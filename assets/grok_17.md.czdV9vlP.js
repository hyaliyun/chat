import{_,o as s,c as r,a as t,m as c,t as d,C as h,M as g,U as b,f as u,F as y,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},L={class:"review-title"},R={class:"review-content"};function A(n,e,l,m,i,a){return s(),r("div",q,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const N=_(k,[["render",A],["__scopeId","data-v-e009dad4"]]),E=JSON.parse(`[{"question":"from typing import List, Tuple from datetime import datetime def detect_brute_force_attacks(logs: List[Tuple[str, str, str]], k: int, m: int) -> List[str]: Identifies IP addresses with \`k\` or more failed login attempts within any \`m\` minute window. Args: logs (List[Tuple[str, str, str]]): List of log entries as tuples (timestamp, IP, status). k (int): Number of failed attempts to consider as a brute force attack. m (int): Window of time in minutes within which the fails should be counted. Returns: List[str]: List of IP addresses. pass # Write your implementation here def test_single_ip_failed_attempts(): logs = [ (\\"2023-01-01 00:01:00\\", \\"192.168.1.1\\", \\"FAIL\\"), (\\"2023-01-01 00:02:00\\", \\"192.168.1.1\\", \\"FAIL\\"), (\\"2023-01-01 00:05:00\\", \\"192.168.1.1\\", \\"FAIL\\"), (\\"2023-01-01 00:01:00\\", \\"192.168.1.2\\", \\"SUCCESS\\"), (\\"2023-01-01 00:01:30\\", \\"192.168.1.2\\", \\"FAIL\\"), (\\"2023-01-01 00:01:55\\", \\"192.168.1.2\\", \\"FAIL\\") ] assert detect_brute_force_attacks(logs, 3, 10) == [\\"192.168.1.1\\"] def test_no_ip_exceeds_failed_attempts(): logs = [ (\\"2023-01-01 00:01:00\\", \\"192.168.1.1\\", \\"FAIL\\"), (\\"2023-01-01 00:02:00\\", \\"192.168.1.2\\", \\"FAIL\\"), (\\"2023-01-01 00:02:01\\", \\"192.168.1.3\\", \\"FAIL\\") ] assert detect_brute_force_attacks(logs, 2, 5) == [] def test_multiple_ips_exceed_failed_attempts(): logs = [ (\\"2023-01-01 00:01:00\\", \\"192.168.1.1\\", \\"FAIL\\"), (\\"2023-01-01 00:02:00\\", \\"192.168.1.1\\", \\"FAIL\\"), (\\"2023-01-01 00:03:00\\", \\"192.168.1.1\\", \\"FAIL\\"), (\\"2023-01-01 00:01:00\\", \\"192.168.1.2\\", \\"FAIL\\"), (\\"2023-01-01 00:02:01\\", \\"192.168.1.2\\", \\"FAIL\\"), (\\"2023-01-01 00:03:02\\", \\"192.168.1.2\\", \\"FAIL\\") ] result = detect_brute_force_attacks(logs, 3, 10) assert \\"192.168.1.1\\" in result assert \\"192.168.1.2\\" in result def test_ignore_success_attempts(): logs = [ (\\"2023-01-01 00:01:00\\", \\"192.168.1.1\\", \\"FAIL\\"), (\\"2023-01-01 00:02:00\\", \\"192.168.1.1\\", \\"FAIL\\"), (\\"2023-01-01 00:03:00\\", \\"192.168.1.1\\", \\"SUCCESS\\"), (\\"2023-01-01 00:03:30\\", \\"192.168.1.1\\", \\"FAIL\\"), (\\"2023-01-01 00:04:30\\", \\"192.168.1.1\\", \\"FAIL\\") ] assert detect_brute_force_attacks(logs, 3, 5) == [\\"192.168.1.1\\"]","solution":"from datetime import datetime, timedelta from collections import defaultdict, deque def detect_brute_force_attacks(logs, k, m): Identifies IP addresses with \`k\` or more failed login attempts within any \`m\` minute window. Args: logs (list): List of log entries as tuples (timestamp, IP, status). k (int): Number of failed attempts to consider as a brute force attack. m (int): Window of time in minutes within which the fails should be counted. Returns: list: List of IP addresses. failed_attempts = defaultdict(deque) result = set() # Convert logs into tuples and sort by timestamp log_entries = [(datetime.strptime(log[0], \\"%Y-%m-%d %H:%M:%S\\"), log[1], log[2]) for log in logs] log_entries.sort() for timestamp, ip, status in log_entries: if status == \\"FAIL\\": attempt_window = failed_attempts[ip] # Add the current attempt to the queue attempt_window.append(timestamp) # Remove attempts older than the m-minute window while attempt_window and (timestamp - attempt_window[0]).total_seconds() > m * 60: attempt_window.popleft() # Check if the number of failed attempts within the window meets or exceeds k if len(attempt_window) >= k: result.add(ip) return list(result)"},{"question":"def is_beautiful_sequence(n: int, sequence: List[int]) -> str: Determines if the sequence is beautiful. A sequence is considered beautiful if the difference between consecutive integers is either 1 or -1. Parameters: n (int): Number of elements in the sequence. sequence (list of int): The sequence of integers. Returns: str: \\"BEAUTIFUL\\" if the sequence is beautiful, otherwise \\"NOT BEAUTIFUL\\". >>> is_beautiful_sequence(5, [1, 2, 3, 2, 1]) \\"BEAUTIFUL\\" >>> is_beautiful_sequence(4, [1, 3, 5, 7]) \\"NOT BEAUTIFUL\\"","solution":"def is_beautiful_sequence(n, sequence): Determines if the sequence is beautiful. A sequence is considered beautiful if the difference between consecutive integers is either 1 or -1. Parameters: n (int): Number of elements in the sequence. sequence (list of int): The sequence of integers. Returns: str: \\"BEAUTIFUL\\" if the sequence is beautiful, otherwise \\"NOT BEAUTIFUL\\". for i in range(1, n): if abs(sequence[i] - sequence[i-1]) != 1: return \\"NOT BEAUTIFUL\\" return \\"BEAUTIFUL\\""},{"question":"def max_passengers(n: int, stations: List[Tuple[int, int]]) -> int: Calculate the maximum number of passengers on the train at any point. Parameters: n (int): Number of stations. stations (list of tuple): List of tuples where each tuple contains two integers, passengers getting on and off the train at each station. Returns: int: The maximum number of passengers on the train at any point. Examples: >>> max_passengers(3, [(10, 0), (3, 5), (2, 8)]) 10 >>> max_passengers(4, [(15, 0), (0, 5), (3, 3), (7, 10)]) 15 from typing import List, Tuple def test_example1(): n = 3 stations = [(10, 0), (3, 5), (2, 8)] assert max_passengers(n, stations) == 10 def test_example2(): n = 4 stations = [(15, 0), (0, 5), (3, 3), (7, 10)] assert max_passengers(n, stations) == 15 def test_all_on_no_off(): n = 3 stations = [(5, 0), (10, 0), (15, 0)] assert max_passengers(n, stations) == 30 def test_all_off_no_on(): n = 2 stations = [(0, 5), (0, 10)] assert max_passengers(n, stations) == 0 def test_alternating_on_off(): n = 5 stations = [(5, 0), (0, 5), (10, 0), (0, 10), (20, 0)] assert max_passengers(n, stations) == 20 def test_large_numbers(): n = 4 stations = [(100, 0), (0, 100), (100, 0), (0, 100)] assert max_passengers(n, stations) == 100","solution":"def max_passengers(n, stations): Calculate the maximum number of passengers on the train at any point. Parameters: n (int): Number of stations. stations (list of tuple): List of tuples where each tuple contains two integers, passengers getting on and off the train at each station. Returns: int: The maximum number of passengers on the train at any point. current_passengers = 0 max_passengers = 0 for on, off in stations: current_passengers += on current_passengers -= off max_passengers = max(max_passengers, current_passengers) return max_passengers"},{"question":"def search_in_circular_array(n: int, x: int, a: List[int]) -> int: Determines if the integer 'x' exists in the sorted circular array 'a'. Returns the index of 'x' if it exists, or -1 if it does not. >>> search_in_circular_array(5, 3, [3, 4, 5, 1, 2]) 0 >>> search_in_circular_array(6, 7, [5, 6, 7, 8, 9, 10]) 2 >>> search_in_circular_array(4, 12, [10, 11, 12, 3]) 2 >>> search_in_circular_array(4, 2, [10, 11, 12, 3]) -1","solution":"def search_in_circular_array(n, x, a): Determines if the integer 'x' exists in the sorted circular array 'a'. Returns the index of 'x' if it exists, or -1 if it does not. for i in range(n): if a[i] == x: return i return -1"},{"question":"def get_highest_priority_log(n: int, logs: List[str]) -> str: Determines the highest priority log level from a list of log messages. Args: n: int - the number of log messages. logs: list of str - the log messages. Returns: str - The highest priority log level encountered. >>> get_highest_priority_log(1, [\\"12:00:00 INFO Initializing database\\"]) 'INFO' >>> get_highest_priority_log(3, [\\"12:00:00 INFO Initializing database\\", \\"12:05:00 WARNING Disk space low\\", \\"12:10:00 ERROR Connection lost\\"]) 'ERROR'","solution":"def get_highest_priority_log(n, logs): Determines the highest priority log level from a list of log messages. Args: n: int - the number of log messages. logs: list of str - the log messages. Returns: str - The highest priority log level encountered. priority_map = {\\"INFO\\": 1, \\"WARNING\\": 2, \\"ERROR\\": 3} highest_priority = \\"\\" earliest_timestamp = \\"24:00:00\\" # Placeholder for the earliest timestamp for log in logs: timestamp, level, message_body = log.split(\\" \\", 2) if (highest_priority == \\"\\" or priority_map[level] > priority_map[highest_priority] or (priority_map[level] == priority_map[highest_priority] and timestamp < earliest_timestamp)): highest_priority = level earliest_timestamp = timestamp return highest_priority"},{"question":"def find_missing_number(sequence: List[int]) -> int: Given a sequence with one missing number in an arithmetic series, finds the missing number. sequence (List[int]): List of n-1 integers where the sequence is missing one number Returns: int: The missing number in the sequence pass def process_input(input_data: str) -> List[int]: Processes the input data as specified and outputs the missing number for each sequence. input_data (str): Multi-line string where each section represents a test case Returns: List[int]: List of missing numbers for each test case in order pass def test_find_missing_number(): assert find_missing_number([2, 4, 8, 10]) == 6 assert find_missing_number([3, 9, 15, 21, 33, 39]) == 27 assert find_missing_number([1, 9, 13]) == 5 def test_process_input(): input_data = \\"5n2 4 8 10n7n3 9 15 21 33 39n4n1 9 13n0n\\" expected_output = [6, 27, 5] assert process_input(input_data) == expected_output input_data = \\"6n-5 -2 1 4 10n5n2 4 6 10n0n\\" expected_output = [7, 8] assert process_input(input_data) == expected_output","solution":"def find_missing_number(sequence): Given a sequence with one missing number in an arithmetic series, finds the missing number. Input: sequence (list of int): List of n-1 integers where the sequence is missing one number Output: int: The missing number in the sequence # Calculate the common difference d = (sequence[-1] - sequence[0]) // len(sequence) # Calculate the expected sums n = len(sequence) + 1 expected_sum = (n * (2 * sequence[0] + (n - 1) * d)) // 2 actual_sum = sum(sequence) return expected_sum - actual_sum def process_input(input_data): Processes the input data as specified and outputs the missing number for each sequence. Input: input_data (str): Multi-line string where each section represents a test case Output: list of int: List of missing numbers for each test case in order lines = input_data.strip().split('n') results = [] i = 0 while i < len(lines): n = int(lines[i]) if n == 0: break sequence = list(map(int, lines[i+1].split())) missing_number = find_missing_number(sequence) results.append(missing_number) i += 2 return results"},{"question":"def min_transmission_time(N: int, delays: List[int]) -> int: Returns the minimum total time required to transmit the data packet from Computer 1 to Computer N, considering the forwarding delays of all computers involved. Args: - N (int): The number of computers. - delays (list of int): A list of delays for each computer. Returns: - int: The minimum total time required for transmission. Examples: >>> min_transmission_time(5, [1, 2, 3, 4, 5]) 15 >>> min_transmission_time(3, [10, 20, 30]) 60","solution":"def min_transmission_time(N, delays): Returns the minimum total time required to transmit the data packet from Computer 1 to Computer N, considering the forwarding delays of all computers involved. Args: - N (int): The number of computers. - delays (list of int): A list of delays for each computer. Returns: - int: The minimum total time required for transmission. return sum(delays)"},{"question":"def largest_rectangle_area(grid: List[str]) -> int: Determine the size of the largest rectangle that can be formed using only one type of letter in a grid. >>> largest_rectangle_area([ ... \\"aab\\", ... \\"abb\\", ... \\"bbb\\" ... ]) 4 >>> largest_rectangle_area([ ... \\"abcde\\", ... \\"fghij\\", ... \\"klmno\\", ... \\"pqrst\\" ... ]) 1 >>> largest_rectangle_area([ ... \\"aa\\", ... \\"aa\\" ... ]) 4 pass from solution import largest_rectangle_area def test_largest_rectangle_area_case1(): grid = [ \\"aab\\", \\"abb\\", \\"bbb\\" ] assert largest_rectangle_area(grid) == 4 def test_largest_rectangle_area_case2(): grid = [ \\"abcde\\", \\"fghij\\", \\"klmno\\", \\"pqrst\\" ] assert largest_rectangle_area(grid) == 1 def test_largest_rectangle_area_case3(): grid = [ \\"aa\\", \\"aa\\" ] assert largest_rectangle_area(grid) == 4 def test_largest_rectangle_area_single_row(): grid = [ \\"aaaaa\\" ] assert largest_rectangle_area(grid) == 5 def test_largest_rectangle_area_single_column(): grid = [ \\"a\\", \\"a\\", \\"a\\", \\"a\\", \\"a\\" ] assert largest_rectangle_area(grid) == 5 def test_largest_rectangle_area_single_letter(): grid = [ \\"xxxx\\", \\"xxxx\\", \\"xxxx\\" ] assert largest_rectangle_area(grid) == 12","solution":"def largest_rectangle_area(grid): n = len(grid) if n == 0: return 0 m = len(grid[0]) if m == 0: return 0 # Transform the grid into height matrix for each letter heights = {chr(i): [0] * m for i in range(ord('a'), ord('z') + 1)} max_area = 0 for i in range(n): for j in range(m): letter = grid[i][j] if i == 0: heights[letter][j] = 1 else: heights[letter][j] = heights[letter][j] + 1 if grid[i][j] == grid[i - 1][j] else 1 for letter, height in heights.items(): max_area = max(max_area, largest_histogram_area(height)) return max_area def largest_histogram_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List def longest_alternating_subsequence(arr: List[int]) -> int: Find the length of the longest subsequence such that the difference between any two consecutive elements is either +1 or -1. >>> longest_alternating_subsequence([1, 2, 3, 4, 3, 2, 1, 2]) 8 >>> longest_alternating_subsequence([1, 2, 1, 2, 1]) 5","solution":"from typing import List def longest_alternating_subsequence(arr: List[int]) -> int: if not arr: return 0 n = len(arr) if n == 1: return 1 # dp[i] will store the length of longest alternating subsequence ending at index i dp = [1] * n for i in range(1, n): for j in range(i): if abs(arr[i] - arr[j]) == 1: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"from typing import List, Tuple from collections import defaultdict def count_divisible_by_k(N: int, edges: List[Tuple[int, int]], K: int) -> int: Count the number of employees whose ID is divisible by K. Parameters: - N: number of employees - edges: list of tuples representing the edges between employees - K: the divisor to check divisibility Returns: - int: the count of employees whose ID is divisible by K. >>> count_divisible_by_k(5, [(1, 2), (1, 3), (2, 4), (2, 5)], 2) 2 >>> count_divisible_by_k(3, [(1, 2), (1, 3)], 4) 0 >>> count_divisible_by_k(4, [(1, 2), (1, 3), (3, 4)], 1) 4","solution":"from collections import defaultdict def count_divisible_by_k(N, edges, K): Count the number of employees whose ID is divisible by K. Parameters: N : int : Number of employees edges : List[Tuple[int, int]] : List of edges denoting the reporting structure K : int : The divisor to check divisibility Returns: int : Count of employees with IDs divisible by K tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) count = 0 for employee_id in range(1, N+1): if employee_id % K == 0: count += 1 return count # Example usage # N = 5 # edges = [(1, 2), (1, 3), (2, 4), (2, 5)] # K = 2 # The employees with IDs divisible by 2 are 2 and 4 # Hence, the expected output is 2"},{"question":"def get_prime_numbers(a: int, b: int) -> List[int]: Returns a list of prime numbers between a and b (inclusive). If there are no primes in the range, return [\\"No primes\\"]. >>> get_prime_numbers(10, 20) [11, 13, 17, 19] >>> get_prime_numbers(22, 25) [23] >>> get_prime_numbers(15, 15) [\\"No primes\\"] >>> get_prime_numbers(1, 10) [2, 3, 5, 7] >>> get_prime_numbers(17, 19) [17, 19] >>> get_prime_numbers(100, 110) [101, 103, 107, 109] >>> get_prime_numbers(8, 10) [\\"No primes\\"]","solution":"def get_prime_numbers(a, b): Returns a list of prime numbers between a and b (inclusive). If there are no primes in the range, return [\\"No primes\\"]. def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True primes = [num for num in range(a, b + 1) if is_prime(num)] if not primes: return [\\"No primes\\"] return primes"},{"question":"from typing import List def largest_square_subgrid(M: int, N: int, grid: List[str]) -> int: Consider a grid of size M x N, where each cell contains either '0' (empty cell) or '1' (occupied cell). The task is to count the largest square sub-grid containing only '1's. Args: M (int): The number of rows in the grid. N (int): The number of columns in the grid. grid (List[str]): The grid in the form of a list of strings. Returns: int: The side length of the largest square sub-grid containing only '1's. >>> largest_square_subgrid(4, 5, [\\"11010\\", \\"11011\\", \\"11111\\", \\"10011\\"]) 2 >>> largest_square_subgrid(3, 3, [\\"000\\", \\"000\\", \\"000\\"]) 0","solution":"def largest_square_subgrid(M, N, grid): # Create a 2D array to store the size of the largest square sub-grid ending at each cell dp = [[0] * (N + 1) for _ in range(M + 1)] max_side = 0 for i in range(1, M + 1): for j in range(1, N + 1): if grid[i-1][j-1] == '1': dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"def is_palindromic(number: int) -> bool: Helper function to check if a number is palindromic. >>> is_palindromic(121) == True >>> is_palindromic(123) == False >>> is_palindromic(1) == True >>> is_palindromic(22) == True >>> is_palindromic(10) == False def count_palindromic_numbers(L: int, R: int) -> int: Returns the count of palindromic numbers in the inclusive range [L, R]. >>> count_palindromic_numbers(10, 20) == 1 >>> count_palindromic_numbers(5, 5) == 1 >>> count_palindromic_numbers(1, 9) == 9 >>> count_palindromic_numbers(100, 200) == 10 >>> count_palindromic_numbers(120, 130) == 1","solution":"def is_palindromic(number): Helper function to check if a number is palindromic. return str(number) == str(number)[::-1] def count_palindromic_numbers(L, R): Returns the count of palindromic numbers in the inclusive range [L, R]. count = 0 for num in range(L, R + 1): if is_palindromic(num): count += 1 return count"},{"question":"def can_store_marbles(n, c, m, shipments): Determines if Jasmine can store all the marbles in her jars without exceeding the capacity of any jar. :param n: Number of jars :param c: Capacity of each jar :param m: Number of shipments :param shipments: List containing the number of marbles in each shipment :return: \\"YES\\" if all marbles can be stored, otherwise \\"NO\\". from solution import can_store_marbles def test_can_store_marbles_yes_case(): assert can_store_marbles(3, 10, 5, [3, 5, 8, 7, 2]) == \\"YES\\" def test_can_store_marbles_no_case(): assert can_store_marbles(2, 8, 4, [6, 9, 2, 3]) == \\"NO\\" def test_can_store_marbles_exact_fit(): assert can_store_marbles(4, 10, 4, [10, 10, 10, 10]) == \\"YES\\" def test_can_store_marbles_just_under_capacity(): assert can_store_marbles(2, 5, 2, [4, 5]) == \\"YES\\" def test_can_store_marbles_just_over_capacity(): assert can_store_marbles(2, 5, 2, [5, 6]) == \\"NO\\"","solution":"def can_store_marbles(n, c, m, shipments): Determines if Jasmine can store all the marbles in her jars without exceeding the capacity of any jar. :param n: Number of jars :param c: Capacity of each jar :param m: Number of shipments :param shipments: List containing the number of marbles in each shipment :return: \\"YES\\" if all marbles can be stored, otherwise \\"NO\\". total_capacity = n * c total_marbles = sum(shipments) if total_marbles <= total_capacity: return \\"YES\\" return \\"NO\\""},{"question":"def spiral_order(matrix: List[List[int]]) -> List[int]: Traverse a matrix in a spiral order and return the elements as a list. >>> spiral_order([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiral_order([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9], ... [10, 11, 12] ... ]) [1, 2, 3, 6, 9, 12, 11, 10, 7, 4, 5, 8]","solution":"def spiral_order(matrix): Returns the elements of the matrix in spiral order. result = [] if len(matrix) == 0: return result top, bottom = 0, len(matrix) - 1 left, right = 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 # Traverse downwards for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: # Traverse upwards for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"def can_form_contiguous_sequence(arr: List[int]) -> str: Determines if the array can be rearranged to form a contiguous sequence. Parameters: arr (list of int): The array of integers. Returns: str: \\"YES\\" if the array can be rearranged to form a contiguous sequence, otherwise \\"NO\\". >>> can_form_contiguous_sequence([3, 4, 2, 1, 5]) 'YES' >>> can_form_contiguous_sequence([7, 5, 8, 6]) 'YES' >>> can_form_contiguous_sequence([1, 3, 2, 5, 4, 7]) 'NO' >>> can_form_contiguous_sequence([10, 11, 12, 13, 14]) 'YES' >>> can_form_contiguous_sequence([1, 2, 4, 5, 6]) 'NO' >>> can_form_contiguous_sequence([1000000000, 999999999, 999999998]) 'YES' >>> can_form_contiguous_sequence([1]) 'YES' >>> can_form_contiguous_sequence([1, 2, 3, 5]) 'NO' >>> can_form_contiguous_sequence([5, 6, 7, 8, 9, 10]) 'YES' >>> can_form_contiguous_sequence([4, 3, 2, 1]) 'YES' # Write the code here","solution":"def can_form_contiguous_sequence(arr): Determines if the array can be rearranged to form a contiguous sequence. Parameters: arr (list of int): The array of integers. Returns: str: \\"YES\\" if the array can be rearranged to form a contiguous sequence, otherwise \\"NO\\". min_value = min(arr) max_value = max(arr) expected_length = max_value - min_value + 1 if len(arr) == expected_length: return \\"YES\\" else: return \\"NO\\""},{"question":"def is_palindrome(n: str) -> bool: Check if the given string representation of a number is a palindrome. Args: n (str): The string representation of the number. Returns: bool: True if the number is a palindrome, False otherwise. def check_palindromes(numbers: List[str]) -> List[str]: Given a list of numbers in string format, check if each one is a palindrome. Args: numbers (List[str]): List of numbers in string format. Returns: List[str]: List of \\"YES\\" or \\"NO\\" based on whether each number is a palindrome. >>> check_palindromes([\\"123\\", \\"121\\", \\"1001\\"]) ['NO', 'YES', 'YES'] >>> check_palindromes([\\"1\\", \\"22\\", \\"303\\", \\"4040\\"]) ['YES', 'YES', 'YES', 'NO'] import pytest def test_basic_cases(): assert check_palindromes([\\"123\\", \\"121\\", \\"1001\\"]) == [\\"NO\\", \\"YES\\", \\"YES\\"] def test_single_digit_numbers(): assert check_palindromes([\\"1\\", \\"2\\", \\"3\\", \\"4\\", \\"5\\", \\"6\\", \\"7\\", \\"8\\", \\"9\\"]) == [\\"YES\\"] * 9 def test_larger_numbers(): assert check_palindromes([\\"1234321\\", \\"12344321\\", \\"1234554321\\", \\"98765432123456789\\"]) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] def test_non_palindromic_numbers(): assert check_palindromes([\\"12345\\", \\"67890\\", \\"123456789\\", \\"9876543210\\"]) == [\\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\"] def test_edge_cases(): assert check_palindromes([\\"1\\" * 100, \\"0\\" * 99 + \\"1\\", \\"1234567890987654321\\", \\"123456789987654321\\"]) == [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] def test_mixed_cases(): assert check_palindromes([\\"1\\", \\"22\\", \\"303\\", \\"4040\\"]) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def is_palindrome(n): Check if the given string representation of a number is a palindrome. return n == n[::-1] def check_palindromes(numbers): Given a list of numbers in string format, check if each one is a palindrome. results = [] for number in numbers: if is_palindrome(number): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def can_be_rearranged_to_special_string(s: str) -> bool: Checks if the binary string s can be rearranged into a valid special string. A valid special string must contain an equal number of '0's and '1's. >>> can_be_rearranged_to_special_string(\\"1100\\") True >>> can_be_rearranged_to_special_string(\\"1010\\") True >>> can_be_rearranged_to_special_string(\\"1110\\") False >>> can_be_rearranged_to_special_string(\\"00\\") False >>> can_be_rearranged_to_special_string(\\"11\\") False def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Processes test cases and returns the results for each case. >>> process_test_cases(3, [\\"1100\\", \\"1010\\", \\"1110\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_test_cases(2, [\\"00\\", \\"11\\"]) [\\"NO\\", \\"NO\\"] >>> process_test_cases(1, [\\"101010\\"]) [\\"YES\\"]","solution":"def can_be_rearranged_to_special_string(s): Checks if the binary string s can be rearranged into a valid special string. A valid special string must contain an equal number of '0's and '1's. return s.count('0') == s.count('1') def process_test_cases(t, test_cases): Processes test cases and returns the results for each case. results = [] for s in test_cases: if can_be_rearranged_to_special_string(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def compress_workout_sequences(T: int, sequences: List[str]) -> List[str]: Compress consecutive duplicate workouts in each workout sequence. >>> compress_workout_sequences(3, [\\"pushup pushup situp situp situp squat squat\\", \\"jump jump jump situp pushup\\", \\"run run pushup pushup pushup run run run\\"]) [\\"pushup2 situp3 squat2\\", \\"jump3 situp1 pushup1\\", \\"run2 pushup3 run3\\"] >>> compress_workout_sequences(1, [\\"pushup pushup pushup\\"]) [\\"pushup3\\"]","solution":"def compress_workout_sequences(T, sequences): results = [] for sequence in sequences: workouts = sequence.split() compressed = [] current_workout = workouts[0] count = 1 for i in range(1, len(workouts)): if workouts[i] == current_workout: count += 1 else: compressed.append(f\\"{current_workout}{count}\\") current_workout = workouts[i] count = 1 compressed.append(f\\"{current_workout}{count}\\") results.append(\\" \\".join(compressed)) return results"},{"question":"from collections import Counter from typing import List, Tuple def findLHS(nums: List[int]) -> int: Finds the length of the longest harmonious subarray in nums. >>> findLHS([1, 3, 2, 2, 5, 2, 3, 7]) 5 >>> findLHS([1, 2, 3, 4, 3, 2]) 4 num_count = Counter(nums) max_length = 0 for num in num_count: if num + 1 in num_count: max_length = max(max_length, num_count[num] + num_count[num + 1]) return max_length def solve(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Solves the problem of finding the longest harmonious subarray for each test case. >>> solve(2, [(8, [1, 3, 2, 2, 5, 2, 3, 7]), (6, [1, 2, 3, 4, 3, 2])]) [5, 4] results = [] for i in range(t): n = test_cases[i][0] arr = test_cases[i][1] results.append(findLHS(arr)) return results","solution":"from collections import Counter def findLHS(nums): Finds the length of the longest harmonious subarray in nums. num_count = Counter(nums) max_length = 0 for num in num_count: if num + 1 in num_count: max_length = max(max_length, num_count[num] + num_count[num + 1]) return max_length def solve(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] arr = test_cases[i][1] results.append(findLHS(arr)) return results"},{"question":"def count_paths_of_length_k(n: int, m: int, k: int, edges: List[Tuple[int, int]], u: int, v: int) -> int: Given an undirected graph, determine the number of unique paths of length exactly k between two distinct nodes u and v. Args: n : int : the number of vertices m : int : the number of edges k : int : the required path length edges : List[Tuple[int, int]] : list of edges, each a tuple of two integers indicating a connection between vertices a and b u : int : start vertex v : int : end vertex Returns: int : number of unique paths of length exactly k between vertices u and v Examples: >>> count_paths_of_length_k(5, 5, 3, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 3)], 1, 4) 1 >>> count_paths_of_length_k(4, 4, 2, [(1, 2), (2, 3), (3, 4), (4, 1)], 1, 3) 2","solution":"def count_paths_of_length_k(n, m, k, edges, u, v): from collections import defaultdict, deque # Build the graph graph = defaultdict(list) for a, b in edges: graph[a].append(b) graph[b].append(a) # BFS to find all paths of length k queue = deque([(u, 0)]) # (current_node, current_length) paths_count = 0 while queue: current_node, current_length = queue.popleft() if current_length == k: if current_node == v: paths_count += 1 continue for neighbor in graph[current_node]: if current_length < k: queue.append((neighbor, current_length + 1)) return paths_count # Example usage: # n = 5, m = 5, k = 3 # edges = [(1, 2), (2, 3), (3, 4), (4, 5), (1, 3)] # u, v = 1, 4 # Expected output: 1"},{"question":"def max_flowers(n: int, m: int) -> int: Function to calculate the maximum number of flowers that can be planted in a garden with given constraints. Args: n: number of rows m: number of columns Returns: Maximum number of flowers that can be planted >>> max_flowers(3, 3) 5 >>> max_flowers(4, 4) 8 from solution import max_flowers def test_max_flowers_3x3(): assert max_flowers(3, 3) == 5 def test_max_flowers_4x4(): assert max_flowers(4, 4) == 8 def test_max_flowers_1x1(): assert max_flowers(1, 1) == 1 def test_max_flowers_2x2(): assert max_flowers(2, 2) == 2 def test_max_flowers_5x5(): assert max_flowers(5, 5) == 13 def test_max_flowers_rectangular_3x5(): assert max_flowers(3, 5) == 8 def test_max_flowers_rectangular_7x3(): assert max_flowers(7, 3) == 11","solution":"def max_flowers(n, m): Function to calculate the maximum number of flowers that can be planted in a garden with given constraints. Args: n: number of rows m: number of columns Returns: Maximum number of flowers that can be planted return (n * m + 1) // 2"},{"question":"def make_palindrome(s: str) -> str: Returns the lexicographically smallest palindrome that can be obtained from the input string s with the fewest insertions. >>> make_palindrome(\\"abba\\") 'abba' >>> make_palindrome(\\"abc\\") 'abcba' >>> make_palindrome(\\"racec\\") 'racecar' >>> make_palindrome(\\"a\\") 'a' >>> make_palindrome(\\"ab\\") 'aba' >>> make_palindrome(\\"aaa\\") 'aaa' >>> make_palindrome(\\"acdbbca\\") 'acdbbdca'","solution":"def make_palindrome(s): Returns the lexicographically smallest palindrome that can be obtained from the input string s with the fewest insertions. n = len(s) dp = [[0]*n for _ in range(n)] for length in range(2, n+1): for i in range(n-length+1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] else: dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1 def build_palindrome(i, j): if i > j: return \\"\\" if i == j: return s[i] if s[i] == s[j]: return s[i] + build_palindrome(i+1, j-1) + s[j] if dp[i+1][j] < dp[i][j-1]: return s[i] + build_palindrome(i+1, j) + s[i] if dp[i+1][j] > dp[i][j-1]: return s[j] + build_palindrome(i, j-1) + s[j] # When the values are equal, choose lexicographically smaller option opt1 = s[i] + build_palindrome(i+1, j) + s[i] opt2 = s[j] + build_palindrome(i, j-1) + s[j] return min(opt1, opt2) return build_palindrome(0, n-1)"},{"question":"def min_subsets(ages: List[int]) -> int: This function calculates the minimum number of subsets needed to split the group such that each subset contains unique ages. Args: ages (list): A list of integers where each element represents the age of a person. Returns: int: The minimum number of subsets needed. >>> min_subsets([10, 20, 20, 30, 30, 30]) == 3 >>> min_subsets([45, 45, 45, 45]) == 4 >>> min_subsets([25]) == 1 >>> min_subsets([5, 10, 15]) == 1 >>> min_subsets([30, 30, 30, 20, 20, 10]) == 3 >>> min_subsets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 1 >>> min_subsets([i for i in range(1, 101)]) == 1 >>> min_subsets([10, 10, 20, 30, 30, 20, 30]) == 3 pass","solution":"def min_subsets(ages): This function calculates the minimum number of subsets needed to split the group such that each subset contains unique ages. Args: ages (list): A list of integers where each element represents the age of a person. Returns: int: The minimum number of subsets needed. from collections import Counter age_counts = Counter(ages) return max(age_counts.values())"},{"question":"from typing import List, Tuple def find_number_of_connected_components(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the number of connected components in an undirected graph. Parameters: n (int): The number of vertices. m (int): The number of edges. edges (List[Tuple[int, int]]): A list of edges represented as tuples. Returns: int: The number of connected components in the graph. Examples: >>> find_number_of_connected_components(6, 5, [(1, 2), (2, 3), (4, 5), (5, 6), (6, 4)]) 2 >>> find_number_of_connected_components(4, 3, [(1, 2), (2, 3), (3, 4)]) 1 >>> find_number_of_connected_components(1, 0, []) 1","solution":"def find_number_of_connected_components(n, m, edges): def dfs(node): stack = [node] while stack: current = stack.pop() if visited[current]: continue visited[current] = True for neighbor in adjacency_list[current]: if not visited[neighbor]: stack.append(neighbor) # Initialize the adjacency list adjacency_list = [[] for _ in range(n + 1)] for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) # To keep track of visited nodes visited = [False] * (n + 1) connected_components_count = 0 for i in range(1, n + 1): if not visited[i]: connected_components_count += 1 dfs(i) return connected_components_count"},{"question":"from collections import deque from typing import List def shortest_path(grid: List[List[int]]) -> int: Find the shortest path from the top-left to the bottom-right corner of the grid. Each cell contains either 0 (free) or 1 (blocked). The function returns the length of the shortest path or -1 if no such path exists. >>> shortest_path([ ... [0, 0, 1], ... [0, 1, 0], ... [0, 0, 0] ... ]) 4 >>> shortest_path([ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) 4 >>> shortest_path([ ... [0, 1, 1], ... [1, 0, 0], ... [1, 1, 0] ... ]) -1","solution":"from collections import deque def shortest_path(grid): n = len(grid) m = len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == 0 queue = deque([(0, 0, 0)]) # (row, column, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"import math def smallest_enclosed_area(n: int) -> int: Returns the smallest possible enclosed area that can contain all n blocks. >>> smallest_enclosed_area(4) == 4 True >>> smallest_enclosed_area(5) == 6 True >>> smallest_enclosed_area(9) == 9 True","solution":"import math def smallest_enclosed_area(n): Returns the smallest possible enclosed area that can contain all n blocks. # To minimize the area, the shape should be as square-like as possible side_length = math.ceil(math.sqrt(n)) other_side_length = math.ceil(n / side_length) return side_length * other_side_length"},{"question":"from typing import List, Tuple def process_appointments(m: int, n: int, grid: List[str], p: int, pets: List[Tuple[str, int, int, int]]) -> None: Prints the updated grid with appointments marked by pet ids. If an appointment can't be processed due to conflicts or invalid slots, it indicates the booking failure for that specific pet. Parameters: m (int): number of rows in the grid. n (int): number of columns in the grid. grid (List[str]): a representation of the species-booking grid, where each character represents a species or available slot ('.'). p (int): number of pets requesting appointments. pets (List[Tuple[str, int, int, int]]): a list containing tuples with pet species, identification number, and the requested row and column for the appointment. # Function implementation goes here def test_basic_functionality(): assert process_appointments(3, 5, [\\"A....\\", \\"AA..B\\", \\"....B\\"], 3, [('A', 101, 1, 0), ('B', 202, 1, 4), ('A', 303, 0, 1)]) == None def test_booking_conflict(): assert process_appointments(2, 3, [\\".C.\\", \\".C.\\"], 2, [('C', 101, 0, 1), ('C', 202, 1, 1)]) == None def test_out_of_bound_requests(): assert process_appointments(1, 3, [\\".A.\\"], 3, [('A', 101, 0, 1), ('B', 202, 0, 2), ('A', 303, 0, 1)]) == None","solution":"def update_appointment_grid(m, n, grid, pets): Updates the given species-booking grid with appointment slots marked by pet ids. for species, pet_id, row, col in pets: if grid[row][col] == species: grid[row][col] = str(pet_id) else: print(f'Booking failed for pet id: {pet_id}') for row in grid: print(''.join(row)) def process_appointments(m, n, grid, p, pets): # First, convert each row of the grid into a list to allow mutable operations grid = [list(row) for row in grid] # Update the appointment grid update_appointment_grid(m, n, grid, pets)"},{"question":"def calculate_averages(data): Calculate and display the average score for each subject. Input: data: A list of datasets, where each dataset is a list of strings representing scores. Output: Returns a list of lists, where each sublist contains the average scores for each subject rounded to two decimal points. Example: >>> data = [ >>> [ >>> \\"3\\", >>> \\"80 90 100\\", >>> \\"70 85 95\\", >>> \\"65 80 90\\" >>> ], >>> \\"END\\" >>> ] >>> calculate_averages(data) [[71.67, 85.00, 95.00]] def test_single_dataset(): data = [ [ \\"3\\", \\"80 90 100\\", \\"70 85 95\\", \\"65 80 90\\" ] ] result = calculate_averages(data) assert result == [[71.67, 85.00, 95.00]] def test_multiple_datasets(): data = [ [ \\"3\\", \\"80 90 100\\", \\"70 85 95\\", \\"65 80 90\\" ], [ \\"2\\", \\"88 92\\", \\"76 84\\", \\"95 97\\" ] ] result = calculate_averages(data) assert result == [[71.67, 85.00, 95.00], [86.33, 91.00]] def test_example(): data = [ [ \\"3\\", \\"80 90 100\\", \\"70 85 95\\", \\"65 80 90\\" ], [ \\"2\\", \\"88 92\\", \\"76 84\\", \\"95 97\\" ], \\"END\\" ] result = calculate_averages(data) assert result == [[71.67, 85.00, 95.00], [86.33, 91.00]] def test_single_subject(): data = [ [ \\"1\\", \\"80\\", \\"90\\", \\"70\\" ] ] result = calculate_averages(data) assert result == [[80.0]] def test_single_student(): data = [ [ \\"2\\", \\"80 70\\" ] ] result = calculate_averages(data) assert result == [[80.0, 70.0]]","solution":"def calculate_averages(data): results = [] for dataset in data: if dataset == \\"END\\": break m = int(dataset[0]) scores = [list(map(int, line.split())) for line in dataset[1:]] total_students = len(scores) averages = [] for subject_index in range(m): subject_total = sum(scores[student_index][subject_index] for student_index in range(total_students)) subject_average = round(subject_total / total_students, 2) averages.append(subject_average) results.append(averages) return results"},{"question":"from typing import List, Tuple def group_anagrams(n: int, strings: List[str]) -> List[List[str]]: Group the anagrams together and return the result as a list of lists. Parameters: n (int): Number of strings strings (List[str]): List of strings Returns: List[List[str]]: A list of lists, where each sublist contains strings that are anagrams of each other. Examples: >>> group_anagrams(6, [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['ate', 'eat', 'tea'], ['bat'], ['nat', 'tan']] >>> group_anagrams(5, [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gogole\\"]) [['enlist', 'listen', 'silent'], ['gogole', 'google']] Unit Tests: def test_group_anagrams_example1(): result = group_anagrams(6, [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) expected = [['ate', 'eat', 'tea'], ['bat'], ['nat', 'tan']] assert result == sorted(expected) def test_group_anagrams_example2(): result = group_anagrams(5, [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gogole\\"]) expected = [['enlist', 'listen', 'silent'], ['gogole', 'google']] assert result == sorted(expected) def test_group_anagrams_empty(): result = group_anagrams(0, []) assert result == [] def test_group_anagrams_single(): result = group_anagrams(1, [\\"abc\\"]) expected = [['abc']] assert result == expected def test_group_anagrams_no_anagrams(): result = group_anagrams(3, [\\"abc\\", \\"def\\", \\"ghi\\"]) expected = [['abc'], ['def'], ['ghi']] assert result == sorted(expected) def test_group_anagrams_all_same(): result = group_anagrams(3, [\\"abc\\", \\"bca\\", \\"cab\\"]) expected = [['abc', 'bca', 'cab']] assert result == expected","solution":"from collections import defaultdict def group_anagrams(n, strings): Groups anagrams together from the input list of strings. Parameters: n (int): Number of strings strings (list): List of strings Returns: list: A list of lists containing grouped anagrams anagrams = defaultdict(list) for string in strings: sorted_str = ''.join(sorted(string)) anagrams[sorted_str].append(string) result = [sorted(group) for group in anagrams.values()] result.sort() return result"},{"question":"def min_rectangles_covering_grass(lawn): Determine the minimum number of rectangles required to cover all the grass-filled squares. :param lawn: List of strings representing the lawn where '1' is grass and '0' is empty. :return: Integer representing the minimum number of rectangles required to cover the grass. >>> min_rectangles_covering_grass([\\"011\\", \\"111\\"]) 1 >>> min_rectangles_covering_grass([\\"111\\"]) 1 >>> min_rectangles_covering_grass([\\"1\\", \\"1\\", \\"1\\"]) 1 >>> min_rectangles_covering_grass([\\"101\\", \\"010\\", \\"101\\"]) 5 >>> min_rectangles_covering_grass([\\"110\\", \\"011\\", \\"000\\", \\"111\\"]) 2 >>> min_rectangles_covering_grass([\\"0\\", \\"0\\", \\"0\\"]) 0 >>> min_rectangles_covering_grass( [\\"1111\\", \\"1111\\", \\"1111\\"] ) 1 >>> min_rectangles_covering_grass( [\\"101010\\", \\"010101\\", \\"101010\\", \\"010101\\"] ) 12","solution":"def min_rectangles_covering_grass(lawn): Determine the minimum number of rectangles required to cover all the grass-filled squares. :param lawn: List of strings representing the lawn where '1' is grass and '0' is empty. :return: Integer representing the minimum number of rectangles required to cover the grass. n = len(lawn) m = len(lawn[0]) visited = [[False] * m for _ in range(n)] def dfs(x, y): # Perform a DFS to mark all connected '1's stack = [(x, y)] while stack: cx, cy = stack.pop() if not (0 <= cx < n and 0 <= cy < m) or visited[cx][cy] or lawn[cx][cy] == '0': continue visited[cx][cy] = True for nx, ny in [(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)]: stack.append((nx, ny)) rectangles = 0 for i in range(n): for j in range(m): if lawn[i][j] == '1' and not visited[i][j]: dfs(i, j) rectangles += 1 return rectangles"},{"question":"def longest_odd_sum_subsequence_length(n: int, a: List[int]) -> int: Find the length of the longest subsequence where the sum of any two consecutive elements is odd. >>> longest_odd_sum_subsequence_length(5, [1, 2, 3, 4, 5]) 5 >>> longest_odd_sum_subsequence_length(6, [2, 4, 6, 8, 10, 12]) 1 import unittest class TestLongestOddSumSubsequenceLength(unittest.TestCase): def test_cases(self): self.assertEqual(longest_odd_sum_subsequence_length(5, [1, 2, 3, 4, 5]), 5) self.assertEqual(longest_odd_sum_subsequence_length(6, [2, 4, 6, 8, 10, 12]), 1) self.assertEqual(longest_odd_sum_subsequence_length(1, [1]), 1) self.assertEqual(longest_odd_sum_subsequence_length(1, [2]), 1) self.assertEqual(longest_odd_sum_subsequence_length(3, [2, 1, 4]), 3) self.assertEqual(longest_odd_sum_subsequence_length(4, [2, 1, 4, 3]), 3) self.assertEqual(longest_odd_sum_subsequence_length(5, [2, 10, 12, 8, 6]), 1) self.assertEqual(longest_odd_sum_subsequence_length(5, [1, 3, 5, 7, 9]), 1) if __name__ == \\"__main__\\": unittest.main()","solution":"def longest_odd_sum_subsequence_length(n, a): # Count the number of odd and even numbers in the sequence odd_count = sum(1 for x in a if x % 2 != 0) even_count = n - odd_count # The length of the longest subsequence with alternating odd and even sum can be: # - If there are both odd and even numbers: min(odd_count, even_count) * 2 + 1 # - If there are only odd or only even numbers: 1 if odd_count > 0 and even_count > 0: return min(odd_count, even_count) * 2 + 1 else: return 1 # Example usage: # longest_odd_sum_subsequence_length(5, [1, 2, 3, 4, 5]) returns 5 # longest_odd_sum_subsequence_length(6, [2, 4, 6, 8, 10, 12]) returns 1"},{"question":"def calculate_final_balance(transactions: List[int]) -> int: Calculates the final balance after processing a list of transactions. Args: transactions: List of integers representing the transactions. Returns: Integer representing the final balance. >>> calculate_final_balance([]) 0 >>> calculate_final_balance([100]) 100 >>> calculate_final_balance([-50]) -50 >>> calculate_final_balance([100, -50, 10, -20, 30]) 70 >>> calculate_final_balance([10, 20, 30, 40]) 100 >>> calculate_final_balance([-10, -20, -30, -40]) -100 >>> transactions = [1] * 100000 >>> calculate_final_balance(transactions) 100000 >>> transactions = [-1] * 100000 >>> calculate_final_balance(transactions) -100000","solution":"def calculate_final_balance(transactions): Calculates the final balance after processing a list of transactions. Args: transactions: List of integers representing the transactions. Returns: Integer representing the final balance. return sum(transactions)"},{"question":"def longest_arithmetic_progression(arr: List[int]) -> int: Determine the length of the longest arithmetic progression that can be formed from the numbers in the list. Args: arr: List[int] - A list of integers. Returns: int - Length of the longest arithmetic progression. Examples: >>> longest_arithmetic_progression([1, 7, 10, 13, 14, 16]) 4 >>> longest_arithmetic_progression([10, 20, 30, 40, 50]) 5 >>> longest_arithmetic_progression([3, 6, 9, 12]) 4 >>> longest_arithmetic_progression([100]) 1 >>> longest_arithmetic_progression([10, 20]) 2 >>> longest_arithmetic_progression([1, 3, 7, 120]) 2 >>> longest_arithmetic_progression([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 10","solution":"def longest_arithmetic_progression(arr): This function finds the length of the longest arithmetic progression in a given list of integers. if not arr: return 0 n = len(arr) if n == 1: return 1 arr.sort() # Create a table to store lengths of longest APs. # table[i][j] will store length of the longest AP that ends with arr[i] and arr[j]. table = [[2 for _ in range(n)] for __ in range(n)] # Initialize result max_len = 2 # Consider every element as the second element of the AP for j in range(n-1, 0, -1): i = j - 1 k = j + 1 while (i >= 0 and k <= n-1): if arr[i] + arr[k] < 2 * arr[j]: k += 1 elif arr[i] + arr[k] > 2 * arr[j]: table[i][j] = 2 i -= 1 else: table[i][j] = table[j][k] + 1 max_len = max(max_len, table[i][j]) i -= 1 k += 1 while (i >= 0): table[i][j] = 2 i -= 1 return max_len"},{"question":"def longest_substring_with_replacements(s: str, k: int) -> int: Returns the length of the longest substring containing the same letter after performing at most k character replacements. >>> longest_substring_with_replacements(\\"ABAB\\", 2) 4 >>> longest_substring_with_replacements(\\"AABABBA\\", 1) 4 >>> longest_substring_with_replacements(\\"ABCDE\\", 2) 3 pass # Unittest def test_example_1(): assert longest_substring_with_replacements(\\"ABAB\\", 2) == 4 def test_example_2(): assert longest_substring_with_replacements(\\"AABABBA\\", 1) == 4 def test_example_3(): assert longest_substring_with_replacements(\\"ABCDE\\", 2) == 3 def test_single_character(): assert longest_substring_with_replacements(\\"A\\", 1) == 1 def test_all_same_characters(): assert longest_substring_with_replacements(\\"AAAA\\", 2) == 4 def test_no_replacements_needed(): assert longest_substring_with_replacements(\\"AAABBB\\", 3) == 6 def test_no_replacements_possible(): assert longest_substring_with_replacements(\\"ABCDE\\", 0) == 1","solution":"def longest_substring_with_replacements(s, k): Returns the length of the longest substring containing the same letter after performing at most k character replacements. max_length = 0 max_count = 0 counts = {} left = 0 for right in range(len(s)): counts[s[right]] = counts.get(s[right], 0) + 1 max_count = max(max_count, counts[s[right]]) if right - left + 1 - max_count > k: counts[s[left]] -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List, Tuple def max_profit(prices: List[int]) -> int: Find the maximum profit that can be obtained by buying and then selling one product. :param prices: List of integers representing the prices of products. :return: Maximum possible profit, or 0 if no profit is possible. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases and return the results. :param test_cases: List of tuples, each containing integer N and list of N prices. :return: List of integers, each representing the max profit for the corresponding test case. >>> process_test_cases([(6, [7, 1, 5, 3, 6, 4]), (5, [7, 6, 4, 3, 1]), (5, [1, 2, 3, 4, 5]), (5, [5, 4, 3, 2, 1])]) [5, 0, 4, 0] pass","solution":"def max_profit(prices): Find the maximum profit that can be obtained by buying and then selling one product. :param prices: List of integers representing the prices of products. :return: Maximum possible profit, or 0 if no profit is possible. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit def process_test_cases(test_cases): Process multiple test cases and return the results. :param test_cases: List of tuples, each containing integer N and list of N prices. :return: List of integers, each representing the max profit for the corresponding test case. results = [] for N, prices in test_cases: results.append(max_profit(prices)) return results"},{"question":"def max_submatrix_sum(matrix: List[List[int]]) -> int: Given a matrix of integers, find the submatrix with the maximum sum. >>> max_submatrix_sum([ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ]) 29 >>> max_submatrix_sum([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) -1 >>> max_submatrix_sum([[5]]) 5 >>> max_submatrix_sum([[-7]]) -7 >>> max_submatrix_sum([ ... [1, 2], ... [3, 4] ... ]) 10 >>> max_submatrix_sum([ ... [-1, -2], ... [-3, -4] ... ]) -1 pass","solution":"def max_submatrix_sum(matrix): Returns the maximum sum of any submatrix of the given matrix. n = len(matrix) m = len(matrix[0]) max_sum = float('-inf') for left in range(m): row_sum = [0] * n for right in range(left, m): for i in range(n): row_sum[i] += matrix[i][right] current_sum = kadane(row_sum) if current_sum > max_sum: max_sum = current_sum return max_sum def kadane(arr): max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns a list where each element at index i is the product of all the elements in the input list except nums[i]. pass def solve(test_cases: List[List[int]]) -> List[List[int]]: Processes multiple test cases and returns the results for each. pass def parse_input(input_data: str) -> List[List[int]]: Parses the input data and returns a list of test cases. pass def format_output(results: List[List[int]]) -> str: Formats the output results into a string. pass import pytest def test_case_1(): input_data = \\"2n3n1 2 3n4n2 3 4 5\\" expected_output = \\"6 3 2n60 40 30 24\\" test_cases = parse_input(input_data) results = solve(test_cases) output = format_output(results) assert output == expected_output def test_case_2(): input_data = \\"1n5n1 2 3 4 5\\" expected_output = \\"120 60 40 30 24\\" test_cases = parse_input(input_data) results = solve(test_cases) output = format_output(results) assert output == expected_output def test_case_3(): input_data = \\"1n2n9 1\\" expected_output = \\"1 9\\" test_cases = parse_input(input_data) results = solve(test_cases) output = format_output(results) assert output == expected_output def test_case_single_value(): input_data = \\"1n2n1 1\\" expected_output = \\"1 1\\" test_cases = parse_input(input_data) results = solve(test_cases) output = format_output(results) assert output == expected_output def test_case_large_values(): input_data = \\"1n3n1000 1000 1000\\" expected_output = \\"1000000 1000000 1000000\\" test_cases = parse_input(input_data) results = solve(test_cases) output = format_output(results) assert output == expected_output","solution":"def product_except_self(nums): Returns a list where each element at index i is the product of all the elements in the input list except nums[i]. n = len(nums) result = [1] * n # Calculate prefix multiplication prefix = 1 for i in range(n): result[i] = prefix prefix *= nums[i] # Calculate suffix multiplication and multiply with prefix results suffix = 1 for i in range(n - 1, -1, -1): result[i] *= suffix suffix *= nums[i] return result def solve(test_cases): results = [] for nums in test_cases: results.append(product_except_self(nums)) return results def parse_input(input_data): data = input_data.strip().split() idx = 0 t = int(data[idx]) idx += 1 test_cases = [] for _ in range(t): n = int(data[idx]) idx += 1 nums = list(map(int, data[idx:idx + n])) idx += n test_cases.append(nums) return test_cases def format_output(results): return \\"n\\".join(\\" \\".join(map(str, result)) for result in results)"},{"question":"def is_valid_parentheses(s: str) -> str: Determines if the input string of parentheses is valid. >>> is_valid_parentheses(\\"()\\") == \\"YES\\" >>> is_valid_parentheses(\\"()[]{}\\") == \\"YES\\" >>> is_valid_parentheses(\\"(]\\") == \\"NO\\" >>> is_valid_parentheses(\\"([)]\\") == \\"NO\\"","solution":"def is_valid_parentheses(s): Determines if the input string of parentheses is valid. stack = [] mapping = {')': '(', '}': '{', ']': '['} for char in s: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return \\"NO\\" else: stack.append(char) return \\"YES\\" if not stack else \\"NO\\" # Example usage # print(is_valid_parentheses(\\"()\\")) # YES # print(is_valid_parentheses(\\"()[]\\")) # YES # print(is_valid_parentheses(\\"(]\\")) # NO # print(is_valid_parentheses(\\"([)]\\")) # NO"},{"question":"def grade_students(n: int, student_scores: List[Tuple[int, int]]) -> Tuple[List[str], str, str]: Grades students based on their scores and finds the highest score with the smallest ID of top scorer. Parameters: n (int): Number of students. student_scores (list of tuples): Each tuple contains a student ID and their score. Returns: list of str: Grades of students along with their IDs. str: The highest score. str: The top student ID with the highest score and smallest ID if tie. >>> n = 5 >>> student_scores = [(101, 86), (102, 92), (103, 77), (104, 90), (105, 62)] >>> grades, highest_score_str, top_student_id_str = grade_students(n, student_scores) >>> grades [\\"101 B\\", \\"102 A\\", \\"103 C\\", \\"104 A\\", \\"105 D\\"] >>> highest_score_str \\"Highest score: 92\\" >>> top_student_id_str \\"Top student ID: 102\\" >>> n = 3 >>> student_scores = [(1, 100), (2, 100), (3, 100)] >>> grades, highest_score_str, top_student_id_str = grade_students(n, student_scores) >>> grades [\\"1 A\\", \\"2 A\\", \\"3 A\\"] >>> highest_score_str \\"Highest score: 100\\" >>> top_student_id_str \\"Top student ID: 1\\" >>> n = 4 >>> student_scores = [(201, 55), (202, 65), (203, 75), (204, 85)] >>> grades, highest_score_str, top_student_id_str = grade_students(n, student_scores) >>> grades [\\"201 F\\", \\"202 D\\", \\"203 C\\", \\"204 B\\"] >>> highest_score_str \\"Highest score: 85\\" >>> top_student_id_str \\"Top student ID: 204\\" >>> n = 1 >>> student_scores = [(501, 78)] >>> grades, highest_score_str, top_student_id_str = grade_students(n, student_scores) >>> grades [\\"501 C\\"] >>> highest_score_str \\"Highest score: 78\\" >>> top_student_id_str \\"Top student ID: 501\\"","solution":"def grade_students(n, student_scores): Grades students based on their scores and finds the highest score with the smallest ID of top scorer. Parameters: n (int): Number of students. student_scores (list of tuples): Each tuple contains a student ID and their score. Returns: list of str: Grades of students along with their IDs. str: The highest score. str: The top student ID with the highest score and smallest ID if tie. def get_grade(score): if 90 <= score <= 100: return 'A' elif 80 <= score <= 89: return 'B' elif 70 <= score <= 79: return 'C' elif 60 <= score <= 69: return 'D' else: return 'F' grades = [] highest_score = -1 top_student_id = 1001 # since 1 <= ID <= 1000 for student_id, score in student_scores: grade = get_grade(score) grades.append(f\\"{student_id} {grade}\\") if score > highest_score or (score == highest_score and student_id < top_student_id): highest_score = score top_student_id = student_id highest_score_str = f\\"Highest score: {highest_score}\\" top_student_id_str = f\\"Top student ID: {top_student_id}\\" return grades, highest_score_str, top_student_id_str"},{"question":"def max_cities_within_budget(b: int, m: int, costs: List[int]) -> int: Returns the maximum number of cities that can be visited within the budget. Parameters: b (int): The budget for the trip. m (int): The number of cities. costs (list of int): The costs associated with visiting each city. Returns: int: The maximum number of cities that can be visited within the budget. >>> max_cities_within_budget(50, 5, [20, 10, 30, 40, 50]) 2 >>> max_cities_within_budget(100, 4, [10, 20, 30, 40]) 4 >>> max_cities_within_budget(5, 3, [10, 15, 20]) 0 >>> max_cities_within_budget(60, 4, [10, 20, 30, 50]) 3 >>> max_cities_within_budget(50, 5, [10, 10, 10, 10, 10]) 5 >>> max_cities_within_budget(10**8, 10**6, [1]*10**6) 1000000","solution":"def max_cities_within_budget(b, m, costs): Returns the maximum number of cities that can be visited within the budget. Parameters: b (int): The budget for the trip. m (int): The number of cities. costs (list of int): The costs associated with visiting each city. Returns: int: The maximum number of cities that can be visited within the budget. costs.sort() total_cost = 0 count = 0 for cost in costs: if total_cost + cost <= b: total_cost += cost count += 1 else: break return count"},{"question":"def is_palindromic_pair_possible(words): Determines if it is possible to create a palindromic word by combining two different words from the list. >>> is_palindromic_pair_possible([\\"ab\\", \\"ba\\", \\"cba\\", \\"abc\\"]) == \\"YES\\" >>> is_palindromic_pair_possible([\\"aa\\", \\"aaa\\", \\"aaaa\\"]) == \\"YES\\" >>> is_palindromic_pair_possible([\\"abc\\", \\"def\\", \\"ghi\\"]) == \\"NO\\" def solve(t, test_cases): For each test case, determines if it is possible to create a palindromic word by combining two different words from the list. >>> solve(3, [(4, [\\"ab\\", \\"ba\\", \\"cba\\", \\"abc\\"]), (3, [\\"aa\\", \\"aaa\\", \\"aaaa\\"]), (3, [\\"abc\\", \\"def\\", \\"ghi\\"])]) == [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def is_palindromic_pair_possible(words): Determines if it is possible to create a palindromic word by combining two different words from the list. word_set = set(words) for word in words: reversed_word = word[::-1] if reversed_word in word_set and reversed_word != word: return \\"YES\\" for i in range(len(word)): if word[:i+1][::-1] in word_set or word[i:][::-1] in word_set: return \\"YES\\" return \\"NO\\" def solve(t, test_cases): results = [] for i in range(t): n, words = test_cases[i] results.append(is_palindromic_pair_possible(words)) return results"},{"question":"from typing import List, Tuple def max_fence_length(W: int, H: int, obstacles: List[Tuple[int, int]]) -> int: Calculate the maximum possible length of the straight fence that can be constructed in the rectangular field. The function takes the width W and height H of the rectangle and an optional list of obstacles inside the field. >>> max_fence_length(1, 1, []) 1 >>> max_fence_length(3, 4, []) 5 >>> max_fence_length(5, 12, []) 13","solution":"import math def max_fence_length(W, H, obstacles): Calculate the maximum possible length of the straight fence that can be constructed in the rectangle defined by width W and height H, optionally passing through at most one obstacle. # Calculate the diagonal length of the rectangle max_length = math.sqrt(W ** 2 + H ** 2) return int(round(max_length)) # Round to the nearest integer and return W = 10 H = 10 obstacles = [(5, 5), (6, 6)] max_fence_length(W, H, obstacles)"},{"question":"from typing import List, Tuple def find_convex_hull_with_k_vertices(n: int, k: int, points: List[Tuple[int, int]]) -> str: Given n points in a 2D plane, determine if there exists a subset of these points whose convex hull has exactly k vertices. If such a subset exists, return \\"YES\\" followed by the indices of the points in the subset. If no such subset exists, output \\"NO\\". >>> find_convex_hull_with_k_vertices(5, 3, [(0, 0), (1, 0), (0, 1), (1, 1), (2, 2)]) 'YESn1 2 4' >>> find_convex_hull_with_k_vertices(4, 4, [(0, 0), (1, 0), (1, 1), (0, 1)]) 'YESn1 2 3 4' >>> find_convex_hull_with_k_vertices(5, 6, [(0, 0), (1, 0), (0, 1), (1, 1), (2, 2)]) 'NO'","solution":"from itertools import combinations from math import atan2 def convex_hull(points): points = sorted(points, key=lambda p: (p[0], p[1])) def cross(o, a, b): return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]) lower = [] for p in points: while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0: lower.pop() lower.append(p) upper = [] for p in reversed(points): while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0: upper.pop() upper.append(p) return lower[:-1] + upper[:-1] def find_convex_hull_with_k_vertices(n, k, points): for subset_indices in combinations(range(n), k): subset = [points[i] for i in subset_indices] hull = convex_hull(subset) if len(hull) == k: return \\"YESn\\" + ' '.join(str(i + 1) for i in subset_indices) return \\"NO\\" # Example usage if __name__ == \\"__main__\\": n = 5 k = 3 points = [(0, 0), (1, 0), (0, 1), (1, 1), (2, 2)] print(find_convex_hull_with_k_vertices(n, k, points))"},{"question":"def can_transform_string(s, t): Determines if string s can be transformed into string t using the allowed operations. >>> can_transform_string(\\"abc\\", \\"bbc\\") \\"YES\\" >>> can_transform_string(\\"abcd\\", \\"bcda\\") \\"NO\\" >>> can_transform_string(\\"aaaaa\\", \\"zzzzz\\") \\"NO\\" >>> can_transform_string(\\"xyz\\", \\"xzz\\") \\"YES\\" >>> can_transform_string(\\"mnopqrst\\", \\"nopqrstt\\") \\"YES\\" def process_test_cases(test_cases): Processes multiple test cases to determine if string s can be transformed into string t. >>> process_test_cases([(3, \\"abc\\", \\"bbc\\"), (4, \\"abcd\\", \\"bcda\\"), (5, \\"aaaaa\\", \\"zzzzz\\")]) [\\"YES\\", \\"NO\\", \\"NO\\"] >>> process_test_cases([(9, \\"abcdefghi\\", \\"bbcdefghi\\"), (3, \\"xyz\\", \\"xzz\\")]) [\\"YES\\", \\"YES\\"]","solution":"def can_transform_string(s, t): Determines if string s can be transformed into string t using the allowed operations. for i in range(len(s)): diff = abs(ord(s[i]) - ord(t[i])) if diff not in [0, 1]: return \\"NO\\" return \\"YES\\" def process_test_cases(test_cases): results = [] for n, s, t in test_cases: results.append(can_transform_string(s, t)) return results"},{"question":"def sum_of_largest_m_values(m: int, n: int, values: List[int]) -> int: Returns the sum of the largest m values in the given list of n values. :param m: Number of largest values to sum :param n: Number of values in the input list :param values: List of integer values :return: Sum of the largest m values >>> sum_of_largest_m_values(5, 4, [2, 3, 7, 11]) 23 >>> sum_of_largest_m_values(3, 6, [5, 1, 2, 8, 12, 16]) 36 >>> sum_of_largest_m_values(1, 1, [10]) 10 >>> sum_of_largest_m_values(2, 4, [5, 5, 5, 5]) 10 >>> large_list = list(range(1, 100001)) >>> sum_of_largest_m_values(3, 100000, large_list) 299997 >>> sum_of_largest_m_values(3, 5, [4, 1, 3, 2, 5]) 12","solution":"def sum_of_largest_m_values(m, n, values): Returns the sum of the largest m values in the given list of n values. :param m: Number of largest values to sum :param n: Number of values in the input list :param values: List of integer values :return: Sum of the largest m values # Sort the list of values in descending order values.sort(reverse=True) # Sum the top m values return sum(values[:m])"},{"question":"def traveling_salesman(n: int, distance_matrix: List[List[int]]) -> int: Given the number of cities and the distance matrix, returns the minimum possible distance of the route that visits all cities exactly once and returns to the starting city. >>> n = 4 >>> distance_matrix = [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ] >>> traveling_salesman(n, distance_matrix) 80 >>> n = 3 >>> distance_matrix = [ ... [0, 29, 20], ... [29, 0, 15], ... [20, 15, 0] ... ] >>> traveling_salesman(n, distance_matrix) 64","solution":"from itertools import permutations def traveling_salesman(n, distance_matrix): Solves the Traveling Salesman Problem using brute force. Parameters: - n: int, the number of cities - distance_matrix: list of list of int, the distance matrix Returns: - int, the minimum possible distance of the route that visits all cities exactly once and returns to the starting city min_distance = float('inf') # Generate all permutations of cities, excluding the starting city (0) cities = list(range(1, n)) for perm in permutations(cities): # Calculate the total distance for this permutation current_distance = distance_matrix[0][perm[0]] # Start from city 0 to the first city in the permutation for i in range(len(perm) - 1): current_distance += distance_matrix[perm[i]][perm[i + 1]] current_distance += distance_matrix[perm[-1]][0] # Return to starting city 0 # Update the minimum distance found min_distance = min(min_distance, current_distance) return min_distance # Example usage # n = 4 # distance_matrix = [ # [0, 10, 15, 20], # [10, 0, 35, 25], # [15, 35, 0, 30], # [20, 25, 30, 0] # ] # print(traveling_salesman(n, distance_matrix)) # Output: 80"},{"question":"def count_useful_wells(n: int, k: int, r: int, village_structure: str) -> (int, int): Returns the number of useful oil wells and water wells in the village. Parameters: n (int): Number of villages k (int): Units of resources a well provides (unused in this solution) r (int): Range of the wells village_structure (str): A string representing the village structure with wells and barren lands Returns: tuple: Number of useful oil wells and useful water wells >>> count_useful_wells(5, 1000, 1, \\".O.W.\\") (1, 1) >>> count_useful_wells(10, 500, 2, \\"..O....W..\\") (1, 1) >>> count_useful_wells(7, 100, 3, \\"O.W.O..\\") (2, 1) >>> count_useful_wells(5, 100, 1, \\".....\\") (0, 0) >>> count_useful_wells(10, 100, 3, \\"..O..W...O\\") (2, 1) >>> count_useful_wells(1, 1, 1, \\"O\\") (0, 0) >>> count_useful_wells(1, 1, 1, \\"W\\") (0, 0)","solution":"def count_useful_wells(n, k, r, village_structure): Returns the number of useful oil wells and water wells in the village. Parameters: n (int): Number of villages k (int): Units of resources a well provides (unused in this solution) r (int): Range of the wells village_structure (str): A string representing the village structure with wells and barren lands Returns: tuple: Number of useful oil wells and useful water wells oil_wells = set() water_wells = set() villages = list(village_structure) for i in range(n): if villages[i] == 'O': for j in range(max(0, i-r), min(n, i+r+1)): if villages[j] == '.' or villages[j] == 'W': oil_wells.add(i) break elif villages[i] == 'W': for j in range(max(0, i-r), min(n, i+r+1)): if villages[j] == '.' or villages[j] == 'O': water_wells.add(i) break return (len(oil_wells), len(water_wells))"},{"question":"def grep(pattern: str, lines: List[str]) -> List[str]: Searches for the given pattern in each line and returns the lines that contain the pattern. If no lines match, returns [\\"No matches found\\"]. :param pattern: The pattern to search for within the lines. :param lines: List of lines to search through. :return: List of lines that contain the pattern. >>> grep(\\"abc\\", [\\"abcdef\\", \\"xyzabc\\", \\"uvw\\"]) ['abcdef', 'xyzabc'] >>> grep(\\"gh\\", [\\"abcdef\\", \\"xyzabc\\", \\"uvw\\"]) ['No matches found'] >>> grep(\\"ab\\", [\\"abc\\", \\"ab\\", \\"bca\\", \\"xyzab\\"]) ['abc', 'ab', 'xyzab'] >>> grep(\\"ab\\", [\\"\\", \\"\\", \\"\\"]) ['No matches found'] >>> grep(\\"abc\\", [\\"abcde\\", \\"deabc\\", \\"abc\\", \\"xabcx\\"]) ['abcde', 'deabc', 'abc', 'xabcx'] >>> grep(\\"hello\\", [\\"hello\\", \\"world\\", \\"hello world\\"]) ['hello', 'hello world'] >>> grep(\\"a%\\", [\\"a%cd\\", \\"xya%bc\\", \\"uvw\\"]) ['a%cd', 'xya%bc'] >>> grep(\\"pattern\\", []) ['No matches found'] >>> grep(\\"longpattern\\", [\\"short\\", \\"test\\", \\"lines\\"]) ['No matches found'] >>> grep(\\"abc\\", [\\"ABC\\", \\"aBc\\", \\"abC\\", \\"abc\\"]) ['abc'] pass","solution":"from typing import List def grep(pattern: str, lines: List[str]) -> List[str]: Searches for the given pattern in each line and returns the lines that contain the pattern. If no lines match, returns [\\"No matches found\\"]. :param pattern: The pattern to search for within the lines. :param lines: List of lines to search through. :return: List of lines that contain the pattern. matching_lines = [line for line in lines if pattern in line] return matching_lines if matching_lines else [\\"No matches found\\"]"},{"question":"def count_subarrays_with_sum_k(prizes: List[int], k: int) -> int: Returns the number of subarrays whose sum equals k. >>> count_subarrays_with_sum_k([3, 4, -7, 10, 2], 10) 2 >>> count_subarrays_with_sum_k([1, 3, -2, 5, 1, -1], 3) 3 >>> count_subarrays_with_sum_k([1, 2, 3], 5) 1 >>> count_subarrays_with_sum_k([1, 2, 3], 6) 1 >>> count_subarrays_with_sum_k([-1, -1, 1], -1) 3 >>> count_subarrays_with_sum_k([1, -1, 1, -1], 0) 4 >>> count_subarrays_with_sum_k([0, 0, 0, 0], 0) 10 >>> count_subarrays_with_sum_k([1], 1) 1 pass","solution":"def count_subarrays_with_sum_k(prizes, k): Returns the number of subarrays whose sum equals k. n = len(prizes) current_sum = 0 prefix_sums = {0: 1} count = 0 for prize in prizes: current_sum += prize if current_sum - k in prefix_sums: count += prefix_sums[current_sum - k] if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count def from_input_string(input_string): parts = input_string.split() n = int(parts[0]) k = int(parts[1]) prizes = list(map(int, parts[2:2+n])) return (prizes, k) def to_result_string(result): return str(result) + 'n'"},{"question":"def min_operations_to_make_equal(array: List[int]) -> int: Given an array of integers, determine the smallest number of operations required to make all the elements of the array equal. In one operation, you can select any two different elements and set one of them to be equal to the other. Args: array (List[int]): The list of integers. Returns: int: The minimal number of operations required to make all elements equal. Examples: >>> min_operations_to_make_equal([4, 9, 4]) 1 >>> min_operations_to_make_equal([1, 1, 2, 3]) 2 >>> min_operations_to_make_equal([5, 5, 5, 5, 5]) 0 # Unit tests def test_case_1(): assert min_operations_to_make_equal([4, 9, 4]) == 1 def test_case_2(): assert min_operations_to_make_equal([1, 1, 2, 3]) == 2 def test_case_3(): assert min_operations_to_make_equal([5, 5, 5, 5, 5]) == 0 def test_single_element(): assert min_operations_to_make_equal([7]) == 0 # Single element array case def test_all_different(): assert min_operations_to_make_equal([1, 2, 3, 4]) == 3 # All elements are different def test_all_same(): assert min_operations_to_make_equal([10, 10, 10, 10]) == 0 # All elements are the same def test_some_repeats(): assert min_operations_to_make_equal([1, 2, 2, 3, 3, 3]) == 3 # Some elements repeat def test_large_numbers(): assert min_operations_to_make_equal([1000, 1000, -1000, 1000, -1000]) == 2 # Large positive and negative numbers def test_negative_numbers(): assert min_operations_to_make_equal([-1, -1, -2, -3]) == 2 # All elements are negative","solution":"def min_operations_to_make_equal(array): Returns the minimum number of operations required to make all elements in the array equal. from collections import Counter element_counts = Counter(array) most_common_count = max(element_counts.values()) return len(array) - most_common_count"},{"question":"def count_ways_to_divide(n: int, fragments: List[str]) -> int: Returns the number of ways to divide the reconstructed text into words using the provided fragments. Parameters: n (int): The number of fragments. fragments (List[str]): The list of fragment strings. Returns: int: The number of ways to divide the reconstructed text into words. >>> count_ways_to_divide(1, [\\"ALONE\\"]) 1 >>> count_ways_to_divide(2, [\\"ABCDE\\", \\"FGHIJ\\"]) 1 >>> count_ways_to_divide(3, [\\"HELLO\\", \\"WORLD\\", \\"GOODBYE\\"]) 3 >>> count_ways_to_divide(5, [\\"ONE\\", \\"TWO\\", \\"THREE\\", \\"FOUR\\", \\"FIVE\\"]) 5 >>> count_ways_to_divide(4, [\\"A\\", \\"B\\", \\"C\\", \\"D\\"]) 4 pass","solution":"def count_ways_to_divide(n, fragments): Returns the number of ways to divide the reconstructed text into words using the provided fragments. # Each fragment can be considered as a separate word. # Since we must use all fragments exactly once and each as a word, # the number of ways to divide the text is simply the number of fragments. return n"},{"question":"from typing import List def minPathCost(cost: List[List[int]]) -> int: Compute the minimum cost to traverse from the top-left to the bottom-right cell of the given grid. Alice can only move right or down from each cell. >>> minPathCost([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> minPathCost([ ... [1, 2, 3, 4] ... ]) 10 >>> minPathCost([ ... [1], ... [2], ... [3], ... [4] ... ]) 10","solution":"from typing import List def minPathCost(cost: List[List[int]]) -> int: n = len(cost) m = len(cost[0]) dp = [[0] * m for _ in range(n)] dp[0][0] = cost[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + cost[i][0] for j in range(1, m): dp[0][j] = dp[0][j-1] + cost[0][j] for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j] return dp[n-1][m-1]"},{"question":"from typing import List def num_islands(grid: List[List[str]]) -> int: Given a grid consisting of '0's (representing water) and '1's (representing land), compute the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. >>> grid = [ ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ... ] >>> num_islands(grid) 3 >>> grid = [ ... [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"1\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"] ... ] >>> num_islands(grid) 1","solution":"from typing import List def num_islands(grid: List[List[str]]) -> int: if not grid: return 0 def dfs(grid, i, j): # if the current cell is out of bounds or is water ('0') if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0': return # mark the current cell as visited grid[i][j] = '0' # visit all four adjacent cells (up, down, left, right) dfs(grid, i - 1, j) dfs(grid, i + 1, j) dfs(grid, i, j - 1) dfs(grid, i, j + 1) num_of_islands = 0 # iterate over all cells in the grid for i in range(len(grid)): for j in range(len(grid[0])): # if the current cell is land ('1'), it's a new island if grid[i][j] == '1': num_of_islands += 1 dfs(grid, i, j) return num_of_islands"},{"question":"def singleNumber(nums: List[int]) -> int: Returns the element that appears only once in the array. >>> singleNumber([2, 2, 1]) 1 >>> singleNumber([4, 1, 2, 1, 2]) 4 >>> singleNumber([1]) 1","solution":"def singleNumber(nums): Returns the element that appears only once in the array. result = 0 for num in nums: result ^= num return result # Example usage: # print(singleNumber([2, 2, 1])) # Output should be 1 # print(singleNumber([4, 1, 2, 1, 2])) # Output should be 4"},{"question":"def is_fibonacci(num: int) -> bool: Check if a number is a Fibonacci number. >>> is_fibonacci(1) True >>> is_fibonacci(2) True >>> is_fibonacci(4) False def largest_fibonacci_divisor(n: int, collection: List[int]) -> int: Return the largest Fibonacci number in collection that divides n. If no such number exists, return -1. >>> largest_fibonacci_divisor(100, [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]) 5 >>> largest_fibonacci_divisor(144, [144, 89, 55, 34, 21, 13, 8, 5, 3, 2]) 144 >>> largest_fibonacci_divisor(10, [6, 9, 15, 20]) -1","solution":"def is_fibonacci(num): Check if a number is a Fibonacci number. if num <= 0: return False a, b = 0, 1 while b < num: a, b = b, a + b return b == num def largest_fibonacci_divisor(n, collection): Return the largest Fibonacci number in collection that divides n. If no such number exists, return -1. largest_divisor = -1 for num in collection: if is_fibonacci(num) and n % num == 0: largest_divisor = max(largest_divisor, num) return largest_divisor"},{"question":"def manipulate_array(N: int, Q: int, arr: List[int], queries: List[List[int]]) -> List[int]: Perform operations on the array based on queries. N: number of elements in the array Q: number of queries arr: initial array of integers queries: a list of queries, where each query is a list. Query Type 1: [1, x, y] - Update the element at index x to y Query Type 2: [2, l, r] - Find the sum of elements between indices l and r (inclusive) Returns a list of sums for each sum query. >>> manipulate_array(5, 3, [1, 2, 3, 4, 5], [[2, 0, 2], [1, 1, 10], [2, 1, 3]]) [6, 17] >>> manipulate_array(3, 2, [5, 6, 7], [[2, 0, 2], [1, 2, 10]]) [18]","solution":"def manipulate_array(N, Q, arr, queries): results = [] for query in queries: if query[0] == 1: _, x, y = query arr[x] = y elif query[0] == 2: _, l, r = query results.append(sum(arr[l:r+1])) return results"},{"question":"def generate_tournament_schedule(n: int): Generates a schedule for a tournament where each of the n teams plays exactly one match against each other team. The schedule ensures no team plays more than one match per day. Parameters: n (int): the number of teams (2  n  50) Returns: list of lists: each inner list contains tuples representing matches scheduled for that day Example: >>> generate_tournament_schedule(4) [[(1, 2), (3, 4)], [(1, 3), (2, 4)], [(1, 4), (2, 3)]] >>> generate_tournament_schedule(3) [[(1, 2)], [(1, 3)], [(2, 3)]] from solution import generate_tournament_schedule def test_generate_tournament_schedule_four_teams(): expected_output = [ [(1, 2), (3, 4)], [(1, 3), (2, 4)], [(1, 4), (2, 3)] ] assert generate_tournament_schedule(4) == expected_output def test_generate_tournament_schedule_three_teams(): expected_output = [ [(1, 2)], [(1, 3)], [(2, 3)] ] assert generate_tournament_schedule(3) == expected_output def test_generate_tournament_schedule_two_teams(): expected_output = [ [(1, 2)] ] assert generate_tournament_schedule(2) == expected_output def test_generate_tournament_schedule_five_teams(): output = generate_tournament_schedule(5) # Check each team plays exactly 1 match per day teams_per_day = sum([len(day) for day in output]) assert teams_per_day == (5 * (5 - 1)) // 2 # total number of matches should be 10 since 5 choose 2 equals 10","solution":"def generate_tournament_schedule(n): Generates a schedule for a tournament where each of the n teams plays exactly one match against each other team. The schedule ensures no team plays more than one match per day. Parameters: n (int): the number of teams (2  n  50) Returns: list of lists: each inner list contains tuples representing matches scheduled for that day days = [] matches = [(i, j) for i in range(1, n+1) for j in range(i+1, n+1)] used = [False] * len(matches) while not all(used): day_matches = [] teams_playing = set() for idx, (a, b) in enumerate(matches): if not used[idx] and a not in teams_playing and b not in teams_playing: day_matches.append((a, b)) teams_playing.add(a) teams_playing.add(b) used[idx] = True days.append(day_matches) return days"},{"question":"def max_submatrix_sum(R: int, C: int, S: int, matrix: List[List[int]]) -> int: Function to find the maximum submatrix sum in a given matrix that does not exceed S. Args: R: int : number of rows in the matrix C: int : number of columns in the matrix S: int : maximum allowable sum of any submatrix matrix: List[List[int]] : input matrix containing the elements Returns: int : maximum sum of submatrix that is less than or equal to S. Example Usage: >>> max_submatrix_sum(4, 4, 10, [ [1, 2, -1, 4], [-2, 3, 4, 1], [3, -1, 5, 2], [-1, 4, 2, 8] ]) 10 >>> max_submatrix_sum(3, 3, 5, [ [2, 1, 2], [1, 3, 4], [5, 1, -1] ]) 5 >>> max_submatrix_sum(2, 2, 0, [ [-1, 2], [3, 4] ]) 0","solution":"def max_submatrix_sum(R, C, S, matrix): Function to find the maximum submatrix sum in a given matrix that does not exceed S. max_sum = 0 for left in range(C): temp = [0] * R for right in range(left, C): for row in range(R): temp[row] += matrix[row][right] curr_sum = 0 subarray_sum = 0 for val in temp: curr_sum += val if curr_sum > S: curr_sum -= val continue if curr_sum >= max_sum: subarray_sum = curr_sum while curr_sum > S: curr_sum -= temp[temp.index(min(temp))] max_sum = max(max_sum, subarray_sum) return max_sum"},{"question":"def max_repost_depth(t, queries): Determines the maximum repost chain depth for each specified post. Args: t: An integer representing the number of queries. queries: A list of tuples where each tuple contains: - An integer n representing the number of reposts in the current query. - A list of tuples where each tuple contains: - A unique post ID (string) - The user who reposted it (string) - The original post ID (string) it was reposted from or -1 if it's an original post Returns: A list of integers where each integer represents the maximum repost chain depth for each query. Example: >>> max_repost_depth(2, [ ... (5, [ ... (\\"P1\\", \\"user1\\", \\"-1\\"), ... (\\"P2\\", \\"user2\\", \\"P1\\"), ... (\\"P3\\", \\"user3\\", \\"P2\\"), ... (\\"P4\\", \\"user4\\", \\"-1\\"), ... (\\"P5\\", \\"user5\\", \\"P4\\") ... ]), ... (4, [ ... (\\"P6\\", \\"user6\\", \\"-1\\"), ... (\\"P7\\", \\"user7\\", \\"P6\\"), ... (\\"P8\\", \\"user8\\", \\"P7\\"), ... (\\"P9\\", \\"user9\\", \\"P8\\") ... ]) ... ]) == [3, 4] >>> max_repost_depth(1, [ ... (1, [(\\"P1\\", \\"user1\\", \\"-1\\")])]) == [1]","solution":"def max_repost_depth(t, queries): results = [] for query in queries: n, posts = query graph = {} depths = {} for post in posts: pid, user, opid = post if opid == '-1': graph[pid] = None depths[pid] = 1 else: graph[pid] = opid def get_depth(pid): if pid not in graph: return 0 if pid in depths: return depths[pid] depth = 1 + get_depth(graph[pid]) depths[pid] = depth return depth max_depth = 0 for pid in graph.keys(): max_depth = max(max_depth, get_depth(pid)) results.append(max_depth) return results"},{"question":"def max_subarray_product(arr): Returns the maximum product of any contiguous subarray of the given array. >>> max_subarray_product([1, 2, 3, 4, 5]) == 120 >>> max_subarray_product([1, -2, 0, 3, 4]) == 12 >>> max_subarray_product([-1, -2, -3, -4, -5]) == 120 >>> max_subarray_product([1, -2, 3, -4, 5]) == 120 >>> max_subarray_product([5]) == 5 >>> max_subarray_product([-5]) == -5 >>> max_subarray_product([2] * 10000) == 2 ** 10000 >>> max_subarray_product([-2, 3, -4, 5, -1]) == 120","solution":"def max_subarray_product(arr): Returns the maximum product of any contiguous subarray of the given array. if not arr: return 0 max_product = arr[0] min_product = arr[0] result = arr[0] for i in range(1, len(arr)): if arr[i] < 0: max_product, min_product = min_product, max_product max_product = max(arr[i], max_product * arr[i]) min_product = min(arr[i], min_product * arr[i]) result = max(result, max_product) return result"},{"question":"def two_sum_possible(n: int, arr: List[int], target: int) -> str: Determines whether any two distinct integers from the list sum up to the target value. >>> two_sum_possible(5, [1, 2, 3, 4, 5], 9) \\"YES\\" >>> two_sum_possible(3, [1, 2, 3], 6) \\"NO\\"","solution":"def two_sum_possible(n, arr, target): Determines whether any two distinct integers from the list sum up to the target value. seen = set() for num in arr: if target - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\" def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:n+1])) target = int(data[n+1]) result = two_sum_possible(n, arr, target) print(result) if __name__ == \\"__main__\\": main()"},{"question":"def count_shorter_students(n: int, heights: List[int]) -> List[int]: Calculate the number of students in front of each student who are shorter. Parameters: n (int): The number of students heights (list): The list of heights of the students Returns: list: A list of counts of shorter students in front of each student Example: >>> count_shorter_students(5, [3, 1, 4, 2, 5]) [0, 0, 2, 1, 4] >>> count_shorter_students(4, [1, 2, 3, 4]) [0, 1, 2, 3]","solution":"def count_shorter_students(n, heights): Calculate the number of students in front of each student who are shorter. Parameters: n (int): The number of students heights (list): The list of heights of the students Returns: list: A list of counts of shorter students in front of each student result = [0] * n for i in range(1, n): count = 0 for j in range(i): if heights[j] < heights[i]: count += 1 result[i] = count return result"},{"question":"def form_circle(heights: List[int]) -> List[int]: Given a list of heights, order them to minimize the difference in height between adjacent people in the circle. >>> form_circle([5, 8, 3, 2, 10]) [2, 3, 5, 8, 10] >>> form_circle([21, 13, 17, 8, 5, 2]) [2, 5, 8, 13, 17, 21]","solution":"def form_circle(heights): Given a list of heights, the function sorts the list in ascending order to form a circle such that the difference in height between any two adjacent people is minimized. return sorted(heights)"},{"question":"def sum_of_distinct_prime_divisors(n: int, sequence: List[int]) -> List[int]: Given a sequence of integers, returns a list where each element is replaced by the sum of its distinct prime divisors. Parameters: n (int): Number of integers in the sequence. sequence (list): List of integers Returns: list: List of integers where each element is the sum of its distinct prime divisors. Examples: >>> sum_of_distinct_prime_divisors(5, [10, 15, 21, 33, 34]) [7, 8, 10, 14, 19] >>> sum_of_distinct_prime_divisors(3, [7, 11, 13]) [7, 11, 13]","solution":"def sum_of_distinct_prime_divisors(n, sequence): Given a sequence of integers, returns a list where each element is replaced by the sum of its distinct prime divisors. Parameters: n (int): Number of integers in the sequence. sequence (list): List of integers Returns: list: List of integers where each element is the sum of its distinct prime divisors. def sieve(limit): primes = [] is_prime = [True] * (limit + 1) is_prime[0], is_prime[1] = False, False for i in range(2, limit + 1): if is_prime[i]: primes.append(i) for multiple in range(i * i, limit + 1, i): is_prime[multiple] = False return primes def get_prime_sum(x, primes): prime_sum = 0 for prime in primes: if prime * prime > x: break if x % prime == 0: prime_sum += prime while x % prime == 0: x //= prime if x > 1: prime_sum += x return prime_sum max_value = max(sequence) primes = sieve(max_value) return [get_prime_sum(a, primes) for a in sequence]"},{"question":"def min_palindromic_substrings(s: str) -> int: Compute the minimum number of palindromic substrings required to split the given string. >>> min_palindromic_substrings(\\"abac\\") 2 >>> min_palindromic_substrings(\\"aabxaa\\") 4 >>> min_palindromic_substrings(\\"a\\") 1 >>> min_palindromic_substrings(\\"aaaa\\") 1 >>> min_palindromic_substrings(\\"abccba\\") 1 >>> min_palindromic_substrings(\\"racecar\\") 1 >>> min_palindromic_substrings(\\"abcdefg\\") 7 >>> min_palindromic_substrings(\\"aabb\\") 2 >>> min_palindromic_substrings(\\"abaxabaxabb\\") 3 >>> min_palindromic_substrings(\\"civicracecar\\") 2","solution":"def min_palindromic_substrings(s: str) -> int: n = len(s) # Table to store the palindrome status dp_palindrome = [[False] * n for _ in range(n)] # Table to store the minimum cuts needed min_cuts = [float('inf')] * n for i in range(n): dp_palindrome[i][i] = True for length in range(2, n+1): # length is the length of substrings for start in range(n-length+1): end = start + length - 1 if length == 2: dp_palindrome[start][end] = (s[start] == s[end]) else: dp_palindrome[start][end] = (s[start] == s[end] and dp_palindrome[start+1][end-1]) for i in range(n): if dp_palindrome[0][i]: min_cuts[i] = 1 else: for j in range(i): if dp_palindrome[j+1][i]: min_cuts[i] = min(min_cuts[i], min_cuts[j] + 1) return min_cuts[n-1]"},{"question":"def is_sorted_and_contiguous(n: int, coins: List[int]) -> str: Determines if the coins are sorted in non-decreasing order and all coins with the same type appear in a contiguous block. Args: n (int): The number of coins. coins (list of int): The types of the coins in their current order. Returns: str: \\"YES\\" if coins are sorted and contiguous, \\"NO\\" otherwise. >>> is_sorted_and_contiguous(5, [1, 2, 2, 3, 3]) \\"YES\\" >>> is_sorted_and_contiguous(6, [1, 3, 2, 2, 3, 3]) \\"NO\\" >>> is_sorted_and_contiguous(1, [1]) \\"YES\\" >>> is_sorted_and_contiguous(4, [2, 2, 2, 2]) \\"YES\\" >>> is_sorted_and_contiguous(3, [3, 2, 1]) \\"NO\\" >>> is_sorted_and_contiguous(5, [1, 2, 3, 2, 3]) \\"NO\\"","solution":"def is_sorted_and_contiguous(n, coins): Determines if the coins are sorted in non-decreasing order and all coins with the same type appear in a contiguous block. Args: n (int): The number of coins. coins (list of int): The types of the coins in their current order. Returns: str: \\"YES\\" if coins are sorted and contiguous, \\"NO\\" otherwise. for i in range(1, n): if coins[i] < coins[i - 1]: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def subtree_sizes(n: int, edges: List[Tuple[int, int]]) -> List[int]: Compute the sizes of the subtrees rooted at each node of a tree. Args: n (int): The number of nodes in the tree. edges (List[Tuple[int, int]]): List of edges in the tree. Returns: List[int]: List of subtree sizes. Example: >>> subtree_sizes(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) [5, 3, 1, 1, 1] >>> subtree_sizes(1, []) [1] pass def test_example_1(): n = 5 edges = [(1, 2), (1, 3), (2, 4), (2, 5)] result = subtree_sizes(n, edges) assert result == [5, 3, 1, 1, 1] def test_single_node(): n = 1 edges = [] result = subtree_sizes(n, edges) assert result == [1] def test_chain_tree(): n = 3 edges = [(1, 2), (2, 3)] result = subtree_sizes(n, edges) assert result == [3, 2, 1] def test_star_tree(): n = 4 edges = [(1, 2), (1, 3), (1, 4)] result = subtree_sizes(n, edges) assert result == [4, 1, 1, 1] def test_balanced_binary_tree(): n = 7 edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)] result = subtree_sizes(n, edges) assert result == [7, 3, 3, 1, 1, 1, 1]","solution":"def subtree_sizes(n, edges): from collections import defaultdict, deque # Create an adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # To store the size of subtree rooted at each node size = [0] * (n + 1) def dfs(node, parent): # Initially the node size is 1 including itself subtree_size = 1 for neighbor in adj_list[node]: if neighbor != parent: subtree_size += dfs(neighbor, node) size[node] = subtree_size return subtree_size # Starting DFS from the root node, which is 1 dfs(1, -1) # Exclude the dummy 0-th index to match 1-based index requirement return size[1:]"},{"question":"def compress_string(s: str) -> str: Compresses the given string by replacing consecutive repeated characters with a single character followed by the number of occurrences. Args: s (str): Input string composed of lowercase English letters. Returns: str: Compressed string. Examples: >>> compress_string(\\"aaabbbccc\\") \\"a3b3c3\\" >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\"","solution":"def compress_string(s): Compresses the given string by replacing consecutive repeated characters with a single character followed by the number of occurrences. Args: s (str): Input string composed of lowercase English letters. Returns: str: Compressed string. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) return \\"\\".join(compressed)"},{"question":"def can_create_batch(n: int, sugar_contents: List[int], max_sugar: int) -> str: Determines if we can create a batch with the given ingredients that meets the criteria set by Peter Parameters: n (int): Number of different ingredients sugar_contents (List[int]): Sugar content of each ingredient max_sugar (int): Maximum allowed total sugar content for a batch Returns: str: \\"possible\\" if a valid batch can be created, otherwise \\"impossible\\" >>> can_create_batch(4, [50, 25, 100, 200], 250) \\"possible\\" >>> can_create_batch(1, [150], 100) \\"impossible\\" pass","solution":"def can_create_batch(n, sugar_contents, max_sugar): Determines if we can create a batch with the given ingredients that meets the criteria set by Peter Parameters: n (int): Number of different ingredients sugar_contents (list of int): Sugar content of each ingredient max_sugar (int): Maximum allowed total sugar content for a batch Returns: str: \\"possible\\" if a valid batch can be created, otherwise \\"impossible\\" # If the sum of all ingredients is less than or equal to max_sugar, it's possible if sum(sugar_contents) <= max_sugar: return \\"possible\\" # Otherwise, try to find a combination of ingredients that satisfies the criteria from itertools import combinations for i in range(1, len(sugar_contents) + 1): for combo in combinations(sugar_contents, i): if sum(combo) <= max_sugar: return \\"possible\\" return \\"impossible\\""},{"question":"def smallest_subsequence(s: str) -> str: Returns the lexicographically smallest subsequence of s that contains all distinct characters of s. >>> smallest_subsequence(\\"bcabc\\") \\"abc\\" >>> smallest_subsequence(\\"cbacdcbc\\") \\"acdb\\" pass def solve_cases(test_cases: List[str]) -> List[str]: For each string in test_cases, determines the lexicographically smallest subsequence that contains all distinct characters. >>> solve_cases([\\"bcabc\\", \\"cbacdcbc\\"]) [\\"abc\\", \\"acdb\\"] pass","solution":"def smallest_subsequence(s): Returns the lexicographically smallest subsequence of s that contains all distinct characters of s. last_occurrence = {char: i for i, char in enumerate(s)} stack = [] in_stack = set() for i, char in enumerate(s): if char in in_stack: continue while stack and char < stack[-1] and i < last_occurrence[stack[-1]]: in_stack.remove(stack.pop()) stack.append(char) in_stack.add(char) return \\"\\".join(stack) def solve_cases(test_cases): results = [] for s in test_cases: results.append(smallest_subsequence(s)) return results"},{"question":"def traffic_light_durations(T: int, R: int, G: int, Y: int) -> Tuple[int, int, int]: Determine the specific durations (in seconds) for Red, Green, and Yellow lights. Args: T (int): Total cycle time in seconds. R (int): Ratio for Red light duration. G (int): Ratio for Green light duration. Y (int): Ratio for Yellow light duration. Returns: Tuple[int, int, int]: Durations for Red, Green, and Yellow lights respectively. >>> traffic_light_durations(120, 2, 1, 1) (60, 30, 30) >>> traffic_light_durations(90, 3, 2, 1) (45, 30, 15) >>> traffic_light_durations(60, 1, 1, 1) (20, 20, 20) >>> traffic_light_durations(10000, 10, 5, 5) (5000, 2500, 2500) >>> traffic_light_durations(1, 1, 1, 1) (1//3, 1//3, 1//3) >>> traffic_light_durations(300, 3, 5, 2) (90, 150, 60) # Your code here","solution":"def traffic_light_durations(T, R, G, Y): Returns the durations of Red, Green, and Yellow lights based on the total cycle time and given ratios. total_ratio = R + G + Y factor = T // total_ratio red_duration = R * factor green_duration = G * factor yellow_duration = Y * factor return red_duration, green_duration, yellow_duration"},{"question":"def maximum_non_consecutive_sum(arr: List[int]) -> int: Function to find the maximum possible sum of elements such that no two consecutive elements are selected. >>> maximum_non_consecutive_sum([3, 2, 5, 10]) 13 >>> maximum_non_consecutive_sum([10, 2, 7, 8, 5]) 22","solution":"def maximum_non_consecutive_sum(arr): Function to find the maximum possible sum of elements such that no two consecutive elements are selected. if not arr: return 0 n = len(arr) if n == 1: return arr[0] # dp[i] will store the maximum sum of elements # up to the ith index such that no two consecutive elements # are taken. dp = [0] * n dp[0] = arr[0] dp[1] = max(arr[0], arr[1]) for i in range(2, n): dp[i] = max(dp[i - 1], arr[i] + dp[i - 2]) return dp[-1]"},{"question":"def can_be_strictly_increasing(arr): Determine if it is possible to remove at most one element to make the array strictly increasing. >>> can_be_strictly_increasing([1, 2, 3, 5, 4]) True >>> can_be_strictly_increasing([1, 2, 3, 4]) True >>> can_be_strictly_increasing([7, 3, 5, 4, 6, 7]) False pass def process_test_cases(T, test_cases): Process multiple test cases to determine if it is possible to remove at most one element from each array to make it strictly increasing. >>> T = 3 >>> test_cases = [(5, [1, 2, 3, 5, 4]), (4, [1, 2, 3, 4]), (6, [7, 3, 5, 4, 6, 7])] >>> process_test_cases(T, test_cases) ['YES', 'YES', 'NO'] >>> T = 2 >>> test_cases = [(3, [1, 2, 10]), (6, [1, 3, 2, 4, 5, 6])] >>> process_test_cases(T, test_cases) ['YES', 'YES'] pass","solution":"def can_be_strictly_increasing(arr): def is_strictly_increasing(a): return all(a[i] < a[i + 1] for i in range(len(a) - 1)) n = len(arr) if is_strictly_increasing(arr): return True for i in range(n): if is_strictly_increasing(arr[:i] + arr[i + 1:]): return True return False def process_test_cases(T, test_cases): results = [] for i in range(T): N, array = test_cases[i] if can_be_strictly_increasing(array): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_meeting_rooms(intervals: List[List[int]]) -> int: Determine the minimum number of meeting rooms required to accommodate all employees. >>> min_meeting_rooms([[1, 4], [2, 5], [7, 9]]) == 2 >>> min_meeting_rooms([[0, 30], [5, 10], [15, 20], [25, 35]]) == 2 >>> min_meeting_rooms([]) == 0 >>> min_meeting_rooms([[5, 10]]) == 1 >>> min_meeting_rooms([[1, 2], [3, 4], [5, 6]]) == 1 >>> min_meeting_rooms([[1, 5], [2, 6], [4, 8], [3, 7]]) == 4 >>> min_meeting_rooms([[i, i + 1] for i in range(0, 100000, 2)]) == 1","solution":"def min_meeting_rooms(intervals): if not intervals: return 0 # Initialize variables to track start and end times start_times = sorted([i[0] for i in intervals]) end_times = sorted([i[1] for i in intervals]) start_pointer, end_pointer = 0, 0 used_rooms = 0 max_rooms_needed = 0 # Iterate through all the intervals while start_pointer < len(intervals): if start_times[start_pointer] < end_times[end_pointer]: used_rooms += 1 start_pointer += 1 else: used_rooms -= 1 end_pointer += 1 max_rooms_needed = max(max_rooms_needed, used_rooms) return max_rooms_needed"},{"question":"def reverse_words_in_string(s: str) -> str: Reverse the order of words in the string while maintaining the positions of spaces. :param s: A string containing words and spaces. :return: A string with the words in reverse order and spaces in their original places. Examples: >>> reverse_words_in_string(\\"the sky is blue\\") \\"blue is sky the\\" >>> reverse_words_in_string(\\" hello world \\") \\" world hello \\"","solution":"def reverse_words_in_string(s: str) -> str: Reverse the order of words in the string while maintaining the positions of spaces. :param s: A string containing words and spaces. :return: A string with the words in reverse order and spaces in their original places. # Split the string into a list of words and spaces words = s.split() # Reverse the list of words reversed_words = words[::-1] # Create an iterator for the reversed words words_iter = iter(reversed_words) # Reconstruct the string result = [] i = 0 while i < len(s): if s[i] == ' ': result.append(' ') i += 1 else: result.append(next(words_iter)) # Move the index to the end of the current word in the original string while i < len(s) and s[i] != ' ': i += 1 return ''.join(result)"},{"question":"def minimize_steps_to_equal_height(buildings: List[int]) -> int: Returns the minimum number of steps required to make all buildings have the same height. Parameters: buildings (List[int]): A list of integers representing the heights of buildings. Returns: int: The minimum number of steps required. >>> minimize_steps_to_equal_height([1, 2, 3]) 2 >>> minimize_steps_to_equal_height([5, 5, 5, 5]) 0 >>> minimize_steps_to_equal_height([5]) 0 >>> minimize_steps_to_equal_height([1, 10, 2, 9]) 16 >>> minimize_steps_to_equal_height([1000000, 1000001, 999999, 1000002]) 4 >>> buildings = [1, 1000000] * 50000 ... >>> minimize_steps_to_equal_height(buildings) 49999950000","solution":"def minimize_steps_to_equal_height(buildings): Returns the minimum number of steps required to make all buildings have the same height. Parameters: buildings (List[int]): A list of integers representing the heights of buildings. Returns: int: The minimum number of steps required. # Find the median of the buildings' heights buildings.sort() median = buildings[len(buildings) // 2] # Calculate the total number of steps needed to make all heights equal to the median steps = sum(abs(height - median) for height in buildings) return steps"},{"question":"def top_n_products(products, category, n): Determine the top n products from a specific category, sorted by their rating in descending order. Parameters: products (list of str): A list of product details in the format \\"id,name,category,price,rating\\". category (str): The category to filter the products by. n (int): The number of top-rated products to return. Returns: list of str: A list of ids representing the top n products in the specified category. Examples: >>> products = [\\"1,book,stationery,12.5,4.5\\", \\"2,pen,stationery,1.5,3.9\\", \\"3,notebook,stationery,5.0,4.8\\", \\"4,mug,home,7.5,4.2\\", \\"5,poster,home,2.5,3.5\\"] >>> category = \\"stationery\\" >>> n = 2 >>> top_n_products(products, category, n) [\\"3\\", \\"1\\"] pass def test_top_n_products_basic(): products = [ \\"1,book,stationery,12.5,4.5\\", \\"2,pen,stationery,1.5,3.9\\", \\"3,notebook,stationery,5.0,4.8\\", \\"4,mug,home,7.5,4.2\\", \\"5,poster,home,2.5,3.5\\" ] category = \\"stationery\\" n = 2 assert top_n_products(products, category, n) == [\\"3\\", \\"1\\"] def test_top_n_products_same_rating(): products = [ \\"1,pencil,stationery,1.0,4.0\\", \\"2,eraser,stationery,0.5,4.0\\", \\"3,ruler,stationery,1.2,3.5\\", \\"4,sharpener,stationery,1.0,4.0\\", \\"5,book,stationery,5.0,4.2\\" ] category = \\"stationery\\" n = 3 assert top_n_products(products, category, n) == [\\"5\\", \\"1\\", \\"2\\"] def test_top_n_products_less_than_n(): products = [ \\"1,notebook,office,3.5,4.5\\", \\"2,stapler,office,6.0,4.0\\" ] category = \\"office\\" n = 3 assert top_n_products(products, category, n) == [\\"1\\", \\"2\\"] def test_top_n_products_no_category(): products = [ \\"1,notebook,office,3.5,4.5\\", \\"2,stapler,office,6.0,4.0\\" ] category = \\"home\\" n = 2 assert top_n_products(products, category, n) == [] def test_top_n_products_single_item(): products = [ \\"1,notebook,stationery,3.5,4.5\\" ] category = \\"stationery\\" n = 1 assert top_n_products(products, category, n) == [\\"1\\"] def test_top_n_products_tie_ratings(): products = [ \\"1,pencil,stationery,1.0,4.0\\", \\"2,eraser,stationery,0.5,4.0\\", \\"3,ruler,stationery,1.2,4.0\\", \\"4,sharpener,stationery,1.0,4.0\\", \\"5,book,stationery,5.0,4.2\\" ] category = \\"stationery\\" n = 4 assert top_n_products(products, category, n) == [\\"5\\", \\"1\\", \\"2\\", \\"3\\"]","solution":"def top_n_products(products, category, n): # Parse the product details product_list = [] for product in products: product_id, name, prod_category, price, rating = product.split(',') if prod_category == category: product_list.append((product_id, float(rating))) # Sort the products based on rating in descending order sorted_products = sorted(product_list, key=lambda x: x[1], reverse=True) # Extract the top n product IDs top_n_product_ids = [prod[0] for prod in sorted_products[:n]] return top_n_product_ids"},{"question":"def find_pair_with_target_sum(n: int, numbers: List[int], target: int) -> str: Find whether there is a pair of integers in the list that adds up to the target. Print the indices of the two integers in the list. If there are multiple possible pairs, return any of them. If no such pair exists, print \`-1\`. >>> find_pair_with_target_sum(5, [2, 7, 11, 15, 1], 9) \\"0 1\\" >>> find_pair_with_target_sum(4, [1, 2, 3, 4], 8) \\"-1\\" from typing import List def test_find_pair_with_target_sum_case1(): n = 5 numbers = [2, 7, 11, 15, 1] target = 9 result = find_pair_with_target_sum(n, numbers, target) assert result == \\"0 1\\" or result == \\"1 0\\" def test_find_pair_with_target_sum_case2(): n = 4 numbers = [1, 2, 3, 4] target = 8 result = find_pair_with_target_sum(n, numbers, target) assert result == \\"-1\\" def test_find_pair_with_target_sum_case3(): n = 6 numbers = [3, 3, 4, 5, 6, 7] target = 10 result = find_pair_with_target_sum(n, numbers, target) assert result == \\"1 5\\" or result == \\"5 1\\" or result == \\"2 4\\" or result == \\"4 2\\" def test_find_pair_with_target_sum_no_pair(): n = 3 numbers = [5, 9, 14] target = 20 result = find_pair_with_target_sum(n, numbers, target) assert result == \\"-1\\" def test_find_pair_with_target_sum_single_pair(): n = 2 numbers = [4, 6] target = 10 result = find_pair_with_target_sum(n, numbers, target) assert result == \\"0 1\\" or result == \\"1 0\\"","solution":"def find_pair_with_target_sum(n, numbers, target): num_to_index = {} for i, num in enumerate(numbers): complement = target - num if complement in num_to_index: return f\\"{num_to_index[complement]} {i}\\" num_to_index[num] = i return \\"-1\\""},{"question":"def can_align_dots(board): Determine if it's possible to align all dots in a 3x3 board in a single row or column. Args: - board (list of lists): 2D list representing the 3x3 board. Returns: - str: 'Yes' if alignment is possible, 'No' otherwise. >>> can_align_dots([['a', '.', 'b'],['c', 'a', '.'],['a', 'c', 'b']]) 'No' >>> can_align_dots([['.', '.', '.'],['a', 'b', 'c'],['x', 'y', 'z']]) 'Yes' >>> can_align_dots([['.', 'a', 'b'],['.', 'c', 'd'],['.', 'e', 'f']]) 'Yes' >>> can_align_dots([['a', '.', 'c'],['.', 'f', '.'],['.', 'i', '.']]) 'No' >>> can_align_dots([['a', 'b', 'c'],['d', 'e', 'f'],['g', 'h', 'i']]) 'No'","solution":"def can_align_dots(board): Determine if it's possible to align all dots in a 3x3 board in a single row or column. Args: - board (list of lists): 2D list representing the 3x3 board. Returns: - str: 'Yes' if alignment is possible, 'No' otherwise. # Count dots in rows and columns row_dot_count = [0, 0, 0] col_dot_count = [0, 0, 0] for i in range(3): for j in range(3): if board[i][j] == '.': row_dot_count[i] += 1 col_dot_count[j] += 1 # Check rows for count in row_dot_count: if count == 3: return 'Yes' # Check columns for count in col_dot_count: if count == 3: return 'Yes' return 'No'"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5 >>> length_of_longest_substring_two_distinct(\\"\\") 0 >>> length_of_longest_substring_two_distinct(\\"a\\") 1 >>> length_of_longest_substring_two_distinct(\\"aaaa\\") 4 >>> length_of_longest_substring_two_distinct(\\"ab\\") 2 >>> length_of_longest_substring_two_distinct(\\"abaccc\\") 4","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring that contains at most two distinct characters. if not s: return 0 start = 0 max_length = 0 char_count = {} for end in range(len(s)): char_count[s[end]] = char_count.get(s[end], 0) + 1 while len(char_count) > 2: char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def can_divide_into_equal_segments(n: int, k: int, array: List[int]) -> str: Determines if it's possible to divide the sequence into k non-empty contiguous segments such that the sum of elements in each segment is equal. >>> can_divide_into_equal_segments(8, 4, [2, 2, 2, 2, 2, 2, 2, 2]) \\"YES\\" >>> can_divide_into_equal_segments(9, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]) \\"NO\\" >>> can_divide_into_equal_segments(6, 2, [1, 1, 1, 1, 4, 4]) \\"NO\\" pass","solution":"def can_divide_into_equal_segments(n, k, array): Determines if it's possible to divide the sequence into k non-empty contiguous segments such that the sum of elements in each segment is equal. total_sum = sum(array) # The total sum must be divisible by k for equal division. if total_sum % k != 0: return \\"NO\\" target_sum = total_sum // k current_sum = 0 segments = 0 for num in array: current_sum += num if current_sum == target_sum: segments += 1 current_sum = 0 if segments == k: return \\"YES\\" else: return \\"NO\\""},{"question":"def min_hours_to_prepare_dishes(m: int, n: int, efficiencies: List[int]) -> int: Determine the minimum number of hours required to prepare all dishes. Parameters: m (int): The number of dishes. n (int): The number of chefs. efficiencies (list): List of integers representing the efficiency of each chef. Returns: int: The minimum number of hours required to prepare all dishes. def test_min_hours_example(): assert min_hours_to_prepare_dishes(15, 3, [2, 4, 6]) == 2 def test_min_hours_single_chef(): assert min_hours_to_prepare_dishes(10, 1, [5]) == 2 assert min_hours_to_prepare_dishes(10, 1, [10]) == 1 def test_min_hours_multiple_chefs_with_equal_efficiencies(): assert min_hours_to_prepare_dishes(10, 2, [5, 5]) == 1 assert min_hours_to_prepare_dishes(24, 3, [8, 8, 8]) == 1 def test_min_hours_single_dish(): assert min_hours_to_prepare_dishes(1, 3, [1, 2, 3]) == 1 def test_min_hours_efficiencies_greater_than_dishes(): assert min_hours_to_prepare_dishes(5, 2, [4, 4]) == 1 assert min_hours_to_prepare_dishes(5, 3, [3, 3, 3]) == 1 def test_min_hours_high_efficiency(): assert min_hours_to_prepare_dishes(1000, 3, [500, 300, 200]) == 1 def test_min_hours_edge_cases(): assert min_hours_to_prepare_dishes(1, 1, [1]) == 1 assert min_hours_to_prepare_dishes(1000, 1, [1]) == 1000 assert min_hours_to_prepare_dishes(1000, 2, [500, 500]) == 1 assert min_hours_to_prepare_dishes(1000, 3, [300, 300, 300]) == 2","solution":"def min_hours_to_prepare_dishes(m, n, efficiencies): Determine the minimum number of hours required to prepare all dishes. Parameters: m (int): The number of dishes. n (int): The number of chefs. efficiencies (list): List of integers representing the efficiency of each chef. Returns: int: The minimum number of hours required to prepare all dishes. # Sum of the efficiencies of all chefs total_efficiency_per_hour = sum(efficiencies) # Calculate the minimum number of hours required min_hours = (m + total_efficiency_per_hour - 1) // total_efficiency_per_hour return min_hours"},{"question":"def max_houses_renovated(n: int, B: int, costs: List[int]) -> int: Returns the maximum number of houses that can be renovated within the given budget. Parameters: n (int): The number of houses. B (int): The total budget. costs (list of int): The renovation costs of the houses. Returns: int: The maximum number of houses that can be renovated. from solution import max_houses_renovated def test_example_case(): assert max_houses_renovated(5, 10, [2, 3, 1, 5, 4]) == 4 def test_all_houses_can_be_renovated(): assert max_houses_renovated(3, 15, [3, 5, 4]) == 3 def test_no_house_can_be_renovated(): assert max_houses_renovated(3, 1, [2, 3, 4]) == 0 def test_some_houses_can_be_renovated(): assert max_houses_renovated(4, 8, [2, 5, 3, 1]) == 3 def test_single_house_with_exact_budget(): assert max_houses_renovated(1, 5, [5]) == 1 def test_single_house_exceeding_budget(): assert max_houses_renovated(1, 4, [5]) == 0 def test_multiple_houses_exceeding_budget(): assert max_houses_renovated(3, 5, [4, 4, 4]) == 1 def test_large_input(): costs = [i for i in range(1, 100001)] assert max_houses_renovated(100000, 5000000, costs) == 3161","solution":"def max_houses_renovated(n, B, costs): Returns the maximum number of houses that can be renovated within the given budget. Parameters: n (int): The number of houses. B (int): The total budget. costs (list of int): The renovation costs of the houses. Returns: int: The maximum number of houses that can be renovated. # Sort the costs in ascending order costs.sort() total_cost = 0 count = 0 # Iterate through the sorted costs for cost in costs: if total_cost + cost <= B: total_cost += cost count += 1 else: break return count"},{"question":"def compress_string(s: str) -> str: Write a function that takes a string as input and compresses it. The compression is achieved by replacing sequences of the same character with that character followed by the number of occurrences. If the length of the compressed string is not smaller than the original string, return the original string. The function should handle both uppercase and lowercase characters. >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compress_string(\\"abcdef\\") \\"abcdef\\" def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Process multiple test cases of string compression. >>> process_test_cases(2, [\\"aabcccccaaa\\", \\"abcdef\\"]) [\\"a2b1c5a3\\", \\"abcdef\\"] from solution import compress_string, process_test_cases def test_single_repetition(): assert compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" def test_no_repetition(): assert compress_string(\\"abcdef\\") == \\"abcdef\\" def test_all_same_characters(): assert compress_string(\\"aaaaa\\") == \\"a5\\" def test_mixed_case_characters(): assert compress_string(\\"AAaaBBbb\\") == \\"AAaaBBbb\\" def test_length_edge_case(): assert compress_string(\\"a\\"*200) == \\"a200\\" assert compress_string(\\"ab\\"*100) == \\"ab\\"*100 def test_single_character(): assert compress_string(\\"a\\") == \\"a\\" def test_process_test_cases(): T = 2 test_cases = [\\"aabcccccaaa\\", \\"abcdef\\"] assert process_test_cases(T, test_cases) == [\\"a2b1c5a3\\", \\"abcdef\\"]","solution":"def compress_string(s): compressed = [] count = 1 for i in range(1, len(s) + 1): if i < len(s) and s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s def process_test_cases(T, test_cases): results = [] for s in test_cases: results.append(compress_string(s)) return results"},{"question":"def update_inventory(inventory_list, transactions): Updates the inventory based on provided transactions. Args: inventory_list: List of tuples, where each tuple contains two integers, representing gadget id and its quantity. transactions: List of tuples, where each tuple contains two integers, representing gadget id and change in stock quantity. Returns: List of tuples representing the final inventory state, sorted by gadget id. >>> update_inventory([(1, 10), (2, 20), (3, 30)], [(1, -5), (2, -10), (3, 5), (1, 3), (2, -15)]) [(1, 8), (2, 0), (3, 35)] >>> update_inventory([(1, 10), (2, 20)], []) [(1, 10), (2, 20)] >>> update_inventory([(1, 10), (2, 20), (3, 5)], [(1, -20), (2, -30), (3, -10)]) [(1, 0), (2, 0), (3, 0)] >>> update_inventory([(1, 10)], [(2, 5)]) [(1, 10), (2, 5)] >>> update_inventory([(1, 10)], [(1, -15)]) [(1, 0)]","solution":"def update_inventory(inventory_list, transactions): Updates the inventory based on provided transactions. Args: inventory_list: List of tuples, where each tuple contains two integers, representing gadget id and its quantity. transactions: List of tuples, where each tuple contains two integers, representing gadget id and change in stock quantity. Returns: List of tuples representing the final inventory state, sorted by gadget id. # Create a dictionary for quick lookups and updates inventory = {id: quantity for id, quantity in inventory_list} # Apply each transaction to the inventory for id, change in transactions: if id in inventory: inventory[id] = max(0, inventory[id] + change) else: inventory[id] = max(0, change) # Handle case when a new id is introduced # Sort the final inventory by gadget id final_inventory = sorted(inventory.items()) return final_inventory"},{"question":"MOD = 1000000007 def generalized_fibonacci(F1, F2, n): Compute the nth number in the generalized Fibonacci sequence starting with F1 and F2. >>> generalized_fibonacci(1, 1, 5) 5 >>> generalized_fibonacci(3, 7, 4) 17 pass def solve_generalized_fibonacci(test_cases): Solve generalized Fibonacci sequence for multiple test cases. >>> solve_generalized_fibonacci([(1, 1, 5), (3, 7, 4), (0, 1, 10)]) [5, 17, 34] >>> solve_generalized_fibonacci([(2, 3, 6), (1, 2, 7)]) [21, 21] pass def read_input(): Read input for the generalized Fibonacci sequence problem. This function will read from input, which should be replaced with an input function if used in a real scenario. T = int(input()) test_cases = [] for _ in range(T): F1, F2, n = map(int, input().split()) test_cases.append((F1, F2, n)) return test_cases","solution":"MOD = 1000000007 def generalized_fibonacci(F1, F2, n): if n == 1: return F1 % MOD elif n == 2: return F2 % MOD dp = [0] * (n + 1) dp[1] = F1 dp[2] = F2 for i in range(3, n + 1): dp[i] = (dp[i-1] + dp[i-2]) % MOD return dp[n] def solve_generalized_fibonacci(test_cases): results = [] for F1, F2, n in test_cases: results.append(generalized_fibonacci(F1, F2, n)) return results # Read input for testing purposes (it should be replaced with input function if used in a real scenario) def read_input(): T = int(input()) test_cases = [] for _ in range(T): F1, F2, n = map(int, input().split()) test_cases.append((F1, F2, n)) return test_cases"},{"question":"def max_unique_flowers(P: int, blooming_times: List[int]) -> Tuple[int, List[int]]: Returns the maximum number of unique flowers that can be photographed and their blooming times. :param P: int: Total time in seconds Yui has in the rainforest. :param blooming_times: List[int]: List of blooming times in seconds past midnight. :return: Tuple[int, List[int]]: (max number of unique flowers, list of blooming times in ascending order) def process_input(input_data: str) -> str: Processes the input data and returns the results in the specified format. :param input_data: str: Input data as a string. :return: str: Output results in the specified format. from max_unique_flowers import max_unique_flowers from process_input import process_input def test_max_unique_flowers(): # Test case from the example assert max_unique_flowers(3600, [3600, 7200, 10800, 14400, 18000]) == (1, [3600]) assert max_unique_flowers(1800, [300, 1000, 1700]) == (2, [300, 1000]) # Additional test cases assert max_unique_flowers(10000, [3000, 4000, 5000]) == (2, [3000, 4000]) assert max_unique_flowers(2000, [1000, 3000, 5000]) == (1, [1000]) assert max_unique_flowers(6000, [1000, 2000, 3000, 4000, 5000, 6000]) == (3, [1000, 2000, 3000]) def test_process_input(): input_data = \\"2n3600 5n3600n7200n10800n14400n18000n1800 3n300n1000n1700n\\" expected_output = \\"1n3600n2n300 1000\\" assert process_input(input_data) == expected_output input_data = \\"1n10000 3n3000n4000n5000n\\" expected_output = \\"2n3000 4000\\" assert process_input(input_data) == expected_output input_data = \\"1n6000 6n1000n2000n3000n4000n5000n6000n\\" expected_output = \\"3n1000 2000 3000\\" assert process_input(input_data) == expected_output","solution":"def max_unique_flowers(P, blooming_times): Returns the maximum number of unique flowers that can be photographed and their blooming times. :param P: int: Total time in seconds Yui has in the rainforest. :param blooming_times: List[int]: List of blooming times in seconds past midnight. :return: Tuple[int, List[int]]: (max number of unique flowers, list of blooming times in ascending order) count = 0 times = [] for time in blooming_times: if P >= time: count += 1 times.append(time) P -= time return count, times def process_input(input_data): datasets = input_data.strip().split('n') num_datasets = int(datasets[0]) results = [] i = 1 for _ in range(num_datasets): P, Q = map(int, datasets[i].split()) blooming_times = list(map(int, datasets[i + 1:i + Q + 1])) count, times = max_unique_flowers(P, blooming_times) results.append(f\\"{count}n{' '.join(map(str, times))}\\") i += Q + 1 return \\"n\\".join(results)"},{"question":"def all_characters_distinct(s: str) -> str: Determines if all characters in the string are distinct. Parameters: s (str): The input string to evaluate. Returns: str: \\"YES\\" if all characters are distinct, \\"NO\\" otherwise. >>> all_characters_distinct(\\"world\\") \\"YES\\" >>> all_characters_distinct(\\"hello\\") \\"NO\\" >>> all_characters_distinct(\\"aaaaa\\") \\"NO\\" >>> all_characters_distinct(\\"abcdefghi\\") \\"YES\\" >>> all_characters_distinct(\\"abcadefgh\\") \\"NO\\" >>> all_characters_distinct(\\"a\\") \\"YES\\" >>> all_characters_distinct(\\"\\") \\"YES\\" >>> all_characters_distinct(\\"abcdefghijklmnopqrstuvwxyz\\"*3 + \\"a\\") \\"NO\\" >>> all_characters_distinct(\\"abcdefghijklmnopqrstuvwxyz\\"*3 + \\"z\\") \\"NO\\"","solution":"def all_characters_distinct(s): Determines if all characters in the string are distinct. Parameters: s (str): The input string to evaluate. Returns: str: \\"YES\\" if all characters are distinct, \\"NO\\" otherwise. return \\"YES\\" if len(set(s)) == len(s) else \\"NO\\""},{"question":"def recommend_friends(N: int, M: int, friendships: List[Tuple[int, int]]) -> List[int]: Recommend friends for each user based on the shortest path in graph theory. >>> recommend_friends(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) [3, 4, 1, 2, 3] >>> recommend_friends(3, 0, []) [-1, -1, -1] >>> recommend_friends(4, 6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) [-1, -1, -1, -1] >>> recommend_friends(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) [3, 4, 1, 2] >>> recommend_friends(5, 4, [(1, 2), (1, 3), (1, 4), (1, 5)]) [-1, 3, 2, 2, 2]","solution":"def recommend_friends(N, M, friendships): from collections import defaultdict, deque # Initialize adjacency list to represent the graph adj_list = defaultdict(list) # Fill the adjacency list with the friendships for u, v in friendships: adj_list[u].append(v) adj_list[v].append(u) # Function to find all friends of friends two steps away who are not already friends def find_friends_of_friends(user): visited = set() queue = deque([(user, 0)]) visited.add(user) suggestions = set() while queue: current_user, depth = queue.popleft() if depth == 2: suggestions.add(current_user) continue for neighbor in adj_list[current_user]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, depth + 1)) # Remove direct friends and the user itself from suggestions suggestions -= set(adj_list[user]) suggestions -= {user} return suggestions # Function to count the number of connections def count_connections(user): return len(adj_list[user]) recommendations = [] for user in range(1, N + 1): friends_of_friends = find_friends_of_friends(user) if not friends_of_friends: recommendations.append(-1) else: # Find the friend with the highest average number of connections recommended_friend = max(friends_of_friends, key=lambda foaf: count_connections(foaf)) recommendations.append(recommended_friend) return recommendations # Example usage: N, M = 5, 4 friendships = [(1, 2), (2, 3), (3, 4), (4, 5)] print(recommend_friends(N, M, friendships)) # Output: [3, 4, 1, 2, 3]"},{"question":"def sum_of_unique_numbers(sequence): Takes a sequence of integers and returns the sum of all unique numbers. The input sequence is terminated by a zero, which should not be included in the sum. :param sequence: list of integers :return: sum of unique numbers pass # Unit Tests def test_sum_of_unique_numbers_normal_case(): assert sum_of_unique_numbers([3, 1, 4, 3, 2, 0]) == 10 def test_sum_of_unique_numbers_all_unique(): assert sum_of_unique_numbers([7, 8, 3, 5, 0]) == 23 def test_sum_of_unique_numbers_all_duplicates(): assert sum_of_unique_numbers([2, 2, 2, 2, 0]) == 2 def test_sum_of_unique_numbers_start_with_zero(): assert sum_of_unique_numbers([0, 3, 1, 4]) == 0 def test_sum_of_unique_numbers_empty_list(): assert sum_of_unique_numbers([0]) == 0 def test_sum_of_unique_numbers_with_large_numbers(): assert sum_of_unique_numbers([100, 200, 300, 100, 200, 0]) == 600","solution":"def sum_of_unique_numbers(sequence): Takes a sequence of integers and returns the sum of all unique numbers. The input sequence is terminated by a zero, which should not be included in the sum. :param sequence: list of integers :return: sum of unique numbers unique_numbers = set() for number in sequence: if number == 0: break unique_numbers.add(number) return sum(unique_numbers)"},{"question":"def can_partition(X: int) -> str: Determines if it is possible to partition the set of integers from 1 to 2X into exactly X subsets such that the sum of the numbers in each subset is the same. >>> can_partition(4) \\"YES\\" >>> can_partition(3) \\"NO\\"","solution":"def can_partition(X): Determines if it is possible to partition the set of integers from 1 to 2X into exactly X subsets such that the sum of the numbers in each subset is the same. return \\"YES\\" if X % 2 == 0 else \\"NO\\""},{"question":"def can_transform(A: str, B: str) -> str: Determine if string A can be transformed into string B by performing the same shift on each character of A. >>> can_transform(\\"abc\\", \\"def\\") \\"Yes\\" >>> can_transform(\\"abc\\", \\"dea\\") \\"No\\" >>> can_transform(\\"xyz\\", \\"abc\\") \\"Yes\\" >>> can_transform(\\"abcd\\", \\"abee\\") \\"No\\" >>> can_transform(\\"a\\" * 1000, \\"b\\" * 1000) \\"Yes\\" >>> can_transform(\\"a\\" * 999 + \\"b\\", \\"b\\" * 1000) \\"No\\"","solution":"def can_transform(A, B): Determine if string A can be transformed into string B by performing the same shift on each character of A. if len(A) != len(B): return \\"No\\" shift = (ord(B[0]) - ord(A[0])) % 26 for a, b in zip(A, B): if (ord(b) - ord(a)) % 26 != shift: return \\"No\\" return \\"Yes\\" # Example usage: # A = \\"abc\\" # B = \\"def\\" # print(can_transform(A, B)) # Output: \\"Yes\\""},{"question":"def find_smallest_possible_minimum(N: int, array: List[int]) -> int: Find the smallest possible value of the minimum element after performing the specified operations until all elements in the array become equal. Parameters: N (int): The number of elements in the array. array (list of int): The list of non-negative integers. Returns: int: The smallest possible value of the minimum element. >>> find_smallest_possible_minimum(4, [5, 3, 8, 3]) 1 >>> find_smallest_possible_minimum(3, [7, 5, 2]) 1 >>> find_smallest_possible_minimum(5, [2, 3, 4, 5, 6]) 1 >>> find_smallest_possible_minimum(6, [1, 1, 1, 1, 1, 1]) 1 >>> find_smallest_possible_minimum(7, [14, 28, 7, 21, 35, 49, 7]) 7","solution":"def find_smallest_possible_minimum(N, array): Find the smallest possible value of the minimum element after performing the specified operations until all elements in the array become equal. Parameters: N (int): The number of elements in the array. array (list of int): The list of non-negative integers. Returns: int: The smallest possible value of the minimum element. from math import gcd from functools import reduce # Function to compute GCD of a list of numbers def find_gcd_of_list(nums): return reduce(gcd, nums) return find_gcd_of_list(array)"},{"question":"def count_adjacent_flowers(garden: List[List[str]]) -> int: Count the number of flowers ('F') that are adjacent to at least one other flower. Parameters: garden (list of list of str): A 2D grid where each element is either 'G' or 'F'. Returns: int: The number of flowers adjacent to at least one other flower. Examples: >>> count_adjacent_flowers([ ... ['F', 'G', 'F'], ... ['G', 'G', 'F'], ... ['F', 'F', 'F'] ... ]) 5 >>> count_adjacent_flowers([ ... ['G', 'G', 'G', 'G'], ... ['G', 'F', 'F', 'G'], ... ['G', 'F', 'F', 'G'], ... ['G', 'G', 'G', 'G'] ... ]) 4 >>> count_adjacent_flowers([ ... ['G', 'F', 'G'], ... ['G', 'G', 'G'], ... ['G', 'F', 'G'] ... ]) 0 >>> count_adjacent_flowers([ ... ['G', 'G', 'G'], ... ['G', 'G', 'G'], ... ['G', 'G', 'G'] ... ]) 0 >>> count_adjacent_flowers([ ... ['G', 'G', 'G'], ... ['G', 'F', 'G'], ... ['G', 'G', 'G'] ... ]) 0 >>> count_adjacent_flowers([ ... ['F', 'F', 'F'], ... ['F', 'F', 'F'], ... ['F', 'F', 'F'] ... ]) 9 >>> count_adjacent_flowers([ ... ['F', 'G', 'F'], ... ['G', 'F', 'G'], ... ['F', 'G', 'F'] ... ]) 0","solution":"def count_adjacent_flowers(garden): Count the number of flowers ('F') that are adjacent to at least one other flower. Parameters: garden (list of list of str): A 2D grid where each element is either 'G' or 'F'. Returns: int: The number of flowers adjacent to at least one other flower. R = len(garden) C = len(garden[0]) def is_flower_adjacent(i, j): # Check left if i > 0 and garden[i-1][j] == 'F': return True # Check right if i < R-1 and garden[i+1][j] == 'F': return True # Check up if j > 0 and garden[i][j-1] == 'F': return True # Check down if j < C-1 and garden[i][j+1] == 'F': return True return False count = 0 for i in range(R): for j in range(C): if garden[i][j] == 'F' and is_flower_adjacent(i, j): count += 1 return count"},{"question":"def max_speed_difference(N: int, speeds: List[int]) -> int: Returns the maximum speed difference where the slower hedgehog is behind the faster hedgehog. If no such pair exists, returns 0. Args: N (int): The number of hedgehogs. speeds (List[int]): List of speeds of the hedgehogs. Returns: int: The maximum speed difference. Examples: >>> max_speed_difference(5, [5, 3, 8, 2, 7]) 5 >>> max_speed_difference(3, [9, 8, 3]) 0 pass import pytest def test_example_1(): assert max_speed_difference(5, [5, 3, 8, 2, 7]) == 5 def test_example_2(): assert max_speed_difference(3, [9, 8, 3]) == 0 def test_example_3(): assert max_speed_difference(4, [1, 2, 3, 4]) == 3 def test_single_max_difference(): assert max_speed_difference(2, [1, 1000]) == 999 def test_no_valid_difference(): assert max_speed_difference(4, [10, 9, 8, 7]) == 0 def test_multiple_correct_differences(): assert max_speed_difference(6, [5, 1, 3, 4, 2, 10]) == 9 def test_all_speeds_same(): assert max_speed_difference(3, [5, 5, 5]) == 0 def test_minimal_case(): assert max_speed_difference(2, [100, 1]) == 0","solution":"def max_speed_difference(N, speeds): Returns the maximum speed difference where the slower hedgehog is behind the faster hedgehog. If no such pair exists, returns 0. max_diff = 0 min_speed = speeds[0] for j in range(1, N): if speeds[j] > min_speed: max_diff = max(max_diff, speeds[j] - min_speed) min_speed = min(min_speed, speeds[j]) return max_diff"},{"question":"def is_interesting(A: str) -> str: Determines if a string A is interesting. A string is considered interesting if the reverse of the string is equal to the original string itself. >>> is_interesting(\\"level\\") \\"Interesting\\" >>> is_interesting(\\"hello\\") \\"Not Interesting\\"","solution":"def is_interesting(A): Determines if a string A is interesting. A string is considered interesting if the reverse of the string is equal to the original string itself. Args: A (str): input string Returns: str: \\"Interesting\\" if the string is a palindrome, otherwise \\"Not Interesting\\" if A == A[::-1]: return \\"Interesting\\" else: return \\"Not Interesting\\""},{"question":"def min_trucks_to_transport_crops(n: int, C: int, capacities: List[int]) -> Tuple[int, int]: Determines the minimum number of trucks needed to transport the maximum amount of crops, and the total amount of crops transported. >>> min_trucks_to_transport_crops(3, 100, [50, 60, 70]) (2, 100) >>> min_trucks_to_transport_crops(5, 200, [40, 60, 80, 20, 100]) (3, 200)","solution":"def min_trucks_to_transport_crops(n, C, capacities): Determines the minimum number of trucks needed to transport the maximum amount of crops, and the total amount of crops transported. Parameters: n (int): The number of trucks. C (int): The total amount of crops that need to be transported. capacities (list of int): The load capacity of each truck. Returns: (int, int): The minimum number of trucks required to transport the maximum amount of crops, and the total amount of crops transported. capacities.sort(reverse=True) total_crops = 0 trucks_used = 0 for capacity in capacities: if total_crops >= C: break total_crops += capacity trucks_used += 1 return trucks_used, min(total_crops, C)"},{"question":"def max_difference_between_any_two_elements(n, m, array, queries): Returns the maximum difference between any two elements in the specified subarrays for each query. Parameters: n (int): The number of elements in the array. m (int): The number of queries. array (list of int): The list of integers representing the array. queries (list of tuples of int): The list of queries, each described by a tuple (l, r). Returns: list of int: A list of results for each query. >>> max_difference_between_any_two_elements(7, 3, [3, 1, 4, 1, 5, 9, 2], [(1, 3), (4, 6), (2, 7)]) [3, 8, 8] >>> max_difference_between_any_two_elements(5, 2, [1, 2, 3, 4, 5], [(1, 5), (2, 4)]) [4, 2] >>> max_difference_between_any_two_elements(4, 1, [5, 4, 3, 2], [(1, 3)]) [2] >>> max_difference_between_any_two_elements(1, 1, [7], [(1, 1)]) [0] >>> max_difference_between_any_two_elements(6, 3, [10, 20, 30, 40, 50, 60], [(1, 6), (1, 3), (4, 6)]) [50, 20, 20]","solution":"def max_difference_between_any_two_elements(n, m, array, queries): Returns the maximum difference between any two elements in the specified subarrays for each query. Parameters: n (int): The number of elements in the array. m (int): The number of queries. array (list of int): The list of integers representing the array. queries (list of tuples of int): The list of queries, each described by a tuple (l, r). Returns: list of int: A list of results for each query. results = [] for l, r in queries: subarray = array[l-1:r] max_diff = max(subarray) - min(subarray) results.append(max_diff) return results"},{"question":"def longest_even_subarray(arr): Returns the length of the longest subarray that contains only even numbers. pass def process_test_cases(test_cases): Processes multiple test cases where each test case provides an array. Returns a list of results. results = [] for n, arr in test_cases: results.append(longest_even_subarray(arr)) return results if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): n = int(data[index]) index += 1 arr = list(map(int, data[index:index + n])) index += n test_cases.append((n, arr)) results = process_test_cases(test_cases) for result in results: print(result)","solution":"def longest_even_subarray(arr): Returns the length of the longest subarray that contains only even numbers. max_length = 0 current_length = 0 for num in arr: if num % 2 == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length def process_test_cases(test_cases): Processes multiple test cases where each test case provides an array. Returns a list of results. results = [] for n, arr in test_cases: results.append(longest_even_subarray(arr)) return results"},{"question":"def weighted_average(N, BW): Calculate the weighted average of a sequence. Parameters: N (int): Number of integers in the sequence BW (list): List of tuples, where each tuple contains an integer and its weight Returns: float: The weighted average of the sequence","solution":"def weighted_average(N, BW): Calculate the weighted average of a sequence. Parameters: N (int): Number of integers in the sequence BW (list): List of tuples, where each tuple contains an integer and its weight Returns: float: The weighted average of the sequence total_weighted_sum = 0 total_weight = 0 for B, W in BW: total_weighted_sum += B * W total_weight += W return total_weighted_sum / total_weight def main(): import sys input = sys.stdin.read data = input().strip().split('n') N = int(data[0]) BW = [tuple(map(int, line.split())) for line in data[1:]] result = weighted_average(N, BW) print(result) if __name__ == \\"__main__\\": main()"},{"question":"def maximum_contiguous_subsequence_length(n: int, m: int, sequence1: List[int], sequence2: List[int]) -> int: Determines the maximum length of a contiguous subsequence of prices that is present in both sequences. >>> maximum_contiguous_subsequence_length(5, 6, [8, 12, 16, 20, 24], [16, 20, 24, 28, 32, 36]) 3 >>> maximum_contiguous_subsequence_length(4, 4, [5, 10, 15, 20], [25, 30, 35, 40]) 0 >>> maximum_contiguous_subsequence_length(7, 8, [3, 7, 11, 15, 19, 23, 27], [10, 7, 11, 15, 19, 35, 23, 40]) 4","solution":"def maximum_contiguous_subsequence_length(n, m, sequence1, sequence2): # Use dynamic programming to find the longest common subarray dp = [[0] * (m + 1) for _ in range(n + 1)] max_length = 0 for i in range(1, n + 1): for j in range(1, m + 1): if sequence1[i - 1] == sequence2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) return max_length"},{"question":"def product_except_self(arr): Returns a new array such that each element at index 'i' is the product of all the numbers in the original array except the one at 'i'. Args: arr (List[int]): Array of integers. Returns: List[int]: A new array where each element at index 'i' is the product of all the numbers in the array except the one at 'i'. Examples: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5]) [1] >>> product_except_self([1, 0, 3, 4]) [0, 12, 0, 0] >>> product_except_self([1, -2, 3, -4]) [24, -12, 8, -6] >>> product_except_self([1, 2, 0, 4, 5]) [0, 0, 40, 0, 0]","solution":"def product_except_self(arr): Returns a new array such that each element at index 'i' is the product of all the numbers in the original array except the one at 'i'. n = len(arr) if n == 0: return [] left_products = [1] * n right_products = [1] * n output = [1] * n for i in range(1, n): left_products[i] = left_products[i - 1] * arr[i - 1] for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * arr[i + 1] for i in range(n): output[i] = left_products[i] * right_products[i] return output"},{"question":"def max_subarray(nums): This function finds the contiguous subarray within an array that has the largest sum, and returns that subarray. >>> max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) [4, -1, 2, 1] >>> max_subarray([-1, -2, -3, -4]) [-1] >>> max_subarray([1, 2, 3, 4]) [1, 2, 3, 4] >>> max_subarray([5]) [5] >>> max_subarray([-5]) [-5] >>> max_subarray([]) []","solution":"def max_subarray(nums): This function finds the contiguous subarray within an array that has the largest sum, and returns that subarray. if not nums: return [] max_sum = current_sum = nums[0] start = end = temp_start = 0 for i in range(1, len(nums)): if current_sum < 0: current_sum = nums[i] temp_start = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return nums[start:end + 1]"},{"question":"def min_max_height_difference(heights: List[int]) -> int: Given a list of integers representing the heights, find the minimum possible value of the maximum height difference within any contiguous subgroup of students. >>> min_max_height_difference([1, 5, 3, 4, 2]) 1 >>> min_max_height_difference([10, 13, 15]) 2 >>> min_max_height_difference([100, 100, 100, 100]) 0 >>> min_max_height_difference([1, 10, 100, 1000]) 9 >>> min_max_height_difference([6, 9, 5, 7, 3]) 1 >>> min_max_height_difference([10, 9, 8, 7]) 1","solution":"def min_max_height_difference(heights): Given a list of integers representing the heights, find the minimum possible value of the maximum height difference within any contiguous subgroup of students. n = len(heights) heights.sort() min_diff = float('inf') for i in range(1, n): min_diff = min(min_diff, heights[i] - heights[i - 1]) return min_diff"},{"question":"def maxMonstersDefeated(n: int, p: int, t: int, d: int, h: List[int]) -> int: Determine the maximum number of monsters Harry can defeat given the initial spell power, spell casting time, and spell power decrement factor. Parameters: n (int): The number of monsters. p (int): The initial spell power. t (int): The time (in seconds) it takes to cast each spell. d (int): The decrement factor for spell power per second. h (List[int]): A list of integers representing the health points of the monsters. Returns: int: The maximum number of monsters Harry can defeat. >>> maxMonstersDefeated(5, 10, 2, 1, [3, 8, 9, 5, 2]) 3 >>> maxMonstersDefeated(1, 10, 2, 1, [15]) 0 >>> maxMonstersDefeated(4, 50, 3, 2, [5, 10, 15, 20]) 4 >>> maxMonstersDefeated(3, 5, 2, 5, [10, 15, 20]) 0 >>> maxMonstersDefeated(5, 1000000, 2, 1, [10, 20, 30, 40, 50]) 5 >>> maxMonstersDefeated(4, 10, 1, 3, [3, 5, 7, 9]) 2","solution":"from typing import List def maxMonstersDefeated(n: int, p: int, t: int, d: int, h: List[int]) -> int: h.sort() defeated_count = 0 for i in range(n): current_time = (defeated_count + 1) * t current_power = p - (current_time - 1) * d if current_power >= h[i]: defeated_count += 1 else: break return defeated_count"},{"question":"from typing import List def count_distinct_subsequences(s: str, n: int) -> int: Returns the number of distinct subsequences of length n in string s. >>> count_distinct_subsequences(\\"abc\\", 2) 3 >>> count_distinct_subsequences(\\"abc\\", 3) 1 >>> count_distinct_subsequences(\\"aaa\\", 2) 1 >>> count_distinct_subsequences(\\"abcdefghij\\", 5) 252 pass def process_input(input_data: List[str]) -> List[int]: Process the input data and output the number of distinct subsequences for each dataset. >>> process_input([\\"abc 2\\", \\"abc 3\\", \\"aaa 2\\", \\"abcdefghij 5\\", \\"0 0\\"]) [3, 1, 1, 252] pass","solution":"from itertools import combinations def count_distinct_subsequences(s, n): Returns the number of distinct subsequences of length n in string s. subsequences = set(combinations(s, n)) return len(subsequences) def process_input(input_data): Process the input data and output the number of distinct subsequences for each dataset. results = [] for line in input_data: if line == \\"0 0\\": break s, n = line.split() n = int(n) results.append(count_distinct_subsequences(s, n)) return results"},{"question":"def number_of_groups(K: int, C: int) -> int: Given K types of candies and C total number of candies, determine the number of completely filled groups Rikka can form. :param K: int - the number of types of candies :param C: int - the total number of candies :return: int - number of completely filled groups >>> number_of_groups(3, 15) 5 >>> number_of_groups(4, 9) 2 >>> number_of_groups(1, 9) 9 >>> number_of_groups(5, 5) 1 >>> number_of_groups(5, 0) 0 >>> number_of_groups(100000, 1000000000) 10000 >>> number_of_groups(100000, 999999999) 9999 >>> number_of_groups(0, 10) 0","solution":"def number_of_groups(K, C): Given K types of candies and C total number of candies, determine the number of completely filled groups Rikka can form. :param K: int - the number of types of candies :param C: int - the total number of candies :return: int - number of completely filled groups if K == 0: return 0 return C // K"},{"question":"def longest_subarray_with_two_distinct(nums: List[int]) -> int: Find the length of the longest subarray that contains no more than two distinct numbers, where the distinct numbers appear consecutively. Parameters: nums (List[int]): A list of integers Returns: int: The length of the longest subarray Examples: >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 3, 4, 2]) 4 >>> longest_subarray_with_two_distinct([4, 4, 4, 4, 4]) 5 >>> longest_subarray_with_two_distinct([1, 2, 3, 1, 2, 2, 2, 3, 3, 3]) 6 >>> longest_subarray_with_two_distinct([]) 0 >>> longest_subarray_with_two_distinct([1]) 1 >>> longest_subarray_with_two_distinct([5, 5, 5, 5, 5]) 5 >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 1]) 5 >>> longest_subarray_with_two_distinct([1, 2] * 50000 + [3]) 100000","solution":"def longest_subarray_with_two_distinct(nums): Returns the length of the longest subarray that contains no more than two distinct numbers. n = len(nums) if n == 0: return 0 # Dictionary to store count of elements counts = {} left = 0 max_length = 0 for right in range(n): # Add the right element to the dictionary if nums[right] in counts: counts[nums[right]] += 1 else: counts[nums[right]] = 1 # While we have more than 2 distinct elements, shrink the window while len(counts) > 2: counts[nums[left]] -= 1 if counts[nums[left]] == 0: del counts[nums[left]] left += 1 # Update the max_length max_length = max(max_length, right - left + 1) return max_length"},{"question":"def maxProfit(prices: List[int]) -> int: Calculate the maximum profit achievable with at most two transactions on a given list of stock prices. >>> maxProfit([3, 3, 5, 0, 0, 3, 1, 4]) 6 >>> maxProfit([1, 2, 3, 4, 5, 6, 7]) 6 >>> maxProfit([7, 6, 4, 3, 1]) 0","solution":"def maxProfit(prices): n = len(prices) if n <= 1: return 0 first_buy = [0] * n second_buy = [0] * n min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) first_buy[i] = max(first_buy[i-1], prices[i] - min_price) max_price = prices[-1] for i in range(n-2, -1, -1): max_price = max(max_price, prices[i]) second_buy[i] = max(second_buy[i+1], max_price - prices[i]) max_profit = 0 for i in range(n): max_profit = max(max_profit, first_buy[i] + second_buy[i]) return max_profit"},{"question":"def compress_string(s: str) -> str: Compress the string by counting consecutive characters. Return the compressed string if it is shorter than the original string; otherwise, return the original string. >>> compress_string(\\"aabcccccaaa\\") 'a2b1c5a3' >>> compress_string(\\"abcdef\\") 'abcdef' >>> compress_string(\\"a\\") 'a' >>> compress_string(\\"bbbbbb\\") 'b6' >>> compress_string(\\"\\") '' >>> compress_string(\\"abcdefghij\\") 'abcdefghij' >>> compress_string(\\"aabbcc\\") 'aabbcc' >>> compress_string(\\"aaAAaaAA\\") 'aaAAaaAA' >>> compress_string(\\"AaaBBb\\") 'AaaBBb' >>> compress_string(\\"a\\" * 100000) 'a100000'","solution":"def compress_string(s): Compress the string by counting consecutive characters. Return the compressed string if it is shorter than the original string; otherwise, return the original string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) compressed.append(str(count)) count = 1 compressed.append(s[-1]) compressed.append(str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"from typing import List def transform_string_to_good(s: str) -> int: Transform a string into a \\"good\\" string by removing the minimum number of characters. A string is considered \\"good\\" if no two adjacent characters are the same. Args: s (str): The input string. Returns: int: The length of the transformed \\"good\\" string. >>> transform_string_to_good(\\"aabcc\\") 3 >>> transform_string_to_good(\\"aaab\\") 2 >>> transform_string_to_good(\\"abcde\\") 5 >>> transform_string_to_good(\\"aaaa\\") 1 >>> transform_string_to_good(\\"ababa\\") 5 >>> transform_string_to_good(\\"aabbaabb\\") 4 >>> transform_string_to_good(\\"abcabcabc\\") 9 pass def length_of_good_strings(test_cases: List[str]) -> List[int]: Compute the lengths of transformed \\"good\\" strings for each test case. Args: test_cases (List[str]): A list of input strings. Returns: List[int]: A list of lengths of the transformed \\"good\\" strings. >>> length_of_good_strings([\\"aabcc\\", \\"aaab\\", \\"abcde\\", \\"aaaa\\", \\"ababa\\", \\"aabbaabb\\", \\"abcabcabc\\"]) [3, 2, 5, 1, 5, 4, 9] pass","solution":"def transform_string_to_good(s): # Initialize the result string result = \\"\\" # Iterate through the string for char in s: # If result is empty or the last character of result is not the same as current character, append it to the result if not result or result[-1] != char: result += char # Return the length of the transformed string return len(result) def length_of_good_strings(test_cases): results = [] for s in test_cases: results.append(transform_string_to_good(s)) return results"},{"question":"def rotate_matrix(input_string: str) -> str: Rotates a given square matrix clockwise by 90 degrees. Args: input_string (str): A formatted string representing the matrix size and its elements. Returns: str: A formatted string representing the rotated matrix. Example: >>> rotate_matrix('''3n1 2 3n4 5 6n7 8 9''') '7 4 1n8 5 2n9 6 3' >>> rotate_matrix('''4n1 2 3 4n5 6 7 8n9 10 11 12n13 14 15 16''') '13 9 5 1n14 10 6 2n15 11 7 3n16 12 8 4' pass def test_rotate_3x3_matrix(): input_matrix = '''3 1 2 3 4 5 6 7 8 9''' expected_output = '''7 4 1 8 5 2 9 6 3''' assert rotate_matrix(input_matrix) == expected_output def test_rotate_4x4_matrix(): input_matrix = '''4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16''' expected_output = '''13 9 5 1 14 10 6 2 15 11 7 3 16 12 8 4''' assert rotate_matrix(input_matrix) == expected_output def test_rotate_1x1_matrix(): input_matrix = '''1 42''' expected_output = '''42''' assert rotate_matrix(input_matrix) == expected_output def test_rotate_2x2_matrix(): input_matrix = '''2 1 2 3 4''' expected_output = '''3 1 4 2''' assert rotate_matrix(input_matrix) == expected_output def test_rotate_5x5_matrix(): input_matrix = '''5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25''' expected_output = '''21 16 11 6 1 22 17 12 7 2 23 18 13 8 3 24 19 14 9 4 25 20 15 10 5''' assert rotate_matrix(input_matrix) == expected_output","solution":"def rotate_matrix_clockwise(matrix): Rotates a given n x n matrix clockwise by 90 degrees. :param matrix: List of lists representing the n x n matrix :return: New n x n matrix rotated clockwise by 90 degrees n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix def read_matrix_input(input_string): Reads the matrix from the given input string :param input_string: A string containing the matrix size and its elements :return: a list of lists representing the square matrix input_lines = input_string.strip().split(\\"n\\") n = int(input_lines[0]) matrix = [list(map(int, line.split())) for line in input_lines[1:]] return matrix def matrix_to_string(matrix): Converts the matrix to a formatted string :param matrix: A list of lists representing the square matrix :return: A string representing the matrix return 'n'.join(' '.join(map(str, row)) for row in matrix) def rotate_matrix(input_string): Rotates the matrix described in the input string clockwise by 90 degrees :param input_string: A string containing the matrix size and its elements :return: A formatted string representing the rotated matrix matrix = read_matrix_input(input_string) rotated_matrix = rotate_matrix_clockwise(matrix) return matrix_to_string(rotated_matrix)"},{"question":"def sum_of_evens_and_product_of_odds(numbers): Return the sum of all even numbers and the product of all odd numbers in the list. :param numbers: List of integers :return: Tuple containing sum of even numbers and product of odd numbers >>> sum_of_evens_and_product_of_odds([2, 3, 4, 5, 6]) == (12, 15) >>> sum_of_evens_and_product_of_odds([1, 3, 5, 7]) == (0, 105) >>> sum_of_evens_and_product_of_odds([2, 4, 6, 8]) == (20, 1) >>> sum_of_evens_and_product_of_odds([]) == (0, 1) >>> sum_of_evens_and_product_of_odds([1000000000, 1]) == (1000000000, 1) >>> sum_of_evens_and_product_of_odds([2]) == (2, 1) >>> sum_of_evens_and_product_of_odds([1]) == (0, 1)","solution":"def sum_of_evens_and_product_of_odds(numbers): Return the sum of all even numbers and the product of all odd numbers in the list. :param numbers: List of integers :return: Tuple containing sum of even numbers and product of odd numbers sum_evens = 0 product_odds = 1 has_even = False has_odd = False for num in numbers: if num % 2 == 0: sum_evens += num has_even = True else: product_odds *= num has_odd = True if not has_even: sum_evens = 0 if not has_odd: product_odds = 1 return sum_evens, product_odds"},{"question":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def build_tree(N, parents): nodes = [TreeNode(i) for i in range(1, N+1)] root = None for i, p in enumerate(parents): if p == -1: root = nodes[i] else: if nodes[p-1].left is None: nodes[p-1].left = nodes[i] else: nodes[p-1].right = nodes[i] return root def check_balanced_tree(root): def height_and_balance(node): if not node: return 0, True left_height, left_balanced = height_and_balance(node.left) right_height, right_balanced = height_and_balance(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, balanced _, is_balanced = height_and_balance(root) return is_balanced def is_balanced_binary_tree(N, parents): Determine if the given binary tree is a height-balanced binary tree. Args: N (int): Number of nodes. parents (List[int]): List of parent nodes. Returns: str: \\"Yes\\" if the binary tree is height-balanced, otherwise \\"No\\". >>> is_balanced_binary_tree(5, [-1, 1, 1, 2, 2]) \\"Yes\\" >>> is_balanced_binary_tree(3, [-1, 1, 2]) \\"No\\"","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def build_tree(N, parents): nodes = [TreeNode(i) for i in range(1, N+1)] root = None for i, p in enumerate(parents): if p == -1: root = nodes[i] else: if nodes[p-1].left is None: nodes[p-1].left = nodes[i] else: nodes[p-1].right = nodes[i] return root def check_balanced_tree(root): def height_and_balance(node): if not node: return 0, True left_height, left_balanced = height_and_balance(node.left) right_height, right_balanced = height_and_balance(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, balanced _, is_balanced = height_and_balance(root) return is_balanced def is_balanced_binary_tree(N, parents): root = build_tree(N, parents) if check_balanced_tree(root): return \\"Yes\\" else: return \\"No\\""},{"question":"from typing import List def fibonacci_sequence(N: int) -> List[int]: Generate the first N terms of the Fibonacci sequence. >>> fibonacci_sequence(1) [0] >>> fibonacci_sequence(2) [0, 1] >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(8) [0, 1, 1, 2, 3, 5, 8, 13] def generate_fibonacci_sequences(T: int, test_cases: List[int]) -> List[List[int]]: Generate the first N terms of the Fibonacci sequence for each test case. >>> generate_fibonacci_sequences(2, [5, 8]) [[0, 1, 1, 2, 3], [0, 1, 1, 2, 3, 5, 8, 13]] >>> generate_fibonacci_sequences(3, [1, 2, 3]) [[0], [0, 1], [0, 1, 1]]","solution":"def fibonacci_sequence(N): Returns the first N terms of the Fibonacci sequence. if N == 0: return [] elif N == 1: return [0] elif N == 2: return [0, 1] fib = [0, 1] for i in range(2, N): fib.append(fib[-1] + fib[-2]) return fib def generate_fibonacci_sequences(T, test_cases): results = [] for N in test_cases: results.append(fibonacci_sequence(N)) return results"},{"question":"def mow_grass(n: int, m: int, garden: List[List[int]]) -> List[List[int]]: Mow the grass in the garden to a height of 0 following a zig-zag pattern. Args: n (int): number of rows in the garden. m (int): number of columns in the garden. garden (List[List[int]]): initial heights of the grass in the garden. Returns: List[List[int]]: final heights of the grass after mowing. Example: >>> mow_grass(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> mow_grass(2, 4, [[3, 1, 2, 3], [0, 4, 8, 6]]) [[0, 0, 0, 0], [0, 0, 0, 0]] from mow_grass import mow_grass def test_mow_grass_3x3(): garden = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = mow_grass(3, 3, garden) expected = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert result == expected def test_mow_grass_2x4(): garden = [ [3, 1, 2, 3], [0, 4, 8, 6] ] result = mow_grass(2, 4, garden) expected = [ [0, 0, 0, 0], [0, 0, 0, 0] ] assert result == expected def test_mow_grass_1x1(): garden = [ [5] ] result = mow_grass(1, 1, garden) expected = [ [0] ] assert result == expected def test_mow_grass_3x2(): garden = [ [3, 3], [4, 4], [5, 5] ] result = mow_grass(3, 2, garden) expected = [ [0, 0], [0, 0], [0, 0] ] assert result == expected def test_mow_grass_4x4(): garden = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] result = mow_grass(4, 4, garden) expected = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] assert result == expected","solution":"def mow_grass(n, m, garden): for i in range(n): if i % 2 == 0: for j in range(m): garden[i][j] = 0 else: for j in range(m-1, -1, -1): garden[i][j] = 0 return garden"},{"question":"from typing import List def rainbow_sort(colors: List[str]) -> List[str]: Create a function rainbow_sort that takes a list of strings representing colors (\\"red\\", \\"orange\\", \\"yellow\\", \\"green\\", \\"blue\\", \\"indigo\\", \\"violet\\") as input and returns a new list with the colors sorted in the order they appear in the rainbow. Example: >>> rainbow_sort([\\"blue\\", \\"red\\", \\"yellow\\", \\"green\\", \\"blue\\", \\"violet\\"]) ['red', 'yellow', 'green', 'blue', 'blue', 'violet'] >>> rainbow_sort([\\"red\\", \\"red\\", \\"red\\"]) ['red', 'red', 'red'] >>> rainbow_sort([]) [] pass def test_rainbow_sort_basic(): assert rainbow_sort([\\"blue\\", \\"red\\", \\"yellow\\", \\"green\\", \\"blue\\", \\"violet\\"]) == [\\"red\\", \\"yellow\\", \\"green\\", \\"blue\\", \\"blue\\", \\"violet\\"] def test_rainbow_sort_single_color(): assert rainbow_sort([\\"red\\", \\"red\\", \\"red\\"]) == [\\"red\\", \\"red\\", \\"red\\"] def test_rainbow_sort_long_list(): assert rainbow_sort([\\"blue\\", \\"blue\\", \\"blue\\", \\"red\\", \\"yellow\\", \\"green\\", \\"violet\\", \\"indigo\\", \\"orange\\", \\"red\\", \\"red\\", \\"violet\\", \\"blue\\", \\"green\\"]) == [\\"red\\", \\"red\\", \\"red\\", \\"orange\\", \\"yellow\\", \\"green\\", \\"green\\", \\"blue\\", \\"blue\\", \\"blue\\", \\"blue\\", \\"indigo\\", \\"violet\\", \\"violet\\"] def test_rainbow_sort_all_colors(): assert rainbow_sort([\\"violet\\", \\"indigo\\", \\"blue\\", \\"green\\", \\"yellow\\", \\"orange\\", \\"red\\"]) == [\\"red\\", \\"orange\\", \\"yellow\\", \\"green\\", \\"blue\\", \\"indigo\\", \\"violet\\"] def test_rainbow_sort_empty(): assert rainbow_sort([]) == [] def test_rainbow_sort_single_element(): assert rainbow_sort([\\"green\\"]) == [\\"green\\"]","solution":"def rainbow_sort(colors): Sorts the list of colors in the order they appear in the rainbow. rainbow_order = { \\"red\\": 1, \\"orange\\": 2, \\"yellow\\": 3, \\"green\\": 4, \\"blue\\": 5, \\"indigo\\": 6, \\"violet\\": 7 } return sorted(colors, key=lambda color: rainbow_order[color])"},{"question":"from typing import List def can_jump(nums: List[int]) -> str: Determine if it is possible to reach the last index starting from the first index. >>> can_jump([2, 3, 1, 1, 4]) \\"Yes\\" >>> can_jump([3, 2, 1, 0, 4]) \\"No\\" def test_can_jump(): assert can_jump([2, 3, 1, 1, 4]) == \\"Yes\\" assert can_jump([3, 2, 1, 0, 4]) == \\"No\\" assert can_jump([0]) == \\"Yes\\" # single element assert can_jump([2, 0, 0]) == \\"Yes\\" assert can_jump([1, 1, 1, 1]) == \\"Yes\\" assert can_jump([1, 1, 0, 1]) == \\"No\\" assert can_jump([10**5] * 10**4) == \\"Yes\\" assert can_jump([0, 1, 2, 3, 4]) == \\"No\\" def test_edge_cases(): assert can_jump([5, 4, 3, 2, 1, 0, 4, 2]) == \\"No\\" assert can_jump([1, 2, 3]) == \\"Yes\\" assert can_jump([2, 0, 2, 0, 1]) == \\"Yes\\" assert can_jump([1, 2, 3, 0, 4]) == \\"Yes\\" assert can_jump([1, 3, 0, 0, 0, 2, 1]) == \\"No\\"","solution":"from typing import List def can_jump(nums: List[int]) -> str: max_reachable = 0 n = len(nums) for i in range(n): if i > max_reachable: return \\"No\\" max_reachable = max(max_reachable, i + nums[i]) return \\"Yes\\" if max_reachable >= n - 1 else \\"No\\""},{"question":"from typing import List def can_be_palindrome(s: str) -> bool: Determines if a string can be rearranged to form a palindrome. def check_strings_for_palindrome(N: int, strings: List[str]) -> List[str]: For each string in a list, prints \\"Possible\\" if the string can be rearranged to form a palindrome, otherwise prints \\"Not Possible\\". # Example usage if __name__ == \\"__main__\\": N = 2 strings = [\\"aabb\\", \\"abc\\"] results = check_strings_for_palindrome(N, strings) for result in results: print(result)","solution":"def can_be_palindrome(s): Determines if a string can be rearranged to form a palindrome. from collections import Counter count = Counter(s) odd_count = sum(1 for element in count.values() if element % 2 != 0) return odd_count <= 1 def check_strings_for_palindrome(N, strings): For each string in a list, prints \\"Possible\\" if the string can be rearranged to form a palindrome, otherwise prints \\"Not Possible\\". results = [] for s in strings: if can_be_palindrome(s): results.append(\\"Possible\\") else: results.append(\\"Not Possible\\") return results # Example usage if __name__ == \\"__main__\\": N = 2 strings = [\\"aabb\\", \\"abc\\"] results = check_strings_for_palindrome(N, strings) for result in results: print(result)"},{"question":"def manage_appliances(n: int, appliances: List[Tuple[str, int]], m: int, events: List[str]) -> List[Tuple[str, str]]: Manage the state of household appliances based on their priorities and events. Args: n (int): The number of appliances. appliances (List[Tuple[str, int]]): List of tuples, each containing an appliance's name and its priority level. m (int): The number of events. events (List[str]): List of strings representing various events, such as \\"ON appliance_name\\", \\"OFF appliance_name\\", \\"SIMULATE\\". Returns: List[Tuple[str, str]]: A list of tuples with each appliance's name and its final state (\\"ON\\" or \\"OFF\\"). >>> manage_appliances(4, [(\\"AC\\", 10), (\\"Fridge\\", 20), (\\"Heater\\", 5), (\\"TV\\", 15)], 5, [\\"ON AC\\", \\"ON TV\\", \\"OFF AC\\", \\"SIMULATE\\", \\"ON Fridge\\"]) [('AC', 'OFF'), ('Fridge', 'ON'), ('Heater', 'OFF'), ('TV', 'ON')] >>> manage_appliances(3, [(\\"Lamp\\", 5), (\\"Fan\\", 15), (\\"Oven\\", 20)], 3, [\\"ON Lamp\\", \\"ON Fan\\", \\"SIMULATE\\"]) [('Fan', 'ON'), ('Lamp', 'ON'), ('Oven', 'OFF')] >>> manage_appliances(2, [(\\"AC\\", 10), (\\"Heater\\", 5)], 2, [\\"ON AC\\", \\"OFF AC\\"]) [('AC', 'OFF'), ('Heater', 'OFF')] >>> manage_appliances(3, [(\\"Fridge\\", 20), (\\"TV\\", 15), (\\"Washer\\", 8)], 0, []) [('Fridge', 'OFF'), ('TV', 'OFF'), ('Washer', 'OFF')]","solution":"def manage_appliances(n, appliances, m, events): appliance_priorities = {} appliance_status = {} # Load the appliance priorities and initialize their status for i in range(n): name, priority = appliances[i] appliance_priorities[name] = int(priority) appliance_status[name] = \\"OFF\\" for event in events: parts = event.split() command = parts[0] if command == \\"ON\\": appliance_name = parts[1] appliance_status[appliance_name] = \\"ON\\" elif command == \\"OFF\\": appliance_name = parts[1] appliance_status[appliance_name] = \\"OFF\\" elif command == \\"SIMULATE\\": # Simulation logic would be handled here if needed pass result = [(name, status) for name, status in sorted(appliance_status.items())] return result"},{"question":"def check_collisions(aircrafts: List[List[Tuple[int, int, int]]]) -> str: Simulate the paths and determine if any two aircraft will occupy the same waypoint at the same time. >>> check_collisions([[(5, 5, 2), (10, 10, 4)], [(5, 5, 3), (10, 10, 6)], [(5, 5, 2), (10, 10, 6)]]) == \\"Collision detected\\" >>> check_collisions([[(2, 2, 1), (4, 4, 2), (6, 6, 3)], [(1, 1, 1), (3, 3, 2), (5, 5, 3)]]) == \\"No collision\\" pass def main(input_data: str) -> str: Process input data and return if there is a collision or not. >>> main(\\"3n2n5 5 2n10 10 4n2n5 5 3n10 10 6n2n5 5 2n10 10 6n\\") == \\"Collision detected\\" >>> main(\\"2n3n2 2 1n4 4 2n6 6 3n3n1 1 1n3 3 2n5 5 3n\\") == \\"No collision\\" >>> main(\\"2n2n0 0 0n5 5 1n2n5 5 1n6 6 2n\\") == \\"Collision detected\\" >>> main(\\"2n2n1 1 1n2 2 2n2n3 3 1n4 4 2n\\") == \\"No collision\\" >>> main(\\"2n2n1 1 1n2 2 2n2n3 3 1n4 4 2n\\") == \\"No collision\\" pass","solution":"def check_collisions(aircrafts): waypoints = {} for i, aircraft in enumerate(aircrafts): for waypoint in aircraft: x, y, t = waypoint if (x, y, t) in waypoints: return \\"Collision detected\\" waypoints[(x, y, t)] = i return \\"No collision\\" def main(input_data): data = input_data.strip().split('n') n = int(data[0]) index = 1 aircrafts = [] for _ in range(n): m = int(data[index]) index += 1 aircraft = [] for _ in range(m): x, y, t = map(int, data[index].split()) aircraft.append((x, y, t)) index += 1 aircrafts.append(aircraft) return check_collisions(aircrafts)"},{"question":"def min_days_to_watch(n: int, dependencies: List[int]) -> int: Calculate the minimum number of days needed for Marie to watch the TV series given the dependencies. >>> min_days_to_watch(5, [0, 1, 0, 3, 3]) 2 >>> min_days_to_watch(4, [0, 0, 0, 0]) 1 >>> min_days_to_watch(4, [0, 1, 2, 3]) 4 >>> min_days_to_watch(4, [0, 1, 1, 1]) 2 >>> min_days_to_watch(6, [0, 1, 2, 0, 4, 4]) 3 >>> min_days_to_watch(1, [0]) 1","solution":"def min_days_to_watch(n, dependencies): def find_max_depth(episode): if episode in memo: return memo[episode] if dependencies[episode] == 0: return 1 memo[episode] = find_max_depth(dependencies[episode] - 1) + 1 return memo[episode] memo = {} max_depth = 1 for episode in range(n): max_depth = max(max_depth, find_max_depth(episode)) return max_depth"},{"question":"def count_paths_through_labyrinth(R: int, C: int, grid: List[str]) -> int: Determine the number of unique paths from the top-left corner to the bottom-right corner of the grid, moving only down or right at each step. >>> count_paths_through_labyrinth(3, 3, ['...', '.#.', '...']) == 2 >>> count_paths_through_labyrinth(2, 2, ['.#', '#.']) == 0","solution":"def count_paths_through_labyrinth(R, C, grid): # If the starting or ending point is an obstacle, return 0 as no paths are possible if grid[0][0] == '#' or grid[R-1][C-1] == '#': return 0 # Initialize a 2D array dp with 0s dp = [[0 for _ in range(C)] for _ in range(R)] # Set starting position dp[0][0] = 1 # Fill the dp table for i in range(R): for j in range(C): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] # Return the number of ways to reach the bottom-right corner return dp[R-1][C-1]"},{"question":"def max_balanced_pairs(n: int, k: int, ratings: List[int]) -> int: Determines the maximum number of balanced pairs of players that can be formed. Parameters: n (int): The number of players. k (int): The maximum allowed difference in their ratings for a balanced pair. ratings (list[int]): The rating scores of the players. Returns: int: The maximum number of balanced pairs that can be formed. Examples: >>> max_balanced_pairs(5, 1, [4, 3, 1, 5, 2]) 2 >>> max_balanced_pairs(3, 0, [5, 5, 5]) 1 from solution import max_balanced_pairs def test_balanced_pairs_example_1(): assert max_balanced_pairs(5, 1, [4, 3, 1, 5, 2]) == 2 def test_balanced_pairs_example_2(): assert max_balanced_pairs(3, 0, [5, 5, 5]) == 1 def test_no_pairs(): assert max_balanced_pairs(3, 0, [1, 2, 3]) == 0 def test_all_can_pair(): assert max_balanced_pairs(6, 10, [1, 2, 3, 4, 5, 6]) == 3 def test_large_k_value(): assert max_balanced_pairs(5, 1000000, [10, 20, 30, 40, 50]) == 2 def test_identical_ratings(): assert max_balanced_pairs(4, 0, [10, 10, 10, 10]) == 2","solution":"def max_balanced_pairs(n, k, ratings): Determines the maximum number of balanced pairs of players that can be formed. Parameters: n (int): The number of players. k (int): The maximum allowed difference in their ratings for a balanced pair. ratings (list[int]): The rating scores of the players. Returns: int: The maximum number of balanced pairs that can be formed. ratings.sort() i, j = 0, 1 pairs_count = 0 while i < n and j < n: if abs(ratings[j] - ratings[i]) <= k: pairs_count += 1 i += 2 j += 2 else: if i + 1 == j: j += 1 else: i += 1 return pairs_count"},{"question":"def get_books_to_reorder(book_list): Returns a list of book titles that need to be reordered based on their stock count and reorder threshold. :param book_list: List of strings representing books in \\"title, stock_count, reorder_threshold\\" format. :return: List of titles that need to be reordered. pass from solution import get_books_to_reorder def test_books_to_reorder_basic(): books = [ \\"Book A, 5, 10\\", \\"Book B, 15, 5\\", \\"Book C, 3, 3\\", \\"Book D, 0, 1\\" ] expected = [\\"Book A\\", \\"Book D\\"] assert get_books_to_reorder(books) == expected def test_books_to_reorder_none(): books = [ \\"Book A, 10, 5\\", \\"Book B, 15, 15\\", \\"Book C, 5, 5\\", \\"Book D, 1, 1\\" ] expected = [] assert get_books_to_reorder(books) == expected def test_books_to_reorder_all(): books = [ \\"Book A, 2, 5\\", \\"Book B, 1, 2\\", \\"Book C, 4, 7\\", \\"Book D, 0, 10\\" ] expected = [\\"Book A\\", \\"Book B\\", \\"Book C\\", \\"Book D\\"] assert get_books_to_reorder(books) == expected def test_books_to_reorder_mixed(): books = [ \\"Book A, 9, 10\\", \\"Book B, 10, 10\\", \\"Book C, 0, 1\\", \\"Book D, 2, 1\\", \\"Book E, 5, 5\\" ] expected = [\\"Book A\\", \\"Book C\\"] assert get_books_to_reorder(books) == expected def test_books_to_reorder_edge_cases(): books = [ \\"Book A, 100, 100\\", \\"Book B, 50, 49\\", \\"Book C, 0, 0\\", \\"Book D, 1, 0\\" ] expected = [] assert get_books_to_reorder(books) == expected","solution":"def get_books_to_reorder(book_list): Returns a list of book titles that need to be reordered based on their stock count and reorder threshold. :param book_list: List of strings representing books in \\"title, stock_count, reorder_threshold\\" format. :return: List of titles that need to be reordered. books_to_reorder = [] for book in book_list: title, stock_count, reorder_threshold = book.split(', ') stock_count = int(stock_count) reorder_threshold = int(reorder_threshold) if stock_count < reorder_threshold: books_to_reorder.append(title) return books_to_reorder"},{"question":"from typing import List, Tuple def can_complete_all_contests(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Determine whether it's possible for the contestants to complete all contests without violating any prerequisite rules. Args: T (int): The number of test cases test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): A list of test cases, where each test case is described by a tuple (N, M, prerequisites). N is the number of contests, M is the number of prerequisite pairs, and prerequisites is a list of tuples indicating the prerequisite pairs. Returns: List[str]: A list of results for each test case, either \\"Possible\\" or \\"Not Possible\\". Example: >>> T = 2 >>> test_cases = [ >>> (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), >>> (5, 3, [(1, 2), (2, 3), (1, 3)]) >>> ] >>> can_complete_all_contests(T, test_cases) ['Case 1: Not Possible', 'Case 2: Possible']","solution":"from collections import defaultdict, deque def can_complete_all_contests(T, test_cases): def is_possible(n, prerequisites): adj_list = defaultdict(list) indegree = [0] * (n + 1) for a, b in prerequisites: adj_list[b].append(a) indegree[a] += 1 queue = deque([i for i in range(1, n + 1) if indegree[i] == 0]) count = 0 while queue: current = queue.popleft() count += 1 for neighbor in adj_list[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) return count == n results = [] for i in range(T): N, M, prerequisites = test_cases[i] if is_possible(N, prerequisites): results.append(f\\"Case {i + 1}: Possible\\") else: results.append(f\\"Case {i + 1}: Not Possible\\") return results # Example usage T = 2 test_cases = [ (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), (5, 3, [(1, 2), (2, 3), (1, 3)]) ] print(can_complete_all_contests(T, test_cases))"},{"question":"from collections import deque from typing import List, Tuple def min_steps_to_reach_destination(t: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Determine the minimum number of steps required to navigate through a maze. The maze is represented by a grid containing '0' (empty cell) and '1' (obstacle cell). The explorer starts at the top-left corner and needs to reach the bottom-right corner. If it's not possible to reach the destination, return -1. Args: t: Number of test cases. test_cases: A list of tuples, each containing the number of rows and columns of the grid and the grid itself as a list of lists of integers. Returns: A list of integers representing the minimum number of steps required for each test case, or -1 if the destination is unreachable. Example: >>> min_steps_to_reach_destination(1, [(4, 4, [[0, 0, 1, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]])]) [6] >>> min_steps_to_reach_destination(1, [(3, 3, [[0, 1, 0], [1, 1, 0], [0, 0, 0]])]) [-1] def test_sample_input(): t = 1 test_cases = [ (4, 4, [ [0, 0, 1, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0] ]) ] assert min_steps_to_reach_destination(t, test_cases) == [6] def test_no_possible_path(): t = 1 test_cases = [ (3, 3, [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ]) ] assert min_steps_to_reach_destination(t, test_cases) == [-1] def test_single_cell_grid(): t = 2 test_cases = [ (1, 1, [ [0] ]), (1, 1, [ [1] ]) ] assert min_steps_to_reach_destination(t, test_cases) == [0, -1] def test_multiple_paths(): t = 1 test_cases = [ (3, 3, [ [0, 0, 0], [1, 1, 0], [0, 0, 0] ]) ] assert min_steps_to_reach_destination(t, test_cases) == [4] def test_large_grid(): t = 1 test_cases = [ (2, 2, [ [0, 0], [1, 0] ]) ] assert min_steps_to_reach_destination(t, test_cases) == [2]","solution":"from collections import deque def min_steps_to_reach_destination(t, test_cases): results = [] directions = [(0,1), (1,0), (0,-1), (-1,0)] for case in test_cases: m, n, grid = case if grid[0][0] == 1 or grid[m-1][n-1] == 1: results.append(-1) continue queue = deque([(0, 0, 0)]) # (x, y, steps) visited = set([(0, 0)]) found = False while queue: x, y, steps = queue.popleft() if x == m-1 and y == n-1: results.append(steps) found = True break for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) if not found: results.append(-1) return results"},{"question":"from typing import List, Tuple def minimum_edges_to_remove(n: int, edges: List[Tuple[int, int, int]]) -> int: Determine the smallest number of edges that need to be removed in order to make the graph acyclic. >>> minimum_edges_to_remove(5, [(0, 1, 4), (0, 2, 3), (1, 2, 1), (1, 3, 2), (3, 4, 6), (2, 4, 5)]) 2 >>> minimum_edges_to_remove(4, [(0, 1, 1), (1, 2, 2), (2, 3, 3)]) 0","solution":"from collections import defaultdict def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if xroot != yroot: if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def minimum_edges_to_remove(n, edges): parent = [i for i in range(n)] rank = [0] * n edge_count = defaultdict(int) for u, v, w in edges: edge_count[(u, v)] = w edge_count[(v, u)] = w union(parent, rank, u, v) unique_components = set(find(parent, i) for i in range(n)) component_edge_count = {comp: 0 for comp in unique_components} for u, v, w in edges: root = find(parent, u) component_edge_count[root] += 1 excess_edges = 0 for comp in unique_components: nodes = sum(1 for i in range(n) if find(parent, i) == comp) edges = component_edge_count[comp] excess_edges += edges - (nodes - 1) # (edges in component - (nodes-1)) return excess_edges def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) edges = [] index = 2 for _ in range(M): u = int(data[index]) v = int(data[index+1]) weight = int(data[index+2]) edges.append((u, v, weight)) index += 3 result = minimum_edges_to_remove(N, edges) print(result) if __name__ == \\"__main__\\": main()"},{"question":"def process_input(input_data: str) -> str: Given a sequence of datasets representing a directed graph of nodes and edges, determine if the graph contains any cycles and if so, identify one such cycle. Input: A sequence of datasets in the following format: n m u1 v1 . . . um vm The first line contains two integers n and m (1 <= n <= 100, 0 <= m <= 5000), which represent the number of nodes and the number of directed edges in the circuit respectively. Each of the following m lines contains two integers ui and vi (1 <= ui, vi <= n) representing a directed edge from node ui to node vi. The end of the input is indicated by a line containing two zeros. Output: For each dataset, if the circuit contains a cycle, output \\"Cycle Detected\\" and the nodes in one such cycle in the order they are visited. If the circuit does not contain any cycles, output \\"No Cycle\\". >>> process_input(\\"4 4n1 2n2 3n3 4n4 2n0 0\\") \\"Cycle Detected 2 3 4 2\\" >>> process_input(\\"4 3n1 2n2 3n3 4n0 0\\") \\"No Cycle\\"","solution":"def detect_cycle(n, m, edges): from collections import defaultdict def dfs(node, graph, visited, rec_stack): visited[node] = True rec_stack[node] = True stack.append(node) for neighbor in graph[node]: if not visited[neighbor]: if dfs(neighbor, graph, visited, rec_stack): return True elif rec_stack[neighbor]: cycle_start_index = stack.index(neighbor) cycle.extend(stack[cycle_start_index:]) cycle.append(neighbor) return True rec_stack[node] = False stack.pop() return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = [False] * (n + 1) rec_stack = [False] * (n + 1) stack = [] cycle = [] for node in range(1, n + 1): if not visited[node]: if dfs(node, graph, visited, rec_stack): break if cycle: return \\"Cycle Detected \\" + \\" \\".join(map(str, cycle)) else: return \\"No Cycle\\" def process_input(input_data): results = [] input_lines = input_data.strip().split(\\"n\\") index = 0 while index < len(input_lines): n, m = map(int, input_lines[index].strip().split()) if n == 0 and m == 0: break index += 1 edges = [] for _ in range(m): u, v = map(int, input_lines[index].strip().split()) edges.append((u, v)) index += 1 result = detect_cycle(n, m, edges) results.append(result) return \\"n\\".join(results)"},{"question":"def unique_k_length_strings(n: int, k: int, string_list: List[str]) -> int: Returns the number of unique k-length strings formed from consecutive characters of the provided list of strings. Args: n : int : number of strings k : int : length of substring string_list : list of str : list of strings Returns: int : number of unique k-length strings >>> unique_k_length_strings(4, 3, [\\"abcde\\", \\"defgh\\", \\"ijklmn\\", \\"ab\\"]) 10 >>> unique_k_length_strings(3, 2, [\\"abc\\", \\"bcd\\", \\"efg\\"]) 5 >>> unique_k_length_strings(2, 1, [\\"aaa\\", \\"aa\\"]) 1","solution":"def unique_k_length_strings(n, k, string_list): Returns the number of unique k-length strings formed from consecutive characters of the provided list of strings. Args: n : int : number of strings k : int : length of substring string_list : list of str : list of strings Returns: int : number of unique k-length strings unique_substrings = set() for string in string_list: for i in range(len(string) - k + 1): unique_substrings.add(string[i:i+k]) return len(unique_substrings)"},{"question":"def is_magic_square(nums): Returns \\"YES\\" if the numbers can be arranged into a 3x3 magic square, else \\"NO\\". >>> is_magic_square([2, 7, 6, 9, 5, 1, 4, 3, 8]) == \\"YES\\" >>> is_magic_square([1, 2, 3, 4, 5, 6, 7, 8, 9]) == \\"NO\\" >>> is_magic_square([8, 1, 6, 3, 5, 7, 4, 9, 2]) == \\"YES\\" >>> is_magic_square([0, 1, 2, 3, 4, 5, 6, 7, 8]) == \\"NO\\" >>> is_magic_square([-5, 2, 7, 8, -2, 4, 6, -1, -9]) == \\"NO\\" >>> is_magic_square([-1, -2, -3, -4, -5, -6, -7, -8, -9]) == \\"NO\\"","solution":"from itertools import permutations def is_magic_square(nums): Returns \\"YES\\" if the numbers can be arranged into a 3x3 magic square, else \\"NO\\". possible_magic_sums = [sum(perm[:3]) for perm in permutations(nums, 3)] target_sum = possible_magic_sums[0] grid_permutations = permutations(nums) for perm in grid_permutations: mat = [perm[0:3], perm[3:6], perm[6:9]] rows = [sum(row) for row in mat] cols = [sum(col) for col in zip(*mat)] diags = [mat[0][0] + mat[1][1] + mat[2][2], mat[0][2] + mat[1][1] + mat[2][0]] if all(x == target_sum for x in rows + cols + diags): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def min_clan_strength_difference(n: int, strengths: List[int]) -> int: Returns the minimum absolute difference between any two clan strengths. Parameters: n (int): The number of clans. strengths (list of int): The strength scores of the clans. Returns: int: The minimum absolute difference between any two clan strengths. >>> min_clan_strength_difference(5, [5, 1, 9, 13, 8]) 1 >>> min_clan_strength_difference(2, [1, 100]) 99 >>> min_clan_strength_difference(4, [10, 5, 15, 7]) 2 >>> min_clan_strength_difference(3, [3, 8, 15]) 5 >>> min_clan_strength_difference(6, [50, 1000, 450, 20, 30, 80]) 10","solution":"def min_clan_strength_difference(n, strengths): Returns the minimum absolute difference between any two clan strengths. Parameters: n (int): The number of clans. strengths (list of int): The strength scores of the clans. Returns: int: The minimum absolute difference between any two clan strengths. strengths.sort() min_diff = float('inf') for i in range(1, n): diff = strengths[i] - strengths[i - 1] if diff < min_diff: min_diff = diff return min_diff"},{"question":"def longest_subarray_bitwise_and(arr: List[int]) -> int: Returns the maximum length of a subarray where the bitwise AND of all elements is greater than zero. >>> longest_subarray_bitwise_and([2, 4, 0, 3, 7]) == 2 >>> longest_subarray_bitwise_and([1, 2, 3, 4, 5, 6]) == 6 >>> longest_subarray_bitwise_and([0, 0, 0, 0, 0]) == 0 >>> longest_subarray_bitwise_and([1, 1, 1, 1, 1]) == 5 >>> longest_subarray_bitwise_and([1, 2, 3, 0, 4, 5]) == 3 >>> longest_subarray_bitwise_and([1, 0, 2, 0, 3]) == 1 >>> longest_subarray_bitwise_and([0]) == 0 >>> longest_subarray_bitwise_and([1]) == 1","solution":"def longest_subarray_bitwise_and(arr): Returns the maximum length of a subarray where the bitwise AND of all elements is greater than zero. max_length = 0 current_length = 0 for num in arr: if num != 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def count_command_occurrences(n: int, log_entries: List[str], q: int, queries: List[str]) -> List[int]: Counts the occurrences of specified commands from the log entries. :param n: Number of log entries :param log_entries: List of log entries :param q: Number of queries :param queries: List of command names to count in the logs :return: List containing the count of each command in the queries list pass def test_single_command(): assert count_command_occurrences(1, [\\"CREATE user1\\"], 1, [\\"CREATE\\"]) == [1] def test_multiple_commands(): log_entries = [ \\"CREATE user1 David\\", \\"DELETE user2\\", \\"CREATE user3 Mark\\", \\"UPDATE user1 profile_data\\", \\"DELETE user3\\", \\"CREATE user4 Alice\\", \\"UPDATE user1 email\\" ] queries = [\\"CREATE\\", \\"DELETE\\", \\"UPDATE\\"] assert count_command_occurrences(7, log_entries, 3, queries) == [3, 2, 2] def test_no_matching_command(): log_entries = [\\"CREATE user1\\", \\"DELETE user1\\"] queries = [\\"UPDATE\\"] assert count_command_occurrences(2, log_entries, 1, queries) == [0] def test_commands_not_in_log(): log_entries = [\\"CREATE user1\\", \\"CREATE user2\\"] queries = [\\"DELETE\\"] assert count_command_occurrences(2, log_entries, 1, queries) == [0] def test_case_sensitivity(): log_entries = [\\"Create user1\\", \\"create user2\\"] queries = [\\"CREATE\\"] assert count_command_occurrences(2, log_entries, 1, queries) == [0] def test_large_input(): log_entries = [\\"CREATE user\\" + str(i) for i in range(10**6)] queries = [\\"CREATE\\"] assert count_command_occurrences(10**6, log_entries, 1, queries) == [10**6] def test_mixed_queries(): log_entries = [ \\"CREATE user1\\", \\"DELETE user1\\", \\"UPDATE user1\\", \\"CREATE user2\\", \\"DELETE user2\\", \\"UPDATE user2\\", ] queries = [\\"CREATE\\", \\"UPDATE\\", \\"MODIFY\\"] assert count_command_occurrences(6, log_entries, 3, queries) == [2, 2, 0]","solution":"def count_command_occurrences(n, log_entries, q, queries): Counts the occurrences of specified commands from the log entries. :param n: Number of log entries :param log_entries: List of log entries :param q: Number of queries :param queries: List of command names to count in the logs :return: List containing the count of each command in the queries list command_count = {} # Count the occurrences of each command in the log entries for entry in log_entries: command = entry.split()[0] if command in command_count: command_count[command] += 1 else: command_count[command] = 1 # Get the result for each query results = [] for query in queries: results.append(command_count.get(query, 0)) return results"},{"question":"def calculate_ranks(n: int, distances: List[int]) -> List[int]: Returns the ranks of participants based on the distances covered. >>> calculate_ranks(5, [10, 5, 20, 15, 10]) [3, 5, 1, 2, 3] >>> calculate_ranks(4, [10, 10, 10, 10]) [1, 1, 1, 1] >>> calculate_ranks(3, [5, 10, 15]) [3, 2, 1] >>> calculate_ranks(3, [15, 10, 5]) [1, 2, 3] >>> calculate_ranks(1, [10]) [1] >>> calculate_ranks(4, [10, 15, 5, 20]) [3, 2, 4, 1] pass","solution":"def calculate_ranks(n, distances): Returns the ranks of participants based on the distances covered. # Pair each distance with its original index indexed_distances = list(enumerate(distances)) # Sort the distances in descending order sorted_distances = sorted(indexed_distances, key=lambda x: (-x[1], x[0])) # Initialize ranks array ranks = [0] * n # Assign ranks current_rank = 1 for i in range(n): if i > 0 and sorted_distances[i][1] != sorted_distances[i - 1][1]: current_rank = i + 1 ranks[sorted_distances[i][0]] = current_rank return ranks"},{"question":"def word_occurrence_counter(input_lines: List[str]) -> List[Tuple[str, int]]: Count the number of occurrences of each word in the given text. The last line contains the word \\"END\\" which is not part of the text to be processed. The function returns a list of tuples where each tuple contains a word and its count, sorted in lexicographical order. >>> word_occurrence_counter([\\"hello world\\", \\"hello coding\\", \\"hello\\", \\"END\\"]) [(\\"coding\\", 1), (\\"hello\\", 3), (\\"world\\", 1)] >>> word_occurrence_counter([\\"END\\"]) [] pass def format_word_counts(word_counts: List[Tuple[str, int]]) -> List[str]: Format the word counts into a list of strings in the format 'word: count'. >>> format_word_counts([(\\"coding\\", 1), (\\"hello\\", 3), (\\"world\\", 1)]) [\\"coding: 1\\", \\"hello: 3\\", \\"world: 1\\",] >>> format_word_counts([]) [] pass","solution":"def word_occurrence_counter(input_lines): from collections import defaultdict word_counts = defaultdict(int) for line in input_lines: if line.strip() == \\"END\\": break words = line.split() for word in words: word_counts[word] += 1 result = sorted(word_counts.items()) return result def format_word_counts(word_counts): return [f\\"{word}: {count}\\" for word, count in word_counts]"},{"question":"def complete_laps(D: int, R: int, N: int) -> int: Given total time D (hours), running distance per hour R (meters), and number of checkpoints N, determine the number of complete laps Harry will be able to run within the given time. >>> complete_laps(5, 10, 3) 16 >>> complete_laps(4, 12, 4) 12 >>> complete_laps(6, 9, 2) 27 >>> complete_laps(1, 1, 1) 1 >>> complete_laps(10, 100, 100) 10 >>> complete_laps(10, 0, 1) 0","solution":"def complete_laps(D, R, N): Given total time D (hours), running distance per hour R (meters), and number of checkpoints N, determine the number of complete laps Harry will be able to run within the given time. total_distance = D * R lap_distance = N complete_laps = total_distance // lap_distance return complete_laps"},{"question":"import math from typing import List def has_perfect_square_subarray(N: int, arr: List[int]) -> str: Determines if there exists a non-empty subarray whose product is a perfect square. Args: N : int : the number of elements in the array arr : list of int : the array of positive integers Returns: str : \\"Yes\\" if a subarray whose product is a perfect square exists, otherwise \\"No\\" Examples: >>> has_perfect_square_subarray(5, [1, 3, 9, 4, 2]) 'Yes' >>> has_perfect_square_subarray(4, [2, 3, 5, 7]) 'No' >>> has_perfect_square_subarray(3, [4, 6, 16]) 'Yes' # Your code here def is_perfect_square(x: int) -> bool: Checks if a number is a perfect square. Args: x : int : the number to check Returns: bool : True if x is a perfect square, otherwise False Examples: >>> is_perfect_square(16) True >>> is_perfect_square(18) False # Your code here def test_has_perfect_square_subarray(): assert has_perfect_square_subarray(5, [1, 3, 9, 4, 2]) == \\"Yes\\" assert has_perfect_square_subarray(4, [2, 3, 5, 7]) == \\"No\\" assert has_perfect_square_subarray(3, [4, 6, 16]) == \\"Yes\\" assert has_perfect_square_subarray(1, [4]) == \\"Yes\\" assert has_perfect_square_subarray(1, [2]) == \\"No\\" assert has_perfect_square_subarray(5, [4, 9, 16, 25, 36]) == \\"Yes\\" def test_is_perfect_square(): assert is_perfect_square(1) == True assert is_perfect_square(4) == True assert is_perfect_square(16) == True assert is_perfect_square(18) == False assert is_perfect_square(25) == True assert is_perfect_square(26) == False assert is_perfect_square(100) == True assert is_perfect_square(99) == False","solution":"import math def has_perfect_square_subarray(N, arr): Determines if there exists a non-empty subarray whose product is a perfect square. Args: N : int : the number of elements in the array arr : list of int : the array of positive integers Returns: str : \\"Yes\\" if a subarray whose product is a perfect square exists, otherwise \\"No\\" for i in range(N): product = 1 for j in range(i, N): product *= arr[j] if is_perfect_square(product): return \\"Yes\\" return \\"No\\" def is_perfect_square(x): Checks if a number is a perfect square. Args: x : int : the number to check Returns: bool : True if x is a perfect square, otherwise False if x < 1: return False sqrt_x = int(math.sqrt(x)) return sqrt_x * sqrt_x == x"},{"question":"def subarray_sums(n: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns the sum of elements for each subarray defined in queries. :param n: int, number of elements in the array :param array: list of n integers, the elements of the array :param queries: list of tuples, each containing (l, k) for the start index and length of the subarray :return: list of sums for each query Example: >>> subarray_sums(5, [1, 2, 3, 4, 5], [(1, 3), (2, 2), (4, 1)]) [6, 5, 4] >>> subarray_sums(1, [10], [(1, 1)]) [10] >>> subarray_sums(4, [1, 2, 3, 4], [(1, 4)]) [10]","solution":"def subarray_sums(n, array, queries): Returns the sum of elements for each subarray defined in queries. :param n: int, number of elements in the array :param array: list of n integers, the elements of the array :param queries: list of tuples, each containing (l, k) for the start index and length of the subarray :return: list of sums for each query # Create prefix sum array prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + array[i] results = [] for l, k in queries: sub_sum = prefix_sum[l + k - 1] - prefix_sum[l - 1] results.append(sub_sum) return results"},{"question":"def is_valid_sentence(words: List[str]) -> str: Determines if the given list of words forms a valid sentence. >>> is_valid_sentence([\\"Once\\", \\"upon\\", \\"a\\", \\"time.\\", \\"END\\"]) == \\"YES\\" >>> is_valid_sentence([\\"hello\\", \\"world.\\", \\"END\\"]) == \\"NO\\"","solution":"def is_valid_sentence(words): Determines if the given list of words forms a valid sentence. Parameters: words (list of str): The input list of words ending with 'END'. Returns: str: \\"YES\\" if the list of words forms a valid sentence, \\"NO\\" otherwise. if not words or words[0] == \\"END\\": return \\"NO\\" first_word = words[0] if not first_word[0].isupper(): return \\"NO\\" for word in words[1:]: if word == \\"END\\": break if word[0].isupper(): return \\"NO\\" if words[-2][-1] != '.': return \\"NO\\" return \\"YES\\""},{"question":"def max_length_after_operations(n: int, arr: List[int]) -> int: Returns the maximum possible length of the sequence after performing the described operations. >>> max_length_after_operations(5, [-2, -1, 2, 1, -2]) == 1 >>> max_length_after_operations(6, [1, -1, 2, -2, 3, -3]) == 6 >>> max_length_after_operations(3, [1, 1, -1]) == 1","solution":"def max_length_after_operations(n, arr): Returns the maximum possible length of the sequence after performing the described operations. positive = 0 negative = 0 for num in arr: if num > 0: positive += 1 elif num < 0: negative += 1 return abs(positive - negative)"},{"question":"def duration_to_seconds(time_str: str) -> int: Converts a duration string in the format \\"hh:mm:ss\\" to the total number of seconds. >>> duration_to_seconds(\\"02:30:15\\") 9015 >>> duration_to_seconds(\\"00:05:20\\") 320 >>> duration_to_seconds(\\"00:00:00\\") 0 >>> duration_to_seconds(\\"00:00:45\\") 45 >>> duration_to_seconds(\\"00:25:00\\") 1500 >>> duration_to_seconds(\\"03:00:00\\") 10800 >>> duration_to_seconds(\\"12:34:56\\") 45296","solution":"def duration_to_seconds(time_str): Converts a duration string in the format \\"hh:mm:ss\\" to the total number of seconds. hours, minutes, seconds = map(int, time_str.split(':')) total_seconds = (hours * 3600) + (minutes * 60) + seconds return total_seconds"},{"question":"def add_minutes_to_time(t1: str, t2: str, D: int) -> str: Calculate the time the clock will display after adding D minutes to the initial time t1. Parameters: t1 (str): The current time in the format hh:mm. t2 (str): The same initial time as t1 in the format hh:mm. D (int): The number of minutes to add. Returns: str: The new time in the format hh:mm. >>> add_minutes_to_time(\\"12:30\\", \\"12:30\\", 150) '15:00' >>> add_minutes_to_time(\\"23:45\\", \\"23:45\\", 50) '00:35'","solution":"def add_minutes_to_time(t1, t2, D): Adds D minutes to the initial time t1 and returns the new time as hh:mm. Parameters: t1 (str): The current time in the format hh:mm. t2 (str): The current time in the format hh:mm (initially the same as t1). D (int): The number of minutes to add. Returns: str: The new time in the format hh:mm. h, m = map(int, t1.split(':')) total_minutes = (h * 60 + m + D) % 1440 new_h = total_minutes // 60 new_m = total_minutes % 60 return f'{new_h:02}:{new_m:02}'"},{"question":"def recover_original_pairs(n: int, pairs: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Recover the original list of pairs from the sorted list by using the indices. >>> recover_original_pairs(4, [(10, 2), (20, 3), (10, 1), (30, 4)]) [(10, 1), (10, 2), (20, 3), (30, 4)] >>> recover_original_pairs(5, [(5, 5), (3, 2), (5, 4), (2, 1), (5, 3)]) [(2, 1), (3, 2), (5, 3), (5, 4), (5, 5)] >>> recover_original_pairs(1, [(7, 1)]) [(7, 1)] >>> recover_original_pairs(3, [(1, 3), (1, 1), (1, 2)]) [(1, 1), (1, 2), (1, 3)] >>> recover_original_pairs(3, [(10**9, 1), (-10**9, 2), (5, 3)]) [(10**9, 1), (-10**9, 2), (5, 3)]","solution":"def recover_original_pairs(n, pairs): # Create a list to hold the original pairs (xi, yi) based on their indices yi original_pairs = [None] * n for xi, yi in pairs: original_pairs[yi - 1] = (xi, yi) return original_pairs # Example usage (for local testing purpose): # input_pairs = [(10, 2), (20, 3), (10, 1), (30, 4)] # print(recover_original_pairs(4, input_pairs))"},{"question":"def can_sort_with_swaps(n, s, arr): This function determines if it is possible to make the given array non-decreasing within at most s adjacent swaps. # Write your logic here def multiple_test_cases(t, test_cases): This function processes multiple test cases and returns results for each. # Write your logic here # Example usage: if __name__ == \\"__main__\\": # Read input from standard input (console) import sys input = sys.stdin.read data = input().strip().split() index = 0 t = int(data[index]) index += 1 test_cases = [] for _ in range(t): n = int(data[index]) s = int(data[index + 1]) arr = list(map(int, data[index + 2:index + 2 + n])) index += 2 + n test_cases.append((n, s, arr)) results = multiple_test_cases(t, test_cases) for result in results: print(result) # Unit Test Example: import pytest def test_example_cases(): t = 3 test_cases = [ (5, 3, [3, 1, 2, 4, 5]), (5, 1, [3, 1, 2, 4, 5]), (4, 0, [2, 2, 2, 2]), ] expected = [\\"YES\\", \\"NO\\", \\"YES\\"] assert multiple_test_cases(t, test_cases) == expected def test_large_case(): t = 1 test_cases = [ (1000, 1000, list(range(1000, 0, -1))), # Completely reversed array ] expected = [\\"YES\\"] assert multiple_test_cases(t, test_cases) == expected def test_smallest_case_possible(): t = 1 test_cases = [ (1, 0, [1]), # Single element array ] expected = [\\"YES\\"] assert multiple_test_cases(t, test_cases) == expected def test_no_swaps_needed(): t = 1 test_cases = [ (5, 2, [1, 2, 3, 4, 5]), # Already sorted array ] expected = [\\"YES\\"] assert multiple_test_cases(t, test_cases) == expected def test_insufficient_swaps(): t = 1 test_cases = [ (5, 1, [5, 4, 3, 2, 1]), # Reversed array but not enough swaps ] expected = [\\"NO\\"] assert multiple_test_cases(t, test_cases) == expected","solution":"def can_sort_with_swaps(n, s, arr): This function determines if it is possible to make the given array non-decreasing within at most s adjacent swaps. # Copy the array and sort it to get the target non-decreasing array sorted_arr = sorted(arr) # Count the positions where the original array differs from the sorted array mismatch_positions = sum(1 for i in range(n) if arr[i] != sorted_arr[i]) # If mismatch positions can be resolved within the given swaps if mismatch_positions <= 2 * s: return \\"YES\\" else: return \\"NO\\" def multiple_test_cases(t, test_cases): This function processes multiple test cases and returns results for each. results = [] for i in range(t): n, s, arr = test_cases[i] results.append(can_sort_with_swaps(n, s, arr)) return results"},{"question":"def calculate_highest_and_average(grades: List[int]) -> Tuple[int, float]: Create a program that takes a list of students' grades and calculates the highest and average grade. :param grades: List of integer grades :return: Tuple containing highest grade and average grade rounded to two decimal places >>> calculate_highest_and_average([85, 90, 78, 92, 88]) (92, 86.60) >>> calculate_highest_and_average([100]) (100, 100.00)","solution":"def calculate_highest_and_average(grades): Returns the highest grade and the average grade rounded to two decimal places from the list of grades. :param grades: List of integer grades :return: Tuple containing highest grade and average grade rounded to two decimal places if not grades: raise ValueError(\\"The grades list cannot be empty\\") highest_grade = max(grades) average_grade = round(sum(grades) / len(grades), 2) return highest_grade, average_grade"},{"question":"def sequence_length(a: int, b: int, m: int) -> int: Determines the length of the sequence before it first reaches or exceeds the given positive integer value m. Parameters: a (int): The first integer in the sequence. b (int): The second integer in the sequence. m (int): The target integer value. Returns: int: The length of the sequence before the first term that reaches or exceeds m. >>> sequence_length(2, 3, 10) 5 >>> sequence_length(1, 1, 100) 12","solution":"def sequence_length(a, b, m): Determines the length of the sequence before it first reaches or exceeds the given positive integer value m. Parameters: a (int): The first integer in the sequence. b (int): The second integer in the sequence. m (int): The target integer value. Returns: int: The length of the sequence before the first term that reaches or exceeds m. if a >= m: return 1 elif b >= m: return 2 seq = [a, b] count = 2 while seq[-1] < m: next_term = seq[-1] + seq[-2] seq.append(next_term) count += 1 return count"},{"question":"def max_fish_catch(n: int, T: int, effectiveness: List[int]) -> int: Returns the maximum number of fish that can be caught with given gadgets and total time. Parameters: n (int): Number of gadgets T (int): Total available time in minutes for fishing effectiveness (list of int): List containing the effectiveness of each gadget in fish per minute Returns: int: The maximum number of fish that can be caught Examples: >>> max_fish_catch(3, 30, [5, 10, 15]) == 450 >>> max_fish_catch(2, 100, [15, 5]) == 1500 >>> max_fish_catch(4, 50, [1, 1, 1, 1]) == 50","solution":"def max_fish_catch(n, T, effectiveness): Returns the maximum number of fish that can be caught with given gadgets and total time. Parameters: n (int): Number of gadgets T (int): Total available time in minutes for fishing effectiveness (list of int): List containing the effectiveness of each gadget in fish per minute Returns: int: The maximum number of fish that can be caught max_effectiveness = max(effectiveness) return max_effectiveness * T"},{"question":"def file_management(commands: List[str]) -> List[str]: Simulate a simple file management system with basic commands for creating, writing, reading, and deleting files. Supported commands: - create <filename> - write <filename> <content> - read <filename> - delete <filename> - end Example: >>> file_management([\\"create file1\\", \\"write file1 Hello_World\\", \\"read file1\\", \\"end\\"]) [\\"Hello_World\\"] >>> file_management([\\"create file1\\", \\"create file1\\", \\"end\\"]) [\\"File already exists\\"] Arguments: commands -- List of commands to simulate file management Returns: List of outputs produced by the read commands or error messages.","solution":"def file_management(commands): file_system = {} output = [] for command in commands: parts = command.split(maxsplit=2) action = parts[0] if action == 'create': filename = parts[1] if filename in file_system: output.append(\\"File already exists\\") else: file_system[filename] = \\"\\" elif action == 'write': filename = parts[1] content = parts[2] if len(parts) > 2 else \\"\\" if filename not in file_system: output.append(\\"File not found\\") else: file_system[filename] = content elif action == 'read': filename = parts[1] if filename not in file_system: output.append(\\"File not found\\") else: output.append(file_system[filename]) elif action == 'delete': filename = parts[1] if filename not in file_system: output.append(\\"File not found\\") else: del file_system[filename] elif action == 'end': break return output"},{"question":"def find_minimum_cycle(N: int, M: int, connections: List[Tuple[int, int, int]]) -> int: Find the minimum time required to complete a cycle in the barns' connections. Returns -1 if no cycle exists. Args: N : int : The number of barns. M : int : The number of connections. connections : List[Tuple[int, int, int]] : The list of connections, where each connection is represented by a tuple of integers (a, b, t) representing a bidirectional connection between barn a and barn b that takes time t to travel in either direction. Returns: int : The minimum time required to complete a cycle or -1 if no cycle exists. Examples: >>> find_minimum_cycle(4, 4, [(1, 2, 4), (2, 3, 2), (3, 4, 3), (4, 2, 1)]) 6 >>> find_minimum_cycle(3, 3, [(1, 2, 3), (2, 3, 4), (3, 1, 5)]) 12 >>> find_minimum_cycle(5, 4, [(1, 2, 8), (2, 3, 6), (3, 4, 7), (4, 5, 5)]) -1 pass # Helper function for testing def find_minimum_cycle_helper(N: int, M: int, connections: List[Tuple[int, int, int]]) -> int: return find_minimum_cycle(N, M, connections)","solution":"import heapq def find_minimum_cycle(N, M, connections): def dijkstra(src): Run Dijkstra's algorithm from a source node dist = [float('inf')] * (N + 1) dist[src] = 0 priority_queue = [(0, src)] while priority_queue: current_dist, current_node = heapq.heappop(priority_queue) if current_dist > dist[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return dist graph = [[] for _ in range(N + 1)] for a, b, t in connections: graph[a].append((b, t)) graph[b].append((a, t)) minimum_cycle_time = float('inf') for a, b, t in connections: # Remove the edge (a, b, t) and calculate the shortest path from a to b graph[a].remove((b, t)) graph[b].remove((a, t)) dist = dijkstra(a) if dist[b] != float('inf'): cycle_time = dist[b] + t minimum_cycle_time = min(minimum_cycle_time, cycle_time) # Restore the edge (a, b, t) graph[a].append((b, t)) graph[b].append((a, t)) return -1 if minimum_cycle_time == float('inf') else minimum_cycle_time # Helper function for testing def find_minimum_cycle_helper(N, M, connections): return find_minimum_cycle(N, M, connections)"},{"question":"def find_largest_file(filesystem: dict) -> int: Find the largest file size in a given directory (including all its subdirectories). If there are no files, return -1. >>> find_largest_file({ \\"root\\": { \\"dir1\\": {}, \\"file1.txt\\": 1200, \\"dir2\\": { \\"file2.txt\\": 800, \\"dir3\\": { \\"file3.txt\\": 2000 } } } }) == 2000 >>> find_largest_file({ \\"root\\": { \\"folder1\\": { \\"folder2\\": {} } } }) == -1 >>> find_largest_file({ \\"root\\": { \\"dir1\\": { \\"file4.txt\\": 500 }, \\"dir2\\": { \\"file5.txt\\": 1500 }, \\"file3.txt\\": 3000 } }) == 3000 >>> find_largest_file({}) == -1 >>> find_largest_file({\\"root\\": {\\"file_only.txt\\": 600}}) == 600 >>> find_largest_file({ \\"root\\": { \\"file1.txt\\": 1000, \\"dir1\\": { \\"file2.txt\\": 1000 } } }) == 1000 >>> find_largest_file({ \\"main_dir\\": { \\"subdir1\\": { \\"a.txt\\": 2100, \\"b.txt\\": 3200 }, \\"subdir2\\": { \\"c.txt\\": 400, \\"d.txt\\": 1500 }, \\"subdir3\\": { \\"e.txt\\": 3200 } } }) == 3200","solution":"def find_largest_file(filesystem: dict) -> int: def dfs(directory: dict) -> int: max_size = -1 for name, value in directory.items(): if isinstance(value, dict): max_size = max(max_size, dfs(value)) elif isinstance(value, int): max_size = max(max_size, value) return max_size return dfs(filesystem)"},{"question":"def sort_tasks(test_cases: List[List[Tuple[int, int]]]) -> List[List[Tuple[int, int]]]: Sort tasks by priority and duration. Parameters: - test_cases (list): A list of test cases, where each test case is a list of tasks. Each task is represented as a tuple (priority, duration). Returns: - list: A list of sorted tasks for each test case. pass def read_input_output(input_string: str) -> str: Reads input in string format as specified and returns structured data. Parameters: - input_string (str): Input tasks as a string with the described format. Returns: - str: Output tasks as a string after sorting according to the criteria. >>> input_string = \\"1n3n2 5n1 3n2 2\\" >>> read_input_output(input_string) '1 3n2 2n2 5' >>> input_string = \\"1n4n2 5n2 3n2 4n2 1\\" >>> read_input_output(input_string) '2 1n2 3n2 4n2 5' pass","solution":"def sort_tasks(test_cases): Sort tasks by priority and duration. Parameters: - test_cases (list): A list of test cases, where each test case is a list of tasks. Each task is represented as a tuple (priority, duration). Returns: - list: A list of sorted tasks for each test case. sorted_results = [] for tasks in test_cases: # Each task is a tuple (P, D) tasks.sort(key=lambda task: (task[0], task[1])) # Sort first by priority, then by duration sorted_results.append(tasks) return sorted_results def read_input_output(input_string): Reads input in string format as specified and returns structured data. input_lines = input_string.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) tasks = [] for i in range(index + 1, index + 1 + N): P, D = map(int, input_lines[i].split()) tasks.append((P, D)) test_cases.append(tasks) index += 1 + N sorted_tasks = sort_tasks(test_cases) output_result = [] for tasks in sorted_tasks: for task in tasks: output_result.append(f\\"{task[0]} {task[1]}\\") return 'n'.join(output_result)"},{"question":"def collect_treasures(grid: List[List[str]]) -> bool: Determine if it is possible to collect all treasures on the island starting from the given position and without crossing the sea. >>> grid = [ ... ['L', 'T', 'S', 'L'], ... ['S', 'L', 'L', 'T'], ... ['L', 'L', 'S', 'S'], ... ['S', 'T', 'L', 'L'] ... ] >>> collect_treasures(grid) True >>> grid = [ ... ['L', 'T', 'S', 'L'], ... ['S', 'L', 'L', 'T'], ... ['L', 'S', 'S', 'S'], ... ['S', 'T', 'L', 'L'] ... ] >>> collect_treasures(grid) False","solution":"def collect_treasures(grid): def dfs(x, y, visited): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or (x, y) in visited or grid[x][y] == 'S': return visited.add((x, y)) if grid[x][y] == 'T': treasures_visited.add((x, y)) dfs(x + 1, y, visited) dfs(x - 1, y, visited) dfs(x, y + 1, visited) dfs(x, y - 1, visited) rows = len(grid) cols = len(grid[0]) visited = set() treasures = set() start_position = None for i in range(rows): for j in range(cols): if grid[i][j] == 'L': start_position = (i, j) break if start_position: break if not start_position: return False for i in range(rows): for j in range(cols): if grid[i][j] == 'T': treasures.add((i, j)) treasures_visited = set() dfs(start_position[0], start_position[1], visited) return treasures == treasures_visited"},{"question":"def unique_paths_with_obstacles(grid): Returns the number of unique paths in a grid with obstacles. >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[0, 1, 0], [0, 1, 0], [0, 0, 0]]) 1 >>> unique_paths_with_obstacles([[1, 0, 0], [0, 1, 0], [0, 0, 0]]) 0 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 6 >>> unique_paths_with_obstacles([[0, 1], [1, 0]]) 0","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths in a grid with obstacles. m = len(grid) n = len(grid[0]) if grid[0][0] == 1 or grid[m - 1][n - 1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] return dp[m - 1][n - 1]"},{"question":"from typing import List def longest_palindrome_length(n: int, blocks: str) -> int: Returns the length of the longest palindrome that can be formed using the blocks. n: int - the number of blocks blocks: str - the string of uppercase Latin letters on the blocks >>> longest_palindrome_length(6, \\"AABBCC\\") 6 >>> longest_palindrome_length(4, \\"ABAA\\") 3 >>> longest_palindrome_length(1, \\"A\\") 1 >>> longest_palindrome_length(5, \\"AABBC\\") 5 >>> longest_palindrome_length(4, \\"ABCD\\") 1 >>> longest_palindrome_length(0, \\"\\") 0","solution":"def longest_palindrome_length(n, blocks): Returns the length of the longest palindrome that can be formed using the blocks. n: int - the number of blocks blocks: str - the string of uppercase Latin letters on the blocks from collections import Counter # Count the frequency of each letter count = Counter(blocks) length = 0 odd_found = False # Calculate the total length of the longest possible palindrome for freq in count.values(): if freq % 2 == 0: # Even frequency letters can fully be used in the palindrome length += freq else: length += freq - 1 # Use the even part of the frequency in the palindrome odd_found = True # We found at least one letter with an odd frequency # If there is at least one odd frequency letter, we can place one at the center if odd_found: length += 1 return length"},{"question":"def enrollments_to_dict(enrollments): Converts a list of enrollment records into a dictionary where the keys are course IDs and the values are lists of sorted student IDs enrolled in these courses. :param enrollments: List of tuples, where each tuple contains a student ID and a course ID. :return: Dictionary where keys are course IDs and values are sorted lists of student IDs. # Your implementation here from solution import enrollments_to_dict def test_basic_case(): enrollments = [ (1, 101), (2, 101), (3, 102), (1, 102), (2, 103) ] expected_output = {101: [1, 2], 102: [1, 3], 103: [2]} assert enrollments_to_dict(enrollments) == expected_output def test_single_record(): enrollments = [(1, 101)] expected_output = {101: [1]} assert enrollments_to_dict(enrollments) == expected_output def test_multiple_courses_single_student(): enrollments = [ (1, 101), (1, 102), (1, 103) ] expected_output = {101: [1], 102: [1], 103: [1]} assert enrollments_to_dict(enrollments) == expected_output def test_multiple_students_multiple_courses(): enrollments = [ (3, 104), (1, 104), (2, 104), (2, 105), (1, 105) ] expected_output = {104: [1, 2, 3], 105: [1, 2]} assert enrollments_to_dict(enrollments) == expected_output def test_unsorted_input(): enrollments = [ (3, 106), (1, 106), (2, 106), (4, 106) ] expected_output = {106: [1, 2, 3, 4]} assert enrollments_to_dict(enrollments) == expected_output def test_duplicate_students_in_course(): enrollments = [ (2, 107), (1, 107), (2, 107), (3, 107) ] expected_output = {107: [1, 2, 2, 3]} assert enrollments_to_dict(enrollments) == expected_output","solution":"def enrollments_to_dict(enrollments): Converts a list of enrollment records into a dictionary where the keys are course IDs and the values are lists of sorted student IDs enrolled in these courses. :param enrollments: List of tuples, where each tuple contains a student ID and a course ID. :return: Dictionary where keys are course IDs and values are sorted lists of student IDs. course_dict = {} for student_id, course_id in enrollments: if course_id not in course_dict: course_dict[course_id] = [] course_dict[course_id].append(student_id) for course_id in course_dict: course_dict[course_id].sort() return course_dict"},{"question":"def max_profit(n: int, prices: List[int]) -> int: Function to calculate the maximum profit from buying and selling a stock once. :param n: int, number of prices :param prices: list of int, stock prices recorded throughout the day :return: int, maximum profit (0 if no profit can be made) >>> max_profit(6, [7, 1, 5, 3, 6, 4]) 5 >>> max_profit(5, [7, 6, 4, 3, 1]) 0","solution":"def max_profit(n, prices): Function to calculate the maximum profit from buying and selling a stock once. :param n: int, number of prices :param prices: list of int, stock prices recorded throughout the day :return: int, maximum profit (0 if no profit can be made) if n <= 1: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price else: potential_profit = price - min_price if potential_profit > max_profit: max_profit = potential_profit return max_profit"},{"question":"def count_passengers(n: int, query: callable) -> int: Counts the number of passengers on the roller coaster. Parameters: n (int): The number of seats on the roller coaster. query (function): A function that takes a seat number (int) and returns \\"Occupied\\" or \\"Empty\\". Returns: int: The number of occupied seats. Example: >>> mock_query_factory([\\"Occupied\\", \\"Empty\\", \\"Occupied\\", \\"Empty\\", \\"Occupied\\"]) >>> query = mock_query_factory([\\"Occupied\\", \\"Empty\\", \\"Occupied\\", \\"Empty\\", \\"Occupied\\"]) >>> count_passengers(5, query) 3","solution":"def count_passengers(n, query): Counts the number of passengers on the roller coaster. Parameters: n (int): The number of seats on the roller coaster. query (function): A function that takes a seat number (int) and returns \\"Occupied\\" or \\"Empty\\". Returns: int: The number of occupied seats. occupied_count = 0 for seat in range(1, n + 1): result = query(seat) if result == \\"Occupied\\": occupied_count += 1 return occupied_count"},{"question":"def assemble_bicycles(n: int, m: int) -> tuple: Calculate the maximum number of bicycles that can be assembled, and the remaining chains and tires. Args: n (int): Number of chains. m (int): Number of tires. Returns: tuple: A tuple containing the number of assembled bicycles, remaining chains, and remaining tires. # Complete the function here","solution":"def assemble_bicycles(n, m): Calculate the maximum number of bicycles that can be assembled, and the remaining chains and tires. Args: n (int): Number of chains. m (int): Number of tires. Returns: tuple: A tuple containing the number of assembled bicycles, remaining chains, and remaining tires. max_bicycles = min(n, m // 2) remaining_chains = n - max_bicycles remaining_tires = m - (max_bicycles * 2) return max_bicycles, remaining_chains, remaining_tires"},{"question":"def min_max_travel_distance(m: int, n: int, k: int) -> int: A courier company is planning to optimize its delivery schedule in a large city. The city can be represented as a grid of size m x n, where each point on the grid represents a delivery location. The company has k couriers available, and each courier can start from any delivery location on the grid and must deliver a package to a different delivery location on the grid. The goal is to minimize the maximum distance any courier must travel to make a delivery. The distance is calculated as the Manhattan distance between two points (x1, y1) and (x2, y2), which is |x1 - x2| + |y1 - y2|. The function determines the minimum possible value of the maximum travel distance for the k couriers. >>> min_max_travel_distance(5, 5, 3) 2 >>> min_max_travel_distance(7, 7, 4) 2 from solution import min_max_travel_distance def test_case_1(): # Test with example inputs assert min_max_travel_distance(5, 5, 3) == 2 def test_case_2(): # Test with example inputs assert min_max_travel_distance(7, 7, 4) == 2 def test_case_3(): # Test with minimum grid size and 1 courier assert min_max_travel_distance(1, 1, 1) == 0 def test_case_4(): # Test with a different configuration assert min_max_travel_distance(4, 4, 2) == 1 def test_case_5(): # Test max inputs assert min_max_travel_distance(100, 100, 1) == 0 def test_case_6(): # Test another arbitrary configuration assert min_max_travel_distance(3, 3, 2) == 1 def test_case_7(): # Test with grid 2x2 and 1 courier assert min_max_travel_distance(2, 2, 1) == 0 def test_case_8(): # Test with grid 2x2 and 4 couriers assert min_max_travel_distance(2, 2, 4) == 2","solution":"def min_max_travel_distance(m, n, k): This function calculates the minimum possible value of the maximum travel distance any courier must travel to deliver a package, given a grid m x n and k couriers. # Function to determine the maximum distance for given (i, j) points def calc_max_distance(locations): max_d = 0 for i in range(len(locations)): for j in range(len(locations)): if i != j: dist = abs(locations[i][0] - locations[j][0]) + abs(locations[i][1] - locations[j][1]) max_d = max(max_d, dist) return max_d # Generate all distinct delivery locations from the grid delivery_locations = [(i, j) for i in range(m) for j in range(n)] # Since the problem is to find minimum of the maximum distances, # we perform a search through all combinations of k locations from itertools import combinations min_max_distance = float('inf') for comb in combinations(delivery_locations, k): max_dist = calc_max_distance(comb) min_max_distance = min(min_max_distance, max_dist) return min_max_distance"},{"question":"def max_employees_accommodated(t: int, capacities: List[int], e: int) -> int: Determines the maximum number of employees that can be accommodated in the available workshops. Parameters: t (int): Number of workshops. capacities (list of int): Capacities of each workshop. e (int): Number of employees wishing to attend. Returns: int: The maximum number of employees that can be accommodated. Examples: >>> max_employees_accommodated(3, [50, 30, 20], 60) 60 >>> max_employees_accommodated(4, [10, 20, 30, 40], 70) 70 >>> max_employees_accommodated(2, [50, 50], 120) 100 from typing import List # Unit tests def test_example_1(): assert max_employees_accommodated(3, [50, 30, 20], 60) == 60 def test_example_2(): assert max_employees_accommodated(4, [10, 20, 30, 40], 70) == 70 def test_example_3(): assert max_employees_accommodated(2, [50, 50], 120) == 100 def test_no_employees(): assert max_employees_accommodated(3, [50, 30, 20], 0) == 0 def test_large_number_of_employees(): assert max_employees_accommodated(1, [50], 100) == 50 def test_exact_capacity_match(): assert max_employees_accommodated(3, [30, 20, 10], 60) == 60 def test_less_than_capacity(): assert max_employees_accommodated(3, [50, 30, 20], 40) == 40 def test_all_zeros(): assert max_employees_accommodated(3, [0, 0, 0], 10) == 0","solution":"def max_employees_accommodated(t, capacities, e): Determines the maximum number of employees that can be accommodated in the available workshops. Parameters: t (int): Number of workshops. capacities (list of int): Capacities of each workshop. e (int): Number of employees wishing to attend. Returns: int: The maximum number of employees that can be accommodated. total_capacity = sum(capacities) return min(total_capacity, e)"},{"question":"def count_ways(n: int) -> int: Returns the number of distinct ways to reach the top of the staircase with N steps, where you can either take 1 step, 2 steps, or 3 steps at a time. >>> count_ways(3) 4 >>> count_ways(4) 7","solution":"def count_ways(n): Returns the number of distinct ways to reach the top of the staircase with N steps, where you can either take 1 step, 2 steps, or 3 steps at a time. if n == 0: return 1 elif n == 1: return 1 elif n == 2: return 2 # Initialize a list to store the number of ways to reach each step ways = [0] * (n + 1) ways[0] = 1 ways[1] = 1 ways[2] = 2 # Fill the list with the number of ways to reach each subsequent step for i in range(3, n + 1): ways[i] = ways[i-1] + ways[i-2] + ways[i-3] return ways[n]"},{"question":"def kth_prime(k: int) -> int: Tara loves playing with numbers, and she is particularly fond of prime numbers. Write a function that takes an integer k and returns the k-th prime number. Constraints: * 1  k  200 Examples: >>> kth_prime(5) 11 >>> kth_prime(10) 29","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def kth_prime(k): count = 0 num = 1 while count < k: num += 1 if is_prime(num): count += 1 return num"},{"question":"def optimize_shipment(t: int, test_cases: List[Tuple[int, int, List[int], List[Tuple[int, int, int]]]]) -> List[int]: Optimize the shipment of widgets from a central warehouse to several regional factories to minimize total transportation cost. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[int], List[Tuple[int, int, int]]]]): A list of tuples representing the test cases. Each tuple contains: - The number of factories (int). - The number of roads (int). - A list of demands for each factory (List[int]). - A list of roads, each represented as a tuple (u, v, c) where u is the starting point, v is the ending point, and c is the transportation cost per widget (List[Tuple[int, int, int]]). Returns: List[int]: A list of integers, each representing the minimum total transportation cost for each test case. If it's impossible to meet all demands, return -1 for that test case. Example: >>> t = 2 >>> test_cases = [ (2, 3, [4, 6], [(0, 1, 5), (0, 2, 2), (1, 2, 3)]), (3, 4, [10, 10, 10], [(0, 1, 1), (0, 2, 2), (0, 3, 3), (1, 2, 1)]) ] >>> optimize_shipment(t, test_cases) [32, 60] results = [] for case in test_cases: n, m, demands, roads = case ... # Code to compute minimum transportation cost for each test case results.append(result) return results","solution":"def optimize_shipment(t, test_cases): def min_cost(n, m, demands, roads): from heapq import heappush, heappop import sys inf = sys.maxsize dist = [inf] * (n + 1) dist[0] = 0 # Dijkstra's algorithm to find the shortest paths from the warehouse to each factory pq = [(0, 0)] # (cost, vertex) road_map = [[] for _ in range(n + 1)] for u, v, c in roads: road_map[u].append((v, c)) if v == 0: # Keep roads symmetrical for easier calculations road_map[v].append((u, c)) while pq: current_distance, u = heappop(pq) if current_distance > dist[u]: continue for v, weight in road_map[u]: distance = current_distance + weight if distance < dist[v]: dist[v] = distance heappush(pq, (distance, v)) total_cost = 0 for i in range(1, n + 1): if dist[i] == inf: return -1 total_cost += dist[i] * demands[i - 1] return total_cost results = [] for case in test_cases: n, m, demands, roads = case result = min_cost(n, m, demands, roads) results.append(result) return results"},{"question":"def find_isolated_transactions(n: int, m: int, categories: List[int], dependencies: List[Tuple[int, int]]) -> Tuple[int, List[int]]: Returns the number of isolated transactions and a list of their identifiers. Parameters: n (int): The number of transactions. m (int): The number of dependencies. categories (list): A list of integers representing the category of each transaction. dependencies (list of tuples): Each tuple (u, v) indicates that transaction u depends on transaction v. Returns: tuple: A tuple containing the number of isolated transactions and a list of their identifiers. # Write your code here # Unit tests def test_isolated_transactions_case_1(): n = 6 m = 3 categories = [1, 2, 3, 2, 1, 3] dependencies = [(1, 2), (2, 3), (3, 4)] assert find_isolated_transactions(n, m, categories, dependencies) == (2, [5, 6]) def test_isolated_transactions_case_2(): n = 5 m = 5 categories = [1, 2, 3, 2, 1] dependencies = [(1, 2), (2, 3), (3, 4), (4, 5), (2, 4)] assert find_isolated_transactions(n, m, categories, dependencies) == (0, []) def test_isolated_transactions_case_3(): n = 1 m = 0 categories = [1] dependencies = [] assert find_isolated_transactions(n, m, categories, dependencies) == (1, [1]) def test_isolated_transactions_case_4(): n = 3 m = 2 categories = [1, 1, 1] dependencies = [(1, 2), (2, 3)] assert find_isolated_transactions(n, m, categories, dependencies) == (0, []) def test_isolated_transactions_case_5(): n = 4 m = 1 categories = [1, 3, 2, 1] dependencies = [(2, 1)] assert find_isolated_transactions(n, m, categories, dependencies) == (2, [3, 4])","solution":"def find_isolated_transactions(n, m, categories, dependencies): Returns the number of isolated transactions and a list of their identifiers. Parameters: n (int): The number of transactions. m (int): The number of dependencies. categories (list): A list of integers representing the category of each transaction. dependencies (list of tuples): Each tuple (u, v) indicates that transaction u depends on transaction v. Returns: tuple: A tuple containing the number of isolated transactions and a list of their identifiers. from collections import defaultdict # Initialize a set of all transactions all_transactions = set(range(1, n+1)) # Initialize sets to keep track of transactions with dependencies dependent_transactions = set() depended_transactions = set() # Process the dependencies for u, v in dependencies: dependent_transactions.add(u) depended_transactions.add(v) # Find isolated transactions by subtracting dependent and depended transactions from all isolated_transactions = all_transactions - dependent_transactions - depended_transactions # Sort the isolated transactions isolated_transactions_sorted = sorted(isolated_transactions) return len(isolated_transactions_sorted), isolated_transactions_sorted # Example usage: n = 6 m = 3 categories = [1, 2, 3, 2, 1, 3] dependencies = [(1, 2), (2, 3), (3, 4)] result = find_isolated_transactions(n, m, categories, dependencies) print(result) # Output should be (2, [5, 6])"},{"question":"def min_energy_cost(n: int, grid: List[List[int]]) -> int: Returns the minimum energy cost required to reach the bottom-right cell from the top-left cell. >>> min_energy_cost(3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_energy_cost(2, [ ... [1, 2], ... [1, 1] ... ]) 3","solution":"def min_energy_cost(n, grid): Returns the minimum energy cost required to reach the bottom-right cell from the top-left cell. dp = [[0] * n for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] dp[0][i] = dp[0][i-1] + grid[0][i] for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][n-1]"},{"question":"def merge_times(n: int, times1: List[int], times2: List[int]) -> List[int]: Merges two lists of completion times into one sorted list without duplicates. Parameters: n (int): Number of participants times1 (list): List of completion times times2 (list): Duplicate list of completion times Returns: list: Sorted list of unique completion times >>> merge_times(5, [12, 34, 56, 78, 90], [12, 34, 56, 78, 90]) [12, 34, 56, 78, 90] >>> merge_times(7, [23, 45, 67, 89, 101, 123, 145], [45, 67, 89, 145, 156, 167, 178]) [23, 45, 67, 89, 101, 123, 145, 156, 167, 178] >>> merge_times(4, [10, 20, 30, 40], [30, 40, 50, 60]) [10, 20, 30, 40, 50, 60] >>> merge_times(3, [1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_times(1, [7], [7]) [7]","solution":"def merge_times(n, times1, times2): Merges two lists of completion times into one sorted list without duplicates. Parameters: n (int): Number of participants times1 (list): List of completion times times2 (list): Duplicate list of completion times Returns: list: Sorted list of unique completion times # Combine both lists and remove duplicates using a set all_times = set(times1 + times2) # Convert the set back to a sorted list sorted_unique_times = sorted(all_times) return sorted_unique_times"},{"question":"def password_strength_checker(T: int, passwords: List[str]) -> List[str]: Evaluates passwords based on specified criteria. Parameters: T (int): Number of passwords. passwords (list of str): List of passwords to be evaluated. Returns: list of str: List containing \\"VALID\\" or \\"INVALID\\" for each password. >>> password_strength_checker(3, [\\"Hello@123\\", \\"Pa55word!\\", \\"A1b2*c3\\"]) [\\"VALID\\", \\"VALID\\", \\"VALID\\"] >>> password_strength_checker(3, [\\"password\\", \\"HELLO@123\\", \\"pass2!c\\"]) [\\"INVALID\\", \\"INVALID\\", \\"INVALID\\"]","solution":"import re def password_strength_checker(T, passwords): Evaluates passwords based on specified criteria. Parameters: T (int): Number of passwords. passwords (list of str): List of passwords to be evaluated. Returns: list of str: List containing \\"VALID\\" or \\"INVALID\\" for each password. results = [] for password in passwords: if (len(password) >= 6 and re.search(\\"[A-Z]\\", password) and re.search(\\"[a-z]\\", password) and re.search(\\"[0-9]\\", password) and re.search(\\"[!@#%^&*]\\", password)): results.append(\\"VALID\\") else: results.append(\\"INVALID\\") return results"},{"question":"def can_form_sequence(n: int, heights: List[int]) -> str: Determines if pillars can be arranged such that the difference between any two adjacent pillars' heights is exactly one unit. Parameters: n (int): Number of pillars. heights (list): Heights of the pillars. Returns: str: \\"YES\\" if possible to rearrange, otherwise \\"NO\\". >>> can_form_sequence(5, [1, 2, 3, 4, 5]) \\"YES\\" >>> can_form_sequence(4, [4, 2, 1, 3]) \\"YES\\" >>> can_form_sequence(3, [7, 1, 4]) \\"NO\\"","solution":"def can_form_sequence(n, heights): Determines if pillars can be arranged such that the difference between any two adjacent pillars' heights is exactly one unit. Parameters: n (int): Number of pillars. heights (list): Heights of the pillars. Returns: str: \\"YES\\" if possible to rearrange, otherwise \\"NO\\". heights.sort() for i in range(1, n): if heights[i] - heights[i - 1] != 1: return \\"NO\\" return \\"YES\\""},{"question":"pass","solution":"def count_unique_duels(n): Returns the number of unique duels where there is a distinct winner between the warriors numbered 1 to n. Args: n : int : Number of warriors Returns: int : Number of unique duels # Every warrior can challenge every other warrior that comes before him return n * (n - 1) // 2 def solve(test_cases): Solves each test case by calculating the number of unique duels for each number of warriors. Args: test_cases : list : List of integers representing the number of warriors for each test case Returns: list : List of integers where each integer represents the number of unique duels results = [] for n in test_cases: results.append(count_unique_duels(n)) return results"},{"question":"def max_profit(prices): Returns the maximum profit that can be achieved from the given stock prices. # Your code goes here if __name__ == \\"__main__\\": # Test cases assert max_profit([7, 1, 5, 3, 6, 4]) == 5 assert max_profit([7, 6, 4, 3, 1]) == 0 assert max_profit([100]) == 0 assert max_profit([5, 5, 5, 5, 5]) == 0 assert max_profit([1, 2, 3, 4, 5]) == 4 assert max_profit([9, 2, 7, 3, 8, 4]) == 6 assert max_profit([]) == 0 prices = list(range(1000000, 0, -1)) assert max_profit(prices) == 0 assert max_profit([9, 2, 6, 1, 6]) == 5","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from the given stock prices. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def simplify_sequence(n: int, sequence: str) -> str: Simplifies the sequence of commands by removing consecutive repeating commands. Params: n (int): The length of the command sequence. sequence (str): The sequence of commands in the form of a string. Returns: str: The simplified sequence of commands. Examples: >>> simplify_sequence(6, \\"AAABCC\\") \\"ABC\\" >>> simplify_sequence(10, \\"ZZZYYYXXXX\\") \\"ZYX\\" >>> simplify_sequence(1, \\"A\\") \\"A\\"","solution":"def simplify_sequence(n, sequence): Simplifies the sequence of commands by removing consecutive repeating commands. Params: n (int): The length of the command sequence. sequence (str): The sequence of commands in the form of a string. Returns: str: The simplified sequence of commands. if n == 0: return '' simplified_sequence = sequence[0] # Start with the first character for i in range(1, n): if sequence[i] != sequence[i-1]: # Add only if it's different from the previous character simplified_sequence += sequence[i] return simplified_sequence"},{"question":"def count_distinct_substrings(s: str) -> int: Returns the number of distinct non-empty substrings of the given string s. >>> count_distinct_substrings(\\"abc\\") 6 >>> count_distinct_substrings(\\"aaa\\") 3 pass def process_input_output(test_cases: List[str]) -> List[int]: Processes multiple test cases and returns a list of results for each input string. >>> process_input_output([\\"abc\\", \\"aaa\\"]) [6, 3] >>> process_input_output([\\"a\\", \\"ab\\", \\"abab\\"]) [1, 3, 7] pass # Test cases from solution import count_distinct_substrings, process_input_output def test_count_distinct_substrings(): assert count_distinct_substrings(\\"abc\\") == 6 assert count_distinct_substrings(\\"aaa\\") == 3 assert count_distinct_substrings(\\"a\\") == 1 assert count_distinct_substrings(\\"ab\\") == 3 assert count_distinct_substrings(\\"abab\\") == 7 def test_process_input_output(): assert process_input_output([\\"abc\\", \\"aaa\\"]) == [6, 3] assert process_input_output([\\"a\\", \\"ab\\", \\"abab\\"]) == [1, 3, 7] def test_empty_string(): assert count_distinct_substrings(\\"\\") == 0 def test_long_string(): long_string = \\"a\\" * 1000 assert count_distinct_substrings(long_string) == 1000","solution":"def count_distinct_substrings(s): Returns the number of distinct non-empty substrings of the given string s. substrings = set() n = len(s) for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings) def process_input_output(test_cases): results = [] for s in test_cases: results.append(count_distinct_substrings(s)) return results"},{"question":"def min_operations(n, node_values, edges): Find the minimum number of operations required to convert the entire tree into a uniform binary tree. Input: - n: int, the number of nodes in the binary tree. - node_values: List[int], the values assigned to the nodes in the tree. - edges: List[Tuple[int, int]], the description of the edges between the nodes. Output: - int, the minimum number of operations required to convert the entire tree into a uniform binary tree. Example: >>> min_operations(5, [0, 1, 0, 1, 0], [(1, 2), (1, 3), (3, 4), (3, 5)]) 2 >>> min_operations(3, [1, 0, 0], [(1, 2), (1, 3)]) 1","solution":"def find_min_operations(n, node_values, edges): from collections import defaultdict graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def dfs(node, parent): count_0 = 0 if node_values[node - 1] else 1 count_1 = 1 if node_values[node - 1] else 0 for neighbor in graph[node]: if neighbor == parent: continue c0, c1 = dfs(neighbor, node) count_0 += c0 count_1 += c1 min_operations = min(count_0, count_1) return count_0, count_1 count_0, count_1 = dfs(1, -1) return min(count_0, count_1) def min_operations(n, node_values, edges): return find_min_operations(n, node_values, edges)"},{"question":"def find_unique_elements(n: int, arr: List[int]) -> List[int]: Finds the integers that appear only once in the array. Args: n: int - The number of elements in the array. arr: List[int] - The array of integers. Returns: List[int]: A sorted list of integers that appear only once. >>> find_unique_elements(7, [4, 3, 2, 7, 8, 2, 3]) [4, 7, 8] >>> find_unique_elements(5, [1, 2, 2, 3, 1]) [3] >>> find_unique_elements(3, [5, -1, 5]) [-1] >>> find_unique_elements(5, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> find_unique_elements(6, [10, 10, 20, 20, 30, 30]) [] >>> find_unique_elements(10, [1, 1, -1, -1, 2, 2, 3, 3, 4, 4]) [] >>> find_unique_elements(0, []) [] >>> find_unique_elements(1, [1]) [1] >>> find_unique_elements(1, [-1]) [-1] >>> find_unique_elements(10, [-10, 20, 30, -40, 50, 60, -70, 80, 90, -100]) sorted([-10, 20, 30, -40, 50, 60, -70, 80, 90, -100]) >>> large_input = list(range(1, 100001)) >>> find_unique_elements(100000, large_input) sorted(large_input)","solution":"def find_unique_elements(n, arr): Finds the elements that appear only once in the array. Args: n: int - The number of elements in the array. arr: List[int] - The array of integers. Returns: List[int]: A sorted list of elements that appear only once. element_count = {} # Count each number's frequency in the array for num in arr: if num in element_count: element_count[num] += 1 else: element_count[num] = 1 # Collect numbers that appear only once unique_elements = [num for num in element_count if element_count[num] == 1] # Return the sorted list of unique elements return sorted(unique_elements)"},{"question":"def can_form_concatenation(s: str, words: List[str]) -> str: Determines if any permutation of the string \`s\` can form a concatenation of all the words in the list \`words\` exactly once without any intervening characters. Args: s (str): A string given to form concatenations. words (List[str]): A list of words to be concatenated. Returns: str: \\"YES\\" if any permutation of \`s\` can form the concatenation, otherwise \\"NO\\". Examples: >>> can_form_concatenation(\\"aabbcc\\", [\\"ab\\", \\"bc\\"]) \\"YES\\" >>> can_form_concatenation(\\"aabb\\", [\\"ab\\", \\"bc\\"]) \\"NO\\"","solution":"from collections import Counter def can_form_concatenation(s, words): Determines if any permutation of the string \`s\` can form a concatenation of all the words in the list \`words\` exactly once without any intervening characters. # Combine all words into a single string combined_words = ''.join(words) # Count the frequency of each character in \`s\` s_counter = Counter(s) # Count the frequency of each character in the combined words combined_words_counter = Counter(combined_words) # For each character in combined_words_counter, check if \`s\` has enough to match for char, count in combined_words_counter.items(): if s_counter[char] < count: return \\"NO\\" return \\"YES\\""},{"question":"def count_significant_changes(n: int, T: int, readings: List[int]) -> int: Counts the number of significant temperature changes in the list of readings. Parameters: n (int): Number of temperature readings. T (int): Threshold for significant temperature change. readings (list of int): List of temperature readings. Returns: int: Number of significant temperature changes. >>> count_significant_changes(6, 5, [10, 7, 15, 10, 18, 12]) 3 >>> count_significant_changes(8, 4, [-1, 3, 0, 2, -4, 5, -5, 1]) 4 >>> count_significant_changes(5, 10, [1, 2, 3, 4, 5]) 0 >>> count_significant_changes(4, 0, [-1, 0, -1, 0]) 3 >>> count_significant_changes(1000, 50, [i for i in range(-500, 500)]) 0 >>> count_significant_changes(5, 200, [100, 50, 0, -50, -100]) 0","solution":"def count_significant_changes(n, T, readings): Counts the number of significant temperature changes in the list of readings. Parameters: n (int): Number of temperature readings. T (int): Threshold for significant temperature change. readings (list of int): List of temperature readings. Returns: int: Number of significant temperature changes. significant_changes = 0 for i in range(1, n): if abs(readings[i] - readings[i-1]) > T: significant_changes += 1 return significant_changes"},{"question":"def min_possible_final_sum(n: int, sequence: List[int]) -> int: Determines the minimum possible final sum of the sequence after performing the specified operations. >>> min_possible_final_sum(5, [1, 2, 3, 4, 5]) 15 >>> min_possible_final_sum(3, [5, 5, 5]) 15 >>> min_possible_final_sum(4, [1, 1, 1, 1]) 4 >>> min_possible_final_sum(1, [10]) 10 >>> min_possible_final_sum(6, [10, 20, 30, 40, 50, 60]) 210 >>> min_possible_final_sum(3, [1, 1, 1]) 3 >>> min_possible_final_sum(2, [100, 100]) 200","solution":"def min_possible_final_sum(n, sequence): Determines the minimum possible final sum of the sequence. return sum(sequence)"},{"question":"def maximize_abs_diff(n): Generates a shuffled deck of n cards such that the sum of the absolute differences between adjacent cards is maximized. :param n: Integer, the number of cards in the deck. :return: List of integers representing the maximized shuffled deck. >>> maximize_abs_diff(4) [1, 4, 2, 3] >>> maximize_abs_diff(5) [1, 5, 2, 4, 3] >>> maximize_abs_diff(1) [1] >>> maximize_abs_diff(2) [1, 2] >>> maximize_abs_diff(3) [1, 3, 2]","solution":"def maximize_abs_diff(n): Generates a shuffled deck of n cards such that the sum of the absolute differences between adjacent cards is maximized. :param n: Integer, the number of cards in the deck. :return: List of integers representing the maximized shuffled deck. result = [] left, right = 1, n while left <= right: if left == right: result.append(left) else: result.append(left) result.append(right) left += 1 right -= 1 return result"},{"question":"def maximize_games(n: int, m: int, times: List[int]) -> Tuple[int, List[int]]: Evaluate the maximum number of games that can be learned within the provided hours. Input: n -- the number of games m -- the total hours available for training times -- a list of integers representing the number of hours required to learn each game Output: Returns a tuple where the first element is the maximum number of games that can be learned, and the second element is a list of indices of these games. Examples: >>> maximize_games(5, 15, [3, 5, 8, 2, 4]) (4, [1, 2, 4, 5]) >>> maximize_games(6, 7, [2, 2, 2, 2, 2, 2]) (3, [1, 2, 3]) from solution import maximize_games def test_example_1(): assert maximize_games(5, 15, [3, 5, 8, 2, 4]) == (4, [1, 2, 4, 5]) def test_example_2(): assert maximize_games(6, 7, [2, 2, 2, 2, 2, 2]) == (3, [1, 2, 3]) def test_example_3(): assert maximize_games(3, 5, [6, 7, 2]) == (1, [3]) def test_example_4(): assert maximize_games(4, 0, [2, 4, 6, 8]) == (0, []) def test_no_time_alloted(): assert maximize_games(3, 0, [2, 1, 3]) == (0, []) def test_cannot_learn_any_games(): assert maximize_games(3, 1, [2, 3, 10]) == (0, [])","solution":"def maximize_games(n, m, times): hours_remaining = m games_learned = [] # Pair each game with its index and sort by learning time indexed_times = sorted(enumerate(times, start=1), key=lambda x: x[1]) for index, time in indexed_times: if hours_remaining >= time: games_learned.append(index) hours_remaining -= time else: break return len(games_learned), sorted(games_learned) # Example usage: # n = 5 # m = 15 # times = [3, 5, 8, 2, 4] # print(maximize_games(n, m, times)) # Output: (4, [1, 2, 4, 5])"},{"question":"def extract_poem_lines(poem_lines: List[str], num_lines: int) -> List[str]: Extracts the first N non-empty lines from a poem and trims leading/trailing spaces. Args: poem_lines (List[str]): List of strings representing the lines of the poem num_lines (int): Number of non-empty lines to return Returns: List[str]: List of strings representing the first N non-empty trimmed lines of the poem. >>> poem = [ ... \\" Once upon a midnight dreary, while I pondered, weak and weary, \\", ... \\" Over many a quaint and curious volume of forgotten lore \\", ... \\" While I nodded, nearly napping, suddenly there came a tapping, \\", ... \\" As of some one gently rapping, rapping at my chamber door. \\", ... \\" 'Tis some visitor', I muttered, 'tapping at my chamber door \\" ... ] >>> extract_poem_lines(poem, 3) ['Once upon a midnight dreary, while I pondered, weak and weary,', 'Over many a quaint and curious volume of forgotten lore', 'While I nodded, nearly napping, suddenly there came a tapping,'] >>> poem = [ ... \\" When he shall die, \\", ... \\" Take him and cut him out in little stars, \\", ... \\" And he will make the face of heaven so fine \\", ... \\" That all the world will be in love with night \\", ... \\" And pay no worship to the garish sun. \\" ... ] >>> extract_poem_lines(poem, 4) ['When he shall die,', 'Take him and cut him out in little stars,', 'And he will make the face of heaven so fine', 'That all the world will be in love with night'] >>> poem = [ ... \\" When he shall die, \\", ... \\" Take him and cut him out in little stars, \\", ... \\" And he will make the face of heaven so fine \\" ... ] >>> extract_poem_lines(poem, 4) ['When he shall die,', 'Take him and cut him out in little stars,', 'And he will make the face of heaven so fine'] >>> poem = [ ... \\" When he shall die, \\", ... \\" \\", ... \\" Take him and cut him out in little stars, \\", ... \\" \\", ... \\" \\", ... \\" And he will make the face of heaven so fine \\", ... \\" \\", ... \\" That all the world will be in love with night \\" ... ] >>> extract_poem_lines(poem, 4) ['When he shall die,', 'Take him and cut him out in little stars,', 'And he will make the face of heaven so fine', 'That all the world will be in love with night'] >>> poem = [ ... \\" Line with leading and trailing spaces \\", ... \\" Another line \\", ... \\" And another one with spaces at end \\", ... \\"No spaces\\" ... ] >>> extract_poem_lines(poem, 4) ['Line with leading and trailing spaces', 'Another line', 'And another one with spaces at end', 'No spaces']","solution":"def extract_poem_lines(poem_lines, num_lines): Extracts the first N non-empty lines from the poem and trims leading/trailing spaces. :param poem_lines: List of strings representing the lines of the poem :param num_lines: Integer representing the number of non-empty lines to return :return: List of strings representing the first N non-empty trimmed lines of the poem result = [] for line in poem_lines: trimmed_line = line.strip() if trimmed_line: result.append(trimmed_line) if len(result) == num_lines: break return result"},{"question":"def largest_mystic_number(b: int, m: int, allowed_digits: List[str], n: int) -> str: Returns the largest possible Mystic Number of length n using the allowed digits. Parameters: b (int): The base of the Mystic Number system (2 <= b <= 36). m (int): The number of allowed digits (1 <= m <= b). allowed_digits (list): List of allowed characters representing the digits. n (int): The desired length of the Mystic Number (1 <= n <= 105). Returns: str: The largest possible Mystic Number of length n, or \\"-1\\" if it cannot be formed. Examples: >>> largest_mystic_number(10, 3, ['3', '1', '4'], 5) \\"44444\\" >>> largest_mystic_number(16, 5, ['F', 'A', 'B', '3', '2'], 8) \\"FFFFFFA\\" >>> largest_mystic_number(8, 1, ['7'], 3) \\"777\\" >>> largest_mystic_number(8, 1, ['0'], 3) \\"000\\" >>> largest_mystic_number(16, 1, ['5'], 6) \\"555555\\"","solution":"def largest_mystic_number(b, m, allowed_digits, n): Returns the largest possible Mystic Number of length n using the allowed digits. Parameters: b (int): The base of the Mystic Number system (2 <= b <= 36). m (int): The number of allowed digits (1 <= m <= b). allowed_digits (list): List of allowed characters representing the digits. n (int): The desired length of the Mystic Number (1 <= n <= 105). Returns: str: The largest possible Mystic Number of length n, or \\"-1\\" if it cannot be formed. # Check if it is possible to form a number of length n if len(allowed_digits) == 0: return \\"-1\\" # Sort the allowed digits in descending order to get the largest possible number sorted_digits = sorted(allowed_digits, reverse=True) # The largest digit is the first in the sorted list largest_digit = sorted_digits[0] # Create the largest possible number of length n using the largest allowed digit largest_number = largest_digit * n return largest_number"},{"question":"def can_half_participants_finish(N: int, T: int, speeds: List[int], distances: List[int]) -> str: Determine if at least half of the participants can finish the race within the time limit. >>> can_half_participants_finish(6, 10, [5, 10, 3, 8, 2, 6], [50, 100, 30, 40, 25, 60]) == \\"YES\\" >>> can_half_participants_finish(3, 1, [1, 1, 1], [3, 3, 4]) == \\"NO\\" >>> can_half_participants_finish(3, 2, [3, 4, 2], [6, 9, 5]) == \\"NO\\" >>> can_half_participants_finish(5, 5, [5, 5, 5, 5, 5], [25, 20, 10, 15, 35]) == \\"YES\\" >>> can_half_participants_finish(4, 5, [5, 5, 1, 1], [25, 20, 15, 10]) == \\"YES\\"","solution":"def can_half_participants_finish(N, T, speeds, distances): completed_count = 0 for i in range(N): if distances[i] / speeds[i] <= T: completed_count += 1 return \\"YES\\" if completed_count * 2 >= N else \\"NO\\""},{"question":"def solve_amusement_park(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) test_cases = [] line_index = 1 for _ in range(T): N = int(input_lines[line_index]) values = list(map(int, input_lines[line_index + 1].split())) test_cases.append((N, values)) line_index += 2 def max_adrenaline(T, test_cases): def max_subarray_sum(arr): max_sum = float('-inf') current_sum = 0 for value in arr: current_sum += value if current_sum < 0: current_sum = 0 max_sum = max(max_sum, current_sum) return max_sum results = [] for i in range(T): N, values = test_cases[i] max_sum = float('-inf') # Calculate maximum sum for both directions for j in range(N): clockwise = values[j:] + values[:j] counterclockwise = values[j::-1] + values[:j:-1] max_sum = max(max_sum, max_subarray_sum(clockwise), max_subarray_sum(counterclockwise)) results.append(max_sum) return results results = max_adrenaline(T, test_cases) for result in results: print(result) def test_max_adrenaline(): input_data = \\"1n5n1 -2 3 4 -5n\\" expected_output = \\"7\\" solve_amusement_park(input_data) def test_max_adrenaline_single_value(): input_data = \\"1n1n5n\\" expected_output = \\"5\\" solve_amusement_park(input_data) def test_max_adrenaline_all_negative_values(): input_data = \\"1n4n-1 -2 -3 -4n\\" expected_output = \\"0\\" solve_amusement_park(input_data) def test_max_adrenaline_mixed_values(): input_data = 2 5 1 -2 3 4 -1 6 2 -1 2 3 -4 5 expected_output = \\"7n7\\" solve_amusement_park(input_data)","solution":"def max_adrenaline(T, test_cases): def max_subarray_sum(arr): max_sum = float('-inf') current_sum = 0 for value in arr: current_sum += value if current_sum < 0: current_sum = 0 max_sum = max(max_sum, current_sum) return max_sum results = [] for i in range(T): N, values = test_cases[i] max_sum = float('-inf') # Calculate maximum sum for both directions for j in range(N): clockwise = values[j:] + values[:j] counterclockwise = values[j::-1] + values[:j:-1] max_sum = max(max_sum, max_subarray_sum(clockwise), max_subarray_sum(counterclockwise)) results.append(max_sum) return results # Wrapper function to handle input and output def solve_amusement_park(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) test_cases = [] line_index = 1 for _ in range(T): N = int(input_lines[line_index]) values = list(map(int, input_lines[line_index + 1].split())) test_cases.append((N, values)) line_index += 2 results = max_adrenaline(T, test_cases) for result in results: print(result)"},{"question":"def find_last_player_remaining(n: int, k: int, skills: List[int]) -> int: Given the number of players, the decrement value k, and a list of skill levels, determine the last player remaining after a series of competitions. >>> find_last_player_remaining(4, 10, [40, 30, 20, 10]) 1 >>> find_last_player_remaining(3, 5, [15, 30, 25]) 2","solution":"def find_last_player_remaining(n, k, skills): players = [(skills[i], i + 1) for i in range(n)] while len(players) > 1: players.sort(reverse=True, key=lambda x: x[0]) winner, winner_id = players[0] loser, loser_id = players[1] loser -= k if loser > 0: players[1] = (loser, loser_id) else: players.pop(1) return players[0][1]"},{"question":"def max_growth(heights: List[List[int]]) -> int: Determine the maximum growth observed in height between any two days for some plant. >>> max_growth([[1, 5, 3, 6, 4], [2, 2, 2, 8, 7], [3, 6, 3, 5, 8]]) 6 >>> max_growth([[7, 14, 9, 10], [6, 7, 8, 8]]) 7 >>> max_growth([[1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4]]) 0 >>> max_growth([[1, 10000], [5000, 10000]]) 9999 >>> max_growth([[5, 6, 7, 8, 15]]) 10 >>> max_growth([[1, 2, 3, 3, 2]]) 2","solution":"def max_growth(heights): n = len(heights) D = len(heights[0]) max_growth_value = 0 for i in range(n): for t1 in range(D): for t2 in range(t1 + 1, D): growth = heights[i][t2] - heights[i][t1] if growth > max_growth_value: max_growth_value = growth return max_growth_value"},{"question":"def max_photo_height_in_intervals(N, heights, queries): Function to determine the maximum photo height in given intervals. Parameters: N : int : Number of slots in the album heights : list : Heights of each photo in the slots queries : list : List of tuples, each containing two integers (a, b) Returns: list : A list containing the max height for each query interval >>> max_photo_height_in_intervals(10, [5, 3, 8, 7, 2, 6, 12, 4, 9, 11], [(1, 3), (4, 6), (0, 9)]) [8, 12, 12] >>> max_photo_height_in_intervals(5, [1, 2, 3, 4, 5], [(0, 4)]) [5]","solution":"def max_photo_height_in_intervals(N, heights, queries): Function to determine the maximum photo height in given intervals. Parameters: N : int : Number of slots in the album heights : list : Heights of each photo in the slots queries : list : List of tuples, each containing two integers (a, b) Returns: list : A list containing the max height for each query interval results = [] for a, b in queries: results.append(max(heights[a:b+1])) return results"},{"question":"def merge(nums1: List[int], m: int, nums2: List[int], n: int) -> None: Merges nums2 into nums1 as one sorted array in-place. >>> nums1 = [1, 2, 3, 0, 0, 0] >>> m = 3 >>> nums2 = [2, 5, 6] >>> n = 3 >>> merge(nums1, m, nums2, n) >>> nums1 [1, 2, 2, 3, 5, 6]","solution":"def merge(nums1, m, nums2, n): Merges nums2 into nums1 as one sorted array in-place. # Start from the end of the arrays while m > 0 and n > 0: if nums1[m-1] > nums2[n-1]: nums1[m + n - 1] = nums1[m - 1] m -= 1 else: nums1[m + n - 1] = nums2[n - 1] n -= 1 # If there are remaining elements in nums2, copy them while n > 0: nums1[n - 1] = nums2[n - 1] n -= 1"},{"question":"def max_profit(prices): You are given a list of integers representing the stock prices of a company in chronological order. As an investor, you can make at most one transaction (i.e., you can buy and sell one share of the stock once). You want to maximize your profit by choosing a single day to buy one share and a different day in the future to sell that share. Returns the maximum profit you can achieve from this transaction. If no profit can be made, return 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Returns the maximum profit from a single buy and sell. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def queue_management(n: int, customers: List[Tuple[int, int]]) -> List[int]: This function simulates the queue management system and returns the order in which customers should be served based on their priority and arrival time. Args: n (int): Number of customers customers (list of tuples): List of tuples where each tuple contains two integers, arrival time and priority of a customer Returns: list: Order of customers to be served based on their priority and arrival time Example: >>> queue_management(5, [(1, 3), (2, 5), (3, 2), (4, 5), (5, 1)]) [2, 4, 1, 3, 5] >>> queue_management(3, [(1, 2), (2, 1), (3, 2)]) [1, 3, 2] >>> queue_management(4, [(1, 4), (2, 3), (3, 2), (4, 1)]) [1, 2, 3, 4]","solution":"def queue_management(n, customers): This function simulates the queue management system and returns the order in which customers should be served based on their priority and arrival time. Args: n (int): Number of customers customers (list of tuples): List of tuples where each tuple contains two integers, arrival time and priority of a customer Returns: list: Order of customers to be served based on their priority and arrival time # Sort the customers based on priority in descending order, if priority is same then by arrival time in ascending order sorted_customers = sorted(customers, key=lambda x: (-x[1], x[0])) # Extract and return the order of customers based on sorted list return [customers.index(c) + 1 for c in sorted_customers]"},{"question":"def manage_inventory(operations: List[str]) -> List[str]: Handle a list of inventory operations and return the results of 'QUERY' operations. Operations include: - \\"ADD <ID> <NAME> <QUANTITY>\\": Adds/updates a product with the given ID, name, and quantity. - \\"UPDATE <ID> <QUANTITY>\\": Updates the quantity of the product with the given ID. - \\"QUERY <ID>\\": Queries the quantity of the product with the given ID. Returns a list of results for each 'QUERY' operation. >>> manage_inventory([\\"ADD 1 Apple 50\\", \\"ADD 2 Banana 100\\", \\"QUERY 1\\", \\"UPDATE 2 150\\", \\"QUERY 2\\"]) [\\"50\\", \\"150\\"] >>> manage_inventory([\\"ADD 1 Apple 50\\", \\"UPDATE 1 70\\", \\"QUERY 1\\", \\"QUERY 3\\"]) [\\"70\\", \\"Product not found\\"]","solution":"def manage_inventory(operations): inventory = {} output = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"ADD\\": id = int(parts[1]) name = parts[2] quantity = int(parts[3]) inventory[id] = {'name': name, 'quantity': quantity} elif command == \\"UPDATE\\": id = int(parts[1]) quantity = int(parts[2]) if id in inventory: inventory[id]['quantity'] = quantity elif command == \\"QUERY\\": id = int(parts[1]) if id in inventory: output.append(str(inventory[id]['quantity'])) else: output.append(\\"Product not found\\") return output"},{"question":"def count_distinct_elements(n: int, m: int, sequence: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given a sequence of n integers and a list of m queries, return a list of integers where each integer is the number of distinct elements in the specified subsequence for that query. Parameters: n (int): The number of elements in the sequence. m (int): The number of queries. sequence (List[int]): The elements of the sequence. queries (List[Tuple[int, int]]): A list of queries, each given by two integers l and r. Returns: List[int]: List of integers representing the number of distinct elements in the specified subsequence for each query. Examples: >>> count_distinct_elements(6, 3, [1, 2, 1, 3, 2, 4], [(1, 3), (2, 5), (1, 6)]) [2, 3, 4] >>> count_distinct_elements(5, 2, [1, 1, 1, 1, 1], [(1, 5), (2, 4)]) [1, 1]","solution":"def count_distinct_elements(n, m, sequence, queries): result = [] for l, r in queries: distinct_elements = set(sequence[l-1:r]) result.append(len(distinct_elements)) return result"},{"question":"def min_jumps(arr: List[int]) -> int: Returns the minimum number of jumps needed for the frog to reach the end of the array. If the end is not reachable, return -1. >>> min_jumps([2, 3, 1, 1, 4]) 2 >>> min_jumps([3, 2, 1, 0, 4]) -1 >>> min_jumps([1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9]) 3 >>> min_jumps([1]) 0 >>> min_jumps([0, 1, 2, 3, 4, 5]) -1 >>> min_jumps([1000] * 1000) 1 >>> min_jumps([1, 1, 1, 1, 1, 1, 1, 1, 1]) 8","solution":"def min_jumps(arr): Returns the minimum number of jumps needed for the frog to reach the end of the array. If the end is not reachable, return -1. n = len(arr) if n == 1: return 0 if arr[0] == 0: return -1 jumps = 0 current_end = 0 current_farthest = 0 for i in range(n): current_farthest = max(current_farthest, i + arr[i]) if i == current_end: jumps += 1 current_end = current_farthest if current_end >= n - 1: return jumps if i >= current_farthest: return -1 return -1"},{"question":"def max_candies(n: int, houses: List[int]) -> int: Find the maximum number of candies that can be collected from a list of houses, where no candies can be collected from two consecutive houses. >>> max_candies(5, [3, 2, 5, 10, 7]) 15 >>> max_candies(3, [1, 2, 3]) 4","solution":"def max_candies(n, houses): if n == 0: return 0 elif n == 1: return houses[0] dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1] # Example usage if __name__ == \\"__main__\\": n = int(input().strip()) houses = list(map(int, input().strip().split())) print(max_candies(n, houses))"},{"question":"def minimized_inspection_time(N: int, T: List[int]) -> int: Minimizes the total inspection time using three parallel inspection stations. Args: N : int : number of products T : list : list of inspection times for each product Returns: int : minimized total time taken to inspect all products >>> minimized_inspection_time(4, [1, 1, 1, 1]) 2 >>> minimized_inspection_time(9, [15, 20, 27, 4, 10, 7, 34, 30, 36]) 61 >>> minimized_inspection_time(6, [20, 18, 46, 16, 9, 48]) 55 >>> minimized_inspection_time(1, [5]) 5 >>> minimized_inspection_time(3, [10, 10, 10]) 10 >>> minimized_inspection_time(5, [2, 3, 5, 7, 11]) 11 >>> minimized_inspection_time(1, [1]) 1 >>> minimized_inspection_time(3, [50, 50, 50]) 50","solution":"def minimized_inspection_time(N, T): Minimizes the total inspection time using three parallel inspection stations. Args: N : int : number of products T : list : list of inspection times for each product Returns: int : minimized total time taken to inspect all products # Sort products in descending order of inspection times T.sort(reverse=True) # Initialize stations with zero time stations = [0, 0, 0] # Assign each product to the station with the least current time for time in T: least_loaded = stations.index(min(stations)) stations[least_loaded] += time # The total time taken is the maximum loaded station time return max(stations)"},{"question":"def is_fountain_installed(x: int, y: int) -> str: Determines if a fountain is installed at grid corner (x, y). A fountain is installed if x and y are coprime numbers. :param x: Integer x-coordinate of the grid corner. :param y: Integer y-coordinate of the grid corner. :return: \\"Yes\\" if a fountain is installed, otherwise \\"No\\". >>> is_fountain_installed(3, 4) == \\"Yes\\" >>> is_fountain_installed(4, 6) == \\"No\\" >>> is_fountain_installed(7, 9) == \\"Yes\\" >>> is_fountain_installed(0, 1) == \\"Yes\\" >>> is_fountain_installed(-3, 4) == \\"Yes\\"","solution":"import math def is_fountain_installed(x, y): Determines if a fountain is installed at grid corner (x, y). A fountain is installed if x and y are coprime numbers. :param x: Integer x-coordinate of the grid corner. :param y: Integer y-coordinate of the grid corner. :return: \\"Yes\\" if a fountain is installed, otherwise \\"No\\". return \\"Yes\\" if math.gcd(x, y) == 1 else \\"No\\""},{"question":"def is_subsequence(n: int, m: int, A: list, B: list) -> str: Determines if B is a subsequence of A. Parameters: n : int - length of array A m : int - length of array B A : list of int - array A B : list of int - array B Returns: str - \\"YES\\" if B is a subsequence of A, otherwise \\"NO\\" Examples: >>> is_subsequence(5, 3, [1, 2, 3, 4, 5], [2, 4, 5]) \\"YES\\" >>> is_subsequence(5, 3, [1, 2, 3, 4, 5], [3, 1, 4]) \\"NO\\" >>> is_subsequence(6, 4, [1, 1, 2, 3, 5, 8], [1, 2, 5, 8]) \\"YES\\"","solution":"def is_subsequence(n, m, A, B): Determines if B is a subsequence of A. Parameters: n : int - length of array A m : int - length of array B A : list of int - array A B : list of int - array B Returns: str - \\"YES\\" if B is a subsequence of A, otherwise \\"NO\\" it = iter(A) return \\"YES\\" if all(b in it for b in B) else \\"NO\\""},{"question":"def max_sum_subarray_k_elements(n: int, k: int, arr: List[int]) -> int: Returns the maximum sum of a subarray with exactly k elements. >>> max_sum_subarray_k_elements(5, 3, [2, 1, 5, 1, 3]) 9 >>> max_sum_subarray_k_elements(6, 2, [1, 2, 3, 4, 5, 6]) 11 >>> max_sum_subarray_k_elements(4, 2, [-1, -2, -3, -4]) -3 >>> max_sum_subarray_k_elements(5, 2, [-2, 4, -1, 3, 6]) 9 >>> max_sum_subarray_k_elements(5, 5, [1, -2, 3, 4, -1]) 5 >>> max_sum_subarray_k_elements(1, 1, [5]) 5 >>> max_sum_subarray_k_elements(5, 3, [-1000, -1000, -1000, -1000, -1000]) -3000 from typing import List","solution":"def max_sum_subarray_k_elements(n, k, arr): Returns the maximum sum of a subarray with exactly k elements. Parameters: n (int): The size of the array. k (int): The number of elements in the subarray. arr (list): The elements of the array. Returns: int: The maximum sum of a subarray with exactly k elements. # Check if the array length is less than k if n < k: return 0 # Calculate the sum of the first 'k' elements max_sum = sum(arr[:k]) current_sum = max_sum # Slide through the array to find the maximum sum of k consecutive elements for i in range(k, n): current_sum += arr[i] - arr[i-k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def max_unique_squares(k: int) -> int: Calculate and return the maximum number of unique squares a knight can visit on a standard 8x8 chessboard after k moves. >>> max_unique_squares(0) 1 >>> max_unique_squares(1) 8 >>> max_unique_squares(2) 27 >>> max_unique_squares(3) 48 >>> max_unique_squares(4) 64 >>> max_unique_squares(1000) 64 >>> max_unique_squares(int(1e9)) 64","solution":"def max_unique_squares(k): Returns the maximum number of unique squares a knight can visit on an 8x8 chessboard after exactly k moves. if k == 0: return 1 elif k == 1: return 8 elif k == 2: return 27 elif k == 3: return 48 else: return 64"},{"question":"def max_odd_magic_power(n: int, magic_powers: List[int]) -> int: Returns the maximum magic power that the mage can collect such that the total magic power is an odd number. Parameters: n (int): The number of magical trees in the forest. magic_powers (list): A list of integers representing the magic power of the fruits on each tree. Returns: int: Maximum odd total magic power or -1 if there's no such way to collect. >>> max_odd_magic_power(5, [2, 4, 3, 5, 1]) 15 >>> max_odd_magic_power(1, [5]) 5 >>> max_odd_magic_power(4, [2, 4, 6, 8]) -1 >>> max_odd_magic_power(6, [1, 2, 3, 4, 5, 6]) 21 >>> max_odd_magic_power(1, [2]) -1 >>> max_odd_magic_power(100, list(range(1, 101))) 5050 >>> max_odd_magic_power(5, [1, 2, 3, 4, 5]) 15","solution":"def max_odd_magic_power(n, magic_powers): Returns the maximum magic power that the mage can collect such that the total magic power is an odd number. Parameters: n (int): The number of magical trees in the forest. magic_powers (list): A list of integers representing the magic power of the fruits on each tree. Returns: int: Maximum odd total magic power or -1 if there's no such way to collect. max_odd_sum = -1 for i in range(n): current_sum = 0 for j in range(i, n): current_sum += magic_powers[j] if current_sum % 2 == 1: max_odd_sum = max(max_odd_sum, current_sum) return max_odd_sum"},{"question":"def max_unique_decorations(n: int, m: int) -> int: Returns the maximum number of unique decoration types that can be used. >>> max_unique_decorations(3, 5) 3 >>> max_unique_decorations(4, 10) 4 >>> max_unique_decorations(5, 5) 5 >>> max_unique_decorations(2, 1) 1 >>> max_unique_decorations(7, 0) 0 >>> max_unique_decorations(1, 1000) 1 >>> max_unique_decorations(100000, 1000000000) 100000","solution":"def max_unique_decorations(n, m): Returns the maximum number of unique decoration types that can be used. # The maximum number of unique decorations Bob can use is the minimum # between the number of decoration types and the total number of decorations return min(n, m)"},{"question":"def digital_reduce(n: int) -> int: Returns the single-digit result of digitally reducing the number n. Parameters: n: int - input number to be digitally reduced Returns: int - the single-digit result of the digital reduction >>> digital_reduce(123) 6 >>> digital_reduce(9876) 3 >>> digital_reduce(5) 5 def process_test_cases(t: int, test_cases: List[int]) -> List[int]: Processes multiple test cases for digital reduction. Parameters: t: int - number of test cases test_cases: list of int - the input numbers for each test case Returns: list of int - the single-digit result for each test case >>> process_test_cases(3, [123, 9876, 5]) [6, 3, 5] >>> process_test_cases(4, [123, 999, 12345, 0]) [6, 9, 6, 0]","solution":"def digital_reduce(n): Returns the single-digit result of digitally reducing the number n. while n >= 10: n = sum(int(digit) for digit in str(n)) return n def process_test_cases(t, test_cases): Processes multiple test cases for digital reduction. Parameters: t: int - number of test cases test_cases: list of int - the input numbers for each test case Returns: list of int - the single-digit result for each test case results = [] for n in test_cases: results.append(digital_reduce(n)) return results"},{"question":"from typing import List def count_ways(n: int) -> int: Calculate the total number of ways to decorate the staircase with N steps such that no three consecutive steps are decorated with flowers. Args: n (int): The number of steps in the staircase. Returns: int: The total number of ways to decorate the staircase. >>> count_ways(3) 7 >>> count_ways(4) 13 >>> count_ways(0) 1 >>> count_ways(1) 2 >>> count_ways(2) 4 pass def solve(test_cases: List[int]) -> List[int]: Calculate the total number of ways to decorate the staircase for each test case. Args: test_cases (list of int): A list where each integer represents the number of steps in the staircase. Returns: list of int: A list where each integer represents the total number of ways to decorate the staircase for the corresponding test case. >>> solve([3, 4]) [7, 13] >>> solve([0, 1, 2]) [1, 2, 4] pass","solution":"def count_ways(n): if n == 0: return 1 elif n == 1: return 2 elif n == 2: return 4 elif n == 3: return 7 dp = [0] * (n + 1) dp[0] = 1 dp[1] = 2 dp[2] = 4 dp[3] = 7 for i in range(4, n + 1): dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] return dp[n] def solve(test_cases): results = [] for n in test_cases: results.append(count_ways(n)) return results"},{"question":"def maximum_profit(test_cases): You are given a list of integers where each integer represents the profit or loss for each day. Your goal is to determine the maximum profit that can be made by buying and selling on the same day. A transaction consists of buying on day i and selling on day j (i <= j). You need to find a contiguous subarray which has the maximum sum. Input The first line contains an integer T (1  T  10), the number of test cases. For each test case: - The first line contains a single integer n (1  n  10^5), the length of the list. - The second line contains n integers, representing the profit or loss for each day. The integers are space-separated and can range from -10^4 to 10^4. Output For each test case, output a single integer, the maximum profit that can be achieved with a transaction on a contiguous subarray. Examples: >>> maximum_profit([(5, [3, -2, 5, -1, 2]), (4, [-1, -2, -3, -4]), (6, [1, 2, 3, 4, -10, 5])]) [7, -1, 10] >>> maximum_profit([(4, [-5, -1, -8, -3])]) [-1] pass def process_input(input_data): Function to parse the input data and run the maximum_profit function. Examples: >>> input_data = \\"3n5n3 -2 5 -1 2n4n-1 -2 -3 -4n6n1 2 3 4 -10 5n\\" >>> process_input(input_data) [7, -1, 10] >>> input_data = \\"1n4n-5 -1 -8 -3n\\" >>> process_input(input_data) [-1] pass # Unit Tests def test_maximum_profit(): input_data = \\"3n5n3 -2 5 -1 2n4n-1 -2 -3 -4n6n1 2 3 4 -10 5n\\" expected_output = [7, -1, 10] assert process_input(input_data) == expected_output def test_maximum_profit_all_negative(): input_data = \\"1n4n-5 -1 -8 -3n\\" expected_output = [-1] assert process_input(input_data) == expected_output def test_maximum_profit_single_element(): input_data = \\"1n1n5n\\" expected_output = [5] assert process_input(input_data) == expected_output def test_maximum_profit_mixed_values(): input_data = \\"1n8n-2 1 -3 4 -1 2 1 -5n\\" expected_output = [6] # The subarray [4, -1, 2, 1] has maximum sum = 6 assert process_input(input_data) == expected_output def test_maximum_profit_zeros(): input_data = \\"1n7n0 0 0 0 0 0 0n\\" expected_output = [0] assert process_input(input_data) == expected_output","solution":"def maximum_profit(test_cases): results = [] for case in test_cases: n, profits_or_losses = case max_profit = float('-inf') current_sum = 0 for profit_loss in profits_or_losses: current_sum += profit_loss if current_sum > max_profit: max_profit = current_sum if current_sum < 0: current_sum = 0 results.append(max_profit) return results # Function to parse the input data and run the maximum_profit function def process_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): n = int(lines[index]) profits_or_losses = list(map(int, lines[index + 1].split())) test_cases.append((n, profits_or_losses)) index += 2 return maximum_profit(test_cases)"},{"question":"def maximalRectangle(matrix): Tommy wants to fence off the largest possible rectangular sub-garden of soil cells only. Determine the area of this largest rectangular sub-garden. >>> maximalRectangle([[1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [0, 1, 1, 1, 0], [1, 1, 0, 1, 1]]) 6 >>> maximalRectangle([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) 1 >>> maximalRectangle([]) 0 >>> maximalRectangle([[1, 1], [1, 1]]) 4 >>> maximalRectangle([[0, 1, 0], [1, 1, 1], [0, 1, 1]]) 4 >>> maximalRectangle([[0, 0], [0, 0]]) 0","solution":"def maximalRectangle(matrix): if not matrix: return 0 n = len(matrix) m = len(matrix[0]) heights = [0] * m max_area = 0 for row in matrix: for i in range(m): if row[i] == 0: heights[i] = 0 else: heights[i] += 1 max_area = max(max_area, largestRectangleArea(heights)) return max_area def largestRectangleArea(heights): stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area"},{"question":"def max_distinct_arrays(m: int, moduli: List[int]) -> int: Calculate the maximum number of distinct arrays modulo 10^9 + 9. Parameters: m (int): Number of elements in the array. moduli (list of int): List of m-space-separated prime numbers. Returns: int: The maximum number of distinct arrays modulo 10^9 + 9. pass # Unit Tests def test_example_1(): assert max_distinct_arrays(3, [3, 5, 7]) == 105 def test_example_2(): assert max_distinct_arrays(2, [11, 13]) == 143 def test_small_input(): assert max_distinct_arrays(1, [2]) == 2 assert max_distinct_arrays(1, [3]) == 3 assert max_distinct_arrays(1, [5]) == 5 def test_large_values(): assert max_distinct_arrays(2, [1000003, 1000009]) == 1000003 * 1000009 % (10**9 + 9) assert max_distinct_arrays(2, [1999993, 1999997]) == 1999993 * 1999997 % (10**9 + 9) def test_zero_moduli(): assert max_distinct_arrays(0, []) == 1 # Edge case with no moduli def test_max_moduli_range(): moduli = [1000003] * 200000 result = 1 for q in moduli: result *= q result %= 10**9 + 9 assert max_distinct_arrays(200000, moduli) == result","solution":"def max_distinct_arrays(m, moduli): Calculate the maximum number of distinct arrays modulo 10^9 + 9. Parameters: m (int) - number of elements in the array. moduli (list of int) - m-space-separated prime numbers. Returns: int - the maximum number of distinct arrays modulo 10^9 + 9. MOD = 10**9 + 9 result = 1 for q in moduli: result *= q result %= MOD return result # Example input and function call m = 3 moduli = [3, 5, 7] print(max_distinct_arrays(m, moduli)) # Output: 105"},{"question":"def solve_river_crossing_puzzle(): Find a sequence of moves to solve the river crossing puzzle with a farmer, wolf, goat, and cabbage. The function should return a list of moves required to solve the puzzle or indicate that no solution exists. >>> solve_river_crossing_puzzle() ['farmer and goat', 'farmer alone', 'farmer and wolf', 'farmer and goat', 'farmer and cabbage', 'farmer alone', 'farmer and goat']","solution":"def solve_river_crossing_puzzle(): Returns a list of moves to solve the river crossing puzzle. return [ 'farmer and goat', 'farmer alone', 'farmer and wolf', 'farmer and goat', 'farmer and cabbage', 'farmer alone', 'farmer and goat' ]"},{"question":"def activity_times(n, m, ids, times, q, queries): Calculate the sum of activity times for each query range. :param n: int - Number of employees :param m: int - Number of minutes (logs) :param ids: list of int - Employee IDs for each minute :param times: list of int - Time spent by employees for each minute :param q: int - Number of queries :param queries: list of tuple - Each tuple contains start and end (inclusive) of the range of minutes :return: list of int - List of results for each query >>> activity_times(4, 5, [1, 2, 3, 3, 1], [3, 2, 4, 1, 2], 3, [(1, 3), (2, 5), (1, 5)]) [9, 9, 12] >>> activity_times(3, 4, [1, 2, 1, 3], [10, 20, 10, 30], 2, [(1, 2), (2, 4)]) [30, 60] >>> activity_times(2, 3, [1, 2, 1], [5, 10, 15], 1, [(1, 3)]) [30] >>> activity_times(1, 3, [1, 1, 1], [5, 10, 15], 2, [(1, 1), (1, 3)]) [5, 30] >>> activity_times(5, 6, [1, 2, 3, 4, 5, 1], [7, 8, 9, 10, 11, 12], 3, [(1, 3), (2, 5), (3, 6)]) [24, 38, 42]","solution":"def activity_times(n, m, ids, times, q, queries): Calculate the sum of activity times for each query range. :param n: int - Number of employees :param m: int - Number of minutes (logs) :param ids: list of int - Employee IDs for each minute :param times: list of int - Time spent by employees for each minute :param q: int - Number of queries :param queries: list of tuple - Each tuple contains start and end (inclusive) of the range of minutes :return: list of int - List of results for each query # Create a prefix sum array to store the cumulative sum up to each minute prefix_sum = [0] * (m + 1) for i in range(1, m + 1): prefix_sum[i] = prefix_sum[i - 1] + times[i - 1] results = [] for start, end in queries: results.append(prefix_sum[end] - prefix_sum[start - 1]) return results"},{"question":"def sum_of_distinct_integers(arr: List[int]) -> int: Given an array of integers, determine the sum of all distinct integers after removing all pairs of adjacent equal integers until no such pairs exist. >>> sum_of_distinct_integers([2, 1, 2, 2, 3, 1, 3]) 6 >>> sum_of_distinct_integers([4, 4, 4, 4, 4]) 4 >>> sum_of_distinct_integers([1, 2, 2, 1, 3, 4, 4, 5]) 8 pass def test_sum_of_distinct_integers_example_1(): assert sum_of_distinct_integers([2, 1, 2, 2, 3, 1, 3]) == 6 def test_sum_of_distinct_integers_example_2(): assert sum_of_distinct_integers([4, 4, 4, 4, 4]) == 4 def test_sum_of_distinct_integers_example_3(): assert sum_of_distinct_integers([1, 2, 2, 1, 3, 4, 4, 5]) == 8 def test_sum_of_distinct_integers_no_adjacent_pairs(): assert sum_of_distinct_integers([1, 2, 3, 4, 5]) == 15 def test_sum_of_distinct_integers_all_adjacent_pairs(): assert sum_of_distinct_integers([1, 1, 2, 2, 3, 3]) == 0 def test_sum_of_distinct_integers_some_adjacent_pairs(): assert sum_of_distinct_integers([1, 1, 2, 2, 3, 4, 4, 5]) == 8 def test_sum_of_distinct_integers_single_element(): assert sum_of_distinct_integers([10]) == 10 def test_sum_of_distinct_integers_large_numbers(): assert sum_of_distinct_integers([10000, 10000, -10000, -10000, 9999]) == 9999","solution":"def sum_of_distinct_integers(arr): Returns the sum of all distinct integers after removing adjacent equal integers in pairs. stack = [] for num in arr: if stack and stack[-1] == num: stack.pop() else: stack.append(num) return sum(set(stack))"},{"question":"def top_k_sum_of_exhibition_scores(n, m, k, scores, exhibitions): Lucy has a collection of n paintings, each with a viewing score described by an integer ai. She wants to organize m exhibitions, where each exhibition is specified by a pair of indices li and ri, representing the range of paintings to be included. For each exhibition, she wants to find the sum of viewing scores of the top k paintings from the range [li, ri]. >>> top_k_sum_of_exhibition_scores(6, 2, 3, [5, 3, 8, 7, 2, 4], [(1, 6), (2, 5)]) [20, 18] >>> top_k_sum_of_exhibition_scores(5, 3, 2, [10, 20, 30, 40, 50], [(1, 3), (2, 4), (1, 5)]) [50, 70, 90]","solution":"def top_k_sum_of_exhibition_scores(n, m, k, scores, exhibitions): results = [] for l, r in exhibitions: # Get the sublist for the current exhibition range and sort it sublist = scores[l - 1:r] sublist.sort(reverse=True) # Calculate the sum of the top k elements top_k_sum = sum(sublist[:k]) results.append(top_k_sum) return results"},{"question":"def find_longest_subarray(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a sequence of integers, determine the longest contiguous subarray that has an equal number of even and odd integers. >>> find_longest_subarray(2, [(5, [1, 2, 3, 4, 5]), (4, [1, 1, 1, 1])]) [4, 0] >>> find_longest_subarray(1, [(6, [1, 2, 2, 1, 3, 4])]) [6]","solution":"def find_longest_subarray(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] arr = test_cases[i][1] # To store prefix sums where even -> +1 and odd -> -1 prefix_sum = {} curr_sum = 0 max_len = 0 # Store initial sum which means no elements taken prefix_sum[0] = -1 for j in range(N): if arr[j] % 2 == 0: curr_sum += 1 else: curr_sum -= 1 if curr_sum in prefix_sum: max_len = max(max_len, j - prefix_sum[curr_sum]) else: prefix_sum[curr_sum] = j results.append(max_len) return results"},{"question":"def shortest_palindromic_by_appending(s: str) -> str: Given a string, finds the shortest palindromic string that can be obtained by appending characters to its end. >>> shortest_palindromic_by_appending(\\"race\\") 'racecar' >>> shortest_palindromic_by_appending(\\"ab\\") 'aba' def test_example_cases(): assert shortest_palindromic_by_appending(\\"race\\") == \\"racecar\\" assert shortest_palindromic_by_appending(\\"ab\\") == \\"aba\\" def test_single_character(): assert shortest_palindromic_by_appending(\\"a\\") == \\"a\\" assert shortest_palindromic_by_appending(\\"z\\") == \\"z\\" def test_already_palindromic(): assert shortest_palindromic_by_appending(\\"madam\\") == \\"madam\\" assert shortest_palindromic_by_appending(\\"radar\\") == \\"radar\\" def test_general_cases(): assert shortest_palindromic_by_appending(\\"abcd\\") == \\"abcdcba\\" assert shortest_palindromic_by_appending(\\"abab\\") == \\"ababa\\" assert shortest_palindromic_by_appending(\\"aabba\\") == \\"aabbaa\\"","solution":"def shortest_palindromic_by_appending(s): Given a string, finds the shortest palindromic string that can be obtained by appending characters to its end. def is_palindrome(x): return x == x[::-1] if is_palindrome(s): return s for i in range(len(s)): if is_palindrome(s[i:]): return s + s[:i][::-1] return s + s[:-1][::-1]"},{"question":"def longest_unique_substring_length(S: str) -> int: Returns the length of the longest substring with unique letters in a given string S. Examples: >>> longest_unique_substring_length(\\"ABCADEFGH\\") 8 >>> longest_unique_substring_length(\\"AABBC\\") 2 >>> longest_unique_substring_length(\\"XYZXYZ\\") 3","solution":"def longest_unique_substring_length(S): Returns the length of the longest substring with unique letters in a given string S. n = len(S) if n == 0: return 0 max_len = 0 start = 0 char_index = {} for end in range(n): if S[end] in char_index and char_index[S[end]] >= start: start = char_index[S[end]] + 1 char_index[S[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def max_shrines_protected(n: int) -> int: Determine the maximum number of shrines that can be protected by at most one guardian. >>> max_shrines_protected(5) 5 >>> max_shrines_protected(10) 10 >>> max_shrines_protected(1) 1 >>> max_shrines_protected(1000) 1000 >>> max_shrines_protected(100000) 100000","solution":"def max_shrines_protected(n): Function to determine the maximum number of shrines that can be protected by at most one guardian. # Since each guardian at gate i can protect any shrine at gate j where j is divisible by i, # and each gate can be used only once, the maximum number of shrines that can be protected # is just the number of gates itself. return n"},{"question":"def can_rearrange_cakes(n: int, cakes: List[int]) -> str: Determines if it is possible to rearrange the cakes such that no two adjacent cakes are of the same type. Parameters: - n: int, number of cakes (and types of cakes) - cakes: list of int, types of cakes Returns: - str: \\"yes\\" if it is possible to rearrange, \\"no\\" otherwise >>> can_rearrange_cakes(5, [1, 2, 3, 4, 5]) 'yes' >>> can_rearrange_cakes(3, [1, 1, 2]) 'yes' >>> can_rearrange_cakes(2, [1, 1]) 'no'","solution":"from collections import Counter def can_rearrange_cakes(n, cakes): Determines if it is possible to rearrange the cakes such that no two adjacent cakes are of the same type. Parameters: - n: int, number of cakes (and types of cakes) - cakes: list of int, types of cakes Returns: - str: \\"yes\\" if it is possible to rearrange, \\"no\\" otherwise cake_counts = Counter(cakes) max_count = max(cake_counts.values()) # If the most common type of cake is more than half the number of cakes, it won't be possible to place them without repeating if max_count > (n + 1) // 2: return \\"no\\" return \\"yes\\""},{"question":"def remove_odd_houses(n, house_numbers): Removes odd house numbers from the list of house numbers and returns the remaining even house numbers. If no even house numbers remain, returns \\"all houses disconnected\\". Args: n (int): Number of houses. house_numbers (list of int): List of house numbers. Returns: str: A space-separated string of even house numbers or \\"all houses disconnected\\". Examples: >>> remove_odd_houses(6, [1, 4, 3, 6, 7, 9]) \\"4 6\\" >>> remove_odd_houses(5, [1, 3, 5, 7, 9]) \\"all houses disconnected\\" >>> remove_odd_houses(4, [2, 4, 6, 8]) \\"2 4 6 8\\"","solution":"def remove_odd_houses(n, house_numbers): Removes odd house numbers from the list of house numbers and returns the remaining even house numbers. If no even house numbers remain, returns \\"all houses disconnected\\". Args: n (int): Number of houses. house_numbers (list of int): List of house numbers. Returns: str: A space-separated string of even house numbers or \\"all houses disconnected\\". even_houses = [house for house in house_numbers if house % 2 == 0] if not even_houses: return \\"all houses disconnected\\" return \\" \\".join(map(str, even_houses))"},{"question":"def min_subset_sum_difference(n: int, arr: List[int]) -> int: Given a list of integers, determine if it is possible to partition these integers into two subsets such that the difference between the sum of integers in the first subset and the sum of integers in the second subset is minimized. >>> min_subset_sum_difference(4, [1, 6, 11, 5]) == 1 >>> min_subset_sum_difference(3, [2, 3, 5]) == 0 >>> min_subset_sum_difference(4, [0, 0, 0, 0]) == 0 >>> min_subset_sum_difference(1, [1]) == 1 >>> min_subset_sum_difference(5, [3, 1, 4, 2, 2]) == 0 >>> min_subset_sum_difference(6, [1, 1, 1, 1, 1, 1]) == 0 # Your code here","solution":"def min_subset_sum_difference(n, arr): total_sum = sum(arr) dp = [[False] * (total_sum // 2 + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True # Zero sum is always possible with an empty subset for i in range(1, n + 1): for j in range(1, (total_sum // 2) + 1): if arr[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] else: dp[i][j] = dp[i - 1][j] for j in range(total_sum // 2, -1, -1): if dp[n][j]: subset1_sum = j break subset2_sum = total_sum - subset1_sum return abs(subset2_sum - subset1_sum)"},{"question":"class FileSystem: def __init__(self): self.fs = {'/': {}} self.current_path = ['/'] def mkdir(self, dir_name): Create a directory named \`dir_name\`. If the directory already exists, do nothing. :param dir_name: Name of the directory to be created. pass def touch(self, file_name): Create a file named \`file_name\`. If the file already exists, do nothing. :param file_name: Name of the file to be created. pass def cd(self, dir_name): Change the current directory to \`dir_name\`. :param dir_name: Name of the directory to change to. \`..\` changes to the parent directory. pass def ls(self): List the contents of the current directory in lexicographical order. pass def pwd(self): Print the full path from the root directory to the current directory. pass def _get_current_dict(self): Get the dictionary representing the current directory. :return: Dictionary representing the current directory. pass def process_commands(commands): Processes a list of file system commands. :param commands: List of commands to be processed. pass # Unit Tests def test_mkdir(): fs = FileSystem() fs.mkdir('testdir') result = fs._get_current_dict() assert 'testdir' in result and isinstance(result['testdir'], dict) def test_touch(): fs = FileSystem() fs.touch('testfile') result = fs._get_current_dict() assert 'testfile' in result and result['testfile'] is None def test_cd_and_pwd(): fs = FileSystem() fs.mkdir('testdir') fs.cd('testdir') assert fs.current_path == ['/', 'testdir'] fs.pwd() # Should output /testdir def test_cd_and_ls(): fs = FileSystem() fs.mkdir('testdir') fs.cd('testdir') fs.touch('testfile') fs.mkdir('subdir') fs.ls() # Should list subdir and testfile def test_cd_parent(): fs = FileSystem() fs.mkdir('testdir') fs.cd('testdir') fs.cd('..') assert fs.current_path == ['/'] def test_process_commands(capfd): commands = [ 'mkdir home', 'cd home', 'mkdir user', 'touch file.txt', 'mkdir documents', 'cd documents', 'touch doc1.txt', 'touch doc2.txt', 'ls', 'cd ..', 'pwd', 'ls' ] process_commands(commands) out, err = capfd.readouterr() expected_output = doc1.txt doc2.txt /home documents file.txt user assert out.strip() == expected_output.strip()","solution":"class FileSystem: def __init__(self): self.fs = {'/': {}} self.current_path = ['/'] def mkdir(self, dir_name): current_dict = self._get_current_dict() if dir_name not in current_dict: current_dict[dir_name] = {} def touch(self, file_name): current_dict = self._get_current_dict() if file_name not in current_dict: current_dict[file_name] = None def cd(self, dir_name): if dir_name == '..': if len(self.current_path) > 1: self.current_path.pop() else: current_dict = self._get_current_dict() if dir_name in current_dict and isinstance(current_dict[dir_name], dict): self.current_path.append(dir_name) def ls(self): current_dict = self._get_current_dict() items = sorted(current_dict.keys()) for item in items: print(item) def pwd(self): if len(self.current_path) == 1: print('/') else: print('/' + '/'.join(self.current_path[1:])) def _get_current_dict(self): current_dict = self.fs['/'] for dir in self.current_path[1:]: current_dict = current_dict[dir] return current_dict def process_commands(commands): fs = FileSystem() for command in commands: parts = command.split() cmd = parts[0] if cmd == 'mkdir': fs.mkdir(parts[1]) elif cmd == 'touch': fs.touch(parts[1]) elif cmd == 'cd': fs.cd(parts[1]) elif cmd == 'ls': fs.ls() elif cmd == 'pwd': fs.pwd()"},{"question":"def count_gold_lockers(n, lockers, k, keys): Finds the number of lockers containing gold coins that the employees can access with their keys. Parameters: n (int): The total number of lockers. lockers (list of int): The list representing type of coins in each locker (1 for gold, 2 for silver, 3 for bronze). k (int): The number of keys. keys (list of int): The list representing the locker numbers for which employees have keys. Returns: int: The number of lockers containing gold coins that can be accessed. pass from solution import count_gold_lockers def test_count_gold_lockers_case1(): assert count_gold_lockers(5, [1, 2, 1, 3, 1], 3, [1, 2, 5]) == 2 def test_count_gold_lockers_case2(): assert count_gold_lockers(4, [3, 3, 2, 1], 2, [3, 4]) == 1 def test_count_gold_lockers_no_keys(): assert count_gold_lockers(4, [3, 3, 2, 1], 0, []) == 0 def test_count_gold_lockers_all_gold(): assert count_gold_lockers(3, [1, 1, 1], 3, [1, 2, 3]) == 3 def test_count_gold_lockers_no_gold(): assert count_gold_lockers(3, [2, 2, 3], 3, [1, 2, 3]) == 0 def test_count_gold_lockers_single_key(): assert count_gold_lockers(3, [1, 2, 3], 1, [1]) == 1 assert count_gold_lockers(3, [1, 2, 3], 1, [2]) == 0 assert count_gold_lockers(3, [1, 2, 3], 1, [3]) == 0","solution":"def count_gold_lockers(n, lockers, k, keys): Finds the number of lockers containing gold coins that the employees can access with their keys. Parameters: n (int): The total number of lockers. lockers (list of int): The list representing type of coins in each locker (1 for gold, 2 for silver, 3 for bronze). k (int): The number of keys. keys (list of int): The list representing the locker numbers for which employees have keys. Returns: int: The number of lockers containing gold coins that can be accessed. gold_lockers_count = 0 for key in keys: if lockers[key - 1] == 1: gold_lockers_count += 1 return gold_lockers_count"},{"question":"def process_operations(operations): Write a program to manage a sequence of operations on an initially empty list B. The program should efficiently handle the following operations: * append(v): Append the value v to the end of list B. * removeLast(): Remove the last element from list B. * sum(l, r): Return the sum of the elements from index l to index r in the list B inclusive (0-based index). Args: operations (List[str]): The list of operations to be processed on list B. Returns: List[int]: The results of sum operations. Constraints: * 1  q  100000 * 1  v  100000 * 0  l  r < length of current list B * The sum operation will only be called if the list contains the specified indices l to r. Example: >>> process_operations(['append 3', 'append 1', 'append 4', 'sum 0 2', 'removeLast', 'sum 0 1']) [8, 4] >>> process_operations(['append 5', 'append 7', 'append 2', 'append 8', 'sum 1 3', 'removeLast', 'sum 0 1']) [17, 12] from solution import process_operations def test_process_operations_case_1(): operations = ['append 3', 'append 1', 'append 4', 'sum 0 2', 'removeLast', 'sum 0 1'] assert process_operations(operations) == [8, 4] def test_process_operations_case_2(): operations = ['append 5', 'append 7', 'append 2', 'append 8', 'sum 1 3', 'removeLast', 'sum 0 1'] assert process_operations(operations) == [17, 12] def test_process_operations_single_append(): operations = ['append 10', 'sum 0 0'] assert process_operations(operations) == [10] def test_process_operations_multiple_appends_and_remove(): operations = ['append 2', 'append 4', 'append 6', 'append 8', 'removeLast', 'sum 0 2', 'removeLast', 'sum 0 1'] assert process_operations(operations) == [12, 6] def test_process_operations_empty_operations(): operations = [] assert process_operations(operations) == [] def test_process_operations_only_remove(): operations = ['append 1', 'append 2', 'removeLast', 'removeLast', 'removeLast'] assert process_operations(operations) == [] def test_process_operations_consecutive_sums(): operations = ['append 5', 'append 5', 'sum 0 0', 'sum 0 1', 'append 10', 'sum 1 2'] assert process_operations(operations) == [5, 10, 15]","solution":"class ListManager: def __init__(self): self.B = [] self.prefix_sum = [] def append(self, v): self.B.append(v) if self.prefix_sum: self.prefix_sum.append(self.prefix_sum[-1] + v) else: self.prefix_sum.append(v) def removeLast(self): if self.B: self.B.pop() self.prefix_sum.pop() def sum(self, l, r): if l > 0: return self.prefix_sum[r] - self.prefix_sum[l - 1] else: return self.prefix_sum[r] def process_operations(operations): manager = ListManager() results = [] for operation in operations: if operation.startswith('append'): _, v = operation.split() manager.append(int(v)) elif operation == 'removeLast': manager.removeLast() elif operation.startswith('sum'): _, l, r = operation.split() results.append(manager.sum(int(l), int(r))) return results"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameterOfBinaryTree(root: Optional[TreeNode]) -> int: Given a binary tree, find the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Input: root of the following binary tree: 1 / 2 3 / 4 5 Output: 3 Test Cases: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> diameterOfBinaryTree(root) 3 >>> root = TreeNode(1) >>> diameterOfBinaryTree(root) 0 >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> diameterOfBinaryTree(root) 2","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameterOfBinaryTree(root: TreeNode) -> int: def dfs(node): nonlocal diameter if not node: return 0 left_depth = dfs(node.left) right_depth = dfs(node.right) diameter = max(diameter, left_depth + right_depth) return max(left_depth, right_depth) + 1 diameter = 0 dfs(root) return diameter"},{"question":"def max_energy_sum(n: int, k: int, energy_values: List[int]) -> int: Determines the maximum sum of energy values from k consecutive trees. Args: n (int): The number of trees. k (int): The number of consecutive trees to select. energy_values (List[int]): The energy values of the fruits. Returns: int: The maximum sum of energy values from k consecutive trees. >>> max_energy_sum(5, 2, [-1, 2, 3, -2, 5]) 5 >>> max_energy_sum(1, 1, [10]) 10","solution":"def max_energy_sum(n, k, energy_values): Returns the maximum sum of energy values from k consecutive trees. # Let's use a sliding window to find the maximum sum of k consecutive values current_sum = sum(energy_values[:k]) max_sum = current_sum for i in range(k, n): current_sum += energy_values[i] - energy_values[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def minimum_spanning_tree(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Determine the sum of weights in the minimum spanning tree of the graph. Args: n (int): The number of vertices. m (int): The number of edges. edges (List[Tuple[int, int, int]]): List of edges where each edge is represented as a tuple (u, v, w), where u and v are vertices and w is the positive weight of the edge. Returns: int: Sum of weights in the minimum spanning tree. Examples: >>> minimum_spanning_tree(4, 5, [(1, 2, 5), (1, 3, 3), (4, 2, 7), (3, 4, 4), (2, 3, 6)]) 12 >>> minimum_spanning_tree(2, 1, [(1, 2, 1)]) 1 >>> minimum_spanning_tree(3, 3, [(1, 2, 3), (2, 3, 4), (1, 3, 2)]) 5","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal(n, edges): # Sort edges by weight edges.sort(key=lambda x: x[2]) parent = [] rank = [] # Initialize parent and rank for each vertex for node in range(n): parent.append(node) rank.append(0) mst_weight = 0 for edge in edges: u, v, w = edge root_u = find(parent, u - 1) root_v = find(parent, v - 1) if root_u != root_v: mst_weight += w union(parent, rank, root_u, root_v) return mst_weight def minimum_spanning_tree(n, m, edges): return kruskal(n, edges) # Example usage n = 4 m = 5 edges = [ (1, 2, 5), (1, 3, 3), (4, 2, 7), (3, 4, 4), (2, 3, 6) ] print(minimum_spanning_tree(n, m, edges)) # Outputs 12"},{"question":"def find_palace_location(t: int, cases: List[Tuple[int, int]]) -> List[str]: Given the dimensions of the grid, determine if it is possible to place the palace in such a way that it fulfills the king's symmetry condition, and specify the coordinates of such a palace if possible. >>> find_palace_location(4, [(3, 3), (4, 4), (2, 3), (1, 1)]) [\\"YES 2 2\\", \\"NO\\", \\"NO\\", \\"YES 1 1\\"] >>> find_palace_location(3, [(2, 4), (6, 5), (7, 8)]) [\\"NO\\", \\"NO\\", \\"NO\\"] >>> find_palace_location(1, [(1, 1)]) [\\"YES 1 1\\"] >>> find_palace_location(3, [(3, 3), (5, 5), (7, 7)]) [\\"YES 2 2\\", \\"YES 3 3\\", \\"YES 4 4\\"]","solution":"def find_palace_location(t, cases): results = [] for n, m in cases: if n % 2 != 0 and m % 2 != 0: results.append(f\\"YES {n//2 + 1} {m//2 + 1}\\") else: results.append(\\"NO\\") return results"},{"question":"def find_min_skill_diff(n: int, k: int, skills: List[int]) -> int: Determines the minimum difference possible between the highest and lowest group skill values when the players are divided into k groups. >>> find_min_skill_diff(5, 2, [8, 2, 6, 4, 10]) == 2 >>> find_min_skill_diff(1, 1, [10]) == 0 >>> find_min_skill_diff(4, 2, [5, 5, 5, 5]) == 0 >>> find_min_skill_diff(6, 3, [3, 1, 4, 1, 5, 9]) == 2 >>> find_min_skill_diff(6, 3, [7, 1, 8, 2, 5, 9]) == 2 >>> find_min_skill_diff(6, 2, [1, 3, 5, 7, 9, 11]) == 2 >>> find_min_skill_diff(5, 3, [1, 10, 12, 19, 21]) == 9","solution":"def find_min_skill_diff(n, k, skills): # Sort the skill values skills.sort() # Initializing the minimum difference as large as possible min_diff = float('inf') # Iterate from the beginning to find the smallest range of k elements for i in range(n - k + 1): diff = skills[i + k - 1] - skills[i] min_diff = min(min_diff, diff) return min_diff # Sample function to parse inputs and provide output def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) k = int(data[1]) skills = list(map(int, data[2:n+2])) result = find_min_skill_diff(n, k, skills) print(result)"},{"question":"def is_permutation_of_palindrome(s: str) -> bool: Determine if a given string is a permutation of a palindrome. Ignore case and non-letter characters. >>> is_permutation_of_palindrome(\\"Tact Coa\\") == True >>> is_permutation_of_palindrome(\\"Hello\\") == False >>> is_permutation_of_palindrome(\\"A man, a plan, a canal, Panama!\\") == True >>> is_permutation_of_palindrome(\\"a\\") == True >>> is_permutation_of_palindrome(\\"aabbcc\\") == True >>> is_permutation_of_palindrome(\\"aabbc\\") == True >>> is_permutation_of_palindrome(\\"abc\\") == False >>> is_permutation_of_palindrome(\\"\\") == True # Edge case, an empty string is trivially a palindrome >>> is_permutation_of_palindrome(\\"123 @#\\") == True # No letters present, should be considered as trivially palindrome","solution":"def is_permutation_of_palindrome(s): Determines if the given string is a permutation of a palindrome. Ignores case and non-letter characters. from collections import Counter import re # Remove non-letter characters and convert to lowercase s = re.sub(r'[^a-zA-Z]', '', s).lower() # Count the occurrences of each character counts = Counter(s) # Check the number of characters with odd counts odd_count = sum(1 for count in counts.values() if count % 2 != 0) # For string to be palindrome permutation, at most one character can have an odd count return odd_count <= 1"},{"question":"def is_subset_sum_zero(n: int, arr: List[int]) -> str: Determines if there exists a subset of the array such that the sum of the subset is zero. Args: n (int): The number of elements in the array. arr (list of int): The list of integers. Returns: str: \\"YES\\" if there is a subset with sum zero, otherwise \\"NO\\". Examples: >>> is_subset_sum_zero(5, [1, -1, 3, 2, -2]) 'YES' >>> is_subset_sum_zero(4, [1, 2, 3, 4]) 'NO'","solution":"def is_subset_sum_zero(n, arr): Determines if there exists a subset of the array such that the sum of the subset is zero. Args: n (int): The number of elements in the array. arr (list of int): The list of integers. Returns: str: \\"YES\\" if there is a subset with sum zero, otherwise \\"NO\\". # Using a set to store the sums of all subsets subset_sums = {0} for num in arr: # Update the subset_sums set with the current number added to each of the existing sums new_sums = set() for s in subset_sums: new_sum = s + num if new_sum == 0: return \\"YES\\" new_sums.add(new_sum) subset_sums.update(new_sums) return \\"NO\\""},{"question":"def max_activities(n: int, activities: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping activities. :param n: int - the number of activities :param activities: List[Tuple[int, int]] - list of tuples where each tuple contains start and finish time of an activity :return: int - the maximum number of non-overlapping activities >>> max_activities(6, [(1, 3), (2, 4), (3, 5), (0, 6), (5, 7), (8, 9)]) 4 >>> max_activities(4, [(1, 2), (3, 4), (0, 6), (5, 9)]) 3 >>> max_activities(1, [(1, 2)]) 1 >>> max_activities(3, [(1, 2), (2, 3), (3, 4)]) 3 >>> max_activities(3, [(1, 4), (2, 5), (3, 6)]) 1 >>> max_activities(5, [(1, 4), (3, 5), (0, 6), (5, 7), (8, 9)]) 3","solution":"def max_activities(n, activities): Returns the maximum number of non-overlapping activities. :param n: int - the number of activities :param activities: List[Tuple[int, int]] - list of tuples where each tuple contains start and finish time of an activity :return: int - the maximum number of non-overlapping activities # Sort activities based on their finish time activities.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, finish in activities: if start >= last_end_time: count += 1 last_end_time = finish return count"},{"question":"def can_trucks_cross_bridge(n: int, k: int, bridge_caps: List[int], truck_weights: List[int], crossings: List[int]) -> List[str]: Determines if each truck can safely cross its respective bridge. Parameters: n (int): Number of bridges k (int): Number of trucks bridge_caps (list of int): Maximum weight capacities of the bridges truck_weights (list of int): Weights of the trucks crossings (list of int): Bridge indices for each truck Returns: list of str: \\"YES\\" or \\"NO\\" result for each truck >>> can_trucks_cross_bridge(5, 3, [10000, 5000, 6000, 3000, 10000], [6000, 2000, 7000], [1, 3, 2]) ['YES', 'YES', 'NO'] >>> can_trucks_cross_bridge(4, 4, [8000, 7000, 3000, 6000], [4000, 9000, 5000, 6000], [1, 2, 4, 3]) ['YES', 'NO', 'YES', 'NO'] results = [] for j in range(k): bridge_index = crossings[j] - 1 # Convert to 0-based index if truck_weights[j] <= bridge_caps[bridge_index]: results.append(\\"YES\\") else: results.append(\\"NO\\") return results","solution":"def can_trucks_cross_bridge(n, k, bridge_caps, truck_weights, crossings): Determines if each truck can safely cross its respective bridge. Parameters: n (int): Number of bridges k (int): Number of trucks bridge_caps (list of int): Maximum weight capacities of the bridges truck_weights (list of int): Weights of the trucks crossings (list of int): Bridge indices for each truck Returns: list of str: \\"YES\\" or \\"NO\\" result for each truck results = [] for j in range(k): bridge_index = crossings[j] - 1 # Convert to 0-based index if truck_weights[j] <= bridge_caps[bridge_index]: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Ensure to keep the function calls and tests outside the code block for solution # to ensure proper functionality and avoid execution errors."},{"question":"def min_distance(s1: str, s2: str) -> int: Calculate the minimum number of changes required to transform string s1 into string s2. >>> min_distance(\\"kitten\\", \\"sitting\\") 3 >>> min_distance(\\"flaw\\", \\"lawn\\") 2 pass def process_input(n: int, test_cases: List[str]) -> List[int]: Process multiple test cases and return the results for each case. >>> process_input(2, [\\"kitten\\", \\"sitting\\", \\"flaw\\", \\"lawn\\"]) [3, 2] >>> process_input(1, [\\"abc\\", \\"abc\\"]) [0] pass # Unit Tests def test_example_cases(): assert process_input(2, [\\"kitten\\", \\"sitting\\", \\"flaw\\", \\"lawn\\"]) == [3, 2] def test_identical_strings(): assert process_input(1, [\\"abc\\", \\"abc\\"]) == [0] def test_empty_and_non_empty_strings(): assert process_input(1, [\\"\\", \\"abc\\"]) == [3] assert process_input(1, [\\"abc\\", \\"\\"]) == [3] def test_single_character_variation(): assert process_input(2, [\\"a\\", \\"b\\", \\"a\\", \\"a\\"]) == [1, 0] def test_varied_length_string_pairs(): assert process_input(2, [\\"abcdef\\", \\"azced\\", \\"intention\\", \\"execution\\"]) == [3, 5]","solution":"def min_distance(s1, s2): Returns the minimum number of changes required to transform string s1 into string s2. def edit_distance_dp(s1, s2): m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[m][n] return edit_distance_dp(s1, s2) def process_input(n, test_cases): results = [] for i in range(n): s1 = test_cases[2*i] s2 = test_cases[2*i + 1] results.append(min_distance(s1, s2)) return results"},{"question":"def maximize_magic_power(N: int, K: int, magic_levels: List[int]) -> int: Returns the maximum possible magic level of any tree after exactly K enchantments. Parameters: N (int): Number of trees. K (int): Number of enchantments. magic_levels (list): Initial magic levels of the trees. Returns: int: Maximum possible magic level of any tree after K enchantments. pass # Unit Test def test_maximize_magic_power(): assert maximize_magic_power(5, 3, [1, 2, 3, 4, 5]) == 8 assert maximize_magic_power(3, 5, [5, 3, 1]) == 10 assert maximize_magic_power(1, 10, [5]) == 15 assert maximize_magic_power(4, 4, [0, 0, 0, 0]) == 4 assert maximize_magic_power(3, 10000, [1, 2, 3]) == 10003 assert maximize_magic_power(4, 10, [5, 5, 5, 5]) == 15 assert maximize_magic_power(3, 0, [7, 8, 9]) == 9","solution":"def maximize_magic_power(N, K, magic_levels): Returns the maximum possible magic level of any tree after exactly K enchantments. Parameters: N (int): Number of trees. K (int): Number of enchantments. magic_levels (list): Initial magic levels of the trees. Returns: int: Maximum possible magic level of any tree after K enchantments. # We will add K to the magic level of the highest initial magic level max_initial_magic = max(magic_levels) return max_initial_magic + K"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kthSmallestElementInBST(root: TreeNode, k: int) -> int: Return the k-th smallest element in the BST. >>> root = TreeNode(3, TreeNode(1, None, TreeNode(2)), TreeNode(4)) >>> kthSmallestElementInBST(root, 1) 1 >>> root = TreeNode(5, TreeNode(3, TreeNode(2, TreeNode(1)), TreeNode(4)), TreeNode(6)) >>> kthSmallestElementInBST(root, 3) 3","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kthSmallestElementInBST(root: TreeNode, k: int) -> int: Return the k-th smallest element in the BST. def inorder_traversal(node): # Generator for in-order traversal if node is not None: yield from inorder_traversal(node.left) yield node.val yield from inorder_traversal(node.right) generator = inorder_traversal(root) for _ in range(k - 1): next(generator) return next(generator)"},{"question":"def find_triplet_with_sum_zero(nums: List[int]) -> List[int]: Given an array of integers, find and return a triplet (a, b, c) such that a + b + c = 0. If no such triplet exists, return an empty list. >>> find_triplet_with_sum_zero([-1, 0, 1, 2, -1]) [-1, 0, 1] >>> find_triplet_with_sum_zero([1, 2, 3, 4]) [] >>> find_triplet_with_sum_zero([-4, -1, -1, 0, 1, 2]) [-1, -1, 2] >>> find_triplet_with_sum_zero([-5, -4, -3, -2, 4]) [] >>> find_triplet_with_sum_zero([-10**5, -10**5, 2 * 10**5]) [-100000, -100000, 200000] >>> find_triplet_with_sum_zero([8, 9, 10, 11]) []","solution":"def find_triplet_with_sum_zero(nums): Find a triplet (a, b, c) such that a + b + c = 0. If such a triplet exists, return it as a list [a, b, c]. If no such triplet exists, return an empty list. nums.sort() n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: triplet_sum = nums[i] + nums[left] + nums[right] if triplet_sum == 0: return [nums[i], nums[left], nums[right]] elif triplet_sum < 0: left += 1 else: right -= 1 return []"},{"question":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, delta): while index <= self.size: self.tree[index] += delta index += index & -index def prefix_sum(self, index): total = 0 while index > 0: total += self.tree[index] index -= index & -index return total def range_sum(self, left, right): return self.prefix_sum(right) - self.prefix_sum(left - 1) def initialize_array_and_fenwick_tree(array): n = len(array) fenwick_tree = FenwickTree(n) for index, value in enumerate(array, start=1): fenwick_tree.update(index, value) return array, fenwick_tree def increase_range(array, fenwick_tree, left, right, value): for i in range(left, right + 1): array[i - 1] += value fenwick_tree.update(i, value) def sum_range(fenwick_tree, left, right): return fenwick_tree.range_sum(left, right) def process_operations(n, operations, array): Process a list of operations on the array and return the results of sum queries. Parameters: n (int): length of array operations (list of tuples): operations to perform array (list of int): initial values of the array Returns: list of int: results of the sum queries >>> n = 5 >>> operations = [(2, 1, 3), (1, 2, 4, 1), (2, 2, 4), (1, 3, 5, 2), (2, 1, 5)] >>> array = [1, 2, 3, 4, 5] >>> process_operations(n, operations, array) [6, 12, 24] >>> n = 1 >>> operations = [(2, 1, 1), (1, 1, 1, 10), (2, 1, 1)] >>> array = [5] >>> process_operations(n, operations, array) [5, 15] >>> n = 3 >>> operations = [(1, 1, 1, 10**9), (2, 1, 1), (1, 2, 3, 10**9), (2, 1, 3)] >>> array = [1, 1, 1] >>> process_operations(n, operations, array) [1000000001, 3000000002]","solution":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, delta): while index <= self.size: self.tree[index] += delta index += index & -index def prefix_sum(self, index): total = 0 while index > 0: total += self.tree[index] index -= index & -index return total def range_sum(self, left, right): return self.prefix_sum(right) - self.prefix_sum(left - 1) def initialize_array_and_fenwick_tree(array): n = len(array) fenwick_tree = FenwickTree(n) for index, value in enumerate(array, start=1): fenwick_tree.update(index, value) return array, fenwick_tree def increase_range(array, fenwick_tree, left, right, value): for i in range(left, right + 1): array[i - 1] += value fenwick_tree.update(i, value) def sum_range(fenwick_tree, left, right): return fenwick_tree.range_sum(left, right) def process_operations(n, operations, array): array, fenwick_tree = initialize_array_and_fenwick_tree(array) result = [] for operation in operations: if operation[0] == 1: _, l, r, x = operation increase_range(array, fenwick_tree, l, r, x) elif operation[0] == 2: _, l, r = operation result.append(sum_range(fenwick_tree, l, r)) return result"},{"question":"def max_profit(prices): Returns the maximum profit that can be achieved from a single buy and sell of stock prices provided in the list. If no profit is possible, returns 0. def process_input(data): Function to process the input data for stock prices and return the corresponding maximum profits for each dataset. Each line in the input data represents a separate dataset. # Unit tests for the max_profit function def test_max_profit_example1(): assert max_profit([3, 8, 5, 1, 7, 8, 2]) == 7 def test_max_profit_example2(): assert max_profit([10, 9, 8, 7, 6, 5]) == 0 def test_max_profit_example3(): assert max_profit([1, 6, 4, 5, 2, 3]) == 5 def test_max_profit_empty(): assert max_profit([]) == 0 def test_max_profit_all_same_price(): assert max_profit([5, 5, 5, 5]) == 0 # Unit tests for the process_input function def test_process_input_examples(): data = [ \\"3 8 5 1 7 8 2 0\\", \\"10 9 8 7 6 5 0\\", \\"1 6 4 5 2 3 0\\", \\"0\\" ] expected = [7, 0, 5] assert process_input(data) == expected def test_process_input_no_data(): data = [\\"0\\"] expected = [] assert process_input(data) == expected def test_process_input_single_dataset_no_profit(): data = [\\"7 6 5 4 3 2 1 0\\", \\"0\\"] expected = [0] assert process_input(data) == expected","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from a single buy and sell of stock prices provided in the list. If no profit is possible, returns 0. if not prices: return 0 min_price = prices[0] max_profit = 0 for price in prices: if price < min_price: min_price = price current_profit = price - min_price if current_profit > max_profit: max_profit = current_profit return max_profit def process_input(data): results = [] for line in data: prices = list(map(int, line.split())) if len(prices) == 1 and prices[0] == 0: break results.append(max_profit(prices[:-1])) return results"},{"question":"def largest_square_submatrix(matrix: List[List[int]]) -> int: Given a binary matrix, this function finds the size of the largest square submatrix that contains all 1s. Args: matrix: List[List[int]]: A list of lists representing the binary matrix. Returns: int: The size of the largest square submatrix that contains all 1s. def parse_input_and_find_largest_square_submatrix(input_string: str) -> int: Parses the input string to extract the binary matrix and finds the size of the largest square submatrix that contains all 1s. Args: input_string: str: The input string containing the size of the matrix and the matrix itself. Returns: int: The size of the largest square submatrix that contains all 1s. # Unit tests def test_example_case(): input_data = \\"4n0111n1111n1111n0111\\" assert parse_input_and_find_largest_square_submatrix(input_data) == 3 def test_all_ones(): input_data = \\"3n111n111n111\\" assert parse_input_and_find_largest_square_submatrix(input_data) == 3 def test_mixed_zeros_and_ones(): input_data = \\"5n10111n11111n11111n11101n01111\\" assert parse_input_and_find_largest_square_submatrix(input_data) == 3 def test_all_zeros(): input_data = \\"4n0000n0000n0000n0000\\" assert parse_input_and_find_largest_square_submatrix(input_data) == 0 def test_single_one(): input_data = \\"4n0000n0010n0000n0000\\" assert parse_input_and_find_largest_square_submatrix(input_data) == 1 def test_single_row_and_column(): input_data = \\"1n1\\" assert parse_input_and_find_largest_square_submatrix(input_data) == 1 def test_single_row_and_column_zero(): input_data = \\"1n0\\" assert parse_input_and_find_largest_square_submatrix(input_data) == 0","solution":"def largest_square_submatrix(matrix): Given a binary matrix, this function finds the size of the largest square submatrix that contains all 1s. Args: matrix: List[List[int]]: A list of lists representing the binary matrix. Returns: int: The size of the largest square submatrix that contains all 1s. if not matrix or not matrix[0]: return 0 N = len(matrix) dp = [[0] * N for _ in range(N)] max_size = 0 for i in range(N): for j in range(N): if i == 0 or j == 0: dp[i][j] = matrix[i][j] elif matrix[i][j] == 1: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 else: dp[i][j] = 0 max_size = max(max_size, dp[i][j]) return max_size def parse_input_and_find_largest_square_submatrix(input_string): lines = input_string.split(\\"n\\") N = int(lines[0]) matrix = [] for i in range(1, N + 1): row = list(map(int, list(lines[i].strip()))) matrix.append(row) return largest_square_submatrix(matrix)"},{"question":"def max_candy_power(n: int, R: int, power_levels: List[int]) -> int: Determine the maximum power level that can be achieved without exceeding R by selecting any combination of the given candies. Parameters: n (int): Number of different types of candies R (int): Required power level power_levels (List[int]): List of power levels of each candy type Returns: int: The maximum power level that can be achieved without exceeding R >>> max_candy_power(5, 50, [10, 20, 30, 40, 50]) 50 >>> max_candy_power(5, 45, [10, 20, 30, 40, 50]) 40 >>> max_candy_power(3, 100, [25, 50, 75]) 100 >>> max_candy_power(3, 85, [25, 50, 75]) 75","solution":"def max_candy_power(n, R, power_levels): Returns the maximum power level that can be achieved without exceeding R using the given candy power levels. possible_powers = [0] * (R + 1) for power in power_levels: for i in range(R, power - 1, -1): possible_powers[i] = max(possible_powers[i], possible_powers[i - power] + power) return possible_powers[R]"},{"question":"def average_steps(n: int, steps: List[int]) -> int: Eva is constantly on the go and wants an application that can help her track her steps. She wants a program that calculates the average number of steps she's taken over a certain number of days, allowing her to evaluate her progress over time. Your task is to write a function that: 1. Takes an array of daily step counts. 2. Returns the average number of steps Eva has taken, rounded down to the nearest integer. Input: - An integer n (1  n  105) representing the number of days Eva has recorded her steps. - An array of n integers, where each integer s (0  s  105) represents the number of steps taken on that day. Output: - A single integer representing the average number of steps rounded down. Examples: >>> average_steps(5, [10000, 12000, 11000, 13000, 14000]) 12000 >>> average_steps(3, [5000, 8000, 10000]) 7666","solution":"import math def average_steps(n, steps): Returns the average number of steps rounded down to the nearest integer. Parameters: n (int): The number of days. steps (list of int): The array of steps taken each day. Returns: int: The average steps rounded down. total_steps = sum(steps) avg_steps = total_steps // n return avg_steps"},{"question":"def min_contiguous_subsets(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of subsets into which the set A can be partitioned such that each subset is a contiguous sequence of integers. Args: test_cases: A list of tuples containing the number of elements in the set and the elements themselves. Returns: A list of integers representing the minimum number of contiguous subsets for each test case. >>> min_contiguous_subsets([(5, [1, 3, 5, 7, 9]), (4, [4, 5, 6, 10])]) [5, 2] >>> min_contiguous_subsets([(6, [1, 2, 3, 4, 5, 6]), (5, [10, 20, 30, 40, 50]), (3, [5, 6, 7])]) [1, 5, 1] >>> min_contiguous_subsets([(1, [100]), (2, [1, 100])]) [1, 2] >>> min_contiguous_subsets([(7, [4, 6, 8, 10, 12, 14, 16]), (4, [3, 2, 1, 5])]) [7, 2]","solution":"def min_contiguous_subsets(test_cases): results = [] for case in test_cases: n, numbers = case numbers.sort() count = 1 for i in range(1, n): if numbers[i] != numbers[i-1] + 1: count += 1 results.append(count) return results"},{"question":"from typing import List, Tuple def minimum_roads_to_connect_all_cities(N: int, M: int, roads: List[Tuple[int, int, int]]) -> int: Find the minimum number of roads required to keep all cities connected. Args: N: An integer representing the number of cities. M: An integer representing the number of bidirectional roads. roads: A list of tuples, each containing three integers (U_i, V_i, T_i) representing a road between cities U_i and V_i with travel time T_i. Returns: An integer representing the minimum number of roads to keep all cities connected or -1 if not possible. pass def test_minimum_roads_to_connect_all_cities(): # Test Case 1 assert minimum_roads_to_connect_all_cities(4, 5, [ (1, 2, 1), (1, 3, 4), (2, 3, 1), (2, 4, 2), (3, 4, 3), ]) == 3 # Test Case 2 assert minimum_roads_to_connect_all_cities(4, 2, [ (1, 2, 1), (3, 4, 5), ]) == -1 # Test Case 3 assert minimum_roads_to_connect_all_cities(6, 6, [ (1, 2, 2), (2, 3, 2), (2, 4, 3), (4, 5, 3), (5, 6, 1), (1, 6, 5), ]) == 5 # Edge Case: Only one city assert minimum_roads_to_connect_all_cities(1, 0, []) == 0 # Test Case: All cities already connected in the most minimal way assert minimum_roads_to_connect_all_cities(5, 4, [ (1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4), ]) == 4","solution":"def minimum_roads_to_connect_all_cities(N, M, roads): def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 # Sort roads based on travel time roads.sort(key=lambda x: x[2]) parent = list(range(N)) rank = [0] * N num_edges_in_mst = 0 for u, v, t in roads: if find(parent, u - 1) != find(parent, v - 1): union(parent, rank, u - 1, v - 1) num_edges_in_mst += 1 # If we have N-1 edges in MST, we can stop if num_edges_in_mst == N - 1: return num_edges_in_mst return -1 if num_edges_in_mst != N - 1 else num_edges_in_mst"},{"question":"from typing import List, Tuple def find_item_positions(warehouse: List[List[int]]) -> dict: Find the positions of all items in the warehouse grid. Args: warehouse: List[List[int]] - A 2D list of integers representing the warehouse grid. Returns: dict: A dictionary where keys are item IDs and values are tuples representing the coordinates (x, y) of the racks. >>> warehouse = [ >>> [1, 0, 3], >>> [0, 2, 0], >>> [4, 0, 5] >>> ] >>> find_item_positions(warehouse) {1: (0, 0), 3: (0, 2), 2: (1, 1), 4: (2, 0), 5: (2, 2)} pass def manhattan_distance(x1: int, y1: int, x2: int, y2: int) -> int: Calculate the Manhattan distance between two coordinates. Args: x1: int - The x-coordinate of the first position. y1: int - The y-coordinate of the first position. x2: int - The x-coordinate of the second position. y2: int - The y-coordinate of the second position. Returns: int: The Manhattan distance between the two coordinates. >>> manhattan_distance(0, 0, 0, 0) 0 >>> manhattan_distance(0, 0, 1, 1) 2 >>> manhattan_distance(0, 0, 2, 3) 5 >>> manhattan_distance(3, 2, 1, 1) 3 pass def robot_path(warehouse: List[List[int]], start_x: int, start_y: int, item_ids: List[int]) -> List[Tuple[int, int]]: Given the starting position of the robot and a list of item IDs that the robot needs to pick up, return the list of coordinates of the racks in the order that the robot will visit them to pick the items. Args: warehouse: List[List[int]] - A 2D list of integers representing the warehouse grid. start_x: int - The starting x-coordinate of the robot. start_y: int - The starting y-coordinate of the robot. item_ids: List[int] - A list of integers representing the item IDs that the robot needs to pick up. Returns: List[Tuple[int, int]] - A list of tuples, each representing the coordinates (x, y) of the racks to visit in order. >>> warehouse = [ >>> [1, 0, 3], >>> [0, 2, 0], >>> [4, 0, 5] >>> ] >>> start_x = 0 >>> start_y = 0 >>> item_ids = [3, 2, 5] >>> robot_path(warehouse, start_x, start_y, item_ids) [(0, 2), (1, 1), (2, 2)] >>> start_x = 1 >>> start_y = 1 >>> item_ids = [5, 3] >>> robot_path(warehouse, start_x, start_y, item_ids) [(2, 2), (0, 2)] pass","solution":"def find_item_positions(warehouse): item_positions = {} for i in range(len(warehouse)): for j in range(len(warehouse[0])): if warehouse[i][j] != 0: item_positions[warehouse[i][j]] = (i, j) return item_positions def manhattan_distance(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2) def robot_path(warehouse, start_x, start_y, item_ids): item_positions = find_item_positions(warehouse) current_x, current_y = start_x, start_y path = [] for item_id in item_ids: if item_id in item_positions: target_x, target_y = item_positions[item_id] path.append((target_x, target_y)) current_x, current_y = target_x, target_y return path"},{"question":"def grid_cost_and_tallest(rows: int, cols: int, grid: List[List[int]]) -> Tuple[int, int]: You are given a rectangular grid with rows and columns of cells. Each cell contains a positive integer representing a height. Find the cost of covering this grid with building blocks of height 1, and also find the height of the tallest building that can be made with the given blocks. :param rows: int, number of rows of the grid :param cols: int, number of columns of the grid :param grid: list of list of int, heights of each cell in the grid :return: tuple (total_cost, tallest_building_height) >>> grid_cost_and_tallest(3, 3, [[3, 2, 1], [4, 2, 3], [5, 1, 2]]) (23, 5) >>> grid_cost_and_tallest(2, 2, [[1, 2], [2, 1]]) (6, 2)","solution":"def grid_cost_and_tallest(rows, cols, grid): Given the height grid, return the total cost to cover the grid and the height of the tallest building. :param rows: int, number of rows of the grid :param cols: int, number of columns of the grid :param grid: list of list of int, heights of each cell in the grid :return: tuple (total_cost, tallest_building_height) total_cost = 0 tallest_building_height = 0 for row in grid: for height in row: total_cost += height if height > tallest_building_height: tallest_building_height = height return total_cost, tallest_building_height"},{"question":"def find_levels(n, managers): Returns the levels of all employees in the company. Args: n (int): Number of employees. managers (list of tuples): Each tuple contains two integers u and v, denoting that employee u is a direct manager of employee v. Returns: list: n space-separated integers where the ith integer represents the level of employee i (0-indexed). Examples: >>> find_levels(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) [0, 1, 1, 2, 2] >>> find_levels(6, [(1, 2), (1, 3), (3, 4), (3, 5), (4, 6)]) [0, 1, 1, 2, 2, 3] >>> find_levels(3, [(1, 2), (1, 3)]) [0, 1, 1] >>> find_levels(1, []) [0] >>> find_levels(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) [0, 1, 2, 3, 4] >>> find_levels(4, [(1, 2), (1, 3), (1, 4)]) [0, 1, 1, 1]","solution":"from collections import deque, defaultdict def find_levels(n, managers): Returns the levels of all employees in the company. Args: n (int): Number of employees. managers (list of tuples): Each tuple contains two integers u and v, denoting that employee u is a direct manager of employee v. Returns: list: n space-separated integers where the ith integer represents the level of employee i (0-indexed). # Create a graph to represent the organizational structure graph = defaultdict(list) for u, v in managers: graph[u].append(v) # Initialize the levels levels = [-1] * n levels[0] = 0 # CEO is at level 0 # BFS to calculate the levels of each employee queue = deque([1]) while queue: u = queue.popleft() for v in graph[u]: levels[v - 1] = levels[u - 1] + 1 queue.append(v) return levels"},{"question":"def min_additional_time(n: int, t: int, a: List[int], b: List[int]) -> int: Calculate the minimum additional time needed for each participant to complete all questions in all rounds within the given time limits. Parameters: n (int): Number of rounds in the quiz competition. t (int): Time required by a participant to answer one question. a (list of int): Number of questions in the i-th round. b (list of int): Time limit in seconds for the i-th round. Returns: int: Minimum additional time needed. >>> min_additional_time(3, 5, [10, 20, 15], [60, 100, 75]) 0 >>> min_additional_time(3, 5, [10, 25, 15], [60, 100, 75]) 25 >>> min_additional_time(3, 5, [20, 25, 30], [60, 100, 75]) 75 >>> min_additional_time(4, 10, [10, 15, 12, 30], [100, 200, 150, 280]) 20 >>> min_additional_time(1, 10, [15], [80]) 70","solution":"def min_additional_time(n, t, a, b): Calculate the minimum additional time needed for each participant to complete all questions in all rounds within the given time limits. Parameters: n (int): Number of rounds in the quiz competition. t (int): Time required by a participant to answer one question. a (list of int): Number of questions in the i-th round. b (list of int): Time limit in seconds for the i-th round. Returns: int: Minimum additional time needed. additional_time = 0 for i in range(n): required_time = a[i] * t if required_time > b[i]: additional_time = max(additional_time, required_time - b[i]) return additional_time"},{"question":"class TextEditor: def __init__(self, dictionary: List[str], text: str): Initializes the TextEditor with a dictionary of words and an initial text. Parameters: - dictionary: List of allowed words. - text: Initial text in the editor. def insert(self, position: int, text: str) -> None: Inserts the substring \`text\` at the specified \`position\` in the existing text. Parameters: - position: Zero-based position where text is to be inserted. - text: Substring to be inserted. def delete(self, position: int, length: int) -> None: Deletes \`length\` characters starting from the specified \`position\` in the existing text. Parameters: - position: Zero-based position from where deletion begins. - length: Number of characters to delete. def find(self, substring: str) -> List[int]: Finds and returns a list of starting positions of all occurrences of \`substring\` in the existing text. Parameters: - substring: Substring to find in the text. Returns: - List of starting positions where \`substring\` is found. def autocomplete(self, prefix: str) -> List[str]: Returns a list of words from the predefined dictionary that start with the given \`prefix\`. Parameters: - prefix: The prefix to autocomplete. Returns: - List of words from the dictionary that start with the \`prefix\`. # Unit Tests def test_insert(): editor = TextEditor(['hello', 'world'], \\"hello\\") editor.insert(5, \\" world\\") assert editor.text == \\"hello world\\" def test_delete(): editor = TextEditor(['hello', 'world'], \\"hello world\\") editor.delete(5, 6) assert editor.text == \\"hello\\" def test_find(): editor = TextEditor(['hello', 'world'], \\"hello world hello\\") assert editor.find('hello') == [0, 12] assert editor.find('world') == [6] assert editor.find('test') == [] def test_autocomplete(): editor = TextEditor(['hello', 'world', 'hell', 'heaven', 'havoc'], \\"hello world\\") assert editor.autocomplete('he') == ['hello', 'hell', 'heaven'] assert editor.autocomplete('ha') == ['havoc'] assert editor.autocomplete('wo') == ['world'] assert editor.autocomplete('no') == [] def run_all_tests(): test_insert() test_delete() test_find() test_autocomplete() run_all_tests()","solution":"class TextEditor: def __init__(self, dictionary, text): self.dictionary = dictionary self.text = text def insert(self, position, text): self.text = self.text[:position] + text + self.text[position:] def delete(self, position, length): self.text = self.text[:position] + self.text[position + length:] def find(self, substring): positions = [] index = self.text.find(substring) while index != -1: positions.append(index) index = self.text.find(substring, index + 1) return positions def autocomplete(self, prefix): return [word for word in self.dictionary if word.startswith(prefix)]"},{"question":"def process_login_attempts(test_cases): Process a list of login attempts and return a list of unique login attempts in order of their first occurrence. >>> raw_input = \\"2n5n101 1n102 2n101 3n103 4n102 5n6n201 10n202 11n201 12n203 13n202 14n204 15n\\" >>> test_cases = format_input(raw_input) >>> results = process_login_attempts(test_cases) >>> format_output(results) \\"101[1] 102[2] 103[4]n201[10] 202[11] 203[13] 204[15]\\" >>> raw_input = \\"1n3n301 100n302 101n303 102n\\" >>> test_cases = format_input(raw_input) >>> results = process_login_attempts(test_cases) >>> format_output(results) \\"301[100] 302[101] 303[102]\\" >>> raw_input = \\"1n4n101 1n101 2n101 3n101 4n\\" >>> test_cases = format_input(raw_input) >>> results = process_login_attempts(test_cases) >>> format_output(results) \\"101[1]\\" >>> raw_input = \\"1n1n505 999n\\" >>> test_cases = format_input(raw_input) >>> results = process_login_attempts(test_cases) >>> format_output(results) \\"505[999]\\" >>> raw_input = \\"1n5n401 7n402 8n403 9n404 10n405 11n\\" >>> test_cases = format_input(raw_input) >>> results = process_login_attempts(test_cases) >>> format_output(results) \\"401[7] 402[8] 403[9] 404[10] 405[11]\\" pass def format_input(raw_input): Helper function to format raw input into test cases. pass def format_output(results): Helper function to format results into the desired output format. pass","solution":"def process_login_attempts(test_cases): results = [] for test_case in test_cases: N, attempts = test_case unique_logins = {} for emp_id, timestamp in attempts: if emp_id not in unique_logins: unique_logins[emp_id] = timestamp formatted_attempts = [f\\"{eid}[{ts}]\\" for eid, ts in unique_logins.items()] results.append(\\" \\".join(formatted_attempts)) return results def format_input(raw_input): lines = raw_input.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) attempts = [] for i in range(1, N+1): emp_id, timestamp = map(int, lines[index + i].split()) attempts.append((emp_id, timestamp)) test_cases.append((N, attempts)) index += N + 1 return test_cases def format_output(results): return \\"n\\".join(results)"},{"question":"from typing import List, Tuple def find_single_number(arr: List[int]) -> int: Returns the element that appears only once in the array where each element appears exactly twice except for one. pass def process_test_cases(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases to find the element that appears only once in each array. pass # Unit tests def test_single_number_case1(): assert find_single_number([1, 2, 3, 2, 1]) == 3 def test_single_number_case2(): assert find_single_number([4, 4, 5, 6, 6, 5, 7]) == 7 def test_single_number_large_case(): array = list(range(1, 100001)) * 2 + [123456] assert find_single_number(array) == 123456 def test_process_test_cases(): test_cases = [ (5, [1, 2, 3, 2, 1]), (7, [4, 4, 5, 6, 6, 5, 7]) ] results = process_test_cases(2, test_cases) assert results == [3, 7] def test_multiple_test_cases(): test_cases = [ (3, [2, 2, 1]), (5, [1, 3, 1, 2, 2]), (3, [9, 8, 8]) ] results = process_test_cases(3, test_cases) assert results == [1, 3, 9]","solution":"def find_single_number(arr): Returns the element that appears only once in the array where each element appears exactly twice except for one. result = 0 for num in arr: result ^= num return result def process_test_cases(t, test_cases): results = [] for case in test_cases: n, arr = case results.append(find_single_number(arr)) return results"},{"question":"def process_commands(commands): Processes a series of commands on a list of integers and returns the results of all sum commands. Args: commands (list of str): The list of commands. Returns: list of int: The results of all sum commands. from solution import process_commands def test_process_commands(): commands = [ \\"append 5\\", \\"append 3\\", \\"sum\\", \\"remove 3\\", \\"sum\\", \\"append 10\\", \\"sum\\" ] assert process_commands(commands) == [8, 5, 15] def test_process_commands_only_append(): commands = [ \\"append 1\\", \\"append 2\\", \\"append 3\\", \\"sum\\" ] assert process_commands(commands) == [6] def test_process_commands_remove_non_existent(): commands = [ \\"append 1\\", \\"remove 2\\", \\"sum\\" ] assert process_commands(commands) == [1] def test_process_commands_no_commands(): commands = [] assert process_commands(commands) == [] def test_process_commands_multiple_sums(): commands = [ \\"append 4\\", \\"sum\\", \\"append 5\\", \\"sum\\", \\"append 6\\", \\"sum\\" ] assert process_commands(commands) == [4, 9, 15] def test_process_commands_all_remove_and_add(): commands = [ \\"append 1\\", \\"append 2\\", \\"append 3\\", \\"remove 2\\", \\"sum\\", \\"remove 1\\", \\"remove 3\\", \\"sum\\", \\"append 4\\", \\"sum\\" ] assert process_commands(commands) == [4, 0, 4]","solution":"def process_commands(commands): Processes a series of commands on a list of integers and returns the results of all sum commands. Args: commands (list of str): The list of commands. Returns: list of int: The results of all sum commands. lst = [] result = [] for command in commands: parts = command.split() cmd = parts[0] if cmd == \\"append\\": value = int(parts[1]) lst.append(value) elif cmd == \\"remove\\": value = int(parts[1]) if value in lst: lst.remove(value) elif cmd == \\"sum\\": result.append(sum(lst)) return result"},{"question":"def find_most_frequent(lst): Write a function \`find_most_frequent\` that accepts a list of integers and returns the integer that appears most frequently in the list. If there are multiple integers with the same highest frequency, return the smallest one among them. >>> find_most_frequent([1, 3, 2, 1, 4, 3, 2, 1, 3, 3, 4]) 3 >>> find_most_frequent([5, 5, 6, 6, 7]) 5 >>> find_most_frequent([1, 2, 2, 1, 3]) 1 >>> find_most_frequent([42]) 42 >>> find_most_frequent([7, 7, 7, 7, 7]) 7 >>> find_most_frequent([10**9, -10**9, 10**9, -10**9, 10**9]) 10**9 >>> large_list = [1] * 500000 + [2] * 300000 + [3] * 200000 >>> find_most_frequent(large_list) 1","solution":"def find_most_frequent(lst): from collections import Counter # Create a counter of the frequencies of each integer in the list counts = Counter(lst) # Find the maximum frequency max_freq = max(counts.values()) # Collect all numbers with the maximum frequency most_frequent_numbers = [num for num, freq in counts.items() if freq == max_freq] # Return the smallest number among the most frequent numbers return min(most_frequent_numbers)"},{"question":"def rotate_array(arr: List[int], k: int) -> None: Rotates the array to the right by k steps. Modifies the array in place. :param arr: List of integers to be rotated :param k: Number of steps to rotate the array >>> arr = [1, 2, 3, 4, 5] >>> rotate_array(arr, 2) >>> arr [4, 5, 1, 2, 3] >>> arr = [1] >>> rotate_array(arr, 3) >>> arr [1] >>> arr = [1, 2, 3, 4, 5] >>> rotate_array(arr, 0) >>> arr [1, 2, 3, 4, 5] >>> arr = [1, 2, 3, 4, 5] >>> rotate_array(arr, 7) >>> arr [4, 5, 1, 2, 3] >>> arr = [1, 2, 3, 4, 5] >>> rotate_array(arr, 5) >>> arr [1, 2, 3, 4, 5] >>> arr = [-1, -100, 3, 99] >>> rotate_array(arr, 2) >>> arr [3, 99, -1, -100]","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. n = len(arr) k = k % n # Normalize k to be within the length of the array arr[:] = arr[-k:] + arr[:-k] # This modifies the array in place"},{"question":"def count_distinct_colors(test_cases): Determine the number of distinct colors in each image grid from given test cases. >>> count_distinct_colors([(3, 3, [[1, 2, 3], [4, 5, 1], [6, 7, 8]]), (2, 2, [[1, 1], [1, 1]])]) [8, 1] def parse_input(input_str): Parse the input string to extract the test cases. >>> parse_input('2n3 3n1 2 3n4 5 1n6 7 8n2 2n1 1n1 1') [(3, 3, [[1, 2, 3], [4, 5, 1], [6, 7, 8]]), (2, 2, [[1, 1], [1, 1]])] def main(input_str): Main function to process the input and print the number of distinct colors for each test case. Example usage: example_input = '2n3 3n1 2 3n4 5 1n6 7 8n2 2n1 1n1 1' main(example_input) # Example unit tests def test_count_distinct_colors(): test_cases = [ (3, 3, [[1, 2, 3], [4, 5, 1], [6, 7, 8]]), (2, 2, [[1, 1], [1, 1]]) ] assert count_distinct_colors(test_cases) == [8, 1] def test_with_larger_grid(): test_cases = [ (4, 4, [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) ] assert count_distinct_colors(test_cases) == [16] def test_with_empty_grid(): test_cases = [ (0, 0, []) ] assert count_distinct_colors(test_cases) == [0] def test_with_duplicate_colors(): test_cases = [ (3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]), (2, 2, [[2, 3], [3, 2]]) ] assert count_distinct_colors(test_cases) == [1, 2] # Running the tests test_count_distinct_colors() test_with_larger_grid() test_with_empty_grid() test_with_duplicate_colors()","solution":"def count_distinct_colors(test_cases): results = [] for case in test_cases: n, m, grid = case distinct_colors = set() for row in grid: distinct_colors.update(row) results.append(len(distinct_colors)) return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n, m = map(int, lines[index].split()) grid = [] for i in range(n): grid.append(list(map(int, lines[index + 1 + i].split()))) test_cases.append((n, m, grid)) index += n + 1 return test_cases def main(input_str): test_cases = parse_input(input_str) results = count_distinct_colors(test_cases) for result in results: print(result) # Example usage example_input = '''2 3 3 1 2 3 4 5 1 6 7 8 2 2 1 1 1 1''' main(example_input)"},{"question":"def transform_texts(datasets): Transforms a list of text datasets by replacing each letter with its opposite character in the sequence. Non-alphabetic characters remain unchanged. Args: datasets (list of str): List containing the text datasets as strings. Returns: list of str: List containing the transformed text datasets. from solution import transform_texts def test_transform_texts_simple(): datasets = [ \\"hello\\", \\"RgV\\" ] expected_output = [ \\"svool\\", \\"ItE\\" ] assert transform_texts(datasets) == expected_output def test_transform_texts_mixed(): datasets = [ \\"aBc\\", \\"xYz\\", \\"Hello, World!\\" ] expected_output = [ \\"zYx\\", \\"cBa\\", \\"Svool, Dliow!\\" ] assert transform_texts(datasets) == expected_output def test_transform_texts_no_alphabetic(): datasets = [ \\"123\\", \\"!@#\\", \\" \\" ] expected_output = [ \\"123\\", \\"!@#\\", \\" \\" ] assert transform_texts(datasets) == expected_output def test_transform_texts_empty_string(): datasets = [ \\"\\", \\" \\" ] expected_output = [ \\"\\", \\" \\" ] assert transform_texts(datasets) == expected_output","solution":"def transform_texts(datasets): Transforms a list of text datasets by replacing each letter with its opposite character in the sequence. Non-alphabetic characters remain unchanged. Args: datasets (list of str): List containing the text datasets as strings. Returns: list of str: List containing the transformed text datasets. def replace_char(char): if 'a' <= char <= 'z': return chr(219 - ord(char)) elif 'A' <= char <= 'Z': return chr(155 - ord(char)) else: return char transformed_texts = [] for text in datasets: transformed_text = ''.join(replace_char(char) for char in text) transformed_texts.append(transformed_text) return transformed_texts"},{"question":"def minimal_distance(x1, y1, x2, y2, n, buildings): Calculate the minimal distance the drone needs to cover from point A to point B. :param x1: int, starting x-coordinate :param y1: int, starting y-coordinate :param x2: int, destination x-coordinate :param y2: int, destination y-coordinate :param n: int, number of buildings :param buildings: list of tuples, each containing four integers representing a building :return: float, minimal distance the drone needs to travel >>> minimal_distance(0, 0, 3, 3, 0, []) 4.2426406871 >>> minimal_distance(0, 0, 3, 3, 1, [(1, 1, 2, 2)]) 4.2426406871 >>> minimal_distance(-3, -3, 3, 3, 2, [(-1, -1, 1, 1), (2, 2, 4, 4)]) 8.4852813742 >>> minimal_distance(-10**9, -10**9, 10**9, 10**9, 1, [(0, 0, 1, 1)]) 2828427124746.1904 pass","solution":"import math def minimal_distance(x1, y1, x2, y2, n, buildings): Calculate the minimal distance the drone needs to cover from point A to point B. :param x1: int, starting x-coordinate :param y1: int, starting y-coordinate :param x2: int, destination x-coordinate :param y2: int, destination y-coordinate :param n: int, number of buildings :param buildings: list of tuples, each containing four integers representing a building :return: float, minimal distance the drone needs to travel # If there are no buildings, return the direct Euclidean distance if n == 0: return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) # Placeholder for more complex pathfinding algorithm # Just calculating the direct distance for demonstration as it always valid, since the drone can fly over buildings return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)"},{"question":"from typing import List, Tuple def find_highest_calorie_recipe(ingredient_calories: List[Tuple[str, int]], recipes: List[List[str]]) -> Tuple[int, int]: Find the recipe with the highest calorie count. Args: ingredient_calories (list): A list of tuples where each tuple contains an ingredient name and its calories. recipes (list): A list of recipes, where each recipe is a list of ingredient names. Returns: tuple: Index of the recipe with the highest calorie count and the total calories. pass # Unit Tests def test_example_case(): ingredient_calories = [('flour', 364), ('sugar', 400), ('egg', 78), ('butter', 102)] recipes = [['flour', 'sugar', 'egg'], ['sugar', 'butter'], ['flour', 'butter'], ['egg', 'sugar']] assert find_highest_calorie_recipe(ingredient_calories, recipes) == (0, 842) def test_single_recipe(): ingredient_calories = [('flour', 364), ('sugar', 400)] recipes = [['flour']] assert find_highest_calorie_recipe(ingredient_calories, recipes) == (0, 364) def test_multiple_highest_calorie_recipe(): ingredient_calories = [('flour', 100), ('sugar', 200)] recipes = [['flour', 'sugar'], ['sugar', 'flour']] assert find_highest_calorie_recipe(ingredient_calories, recipes) == (0, 300) def test_multiple_ingredients_in_recipe(): ingredient_calories = [('flour', 100), ('sugar', 200), ('egg', 50)] recipes = [['flour', 'egg'], ['sugar']] assert find_highest_calorie_recipe(ingredient_calories, recipes) == (1, 200) def test_minimal_case(): ingredient_calories = [('ingredient', 100)] recipes = [['ingredient']] assert find_highest_calorie_recipe(ingredient_calories, recipes) == (0, 100)","solution":"def find_highest_calorie_recipe(ingredient_calories, recipes): Find the recipe with the highest calorie count. Args: ingredient_calories (list): A list of tuples where each tuple contains an ingredient name and its calories. recipes (list): A list of recipes, where each recipe is a list of ingredient names. Returns: tuple: Index of the recipe with the highest calorie count and the total calories. calorie_dict = {ingredient: calories for ingredient, calories in ingredient_calories} max_calories = 0 max_index = -1 for index, recipe in enumerate(recipes): total_calories = sum(calorie_dict[ingredient] for ingredient in recipe) if total_calories > max_calories: max_calories = total_calories max_index = index return max_index, max_calories"},{"question":"def is_fully_connected(n, m, connections): Determine if it's possible to visit all the bus stops starting from any one of them. Parameters: n (int): Number of bus stops. m (int): Number of direct connections. connections (List[Tuple[int, int]]): Direct connections between bus stops. Returns: str: \\"YES\\" if the graph is fully connected, otherwise \\"NO\\". >>> is_fully_connected(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 'YES' >>> is_fully_connected(5, 3, [(1, 2), (2, 3), (4, 5)]) 'NO' import pytest def test_fully_connected_graph(): assert is_fully_connected(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == \\"YES\\" def test_not_fully_connected_graph(): assert is_fully_connected(5, 3, [(1, 2), (2, 3), (4, 5)]) == \\"NO\\" def test_single_node(): assert is_fully_connected(1, 0, []) == \\"YES\\" def test_disconnected_graph(): assert is_fully_connected(6, 4, [(1, 2), (2, 3), (4, 5)]) == \\"NO\\" def test_connected_graph_with_extra_isolated_node(): assert is_fully_connected(5, 4, [(1, 2), (2, 3), (3, 4), (1, 5)]) == \\"YES\\" def test_large_connected_graph(): connections = [(i, i+1) for i in range(1, 1000)] assert is_fully_connected(1000, 999, connections) == \\"YES\\"","solution":"def is_fully_connected(n, m, connections): if n == 1: return \\"YES\\" from collections import defaultdict, deque graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) visited = set() def bfs(start): queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # We can start BFS/DFS from any node; here we start from 1 bfs(1) # Check if all nodes from 1 to n are visited if len(visited) == n: return \\"YES\\" else: return \\"NO\\""},{"question":"def count_ways_to_place_min_obstacles(N: int, M: int, instructions: str, fx: int, fy: int) -> int: Valera has a grid of N rows and M columns, with a robot that moves according to a sequence of instructions. Find the number of ways to place the minimum number of obstacles such that the robot reaches the finish cell (fx, fy). Args: N (int): Number of rows in the grid. M (int): Number of columns in the grid. instructions (str): Sequence of moves (U, D, L, R) for the robot. fx (int): Row index of the finish cell. fy (int): Column index of the finish cell. Returns: int: The number of ways to place the minimum number of obstacles. Example: >>> count_ways_to_place_min_obstacles(3, 3, 'DDRR', 3, 3) 1 >>> count_ways_to_place_min_obstacles(3, 3, 'DDDRRR', 3, 3) 1 def test_count_ways_to_place_min_obstacles(): # Trivial Case with no obstacles needed assert count_ways_to_place_min_obstacles(3, 3, 'DDRR', 3, 3) == 1 # Case where we need at least one obstacle to make robot reach (3, 3) assert count_ways_to_place_min_obstacles(3, 3, 'DDDRRR', 3, 3) == 1 # Case where multiple obstacles are necessary assert count_ways_to_place_min_obstacles(5, 5, 'DDRRUURRDD', 5, 5) == 0 # Case where the robot cannot move to the target position as given in instructions assert count_ways_to_place_min_obstacles(5, 5, 'UUU', 5, 5) == 0 # Edge cases assert count_ways_to_place_min_obstacles(1, 1, '', 1, 1) == 1 # Case with multiple distinct ways to place minimum obstacles assert count_ways_to_place_min_obstacles(2, 2, 'DRRUULLDD', 1, 2) == 1 # Complex cases with longer instruction sequences assert count_ways_to_place_min_obstacles(1000, 1000, 'R' * 999 + 'D' * 999, 1000, 1000) == 1","solution":"def count_ways_to_place_min_obstacles(N, M, instructions, fx, fy): # Initial positions x, y = 1, 1 # Directions move = { 'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1) } # Calculate the robot's final position without any obstacles for inst in instructions: dx, dy = move[inst] x, y = x + dx, y + dy # If the robot ends up in the proper cell without any obstacles if (x, y) == (fx, fy): return 1 # The minimum number of obstacles needed to be placed such that the robot ends up exactly at (fx, fy) def simulate_with_obstacles_count(instructions, target_x, target_y): x, y = 1, 1 obstructed_positions = set() for inst in instructions: dx, dy = move[inst] next_x, next_y = x + dx, y + dy # Check if going next crosses the boundary if 1 <= next_x <= N and 1 <= next_y <= M: x, y = next_x, next_y if x == target_x and y == target_y: obstructed_positions.add((next_x, next_y)) # Do not actually move to (next_x, next_y) but instead stay in current cell x, y = x - dx, y - dy return len(obstructed_positions), obstructed_positions # Calculate the minimum obstacles needed to be placed min_obstacles, obstructed_positions = simulate_with_obstacles_count(instructions, fx, fy) return min_obstacles # Test the function with an example print(count_ways_to_place_min_obstacles(3, 3, 'DDRR', 3, 3)) # Output: 0"},{"question":"def final_position(commands): Computes the final position of the robot after a sequence of movements. Parameters: commands (list): List of commands in the format [N, Command1, Command2, ..., CommandN] Returns: tuple: Final coordinates of the robot (x, y) pass def process_datasets(input_data): Processes multiple datasets of robot commands and returns their final positions. Parameters: input_data (str): Input string containing multiple datasets Returns: list: A list of final coordinates tuples for each dataset pass def test_final_position(): assert final_position([\\"4\\", \\"N 2\\", \\"E 3\\", \\"S 1\\", \\"W 4\\"]) == (-1, 1) assert final_position([\\"3\\", \\"N 5\\", \\"E 5\\", \\"S 10\\"]) == (5, -5) assert final_position([\\"2\\", \\"E 10\\", \\"S 7\\"]) == (10, -7) assert final_position([\\"1\\", \\"N 100\\"]) == (0, 100) def test_process_datasets(): input_data = 4 N 2 E 3 S 1 W 4 3 N 5 E 5 S 10 0 expected = [(-1, 1), (5, -5)] assert process_datasets(input_data) == expected input_data = 2 E 10 S 7 1 N 100 0 expected = [(10, -7), (0, 100)] assert process_datasets(input_data) == expected input_data = 1 W 7 1 E 20 1 S 15 1 N 25 0 expected = [(-7, 0), (20, 0), (0, -15), (0, 25)] assert process_datasets(input_data) == expected","solution":"def final_position(commands): Computes the final position of the robot after a sequence of movements. Parameters: commands (list): List of commands in the format [N, Command1, Command2, ..., CommandN] Returns: tuple: Final coordinates of the robot (x, y) x, y = 0, 0 for command in commands[1:]: direction, steps = command.split() steps = int(steps) if direction == 'N': y += steps elif direction == 'S': y -= steps elif direction == 'E': x += steps elif direction == 'W': x -= steps return (x, y) def process_datasets(input_data): Processes multiple datasets of robot commands and returns their final positions. Parameters: input_data (str): Input string containing multiple datasets Returns: list: A list of final coordinates tuples for each dataset lines = input_data.strip().split(\\"n\\") index = 0 results = [] while index < len(lines): num_commands = int(lines[index]) if num_commands == 0: break commands = lines[index:index+num_commands+1] final_pos = final_position(commands) results.append(final_pos) index += num_commands + 1 return results"},{"question":"from typing import List, Tuple def parse_input(input_lines: str) -> List[List[Tuple[int, int]]]: Parse the input string and return the test cases data. def count_unique_squares(points: List[Tuple[int, int]]) -> int: Count the number of unique squares that can be formed from the given points. def unique_squares(test_cases: List[List[Tuple[int, int]]]) -> List[int]: For each test case, determine the number of unique squares that can be formed. # Unit Tests def test_case_1(): input_data = \\"1n4n0 0n0 1n1 0n1 1n\\" test_cases = parse_input(input_data) assert unique_squares(test_cases) == [1] def test_case_2(): input_data = \\"1n5n0 0n0 1n1 0n1 1n2 2n\\" test_cases = parse_input(input_data) assert unique_squares(test_cases) == [1] def test_case_3(): input_data = \\"1n8n0 0n0 2n2 0n2 2n1 1n1 3n3 1n3 3n\\" test_cases = parse_input(input_data) assert unique_squares(test_cases) == [2] def test_case_4(): input_data = \\"2n4n0 0n0 1n1 0n1 1n5n0 0n0 1n1 0n1 1n2 2n\\" test_cases = parse_input(input_data) assert unique_squares(test_cases) == [1, 1] def test_case_5(): input_data = \\"1n3n0 0n1 1n2 2n\\" test_cases = parse_input(input_data) assert unique_squares(test_cases) == [0]","solution":"from collections import defaultdict def count_unique_squares(points): points_set = set((x, y) for x, y in points) n = len(points) lookup = defaultdict(int) for i in range(n): for j in range(i + 1, n): (x1, y1) = points[i] (x2, y2) = points[j] if (x1 != x2 and y1 != y2 and (x1, y2) in points_set and (x2, y1) in points_set): center = ((x1 + x2) // 2, (y1 + y2) // 2) dist = (x1 - x2) ** 2 + (y1 - y2) ** 2 lookup[(center, dist)] += 1 return len(lookup) def unique_squares(test_cases): results = [] for points in test_cases: results.append(count_unique_squares(points)) return results def parse_input(input_lines): input_data = input_lines.strip().split('n') T = int(input_data[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_data[index]) points = [] index += 1 for _ in range(N): x, y = map(int, input_data[index].split()) points.append((x, y)) index += 1 test_cases.append(points) return test_cases"},{"question":"def unique_paths_with_obstacles(grid): Calculate the number of unique paths from the top-left corner to the bottom-right corner on a grid, considering obstacles. :param grid: List[List[int]], the grid of size n x m containing '0' open paths and '1' obstacles. :return: int, the number of unique paths to the bottom-right corner. Example: >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 2 >>> unique_paths_with_obstacles([[0, 1], [1, 0]]) == 0 >>> unique_paths_with_obstacles([[0]]) == 1 >>> unique_paths_with_obstacles([[1]]) == 0 >>> unique_paths_with_obstacles([[0, 0, 0], [1, 1, 0], [0, 0, 0]]) == 1 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 1]]) == 0 >>> unique_paths_with_obstacles([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0","solution":"def unique_paths_with_obstacles(grid): Calculate the number of unique paths from the top-left corner to the bottom-right corner on a grid, considering obstacles. :param grid: List[List[int]], the grid of size n x m containing '0' open paths and '1' obstacles. :return: int, the number of unique paths to the bottom-right corner. n = len(grid) m = len(grid[0]) # If the starting point or ending point is an obstacle, there's no valid path. if grid[0][0] == 1 or grid[n-1][m-1] == 1: return 0 # Initialize a 2D dp array with 0's dp = [[0] * m for _ in range(n)] # Starting point dp[0][0] = 1 # Fill the dp array for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1]"},{"question":"def sort_unique_binaries(int_list: List[int]) -> List[str]: Process the list of integers to remove duplicates, convert to binary strings, and sort these binary strings numerically. Parameters: int_list (list): List of integers Returns: list: List of sorted binary string representations of the unique integers Examples: >>> sort_unique_binaries([10, 2, 10, 5, 3, 2]) ['10', '11', '101', '1010'] >>> sort_unique_binaries([1, 4, 3, 2, 6, 7, 5]) ['1', '10', '11', '100', '101', '110', '111'] pass # Unit Tests def test_sort_unique_binaries_example1(): input_data = [10, 2, 10, 5, 3, 2] expected_output = ['10', '11', '101', '1010'] assert sort_unique_binaries(input_data) == expected_output def test_sort_unique_binaries_example2(): input_data = [1, 4, 3, 2, 6, 7, 5] expected_output = ['1', '10', '11', '100', '101', '110', '111'] assert sort_unique_binaries(input_data) == expected_output def test_sort_unique_binaries_single_element(): input_data = [15] expected_output = ['1111'] assert sort_unique_binaries(input_data) == expected_output def test_sort_unique_binaries_all_duplicates(): input_data = [8, 8, 8, 8] expected_output = ['1000'] assert sort_unique_binaries(input_data) == expected_output def test_sort_unique_binaries_large_numbers(): input_data = [1024, 512, 256, 128] expected_output = ['10000000', '100000000', '1000000000', '10000000000'] assert sort_unique_binaries(input_data) == expected_output","solution":"def sort_unique_binaries(int_list): Process the list of integers to remove duplicates, convert to binary strings, and sort these binary strings numerically. Parameters: int_list (list): List of integers Returns: list: List of sorted binary string representations of the unique integers # Step 1: Remove duplicates unique_integers = set(int_list) # Step 2: Convert each unique integer to its binary representation as a string binary_strings = [bin(num)[2:] for num in unique_integers] # Step 3: Sort the binary strings numerically sorted_binary_strings = sorted(binary_strings, key=lambda x: int(x, 2)) return sorted_binary_strings"},{"question":"def min_patrol_time(n: int, positions: List[int]) -> int: Calculate the minimum time in seconds required for Xeno to patrol all artifact positions and return to the entrance. :param n: int - Number of artifacts. :param positions: list of int - Positions of the artifacts. :return: int - Minimum time in seconds. >>> min_patrol_time(3, [2, 8, 5]) == 16 >>> min_patrol_time(4, [1, 3, 7, 10]) == 20 pass from solution import min_patrol_time def test_min_patrol_time_example1(): assert min_patrol_time(3, [2, 8, 5]) == 16 def test_min_patrol_time_example2(): assert min_patrol_time(4, [1, 3, 7, 10]) == 20 def test_min_patrol_time_single_position(): assert min_patrol_time(1, [5]) == 10 def test_min_patrol_time_same_positions(): assert min_patrol_time(4, [5, 5, 5, 5]) == 10 def test_min_patrol_time_single_position_at_max(): assert min_patrol_time(1, [1000]) == 2000 def test_min_patrol_time_minimum_case(): assert min_patrol_time(1, [1]) == 2 def test_min_patrol_time_two_positions(): assert min_patrol_time(2, [2, 8]) == 16 def test_min_patrol_time_five_positions(): assert min_patrol_time(5, [1, 2, 3, 10, 20]) == 40","solution":"def min_patrol_time(n, positions): Calculate the minimum time in seconds required for Xeno to patrol all artifact positions and return to the entrance. :param n: int - Number of artifacts. :param positions: list of int - Positions of the artifacts. :return: int - Minimum time in seconds. if n == 0: return 0 # Calculate the distance to the farthest artifact and back to the entrance farthest_position = max(positions) # Total distance covered is going to the farthest artifact and back total_distance = farthest_position * 2 return total_distance"},{"question":"from typing import List def min_subarrays(n: int, k: int, t: int, sequence: List[int]) -> int: Determine the minimum number of subarrays of length k with a sum >= t. Parameters: n (int): Length of the sequence. k (int): Required length of each subarray. t (int): The threshold for the sum of the elements in each subarray. sequence (List[int]): The elements of the sequence. Returns: int: The minimum number of subarrays needed, or -1 if impossible. >>> min_subarrays(8, 3, 15, [5, 4, 6, 7, 8, 9, 3, 2]) 2 >>> min_subarrays(6, 2, 20, [4, 15, 3, 7, 9, 6]) -1 >>> min_subarrays(10, 5, 50, [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) 2 def test_example_1(): assert min_subarrays(8, 3, 15, [5, 4, 6, 7, 8, 9, 3, 2]) == 2 def test_example_2(): assert min_subarrays(6, 2, 20, [4, 15, 3, 7, 9, 6]) == -1 def test_example_3(): assert min_subarrays(10, 5, 50, [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) == 2 def test_subarray_not_possible(): assert min_subarrays(4, 5, 10, [1, 2, 3, 4]) == -1 def test_threshold_not_reached(): assert min_subarrays(5, 2, 10, [1, 2, 3, 4, 5]) == -1 def test_all_elements_valid(): assert min_subarrays(5, 1, 1, [1, 1, 1, 1, 1]) == 5 def test_large_threshold(): assert min_subarrays(5, 5, 25, [5, 5, 5, 5, 6]) == 1","solution":"def min_subarrays(n, k, t, sequence): # Ensure we're not trying to form subarrays larger than the sequence if n < k: return -1 subarray_count = 0 i = 0 while i <= n - k: subarray_sum = sum(sequence[i:i + k]) if subarray_sum >= t: subarray_count += 1 i += k else: # If we cannot find sufficient sum in any k-length subarray, return -1 return -1 return subarray_count # Handling input format if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) k = int(data[1]) t = int(data[2]) sequence = list(map(int, data[3:])) result = min_subarrays(n, k, t, sequence) print(result)"},{"question":"def canReachBottomRight(grid: List[List[int]]) -> bool: Determines if the robot can reach the bottom-right corner of the grid. The grid is represented by an m x n matrix where each cell contains either a 0 (free space) or a 1 (obstacle). The robot can move down, right, or diagonally down-right. >>> canReachBottomRight([ ... [0, 0, 0], ... [1, 0, 1], ... [0, 0, 0] ... ]) True >>> canReachBottomRight([ ... [0, 1, 1], ... [1, 1, 1], ... [1, 1, 0] ... ]) False Returns: bool: True if the robot can reach the bottom-right corner, False otherwise. from typing import List def test_simple_path(): grid = [ [0, 0, 0], [1, 0, 1], [0, 0, 0] ] assert canReachBottomRight(grid) def test_no_path(): grid = [ [0, 1, 1], [1, 1, 1], [1, 1, 0] ] assert not canReachBottomRight(grid) def test_direct_path(): grid = [ [0] ] assert canReachBottomRight(grid) def test_with_obstacles(): grid = [ [0, 0, 1], [1, 0, 1], [1, 1, 0] ] assert canReachBottomRight(grid) def test_one_column_path(): grid = [ [0], [0], [0] ] assert canReachBottomRight(grid) def test_larger_grid(): grid = [ [0, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0], [1, 1, 1, 0] ] assert canReachBottomRight(grid)","solution":"def canReachBottomRight(grid): Determines if the robot can reach the bottom-right corner of the grid. Parameters: grid (List[List[int]]): The grid representation where 0 is free space and 1 is an obstacle. Returns: bool: True if the robot can reach the bottom-right corner, False otherwise. if not grid or not grid[0]: return False m, n = len(grid), len(grid[0]) def is_valid(x, y): return 0 <= x < m and 0 <= y < n and grid[x][y] == 0 def dfs(x, y): if x == m-1 and y == n-1: return True if not is_valid(x, y): return False # mark the cell as visited grid[x][y] = 1 # move down if dfs(x+1, y): return True # move right if dfs(x, y+1): return True # move diagonally if dfs(x+1, y+1): return True return False return dfs(0, 0)"},{"question":"def find_connected_components(n, edges): Find the number of connected components in an undirected graph. from collections import defaultdict, deque def bfs(start): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) component_count = 0 for i in range(1, n + 1): if not visited[i]: component_count += 1 bfs(i) return component_count def min_new_paths_to_add(n, m, edges): Returns the minimum number of new paths that need to be added to make the park fully connected. components = find_connected_components(n, edges) return components - 1 def park_paths(n, m, paths): Determine the minimum number of new paths to add to make the park fully connected. >>> park_paths(5, 3, [\\"1 2\\", \\"2 3\\", \\"4 5\\"]) 1 >>> park_paths(4, 1, [\\"1 2\\"]) 2 >>> park_paths(4, 4, [\\"1 2\\", \\"2 3\\", \\"3 4\\", \\"4 1\\"]) 0 >>> park_paths(1, 0, []) 0 >>> park_paths(3, 0, []) 2 >>> park_paths(6, 4, [\\"1 2\\", \\"3 4\\", \\"5 6\\"]) 2 >>> park_paths(6, 15, [\\"1 2\\", \\"1 3\\", \\"1 4\\", \\"1 5\\", \\"1 6\\", \\"2 3\\", \\"2 4\\", \\"2 5\\", \\"2 6\\", \\"3 4\\", \\"3 5\\", \\"3 6\\", \\"4 5\\", \\"4 6\\", \\"5 6\\"]) 0","solution":"def find_connected_components(n, edges): Find the number of connected components in an undirected graph. from collections import defaultdict, deque def bfs(start): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) component_count = 0 for i in range(1, n + 1): if not visited[i]: component_count += 1 bfs(i) return component_count def min_new_paths_to_add(n, m, edges): Returns the minimum number of new paths that need to be added to make the park fully connected. components = find_connected_components(n, edges) return components - 1 # Example function to read input, useful for testing manually or specifying input directly def park_paths(n, m, paths): edges = [tuple(map(int, path.split())) for path in paths] return min_new_paths_to_add(n, m, edges)"},{"question":"from typing import List, Tuple from collections import deque, defaultdict def count_valid_start_islands(n: int, d: int, k: int, known_islands: List[int], bridges: List[Tuple[int, int]]) -> int: In an enchanting forest, there are n mystical islands interconnected by exactly n-1 magical bridges. Each bridge links a pair of islands and it is possible to travel between any two islands using one or more bridges. The Great Wizard of the forest has a flying broomstick that can help him quickly travel between islands, but the broomstick is limited by its flight power k. This means the Wizard can fly between two islands if the minimum number of bridges between them is at most k. The wizard is intrigued by d specific islands that are known to be home to unique magical creatures. Their numbers are q1, q2, ..., qd. The wizard wants to identify which islands he can start from and be able to visit all d known islands using his broomstick's flight power. Input - n: an integer representing the total number of islands. - d: an integer representing the number of known magical creature islands. - k: an integer representing the maximum number of bridges the broomstick can traverse. - known_islands: a list of integers representing the known magical creature islands. - bridges: a list of tuples where each tuple contains two integers representing the interconnected islands. Output - Return a single number, the number of islands from which the wizard can start and visit all known magical creature islands using his broomstick's flight power. If it's not possible to start from any island, return 0. >>> count_valid_start_islands(7, 3, 2, [3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)]) 3 >>> count_valid_start_islands(5, 2, 1, [2, 3], [(1, 2), (2, 3), (3, 4), (4, 5)]) 2 >>> count_valid_start_islands(4, 2, 0, [1, 4], [(1, 2), (2, 3), (3, 4)]) 0","solution":"from collections import deque, defaultdict def bfs_distance(n, start, edges): # Using BFS to calculate distances from the start island queue = deque([start]) distances = [-1] * (n + 1) distances[start] = 0 while queue: current = queue.popleft() for neighbor in edges[current]: if distances[neighbor] == -1: distances[neighbor] = distances[current] + 1 queue.append(neighbor) return distances def count_valid_start_islands(n, d, k, known_islands, bridges): edges = defaultdict(list) for u, v in bridges: edges[u].append(v) edges[v].append(u) valid_start_count = 0 for start in range(1, n + 1): distances = bfs_distance(n, start, edges) if all(distances[qi] <= k for qi in known_islands): valid_start_count += 1 return valid_start_count # Example usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) d = int(data[1]) k = int(data[2]) known_islands = list(map(int, data[3:3+d])) bridges = [] for i in range(3+d, len(data), 2): u = int(data[i]) v = int(data[i+1]) bridges.append((u, v)) result = count_valid_start_islands(n, d, k, known_islands, bridges) print(result)"},{"question":"def min_cost_wall(M: int, N: int, cost_matrix: List[List[int]]) -> int: Find the minimum cost of building a continuous vertical wall from the top row to the bottom row with allowed moves to directly below, diagonally left, or diagonally right cell. Parameters: M (int): The number of rows in the matrix. N (int): The number of columns in the matrix. cost_matrix (List[List[int]]): The matrix where each cell represents the cost to build a wall on that cell. Returns: int: The minimum cost required to build the wall. Examples: >>> min_cost_wall(3, 4, [ ... [1, 3, 1, 5], ... [2, 2, 4, 1], ... [5, 1, 2, 3] ... ]) 4 >>> min_cost_wall(2, 3, [ ... [10, 2, 1], ... [1, 2, 10] ... ]) 3 from typing import List def test_example_1(): cost_matrix = [ [1, 3, 1, 5], [2, 2, 4, 1], [5, 1, 2, 3] ] assert min_cost_wall(3, 4, cost_matrix) == 4 def test_example_2(): cost_matrix = [ [10, 2, 1], [1, 2, 10] ] assert min_cost_wall(2, 3, cost_matrix) == 3 def test_single_cell(): cost_matrix = [ [5] ] assert min_cost_wall(1, 1, cost_matrix) == 5 def test_all_zero_cost(): cost_matrix = [ [0, 0], [0, 0] ] assert min_cost_wall(2, 2, cost_matrix) == 0 def test_large_cost_values(): cost_matrix = [ [1000, 999], [998, 1000] ] assert min_cost_wall(2, 2, cost_matrix) == 1997","solution":"def min_cost_to_build_wall(cost): if not cost or not cost[0]: return 0 M, N = len(cost), len(cost[0]) dp = [[0]*N for _ in range(M)] # Initialize the first row of dp array to the cost of the top row for j in range(N): dp[0][j] = cost[0][j] # Build the dp array for i in range(1, M): for j in range(N): # Cost to reach cell (i, j) would be the cost of (i, j) plus the minimum cost of the reachable cells from previous row dp[i][j] = cost[i][j] + min(dp[i-1][j], dp[i-1][j-1] if j-1 >= 0 else float('inf'), dp[i-1][j+1] if j+1 < N else float('inf')) # The minimum cost to build the wall will be the minimum value in the last row of dp array return min(dp[M-1]) def min_cost_wall(M, N, cost_matrix): return min_cost_to_build_wall(cost_matrix)"},{"question":"def normalized_ranking(n, scores): Determine the normalized ranking of participants based on their scores. Args: n (int): Number of participants scores (list of int): Scores of participants Returns: list of int: Rankings of participants based on their normalized scores pass # Example tests def test_single_participant(): assert normalized_ranking(1, [42]) == [1] def test_equal_scores(): assert normalized_ranking(3, [10, 10, 10]) == [1, 1, 1] def test_distinct_scores(): assert normalized_ranking(5, [10, 20, 20, 30, 40]) == [5, 3, 3, 2, 1] def test_some_equal_scores(): assert normalized_ranking(4, [12, 15, 15, 10]) == [3, 1, 1, 4] def test_large_range_scores(): assert normalized_ranking(5, [100, 200, 1000, 300, 500]) == [5, 4, 1, 3, 2] def test_scores_with_min_zero(): assert normalized_ranking(4, [0, 25, 50, 75]) == [4, 3, 2, 1] def test_scores_with_max_same_min(): assert normalized_ranking(4, [4, 4, 2, 2]) == [1, 1, 3, 3] def test_increasing_scores(): assert normalized_ranking(5, [1, 2, 3, 4, 5]) == [5, 4, 3, 2, 1] def test_decreasing_scores(): assert normalized_ranking(5, [5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]","solution":"def normalized_ranking(n, scores): Determine the normalized ranking of participants based on their scores. Args: n (int): Number of participants scores (list of int): Scores of participants Returns: list of int: Rankings of participants based on their normalized scores if n == 1: return [1] min_score, max_score = min(scores), max(scores) if max_score == min_score: return [1] * n normalized_scores = [(score - min_score) / (max_score - min_score) for score in scores] sorted_indices = sorted(range(n), key=lambda i: -normalized_scores[i]) ranks = [0] * n current_rank = 1 for i in range(n): if i == 0 or normalized_scores[sorted_indices[i]] < normalized_scores[sorted_indices[i-1]]: current_rank = i + 1 ranks[sorted_indices[i]] = current_rank return ranks"},{"question":"def min_operations_for_sorting(arrays): Determine the minimum number of operations needed to sort the array by reversing subarrays. Args: arrays (List[List[int]]): A list of lists containing the input arrays for each test case. Returns: List[int]: A list of integers representing the minimum number of operations needed to sort each array. def process_input(input_data): Process the input data from string format into a list of arrays. Args: input_data (str): Multiline string with the number of test cases, followed by the arrays. Returns: List[List[int]]: A list of lists where each sublist is an array for a test case. def main(input_data): Main function to handle input and output for the sorting problem. Args: input_data (str): Multiline string input. Returns: List[int]: The results for each test case. >>> input_data = \\"3n5n4 5 1 3 2n3n3 2 1n4n1 3 2 4n\\" >>> main(input_data) [2, 1, 1] >>> input_data = \\"2n5n1 2 3 4 5n4n2 4 6 8n\\" >>> main(input_data) [0, 0]","solution":"def min_operations_for_sorting(arrays): results = [] for array in arrays: if array == sorted(array): results.append(0) elif array == sorted(array, reverse=True): results.append(1) elif array[0] == min(array) or array[-1] == max(array): results.append(1) else: results.append(2) return results def process_input(input_data): input_lines = input_data.strip().split(\\"n\\") t = int(input_lines[0]) arrays = [] index = 1 for _ in range(t): n = int(input_lines[index]) array = list(map(int, input_lines[index + 1].split())) arrays.append(array) index += 2 return arrays def main(input_data): arrays = process_input(input_data) return min_operations_for_sorting(arrays)"},{"question":"import math class Triangle: def __init__(self, a: float, b: float, c: float): Initialize the sides of the triangle. self.a = a self.b = b self.c = c def is_valid(self) -> bool: Check if the three sides can form a valid triangle. A triangle is valid if the sum of its any two sides is greater than the third side. pass def perimeter(self) -> float: Return the perimeter of the triangle. The perimeter is the sum of its three sides. pass def area(self) -> float: Return the area of the triangle using Heron's formula. Raises a ValueError if the triangle is not valid. pass # Test cases def test_triangle_is_valid(): assert Triangle(3, 4, 5).is_valid() is True assert Triangle(1, 2, 3).is_valid() is False assert Triangle(7, 10, 5).is_valid() is True assert Triangle(10, 10, 10).is_valid() is True assert Triangle(1, 1, 2).is_valid() is False def test_triangle_perimeter(): assert Triangle(3, 4, 5).perimeter() == 12 assert Triangle(7, 10, 5).perimeter() == 22 assert Triangle(10, 10, 10).perimeter() == 30 def test_triangle_area(): assert math.isclose(Triangle(3, 4, 5).area(), 6.0, rel_tol=1e-9) assert math.isclose(Triangle(7, 10, 5).area(), 16.24807680927192, rel_tol=1e-9) assert math.isclose(Triangle(10, 10, 10).area(), 43.30127018922193, rel_tol=1e-9) def test_triangle_area_invalid(): invalid_triangle = Triangle(1, 2, 3) try: invalid_triangle.area() assert False, \\"Expected ValueError for Invalid Triangle\\" except ValueError as ve: assert str(ve) == \\"Invalid Triangle\\"","solution":"import math class Triangle: def __init__(self, a, b, c): self.a = a self.b = b self.c = c def is_valid(self): Checks if the three sides can form a valid triangle. A triangle is valid if the sum of its any two sides is greater than the third side. return (self.a + self.b > self.c) and (self.a + self.c > self.b) and (self.b + self.c > self.a) def perimeter(self): Returns the perimeter of the triangle. The perimeter is the sum of its three sides. return self.a + self.b + self.c def area(self): Returns the area of the triangle using Heron's formula. Raises a ValueError if the triangle is not valid. if not self.is_valid(): raise ValueError(\\"Invalid Triangle\\") s = self.perimeter() / 2 return math.sqrt(s * (s - self.a) * (s - self.b) * (s - self.c))"},{"question":"from typing import List, Tuple def is_robust_network(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine if the network will remain connected if any single node is removed. Args: n (int): The number of nodes in the graph. m (int): The number of edges in the graph. edges (List[Tuple[int, int]]): List of edges in the graph. Returns: str: \\"YES\\" if the network will remain connected if any single node is removed, otherwise \\"NO\\". >>> is_robust_network(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'YES' >>> is_robust_network(5, 5, [(1, 2), (1, 3), (2, 3), (3, 4), (4, 5)]) 'NO' pass def test_example_one(): n, m = 4, 4 edges = [(1, 2), (2, 3), (3, 4), (4, 1)] assert is_robust_network(n, m, edges) == \\"YES\\" def test_example_two(): n, m = 5, 5 edges = [(1, 2), (1, 3), (2, 3), (3, 4), (4, 5)] assert is_robust_network(n, m, edges) == \\"NO\\" def test_complete_graph(): n, m = 5, 10 edges = [(1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)] assert is_robust_network(n, m, edges) == \\"YES\\" def test_minimal_graph(): n, m = 3, 2 edges = [(1, 2), (2, 3)] assert is_robust_network(n, m, edges) == \\"NO\\" def test_single_node_failure_still_connected(): n, m = 4, 5 edges = [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)] assert is_robust_network(n, m, edges) == \\"YES\\"","solution":"from collections import defaultdict def is_robust_network(n, m, edges): def dfs(v, excluded): stack = [v] visited = set() visited.add(v) while stack: node = stack.pop() for neighbor in graph[node]: if neighbor not in visited and neighbor != excluded: visited.add(neighbor) stack.append(neighbor) return visited graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) for excluded_node in range(1, n + 1): start_node = 1 if excluded_node != 1 else 2 visited = dfs(start_node, excluded_node) if len(visited) != n - 1: return \\"NO\\" return \\"YES\\""},{"question":"def is_path_exist(n: int, m: int, obstacles: List[Tuple[int, int]], start: Tuple[int, int], destination: Tuple[int, int]) -> str: Determine if there is a valid path from the robot's starting position to the destination without moving through any obstacles. >>> is_path_exist(5, 5, [(2, 2), (2, 3), (3, 2)], (1, 1), (5, 5)) \\"yes\\" >>> is_path_exist(5, 5, [(2, 2), (2, 3), (3, 2)], (1, 1), (2, 2)) \\"no\\" from typing import List, Tuple def test_path_exists_with_obstacles(): n = 5 m = 5 obstacles = [(2, 2), (2, 3), (3, 2)] start = (1, 1) destination = (5, 5) assert is_path_exist(n, m, obstacles, start, destination) == \\"yes\\" def test_no_path_due_to_obstacle_at_destination(): n = 5 m = 5 obstacles = [(2, 2), (2, 3), (3, 2)] start = (1, 1) destination = (2, 2) assert is_path_exist(n, m, obstacles, start, destination) == \\"no\\" def test_no_path_due_to_obstacle_at_start(): n = 5 m = 5 obstacles = [(1, 1), (2, 3), (3, 2)] start = (1, 1) destination = (5, 5) assert is_path_exist(n, m, obstacles, start, destination) == \\"no\\" def test_path_exists_with_no_obstacles(): n = 5 m = 5 obstacles = [] start = (1, 1) destination = (5, 5) assert is_path_exist(n, m, obstacles, start, destination) == \\"yes\\" def test_no_path_in_small_grid(): n = 2 m = 2 obstacles = [(1, 2), (2, 1)] start = (1, 1) destination = (2, 2) assert is_path_exist(n, m, obstacles, start, destination) == \\"no\\" def test_direct_path_when_start_equals_destination(): n = 5 m = 5 obstacles = [(2, 2), (2, 3), (3, 2)] start = (1, 1) destination = (1, 1) assert is_path_exist(n, m, obstacles, start, destination) == \\"yes\\"","solution":"def is_path_exist(n, m, obstacles, start, destination): from collections import deque # Convert obstacles list into a set for faster lookup obstacle_set = set(obstacles) sx, sy = start dx, dy = destination # If starting or destination point is an obstacle, path doesn't exist if (sx, sy) in obstacle_set or (dx, dy) in obstacle_set: return \\"no\\" # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Using Breadth-First Search (BFS) queue = deque([(sx, sy)]) visited = set([(sx, sy)]) while queue: x, y = queue.popleft() if (x, y) == (dx, dy): return \\"yes\\" for direction in directions: nx, ny = x + direction[0], y + direction[1] if 1 <= nx <= n and 1 <= ny <= m and (nx, ny) not in obstacle_set and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"no\\""},{"question":"def compute_min_teleportation_costs(n: int, m: int, roads: List[Tuple[int, int, int]]) -> List[List[int]]: Compute the minimum cost of teleportation from each location to every other location. Args: n (int): The number of locations. m (int): The number of one-way roads. roads (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers u, v, w representing a one-way road from location u to location v with cost w. Returns: List[List[int]]: A 2D list where the i-th row and j-th column represents the minimum cost of teleportation from location i+1 to location j+1. pass def format_teleportation_costs(dist: List[List[int]]) -> str: Format the teleportation costs for output. Args: dist (List[List[int]]): A 2D list of integers representing the minimum costs. Returns: str: A string representation of the costs formatted for output. pass from solution import compute_min_teleportation_costs, format_teleportation_costs def test_teleportation_example_1(): n, m = 4, 4 roads = [ (1, 2, 5), (2, 3, 10), (3, 4, 1), (1, 4, 100) ] result = compute_min_teleportation_costs(n, m, roads) expected = [ [0, 5, 15, 16], [-1, 0, 10, 11], [-1, -1, 0, 1], [-1, -1, -1, 0] ] assert result == expected def test_teleportation_example_2(): n, m = 3, 3 roads = [ (1, 2, 2), (2, 3, 3), (1, 3, 6) ] result = compute_min_teleportation_costs(n, m, roads) expected = [ [0, 2, 5], [-1, 0, 3], [-1, -1, 0] ] assert result == expected def test_format_teleportation_costs_example_1(): costs = [ [0, 5, 15, 16], [-1, 0, 10, 11], [-1, -1, 0, 1], [-1, -1, -1, 0] ] result = format_teleportation_costs(costs) expected = ( \\"0 5 15 16n\\" \\"-1 0 10 11n\\" \\"-1 -1 0 1n\\" \\"-1 -1 -1 0\\" ) assert result == expected def test_format_teleportation_costs_example_2(): costs = [ [0, 2, 5], [-1, 0, 3], [-1 -1 0] ] result = format_teleportation_costs(costs) expected = ( \\"0 2 5n\\" \\"-1 0 3n\\" \\"-1 -1 0\\" ) assert result == expected","solution":"def compute_min_teleportation_costs(n, m, roads): # Initialize the distance matrix inf = float('inf') dist = [[inf] * n for _ in range(n)] # Distance to self is zero for i in range(n): dist[i][i] = 0 # Read the roads and fill the matrix for u, v, w in roads: dist[u-1][v-1] = w # Floyd-Warshall algorithm for k in range(n): for i in range(n): for j in range(n): if dist[i][k] < inf and dist[k][j] < inf: dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) # Replace 'inf' with -1 to indicate no path for i in range(n): for j in range(n): if dist[i][j] == inf: dist[i][j] = -1 return dist def format_teleportation_costs(dist): return 'n'.join(' '.join(map(str, row)) for row in dist)"},{"question":"def can_reservations_be_made(r: int, s: int, reservations: List[Tuple[int, int, int]]) -> str: Determines if all the seat reservations can be made without any conflict. Parameters: r (int): Number of rows. s (int): Number of seats per row. reservations (list): List of tuples, each denoting a reservation in the format (row, start_seat, end_seat). Returns: str: \\"YES\\" if all reservations can be made without any conflict, otherwise \\"NO\\". >>> can_reservations_be_made(2, 5, [(1, 1, 3), (1, 4, 5), (2, 2, 4)]) \\"YES\\" >>> can_reservations_be_made(3, 10, [(1, 2, 5), (1, 4, 6), (2, 1, 3), (3, 5, 8)]) \\"NO\\" pass # Unit Tests import pytest def test_no_conflict(): r = 2 s = 5 reservations = [(1, 1, 3), (1, 4, 5), (2, 2, 4)] assert can_reservations_be_made(r, s, reservations) == \\"YES\\" def test_conflict_on_same_row(): r = 3 s = 10 reservations = [(1, 2, 5), (1, 4, 6), (2, 1, 3), (3, 5, 8)] assert can_reservations_be_made(r, s, reservations) == \\"NO\\" def test_conflict_on_different_row(): r = 3 s = 10 reservations = [(1, 2, 3), (2, 4, 6), (1, 3, 5)] assert can_reservations_be_made(r, s, reservations) == \\"NO\\" def test_no_conflict_large(): r = 10 s = 50 reservations = [ (1, 1, 5), (2, 5, 10), (3, 1, 20), (4, 21, 25), (5, 10, 15), (6, 16, 20) ] assert can_reservations_be_made(r, s, reservations) == \\"YES\\" def test_single_reservation(): r = 1 s = 1 reservations = [(1, 1, 1)] assert can_reservations_be_made(r, s, reservations) == \\"YES\\"","solution":"def can_reservations_be_made(r, s, reservations): Determines if all the seat reservations can be made without any conflict. Parameters: r (int): Number of rows. s (int): Number of seats per row. reservations (list): List of tuples, each denoting a reservation in the format (row, start_seat, end_seat). Returns: str: \\"YES\\" if all reservations can be made without any conflict, otherwise \\"NO\\". # Initialize an empty list of sets for each row to keep track of booked seats booked_seats = [set() for _ in range(r)] for reservation in reservations: row, start_seat, end_seat = reservation row_index = row - 1 # Check for conflict in the current row for seat in range(start_seat, end_seat + 1): if seat in booked_seats[row_index]: return \\"NO\\" booked_seats[row_index].add(seat) return \\"YES\\""},{"question":"def can_transform(t: int, test_cases: list) -> list: Determine if Alice can transform string A into string B by performing exactly one or zero operations (reversing a contiguous substring). Args: t (int): The number of test cases. test_cases (list): A list of tuples, where each tuple contains: - n (int): The length of strings A and B. - A (str): The first canvas (string). - B (str): The second canvas (string). Returns: list: A list of strings, either \\"YES\\" or \\"NO\\" for each test case. >>> can_transform(4, [(3, \\"abc\\", \\"bca\\"), (4, \\"abcd\\", \\"dcba\\"), (5, \\"abcde\\", \\"abced\\"), (3, \\"xyz\\", \\"xyz\\")]) [\\"NO\\", \\"YES\\", \\"YES\\", \\"YES\\"] >>> can_transform(2, [(5, \\"abcde\\", \\"edcba\\"), (6, \\"abcdef\\", \\"abcdef\\")]) [\\"YES\\", \\"YES\\"] pass # Unit tests def test_case_1(): t = 4 test_cases = [ (3, \\"abc\\", \\"bca\\"), (4, \\"abcd\\", \\"dcba\\"), (5, \\"abcde\\", \\"abced\\"), (3, \\"xyz\\", \\"xyz\\") ] assert can_transform(t, test_cases) == [\\"NO\\", \\"YES\\", \\"YES\\", \\"YES\\"] def test_case_2(): t = 2 test_cases = [ (5, \\"abcde\\", \\"edcba\\"), (6, \\"abcdef\\", \\"abcdef\\") ] assert can_transform(t, test_cases) == [\\"YES\\", \\"YES\\"] def test_case_3(): t = 1 test_cases = [ (5, \\"aaaaa\\", \\"aaaaa\\") ] assert can_transform(t, test_cases) == [\\"YES\\"] def test_case_4(): t = 3 test_cases = [ (6, \\"abcdef\\", \\"abcfed\\"), (3, \\"aab\\", \\"aba\\"), (4, \\"abcd\\", \\"abdc\\") ] assert can_transform(t, test_cases) == [\\"YES\\", \\"YES\\", \\"YES\\"] def test_case_5(): t = 2 test_cases = [ (2, \\"ab\\", \\"ba\\"), (3, \\"abc\\", \\"cab\\") ] assert can_transform(t, test_cases) == [\\"YES\\", \\"NO\\"] def test_case_6(): t = 3 test_cases = [ (100000, \\"a\\" * 100000, \\"a\\" * 100000), (2, \\"ab\\", \\"ab\\"), (3, \\"cba\\", \\"abc\\") ] assert can_transform(t, test_cases) == [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_transform(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] A = test_cases[i][1] B = test_cases[i][2] if A == B: results.append(\\"YES\\") continue # Look for a segment in A that can be reversed to match B can_transform = False for j in range(n): for k in range(j, n): reversed_segment = A[:j] + A[j:k+1][::-1] + A[k+1:] if reversed_segment == B: can_transform = True break if can_transform: break if can_transform: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def arrange_floats(N: int) -> List[int]: Returns a sequence of N integers such that sums of all contiguous subarrays are unique. >>> arrange_floats(1) [1] >>> arrange_floats(3) [1, 2, 4] >>> arrange_floats(5) [1, 2, 4, 8, 16] >>> arrange_floats(10) [1, 2, 4, 8, 16, 32, 64, 128, 256, 512] >>> arrange_floats(100) [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648, 4294967296, 8589934592, 17179869184, 34359738368, 68719476736, 137438953472, 274877906944, 549755813888, 1099511627776, 2199023255552, 4398046511104, 8796093022208, 17592186044416, 35184372088832, 70368744177664, 140737488355328, 281474976710656, 562949953421312, 1125899906842624, 2251799813685248, 4503599627370496, 9007199254740992, 18014398509481984, 36028797018963968, 72057594037927936, 144115188075855872, 288230376151711744, 576460752303423488, 1152921504606846976, 2305843009213693952, 4611686018427387904, 9223372036854775808, 18446744073709551616, 36893488147419103232, 73786976294838206464, 147573952589676412928, 295147905179352825856, 590295810358705651712, 1180591620717411303424, 2361183241434822606848, 4722366482869645213696, 9444732965739290427392, 18889465931478580854784, 37778931862957161709568, 75557863725914323419136, 151115727451828646838272, 302231454903657293676544, 604462909807314587353088, 1208925819614629174706176, 2417851639229258349412352, 4835703278458516698824704, 9671406556917033397649408, 19342813113834066795298816, 38685626227668133590597632, 77371252455336267181195264, 154742504910672534362390528, 309485009821345068724781056, 618970019642690137449562112, 1237940039285380274899124224, 2475880078570760549798248448, 4951760157141521099596496896, 9903520314283042199192993792, 19807040628566084398385987584, 39614081257132168796771975168, 79228162514264337593543950336, 158456325028528675187087900672, 316912650057057350374175801344, 633825300114114700748351602688]","solution":"def arrange_floats(N): Returns a sequence of N integers such that sums of all contiguous subarrays are unique. A simple sequence that ensures unique sums is to use consecutive powers of 2. result = [] current_power = 1 for _ in range(N): result.append(current_power) current_power *= 2 return result"},{"question":"from typing import List, Tuple def is_prime(n: int) -> bool: if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True def find_primes(numbers: List[int]) -> Tuple[List[int], int]: Create a function that takes a single list of integers as input and returns a new list containing only the prime numbers from the original list. The function should also return the count of prime numbers found. >>> find_primes([-5, 0, 2, 3, 4, 5, 10, 11, 13, 16, 17]) ([2, 3, 5, 11, 13, 17], 6) >>> find_primes([-5, 0, 1, 4, 6, 8, 10]) ([], 0) >>> find_primes([2, 3, 5, 7, 11, 13]) ([2, 3, 5, 7, 11, 13], 6) >>> find_primes([9973, 99991, 99989, 100003]) ([9973, 99991, 99989, 100003], 4)","solution":"def is_prime(n): if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True def find_primes(numbers): Returns a tuple containing a list of prime numbers found in the input list and the count of prime numbers. primes = [num for num in numbers if is_prime(num)] return primes, len(primes)"},{"question":"def remove_consecutive_duplicates(lst): Given a list of integers, removes any sequences of consecutive duplicate elements, retaining only one instance of each group of consecutive duplicates. Parameters: lst (list): A list of integers. Returns: list: A modified list that retains only one instance of each group of consecutive duplicates. >>> remove_consecutive_duplicates([1, 1, 2, 2, 3, 3, 3, 4]) [1, 2, 3, 4] >>> remove_consecutive_duplicates([1, 2, 3, 4]) [1, 2, 3, 4] >>> remove_consecutive_duplicates([5, 5, 5, 5, 5]) [5] >>> remove_consecutive_duplicates([]) [] >>> remove_consecutive_duplicates([7]) [7] >>> remove_consecutive_duplicates([1, 1, 2, 3, 3, 4, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_consecutive_duplicates([1, 2, 1, 2, 1, 2]) [1, 2, 1, 2, 1, 2]","solution":"def remove_consecutive_duplicates(lst): Given a list of integers, removes any sequences of consecutive duplicate elements, retaining only one instance of each group of consecutive duplicates. Parameters: lst (list): A list of integers. Returns: list: A modified list that retains only one instance of each group of consecutive duplicates. if not lst: return [] result = [lst[0]] for i in range(1, len(lst)): if lst[i] != lst[i - 1]: result.append(lst[i]) return result"},{"question":"def subsets_with_duplicates(nums: List[int]) -> List[List[int]]: Returns a list of unique subsets for a given list of integers. Subsets are in non-descending order and duplicates are not included. >>> subsets_with_duplicates([]) == [[]] >>> subsets_with_duplicates([1]) == [[], [1]] >>> subsets_with_duplicates([1, 2]) == [[], [1], [1, 2], [2]] >>> subsets_with_duplicates([1, 2, 2]) == [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]] >>> subsets_with_duplicates([1, 1, 2, 2]) == [[], [1], [1, 1], [1, 1, 2], [1, 1, 2, 2], [1, 2], [1, 2, 2], [2], [2, 2]] >>> subsets_with_duplicates([4, 1, 0]) == [[], [0], [0, 1], [0, 1, 4], [0, 4], [1], [1, 4], [4]]","solution":"def subsets_with_duplicates(nums): Returns a list of unique subsets for a given list of integers. Subsets are in non-descending order. def backtrack(start, path): result.append(path.copy()) for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue path.append(nums[i]) backtrack(i + 1, path) path.pop() nums.sort() result = [] backtrack(0, []) return result"},{"question":"def find_missing_positive(nums: List[int]) -> int: Find the smallest positive integer that is missing from an unsorted array of integers. >>> find_missing_positive([3, 4, -1, 1]) 2 >>> find_missing_positive([1, 2, 0]) 3 >>> find_missing_positive([7, 8, 9, 11, 12]) 1 >>> find_missing_positive([1, 2, 3]) 4 >>> find_missing_positive([0, -1, -2]) 1 >>> find_missing_positive([2, 3, 4, -1, 1]) 5 >>> find_missing_positive([]) 1 >>> find_missing_positive([-1]) 1 >>> find_missing_positive([1]) 2 >>> find_missing_positive([0]) 1","solution":"def find_missing_positive(nums): Returns the smallest positive integer that is missing from the unsorted array. n = len(nums) # Step 1: Replace non-positive numbers and numbers greater than n with n + 1 for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Step 2: Use the index as a hash to record the presence of numbers for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # Step 3: Identify the first positive number's index for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"from typing import List def find_unique_common_elements(list1: List[int], list2: List[int]) -> List[int]: Given two lists of integers, returns a new list containing only the unique numbers that are present in both lists. The order of the elements in the resulting list does not matter. Do not use any built-in set operations to solve the problem. >>> sorted(find_unique_common_elements([1, 2, 3, 4, 5], [4, 5, 6, 7, 8])) == [4, 5] True >>> sorted(find_unique_common_elements([1, 2, 3, 4, 4], [4, 5, 6, 7, 7])) == [] True >>> sorted(find_unique_common_elements([10, 20, 30, 40], [20, 30, 50, 60])) == [20, 30] True >>> sorted(find_unique_common_elements([1, 2, 3], [4, 5, 6])) == [] True >>> sorted(find_unique_common_elements([1, 1, 2, 3, 4], [4, 4, 5])) == [] True","solution":"def find_unique_common_elements(list1, list2): Returns a list containing only the unique numbers that are present in both lists. The order of the elements in the resulting list does not matter. unique_in_list1 = {} unique_in_list2 = {} # Collect unique elements in list1 for number in list1: if number in unique_in_list1: unique_in_list1[number] += 1 else: unique_in_list1[number] = 1 # Collect unique elements in list2 for number in list2: if number in unique_in_list2: unique_in_list2[number] += 1 else: unique_in_list2[number] = 1 # Find common unique elements common_elements = [] for number in unique_in_list1: if number in unique_in_list2 and unique_in_list1[number] == 1 and unique_in_list2[number] == 1: common_elements.append(number) return common_elements"},{"question":"from typing import List def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. pass def sum_of_primes(input_array: List[int]) -> int: Returns the sum of all prime numbers in the input_array. Example: >>> sum_of_primes([10, 15, 3, 7, 19, 21, 29]) 58 >>> sum_of_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 17 >>> sum_of_primes([0, 1, 4, 6, 8, 10]) 0 pass","solution":"from typing import List def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. if n <= 1: return False for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return False return True def sum_of_primes(input_array: List[int]) -> int: Returns the sum of all prime numbers in the input_array. return sum(x for x in input_array if is_prime(x))"},{"question":"def reverse_string(s: str) -> str: Reverse a string without using built-in functions in Python. This function accepts a string and returns its reverse. >>> reverse_string(\\"hello\\") == \\"olleh\\" >>> reverse_string(\\"world!\\") == \\"!dlrow\\" >>> reverse_string(\\"\\") == \\"\\" >>> reverse_string(\\"a\\") == \\"a\\" >>> reverse_string(\\"madam\\") == \\"madam\\"","solution":"def reverse_string(s): Returns the reverse of the input string s without using built-in functions. reversed_str = '' for char in s: reversed_str = char + reversed_str return reversed_str"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestUnivaluePath(root: TreeNode) -> int: Determines the longest path in which each node's value is the same as its parent's value. :param root: TreeNode - The root of the binary tree :return: int - The length of the longest path with the same value >>> root = TreeNode(1) >>> root.left = TreeNode(4) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(4) >>> root.right.right = TreeNode(5) >>> longestUnivaluePath(root) 2 >>> root = TreeNode(1) >>> longestUnivaluePath(root) 0 >>> root = TreeNode(1) >>> root.left = TreeNode(1) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(1) >>> root.right.right = TreeNode(1) >>> longestUnivaluePath(root) 4 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> longestUnivaluePath(root) 0 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(1) >>> root.right.right = TreeNode(1) >>> root.right.left = TreeNode(1) >>> root.right.left.left = TreeNode(1) >>> root.right.left.left.left = TreeNode(1) >>> longestUnivaluePath(root) 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestUnivaluePath(root): Determines the longest path in which each node's value is the same as its parent's value. def dfs(node): nonlocal max_path if not node: return 0 left = dfs(node.left) right = dfs(node.right) left_path = right_path = 0 if node.left and node.left.val == node.val: left_path = left + 1 if node.right and node.right.val == node.val: right_path = right + 1 max_path = max(max_path, left_path + right_path) return max(left_path, right_path) max_path = 0 dfs(root) return max_path"},{"question":"def array_element_multiplication(numbers: List[int], queries: List[List[int]]) -> List[int]: Multiplies elements within subarrays of \`numbers\` as defined by \`queries\`. Each query consists of three integers: \`l\`, \`r\`, and \`m\`, which dictate that each element in the subarray from index \`l\` to index \`r\` (inclusive) should be multiplied by \`m\`. :param numbers: List of integers. :param queries: List of queries, where each query is a list of three integers [l, r, m]. :return: Modified numbers list after performing all the queries. >>> array_element_multiplication([1, 2, 3, 4, 5], [[1, 3, 2], [0, 2, 3]]) [3, 12, 18, 8, 5] >>> array_element_multiplication([10, 20, 30], [[0, 1, 5], [1, 2, 2]]) [50, 200, 60]","solution":"def array_element_multiplication(numbers, queries): Multiplies elements within subarrays of \`numbers\` as defined by \`queries\`. :param numbers: List of integers. :param queries: List of queries, where each query is a list of three integers [l, r, m]. :return: Modified numbers list after performing all the queries. for l, r, m in queries: for i in range(l, r + 1): numbers[i] *= m return numbers"},{"question":"def shift_characters(s: str) -> str: Takes a string as input and returns a new string where each character is replaced by the next character in the ASCII sequence. The function should preserve the case of the characters and maintain any non-alphabetical characters unchanged. >>> shift_characters(\\"abc\\") == \\"bcd\\" >>> shift_characters(\\"ABC\\") == \\"BCD\\" >>> shift_characters(\\"aBc\\") == \\"bCd\\" >>> shift_characters(\\"aBc1\\") == \\"bCd1\\" >>> shift_characters(\\"hello!\\") == \\"ifmmp!\\" >>> shift_characters(\\"\\") == \\"\\" >>> shift_characters(\\"1234\\") == \\"1234\\"","solution":"def shift_characters(s): Takes a string as input and returns a new string where each character is replaced by the next character in the ASCII sequence. shifted_string = \\"\\" for char in s: shifted_string += chr(ord(char) + 1) if char.isalpha() else char return shifted_string"},{"question":"def diagonal_difference(matrix: List[List[int]]) -> int: Calculate the difference between the sum of the main diagonal and the sum of the secondary diagonal of a given square matrix. Args: matrix (list of list of int): The square matrix of integers. Returns: int: The absolute difference between the two diagonal sums. Example: >>> diagonal_difference([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 0 >>> diagonal_difference([[11, 2, 4], [4, 5, 6], [10, 8, -12]]) 15","solution":"def diagonal_difference(matrix): Returns the absolute difference between the sum of the main diagonal and the sum of the secondary diagonal of a square matrix. Args: matrix (list of list of int): The square matrix of integers. Returns: int: The absolute difference between the two diagonal sums. n = len(matrix) main_diagonal_sum = sum(matrix[i][i] for i in range(n)) secondary_diagonal_sum = sum(matrix[i][n-1-i] for i in range(n)) return abs(main_diagonal_sum - secondary_diagonal_sum)"},{"question":"def custom_sort(lst): This function sorts a list of strings based on length in descending order. If multiple strings have the same length, it then sorts those strings lexicographically. Args: lst: A list of strings Returns: A list of strings sorted first by length (from longest to shortest), then by lexicographical order when lengths are the same. Expectations from this function would include: >>> custom_sort([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"egg\\", \\"fig\\", \\"grape\\"]) == ['banana', 'cherry', 'apple', 'grape', 'date', 'egg', 'fig'] >>> custom_sort([\\"a\\", \\"abc\\", \\"ab\\", \\"abcd\\", \\"\\"]) == ['abcd', 'abc', 'ab', 'a', ''] >>> custom_sort([\\"xyz\\", \\"xy\\", \\"z\\", \\"w\\"]) == ['xyz', 'xy', 'w', 'z'] pass","solution":"def custom_sort(lst): This function sorts a list of strings based on length in descending order. If multiple strings have the same length, it then sorts those strings lexicographically. Args: lst: A list of strings Returns: A list of strings sorted first by length (from longest to shortest), then by lexicographical order when lengths are the same. return sorted(lst, key=lambda x: (-len(x), x))"},{"question":"def caesar_cipher(input_string: str, shift: int) -> str: Encodes a given string using the Caesar cipher. :param input_string: str, the string to be encoded. :param shift: int, the number of positions each character should be shifted (1 to 25). :return: str, the encoded string. >>> caesar_cipher(\\"abc\\", 1) == \\"bcd\\" >>> caesar_cipher(\\"xyz\\", 2) == \\"zab\\" >>> caesar_cipher(\\"hello, world!\\", 3) == \\"khoor, zruog!\\" >>> caesar_cipher(\\"defend the east wall of the castle!\\", 1) == \\"efgfoe uif fbtu xbmm pg uif dbtumf!\\" >>> caesar_cipher(\\"ABC\\", 2) == \\"CDE\\" >>> caesar_cipher(\\"XYZ\\", 4) == \\"BCD\\" >>> caesar_cipher(\\"Python\\", 5) == \\"Udymts\\" >>> caesar_cipher(\\"CaEsAr\\", 3) == \\"FdHvDu\\"","solution":"def caesar_cipher(input_string, shift): Encodes a given string using the Caesar cipher. :param input_string: str, the string to be encoded. :param shift: int, the number of positions each character should be shifted (1 to 25). :return: str, the encoded string. if not input_string: raise ValueError(\\"Input string must not be empty.\\") if not isinstance(shift, int) or not (1 <= shift <= 25): raise ValueError(\\"Shift must be an integer between 1 and 25.\\") encoded_string = [] for char in input_string: if char.isalpha(): shift_base = ord('A') if char.isupper() else ord('a') encoded_char = chr((ord(char) - shift_base + shift) % 26 + shift_base) encoded_string.append(encoded_char) else: encoded_string.append(char) # Keep non-alphabetic characters unchanged return ''.join(encoded_string)"},{"question":"def remove_vowels(input_string: str) -> str: Accepts a string and returns a new string with all the vowels removed. >>> remove_vowels(\\"Hello World!\\") \\"Hll Wrld!\\" >>> remove_vowels(\\"AEIOUaeiou\\") \\"\\" >>> remove_vowels(\\"Python Programming\\") \\"Pythn Prgrmmng\\" pass class StringProcessor: def __init__(self, text: str): self.text = text def process(self): Demonstrates the usage of the remove_vowels function. Output: Original string: Hello World! String without vowels: Hll Wrld! pass # Example usage processor = StringProcessor(\\"Hello World!\\") processor.process()","solution":"def remove_vowels(input_string): Accepts a string and returns a new string with all the vowels removed. vowels = \\"aeiouAEIOU\\" return ''.join([char for char in input_string if char not in vowels]) class StringProcessor: def __init__(self, text): self.text = text def process(self): processed_text = remove_vowels(self.text) print(\\"Original string:\\", self.text) print(\\"String without vowels:\\", processed_text) # Example usage processor = StringProcessor(\\"Hello World!\\") processor.process()"},{"question":"def max_profit(prices): Calculate the maximum profit possible by buying and selling one share of stock. :param prices: List of integers representing stock prices in chronological order. :return: Maximum profit attainable, or 0 if no profit is possible. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([5, 5, 5, 5]) == 0 >>> max_profit([10]) == 0 >>> max_profit([1, 5]) == 4 >>> max_profit([5, 1]) == 0 >>> max_profit([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 9 >>> max_profit([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 0","solution":"def max_profit(prices): Calculate the maximum profit possible by buying and selling one share of stock. :param prices: List of integers representing stock prices in chronological order. :return: Maximum profit attainable, or 0 if no profit is possible. if len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: profit = price - min_price if profit > max_profit: max_profit = profit if price < min_price: min_price = price return max_profit # Explanation: # We initialize the minimum price to the first price and maximum profit to 0. # We then iterate through the list of prices starting from the second element. # For each price, we calculate the potential profit by subtracting the minimum price seen so far from the current price. # If this profit is greater than the maximum profit seen so far, we update the maximum profit. # We also update the minimum price if the current price is lower than the minimum price seen so far. # This approach ensures we are scanning through the list only once, resulting in a time complexity of O(n)."},{"question":"def is_prime(n: int) -> bool: Determines if a given number is a prime number. pass def sum_of_digits(n: int) -> int: Returns the sum of the digits of a given number. pass def prime_digit_sum(lst: List[int]) -> Dict[int, int]: Returns a dictionary where the keys are prime numbers from the input list and the values are the sum of the digits of those prime numbers. >>> prime_digit_sum([2, 3, 5, 7, 11, 13, 17]) == {2: 2, 3: 3, 5: 5, 7: 7, 11: 2, 13: 4, 17: 8} >>> prime_digit_sum([4, 6, 8, 9, 10, 11, 13]) == {11: 2, 13: 4} >>> prime_digit_sum([1, 4, 6, 8, 9, 10]) == {} >>> prime_digit_sum([29]) == {29: 11} >>> prime_digit_sum([]) == {} pass","solution":"def is_prime(n): if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def sum_of_digits(n): return sum(int(digit) for digit in str(n)) def prime_digit_sum(lst): Returns a dictionary where the keys are prime numbers from the input list and the values are the sum of the digits of those prime numbers. result = {} for num in lst: if is_prime(num): result[num] = sum_of_digits(num) return result"},{"question":"from typing import List, Tuple def reverse_and_remove_palindromes(words: List[str]) -> Tuple[List[str], List[str]]: Reverse each string in the list without changing the order of strings. Remove palindromes from the list and keep track of them in a separate list. Return a tuple with the first element being the list of reversed, non-palindromic strings, and the second element being the list of removed palindromes, preserving their original order. >>> reverse_and_remove_palindromes([\\"racecar\\", \\"hello\\", \\"madam\\", \\"world\\"]) ([\\"olleh\\", \\"dlrow\\"], [\\"racecar\\", \\"madam\\"])","solution":"from typing import List, Tuple def reverse_and_remove_palindromes(words: List[str]) -> Tuple[List[str], List[str]]: Reverse each string in the list without changing the order of strings. Remove palindromes from the list and keep track of them in a separate list. Return a tuple with the first element being the list of reversed, non-palindromic strings, and the second element being the list of removed palindromes, preserving their original order. reversed_non_palindromic_words = [] removed_palindromes = [] for word in words: if word == word[::-1]: removed_palindromes.append(word) else: reversed_non_palindromic_words.append(word[::-1]) return (reversed_non_palindromic_words, removed_palindromes)"},{"question":"def rearrange_even_before_odd(lst: List[int]) -> List[int]: Rearrange the list so that all even numbers appear before all the odd numbers, preserving the relative order of both even and odd numbers as they appear originally in the list. >>> rearrange_even_before_odd([2, 4, 6]) [2, 4, 6] >>> rearrange_even_before_odd([1, 3, 5]) [1, 3, 5] >>> rearrange_even_before_odd([1, 2, 3, 4, 5, 6]) [2, 4, 6, 1, 3, 5] >>> rearrange_even_before_odd([4, 2, 1, 3]) [4, 2, 1, 3] >>> rearrange_even_before_odd([1, 3, 2, 4]) [2, 4, 1, 3] >>> rearrange_even_before_odd([]) [] >>> rearrange_even_before_odd([4]) [4] >>> rearrange_even_before_odd([3]) [3] >>> rearrange_even_before_odd([2, 1]) [2, 1] >>> rearrange_even_before_odd([1, 2]) [2, 1]","solution":"def rearrange_even_before_odd(lst): Rearranges the list so that all even numbers appear before all the odd numbers, preserving the relative order of both even and odd numbers. Parameters: lst (list): List of integers. Returns: list: The rearranged list. if not lst: return lst next_even_index = 0 for i in range(len(lst)): if lst[i] % 2 == 0: value_to_move = lst.pop(i) lst.insert(next_even_index, value_to_move) next_even_index += 1 return lst"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Write a function that takes an integer array and an integer target, and returns the indices of the two numbers in the array such that they add up to the target. If no such two numbers exist, return an empty list. Consider the array to have exactly one solution and do not use the same element twice. The function should have a time complexity of O(n). >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([1, 3, 4, 2], 3) [0, 3] >>> two_sum([-1, -2, -3, -4, -5], -8) [2, 4] >>> two_sum([1, 2, 3], 7) [] >>> two_sum([1, 2, 3, 4, 5, 6, 7, 8], 15) [6, 7]","solution":"def two_sum(nums, target): Returns the indices of the two numbers in the nums array that add up to the target. If no such numbers exist, return an empty list. :param nums: List[int], the list of integers :param target: int, the target sum :return: List[int], the list containing the indices of the two numbers that add up to the target lookup = {} for i, num in enumerate(nums): complement = target - num if complement in lookup: return [lookup[complement], i] lookup[num] = i return []"},{"question":"def rearrange_list(nums): Re-arranges the list so that all negative integers appear before all positive integers, while maintaining the relative order of the negative integers and positive integers. Modifies the original list in-place. >>> nums = [1, -2, 3, -4, 5] >>> rearrange_list(nums) >>> nums [-2, -4, 1, 3, 5] >>> nums = [-1, 2, -3, 4, -5] >>> rearrange_list(nums) >>> nums [-1, -3, -5, 2, 4]","solution":"def rearrange_list(nums): Re-arranges the list so that all negative integers appear before all positive integers, while maintaining the relative order of the negative integers and positive integers. Modifies the original list in-place. neg = [x for x in nums if x < 0] pos = [x for x in nums if x >= 0] nums[:] = neg + pos"},{"question":"def largest_prime_factors(lst): Write a Python function that takes as input a list of integers and returns a list of the largest prime factor of each integer. If an integer is prime or less than 2, return the integer itself. >>> largest_prime_factors([10, 15, 3, 1, 28]) [5, 5, 3, 1, 7] >>> largest_prime_factors([2, 3, 5, 7, 11, 13]) [2, 3, 5, 7, 11, 13] >>> largest_prime_factors([]) [] >>> largest_prime_factors([0, 1, -1, -10]) [0, 1, -1, -10] >>> largest_prime_factors([2, 10, 1, 7, 8, 9]) [2, 5, 1, 7, 2, 3]","solution":"def largest_prime_factor(n): if n <= 1: return n i = 2 while i * i <= n: if n % i: i += 1 else: n //= i return n def largest_prime_factors(lst): return [largest_prime_factor(n) for n in lst]"},{"question":"def filter_greater_than(lst, n): Returns a new list containing all integers from the original list that are greater than \`n\`. Parameters: lst (list): A list of integers. n (int): An integer to compare the elements of the list with. Returns: list: A list of integers greater than \`n\`. Example usage: >>> filter_greater_than([7, 4, 12, 1, 9, 3], 5) [7, 12, 9] >>> filter_greater_than([1, 2, 3], 5) [] >>> filter_greater_than([10, 15, 20], 5) [10, 15, 20] >>> filter_greater_than([5, 6, 7], 5) [6, 7]","solution":"def filter_greater_than(lst, n): Returns a new list containing all integers from the original list that are greater than \`n\`. Parameters: lst (list): A list of integers. n (int): An integer to compare the elements of the list with. Returns: list: A list of integers greater than \`n\`. return [x for x in lst if x > n] # Example usage: # lst = [7, 4, 12, 1, 9, 3] # n = 5 # filter_greater_than(lst, n) should return [7, 12, 9]"},{"question":"def total_discounted_price(prices: List[int]) -> int: Calculate the total cost of all books with a 20% discount, rounded to the nearest integer. Args: prices (list of int): List of book prices Returns: int: Total cost rounded to the nearest integer >>> total_discounted_price([100, 200, 150]) 360 >>> total_discounted_price([50, 50, 50]) 120 >>> total_discounted_price([0, 100, 200]) 240 >>> total_discounted_price([100, 0, 200]) 240 >>> total_discounted_price([0, 0, 0]) 0 >>> total_discounted_price([100]) 80 >>> total_discounted_price([50]) 40 >>> total_discounted_price([379]) 303 >>> total_discounted_price([]) 0 >>> total_discounted_price([1000, 2000]) 2400 >>> total_discounted_price([10000, 5000, 2500]) 14000","solution":"def total_discounted_price(prices): Calculate the total cost of all books with a 20% discount, rounded to the nearest integer. Args: prices (list of int): List of book prices Returns: int: Total cost rounded to the nearest integer total = 0 for price in prices: discounted_price = price * 0.8 total += discounted_price return round(total)"},{"question":"from typing import List def longest_consecutive_sequence(nums: List[int]) -> int: Write a Python function that reads a list of integers and determines the longest sequence of consecutive integers present in the list. Ensure that the function can handle an unsorted list and accounts for potential edge cases such as an empty list or all elements being the same. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([0, 2, 2, 1, 1]) 3 >>> longest_consecutive_sequence([]) 0 def test_longest_consecutive_sequence(): assert longest_consecutive_sequence([]) == 0 assert longest_consecutive_sequence([1]) == 1 assert longest_consecutive_sequence([10, 5, 15]) == 1 assert longest_consecutive_sequence([1, 2, 2, 3, 3, 4]) == 4 assert longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) == 4 assert longest_consecutive_sequence([0, 2, 2, 1, 1]) == 3 assert longest_consecutive_sequence([-1, -2, -3, -4, -5]) == 5 assert longest_consecutive_sequence([-2, -1, 0, 1, 2]) == 5 assert longest_consecutive_sequence([10, 50, 100]) == 1 assert longest_consecutive_sequence(list(range(10000))) == 10000","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive sequence of integers in the list. if not nums: return 0 nums = set(nums) longest_streak = 0 for num in nums: if num - 1 not in nums: # only start counting if \`num\` is the start of a sequence current_num = num current_streak = 1 while current_num + 1 in nums: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def is_palindrome(number: int) -> bool: Determines whether a non-negative integer is a palindrome without converting it to a string. >>> is_palindrome(12321) == True >>> is_palindrome(123) == False >>> is_palindrome(0) == True >>> is_palindrome(1) == True >>> is_palindrome(1221) == True >>> is_palindrome(123456789987654321) == True >>> is_palindrome(123456789876543210) == False","solution":"def is_palindrome(number: int) -> bool: Determines whether a non-negative integer is a palindrome without converting it to a string. if number < 0: return False if number < 10: return True # Calculate the reverse of the number original = number reversed_number = 0 while number > 0: reversed_number = reversed_number * 10 + number % 10 number //= 10 return original == reversed_number"},{"question":"def classify_numbers(numbers): Classifies numbers into odd and even. :param numbers: List of integers. :return: Dictionary with keys \\"odd\\" and \\"even\\" and lists of classified numbers. >>> classify_numbers([1, 2, 3, 4, 5]) {'odd': [1, 3, 5], 'even': [2, 4]} >>> classify_numbers([10, 15, 20, 25]) {'odd': [15, 25], 'even': [10, 20]} >>> classify_numbers([]) {'odd': [], 'even': []}","solution":"def classify_numbers(numbers): Classifies numbers into odd and even. :param numbers: List of integers. :return: Dictionary with keys \\"odd\\" and \\"even\\" and lists of classified numbers. result = {'odd': [], 'even': []} for num in numbers: if num % 2 == 0: result['even'].append(num) else: result['odd'].append(num) return result"},{"question":"def LongestConsecutiveSubsequence(nums: List[int]) -> int: Returns the length of the longest consecutive subsequence. >>> LongestConsecutiveSubsequence([]) 0 >>> LongestConsecutiveSubsequence([5]) 1 >>> LongestConsecutiveSubsequence([1, 9, 3, 10, 4, 20, 2]) 4 >>> LongestConsecutiveSubsequence([100, 4, 200, 1, 3, 2]) 4 >>> LongestConsecutiveSubsequence([10, 20, 30]) 1 >>> LongestConsecutiveSubsequence([1, 2, 3, 4, 5]) 5 >>> LongestConsecutiveSubsequence([5, 2, 99, 3, 4, 100, 1, 101]) 5 >>> LongestConsecutiveSubsequence([1, 2, 2, 3, 4]) 4 pass","solution":"def LongestConsecutiveSubsequence(nums): Returns the length of the longest consecutive subsequence. if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: if num - 1 not in nums_set: current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def atm_simulator(initial_balance, transactions): Simulates an ATM by processing a sequence of transactions. :param initial_balance: float, initial balance in the account :param transactions: list of tuples, where each tuple contains a transaction type ('deposit' or 'withdraw') and a transaction amount :return: float, final balance after processing all transactions >>> atm_simulator(1000, [('deposit', 200), ('withdraw', 500), ('withdraw', 800)]) 700 >>> atm_simulator(300, [('withdraw', 100), ('deposit', 50), ('withdraw', 200), ('deposit', 100)]) 150 >>> atm_simulator(300, [('withdraw', 400), ('deposit', 100)]) 400 >>> atm_simulator(300, []) 300","solution":"def atm_simulator(initial_balance, transactions): Simulates an ATM by processing a sequence of transactions. :param initial_balance: float, initial balance in the account :param transactions: list of tuples, where each tuple contains a transaction type ('deposit' or 'withdraw') and a transaction amount :return: float, final balance after processing all transactions balance = initial_balance for transaction in transactions: transaction_type, amount = transaction if transaction_type == 'deposit': balance += amount elif transaction_type == 'withdraw': if amount <= balance: balance -= amount return balance"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression involving +, -, *, /, and parentheses for precedence. Supports both integers and floating point numbers. >>> evaluate_expression(\\"2 + 3\\") == 5 >>> evaluate_expression(\\"5 - 3\\") == 2 >>> evaluate_expression(\\"4 * 3\\") == 12 >>> evaluate_expression(\\"10 / 2\\") == 5 >>> evaluate_expression(\\"5 / 2\\") == 2.5 >>> evaluate_expression(\\"2.5 + 3.1\\") == 5.6 >>> evaluate_expression(\\"(2 + 3.5) * 4 / (1.5 - 0.5)\\") == 22.0 >>> evaluate_expression(\\"1 / 0\\") # raises ValueError >>> evaluate_expression(\\"2 + * 3\\") # raises ValueError >>> evaluate_expression(\\"2 + a\\") # raises ValueError","solution":"def evaluate_expression(expression): Evaluates a mathematical expression involving +, -, *, /, and parentheses. Supports both integers and floating point numbers. try: result = eval(expression) return result except (SyntaxError, NameError, ZeroDivisionError) as e: raise ValueError(f\\"Invalid expression: {expression}\\") # Example usage # result = evaluate_expression(\\"(2 + 3.5) * 4 / (1.5 - 0.5)\\") # print(result) # Outputs: 22.0"},{"question":"def unique_sorted_by_length(strings: List[str]) -> List[str]: Returns a list of unique strings sorted by length in ascending order. If two strings have the same length, they are sorted alphabetically. >>> unique_sorted_by_length(['pear', 'apple', 'orange', 'pear', 'banana', 'grape']) ['pear', 'apple', 'grape', 'banana', 'orange'] >>> unique_sorted_by_length(['kiwi', 'melon', 'berry', 'mango']) ['kiwi', 'berry', 'mango', 'melon'] >>> unique_sorted_by_length(['a', 'bb', 'ccc', 'a', 'bb', 'dddd']) ['a', 'bb', 'ccc', 'dddd'] >>> unique_sorted_by_length(['abc', 'def', 'ghi']) ['abc', 'def', 'ghi'] >>> unique_sorted_by_length(['b', 'a', 'cc', 'bb', 'aaa', 'aa']) ['a', 'b', 'aa', 'bb', 'cc', 'aaa'] >>> unique_sorted_by_length([]) [] >>> try: ... unique_sorted_by_length(['a', 'b', 123]) ... except ValueError as e: ... assert str(e) == 'All elements in the list must be strings.'","solution":"def unique_sorted_by_length(strings): Returns a list of unique strings sorted by length in ascending order. If two strings have the same length, they are sorted alphabetically. if not all(isinstance(s, str) for s in strings): raise ValueError(\\"All elements in the list must be strings.\\") unique_strings = list(set(strings)) unique_strings.sort(key=lambda x: (len(x), x)) return unique_strings"},{"question":"def most_common_char(s: str) -> str: Returns the most common character in the string s. In case of a tie, returns the character that appears first in the string. >>> most_common_char(\\"abracadabra\\") == \\"a\\" >>> most_common_char(\\"aabbcc\\") == \\"a\\" >>> most_common_char(\\"bbbaaa\\") == \\"b\\"","solution":"def most_common_char(s): Returns the most common character in the string s. In case of a tie, returns the character that appears first in the string. from collections import Counter count = Counter(s) max_count = max(count.values()) for char in s: if count[char] == max_count: return char"},{"question":"def balance_brackets(s: str) -> bool: Checks whether the brackets in a given string are balanced. Supports '()', '{}', '[]'. Examples: >>> balance_brackets(\\"()[]{}\\") True >>> balance_brackets(\\"([{}])\\") True >>> balance_brackets(\\"([)]\\") False >>> balance_brackets(\\"{[}\\") False","solution":"def balance_brackets(s): Checks if the brackets in the given string are balanced. Parameters: s (str): The string containing brackets. Returns: bool: True if the brackets are balanced, False otherwise. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map.values(): stack.append(char) else: if not stack or bracket_map[char] != stack.pop(): return False return not stack"},{"question":"import math def find_next_square(n: int) -> int: Find the next perfect square after a given integer. >>> find_next_square(16) 25 >>> find_next_square(1) 4 >>> find_next_square(10) -1","solution":"import math def find_next_square(n): Given an integer n, returns the next perfect square if n is a perfect square. Otherwise, returns -1. if n < 0: return -1 root = math.isqrt(n) if root * root == n: return (root + 1) ** 2 else: return -1"},{"question":"def single_number(nums: List[int]) -> int: Finds the single occurrence element in a list where each element appears twice except for one. Args: nums (List[int]): The list of integers Returns: int: The single occurrence integer >>> single_number([4, 1, 2, 1, 2]) 4 >>> single_number([2, 2, 1]) 1 >>> single_number([1, 0, 1]) 0 >>> single_number([0, 1, 0, 1, 2]) 2 >>> single_number([11, 22, 22, 11, 99]) 99","solution":"def single_number(nums): Finds and returns the single occurrence element in the list where each element appears twice except for one. Args: nums: List[int] - The list of integers Returns: int - The single occurrence integer single = 0 for num in nums: single ^= num return single"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Design a function that takes a list of integers and returns a list of integers where each element at index i (0 <= i < n) of the input list is replaced by the product of all the integers in the list except the one at index i. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([10]) [1] >>> product_except_self([2, 3]) [3, 2] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_except_self([2, -3, 4, -5]) [60, -40, 30, -24]","solution":"def product_except_self(nums): Returns a list of integers where each element at index i is the product of all the integers in the input list except the one at index i. n = len(nums) result = [1] * n # Calculate prefix product for each element prefix = 1 for i in range(n): result[i] = prefix prefix *= nums[i] # Calculate suffix product and multiply with respectve prefix result suffix = 1 for i in range(n - 1, -1, -1): result[i] *= suffix suffix *= nums[i] return result"},{"question":"from typing import List, Tuple def character_frequency(s: str) -> List[Tuple[str, int]]: Write a Python function that takes a string \`s\` consisting of various characters, and returns a list of tuples, each containing a unique character from the string and its frequency in the string, sorted in descending order by frequency. If two characters have the same frequency, sort them alphabetically. Examples: >>> character_frequency(\\"abracadabra\\") [('a', 5), ('b', 2), ('r', 2), ('c', 1), ('d', 1)] >>> character_frequency(\\"abc\\") [('a', 1), ('b', 1), ('c', 1)] >>> character_frequency(\\"aaaa\\") [('a', 4)] >>> character_frequency(\\"AaBbCc\\") [('A', 1), ('B', 1), ('C', 1), ('a', 1), ('b', 1), ('c', 1)] >>> character_frequency(\\"\\") [] >>> character_frequency(\\"a1b2c3!\\") [('!', 1), ('1', 1), ('2', 1), ('3', 1), ('a', 1), ('b', 1), ('c', 1)] >>> character_frequency(\\"aabbcc\\") [('a', 2), ('b', 2), ('c', 2)]","solution":"from typing import List, Tuple def character_frequency(s: str) -> List[Tuple[str, int]]: Returns a list of tuples, each containing a unique character from the string s and its frequency, sorted in descending order by frequency. If two characters have the same frequency, sort them alphabetically. from collections import Counter # Count frequency of each character freq = Counter(s) # Sort by frequency first (descending) then alphabetically (ascending) sorted_freq = sorted(freq.items(), key=lambda x: (-x[1], x[0])) return sorted_freq"},{"question":"def intersection(lst1: List[int], lst2: List[int]) -> List[int]: Returns a new list containing the integers that are present in both input lists, maintaining the order of their first appearance in the first list. >>> intersection([1, 2, 3, 4], [3, 4, 5, 6]) == [3, 4] >>> intersection([1, 2, 3], [4, 5, 6]) == [] >> intersection([], [1, 2, 3]) == [] >> >>> intersection([1, 2, 3], []) == [] >> >>> intersection([1, 2, 2, 3, 4], [2, 4]) == [2, 2, 4] >> >>> intersection([1, 2, 3], [2, 2, 3, 3]) == [2, 3] >> >>> intersection([1, 2, 3], [3, 2, 1]) == [1, 2, 3] >> >>> intersection([3, 2, 1], [1, 2, 3]) == [3, 2, 1]","solution":"def intersection(lst1, lst2): Returns a new list containing the integers that are present in both input lists, maintaining the order of their first appearance in the first list. return [num for num in lst1 if num in lst2]"},{"question":"from typing import List, Optional from collections import Counter def second_most_frequent(lst: List[int]) -> Optional[int]: Returns the second most frequent element in the list. If there is a tie for the second most frequent element, returns any one of them. >>> second_most_frequent([4, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5]) in [3, 5] >>> second_most_frequent([1, 2, 2, 3, 3, 4, 4]) in [2, 3, 4] >>> second_most_frequent([]) is None >>> second_most_frequent([1]) is None >>> second_most_frequent([1, 1, 2]) == 2 >>> second_most_frequent([1, 2, 3, 4, 5]) == 2","solution":"from collections import Counter def second_most_frequent(lst): Returns the second most frequent element in the list. If there is a tie for the second most frequent element, returns any one of them. if not lst: return None frequency = Counter(lst) most_common = frequency.most_common() if len(most_common) < 2: return None return most_common[1][0]"},{"question":"def sort_nested_dicts(data, key): Sort a list of nested dictionaries by a specified key at any depth. Returns the sorted list. If the key is not present in any of the dictionaries, returns the original list. >>> data = [ ... {\\"level1\\": {\\"level2\\": {\\"id\\": 3, \\"value\\": \\"C\\"}}}, ... {\\"level1\\": {\\"level2\\": {\\"id\\": 1, \\"value\\": \\"A\\"}}}, ... {\\"level1\\": {\\"level2\\": {\\"id\\": 2, \\"value\\": \\"B\\"}}}, ... {\\"level1\\": {\\"info\\": {\\"name\\": \\"D\\"}}} ...] >>> key = \\"id\\" >>> sort_nested_dicts(data, key) [ {\\"level1\\": {\\"level2\\": {\\"id\\": 1, \\"value\\": \\"A\\"}}}, {\\"level1\\": {\\"level2\\": {\\"id\\": 2, \\"value\\": \\"B\\"}}}, {\\"level1\\": {\\"level2\\": {\\"id\\": 3, \\"value\\": \\"C\\"}}}, {\\"level1\\": {\\"info\\": {\\"name\\": \\"D\\"}}} ]","solution":"def find_key(d, key): Helper function that recursively searches for the key in nested dictionaries. Returns the value if the key is found, otherwise returns None. if key in d: return d[key] for k, v in d.items(): if isinstance(v, dict): result = find_key(v, key) if result is not None: return result return None def sort_nested_dicts(data, key): Sorts a list of nested dictionaries by a specified key at any depth. Returns the sorted list. If the key is not present in any of the dictionaries, returns the original list. # Check if the key exists in any of the dictionaries if not any(find_key(d, key) is not None for d in data): return data # Sort the list based on the value associated with the specified key return sorted(data, key=lambda d: (find_key(d, key) is None, find_key(d, key))) # Example data data = [ {\\"level1\\": {\\"level2\\": {\\"id\\": 3, \\"value\\": \\"C\\"}}}, {\\"level1\\": {\\"level2\\": {\\"id\\": 1, \\"value\\": \\"A\\"}}}, {\\"level1\\": {\\"level2\\": {\\"id\\": 2, \\"value\\": \\"B\\"}}}, {\\"level1\\": {\\"info\\": {\\"name\\": \\"D\\"}}} ] key = \\"id\\" # Expected result expected_result = [ {\\"level1\\": {\\"level2\\": {\\"id\\": 1, \\"value\\": \\"A\\"}}}, {\\"level1\\": {\\"level2\\": {\\"id\\": 2, \\"value\\": \\"B\\"}}}, {\\"level1\\": {\\"level2\\": {\\"id\\": 3, \\"value\\": \\"C\\"}}}, {\\"level1\\": {\\"info\\": {\\"name\\": \\"D\\"}}} ] # Running the function to get the sorted result result = sort_nested_dicts(data, key) print(result) # Should output the expected result"},{"question":"def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Takes two sorted lists of integers and merges them into one sorted list without using any built-in sort functions. >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([], [2, 4, 6]) [2, 4, 6] >>> merge_sorted_lists([1, 3, 5], []) [1, 3, 5] >>> merge_sorted_lists([], []) [] >>> merge_sorted_lists([1, 3, 5], [1, 3, 5]) [1, 1, 3, 3, 5, 5] >>> merge_sorted_lists([-3, 0, 4], [-4, -1, 2]) [-4, -3, -1, 0, 2, 4]","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into one sorted list without using any built-in sort functions. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append remaining elements, if any while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def longest_palindrome_substring(s: str) -> str: Returns the longest palindrome substring in the given string \`s\`. >>> longest_palindrome_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindrome_substring(\\"cbbd\\") 'bb' >>> longest_palindrome_substring(\\"a\\") 'a' >>> longest_palindrome_substring(\\"abc\\") in [\\"a\\", \\"b\\", \\"c\\"] True >>> longest_palindrome_substring(\\"\\") '' >>> longest_palindrome_substring(\\"aaaa\\") 'aaaa' >>> longest_palindrome_substring(\\"abacdfgdcaba\\") 'aba' >>> longest_palindrome_substring(\\"abcdefg\\") in [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\", \\"g\\"] True","solution":"def longest_palindrome_substring(s): Returns the longest palindrome substring in the given string \`s\`. n = len(s) if n == 0: return \\"\\" dp = [[False] * n for _ in range(n)] start = 0 max_length = 1 for i in range(n): dp[i][i] = True for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True start = i max_length = 2 for length in range(3, n+1): for i in range(n-length+1): j = i + length - 1 if s[i] == s[j] and dp[i+1][j-1]: dp[i][j] = True start = i max_length = length return s[start:start + max_length]"},{"question":"def shift_string(s: str, shift: int = 3) -> str: Returns a new string where each character is shifted by 'shift' positions in the alphabet. Non-alphabetic characters remain unchanged. Parameters: s (str): The input string to be shifted. shift (int): The number of positions to shift each character (default is 3). Returns: str: The shifted string. >>> shift_string(\\"abc\\") == \\"def\\" >>> shift_string(\\"xyz\\") == \\"abc\\" >>> shift_string(\\"ABC\\") == \\"DEF\\" >>> shift_string(\\"XYZ\\") == \\"ABC\\" >>> shift_string(\\"aBcXyZ\\") == \\"dEfAbC\\" >>> shift_string(\\"Hello, World!\\") == \\"Khoor, Zruog!\\" >>> shift_string(\\"Shift 123!\\") == \\"Vkliw 123!\\" >>> shift_string(\\"abc\\", 1) == \\"bcd\\" >>> shift_string(\\"xyz\\", 5) == \\"cde\\" >>> shift_string(\\"\\") == \\"\\"","solution":"def shift_char(c, shift): if c.islower(): return chr((ord(c) - ord('a') + shift) % 26 + ord('a')) elif c.isupper(): return chr((ord(c) - ord('A') + shift) % 26 + ord('A')) else: return c def shift_string(s, shift=3): Returns a new string where each character is shifted by 'shift' positions in the alphabet. Non-alphabetic characters remain unchanged. Parameters: s (str): The input string to be shifted. shift (int): The number of positions to shift each character (default is 3). Returns: str: The shifted string. return ''.join(shift_char(c, shift) for c in s)"},{"question":"from typing import List, Optional, Tuple def find_pair_with_sum(numbers: List[int], target: int) -> Optional[Tuple[int, int]]: Finds two distinct integers from the list that add up to the target sum. >>> find_pair_with_sum([2, 7, 11, 15], 9) (2, 7) >>> find_pair_with_sum([1, 5, 3, 4, 2], 6) (1, 5) or (2, 4) >>> find_pair_with_sum([3, 5, 9], 12) (3, 9) >>> find_pair_with_sum([1, 2, 3], 7) None","solution":"from typing import List, Optional, Tuple def find_pair_with_sum(numbers: List[int], target: int) -> Optional[Tuple[int, int]]: Finds two distinct integers in \`numbers\` that add up to \`target\`. Parameters: - numbers (List[int]): The list of integers to search within. - target (int): The target sum to find. Returns: - Optional[Tuple[int, int]]: A tuple of two integers that add up to \`target\`, or None if no such pair exists. seen = {} for number in numbers: complement = target - number if complement in seen: return (complement, number) seen[number] = True return None"},{"question":"def longest_consecutive_sequence(arr): Determines the longest consecutive sequence of identical elements in an array and returns the element and the length of that sequence. >>> longest_consecutive_sequence([1, 1, 2, 2, 2, 3, 3, 1, 1, 1]) == (2, 3) >>> longest_consecutive_sequence([1, 2, 3, 4]) == (1, 1) >>> longest_consecutive_sequence([1, 1, 1, 1]) == (1, 4) >>> longest_consecutive_sequence([]) == (None, 0) >>> longest_consecutive_sequence([1, 1, 2, 2, 3, 3]) == (1, 2) >>> longest_consecutive_sequence([3, 3, 3, 1, 1]) == (3, 3) >>> longest_consecutive_sequence([1, 1, 2, 2, 2]) == (2, 3) >>> longest_consecutive_sequence([5]) == (5, 1)","solution":"def longest_consecutive_sequence(arr): Determines the longest consecutive sequence of identical elements in an array and returns the element and the length of that sequence. if not arr: return None, 0 longest_element = arr[0] longest_length = 1 current_element = arr[0] current_length = 1 for i in range(1, len(arr)): if arr[i] == current_element: current_length += 1 else: if current_length > longest_length: longest_element = current_element longest_length = current_length current_element = arr[i] current_length = 1 # Final check to handle the case where the longest sequence is at the end of the array if current_length > longest_length: longest_element = current_element longest_length = current_length return longest_element, longest_length"},{"question":"def evaluate_expressions(expressions: List[str]) -> List[int]: Takes a list of arithmetic expression strings and returns the evaluated results as a list. >>> evaluate_expressions([\\"3+5*2\\"]) == [13] >>> evaluate_expressions([\\"3+5*2\\", \\"(2+3)*(5-2)\\", \\"10/2-1\\"]) == [13, 15, 4] >>> evaluate_expressions([\\"10/2-1\\", \\"6-3/2\\"]) == [4, 5] >>> evaluate_expressions([\\"(2+3)*(5-2)\\", \\"2*(3+4)-5\\"]) == [15, 9] >>> evaluate_expressions([\\"3+5*2/(7-4)\\"]) == [6]","solution":"def evaluate_expression(expression): Evaluates a single arithmetic expression string and returns the result def apply_operator(operators, operands): operator = operators.pop() right_operand = operands.pop() left_operand = operands.pop() if operator == '+': operands.append(left_operand + right_operand) elif operator == '-': operands.append(left_operand - right_operand) elif operator == '*': operands.append(left_operand * right_operand) elif operator == '/': operands.append(int(left_operand / right_operand)) # Truncate towards zero def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 operators = [] operands = [] i = 0 while i < len(expression): if expression[i] == '(': operators.append(expression[i]) elif expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 operands.append(num) i -= 1 elif expression[i] == ')': while operators[-1] != '(': apply_operator(operators, operands) operators.pop() # Pop '(' else: while (operators and operators[-1] != '(' and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, operands) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, operands) return operands[-1] def evaluate_expressions(expressions): Takes a list of arithmetic expression strings and returns the evaluated results as a list return [evaluate_expression(expression) for expression in expressions]"},{"question":"def factorial(n: int) -> int: Returns the factorial of the given non-negative integer n using an iterative approach. If n is 0, the function should return 1. >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(5) 120 >>> factorial(10) 3628800 >>> factorial(7) 5040","solution":"def factorial(n): Returns the factorial of the given non-negative integer n. if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"def analyze_sentiment(paragraph: str) -> str: Analyze the sentiment of a given paragraph of text. The function identifies whether the overall sentiment is positive, negative, or neutral by counting the number of positive and negative words in the paragraph and comparing these counts. Args: paragraph (str): The input paragraph of text to analyze. Returns: str: 'positive', 'negative', or 'neutral' based on the sentiment analysis. >>> analyze_sentiment(\\"The day was wonderful and amazing.\\") 'positive' >>> analyze_sentiment(\\"The experience was horrible and terrible.\\") 'negative' >>> analyze_sentiment(\\"The day was just okay, not good but not bad either.\\") 'neutral' >>> analyze_sentiment(\\"It was an excellent day but ended with a terrible incident.\\") 'neutral' >>> analyze_sentiment(\\"\\") 'neutral' >>> analyze_sentiment(\\"The dog barked all day and the cat slept.\\") 'neutral'","solution":"def analyze_sentiment(paragraph): Analyze the sentiment of a given paragraph of text. The function identifies whether the overall sentiment is positive, negative, or neutral by counting the number of positive and negative words in the paragraph and comparing these counts. Args: paragraph (str): The input paragraph of text to analyze. Returns: str: 'positive', 'negative', or 'neutral' based on the sentiment analysis. positive_words = {\\"good\\", \\"happy\\", \\"joyful\\", \\"excellent\\", \\"wonderful\\", \\"amazing\\"} negative_words = {\\"bad\\", \\"sad\\", \\"terrible\\", \\"awful\\", \\"horrible\\", \\"unhappy\\"} words = paragraph.lower().split() positive_count = sum(1 for word in words if word in positive_words) negative_count = sum(1 for word in words if word in negative_words) if positive_count > negative_count: return 'positive' elif negative_count > positive_count: return 'negative' else: return 'neutral'"},{"question":"def sum_of_factorials(numbers: str) -> int: Compute the sum of the factorials of each integer in the comma-separated input string. >>> sum_of_factorials('1,2,3') 9 >>> sum_of_factorials('4,5') 144 >>> sum_of_factorials('6') 720","solution":"def factorial(n): Helper function to compute the factorial of a given number n. if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result def sum_of_factorials(numbers: str) -> int: Compute the sum of the factorials of each integer in the comma-separated input string. nums = map(int, numbers.split(',')) return sum(factorial(num) for num in nums)"},{"question":"from datetime import datetime class Task: def __init__(self, title: str, description: str, due_date: str, priority: int): self.title = title self.description = description self.due_date = datetime.strptime(due_date, '%Y-%m-%d') self.priority = priority self.completed = False def is_overdue(self) -> bool: Check if the task's due date has passed pass def modify_task(self, title: str = None, description: str = None, due_date: str = None, priority: int = None): Modify the task's attributes pass def mark_as_completed(self): Mark the task as completed pass class TaskManager: def __init__(self): self.tasks = [] def add_task(self, task: Task): Add a new task to the task list pass def remove_task(self, task: Task): Remove a task from the task list pass def retrieve_tasks_by_due_date(self) -> list: Retrieve tasks sorted by their due date pass def retrieve_tasks_by_priority(self) -> list: Retrieve tasks sorted by their priority pass def get_pending_tasks(self) -> list: Retrieve all pending tasks sorted by their due date pass","solution":"from datetime import datetime class Task: def __init__(self, title: str, description: str, due_date: str, priority: int): self.title = title self.description = description self.due_date = datetime.strptime(due_date, '%Y-%m-%d') self.priority = priority self.completed = False def is_overdue(self) -> bool: Check if the task's due date has passed return datetime.now() > self.due_date and not self.completed def modify_task(self, title: str = None, description: str = None, due_date: str = None, priority: int = None): Modify the task's attributes if title: self.title = title if description: self.description = description if due_date: self.due_date = datetime.strptime(due_date, '%Y-%m-%d') if priority is not None: self.priority = priority def mark_as_completed(self): Mark the task as completed self.completed = True class TaskManager: def __init__(self): self.tasks = [] def add_task(self, task: Task): Add a new task to the task list self.tasks.append(task) def remove_task(self, task: Task): Remove a task from the task list self.tasks = [t for t in self.tasks if t != task] def retrieve_tasks_by_due_date(self) -> list: Retrieve tasks sorted by their due date return sorted(self.tasks, key=lambda x: x.due_date) def retrieve_tasks_by_priority(self) -> list: Retrieve tasks sorted by their priority return sorted(self.tasks, key=lambda x: x.priority) def get_pending_tasks(self) -> list: Retrieve all pending tasks sorted by their due date return sorted([task for task in self.tasks if not task.completed], key=lambda x: x.due_date)"},{"question":"def char_count(s: str) -> dict: Returns a dictionary with characters as keys and their occurrences as values. Ignores case sensitivity and non-alphabetical characters. >>> char_count(\\"Hello\\") == {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> char_count(\\"HeLlo\\") == {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> char_count(\\"Hello!123\\") == {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> char_count(\\"\\") == {} >>> char_count(\\"12345!!!\\") == {} >>> char_count(\\"The quick brown fox!\\") == { 't': 1, 'h': 1, 'e': 1, 'q': 1, 'u': 1, 'i': 1, 'c': 1, 'k': 1, 'b': 1, 'r': 1, 'o': 2, 'w': 1, 'n': 1, 'f': 1, 'x': 1 }","solution":"def char_count(s): Returns a dictionary with characters as keys and their occurrences as values. Ignores case sensitivity and non-alphabetical characters. s = s.lower() result = {} for char in s: if char.isalpha(): if char in result: result[char] += 1 else: result[char] = 1 return result"},{"question":"def find_prime_numbers(start: int, end: int) -> List[int]: Write a Python function named \`find_prime_numbers\` that takes two integers, \`start\` and \`end\`, as parameters and returns a list of all prime numbers between \`start\` and \`end\` (inclusive). A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. >>> find_prime_numbers(10, 30) [11, 13, 17, 19, 23, 29] >>> find_prime_numbers(0, 1) [] >>> find_prime_numbers(2, 2) [2] >>> find_prime_numbers(50, 100) [53, 59, 61, 67, 71, 73, 79, 83, 89, 97] >>> find_prime_numbers(30, 10) [] >>> find_prime_numbers(17, 17) [17] >>> find_prime_numbers(-10, 2) [2]","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False elif n <= 3: return True elif n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_prime_numbers(start, end): Returns a list of all prime numbers between start and end (inclusive). return [num for num in range(start, end + 1) if is_prime(num)]"},{"question":"def count_pairs_divisible_by_k(arr, k): Returns the number of pairs of integers in the array whose sum is divisible by k. Parameters: arr (list): List of integers. k (int): The divisor. Returns: int: Number of pairs whose sum is divisible by k.","solution":"def count_pairs_divisible_by_k(arr, k): Returns the number of pairs of integers in the array whose sum is divisible by k. Parameters: arr (list): List of integers. k (int): The divisor. Returns: int: Number of pairs whose sum is divisible by k. count = 0 n = len(arr) for i in range(n): for j in range(i + 1, n): if (arr[i] + arr[j]) % k == 0: count += 1 return count"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def in_order_traversal(root: TreeNode) -> list: Perform an in-order traversal of a binary search tree (BST) and return the elements in a sorted list. >>> in_order_traversal(None) [] >>> in_order_traversal(TreeNode(1)) [1] >>> in_order_traversal(TreeNode(2, TreeNode(1))) [1, 2] >>> in_order_traversal(TreeNode(2, TreeNode(1), TreeNode(3))) [1, 2, 3] >>> root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(5, None, TreeNode(6))) >>> in_order_traversal(root) [1, 2, 3, 4, 5, 6]","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def in_order_traversal(root): Perform an in-order traversal of a binary search tree and return the elements in a sorted list. result = [] def traverse(node): if node is not None: traverse(node.left) result.append(node.value) traverse(node.right) traverse(root) return result"},{"question":"def find_prime_factors(n: int) -> List[int]: Returns a list of prime factors of the given integer n. Examples: >>> find_prime_factors(28) [2, 2, 7] >>> find_prime_factors(45) [3, 3, 5] >>> find_prime_factors(101) [101]","solution":"def find_prime_factors(n): Returns a list of prime factors of the given integer n. prime_factors = [] divisor = 2 while n > 1: while n % divisor == 0: prime_factors.append(divisor) n //= divisor divisor += 1 return prime_factors"},{"question":"def rotate_matrix_90_clockwise(matrix): Rotates a given 2D list (matrix) 90 degrees clockwise. Args: matrix (list of list of int): The input 2D list (matrix). Returns: list of list of int: The rotated matrix. Example: >>> rotate_matrix_90_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ]","solution":"def rotate_matrix_90_clockwise(matrix): Rotates a given 2D list (matrix) 90 degrees clockwise. Args: matrix (list of list of int): The input 2D list (matrix). Returns: list of list of int: The rotated matrix. if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) rotated_matrix = [[0] * rows for _ in range(cols)] for r in range(rows): for c in range(cols): rotated_matrix[c][rows - 1 - r] = matrix[r][c] return rotated_matrix"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring with at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5 >>> length_of_longest_substring_two_distinct(\\"a\\") 1 >>> length_of_longest_substring_two_distinct(\\"abaccc\\") 4 >>> length_of_longest_substring_two_distinct(\\"abcabcabc\\") 2 >>> length_of_longest_substring_two_distinct(\\"ab\\") 2 >>> length_of_longest_substring_two_distinct(\\"\\") 0","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring with at most two distinct characters. :param s: String :type s: str :return: Length of the longest substring with at most two distinct characters. :rtype: int if len(s) < 3: return len(s) left = 0 right = 0 max_len = 2 char_map = {} while right < len(s): if len(char_map) < 3: char_map[s[right]] = right right += 1 if len(char_map) == 3: del_idx = min(char_map.values()) del char_map[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"from typing import List def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merge two sorted lists into a single sorted list. :param list1: List[int] - first sorted list :param list2: List[int] - second sorted list :return: List[int] - merged and sorted list >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([0, 10, 20], [5, 15, 25]) [0, 5, 10, 15, 20, 25] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_lists([], []) [] >>> merge_sorted_lists([1, 2, 2, 3], [2, 2, 4]) [1, 2, 2, 2, 2, 3, 4] >>> merge_sorted_lists([1], [2]) [1, 2] >>> merge_sorted_lists([2], [1]) [1, 2] >>> merge_sorted_lists([1, 1000000], [500000, 1000001]) [1, 500000, 1000000, 1000001] >>> merge_sorted_lists([-3, -1, 0], [-2, 2, 3]) [-3, -2, -1, 0, 2, 3]","solution":"def merge_sorted_lists(list1, list2): Merge two sorted lists into a single sorted list. :param list1: List[int] - first sorted list :param list2: List[int] - second sorted list :return: List[int] - merged and sorted list merged_list = [] i = j = 0 # Traverse both lists and merge them into merged_list while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # If there are remaining elements in list1 while i < len(list1): merged_list.append(list1[i]) i += 1 # If there are remaining elements in list2 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"import re from collections import Counter from typing import Dict def word_count(s: str) -> Dict[str, int]: Write a function that takes a string consisting of words and returns a dictionary where each key is a word in the string, and the value is the count of occurrences of that word. The function should ignore punctuation and be case-insensitive. >>> word_count(\\"Hello, hello! How are you? You look just fine.\\") {\\"hello\\": 2, \\"how\\": 1, \\"are\\": 1, \\"you\\": 2, \\"look\\": 1, \\"just\\": 1, \\"fine\\": 1} >>> word_count(\\"\\") {} >>> word_count(\\"This is a test. This is only a test!\\") {\\"this\\": 2, \\"is\\": 2, \\"a\\": 2, \\"test\\": 2, \\"only\\": 1} >>> word_count(\\"Case insensitivity is important. CASE insensitivity!\\") {\\"case\\": 2, \\"insensitivity\\": 2, \\"is\\": 1, \\"important\\": 1} >>> word_count(\\"Spaces should not affect the counts.\\") {\\"spaces\\": 1, \\"should\\": 1, \\"not\\": 1, \\"affect\\": 1, \\"the\\": 1, \\"counts\\": 1}","solution":"import re from collections import Counter def word_count(s): Returns a dictionary where each key is a word in the string \`s\` and the value is the count of occurrences of that word. The function ignores punctuation and is case-insensitive. # Remove punctuation and convert to lower case s = re.sub(r'[^ws]', '', s).lower() # Split the string into words words = s.split() # Count the occurrences of each word return dict(Counter(words))"},{"question":"import math from typing import Union def cylinder_surface_area(r: Union[int, float], h: Union[int, float]) -> float: Calculate the surface area of a cylinder using the formula 2 * pi * r * (r + h), where 'r' is the radius of the base and 'h' is the height of the cylinder. >>> math.isclose(cylinder_surface_area(1, 1), 2 * math.pi * 1 * (1 + 1), rel_tol=1e-9) True >>> math.isclose(cylinder_surface_area(0, 5), 2 * math.pi * 0 * (0 + 5), rel_tol=1e-9) True >>> math.isclose(cylinder_surface_area(2, 0), 2 * math.pi * 2 * (2 + 0), rel_tol=1e-9) True >>> math.isclose(cylinder_surface_area(10, 20), 2 * math.pi * 10 * (10 + 20), rel_tol=1e-9) True >>> math.isclose(cylinder_surface_area(1.5, 2.5), 2 * math.pi * 1.5 * (1.5 + 2.5), rel_tol=1e-9) True pass","solution":"import math def cylinder_surface_area(r, h): Returns the surface area of a cylinder with radius r and height h. return 2 * math.pi * r * (r + h)"},{"question":"def is_palindrome(s: str) -> bool: Check if the given string is a palindrome by ignoring non-alphanumeric characters and case sensitivity. >>> is_palindrome(\\"A man a plan a canal Panama\\") == True >>> is_palindrome(\\"Race car!\\") == True >>> is_palindrome(\\"Hello, World!\\") == False >>> is_palindrome(\\"Testing, 1, 2, 3.\\") == False >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"Z\\") == True >>> is_palindrome(\\"No 'x' in Nixon\\") == True >>> is_palindrome(\\"!!!Radar!!!\\") == True","solution":"def is_palindrome(s): Check if the given string is a palindrome by ignoring non-alphanumeric characters and case sensitivity. # Filter the string to remove non-alphanumeric characters and convert to lowercase filtered_s = ''.join(char.lower() for char in s if char.isalnum()) # Check if the filtered string is equal to its reverse return filtered_s == filtered_s[::-1]"},{"question":"def checkParentheses(s: str) -> bool: Create a function that takes a string of parentheses and determines if the order of the parentheses is valid. Args: s (str): A string consisting of '(' and ')'. Returns: bool: True if the string is valid, otherwise False. Example: >>> checkParentheses(\\"()\\") True >>> checkParentheses(\\"(()\\") False >>> checkParentheses(\\"()()\\") True >>> checkParentheses(\\"(())\\") True >>> checkParentheses(\\"(()))\\") False","solution":"def checkParentheses(s): Checks if the parentheses in the given string are valid. Args: s (str): A string consisting of '(' and ')'. Returns: bool: True if the string is valid, otherwise False. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack or stack.pop() != '(': return False return not stack"},{"question":"def longest_substring_with_k_distinct_characters(s: str, k: int) -> int: Determine the length of the longest substring of s that contains at most k distinct characters. >>> longest_substring_with_k_distinct_characters(\\"aabbcc\\", 1) 2 >>> longest_substring_with_k_distinct_characters(\\"aabbcc\\", 2) 4 >>> longest_substring_with_k_distinct_characters(\\"aabbcc\\", 3) 6 >>> longest_substring_with_k_distinct_characters(\\"aabc\\", 5) 4 >>> longest_substring_with_k_distinct_characters(\\"\\", 2) 0 >>> longest_substring_with_k_distinct_characters(\\"abc\\", 0) 0 >>> longest_substring_with_k_distinct_characters(\\"aaaaaa\\", 1) 6 >>> longest_substring_with_k_distinct_characters(\\"eceba\\", 2) 3 >>> longest_substring_with_k_distinct_characters(\\"a\\" * 1000000, 5000) 1000000","solution":"def longest_substring_with_k_distinct_characters(s, k): Returns the length of the longest substring of s that contains at most k distinct characters. if k == 0 or not s: return 0 char_map = {} left = 0 max_len = 0 for right in range(len(s)): char = s[right] if char in char_map: char_map[char] += 1 else: char_map[char] = 1 while len(char_map) > k: left_char = s[left] char_map[left_char] -= 1 if char_map[left_char] == 0: del char_map[left_char] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"# Chat Server import asyncio import websockets connected_clients = {} async def broadcast(message): if connected_clients: await asyncio.wait([client.send(message) for client in connected_clients.values()]) async def handle_client(websocket, path): client_id = websocket.remote_address connected_clients[client_id] = websocket try: async for message in websocket: await broadcast(f\\"Client {client_id}: {message}\\") finally: del connected_clients[client_id] await broadcast(f\\"Client {client_id} has disconnected.\\") async def main(): async with websockets.serve(handle_client, \\"localhost\\", 6789): await asyncio.Future() # Run forever if __name__ == \\"__main__\\": asyncio.run(main()) # Chat Client import asyncio import websockets async def send_message(websocket): while True: message = input(\\"You: \\") await websocket.send(message) async def receive_message(websocket): async for message in websocket: print(message) async def main(): async with websockets.connect(\\"ws://localhost:6789\\") as websocket: await asyncio.gather( send_message(websocket), receive_message(websocket), ) if __name__ == \\"__main__\\": asyncio.run(main())","solution":"# Chat Server import asyncio import websockets connected_clients = {} async def broadcast(message): if connected_clients: await asyncio.wait([client.send(message) for client in connected_clients.values()]) async def handle_client(websocket, path): client_id = websocket.remote_address connected_clients[client_id] = websocket try: async for message in websocket: await broadcast(f\\"Client {client_id}: {message}\\") finally: del connected_clients[client_id] await broadcast(f\\"Client {client_id} has disconnected.\\") async def main(): async with websockets.serve(handle_client, \\"localhost\\", 6789): await asyncio.Future() if __name__ == \\"__main__\\": asyncio.run(main()) # Chat Client import asyncio import websockets async def send_message(websocket): while True: message = input(\\"You: \\") await websocket.send(message) async def receive_message(websocket): async for message in websocket: print(message) async def main(): async with websockets.connect(\\"ws://localhost:6789\\") as websocket: await asyncio.gather( send_message(websocket), receive_message(websocket), ) if __name__ == \\"__main__\\": asyncio.run(main())"},{"question":"def is_prime(n: int) -> bool: Checks if a number is a prime. >>> is_prime(2) True >>> is_prime(4) False pass def filter_primes(numbers: List[int]) -> List[int]: Filters the prime numbers from a list of integers. >>> filter_primes([2, 3, 5, 7]) [2, 3, 5, 7] >>> filter_primes([4, 6, 8, 10]) [] >>> filter_primes([4, 6, 7, 10, 13]) [7, 13] >>> filter_primes([7]) [7] >>> filter_primes([4]) [] >>> filter_primes(list(range(1, 101))) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] pass","solution":"def is_prime(n): Checks if a number is a prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(numbers): Filters the prime numbers from a list of integers. return [num for num in numbers if is_prime(num)]"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Determine the number of unique paths a robot can take from the top-left corner to the bottom-right corner of a grid, considering obstacles. Each cell in the grid either has an obstacle ('1') or is a free cell ('0'). >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[0, 1], [0, 0]]) 1 >>> unique_paths_with_obstacles([[0, 1], [1, 0]]) 0 >>> unique_paths_with_obstacles([[0, 0, 0, 0]]) 1 >>> unique_paths_with_obstacles([[0], [0], [0], [0]]) 1 >>> unique_paths_with_obstacles([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 1]]) 0 pass","solution":"def unique_paths_with_obstacles(grid): if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def string_lengths(strings: List[str]) -> List[int]: Returns a list of the lengths of the given strings. Ensure the function handles an empty list by returning an empty list. >>> string_lengths([\\"apple\\", \\"banana\\", \\"cherry\\"]) [5, 6, 6] >>> string_lengths([\\"strawberry\\"]) [10] >>> string_lengths([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"]) [1, 2, 3, 4] >>> string_lengths([\\"apple pie\\", \\"banana split\\", \\"cherry tart\\"]) [9, 12, 11] >>> string_lengths([]) []","solution":"def string_lengths(strings): Returns a list of the lengths of the given strings. Parameters: strings (list of str): A list of strings. Returns: list of int: A list of lengths of the given strings. return [len(s) for s in strings]"},{"question":"def longest_palindrome(s: str) -> str: Finds the longest palindrome in a given string. A palindrome is a word, phrase, or sequence of characters that reads the same backward as it does forward, ignoring spaces, punctuation, and capitalization. You may assume that the input string contains only lowercase alphabetic characters and spaces. >>> longest_palindrome(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindrome(\\"cbbd\\") 'bb' >>> longest_palindrome(\\"a\\") 'a' >>> longest_palindrome(\\"ac\\") in [\\"a\\", \\"c\\"] True pass # Example usage print(longest_palindrome(\\"babad\\")) # Output: \\"bab\\" or \\"aba\\" print(longest_palindrome(\\"cbbd\\")) # Output: \\"bb\\" print(longest_palindrome(\\"a\\")) # Output: \\"a\\" print(longest_palindrome(\\"ac\\")) # Output: \\"a\\" or \\"c\\"","solution":"def longest_palindrome(s): Finds the longest palindromic substring in the given string. if len(s) <= 1: return s start, end = 0, 0 def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return left + 1, right - 1 for i in range(len(s)): l1, r1 = expand_around_center(s, i, i) # Odd length palindromes l2, r2 = expand_around_center(s, i, i + 1) # Even length palindromes if r1 - l1 > end - start: start, end = l1, r1 if r2 - l2 > end - start: start, end = l2, r2 return s[start:end+1]"},{"question":"def product_except_self(nums): Returns an array where each element is the product of all other elements in the input array. No division operation is used. >>> product_except_self([1, 2, 3, 4]) # [24, 12, 8, 6] >>> product_except_self([0, 0, 1, 2]) # [0, 0, 0, 0] >>> product_except_self([7]) # [1] >>> product_except_self([6, 3]) # [3, 6] >>> product_except_self([1000, 2000, 3000, 4000]) # [24000000000, 12000000000, 8000000000, 6000000000] #  pass","solution":"def product_except_self(nums): Returns an array where each element is the product of all other elements in the input array. No division operation is used. length = len(nums) result = [1] * length left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def double_values_alternating(lst: List[int]) -> List[int]: Return a list where every element in the input list is followed by its double >>> double_values_alternating([]) [] >>> double_values_alternating([1, 2, 3]) [1, 2, 2, 4, 3, 6] >>> double_values_alternating([-1, -2, -3]) [-1, -2, -2, -4, -3, -6] >>> double_values_alternating([-1, 0, 3]) [-1, -2, 0, 0, 3, 6] >>> double_values_alternating([2, 2, 2]) [2, 4, 2, 4, 2, 4]","solution":"def double_values_alternating(lst): Returns a list where every element in the input list is followed by its double. :param lst: List of integers :return: List of integers where every element is followed by its double result = [] for number in lst: result.append(number) result.append(number * 2) return result"},{"question":"def is_palindrome(s: str) -> bool: Checks if the input string is a valid palindrome, ignoring case and non-alphanumeric characters. Args: s (str): The input string to check. Returns: bool: True if the string is a palindrome, False otherwise. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"This is not a palindrome\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"Z\\") True >>> is_palindrome(\\"RaceCar\\") True >>> is_palindrome(\\"1221\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"123456\\") False","solution":"def is_palindrome(s: str) -> bool: Checks if the input string is a valid palindrome, ignoring case and non-alphanumeric characters. Args: s (str): The input string to check. Returns: bool: True if the string is a palindrome, False otherwise. # Filter out non-alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered characters form a palindrome return filtered_chars == filtered_chars[::-1]"},{"question":"def product_except_first(arr: List[int]) -> int: Returns the product of all elements in the list except the one at the first position. >>> product_except_first([3, 2, 5, 6]) 60 >>> product_except_first([3]) 0 >>> product_except_first([3, 4]) 4 >>> product_except_first([3, 0, 5, 6]) 0 >>> product_except_first([3, 1, 1, 1]) 1 >>> product_except_first([3, -2, -3, 4]) 24 >>> product_except_first([3, -2, 0, 4]) 0","solution":"def product_except_first(arr): Returns the product of all elements in the list except the one at the first position. if len(arr) <= 1: return 0 # Return 0 if there's no element to multiply product = 1 for num in arr[1:]: product *= num return product"},{"question":"def is_prime(n: int) -> bool: Returns True if n is a prime number, False otherwise. >>> is_prime(2) True >>> is_prime(4) False def prime_factors(n: int) -> list: Returns a list of all prime factors of n in ascending order. >>> prime_factors(28) [2, 2, 7] >>> prime_factors(30) [2, 3, 5]","solution":"def is_prime(n): Returns True if n is a prime number, False otherwise. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def prime_factors(n): Returns a list of all prime factors of n in ascending order. if n <= 1: return [] factors = [] for i in range(2, int(n**0.5) + 1): while is_prime(i) and n % i == 0: factors.append(i) n //= i if n > 1: factors.append(n) return factors"},{"question":"def sort_movies_by_word_count(movies: List[str]) -> List[str]: Sorts movie titles first by the number of words in the title, and then alphabetically among titles with the same word count. >>> sort_movies_by_word_count([ ... \\"The Matrix\\", ... \\"Inception\\", ... \\"Interstellar\\", ... \\"The Prestige\\", ... \\"The Dark Knight\\", ... \\"Memento\\", ... \\"Insomnia\\", ... \\"Dunkirk\\", ... \\"Tenet\\", ... \\"Following\\" ... ]) ['Dunkirk', 'Following', 'Inception', 'Insomnia', 'Interstellar', 'Memento', 'Tenet', 'The Matrix', 'The Prestige', 'The Dark Knight'] pass","solution":"def sort_movies_by_word_count(movies): Sorts movie titles first by the number of words in the title, and then alphabetically among titles with the same word count. :param movies: List[str] - A list of movie titles. :return: List[str] - Sorted list of movie titles. return sorted(movies, key=lambda title: (len(title.split()), title))"},{"question":"import re def is_valid_ipv4(ip: str) -> bool: Check if the given IP address is a valid IPv4 address. >>> is_valid_ipv4(\\"192.168.0.1\\") == True >>> is_valid_ipv4(\\"256.256.256.256\\") == False ... def filter_valid_ipv4_addresses(ip_addresses: list) -> list: Filters out the valid IPv4 addresses from the given list of IP addresses. Parameters: ip_addresses (list): A list of strings representing IP addresses. Returns: list: A list of valid IPv4 addresses. ...","solution":"import re def is_valid_ipv4(ip): Check if the given IP address is a valid IPv4 address. pattern = r'^(d{1,3}.){3}d{1,3}' if re.match(pattern, ip): parts = ip.split('.') for part in parts: if int(part) < 0 or int(part) > 255: return False return True return False def filter_valid_ipv4_addresses(ip_addresses): Filters out the valid IPv4 addresses from the given list of IP addresses. Parameters: ip_addresses (list): A list of strings representing IP addresses. Returns: list: A list of valid IPv4 addresses. return [ip for ip in ip_addresses if is_valid_ipv4(ip)]"},{"question":"def find_mode_height(heights): Returns the mode height from a list of heights. If there are multiple heights with the same maximum frequency, returns the smallest height. >>> find_mode_height([160, 170, 160, 165, 180, 165, 160]) 160 >>> find_mode_height([150, 160, 170, 180]) 150 >>> find_mode_height([150, 150, 160, 160, 170, 170, 180, 180]) 150 >>> find_mode_height([]) Traceback (most recent call last): ... ValueError: The list of heights cannot be empty >>> find_mode_height([155]) 155 >>> find_mode_height([150, 150, 150, 150, 150]) 150","solution":"def find_mode_height(heights): Returns the mode height from a list of heights. If there are multiple heights with the same maximum frequency, returns the smallest height. from collections import Counter if not heights: raise ValueError(\\"The list of heights cannot be empty\\") height_counter = Counter(heights) max_frequency = max(height_counter.values()) mode_heights = [height for height, frequency in height_counter.items() if frequency == max_frequency] return min(mode_heights)"},{"question":"def filter_and_sort(numbers, min_val, max_val): Filters out integers not within the range [min_val, max_val] from the list, and returns the sorted list of remaining integers. :param numbers: List of integers :param min_val: Minimum value of the range (inclusive) :param max_val: Maximum value of the range (inclusive) :return: Sorted list of integers within the range [min_val, max_val] >>> filter_and_sort([1, 2, 3, 4, 5], 2, 4) [2, 3, 4] >>> filter_and_sort([1, 2, 3, 4, 5], 6, 10) [] >>> filter_and_sort([1, 2, 3, 4, 5], 1, 5) [1, 2, 3, 4, 5] >>> filter_and_sort([], 1, 5) [] >>> filter_and_sort([5, 1, 3, 9, 2], 2, 5) [2, 3, 5] >>> filter_and_sort([-10, -5, 0, 5, 10], -5, 5) [-5, 0, 5] >>> filter_and_sort([3], 3, 3) [3] >>> filter_and_sort([3], 2, 2) []","solution":"def filter_and_sort(numbers, min_val, max_val): Filters out integers not within the range [min_val, max_val] from the list, and returns the sorted list of remaining integers. :param numbers: List of integers :param min_val: Minimum value of the range (inclusive) :param max_val: Maximum value of the range (inclusive) :return: Sorted list of integers within the range [min_val, max_val] # Filter the numbers within the range [min_val, max_val] filtered_numbers = [num for num in numbers if min_val <= num <= max_val] # Return the sorted filtered numbers return sorted(filtered_numbers)"},{"question":"def count_strings(input_list: List[str]) -> Dict[str, int]: Create a function that takes a list of strings and returns a dictionary with each unique string from the list as the key and the value being the number of times it appears in the list. If the input list is empty, return an empty dictionary. >>> count_strings([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) {\\"apple\\": 3, \\"banana\\": 2, \\"orange\\": 1} >>> count_strings([]) {} >>> count_strings([\\"apple\\"]) {\\"apple\\": 1} >>> count_strings([\\"apple\\", \\"banana\\", \\"orange\\", \\"grape\\"]) {\\"apple\\": 1, \\"banana\\": 1, \\"orange\\": 1, \\"grape\\": 1} >>> count_strings([\\"apple\\", \\"apple\\", \\"apple\\"]) {\\"apple\\": 3}","solution":"def count_strings(input_list): Returns a dictionary with each unique string from the input list as the key and the value being the number of times it appears in the list. count_dict = {} for string in input_list: if string in count_dict: count_dict[string] += 1 else: count_dict[string] = 1 return count_dict"},{"question":"import string def word_count(sentence): Takes a sentence as input and prints the frequency of each word, ignoring punctuation and case differences, in alphabetical order. >>> word_count(\\"Hello World\\") \\"hello: 1nworld: 1n\\" >>> word_count(\\"Hello, World!\\") \\"hello: 1nworld: 1n\\" >>> word_count(\\"Hello hello HELLO\\") \\"hello: 3n\\" >>> word_count(\\"Hello! hello, HELLO. world WORLD\\") \\"hello: 3nworld: 2n\\" >>> word_count(\\"\\") \\"\\"","solution":"import string def word_count(sentence): Takes a sentence as input and prints the frequency of each word, ignoring punctuation and case differences, in alphabetical order. # Convert the sentence to lowercase and remove punctuation translator = str.maketrans('', '', string.punctuation) sentence = sentence.translate(translator).lower() # Split the sentence into words words = sentence.split() # Count the frequency of each word word_freq = {} for word in words: word_freq[word] = word_freq.get(word, 0) + 1 # Sort the words alphabetically sorted_words = sorted(word_freq.items()) # Print the words and their counts for word, count in sorted_words: print(f\\"{word}: {count}\\")"},{"question":"from typing import List def longest_contiguous_subsequence(arr: List[int], limit: int) -> int: Create a function that, given a list of integers, returns the length of the longest contiguous subsequence where the absolute difference between any two consecutive elements is less than or equal to a given limit. The function should handle an empty list as a special case, returning 0. >>> longest_contiguous_subsequence([], 3) 0 >>> longest_contiguous_subsequence([5], 3) 1 >>> longest_contiguous_subsequence([1, 10, 20], 3) 1 >>> longest_contiguous_subsequence([1, 2, 3, 4, 5], 1) 5 >>> longest_contiguous_subsequence([1, 3, 5, 7, 1, 3, 2, 5, 7, 4], 2) 4 # Implement your solution here","solution":"from typing import List def longest_contiguous_subsequence(arr: List[int], limit: int) -> int: if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if abs(arr[i] - arr[i - 1]) <= limit: current_length += 1 else: current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def second_minimum_value(arr): Write a function that accepts an array consisting of \`n\` integers where \`n\` is between 2 and 10^4, all elements are within the range from -10^4 to 10^4 and may include duplicates. The function should find the second minimum value in the array. If no such second minimum value exists, return -1. The second minimum value is defined as the smallest number greater than the minimum value in the array. Examples: >>> second_minimum_value([2, 2, 3, 4, 5]) 3 >>> second_minimum_value([1, 1, 1, 1]) -1 >>> second_minimum_value([1, 2, 2, 3]) 2 Test Cases: assert second_minimum_value([2, 2, 3, 4, 5]) == 3 assert second_minimum_value([1, 1, 1, 1]) == -1 assert second_minimum_value([1, 2, 2, 3]) == 2 assert second_minimum_value([-1, -2, -3, -3, -2, -1]) == -2 assert second_minimum_value([-1, 1, 2, 3]) == 1 assert second_minimum_value([2, 2]) == -1 assert second_minimum_value([4, 4, 5, 6, 7, 8, 6, 5, 4, 3, 2, 1, 1, 1, 1]) == 2","solution":"def second_minimum_value(arr): Returns the second minimum value in the array. If no such value exists, returns -1. # Step 1: Remove duplicates by converting the array to a set unique_values = set(arr) # Step 2: If there are less than 2 unique values, return -1 if len(unique_values) < 2: return -1 # Step 3: Remove the minimum value and then find the next minimum unique_values.remove(min(unique_values)) return min(unique_values)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing integers and the operators + and -, handling whitespace within the string, and returns the final result as an integer. >>> evaluate_expression(\\"3 + 4 - 2\\") 5 >>> evaluate_expression(\\"10 + 2 - 6\\") 6 >>> evaluate_expression(\\"100 - 50 + 25\\") 75","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing integers and the operators + and -, handling whitespace within the string, and returns the final result as an integer. total = 0 current_number = 0 operator = '+' for char in expression + ' ': if char.isdigit(): current_number = current_number * 10 + int(char) elif char in '+-': if operator == '+': total += current_number elif operator == '-': total -= current_number current_number = 0 operator = char if operator == '+': total += current_number elif operator == '-': total -= current_number return total"},{"question":"import pandas as pd def average_score_above_20(file_path: str) -> float: Reads a CSV file and calculates the average score of individuals who are above 20 years old. Parameters: file_path (str): The file path to the CSV file. Returns: float: The average score of individuals above 20 years old. # Implementation here if __name__ == \\"__main__\\": from io import StringIO data = Name,Age,Score Alice,22,85 Bob,19,75 Charlie,23,95 David,20,65 Eve,25,70 # Simulating reading from a file using StringIO file_path = StringIO(data) print(average_score_above_20(file_path)) # Expected output: 83.33","solution":"import pandas as pd def average_score_above_20(file_path): Reads a CSV file and calculates the average score of individuals who are above 20 years old. Parameters: file_path (str): The file path to the CSV file. Returns: float: The average score of individuals above 20 years old. # Read the CSV file df = pd.read_csv(file_path) # Filter individuals who are above 20 years old df_filtered = df[df['Age'] > 20] # Calculate the average score average_score = df_filtered['Score'].mean() return average_score"},{"question":"import re def evaluate_expression(expression: str): Evaluates an arithmetic expression containing positive integers and the operators '+', '-', '*', and '/'. Handles an empty string or invalid characters by returning a message. Parameters: expression (str): The arithmetic expression to evaluate. Returns: float: The result of the expression. str: An error message if the input is invalid. Examples: >>> evaluate_expression(\\"2 + 3\\") 5 >>> evaluate_expression(\\"10 - 7\\") 3 >>> evaluate_expression(\\"6 * 3\\") 18 >>> evaluate_expression(\\"8 / 4\\") 2.0 >>> evaluate_expression(\\"\\") 'Error: Empty expression' >>> evaluate_expression(\\"2 + 3a - 4\\") 'Error: Invalid characters in expression' >>> evaluate_expression(\\" + \\".join([\\"1\\"] * 10000)) 10000","solution":"import re def evaluate_expression(expression): Evaluates an arithmetic expression containing positive integers and the operators '+', '-', '*', and '/'. Handles an empty string by returning a message. Parameters: expression (str): The arithmetic expression to evaluate. Returns: float: The result of the expression. str: An error message if the input is invalid. if not expression: return \\"Error: Empty expression\\" # Check for invalid characters if not re.match(r'^[d+-*/s]+', expression): return \\"Error: Invalid characters in expression\\" try: # Tokenize the expression tokens = re.findall(r'd+|[+-*/]', expression) # Convert numbers to integers for i in range(len(tokens)): if tokens[i].isdigit(): tokens[i] = int(tokens[i]) def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(left / right) # Operator precedence precedence = {'+': 1, '-': 1, '*': 2, '/': 2} operators = [] values = [] i = 0 while i < len(tokens): if isinstance(tokens[i], int): values.append(tokens[i]) i += 1 else: while (operators and precedence[operators[-1]] >= precedence[tokens[i]]): apply_operator(operators, values) operators.append(tokens[i]) i += 1 while operators: apply_operator(operators, values) return values[0] except Exception as e: return \\"Error: Invalid expression\\""},{"question":"from typing import List, Union def evaluate_expressions(expressions: List[str]) -> List[Union[int, float, None]]: Evaluate a list of mathematical expressions. Args: expressions (list): A list of strings, where each string is a mathematical expression. Returns: list: A list of results for each evaluated expression. If any expression results in an error (e.g., division by zero, incorrect expression), it will return None for that particular expression. >>> evaluate_expressions([\\"3 + 5\\", \\"10 * 2\\", \\"6 / 3\\", \\"8 - 4\\", \\"12 / 4\\"]) [8, 20, 2.0, 4, 3.0] >>> evaluate_expressions([\\"5 / 0\\"]) [None] >>> evaluate_expressions([\\"7 +\\"]) [None] >>> evaluate_expressions([\\"3 + 5\\", \\"10 * 2\\", \\"6 / 3\\", \\"8 - 4\\", \\"5 / 0\\", \\"7 +\\", \\"12 / 4\\"]) [8, 20, 2.0, 4, None, None, 3.0] >>> evaluate_expressions([]) []","solution":"def evaluate_expressions(expressions): Evaluates a list of mathematical expressions. Args: expressions (list): A list of strings, where each string is a mathematical expression. Returns: list: A list of results for each evaluated expression. If any expression results in an error (e.g., division by zero, incorrect expression), it will return None for that particular expression. results = [] for expr in expressions: try: # Evaluate the expression safely result = eval(expr) results.append(result) except ZeroDivisionError: # Division by zero results.append(None) except Exception: # Any other exception, like syntax errors results.append(None) return results"},{"question":"def square_positive_evens(numbers: List[int]) -> List[int]: Given a list of integers, returns a new list containing the squares of all positive even numbers from the original list. >>> square_positive_evens([2, 4, 6]) == [4, 16, 36] >>> square_positive_evens([-2, 3, 4, -5, 6]) == [16, 36] >>> square_positive_evens([-2, -4, -6, 1, 3, 5]) == [] >>> square_positive_evens([0, 1, 2, 3, 4, 5]) == [4, 16] >>> square_positive_evens([]) == []","solution":"def square_positive_evens(numbers): Given a list of integers, returns a new list containing the squares of all positive even numbers from the original list. return [x**2 for x in numbers if x > 0 and x % 2 == 0]"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, returns a new list where each element is the product of all the other elements in the original list except the element at the current position, without using division. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6]","solution":"def product_except_self(nums): Given a list of integers, returns a new list where each element is the product of all the other elements in the original list except the element at the current position. if len(nums) == 0: return [] length = len(nums) products = [1] * length # Multiply all the elements to the left of each element left_product = 1 for i in range(length): products[i] = left_product left_product *= nums[i] # Multiply all the elements to the right of each element right_product = 1 for i in range(length - 1, -1, -1): products[i] *= right_product right_product *= nums[i] return products"},{"question":"def longest_palindromic_substring(s: str) -> str: Create a function that returns the longest palindromic substring within a given string. The function should be efficient, ideally running in O(n^2) time complexity or better. Additionally, the function should consider all possible edge cases such as the string being empty, of length one, or having multiple palindromic substrings of the same maximum length. The longest palindromic substring should be returned as a string. >>> longest_palindromic_substring(\\"\\") == \\"\\" >>> longest_palindromic_substring(\\"a\\") == \\"a\\" >>> longest_palindromic_substring(\\"ab\\") in [\\"a\\", \\"b\\"] >>> longest_palindromic_substring(\\"bab\\") == \\"bab\\" >>> longest_palindromic_substring(\\"aba\\") == \\"aba\\" >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" >>> longest_palindromic_substring(\\"racecar\\") == \\"racecar\\" >>> longest_palindromic_substring(\\"forgeeksskeegfor\\") == \\"geeksskeeg\\" >>> longest_palindromic_substring(\\"abacdfgdcaba\\") in [\\"aba\\", \\"cdc\\", \\"aba\\"] >>> longest_palindromic_substring(\\"abcd\\") in [\\"a\\", \\"b\\", \\"c\\", \\"d\\"]","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in the given string s. if not s: return \\"\\" n = len(s) start = 0 max_length = 1 def expand_around_center(left, right): nonlocal start, max_length while left >= 0 and right < n and s[left] == s[right]: current_length = right - left + 1 if current_length > max_length: start = left max_length = current_length left -= 1 right += 1 for i in range(n): # Odd length palindromes expand_around_center(i, i) # Even length palindromes expand_around_center(i, i + 1) return s[start:start + max_length]"},{"question":"def is_valid_palindrome(s: str) -> bool: Checks if the given string is a valid palindrome by considering only alphanumeric characters and ignoring cases. >>> is_valid_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_valid_palindrome(\\"race a car\\") False >>> is_valid_palindrome(\\"\\") True >>> is_valid_palindrome(\\"a\\") True >>> is_valid_palindrome(\\"!!!\\") True >>> is_valid_palindrome(\\"No lemon, no melon\\") True","solution":"def is_valid_palindrome(s): Checks if the given string is a valid palindrome by considering only alphanumeric characters and ignoring cases. Parameters: s (str): The input string to check. Returns: bool: True if the string is a valid palindrome, False otherwise. cleaned_string = ''.join(c.lower() for c in s if c.isalnum()) return cleaned_string == cleaned_string[::-1]"},{"question":"def second_largest(numbers: List[int]) -> int: Returns the second largest number in the list. If the list has fewer than two distinct numbers, returns None. >>> second_largest([10, 4, 3, 2, 10]) 4 >>> second_largest([5, 5, 5, 5]) None >>> second_largest([1, 2]) 1 >>> second_largest([2, 1]) 1 >>> second_largest([10]) None >>> second_largest([-2, -3, -1]) -2 >>> second_largest([0, 1, -1, 0, 2]) 1 >>> second_largest([1000000, 999999, -1000000]) 999999","solution":"def second_largest(numbers): Returns the second largest number in the list. If the list has fewer than two distinct numbers, returns None. if len(numbers) < 2: return None first = second = float('-inf') for num in numbers: if num > first: second = first first = num elif first > num > second: second = num return second if second != float('-inf') else None"},{"question":"def two_sum(array: List[int], target: int) -> bool: Write a function that takes an array of integers and an integer target value and returns whether there are any two distinct indices i and j in the array such that the elements at those indices sum up to the target value. Example: >>> two_sum([1, 2, 3, 4], 5) True >>> two_sum([1, 2, 3, 4], 8) False","solution":"def two_sum(array, target): Returns whether there are two distinct indices i and j in the array such that the elements at those indices sum up to the target value. # Create a dictionary to store the elements and their indices seen = {} # Iterate over the array for i, num in enumerate(array): # Compute the complement that would sum up to the target complement = target - num # Check if the complement is already in seen if complement in seen: return True # Add the current number to seen seen[num] = i # If no such pair is found, return False return False"},{"question":"from collections import Counter def is_permutation_of_palindrome(s: str) -> bool: Determine if the input string is a permutation of a palindrome. Consider spaces and punctuation, but ignore case sensitivity. >>> is_permutation_of_palindrome(\\"Tact Coa\\") True >>> is_permutation_of_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_permutation_of_palindrome(\\" \\") True >>> is_permutation_of_palindrome(\\"a\\") True >>> is_permutation_of_palindrome(\\"abcdefg\\") False >>> is_permutation_of_palindrome(\\"abcdefgg\\") False >>> is_permutation_of_palindrome(\\"Taco cat\\") True >>> is_permutation_of_palindrome(\\"1221 333\\") True pass","solution":"from collections import Counter def is_permutation_of_palindrome(s: str) -> bool: Determine if the input string is a permutation of a palindrome. Consider spaces and punctuation, but ignore case sensitivity. s = s.lower() # consider ignoring case sensitivity count = Counter(c for c in s if c.isalnum()) # consider punctuation, count all alphanumeric characters odd_count = sum(1 for c in count.values() if c % 2 != 0) # For the string to be a permutation of a palindrome, there can be at most one character with an odd count return odd_count <= 1"},{"question":"def subarray_with_zero_sum(arr: List[int]) -> Optional[Tuple[int, int]]: Determines if there is a subarray that sums up to zero and returns the start and end indices of one such subarray. If no such subarray exists, returns None. >>> subarray_with_zero_sum([4, 2, -3, 1, 6]) (1, 3) >>> subarray_with_zero_sum([4, 2, 0, 1, 6]) (2, 2) >>> subarray_with_zero_sum([-3, 2, 3, 1, 6]) None >>> subarray_with_zero_sum([0]) (0, 0) >>> subarray_with_zero_sum([1, 2, -3]) (0, 2) >>> subarray_with_zero_sum([1, 2, 3, -6, 1, 2]) (0, 3) >>> subarray_with_zero_sum([-1, -2, -3, 6]) (0, 3) >>> subarray_with_zero_sum([]) None >>> subarray_with_zero_sum([3, 4, -7, 1, 2, -4, 5, -1, 6]) (0, 2) >>> subarray_with_zero_sum([1, 2, 3, 4, 5]) None # Your code here","solution":"def subarray_with_zero_sum(arr): Determines if there is a subarray that sums up to zero and returns the start and end indices of one such subarray. If no such subarray exists, returns None. sum_indices_map = {} current_sum = 0 for i, num in enumerate(arr): current_sum += num if current_sum == 0: return (0, i) if current_sum in sum_indices_map: return (sum_indices_map[current_sum] + 1, i) sum_indices_map[current_sum] = i return None"},{"question":"def remove_duplicates(arr: List[int]) -> List[int]: Create a function that takes an array of integers as input and returns an array of integers that are in the same order but without any duplicates. >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([1, 1, 1, 1]) [1] >>> remove_duplicates([]) [] >>> remove_duplicates([5, 5, 5, 5]) [5] >>> remove_duplicates([2, 3, 2, 3, 2, 3, 2]) [2, 3] >>> remove_duplicates([1, 2, 1, 3, 1, 4, 1, 5]) [1, 2, 3, 4, 5]","solution":"def remove_duplicates(arr): Returns a list of integers in the same order as input but without any duplicates. seen = set() result = [] for num in arr: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"from typing import List, Tuple def filter_and_sort_primes(lst: List[int]) -> Tuple[List[int], int]: Write a function that accepts a list of integers and returns the list with all its elements removed except for the prime numbers, but with the primes sorted in descending order. Additionally, the function should return the sum of these prime numbers. >>> filter_and_sort_primes([12, 3, 17, 4, 2, 8, 5, 11]) == ([17, 11, 5, 3, 2], 38) >>> filter_and_sort_primes([2, 3, 5, 7]) == ([7, 5, 3, 2], 17) >>> filter_and_sort_primes([1, 4, 6, 8, 10]) == ([], 0) >>> filter_and_sort_primes([-1, -2, -3, 2, 3, 5]) == ([5, 3, 2], 10) >>> filter_and_sort_primes([]) == ([], 0)","solution":"def is_prime(n): if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def filter_and_sort_primes(lst): primes = [x for x in lst if is_prime(x)] primes.sort(reverse=True) prime_sum = sum(primes) return primes, prime_sum"},{"question":"from typing import List def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. >>> is_prime(2) == True >>> is_prime(4) == False >>> is_prime(17) == True >>> is_prime(18) == False def filter_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the provided list of integers. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) == [2, 3, 5, 7] >>> filter_primes([11, 13, 14, 15, 16, 17]) == [11, 13, 17] >>> filter_primes([]) == [] >>> filter_primes([1, 4, 6, 8, 10]) == [] def range_primes(start: int, end: int) -> List[int]: Returns a list of prime numbers within the specified range [start, end]. >>> range_primes(1, 10) == [2, 3, 5, 7] >>> range_primes(10, 20) == [11, 13, 17, 19] >>> range_primes(20, 30) == [23, 29] >>> range_primes(0, 1) == [] >>> range_primes(-10, 2) == [2]","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(numbers): Returns a list of prime numbers from the provided list of integers. return [num for num in numbers if is_prime(num)] def range_primes(start, end): Returns a list of prime numbers within the specified range [start, end]. return filter_primes(range(start, end + 1))"},{"question":"def infix_to_postfix(expression: str) -> str: Converts an infix arithmetic expression to its corresponding postfix expression using the Shunting Yard algorithm. The infix expression may contain the operators +, -, *, /, and parentheses. Parameters: expression (str): A string representing the infix expression. Returns: str: A string representing the postfix expression. Example: >>> infix_to_postfix(\\"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\\") \\"3 4 2 * 1 5 - 2 3 ^ ^ / +\\" >>> infix_to_postfix(\\"10 + 2 * 6\\") \\"10 2 6 * +\\" >>> infix_to_postfix(\\"100 * ( 2 + 12 ) / 14\\") \\"100 2 12 + * 14 /\\" >>> infix_to_postfix(\\"1 + 2 * 3 - 4 / 2\\") \\"1 2 3 * + 4 2 / -\\" >>> infix_to_postfix(\\"( 3 + 4 ) * ( 5 - 2 )\\") \\"3 4 + 5 2 - *\\" >>> infix_to_postfix(\\"3 + 4 - 5 + 6\\") \\"3 4 + 5 - 6 +\\"","solution":"def infix_to_postfix(expression): Converts an infix arithmetic expression to its corresponding postfix expression using the Shunting Yard algorithm. Parameters: expression (str): A string representing the infix expression. Returns: str: A string representing the postfix expression. Example: infix_to_postfix(\\"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\\") = \\"3 4 2 * 1 5 - 2 3 ^ ^ / +\\" infix_to_postfix(\\"10 + 2 * 6\\") = \\"10 2 6 * +\\" infix_to_postfix(\\"100 * ( 2 + 12 ) / 14\\") = \\"100 2 12 + * 14 /\\" def get_precedence(op): precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3} return precedence.get(op, 0) def is_left_associative(op): return op in ('+', '-', '*', '/') output = [] operators = [] tokens = expression.split() for token in tokens: if token.isnumeric(): # If the token is an operand output.append(token) elif token == '(': # If the token is a left parenthesis operators.append(token) elif token == ')': # If the token is a right parenthesis while operators and operators[-1] != '(': output.append(operators.pop()) operators.pop() # Pop the left parenthesis else: # The token is an operator while (operators and operators[-1] != '(' and (get_precedence(operators[-1]) > get_precedence(token) or (get_precedence(operators[-1]) == get_precedence(token) and is_left_associative(token)))): output.append(operators.pop()) operators.append(token) # Pop any remaining operators in the stack while operators: output.append(operators.pop()) return ' '.join(output)"},{"question":"def find_pairs(input_list, target): Returns a list of tuples containing pairs of integers from input_list that sum up to the target value. Each tuple should appear in ascending order (i.e., (min(a, b), max(a, b))) and no duplicate pairs should be included. >>> find_pairs([1, 2, 3, 4, 5, 6], 7) [(1, 6), (2, 5), (3, 4)] >>> find_pairs([1, 2, 3], 10) [] >>> find_pairs([1, 2, 3, 4, 4, 5, 6], 8) [(2, 6), (3, 5), (4, 4)] >>> find_pairs([-3, -2, -1, 0, 1, 2, 3, 4], 1) [(-3, 4), (-2, 3), (-1, 2), (0, 1)] >>> find_pairs([0, 0, 1, -1, 2], 0) [(-1, 1), (0, 0)]","solution":"def find_pairs(input_list, target): Returns a list of tuples, each containing two numbers from input_list that sum to the target value. Each tuple is in the form (min(a,b), max(a,b)) and no duplicate pairs are included. seen = set() pairs = set() for number in input_list: complement = target - number if complement in seen: pairs.add((min(number, complement), max(number, complement))) seen.add(number) return sorted(pairs)"},{"question":"from typing import List def threeSumClosest(nums: List[int], target: int) -> int: Find three integers in a collection such that the sum of the three integers is closest to a given target value. >>> threeSumClosest([2, 3, 5, -2, 8, -1], 3) == 3 >>> threeSumClosest([-1, 2, 1, -4], 1) == 2 >>> threeSumClosest([1, 1, 1, 1], 2) == 3","solution":"from typing import List def threeSumClosest(nums: List[int], target: int) -> int: nums.sort() closest_sum = float('inf') for i in range(len(nums) - 2): left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return closest_sum return closest_sum"},{"question":"def cumulative_sum(input_list): This function takes a list of integers and returns a new list where each element is the cumulative sum of the input list up to that index. Parameters: input_list (list): A list of integers Returns: list: A new list of integers with the cumulative sums >>> cumulative_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> cumulative_sum([0, 2, 4, 0]) [0, 2, 6, 6] >>> cumulative_sum([-1, 1, -2, 2]) [-1, 0, -2, 0] >>> cumulative_sum([-1, 2, -3, 4]) [-1, 1, -2, 2] >>> cumulative_sum([5]) [5] >>> cumulative_sum([]) []","solution":"def cumulative_sum(input_list): This function takes a list of integers and returns a new list where each element is the cumulative sum of the input list up to that index. Parameters: input_list (list): A list of integers Returns: list: A new list of integers with the cumulative sums if not input_list: return [] cumulative_list = [] current_sum = 0 for number in input_list: current_sum += number cumulative_list.append(current_sum) return cumulative_list"},{"question":"def find_majority_element(nums: List[int]) -> int: Write a Python function \`find_majority_element\` that takes a list of integers as input and returns the majority element. The majority element is the one that appears more than n/2 times in the list, where n is the length of the list. If no majority element exists, return \`None\`. >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4]) None","solution":"def find_majority_element(nums): Returns the majority element in the list nums, or None if no majority element exists. The majority element is the one that appears more than n/2 times in the list, where n is the length of the list. count = 0 candidate = None # Boyer-Moore Voting Algorithm for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) # Verify the candidate if nums.count(candidate) > len(nums) // 2: return candidate else: return None"},{"question":"def read_integers(file_path): Reads a file containing a list of integers, one per line. Yields each integer. pass def write_moving_averages(file_path, moving_averages): Writes the moving averages to a file, one per line. pass def calculate_moving_averages(integers, window_size): Calculates the moving averages of a sequence of integers with a specified window size. Uses a generator to yield each moving average. pass def process_file(input_file_path, output_file_path, window_size): Reads integers from the input file, calculates their moving averages with the given window size, and writes the results to the output file. pass # Unit Tests import os def test_read_integers(tmp_path): # Setup input_file = tmp_path / \\"input.txt\\" input_file.write_text(\\"1n2n3n4n5n\\") # Function call and assertion expected_result = [1, 2, 3, 4, 5] result = list(read_integers(str(input_file))) assert result == expected_result def test_calculate_moving_averages(): # Test with multiple windows integers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # Test with window size 1 (should return the same list) expected_result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] result = list(calculate_moving_averages(integers, 1)) assert result == expected_result # Test with window size 2 expected_result = [1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5] result = list(calculate_moving_averages(integers, 2)) assert result == expected_result # Test with window size 3 expected_result = [2, 3, 4, 5, 6, 7, 8, 9] result = list(calculate_moving_averages(integers, 3)) assert result == expected_result def test_write_moving_averages(tmp_path): # Setup output_file = tmp_path / \\"output.txt\\" moving_averages = [1.5, 2.5, 3.5] # Function call write_moving_averages(str(output_file), moving_averages) # Read from file and assertion result = output_file.read_text().strip().split('n') expected_result = ['1.5', '2.5', '3.5'] assert result == expected_result def test_process_file(tmp_path): # Setup input_file = tmp_path / \\"input.txt\\" input_file.write_text(\\"1n2n3n4n5n\\") output_file = tmp_path / \\"output.txt\\" # Function call process_file(str(input_file), str(output_file), window_size=2) # Assertion result = output_file.read_text().strip().split('n') expected_result = ['1.5', '2.5', '3.5', '4.5'] assert result == expected_result","solution":"def read_integers(file_path): Reads a file containing a list of integers, one per line. Yields each integer. with open(file_path, 'r') as file: for line in file: yield int(line.strip()) def write_moving_averages(file_path, moving_averages): Writes the moving averages to a file, one per line. with open(file_path, 'w') as file: for avg in moving_averages: file.write(f\\"{avg}n\\") def calculate_moving_averages(integers, window_size): Calculates the moving averages of a sequence of integers with a specified window size. Uses a generator to yield each moving average. window = [] for number in integers: window.append(number) if len(window) > window_size: window.pop(0) if len(window) == window_size: yield sum(window) / window_size def process_file(input_file_path, output_file_path, window_size): Reads integers from the input file, calculates their moving averages with the given window size, and writes the results to the output file. integers = read_integers(input_file_path) moving_averages = calculate_moving_averages(integers, window_size) write_moving_averages(output_file_path, moving_averages)"},{"question":"def transform_string(s: str) -> str: Transforms a string such that: - Each letter is replaced by the next one in the alphabet ('z' goes to 'a' and 'Z' goes to 'A'). - Digits (0-9) are replaced by their complement to 9 (e.g., '0' with '9', '1' with '8'). - All other characters remain unchanged. >>> transform_string(\\"abcdefghijklmnopqrstuvwxyz\\") == \\"bcdefghijklmnopqrstuvwxyza\\" >>> transform_string(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") == \\"BCDEFGHIJKLMNOPQRSTUVWXYZA\\" >>> transform_string(\\"0123456789\\") == \\"9876543210\\" >>> transform_string(\\"Hello World! 123\\") == \\"Ifmmp Xpsme! 876\\" >>> transform_string(\\"ZzZz1234\\") == \\"AaAa8765\\" >>> transform_string(\\"\\") == \\"\\"","solution":"def transform_string(s): Transforms a string such that: - Each letter is replaced by the next one in the alphabet ('z' goes to 'a' and 'Z' goes to 'A'). - Digits (0-9) are replaced by their complement to 9 (e.g., '0' with '9', '1' with '8'). - All other characters remain unchanged. transformed = [] for char in s: if char.isalpha(): if char == 'z': transformed.append('a') elif char == 'Z': transformed.append('A') else: transformed.append(chr(ord(char) + 1)) elif char.isdigit(): transformed.append(str(9 - int(char))) else: transformed.append(char) return ''.join(transformed)"},{"question":"def recursive_fibonacci(n: int) -> int: Calculates the nth Fibonacci number using recursion. >>> recursive_fibonacci(0) == 0 >>> recursive_fibonacci(1) == 1 >>> recursive_fibonacci(2) == 1 >>> recursive_fibonacci(3) == 2 >>> recursive_fibonacci(4) == 3 >>> recursive_fibonacci(5) == 5 >>> recursive_fibonacci(10) == 55 pass def iterative_fibonacci(n: int) -> int: Calculates the nth Fibonacci number using iteration. >>> iterative_fibonacci(0) == 0 >>> iterative_fibonacci(1) == 1 >>> iterative_fibonacci(2) == 1 >>> iterative_fibonacci(3) == 2 >>> iterative_fibonacci(4) == 3 >>> iterative_fibonacci(5) == 5 >>> iterative_fibonacci(10) == 55 pass","solution":"def recursive_fibonacci(n): Calculates the nth Fibonacci number using recursion. if n <= 0: return 0 elif n == 1: return 1 else: return recursive_fibonacci(n - 1) + recursive_fibonacci(n - 2) def iterative_fibonacci(n): Calculates the nth Fibonacci number using iteration. if n <= 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n+1): a, b = b, a + b return b # Explanation of recursion, its characteristics, and comparison with iteration: ''' Recursion in programming refers to the technique where a function calls itself to solve smaller instances of the same problem until a base case is reached. Essential characteristics of problems suitable for recursive solutions: 1. The problem can be broken down into smaller subproblems of the same type. 2. It has a base case that terminates the recursion. 3. Each recursive call reduces the problem size or brings it closer to the base case. Time Complexity and Space Complexity: - The time complexity of the simple recursive Fibonacci solution is O(2^n) due to redundant calculations. - The space complexity is O(n) due to the call stack. Potential drawbacks of using recursion: - Redundant computations leading to inefficient solutions for problems like Fibonacci. - Stack overflow risk for deeply nested recursions. Ways to minimize recursion issues: - Memoization: Store the results of expensive function calls and reuse when the same inputs occur again. - Tail Recursion: A form of recursion where the recursive call is the last operation, allowing optimization by the compiler. - Transforming recursion to iteration: It can help avoid the drawbacks by using loops and maintaining an explicit stack. Example of memoization (in Python): memo = {} def memoized_fibonacci(n): if n in memo: return memo[n] if n <= 0: return 0 elif n == 1: return 1 else: memo[n] = memoized_fibonacci(n - 1) + memoized_fibonacci(n - 2) return memo[n] '''"},{"question":"def unique_paths_with_obstacles(m, n, matrix): Returns the number of unique paths in an m x n matrix with obstacles >>> unique_paths_with_obstacles(3, 3, [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) 2 >>> unique_paths_with_obstacles(3, 3, [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 6 >>> unique_paths_with_obstacles(3, 3, [ [0, 1, 1], [1, 1, 1], [1, 1, 0] ]) 0 >>> unique_paths_with_obstacles(1, 4, [ [0, 0, 0, 0] ]) 1 >>> unique_paths_with_obstacles(4, 1, [ [0], [0], [0], [0] ]) 1","solution":"def unique_paths_with_obstacles(m, n, matrix): Returns the number of unique paths in an m x n matrix with obstacles if matrix[0][0] == 1 or matrix[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if matrix[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list without using sort(). Parameters: list1 (list): First sorted list of integers. list2 (list): Second sorted list of integers. Returns: list: A new sorted list containing all elements from list1 and list2. >>> merge_sorted_lists([1, 3, 5, 7], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_lists([-1, 5, 10], [2, 7, 15]) [-1, 2, 5, 7, 10, 15] >>> merge_sorted_lists([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_lists([], [4, 5, 6]) [4, 5, 6] >>> merge_sorted_lists([], []) [] >>> merge_sorted_lists([1], [2, 3, 4]) [1, 2, 3, 4] >>> merge_sorted_lists([1, 1, 1], [1, 1]) [1, 1, 1, 1, 1] >>> merge_sorted_lists([-5, -3, -1], [-2, 0, 2]) [-5, -3, -2, -1, 0, 2]","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list without using sort(). Parameters: list1 (list): First sorted list of integers. list2 (list): Second sorted list of integers. Returns: list: A new sorted list containing all elements from list1 and list2. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def generate_fibonacci(n: int) -> List[int]: Generate a list of n Fibonacci numbers. >>> generate_fibonacci(0) [] >>> generate_fibonacci(1) [0] >>> generate_fibonacci(2) [0, 1] >>> generate_fibonacci(5) [0, 1, 1, 2, 3] >>> generate_fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> generate_fibonacci(-5) []","solution":"def generate_fibonacci(n): Returns a list of the first n Fibonacci numbers. if n <= 0: return [] fibonacci_sequence = [0] * n if n > 0: fibonacci_sequence[0] = 0 if n > 1: fibonacci_sequence[1] = 1 for i in range(2, n): fibonacci_sequence[i] = fibonacci_sequence[i - 1] + fibonacci_sequence[i - 2] return fibonacci_sequence"},{"question":"def find_unique_numbers(arr: List[int]) -> Union[List[int], str]: Given an array of integers, find the numbers that appears only once. If there's no such number, return a message indicating so. >>> find_unique_numbers([4, -1, 1, 6, 3, -1, 3, 3]) [4, 1, 6] >>> find_unique_numbers([1, 1, 2, 2, 3, 3]) \\"No unique number found\\" >>> find_unique_numbers([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> find_unique_numbers([1, 2, 1, 2, 3, 3]) \\"No unique number found\\" >>> find_unique_numbers([4]) [4] >>> find_unique_numbers([]) \\"No unique number found\\" >>> find_unique_numbers([-1, -2, -2, -3, -1]) [-3]","solution":"def find_unique_numbers(arr): Returns a list of numbers that appear only once in the given array. If no such number exists, returns an appropriate message. from collections import Counter count = Counter(arr) unique_numbers = [num for num, freq in count.items() if freq == 1] if unique_numbers: return unique_numbers else: return \\"No unique number found\\""},{"question":"def sum_of_digits(num: int) -> int: Calculates the sum of the digits of a given positive integer repeatedly until a single-digit number is obtained. >>> sum_of_digits(5) 5 >>> sum_of_digits(38) 2 >>> sum_of_digits(987654321) 9 >>> sum_of_digits(1111) 4 >>> sum_of_digits(27) 9 >>> sum_of_digits(0) 0","solution":"def sum_of_digits(num): Calculates the sum of the digits of a given positive integer repeatedly until a single-digit number is obtained. Parameters: num (int): A positive integer. Returns: int: The resulting single-digit number. while num >= 10: num = sum(int(digit) for digit in str(num)) return num"},{"question":"def longest_contiguous_subarray(nums: List[int]) -> int: Find the length of the longest contiguous subarray with an equal number of even and odd integers. Args: nums (list): List of non-negative integers Returns: int: Length of the longest contiguous subarray with an equal number of even and odd integers. Examples: >>> longest_contiguous_subarray([1, 2, 3, 4]) 4 >>> longest_contiguous_subarray([1, 1, 2, 2]) 4 >>> longest_contiguous_subarray([1, 2, 3, 5, 6, 7]) 4 >>> longest_contiguous_subarray([2, 4, 6, 8]) 0","solution":"def longest_contiguous_subarray(nums): Find the length of the longest contiguous subarray with an equal number of even and odd integers. Args: nums (list): List of non-negative integers Returns: int: Length of the longest contiguous subarray with an equal number of even and odd integers. max_length = 0 count = 0 count_map = {0: -1} for i, num in enumerate(nums): if num % 2 == 0: count += 1 else: count -= 1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"def simulate_movement(movements): Simulates the movement of an object starting at the origin (0,0) according to a list of movements and returns the final coordinates. Parameters: movements (list of tuple): A list of movements, each represented by a tuple (direction, distance). Returns: tuple: The final coordinates of the object. >>> simulate_movement([('UP', 5), ('RIGHT', 3), ('DOWN', 2), ('LEFT', 4)]) (-1, 3) >>> simulate_movement([('UP', 1), ('LEFT', 1), ('UP', 1), ('LEFT', 1)]) (-2, 2)","solution":"def simulate_movement(movements): Simulates the movement of an object starting at the origin (0,0) according to a list of movements and returns the final coordinates. Parameters: movements (list of tuple): A list of movements, each represented by a tuple (direction, distance). Returns: tuple: The final coordinates of the object. x, y = 0, 0 for direction, distance in movements: if direction == 'UP': y += distance elif direction == 'DOWN': y -= distance elif direction == 'LEFT': x -= distance elif direction == 'RIGHT': x += distance return x, y"},{"question":"from datetime import datetime def birthday_today(people): Given a list of people and their birthdates, returns the names of people whose birthday is today. :param people: List of dictionaries containing 'name' and 'birthdate'. :return: List of names of people with today's birthday. >>> from datetime import datetime >>> people = [ ... {\\"name\\": \\"Alice\\", \\"birthdate\\": \\"1990-05-24\\"}, ... {\\"name\\": \\"Bob\\", \\"birthdate\\": \\"1985-10-16\\"}, ... {\\"name\\": \\"Charlie\\", \\"birthdate\\": \\"1992-01-08\\"}, ... {\\"name\\": \\"David\\", \\"birthdate\\": datetime.now().strftime(\\"%Y-%m-%d\\")}, ... ] >>> birthday_today(people) ['Charlie', 'David'] # Assuming today is January 8 today = datetime.now().strftime(\\"%m-%d\\") return [person['name'] for person in people if person['birthdate'][5:] == today]","solution":"from datetime import datetime def birthday_today(people): Returns a list of names of people whose birthday is today. :param people: List of dictionaries containing 'name' and 'birthdate'. :return: List of names of people with today's birthday. today = datetime.now().strftime(\\"%m-%d\\") return [person['name'] for person in people if person['birthdate'][5:] == today]"},{"question":"from typing import Tuple def separate_alphabets_and_digits(s: str) -> Tuple[str, str]: Given a string containing alphabets and digits, separates the alphabets from the digits and returns a tuple with two elements. The first element should be a string of all the alphabets in the order they appear in the input, and the second element should be a string of all the digits in the order they appear in the input. Parameters: s (str): the input string containing alphabets and digits. Returns: Tuple[str, str]: a tuple where the first element is a string of all the alphabets in the order they appear in the input, and the second element is a string of all the digits in the order they appear in the input. >>> separate_alphabets_and_digits(\\"a1b2c3d4\\") ('abcd', '1234') >>> separate_alphabets_and_digits(\\"abcd\\") ('abcd', '') >>> separate_alphabets_and_digits(\\"1234\\") ('', '1234') >>> separate_alphabets_and_digits(\\"\\") ('', '') >>> separate_alphabets_and_digits(\\"abcde\\") ('abcde', '') >>> separate_alphabets_and_digits(\\"12345\\") ('', '12345') >>> separate_alphabets_and_digits(\\"a1b2c3d\\") ('abcd', '123') >>> separate_alphabets_and_digits(\\"aa11bb22\\") ('aabb', '1122')","solution":"from typing import Tuple def separate_alphabets_and_digits(s: str) -> Tuple[str, str]: Separates the alphabets from the digits in the input string. Parameters: s (str): the input string containing alphabets and digits. Returns: Tuple[str, str]: a tuple where the first element is a string of all the alphabets in the order they appear in the input, and the second element is a string of all the digits in the order they appear in the input. alphabets = ''.join([char for char in s if char.isalpha()]) digits = ''.join([char for char in s if char.isdigit()]) return (alphabets, digits)"},{"question":"def transpose(matrix): Returns the transpose of a given matrix. # Your code here def determinant(matrix): Returns the determinant of the given square matrix. # Your code here def transpose_and_determinant(matrix): Returns the transpose of the matrix and the determinant if it's square, otherwise, an informative message. # Your code here # Test cases def test_transpose_square_matrix(): assert transpose([[1, 2], [3, 4]]) == [[1, 3], [2, 4]] def test_transpose_rectangular_matrix(): assert transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]] def test_determinant_2x2_matrix(): assert determinant([[1, 2], [3, 4]]) == -2 def test_determinant_3x3_matrix(): assert determinant([[1, 2, 3], [0, 1, 4], [5, 6, 0]]) == 1 def test_determinant_1x1_matrix(): assert determinant([[5]]) == 5 def test_transpose_and_determinant_square_matrix(): result = transpose_and_determinant([[1, 2], [3, 4]]) assert result[0] == [[1, 3], [2, 4]] assert result[1] == -2 def test_transpose_and_determinant_rectangular_matrix(): result = transpose_and_determinant([[1, 2, 3], [4, 5, 6]]) assert result[0] == [[1, 4], [2, 5], [3, 6]] assert result[1] == \\"The transposed matrix is not square, so the determinant is not defined.\\"","solution":"def transpose(matrix): Returns the transpose of a given matrix. return [list(row) for row in zip(*matrix)] def determinant(matrix): Returns the determinant of the given square matrix. n = len(matrix) if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(n): submatrix = [row[:c] + row[c+1:] for row in matrix[1:]] det += ((-1)**c) * matrix[0][c] * determinant(submatrix) return det def transpose_and_determinant(matrix): Returns the transpose of the matrix and the determinant if it's square, otherwise, an informative message. transposed = transpose(matrix) if len(transposed) == len(transposed[0]): det = determinant(transposed) return transposed, det else: return transposed, \\"The transposed matrix is not square, so the determinant is not defined.\\""},{"question":"def max_min_subarray(arr: list) -> tuple: Returns the longest contiguous subarray with the largest sum and the subarray with the smallest sum, along with their respective starting and ending indices. Parameters: arr (list): List of integers. Returns: tuple: ((max_sum, max_start, max_end), (min_sum, min_start, min_end)) Examples: >>> max_min_subarray([1, 2, 3, 4, 5]) ((15, 0, 4), (1, 0, 0)) >>> max_min_subarray([-1, -2, -3, -4, -5]) ((-1, 0, 0), (-15, 0, 4)) >>> max_min_subarray([1, -2, 3, 4, -5, 6]) ((8, 2, 5), (-5, 4, 4)) >>> max_min_subarray([7]) ((7, 0, 0), (7, 0, 0)) >>> max_min_subarray([]) (None, None) >>> max_min_subarray(list(range(-1000, 1000))) ((499500, 1000, 1999), (-500500, 0, 999)) pass","solution":"def max_min_subarray(arr): Returns the longest contiguous subarray with the largest sum and the subarray with the smallest sum, along with their respective starting and ending indices. Parameters: arr (list): List of integers. Returns: tuple: ((max_sum, max_start, max_end), (min_sum, min_start, min_end)) n = len(arr) if n == 0: return None, None # Initialize variables for maximum sum subarray max_sum = arr[0] current_max_sum = arr[0] max_start = max_end = 0 temp_start = 0 # Initialize variables for minimum sum subarray min_sum = arr[0] current_min_sum = arr[0] min_start = min_end = 0 temp_min_start = 0 for i in range(1, n): # For maximum sum subarray if current_max_sum < 0: current_max_sum = arr[i] temp_start = i else: current_max_sum += arr[i] if current_max_sum > max_sum: max_sum = current_max_sum max_start = temp_start max_end = i # For minimum sum subarray if current_min_sum > 0: current_min_sum = arr[i] temp_min_start = i else: current_min_sum += arr[i] if current_min_sum < min_sum: min_sum = current_min_sum min_start = temp_min_start min_end = i return (max_sum, max_start, max_end), (min_sum, min_start, min_end)"},{"question":"import random def generate_unique_random_list(n: int) -> list: Generate a list of n unique random integers from 1 to 100. Parameters: n (int): The number of integers to generate. Returns: list: A list of n unique random integers from 1 to 100. Raises: ValueError: If n is greater than 100. >>> generate_unique_random_list(10) [a unique list of 10 integers] >>> generate_unique_random_list(0) [] >>> generate_unique_random_list(100) [a unique list of 100 integers] >>> generate_unique_random_list(101) ValueError: n should not be greater than 100","solution":"import random def generate_unique_random_list(n): Generate a list of n unique random integers from 1 to 100. Parameters: n (int): The number of integers to generate. Returns: list: A list of n unique random integers from 1 to 100. Raises: ValueError: If n is greater than 100. if n > 100: raise ValueError(\\"n should not be greater than 100\\") random_list = random.sample(range(1, 101), n) return random_list"},{"question":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. The robot can only move either down or right at any point in time. Implement this function using dynamic programming. >>> unique_paths(3, 7) 28 >>> unique_paths(3, 2) 3 >>> unique_paths(7, 3) 28 >>> unique_paths(3, 3) 6 >>> unique_paths(1, 1) 1 >>> unique_paths(2, 2) 2 # Create a 2D array (list of lists) to store the number of ways to reach each cell. dp = [[0] * n for _ in range(m)] # Initialize the first row and the first column for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): # The number of ways to reach cell (i, j) is the sum of ways # to reach the cell above it and the cell to the left of it. dp[i][j] = dp[i - 1][j] + dp[i][j - 1] # The bottom-right corner will contain the number of unique paths return dp[m - 1][n - 1]","solution":"def unique_paths(m, n): Calculate the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. # Create a 2D array (list of lists) to store the number of ways to reach each cell. dp = [[0] * n for _ in range(m)] # Initialize the first row and the first column for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): # The number of ways to reach cell (i, j) is the sum of ways # to reach the cell above it and the cell to the left of it. dp[i][j] = dp[i - 1][j] + dp[i][j - 1] # The bottom-right corner will contain the number of unique paths return dp[m - 1][n - 1]"},{"question":"def most_frequent_character(s: str) -> str: Returns the most frequent character in the string. If there is a tie, returns the character that appears first in the string. Ignores case and non-alphabetic characters. >>> most_frequent_character(\\"aabbcc\\") \\"a\\" >>> most_frequent_character(\\"abbccc\\") \\"c\\" >>> most_frequent_character(\\"AAbbCC\\") \\"a\\" >>> most_frequent_character(\\"!!aabb1122cc\\") \\"a\\" >>> most_frequent_character(\\"\\") \\"\\" >>> most_frequent_character(\\"a a a b b c\\") \\"a\\"","solution":"def most_frequent_character(s): Returns the most frequent character in the string s. If there is a tie, returns the character that appears first in the string. Ignores case and non-alphabetic characters. from collections import Counter # Clean the string: remove non-alphabetic characters and convert to lowercase cleaned_string = ''.join(filter(str.isalpha, s)).lower() # Count frequencies of characters counter = Counter(cleaned_string) # Find the most frequent character max_frequency = max(counter.values(), default=0) # find the highest frequency for char in s.lower(): # iterate through original string lowered, in original order if char.isalpha() and counter[char] == max_frequency: return char return \\"\\" # in case there's no alphabetic character in the string"},{"question":"def filter_students_by_grade(students: list, grade: str) -> list: Filters students by grade and sorts them by averageScore in descending order. If students have the same averageScore, sorts them alphabetically by name. Parameters: students (list of dict): List of student records. grade (str): The grade to filter by. Returns: list: Sorted list of student names who have the specified grade. str: Error message if no students have the specified grade. Example: >>> students = [ >>> { \\"name\\": \\"Alice\\", \\"grade\\": \\"A\\", \\"averageScore\\": 92 }, >>> { \\"name\\": \\"Bob\\", \\"grade\\": \\"B\\", \\"averageScore\\": 85 }, >>> { \\"name\\": \\"Charlie\\", \\"grade\\": \\"A\\", \\"averageScore\\": 88 }, >>> { \\"name\\": \\"David\\", \\"grade\\": \\"B\\", \\"averageScore\\": 91 }, >>> { \\"name\\": \\"Eve\\", \\"grade\\": \\"A\\", \\"averageScore\\": 92 } >>> ] >>> filter_students_by_grade(students, 'A') [ { \\"name\\": \\"Alice\\", \\"grade\\": \\"A\\", \\"averageScore\\": 92 }, { \\"name\\": \\"Eve\\", \\"grade\\": \\"A\\", \\"averageScore\\": 92 }, { \\"name\\": \\"Charlie\\", \\"grade\\": \\"A\\", \\"averageScore\\": 88 } ]","solution":"def filter_students_by_grade(students, grade): Filters students by grade and sorts them by averageScore in descending order. If students have the same averageScore, sorts them alphabetically by name. Parameters: students (list of dict): List of student records. grade (str): The grade to filter by. Returns: list: Sorted list of student names who have the specified grade. str: Error message if no students have the specified grade. filtered_students = [student for student in students if student['grade'] == grade] if not filtered_students: return \\"No students found with the specified grade.\\" sorted_students = sorted(filtered_students, key=lambda x: (-x['averageScore'], x['name'])) return sorted_students"},{"question":"def squares_of_positives(numbers: List[int]) -> Dict[int, int]: Takes a list of integers as input and returns a dictionary where the keys are the integers and the values are the square of the corresponding integers only for those integers which are positive. >>> squares_of_positives([1, 2, 3]) {1: 1, 2: 4, 3: 9} >>> squares_of_positives([0, 1, 2]) {1: 1, 2: 4} >>> squares_of_positives([-1, -2, 3]) {3: 9} >>> squares_of_positives([0, -1, -2]) {} >>> squares_of_positives([]) {} >>> squares_of_positives([0, 1, -1, 2, -2, 3]) {1: 1, 2: 4, 3: 9}","solution":"def squares_of_positives(numbers): Returns a dictionary where the keys are the positive integers from the input list and the values are their corresponding squares. return {num: num ** 2 for num in numbers if num > 0}"},{"question":"def find_primes(start: int, end: int) -> List[int]: Returns a list of prime numbers between the given start and end (inclusive). >>> find_primes(10, 30) == [11, 13, 17, 19, 23, 29] >>> find_primes(1, 10) == [2, 3, 5, 7] >>> find_primes(30, 40) == [31, 37] >>> find_primes(50, 60) == [53, 59] >>> find_primes(5, 5) == [5] >>> find_primes(11, 11) == [11] >>> find_primes(29, 29) == [29] >>> find_primes(0, 1) == [] >>> find_primes(4, 6) == [5] >>> find_primes(14, 16) == [] >>> find_primes(-10, 2) == [2] >>> find_primes(-10, 0) == [] >>> find_primes(30, 10) == [] >>> find_primes(10, -5) == []","solution":"def find_primes(start, end): Returns a list of prime numbers between the given start and end (inclusive). def is_prime(n): if n <= 1: return False for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return False return True primes = [n for n in range(start, end + 1) if is_prime(n)] return primes"},{"question":"from typing import List def is_palindrome(s: str) -> bool: Determines if a given string is a valid palindrome, considering only alphanumeric characters and ignoring cases. Steps: - Filter out non-alphanumeric characters and convert to lower case. - Check if the sanitized string is a palindrome. >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"Hello, World!\\") False >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"RaceCar\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"12345\\") False >>> is_palindrome(\\"1a2b2a1\\") True >>> is_palindrome(\\"1a2b3c4d\\") False","solution":"def is_palindrome(s): Checks if a given string is a valid palindrome, considering only alphanumeric characters and ignoring cases. # Step 1: Filter out non-alphanumeric characters and convert to lower case filtered_chars = [char.lower() for char in s if char.isalnum()] # Step 2: Check if the filtered list is a palindrome return filtered_chars == filtered_chars[::-1]"},{"question":"def is_prime(num: int) -> bool: Determine if a given number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False def find_largest_prime(n: int) -> int: Finds the largest prime number less than or equal to n. >>> find_largest_prime(10) 7 >>> find_largest_prime(20) 19 >>> find_largest_prime(2) 2 >>> find_largest_prime(1) None","solution":"def is_prime(num): Checks if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def find_largest_prime(n): Finds the largest prime number less than or equal to n. for i in range(n, 1, -1): if is_prime(i): return i return None"},{"question":"from typing import List def product_of_positives(integers: List[int]) -> int: Returns the product of all positive integers in the list. If the list is empty or does not contain any positive integers, returns 1. >>> product_of_positives([-1, -2, -3]) 1 >>> product_of_positives([1, -2, 3, 0, -4]) 3 >>> product_of_positives([2, 4, 6]) 48 >>> product_of_positives([]) 1 >>> product_of_positives([5]) 5 >>> product_of_positives([-5]) 1 >>> product_of_positives([0, 0, 0]) 1 >>> product_of_positives([2, 0, 3]) 6 >>> product_of_positives([0]) 1","solution":"from typing import List def product_of_positives(integers: List[int]) -> int: Returns the product of all positive integers in the list. If the list is empty or does not contain any positive integers, returns 1. product = 1 has_positive = False for num in integers: if num > 0: product *= num has_positive = True return product if has_positive else 1"},{"question":"def parse_string(s: str) -> dict: Parse the input string and return a dictionary with lists of digits, words, and special characters. Parameters: s (str): The input string to parse. Returns: dict: A dictionary with keys 'digits', 'words', and 'special_chars'. Examples: >>> parse_string(\\"abc 123 !@#\\") {'digits': ['123'], 'words': ['abc'], 'special_chars': ['!', '@', '#']} >>> parse_string(\\"welcome to 2021, the year of challenges!\\") {'digits': ['2021'], 'words': ['welcome', 'to', 'the', 'year', 'of', 'challenges'], 'special_chars': [',', '!']} >>> parse_string(\\"test1234test\\") {'digits': ['1234'], 'words': ['test', 'test'], 'special_chars': []} >>> parse_string(\\"hello world\\") {'digits': [], 'words': ['hello', 'world'], 'special_chars': []} >>> parse_string(\\"!@#%^&*()\\") {'digits': [], 'words': [], 'special_chars': ['!', '@', '#', '', '%', '^', '&', '*', '(', ')']}","solution":"import re def parse_string(s: str) -> dict: Parse the input string and return a dictionary with lists of digits, words, and special characters. Parameters: s (str): The input string to parse. Returns: dict: A dictionary with keys 'digits', 'words', and 'special_chars'. digits = re.findall(r'd+', s) words = re.findall(r'[a-zA-Z]+', s) special_chars = re.findall(r'[^a-zA-Z0-9s]', s) return { 'digits': digits, 'words': words, 'special_chars': special_chars }"},{"question":"def sum_of_ones_in_hex_binary(lst): Takes a list of integers, converts each to its hexadecimal equivalent, counts the number of 1's in its binary representation, and returns the sum of these counts for all elements in the list. >>> sum_of_ones_in_hex_binary([10]) == 2 >>> sum_of_ones_in_hex_binary([15]) == 4 >>> sum_of_ones_in_hex_binary([10, 15]) == 6 >>> sum_of_ones_in_hex_binary([1, 2, 3]) == 4 >>> sum_of_ones_in_hex_binary([0]) == 0 >>> sum_of_ones_in_hex_binary([255, 256]) == 9 >>> sum_of_ones_in_hex_binary([]) == 0","solution":"def count_ones_in_binary_of_hex(num): Takes an integer number and returns the number of 1's in the binary representation of its hexadecimal equivalent. # Convert to hexadecimal and remove '0x' prefix hex_num = hex(num)[2:] # Convert each hexadecimal digit to its binary form and count the '1's one_count = sum(bin(int(digit, 16)).count('1') for digit in hex_num) return one_count def sum_of_ones_in_hex_binary(lst): Takes a list of integers, converts each to its hexadecimal equivalent, counts the number of 1's in its binary representation, and returns the sum of these counts for all elements in the list. total_ones = sum(count_ones_in_binary_of_hex(num) for num in lst) return total_ones"},{"question":"[Completion Task in Python] def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression string containing integers and the plus (+) and minus (-) operators and returns the result. >>> evaluate_expression(\\"1+2\\") 3 >>> evaluate_expression(\\"5-3\\") 2 >>> evaluate_expression(\\"12+34-5+67\\") 108 >>> evaluate_expression(\\"42\\") 42 >>> evaluate_expression(\\"10+20+30-10-5+3\\") 48 >>> evaluate_expression(\\"5-10\\") -5","solution":"def evaluate_expression(expression): Evaluates a mathematical expression string containing integers and the plus (+) and minus (-) operators and returns the result. total = 0 current_number = 0 operator = '+' for char in expression: if char.isdigit(): current_number = current_number * 10 + int(char) else: if operator == '+': total += current_number elif operator == '-': total -= current_number operator = char current_number = 0 # To process the last number if operator == '+': total += current_number elif operator == '-': total -= current_number return total"},{"question":"import time import random class NetworkPacket: def __init__(self, traffic_type: str, source_ip: str, dest_ip: str): self.traffic_type = traffic_type self.source_ip = source_ip self.dest_ip = dest_ip class NetworkManagementSystem: def __init__(self): self.network_statistics = {} self.qos_policies = { \\"HTTP\\": \\"High\\", \\"FTP\\": \\"Medium\\", \\"Streaming\\": \\"Low\\" } def capture_packet(self) -> NetworkPacket: Capture a network packet with simulated logic. Returns a NetworkPacket instance with traffic type, source and destination IP addresses. Example: packet = network_system.capture_packet() >>> packet.traffic_type in [\\"HTTP\\", \\"FTP\\", \\"Streaming\\"] >>> packet.source_ip.startswith(\\"192.168.0.\\") >>> packet.dest_ip.startswith(\\"192.168.1.\\") pass def process_packet(self, packet: NetworkPacket): Process the captured network packet applying QoS policies. Logs the packet type and applies the corresponding QoS policy. Example: packet = NetworkPacket(\\"HTTP\\", \\"192.168.0.1\\", \\"192.168.1.1\\") network_system.process_packet(packet) >>> network_system.network_statistics[\\"HTTP\\"] == 1 pass def monitor_network_traffic(self): Continuously monitor the network traffic by capturing and processing packets in real-time. while True: packet = self.capture_packet() self.process_packet(packet) time.sleep(1) # Simulate time delay for capturing next packet def main(): Initialize the network management system and start monitoring network traffic. network_system = NetworkManagementSystem() network_system.monitor_network_traffic() if __name__ == \\"__main__\\": main() from solution import NetworkManagementSystem, NetworkPacket def test_capture_packet(): network_system = NetworkManagementSystem() packet = network_system.capture_packet() assert packet.traffic_type in [\\"HTTP\\", \\"FTP\\", \\"Streaming\\"] assert packet.source_ip.startswith(\\"192.168.0.\\") assert packet.dest_ip.startswith(\\"192.168.1.\\") def test_process_packet(): network_system = NetworkManagementSystem() packet = NetworkPacket(\\"HTTP\\", \\"192.168.0.1\\", \\"192.168.1.1\\") network_system.process_packet(packet) assert network_system.network_statistics[\\"HTTP\\"] == 1 def test_qos_policy_assignment(): network_system = NetworkManagementSystem() packet = NetworkPacket(\\"Streaming\\", \\"192.168.0.1\\", \\"192.168.1.1\\") network_system.process_packet(packet) assert network_system.network_statistics[\\"Streaming\\"] == 1 def test_unknown_traffic_type(): network_system = NetworkManagementSystem() packet = NetworkPacket(\\"Unknown\\", \\"192.168.0.1\\", \\"192.168.1.1\\") network_system.process_packet(packet) assert network_system.network_statistics[\\"Unknown\\"] == 1","solution":"# Import necessary libraries import time import random class NetworkPacket: def __init__(self, traffic_type, source_ip, dest_ip): self.traffic_type = traffic_type self.source_ip = source_ip self.dest_ip = dest_ip class NetworkManagementSystem: def __init__(self): self.network_statistics = {} self.qos_policies = { \\"HTTP\\": \\"High\\", \\"FTP\\": \\"Medium\\", \\"Streaming\\": \\"Low\\" } def capture_packet(self): # Simulated packet capturing logic traffic_types = [\\"HTTP\\", \\"FTP\\", \\"Streaming\\"] packet = NetworkPacket( traffic_type=random.choice(traffic_types), source_ip=f\\"192.168.0.{random.randint(1, 255)}\\", dest_ip=f\\"192.168.1.{random.randint(1, 255)}\\" ) return packet def process_packet(self, packet): traffic_type = packet.traffic_type source_ip = packet.source_ip dest_ip = packet.dest_ip # Log network traffic for analysis if traffic_type not in self.network_statistics: self.network_statistics[traffic_type] = 0 self.network_statistics[traffic_type] += 1 # Apply QoS policy qos = self.qos_policies.get(traffic_type, \\"Unknown\\") print(f\\"Processing packet: {traffic_type}, QoS: {qos}, Source: {source_ip}, Destination: {dest_ip}\\") def monitor_network_traffic(self): while True: packet = self.capture_packet() self.process_packet(packet) time.sleep(1) # Simulate time delay for capturing next packet # Start monitoring network traffic def main(): network_system = NetworkManagementSystem() network_system.monitor_network_traffic() if __name__ == \\"__main__\\": main()"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class DoublyListNode: def __init__(self, val=0, prev=None, next_=None): self.val = val self.prev = prev self.next = next_ def bst_to_doubly_list(root): Convert a binary search tree (BST) into a doubly linked list in-place, following an in-order traversal. Time complexity: O(n) Space complexity: O(n) due to recursion stack >>> bst_to_doubly_list(None) is None True >>> head = bst_to_doubly_list(TreeNode(1)) >>> list_to_array(head) == [1] True >>> root = TreeNode(2) >>> root.left = TreeNode(1) >>> root.right = TreeNode(3) >>> head = bst_to_doubly_list(root) >>> list_to_array(head) == [1, 2, 3] True >>> root = TreeNode(4) >>> root.left = TreeNode(2) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(3) >>> head = bst_to_doubly_list(root) >>> list_to_array(head) == [1, 2, 3, 4, 5] True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class DoublyListNode: def __init__(self, val=0, prev=None, next_=None): self.val = val self.prev = prev self.next = next_ def bst_to_doubly_list(root): if not root: return None def inorder_traversal(node): nonlocal last, head if not node: return inorder_traversal(node.left) if last: last.next = DoublyListNode(node.val) last.next.prev = last last = last.next else: head = DoublyListNode(node.val) last = head inorder_traversal(node.right) last = None head = None inorder_traversal(root) return head"},{"question":"def custom_sort(arr: List[int]) -> List[int]: Sort a list of integers in ascending order without using built-in sort function. >>> custom_sort([34, 2, 25, 16, 7]) [2, 7, 16, 25, 34] >>> custom_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> custom_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> custom_sort([]) [] >>> custom_sort([1]) [1] >>> custom_sort([3, 3, 2, 2, 1, 1]) [1, 1, 2, 2, 3, 3] >>> custom_sort([10, -1, 2, -22, 5]) [-22, -1, 2, 5, 10]","solution":"def custom_sort(arr): Sorts a list of integers in ascending order using bubble sort algorithm. n = len(arr) # Bubble sort for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr"},{"question":"def filter_and_sort_primes(lst: List[int]) -> List[int]: Filters the prime numbers from the list and sorts them in descending order. >>> filter_and_sort_primes([10, 3, 5, 8, 15, 2]) [5, 3, 2] >>> filter_and_sort_primes([4, 6, 8, 10, 15]) [] >>> filter_and_sort_primes([11, 13, 5, 7, 3]) [13, 11, 7, 5, 3] >>> filter_and_sort_primes([]) [] >>> filter_and_sort_primes([17]) [17] >>> filter_and_sort_primes([-1, 0, 2, 3]) [3, 2] pass","solution":"def is_prime(n): Helper function to check if a number is a prime number. if n <= 1: return False if n == 2: return True # 2 is the only even prime number if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def filter_and_sort_primes(lst): Filters the prime numbers from the list and sorts them in descending order. primes = [num for num in lst if is_prime(num)] primes.sort(reverse=True) return primes"},{"question":"def is_anagram(s1: str, s2: str) -> bool: Determines if s1 is an anagram of s2. Case-sensitive and ignores non-alphabetic characters. >>> is_anagram(\\"listen\\", \\"silent\\") True >>> is_anagram(\\"Listen\\", \\"Silent\\") False >>> is_anagram(\\"a!b?c\\", \\"cba\\") True >>> is_anagram(\\"abc\\", \\"abcd\\") False >>> is_anagram(\\"aabb\\", \\"ab\\") False >>> is_anagram(\\"conversation\\", \\"voices rant on\\") True >>> is_anagram(\\"hello\\", \\"world\\") False","solution":"def is_anagram(s1, s2): Determines if s1 is an anagram of s2. Case-sensitive and ignores non-alphabetic characters. def filter_and_count(s): count = {} for char in s: if char.isalpha(): if char in count: count[char] += 1 else: count[char] = 1 return count count1 = filter_and_count(s1) count2 = filter_and_count(s2) return count1 == count2"},{"question":"class FileSystem: def __init__(self): Initialize the file system, stored as a dictionary self.files = {} def create(self, file_name): Create a new file with the specified name. Raise an error if the file already exists. >>> fs = FileSystem() >>> fs.create(\\"file1\\") >>> fs.create(\\"file1\\") # raises FileExistsError pass def write(self, file_name, data): Write the specified data to the file. Raise an error if the file does not exist. >>> fs = FileSystem() >>> fs.create(\\"file2\\") >>> fs.write(\\"file2\\", \\"Hello, world!\\") >>> fs.write(\\"file3\\", \\"This should raise an error\\") # raises FileNotFoundError pass def read(self, file_name): Read and return the data from the file. Raise an error if the file does not exist. >>> fs = FileSystem() >>> fs.create(\\"file3\\") >>> fs.write(\\"file3\\", \\"Test read\\") >>> fs.read(\\"file4\\") # raises FileNotFoundError pass def delete(self, file_name): Delete the specified file. Raise an error if the file does not exist. >>> fs = FileSystem() >>> fs.create(\\"file4\\") >>> fs.delete(\\"file4\\") >>> fs.delete(\\"file4\\") # raises FileNotFoundError pass","solution":"class FileSystem: def __init__(self): # Initialize the file system, stored as a dictionary self.files = {} def create(self, file_name): Create a new file with the specified name. Raise an error if the file already exists. if file_name in self.files: raise FileExistsError(f\\"File '{file_name}' already exists.\\") self.files[file_name] = \\"\\" def write(self, file_name, data): Write the specified data to the file. Raise an error if the file does not exist. if file_name not in self.files: raise FileNotFoundError(f\\"File '{file_name}' does not exist.\\") self.files[file_name] = data def read(self, file_name): Read and return the data from the file. Raise an error if the file does not exist. if file_name not in self.files: raise FileNotFoundError(f\\"File '{file_name}' does not exist.\\") return self.files[file_name] def delete(self, file_name): Delete the specified file. Raise an error if the file does not exist. if file_name not in self.files: raise FileNotFoundError(f\\"File '{file_name}' does not exist.\\") del self.files[file_name]"},{"question":"def read_file(file_path): Read the contents of the file specified by file_path. Returns the contents as a string. Handles FileNotFoundError if file is not found. pass def clean_text(text): Convert text to lowercase and remove punctuation. >>> clean_text(\\"Hello, World!\\") 'hello world' >>> clean_text(\\"Python is fun. Isn't it?\\") 'python is fun isnt it' pass def remove_stop_words(words, stop_words): Remove stop words from a list of words. >>> remove_stop_words([\\"this\\", \\"is\\", \\"a\\", \\"test\\"], {\\"is\\", \\"a\\"}) ['this', 'test'] pass def count_words(text): Count the occurrences of each word in the given text. >>> count_words(\\"hello hello world\\") {'hello': 2, 'world': 1} pass def display_top_words(word_count, top_n): Display the top N most frequent words along with their frequencies. Formats the output as \\"1. word - frequency\\" pass def main(file_path, top_n, ignore_stop_words=False): Main function to read the file, process the text, and display the top N frequent words. file_path: Path to the text file to analyze. top_n: Number of top frequent words to display. ignore_stop_words: Whether to ignore common stop words or not. pass if __name__ == \\"__main__\\": if len(sys.argv) < 3: print(\\"Usage: python word_frequency.py <file_path> <top_n> [--ignore-stop-words]\\") sys.exit(1) file_path = sys.argv[1] try: top_n = int(sys.argv[2]) except ValueError: print(\\"Error: The number of top words to display must be an integer.\\") sys.exit(1) ignore_stop_words = '--ignore-stop-words' in sys.argv main(file_path, top_n, ignore_stop_words)","solution":"import sys import collections import string def read_file(file_path): try: with open(file_path, 'r', encoding='utf-8') as file: return file.read() except FileNotFoundError: print(f\\"Error: The file {file_path} was not found.\\") sys.exit(1) def clean_text(text): text = text.lower() text = text.translate(str.maketrans('', '', string.punctuation)) return text def remove_stop_words(words, stop_words): return [word for word in words if word not in stop_words] def count_words(text): words = text.split() word_count = collections.Counter(words) return word_count def display_top_words(word_count, top_n): top_words = word_count.most_common(top_n) for index, (word, count) in enumerate(top_words): print(f\\"{index + 1}. {word} - {count}\\") def main(file_path, top_n, ignore_stop_words=False): stop_words = set(['the', 'is', 'in', 'and', 'of', 'to', 'a', 'with']) text = read_file(file_path) cleaned_text = clean_text(text) words = cleaned_text.split() if ignore_stop_words: words = remove_stop_words(words, stop_words) word_count = count_words(' '.join(words)) display_top_words(word_count, top_n) if __name__ == \\"__main__\\": if len(sys.argv) < 3: print(\\"Usage: python word_frequency.py <file_path> <top_n> [--ignore-stop-words]\\") sys.exit(1) file_path = sys.argv[1] try: top_n = int(sys.argv[2]) except ValueError: print(\\"Error: The number of top words to display must be an integer.\\") sys.exit(1) ignore_stop_words = '--ignore-stop-words' in sys.argv main(file_path, top_n, ignore_stop_words)"},{"question":"def is_valid_identifier(identifier: str) -> bool: Determines if the provided string is a valid Python identifier. Args: identifier (str): The string to be checked. Returns: bool: True if the identifier is valid, False otherwise. >>> is_valid_identifier(\\"variable\\") True >>> is_valid_identifier(\\"_variable\\") True >>> is_valid_identifier(\\"123variable\\") False >>> is_valid_identifier(\\"variable-1\\") False","solution":"def is_valid_identifier(identifier): Determines if the provided string is a valid Python identifier. Args: identifier (str): The string to be checked. Returns: bool: True if the identifier is valid, False otherwise. # Check if identifier is empty if not identifier: return False # Check if identifier starts with a letter (A-Z, a-z) or an underscore (_) if not (identifier[0].isalpha() or identifier[0] == '_'): return False # Check if the rest of the identifier consists of letters, digits, or underscores for char in identifier[1:]: if not (char.isalnum() or char == '_'): return False return True"},{"question":"def reverse_digits(n: int) -> List[int]: Returns the digits of a non-negative integer in reverse order. Args: n (int): A non-negative integer. Returns: List[int]: A list of digits in reverse order. >>> reverse_digits(0) [0] >>> reverse_digits(5) [5] >>> reverse_digits(12345) [5, 4, 3, 2, 1] >>> reverse_digits(987654) [4, 5, 6, 7, 8, 9] >>> reverse_digits(1000) [0, 0, 0, 1] >>> reverse_digits(123456789012345) [5, 4, 3, 2, 1, 0, 9, 8, 7, 6, 5, 4, 3, 2, 1] pass","solution":"def reverse_digits(n): Returns the digits of a non-negative integer in reverse order. Args: n (int): A non-negative integer. Returns: List[int]: A list of digits in reverse order. return [int(digit) for digit in str(n)][::-1]"},{"question":"def max_product_of_two(nums): Returns the maximum product of two integers from the array nums. Args: nums: List[int] - A list of integers. Returns: int: The maximum product of two integers. Raises: ValueError: If the list contains fewer than two integers. Examples: >>> max_product_of_two([3, 5, -2, 9, -10]) 90 >>> max_product_of_two([-1, -3, -4, 2, 0, -2]) 12","solution":"def max_product_of_two(nums): Returns the maximum product of two integers from the array nums. if len(nums) < 2: raise ValueError(\\"List must contain at least two integers\\") max1 = max2 = float('-inf') min1 = min2 = float('inf') for num in nums: if num > max1: max2 = max1 max1 = num elif num > max2: max2 = num if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num return max(max1 * max2, min1 * min2)"},{"question":"from collections import Counter from typing import Tuple def minimum_window_substring(s: str, t: str) -> str: Find the minimum window substring of \`s\` containing all characters of \`t\`. :param s: The string to search within. :param t: The string containing characters to be found in \`s\`. :return: The minimum window substring or an empty string if no such window exists. Examples: >>> minimum_window_substring(\\"ADOBECODEBANC\\", \\"ABC\\") 'BANC' >>> minimum_window_substring(\\"a\\", \\"a\\") 'a' >>> minimum_window_substring(\\"a\\", \\"aa\\") '' def test_example_1(): assert minimum_window_substring(\\"ADOBECODEBANC\\", \\"ABC\\") == \\"BANC\\" def test_example_2(): assert minimum_window_substring(\\"a\\", \\"a\\") == \\"a\\" def test_example_3(): assert minimum_window_substring(\\"a\\", \\"aa\\") == \\"\\" def test_no_occurence(): assert minimum_window_substring(\\"ADOBECODEBANC\\", \\"XYZ\\") == \\"\\" def test_entire_string(): assert minimum_window_substring(\\"aa\\", \\"aa\\") == \\"aa\\" def test_single_character_multiple_times(): assert minimum_window_substring(\\"aaabcabdabce\\", \\"abc\\") == \\"abc\\" def test_large_input_with_no_solution(): long_string = \\"x\\" * 10**5 substring = \\"a\\" assert minimum_window_substring(long_string, substring) == \\"\\" def test_large_input_with_solution(): long_string = \\"x\\" * 10**5 + \\"a\\" + \\"x\\" * 10**5 substring = \\"a\\" assert minimum_window_substring(long_string, substring) == \\"a\\"","solution":"from collections import Counter def minimum_window_substring(s: str, t: str) -> str: Find the minimum window substring of \`s\` containing all characters of \`t\`. :param s: The string to search within. :param t: The string containing characters to be found in \`s\`. :return: The minimum window substring or an empty string if no such window exists. Examples: >>> minimum_window_substring(\\"ADOBECODEBANC\\", \\"ABC\\") 'BANC' >>> minimum_window_substring(\\"a\\", \\"a\\") 'a' >>> minimum_window_substring(\\"a\\", \\"aa\\") '' if not s or not t: return \\"\\" dict_t = Counter(t) required = len(dict_t) l, r = 0, 0 formed = 0 window_counts = {} ans = float(\\"inf\\"), None, None # window length, left, right while r < len(s): character = s[r] window_counts[character] = window_counts.get(character, 0) + 1 if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 while l <= r and formed == required: character = s[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1]:ans[2] + 1]"},{"question":"def square_digits(num: int) -> int: Squares each digit of the input non-negative integer and concatenates the results as a new integer. >>> square_digits(9119) # 81, 1, 1, 81 => 811181 811181 >>> square_digits(5) # 25 25 >>> square_digits(0) # 0 0 >>> square_digits(1111) # 1, 1, 1, 1 => 1111 1111 >>> square_digits(1234) # 1, 4, 9, 16 => 14916 14916 >>> square_digits(10) # 1, 0 => 10 10 >>> square_digits(99) # 81, 81 => 8181 8181","solution":"def square_digits(num): Squares each digit of the input non-negative integer and concatenates the results as a new integer. result = 0 factor = 1 digits = [] while num > 0: digit = num % 10 num //= 10 digits.append(digit) for digit in reversed(digits): squared_digit = digit * digit result = result * (10 ** (len(str(squared_digit)))) + squared_digit return result"},{"question":"def find_missing_number(nums: List[int]) -> int: Given a list of integers representing a sequence of consecutive numbers with exactly one number missing, return the missing number. >>> find_missing_number([1, 2, 3, 5]) == 4 >>> find_missing_number([10, 11, 12, 14, 15]) == 13 >>> find_missing_number([1, 3]) == 2 >>> find_missing_number([4, 6, 5, 7, 9]) == 8 >>> find_missing_number([20, 21, 23, 24]) == 22","solution":"def find_missing_number(nums): Given a list of integers representing a sequence of consecutive numbers with exactly one number missing, return the missing number. n = len(nums) + 1 expected_sum = n * (nums[0] + nums[-1]) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"def repeat_elements(lst, k): Returns a new list where each element of the original list is repeated k times consecutively. Parameters: lst (list): The list of integers. k (int): The number of times each element should be repeated. Returns: list: A new list with each element repeated k times.","solution":"def repeat_elements(lst, k): Returns a new list where each element of the original list is repeated k times consecutively. Parameters: lst (list): The list of integers. k (int): The number of times each element should be repeated. Returns: list: A new list with each element repeated k times. result = [] for item in lst: result.extend([item] * k) return result"},{"question":"def reverse_words_order_and_swap_cases(s: str) -> str: Reverses the order of words in a string and swaps the case of each letter. :param s: Input string containing words. :return: A new string with the order of words reversed and the cases swapped. >>> reverse_words_order_and_swap_cases(\\"Hello World\\") 'wORLD hELLO' >>> reverse_words_order_and_swap_cases(\\"Python\\") 'pYTHON' >>> reverse_words_order_and_swap_cases(\\"HELLO WORLD\\") 'world hello' >>> reverse_words_order_and_swap_cases(\\"hello world\\") 'WORLD HELLO' >>> reverse_words_order_and_swap_cases(\\"HeLLo WoRLD\\") 'wOrld hEllO'","solution":"def reverse_words_order_and_swap_cases(s): Reverses the order of words in a string and swaps the case of each letter. :param s: Input string containing words. :return: A new string with the order of words reversed and the cases swapped. # Split the string into words words = s.split() # Reverse the order of words reversed_words = words[::-1] # Join the words back into a string reversed_string = ' '.join(reversed_words) # Swap the cases of each letter swapped_case_string = reversed_string.swapcase() return swapped_case_string"},{"question":"def substring_count(main_str: str, sub_str: str) -> int: Returns the number of times the substring appears in the given string. >>> substring_count(\\"ababcabcabc\\", \\"abc\\") 3 >>> substring_count(\\"aaaa\\", \\"aa\\") 3 >>> substring_count(\\"hello world\\", \\"o\\") 2 >>> substring_count(\\"hello world\\", \\"hello\\") 1 >>> substring_count(\\"hello world\\", \\"world\\") 1 >>> substring_count(\\"hello world\\", \\"x\\") 0 >>> substring_count(\\"\\", \\"x\\") 0 >>> substring_count(\\"aaaaaa\\", \\"\\") 7 # Consider cases with empty substring, expecting length + 1","solution":"def substring_count(main_str, sub_str): Returns the number of times the substring appears in the given string. count = 0 for i in range(len(main_str) - len(sub_str) + 1): if main_str[i:i+len(sub_str)] == sub_str: count += 1 return count # Example usage: # print(substring_count(\\"ababcabcabc\\", \\"abc\\")) # Expected output: 3"},{"question":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_squared_error def linear_regression_model(file_path, target_column, test_size=0.25, random_state=42): This function reads a dataset from a csv file, separates features and target variables, divides the dataset into training and testing subsets, and fits a Linear Regression model. Parameters: - file_path (str): Path to the csv file containing the dataset. - target_column (str): Name of the target column. - test_size (float): Proportion of the dataset to include in the test split. - random_state (int): Seed used by the random number generator. Returns: - model (LinearRegression): Trained Linear Regression model. - X_train, X_test, y_train, y_test: Training and testing sets. - y_pred (array): Predictions for the test set. - mse (float): Mean squared error of the model predictions.","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_squared_error def linear_regression_model(file_path, target_column, test_size=0.25, random_state=42): This function reads a dataset from a csv file, separates features and target variables, divides the dataset into training and testing subsets, and fits a Linear Regression model. Parameters: - file_path (str): Path to the csv file containing the dataset. - target_column (str): Name of the target column. - test_size (float): Proportion of the dataset to include in the test split. - random_state (int): Seed used by the random number generator. Returns: - model (LinearRegression): Trained Linear Regression model. - X_train, X_test, y_train, y_test: Training and testing sets. - y_pred (array): Predictions for the test set. - mse (float): Mean squared error of the model predictions. # Read the dataset df = pd.read_csv(file_path) # Separate features and target X = df.drop(target_column, axis=1) y = df[target_column] # Split dataset into training and testing subsets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size, random_state=random_state) # Create and train the Linear Regression model model = LinearRegression() model.fit(X_train, y_train) # Predict on test data y_pred = model.predict(X_test) # Compute mean squared error mse = mean_squared_error(y_test, y_pred) return model, X_train, X_test, y_train, y_test, y_pred, mse"},{"question":"def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted arrays into a single sorted array. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 1, 3], [1, 4, 5]) [1, 1, 1, 3, 4, 5] >>> merge_sorted_arrays([], [2, 3, 4]) [2, 3, 4] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_arrays([], []) [] pass","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Parameters: arr1 (list of int): First sorted list of integers. arr2 (list of int): Second sorted list of integers. Returns: list of int: Merged sorted list of integers. merged_array = [] i = 0 j = 0 while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def rearrange_string(s: str) -> str: Transforms a given string by moving all alphabetic characters to the start of the string, maintaining their relative order, followed by all digits, maintaining their relative order. Any other characters are removed. >>> rearrange_string(\\"a1b2c3!!\\") == \\"abc123\\" >>> rearrange_string(\\"hello world!123\\") == \\"helloworld123\\" >>> rearrange_string(\\"12345\\") == \\"12345\\" >>> rearrange_string(\\"abcxyz\\") == \\"abcxyz\\" >>> rearrange_string(\\"\\") == \\"\\" >>> rearrange_string(\\"1234!@#\\") == \\"1234\\" >>> rearrange_string(\\"helloworld!\\") == \\"helloworld\\"","solution":"def rearrange_string(s: str) -> str: Transforms a given string by moving all alphabetic characters to the start of the string, maintaining their relative order, followed by all digits, maintaining their relative order. Any other characters are removed. letters = [] digits = [] for char in s: if char.isalpha(): letters.append(char) elif char.isdigit(): digits.append(char) return ''.join(letters) + ''.join(digits)"},{"question":"def find_longest_sequence(s: str) -> int: Returns the length of the longest consecutive sequence of 'A's in the string s. >>> find_longest_sequence(\\"A\\") 1 >>> find_longest_sequence(\\"AAAAA\\") 5 >>> find_longest_sequence(\\"BAAABBAAAB\\") 3 >>> find_longest_sequence(\\"BABA\\") 1 >>> find_longest_sequence(\\"BBBAAAB\\") 3 >>> find_longest_sequence(\\"BBBAAAABB\\") 4","solution":"def find_longest_sequence(s): Returns the length of the longest consecutive sequence of 'A's in the string s. max_length = 0 current_length = 0 for char in s: if char == 'A': current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def find_longest_substring_without_repeating_characters(s: str) -> int: Returns the length of the longest substring without repeating characters. Example: >>> find_longest_substring_without_repeating_characters(\\"abrkaabcdefghijjxxx\\") 10 def test_example_case(): assert find_longest_substring_without_repeating_characters(\\"abrkaabcdefghijjxxx\\") == 10 def test_no_repeating_characters(): assert find_longest_substring_without_repeating_characters(\\"abcdef\\") == 6 def test_all_repeating_characters(): assert find_longest_substring_without_repeating_characters(\\"aaaa\\") == 1 def test_mixed_characters(): assert find_longest_substring_without_repeating_characters(\\"abcabcbb\\") == 3 def test_single_character(): assert find_longest_substring_without_repeating_characters(\\"a\\") == 1 def test_empty_string(): assert find_longest_substring_without_repeating_characters(\\"\\") == 0 def test_long_string(): assert find_longest_substring_without_repeating_characters(\\"pwwkew\\") == 3 def test_repeating_characters_with_Gap(): assert find_longest_substring_without_repeating_characters(\\"aab\\") == 2","solution":"def find_longest_substring_without_repeating_characters(s): Returns the length of the longest substring without repeating characters. char_index_map = {} start = 0 max_length = 0 for end in range(len(s)): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def num_islands(matrix: List[List[str]]) -> int: Returns the number of distinct islands in the given matrix. An island is a group of 'L' cells connected horizontally or vertically. :param matrix: List of lists containing 'L' for land and 'W' for water :type matrix: List[List[str]] :rtype: int Examples: >>> num_islands([ ... ['L', 'L', 'L'], ... ['L', 'L', 'L'], ... ['L', 'L', 'L'] ... ]) 1 >>> num_islands([ ... ['W', 'W', 'W'], ... ['W', 'W', 'W'], ... ['W', 'W', 'W'] ... ]) 0 # Implement the function here def largest_island(matrix: List[List[str]]) -> int: Returns the size of the largest island in the given matrix. :param matrix: List of lists containing 'L' for land and 'W' for water :type matrix: List[List[str]] :rtype: int Examples: >>> largest_island([ ... ['L', 'L', 'L'], ... ['L', 'L', 'L'], ... ['L', 'L', 'L'] ... ]) 9 >>> largest_island([ ... ['W', 'W', 'W'], ... ['W', 'W', 'W'], ... ['W', 'W', 'W'] ... ]) 0 # Implement the function here","solution":"def num_islands(matrix): Returns the number of distinct islands in the given matrix. :type matrix: List[List[str]] :rtype: int if not matrix: return 0 rows, cols = len(matrix), len(matrix[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): stack = [(r, c)] while stack: x, y = stack.pop() if x < 0 or x >= rows or y < 0 or y >= cols or matrix[x][y] == 'W' or visited[x][y]: continue visited[x][y] = True stack.extend([(x-1, y), (x+1, y), (x, y-1), (x, y+1)]) num_islands = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 'L' and not visited[i][j]: num_islands += 1 dfs(i, j) return num_islands def largest_island(matrix): Returns the size of the largest island in the given matrix. :type matrix: List[List[str]] :rtype: int if not matrix: return 0 rows, cols = len(matrix), len(matrix[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs_size(r, c): stack = [(r, c)] size = 0 while stack: x, y = stack.pop() if x < 0 or x >= rows or y < 0 or y >= cols or matrix[x][y] == 'W' or visited[x][y]: continue visited[x][y] = True size += 1 stack.extend([(x-1, y), (x+1, y), (x, y-1), (x, y+1)]) return size max_size = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 'L' and not visited[i][j]: max_size = max(max_size, dfs_size(i, j)) return max_size"},{"question":"def find_median_of_two_sorted_arrays(array1: List[int], array2: List[int]) -> float: Calculate the median of the union of two sorted arrays. If the length of the combined array is even, return the average of the two middle elements. If it is odd, return the middle element. >>> find_median_of_two_sorted_arrays([1, 2], [3, 4]) 2.5 >>> find_median_of_two_sorted_arrays([1, 3], [2]) 2 >>> find_median_of_two_sorted_arrays([1], []) 1 >>> find_median_of_two_sorted_arrays([1, 3, 8], [2, 7, 10, 11]) 7 >>> find_median_of_two_sorted_arrays([-3, -2, -1], [1, 2, 3]) 0","solution":"def find_median_of_two_sorted_arrays(array1, array2): Returns the median of the union of two sorted arrays. merged_array = sorted(array1 + array2) n = len(merged_array) mid = n // 2 if n % 2 == 0: # even length median = (merged_array[mid - 1] + merged_array[mid]) / 2 else: # odd length median = merged_array[mid] return median"},{"question":"def max_repeating_substring(s: str, k: int) -> int: Write a function \`max_repeating_substring(s: str, k: int) -> int\` that takes a string \`s\` and an integer \`k\`, and returns the length of the longest substring that contains at most \`k\` distinct characters. The function should handle edge cases where \`s\` is empty or \`k\` is zero. Raise a \`ValueError\` if \`k\` is negative. >>> max_repeating_substring(\\"eceba\\", 2) 3 >>> max_repeating_substring(\\"aa\\", 1) 2 >>> max_repeating_substring(\\"aabbcc\\", 1) 2 >>> max_repeating_substring(\\"\\", 2) 0","solution":"def max_repeating_substring(s: str, k: int) -> int: Returns the length of the longest substring that contains at most k distinct characters. Raise ValueError if k is negative. if k < 0: raise ValueError(\\"k must be a non-negative integer\\") n = len(s) if n == 0 or k == 0: return 0 char_count = {} max_len = 0 left = 0 # Expand the sliding window for right in range(n): char = s[right] char_count[char] = char_count.get(char, 0) + 1 # Contract the sliding window until we have at most k distinct characters while len(char_count) > k: left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def compress_string(s: str) -> str: Compresses a string using Run-Length Encoding (RLE). If the compressed string is not shorter than the original string, return the original string. :param s: The input string to compress. :return: The compressed string or the original string. >>> compress_string(\\"aabcccccaaa\\") 'a2b1c5a3' >>> compress_string(\\"abcdefgh\\") 'abcdefgh'","solution":"def compress_string(s: str) -> str: Compresses a string using Run-Length Encoding (RLE). If the compressed string is not shorter than the original string, return the original string. :param s: The input string to compress. :return: The compressed string or the original string. if not s: return s # Return the string itself if it is empty compressed = [] count = 1 length = len(s) for i in range(1, length): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 # Appending the last character and its count compressed.append(s[-1] + str(count)) # Joining the compressed components compressed_string = ''.join(compressed) # Return the shorter of the original and compressed string return compressed_string if len(compressed_string) < length else s"},{"question":"def find_pair_with_sum(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Returns a pair of indices (i, j) such that nums[i] + nums[j] == target. If no such pair exists, return None. >>> find_pair_with_sum([2, 7, 11, 15], 9) == (0, 1) >>> find_pair_with_sum([3, 2, 4], 6) == (1, 2) >>> find_pair_with_sum([3, 3], 6) == (0, 1) >>> find_pair_with_sum([1, 2, 3], 7) == None","solution":"from typing import List, Optional, Tuple def find_pair_with_sum(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Returns a pair of indices (i, j) such that nums[i] + nums[j] == target. If no such pair exists, return None. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return (seen[complement], i) seen[num] = i return None"},{"question":"from typing import List def square_and_sort_desc(lst: List[int]) -> List[int]: Returns a list of the squares of integers in the input list, sorted in descending order. Args: lst (list): A list of integers. Returns: list: A list of the squares of integers in descending order. Raises: ValueError: If the input list contains non-integer elements. pass import pytest def test_square_and_sort_desc_normal_case(): assert square_and_sort_desc([1, 2, 3, 4, 5]) == [25, 16, 9, 4, 1] def test_square_and_sort_desc_with_negative_numbers(): assert square_and_sort_desc([-1, -2, -3, 3, 2, 1]) == [9, 9, 4, 4, 1, 1] def test_square_and_sort_desc_empty_list(): assert square_and_sort_desc([]) == [] def test_square_and_sort_desc_single_element(): assert square_and_sort_desc([7]) == [49] def test_square_and_sort_desc_non_integer_elements(): with pytest.raises(ValueError): square_and_sort_desc([1, 2.5, 3]) def test_square_and_sort_desc_with_zero(): assert square_and_sort_desc([0, -1, 1]) == [1, 1, 0]","solution":"def square_and_sort_desc(lst): Returns a list of the squares of integers in the input list, sorted in descending order. Args: lst (list): A list of integers. Returns: list: A list of the squares of integers in descending order. Raises: ValueError: If the input list contains non-integer elements. if not all(isinstance(x, int) for x in lst): raise ValueError(\\"All elements in the input list must be integers.\\") squared_lst = [x**2 for x in lst] squared_lst.sort(reverse=True) return squared_lst"},{"question":"def restore_ip_addresses(s: str) -> List[str]: Write a Python function that takes a string as input and returns a list of all valid IP addresses that can be formed by inserting three dots into the string. A valid IP address consists of exactly four integers (each ranging from 0 to 255), separated by dots. Each integer must not have leading zeros (unless the integer is 0 itself). >>> restore_ip_addresses(\\"25525511135\\") [\\"255.255.11.135\\", \\"255.255.111.35\\"] >>> restore_ip_addresses(\\"101023\\") [\\"1.0.10.23\\", \\"1.0.102.3\\", \\"10.1.0.23\\", \\"10.10.2.3\\", \\"101.0.2.3\\"]","solution":"def is_valid(segment): Check if the segment is a valid IP address segment. return int(segment) <= 255 and (segment == \\"0\\" or segment[0] != \\"0\\") def restore_ip_addresses(s): Restore valid IP addresses from a string by inserting three dots. n = len(s) result = [] for i in range(1, min(n, 4)): for j in range(i + 1, min(n, i + 4)): for k in range(j + 1, min(n, j + 4)): if k < n: a, b, c, d = s[:i], s[i:j], s[j:k], s[k:] if is_valid(a) and is_valid(b) and is_valid(c) and is_valid(d): result.append(\\"{}.{}.{}.{}\\".format(a, b, c, d)) return result"},{"question":"def count_vowels_consonants(s: str) -> (int, int): Calculate the number of vowels and consonants in the given string. Parameters: s (str): The input string containing alphabetic characters and spaces. Returns: (int, int): A tuple containing the counts of vowels and consonants. >>> count_vowels_consonants(\\"Hello World\\") (3, 7) >>> count_vowels_consonants(\\"aeiouAEIOU\\") (10, 0) >>> count_vowels_consonants(\\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\\") (0, 42) >>> count_vowels_consonants(\\"\\") (0, 0) >>> count_vowels_consonants(\\" \\") (0, 0) >>> count_vowels_consonants(\\"Python Programming\\") (4, 13)","solution":"def count_vowels_consonants(s): Calculate the number of vowels and consonants in the given string. Paramegers: s (str): The input string containing alphabetic characters and spaces. Returns: (int, int): A tuple containing the counts of vowels and consonants. vowels = \\"aeiouAEIOU\\" vowel_count = 0 consonant_count = 0 for char in s: if char.isalpha(): if char in vowels: vowel_count += 1 else: consonant_count += 1 return (vowel_count, consonant_count)"},{"question":"class DeliveryRobot: Implement a navigation system for a delivery robot. The delivery robot works as follows: 1. The robot is placed on a grid of variable size, defined by the user, with its starting position at the origin (0,0). 2. The robot can move North, South, East, or West. Each move advances the robot by one unit in the corresponding direction. 3. The robot can be given a series of instructions to navigate to a target position on the grid. 4. If the robot encounters an obstacle, it should stop immediately and report its current position. 5. The robot should be capable of storing and retrieving its position history, allowing it to undo its last move and revert to the previous position. 6. The robot returns a status message after each instruction to indicate whether it successfully moved, hit an obstacle, or reached the target position. Maintenance mode features: 1. Ability to add or remove obstacles on the grid. 2. Ability to reset the robot to its initial position or to a user-defined position on the grid. 3. Access to detailed movement logs, including all instructions received and positions visited. >>> robot = DeliveryRobot((10, 10)) >>> robot.move(\\"N\\") \\"Moved successfully\\" >>> robot.get_position() (0, 1) >>> robot.move(\\"E\\") \\"Moved successfully\\" >>> robot.get_position() (1, 1) >>> robot.reset_position() >>> robot.get_position() (0, 0) >>> robot.add_obstacle((0, 1)) >>> robot.move(\\"N\\") \\"Hit obstacle\\" >>> robot.get_position() (0, 0) >>> robot.remove_obstacle((0, 1)) >>> robot.move(\\"N\\") \\"Moved successfully\\" >>> robot.get_position() (0, 1) >>> robot.undo_last_move() >>> robot.get_position() (0, 0) >>> robot.get_position_history() [(0, 0), (0, 1), (0, 0)] >>> robot.get_instructions_log() [\\"N\\", \\"E\\", \\"N\\"]","solution":"class DeliveryRobot: def __init__(self, grid_size): self.grid_size = grid_size self.position = (0, 0) self.initial_position = (0, 0) self.position_history = [self.position] self.obstacles = set() self.instructions_log = [] def move(self, direction): x, y = self.position new_position = { \\"N\\": (x, y + 1), \\"S\\": (x, y - 1), \\"E\\": (x + 1, y), \\"W\\": (x - 1, y) }.get(direction, self.position) self.instructions_log.append(direction) if new_position in self.obstacles: return \\"Hit obstacle\\" elif self.is_valid_position(new_position): self.position = new_position self.position_history.append(self.position) return \\"Moved successfully\\" else: return \\"Invalid move\\" def is_valid_position(self, position): x, y = position return 0 <= x < self.grid_size[0] and 0 <= y < self.grid_size[1] def undo_last_move(self): if len(self.position_history) > 1: self.position_history.pop() self.position = self.position_history[-1] def reset_position(self, position=None): if position: self.position = position else: self.position = self.initial_position self.position_history = [self.position] def add_obstacle(self, position): if self.is_valid_position(position): self.obstacles.add(position) def remove_obstacle(self, position): if position in self.obstacles: self.obstacles.remove(position) def get_position(self): return self.position def get_position_history(self): return self.position_history def get_instructions_log(self): return self.instructions_log"},{"question":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number. The Fibonacci sequence is defined as follows: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n > 1 >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(6) 8 >>> fibonacci(10) 55","solution":"def fibonacci(n): Returns the nth Fibonacci number. if n == 0: return 0 elif n == 1: return 1 else: a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def sorted_keeping_negatives(nums): Returns a list sorted in non-decreasing order, while keeping negative numbers in their original positions. >>> sorted_keeping_negatives([3, -1, 4, 1, -5, -9, 2]) [1, -1, 2, 3, -5, -9, 4] >>> sorted_keeping_negatives([-1, -2, -3, -4]) [-1, -2, -3, -4] >>> sorted_keeping_negatives([5, 3, 8, 1]) [1, 3, 5, 8] >>> sorted_keeping_negatives([0, -3, 6, -1, 0, 4]) [0, -3, 0, -1, 4, 6] >>> sorted_keeping_negatives([]) [] >>> sorted_keeping_negatives([0, 0, 0]) [0, 0, 0] >>> sorted_keeping_negatives([7]) [7] >>> sorted_keeping_negatives([-7]) [-7] # Your solution here","solution":"def sorted_keeping_negatives(nums): Returns a list sorted in non-decreasing order, while keeping negative numbers in their original positions. # Extract the indices and values of the non-negative numbers non_negatives = [(idx, num) for idx, num in enumerate(nums) if num >= 0] # Sort the non-negative values while keeping their original indices sorted_non_negatives = sorted(non_negatives, key=lambda x: x[1]) # Place the sorted non-negative values back into their original positions result = nums[:] for (idx, _), (_, val) in zip(non_negatives, sorted_non_negatives): result[idx] = val return result"},{"question":"def fibonacci(n): Calculate the nth Fibonacci number using recursion. The Fibonacci sequence is a series of numbers where a number is the addition of the last two numbers, starting with 0, and 1. The sequence starts as follows: 0, 1, 1, 2, 3, 5, 8, ... Args: n (int): The position in the Fibonacci sequence to calculate. Returns: int: The nth Fibonacci number. Raises: ValueError: If n is not a positive integer. Examples: >>> fibonacci(1) 0 >>> fibonacci(2) 1 >>> fibonacci(3) 1 >>> fibonacci(4) 2 >>> fibonacci(5) 3 >>> fibonacci(6) 5 >>> fibonacci(10) 34 >>> fibonacci(20) 4181 >>> fibonacci(0) Traceback (most recent call last): ... ValueError: n must be a positive integer. >>> fibonacci(-1) Traceback (most recent call last): ... ValueError: n must be a positive integer. # Test cases to validate the solution def test_fibonacci_base_cases(): assert fibonacci(1) == 0 assert fibonacci(2) == 1 def test_fibonacci_recursive_cases(): assert fibonacci(3) == 1 assert fibonacci(4) == 2 assert fibonacci(5) == 3 assert fibonacci(6) == 5 def test_fibonacci_large_n(): assert fibonacci(10) == 34 assert fibonacci(20) == 4181 def test_fibonacci_invalid_input(): import pytest with pytest.raises(ValueError): fibonacci(-1) with pytest.raises(ValueError): fibonacci(0)","solution":"def fibonacci(n): Returns the nth Fibonacci number. if n <= 0: raise ValueError(\\"n must be a positive integer.\\") elif n == 1: return 0 elif n == 2: return 1 else: return fibonacci(n - 1) + fibonacci(n - 2)"},{"question":"def minCostToMoveChips(position: List[int]) -> int: Calculate the minimum cost to move all chips to the same position. Example 1: >>> minCostToMoveChips([1, 2, 3]) 1 Example 2: >>> minCostToMoveChips([2, 2, 2, 3, 3]) 2 Example 3: >>> minCostToMoveChips([1, 1000000000]) 1 Example 4: >>> minCostToMoveChips([2, 4, 6, 8]) 0 Example 5: >>> minCostToMoveChips([1, 3, 5, 7]) 0 Example 6: >>> minCostToMoveChips([1, 2, 3, 4, 5, 6]) 3 Example 7: >>> minCostToMoveChips([7, 7, 7, 7, 7]) 0","solution":"def minCostToMoveChips(position): Calculate the minimum cost to move all chips to the same position. # Count how many chips are on even and odd positions odd_count = sum(1 for p in position if p % 2 != 0) even_count = len(position) - odd_count # The minimum cost will be the smaller number of chips on either even or odd positions return min(odd_count, even_count)"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head: ListNode) -> ListNode: Returns the node where the cycle begins. If there is no cycle, return None. >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head.next.next = ListNode(3) >>> detectCycle(head) is None True >>> head.next.next.next = head # cycle here >>> detectCycle(head) == head True","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head): Returns the node where the cycle begins. If there is no cycle, return None. if not head or not head.next: return None slow = head fast = head # Move slow by 1 step and fast by 2 steps while fast and fast.next: slow = slow.next fast = fast.next.next # Cycle detected if slow == fast: break # No cycle detected if not fast or not fast.next: return None # Find the entry point of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"class Book: def __init__(self, title: str, author: str, id: int): Initializes a book with title, author, and unique id. self.title = title self.author = author self.id = id class Library: def __init__(self): Initializes an empty library. def add_book(self, book: Book): Adds a new book to the library. def borrow_book(self, book_id: int, user: str): Marks a book as borrowed by a user. Raises an exception if the book does not exist or is already borrowed. def return_book(self, book_id: int): Marks a book as returned. Raises an exception if the book is not currently borrowed. def list_available_books(self): Returns a list of books that are currently available for borrowing. def list_borrowed_books(self): Returns a list of books that are currently borrowed along with the user who has borrowed them. # Example usage if __name__ == \\"__main__\\": # Create a library instance library = Library() # Add books to the library book1 = Book(\\"1984\\", \\"George Orwell\\", 1) book2 = Book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 2) library.add_book(book1) library.add_book(book2) # Borrow a book library.borrow_book(1, \\"User1\\") # List available books available_books = library.list_available_books() print([book.title for book in available_books]) # Output: [To Kill a Mockingbird] # List borrowed books borrowed_books = library.list_borrowed_books() print([(book.title, user) for book, user in borrowed_books]) # Output: [(1984, User1)] # Return a book library.return_book(1) # List available books again available_books = library.list_available_books() print([book.title for book in available_books]) # Output: [1984, To Kill a Mockingbird]","solution":"class Book: def __init__(self, title, author, id): self.title = title self.author = author self.id = id class Library: def __init__(self): self.books = {} self.borrowed_books = {} def add_book(self, book): self.books[book.id] = book def borrow_book(self, book_id, user): if book_id not in self.books: raise ValueError(\\"Book does not exist in the library.\\") if book_id in self.borrowed_books: raise ValueError(\\"Book is already borrowed.\\") self.borrowed_books[book_id] = user def return_book(self, book_id): if book_id not in self.borrowed_books: raise ValueError(\\"Book is not borrowed.\\") del self.borrowed_books[book_id] def list_available_books(self): return [book for book_id, book in self.books.items() if book_id not in self.borrowed_books] def list_borrowed_books(self): return [(self.books[book_id], user) for book_id, user in self.borrowed_books.items()]"},{"question":"def sort_students_by_grade(student_grades: dict) -> list: Given a dictionary of student names and grades, return a list of tuples sorted primarily by grades in descending order, and by names in ascending order if grades are the same. :param student_grades: dict: Dictionary with student names as keys and grades as values. :return: list: List of tuples sorted as described above. >>> sort_students_by_grade({'Alice': 90, 'Bob': 85, 'Charlie': 90, 'David': 85, 'Eve': 70}) [('Alice', 90), ('Charlie', 90), ('Bob', 85), ('David', 85), ('Eve', 70)] >>> sort_students_by_grade({'Alice': 80, 'Bob': 80, 'Charlie': 80}) [('Alice', 80), ('Bob', 80), ('Charlie', 80)] >>> sort_students_by_grade({'Alice': 95, 'Bob': 85, 'Charlie': 90}) [('Alice', 95), ('Charlie', 90), ('Bob', 85)] >>> sort_students_by_grade({}) [] >>> sort_students_by_grade({'Alice': 100}) [('Alice', 100)]","solution":"def sort_students_by_grade(student_grades): Given a dictionary of student names and grades, return a list of tuples sorted primarily by grades in descending order, and by names in ascending order if grades are the same. :param student_grades: dict: Dictionary with student names as keys and grades as values. :return: list: List of tuples sorted as described above. return sorted(student_grades.items(), key=lambda item: (-item[1], item[0]))"},{"question":"def reverse_sentence(sentence: str) -> str: Reverse the words in a sentence. Parameters: sentence (str): The input string with words. Returns: str: The string with words in reverse order. Examples: >>> reverse_sentence(\\"Hello\\") 'Hello' >>> reverse_sentence(\\"Hello world\\") 'world Hello' >>> reverse_sentence(\\"Hello world from Python\\") 'Python from world Hello' >>> reverse_sentence(\\" Hello world \\") 'world Hello' >>> reverse_sentence(\\"Hello world from Python\\") 'Python from world Hello' >>> reverse_sentence(\\"\\") ''","solution":"def reverse_sentence(sentence): Reverse the words in a sentence. Parameters: sentence (str): The input string with words. Returns: str: The string with words in reverse order. # Split the sentence by spaces to get the words words = sentence.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words with a single space reversed_sentence = ' '.join(reversed_words) return reversed_sentence"},{"question":"def generate_natural_numbers(n: int, target: int) -> List[int]: Generate a list of n natural numbers that sum up to the target. Return an empty list if it is not possible to generate such a list. >>> generate_natural_numbers(3, 6) [1, 2, 3] >>> generate_natural_numbers(3, 7) [1, 2, 4] >>> generate_natural_numbers(3, 5) [] >>> generate_natural_numbers(0, 5) [] >>> generate_natural_numbers(2, 3) [1, 2] pass","solution":"def generate_natural_numbers(n, target): Generate a list of n natural numbers that sum up to the target. Args: - n (int): Number of natural numbers to generate. - target (int): Target sum of the generated natural numbers. Returns: - list: A list of n natural numbers that sum to the target, or an empty list if not possible. if n <= 0 or target < n * (n + 1) // 2: return [] # Generate the first n natural numbers natural_numbers = list(range(1, n + 1)) current_sum = sum(natural_numbers) # Since we need to reach the target and current_sum is the minimal sum, # calculate the extra required to match the target required_sum = target - current_sum # Distribute the required_sum to the existing numbers by incrementing them index = n - 1 while required_sum > 0: natural_numbers[index] += 1 required_sum -= 1 index -= 1 if index < 0: index = n - 1 return natural_numbers"},{"question":"def compute_ranking(matches): Computes the ranking of players based on matches. Parameters: matches (list of list of str): The list of match results. Returns: list of str: The ranking of players. >>> compute_ranking([[\\"Alice\\", \\"Bob\\"], [\\"Bob\\", \\"Charlie\\"], [\\"Charlie\\", \\"Alice\\"], [\\"Alice\\", \\"Charlie\\"], [\\"Bob\\", \\"Alice\\"], [\\"Charlie\\", \\"Bob\\"]]) [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] >>> compute_ranking([[\\"A\\", \\"C\\"], [\\"B\\", \\"A\\"], [\\"C\\", \\"B\\"], [\\"D\\", \\"A\\"], [\\"C\\", \\"D\\"], [\\"B\\", \\"C\\"]]) [\\"B\\", \\"C\\", \\"D\\", \\"A\\"] >>> compute_ranking([[\\"A\\", \\"B\\"]]) [\\"A\\", \\"B\\"] >>> compute_ranking([[\\"A\\", \\"B\\"], [\\"C\\", \\"D\\"], [\\"E\\", \\"F\\"], [\\"G\\", \\"H\\"]]) [\\"A\\", \\"C\\", \\"E\\", \\"G\\", \\"B\\", \\"D\\", \\"F\\", \\"H\\"] >>> compute_ranking([[\\"A\\", \\"B\\"], [\\"B\\", \\"A\\"], [\\"A\\", \\"C\\"], [\\"C\\", \\"A\\"], [\\"B\\", \\"C\\"], [\\"C\\", \\"B\\"]]) [\\"A\\", \\"B\\", \\"C\\"] >>> compute_ranking([[\\"A\\", \\"B\\"], [\\"A\\", \\"C\\"], [\\"A\\", \\"D\\"], [\\"B\\", \\"C\\"], [\\"B\\", \\"D\\"], [\\"C\\", \\"D\\"]]) [\\"A\\", \\"B\\", \\"C\\", \\"D\\"]","solution":"def compute_ranking(matches): Computes the ranking of players based on matches. Parameters: matches (list of list of str): The list of match results. Returns: list of str: The ranking of players. from collections import defaultdict # Initialize dictionaries to store wins and losses wins = defaultdict(int) losses = defaultdict(int) # Process each match for winner, loser in matches: wins[winner] += 1 losses[loser] += 1 # Get all players players = set(wins.keys()).union(set(losses.keys())) # Prepare player stats player_stats = [] for player in players: player_stats.append((wins[player], losses[player], player)) # Sort by wins (desc), losses (asc), name (lexicographically) player_stats.sort(key=lambda x: (-x[0], x[1], x[2])) # Return the sorted player names return [player for _, _, player in player_stats]"},{"question":"def group_urls_by_domain(urls: list) -> dict: Groups URLs by their domain. Args: urls (list): A list of URLs. Returns: dict: A dictionary with domain names as keys and lists of URLs as values. Example: >>> input_urls = [ ... \\"https://www.example.com/path/to/page\\", ... \\"http://example.com/another/path\\", ... \\"https://www.google.com/\\", ... \\"ftp://files.server.com/download\\", ... \\"www.server.com/path/to/resource\\", ... \\"https://example.com/yet/another/path\\" ... ] >>> group_urls_by_domain(input_urls) { \\"www.example.com\\": [\\"https://www.example.com/path/to/page\\"], \\"example.com\\": [\\"http://example.com/another/path\\", \\"https://example.com/yet/another/path\\"], \\"www.google.com\\": [\\"https://www.google.com/\\"], \\"files.server.com\\": [\\"ftp://files.server.com/download\\"], \\"www.server.com\\": [\\"www.server.com/path/to/resource\\"], \\"unknown\\": [] } pass","solution":"def group_urls_by_domain(urls): Groups URLs by their domain. Args: urls (list): A list of URLs. Returns: dict: A dictionary with domain names as keys and lists of URLs as values. from urllib.parse import urlparse import re domain_dict = {} unknown = [] for url in urls: parsed_url = urlparse(url) if parsed_url.netloc: domain = parsed_url.netloc else: match = re.match(r'^(https?|ftp)://', url) domain = 'unknown' if not match else match.group(0) if domain in domain_dict: domain_dict[domain].append(url) else: domain_dict[domain] = [url] return domain_dict"},{"question":"def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two given sorted lists into one new sorted list. The input lists are sorted individually in ascending order. The merged list should also be sorted in ascending order. >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([1, 2], [3, 4, 5, 6, 7]) [1, 2, 3, 4, 5, 6, 7] >>> merge_sorted_lists([], [1, 2, 3, 4]) [1, 2, 3, 4] >>> merge_sorted_lists([1, 2, 3, 4], []) [1, 2, 3, 4] >>> merge_sorted_lists([], []) [] >>> merge_sorted_lists([-3, -1, 2], [-2, 0, 3]) [-3, -2, -1, 0, 2, 3] >>> merge_sorted_lists([1, 2, 2, 3], [2, 4, 4, 5]) [1, 2, 2, 2, 3, 4, 4, 5]","solution":"def merge_sorted_lists(list1, list2): Merges two given sorted lists into one new sorted list. merged_list = [] i = j = 0 # Merge the lists while there are elements in both while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # If there are remaining elements in list1 while i < len(list1): merged_list.append(list1[i]) i += 1 # If there are remaining elements in list2 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def most_frequent_elements(nums): Returns a list of the elements that appear most frequently in the input list. If multiple elements have the same highest frequency, all of them are returned in ascending order. >>> most_frequent_elements([1, 3, 2, 2, 3, 4, 5, 2, 3]) [2, 3] >>> most_frequent_elements([1, 2, 2, 3, 3]) [2, 3] >>> most_frequent_elements([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> most_frequent_elements([]) [] >>> most_frequent_elements([2, 2, 2, 2]) [2] >>> most_frequent_elements([1, 1, 2, 2, 3, 3, 4]) [1, 2, 3]","solution":"def most_frequent_elements(nums): Returns a list of the elements that appear most frequently in the input list. If multiple elements have the same highest frequency, all of them are returned in ascending order. from collections import Counter if not nums: return [] # Count the frequency of each element using Counter frequency = Counter(nums) # Get the maximum frequency max_freq = max(frequency.values()) # List of elements with the maximum frequency most_frequent = [key for key, value in frequency.items() if value == max_freq] # Return the sorted list return sorted(most_frequent)"},{"question":"import string from collections import Counter import os def read_file(filename): Reads a file and returns its content. Args: filename (str): The name of the file. Returns: str: The content of the file as a string. Raises: FileNotFoundError: If the file does not exist. pass def clean_text(text): Cleans the text by removing punctuation. Args: text (str): The input text. Returns: str: The cleaned text without punctuation. pass def count_word_frequencies(text): Counts the frequency of each word in the text. Args: text (str): The input text. Returns: Counter: A counter object with word frequencies. pass def get_top_n_words(word_counts, n=10): Gets the top n most frequent words. Args: word_counts (Counter): The counter object with word frequencies. n (int): The number of top words to return. Returns: list: A list of tuples containing the top n words and their frequencies. pass def main(filename='sample.txt'): Main function to read the file and find the top 10 most frequent words. Args: filename (str): The name of the file. Returns: list: A list of tuples containing the top 10 words and their frequencies. pass # For demonstration purposes, we directly print the result here if __name__ == \\"__main__\\": result = main('sample.txt') print('Top 10 words:', result) Unit Test: import pytest from collections import Counter from solution import read_file, clean_text, count_word_frequencies, get_top_n_words, main import os def test_read_file(): text = read_file('test_sample.txt') assert text == \\"Hello world! This is a test sample file. Hello again, world.\\" def test_clean_text(): text = \\"Hello, world! This is a test.\\" cleaned = clean_text(text) assert cleaned == \\"Hello world This is a test\\" def test_count_word_frequencies(): text = \\"Hello world Hello\\" word_counts = count_word_frequencies(text) expected_counts = Counter({'hello': 2, 'world': 1}) assert word_counts == expected_counts def test_get_top_n_words(): word_counts = Counter({'hello': 2, 'world': 1}) top_words = get_top_n_words(word_counts, n=1) assert top_words == [('hello', 2)] def test_main(): assert main('non_existent_file.txt') == [] assert main('empty_file.txt') == [] expected_result = [('hello', 2), ('world', 2), ('this', 1), ('is', 1), ('a', 1), ('test', 1), ('sample', 1), ('file', 1), ('again', 1)] assert main('test_sample.txt') == expected_result # Create files for testing purposes def setup_module(module): with open('test_sample.txt', 'w', encoding='utf-8') as file: file.write(\\"Hello world! This is a test sample file. Hello again, world.\\") with open('empty_file.txt', 'w', encoding='utf-8') as file: file.write(\\"\\") # Cleanup files after testing def teardown_module(module): os.remove('test_sample.txt') os.remove('empty_file.txt')","solution":"import string from collections import Counter import os def read_file(filename): if not os.path.exists(filename): raise FileNotFoundError(f\\"The file {filename} does not exist.\\") with open(filename, 'r', encoding='utf-8') as file: text = file.read() return text def clean_text(text): translator = str.maketrans('', '', string.punctuation) return text.translate(translator) def count_word_frequencies(text): words = text.lower().split() return Counter(words) def get_top_n_words(word_counts, n=10): return word_counts.most_common(n) def main(filename='sample.txt'): try: text = read_file(filename) except FileNotFoundError as e: print(e) return [] if not text.strip(): print(\\"The file is empty.\\") return [] cleaned_text = clean_text(text) word_counts = count_word_frequencies(cleaned_text) top_words = get_top_n_words(word_counts) return top_words # For demonstration purposes, we directly print the result here if __name__ == \\"__main__\\": result = main('sample.txt') print('Top 10 words:', result)"},{"question":"def first_non_repeating_char(s: str) -> str: Processes an input string and finds the first non-repeating character. If the string contains no unique characters, returns a specific message indicating this. >>> first_non_repeating_char(\\"abcdef\\") \\"a\\" >>> first_non_repeating_char(\\"aabbccdde\\") \\"e\\" >>> first_non_repeating_char(\\"aabbcc\\") \\"No unique characters found\\" >>> first_non_repeating_char(\\"x\\") \\"x\\" >>> first_non_repeating_char(\\"aAbBcCdD\\") \\"a\\" >>> first_non_repeating_char(\\"!@#@!\\") \\"#\\" >>> first_non_repeating_char(\\"\\") \\"No unique characters found\\" >>> first_non_repeating_char(\\"!!!@@@#\\") \\"No unique characters found\\"","solution":"def first_non_repeating_char(s): Finds the first non-repeating character in the string s. Returns the character if found, otherwise returns a message indicating no unique characters. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in s: if char_count[char] == 1: return char return \\"No unique characters found\\""},{"question":"from typing import List def find_pairs(nums: List[int], target: int) -> List[List[int]]: Implement a function that receives a list of integers and a target integer. The function should return a list of all the unique pairs of integers from the input list that sum up to the target integer. Ensure that each pair is listed in ascending order and the overall list of pairs is also sorted in ascending order. >>> find_pairs([1, 2, 3, 4, 5], 5) [[1, 4], [2, 3]] >>> find_pairs([0, -1, 2, -3, 1], -2) [[-3, 1]] >>> find_pairs([1, 1, 1, 1], 2) [[1, 1]]","solution":"from typing import List def find_pairs(nums: List[int], target: int) -> List[List[int]]: nums.sort() seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return [list(pair) for pair in sorted(pairs)]"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression in infix notation and returns the result. The expression contains only non-negative integers and the operators '+', '-', '*', '/'. Parentheses may be used to change the order of operations. The division operator (/) represents integer division. >>> evaluate_expression(\\"42\\") 42 >>> evaluate_expression(\\"2+3\\") 5 >>> evaluate_expression(\\"10-2\\") 8 >>> evaluate_expression(\\"3*4\\") 12 >>> evaluate_expression(\\"8/3\\") 2 >>> evaluate_expression(\\"2+3*4\\") 14 >>> evaluate_expression(\\"(2+3)*4\\") 20 >>> evaluate_expression(\\"3+(2*2)\\") 7 >>> evaluate_expression(\\"2*(5+5*2)/3+(6/2+8)\\") 21 >>> evaluate_expression(\\"3+(2*(2+3))\\") 13 >>> evaluate_expression(\\"10+2*6\\") 22 >>> evaluate_expression(\\"100 * 2 + 12\\") 212 >>> evaluate_expression(\\"100 * ( 2 + 12 )\\") 1400 >>> evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\") 100 pass","solution":"import operator def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression in infix notation and returns the result. The expression contains only non-negative integers and the operators '+', '-', '*', '/'. Parentheses may be used to change the order of operations. The division operator (/) represents integer division. def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def apply_op(a, b, op): operations = { '+': operator.add, '-': operator.sub, '*': operator.mul, '/': operator.floordiv } return operations[op](a, b) def to_tokens(expression): tokens = [] value = '' for char in expression: if char.isdigit(): value += char else: if value: tokens.append(value) value = '' if char.strip(): tokens.append(char) if value: tokens.append(value) return tokens def evaluate(tokens): values = [] ops = [] def apply_ops_until_opening_parenthesis(): while ops and ops[-1] != '(': right = values.pop() left = values.pop() op = ops.pop() values.append(apply_op(left, right, op)) ops.pop() # removing '(' i = 0 while i < len(tokens): if tokens[i].isdigit(): values.append(int(tokens[i])) elif tokens[i] == '(': ops.append(tokens[i]) elif tokens[i] == ')': apply_ops_until_opening_parenthesis() else: while (ops and ops[-1] != '(' and precedence(ops[-1]) >= precedence(tokens[i])): right = values.pop() left = values.pop() op = ops.pop() values.append(apply_op(left, right, op)) ops.append(tokens[i]) i += 1 while ops: right = values.pop() left = values.pop() op = ops.pop() values.append(apply_op(left, right, op)) return values[0] tokens = to_tokens(expression) return evaluate(tokens)"},{"question":"def reorder_array(arr): Reorders the input list such that all even numbers appear in ascending order followed by all odd numbers in descending order. :param arr: List of integers to be reordered. :return: List of integers reordered as specified. :raises TypeError: If input list contains non-integer types. from solution import reorder_array def test_empty_list(): assert reorder_array([]) == [] def test_only_even_numbers(): assert reorder_array([4, 2, 8, 6]) == [2, 4, 6, 8] def test_only_odd_numbers(): assert reorder_array([7, 1, 3, 9]) == [9, 7, 3, 1] def test_mixed_even_and_odd_numbers(): assert reorder_array([3, 1, 2, 4, 7, 6]) == [2, 4, 6, 7, 3, 1] def test_single_element_even(): assert reorder_array([2]) == [2] def test_single_element_odd(): assert reorder_array([3]) == [3] def test_raises_type_error_with_non_integer_elements(): try: reorder_array([3, 'a', 2]) except TypeError as e: assert str(e) == \\"Input list must contain only integer values\\" else: assert False, \\"TypeError was not raised\\" def test_identical_even_and_odd_elements(): assert reorder_array([2, 2, 3, 3]) == [2, 2, 3, 3]","solution":"def reorder_array(arr): Reorders the input list such that all even numbers appear in ascending order followed by all odd numbers in descending order. :param arr: List of integers to be reordered. :return: List of integers reordered as specified. :raises TypeError: If input list contains non-integer types. if not all(isinstance(x, int) for x in arr): raise TypeError(\\"Input list must contain only integer values\\") evens = sorted([x for x in arr if x % 2 == 0]) odds = sorted([x for x in arr if x % 2 != 0], reverse=True) return evens + odds"},{"question":"class MyClass: A class to represent a person with name and age attributes. def __init__(self, name, age): Initializes the name and age attributes. self._name = name self._age = age @property def name(self): return self._name @name.setter def name(self, value): self._name = value @property def age(self): return self._age @age.setter def age(self, value): self._age = value def display_person(obj): Displays the name and age of the person object. print('Name:', obj.name) print('Age:', obj.age) >>> person = MyClass(\\"John\\", 30) >>> display_person(person) Name: John Age: 30 >>> person = MyClass(\\"Alice\\", 25) >>> person.name = \\"Bob\\" >>> person.age = 30 >>> display_person(person) Name: Bob Age: 30","solution":"class MyClass: A class to represent a person with name and age attributes. def __init__(self, name, age): Initializes the name and age attributes. self._name = name self._age = age @property def name(self): return self._name @name.setter def name(self, value): self._name = value @property def age(self): return self._age @age.setter def age(self, value): self._age = value def display_person(obj): Displays the name and age of the person object. print('Name:', obj.name) print('Age:', obj.age) person = MyClass(\\"John\\", 30) display_person(person)"},{"question":"def validate_braces(s: str) -> bool: Check if the string input has valid pairs of parentheses, brackets, and curly braces. >>> validate_braces(\\"a(b)c[d]{e}\\") True >>> validate_braces(\\"{[a+b]*(c+d)}\\") True >>> validate_braces(\\"([)]\\") False # Implement your solution here pass # Test Cases print(validate_braces(\\"a(b)c[d]{e}\\")) # Expected output: True print(validate_braces(\\"{[a+b]*(c+d)}\\")) # Expected output: True print(validate_braces(\\"([)]\\")) # Expected output: False print(validate_braces(\\"([])\\")) # Expected output: True print(validate_braces(\\"\\")) # Expected output: True print(validate_braces(\\"abc123\\")) # Expected output: True print(validate_braces(\\"(\\")) # Expected output: False print(validate_braces(\\"}\\")) # Expected output: False print(validate_braces(\\"((\\")) # Expected output: False print(validate_braces(\\"))\\")) # Expected output: False print(validate_braces(\\"[{]}\\")) # Expected output: False print(validate_braces(\\"a{b[c(d)e]f}g\\")) # Expected output: True print(validate_braces(\\"{[a+b]*(c+d)]}\\")) # Expected output: False","solution":"def validate_braces(s: str) -> bool: stack = [] matching_brace = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_brace.values(): stack.append(char) elif char in matching_brace.keys(): if stack and stack[-1] == matching_brace[char]: stack.pop() else: return False return not stack"},{"question":"def character_count(s: str) -> dict: Returns a dictionary with counts of each character in the string \`s\`, ignoring spaces and being case-insensitive. >>> character_count(\\"Hello World\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> character_count(\\"AaBbCc\\") {'a': 2, 'b': 2, 'c': 2} >>> character_count(\\"\\") {} >>> character_count(\\" a b c \\") {'a': 1, 'b': 1, 'c': 1} >>> character_count(\\"Python\\") {'p': 1, 'y': 1, 't': 1, 'h': 1, 'o': 1, 'n': 1} >>> character_count(\\" \\") {} >>> long_string = \\"The quick brown fox jumps over the lazy dog\\" >>> expected_count = { ... 't': 2, 'h': 2, 'e': 3, 'q': 1, 'u': 2, 'i': 1, 'c': 1, 'k': 1, ... 'b': 1, 'r': 2, 'o': 4, 'w': 1, 'n': 1, 'f': 1, 'x': 1, 'j': 1, ... 'm': 1, 'p': 1, 's': 1, 'v': 1, 'l': 1, 'a': 1, 'z': 1, 'y': 1, 'd': 1, 'g': 1 ... } >>> character_count(long_string) == expected_count True","solution":"def character_count(s: str) -> dict: Returns a dictionary with counts of each character in the string \`s\`, ignoring spaces and being case-insensitive. # Initialize an empty dictionary to store the counts count_dict = {} # Convert the input string to lowercase and remove spaces s = s.lower().replace(\\" \\", \\"\\") # Iterate over each character in the modified string for char in s: # Increment the count for the character in the dictionary if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 return count_dict"},{"question":"import re from typing import List def sort_file_names(file_names: List[str]) -> List[str]: Sort a list of file names by their base names and numeric extensions. >>> sort_file_names([\\"image2.jpg\\", \\"file1.txt\\", \\"file2.txt\\", \\"document\\", \\"image1.jpg\\"]) [\\"document\\", \\"file1.txt\\", \\"file2.txt\\", \\"image1.jpg\\", \\"image2.jpg\\"] >>> sort_file_names([\\"a10.txt\\", \\"a2.txt\\", \\"a100.txt\\", \\"b1.txt\\", \\"a.txt\\"]) [\\"a.txt\\", \\"a2.txt\\", \\"a10.txt\\", \\"a100.txt\\", \\"b1.txt\\"] # Implementation here pass","solution":"import re from typing import List def sort_file_names(file_names: List[str]) -> List[str]: def extract_base_and_extension(file_name): match = re.match(r'([a-zA-Z]+)([0-9]*).(.*)', file_name) if match: base_name, number, extension = match.groups() number = int(number) if number else 0 return (base_name, number, extension) else: return (file_name, 0, '') return sorted(file_names, key=lambda fn: extract_base_and_extension(fn))"},{"question":"def vowel_indices_sum(s: str) -> dict: Returns a dictionary where each key is a unique vowel encountered in the string s and the value is the sum of the indices where that vowel appears. The string is considered case insensitive. >>> vowel_indices_sum(\\"Hello World\\") {'e': 1, 'o': 11} >>> vowel_indices_sum(\\"AEIou\\") {'a': 0, 'e': 1, 'i': 2, 'o': 3, 'u': 4} >>> vowel_indices_sum(\\"BCDFG\\") {} >>> vowel_indices_sum(\\"\\") {} >>> vowel_indices_sum(\\"aAaA\\") {'a': 6} >>> vowel_indices_sum(\\"a e i o u\\") {'a': 0, 'e': 2, 'i': 4, 'o': 6, 'u': 8}","solution":"def vowel_indices_sum(s): Returns a dictionary where each key is a unique vowel encountered in the string s and the value is the sum of the indices where that vowel appears. The string is considered case insensitive. vowels = \\"aeiou\\" result = {} s = s.lower() for index, char in enumerate(s): if char in vowels: if char in result: result[char] += index else: result[char] = index return result"},{"question":"def unique_k_chars(s: str, k: int) -> str: Returns a new string with only the first occurrence of each character in the original string, such that the new string is at most k characters long. >>> unique_k_chars(\\"banana\\", 3) \\"ban\\" >>> unique_k_chars(\\"Programming\\", 5) \\"Prog\\" >>> unique_k_chars(\\"banana\\", 10) \\"ban\\" >>> unique_k_chars(\\"hello\\", 4) \\"helo\\" >>> unique_k_chars(\\"abcdeabc\\", 3) \\"abc\\" >>> unique_k_chars(\\"aaaaaa\\", 1) \\"a\\" >>> unique_k_chars(\\"\\", 5) \\"\\" >>> unique_k_chars(\\"abcdef\\", 6) \\"abcdef\\" >>> unique_k_chars(\\"abcdeabcdef\\", 5) \\"abcde\\"","solution":"def unique_k_chars(s, k): Returns a new string with only the first occurrence of each character in the original string, such that the new string is at most k characters long. Parameters: s (str): The input string. k (int): The maximum length of the new string. Returns: str: The new string with unique characters. unique_chars = [] seen = set() for char in s: if char not in seen: seen.add(char) unique_chars.append(char) if len(unique_chars) == k: break return ''.join(unique_chars)"},{"question":"def merge_dictionaries(dict_list: List[Dict[str, int]]) -> Dict[str, int]: Combine a list of dictionaries into a single dictionary. If the same key appears in more than one dictionary, their values are summed. >>> merge_dictionaries([{'a': 100, 'b': 200}, {'b': 300, 'c': 400}, {'a': 50, 'c': 80}]) {'a': 150, 'b': 500, 'c': 480} >>> merge_dictionaries([{'a': 1, 'b': 2}, {'b': 3, 'c': 4}, {'a': 5, 'c': 6}]) {'a': 6, 'b': 5, 'c': 10}","solution":"def merge_dictionaries(dict_list): Combines a list of dictionaries into a single dictionary. If the same key appears in more than one dictionary, their values are summed. merged_dict = {} for d in dict_list: for key, value in d.items(): if key in merged_dict: merged_dict[key] += value else: merged_dict[key] = value return merged_dict"},{"question":"from typing import List def top_k_frequent_words(words: List[str], k: int) -> List[str]: Find the k most frequent words in a given list of words. The function returns these words based on their frequencies in descending order. In case of ties, the words are returned in lexicographical order. Parameters: words (List[str]): A list of words to process k (int): The number of most frequent words to return Returns: List[str]: The k most frequent words >>> top_k_frequent_words([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"banana\\"], 2) [\\"banana\\", \\"apple\\"] >>> top_k_frequent_words([\\"a\\", \\"b\\", \\"c\\", \\"a\\", \\"b\\", \\"c\\"], 2) [\\"a\\", \\"b\\"] >>> top_k_frequent_words([\\"word\\"], 1) [\\"word\\"]","solution":"from typing import List from collections import Counter import heapq def top_k_frequent_words(words: List[str], k: int) -> List[str]: Returns the k most frequent words in the list of words. In case of tie, the words are returned in lexicographical order. # Count the frequency of each word count = Counter(words) # Use a heap for the top k frequent elements heap = [(-freq, word) for word, freq in count.items()] heapq.heapify(heap) # Extract the k most frequent elements result = [] for _ in range(k): freq, word = heapq.heappop(heap) result.append(word) return result"},{"question":"from typing import List, Tuple def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Write a function in Python that takes an array of integers and an integer \`target\` value, and returns a list of unique pairs of numbers from the array that sum up to the \`target\` value. Ensure that the output list contains no duplicate pairs and each pair should be sorted in ascending order. Also, the overall list of pairs should be sorted in ascending order based on the first number of each pair. If no such pairs exist, return an empty list. The function should have a time complexity of O(n log n) or better. >>> find_pairs([2, 4, 3, 5, 7, 8, -1, 1], 6) [(-1, 7), (1, 5), (2, 4)] >>> find_pairs([1, 2, 3, 4, 5], 10) [] >>> find_pairs([1, 1, 2, 3, 4, 4, 5, 6], 6) [(1, 5), (2, 4)] >>> find_pairs([2, -2, 3, -3, 4, -4, 5, -5], 0) [(-5, 5), (-4, 4), (-3, 3), (-2, 2)] >>> find_pairs([1], 1) [] >>> find_pairs([], 0) [] >>> find_pairs([1000000000, -1000000000, 999999999, -999999999], 1) [(-999999999, 1000000000)]","solution":"def find_pairs(nums, target): Finds all unique pairs in the array \`nums\` that sum up to \`target\`. nums.sort() pairs = set() left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: pairs.add((nums[left], nums[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 # Convert the set to a sorted list of unique pairs return sorted(pairs)"},{"question":"def max_difference(nums): Returns the maximum difference between two elements such that the larger element comes after the smaller element. If no such elements exist, return -1. >>> max_difference([7, 1, 5, 3, 6, 4]) == 5 >>> max_difference([9, 4, 3, 2]) == -1 >>> max_difference([1, 2, 3, 5, 6, 4]) == 5","solution":"def max_difference(nums): Returns the maximum difference between two elements such that the larger element comes after the smaller element. If no such elements exist, return -1. if not nums or len(nums) < 2: return -1 min_element = nums[0] max_diff = -1 for i in range(1, len(nums)): if nums[i] > min_element: max_diff = max(max_diff, nums[i] - min_element) else: min_element = min(min_element, nums[i]) return max_diff"},{"question":"def find_two_sum(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Finds two distinct integers in the list \`nums\` that add up to \`target\`. Parameters: nums (list of int): A list of integers. target (int): The target sum. Returns: tuple: A tuple of two integers that add up to the target, or None if no such pair exists. Examples: >>> find_two_sum([2, 7, 11, 15], 9) (2, 7) >>> find_two_sum([1, 2, 3, 4], 8) None","solution":"def find_two_sum(nums, target): Finds two distinct integers in the list \`nums\` that add up to \`target\`. Parameters: nums (list of int): A list of integers. target (int): The target sum. Returns: tuple: A tuple of two integers that add up to the target, or None if no such pair exists. num_set = {} for num in nums: complement = target - num if complement in num_set: return (num, complement) num_set[num] = True return None"},{"question":"def is_prime(n): Returns True if n is a prime number, otherwise False. pass def filter_primes(numbers): Returns a list of prime numbers from the given list \`numbers\`. >>> filter_primes([2, 3, 4, 5, 10, 17, 18, 19]) [2, 3, 5, 17, 19] >>> filter_primes([0, 1, -3, -1, -5, 22, 23]) [23] pass","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers): Returns a list of prime numbers from the given list \`numbers\`. return [num for num in numbers if is_prime(num)]"},{"question":"def merge_sorted_lists(list1, list2): '''This function takes two sorted lists, list1 and list2, and returns a new list that contains all elements from both lists in sorted order. If an element is not an integer, the function should return a string stating that the lists must only contain integers. For example: merge_sorted_lists([1, 3, 5], [2, 4, 6]) would return [1, 2, 3, 4, 5, 6] merge_sorted_lists([1, 2, 3], ['a', 'b', 'c']) would return \\"Lists must only contain integers\\" merge_sorted_lists([5, 10], [-1, 7, 9]) would return [-1, 5, 7, 9, 10] ''' # MISSING CODE","solution":"def merge_sorted_lists(list1, list2): ''' This function takes two sorted lists, list1 and list2, and returns a new list that contains all elements from both lists in sorted order. If an element is not an integer, the function should return a string stating that the lists must only contain integers. For example: merge_sorted_lists([1, 3, 5], [2, 4, 6]) would return [1, 2, 3, 4, 5, 6] merge_sorted_lists([1, 2, 3], ['a', 'b', 'c']) would return \\"Lists must only contain integers\\" merge_sorted_lists([5, 10], [-1, 7, 9]) would return [-1, 5, 7, 9, 10] ''' # Check if all elements are integers if not all(isinstance(i, int) for i in list1 + list2): return \\"Lists must only contain integers\\" merged_list = [] i = 0 j = 0 # Merge the two lists while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # If there are still elements in list1 while i < len(list1): merged_list.append(list1[i]) i += 1 # If there are still elements in list2 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def transform_string(input_str: str) -> str: Transforms the input string such that the first letter of each word is capitalized and the rest of the letters in each word are in lowercase. Args: input_str (str): The input string consisting of multiple words. Returns: str: The transformed string. >>> transform_string(\\"gOOD to SEE yoU!\\") 'Good To See You!' >>> transform_string(\\"hello! world.\\") 'Hello! World.'","solution":"def transform_string(input_str): Transforms the input string such that the first letter of each word is capitalized and the rest of the letters in each word are in lowercase. Parameters: input_str (str): The input string consisting of multiple words. Returns: str: The transformed string. return ' '.join(word.capitalize() for word in input_str.split())"},{"question":"def generate_summary(sentences: list) -> str: Generate a summary sentence from the first word of each sentence in the list. Skip any numbers and repeat words starting with a vowel. Args: sentences: list of strings Returns: str: The summary sentence >>> generate_summary(['Alpha beta', '3rd place', 'elephant tricks', 'untold stories', '234 is the start']) 'Alpha Alpha elephant elephant untold untold' >>> generate_summary(['All awesome apps', '2 are great', 'Online tools', 'useful utilities']) 'All All Online Online useful useful' def test_generate_summary_all_conditions(): assert generate_summary(['Alpha beta', '3rd place', 'elephant tricks', 'untold stories', '234 is the start']) == 'Alpha Alpha elephant elephant untold untold' assert generate_summary(['All awesome apps', '2 are great', 'Online tools', 'useful utilities']) == 'All All Online Online useful useful' def test_generate_summary_skip_numbers(): assert generate_summary(['1st place', '2nd chance', '3rd time', '4 times']) == '' def test_generate_summary_no_words(): assert generate_summary(['']) == '' assert generate_summary([' ']) == '' def test_generate_summary_consonants_only(): assert generate_summary(['Beta gamma', 'Car driver', 'Dog run']) == 'Beta Car Dog' def test_generate_summary_mixed(): assert generate_summary(['Apple pie', 'banana split', 'egg salad', '2nd try', 'ultimate goal', 'brave heart']) == 'Apple Apple banana egg egg ultimate ultimate brave'","solution":"def generate_summary(sentences: list) -> str: Generate a summary sentence from the first word of each sentence in the list. Skip any numbers and repeat words starting with a vowel. Args: sentences: list of strings Returns: str: The summary sentence result = [] vowels = 'aeiouAEIOU' for sentence in sentences: words = sentence.split() if words: first_word = words[0] if first_word[0].isdigit(): continue elif first_word[0] in vowels: result.extend([first_word, first_word]) else: result.append(first_word) return ' '.join(result)"},{"question":"def fibonacci(n): Returns a list of the first n numbers in the Fibonacci sequence. >>> fibonacci(0) [] >>> fibonacci(1) [0] >>> fibonacci(2) [0, 1] >>> fibonacci(5) [0, 1, 1, 2, 3] >>> fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci(n): Returns a list of the first n numbers in the Fibonacci sequence. if n <= 0: return [] elif n == 1: return [0] fib_sequence = [0, 1] while len(fib_sequence) < n: fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence"},{"question":"from typing import List, Tuple from collections import Counter def frequency_list(input_list: List[int]) -> List[Tuple[int, int]]: Reads a list of integers and returns a list of tuples, each containing a number and its frequency in the original list. The output list is sorted in descending order of frequency, and for numbers with the same frequency, by the number in ascending order.","solution":"from collections import Counter def frequency_list(input_list): Reads a list of integers and returns a list of tuples, each containing a number and its frequency in the original list. The output list is sorted in descending order of frequency, and for numbers with the same frequency, by the number in ascending order. frequency_counter = Counter(input_list) sorted_frequency = sorted(frequency_counter.items(), key=lambda x: (-x[1], x[0])) return sorted_frequency"},{"question":"from typing import List, Tuple def fibonacci(n: int) -> int: Returns the n-th Fibonacci number. If n is a negative integer, it raises a ValueError. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(3) 2 >>> fibonacci(4) 3 >>> try: ... fibonacci(-1) ... except ValueError as e: ... assert str(e) == \\"Fibonacci number is not defined for negative integers.\\" def list_fibonacci_values(lst: List[int]) -> List[Tuple[int, int]]: Returns a list of tuples. Each tuple consists of an integer from the input list and its corresponding Fibonacci value. >>> list_fibonacci_values([0, 1, 2, 3, 4]) [(0, 0), (1, 1), (2, 1), (3, 2), (4, 3)] >>> list_fibonacci_values([]) [] >>> list_fibonacci_values([10]) [(10, 55)] >>> list_fibonacci_values([5, 6, 7]) [(5, 5), (6, 8), (7, 13)] >>> try: ... list_fibonacci_values([-5]) ... except ValueError as e: ... assert str(e) == \\"Fibonacci number is not defined for negative integers.\\"","solution":"def fibonacci(n): Returns the n-th Fibonacci number. if n < 0: raise ValueError(\\"Fibonacci number is not defined for negative integers.\\") elif n == 0: return 0 elif n == 1: return 1 else: a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b def list_fibonacci_values(lst): Returns a list of tuples. Each tuple consists of an integer from the input list and its corresponding Fibonacci value. return [(num, fibonacci(num)) for num in lst]"},{"question":"def merge_dicts(dict1: dict, dict2: dict) -> list: Merges two dictionaries, summing values for keys that appear in both. Sorts the merged dictionary by keys and returns a list of tuples. >>> merge_dicts({'a': 5, 'b': 2, 'c': 3}, {'a': 7, 'b': 8, 'd': 6}) [('a', 12), ('b', 10), ('c', 3), ('d', 6)] >>> merge_dicts({'a': 1, 'b': 2}, {'c': 3, 'd': 4}) [('a', 1), ('b', 2), ('c', 3), ('d', 4)]","solution":"def merge_dicts(dict1: dict, dict2: dict) -> list: Merges two dictionaries, summing values for keys that appear in both. Sorts the merged dictionary by keys and returns a list of tuples. :param dict1: First dictionary to merge. :param dict2: Second dictionary to merge. :return: List of tuples with keys and summed values, sorted by keys. merged_dict = dict1.copy() # Start with a copy of dict1 for key, value in dict2.items(): if key in merged_dict: merged_dict[key] += value else: merged_dict[key] = value sorted_merged_dict = sorted(merged_dict.items()) return sorted_merged_dict"},{"question":"def generate_magic_square(N: int) -> list: Generates an NxN magic square. N must be an odd positive integer >= 3. Args: N (int): The size of the magic square. Returns: list: A 2D list representing the NxN magic square. Examples: >>> generate_magic_square(3) [[8, 1, 6], [3, 5, 7], [4, 9, 2]] >>> generate_magic_square(5) [[17, 24, 1, 8, 15], [23, 5, 7, 14, 16], [4, 6, 13, 20, 22], [10, 12, 19, 21, 3], [11, 18, 25, 2, 9]] # Implement the function here","solution":"def generate_magic_square(N: int) -> list: Generates an NxN magic square. N must be an odd positive integer >= 3. Args: N (int): The size of the magic square. Returns: list: A 2D list representing the NxN magic square. Examples: >>> generate_magic_square(3) [[8, 1, 6], [3, 5, 7], [4, 9, 2]] >>> generate_magic_square(5) [[17, 24, 1, 8, 15], [23, 5, 7, 14, 16], [4, 6, 13, 20, 22], [10, 12, 19, 21, 3], [11, 18, 25, 2, 9]] # Create an NxN grid filled with zeros magic_square = [[0] * N for _ in range(N)] # Initialize the position for 1 num = 1 i, j = 0, N // 2 while num <= N * N: magic_square[i][j] = num num += 1 # Calculate next position new_i, new_j = (i - 1) % N, (j + 1) % N if magic_square[new_i][new_j] != 0: # If the next position is filled new_i, new_j = (i + 1) % N, j # Move down instead i, j = new_i, new_j return magic_square"},{"question":"def length_of_longest_unique_substring(s: str) -> int: Write a Python program that finds the longest substring of unique characters in a given string. The function should return the length of this substring. If the string is empty, the function should return 0. >>> length_of_longest_unique_substring(\\"abcabcbb\\") == 3 # \\"abc\\" >>> length_of_longest_unique_substring(\\"bbbbb\\") == 1 # \\"b\\" >>> length_of_longest_unique_substring(\\"pwwkew\\") == 3 # \\"wke\\" >>> length_of_longest_unique_substring(\\"\\") == 0 # Empty string >>> length_of_longest_unique_substring(\\"abcdefg\\") == 7 # \\"abcdefg\\" >>> length_of_longest_unique_substring(\\"aab\\") == 2 # \\"ab\\" pass","solution":"def length_of_longest_unique_substring(s): Returns the length of the longest substring with all unique characters. char_set = set() left = 0 max_length = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"def group_cities_by_continent(cities): Group the list of city names by their respective continents. Parameters: - cities (list of str): a list of unique city names. Returns: - dict: a dictionary with continent names as keys and lists of cities as values. pass # Example usage: cities = [\\"Tokyo\\", \\"New York\\", \\"Sao Paulo\\", \\"Paris\\", \\"Lagos\\", \\"Sydney\\"] # Expected output: # { # 'Asia': ['Tokyo'], # 'North America': ['New York'], # 'South America': ['Sao Paulo'], # 'Europe': ['Paris'], # 'Africa': ['Lagos'], # 'Australia': ['Sydney'] # } print(group_cities_by_continent(cities))","solution":"def group_cities_by_continent(cities): Group the list of city names by their respective continents. Parameters: - cities (list of str): a list of unique city names. Returns: - dict: a dictionary with continent names as keys and lists of cities as values. # This is a mock mapping of city to continent. city_to_continent = { \\"Tokyo\\": \\"Asia\\", \\"New York\\": \\"North America\\", \\"Sao Paulo\\": \\"South America\\", \\"Paris\\": \\"Europe\\", \\"Lagos\\": \\"Africa\\", \\"Sydney\\": \\"Australia\\" } result = { \\"Asia\\": [], \\"North America\\": [], \\"South America\\": [], \\"Europe\\": [], \\"Africa\\": [], \\"Australia\\": [] } for city in cities: continent = city_to_continent.get(city) if continent: result[continent].append(city) return result # Example usage: cities = [\\"Tokyo\\", \\"New York\\", \\"Sao Paulo\\", \\"Paris\\", \\"Lagos\\", \\"Sydney\\"] print(group_cities_by_continent(cities))"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Determines the maximum profit from buying and selling a stock. :param prices: List of stock prices on different days. :return: Maximum profit. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"from typing import List def max_profit(prices: List[int]) -> int: Determines the maximum profit from buying and selling a stock. :param prices: List of stock prices on different days. :return: Maximum profit. if not prices: return 0 min_price = prices[0] max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"import re def reverse_words(sentence: str) -> str: Reverses the words in the given sentence while preserving punctuation and spacing. >>> reverse_words(\\"Hello, world! This is a test.\\") 'test. a is This world! Hello,' >>> reverse_words(\\" Leading and trailing spaces. \\") ' spaces. trailing and Leading ' >>> reverse_words(\\"Multiple spaces between words.\\") 'words. between spaces Multiple' from solution import reverse_words def test_reverse_words_regular_sentence(): assert reverse_words(\\"Hello, world! This is a test.\\") == \\"test. a is This world! Hello,\\" def test_reverse_words_leading_trailing_spaces(): assert reverse_words(\\" Leading and trailing spaces. \\") == \\" spaces. trailing and Leading \\" def test_reverse_words_multiple_spaces(): assert reverse_words(\\"Multiple spaces between words.\\") == \\"words. between spaces Multiple\\" def test_reverse_words_only_spaces(): assert reverse_words(\\" \\") == \\" \\" def test_reverse_words_no_spaces(): assert reverse_words(\\"Word\\") == \\"Word\\" def test_reverse_words_empty_string(): assert reverse_words(\\"\\") == \\"\\" def test_reverse_words_punctuation(): assert reverse_words(\\"Hello,world!\\") == \\"Hello,world!\\"","solution":"import re def reverse_words(sentence): Reverses the words in the given sentence while preserving punctuation and spacing. words = re.split(r'(s+)', sentence) # Split by whitespace while preserving it in the results reversed_words = words[::-1] # Reverse the list of words and spaces reversed_sentence = ''.join(reversed_words) # Join the list back into a string without adding extra spaces return reversed_sentence"},{"question":"def cumulative_sum(lst: List[int]) -> List[int]: Takes in a list of integers and returns a new list where each element is the sum of itself and all previous elements in the original list. >>> cumulative_sum([]) == [] >>> cumulative_sum([5]) == [5] >>> cumulative_sum([1, 2, 3, 4, 5]) == [1, 3, 6, 10, 15] >>> cumulative_sum([1, -1, 2, -2, 3]) == [1, 0, 2, 0, 3] >>> cumulative_sum([0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0] >>> cumulative_sum([-1, 3, -2, 5]) == [-1, 2, 0, 5]","solution":"def cumulative_sum(lst): Takes in a list of integers and returns a new list where each element is the sum of itself and all previous elements in the original list. if not lst: return [] result = [lst[0]] for i in range(1, len(lst)): result.append(result[-1] + lst[i]) return result # Time Complexity: # The function iterates over the list once, performing a constant-time operation at each step. # Hence, the time complexity is O(n), where n is the length of the list."},{"question":"from sklearn.datasets import fetch_california_housing from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score import matplotlib.pyplot as plt def load_and_preprocess_data(): Load and preprocess the California Housing dataset by handling missing values, scaling the features and splitting into training and testing sets. Returns: X_train_scaled: Scaled training features X_test_scaled: Scaled testing features y_train: Training labels y_test: Testing labels # Load dataset data = fetch_california_housing() X, y = data.data, data.target # Split the data X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Feature scaling scaler = StandardScaler() X_train_scaled = scaler.fit_transform(X_train) X_test_scaled = scaler.transform(X_test) return X_train_scaled, X_test_scaled, y_train, y_test def train_and_evaluate_model(X_train_scaled, X_test_scaled, y_train, y_test): Fit a linear regression model to the training data and evaluate its performance. Args: X_train_scaled: Scaled training features X_test_scaled: Scaled testing features y_train: Training labels y_test: Testing labels Returns: y_pred: Predicted values for the test set mae: Mean Absolute Error mse: Mean Squared Error r2: R-squared score # Fit the model model = LinearRegression() model.fit(X_train_scaled, y_train) # Evaluate the model y_pred = model.predict(X_test_scaled) mae = mean_absolute_error(y_test, y_pred) mse = mean_squared_error(y_test, y_pred) r2 = r2_score(y_test, y_pred) return y_pred, mae, mse, r2 def visualize_results(y_test, y_pred): Visualize the predicted prices versus the actual prices in a scatter plot. Args: y_test: Actual values from the test set y_pred: Predicted values for the test set # Visualize the performance plt.scatter(y_test, y_pred) plt.xlabel('Actual Prices') plt.ylabel('Predicted Prices') plt.title('Actual vs Predicted Housing Prices') plt.show() if __name__ == '__main__': # Load and preprocess data X_train_scaled, X_test_scaled, y_train, y_test = load_and_preprocess_data() # Train and evaluate the model y_pred, mae, mse, r2 = train_and_evaluate_model(X_train_scaled, X_test_scaled, y_train, y_test) # Print evaluation metrics print('Mean Absolute Error:', mae) print('Mean Squared Error:', mse) print('R-squared Score:', r2) # Visualize the results visualize_results(y_test, y_pred) # Unit tests import pytest def test_load_and_preprocess_data(): X_train_scaled, X_test_scaled, y_train, y_test = load_and_preprocess_data() assert X_train_scaled.shape[0] == y_train.shape[0] assert X_test_scaled.shape[0] == y_test.shape[0] assert X_train_scaled.shape[1] == X_test_scaled.shape[1] assert X_train_scaled.shape[1] == 8 # California Housing data has 8 features def test_train_and_evaluate_model(): X_train_scaled, X_test_scaled, y_train, y_test = load_and_preprocess_data() y_pred, mae, mse, r2 = train_and_evaluate_model(X_train_scaled, X_test_scaled, y_train, y_test) assert len(y_pred) == len(y_test) assert mae >= 0 assert mse >= 0 assert -1 <= r2 <= 1 if __name__ == '__main__': pytest.main()","solution":"from sklearn.datasets import fetch_california_housing from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score import matplotlib.pyplot as plt def load_and_preprocess_data(): # Load dataset data = fetch_california_housing() X, y = data.data, data.target # Split the data X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Feature scaling scaler = StandardScaler() X_train_scaled = scaler.fit_transform(X_train) X_test_scaled = scaler.transform(X_test) return X_train_scaled, X_test_scaled, y_train, y_test def train_and_evaluate_model(X_train_scaled, X_test_scaled, y_train, y_test): # Fit the model model = LinearRegression() model.fit(X_train_scaled, y_train) # Evaluate the model y_pred = model.predict(X_test_scaled) mae = mean_absolute_error(y_test, y_pred) mse = mean_squared_error(y_test, y_pred) r2 = r2_score(y_test, y_pred) return y_pred, mae, mse, r2 def visualize_results(y_test, y_pred): # Visualize the performance plt.scatter(y_test, y_pred) plt.xlabel('Actual Prices') plt.ylabel('Predicted Prices') plt.title('Actual vs Predicted Housing Prices') plt.show() # Load and preprocess data X_train_scaled, X_test_scaled, y_train, y_test = load_and_preprocess_data() # Train and evaluate the model y_pred, mae, mse, r2 = train_and_evaluate_model(X_train_scaled, X_test_scaled, y_train, y_test) # Print evaluation metrics print('Mean Absolute Error:', mae) print('Mean Squared Error:', mse) print('R-squared Score:', r2) # Visualize the results visualize_results(y_test, y_pred)"},{"question":"import re from collections import Counter def count_word_occurrences(file_path): Reads the contents of a text file and counts the occurrence of each word, ignoring case, punctuation, and white space. :param file_path: Path to the text file :return: A dictionary with words as keys and their occurrence counts as values # Unit tests import os def create_test_file(content): Helper function to create a temporary test file with open(\\"test_file.txt\\", \\"w\\") as file: file.write(content) return \\"test_file.txt\\" def delete_test_file(file_path): Helper function to delete the temporary test file os.remove(file_path) def test_word_count_simple_text(): test_content = \\"Hello world! World hello.\\" test_file_path = create_test_file(test_content) expected_output = {\\"hello\\": 2, \\"world\\": 2} try: assert count_word_occurrences(test_file_path) == expected_output finally: delete_test_file(test_file_path) def test_word_count_with_punctuation(): test_content = \\"Python's syntax is clear; yes, very clear!\\" test_file_path = create_test_file(test_content) expected_output = {\\"pythons\\": 1, \\"syntax\\": 1, \\"is\\": 1, \\"clear\\": 2, \\"yes\\": 1, \\"very\\": 1} try: assert count_word_occurrences(test_file_path) == expected_output finally: delete_test_file(test_file_path) def test_word_count_with_numbers(): test_content = \\"Numbers 123 should not affect, nor should %^& special characters.\\" test_file_path = create_test_file(test_content) expected_output = {\\"numbers\\": 1, \\"123\\": 1, \\"should\\": 2, \\"not\\": 1, \\"affect\\": 1, \\"nor\\": 1, \\"special\\": 1, \\"characters\\": 1} try: assert count_word_occurrences(test_file_path) == expected_output finally: delete_test_file(test_file_path) def test_word_count_empty_text(): test_content = \\"\\" test_file_path = create_test_file(test_content) expected_output = {} try: assert count_word_occurrences(test_file_path) == expected_output finally: delete_test_file(test_file_path) def test_word_count_mixed_case_text(): test_content = \\"Case insensitive text should be counted properly. CASE case CaSe.\\" test_file_path = create_test_file(test_content) expected_output = {\\"case\\": 4, \\"insensitive\\": 1, \\"text\\": 1, \\"should\\": 1, \\"be\\": 1, \\"counted\\": 1, \\"properly\\": 1} try: assert count_word_occurrences(test_file_path) == expected_output finally: delete_test_file(test_file_path)","solution":"import re from collections import Counter def count_word_occurrences(file_path): Reads the contents of a text file and counts the occurrence of each word, ignoring case, punctuation, and white space. :param file_path: Path to the text file :return: A dictionary with words as keys and their occurrence counts as values with open(file_path, 'r') as file: text = file.read() # Normalize case, remove punctuation and extra whitespace text = text.lower() # Convert to lowercase text = re.sub(r'[^ws]', '', text) # Remove punctuation words = text.split() # Split on whitespace # Count word occurrences word_counts = Counter(words) return dict(word_counts)"},{"question":"def is_prime(n: int) -> bool: Determine if a given number n is a prime number. >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(9) False >>> is_prime(13) True def find_primes_in_range(start: int, end: int) -> List[int]: Return a list of all prime numbers within a specified range [start, end). >>> find_primes_in_range(10, 20) [11, 13, 17, 19] >>> find_primes_in_range(20, 30) [23, 29] >>> find_primes_in_range(1, 10) [2, 3, 5, 7] >>> find_primes_in_range(50, 60) [53, 59] def count_primes_in_range(start: int, end: int) -> int: Count the number of prime numbers within a specified range [start, end). >>> count_primes_in_range(10, 20) 4 >>> count_primes_in_range(20, 30) 2 >>> count_primes_in_range(1, 10) 4 >>> count_primes_in_range(50, 60) 2","solution":"def is_prime(n): Determines if the given number n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_primes_in_range(start, end): Returns a list of all prime numbers in the given range [start, end). primes = [] for number in range(start, end): if is_prime(number): primes.append(number) return primes def count_primes_in_range(start, end): Returns the count of prime numbers in the given range [start, end). return len(find_primes_in_range(start, end))"},{"question":"def product_except_self(nums: List[int]) -> List[int]: This function takes a list of integers and returns a list where each element is the product of all elements in the list except the element at the same position. Raises: ValueError: If the list is empty or contains only one element. >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([5, 0, 2]) == [0, 10, 0] >>> product_except_self([1, -2, 3, -4]) == [24, -12, 8, -6] >>> product_except_self([0, 0, 0]) == [0, 0, 0] >>> product_except_self([1, 2, 0, 4]) == [0, 0, 8, 0] >>> product_except_self([1]) Traceback (most recent call last): ... ValueError: The list should contain at least two elements. >>> product_except_self([]) Traceback (most recent call last): ... ValueError: The list should not be empty.","solution":"def product_except_self(nums): This function takes a list of integers and returns a list where each element is the product of all elements in the list except the element at the same position. length = len(nums) if length == 0: raise ValueError(\\"The list should not be empty.\\") if length == 1: raise ValueError(\\"The list should contain at least two elements.\\") left_products = [1] * length right_products = [1] * length output = [1] * length for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] for i in range(length): output[i] = left_products[i] * right_products[i] return output"},{"question":"from typing import List def difference_and_sort(list1: List[int], list2: List[int]) -> List[int]: Write a function in Python that takes two lists of integers as inputs and returns a list of integers that are present in the first list but not in the second list. Ensure that the returned list is sorted in ascending order. The function should handle edge cases such as empty lists and lists with duplicate numbers. Examples: >>> difference_and_sort([5, 1, 3, 2, 4, 4, 1], [2, 4, 6]) [1, 3, 5] >>> difference_and_sort([10, 20, 20, 30, 30, 40], [30, 50]) [10, 20, 40] pass","solution":"from typing import List def difference_and_sort(list1: List[int], list2: List[int]) -> List[int]: Returns a sorted list of integers that are present in list1 but not in list2. Removes duplicates from the result. set1 = set(list1) set2 = set(list2) difference_set = set1 - set2 result_list = sorted(difference_set) return result_list"},{"question":"def categorize_team_members(members): Categorizes team members based on their roles. Args: - members (list): A list of strings, each string containing a team member's name and their role Returns: - dict: A dictionary with roles as keys and lists of names as values >>> categorize_team_members([\\"Alice Developer\\", \\"Bob Developer\\", \\"Charlie Manager\\", \\"Diana Designer\\"]) {'Developer': ['Alice', 'Bob'], 'Manager': ['Charlie'], 'Designer': ['Diana']} >>> categorize_team_members([]) {} >>> categorize_team_members([\\"Alice Developer\\", \\"Bob Designer\\"]) {'Developer': ['Alice'], 'Designer': ['Bob']} >>> categorize_team_members([\\"Alice Developer\\", \\"Bob Developer\\", \\"Charlie Developer\\"]) {'Developer': ['Alice', 'Bob', 'Charlie']} >>> categorize_team_members([\\"Alice Developer\\"]) {'Developer': ['Alice']}","solution":"def categorize_team_members(members): Categorizes team members based on their roles. Args: - members (list): A list of strings, each string containing a team member's name and their role Returns: - dict: A dictionary with roles as keys and lists of names as values categorized_members = {} for member in members: name, role = member.rsplit(maxsplit=1) if role not in categorized_members: categorized_members[role] = [] categorized_members[role].append(name) return categorized_members"},{"question":"def binary_search(numbers: List[int], target: int) -> int: Perform a binary search to find the index of target in the sorted list numbers. If target is not found, return -1. >>> binary_search([1, 3, 5, 7, 9, 11, 13, 15, 17, 19], 7) 3 >>> binary_search([1, 3, 5, 7, 9, 11, 13, 15, 17, 19], 4) -1 >>> binary_search([], 1) -1 >>> binary_search([1, 3, 5, 7, 9, 11, 13, 15, 17, 19], 1) 0 >>> binary_search([1, 3, 5, 7, 9, 11, 13, 15, 17, 19], 19) 9 >>> binary_search([5], 5) 0 >>> binary_search([5], 3) -1","solution":"def binary_search(numbers, target): Perform a binary search to find the index of target in the sorted list numbers. If target is not found, return -1. left, right = 0, len(numbers) - 1 while left <= right: mid = (left + right) // 2 if numbers[mid] == target: return mid elif numbers[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"import numpy as np from sklearn.ensemble import IsolationForest from sklearn.metrics import precision_score, recall_score, f1_score, roc_curve, auc def detect_fraud(transactions, user_location, user_ip, threshold=0.5): Detects potentially fraudulent transactions. Parameters: transactions (numpy array): 2D array with transaction data, including amounts and frequency. user_location (numpy array): 1D array with user's location changes. user_ip (numpy array): 1D array with user's IP changes. threshold (float): The threshold for the IsolationForest to determine fraud. Returns: numpy array: 1D array with boolean values indicating if a transaction is fraudulent. pass def flawed_fraud_detection(transactions, user_location, user_ip): A flawed fraud detection algorithm that fails to account for legitimate transactions by frequent travelers. Parameters: transactions (numpy array): 2D array with transaction data, including amounts and frequency. user_location (numpy array): 1D array with user's location changes. user_ip (numpy array): 1D array with user's IP changes. Returns: numpy array: 1D array with boolean values indicating if a transaction is fraudulent. pass def improved_fraud_detection(transactions, user_location, user_ip, threshold=0.5): An improved fraud detection algorithm that accounts for legitimate transactions by frequent travelers. Parameters: transactions (numpy array): 2D array with transaction data, including amounts and frequency. user_location (numpy array): 1D array with user's location changes. user_ip (numpy array): 1D array with user's IP changes. threshold (float): The threshold for the IsolationForest to determine fraud. Returns: numpy array: 1D array with boolean values indicating if a transaction is fraudulent. pass def evaluate_model(predictions, actuals): Evaluates the model's performance using metrics such as precision, recall, F1 score, and ROC AUC. Parameters: predictions (numpy array): 1D array with the model's fraud predictions. actuals (numpy array): 1D array with the actual fraud labels. Returns: dict: A dictionary with evaluation metrics. pass","solution":"import numpy as np from sklearn.ensemble import IsolationForest from sklearn.metrics import precision_score, recall_score, f1_score, roc_curve, auc def detect_fraud(transactions, user_location, user_ip, threshold=0.5): Detects potentially fraudulent transactions. Parameters: transactions (numpy array): 2D array with transaction data, including amounts and frequency. user_location (numpy array): 1D array with user's location changes. user_ip (numpy array): 1D array with user's IP changes. threshold (float): The threshold for the IsolationForest to determine fraud. Returns: numpy array: 1D array with boolean values indicating if a transaction is fraudulent. feature_data = np.hstack((transactions, user_location[:, None], user_ip[:, None])) model = IsolationForest(contamination=threshold) predictions = model.fit_predict(feature_data) return predictions == -1 # Example of flawed algorithm def flawed_fraud_detection(transactions, user_location, user_ip): A flawed fraud detection algorithm that fails to account for legitimate transactions by frequent travelers. Parameters: transactions (numpy array): 2D array with transaction data, including amounts and frequency. user_location (numpy array): 1D array with user's location changes. user_ip (numpy array): 1D array with user's IP changes. Returns: numpy array: 1D array with boolean values indicating if a transaction is fraudulent. fraud_flags = np.zeros(transactions.shape[0], dtype=bool) for i in range(1, transactions.shape[0]): if user_location[i] != user_location[i-1]: fraud_flags[i] = True return fraud_flags # Corrected algorithm def improved_fraud_detection(transactions, user_location, user_ip, threshold=0.5): An improved fraud detection algorithm that accounts for legitimate transactions by frequent travelers. Parameters: transactions (numpy array): 2D array with transaction data, including amounts and frequency. user_location (numpy array): 1D array with user's location changes. user_ip (numpy array): 1D array with user's IP changes. threshold (float): The threshold for the IsolationForest to determine fraud. Returns: numpy array: 1D array with boolean values indicating if a transaction is fraudulent. feature_data = np.hstack((transactions, user_location[:, None], user_ip[:, None])) model = IsolationForest(contamination=threshold) predictions = model.fit_predict(feature_data) return predictions == -1 # Evaluation strategy def evaluate_model(predictions, actuals): precision = precision_score(actuals, predictions) recall = recall_score(actuals, predictions) f1 = f1_score(actuals, predictions) fpr, tpr, _ = roc_curve(actuals, predictions) roc_auc = auc(fpr, tpr) return { \\"precision\\": precision, \\"recall\\": recall, \\"f1_score\\": f1, \\"roc_auc\\": roc_auc } # Mitigation of potential biases can include strategies such as regular model retraining, balanced dataset usage, and rigorous validation."},{"question":"def calculate(expression: str) -> int: Evaluates a mathematical expression containing +, -, *, / with the usual precedence rules. Division is integer division. >>> calculate(\\"3+5*2\\") == 13 >>> calculate(\\"10+2*6\\") == 22 >>> calculate(\\"100-40/5\\") == 92 >>> calculate(\\"10+3*4-2\\") == 20 >>> calculate(\\"7+6/3*5-8\\") == 9 >>> calculate(\\"123456789*1\\") == 123456789 >>> calculate(\\"42\\") == 42 >>> calculate(\\"10/3\\") == 3 >>> calculate(\\"2*2*2/2+3-1\\") == 6","solution":"def calculate(expression: str) -> int: Evaluates a mathematical expression containing +, -, *, / with the usual precedence rules. Division is integer division. def apply_operator(operands, operator): right = operands.pop() left = operands.pop() if operator == '+': operands.append(left + right) elif operator == '-': operands.append(left - right) elif operator == '*': operands.append(left * right) elif operator == '/': operands.append(left // right) operands = [] operators = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 operands.append(num) continue elif expression[i] in \\"+-*/\\": while (operators and operators[-1] in \\"*/\\" and expression[i] in \\"+-\\") or (operators and operators[-1] in \\"*/\\" and expression[i] in \\"*/\\"): apply_operator(operands, operators.pop()) operators.append(expression[i]) i += 1 while operators: apply_operator(operands, operators.pop()) return operands[0]"},{"question":"def distinct_permutations(s: str) -> List[str]: Returns all distinct permutations of the input string 's'. The function handles strings with: - Mixed uppercase and lowercase characters. - Special characters. - Numeric characters. The function also ensures improved performance and avoids recalculating permutations for the same set of characters multiple times. Edge cases: - Empty strings should return an empty list. - Single character strings should return a list with the single character. If the input is not a string, a TypeError should be raised. >>> distinct_permutations(\\"a\\") == [\\"a\\"] >>> distinct_permutations(\\"ab\\") == [\\"ab\\", \\"ba\\"] >>> distinct_permutations(\\"aab\\") == [\\"aab\\", \\"aba\\", \\"baa\\"] >>> distinct_permutations(\\"\\") == [\\"\\"] >>> distinct_permutations(\\"Ab\\") == [\\"Ab\\", \\"bA\\"] >>> distinct_permutations(\\"a@\\") == [\\"@a\\", \\"a@\\"] >>> distinct_permutations(\\"12\\") == [\\"12\\", \\"21\\"] >>> distinct_permutations(\\"a1A\\") == [\\"1Aa\\", \\"1aA\\", \\"A1a\\", \\"Aa1\\", \\"a1A\\", \\"aA1\\"] >>> distinct_permutations(123) raises TypeError >>> distinct_permutations(['a', 'b']) raises TypeError >>> distinct_permutations({'a': 1}) raises TypeError","solution":"def distinct_permutations(s): Returns all distinct permutations of the input string 's'. if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") def permute(s): if len(s) <= 1: return set([s]) permutations = set() for i in range(len(s)): for p in permute(s[:i] + s[i+1:]): permutations.add(s[i] + p) return permutations return sorted(permute(s)) print(distinct_permutations(\\"a\\")) print(distinct_permutations(\\"ab\\")) print(distinct_permutations(\\"aab\\")) print(distinct_permutations(\\"\\"))"},{"question":"def find_missing_number(arr): Create a function named \`find_missing_number\` that takes a list of unique integers ranging from 1 to n (inclusive), where one number is missing. The function should find and return the missing number. Args: arr (list): A list of unique integers with one integer missing in the range from 1 to n. Returns: int: The missing number. >>> find_missing_number([1, 2, 4, 5]) 3 >>> find_missing_number([2, 3, 4, 5]) 1 >>> find_missing_number([1, 2, 3, 4]) 5 >>> find_missing_number([1, 2, 3, 5, 6]) 4 >>> find_missing_number([2]) 1","solution":"def find_missing_number(arr): This function finds the missing number in a list of unique integers ranging from 1 to n. Args: arr (list): A list of unique integers with one integer missing in the range from 1 to n. Returns: int: The missing number. n = len(arr) + 1 total = n * (n + 1) // 2 sum_of_arr = sum(arr) return total - sum_of_arr"},{"question":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list. Parameters: list1, list2: List of integers sorted in ascending order. Returns: A single merged list sorted in ascending order. Examples: >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([1, 3], [2, 4, 6]) [1, 2, 3, 4, 6] >>> merge_sorted_lists([1, 3, 5], [2, 4]) [1, 2, 3, 4, 5] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_lists([1], [2]) [1, 2] >>> merge_sorted_lists([2], [1]) [1, 2] >>> merge_sorted_lists([1, 1, 1], [1, 1, 1]) [1, 1, 1, 1, 1, 1] >>> merge_sorted_lists([1, 3, 5], [1, 3, 5]) [1, 1, 3, 3, 5, 5] >>> merge_sorted_lists([-3, -2, -1], [-5, -4, 0]) [-5, -4, -3, -2, -1, 0] >>> merge_sorted_lists([-10, -5, 0], [-8, -3, 5]) [-10, -8, -5, -3, 0, 5]","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list. Parameters: list1, list2: List of integers sorted in ascending order. Returns: A single merged list sorted in ascending order. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append remaining elements if any merged_list.extend(list1[i:]) merged_list.extend(list2[j:]) return merged_list"},{"question":"import copy from typing import Dict, Any def deep_copy_dict(input_dict: Dict[Any, Any]) -> Dict[Any, Any]: Returns a deep copy of the input dictionary. Handles dictionaries with nested dictionaries, lists, and other mutable data types. Ensure that changes to the original dictionary do not affect the copied dictionary. Args: input_dict (Dict[Any, Any]): The dictionary to be deep copied Returns: Dict[Any, Any]: A deep copy of the input dictionary >>> deep_copy_dict({'a': 1, 'b': 2}) == {'a': 1, 'b': 2} True >>> deep_copy_dict({'a': {'b': 2}, 'c': [1, 2, 3]}) == {'a': {'b': 2}, 'c': [1, 2, 3]} True >>> copied = deep_copy_dict({'a': {'b': 2}, 'c': [1, 2, 3]}) >>> copied['a']['b'] = 3 >>> copied['c'].append(4) >>> copied['a']['b'] == 3 and copied['c'] == [1, 2, 3, 4] True >>> original = {'a': {'b': 2}, 'c': [1, 2, 3]} >>> copied = deep_copy_dict(original) >>> copied['a']['b'] == 2 and copied['c'] == [1, 2, 3] True","solution":"import copy def deep_copy_dict(input_dict): Returns a deep copy of the input dictionary. Handles dictionaries with nested dictionaries, lists, and other mutable data types. :param input_dict: The dictionary to be deep copied :return: A deep copy of the input dictionary return copy.deepcopy(input_dict)"},{"question":"import pandas as pd import matplotlib.pyplot as plt from io import StringIO def load_and_process_data(csv_path): Load the dataset, parse 'datetime' column as datetime object, and add 'hour' column. This function takes the path to a CSV file as input and returns a pandas DataFrame. >>> sample_data = datetime,season,weather,temp,humidity,windspeed,casual,registered,count 2023-10-01 00:00:00,1,1,14.76,81,0.0,3,13,16 2023-10-01 01:00:00,1,1,13.94,80,0.0,4,32,36 2023-10-01 02:00:00,1,1,13.76,79,0.0,2,22,24 >>> df = load_and_process_data(StringIO(sample_data)) >>> 'datetime' in df.columns and 'hour' in df.columns True def plot_bike_rentals_by_hour(df): Generate and display a line plot showing the average 'count', 'casual', and 'registered' bike rentals for each hour of the day. This function takes a pandas DataFrame as input and does not return anything. >>> sample_data = datetime,season,weather,temp,humidity,windspeed,casual,registered,count 2023-10-01 00:00:00,1,1,14.76,81,0.0,3,13,16 2023-10-01 01:00:00,1,1,13.94,80,0.0,4,32,36 2023-10-01 02:00:00,1,1,13.76,79,0.0,2,22,24 >>> df = load_and_process_data(StringIO(sample_data)) >>> plot_bike_rentals_by_hour(df)","solution":"import pandas as pd import matplotlib.pyplot as plt def load_and_process_data(csv_path): Load the dataset, parse 'datetime' column as datetime object, and add 'hour' column. df = pd.read_csv(csv_path, parse_dates=['datetime']) df['hour'] = df['datetime'].dt.hour return df def plot_bike_rentals_by_hour(df): Generate and display a line plot showing the average 'count', 'casual', and 'registered' bike rentals for each hour of the day. hourly_data = df.groupby('hour').mean() plt.figure(figsize=(10, 6)) plt.plot(hourly_data.index, hourly_data['count'], label='Total Count', color='blue', marker='o') plt.plot(hourly_data.index, hourly_data['casual'], label='Casual Count', color='green', marker='s') plt.plot(hourly_data.index, hourly_data['registered'], label='Registered Count', color='red', marker='^') plt.xlabel('Hour of the day') plt.ylabel('Average number of bike rentals') plt.title('Average Number of Bike Rentals by Hour') plt.legend() plt.grid(True) plt.xticks(hourly_data.index) plt.show()"},{"question":"def reorganize_string(s: str) -> str: Reorganizes a string so that no two adjacent characters are the same. If such an arrangement is not possible, returns an empty string. >>> reorganize_string(\\"aab\\") == \\"aba\\" >>> result = reorganize_string(\\"aaabbc\\") >>> result in [\\"ababac\\", \\"abacab\\"] >>> reorganize_string(\\"abc\\") == \\"abc\\" >>> reorganize_string(\\"aaab\\") == \\"\\" >>> reorganize_string(\\"aaaab\\") == \\"\\" >>> reorganize_string(\\"a\\") == \\"a\\" >>> reorganize_string(\\"\\") == \\"\\" >>> reorganize_string(\\"abab\\") == \\"abab\\" >>> result = reorganize_string(\\"aabb\\") >>> result in [\\"abab\\", \\"baba\\"]","solution":"from heapq import heappush, heappop from collections import Counter def reorganize_string(s): Reorganize the input string such that no two adjacent characters are the same. If it is not possible to rearrange the characters, return an empty string. # Count the frequency of each character char_counts = Counter(s) # Maximum heap to store the most frequent characters max_heap = [] for char, count in char_counts.items(): if count > (len(s) + 1) // 2: return \\"\\" heappush(max_heap, (-count, char)) prev_count, prev_char = 0, \\"\\" result = [] while max_heap: count, char = heappop(max_heap) result.append(char) # Push the previous character back to the heap if its count is not zero if prev_count < 0: heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char return \\"\\".join(result)"},{"question":"class Solution: def removeDuplicates(self, nums): Given a list of integers, remove the duplicates in-place such that each element appears only once and returns the new list. Do not allocate extra space for another list; you must do this by modifying the input list in-place with O(1) extra memory. Parameters: nums (List[int]): The list of integers from which you need to remove duplicates. Returns: List[int]: The list after removing duplicates while maintaining order. # Your code here # Unit Tests def test_remove_duplicates_general_case(): sol = Solution() nums = [1, 2, 3, 1, 2, 4, 5, 3] assert sol.removeDuplicates(nums) == [1, 2, 3, 4, 5] def test_remove_duplicates_all_unique(): sol = Solution() nums = [1, 2, 3, 4, 5] assert sol.removeDuplicates(nums) == [1, 2, 3, 4, 5] def test_remove_duplicates_all_duplicates(): sol = Solution() nums = [1, 1, 1, 1] assert sol.removeDuplicates(nums) == [1] def test_remove_duplicates_empty_list(): sol = Solution() nums = [] assert sol.removeDuplicates(nums) == [] def test_remove_duplicates_single_element(): sol = Solution() nums = [1] assert sol.removeDuplicates(nums) == [1] def test_remove_duplicates_with_zeros(): sol = Solution() nums = [0, 1, 0, 2, 0, 3] assert sol.removeDuplicates(nums) == [0, 1, 2, 3]","solution":"class Solution: def removeDuplicates(self, nums): Given a list of integers, remove the duplicates in-place such that each element appears only once and returns the new list. Do not allocate extra space for another list; you must do this by modifying the input list in-place with O(1) extra memory. Parameters: nums (List[int]): The list of integers from which you need to remove duplicates. Returns: List[int]: The list after removing duplicates while maintaining order. i = 0 # Initialize the pointer for the non-duplicate elements seen = set() for j in range(len(nums)): if nums[j] not in seen: seen.add(nums[j]) nums[i] = nums[j] i += 1 # Remove the remaining elements after the unique elements while len(nums) > i: nums.pop() return nums # Example Usage: sol = Solution() nums = [1, 2, 3, 1, 2, 4, 5, 3] print(sol.removeDuplicates(nums)) # Output should be [1, 2, 3, 4, 5]"},{"question":"from typing import List, Dict def eradicate_aliens(regions: List[Dict[str, int]]) -> int: Calculate the total number of days required to eradicate all Lycans and Vamps from the island. Args: regions (List[Dict[str, int]]): A list of dictionaries where each dictionary has two keys 'Lycans' and 'Vamps'. Returns: int: The total number of days required. Examples: >>> eradicate_aliens([{'Lycans': 5, 'Vamps': 2}, {'Lycans': 3, 'Vamps': 7}, {'Lycans': 1, 'Vamps': 0}]) 18 >>> eradicate_aliens([{'Lycans': 1, 'Vamps': 1}, {'Lycans': 2, 'Vamps': 5}, {'Lycans': 0, 'Vamps': 0}]) 9 >>> eradicate_aliens([{'Lycans': 0, 'Vamps': 0}, {'Lycans': 0, 'Vamps': 0}, {'Lycans': 0, 'Vamps': 0}]) 0","solution":"from typing import List, Dict def eradicate_aliens(regions: List[Dict[str, int]]) -> int: total_days = 0 for region in regions: total_days += region.get('Lycans', 0) + region.get('Vamps', 0) return total_days"},{"question":"from typing import List def merge_and_sort_lists(list1: List[int], list2: List[int]) -> List[int]: Takes two lists of integers, merges them into a single list, removes any duplicate values, and returns the list sorted in descending order. >>> merge_and_sort_lists([3, 1, 4], [4, 5, 9]) == [9, 5, 4, 3, 1] >>> merge_and_sort_lists([-1, -2, -3], [-3, 0, 1]) == [1, 0, -1, -2, -3] >>> merge_and_sort_lists([1, 2, 3], []) == [3, 2, 1] >>> merge_and_sort_lists([], []) == [] >>> merge_and_sort_lists([2], [1]) == [2, 1] >>> merge_and_sort_lists([1000000, 999999], [999999, 1000001]) == [1000001, 1000000, 999999]","solution":"from typing import List def merge_and_sort_lists(list1: List[int], list2: List[int]) -> List[int]: Takes two lists of integers, merges them, removes duplicates, and returns the sorted list in descending order. # Merge lists merged_list = list1 + list2 # Remove duplicates by converting to a set unique_list = set(merged_list) # Sort the list in descending order sorted_list = sorted(unique_list, reverse=True) return sorted_list"},{"question":"def has_pair_with_sum(arr: list[int], target: int) -> bool: Determines if there are two distinct integers in the array whose sum equals the target sum. Args: arr (list of int): Array of integers. target (int): Target sum. Returns: bool: True if such a pair exists, otherwise False. Examples: >>> has_pair_with_sum([2, 7, 11, 15], 9) True >>> has_pair_with_sum([3, -1, 4, 6], 10) False","solution":"def has_pair_with_sum(arr, target): Determines if there are two distinct integers in the array whose sum equals the target sum. Args: arr (list of int): Array of integers. target (int): Target sum. Returns: bool: True if such a pair exists, otherwise False. seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False"},{"question":"def sort_by_score(records): Sorts a list of names by their corresponding scores in descending order. In case of a tie, names are sorted alphabetically. >>> sort_by_score([('Alice', 92), ('Bob', 95), ('Charlie', 95), ('Dave', 88)]) ['Bob', 'Charlie', 'Alice', 'Dave'] >>> sort_by_score([('Alice', 100), ('Bob', 100), ('Charlie', 90)]) ['Alice', 'Bob', 'Charlie'] >>> sort_by_score([('John', 85), ('Jane', 90), ('Doe', 85), ('Smith', 90)]) ['Jane', 'Smith', 'Doe', 'John'] >>> sort_by_score([]) [] >>> sort_by_score([('Single', 50)]) ['Single'] >>> sort_by_score([('Alpha', 77), ('Beta', 77), ('Charlie', 77)]) ['Alpha', 'Beta', 'Charlie']","solution":"def sort_by_score(records): Sorts a list of tuples by the scores first in descending order, and then by names in alphabetical order in case of ties. # Sort the records by two keys: # - Negative score for descending order (large to small) # - Name for alphabetical order in case of ties sorted_records = sorted(records, key=lambda x: (-x[1], x[0])) # Extract the names from the sorted records sorted_names = [record[0] for record in sorted_records] return sorted_names"},{"question":"from typing import List def keyboard_words(words: List[str]) -> List[str]: Returns a list of words that can be typed using letters of only one row on a standard QWERTY keyboard. Non-word elements are filtered out, and the function is case insensitive. >>> keyboard_words([\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"]) ['Alaska', 'Dad'] >>> keyboard_words([\\"HeLLo\\", \\"ALAska\\", \\"dAD\\", \\"pEACe\\"]) ['ALAska', 'dAD'] >>> keyboard_words([\\"Hello\\", \\"Alaska\\", 123, \\"Dad\\", None, \\"Peace\\", 45.67, True]) ['Alaska', 'Dad'] pass # Unit tests def test_words_single_row(): assert keyboard_words([\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"]) == [\\"Alaska\\", \\"Dad\\"] def test_words_mixed_case(): assert keyboard_words([\\"HeLLo\\", \\"ALAska\\", \\"dAD\\", \\"pEACe\\"]) == [\\"ALAska\\", \\"dAD\\"] def test_words_non_strings(): assert keyboard_words([\\"Hello\\", \\"Alaska\\", 123, \\"Dad\\", None, \\"Peace\\", 45.67, True]) == [\\"Alaska\\", \\"Dad\\"] def test_empty_list(): assert keyboard_words([]) == [] def test_no_valid_word(): assert keyboard_words([\\"Cat\\", \\"Dog\\", \\"Fish\\"]) == [] def test_all_valid(): assert keyboard_words([\\"Dad\\", \\"Dad\\", \\"Alaska\\"]) == [\\"Dad\\", \\"Dad\\", \\"Alaska\\"]","solution":"def keyboard_words(words): Returns a list of words that can be typed using letters of only one row of a QWERTY keyboard. Non-word elements are filtered out. The function is case insensitive. row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") rows = [row1, row2, row3] result = [] for word in words: # Filter non-strings if not isinstance(word, str): continue lower_word = word.lower() for row in rows: if all(letter in row for letter in lower_word): result.append(word) break return result"},{"question":"def find_first_non_repeating(arr): Finds the first non-repeating integer in the array. If there is no non-repeating integer, return None. >>> find_first_non_repeating([4, 5, 1, 2, 0, 4, 5, 1, 2]) 0 >>> find_first_non_repeating([-10, -1, -2, -10, -3, -1, -2]) -3 >>> find_first_non_repeating([2, 2, 3, 3]) None >>> find_first_non_repeating([]) None >>> find_first_non_repeating([1]) 1","solution":"def find_first_non_repeating(arr): Finds the first non-repeating integer in the array. If there is no non-repeating integer, return None. count_map = {} # First pass: count occurrences of each number for num in arr: if num in count_map: count_map[num] += 1 else: count_map[num] = 1 # Second pass: find the first non-repeating number for num in arr: if count_map[num] == 1: return num # If no non-repeating integer is found return None"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression string containing non-negative integers, +, -, *, / operators, and parentheses, such as \\"3+(2*2)\\", and returns the integer result. >>> evaluate_expression(\\"3+(2*2)\\") 7 >>> evaluate_expression(\\"10+2*6\\") 22 >>> evaluate_expression(\\"100*2+12\\") 212 >>> evaluate_expression(\\"100*(2+12)\\") 1400 >>> evaluate_expression(\\"100*(2+12)/14\\") 100","solution":"def evaluate_expression(expression): Evaluates a mathematical expression string containing non-negative integers, +, -, *, / operators, and parentheses, and returns the integer result. def compute(ops, values): right = values.pop() left = values.pop() op = ops.pop() if op == '+': values.append(left + right) elif op == '-': values.append(left - right) elif op == '*': values.append(left * right) elif op == '/': values.append(left // right) # Integer division precedence = {'+': 1, '-': 1, '*': 2, '/': 2} ops = [] values = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i] == '(': ops.append(expression[i]) elif expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == ')': while ops and ops[-1] != '(': compute(ops, values) ops.pop() else: while ops and ops[-1] in precedence and precedence[ops[-1]] >= precedence[expression[i]]: compute(ops, values) ops.append(expression[i]) i += 1 while ops: compute(ops, values) return values[0]"},{"question":"from typing import List class TreasurePath: @staticmethod def validateGrid(grid: List[List[int]]) -> str: Validates the grid dimensions. >>> TreasurePath.validateGrid([[1,2,3], [4,5,6], [7,8,9]]) '' >>> TreasurePath.validateGrid([]) 'Invalid grid dimensions' >>> TreasurePath.validateGrid([[]]) 'Invalid grid dimensions' >>> TreasurePath.validateGrid([[1,2,3], [\\"a\\",5,6], [7,8,9]]) 'Invalid grid dimensions' @staticmethod def maxTreasure(grid: List[List[int]]) -> int: Calculates the maximum sum of treasures collected from the top-left to the bottom-right cell of a grid. >>> TreasurePath.maxTreasure([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 12 >>> TreasurePath.maxTreasure([]) 'Invalid grid dimensions' >>> TreasurePath.maxTreasure([[]]) 'Invalid grid dimensions' >>> TreasurePath.maxTreasure([ ... [1, 2], ... [1, 1] ... ]) 4 >>> TreasurePath.maxTreasure([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29 >>> TreasurePath.maxTreasure([ ... [5] ... ]) 5 >>> TreasurePath.maxTreasure([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 5 def TreasurePathTest(): Executes test cases for the maxTreasure method of TreasurePath class, printing the results. if __name__ == \\"__main__\\": TreasurePathTest()","solution":"from typing import List class TreasurePath: @staticmethod def validateGrid(grid: List[List[int]]) -> str: if not grid or not all(isinstance(row, list) for row in grid) or not all(isinstance(cell, int) for row in grid for cell in row): return \\"Invalid grid dimensions\\" m = len(grid) n = len(grid[0]) if m <= 0 or n <= 0: return \\"Invalid grid dimensions\\" return \\"\\" @staticmethod def maxTreasure(grid: List[List[int]]) -> int: error_message = TreasurePath.validateGrid(grid) if error_message: return error_message m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"from typing import List, Tuple def max_subarray_indices(arr: List[int]) -> Tuple[int, int]: Finds the start and end indices of the longest contiguous subarray with the highest sum. If multiple subarrays have the same highest sum, returns the indices of the first one. >>> max_subarray_indices([1]) (0, 0) >>> max_subarray_indices([-1]) (0, 0) >>> max_subarray_indices([1, 2, 3, 4]) (0, 3) >>> max_subarray_indices([-1, -2, -3, -4]) (0, 0) >>> max_subarray_indices([-2, 1, -3, 4, -1, 2, 1, -5, 4]) (3, 6) >>> max_subarray_indices([]) (-1, -1) >>> max_subarray_indices([-1, -2, 5, 6]) (2, 3) >>> max_subarray_indices([1, -2, 3, 5, -3, 3, 4]) (2, 6)","solution":"def max_subarray_indices(arr): Finds the start and end indices of the longest contiguous subarray with the highest sum. If multiple subarrays have the same highest sum, returns the indices of the first one. :param arr: List of integers :return: Tuple containing start and end indices if not arr: return -1, -1 max_sum = current_sum = arr[0] start = end = temp_start = 0 for i in range(1, len(arr)): if current_sum < 0: current_sum = arr[i] temp_start = i else: current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return start, end"},{"question":"def can_form_palindrome(s: str) -> bool: Detects whether the given string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabbcc\\") True","solution":"def can_form_palindrome(s): Detects whether the given string can be rearranged to form a palindrome. Args: s (str): The input string. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. char_counts = {} # Dictionary to hold the count of each character # Count occurrences of each character in the string for char in s: if char in char_counts: char_counts[char] += 1 else: char_counts[char] = 1 # Count how many characters have an odd count odd_count = 0 for count in char_counts.values(): if count % 2 != 0: odd_count += 1 # For the string to be rearranged into a palindrome, # there must be at most one character with an odd count return odd_count <= 1"},{"question":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers less than n. Uses the Sieve of Eratosthenes method. Includes error handling for invalid inputs. If the input is invalid, the function should return an empty list. >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> sieve_of_eratosthenes(\\"a string\\") [] >>> sieve_of_eratosthenes(7.2) [] >>> sieve_of_eratosthenes(-10) [] >>> sieve_of_eratosthenes(0) [] >>> sieve_of_eratosthenes(1) [] >>> sieve_of_eratosthenes(2) [] >>> sieve_of_eratosthenes(3) [2] >>> sieve_of_eratosthenes(4) [2, 3] # Add your implementation here","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers less than n. Uses the Sieve of Eratosthenes method. if not isinstance(n, int) or n <= 2: return [] # Initialize a boolean array indicating prime status primes = [True] * n primes[0] = primes[1] = False # 0 and 1 are not prime numbers p = 2 while (p * p < n): if primes[p]: for i in range(p * p, n, p): primes[i] = False p += 1 return [p for p, is_prime in enumerate(primes) if is_prime]"},{"question":"def find_pairs_with_sum(arr: List[int], target: int) -> List[Tuple[int, int]]: Finds all unique pairs of integers in the array whose sum equals the target sum. Each integer in the array is used at most once. >>> find_pairs_with_sum([1, 2, 3, 4, 3, 5], 6) [(1, 5), (2, 4), (3, 3)] >>> find_pairs_with_sum([1, 2, 3, 4, 5], 10) []","solution":"from typing import List, Tuple def find_pairs_with_sum(arr: List[int], target: int) -> List[Tuple[int, int]]: Finds all unique pairs of integers in the array whose sum equals the target sum. Each integer in the array is used at most once. seen = set() # To track seen numbers pairs = set() # To track unique pairs for num in arr: complement = target - num if complement in seen: # Add pairs as ordered tuple (min, max) to avoid duplicates pairs.add((min(num, complement), max(num, complement))) seen.add(num) # Convert the set of pairs to a list of tuples return list(pairs)"},{"question":"def has_all_unique_chars(s: str) -> bool: Returns True if the string contains all unique characters (case insensitive and ignoring spaces), and False otherwise. >>> has_all_unique_chars(\\"abcdefg\\") == True >>> has_all_unique_chars(\\"AbCdEfG\\") == True >>> has_all_unique_chars(\\"abcdefga\\") == False >>> has_all_unique_chars(\\"The quick brown fox\\") == False >>> has_all_unique_chars(\\"The quick fox\\") == True >>> has_all_unique_chars(\\"\\") == True >>> has_all_unique_chars(\\"a\\") == True","solution":"def has_all_unique_chars(s): Returns True if the string contains all unique characters (case insensitive and ignoring spaces), and False otherwise. s = s.replace(\\" \\", \\"\\").lower() for i in range(len(s)): for j in range(i + 1, len(s)): if s[i] == s[j]: return False return True"},{"question":"def max_subarray_sum(arr): Returns the largest sum of any contiguous subarray within the list. If the list is empty, return 0. >>> max_subarray_sum([]) == 0 >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([-5]) == -5 >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) == -1 >>> max_subarray_sum([1, -2, 3, 4, -1, 2, 1, -5, 4]) == 9 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 >>> max_subarray_sum([5, 4, -1, 7, 8]) == 23 >>> max_subarray_sum([0, 0, 0, 0]) == 0 >>> max_subarray_sum([-1, 0, -2, 0]) == 0","solution":"def max_subarray_sum(arr): Returns the largest sum of any contiguous subarray within the list. If the list is empty, return 0. if not arr: return 0 max_ending_here = arr[0] max_so_far = arr[0] for num in arr[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def prime_frequencies(lst: List[int]) -> List[Tuple[int, int]]: Implement a function that receives a list of integers and returns a new list containing only the prime numbers from the input list, paired with their frequencies in ascending order. >>> prime_frequencies([7, 3, 5, 7, 3, 2, 7, 11, 5, 13, 2]) [(2, 2), (3, 2), (5, 2), (7, 3), (11, 1), (13, 1)] >>> prime_frequencies([2, 2, 2]) [(2, 3)] >>> prime_frequencies([1, 4, 6, 8, 10]) [] >>> prime_frequencies([4, 6, 7, 9, 11, 11]) [(7, 1), (11, 2)] >>> prime_frequencies([]) [] >>> prime_frequencies([5, 5, 5, 5]) [(5, 4)]","solution":"def is_prime(n): if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def prime_frequencies(lst): prime_counts = {} for number in lst: if is_prime(number): if number in prime_counts: prime_counts[number] += 1 else: prime_counts[number] = 1 prime_list = list(prime_counts.items()) prime_list.sort() return prime_list # Example usage: # lst = [7, 3, 5, 7, 3, 2, 7, 11, 5, 13, 2] # Output should be: [(2, 2), (3, 2), (5, 2), (7, 3), (11, 1), (13, 1)]"},{"question":"def word_with_most_unique_chars(s: str) -> str: Returns the word with the highest number of unique characters from the input string. >>> word_with_most_unique_chars(\\"hello world algorithms are fun\\") \\"algorithms\\" >>> word_with_most_unique_chars(\\"abcde abcdf\\") \\"abcde\\" >>> word_with_most_unique_chars(\\"university\\") \\"university\\" >>> word_with_most_unique_chars(\\"\\") \\"\\" >>> word_with_most_unique_chars(\\"aaaa bbbb cccc\\") \\"aaaa\\" >>> word_with_most_unique_chars(\\"abc aab aba\\") \\"abc\\"","solution":"def word_with_most_unique_chars(s: str) -> str: Returns the word with the highest number of unique characters from the input string. :param s: A string of words separated by spaces. :return: The word with the highest number of unique characters. words = s.split() max_unique_count = 0 result_word = \\"\\" for word in words: unique_count = len(set(word)) if unique_count > max_unique_count: max_unique_count = unique_count result_word = word return result_word"},{"question":"import pandas as pd def create_and_filter_dataframe() -> pd.DataFrame: Incorporate the pandas library in Python. Create a DataFrame object with two columns, 'A' and 'B'. 'A' should contain integers from 1 to 5, and 'B' should contain their respective squares. After constructing the DataFrame, add a new column 'C' which is the sum of columns 'A' and 'B'. Finally, filter the DataFrame to display only those rows where the value in column 'C' is greater than 10. >>> df = create_and_filter_dataframe() >>> list(df['A']) [3, 4, 5] >>> list(df['B']) [9, 16, 25] >>> list(df['C']) [12, 20, 30] # Create DataFrame data = pd.DataFrame({ 'A': [1, 2, 3, 4, 5], 'B': [1, 4, 9, 16, 25] }) # Add column 'C' data['C'] = data['A'] + data['B'] # Filter rows where 'C' is greater than 10 filtered_data = data[data['C'] > 10] return filtered_data","solution":"import pandas as pd # Create DataFrame data = pd.DataFrame({ 'A': [1, 2, 3, 4, 5], 'B': [1, 4, 9, 16, 25] }) # Add column 'C' data['C'] = data['A'] + data['B'] # Filter rows where 'C' is greater than 10 filtered_data = data[data['C'] > 10] # Result filtered_data"},{"question":"import heapq def kth_smallest_element(arr, k): Returns the kth smallest element in an unsorted array. Parameters: arr (list): List of integers k (int): Positive integer representing the kth position Returns: int: The kth smallest element in the array str: Error message if k is out of bounds >>> kth_smallest_element([3, 2, 1, 5, 6, 4], 2) 2 >>> kth_smallest_element([3, 2, 3, 1, 2, 4, 5, 5, 6], 9) 6 >>> kth_smallest_element([3, 2, 1], 4) \\"Error: k is greater than the length of the array\\" >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 3) 7 >>> kth_smallest_element([5], 1) 5 >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 1) 3","solution":"import heapq def kth_smallest_element(arr, k): Returns the kth smallest element in an unsorted array. Parameters: arr (list): List of integers k (int): Positive integer representing the kth position Returns: int: The kth smallest element in the array str: Error message if k is out of bounds if k > len(arr): return \\"Error: k is greater than the length of the array\\" return heapq.nsmallest(k, arr)[-1]"},{"question":"def count_characters(input_str: str) -> dict: Write a function that takes a string as input and returns a dictionary. The dictionary should contain the count of each character in the string, regardless of case. >>> count_characters(\\"HelloWorld\\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> count_characters(\\"\\") == {} >>> count_characters(\\"AaBbCc\\") == {'a': 2, 'b': 2, 'c': 2} >>> count_characters(\\"aaaaa\\") == {'a': 5} >>> count_characters(\\"Hello, World!\\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, ',': 1, ' ': 1, 'w': 1, 'r': 1, 'd': 1, '!': 1} pass","solution":"def count_characters(input_str): Returns a dictionary with the count of each character in input_str. Case insensitivity is achieved by converting all characters to lowercase. count_dict = {} for char in input_str.lower(): if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 return count_dict"},{"question":"def caesar_cipher(S: str, K: int) -> str: Shifts each letter in the string S by K positions in the alphabet. Wraps around for both lowercase and uppercase letters. Non-alphabetic characters remain unchanged. >>> caesar_cipher(\\"Hello, World!\\", 5) \\"Mjqqt, Btwqi!\\" >>> caesar_cipher(\\"xyzXYZ\\", 3) \\"abcABC\\" >>> caesar_cipher(\\"Hello, World!\\", 0) \\"Hello, World!\\" >>> caesar_cipher(\\"Mjqqt, Btwqi!\\", -5) \\"Hello, World!\\" >>> caesar_cipher(\\"Hello, World!\\", 52) \\"Hello, World!\\" >>> caesar_cipher(\\"123 Hello!\\", 7) \\"123 Olssv!\\" >>> caesar_cipher(\\"123 %^&*\\", 10) \\"123 %^&*\\" >>> caesar_cipher(\\"Hello, World!\\", 26) \\"Hello, World!\\"","solution":"def caesar_cipher(S: str, K: int) -> str: Shifts each letter in the string S by K positions in the alphabet. Wraps around for both lowercase and uppercase letters. Non-alphabetic characters remain unchanged. :param S: The input string to shift. :param K: The number of positions to shift each letter by. :return: The shifted string. result = [] for char in S: if char.isalpha(): base = ord('A') if char.isupper() else ord('a') shifted_char = chr((ord(char) - base + K) % 26 + base) result.append(shifted_char) else: result.append(char) return ''.join(result)"},{"question":"def divisible_by_3_and_5(numbers): Returns a list of numbers that are divisible by both 3 and 5 from the input list. :param numbers: List of integers :return: List of integers divisible by both 3 and 5 >>> divisible_by_3_and_5([10, 15, 30, 50, 75, 80]) [15, 30, 75] >>> divisible_by_3_and_5([1, 2, 4, 7, 11]) []","solution":"def divisible_by_3_and_5(numbers): Returns a list of numbers that are divisible by both 3 and 5 from the input list. :param numbers: List of integers :return: List of integers divisible by both 3 and 5 return [num for num in numbers if num % 3 == 0 and num % 5 == 0]"},{"question":"def two_sum(nums, target): Returns the indices of the two numbers that add up to the target value. :param nums: List of integers :param target: Target sum :return: List containing the indices of the two numbers >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([1, 2, 3], 7) [] >>> two_sum([123456, 987654], 1111110) [0, 1] >>> two_sum([5, 5, 2, 4], 10) [0, 1]","solution":"def two_sum(nums, target): Returns the indices of the two numbers that add up to the target value. :param nums: List of integers :param target: Target sum :return: List containing the indices of the two numbers num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return []"},{"question":"def is_prime(n: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(-1) False >>> is_prime(0) False >>> is_prime(1) False def sum_primes_in_range(lst: List[int], min_value: int, max_value: int) -> int: Return the sum of the elements that are both prime numbers and lie within a given range [min_value, max_value], inclusive. >>> sum_primes_in_range([1, 4, 6, 8, 10], 1, 10) 0 >>> sum_primes_in_range([1, 2, 3, 4, 5, 7, 11], 1, 10) 17 >>> sum_primes_in_range([-1, -2, 2, 3, 11, 13], 1, 10) 5 >>> sum_primes_in_range([1, 4, 6, 8, 10, 7], 6, 7) 7 >>> sum_primes_in_range([1, 2, 6, 8, 9, 11], 11, 11) 11 >>> sum_primes_in_range([], 1, 10) 0","solution":"def is_prime(n): Checks if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def sum_primes_in_range(lst, min_value, max_value): Returns the sum of prime numbers within the range [min_value, max_value] from the list. return sum(x for x in lst if is_prime(x) and min_value <= x <= max_value)"},{"question":"from typing import List def process_odd_squares(input_list: List[int]) -> List[int]: Takes a list of integers and returns a new list containing the squares of all the odd numbers from the original list, sorted in descending order without duplicates. Parameters: input_list (list): A list of integers. Returns: list: A list containing the squares of odd numbers in descending order. >>> process_odd_squares([1, 2, 3, 4, 5, 3, 1, 7]) [49, 25, 9, 1] >>> process_odd_squares([2, 4, 6, 8]) [] >>> process_odd_squares([1, 3, 5, 7]) [49, 25, 9, 1] >>> process_odd_squares([1, 1, 3, 3, 3, 5, 5, 5, 7, 7, 7, 7]) [49, 25, 9, 1] >>> process_odd_squares([15, 2, 13, 4, 14, 3]) [225, 169, 9] >>> process_odd_squares([-1, -2, -3, -4, -5]) [25, 9, 1] >>> process_odd_squares([]) []","solution":"def process_odd_squares(input_list): Takes a list of integers and returns a new list containing the squares of all the odd numbers from the original list, sorted in descending order without duplicates. Parameters: input_list (list): A list of integers. Returns: list: A list containing the squares of odd numbers in descending order. # Get all odd numbers from the list odd_numbers = [x for x in input_list if x % 2 != 0] # Remove duplicates unique_odd_numbers = list(set(odd_numbers)) # Calculate squares of these numbers squared_odds = [x ** 2 for x in unique_odd_numbers] # Sort squares in descending order return sorted(squared_odds, reverse=True)"},{"question":"def flatten(nested_list): Flattens a nested list into a single list of values while preserving the order. >>> flatten([1, [2, [3, 4], 5], 6, [7, [8, [9], 10], 11], 12, []]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] >>> flatten([1, 2, 3, 4]) [1, 2, 3, 4] >>> flatten([]) [] >>> flatten(['a', ['b', ['c']], 1, 2, [3, 'd']]) ['a', 'b', 'c', 1, 2, 3, 'd'] >>> flatten([[], [1, 2, []], 3, []]) [1, 2, 3]","solution":"def flatten(nested_list): Flattens a nested list into a single list of values while preserving the order. result = [] for element in nested_list: if isinstance(element, list): result.extend(flatten(element)) else: result.append(element) return result"},{"question":"def find_most_frequent(numbers: List[int]) -> int: Returns the integer that appears most frequently in the list. If there is a tie, returns any one of the most frequent integers. >>> find_most_frequent([1, 3, 2, 2, 4, 1, 1]) 1 >>> find_most_frequent([4, 4, 1, 2, 2]) 4 # or 2","solution":"def find_most_frequent(numbers): Returns the integer that appears most frequently in the list. If there is a tie, returns any one of the most frequent integers. frequency = {} for num in numbers: frequency[num] = frequency.get(num, 0) + 1 most_frequent = max(frequency, key=frequency.get) return most_frequent"},{"question":"def sequential_calculator(operations: List[Tuple[str, int]]) -> float: Processes a list of mathematical operations sequentially and returns the final result. operations: List of tuples, each containing a string ('+', '-', '*', '/') and an integer. Returns the final result after processing all operations. >>> sequential_calculator([('+', 5), ('-', 3), ('*', 10), ('/', 2)]) == 10.0 >>> sequential_calculator([('+', 5), ('/', 0)]) == 5 >>> sequential_calculator([('+', 5), ('+', 10), ('+', 20)]) == 35 >>> sequential_calculator([('-', 3), ('-', 2), ('-', 5)]) == -10 >>> sequential_calculator([('+', 10), ('-', 7), ('*', 3), ('/', 2)]) == 4.5 >>> sequential_calculator([]) == 0 >>> sequential_calculator([('/', 5), ('*', 3), ('+', 1)]) == 1","solution":"def sequential_calculator(operations): Processes a list of mathematical operations sequentially and returns the final result. operations: List of tuples, each containing a string ('+', '-', '*', '/') and an integer. Returns the final result after processing all operations. result = 0 for operation, value in operations: if operation == '+': result += value elif operation == '-': result -= value elif operation == '*': result *= value elif operation == '/': if value == 0: print(\\"Error: Division by zero. Stopping further operations.\\") return result result /= value return result"},{"question":"from typing import List def max_difference(arr: List[int]) -> int: Compute the maximum difference between any two elements in the list such that the larger element appears after the smaller element. Return -1 if the list has less than two elements. >>> max_difference([7, 1, 5, 4]) == 4 >>> max_difference([9, 4, 3, 2]) == -1 >>> max_difference([1, 2, 90, 10, 110]) == 109 >>> max_difference([]) == -1 >>> max_difference([9]) == -1 >>> max_difference([1, 2, 3, 4, 5]) == 4 >>> max_difference([5, 4, 3, 2, 1]) == -1 >>> max_difference([2, 3, 1, 5, 4]) == 4","solution":"from typing import List def max_difference(arr: List[int]) -> int: Compute the maximum difference between any two elements in the list such that the larger element appears after the smaller element. Return -1 if the list has less than two elements. if len(arr) < 2: return -1 min_element = arr[0] max_diff = -1 for i in range(1, len(arr)): if arr[i] > min_element: max_diff = max(max_diff, arr[i] - min_element) min_element = min(min_element, arr[i]) return max_diff"},{"question":"from sklearn.utils import resample import pandas as pd import numpy as np def balance_classes_upsampling(X, y): Balance dataset using up-sampling (i.e., over-sampling the minority class). Parameters: X: features (DataFrame or NumPy array) y: labels (Array-like) Returns: X_resampled, y_resampled: Balanced features and labels >>> X, y = np.random.rand(100, 5), np.array([0] * 90 + [1] * 10) >>> X_resampled, y_resampled = balance_classes_upsampling(X, y) >>> len(y_resampled) 180 >>> np.sum(y_resampled == 0) 90 >>> np.sum(y_resampled == 1) 90 pass def balance_classes_downsampling(X, y): Balance dataset using down-sampling (i.e., under-sampling the majority class). Parameters: X: features (DataFrame or NumPy array) y: labels (Array-like) Returns: X_resampled, y_resampled: Balanced features and labels >>> X, y = np.random.rand(100, 5), np.array([0] * 90 + [1] * 10) >>> X_resampled, y_resampled = balance_classes_downsampling(X, y) >>> len(y_resampled) 20 >>> np.sum(y_resampled == 0) 10 >>> np.sum(y_resampled == 1) 10 pass","solution":"from sklearn.utils import resample from sklearn.ensemble import RandomForestClassifier import numpy as np import pandas as pd def balance_classes_upsampling(X, y): Balance dataset using up-sampling (i.e., over-sampling the minority class). Parameters: X: features (DataFrame or NumPy array) y: labels (Array-like) Returns: X_resampled, y_resampled: Balanced features and labels X = pd.DataFrame(X) y = pd.Series(y) # Concatenate our training data back together data = pd.concat([X, y], axis=1) # Separate majority and minority classes majority_class = data[y == 0] minority_class = data[y == 1] # Upsample minority class minority_upsampled = resample(minority_class, replace=True, # sample with replacement n_samples=len(majority_class), # match number in majority class random_state=42) # reproducible results # Combine majority class with upsampled minority class upsampled = pd.concat([majority_class, minority_upsampled]) return upsampled.iloc[:, :-1].values, upsampled.iloc[:, -1].values def balance_classes_downsampling(X, y): Balance dataset using down-sampling (i.e., under-sampling the majority class). Parameters: X: features (DataFrame or NumPy array) y: labels (Array-like) Returns: X_resampled, y_resampled: Balanced features and labels X = pd.DataFrame(X) y = pd.Series(y) # Concatenate our training data back together data = pd.concat([X, y], axis=1) # Separate majority and minority classes majority_class = data[y == 0] minority_class = data[y == 1] # Downsample majority class majority_downsampled = resample(majority_class, replace=False, # sample without replacement n_samples=len(minority_class), # match number in minority class random_state=42) # reproducible results # Combine minority class with downsampled majority class downsampled = pd.concat([minority_class, majority_downsampled]) return downsampled.iloc[:, :-1].values, downsampled.iloc[:, -1].values # Example usage: # Assuming X_train and y_train are your features and labels respectively # X_train_upsampled, y_train_upsampled = balance_classes_upsampling(X_train, y_train) # X_train_downsampled, y_train_downsampled = balance_classes_downsampling(X_train, y_train) # Training a classifier with the balanced dataset # clf = RandomForestClassifier() # clf.fit(X_train_upsampled, y_train_upsampled)"},{"question":"def merge_and_sort_dicts(dict1: dict, dict2: dict) -> dict: Merges two dictionaries by combining values of any common keys and sorts the resulting dictionary by values in descending order. If values are the same, sorts keys in ascending order alphabetically. >>> merge_and_sort_dicts({'a': 1, 'b': 2}, {'c': 3, 'd': 4}) {'d': 4, 'c': 3, 'b': 2, 'a': 1} >>> merge_and_sort_dicts({'a': 1, 'b': 2}, {'b': 3, 'c': 1}) {'b': 5, 'c': 1, 'a': 1} >>> merge_and_sort_dicts({'a': 100, 'b': 200}, {'b': 300, 'c': 400}) {'c': 400, 'b': 500, 'a': 100} >>> merge_and_sort_dicts({'a': 50}, {'b': 50, 'c': 50}) {'a': 50, 'b': 50, 'c': 50} >>> merge_and_sort_dicts({}, {'a': 1, 'b': 2}) {'b': 2, 'a': 1} >>> merge_and_sort_dicts({}, {}) {}","solution":"def merge_and_sort_dicts(dict1, dict2): Merges two dictionaries by combining values of any common keys and sorts the resulting dictionary by values in descending order. If values are the same, sorts keys in ascending order alphabetically. # Combine the dictionaries merged_dict = dict1.copy() for key, value in dict2.items(): if key in merged_dict: merged_dict[key] += value else: merged_dict[key] = value # Sort the dictionary by values in descending order, and by keys in ascending order if values are the same sorted_dict = dict(sorted(merged_dict.items(), key=lambda item: (-item[1], item[0]))) return sorted_dict"},{"question":"def run_length_encoding(s: str) -> str: Return the run-length encoded string for the input string s. For example: >>> run_length_encoding(\\"aaabbccca\\") 'a3b2c3a1' >>> run_length_encoding(\\"abc\\") 'a1b1c1' if not s: raise ValueError(\\"Input string is empty\\") encoded_str = \\"\\" count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: encoded_str += s[i - 1] + str(count) count = 1 encoded_str += s[-1] + str(count) return encoded_str # Unit Tests def test_empty_string(): try: run_length_encoding(\\"\\") except ValueError as e: assert str(e) == \\"Input string is empty\\" else: assert False, \\"Expected ValueError for empty string\\" def test_no_repeating_characters(): assert run_length_encoding(\\"abc\\") == \\"a1b1c1\\" def test_single_character_string(): assert run_length_encoding(\\"a\\") == \\"a1\\" def test_repeating_characters(): assert run_length_encoding(\\"aaabbccca\\") == \\"a3b2c3a1\\" def test_mixed_characters(): assert run_length_encoding(\\"abcdabc\\") == \\"a1b1c1d1a1b1c1\\"","solution":"def run_length_encoding(s): Return the run-length encoded string for the input string s. if not s: raise ValueError(\\"Input string is empty\\") encoded_str = \\"\\" count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: encoded_str += s[i - 1] + str(count) count = 1 # Don't forget to add the last set of characters encoded_str += s[-1] + str(count) return encoded_str"},{"question":"def reverse_nested_list(nested_list): Recursively reverses a given nested list. The function maintains the structure of the nested list but reverses the order of elements at each level. >>> reverse_nested_list([1, 2, 3, 4]) [4, 3, 2, 1] >>> reverse_nested_list([1, [2, 3], 4]) [4, [3, 2], 1] >>> reverse_nested_list([1, [2, [3, 4], 5], 6]) [6, [5, [4, 3], 2], 1] >>> reverse_nested_list([1, [\\"a\\", [2.5, \\"b\\"], 3], 4.1]) [4.1, [3, [\\"b\\", 2.5], \\"a\\"], 1] >>> reverse_nested_list([]) [] >>> reverse_nested_list([1, [], [3, []]]) [[[], 3], [], 1] >>> reverse_nested_list([[]]) [[]]","solution":"def reverse_nested_list(nested_list): Recursively reverses a given nested list. The function maintains the structure of the nested list but reverses the order of elements at each level. :param nested_list: list to be reversed :return: reversed nested list if not isinstance(nested_list, list): return nested_list return [reverse_nested_list(item) for item in reversed(nested_list)]"},{"question":"def sortNumbers(arr): Sorts a list of integers in place. Args: arr (list): List of integers to sort. Returns: None Test cases: >>> arr = [] >>> sortNumbers(arr) >>> arr [] >>> arr = [1] >>> sortNumbers(arr) >>> arr [1] >>> arr = [1, 2, 3, 4, 5] >>> sortNumbers(arr) >>> arr [1, 2, 3, 4, 5] >>> arr = [5, 4, 3, 2, 1] >>> sortNumbers(arr) >>> arr [1, 2, 3, 4, 5] >>> arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] >>> sortNumbers(arr) >>> arr [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] >>> arr = [3, 1, 4, 4, 1, 3] >>> sortNumbers(arr) >>> arr [1, 1, 3, 3, 4, 4] >>> arr = [0, -1, 3, -5, 2, -3] >>> sortNumbers(arr) >>> arr [-5, -3, -1, 0, 2, 3] >>> arr = [10, -10, 0, 5, -5, 3, -3, 1, -1] >>> sortNumbers(arr) >>> arr [-10, -5, -3, -1, 0, 1, 3, 5, 10]","solution":"def sortNumbers(arr): Sorts a list of integers in place using the Bubble Sort algorithm. Args: arr (list): List of integers to sort. Returns: None n = len(arr) for i in range(n): for j in range(n - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j]"},{"question":"def separate_evens_and_odds(numbers): Separates the input list of integers into even and odd numbers. Parameters: numbers (list of int): The input list of integers. Returns: dict: A dictionary with keys 'evens' and 'odds' containing lists of even and odd numbers respectively. >>> separate_evens_and_odds([1, 2, 3, 4, 5, 6]) {'evens': [2, 4, 6], 'odds': [1, 3, 5]} >>> separate_evens_and_odds([]) {'evens': [], 'odds': []} >>> separate_evens_and_odds([2, 4, 6, 8]) {'evens': [2, 4, 6, 8], 'odds': []} >>> separate_evens_and_odds([1, 3, 5, 7]) {'evens': [], 'odds': [1, 3, 5, 7]} >>> separate_evens_and_odds([-1, -2, -3, -4]) {'evens': [-2, -4], 'odds': [-1, -3]}","solution":"def separate_evens_and_odds(numbers): Separates the input list of integers into even and odd numbers. Parameters: numbers (list of int): The input list of integers. Returns: dict: A dictionary with keys 'evens' and 'odds' containing lists of even and odd numbers respectively. result = {'evens': [], 'odds': []} for number in numbers: if number % 2 == 0: result['evens'].append(number) else: result['odds'].append(number) return result"},{"question":"def count_key_occurrences(input_list: List[Dict[str, int]], key: str) -> int: Returns the total count of a specific key across all dictionaries in the input list. Parameters: input_list (list): A list of dictionaries to be searched. key (str): The key whose values are to be counted. Returns: int: The total sum of the values associated with the specified key. >>> count_key_occurrences([{'a': 1, 'b': 2}, {'a': 2, 'c': 4}, {'b': 1, 'a': 3}], 'a') 6 >>> count_key_occurrences([{'b': 2}, {'c': 4}, {'b': 1}], 'a') 0 >>> count_key_occurrences([], 'a') 0 >>> count_key_occurrences([{'a': 1}, {'a': 2}, {'a': 3}], 'a') 6 >>> count_key_occurrences([{'a': 1, 'b': 2}, {'b': 4, 'c': 5}, {'d': 1, 'a': 3}], 'a') 4 >>> count_key_occurrences([{'a': 5}], 'a') 5 >>> count_key_occurrences([{'a': 0}, {'a': 0}, {'a': 0}], 'a') 0 pass","solution":"def count_key_occurrences(input_list, key): Returns the total count of a specific key across all dictionaries in the input list. Parameters: input_list (list): A list of dictionaries to be searched. key (str): The key whose values are to be counted. Returns: int: The total sum of the values associated with the specified key. total_count = 0 for dictionary in input_list: if key in dictionary: total_count += dictionary[key] return total_count"},{"question":"def alienOrder(words: List[str]) -> str: Determine the order of characters in an alien language given a sorted list of words in the alien language. >>> alienOrder([\\"wrt\\", \\"wrf\\", \\"er\\", \\"ett\\", \\"rftt\\"]) \\"wertf\\" >>> alienOrder([\\"z\\", \\"x\\", \\"z\\"]) \\"\\"","solution":"from collections import defaultdict, deque def alienOrder(words): # Create a graph graph = defaultdict(set) indegree = {char: 0 for word in words for char in word} # Build the graph for i in range(len(words) - 1): first_word, second_word = words[i], words[i + 1] min_length = min(len(first_word), len(second_word)) if first_word[:min_length] == second_word[:min_length] and len(first_word) > len(second_word): return \\"\\" # Case when order is invalid for j in range(min_length): if first_word[j] != second_word[j]: if second_word[j] not in graph[first_word[j]]: graph[first_word[j]].add(second_word[j]) indegree[second_word[j]] += 1 break # Perform Topological Sort zero_indegree = deque([char for char in indegree if indegree[char] == 0]) result = [] while zero_indegree: current_char = zero_indegree.popleft() result.append(current_char) for neighbor in graph[current_char]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree.append(neighbor) if len(result) != len(indegree): return \\"\\" # There's a cycle in the graph return \\"\\".join(result)"},{"question":"def sum_of_powers(n: int, k: int) -> int: Returns the sum of the first \`n\` positive integers each raised to the power of \`k\`. >>> sum_of_powers(3, 2) 14 >>> sum_of_powers(5, 3) 225","solution":"def sum_of_powers(n: int, k: int) -> int: Returns the sum of the first \`n\` positive integers each raised to the power of \`k\`. return sum(i**k for i in range(1, n+1))"},{"question":"def remove_duplicates(lst): Removes duplicates from the list while maintaining the original order of elements. Provides error handling for invalid inputs. Args: lst (list): A list of integers. Returns: list: A new list with duplicates removed. str: An error message if input is invalid. Examples: >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([1, -1, 2, -2, 2, -1, 3]) [1, -1, 2, -2, 3] >>> remove_duplicates(123) 'Error: Input must be a list.' >>> remove_duplicates([1, 2, 'a', 3]) 'Error: List must contain only integers.'","solution":"def remove_duplicates(lst): Removes duplicates from the list while maintaining the original order of elements. Args: lst (list): A list of integers. Returns: list: A new list with duplicates removed. str: An error message if input is invalid. if not isinstance(lst, list): return \\"Error: Input must be a list.\\" for item in lst: if not isinstance(item, int): return \\"Error: List must contain only integers.\\" seen = set() result = [] for item in lst: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"[Completion Task in Python] from typing import List, Dict def words_length(words: List[str]) -> Dict[str, int]: Takes a list of words and returns a dictionary with words as keys and their lengths as values. Args: words (List[str]): A list of words. Returns: Dict[str, int]: A dictionary with words as keys and their lengths as values. >>> words_length([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) {\\"apple\\": 5, \\"banana\\": 6, \\"cherry\\": 6, \\"date\\": 4} >>> words_length([]) {} >>> words_length([\\"test\\"]) {\\"test\\": 4} pass def sort_dict_by_value(d: Dict[str, int]) -> Dict[str, int]: Takes a dictionary and returns a new dictionary sorted by its values in descending order. Args: d (Dict[str, int]): A dictionary with words as keys and their lengths as values. Returns: Dict[str, int]: A dictionary sorted by its values. >>> sort_dict_by_value({\\"apple\\": 5, \\"banana\\": 6, \\"cherry\\": 6, \\"date\\": 4}) {\\"banana\\": 6, \\"cherry\\": 6, \\"apple\\": 5, \\"date\\": 4} >>> sort_dict_by_value({\\"test\\": 4}) {\\"test\\": 4} pass","solution":"def words_length(words): Takes a list of words and returns a dictionary with words as keys and their lengths as values. return {word: len(word) for word in words} def sort_dict_by_value(d): Takes a dictionary and returns a new dictionary sorted by its values in descending order. sorted_items = sorted(d.items(), key=lambda item: item[1], reverse=True) return dict(sorted_items) # Example usage words = [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"] lengths_dict = words_length(words) sorted_lengths_dict = sort_dict_by_value(lengths_dict) print(sorted_lengths_dict)"},{"question":"class Product: def __init__(self, name, product_id, quantity, price_per_unit): self.name = name self.product_id = product_id self.quantity = quantity self.price_per_unit = price_per_unit def update_quantity(self, new_quantity): self.quantity = new_quantity def get_value(self): return self.quantity * self.price_per_unit class InventoryManagementSystem: def __init__(self): self.inventory = {} def add_product(self, name, product_id, quantity, price_per_unit): Adds a new product to the inventory. Args: name (str): The name of the product. product_id (int): The ID of the product. quantity (int): The quantity of the product. price_per_unit (float): The price per unit of the product. Raises: ValueError: If a product with the same ID already exists. pass def update_product_quantity(self, product_id, new_quantity): Updates the quantity of a product in the inventory. Args: product_id (int): The ID of the product to update. new_quantity (int): The new quantity of the product. Raises: ValueError: If the product does not exist. pass def delete_product(self, product_id): Deletes a product from the inventory. Args: product_id (int): The ID of the product to delete. Raises: ValueError: If the product does not exist. pass def search_product(self, product_id): Searches for a product in the inventory. Args: product_id (int): The ID of the product to search for. Returns: dict: A dictionary with the product details (name, quantity, price per unit). Raises: ValueError: If the product does not exist. pass def display_all_products(self): Displays all the products in the inventory. Returns: list: A list of dictionaries with the details of all products. pass def generate_inventory_report(self): Generates a report of the inventory. Returns: dict: A dictionary containing: - total_products (int): The total number of products. - total_inventory_value (float): The total value of the inventory. - products (list): A list of products with their quantity and value. pass import pytest def test_add_product(): ims = InventoryManagementSystem() ims.add_product(\\"Product A\\", 1, 10, 5.0) assert ims.search_product(1) == {\\"name\\": \\"Product A\\", \\"quantity\\": 10, \\"price_per_unit\\": 5.0} def test_add_product_existing_id(): ims = InventoryManagementSystem() ims.add_product(\\"Product A\\", 1, 10, 5.0) with pytest.raises(ValueError, match=\\"Product with this ID already exists.\\"): ims.add_product(\\"Product B\\", 1, 5, 2.0) def test_update_product_quantity(): ims = InventoryManagementSystem() ims.add_product(\\"Product A\\", 1, 10, 5.0) ims.update_product_quantity(1, 20) assert ims.search_product(1) == {\\"name\\": \\"Product A\\", \\"quantity\\": 20, \\"price_per_unit\\": 5.0} def test_update_non_existent_product(): ims = InventoryManagementSystem() with pytest.raises(ValueError, match=\\"Product with this ID does not exist.\\"): ims.update_product_quantity(1, 20) def test_delete_product(): ims = InventoryManagementSystem() ims.add_product(\\"Product A\\", 1, 10, 5.0) ims.delete_product(1) with pytest.raises(ValueError, match=\\"Product with this ID does not exist.\\"): ims.search_product(1) def test_delete_non_existent_product(): ims = InventoryManagementSystem() with pytest.raises(ValueError, match=\\"Product with this ID does not exist.\\"): ims.delete_product(1) def test_search_product(): ims = InventoryManagementSystem() ims.add_product(\\"Product A\\", 1, 10, 5.0) assert ims.search_product(1) == {\\"name\\": \\"Product A\\", \\"quantity\\": 10, \\"price_per_unit\\": 5.0} def test_search_non_existent_product(): ims = InventoryManagementSystem() with pytest.raises(ValueError, match=\\"Product with this ID does not exist.\\"): ims.search_product(1) def test_display_all_products(): ims = InventoryManagementSystem() ims.add_product(\\"Product A\\", 1, 10, 5.0) ims.add_product(\\"Product B\\", 2, 5, 3.0) assert ims.display_all_products() == [ {\\"name\\": \\"Product A\\", \\"product_id\\": 1, \\"quantity\\": 10, \\"price_per_unit\\": 5.0}, {\\"name\\": \\"Product B\\", \\"product_id\\": 2, \\"quantity\\": 5, \\"price_per_unit\\": 3.0}, ] def test_generate_inventory_report(): ims = InventoryManagementSystem() ims.add_product(\\"Product A\\", 1, 10, 5.0) ims.add_product(\\"Product B\\", 2, 5, 3.0) report = ims.generate_inventory_report() assert report[\\"total_products\\"] == 2 assert report[\\"total_inventory_value\\"] == 10 * 5.0 + 5 * 3.0 assert report[\\"products\\"] == [ {\\"name\\": \\"Product A\\", \\"quantity\\": 10, \\"value\\": 50.0}, {\\"name\\": \\"Product B\\", \\"quantity\\": 5, \\"value\\": 15.0}, ]","solution":"class Product: def __init__(self, name, product_id, quantity, price_per_unit): self.name = name self.product_id = product_id self.quantity = quantity self.price_per_unit = price_per_unit def update_quantity(self, new_quantity): self.quantity = new_quantity def get_value(self): return self.quantity * self.price_per_unit class InventoryManagementSystem: def __init__(self): self.inventory = {} def add_product(self, name, product_id, quantity, price_per_unit): if product_id in self.inventory: raise ValueError(\\"Product with this ID already exists.\\") self.inventory[product_id] = Product(name, product_id, quantity, price_per_unit) def update_product_quantity(self, product_id, new_quantity): if product_id not in self.inventory: raise ValueError(\\"Product with this ID does not exist.\\") self.inventory[product_id].update_quantity(new_quantity) def delete_product(self, product_id): if product_id not in self.inventory: raise ValueError(\\"Product with this ID does not exist.\\") del self.inventory[product_id] def search_product(self, product_id): if product_id not in self.inventory: raise ValueError(\\"Product with this ID does not exist.\\") product = self.inventory[product_id] return { \\"name\\": product.name, \\"quantity\\": product.quantity, \\"price_per_unit\\": product.price_per_unit } def display_all_products(self): products = [] for product_id, product in self.inventory.items(): products.append({ \\"name\\": product.name, \\"product_id\\": product.product_id, \\"quantity\\": product.quantity, \\"price_per_unit\\": product.price_per_unit }) return products def generate_inventory_report(self): total_products = len(self.inventory) total_inventory_value = sum(product.get_value() for product in self.inventory.values()) product_list = [{ \\"name\\": product.name, \\"quantity\\": product.quantity, \\"value\\": product.get_value() } for product in self.inventory.values()] return { \\"total_products\\": total_products, \\"total_inventory_value\\": total_inventory_value, \\"products\\": product_list }"},{"question":"def count_distinct_vertical_lines(points): Determines the number of distinct vertical lines that can be formed using given points, where each line contains at least two distinct points. Parameters: points (list of list of ints): Each point is represented as [x, y] Returns: int: Number of distinct vertical lines >>> count_distinct_vertical_lines([[1,2],[1,3],[2,1],[2,4],[3,5]]) 2 >>> count_distinct_vertical_lines([[1,1],[2,2],[3,3]]) 0 >>> count_distinct_vertical_lines([[1,1],[1,1],[1,1]]) 1 >>> count_distinct_vertical_lines([]) 0 >>> count_distinct_vertical_lines([[1,1]]) 0 >>> count_distinct_vertical_lines([[1,1],[2,2],[1,2],[3,3],[1,3],[3,4],[3,5]]) 2 >>> count_distinct_vertical_lines([[1,1],[1,1],[2,2],[2,2],[3,3],[3,3]]) 3","solution":"def count_distinct_vertical_lines(points): Determines the number of distinct vertical lines that can be formed using given points, where each line contains at least two distinct points. Parameters: points (list of list of ints): Each point is represented as [x, y] Returns: int: Number of distinct vertical lines x_coords = {} for point in points: x = point[0] if x in x_coords: x_coords[x] += 1 else: x_coords[x] = 1 vertical_lines = 0 for count in x_coords.values(): if count >= 2: vertical_lines += 1 return vertical_lines"},{"question":"from typing import List def trap_rain_water(heights: List[int]) -> int: Calculate how much rainwater can be trapped between the buildings after a heavy downpour. >>> trap_rain_water([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> trap_rain_water([4,2,0,3,2,5]) == 9 def test_trap_rain_water_example_1(): assert trap_rain_water([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 def test_trap_rain_water_example_2(): assert trap_rain_water([4,2,0,3,2,5]) == 9 def test_trap_rain_water_no_building(): assert trap_rain_water([]) == 0 def test_trap_rain_water_single_building(): assert trap_rain_water([5]) == 0 def test_trap_rain_water_equal_heights(): assert trap_rain_water([3, 3, 3, 3]) == 0 def test_trap_rain_water_varying_heights(): assert trap_rain_water([5, 2, 1, 2, 1, 5]) == 14 def test_trap_rain_water_increasing_heights(): assert trap_rain_water([1, 2, 3, 4, 5]) == 0 def test_trap_rain_water_decreasing_heights(): assert trap_rain_water([5, 4, 3, 2, 1]) == 0","solution":"from typing import List def trap_rain_water(heights: List[int]) -> int: if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def calculate(expression: str) -> int: Simulates a basic calculator that evaluates a mathematical expression containing integers and operators +, -, *, / with correct operator precedence and support for parentheses. >>> calculate(\\"1 + 1\\") == 2 >>> calculate(\\"2 - 1\\") == 1 >>> calculate(\\"2 * 3\\") == 6 >>> calculate(\\"8 / 4\\") == 2 >>> calculate(\\"2 + 3 * 4\\") == 14 >>> calculate(\\"2 * 3 + 4\\") == 10 >>> calculate(\\"(2 + 3) * 4\\") == 20 >>> calculate(\\"2 * (3 + 4)\\") == 14 >>> calculate(\\"10 + 2 * 6\\") == 22 >>> calculate(\\"100 * 2 + 12\\") == 212 >>> calculate(\\"100 * (2 + 12)\\") == 1400 >>> calculate(\\"100 * (2 + 12) / 14\\") == 100 >>> calculate(\\"((2 + 3) * (5 - 1)) / 2\\") == 10 >>> calculate(\\"2 * (3 + (4 * 5))\\") == 46","solution":"def calculate(expression): Returns the result of the mathematical expression. def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(int(left / right)) # use int() to truncate toward zero def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def calculate_inner(tokens): values = [] operators = [] i = 0 while i < len(tokens): if tokens[i] == ' ': i += 1 continue if tokens[i] == '(': operators.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while(i < len(tokens) and tokens[i].isdigit()): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == ')': while len(operators) > 0 and operators[-1] != '(': apply_operator(operators, values) operators.pop() else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(tokens[i])): apply_operator(operators, values) operators.append(tokens[i]) i += 1 while len(operators) != 0: apply_operator(operators, values) return values[-1] tokens = list(expression) return calculate_inner(tokens)"},{"question":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_squared_error, r2_score from sklearn.impute import SimpleImputer from sklearn.pipeline import Pipeline from sklearn.preprocessing import StandardScaler def build_and_evaluate_model(df, features, target): Builds and evaluates a multiple linear regression model. Parameters: - df: pandas DataFrame containing the dataset - features: list of column names to be used as features - target: column name of the target variable Returns: - Dictionary containing model performance metrics.","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_squared_error, r2_score from sklearn.impute import SimpleImputer from sklearn.pipeline import Pipeline from sklearn.preprocessing import StandardScaler def build_and_evaluate_model(df, features, target): Builds and evaluates a multiple linear regression model. Parameters: - df: pandas DataFrame containing the dataset - features: list of column names to be used as features - target: column name of the target variable Returns: - Dictionary containing model performance metrics. # Separate features and target X = df[features] y = df[target] # Split data into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Define a pipeline with data preprocessing and regression model pipeline = Pipeline([ ('imputer', SimpleImputer(strategy='mean')), # Handle missing data ('scaler', StandardScaler()), # Feature scaling ('regressor', LinearRegression()) # Regression model ]) # Train the model pipeline.fit(X_train, y_train) # Predict the target for test data y_pred = pipeline.predict(X_test) # Evaluate model performance mse = mean_squared_error(y_test, y_pred) r2 = r2_score(y_test, y_pred) return { 'mse': mse, 'r2': r2 }"},{"question":"def parse_math_expression(expression: str) -> float: Create a function \`parse_math_expression(expression: str) -> float\` that takes a mathematical expression as a string and returns the evaluated result as a float. The expression is guaranteed to be a valid mathematical expression containing integers, floating-point numbers, and the operators +, -, *, /, and parentheses (). You are not allowed to use the built-in \`eval\` function or similar utilities from libraries. >>> parse_math_expression(\\"3 + 5\\") 8.0 >>> parse_math_expression(\\"10 + 2 * 6\\") 22.0 >>> parse_math_expression(\\"(10 + 2) * 6\\") 72.0 >>> parse_math_expression(\\"100 * 2 + 12\\") 212.0 >>> parse_math_expression(\\"100 * (2 + 12)\\") 1400.0 >>> parse_math_expression(\\"100 * (2 + 12) / 14\\") 100.0","solution":"def parse_math_expression(expression: str) -> float: def get_precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(left / right) def evaluate(expression): i, n = 0, len(expression) values = [] operators = [] while i < n: if expression[i] == ' ': i += 1 continue if expression[i] == '(': operators.append(expression[i]) elif expression[i].isdigit() or expression[i] == '.': val = 0 if expression[i].isdigit(): while i < n and expression[i].isdigit(): val = (val * 10) + int(expression[i]) i += 1 if i < n and expression[i] == '.': i += 1 frac_val, frac_pos = 0, 0.1 while i < n and expression[i].isdigit(): frac_val += int(expression[i]) * frac_pos frac_pos /= 10 i += 1 val += frac_val values.append(val) i -= 1 elif expression[i] == ')': while operators and operators[-1] != '(': apply_operator(operators, values) operators.pop() else: while (operators and get_precedence(operators[-1]) >= get_precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[-1] return evaluate(expression)"},{"question":"def filter_strings(strings: list, n: int) -> list: Returns a list of strings that have a length greater than n. :param strings: List of strings to be filtered. :param n: Integer specifying the length criteria. :return: List of strings with length greater than n. pass def test_filter_strings_with_various_lengths(): assert filter_strings([\\"apple\\", \\"banana\\", \\"kiwi\\", \\"blueberry\\"], 5) == [\\"banana\\", \\"blueberry\\"] assert filter_strings([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"], 2) == [\\"abc\\", \\"abcd\\"] assert filter_strings([\\"hello\\", \\"world\\", \\"test\\", \\"example\\"], 4) == [\\"hello\\", \\"world\\", \\"example\\"] def test_filter_strings_none_meet_criteria(): assert filter_strings([\\"apple\\", \\"banana\\", \\"kiwi\\", \\"blueberry\\"], 10) == [] assert filter_strings([\\"short\\", \\"tiny\\", \\"small\\"], 5) == [] def test_filter_strings_all_meet_criteria(): assert filter_strings([\\"apple\\", \\"banana\\", \\"kiwi\\", \\"blueberry\\"], 3) == [\\"apple\\", \\"banana\\", \\"kiwi\\", \\"blueberry\\"] assert filter_strings([\\"longer\\", \\"items\\", \\"in\\", \\"the\\", \\"list\\"], 2) == [\\"longer\\", \\"items\\", \\"the\\", \\"list\\"] def test_filter_strings_empty_list(): assert filter_strings([], 5) == [] def test_filter_strings_edge_case_n_equals_0(): assert filter_strings([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"], 0) == [\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"] assert filter_strings([\\"\\", \\"a\\", \\"abc\\"], 0) == [\\"a\\", \\"abc\\"]","solution":"def filter_strings(strings: list, n: int) -> list: Returns a list of strings that have a length greater than n. :param strings: List of strings to be filtered. :param n: Integer specifying the length criteria. :return: List of strings with length greater than n. return [s for s in strings if len(s) > n]"},{"question":"def fibonacci_n(n: int) -> int: Returns the n-th Fibonacci number using an iterative approach. Parameters: n (int): The index in the Fibonacci sequence to return. Returns: int: The n-th Fibonacci number. Raises: ValueError: If the input n is negative. pass # Test cases def test_fibonacci_n_base_cases(): assert fibonacci_n(0) == 0 assert fibonacci_n(1) == 1 def test_fibonacci_n_positive_indices(): assert fibonacci_n(2) == 1 assert fibonacci_n(3) == 2 assert fibonacci_n(4) == 3 assert fibonacci_n(5) == 5 assert fibonacci_n(6) == 8 assert fibonacci_n(10) == 55 def test_fibonacci_n_large_index(): assert fibonacci_n(20) == 6765 assert fibonacci_n(30) == 832040 def test_fibonacci_n_value_error(): try: fibonacci_n(-1) except ValueError as e: assert str(e) == \\"Fibonacci numbers are not defined for negative indices\\" try: fibonacci_n(-10) except ValueError as e: assert str(e) == \\"Fibonacci numbers are not defined for negative indices\\"","solution":"def fibonacci_n(n: int) -> int: Returns the n-th Fibonacci number using an iterative approach. Parameters: n (int): The index in the Fibonacci sequence to return. Returns: int: The n-th Fibonacci number. Raises: ValueError: If the input n is negative. if n < 0: raise ValueError(\\"Fibonacci numbers are not defined for negative indices\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def even_squares(numbers: List[int]) -> List[int]: Create a function that takes a list of integers and returns a new list with the squares of those integers, but only if the result is an even number. >>> even_squares([1, 2, 3, 4]) [4, 16] >>> even_squares([1, 3, 5, 7]) [] >>> even_squares([2, 4, 6, 8]) [4, 16, 36, 64] >>> even_squares([-1, -2, -3, -4]) [4, 16] >>> even_squares([0]) [0] >>> even_squares([]) []","solution":"def even_squares(numbers): Takes a list of integers and returns a new list with the squares of those integers that are even numbers. return [n*n for n in numbers if (n*n) % 2 == 0]"},{"question":"from typing import List def list_duplicates(nums: List[int]) -> List[int]: Returns a list of duplicates in the input list nums, sorted in ascending order. Each duplicate number appears only once in the returned list. >>> list_duplicates([4, 3, 2, 7, 8, 2, 3, 1]) [2, 3] >>> list_duplicates([1, 2, 3, 4, 5]) [] >>> list_duplicates([10, 10, 10]) [10]","solution":"from typing import List def list_duplicates(nums: List[int]) -> List[int]: Returns a list of duplicates in the input list nums, sorted in ascending order. Each duplicate number appears only once in the returned list. seen = set() duplicates = set() for number in nums: if number in seen: duplicates.add(number) else: seen.add(number) return sorted(duplicates)"},{"question":"import numpy as np from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split, cross_val_score, GridSearchCV from sklearn.preprocessing import StandardScaler from sklearn.neighbors import KNeighborsClassifier from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score def evaluate_knn(X, y, cv=5, k_range=range(1, 31)): Evaluate the performance of a k-Nearest Neighbors (k-NN) classifier including data normalization, cross-validation to select the best k, and metrics such as accuracy, precision, recall, and F1-score. Parameters: - X (array-like): Feature dataset - y (array-like): Labels - cv (int): Number of cross-validation folds - k_range (range): Range of k values to try Returns: - dict: Evaluation metrics including best k, accuracy, precision, recall, and F1-score pass # Test cases to validate the functionality development def test_evaluate_knn_performance(): iris = load_iris() X, y = iris.data, iris.target metrics = evaluate_knn(X, y, cv=5, k_range=range(1, 11)) # Check that the best k is within the specified k_range assert 1 <= metrics['best_k'] <= 10 # Check that the metrics are within a reasonable range assert 0 <= metrics['accuracy'] <= 1 assert 0 <= metrics['precision'] <= 1 assert 0 <= metrics['recall'] <= 1 assert 0 <= metrics['f1_score'] <= 1 def test_evaluate_knn_best_k(): iris = load_iris() X, y = iris.data, iris.target metrics = evaluate_knn(X, y, cv=5, k_range=range(1, 31)) # Ensure best_k is an integer in the range assert isinstance(metrics['best_k'], int) assert metrics['best_k'] in range(1, 31) def test_evaluate_knn_all_metrics_present(): iris = load_iris() X, y = iris.data, iris.target metrics = evaluate_knn(X, y, cv=5, k_range=range(1, 31)) # Check that all expected metrics are present assert 'best_k' in metrics assert 'accuracy' in metrics assert 'precision' in metrics assert 'recall' in metrics assert 'f1_score' in metrics","solution":"from sklearn.model_selection import train_test_split, cross_val_score, GridSearchCV from sklearn.preprocessing import StandardScaler from sklearn.neighbors import KNeighborsClassifier from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score import numpy as np def evaluate_knn(X, y, cv=5, k_range=range(1, 31)): Evaluate the performance of a k-Nearest Neighbors (k-NN) classifier. Parameters: - X (array-like): Feature dataset - y (array-like): Labels - cv (int): Number of cross-validation folds - k_range (range): Range of k values to try Returns: - dict: Evaluation metrics including best k, accuracy, precision, recall, and F1-score # Normalize the data scaler = StandardScaler() X_scaled = scaler.fit_transform(X) # Split the data into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42) # Perform grid search to find the best k param_grid = {'n_neighbors': k_range} grid = GridSearchCV(KNeighborsClassifier(), param_grid, cv=cv, scoring='accuracy') grid.fit(X_train, y_train) best_k = grid.best_params_['n_neighbors'] # Train the k-NN classifier with the best k knn = KNeighborsClassifier(n_neighbors=best_k) knn.fit(X_train, y_train) # Predict the labels for the test set y_pred = knn.predict(X_test) # Calculate evaluation metrics accuracy = accuracy_score(y_test, y_pred) precision = precision_score(y_test, y_pred, average='weighted') recall = recall_score(y_test, y_pred, average='weighted') f1 = f1_score(y_test, y_pred, average='weighted') return { 'best_k': best_k, 'accuracy': accuracy, 'precision': precision, 'recall': recall, 'f1_score': f1 }"},{"question":"import re from typing import List def tokenize(expression: str) -> List[str]: Converts an input string representing an arithmetic expression into a list of tokens. Handles four basic arithmetic operators (+, -, *, /), parentheses, and multi-digit integers. :param expression: A string representing an arithmetic expression. :return: A list of tokens. >>> tokenize(\\"3+2\\") == ['3', '+', '2'] >>> tokenize(\\"3+(6*5-8)/4\\") == ['3', '+', '(', '6', '*', '5', '-', '8', ')', '/', '4'] >>> tokenize(\\"123+456*789\\") == ['123', '+', '456', '*', '789'] >>> tokenize(\\"10+20-30*40/50\\") == ['10', '+', '20', '-', '30', '*', '40', '/', '50'] >>> tokenize(\\"(1+(4+5+2)-3)+(6+8)\\") == ['(', '1', '+', '(', '4', '+', '5', '+', '2', ')', '-', '3', ')', '+', '(', '6', '+', '8', ')'] >>> tokenize(\\"10 + 20 - ( 30 * 4) / 50 \\".replace(\\" \\", \\"\\")) == ['10', '+', '20', '-', '(', '30', '*', '4', ')', '/', '50']","solution":"import re def tokenize(expression): Converts an input string representing an arithmetic expression into a list of tokens. Handles four basic arithmetic operators (+, -, *, /), parentheses, and multi-digit integers. :param expression: A string representing an arithmetic expression. :return: A list of tokens. token_pattern = re.compile(r'd+|[()+-*/]') return token_pattern.findall(expression)"},{"question":"[Completion Task in Python] def remove_duplicates(lst): Remove duplicate elements from the list while preserving the order of first appearance. :param lst: List of integers (unsorted with possible duplicates) :return: List of unique integers in the order they first appeared in input. Example: >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([5, 5, 5, 5, 5]) [5] >>> remove_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([2, 1, 2, 3, 4, 1]) [2, 1, 3, 4] >>> remove_duplicates([]) [] >>> remove_duplicates([7]) [7]","solution":"def remove_duplicates(lst): Remove duplicate elements from the list while preserving the order of first appearance. :param lst: List of integers (unsorted with possible duplicates) :return: List of unique integers in the order they first appeared in input. seen = set() unique_lst = [] for num in lst: if num not in seen: unique_lst.append(num) seen.add(num) return unique_lst"},{"question":"def first_non_repeating_char(text: str) -> str: Write a function that takes a string of text as an input. The function should find the first non-repeating character in the string and return it. If all characters are repeating or the input string is empty, the function should return \`None\`. Note that the distinction between uppercase and lowercase letters matters, i.e., 'A' and 'a' are considered different characters. >>> first_non_repeating_char(\\"a\\") == \\"a\\" >>> first_non_repeating_char(\\"aabbc\\") == \\"c\\" >>> first_non_repeating_char(\\"aA\\") == \\"a\\" >>> first_non_repeating_char(\\"aabb\\") == None >>> first_non_repeating_char(\\"\\") == None >>> first_non_repeating_char(\\"abcabcde\\") == \\"d\\" >>> first_non_repeating_char(\\"112233!!\\") == None >>> first_non_repeating_char(\\"a1a2b2\\") == \\"1\\"","solution":"def first_non_repeating_char(text): Returns the first non-repeating character in the given string \`text\`. If all characters are repeating or the string is empty, returns None. char_count = {} # Counting the frequency of each character for char in text: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Finding the first non-repeating character for char in text: if char_count[char] == 1: return char return None"},{"question":"def rotate_matrix_90_degrees_clockwise(matrix): Rotates an NxN matrix 90 degrees clockwise. >>> rotate_matrix_90_degrees_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_matrix_90_degrees_clockwise([ ... [ 1, 2, 3, 4], ... [ 5, 6, 7, 8], ... [ 9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] >>> rotate_matrix_90_degrees_clockwise([]) [] >>> rotate_matrix_90_degrees_clockwise([[1]]) [[1]] >>> rotate_matrix_90_degrees_clockwise([ ... [1, 2], ... [3, 4] ... ]) [ [3, 1], [4, 2] ]","solution":"def rotate_matrix_90_degrees_clockwise(matrix): Rotates an NxN matrix 90 degrees clockwise. n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n-1-i] = matrix[i][j] return rotated_matrix"},{"question":"import re def is_palindrome(s: str) -> bool: Write a function that takes a string as input and returns True if the string is a valid palindrome after removing all non-alphanumeric characters and ignoring case. Examples: >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"A\\") True >>> is_palindrome(\\"!!!\\") True >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"123456\\") False","solution":"import re def is_palindrome(s): Returns True if the input string is a valid palindrome after removing all non-alphanumeric characters and ignoring case. # Remove non-alphanumeric characters and convert to lower case cleaned_str = re.sub(r'[^A-Za-z0-9]+', '', s).lower() # Check if the cleaned string is equal to its reverse return cleaned_str == cleaned_str[::-1]"},{"question":"def process_numbers(nums: List[int]) -> List[int]: Takes in a list of integers and returns a new list with all even numbers squared and all odd numbers doubled. >>> process_numbers([2, 5, 8, 11]) [4, 10, 64, 22] >>> process_numbers([2, 4, 6]) [4, 16, 36] >>> process_numbers([1, 3, 5]) [2, 6, 10] >>> process_numbers([]) [] >>> process_numbers([4]) [16] >>> process_numbers([7]) [14]","solution":"def process_numbers(nums): Takes in a list of integers and returns a new list with all even numbers squared and all odd numbers doubled. :param nums: List[int] :return: List[int] return [x**2 if x % 2 == 0 else x * 2 for x in nums]"},{"question":"def max_non_consecutive_sum(arr: List[int]) -> int: Returns the maximum sum that can be obtained by summing non-consecutive elements of the array. >>> max_non_consecutive_sum([]) == 0 >>> max_non_consecutive_sum([5]) == 5 >>> max_non_consecutive_sum([3, 5]) == 5 >>> max_non_consecutive_sum([3, 2, 5, 10, 7]) == 15 >>> max_non_consecutive_sum([-1, -2, -3, -4, -5]) == 0 >>> max_non_consecutive_sum([3, -2, 5, -1, 7]) == 15","solution":"def max_non_consecutive_sum(arr): Returns the maximum sum that can be obtained by summing non-consecutive elements of the array. if not arr: return 0 elif len(arr) == 1: return arr[0] # Initialize the maximum sums for the first two elements inclusive = arr[0] exclusive = 0 for i in range(1, len(arr)): # Current max excluding i new_exclusive = max(inclusive, exclusive) # Current max including i inclusive = exclusive + arr[i] # Update exclusive to new_exclusive exclusive = new_exclusive # Return the maximum of inclusive and exclusive return max(inclusive, exclusive)"},{"question":"def shift_string(s: str, shift: int) -> str: Shifts each character in the input string s by the shift value in the alphabet. Parameters: s (str): Input string containing lowercase letters of the English alphabet. shift (int): The number of places to shift each letter in the string. Returns: str: The resulting string after shifting. Example: >>> shift_string(\\"xyz\\", 2) \\"zab\\" >>> shift_string(\\"abc\\", 1) \\"bcd\\" >>> shift_string(\\"bcd\\", -1) \\"abc\\" >>> shift_string(\\"\\", 5) \\"\\" >>> shift_string(\\"abcdefghijklmnopqrstuvwxyz\\", 25) \\"zabcdefghijklmnopqrstuvwxy\\"","solution":"def shift_string(s, shift): Shifts each character in the input string s by the shift value in the alphabet. Parameters: s (str): Input string containing lowercase letters of the English alphabet. shift (int): The number of places to shift each letter in the string. Returns: str: The resulting string after shifting. result = [] for char in s: shifted_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a')) result.append(shifted_char) return ''.join(result)"},{"question":"def unique_paths_with_obstacles(grid): Given a 2D grid with obstacles represented by integer values (0 for an empty space and 1 for an obstacle), determine the number of unique paths from the top-left corner to the bottom-right corner, such that one can only move either down or right at any point in time. If there's no possible path due to the obstacles, return 0. Examples: >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[0, 1], [0, 0]]) 1 >>> unique_paths_with_obstacles([[1]]) 0 >>> unique_paths_with_obstacles([[0, 1], [1, 0]]) 0","solution":"def unique_paths_with_obstacles(grid): Given a 2D grid with obstacles represented by integer values (0 for an empty space and 1 for an obstacle), determine the number of unique paths from the top-left corner to the bottom-right corner, such that one can only move either down or right at any point in time. If there's no possible path due to the obstacles, return 0. if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] if grid[i][0] == 0 else 0 # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] if grid[0][j] == 0 else 0 # Fill the dp table for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] else: dp[i][j] = 0 return dp[m-1][n-1]"},{"question":"import unittest def has_pair_with_sum(lst, target): Write a function that takes a list of integers and a target integer. The function should return \`True\` if there are two distinct elements in the list whose sum is equal to the target, and \`False\` otherwise. >>> has_pair_with_sum([3, 5, 1, 7, 4, 2], 6) True >>> has_pair_with_sum([1, 2, 3, 9, 4, 5], 10) True >>> has_pair_with_sum([10, 15, 3, 7], 17) True >>> has_pair_with_sum([1, 2, 3, 4], 8) False >>> has_pair_with_sum([1, 5, 3], 10) False >>> has_pair_with_sum([7, 7, 7, 7], 13) False >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([5], 10) False >>> has_pair_with_sum([1, 2, 3, 2, 4], 5) True","solution":"def has_pair_with_sum(lst, target): Returns True if there are two distinct elements in the list whose sum equals the target. Returns False otherwise. seen = set() for num in lst: if target - num in seen: return True seen.add(num) return False"},{"question":"def fibonacci_with_digits(n: int) -> list: Generates a list of Fibonacci numbers up to F(m), where m is the smallest number such that F(m) has at least 'n' digits. Args: n (int): The minimum number of digits for the Fibonacci number. Returns: list: A list of Fibonacci numbers up to F(m). # Implementation here # Tests def test_fibonacci_with_1_digit(): result = fibonacci_with_digits(1) assert result[-1] == 1 assert all(len(str(num)) < 2 for num in result[:-1]) def test_fibonacci_with_2_digits(): result = fibonacci_with_digits(2) assert len(str(result[-1])) >= 2 assert all(len(str(num)) < 2 or i == len(result) - 2 for i, num in enumerate(result[:-1])) def test_fibonacci_with_3_digits(): result = fibonacci_with_digits(3) assert len(str(result[-1])) >= 3 assert all(len(str(num)) < 3 or i == len(result) - 2 for i, num in enumerate(result[:-1])) def test_fibonacci_with_4_digits(): result = fibonacci_with_digits(4) assert len(str(result[-1])) >= 4 assert all(len(str(num)) < 4 or i == len(result) - 2 for i, num in enumerate(result[:-1])) def test_input_less_than_1(): import pytest with pytest.raises(ValueError, match=\\"n must be at least 1\\"): fibonacci_with_digits(0)","solution":"def fibonacci_with_digits(n): Generates a list of Fibonacci numbers up to F(m), where m is the smallest number such that F(m) has at least 'n' digits. Args: n (int): The minimum number of digits for the Fibonacci number. Returns: list: A list of Fibonacci numbers up to F(m). if n < 1: raise ValueError(\\"n must be at least 1\\") fib_sequence = [0, 1] while True: next_fib = fib_sequence[-1] + fib_sequence[-2] if len(str(next_fib)) >= n: fib_sequence.append(next_fib) break fib_sequence.append(next_fib) return fib_sequence"},{"question":"import random import numpy as np from typing import List, Tuple def initialize_centroids(k: int, data: List[List[float]]) -> List[List[float]]: Randomly initializes centroids by selecting k unique points from the dataset. # [Implementation goes here] def assign_points_to_clusters(centroids: List[List[float]], data: List[List[float]]) -> List[List[List[float]]]: Assigns each data point to the nearest centroid using Euclidean distance. # [Implementation goes here] def update_centroids(clusters: List[List[List[float]]]) -> List[List[float]]: Updates centroids by calculating the mean of all points assigned to each cluster. # [Implementation goes here] def k_means_clustering(k: int, data: List[List[float]], iterations: int) -> Tuple[List[List[float]], List[List[List[float]]]]: Performs k-means clustering on the given dataset. # [Implementation goes here] # Example usage: data = [ [1, 2], [2, 3], [3, 4], [8, 7], [9, 6], [10, 7], [2, 8], [3, 9], [4, 10], [7, 2], [8, 3], [9, 4] ] k = 3 iterations = 10 centroids, clusters = k_means_clustering(k, data, iterations) print(\\"Final centroids:\\", centroids) print(\\"Clusters:\\", clusters)","solution":"import random import numpy as np def initialize_centroids(k, data): Randomly initializes centroids by selecting k unique points from the dataset. centroids = random.sample(data, k) return centroids def assign_points_to_clusters(centroids, data): Assigns each data point to the nearest centroid using Euclidean distance. clusters = [[] for _ in range(len(centroids))] for point in data: distances = [np.linalg.norm(np.array(point) - np.array(centroid)) for centroid in centroids] cluster_index = distances.index(min(distances)) clusters[cluster_index].append(point) return clusters def update_centroids(clusters): Updates centroids by calculating the mean of all points assigned to each cluster. return [np.mean(cluster, axis=0).tolist() for cluster in clusters] def k_means_clustering(k, data, iterations): Performs k-means clustering on the given dataset. centroids = initialize_centroids(k, data) for _ in range(iterations): clusters = assign_points_to_clusters(centroids, data) new_centroids = update_centroids(clusters) if np.array_equal(new_centroids, centroids): break centroids = new_centroids return centroids, clusters # Example usage: data = [ [1, 2], [2, 3], [3, 4], [8, 7], [9, 6], [10, 7], [2, 8], [3, 9], [4, 10], [7, 2], [8, 3], [9, 4] ] k = 3 iterations = 10 centroids, clusters = k_means_clustering(k, data, iterations) print(\\"Final centroids:\\", centroids) print(\\"Clusters:\\", clusters)"},{"question":"def list_subsets(arr): Generates all possible subsets of a given list of unique integers. :param arr: List of unique integers :return: List of lists, each corresponding to a subset of the input list Examples: >>> list_subsets([1, 2, 3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> list_subsets([1, 2]) [[], [1], [2], [1, 2]] >>> list_subsets([]) [[]]","solution":"def list_subsets(arr): Generates all possible subsets of the given list of unique integers. :param arr: List of unique integers :return: List of lists, each corresponding to a subset of the input list def backtrack(start, path): result.append(path) for i in range(start, len(arr)): backtrack(i + 1, path + [arr[i]]) result = [] backtrack(0, []) return result"},{"question":"import requests def load_afinn_lexicon(): Load the AFINN lexicon from a specified URL. url = \\"https://github.com/fnielsen/afinn/blob/master/afinn/data/AFINN-111.txt?raw=true\\" response = requests.get(url) lexicon = {} for line in response.text.strip().split('n'): word, score = line.split('t') lexicon[word] = int(score) return lexicon def sentiment_score(sentence: str, lexicon: dict) -> int: Evaluate the sentiment of a given sentence using the AFINN lexicon. >>> lexicon = load_afinn_lexicon() >>> sentiment_score(\\"I love this wonderful place\\", lexicon) >>> sentiment_score(\\"This is a terrible and awful experience\\", lexicon) >>> sentiment_score(\\"I am going to the store now\\", lexicon) >>> sentiment_score(\\"I love this place but the service is terrible\\", lexicon) >>> sentiment_score(\\"\\", lexicon) >>> sentiment_score(\\"qwertyuiopasdfghjkl\\", lexicon)","solution":"import requests def load_afinn_lexicon(): Loads the AFINN lexicon from the specified URL. url = \\"https://github.com/fnielsen/afinn/blob/master/afinn/data/AFINN-111.txt?raw=true\\" response = requests.get(url) lexicon = {} for line in response.text.strip().split('n'): word, score = line.split('t') lexicon[word] = int(score) return lexicon def sentiment_score(sentence, lexicon): Evaluates the sentiment of a given sentence using the AFINN lexicon. words = sentence.split() score = 0 for word in words: score += lexicon.get(word.lower(), 0) return score # Load the lexicon once and pass it to the sentiment_score function lexicon = load_afinn_lexicon()"},{"question":"def flatten(lst): Flattens a nested list of arbitrary depth. Arguments: lst -- a list which can contain integers or other lists of integers Returns: A single flat list containing all integers in the same order as they appeared in the input. >>> flatten([1, [2, [3, 4], 5], [6, 7]]) [1, 2, 3, 4, 5, 6, 7] >>> flatten([[1], [[2]], [[[3]]]]) [1, 2, 3]","solution":"def flatten(lst): Flattens a nested list of arbitrary depth. Arguments: lst -- a list which can contain integers or other lists of integers Returns: A single flat list containing all integers in the same order as they appeared in the input. result = [] for item in lst: if isinstance(item, list): result.extend(flatten(item)) else: result.append(item) return result"},{"question":"def apply_discount(products: dict, discount: float) -> dict: Applies the given discount to the prices in the products dictionary. Params: - products (dict): A dictionary where keys are product names and values are their prices. - discount (float): The discount to be applied, represented as a float (e.g., 0.10 for a 10% discount). Returns: - dict: A new dictionary with the discounted prices rounded to two decimal places. >>> products = {\\"apple\\": 1.00, \\"banana\\": 0.50, \\"orange\\": 0.80} >>> apply_discount(products, 0.10) {'apple': 0.90, 'banana': 0.45, 'orange': 0.72} >>> products = {\\"apple\\": 1.00, \\"banana\\": 0.50, \\"orange\\": 0.80} >>> apply_discount(products, 0.0) {'apple': 1.00, 'banana': 0.50, 'orange': 0.80} >>> products = {} >>> apply_discount(products, 0.10) {}","solution":"def apply_discount(products: dict, discount: float) -> dict: Applies the given discount to the prices in the products dictionary. Params: - products (dict): A dictionary where keys are product names and values are their prices. - discount (float): The discount to be applied, represented as a float (e.g., 0.10 for a 10% discount). Returns: - dict: A new dictionary with the discounted prices rounded to two decimal places. discounted_products = {} for product, price in products.items(): new_price = round(price * (1 - discount), 2) discounted_products[product] = new_price return discounted_products"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, returns a list where each element is the product of all other elements in the original list except the one at the current position. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([1, 2, 3, 0]) [0, 0, 0, 6] >>> product_except_self([42]) [1] >>> product_except_self([]) []","solution":"def product_except_self(nums): Given a list of integers, returns a list where each element is the product of all other elements in the original list except the one at the current position. length = len(nums) if length == 0: return [] left_products = [1] * length right_products = [1] * length result = [1] * length # Compute the products of elements to the left of each index for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] # Compute the products of elements to the right of each index for j in range(length - 2, -1, -1): right_products[j] = right_products[j + 1] * nums[j + 1] # Combine the products of elements to the left and right of each index for k in range(length): result[k] = left_products[k] * right_products[k] return result"},{"question":"def transpose_matrix(matrix: list) -> list: Transforms the provided rectangular matrix by swapping its rows and columns, generating a new matrix. Libraries and built-in functions for matrix transposition should not be used. >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]]","solution":"def transpose_matrix(matrix: list) -> list: Transforms the provided rectangular matrix by swapping its rows and columns, generating a new matrix. Libraries and built-in functions for matrix transposition should not be used. >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] transposed = [] for col in range(len(matrix[0])): new_row = [] for row in range(len(matrix)): new_row.append(matrix[row][col]) transposed.append(new_row) return transposed"},{"question":"from typing import List def can_form_palindrome(s: str) -> bool: Checks if the input string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"abc\\") False >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"aaaa\\") True","solution":"def can_form_palindrome(s): Checks if the input string can be rearranged to form a palindrome. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # A string can be rearranged to a palindrome if at most one character has an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"from collections import Counter def can_form_palindrome(s: str) -> bool: Determines if a valid palindrome can be formed from the given characters. Removes non-alphabetic characters and ignores case. Args: s (str): Input string. Returns: bool: True if a palindrome can be formed, else False. Examples: >>> can_form_palindrome(\\"racecar racing\\") False >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"abc\\") False >>> can_form_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"aabb\\") True","solution":"from collections import Counter def can_form_palindrome(s): Determines if a valid palindrome can be formed from the given characters. Removes non-alphabetic characters and ignores case. Args: s (str): Input string. Returns: bool: True if a palindrome can be formed, else False. # Remove non-alphabetic characters and normalize to lowercase s = ''.join(filter(str.isalpha, s)).lower() # Count the occurrences of each character count = Counter(s) # Check the number of characters that have an odd count odd_count = sum(1 for c in count if count[c] % 2 != 0) # A string can form a palindrome if there is at most one character with an odd count return odd_count <= 1"},{"question":"def max_spend_within_budget(prices: List[int], budget: int) -> int: Finds the maximum total price of a continuous subarray that does not exceed the budget. Args: prices: List of integers representing the prices of items. budget: An integer representing the maximum allowable spending. Returns: Integer representing the maximum total price of a continuous subarray that does not exceed the budget. >>> max_spend_within_budget([100, 200, 300, 400, 500], 800) 700 >>> max_spend_within_budget([900, 1000, 1100], 800) 0 >>> max_spend_within_budget([100, 200, 150], 500) 450 >>> max_spend_within_budget([100, 200, 300, 400], 600) 600 >>> max_spend_within_budget([100], 50) 0 >>> max_spend_within_budget([300], 300) 300 >>> max_spend_within_budget([300], 500) 300 >>> max_spend_within_budget([100, 200, 300, 200, 100], 500) 500 >>> max_spend_within_budget([1, 1, 1, 1], 10) 4 >>> max_spend_within_budget([50, 50, 50, 50], 150) 150","solution":"def max_spend_within_budget(prices, budget): Finds the maximum total price of a continuous subarray that does not exceed the budget. Args: prices: List of integers representing the prices of items. budget: An integer representing the maximum allowable spending. Returns: Integer representing the maximum total price of a continuous subarray that does not exceed the budget. n = len(prices) max_spend = 0 current_sum = 0 start = 0 for end in range(n): current_sum += prices[end] while current_sum > budget and start <= end: current_sum -= prices[start] start += 1 if current_sum <= budget: max_spend = max(max_spend, current_sum) return max_spend"},{"question":"from typing import List, Dict, Any def generate_exercise_plan(age: int, gender: str, fitness_level: str, fitness_goals: str) -> List[Dict[str, Any]]: Generates a personalized exercise routine based on user inputs. Parameters: age (int): User's age. gender (str): User's gender. fitness_level (str): User's fitness level (beginner, intermediate, advanced). fitness_goals (str): User's fitness goals (e.g., weight loss, muscle gain, cardiovascular health). Returns: List[Dict[str, Any]]: A weekly exercise plan. pass def generate_diet_plan(diet_type: str, fitness_goal: str) -> List[str]: Generates a personalized diet plan based on user inputs. Parameters: diet_type (str): User's dietary preference (vegetarian, vegan, gluten-free, none). fitness_goal (str): User's fitness goals (e.g., weight loss, muscle gain, cardiovascular health). Returns: List[str]: A list of dietary recommendations. pass def log_user_progress(user_id: int, workout_log: List[Dict[str, Any]], diet_log: List[str]) -> Dict[str, List[Any]]: Logs user's workout and dietary adherence daily. Parameters: user_id (int): User's unique identifier. workout_log (List[Dict[str, Any]]): List of workouts logged daily. diet_log (List[str]): List of dietary items logged daily. Returns: Dict[str, List[Any]]: A complete log of user's progress. pass def get_user_progress(user_id: int, progress_log: Dict[str, List[Any]]) -> Dict[str, List[Any]]: Retrieves user's progress based on user ID. Parameters: user_id (int): User's unique identifier. progress_log (Dict[str, List[Any]]): A complete log of user's progress. Returns: Dict[str, List[Any]]: A complete log of user's progress. pass import pytest def test_generate_exercise_plan(): plan = generate_exercise_plan(25, 'male', 'beginner', 'weight loss') assert any(ex['name'] == 'Push-ups' for ex in plan) assert any(ex['name'] == 'Running' for ex in plan) plan = generate_exercise_plan(30, 'female', 'intermediate', 'muscle gain') assert any(ex['name'] == 'Bench Press' for ex in plan) assert any(ex['name'] == 'Bicep Curls' for ex in plan) plan = generate_exercise_plan(35, 'female', 'advanced', 'cardiovascular health') assert any(ex['name'] == 'Snatch' for ex in plan) assert any(ex['name'] == 'Jump Rope' for ex in plan) def test_generate_diet_plan(): diet = generate_diet_plan('vegetarian', 'weight loss') assert 'Salad' in diet assert 'Low-carb vegetables' in diet diet = generate_diet_plan('vegan', 'muscle gain') assert 'Vegan Burger' in diet assert 'High-protein meals' in diet diet = generate_diet_plan('gluten-free', 'cardiovascular health') assert 'Grilled Chicken' in diet assert 'Whole grains' in diet diet = generate_diet_plan('none', 'weight loss') assert 'Chicken Breast' in diet assert 'Low-carb vegetables' in diet def test_log_user_progress(): progress_log = log_user_progress(1, [{'name': 'Running', 'sets': 1, 'reps': '30 min', 'rest': 'none'}], ['Salad']) assert progress_log['user_id'] == 1 assert len(progress_log['workout_log']) == 1 assert progress_log['workout_log'][0]['name'] == 'Running' assert 'Salad' in progress_log['diet_log'] def test_get_user_progress(): progress_log = log_user_progress(1, [{'name': 'Running', 'sets': 1, 'reps': '30 min', 'rest': 'none'}], ['Salad']) user_progress = get_user_progress(1, progress_log) assert user_progress['user_id'] == 1 assert user_progress['workout_log'][0]['name'] == 'Running' with pytest.raises(ValueError): get_user_progress(2, progress_log)","solution":"from typing import List, Dict, Any def generate_exercise_plan(age: int, gender: str, fitness_level: str, fitness_goals: str) -> List[Dict[str, Any]]: Generates a personalized exercise routine based on user inputs. Parameters: age (int): User's age. gender (str): User's gender. fitness_level (str): User's fitness level (beginner, intermediate, advanced). fitness_goals (str): User's fitness goals (e.g., weight loss, muscle gain, cardiovascular health). Returns: List[Dict[str, Any]]: A weekly exercise plan. plan = [] exercises = { 'beginner': [ {'name': 'Push-ups', 'sets': 3, 'reps': 10, 'rest': '1 min'}, {'name': 'Squats', 'sets': 3, 'reps': 15, 'rest': '1 min'}, {'name': 'Plank', 'sets': 3, 'reps': '30 sec', 'rest': '1 min'} ], 'intermediate': [ {'name': 'Bench Press', 'sets': 4, 'reps': 12, 'rest': '1 min'}, {'name': 'Deadlifts', 'sets': 4, 'reps': 10, 'rest': '1 min'}, {'name': 'Pull-ups', 'sets': 3, 'reps': 8, 'rest': '1 min'} ], 'advanced': [ {'name': 'Snatch', 'sets': 5, 'reps': 6, 'rest': '2 min'}, {'name': 'Clean and Jerk', 'sets': 5, 'reps': 6, 'rest': '2 min'}, {'name': 'Front Squat', 'sets': 5, 'reps': 8, 'rest': '2 min'} ] } goal_exercises = { 'weight loss': [ {'name': 'Running', 'sets': 1, 'reps': '30 min', 'rest': 'none'}, {'name': 'Cycling', 'sets': 1, 'reps': '45 min', 'rest': 'none'} ], 'muscle gain': [ {'name': 'Bicep Curls', 'sets': 4, 'reps': 10, 'rest': '1 min'}, {'name': 'Tricep Dips', 'sets': 4, 'reps': 12, 'rest': '1 min'} ], 'cardiovascular health': [ {'name': 'Jump Rope', 'sets': 3, 'reps': '5 min', 'rest': '2 min'}, {'name': 'Swimming', 'sets': 1, 'reps': '30 min', 'rest': 'none'} ] } plan.extend(exercises[fitness_level]) plan.extend(goal_exercises[fitness_goals]) return plan def generate_diet_plan(diet_type: str, fitness_goal: str) -> List[str]: Generates a personalized diet plan based on user inputs. Parameters: diet_type (str): User's dietary preference (vegetarian, vegan, gluten-free, none). fitness_goal (str): User's fitness goals (e.g., weight loss, muscle gain, cardiovascular health). Returns: List[str]: A list of dietary recommendations. diet_preferences = { 'vegetarian': ['Salad', 'Vegetable Stir Fry', 'Lentil Soup'], 'vegan': ['Vegan Burger', 'Quinoa Bowl', 'Smoothie'], 'gluten-free': ['Grilled Chicken', 'Quinoa Salad', 'Fruit Salad'], 'none': ['Chicken Breast', 'Mixed Vegetables', 'Yogurt'] } fitness_goal_diet = { 'weight loss': ['Low-carb vegetables', 'Lean meats', 'Intermittent fasting'], 'muscle gain': ['High-protein meals', 'Protein shakes', 'Nuts and seeds'], 'cardiovascular health': ['Whole grains', 'Fruits', 'Oats'] } diet_plan = diet_preferences[diet_type] diet_plan.extend(fitness_goal_diet[fitness_goal]) return diet_plan def log_user_progress(user_id: int, workout_log: List[Dict[str, Any]], diet_log: List[str]) -> Dict[str, List[Any]]: Logs user's workout and dietary adherence daily. Parameters: user_id (int): User's unique identifier. workout_log (List[Dict[str, Any]]): List of workouts logged daily. diet_log (List[str]): List of dietary items logged daily. Returns: Dict[str, List[Any]]: A complete log of user's progress. progress_log = { 'user_id': user_id, 'workout_log': workout_log, 'diet_log': diet_log } return progress_log def get_user_progress(user_id: int, progress_log: Dict[str, List[Any]]) -> Dict[str, List[Any]]: Retrieves user's progress based on user ID. Parameters: user_id (int): User's unique identifier. Returns: Dict[str, List[Any]]: A complete log of user's progress. if progress_log['user_id'] == user_id: return progress_log else: raise ValueError(\\"User ID not found in progress log.\\")"},{"question":"from typing import List def can_jump(nums: List[int]) -> bool: Determines if you can reach the last index of the array starting from the first index. :param nums: List[int] - array of integers where each element represents the maximum jump length at that position :return: bool - True if you can reach the last index, False otherwise >>> can_jump([2, 3, 1, 1, 4]) True >>> can_jump([3, 2, 1, 0, 4]) False >>> can_jump([0]) True >>> can_jump([0, 0, 0, 0]) False >>> can_jump([1, 0]) True >>> can_jump([3, 2, 1, 0, 4, 6, 7, 8, 9, 10, 0, 0, 1, 1, 1, 0]) False >>> can_jump([10, 2, 1, 0, 4]) True","solution":"def can_jump(nums): Determines if you can reach the last index of the array starting from the first index. :param nums: List[int] - array of integers where each element represents the maximum jump length at that position :return: bool - True if you can reach the last index, False otherwise max_reachable = 0 for i, jump in enumerate(nums): if i > max_reachable: return False max_reachable = max(max_reachable, i + jump) return True"},{"question":"import re def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome, ignoring case sensitivity, spaces, and punctuation. >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"RaceCar\\") True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"This is not a palindrome\\") False >>> is_palindrome(\\"Hello, World!\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"Z\\") True","solution":"import re def is_palindrome(s): Checks if the given string is a palindrome, ignoring case sensitivity, spaces, and punctuation. # Remove non-alphanumeric characters and convert to lowercase cleaned = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the cleaned string is equal to its reverse return cleaned == cleaned[::-1]"},{"question":"def maxProfitWithTwoTransactions(prices: List[int]) -> int: Consider a list of integers where each integer represents the price of a stock on a given day. You are allowed to complete at most two transactions, where a transaction is defined as buying one and selling one share of the stock. Design an algorithm to find the maximum profit you can achieve under these constraints. Note that you cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). >>> maxProfitWithTwoTransactions([3,3,5,0,0,3,1,4]) 6 >>> maxProfitWithTwoTransactions([1,2,3,4,5]) 4 >>> maxProfitWithTwoTransactions([7,6,4,3,1]) 0 >>> maxProfitWithTwoTransactions([]) 0 >>> maxProfitWithTwoTransactions([1,2,4,2,5,7,2,4,9,0]) 13 >>> maxProfitWithTwoTransactions([7,6,5,4,3,2,1]) 0 >>> maxProfitWithTwoTransactions([1,7,4,2,10]) 14 pass","solution":"def maxProfitWithTwoTransactions(prices): if not prices: return 0 # First transaction first_buy = float('-inf') first_sell = 0 # Second transaction second_buy = float('-inf') second_sell = 0 for price in prices: # If we had bought the stock in the first transaction first_buy = max(first_buy, -price) # If we had sold the stock in the first transaction first_sell = max(first_sell, first_buy + price) # If we had bought the stock in the second transaction (after first sell) second_buy = max(second_buy, first_sell - price) # If we had sold the stock in the second transaction second_sell = max(second_sell, second_buy + price) return second_sell"},{"question":"def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted lists into one sorted list. >>> merge([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] pass def merge_sort(numbers: List[int]) -> List[int]: Sorts a list of numbers in ascending order using the merge sort algorithm. >>> merge_sort([34, 7, 23, 32, 5, 62]) [5, 7, 23, 32, 34, 62] >>> merge_sort([]) [] >>> merge_sort([1]) [1] >>> merge_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> merge_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> merge_sort([3, 2, 1, 2, 3]) [1, 2, 2, 3, 3] >>> merge_sort([1000000, 1, 1000, 100000, 10]) [1, 10, 1000, 100000, 1000000] pass","solution":"def merge(left, right): Merges two sorted lists into one sorted list. result = [] i = j = 0 # Traverse both lists and insert the smallest element from either list into the result list while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 # Append remaining elements of left or right list, if any result.extend(left[i:]) result.extend(right[j:]) return result def merge_sort(numbers): Sorts a list of numbers in ascending order using the merge sort algorithm. if len(numbers) <= 1: return numbers # Divide the list into two halves mid = len(numbers) // 2 left_half = merge_sort(numbers[:mid]) right_half = merge_sort(numbers[mid:]) # Merge the sorted halves return merge(left_half, right_half)"},{"question":"def is_palindrome(s: str) -> bool: Determines whether the given string is a palindrome, ignoring spaces, punctuation, and capitalization. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"This is not a palindrome\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"12345\\") False >>> is_palindrome(\\" - . :- @ A man, a plan, a canal: Panama!@,. -\\") True pass","solution":"def is_palindrome(s): Determines whether the given string is a palindrome, ignoring spaces, punctuation, and capitalization. # Clean the string by removing non-alphanumeric characters and converting to lowercase. clean_s = ''.join(char.lower() for char in s if char.isalnum()) left, right = 0, len(clean_s) - 1 while left < right: if clean_s[left] != clean_s[right]: return False left += 1 right -= 1 return True"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a given arithmetic expression and return the result or \\"Error\\" if division by zero is encountered. This function handles addition (+), subtraction (-), multiplication (*), and division (/) operators, and respects the operator precedence rules. Parentheses are also supported. >>> evaluate_expression(\\"3 + 5 / 2 * 3 - 6\\") 3 >>> evaluate_expression(\\"2 + 3 * 2\\") 8 >>> evaluate_expression(\\"10 * (2 + 3) / 5\\") \\"Error\\" >>> evaluate_expression(\\"10 / 0\\") \\"Error\\"","solution":"def evaluate_expression(expression): Evaluate the given arithmetic expression and return the result or \\"Error\\" if division by zero is encountered. def operate(a, b, op): if op == '+': return a + b elif op == '-': return a - b elif op == '*': return a * b elif op == '/': if b == 0: return \\"Error\\" return a // b def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def apply_ops(operators, values): b = values.pop() a = values.pop() op = operators.pop() result = operate(a, b, op) if result == \\"Error\\": return \\"Error\\" values.append(result) i = 0 n = len(expression) values = [] operators = [] while i < n: if expression[i] == ' ': i += 1 continue if expression[i].isdigit(): val = 0 while i < n and expression[i].isdigit(): val = val * 10 + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == '(': operators.append(expression[i]) elif expression[i] == ')': while operators[-1] != '(': if apply_ops(operators, values) == \\"Error\\": return \\"Error\\" operators.pop() else: while (operators and operators[-1] != '(' and precedence(operators[-1]) >= precedence(expression[i])): if apply_ops(operators, values) == \\"Error\\": return \\"Error\\" operators.append(expression[i]) i += 1 while operators: if apply_ops(operators, values) == \\"Error\\": return \\"Error\\" return values[-1]"},{"question":"def sort_and_merge(input_string: str) -> str: Separates the letters and digits from the input string, sorts each group in ascending order and merges them back together with letters appearing before the digits. >>> sort_and_merge('d4c3b2a1') 'abcd1234' >>> sort_and_merge('dcba') 'abcd' >>> sort_and_merge('4321') '1234' >>> sort_and_merge('') '' >>> sort_and_merge('a1b2c3') 'abc123' >>> sort_and_merge('z9y8x7') 'xyz789'","solution":"def sort_and_merge(input_string): Separates the letters and digits from the input string, sorts each group in ascending order and merges them back together with letters appearing before the digits. letters = [] digits = [] for char in input_string: if char.isalpha(): letters.append(char) elif char.isdigit(): digits.append(char) sorted_letters = sorted(letters) sorted_digits = sorted(digits) return ''.join(sorted_letters + sorted_digits)"},{"question":"def first_non_repeating_character(s: str) -> str: Implement a function that takes a string as input and returns the first non-repeating character in the string. If all characters are repeating or the string is empty, return an appropriate message. >>> first_non_repeating_character(\\"swiss\\") == \\"w\\" >>> first_non_repeating_character(\\"racecar\\") == \\"e\\" >>> first_non_repeating_character(\\"aabbcc\\") == \\"No non-repeating character found\\" >>> first_non_repeating_character(\\"\\") == \\"Empty string\\" >>> first_non_repeating_character(\\"abcdefghhgfedcba\\") == \\"No non-repeating character found\\" >>> first_non_repeating_character(\\"a\\") == \\"a\\" >>> first_non_repeating_character(\\"ab\\") == \\"a\\" >>> first_non_repeating_character(\\"aabbccddeef\\") == \\"f\\" >>> first_non_repeating_character(\\"1234321\\") == \\"4\\"","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string. If all characters are repeating or the string is empty, returns an appropriate message. if not s: return \\"Empty string\\" # Create a dictionary to store the count of each character char_count = {} # Count occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first non-repeating character for char in s: if char_count[char] == 1: return char return \\"No non-repeating character found\\""},{"question":"def reverse_words_in_string(s: str) -> str: Returns the string with the words reversed, while preserving the original order of characters within each word. >>> reverse_words_in_string(\\"hello\\") == \\"olleh\\" >>> reverse_words_in_string(\\"hello world\\") == \\"olleh dlrow\\" >>> reverse_words_in_string(\\"hi there, how are you?\\") == \\"ih ,ereht woh era ?uoy\\" >>> reverse_words_in_string(\\"Python Is Fun\\") == \\"nohtyP sI nuF\\" >>> reverse_words_in_string(\\"\\") == \\"\\" >>> reverse_words_in_string(\\"This has multiple spaces\\") == \\"sihT sah elpitlum secaps\\"","solution":"def reverse_words_in_string(s): Returns the string with the words reversed, while preserving the original order of characters within each word. # Split the string into words words = s.split() # Reverse each word and join them back with spaces reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"def merge_alternately(lower_str: str, upper_str: str) -> str: Merge two strings by alternating their characters, starting with the lowercase string. If one string is longer than the other, append the remaining characters of that string at the end. :param lower_str: string containing lowercase alphabets :param upper_str: string containing uppercase alphabets :return: combined string Example usage: >>> merge_alternately(\\"abc\\", \\"XYZ\\") 'aXbYcZ' >>> merge_alternately(\\"ab\\", \\"WXYZ\\") 'aWbXYZ' >>> merge_alternately(\\"\\", \\"ABC\\") 'ABC' >>> merge_alternately(\\"abc\\", \\"\\") 'abc' >>> merge_alternately(\\"\\", \\"\\") '' >>> merge_alternately(\\"a\\", \\"Z\\") 'aZ'","solution":"def merge_alternately(lower_str, upper_str): Merges two strings by alternating their characters, starting with the lowercase string. If one string is longer than the other, append the remaining characters of that string at the end. :param lower_str: string containing lowercase alphabets :param upper_str: string containing uppercase alphabets :return: combined string result = [] min_length = min(len(lower_str), len(upper_str)) for i in range(min_length): result.append(lower_str[i]) result.append(upper_str[i]) # Append remaining characters of the longer string if len(lower_str) > len(upper_str): result.extend(lower_str[min_length:]) else: result.extend(upper_str[min_length:]) return ''.join(result)"},{"question":"def analyze_temperature_drops(temperatures: List[int]) -> Union[List[Tuple[int, int]], str]: Analyzes a list of temperatures recorded over a week and determines if a sudden temperature drop occurred. A sudden drop is defined as a decrease of 15 degrees or more from one day to the next. Parameters: temperatures (list): A list of integers representing daily temperatures over a week. Returns: list or str: A list of tuples, each containing two consecutive days temperatures where a drop of 15 degrees or more is observed, or the string \\"No sudden drop\\" if no such drops are found. >>> analyze_temperature_drops([70, 72, 75, 78, 80, 81, 80]) 'No sudden drop' >>> analyze_temperature_drops([70, 55]) [(70, 55)] >>> analyze_temperature_drops([70, 55, 60, 40, 80, 62, 70, 50]) [(70, 55), (60, 40), (80, 62), (70, 50)] >>> analyze_temperature_drops([80, 60, 61, 62, 63, 62, 50]) [(80, 60)] >>> analyze_temperature_drops([]) 'No sudden drop' >>> analyze_temperature_drops([70]) 'No sudden drop' >>> analyze_temperature_drops([50, 50, 50, 50, 50, 50, 50]) 'No sudden drop'","solution":"def analyze_temperature_drops(temperatures): Analyzes a list of temperatures recorded over a week and determines if a sudden temperature drop occurred. A sudden drop is defined as a decrease of 15 degrees or more from one day to the next. Parameters: temperatures (list): A list of integers representing daily temperatures over a week. Returns: list or str: A list of tuples, each containing two consecutive days temperatures where a drop of 15 degrees or more is observed, or the string \\"No sudden drop\\" if no such drops are found. if len(temperatures) <= 1: return \\"No sudden drop\\" sudden_drops = [] for i in range(len(temperatures) - 1): if temperatures[i] - temperatures[i + 1] >= 15: sudden_drops.append((temperatures[i], temperatures[i + 1])) return sudden_drops if sudden_drops else \\"No sudden drop\\""},{"question":"def longest_increasing_subsequence(nums: List[int]) -> int: Returns the length of the longest increasing subsequence in the list of integers nums. >>> longest_increasing_subsequence([]) # 0 >>> longest_increasing_subsequence([10]) # 1 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) # 1 >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) # 4 >>> longest_increasing_subsequence([1, 2, 3, 4, 5, 6]) # 6 >>> longest_increasing_subsequence([3, 3, 3, 3, 3]) # 1 >>> longest_increasing_subsequence(\\"Invalid input\\") # raises ValueError >>> longest_increasing_subsequence([1, 2, \\"three\\", 4]) # raises ValueError","solution":"def longest_increasing_subsequence(nums): Returns the length of the longest increasing subsequence in the list of integers nums. if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums): raise ValueError(\\"Input must be a list of integers.\\") if not nums: return 0 n = len(nums) dp = [1] * n # Initialize the dp array where each element is 1 for i in range(n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def decrypt_message(encrypted_message: str) -> str: Decrypts the given message by shifting each letter 2 positions back in the alphabet. Non-alphabetical characters remain unchanged. >>> decrypt_message(\\"cde\\") == \\"abc\\" >>> decrypt_message(\\"e f g!\\") == \\"c d e!\\" >>> decrypt_message(\\"shift y z a!\\") == \\"qfgdr w x y!\\"","solution":"def decrypt_message(encrypted_message: str) -> str: Decrypts the given message by shifting each letter 2 positions back in the alphabet. Non-alphabetical characters remain unchanged. decrypted_message = [] for char in encrypted_message: if 'a' <= char <= 'z': decrypted_char = chr((ord(char) - ord('a') - 2) % 26 + ord('a')) decrypted_message.append(decrypted_char) elif 'A' <= char <= 'Z': decrypted_char = chr((ord(char) - ord('A') - 2) % 26 + ord('A')) decrypted_message.append(decrypted_char) else: decrypted_message.append(char) return ''.join(decrypted_message)"},{"question":"import re operators = set(['+', '-', '*', '/', '(', ')']) priority = {'+': 1, '-': 1, '*': 2, '/': 2} def infix_to_postfix(expression): Convert infix expression to postfix expression. def evaluate_postfix(expression): Evaluate a postfix expression. def validate_expression(expression): Validate the arithmetic expression. >>> validate_expression(\\"2+3*4\\") True >>> validate_expression(\\"2 + 3 * 4\\") True >>> validate_expression(\\"2+a\\") False >>> validate_expression(\\"(2+3)*4\\") True >>> validate_expression(\\"(2+3*4\\") False def compute_expression(expression): Compute the result of an arithmetic expression. >>> compute_expression(\\"2+3\\") 5 >>> compute_expression(\\"5-3\\") 2 >>> compute_expression(\\"4*2\\") 8 >>> compute_expression(\\"8/4\\") 2.0 >>> compute_expression(\\"2+3*4\\") 14 >>> compute_expression(\\"4*3+2\\") 14 >>> compute_expression(\\"2+3*4-5\\") 9 >>> compute_expression(\\"(2+3)*4\\") 20 >>> compute_expression(\\"4*(3+2)\\") 20 >>> compute_expression(\\"((2+3)*4)/2\\") 10 >>> compute_expression(\\"4*((3+2)*2)\\") 40","solution":"import re operators = set(['+', '-', '*', '/', '(', ')']) priority = {'+': 1, '-': 1, '*': 2, '/': 2} def infix_to_postfix(expression): stack = [] output = '' for char in expression: if char not in operators: output+= char elif char=='(': stack.append('(') elif char==')': while stack and stack[-1]!= '(': output+= stack.pop() stack.pop() else: while stack and stack[-1]!='(' and priority[char]<=priority[stack[-1]]: output+= stack.pop() stack.append(char) while stack: output+= stack.pop() return output def evaluate_postfix(expression): stack = [] for char in expression: if char not in operators: stack.append(int(char)) else: b = stack.pop() a = stack.pop() if char == '+': stack.append(a + b) elif char == '-': stack.append(a - b) elif char == '*': stack.append(a * b) elif char == '/': stack.append(a / b) return stack[0] def validate_expression(expression): if re.search(r'[^0-9+-*/() ]', expression): return False if expression.count('(') != expression.count(')'): return False return True def compute_expression(expression): if not validate_expression(expression): raise ValueError(\\"Invalid Expression\\") expression = re.sub(r's+', '', expression) postfix_expr = infix_to_postfix(expression) return evaluate_postfix(postfix_expr)"},{"question":"def longest_word_length(s: str) -> int: Returns the length of the longest word in the given string. Parameters: s (str): The input string consisting of alphabetic characters and spaces. Returns: int: The length of the longest word in the string. >>> longest_word_length(\\"alphabet\\") == 8 >>> longest_word_length(\\"A dog fox cat bat\\") == 3 >>> longest_word_length(\\"A quick brown fox jumps over the lazy dog\\") == 5 >>> longest_word_length(\\"bat cat rat mat\\") == 3 >>> longest_word_length(\\"a b c d e f g\\") == 1","solution":"def longest_word_length(s): Returns the length of the longest word in the given string. Parameters: s (str): The input string consisting of alphabetic characters and spaces. Returns: int: The length of the longest word in the string. words = s.split() longest_length = max(len(word) for word in words) return longest_length"},{"question":"def is_perfect_square(n: int) -> bool: Checks if a given integer n is a perfect square. >>> is_perfect_square(0) True >>> is_perfect_square(1) True >>> is_perfect_square(4) True >>> is_perfect_square(26) False def filter_perfect_squares(lst: List[int]) -> List[int]: Returns a list of perfect squares from the original list of integers. >>> filter_perfect_squares([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [1, 4, 9] >>> filter_perfect_squares([2, 3, 10, 15]) []","solution":"def is_perfect_square(n): Checks if a given integer n is a perfect square. if n < 0: return False root = int(n**0.5) return root*root == n def filter_perfect_squares(lst): Returns a list of perfect squares from the original list of integers. return [x for x in lst if is_perfect_square(x)]"},{"question":"from itertools import permutations def generate_unique_permutations(s: str) -> list: Generate all unique permutations of the string s. >>> generate_unique_permutations(\\"abc\\") ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] >>> generate_unique_permutations(\\"aab\\") ['aab', 'aba', 'baa'] >>> generate_unique_permutations(\\"\\") [\\"\\"] >>> generate_unique_permutations(\\"a\\") [\\"a\\"] >>> generate_unique_permutations(\\"aaab\\") ['aaab', 'aaba', 'abaa', 'baaa']","solution":"from itertools import permutations def generate_unique_permutations(s): Generate all unique permutations of the string s. return list(set([''.join(p) for p in permutations(s)]))"},{"question":"def intersection(nums1: List[int], nums2: List[int]) -> List[int]: Determine the intersection of two integer arrays. Each element in the result must be unique and output can be in any order. >>> intersection([1, 2, 2, 1], [2, 2]) [2] >>> intersection([4, 9, 5], [9, 4, 9, 8, 4]) [9, 4] # or [4, 9]","solution":"def intersection(nums1, nums2): Returns the intersection of two arrays where each element in the result is unique. set1 = set(nums1) set2 = set(nums2) return list(set1 & set2)"},{"question":"import numpy as np def create_array(data): Create a 2D numpy array from the given list of lists. Args: - data: List of lists where each sublist represents a row of the array. Returns: - A 2D numpy array pass def normalize_array(arr): Normalize the data values in the numpy array such that the mean of each column is 0 and the standard deviation is 1. Args: - arr: A 2D numpy array. Returns: - A new 2D numpy array with normalized values. pass # Example input data = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Create array array = create_array(data) # Normalize array normalized_array = normalize_array(array) # Print both the original and normalized arrays. print(\\"Original array:\\") print(array) print(\\"nNormalized array:\\") print(normalized_array) # Common mistake example: # Incorrect normalization caused by calculating the mean and std dev across the entire array instead of column-wise. def incorrect_normalize_array(arr): Incorrectly normalize the data values in the numpy array by calculating mean and std dev across the entire array instead of column-wise. Args: - arr: A 2D numpy array. Returns: - A new 2D numpy array with incorrectly normalized values. pass # Incorrectly normalized array for comparison incorrect_normalized_array = incorrect_normalize_array(array) print(\\"nIncorrectly normalized array:\\") print(incorrect_normalized_array)","solution":"import numpy as np def create_array(data): Create a 2D numpy array from the given list of lists. Args: - data: List of lists where each sublist represents a row of the array. Returns: - A 2D numpy array return np.array(data) def normalize_array(arr): Normalize the data values in the numpy array such that the mean of each column is 0 and the standard deviation is 1. Args: - arr: A 2D numpy array. Returns: - A new 2D numpy array with normalized values. mean = np.mean(arr, axis=0) std_dev = np.std(arr, axis=0) # Handle divisions by zero (columns with zero variance). std_dev[std_dev == 0] = 1 normalized_arr = (arr - mean) / std_dev return normalized_arr # Example input data = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Create array array = create_array(data) # Normalize array normalized_array = normalize_array(array) # Print both the original and normalized arrays. print(\\"Original array:\\") print(array) print(\\"nNormalized array:\\") print(normalized_array) # Common mistake example: # Incorrect normalization caused by calculating the mean and std dev across the entire array instead of column-wise. def incorrect_normalize_array(arr): Incorrectly normalize the data values in the numpy array by calculating mean and std dev across the entire array instead of column-wise. Args: - arr: A 2D numpy array. Returns: - A new 2D numpy array with incorrectly normalized values. mean = np.mean(arr) std_dev = np.std(arr) return (arr - mean) / std_dev # Incorrectly normalized array for comparison incorrect_normalized_array = incorrect_normalize_array(array) print(\\"nIncorrectly normalized array:\\") print(incorrect_normalized_array)"},{"question":"def run_length_encoding(s: str) -> str: Compresses a given string using Run-Length Encoding (RLE). Args: s (str): The input string to be compressed. Returns: str: The compressed string in RLE format. >>> run_length_encoding(\\"\\") == \\"\\" >>> run_length_encoding(\\"a\\") == \\"a1\\" >>> run_length_encoding(\\"abc\\") == \\"a1b1c1\\" >>> run_length_encoding(\\"aaaa\\") == \\"a4\\" >>> run_length_encoding(\\"aaabbc\\") == \\"a3b2c1\\" >>> run_length_encoding(\\"aabcccccaaa\\") == \\"a2b1c5a3\\"","solution":"def run_length_encoding(s): Compresses the given string using Run-Length Encoding (RLE). Args: s (str): The input string to be compressed. Returns: str: The compressed string in RLE format. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) return ''.join(compressed) # The initial implementation is fairly efficient. It has a time complexity of O(n) and # space complexity of O(n) where n is the length of the input string. The only minor optimization # would be to avoid unnecessary appends, which is already minimal in the provided code."},{"question":"class Bank: A class to simulate an automated bank that processes transactions. Each transaction must include a unique ID, a user ID, a transaction type (deposit or withdrawal), and an amount. The program should allow users to input a series of transactions and then output a summary report showing the final balance for each user and a log of all the transactions sorted by transaction ID. Ensure that withdrawals do not result in a negative balance for any user. If a withdrawal exceeds the available balance, the transaction should be skipped and an error message should be logged for that transaction. >>> bank = Bank() >>> bank.process_transaction(1, 'user1', 'deposit', 100) >>> bank.process_transaction(2, 'user1', 'withdrawal', 50) >>> bank.process_transaction(3, 'user1', 'withdrawal', 60) # Should log error >>> balances, transactions, errors = bank.summary_report() >>> balances {'user1': 50} >>> transactions [(1, 'user1', 'deposit', 100), (2, 'user1', 'withdrawal', 50)] >>> errors [\\"Error: Withdrawal of 60 exceeds balance for user user1\\"] def __init__(self): pass def process_transaction(self, transaction_id, user_id, transaction_type, amount): pass def summary_report(self): pass","solution":"class Bank: def __init__(self): self.transactions = [] self.user_balances = {} self.error_log = [] def process_transaction(self, transaction_id, user_id, transaction_type, amount): if transaction_type not in ['deposit', 'withdrawal']: raise ValueError(\\"Transaction type must be 'deposit' or 'withdrawal'\\") if user_id not in self.user_balances: self.user_balances[user_id] = 0 if transaction_type == 'deposit': self.user_balances[user_id] += amount self.transactions.append((transaction_id, user_id, transaction_type, amount)) elif transaction_type == 'withdrawal': if self.user_balances[user_id] >= amount: self.user_balances[user_id] -= amount self.transactions.append((transaction_id, user_id, transaction_type, amount)) else: self.error_log.append(f\\"Error: Withdrawal of {amount} exceeds balance for user {user_id}\\") def summary_report(self): sorted_transactions = sorted(self.transactions, key=lambda x: x[0]) return self.user_balances, sorted_transactions, self.error_log"},{"question":"def sum_of_squares(lst: list) -> int: Returns the sum of the squares of the elements in the list. >>> sum_of_squares([1, 2, 3, 4]) 30 >>> sum_of_squares([]) 0 >>> sum_of_squares([5]) 25 >>> sum_of_squares([-1, -2, -3, -4]) 30 >>> sum_of_squares([-1, 2, -3, 4]) 30 >>> sum_of_squares([-1, 0, 3]) 10","solution":"def sum_of_squares(lst: list) -> int: Returns the sum of the squares of the elements in the list. :param lst: List of integers :return: Sum of the squares of the integers in the list return sum(x**2 for x in lst)"},{"question":"def rpn_calculator(tokens): Simulate the operation of a simplified stack-based calculator using Reverse Polish Notation (RPN). Parameters: tokens (list of str): A list of strings where each string is either an integer or an operator (\\"+\\", \\"-\\", \\"*\\", \\"/\\"). Returns: int: The final result after processing all operations. >>> rpn_calculator([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) 9 >>> rpn_calculator([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"-\\"]) 2 >>> rpn_calculator([\\"10\\", \\"6\\", \\"9\\", \\"3\\", \\"+\\", \\"-11\\", \\"*\\", \\"/\\", \\"*\\", \\"17\\", \\"+\\", \\"5\\", \\"+\\"]) 22 >>> rpn_calculator([\\"5\\"]) 5 >>> rpn_calculator([\\"8\\", \\"2\\", \\"/\\"]) 4 >>> rpn_calculator([\\"7\\", \\"3\\", \\"/\\"]) 2 >>> rpn_calculator([\\"-7\\", \\"3\\", \\"/\\"]) -2 >>> rpn_calculator([\\"123456789\\", \\"987654321\\", \\"*\\"]) 123456789 * 987654321","solution":"def rpn_calculator(tokens): Simulate the operation of a simplified stack-based calculator using Reverse Polish Notation (RPN). Parameters: tokens (list of str): A list of strings where each string is either an integer or an operator (\\"+\\", \\"-\\", \\"*\\", \\"/\\"). Returns: int: The final result after processing all operations. stack = [] for token in tokens: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == \\"+\\": stack.append(a + b) elif token == \\"-\\": stack.append(a - b) elif token == \\"*\\": stack.append(a * b) elif token == \\"/\\": # Perform integer division as required stack.append(int(a / b)) else: stack.append(int(token)) return stack.pop()"},{"question":"def is_happy_number(n: int) -> bool: Returns True if n is a happy number, otherwise False. A Happy Number is defined by the following process: starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1, or it loops endlessly in a cycle which does not include 1. Use a set to detect cycles. Examples: >>> is_happy_number(19) True >>> is_happy_number(2) False >>> is_happy_number(7) True","solution":"def is_happy_number(n): Returns True if n is a happy number, otherwise False. Examples: is_happy_number(19) should return True is_happy_number(2) should return False is_happy_number(7) should return True def get_next(number): return sum(int(char) ** 2 for char in str(number)) seen_numbers = set() while n != 1 and n not in seen_numbers: seen_numbers.add(n) n = get_next(n) return n == 1"},{"question":"def count_unique_substrings(s: str) -> int: Returns the number of unique substrings that can be formed from the input string s. >>> count_unique_substrings(\\"ababc\\") 12 >>> count_unique_substrings(\\"a\\") 1 >>> count_unique_substrings(\\"aaa\\") 3 >>> count_unique_substrings(\\"abc\\") 6 >>> count_unique_substrings(\\"abcd\\") 10 >>> count_unique_substrings(\\"\\") 0 >>> count_unique_substrings(\\"aa\\") 2 >>> count_unique_substrings(\\"ab\\") 3 >>> count_unique_substrings(\\"ba\\") 3","solution":"def count_unique_substrings(s): Returns the number of unique substrings that can be formed from the input string s. unique_substrings = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): unique_substrings.add(s[i:j]) return len(unique_substrings)"},{"question":"def levenshtein_distance(s1: str, s2: str) -> int: Calculate the Levenshtein distance between two strings using dynamic programming. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: int: The Levenshtein distance between the two strings. >>> levenshtein_distance(\\"kitten\\", \\"sitting\\") 3 >>> levenshtein_distance(\\"flaw\\", \\"lawn\\") 2 >>> levenshtein_distance(\\"\\", \\"\\") 0 >>> levenshtein_distance(\\"a\\", \\"\\") 1 >>> levenshtein_distance(\\"\\", \\"a\\") 1 >>> levenshtein_distance(\\"abc\\", \\"abc\\") 0 >>> levenshtein_distance(\\"abc\\", \\"yabd\\") 2 >>> levenshtein_distance(\\"intention\\", \\"execution\\") 5 >>> levenshtein_distance(\\"levenshtein\\", \\"meilenstein\\") 4","solution":"def levenshtein_distance(s1, s2): Calculate the Levenshtein distance between two strings using dynamic programming. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: int: The Levenshtein distance between the two strings. len_s1 = len(s1) len_s2 = len(s2) # Create a distance matrix and initialize it dp = [[0 for _ in range(len_s2 + 1)] for _ in range(len_s1 + 1)] # Initialize source prefixes to empty string transformations for i in range(len_s1 + 1): dp[i][0] = i for j in range(len_s2 + 1): dp[0][j] = j # Apply the Levenshtein distance algorithm for i in range(1, len_s1 + 1): for j in range(1, len_s2 + 1): if s1[i - 1] == s2[j - 1]: cost = 0 else: cost = 1 dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + cost) # Substitution return dp[len_s1][len_s2]"},{"question":"def calculate_organization_salary_sum(employees, target_id): Calculate the total salary sum of the target employee's entire organization. >>> employees = [ ... {\\"id\\": 1, \\"manager_id\\": -1, \\"salary\\": 90}, ... {\\"id\\": 2, \\"manager_id\\": 1, \\"salary\\": 100}, ... {\\"id\\": 3, \\"manager_id\\": 2, \\"salary\\": 110}, ... {\\"id\\": 4, \\"manager_id\\": 3, \\"salary\\": 120} ... ] >>> target_id = 2 >>> calculate_organization_salary_sum(employees, target_id) 330","solution":"def calculate_organization_salary_sum(employees, target_id): Calculate the total salary sum of the target employee's entire organization. employee_map = {emp['id']: emp for emp in employees} def calculate_total_salary(employee_id): total_salary = employee_map[employee_id]['salary'] subordinates = [emp['id'] for emp in employees if emp['manager_id'] == employee_id] for subordinate in subordinates: total_salary += calculate_total_salary(subordinate) return total_salary return calculate_total_salary(target_id)"},{"question":"def char_count(s: str) -> dict: Takes a string containing a mix of letters, digits, and special characters, and returns a dictionary with the count of each type of character. :param s: Input string :return: Dictionary with counts of letters, digits, and special characters >>> char_count(\\"HelloWorld\\") == {'letters': 10, 'digits': 0, 'specials': 0} >>> char_count(\\"123456\\") == {'letters': 0, 'digits': 6, 'specials': 0} >>> char_count(\\"!@# %^\\") == {'letters': 0, 'digits': 0, 'specials': 7} >>> char_count(\\"Hello World! 123\\") == {'letters': 10, 'digits': 3, 'specials': 3} >>> char_count(\\"\\") == {'letters': 0, 'digits': 0, 'specials': 0} >>> char_count(\\" \\") == {'letters': 0, 'digits': 0, 'specials': 2} >>> char_count(\\"a1!\\") == {'letters': 1, 'digits': 1, 'specials': 1}","solution":"import string def char_count(s): Takes a string containing a mix of letters, digits, and special characters, and returns a dictionary with the count of each type of character. :param s: Input string :return: Dictionary with counts of letters, digits, and special characters count = {'letters': 0, 'digits': 0, 'specials': 0} for char in s: if char.isalpha(): count['letters'] += 1 elif char.isdigit(): count['digits'] += 1 elif char in string.punctuation or char.isspace(): count['specials'] += 1 return count"},{"question":"def transposeMatrix(matrix): Returns the transpose of the given matrix. Parameters: matrix (list of lists): The 2D list to transpose Returns: list of lists: The transposed matrix Examples: >>> transposeMatrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transposeMatrix([ ... [1, 2, 3], ... [4, 5, 6] ... ]) [[1, 4], [2, 5], [3, 6]] >>> transposeMatrix([[1, 2, 3]]) [[1], [2], [3]] >>> transposeMatrix([[1], [2], [3]]) [[1, 2, 3]] >>> transposeMatrix([]) []","solution":"def transposeMatrix(matrix): Returns the transpose of the given matrix. Parameters: matrix (list of lists): The 2D list to transpose Returns: list of lists: The transposed matrix return [list(row) for row in zip(*matrix)]"},{"question":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters. Uses a sliding window approach to achieve linear time complexity. Args: s (str): Input string Returns: str: The longest substring without repeating characters >>> longest_unique_substring(\\"abcabcbb\\") == \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") == \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") == \\"wke\\" >>> longest_unique_substring(\\"\\") == \\"\\" >>> longest_unique_substring(\\"a\\") == \\"a\\" >>> longest_unique_substring(\\"au\\") == \\"au\\" >>> longest_unique_substring(\\"abba\\") == \\"ab\\"","solution":"def longest_unique_substring(s): Returns the longest substring without repeating characters. Uses a sliding window approach to achieve linear time complexity. Args: s (str): Input string Returns: str: The longest substring without repeating characters start = 0 max_length = 0 max_substring = \\"\\" used_chars = {} for i, char in enumerate(s): if char in used_chars and start <= used_chars[char]: start = used_chars[char] + 1 else: if i - start + 1 > max_length: max_length = i - start + 1 max_substring = s[start:i+1] used_chars[char] = i return max_substring"},{"question":"def separate_and_sort_numbers(input_list): Separates the input list into odd and even numbers, and sorts each list individually. Handles non-integer elements by outputting an error message for them. Returns a tuple containing the sorted even numbers list and the sorted odd numbers list. >>> separate_and_sort_numbers([12, 3, \\"hello\\", 5, 8, 9, \\"world\\", 7, 2]) Error: Non-integer value found - hello Error: Non-integer value found - world ([2, 8, 12], [3, 5, 7, 9])","solution":"def separate_and_sort_numbers(input_list): Separates the input list into odd and even numbers, and sorts each list individually. Returns a tuple containing the sorted even numbers list and the sorted odd numbers list. odd_numbers = [] even_numbers = [] for item in input_list: if isinstance(item, int): if item % 2 == 0: even_numbers.append(item) else: odd_numbers.append(item) else: print(f\\"Error: Non-integer value found - {item}\\") return sorted(even_numbers), sorted(odd_numbers)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers and the operators + and *, respecting the standard mathematical order of operations. >>> evaluate_expression(\\"3+5*2\\") 13 >>> evaluate_expression(\\"10+2*6\\") 22 >>> evaluate_expression(\\"100*2+12\\") 212 >>> evaluate_expression(\\"1+2*5+3\\") 14 >>> evaluate_expression(\\"5*6+7*2\\") 44","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing non-negative integers and the operators + and *, respecting the standard mathematical order of operations. # split expression by the '+' operator addition_parts = expression.split('+') # initialize total to zero total = 0 # go through each part that was split by '+' for part in addition_parts: # if there are '*' operators in the current part, calculate the product if '*' in part: product = 1 multiply_parts = part.split('*') for factor in multiply_parts: product *= int(factor) total += product else: total += int(part) return total"},{"question":"from typing import List def longest_consecutive_subsequence(arr: List[int]) -> int: Write a function that takes an array of integers and returns the length of the longest subsequence where the difference between consecutive elements is exactly 1. >>> longest_consecutive_subsequence([1, 2, 3, 4, 6, 5, 7]) 7 >>> longest_consecutive_subsequence([10, 9, 4, 3, 2]) 3","solution":"from typing import List def longest_consecutive_subsequence(arr: List[int]) -> int: if not arr: return 0 arr_set = set(arr) longest_streak = 0 for num in arr_set: if num - 1 not in arr_set: current_num = num current_streak = 1 while current_num + 1 in arr_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def generate_summary(scores): Processes a list of numeric scores and generates a summary. The summary contains the highest score, the lowest score, the average score, the median score, and a list of all unique scores in ascending order. # your code here # Test cases def test_generate_summary_with_normal_list(): scores = [88, 75, 90, 100, 62, 75, 88, 92] summary = generate_summary(scores) assert summary == { \\"highest\\": 100, \\"lowest\\": 62, \\"average\\": 83.75, \\"median\\": 88, \\"unique_scores\\": [62, 75, 88, 90, 92, 100] } def test_generate_summary_with_duplicates(): scores = [100, 100, 100, 100] summary = generate_summary(scores) assert summary == { \\"highest\\": 100, \\"lowest\\": 100, \\"average\\": 100.0, \\"median\\": 100, \\"unique_scores\\": [100] } def test_generate_summary_with_single_element(): scores = [42] summary = generate_summary(scores) assert summary == { \\"highest\\": 42, \\"lowest\\": 42, \\"average\\": 42.0, \\"median\\": 42, \\"unique_scores\\": [42] } def test_generate_summary_with_empty_list(): scores = [] summary = generate_summary(scores) assert summary == { \\"highest\\": None, \\"lowest\\": None, \\"average\\": None, \\"median\\": None, \\"unique_scores\\": [] } def test_generate_summary_with_mixed_elements(): scores = [1, 5, 7, 8, 1, 9] summary = generate_summary(scores) assert summary == { \\"highest\\": 9, \\"lowest\\": 1, \\"average\\": 5.166666666666667, \\"median\\": 6.0, \\"unique_scores\\": [1, 5, 7, 8, 9] }","solution":"def generate_summary(scores): Processes a list of numeric scores and generates a summary. The summary contains the highest score, the lowest score, the average score, the median score, and a list of all unique scores in ascending order. if not scores: return { \\"highest\\": None, \\"lowest\\": None, \\"average\\": None, \\"median\\": None, \\"unique_scores\\": [] } highest = max(scores) lowest = min(scores) average = sum(scores) / len(scores) sorted_scores = sorted(scores) mid = len(sorted_scores) // 2 if len(sorted_scores) % 2 == 0: median = (sorted_scores[mid - 1] + sorted_scores[mid]) / 2 else: median = sorted_scores[mid] unique_scores = sorted(set(scores)) return { \\"highest\\": highest, \\"lowest\\": lowest, \\"average\\": average, \\"median\\": median, \\"unique_scores\\": unique_scores }"},{"question":"from typing import List def findTriplets(arr: List[int]) -> List[List[int]]: Find all unique triplets in the array that add up to zero. Args: arr (List[int]): The input array of integers. Returns: List[List[int]]: A list of all unique triplets that sum to zero. Examples: >>> findTriplets([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> findTriplets([1, 2, 3, 4]) [] pass def test_findTriplets_example_case(): assert findTriplets([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]] def test_findTriplets_no_triplets(): assert findTriplets([1, 2, 3, 4]) == [] def test_findTriplets_all_zeros(): assert findTriplets([0, 0, 0, 0]) == [[0, 0, 0]] def test_findTriplets_mixed_zeros(): assert findTriplets([0, -1, 1, 2, -2]) == [[-2, 0, 2], [-1, 0, 1]] def test_findTriplets_no_elements(): assert findTriplets([]) == [] def test_findTriplets_two_elements(): assert findTriplets([1, -1]) == [] def test_findTriplets_large_numbers(): assert findTriplets([10000, -10000, 0, -5000, 5000]) == [[-10000, 0, 10000], [-5000, 0, 5000]]","solution":"from typing import List def findTriplets(arr: List[int]) -> List[List[int]]: Returns a list of all unique triplets in the array that sum up to zero. arr.sort() triplets = [] n = len(arr) for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, n - 1 while left < right: total = arr[i] + arr[left] + arr[right] if total == 0: triplets.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return triplets"},{"question":"def reverse_sentence(sentence: str) -> str: Reverses the order of words in a given sentence while maintaining the original spacing and punctuation. >>> reverse_sentence(\\"This is a test.\\") == \\"test. a is This\\" >>> reverse_sentence(\\"Hello\\") == \\"Hello\\" >>> reverse_sentence(\\" This is a test. \\") == \\"test. a is This\\" >>> reverse_sentence(\\"\\") == \\"\\" >>> reverse_sentence(\\"Hello, world!\\") == \\"world! Hello,\\"","solution":"def reverse_sentence(sentence): Reverses the order of words in a given sentence. words = sentence.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates a square matrix by 90 degrees clockwise in place. :param matrix: List[List[int]] - n x n matrix to be rotated :return: List[List[int]] - The rotated matrix >>> rotate_matrix_90_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ] >>> rotate_matrix_90_clockwise([ ... [1, 2], ... [3, 4] ... ]) == [ ... [3, 1], ... [4, 2] ... ] >>> rotate_matrix_90_clockwise([ ... [1] ... ]) == [ ... [1] ... ]","solution":"def rotate_matrix_90_clockwise(matrix): Rotates a square matrix by 90 degrees clockwise in place. :param matrix: List[List[int]] - n x n matrix to be rotated :return: List[List[int]] - The rotated matrix n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"from typing import List, Dict def group_strings_by_length(strings: List[str]) -> Dict[int, List[str]]: Returns a dictionary where the keys are the lengths of the strings and the values are lists of strings of that length. :param strings: list of strings :return: dictionary with string lengths as keys and lists of strings as values >>> group_strings_by_length(['apple', 'dog', 'banana', 'cat']) {5: ['apple'], 3: ['dog', 'cat'], 6: ['banana']} >>> group_strings_by_length(['hi', 'be', 'to', 'by']) {2: ['hi', 'be', 'to', 'by']} >>> group_strings_by_length([]) {} >>> group_strings_by_length(['a', 'ab', 'abc', 'abcd', 'abcde']) {1: ['a'], 2: ['ab'], 3: ['abc'], 4: ['abcd'], 5: ['abcde']} >>> group_strings_by_length(['apple', 'dog', 'dog', 'apple']) {3: ['dog', 'dog'], 5: ['apple', 'apple']}","solution":"def group_strings_by_length(strings): Returns a dictionary where the keys are the lengths of the strings and the values are lists of strings of that length. :param strings: list of strings :return: dictionary with string lengths as keys and lists of strings as values length_dict = {} for string in strings: length = int(len(string)) if length not in length_dict: length_dict[length] = [] length_dict[length].append(string) return length_dict"},{"question":"def rank_elements(lst: List[int]) -> List[int]: Create a function that receives a list of integers and returns a new list where each integer is replaced by the rank of its value within the original list. Duplicate values receive the same rank. Args: lst (list of int): The input list of integers. Returns: list of int: The list of ranks corresponding to the elements in the original list. Examples: >>> rank_elements([3]) [1] >>> rank_elements([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> rank_elements([5, 4, 3, 2, 1]) [5, 4, 3, 2, 1] >>> rank_elements([3, 1, 2, 3, 2, 1]) [3, 1, 2, 3, 2, 1] >>> rank_elements([40, 10, 30, 20, 10, 40]) [4, 1, 3, 2, 1, 4] >>> rank_elements([]) []","solution":"def rank_elements(lst): Returns a list where each element in the original list is replaced by its rank. The rank is determined by sorting the original list. Duplicate values receive the same rank. Args: lst (list of int): The input list of integers. Returns: list of int: The list of ranks corresponding to the elements in the original list. if not lst: return [] sorted_unique_values = sorted(set(lst)) rank_dict = {val: rank+1 for rank, val in enumerate(sorted_unique_values)} return [rank_dict[val] for val in lst]"},{"question":"def longest_subarray_with_sum(nums, target): Develop a function that accepts an array of integers and returns the longest contiguous subarray whose sum is equal to a given target. If there is no such subarray, an empty array should be returned. >>> longest_subarray_with_sum([1, -1, 5, -2, 3], 3) [1, -1, 5, -2] >>> longest_subarray_with_sum([-2, -1, 2, 1], 1) [-1, 2] >>> longest_subarray_with_sum([1, 2, 3], 0) [] from solution import longest_subarray_with_sum def test_example_cases(): assert longest_subarray_with_sum([1, -1, 5, -2, 3], 3) == [1, -1, 5, -2] assert longest_subarray_with_sum([-2, -1, 2, 1], 1) == [-1, 2] assert longest_subarray_with_sum([1, 2, 3], 0) == [] def test_no_valid_subarray(): assert longest_subarray_with_sum([1, 2, 3], 10) == [] assert longest_subarray_with_sum([0, 0, 0], 1) == [] def test_negative_numbers(): assert longest_subarray_with_sum([-1, -2, -3, 4, -1, 2, 1, -5, 4], 6) == [4, -1, 2, 1] assert longest_subarray_with_sum([-1, -1, -1, 2], 1) == [-1, 2] def test_multiple_possible_subarrays(): assert longest_subarray_with_sum([1, 2, 3, 4, 5], 9) == [2, 3, 4] assert longest_subarray_with_sum([1, 2, 1, 2, 1, 2, 1], 5) == [2, 1, 2] def test_single_element(): assert longest_subarray_with_sum([1], 1) == [1] assert longest_subarray_with_sum([1], 2) == [] def test_empty_array(): assert longest_subarray_with_sum([], 0) == [] assert longest_subarray_with_sum([], 10) == []","solution":"def longest_subarray_with_sum(nums, target): Returns the longest contiguous subarray whose sum is equal to the target. If there is no such subarray, returns an empty array. sum_map = {0: -1} current_sum = 0 max_length = 0 subarray_start = -1 for index, num in enumerate(nums): current_sum += num if current_sum - target in sum_map: if index - sum_map[current_sum - target] > max_length: max_length = index - sum_map[current_sum - target] subarray_start = sum_map[current_sum - target] + 1 if current_sum not in sum_map: sum_map[current_sum] = index if max_length == 0: return [] return nums[subarray_start:subarray_start + max_length]"},{"question":"def make_change(coins: List[int], amount: int) -> int: Calculate the minimum number of coins needed to make a given amount of money. Args: coins: A list of coin denominations. amount: The total amount of money to make change for. Returns: An integer representing the minimum number of coins required to make the given amount. If it is not possible to make the given amount with the available coin denominations, return -1. Examples: >>> make_change([1, 2, 5], 11) 3 >>> make_change([2], 3) -1 >>> make_change([1], 0) 0 from solution import make_change def test_example1(): assert make_change([1, 2, 5], 11) == 3 def test_example2(): assert make_change([2], 3) == -1 def test_example3(): assert make_change([1], 0) == 0 def test_single_coin(): assert make_change([3], 9) == 3 assert make_change([3], 10) == -1 def test_multiple_coins(): assert make_change([1, 2, 5], 7) == 2 assert make_change([2, 4], 8) == 2 def test_large_amount(): assert make_change([1, 2, 5], 100) == 20 def test_no_coins(): assert make_change([], 10) == -1 def test_impossible_amount(): assert make_change([4, 5], 7) == -1","solution":"def make_change(coins, amount): Given a list of coin denominations and a target amount, returns the minimum number of coins required to make the amount. If it is not possible to make the amount, returns -1. # Dynamic programming list to store the minimum coins needed for each value from 0 to amount dp = [float('inf')] * (amount + 1) dp[0] = 0 # Iterate through each coin and update the dp list for coin in coins: for x in range(coin, amount + 1): if dp[x - coin] != float('inf'): # If we can make the amount (x - coin) dp[x] = min(dp[x], dp[x - coin] + 1) # Return -1 if dp[amount] is still infinity, meaning we couldn't make the amount return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def is_prime(n: int) -> bool: Check if a given number n is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(18) False >>> is_prime(19) True def list_primes_in_range(start: int, end: int) -> List[int]: Lists all prime numbers in the given range [start, end]. >>> list_primes_in_range(10, 50) [11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] >>> list_primes_in_range(10, 20) [11, 13, 17, 19] >>> list_primes_in_range(30, 40) [31, 37] >>> list_primes_in_range(50, 60) [53, 59] >>> list_primes_in_range(1, 10) [2, 3, 5, 7]","solution":"def is_prime(n): Check if a given number n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def list_primes_in_range(start, end): Lists all prime numbers in the given range [start, end]. return [num for num in range(start, end + 1) if is_prime(num)]"},{"question":"def remove_duplicates(lst: list) -> list: Removes duplicate numbers from the list while preserving the original order of elements. >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 3, 4, 5] >>> remove_duplicates([4, 5, 6, 4, 7, 8, 5]) == [4, 5, 6, 7, 8] from solution import remove_duplicates def test_remove_duplicates_with_some_duplicates(): assert remove_duplicates([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 3, 4, 5] def test_remove_duplicates_with_all_unique(): assert remove_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_remove_duplicates_with_all_duplicates(): assert remove_duplicates([1, 1, 1, 1, 1]) == [1] def test_remove_duplicates_with_empty_list(): assert remove_duplicates([]) == [] def test_remove_duplicates_with_negative_and_positive_nums(): assert remove_duplicates([-1, 1, -1, 3, 2, 3, -2, 2]) == [-1, 1, 3, 2, -2] def test_remove_duplicates_with_large_list(): input_list = list(range(1000)) + list(range(1000)) assert remove_duplicates(input_list) == list(range(1000))","solution":"def remove_duplicates(lst: list) -> list: Removes duplicate numbers from the list while preserving the original order of elements. result = [] for num in lst: if num not in result: result.append(num) return result"},{"question":"import re def find_shortest_word_length(text: str) -> int: Returns the length of the shortest word in a given string of sentences. >>> find_shortest_word_length(\\"Hello world\\") 5 >>> find_shortest_word_length(\\"Hello world. This is a test sentence\\") 1 >>> find_shortest_word_length(\\"Hello, world! This is a test sentence, with punctuation.\\") 1 >>> find_shortest_word_length(\\"A quick brown fox jumps over the lazy dog.\\") 1 >>> find_shortest_word_length(\\"HELLO world. This Is A test Sentence\\") 1 >>> find_shortest_word_length(\\"....!!!\\") 0 >>> find_shortest_word_length(\\"\\") 0","solution":"import re def find_shortest_word_length(text): Returns the length of the shortest word in the given text. # Using regex to split by any non-word character words = re.findall(r'bw+b', text) if not words: return 0 shortest_length = min(len(word) for word in words) return shortest_length"},{"question":"def find_common_elements(nums1: List[int], nums2: List[int]) -> List[int]: Returns a sorted list of unique integers found in both nums1 and nums2. >>> find_common_elements([1, 2, 2, 1], [2, 2]) [2] >>> find_common_elements([4, 9, 5], [9, 4, 9, 8, 4]) [4, 9]","solution":"def find_common_elements(nums1, nums2): Returns a sorted list of unique integers found in both nums1 and nums2. Parameters: nums1 : List[int] A list of integers. nums2 : List[int] Another list of integers. Returns: List[int] Sorted list of unique integers found in both nums1 and nums2. # Convert both lists to sets to remove duplicates and find common elements set1 = set(nums1) set2 = set(nums2) # Find common elements common_elements = set1.intersection(set2) # Convert the set of common elements to a sorted list return sorted(list(common_elements))"},{"question":"from typing import List, Dict def average_salary_by_department(employee_list: List[Dict[str, str]]) -> Dict[str, float]: Groups employees by their department and calculates the average salary for each department. Args: - employee_list (list of dict): List of dictionaries where each dictionary represents an employee with properties 'name', 'department', and 'salary'. Returns: - dict: A dictionary where the keys are the department names and the values are the average salaries. >>> employees = [ >>> {'name': 'Alice', 'department': 'Engineering', 'salary': 120000}, >>> {'name': 'Bob', 'department': 'HR', 'salary': 70000}, >>> {'name': 'Charlie', 'department': 'Engineering', 'salary': 110000}, >>> {'name': 'David', 'department': 'HR', 'salary': 75000}, >>> {'name': 'Eve', 'department': 'Sales', 'salary': 90000}, >>> ] >>> average_salary_by_department(employees) == { >>> 'Engineering': 115000.0, >>> 'HR': 72500.0, >>> 'Sales': 90000.0, >>> } # Your code here pass def print_sorted_department_salaries(department_salaries: Dict[str, float]) -> None: Prints out the department names in alphabetical order along with their corresponding average salaries. Args: - department_salaries (dict): A dictionary where the keys are department names and values are average salaries. >>> departments = {'Engineering': 115000.0, 'HR': 72500.0, 'Sales': 90000.0} >>> print_sorted_department_salaries(departments) Department: Engineering, Average Salary: 115000.00 Department: HR, Average Salary: 72500.00 Department: Sales, Average Salary: 90000.00 # Your code here pass","solution":"from collections import defaultdict def average_salary_by_department(employee_list): Groups employees by their department and calculates the average salary for each department. Args: - employee_list (list of dict): List of dictionaries where each dictionary represents an employee with properties 'name', 'department', and 'salary'. Returns: - dict: A dictionary where the keys are the department names and the values are the average salaries. if not isinstance(employee_list, list): raise ValueError(\\"Input should be a list of dictionaries representing employees.\\") department_salaries = defaultdict(list) for employee in employee_list: if not isinstance(employee, dict) or 'name' not in employee or 'department' not in employee or 'salary' not in employee: raise ValueError(\\"Each employee should be a dictionary with 'name', 'department', and 'salary' keys.\\") department = employee['department'] salary = employee['salary'] if not isinstance(salary, (int, float)): raise ValueError(\\"Salary should be a number.\\") department_salaries[department].append(salary) average_salaries = {} for department, salaries in department_salaries.items(): if salaries: average_salaries[department] = sum(salaries) / len(salaries) return average_salaries def print_sorted_department_salaries(department_salaries): Prints out the department names in alphabetical order along with their corresponding average salaries. Args: - department_salaries (dict): A dictionary where the keys are department names and values are average salaries. if not isinstance(department_salaries, dict): raise ValueError(\\"Input should be a dictionary with department names as keys and average salaries as values.\\") for department in sorted(department_salaries.keys()): print(f\\"Department: {department}, Average Salary: {department_salaries[department]:.2f}\\") # Sample usage employees = [ {'name': 'Alice', 'department': 'Engineering', 'salary': 120000}, {'name': 'Bob', 'department': 'HR', 'salary': 70000}, {'name': 'Charlie', 'department': 'Engineering', 'salary': 110000}, {'name': 'David', 'department': 'HR', 'salary': 75000}, {'name': 'Eve', 'department': 'Sales', 'salary': 90000}, ] average_salaries = average_salary_by_department(employees) print_sorted_department_salaries(average_salaries)"},{"question":"def find_median_sorted_arrays(arr1, arr2): Find the median of two sorted arrays. The overall run time complexity should be O(log(min(m,n))). :param arr1: List[int], first sorted array :param arr2: List[int], second sorted array :return: float, the median of the two sorted arrays >>> find_median_sorted_arrays([1, 3], [2]) 2.0 >>> find_median_sorted_arrays([1, 2], [3, 4]) 2.5 >>> find_median_sorted_arrays([1], [2]) 1.5 >>> find_median_sorted_arrays([], [1]) 1 >>> find_median_sorted_arrays([2], []) 2 >>> find_median_sorted_arrays([1, 3, 8], [7, 9, 10, 11]) 8.0 >>> find_median_sorted_arrays([1, 2, 3], [4, 5]) 3.0","solution":"def find_median_sorted_arrays(arr1, arr2): Find the median of two sorted arrays. The overall run time complexity should be O(log(min(m,n))). :param arr1: List[int], first sorted array :param arr2: List[int], second sorted array :return: float, the median of the two sorted arrays if len(arr1) > len(arr2): arr1, arr2 = arr2, arr1 x, y = len(arr1), len(arr2) low, high = 0, x while low <= high: partition_x = (low + high) // 2 partition_y = (x + y + 1) // 2 - partition_x max_left_x = float('-inf') if partition_x == 0 else arr1[partition_x - 1] min_right_x = float('inf') if partition_x == x else arr1[partition_x] max_left_y = float('-inf') if partition_y == 0 else arr2[partition_y - 1] min_right_y = float('inf') if partition_y == y else arr2[partition_y] if max_left_x <= min_right_y and max_left_y <= min_right_x: if (x + y) % 2 == 0: return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2 else: return max(max_left_x, max_left_y) elif max_left_x > min_right_y: high = partition_x - 1 else: low = partition_x + 1 raise ValueError(\\"Input arrays are not sorted.\\")"},{"question":"def even_squares(nums: List[int]) -> List[int]: Returns a new list containing only the even integers from the original list, but squared. Args: nums (list): A list of integers. Returns: list: A list of squared even integers. >>> even_squares([1, 2, 3, 4, 5]) [4, 16] >>> even_squares([2, 4, 6]) [4, 16, 36] >>> even_squares([]) [] >>> even_squares([-2, -3, -4]) [4, 16]","solution":"def even_squares(nums): Returns a new list containing only the even integers from the original list, but squared. Args: nums (list): A list of integers. Returns: list: A list of squared even integers. result = [] for num in nums: if num % 2 == 0: result.append(num * num) return result"},{"question":"def find_combinations(numbers: List[int], target: int) -> List[List[int]]: Returns all unique combinations of numbers that sum up to the target. Each number in numbers may only be used once in the combination. :param numbers: List[int] - list of positive integers :param target: int - target sum :return: List[List[int]] - sorted list of unique combinations >>> find_combinations([10, 1, 2, 7, 6, 1, 5], 8) [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]] >>> find_combinations([2, 3, 5], 8) [[3, 5]] >>> find_combinations([2, 3, 5], 1) [] >>> find_combinations([2, 3, 6, 7], 7) [[7]] >>> find_combinations([8], 8) [[8]] >>> find_combinations([2, 2, 2, 2], 4) [[2, 2]]","solution":"def find_combinations(numbers, target): Returns all unique combinations of numbers that sum up to the target. Each number in numbers may only be used once in the combination. :param numbers: List[int] - list of positive integers :param target: int - target sum :return: List[List[int]] - sorted list of unique combinations def backtrack(start, current_comb, current_sum): if current_sum == target: result.append(current_comb[:]) return if current_sum > target: return for i in range(start, len(numbers)): if i > start and numbers[i] == numbers[i - 1]: continue current_comb.append(numbers[i]) backtrack(i + 1, current_comb, current_sum + numbers[i]) current_comb.pop() numbers.sort() result = [] backtrack(0, [], 0) return result"},{"question":"def generate_primes(n: int) -> List[int]: Develop a function that takes an integer \`n\` and returns a list of the first \`n\` prime numbers, where \`n\` is a positive integer. Your solution should utilize an efficient algorithm for prime number detection to ensure that the list is generated in a reasonable amount of time even for larger values of \`n\`. >>> generate_primes(0) == [] >>> generate_primes(1) == [2] >>> generate_primes(2) == [2, 3] >>> generate_primes(10) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> generate_primes(-1) == [] >>> generate_primes(20) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]","solution":"def generate_primes(n): Returns a list of the first n prime numbers. if n <= 0: return [] primes = [] num = 2 while len(primes) < n: is_prime = True for p in primes: if p * p > num: break if num % p == 0: is_prime = False break if is_prime: primes.append(num) num += 1 return primes # Example usage print(generate_primes(10)) # Outputs: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]"},{"question":"def max_subarray_sum(arr): Finds the sum of the longest contiguous sub-array with the maximum sum in the given array of integers. >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([1, -3, 2, 1, -1]) == 3 # The sub-array is [2, 1] >>> max_subarray_sum([-1]) == -1 >>> max_subarray_sum([-2, -3, -1, -5]) == -1 # The sub-array is [-1] >>> max_subarray_sum([1, -2, 0, 3, -1, 2]) == 4 # The sub-array is [3, -1, 2] >>> max_subarray_sum([]) == 0 pass","solution":"def max_subarray_sum(arr): Finds the sum of the longest contiguous sub-array with the maximum sum in the given array of integers. Implements Kadane's Algorithm which runs in O(n) time complexity. if not arr: return 0 max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def is_prime(n: int) -> bool: Determines if the given number n is a prime number. >>> is_prime(17) True >>> is_prime(22) False","solution":"def is_prime(n): Determines if the given number n is a prime number. Args: n (int): The number to be checked. Returns: bool: True if n is prime, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"def flatten_nested_list(nested_list: list) -> list: Flattens a nested list of arbitrary depth into a single list of values. Each element in the input list can be either an integer or another nested list. The function should maintain the order of appearance of the elements. >>> flatten_nested_list([1, 2, [3, 4, [5, 6]], 7]) [1, 2, 3, 4, 5, 6, 7] >>> flatten_nested_list([[1, [2, 3]], 4, [[5, 6], 7], 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> flatten_nested_list([[[[1]]], 2, [[3, [4, 5]]], 6]) [1, 2, 3, 4, 5, 6]","solution":"def flatten_nested_list(nested_list: list) -> list: Flattens a nested list of arbitrary depth into a single list of values. Each element in the input list can be either an integer or another nested list. The function should maintain the order of appearance of the elements. def flatten(lst, accumulator): for elem in lst: if isinstance(elem, list): flatten(elem, accumulator) else: accumulator.append(elem) return accumulator return flatten(nested_list, [])"},{"question":"def count_unique_words(s: str) -> int: Returns the number of unique words in the given string s. Words are considered case-insensitive. >>> count_unique_words(\\"This is a test This test is\\") == 4 >>> count_unique_words(\\"one one ONE one\\") == 1 >>> count_unique_words(\\"apple banana Apple BANANA apple\\") == 2 >>> count_unique_words(\\" spaced words spaced \\") == 2 >>> count_unique_words(\\"\\") == 0 >>> count_unique_words(\\"Only_one_word\\") == 1","solution":"def count_unique_words(s): Returns the number of unique words in the given string s. Words are considered case-insensitive. words = s.lower().split() unique_words = set(words) return len(unique_words)"},{"question":"def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges overlapping intervals and returns a list of non-overlapping intervals sorted by their start time. >>> merge_intervals([(1, 3), (4, 6), (7, 9)]) == [(1, 3), (4, 6), (7, 9)] >>> merge_intervals([(1, 4), (2, 5), (7, 9)]) == [(1, 5), (7, 9)] >>> merge_intervals([(1, 5), (2, 3), (4, 6)]) == [(1, 6)] >>> merge_intervals([(1, 3), (3, 5)]) == [(1, 5)] >>> merge_intervals([]) == [] >>> merge_intervals([(4, 5)]) == [(4, 5)] >>> merge_intervals([(1, 3), (2, 6), (8, 10), (9, 12)]) == [(1, 6), (8, 12)]","solution":"def merge_intervals(intervals): Merges overlapping intervals and returns a list of non-overlapping intervals sorted by their start time. if not intervals: return [] # Sort the intervals based on start time intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: merged_intervals[-1] = (last_merged[0], max(last_merged[1], current[1])) else: merged_intervals.append(current) return merged_intervals"},{"question":"from typing import List, Dict def count_words_in_titles(titles: List[str]) -> Dict[str, int]: Counts how many times each distinct word appears across all book titles. Parameters: titles (list of str): List of book titles. Returns: dict: A dictionary where keys are the distinct words and values are their counts. >>> count_words_in_titles([\\"The Great Gatsby\\", \\"Great Expectations\\", \\"The Catcher in the Rye\\", \\"Catch-22\\"]) {\\"The\\": 2, \\"Great\\": 2, \\"Gatsby\\": 1, \\"Expectations\\": 1, \\"Catcher\\": 1, \\"in\\": 1, \\"the\\": 1, \\"Rye\\": 1, \\"Catch-22\\": 1}","solution":"import re from collections import defaultdict def count_words_in_titles(titles): Counts how many times each distinct word appears across all book titles. Parameters: titles (list of str): List of book titles. Returns: dict: A dictionary where keys are the distinct words and values are their counts. word_count = defaultdict(int) for title in titles: # Finding words considering alphanumeric characters and '-' as part of the word words = re.findall(r'b[w-]+b', title) for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"import re from typing import List def is_palindrome(s: str) -> bool: Determines if the given string s is a palindrome, ignoring case and non-alphanumeric characters. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"Madam, in Eden, I'm Adam\\") True >>> is_palindrome(\\"Not a palindrome\\") False","solution":"import re def is_palindrome(s): Determines if the given string s is a palindrome, ignoring case and non-alphanumeric characters. # Convert to lower case and remove non-alphanumeric characters cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if cleaned string is same forwards and backwards return cleaned == cleaned[::-1] # Example usage example_string = \\"A man, a plan, a canal, Panama\\" print(is_palindrome(example_string)) # Output: True"},{"question":"def sum_of_digits_of_largest_number(lst: List[int]) -> int: Write a Python function that takes a list of integers and returns the sum of the digits of the largest number in the list. If the list is empty, the function should return 0. >>> sum_of_digits_of_largest_number([]) 0 >>> sum_of_digits_of_largest_number([123]) 6 >>> sum_of_digits_of_largest_number([123, 456, 789]) 24 >>> sum_of_digits_of_largest_number([11, 22, 33]) 6 >>> sum_of_digits_of_largest_number([-1, -2, -3, 99, -100]) 18 >>> sum_of_digits_of_largest_number([50, 78, 12, 99, 23]) 18 >>> sum_of_digits_of_largest_number([999, 1000, 12345]) 15","solution":"def sum_of_digits_of_largest_number(lst): Returns the sum of the digits of the largest number in the list. If the list is empty, returns 0. if not lst: return 0 # Find the largest number in the list largest_number = max(lst) # Sum the digits of the largest number return sum(int(digit) for digit in str(largest_number))"},{"question":"def square_positive_integers(input_list): Takes a list of integers and returns a new list containing the squares of each positive integer from the input list. If the list contains any non-integer elements, raises a ValueError. >>> square_positive_integers([1, -2, 3, 0, 4]) [1, 9, 16] >>> square_positive_integers([2, 4, 6, 8]) [4, 16, 36, 64] >>> square_positive_integers([-1, -2, -3, 0]) [] >>> square_positive_integers([]) [] >>> square_positive_integers([1, 'a', 3, 4]) Traceback (most recent call last): ... ValueError: All elements of the input list must be integers.","solution":"def square_positive_integers(input_list): Takes a list of integers and returns a new list containing the squares of each positive integer from the input list. If the list contains any non-integer elements, raises a ValueError. if not all(isinstance(x, int) for x in input_list): raise ValueError(\\"All elements of the input list must be integers.\\") return [x**2 for x in input_list if x > 0]"},{"question":"def find_longest_substring(s: str) -> str: Returns the longest substring that contains at most two distinct characters. >>> find_longest_substring(\\"eceba\\") \\"ece\\" >>> find_longest_substring(\\"abbccc\\") \\"bbccc\\" >>> find_longest_substring(\\"aabbcc\\") \\"aabb\\" >>> find_longest_substring(\\"aaaa\\") \\"aaaa\\" >>> find_longest_substring(\\"\\") \\"\\" >>> find_longest_substring(\\"abcbbbbcccbdddadacb\\") \\"bcbbbbcccb\\" >>> find_longest_substring(\\"abcde\\") \\"ab\\" >>> find_longest_substring(\\"abcdefgr\\") \\"ab\\"","solution":"def find_longest_substring(s): Returns the longest substring that contains at most two distinct characters. n = len(s) if n <= 2: return s window_start = 0 max_length = 0 starting_index_of_max = 0 char_frequency = {} for window_end in range(n): right_char = s[window_end] if right_char not in char_frequency: char_frequency[right_char] = 0 char_frequency[right_char] += 1 while len(char_frequency) > 2: left_char = s[window_start] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: del char_frequency[left_char] window_start += 1 current_length = window_end - window_start + 1 if current_length > max_length: max_length = current_length starting_index_of_max = window_start return s[starting_index_of_max:starting_index_of_max + max_length]"},{"question":"def filter_divisible_by_three(numbers): Returns a new list containing only the elements that are divisible by 3. Tracks and prints the number of elements processed. >>> filter_divisible_by_three([1, 3, 4, 6, 7, 9]) [3, 6, 9] >>> filter_divisible_by_three([1, 2, 4, 5, 7]) [] >>> filter_divisible_by_three([3, 6, 9, 12, 15]) [3, 6, 9, 12, 15] >>> filter_divisible_by_three([-3, -6, -7, -9, 0]) [-3, -6, -9, 0] >>> filter_divisible_by_three([]) [] result = [] count = 0 for number in numbers: count += 1 if number % 3 == 0: result.append(number) print(f\\"Number of elements processed: {count}\\") return result","solution":"def filter_divisible_by_three(numbers): Returns a new list containing only the elements that are divisible by 3. Tracks and prints the number of elements processed. result = [] count = 0 for number in numbers: count += 1 if number % 3 == 0: result.append(number) print(f\\"Number of elements processed: {count}\\") return result"},{"question":"def longest_subarray_with_sum(nums, target): Return the longest contiguous subarray that sums to the given target. If multiple subarrays have the same length, return the first one found. If no such subarray exists, return an empty list. >>> longest_subarray_with_sum([1, 2, 3], 7) [] >>> longest_subarray_with_sum([5], 5) [5] >>> longest_subarray_with_sum([3, 4, 1, 2, 5, 1], 8) [3, 4, 1] >>> longest_subarray_with_sum([5, 1, 2, 3, 4, 5, 1], 9) [2, 3, 4] >>> longest_subarray_with_sum([1, 2, 3, 4], 7) [3, 4] >>> longest_subarray_with_sum([1, 2, 3, 4, 2, 3], 5) [2, 3] >>> longest_subarray_with_sum([1, 2, 1, 2, 1, 2, 1], 4) [1, 2, 1] >>> longest_subarray_with_sum([1, 2, 3, 4, 5], 15) [1, 2, 3, 4, 5] >>> longest_subarray_with_sum([], 5) [] >>> longest_subarray_with_sum([1, -1, 2, -2, 3, 0, 4], 0) [1, -1, 2, -2]","solution":"def longest_subarray_with_sum(nums, target): Return the longest contiguous subarray that sums to the given target. If multiple subarrays have the same length, return the first one found. If no such subarray exists, return an empty list. n = len(nums) longest_subarray = [] subarray_indices = {} current_sum = 0 for i in range(n): current_sum += nums[i] if current_sum == target: longest_subarray = nums[:i + 1] if (current_sum - target) in subarray_indices: start_index = subarray_indices[current_sum - target] + 1 if len(nums[start_index:i + 1]) > len(longest_subarray): longest_subarray = nums[start_index:i + 1] if current_sum not in subarray_indices: subarray_indices[current_sum] = i return longest_subarray"},{"question":"def first_non_repeating_char(s: str) -> str: Returns the first non-repeating character in the string s. If all characters are repeating or the input is empty, returns None. >>> first_non_repeating_char('swiss') 'w' >>> first_non_repeating_char('aabbcc') is None >>> first_non_repeating_char('') is None >>> first_non_repeating_char('a') 'a' >>> first_non_repeating_char('aabbccd') 'd' >>> first_non_repeating_char('aabbccddeeffg') 'g'","solution":"def first_non_repeating_char(s): Returns the first non-repeating character in the string s. If all characters are repeating or the input is empty, returns None. char_frequency = {} # Count the frequency of each character in the string for char in s: if char in char_frequency: char_frequency[char] += 1 else: char_frequency[char] = 1 # Find the first non-repeating character for char in s: if char_frequency[char] == 1: return char return None"},{"question":"def is_prime(n: int) -> bool: Determine whether a given number is a prime number. Parameters: n (int): The number to be checked for primality. Returns: bool: True if n is a prime number, False otherwise. Examples: >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True # Example test cases print(is_prime(2)) # True print(is_prime(4)) # False print(is_prime(17)) # True print(is_prime(18)) # False","solution":"def is_prime(n: int) -> bool: Returns True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"def fibonacci(n: int) -> int: Compute the nth Fibonacci number using dynamic programming. >>> fibonacci(0) == 0 >>> fibonacci(1) == 1 >>> fibonacci(2) == 1 >>> fibonacci(3) == 2 >>> fibonacci(4) == 3 >>> fibonacci(5) == 5 >>> fibonacci(10) == 55 >>> fibonacci(15) == 610 >>> fibonacci(30) == 832040","solution":"def fibonacci(n): Returns the nth Fibonacci number using dynamic programming. if n == 0: return 0 if n == 1: return 1 fib = [0] * (n + 1) fib[1] = 1 for i in range(2, n + 1): fib[i] = fib[i - 1] + fib[i - 2] return fib[n]"},{"question":"from typing import List def primes_less_than(input_list: List[int]) -> List[List[int]]: Given a list of integers, return a list of lists where each sub-list contains the prime numbers less than the corresponding input value. >>> primes_less_than([10]) == [[2, 3, 5, 7]] >>> primes_less_than([20]) == [[2, 3, 5, 7, 11, 13, 17, 19]] >>> primes_less_than([10, 20]) == [[2, 3, 5, 7], [2, 3, 5, 7, 11, 13, 17, 19]] >>> primes_less_than([1, 2, 3, 15]) == [[], [], [2], [2, 3, 5, 7, 11, 13]] # Internal helper function to generate primes using Sieve of Eratosthenes def sieve_of_eratosthenes(n: int) -> List[int]: sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not primes for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n, start): sieve[multiple] = False return [num for num, is_prime in enumerate(sieve) if is_prime] # Main function logic here, without providing the complete solution","solution":"def sieve_of_eratosthenes(n): Generate all prime numbers less than n using the Sieve of Eratosthenes algorithm. sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not primes for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n, start): sieve[multiple] = False return [num for num, is_prime in enumerate(sieve) if is_prime] def primes_less_than(input_list): Given a list of integers, return a list of lists where each sub-list contains the prime numbers less than the corresponding input value. max_n = max(input_list) primes = sieve_of_eratosthenes(max_n) results = [] for n in input_list: primes_below_n = [p for p in primes if p < n] results.append(primes_below_n) return results"},{"question":"def factorial(n: int) -> int: Returns the factorial of a given non-negative integer n. The factorial of a number n is defined as the product of all positive integers less than or equal to n (i.e., n! = n * (n-1) * ... * 1). Args: n (int): A non-negative integer whose factorial is to be calculated. Returns: int: The factorial of the input integer. Examples: >>> factorial(5) 120 >>> factorial(0) 1","solution":"def factorial(n): Returns the factorial of a non-negative integer n. if n == 0: return 1 result = 1 for i in range(2, n + 1): result *= i return result"},{"question":"def find_top_three_scores(scores: List[int]) -> List[int]: Returns the top three unique highest scores in descending order. If there are fewer than three unique scores, returns all of them in descending order. Args: scores (List[int]): A list of integers representing the scores. Returns: List[int]: A list of the top three unique highest scores in descending order. Examples: >>> find_top_three_scores([70, 85, 85, 90, 92, 60, 76, 92]) [92, 90, 85] >>> find_top_three_scores([]) [] >>> find_top_three_scores([10, 10, 10]) [10] >>> find_top_three_scores([-5, -1, -3, -7, -9, 0]) [0, -1, -3] >>> find_top_three_scores([10, -10, 0, 5]) [10, 5, 0] >>> find_top_three_scores([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) [4, 3, 2] Raises: ValueError: If the input is not a list of integers.","solution":"def find_top_three_scores(scores): Returns the top three unique highest scores in descending order. If there are fewer than three unique scores, returns all of them in descending order. if not isinstance(scores, list) or not all(isinstance(i, int) for i in scores): raise ValueError(\\"Input must be a list of integers\\") # Remove duplicates and sort in descending order unique_scores = sorted(set(scores), reverse=True) # Return top three or fewer scores return unique_scores[:3]"},{"question":"def flatten(nested_list): Flattens a nested list by extracting all elements into a single list. Args: nested_list (list): A list that may contain other nested lists. Returns: list: A flattened list with all elements from the nested structure. Examples: >>> flatten([1, 2, [3, 4, [5, 6]], 7, [8, 9]]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> flatten([1, [2, [3, 4], 5], 6, [7, 8, [9]]]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> flatten([1, [2], 3]) [1, 2, 3] >>> flatten([]) [] >>> flatten([[[[[1]]]], 2]) [1, 2]","solution":"def flatten(nested_list): Flattens a nested list, extracting all elements into a single list. Args: nested_list (list): A list that may contain other nested lists. Returns: list: A flattened list with all elements from the nested structure. result = [] def _flatten(lst): for item in lst: if isinstance(item, list): _flatten(item) else: result.append(item) _flatten(nested_list) return result"},{"question":"def find_pairs_with_sum(arr, target_sum): Finds all unique pairs of integers in the array that add up to the given sum. Args: - arr: List of integers. - target_sum: Target sum to find pairs for. Returns: - List of tuples with pairs that sum up to the target sum. Examples: >>> find_pairs_with_sum([1, 2, 3, 4, 5, 6], 7) [(1, 6), (2, 5), (3, 4)] >>> find_pairs_with_sum([1, 2, 3], 10) [] >>> find_pairs_with_sum([1, 1, 2, 3, 4, 4, 5, 6], 7) [(1, 6), (2, 5), (3, 4)] >>> find_pairs_with_sum([4, 8, -2, 0, 5, 5, 7, 3, -3], 5) [(-3, 8), (-2, 7), (0, 5)] >>> find_pairs_with_sum([-1, -2, -3, -4, -5, -6], -7) [(-6, -1), (-5, -2), (-4, -3)] >>> find_pairs_with_sum([], 5) [] >>> find_pairs_with_sum([4], 4) []","solution":"def find_pairs_with_sum(arr, target_sum): Finds all unique pairs of integers in the array that add up to the given sum. Args: - arr: List of integers. - target_sum: Target sum to find pairs for. Returns: - List of tuples with pairs that sum up to the target sum. pairs = set() seen = set() for number in arr: needed = target_sum - number if needed in seen: pairs.add(tuple(sorted((number, needed)))) seen.add(number) return list(pairs)"},{"question":"from sklearn import datasets from sklearn.cluster import KMeans from sklearn.metrics import adjusted_rand_score import matplotlib.pyplot as plt import numpy as np def kmeans_clustering_iris(): Using the Iris dataset available from sklearn, implement a k-means clustering algorithm to categorize the data into three distinct clusters. Once the clustering is completed, provide a detailed analysis by evaluating the accuracy of the clustering using external metrics such as the Adjusted Rand Index (ARI) and visualize the clusters along with the actual species to compare the results. Ensure your explanation connects the characteristics of the dataset with the performance of the clustering algorithm. >>> ari, y_pred = kmeans_clustering_iris() >>> ari > 0.5 True >>> y_pred.shape == (150,) True >>> len(np.unique(y_pred)) == 3 True","solution":"from sklearn import datasets from sklearn.cluster import KMeans from sklearn.metrics import adjusted_rand_score import matplotlib.pyplot as plt import numpy as np def kmeans_clustering_iris(): # Load the Iris dataset iris = datasets.load_iris() X = iris.data y_true = iris.target # Apply k-means clustering with 3 clusters kmeans = KMeans(n_clusters=3, random_state=0) y_pred = kmeans.fit_predict(X) # Evaluate the clustering using Adjusted Rand Index (ARI) ari = adjusted_rand_score(y_true, y_pred) # Plot the clusters plt.figure(figsize=(12, 6)) plt.subplot(1, 2, 1) plt.scatter(X[:, 0], X[:, 1], c=y_true, cmap='viridis', edgecolor='k', s=50) plt.title(\\"Actual Species\\") plt.xlabel(iris.feature_names[0]) plt.ylabel(iris.feature_names[1]) plt.subplot(1, 2, 2) plt.scatter(X[:, 0], X[:, 1], c=y_pred, cmap='viridis', edgecolor='k', s=50) plt.title(\\"K-means Clustering\\") plt.xlabel(iris.feature_names[0]) plt.ylabel(iris.feature_names[1]) plt.show() print(f'Adjusted Rand Index (ARI): {ari:.3f}') return ari, y_pred"},{"question":"def aggregate_tuples(tuple_list): Aggregates a list of tuples into a dictionary by summing the integers for each string key. Parameters: tuple_list (list of tuples): Each tuple contains a string and an integer. Returns: dict: A dictionary where the keys are the strings from the tuples, and the values are the sums of the integers associated with each string. Example: >>> aggregate_tuples([(\\"apple\\", 2), (\\"banana\\", 3), (\\"apple\\", 4), (\\"orange\\", 1)]) {'apple': 6, 'banana': 3, 'orange': 1} >>> aggregate_tuples([(\\"apple\\", 2)]) {'apple': 2} >>> aggregate_tuples([]) {} >>> aggregate_tuples([(\\"apple\\", 2), (\\"banana\\", 3), (\\"orange\\", 1)]) {'apple': 2, 'banana': 3, 'orange': 1} >>> aggregate_tuples([(\\"apple\\", 2), (\\"apple\\", 3), (\\"apple\\", 4)]) {'apple': 9} >>> aggregate_tuples([(\\"apple\\", 2), (\\"banana\\", 2), (\\"apple\\", -1), (\\"banana\\", 4)]) {'apple': 1, 'banana': 6}","solution":"def aggregate_tuples(tuple_list): Aggregates a list of tuples into a dictionary by summing the integers for each string key. Parameters: tuple_list (list of tuples): Each tuple contains a string and an integer. Returns: dict: A dictionary where the keys are the strings from the tuples, and the values are the sums of the integers associated with each string. result = {} for item in tuple_list: key, value = item if key in result: result[key] += value else: result[key] = value return result # Example usage: tuple_list = [(\\"apple\\", 2), (\\"banana\\", 3), (\\"apple\\", 4), (\\"orange\\", 1)] print(aggregate_tuples(tuple_list)) # Output: {'apple': 6, 'banana': 3, 'orange': 1}"},{"question":"def count_distinct_substrings(s: str, k: int) -> int: Counts the number of distinct substrings of length k in the given string s. >>> count_distinct_substrings(\\"abcabc\\", 3) 3 >>> count_distinct_substrings(\\"aaaaa\\", 2) 1","solution":"def count_distinct_substrings(s: str, k: int) -> int: Counts the number of distinct substrings of length k in the given string s. :param s: A string of lowercase alphabets :param k: An integer representing the length of the substrings :return: An integer representing the count of distinct substrings of length k if k > len(s): return 0 substrings = set() for i in range(len(s) - k + 1): substrings.add(s[i:i+k]) return len(substrings)"},{"question":"def findDuplicates(nums: List[int]) -> List[int]: Given a list of integers, returns a sorted list of integers that appear more than once. Each duplicated integer appears only once in the output list. >>> findDuplicates([4, 3, 2, 7, 8, 2, 3, 1]) #=> [2, 3] >>> findDuplicates([10, 5, 3, 8, 6]) #=> [] >>> findDuplicates([1, 1, 2, 2, 2, 3, 3]) #=> [1, 2, 3]","solution":"def findDuplicates(nums): Returns a sorted list of integers that appear more than once in the input list. Each duplicated integer appears only once in the output list. from collections import Counter # Count the occurrences of each integer in the list count = Counter(nums) # Extract the integers that appear more than once duplicates = [num for num, freq in count.items() if freq > 1] # Return the sorted list of duplicates return sorted(duplicates)"},{"question":"def longest_consecutive_sequence(arr: List[int]) -> List[int]: Returns the longest sequence of consecutive integers present in the array. >>> longest_consecutive_sequence([3, 9, 1, 10, 4, 20, 2]) == [1, 2, 3, 4] >>> longest_consecutive_sequence([0, -1, 1, 2, -2, -3, 3]) == [-3, -2, -1, 0, 1, 2, 3] >>> longest_consecutive_sequence([7, 6, 5, 8, 10, 9]) == [5, 6, 7, 8, 9, 10] >>> longest_consecutive_sequence([10]) == [10] >>> longest_consecutive_sequence([]) == [] >>> longest_consecutive_sequence([10, 30, 20]) == [10] >>> longest_consecutive_sequence([1, 2, 2, 3, 4]) == [1, 2, 3, 4]","solution":"def longest_consecutive_sequence(arr): Returns the longest sequence of consecutive integers present in the array. if not arr: return [] # Create a set of the array elements for O(1) look-up times. num_set = set(arr) longest_seq = [] for num in arr: # Check if it's the start of a sequence if num - 1 not in num_set: current_num = num current_seq = [] while current_num in num_set: current_seq.append(current_num) current_num += 1 if len(current_seq) > len(longest_seq): longest_seq = current_seq return longest_seq"},{"question":"def generate_pascals_triangle(num_rows): Generates Pascal's Triangle up to the given number of rows using recursion. >>> generate_pascals_triangle(0) == [] >>> generate_pascals_triangle(1) == [[1]] >>> generate_pascals_triangle(2) == [[1], [1, 1]] >>> generate_pascals_triangle(3) == [[1], [1, 1], [1, 2, 1]] >>> generate_pascals_triangle(4) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]] >>> generate_pascals_triangle(5) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] def formatted_pascals_triangle(num_rows): Generates and prints Pascal's Triangle in a formatted manner. >>> formatted_pascals_triangle(0) == \\"\\" >>> formatted_pascals_triangle(1) == \\"1\\" >>> formatted_pascals_triangle(2) == \\"1n1 1\\" >>> formatted_pascals_triangle(3) == \\"1n1 1n1 2 1\\" >>> formatted_pascals_triangle(4) == \\"1n1 1n1 2 1n1 3 3 1\\" >>> formatted_pascals_triangle(5) == \\"1n1 1n1 2 1n1 3 3 1n1 4 6 4 1\\"","solution":"def generate_pascals_triangle(num_rows): Generates Pascal's Triangle up to the given number of rows using recursion. if num_rows < 0: raise ValueError(\\"Number of rows must be a non-negative integer.\\") def generate_row(previous_row): row = [1] for i in range(1, len(previous_row)): row.append(previous_row[i-1] + previous_row[i]) row.append(1) return row def generate_triangle(n): if n == 0: return [] elif n == 1: return [[1]] else: previous_triangle = generate_triangle(n-1) previous_row = previous_triangle[-1] new_row = generate_row(previous_row) return previous_triangle + [new_row] return generate_triangle(num_rows) def formatted_pascals_triangle(num_rows): Generates and prints Pascal's Triangle in a formatted manner. if num_rows < 0: raise ValueError(\\"Number of rows must be a non-negative integer.\\") triangle = generate_pascals_triangle(num_rows) formatted_string = \\"n\\".join([\\" \\".join(map(str, row)) for row in triangle]) return formatted_string"},{"question":"def evaluate_expression(expression: str) -> float: Evaluate an infix mathematical expression. :param expression: A string containing a valid mathematical expression e.g., \\"3 + 5 * (2 - 8)\\". :return: The numerical result of the expression evaluation. >>> evaluate_expression(\\"3 + 2\\") == 5 >>> evaluate_expression(\\"5 - 2\\") == 3 >>> evaluate_expression(\\"3 * 2\\") == 6 >>> evaluate_expression(\\"6 / 2\\") == 3 >>> evaluate_expression(\\"3 + 2 * 2\\") == 7 >>> evaluate_expression(\\"(3 + 2) * 2\\") == 10 >>> evaluate_expression(\\"((2 + 3) * 2) - 4 / 2\\") == 8 >>> evaluate_expression(\\"4 / 0\\") Traceback (most recent call last): ... ValueError: Division by zero","solution":"def evaluate_expression(expression): def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_operator(operands, operator): right = operands.pop() left = operands.pop() if operator == '+': operands.append(left + right) elif operator == '-': operands.append(left - right) elif operator == '*': operands.append(left * right) elif operator == '/': if right == 0: raise ValueError(\\"Division by zero\\") operands.append(left / right) def compute(expr): operands = [] operators = [] i = 0 while i < len(expr): if expr[i].isspace(): i += 1 continue if expr[i].isdigit(): val = 0 while i < len(expr) and expr[i].isdigit(): val = val * 10 + int(expr[i]) i += 1 operands.append(val) i -= 1 elif expr[i] == '(': operators.append(expr[i]) elif expr[i] == ')': while operators and operators[-1] != '(': apply_operator(operands, operators.pop()) operators.pop() elif expr[i] in \\"+-*/\\": while (operators and precedence(operators[-1]) >= precedence(expr[i])): apply_operator(operands, operators.pop()) operators.append(expr[i]) i += 1 while operators: apply_operator(operands, operators.pop()) return operands[-1] return compute(expression)"},{"question":"from typing import List def sort_even_then_odd(numbers: List[int]) -> List[int]: Sort a list of integers such that all even numbers appear before all odd numbers, maintaining the relative order of even and odd numbers. >>> sort_even_then_odd([]) [] >>> sort_even_then_odd([1]) [1] >>> sort_even_then_odd([1, 2, 3, 4]) [2, 4, 1, 3] >>> sort_even_then_odd([4, 2, 1, 3]) [4, 2, 1, 3]","solution":"from typing import List def sort_even_then_odd(numbers: List[int]) -> List[int]: Sort a list of integers such that all even numbers appear before all odd numbers, maintaining the relative order of even and odd numbers. evens = [x for x in numbers if x % 2 == 0] odds = [x for x in numbers if x % 2 != 0] return evens + odds"},{"question":"def evaluate_expressions(expressions: List[str]) -> List[Union[float, str]]: Evaluates a list of mathematical expressions. Returns a list of results or 'Error' for invalid expressions and division by zero. >>> evaluate_expressions([\\"3 + 5\\", \\"10 - 3 * 2\\", \\"8 / 4 + 1\\", \\"7 + (3 * 2)\\"]) [8, 4, 3.0, 13] >>> evaluate_expressions([\\"6 / 0\\", \\"2 + 3 * x\\", \\"\\", \\"3 **\\"]) ['Error', 'Error', 'Error', 'Error'] >>> evaluate_expressions([\\"3 + 2 * 4\\", \\"4 / 0\\", \\"1 + (2 * 3)\\", \\"5 + 2 -\\"]) [11, 'Error', 7, 'Error'] >>> evaluate_expressions([\\"8 / 2\\", \\"6 / 3\\", \\"9 / 3\\", \\"0 / 1\\"]) [4.0, 2.0, 3.0, 0.0]","solution":"def evaluate_expressions(expressions): Evaluates a list of mathematical expressions. Returns a list of results or 'Error' for invalid expressions and division by zero. results = [] for expr in expressions: try: result = eval(expr) results.append(result) except ZeroDivisionError: results.append('Error') except (SyntaxError, NameError): results.append('Error') return results"},{"question":"def tribonacci(n, memo={}): Returns the nth number in the Tribonacci sequence. The Tribonacci sequence is defined as follows: T(0) = 0, T(1) = 1, T(2) = 1, and T(n) = T(n-1) + T(n-2) + T(n-3) for n > 2. Args: n (int): The index in the Tribonacci sequence to retrieve. Returns: int: The nth number in the Tribonacci sequence. pass # Unit Tests def test_tribonacci_base_cases(): assert tribonacci(0) == 0 assert tribonacci(1) == 1 assert tribonacci(2) == 1 def test_tribonacci_small_numbers(): assert tribonacci(3) == 2 assert tribonacci(4) == 4 def test_tribonacci_medium_numbers(): assert tribonacci(10) == 149 assert tribonacci(15) == 3136 def test_tribonacci_large_numbers(): assert tribonacci(25) == 1389537 assert tribonacci(35) == 615693474","solution":"def tribonacci(n, memo={}): Returns the nth number in the Tribonacci sequence. The Tribonacci sequence is defined as follows: T(0) = 0, T(1) = 1, T(2) = 1, and T(n) = T(n-1) + T(n-2) + T(n-3) for n > 2. Args: n (int): The index in the Tribonacci sequence to retrieve. Returns: int: The nth number in the Tribonacci sequence. # Base cases if n == 0: return 0 elif n == 1 or n == 2: return 1 # Check if result is already calculated if n in memo: return memo[n] # Recursively calculate the result while storing it in the memo dictionary memo[n] = tribonacci(n-1, memo) + tribonacci(n-2, memo) + tribonacci(n-3, memo) return memo[n] # Time complexity analysis: # The time complexity of this implementation is O(n) due to memoization. # Each value from 0 to n is computed only once and stored in the memo dictionary. # This minimizes redundant calculations, resulting in linear time complexity."},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression string and returns the result. Parameters: expression (str): The mathematical expression string to evaluate. Returns: float: The result of the evaluated expression. Raises: ValueError: If the provided expression is invalid. Examples: >>> evaluate_expression(\\"2 + 3\\") 5.0 >>> evaluate_expression(\\"4 * 5\\") 20.0 >>> evaluate_expression(\\"10 + (2 * 5) / (7 - 2) - 3\\") 9.0 >>> evaluate_expression(\\"\\") Traceback (most recent call last): ... ValueError: Invalid expression","solution":"def evaluate_expression(expression): Evaluates a mathematical expression string and returns the result. Parameters: expression (str): The mathematical expression string to evaluate. Returns: float: The result of the evaluated expression. Raises: ValueError: If the provided expression is invalid. try: # Use eval to evaluate the expression while ensuring security result = eval(expression, {\\"__builtins__\\": None}, {}) # Return the result as a float for consistency return float(result) except Exception as e: raise ValueError(\\"Invalid expression\\") from e"},{"question":"from typing import List def can_finish_courses(num_courses: int, prerequisites: List[List[int]]) -> bool: Determine if it is possible to finish all courses given the prerequisites. Args: num_courses (int): The total number of courses. prerequisites (List[List[int]]): A list of pairs where each pair represents a prerequisite relationship. Returns: bool: True if it is possible to finish all courses, False otherwise. Examples: >>> can_finish_courses(4, [[1, 0], [2, 1], [3, 2]]) True >>> can_finish_courses(2, [[1, 0], [0, 1]]) False def test_can_finish_courses_no_prerequisites(): assert can_finish_courses(3, []) == True def test_can_finish_courses_simple_case(): assert can_finish_courses(2, [[1, 0]]) == True def test_can_finish_courses_with_cycle(): assert can_finish_courses(2, [[1, 0], [0, 1]]) == False def test_can_finish_courses_complex_case(): assert can_finish_courses(4, [[1, 0], [2, 1], [3, 2]]) == True def test_can_finish_courses_large_case(): prerequisites = [[i, i - 1] for i in range(1, 1000)] # Chain 0 -> 1 -> 2 -> ... -> 999 assert can_finish_courses(1000, prerequisites) == True def test_can_finish_courses_with_disconnected_graph(): prerequisites = [[1, 0], [3, 2]] assert can_finish_courses(4, prerequisites) == True def test_can_finish_courses_with_self_dependency(): prerequisites = [[0, 0]] assert can_finish_courses(1, prerequisites) == False","solution":"from typing import List def can_finish_courses(num_courses: int, prerequisites: List[List[int]]) -> bool: from collections import defaultdict, deque # Create an adjacency list of the graph adj_list = defaultdict(list) indegree = [0] * num_courses for dest, src in prerequisites: adj_list[src].append(dest) indegree[dest] += 1 # Queue for the courses with no prerequisites zero_indegree_queue = deque([k for k in range(num_courses) if indegree[k] == 0]) # Number of visited courses visited_courses = 0 while zero_indegree_queue: course = zero_indegree_queue.popleft() visited_courses += 1 # Decrease the indegree of neighbor nodes (courses depending on current course) for neighbor in adj_list[course]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) # If we visited all courses, return True. Otherwise, there is a cycle return visited_courses == num_courses"},{"question":"def repeat_items(item_dict: dict) -> list: Takes a dictionary where keys are strings representing items and values are integers representing their quantities. Returns a list of strings with items repeated according to their quantities. >>> repeat_items({\\"apple\\": 2, \\"banana\\": 3, \\"cherry\\": 1}) [\\"apple\\", \\"apple\\", \\"banana\\", \\"banana\\", \\"banana\\", \\"cherry\\"] >>> repeat_items({}) [] >>> repeat_items({\\"orange\\": 4}) [\\"orange\\", \\"orange\\", \\"orange\\", \\"orange\\"] >>> repeat_items({\\"pear\\": 0, \\"grape\\": 2}) [\\"grape\\", \\"grape\\"] >>> repeat_items({\\"peach\\": 3, \\"plum\\": 1, \\"berry\\": 2}) [\\"peach\\", \\"peach\\", \\"peach\\", \\"plum\\", \\"berry\\", \\"berry\\"]","solution":"def repeat_items(item_dict): Takes a dictionary where keys are strings representing items and values are integers representing their quantities. Returns a list of strings with items repeated according to their quantities. result = [] for item, quantity in item_dict.items(): result.extend([item] * quantity) return result"},{"question":"def char_count(s: str) -> dict: Returns a dictionary where the keys are the characters in the string, and the values are the number of times each character appears. The function accounts for both uppercase and lowercase versions of a character as the same character. >>> char_count(\\"Programming\\") {'p': 1, 'r': 2, 'o': 1, 'g': 2, 'a': 1, 'm': 2, 'i': 1, 'n': 1} >>> char_count(\\"AaBbCc\\") {'a': 2, 'b': 2, 'c': 2} >>> char_count(\\"Hello, World!\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, ' ': 1, ',': 1, 'w': 1, 'r': 1, 'd': 1, '!': 1} >>> char_count(\\"\\") {} >>> char_count(\\"123445\\") {'1': 1, '2': 1, '3': 1, '4': 2, '5': 1}","solution":"def char_count(s): Returns a dictionary with the count of each character in the string, treating uppercase and lowercase characters as the same. s = s.lower() count_dict = {} for char in s: count_dict[char] = count_dict.get(char, 0) + 1 return count_dict"},{"question":"from typing import List def anagram_pairs(words: List[str]) -> int: Write a Python function called \`anagram_pairs\` that takes a list of strings and returns the number of pairs of strings that are anagrams of each other. An anagram is a word formed by rearranging the letters of another, such as \\"listen\\" and \\"silent\\". >>> anagram_pairs([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gogole\\"]) 4 >>> anagram_pairs([\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"]) 15 >>> anagram_pairs([\\"abcd\\", \\"efgh\\", \\"ijkl\\"]) 0 >>> anagram_pairs([\\"aa\\", \\"aa\\", \\"aa\\", \\"aa\\"]) 6 >>> anagram_pairs([\\"listen\\", \\"silent\\", \\"enlist\\", \\"abc\\", \\"ab\\", \\"ba\\", \\"a\\"]) 4","solution":"from typing import List from collections import defaultdict def anagram_pairs(words: List[str]) -> int: Returns the number of pairs of strings that are anagrams of each other. anagram_count = defaultdict(int) for word in words: sorted_word = ''.join(sorted(word)) anagram_count[sorted_word] += 1 pairs = 0 for count in anagram_count.values(): if count > 1: pairs += (count * (count - 1)) // 2 return pairs"},{"question":"def retrieve_order(order_id, orders): Retrieve an order's details by its ID from the list of orders. Args: - order_id (int): The ID of the order to retrieve. - orders (list of dict): List of orders, where each order is represented as a dictionary. Returns: - dict: The details of the order if the order_id is found, otherwise None. >>> orders = [{\\"id\\": 1, \\"user\\": \\"Alice\\", \\"products\\": [\\"Book\\"], \\"total_amount\\": 12.99}, {\\"id\\": 2, \\"user\\": \\"Bob\\", \\"products\\": [\\"Pen\\", \\"Notebook\\"], \\"total_amount\\": 5.49}] >>> retrieve_order(1, orders) {\\"id\\": 1, \\"user\\": \\"Alice\\", \\"products\\": [\\"Book\\"], \\"total_amount\\": 12.99} >>> retrieve_order(3, orders) None >>> retrieve_order(1, []) None >>> retrieve_order(\\"1\\", orders) None","solution":"def retrieve_order(order_id, orders): Retrieve an order's details by its ID from the list of orders. Args: - order_id (int): The ID of the order to retrieve. - orders (list of dict): List of orders, where each order is represented as a dictionary. Returns: - dict: The details of the order if the order_id is found, otherwise None. for order in orders: if order.get(\\"id\\") == order_id: return order return None"},{"question":"from typing import List, Tuple def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Find all pairs of integers in the list that sum up to the target integer. Each pair should be ordered in non-decreasing order, and the list of pairs should be sorted lexicographically. Args: nums: A list of unique integers. target: The target integer. Returns: A list of tuples, where each tuple contains a pair of integers that sum up to the target integer. Examples: >>> find_pairs([1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> find_pairs([1, 2, 3, 4, 5], 10) [] >>> find_pairs([-5, -4, -3, -2, -1, 0, 1, 2, 3], -5) [(-5, 0), (-4, -1), (-3, -2)] >>> find_pairs([-5, 0, 5, 10, -10, 15, -15, 20, -20], 0) [(-20, 20), (-15, 15), (-10, 10), (-5, 5)] >>> find_pairs([], 0) [] >>> find_pairs([1], 1) []","solution":"from typing import List, Tuple def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: This function finds all pairs of integers in the list that sum up to the target integer. Each pair is ordered in non-decreasing order, and the list of pairs is sorted lexicographically. pairs = [] nums.sort() left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: pairs.append((nums[left], nums[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return pairs"},{"question":"import string def sorted_words_length(s): Construct a sorted_words_length function that accepts a string representing a sentence and returns a list of tuples with words and their lengths sorted by length and lexicographically for words of equal length. Ignore punctuation, consider case insensitivity, and handle exceptions. Example: >>> sorted_words_length(\\"An apple a day keeps the Doctor away!\\") [('a', 1), ('an', 2), ('day', 3), ('the', 3), ('away', 4), ('apple', 5), ('keeps', 5), ('doctor', 6)]","solution":"import string def sorted_words_length(s): Construct a sorted_words_length function that accepts a string representing a sentence and returns a list of tuples with words and their lengths sorted by length and lexicographically for words of equal length. Ignore punctuation, consider case insensitivity, and handle exceptions. Example: >>> sorted_words_length(\\"An apple a day keeps the Doctor away!\\") [('a', 1), ('an', 2), ('day', 3), ('the', 3), ('away', 4), ('apple', 5), ('keeps', 5), ('doctor', 6)] if not isinstance(s, str): raise ValueError(\\"Input must be a string\\") # Remove punctuation and convert to lower case s = s.translate(str.maketrans('', '', string.punctuation)).lower() words = s.split() word_length_pairs = [(word, len(word)) for word in words] # Sort first by length, then lexicographically return sorted(word_length_pairs, key=lambda x: (x[1], x[0]))"},{"question":"def format_number_with_commas(number: int) -> str: Returns the string representation of the integer with commas as thousand separators. >>> format_number_with_commas(1000) '1,000' >>> format_number_with_commas(-1000) '-1,000' >>> format_number_with_commas(1000000) '1,000,000' >>> format_number_with_commas(-123456789) '-123,456,789'","solution":"def format_number_with_commas(number): Returns the string representation of the integer with commas as thousand separators. return \\"{:,}\\".format(number)"},{"question":"def is_prime(num: int) -> bool: Determines if a given number is a prime number. A prime number is a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(11) True >>> is_prime(97) True >>> is_prime(1) False >>> is_prime(0) False >>> is_prime(-7) False def sum_of_primes_less_than(N: int) -> int: Returns the sum of all prime numbers less than a given positive integer N. >>> sum_of_primes_less_than(10) 17 >>> sum_of_primes_less_than(20) 77 >>> sum_of_primes_less_than(2) 0 >>> sum_of_primes_less_than(1) 0 >>> sum_of_primes_less_than(50) 328 >>> sum_of_primes_less_than(100) 1060","solution":"def is_prime(num): if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def sum_of_primes_less_than(N): Returns the sum of all prime numbers less than a given positive integer N. return sum(num for num in range(2, N) if is_prime(num))"},{"question":"def is_palindrome(s: str) -> bool: Determines if a given string is a valid palindrome, considering only alphanumeric characters and ignoring cases. :param s: The input string to check :return: True if the string is a palindrome, False otherwise >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"0P\\") == False >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"1\\") == True >>> is_palindrome(\\"No lemon, no melon\\") == True >>> is_palindrome(\\"12321\\") == True >>> is_palindrome(\\"123456\\") == False >>> is_palindrome(\\"!!@@\\") == True","solution":"def is_palindrome(s): Determines if a given string is a valid palindrome, considering only alphanumeric characters and ignoring cases. :param s: The input string to check :return: True if the string is a palindrome, False otherwise # Filter alphanumeric characters and convert to lower case filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered list is a palindrome return filtered_chars == filtered_chars[::-1]"},{"question":"def sort_keys_by_values_desc(dictionary): Returns a list of keys sorted by their corresponding values in descending order. :param dictionary: Dictionary to be sorted. :return: List of keys sorted by their values in descending order. >>> sort_keys_by_values_desc({'a': 3, 'b': 1, 'c': 2}) ['a', 'c', 'b'] >>> sort_keys_by_values_desc({'a': 1}) ['a'] >>> sort_keys_by_values_desc({}) []","solution":"def sort_keys_by_values_desc(dictionary): Returns a list of keys sorted by their corresponding values in descending order. :param dictionary: Dictionary to be sorted. :return: List of keys sorted by their values in descending order. sorted_keys = sorted(dictionary, key=dictionary.get, reverse=True) return sorted_keys"},{"question":"def find_duplicates(nums): Returns a list of duplicated integers, ordered by their first occurrence. >>> find_duplicates([4, 5, 6, 4, 7, 5, 8, 9, 7]) [4, 5, 7] >>> find_duplicates([1, 2, 3, 4, 5]) [] >>> find_duplicates([1, 1, 2, 2, 3, 3]) [1, 2, 3] >>> find_duplicates([1, 2, 3, 1, 4, 5, 6, 2, 4, 7]) [1, 2, 4] >>> find_duplicates([]) [] >>> find_duplicates([1]) [] >>> find_duplicates(list(range(1000)) + list(range(500, 1500))) list(range(500, 1000))","solution":"def find_duplicates(nums): Returns a list of duplicated integers, ordered by their first occurrence. seen = set() duplicates = set() result = [] for num in nums: if num in seen: if num not in duplicates: duplicates.add(num) result.append(num) else: seen.add(num) return result"},{"question":"def are_permutations(str1: str, str2: str) -> bool: Determines if two strings are permutations of each other. >>> are_permutations(\\"abc\\", \\"bca\\") True >>> are_permutations(\\"abc\\", \\"abz\\") False >>> are_permutations(\\"abc\\", \\"abcd\\") False >>> are_permutations(\\"\\", \\"\\") True >>> are_permutations(\\"a\\", \\"\\") False","solution":"def are_permutations(str1, str2): Determines if two strings are permutations of each other. # If the lengths of the strings are different, they cannot be permutations if len(str1) != len(str2): return False # Sort the characters in both strings and compare return sorted(str1) == sorted(str2)"},{"question":"from functools import wraps from collections import defaultdict def cache_results(func): Decorator that caches the results of a function based on its input arguments. Advantages: - Improved performance for functions with expensive computations, as cached results can be returned for repeated inputs. - Reduced redundant calculations, leading to time and resource savings. Limitations: - Memory overhead due to storage of cached results, especially for functions with a large input space. - Cache invalidation strategies may be needed for dynamic scenarios where input-output mappings can change over time. - Not suitable for functions with side effects, as cached results ignore any side effects. >>> @cache_results ... def example_function(a, b=5): ... return a + b >>> example_function(2, 3) 5 >>> example_function(2, 3) 5 >>> example_function(2, b=7) 9 >>> example_function(3) 8 >>> example_function(2, b=6) 8 >>> example_function(a=2, b=6) 8 cache = defaultdict(dict) @wraps(func) def cached_function(*args, **kwargs): # Implementation here pass return cached_function @cache_results def example_function(a, b=5): return a + b","solution":"from functools import wraps from collections import defaultdict def cache_results(func): cache = defaultdict(dict) @wraps(func) def cached_function(*args, **kwargs): cache_key = args + tuple(sorted(kwargs.items())) if cache_key not in cache: cache[cache_key] = func(*args, **kwargs) return cache[cache_key] return cached_function # Example function to demonstrate the decorator @cache_results def example_function(a, b=5): return a + b"},{"question":"def find_longest_word(words: List[str]) -> str: Write a Python function that takes a list of strings and returns the longest word in the list. If two or more words have the same length, return the first one encountered. >>> find_longest_word([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) == \\"banana\\" >>> find_longest_word([\\"cat\\", \\"dog\\", \\"bat\\"]) == \\"cat\\" >>> find_longest_word([\\"cat\\", \\"dog\\", \\"elephant\\", \\"bee\\"]) == \\"elephant\\" >>> find_longest_word([]) == \\"\\" >>> find_longest_word([\\"single\\"]) == \\"single\\" >>> find_longest_word([\\"go\\", \\"to\\", \\"the\\", \\"longest\\"]) == \\"longest\\" >>> find_longest_word([\\"a\\", \\"bb\\", \\"ccc\\", \\"dddd\\", \\"eeee\\", \\"ffff\\"]) == \\"dddd\\" >>> find_longest_word([\\"1\\", \\"22\\", \\"333\\", \\"4444\\"]) == \\"4444\\"","solution":"def find_longest_word(words): Returns the longest word in the list. If two or more words have the same length, returns the first one encountered. if not words: return \\"\\" longest_word = words[0] for word in words: if len(word) > len(longest_word): longest_word = word return longest_word # Examples: # find_longest_word([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) -> \\"banana\\" # find_longest_word([\\"cat\\", \\"dog\\", \\"elephant\\", \\"bee\\"]) -> \\"elephant\\" # find_longest_word([\\"same\\", \\"size\\", \\"here\\", \\"word\\"]) -> \\"same\\" (first encountered with longest length)"},{"question":"from typing import List, Union, Tuple def find_two_sum(nums: List[int], target: int) -> Union[Tuple[int, int], str]: Finds two distinct elements in the given list of integers that add up to the target. Parameters: - nums: List of integers. - target: The target integer. Returns: - A tuple containing the indices of the two elements that add up to the target, if they exist. - A message stating \\"No two numbers add up to the target\\" if no such elements exist. Example: >>> find_two_sum([2, 7, 11, 15], 9) (0, 1) >>> find_two_sum([2, 7, 11, 15], 20) \\"No two numbers add up to the target\\" >>> find_two_sum([1, 3, 5, 8], 13) (2, 3) >>> find_two_sum([-3, 4, 3, 90], 0) (0, 2) >>> find_two_sum([3, 3, 4], 6) (0, 1) pass","solution":"def find_two_sum(nums, target): Finds two distinct elements in the given list of integers that add up to the target. Parameters: - nums: List of integers. - target: The target integer. Returns: - A tuple containing the indices of the two elements that add up to the target, if they exist. - A message stating \\"No two numbers add up to the target\\" if no such elements exist. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return \\"No two numbers add up to the target\\""},{"question":"def evaluate_operations(operations: List[str]) -> List[int]: Evaluates a list of algebraic operations (given as strings) and returns the results as a list of integers. >>> evaluate_operations([\\"2+2\\", \\"4-1\\", \\"6*3\\", \\"8/2\\"]) == [4, 3, 18, 4] >>> evaluate_operations([\\"-2+2\\", \\"4--1\\", \\"-6*3\\", \\"8/-2\\"]) == [0, 5, -18, -4] >>> evaluate_operations([\\"2+2*2\\", \\"4-1/1\\", \\"6*3+1\\", \\"8/2-3\\"]) == [6, 3, 19, 1] >>> evaluate_operations([\\"100+200\\", \\"1000-500\\", \\"12345*2\\", \\"100000/2\\"]) == [300, 500, 24690, 50000] >>> evaluate_operations([\\"10*10\\"]) == [100] >>> evaluate_operations([\\"50/5\\"]) == [10] >>> evaluate_operations([]) == []","solution":"def evaluate_operations(operations): Evaluates a list of algebraic operations (given as strings) and returns the results as a list of integers. results = [] for operation in operations: results.append(eval(operation.replace(\\"/\\", \\"//\\"))) return results"},{"question":"def longest_even_sublist_length(lst: List[int]) -> int: Returns the length of the longest contiguous sublist that contains only even numbers. If there are no even numbers in the list, the function returns 0. >>> longest_even_sublist_length([5, 10, 20, 6, 3, 12, 14, 7]) 3 >>> longest_even_sublist_length([1, 3, 5, 7, 9]) 0 >>> longest_even_sublist_length([2, 4, 6, 8, 10]) 5 >>> longest_even_sublist_length([1, 2, 4, 1, 2, 2, 1, 6, 8, 10]) 3 >>> longest_even_sublist_length([]) 0 >>> longest_even_sublist_length([2]) 1 >>> longest_even_sublist_length([1]) 0","solution":"def longest_even_sublist_length(lst): Returns the length of the longest contiguous sublist that contains only even numbers. If there are no even numbers in the list, the function returns 0. max_length = 0 current_length = 0 for num in lst: if num % 2 == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length # Example usage: # lst = [5, 10, 20, 6, 3, 12, 14, 7] # print(longest_even_sublist_length(lst)) # Output should be 3"},{"question":"def categorize_integers(int_list: List[int]) -> Dict[str, List[int]]: Takes a list of integers and returns a dictionary with three keys: 'positive', 'negative', and 'neutral' with respective lists of those integers. Raises a ValueError if the input is not a list of integers. >>> categorize_integers([1, -2, 3, -4, 0]) {'positive': [1, 3], 'negative': [-2, -4], 'neutral': [0]} >>> categorize_integers([1, 2, 3, 4, 5]) {'positive': [1, 2, 3, 4, 5], 'negative': [], 'neutral': []} >>> categorize_integers([-1, -2, -3, -4, -5]) {'positive': [], 'negative': [-1, -2, -3, -4, -5], 'neutral': []} >>> categorize_integers([0, 0, 0]) {'positive': [], 'negative': [], 'neutral': [0, 0, 0]} >>> categorize_integers([]) {'positive': [], 'negative': [], 'neutral': []} >>> categorize_integers(\\"Not a list\\") Traceback (most recent call last): ... ValueError: Input must be a list of integers >>> categorize_integers([1, 2, 'three', 4, 5]) Traceback (most recent call last): ... ValueError: Input must be a list of integers >>> categorize_integers([1, 2, 3.5, 4, 0]) Traceback (most recent call last): ... ValueError: Input must be a list of integers","solution":"def categorize_integers(int_list): Takes a list of integers and returns a dictionary with three keys: 'positive', 'negative', and 'neutral' with respective lists of those integers. Raises a ValueError if the input is not a list of integers. if not isinstance(int_list, list) or not all(isinstance(i, int) for i in int_list): raise ValueError(\\"Input must be a list of integers\\") result = {'positive': [], 'negative': [], 'neutral': []} for number in int_list: if number > 0: result['positive'].append(number) elif number < 0: result['negative'].append(number) else: result['neutral'].append(number) return result"},{"question":"def merge_sorted_arrays(arr1, arr2): Merges two sorted integer arrays into a single sorted array. Args: arr1 (list): The first sorted array. arr2 (list): The second sorted array. Returns: list: A merged sorted array. >>> merge_sorted_arrays([1, 3, 5, 7], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_arrays([], [2, 4, 6, 8]) [2, 4, 6, 8] >>> merge_sorted_arrays([1, 3, 5, 7], [1, 3, 5, 7]) [1, 1, 3, 3, 5, 5, 7, 7] >>> merge_sorted_arrays([1], [2]) [1, 2] >>> merge_sorted_arrays([2, 4, 6, 8], []) [2, 4, 6, 8]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted integer arrays into a single sorted array. Args: arr1 (list): The first sorted array. arr2 (list): The second sorted array. Returns: list: A merged sorted array. merged_array = [] i, j = 0, 0 # Use two pointers to go through both arrays and merge them while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Append any remaining elements from arr1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 # Append any remaining elements from arr2 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array # Example usage: arr1 = [1, 3, 5, 7] arr2 = [2, 4, 6, 8] merged_array = merge_sorted_arrays(arr1, arr2) print(merged_array) # Output: [1, 2, 3, 4, 5, 6, 7, 8]"},{"question":"def user_service(): Simulate the User Service. >>> user_service() 'User Service Running' pass def product_service(): Simulate the Product Service. >>> product_service() 'Product Service Running' pass def order_service(): Simulate the Order Service. >>> order_service() 'Order Service Running' pass","solution":"# The solution will focus on a simplified Python representation of how you might organize your microservices architecture # and the components involved. We will not implement the entire solution which includes setting up Node.js, Docker, and Kubernetes, # but we will outline how such a setup can be organized. # For simplicity, we will write the main logic of each service in Python, even though in a real-world scenario # you would write them in Node.js. This will help in demonstrating the core structure. # Please note that writing the actual Docker and Kubernetes files requires quite a bit of infrastructure setup, # which we will represent as descriptive placeholders. def user_service(): Simulate User Service return \\"User Service Running\\" def product_service(): Simulate Product Service return \\"Product Service Running\\" def order_service(): Simulate Order Service return \\"Order Service Running\\" if __name__ == \\"__main__\\": print(user_service()) print(product_service()) print(order_service()) # In a real-world scenario, each of these services would be separate projects with their own database connections, # RESTful API endpoints, Dockerfiles for containerization, and YAML files for Kubernetes deployment. # The overall architecture would use: # 1. Node.js for implementing each microservice. # 2. Docker to containerize each microservice. # 3. Kubernetes to orchestrate and manage the containers. # 4. Prometheus for monitoring and logging. # 5. An API Gateway (e.g., Kong, NGINX) for routing traffic and handling JWT-based authentication."},{"question":"def most_frequent_substrings_of_length_3(s: str) -> list: Determine the most frequent substring of length 3 in the given string. If there are multiple substrings with the same highest frequency, return them in alphabetical order as a list. >>> most_frequent_substrings_of_length_3(\\"ababcabc\\") [\\"abc\\"] >>> most_frequent_substrings_of_length_3(\\"ababab\\") [\\"aba\\", \\"bab\\"] >>> most_frequent_substrings_of_length_3(\\"abcdef\\") [\\"abc\\", \\"bcd\\", \\"cde\\", \\"def\\"] >>> most_frequent_substrings_of_length_3(\\"\\") [] >>> most_frequent_substrings_of_length_3(\\"ab\\") [] >>> most_frequent_substrings_of_length_3(\\"abcdeabc\\") [\\"abc\\"]","solution":"def most_frequent_substrings_of_length_3(s): Returns the most frequent substrings of length 3 in alphabetical order. :param s: Input string :type s: str :return: List of most frequent substrings of length 3 :rtype: list from collections import defaultdict if len(s) < 3: return [] count = defaultdict(int) for i in range(len(s) - 2): substring = s[i:i + 3] count[substring] += 1 max_freq = max(count.values()) most_frequent_substrings = [k for k, v in count.items() if v == max_freq] return sorted(most_frequent_substrings)"},{"question":"def find_paths(m: int, n: int) -> List[str]: Implement a function that finds all unique paths from the top-left corner to the bottom-right corner of an m x n grid. You can only move either down or right at any point in time. Args: m (int): number of rows. n (int): number of columns. Returns: List[str]: A list containing all unique paths represented as strings. >>> find_paths(2, 2) ['DR', 'RD'] >>> find_paths(1, 1) [''] >>> find_paths(2, 3) ['DRR', 'RDR', 'RRD'] >>> find_paths(3, 2) ['DDR', 'DRD', 'RDD'] >>> find_paths(3, 3) ['DDRR', 'DRDR', 'DRRD', 'RDDR', 'RDRD', 'RRDD']","solution":"def find_paths(m, n): def backtrack(i, j, path): if i == m - 1 and j == n - 1: paths.append(path) return if i < m - 1: backtrack(i + 1, j, path + 'D') if j < n - 1: backtrack(i, j + 1, path + 'R') paths = [] backtrack(0, 0, '') return paths"},{"question":"import json from typing import List, Tuple, Union def calculate_average_grade(data: str) -> Union[Tuple[str, float], Tuple[None, None]]: Calculate the average grades for students and identify the student with the highest average grade. Parameters: - data: JSON string representing a list of student records with names and grades Returns: - A tuple containing the name of the student with the highest average grade and the average grade itself. - If no valid student data is present, return (None, None). >>> data = json.dumps([{\\"name\\": \\"Alice\\", \\"grades\\": [85, 90, 92]}, {\\"name\\": \\"Bob\\", \\"grades\\": [78, 81, 85]}, {\\"name\\": \\"Charlie\\", \\"grades\\": [95, 96, 97]}]) >>> calculate_average_grade(data) (\\"Charlie\\", 96.0) >>> data = json.dumps([{\\"name\\": \\"Alice\\", \\"grades\\": []}, {\\"name\\": \\"Bob\\", \\"grades\\": [78, 81, 85]}]) >>> calculate_average_grade(data) (\\"Bob\\", 81.33333333333333) >>> data = json.dumps([{\\"name\\": \\"Alice\\"}, {\\"name\\": \\"Bob\\", \\"grades\\": [78, 81, 85]}]) >>> calculate_average_grade(data) (\\"Bob\\", 81.33333333333333) >>> data = \\"invalid json\\" >>> calculate_average_grade(data) Traceback (most recent call last): ... json.JSONDecodeError: ... >>> data = json.dumps([{\\"name\\": \\"Alice\\", \\"grades\\": [85, 90, \\"92\\"]}, {\\"name\\": \\"Bob\\", \\"grades\\": [78, 81, 85]}]) >>> calculate_average_grade(data) Traceback (most recent call last): ... TypeError: ... >>> data = json.dumps([]) >>> calculate_average_grade(data) (None, None)","solution":"import json def calculate_average_grade(data): Calculate the average grades for students and identify the student with the highest average grade. Parameters: - data: JSON, a list of student records with names and grades Returns: - A tuple containing the name of the student with the highest average grade and the average grade itself. students = json.loads(data) highest_avg_grade = None top_student = None for student in students: if 'grades' not in student: continue grades = student['grades'] if not grades: continue avg_grade = sum(grades) / len(grades) if highest_avg_grade is None or avg_grade > highest_avg_grade: highest_avg_grade = avg_grade top_student = student['name'] return (top_student, highest_avg_grade)"},{"question":"def find_missing_number(arr: List[int], n: int) -> int: Finds the missing number in the list of integers from 1 to n. >>> find_missing_number([2, 3, 4, 5], 5) 1 >>> find_missing_number([1, 2, 3, 4], 5) 5 >>> find_missing_number([1, 2, 4, 5], 5) 3 >>> find_missing_number(list(range(1, 100001)) + list(range(100002, 100002)), 100001) 100001 >>> find_missing_number([1, 3, 4, 5, 6, 7, 8, 9, 10], 10) 2","solution":"def find_missing_number(arr, n): Finds the missing number in the list of integers from 1 to n. :param arr: List[int] - list of unique integers where each integer is between 1 and n (inclusive) :param n: int - the size of the list should be n-1 :return: int - the missing integer # Calculate expected sum of first n natural numbers expected_sum = n * (n + 1) // 2 # Calculate actual sum of the array actual_sum = sum(arr) # Missing number is the difference between expected sum and actual sum return expected_sum - actual_sum"},{"question":"def reverse_and_double(lst: List[int]) -> List[int]: Reverses the order of elements in the list and then doubles each element. >>> reverse_and_double([1, 2, 3, 4]) [8, 6, 4, 2] >>> reverse_and_double([1, -2, 3, 0]) [0, 6, -4, 2] >>> reverse_and_double([5]) [10] >>> reverse_and_double([]) [] >>> reverse_and_double([-1, -2, -3, -4]) [-8, -6, -4, -2]","solution":"def reverse_and_double(lst): Reverses the order of elements in the list and then doubles each element. Parameters: lst (list of int): A list of integers. Returns: list of int: A new list with elements reversed and doubled. # Create an empty list to store the reversed and doubled elements reversed_doubled = [] # Loop through the list in reverse order and double each element for i in range(len(lst) - 1, -1, -1): reversed_doubled.append(lst[i] * 2) return reversed_doubled"},{"question":"def waiting_days_for_warmer_temp(temperatures: List[int]) -> List[int]: Returns a list of integers where each element represents the number of days until a warmer temperature. If there is no future day with a higher temperature, the value should be 0. >>> waiting_days_for_warmer_temp([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> waiting_days_for_warmer_temp([70, 70, 70, 70]) [0, 0, 0, 0] >>> waiting_days_for_warmer_temp([80, 75, 70, 65, 60]) [0, 0, 0, 0, 0] >>> waiting_days_for_warmer_temp([60, 65, 70, 75, 80]) [1, 1, 1, 1, 0] >>> waiting_days_for_warmer_temp([70]) [0] >>> waiting_days_for_warmer_temp([-10, -5, 0, 5, 0]) [1, 1, 1, 0, 0]","solution":"def waiting_days_for_warmer_temp(temperatures): Returns a list of integers where each element represents the number of days until a warmer temperature. If there is no future day with a higher temperature, the value should be 0. n = len(temperatures) result = [0] * n stack = [] # This will store indices of the temperatures list for current_day in range(n): while stack and temperatures[current_day] > temperatures[stack[-1]]: previous_day = stack.pop() result[previous_day] = current_day - previous_day stack.append(current_day) return result"},{"question":"def four_sum(nums, target): Find all unique quadruplets in the array that sum up to the target. :param nums: List[int] - List of integers :param target: int - The target sum :return: List[List[int]] - List of unique quadruplets that sum up to the target >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([1, 2, 3, 4], 100) [] >>> four_sum([1, 1, 1, 1, 1], 4) [[1, 1, 1, 1]] >>> four_sum([], 0) [] >>> four_sum([0], 0) [] >>> four_sum([1, -1], 0) []","solution":"def four_sum(nums, target): Find all unique quadruplets in the array that sum up to the target. :param nums: List[int] - List of integers :param target: int - The target sum :return: List[List[int]] - List of unique quadruplets that sum up to the target nums.sort() res, n = [], len(nums) for i in range(n): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, n): if j > i + 1 and nums[j] == nums[j - 1]: continue left, right = j + 1, n - 1 while left < right: s = nums[i] + nums[j] + nums[left] + nums[right] if s == target: res.append([nums[i], nums[j], nums[left], nums[right]]) left += 1 while left < right and nums[left] == nums[left - 1]: left += 1 elif s < target: left += 1 else: right -= 1 return res"},{"question":"def max_product_subarray(nums: List[int]) -> int: Given an array of integers, find the subarray (contiguous sequence) which has the largest product of its elements. >>> max_product_subarray([2, 3, -2, 4]) 6 >>> max_product_subarray([-2, 0, -1]) 0","solution":"from typing import List def max_product_subarray(nums: List[int]) -> int: if not nums: return 0 max_product = nums[0] current_max = nums[0] current_min = nums[0] for num in nums[1:]: if num < 0: current_max, current_min = current_min, current_max current_max = max(num, current_max * num) current_min = min(num, current_min * num) max_product = max(max_product, current_max) return max_product"},{"question":"from typing import List def generate_permutations(s: str) -> List[str]: Generates all possible permutations of the input string s. :param s: Input string :return: List of all permutations of the string >>> generate_permutations('ABC') ['ABC', 'ACB', 'BAC', 'BCA', 'CAB', 'CBA'] >>> generate_permutations('A') ['A'] >>> generate_permutations('') [''] >>> generate_permutations('AB') ['AB', 'BA'] >>> generate_permutations('AAB') ['AAB', 'ABA', 'BAA']","solution":"from itertools import permutations def generate_permutations(s): Generates all possible permutations of the input string s. :param s: Input string :return: List of all permutations of the string return [''.join(p) for p in permutations(s)]"},{"question":"def positive_even_numbers(lst): Returns a list of integers that are both positive and even. Args: lst (List[int]): A list of integers. Returns: List[int]: A list of integers that are both positive and even. Examples: >>> positive_even_numbers([-10, -7, 0, 2, 3, 8, 11, 14]) [2, 8, 14] >>> positive_even_numbers([2, 4, 8, 10, 12]) [2, 4, 8, 10, 12] >>> positive_even_numbers([1, 3, 5, 7, 9]) [] >>> positive_even_numbers([-2, -4, -6, -8, -10]) [] >>> positive_even_numbers([]) [] >>> positive_even_numbers([0, 0, 0]) [] >>> positive_even_numbers([-4, 3, 4, 6, -8, 10]) [4, 6, 10]","solution":"def positive_even_numbers(lst): Returns a list of integers that are both positive and even. return [num for num in lst if num > 0 and num % 2 == 0]"},{"question":"def find_pairs_with_difference(arr: List[int], k: int) -> int: Returns the number of unique k-pairs in the array where a - b = k. Parameters: arr (list): List of integers. k (int): The difference value. Returns: int: Number of unique k-pairs. >>> find_pairs_with_difference([1, 5, 3, 4, 2], 2) == 3 >>> find_pairs_with_difference([1, 5, 3, 4, 2], 1) == 4 >>> find_pairs_with_difference([1, 5, 3, 4, 2], -2) == 3 >>> find_pairs_with_difference([1, 3, 5, 7], 10) == 0 >>> find_pairs_with_difference([], 1) == 0 >>> find_pairs_with_difference([1], 1) == 0 >>> find_pairs_with_difference([1, 2, 2, 3], 1) == 2 >>> find_pairs_with_difference([1, 1, 1, 1], 0) == 1","solution":"def find_pairs_with_difference(arr, k): Returns the number of unique k-pairs in the array where a - b = k. Parameters: arr (list): List of integers. k (int): The difference value. Returns: int: Number of unique k-pairs. if len(arr) < 2: return 0 seen = set() pairs = set() for num in arr: if num + k in seen: pairs.add((num + k, num)) if num - k in seen: pairs.add((num, num - k)) seen.add(num) return len(pairs)"},{"question":"def find_pairs_with_sum(nums: list, k: int) -> list: Find all unique pairs of integers in the list that sum up to k. The pairs should be returned in a list of tuples, where each tuple contains two integers that sum up to k. The pairs should be presented in lexicographical order. >>> find_pairs_with_sum([1, 5, 3, 7, 9, 2, -1, 6], 8) [(-1, 9), (1, 7), (2, 6), (3, 5)] >>> find_pairs_with_sum([0, 1, 2, 3, 4, 5], 5) [(0, 5), (1, 4), (2, 3)] >>> find_pairs_with_sum([1, 2, 3, 4], 10) [] >>> find_pairs_with_sum([0, -1, -2, 2, 1], 0) [(-2, 2), (-1, 1)] >>> find_pairs_with_sum([1, 1, 2, 2, 3, 3], 4) [(1, 3), (2, 2)]","solution":"def find_pairs_with_sum(nums: list, k: int) -> list: seen = set() output = set() for num in nums: target = k - num if target in seen: pair = (min(num, target), max(num, target)) output.add(pair) seen.add(num) return sorted(output) # Example usage: nums = [1, 5, 3, 7, 9, 2, -1, 6] k = 8 print(find_pairs_with_sum(nums, k)) # Expected output: [(-1, 9), (1, 7), (2, 6), (3, 5)]"},{"question":"import pytest def rotate_string(s: str, k: int) -> str: Returns the string s rotated to the right by k positions. >>> rotate_string(\\"hello\\", 2) 'lohel' >>> rotate_string(\\"rotation\\", 4) 'tionrota' >>> rotate_string(\\"abc\\", 3) 'abc' >>> rotate_string(\\"\\", 5) '' >>> rotate_string(\\"abcdef\\", 12) 'abcdef' >>> rotate_string(\\"a\\", 3) 'a' >>> rotate_string(\\"example\\", 0) 'example' pass def test_rotate_string_general(): assert rotate_string(\\"hello\\", 2) == \\"lohel\\" assert rotate_string(\\"rotation\\", 4) == \\"tionrota\\" def test_rotate_string_full_rotation(): assert rotate_string(\\"abc\\", 3) == \\"abc\\" def test_rotate_string_empty(): assert rotate_string(\\"\\", 5) == \\"\\" def test_rotate_string_large_k(): assert rotate_string(\\"abcdef\\", 12) == \\"abcdef\\" def test_rotate_string_single_character(): assert rotate_string(\\"a\\", 3) == \\"a\\" def test_rotate_string_no_rotation(): assert rotate_string(\\"example\\", 0) == \\"example\\" if __name__ == \\"__main__\\": pytest.main()","solution":"def rotate_string(s: str, k: int) -> str: Returns the string s rotated to the right by k positions. Args: s (str): The input string to be rotated. k (int): The number of positions to rotate the string by. Returns: str: The rotated string. if not s: return s k = k % len(s) # Handle rotation count larger than string length return s[-k:] + s[:-k]"},{"question":"def rectangular_grid_path_count(m: int, n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n rectangular grid, moving only right or down. >>> rectangular_grid_path_count(2, 2) 2 >>> rectangular_grid_path_count(3, 3) 6 >>> rectangular_grid_path_count(1, 5) 1 >>> rectangular_grid_path_count(5, 1) 1 >>> rectangular_grid_path_count(5, 5) 70 >>> rectangular_grid_path_count(3, 7) 28 >>> rectangular_grid_path_count(1, 1) 1 >>> rectangular_grid_path_count(20, 20) 35345263800","solution":"def rectangular_grid_path_count(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n rectangular grid, moving only right or down. # Create a 2D list to store the number of paths to each cell dp = [[0]*n for _ in range(m)] # Initialize the first row and first column for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill in the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will contain the number of unique paths return dp[-1][-1]"},{"question":"from typing import List def has_pair_with_difference(nums: List[int], target: int) -> bool: Returns a Boolean indicating whether there exists a pair of integers in the list whose difference is equal to the target value. Handles both positive and negative differences. >>> has_pair_with_difference([1, 4, 5, 7], 2) True >>> has_pair_with_difference([2, 5, 8, 12], -3) True >>> has_pair_with_difference([1, 5, 3, 8], 10) False >>> has_pair_with_difference([], 2) False >>> has_pair_with_difference([5], 1) False >>> has_pair_with_difference(\\"invalid\\", 2) Traceback (most recent call last): ... ValueError: Input must be a list of integers. >>> has_pair_with_difference([1, 2, 3], 2.5) Traceback (most recent call last): ... ValueError: Target must be an integer. >>> has_pair_with_difference([1, 2, 3, 4, 1], 0) True >>> has_pair_with_difference([3, 1, 6, 2, 9, 5], 3) True","solution":"def has_pair_with_difference(nums, target): Returns a Boolean indicating whether there exists a pair of integers in the list whose difference is equal to the target value. Handles both positive and negative differences. if not isinstance(nums, list) or not all(isinstance(n, int) for n in nums): raise ValueError(\\"Input must be a list of integers.\\") if not isinstance(target, int): raise ValueError(\\"Target must be an integer.\\") num_set = set() for num in nums: if (num + target) in num_set or (num - target) in num_set: return True num_set.add(num) return False"},{"question":"import pandas as pd from sklearn.ensemble import IsolationForest from sklearn.preprocessing import StandardScaler from datetime import datetime def preprocess_data(df): Preprocess the transaction data by converting the 'timestamp' to datetime components and performing one-hot encoding on categorical features. pass def detect_anomalies(df): Detect anomalies in the transaction data using the IsolationForest algorithm. pass def update_model_with_new_data(df, new_data): Update the model with new transaction data and re-detect anomalies on the combined dataset. pass def test_preprocess_data(): data = { 'timestamp': ['2023-09-01 10:05:00', '2023-09-02 15:16:30'], 'amount': [100, 250], 'category': ['groceries', 'utilities'] } df = pd.DataFrame(data) processed_df = preprocess_data(df) assert 'timestamp' not in processed_df.columns assert 'day' in processed_df.columns assert 'month' in processed_df.columns assert 'hour' in processed_df.columns assert 'category_groceries' in processed_df.columns or 'category_utilities' in processed_df.columns def test_detect_anomalies(): data = { 'timestamp': ['2023-09-01 10:05:00', '2023-09-02 15:16:30', '2023-09-03 13:45:00'], 'amount': [100, 100000, 150], 'category': ['groceries', 'luxury', 'groceries'] } df = pd.DataFrame(data) result_df = detect_anomalies(df) assert 'anomaly' in result_df.columns assert set(result_df['anomaly']).issubset({-1, 1}) def test_update_model_with_new_data(): original_data = { 'timestamp': ['2023-09-01 10:05:00', '2023-09-02 15:16:30', '2023-09-03 13:45:00'], 'amount': [100, 250, 150], 'category': ['groceries', 'luxury', 'groceries'] } new_data = { 'timestamp': ['2023-09-04 11:05:00', '2023-09-05 12:16:30'], 'amount': [200000, 50], 'category': ['luxury', 'groceries'] } original_df = pd.DataFrame(original_data) new_df = pd.DataFrame(new_data) result_df = update_model_with_new_data(original_df, new_df) assert len(result_df) == (len(original_df) + len(new_df)) assert 'anomaly' in result_df.columns","solution":"import pandas as pd from sklearn.ensemble import IsolationForest from sklearn.preprocessing import StandardScaler from datetime import datetime def preprocess_data(df): Preprocess the transaction data. # Convert 'timestamp' to datetime and extract important features df['timestamp'] = pd.to_datetime(df['timestamp']) df['day'] = df['timestamp'].dt.day df['month'] = df['timestamp'].dt.month df['hour'] = df['timestamp'].dt.hour # Drop the original timestamp df = df.drop(columns=['timestamp']) # One-hot encode categorical features df = pd.get_dummies(df, columns=['category'], drop_first=True) return df def detect_anomalies(df): Detect anomalies in the transaction data using the IsolationForest algorithm. # Preprocess the data df = preprocess_data(df) # Standardize numerical features scaler = StandardScaler() scaled_features = scaler.fit_transform(df) # Apply Isolation Forest model = IsolationForest(n_estimators=100, contamination='auto', random_state=42) model.fit(scaled_features) # Predict anomalies anomalies = model.predict(scaled_features) # Create an 'anomaly' column df['anomaly'] = anomalies return df def update_model_with_new_data(df, new_data): Update the model with new transaction data. # Concatenate new data and old data combined_data = pd.concat([df, new_data]) # Re-detect anomalies on the combined dataset result = detect_anomalies(combined_data) return result"},{"question":"def find_pairs(n: int): Return a sorted list of unique pairs (a, b) where a * b = n. >>> find_pairs(12) [(1, 12), (2, 6), (3, 4)] >>> find_pairs(28) [(1, 28), (2, 14), (4, 7)] >>> find_pairs(1) [(1, 1)] >>> find_pairs(9) [(1, 9), (3, 3)]","solution":"def find_pairs(n: int): Return a sorted list of unique pairs (a, b) where a * b = n. >>> find_pairs(12) [(1, 12), (2, 6), (3, 4)] >>> find_pairs(28) [(1, 28), (2, 14), (4, 7)] >>> find_pairs(1) [(1, 1)] >>> find_pairs(9) [(1, 9), (3, 3)] pairs = [] for a in range(1, int(n ** 0.5) + 1): if n % a == 0: b = n // a pairs.append((a, b)) return pairs"},{"question":"def fibonacci_with_twist(a, b, n): Generates a sequence of 'n' Fibonacci numbers with a twist: instead of the usual addition operation, the algorithm alternately adds and multiplies the previous two numbers. Parameters: a (int): The first number in the sequence. b (int): The second number in the sequence. n (int): The total length of the sequence to generate. Returns: list: The generated sequence or an error message for invalid inputs. >>> fibonacci_with_twist(2, 3, 6) [2, 3, 5, 15, 20, 300] >>> fibonacci_with_twist(1, 2, 3) [1, 2, 3] >>> fibonacci_with_twist(3, 5, 4) [3, 5, 8, 40] >>> fibonacci_with_twist(-1, 3, 4) \\"Invalid input: All input values must be positive integers\\" >>> fibonacci_with_twist(2, 'b', 4) \\"Invalid input: All input values must be integers\\"","solution":"def fibonacci_with_twist(a, b, n): Generates a sequence of 'n' Fibonacci numbers with a twist: instead of the usual addition operation, the algorithm alternately adds and multiplies the previous two numbers. Parameters: a (int): The first number in the sequence. b (int): The second number in the sequence. n (int): The total length of the sequence to generate. Returns: list: The generated sequence. # Validation if not (isinstance(a, int) and isinstance(b, int) and isinstance(n, int)): return \\"Invalid input: All input values must be integers\\" if a <= 0 or b <= 0 or n <= 0: return \\"Invalid input: All input values must be positive integers\\" sequence = [a, b] for i in range(2, n): if i % 2 == 0: next_value = sequence[-1] + sequence[-2] else: next_value = sequence[-1] * sequence[-2] sequence.append(next_value) return sequence"},{"question":"def find_peak_elements(arr): Given a list of integers, return a list of tuples where each tuple contains a peak element and its index. Example: >>> find_peak_elements([1, 3, 7, 1, 2, 6, 3, 2, 6]) == [(7, 2), (6, 5), (6, 8)] >>> find_peak_elements([10, 20, 15, 2, 23, 90, 67]) == [(20, 1), (90, 5)] >>> find_peak_elements([1, 2, 3, 4, 5]) == [(5, 4)] >>> find_peak_elements([5, 4, 3, 2, 1]) == [(5, 0)] >>> find_peak_elements([4, 1, 2, 1, 2, 1, 3, 1]) == [(4, 0), (2, 2), (2, 4), (3, 6)] >>> find_peak_elements([]) == []","solution":"def find_peak_elements(arr): Given a list of integers, return a list of tuples where each tuple contains a peak element and its index. Example: find_peak_elements([1, 3, 7, 1, 2, 6, 3, 2, 6]) == [(7, 2), (6, 5), (6, 8)] find_peak_elements([10, 20, 15, 2, 23, 90, 67]) == [(20, 1), (90, 5)] find_peak_elements([1, 2, 3, 4, 5]) == [(5, 4)] find_peak_elements([5, 4, 3, 2, 1]) == [(5, 0)] find_peak_elements([4, 1, 2, 1, 2, 1, 3, 1]) == [(4, 0), (2, 2), (2, 4), (3, 6)] find_peak_elements([]) == [] peaks = [] n = len(arr) if n == 0: return peaks for i in range(n): if (i == 0 and n == 1) or (i == 0 and arr[i] > arr[i + 1]) or (i == n - 1 and arr[i] > arr[i - 1]) or (i > 0 and i < n - 1 and arr[i] > arr[i - 1] and arr[i] > arr[i + 1]): peaks.append((arr[i], i)) return peaks"},{"question":"def first_unique(lst: List[int]) -> int: Returns the first unique (non-repeating) integer from a list. If no unique integer is found, returns None. >>> first_unique([1, 2, 2, 1, 3]) 3 >>> first_unique([4, 5, 4, 5, 6]) 6 >>> first_unique([7, 7, 7, 7]) None >>> first_unique([]) None >>> first_unique([10]) 10 >>> first_unique([1, 2, 3, 4, 5]) 1 >>> first_unique([1.1, 2.2, 2.2, 1.1, 3.3]) 3.3 >>> first_unique([-1, -2, -2, -1, -3]) -3","solution":"def first_unique(lst): Returns the first unique (non-repeating) integer from a list. If no unique integer is found, returns None. count = {} # Counting the occurrences of each number in the list for num in lst: if num in count: count[num] += 1 else: count[num] = 1 # Finding the first unique number for num in lst: if count[num] == 1: return num return None"},{"question":"import re from collections import defaultdict from typing import Dict def count_unique_words(text: str) -> Dict[str, int]: Write a Python function that takes a string and returns a dictionary with the count of each unique word in the string. Ignore punctuation and assume that words are case-insensitive. Example input: \\"Hello world! Hello, how are you? Are you learning Python? Learning is fun!\\" Expected output: {'hello': 2, 'world': 1, 'how': 1, 'are': 2, 'you': 2, 'learning': 2, 'python': 1, 'is': 1, 'fun': 1} pass def test_single_word(): assert count_unique_words(\\"Hello\\") == {'hello': 1} def test_multiple_same_words(): assert count_unique_words(\\"Hello hello\\") == {'hello': 2} def test_with_punctuation(): assert count_unique_words(\\"Hello, world!\\") == {'hello': 1, 'world': 1} def test_mixed_case_words(): assert count_unique_words(\\"Hello HeLLo hELLo\\") == {'hello': 3} def test_full_example(): input_text = \\"Hello world! Hello, how are you? Are you learning Python? Learning is fun!\\" expected_output = { 'hello': 2, 'world': 1, 'how': 1, 'are': 2, 'you': 2, 'learning': 2, 'python': 1, 'is': 1, 'fun': 1 } assert count_unique_words(input_text) == expected_output","solution":"import re from collections import defaultdict def count_unique_words(text): Returns a dictionary with the count of each unique word in the string. # Convert to lowercase text = text.lower() # Replace punctuation with spaces text = re.sub(r'[^ws]', ' ', text) # Split the text into words words = text.split() # Count each word word_count = defaultdict(int) for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"def longest_two_char_substring(s: str) -> int: This function calculates the length of the longest substring of the input which consists of exactly two distinct characters. longest_two_char_substring(\\"eceba\\") == 3 # \\"ece\\" longest_two_char_substring(\\"ccaabbb\\") == 5 # \\"aabbb\\" longest_two_char_substring(\\"abaccc\\") == 4 # \\"abac\\" args: s : str : The input string returns: int : Length of the longest substring with exactly two distinct characters","solution":"def longest_two_char_substring(s: str) -> int: This function calculates the length of the longest substring of the input which consists of exactly two distinct characters. n = len(s) if n < 2: return 0 left = 0 max_len = 0 char_count = {} for right in range(n): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if len(char_count) == 2: max_len = max(max_len, right - left + 1) return max_len"},{"question":"def character_count(s: str) -> dict:   Parameters: s (str):  Returns: dict:  : >>> character_count(\\"Hello, World!\\") {'H': 1, 'e': 1, 'l': 3, 'o': 2, ',': 1, ' ': 1, 'W': 1, 'r': 1, 'd': 1, '!': 1}","solution":"def character_count(s): Returns a dictionary where the keys are characters from the string 's' and values are their respective counts in the string. count_dict = {} for char in s: if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 return count_dict"},{"question":"def mixed_sort(input_list): Sorts a given list based on the following criteria: - Integers in ascending order - Floats in descending order - Strings by length (shortest to longest) - Removes other data types Args: input_list (list): List containing elements of mixed data types. Returns: list: Sorted list with specified criteria and other data types removed. Examples: >>> mixed_sort([5, \\"apple\\", 3.14, {}, \\"cat\\", 1, 2.71, 7]) [1, 5, 7, 3.14, 2.71, \\"cat\\", \\"apple\\"] >>> mixed_sort([\\"longest\\", \\"short\\", 3, 0.5, 10, {}, None, \\"mild\\"]) [3, 10, 0.5, \\"mild\\", \\"short\\", \\"longest\\"]","solution":"def mixed_sort(input_list): Sorts a given list based on the following criteria: - Integers in ascending order - Floats in descending order - Strings by length (shortest to longest) - Removes other data types Args: input_list (list): List containing elements of mixed data types. Returns: list: Sorted list with specified criteria and other data types removed. # Filter and sort integers int_list = sorted([x for x in input_list if isinstance(x, int)]) # Filter and sort floats float_list = sorted([x for x in input_list if isinstance(x, float)], reverse=True) # Filter and sort strings str_list = sorted([x for x in input_list if isinstance(x, str)], key=len) # Combine all sorted lists result_list = int_list + float_list + str_list return result_list"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression. The expression can contain integers, the operators +, -, *, / and parentheses. The function follows the proper order of operations and handles invalid input gracefully by raising appropriate exceptions. Examples: >>> evaluate_expression(\\"2 + 3 * (5 - 2)\\") # 11 >>> evaluate_expression(\\"10 + 2 * 5\\") # 20 >>> evaluate_expression(\\"(2 + 3) * 4\\") # 20 >>> evaluate_expression(\\"3 + 4 * 2 / (1 - 5) ** 2\\") # 3.5 >>> evaluate_expression(\\"10 / (5 - 5)\\") # Raises ValueError: Division by zero >>> evaluate_expression(\\"5 * ^ 3\\") # Raises ValueError: Invalid character found >>> evaluate_expression(\\"2 + (3 * 5\\") # Raises ValueError: Unbalanced parentheses pass","solution":"def evaluate_expression(expression): Evaluates a mathematical expression. The expression can contain integers, the operators +, -, *, / and parentheses. The function follows the proper order of operations and handles invalid input gracefully by raising appropriate exceptions. def check_invalid_characters(expression): allowed_chars = set(\\"0123456789+-*/() \\") for char in expression: if char not in allowed_chars: raise ValueError(f\\"Invalid character found: {char}\\") def check_balance_parentheses(expression): balance = 0 for char in expression: if char == '(': balance += 1 elif char == ')': balance -= 1 if balance < 0: raise ValueError(\\"Unbalanced parentheses\\") if balance != 0: raise ValueError(\\"Unbalanced parentheses\\") def eval_expression(exp): try: return eval(exp) except ZeroDivisionError: raise ValueError(\\"Division by zero\\") except Exception as e: raise ValueError(str(e)) # Check for invalid characters check_invalid_characters(expression) # Check for balanced parentheses check_balance_parentheses(expression) # Evaluate the expression return eval_expression(expression)"},{"question":"import threading import logging from collections import OrderedDict class LRUCache: def __init__(self, capacity): Initialize a thread-safe LRU cache with a given capacity. self.capacity = capacity self.cache = OrderedDict() self.lock = threading.Lock() self._initialize_logging() def _initialize_logging(self): Initialize the logging configuration. logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(message)s', handlers=[logging.FileHandler(\\"cache.log\\"), logging.StreamHandler()]) def get(self, key): Retrieve an item from the cache. pass def put(self, key, value): Add an item to the cache. pass def delete(self, key): Delete an item from the cache. pass # Example usage # cache = LRUCache(2) # cache.put(\\"user1\\", \\"data1\\") # cache.put(\\"user2\\", \\"data2\\") # cache.get(\\"user1\\") # cache.put(\\"user3\\", \\"data3\\") # cache.get(\\"user2\\") # cache.delete(\\"user1\\")","solution":"import threading import logging from collections import OrderedDict class LRUCache: def __init__(self, capacity): Initialize a thread-safe LRU cache with a given capacity. self.capacity = capacity self.cache = OrderedDict() self.lock = threading.Lock() self._initialize_logging() def _initialize_logging(self): Initialize the logging configuration. logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(message)s', handlers=[logging.FileHandler(\\"cache.log\\"), logging.StreamHandler()]) def get(self, key): Retrieve an item from the cache. with self.lock: if key not in self.cache: logging.info(f\\"Cache miss for key: {key}\\") return None value = self.cache.pop(key) self.cache[key] = value logging.info(f\\"Cache hit for key: {key}\\") return value def put(self, key, value): Add an item to the cache. with self.lock: if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: evicted_key, evicted_value = self.cache.popitem(last=False) logging.info(f\\"Cache eviction: key={evicted_key}, value={evicted_value}\\") self.cache[key] = value logging.info(f\\"Cache put: key={key}, value={value}\\") def delete(self, key): Delete an item from the cache. with self.lock: if key in self.cache: logging.info(f\\"Cache delete: key={key}\\") del self.cache[key] # Example usage # cache = LRUCache(2) # cache.put(\\"user1\\", \\"data1\\") # cache.put(\\"user2\\", \\"data2\\") # cache.get(\\"user1\\") # cache.put(\\"user3\\", \\"data3\\") # cache.get(\\"user2\\") # cache.delete(\\"user1\\")"},{"question":"def reverse_string_preserve_spaces(s: str) -> str: Returns a reversed version of the string where the order of characters is reversed, but the position of spaces within the string remains unchanged. >>> reverse_string_preserve_spaces(\\"hello world\\") 'dlrow olleh' >>> reverse_string_preserve_spaces(\\"a b c d e\\") 'e d c b a' >>> reverse_string_preserve_spaces(\\"hello world \\") 'dlrow olleh ' >>> reverse_string_preserve_spaces(\\" hello world\\") ' dlrow olleh' >>> reverse_string_preserve_spaces(\\" \\") ' ' >>> reverse_string_preserve_spaces(\\"abc\\") 'cba' >>> reverse_string_preserve_spaces(\\"\\") '' >>> reverse_string_preserve_spaces(\\"a\\") 'a' >>> reverse_string_preserve_spaces(\\" \\") ' '","solution":"def reverse_string_preserve_spaces(s): Returns a reversed version of the string where the order of characters is reversed, but the position of spaces within the string remains unchanged. s_list = list(s) chars = [ch for ch in s if ch != ' '] chars.reverse() for i in range(len(s_list)): if s_list[i] != ' ': s_list[i] = chars.pop(0) return ''.join(s_list)"},{"question":"def sort_even_numbers(lst: list[int]) -> list[int]: Takes a list of integers and returns a new list with all the even numbers sorted in ascending order, while the odd numbers remain in their original positions. Parameters: lst (list of int): The list of integers. Returns: list of int: The list with even numbers sorted and odd numbers in their original positions. >>> sort_even_numbers([5, 3, 2, 8, 1, 4]) == [5, 3, 2, 4, 1, 8] from typing import List def test_no_evens(): assert sort_even_numbers([1, 3, 5, 7]) == [1, 3, 5, 7] def test_no_odds(): assert sort_even_numbers([2, 4, 6, 8]) == [2, 4, 6, 8] def test_mixed_list(): assert sort_even_numbers([5, 3, 2, 8, 1, 4]) == [5, 3, 2, 4, 1, 8] def test_single_element(): assert sort_even_numbers([1]) == [1] assert sort_even_numbers([2]) == [2] def test_empty_list(): assert sort_even_numbers([]) == [] def test_all_same_odd(): assert sort_even_numbers([1, 1, 1]) == [1, 1, 1] def test_all_same_even(): assert sort_even_numbers([2, 2, 2]) == [2, 2, 2] def test_mixed_position(): assert sort_even_numbers([1, 4, 3, 2, 6, 5]) == [1, 2, 3, 4, 6, 5] assert sort_even_numbers([10, 23, 12, 7, 6]) == [6, 23, 10, 7, 12]","solution":"def sort_even_numbers(lst): Takes a list of integers and returns a new list with all the even numbers sorted in ascending order, while the odd numbers remain in their original positions. Parameters: lst (list of int): The list of integers. Returns: list of int: The list with even numbers sorted and odd numbers in their original positions. # Extract even numbers and sort them even_numbers = sorted([x for x in lst if x % 2 == 0]) result = [] even_index = 0 # Construct the result list by replacing even numbers with sorted ones and keeping odds in place for num in lst: if num % 2 == 0: result.append(even_numbers[even_index]) even_index += 1 else: result.append(num) return result"},{"question":"def row_with_max_sum(matrix: List[List[int]]) -> Tuple[int, int]: Given a matrix filled with integers, determine the maximum sum of elements in any row and return the sum along with the row index (0-based). Parameters: matrix (list of lists of int): The input matrix. Returns: tuple: A tuple containing the maximum sum and the row index (0-based). >>> row_with_max_sum([[3, 8, 1, 9], [2, 7, 9, 4], [5, 6, 3, 2], [4, 3, 8, 7]]) (22, 1) >>> row_with_max_sum([[1, 2, 3, 4]]) (10, 0) >>> row_with_max_sum([]) (float('-inf'), -1) >>> row_with_max_sum([[0, 0, 0, 0], [2, 7, 9, 0], [0, 0, 0, 0]]) (18, 1) >>> row_with_max_sum([[-1, -2, -3, -4], [-2, -7, -9, -4], [-5, -6, -3, -2]]) (-10, 0) >>> row_with_max_sum([[1, 2, 3, -1], [4, -5, 6, 7], [-1, -1, -1, -1]]) (12, 1)","solution":"def row_with_max_sum(matrix): Given a matrix (list of lists) filled with integers, returns the maximum sum of elements in any row and the row index (0-based). Parameters: matrix (list of lists of int): The input matrix. Returns: tuple: A tuple containing the maximum sum and the row index. max_sum = float('-inf') # Initialize to negative infinity row_index = -1 # Initialize to an invalid index for i in range(len(matrix)): row_sum = sum(matrix[i]) if row_sum > max_sum: max_sum = row_sum row_index = i return max_sum, row_index"},{"question":"def two_sum(nums, target): Returns a tuple of two distinct indices whose corresponding values add up to the target sum. Arguments: nums -- list of integers target -- target integer sum Returns: A tuple of two indices if found, else None. Example: >>> two_sum([8, 2, 7, 11], 9) (1, 2) >>> two_sum([-3, 4, 3, 90], 0) (0, 2)","solution":"def two_sum(nums, target): Returns a tuple of two distinct indices whose corresponding values add up to the target sum. Arguments: nums -- list of integers target -- target integer sum Returns: A tuple of two indices if found, else None. lookup = {} for i, num in enumerate(nums): complement = target - num if complement in lookup: return (lookup[complement], i) lookup[num] = i return None"},{"question":"def filter_greater_than(numbers: List[int], n: int) -> List[int]: Returns a new list containing only the integers from the original list that are greater than n. Args: numbers (list of int): The list of integers. n (int): The comparison integer. Returns: list of int: A list with integers greater than n. Examples: >>> filter_greater_than([1, 5, 8, 3, 12, 7], 6) [8, 12, 7] >>> filter_greater_than([10, 20, 30], 5) [10, 20, 30] >>> filter_greater_than([1, 2, 3], 5) [] >>> filter_greater_than([1, 2, 6, 6, 7], 6) [7] >>> filter_greater_than([-1, -2, -3, 4, 5], -1) [4, 5] >>> filter_greater_than([0, -10, 10, 5, -5], 0) [10, 5]","solution":"def filter_greater_than(numbers, n): Returns a new list containing only the integers from the original list that are greater than n. Args: numbers (list of int): The list of integers. n (int): The comparison integer. Returns: list of int: A list with integers greater than n. return [number for number in numbers if number > n]"},{"question":"def prime_numbers_up_to_n(n: int) -> List[int]: Write a function that takes an integer \`n\` and returns a list of all prime numbers up to and including \`n\`. Do not use any built-in libraries for checking prime numbers, and implement the function from scratch. >>> prime_numbers_up_to_n(10) [2, 3, 5, 7] >>> prime_numbers_up_to_n(1) [] >>> prime_numbers_up_to_n(2) [2] >>> prime_numbers_up_to_n(3) [2, 3] >>> prime_numbers_up_to_n(29) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> prime_numbers_up_to_n(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]","solution":"def is_prime(num): Checks if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def prime_numbers_up_to_n(n): Returns a list of all prime numbers up to and including n. primes = [] for number in range(2, n + 1): if is_prime(number): primes.append(number) return primes"},{"question":"def longest_constant_interval(distances: List[int]) -> str: Returns the starting and ending seconds of the longest continuous interval where the vehicle traveled the same distance every second. >>> longest_constant_interval([5, 5, 5, 7, 7, 7, 2, 2, 2, 2]) == '6-9' >>> longest_constant_interval([5]) == '0-0' >>> longest_constant_interval([]) == '' >>> longest_constant_interval([3, 3, 3, 3, 3]) == '0-4' >>> longest_constant_interval([1, 2, 3, 4, 5]) == '0-0' >>> longest_constant_interval([2, 2, 1, 1, 1, 3, 3]) == '2-4' >>> longest_constant_interval([1, 1, 2, 2, 2, 3, 3]) == '2-4' >>> longest_constant_interval([5, 5, 1, 5, 5, 5, 5]) == '3-6'","solution":"def longest_constant_interval(distances): Returns the starting and ending seconds of the longest continuous interval where the vehicle traveled the same distance every second. n = len(distances) if n == 0: return \\"\\" max_start, max_end = 0, 0 current_start = 0 for i in range(1, n): if distances[i] != distances[current_start]: if (i - current_start) > (max_end - max_start + 1): max_start, max_end = current_start, i - 1 current_start = i if (n - current_start) > (max_end - max_start + 1): max_start, max_end = current_start, n - 1 return f\\"{max_start}-{max_end}\\""},{"question":"def count_unique_elements(arr: List[int]) -> int: Returns the number of unique elements in an unsorted array of integers. >>> count_unique_elements([1, 2, 3, 4, 5]) == 5 >>> count_unique_elements([1, 2, 2, 3, 3, 4]) == 4 >>> count_unique_elements([1]) == 1 >>> count_unique_elements([]) == 0 >>> count_unique_elements([2, 2, 2, 2]) == 1 >>> count_unique_elements([1000, 1000, 2000, 3000]) == 3 >>> count_unique_elements([3, 4, 1, 4, 3, 1, 2]) == 4","solution":"def count_unique_elements(arr): Returns the number of unique elements in an unsorted array. if not arr: return 0 arr_sorted = sorted(arr) unique_count = 1 for i in range(1, len(arr_sorted)): if arr_sorted[i] != arr_sorted[i-1]: unique_count += 1 return unique_count"},{"question":"def uniquePathsWithObstacles(obstacleGrid: List[List[int]]) -> int: Returns the number of unique paths from top-left to bottom-right in a grid with obstacles. >>> uniquePathsWithObstacles([[0,0,0],[0,1,0],[0,0,0]]) 2 >>> uniquePathsWithObstacles([[0,1],[0,0]]) 1","solution":"def uniquePathsWithObstacles(obstacleGrid): Returns the number of unique paths from top-left to bottom-right in a grid with obstacles. if not obstacleGrid or obstacleGrid[0][0] == 1: return 0 m, n = len(obstacleGrid), len(obstacleGrid[0]) # DP array to store the number of ways to reach each cell dp = [[0] * n for _ in range(m)] # Initialize the starting point dp[0][0] = 1 for i in range(m): for j in range(n): if obstacleGrid[i][j] == 1: dp[i][j] = 0 elif i == 0 and j > 0: dp[i][j] = dp[i][j-1] elif j == 0 and i > 0: dp[i][j] = dp[i-1][j] elif i > 0 and j > 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def strings_to_length_dict(input_list): Takes a list of strings and returns a dictionary where each key is a string from the list and the corresponding value is the length of that string. :param input_list: List of strings :return: Dictionary with string lengths Example: >>> strings_to_length_dict(['apple', 'banana', 'cherry']) {'apple': 5, 'banana': 6, 'cherry': 6} >>> strings_to_length_dict([]) {} >>> strings_to_length_dict(['apple']) {'apple': 5} >>> strings_to_length_dict(['a b c', ' hello ', 'world']) {'a b c': 5, ' hello ': 7, 'world': 5} >>> strings_to_length_dict(['Apple', 'BANANA', 'Cherry']) {'Apple': 5, 'BANANA': 6, 'Cherry': 6} >>> strings_to_length_dict(['@pple', 'ba!na#na', 'cherry']) {'@pple': 5, 'ba!na#na': 8, 'cherry': 7}","solution":"def strings_to_length_dict(input_list): Takes a list of strings and returns a dictionary where each key is a string from the list and the corresponding value is the length of that string. :param input_list: List of strings :return: Dictionary with string lengths return {string: len(string) for string in input_list}"},{"question":"def product_except_self(nums): Returns a list where each element is the product of all the elements in the input list except the one at that position. Parameters: nums (list of int): List of integers. Returns: list of int: List of products. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 1, 2, 3]) [6, 0, 0, 0] >>> product_except_self([-1, 1, -2, 2]) [-4, 4, -2, 2]","solution":"def product_except_self(nums): Returns a list where each element is the product of all the elements in the input list except the one at that position. Parameters: nums (list of int): List of integers. Returns: list of int: List of products. n = len(nums) if n == 0: return [] if n == 1: return [1] left_products = [1] * n right_products = [1] * n output = [1] * n # Construct the left_products array for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Construct the right_products array for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Construct the output array for i in range(n): output[i] = left_products[i] * right_products[i] return output"},{"question":"def reverse_string(s: str) -> str: Returns the reversed version of the input string s. >>> reverse_string(\\"hello\\") \\"olleh\\" >>> reverse_string(\\"a\\") \\"a\\" >>> reverse_string(\\"\\") \\"\\" >>> reverse_string(\\"madam\\") \\"madam\\" >>> reverse_string(\\"The quick brown fox\\") \\"xof nworb kciuq ehT\\"","solution":"def reverse_string(s): Returns the reversed version of the input string s. result = \\"\\" for i in range(len(s) - 1, -1, -1): result += s[i] return result # Example usage print(reverse_string(\\"hello\\")) # Output should be \\"olleh\\""},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers and operators +, -, *, and /. The function processes the expression according to the order of operations (PEMDAS/BODMAS rules). Parameters: expression (str): A string containing the mathematical expression to evaluate. Returns: int: The result of the evaluated expression. >>> evaluate_expression(\\"3+2\\") 5 >>> evaluate_expression(\\"10-3\\") 7 >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"10-5/5\\") 9 >>> evaluate_expression(\\"3+2*2/1-1\\") 6 >>> evaluate_expression(\\"1000+2000*3\\") 7000","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing non-negative integers and operators +, -, *, and /. The function processes the expression according to the order of operations (PEMDAS/BODMAS rules). Parameters: expression (str): A string containing the mathematical expression to evaluate. Returns: int: The result of the evaluated expression. def apply_operator(operands, operator): right = operands.pop() left = operands.pop() if operator == '+': operands.append(left + right) elif operator == '-': operands.append(left - right) elif operator == '*': operands.append(left * right) elif operator == '/': operands.append(left // right) def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 operands = [] operators = [] i = 0 while i < len(expression): if expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = val * 10 + int(expression[i]) i += 1 operands.append(val) i -= 1 elif expression[i] in \\"+-*/\\": while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operands, operators.pop()) operators.append(expression[i]) i += 1 while operators: apply_operator(operands, operators.pop()) return operands[0]"},{"question":"def rotate_matrix_90_clockwise(matrix): Rotates a square matrix (2D list) by 90 degrees in a clockwise direction. Args: matrix (list of list of int): NxN matrix to be rotated. Returns: list of list of int: Rotated matrix. pass def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected_output = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix_90_clockwise(matrix) == expected_output def test_rotate_1x1_matrix(): matrix = [ [1] ] expected_output = [ [1] ] assert rotate_matrix_90_clockwise(matrix) == expected_output def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] expected_output = [ [3, 1], [4, 2] ] assert rotate_matrix_90_clockwise(matrix) == expected_output def test_rotate_4x4_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected_output = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_matrix_90_clockwise(matrix) == expected_output def test_rotate_large_matrix(): matrix = [ [i + j * 10 for i in range(10)] for j in range(10) ] expected_output = [ [90, 80, 70, 60, 50, 40, 30, 20, 10, 0], [91, 81, 71, 61, 51, 41, 31, 21, 11, 1], [92, 82, 72, 62, 52, 42, 32, 22, 12, 2], [93, 83, 73, 63, 53, 43, 33, 23, 13, 3], [94, 84, 74, 64, 54, 44, 34, 24, 14, 4], [95, 85, 75, 65, 55, 45, 35, 25, 15, 5], [96, 86, 76, 66, 56, 46, 36, 26, 16, 6], [97, 87, 77, 67, 57, 47, 37, 27, 17, 7], [98, 88, 78, 68, 58, 48, 38, 28, 18, 8], [99, 89, 79, 69, 59, 49, 39, 29, 19, 9] ] assert rotate_matrix_90_clockwise(matrix) == expected_output","solution":"def rotate_matrix_90_clockwise(matrix): Rotates a square matrix (2D list) by 90 degrees in a clockwise direction. Args: matrix (list of list of int): NxN matrix to be rotated. Returns: list of list of int: Rotated matrix. # First, transpose the matrix n = len(matrix) for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"from typing import List def sort_strings_by_length(strings: List[str]) -> List[str]: Sort a list of strings first by length in descending order, then lexicographically in ascending order if lengths are the same. >>> sort_strings_by_length([\\"apple\\", \\"orange\\", \\"fig\\", \\"pineapple\\", \\"lime\\"]) [\\"pineapple\\", \\"orange\\", \\"apple\\", \\"lime\\", \\"fig\\"] >>> sort_strings_by_length([\\"bat\\", \\"cat\\", \\"apple\\", \\"ape\\"]) [\\"apple\\", \\"ape\\", \\"bat\\", \\"cat\\"]","solution":"def sort_strings_by_length(strings): Sort a list of strings first by length in descending order, then lexicographically in ascending order if lengths are the same. return sorted(strings, key=lambda x: (-len(x), x))"},{"question":"def is_palindrome(s: str) -> bool: Helper function to check if a given string is a palindrome. >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"aba\\") True >>> is_palindrome(\\"abc\\") False >>> is_palindrome(\\"abba\\") True def palindromic_substrings(string: str) -> List[str]: Finds and returns all palindromic substrings in a given string. >>> palindromic_substrings(\\"a\\") [\\"a\\"] >>> palindromic_substrings(\\"abc\\") [\\"a\\", \\"b\\", \\"c\\"] >>> palindromic_substrings(\\"aaa\\") [\\"a\\", \\"a\\", \\"a\\", \\"aa\\", \\"aa\\", \\"aaa\\"] >>> sorted(palindromic_substrings(\\"racecar\\")) ['a', 'a', 'aceca', 'c', 'c', 'cec', 'e', 'racecar', 'r', 'r'] >>> palindromic_substrings(\\"abba\\") [\\"a\\", \\"b\\", \\"b\\", \\"a\\", \\"bb\\", \\"abba\\"]","solution":"def is_palindrome(s): Helper function to check if a given string is a palindrome. return s == s[::-1] def palindromic_substrings(string): Finds and returns all palindromic substrings in a given string. n = len(string) palindromes = [] for i in range(n): # Check all odd-length palindromes centered at i for j in range(n - i): if is_palindrome(string[j:j+i+1]): palindromes.append(string[j:j+i+1]) return palindromes"},{"question":"def separate_letters_and_digits(s: str): Separates letters and digits from the input string into two different strings and checks for any special characters. :param s: Input string containing letters and digits :return: A tuple (letters, digits) if input is valid, otherwise an error message >>> separate_letters_and_digits(\\"abc\\") == (\\"abc\\", \\"\\") >>> separate_letters_and_digits(\\"123\\") == (\\"\\", \\"123\\") >>> separate_letters_and_digits(\\"a1b2c3\\") == (\\"abc\\", \\"123\\") >>> separate_letters_and_digits(\\"a1b@2c3\\") == \\"Invalid input: string contains special characters.\\" >>> separate_letters_and_digits(\\"\\") == (\\"\\", \\"\\") >>> separate_letters_and_digits(\\"abcdef\\") == (\\"abcdef\\", \\"\\") >>> separate_letters_and_digits(\\"123456\\") == (\\"\\", \\"123456\\") >>> separate_letters_and_digits(\\"ab12+cd34\\") == \\"Invalid input: string contains special characters.\\"","solution":"def separate_letters_and_digits(s): Separates letters and digits from the input string into two different strings and checks for any special characters. :param s: Input string containing letters and digits :return: A tuple (letters, digits) if input is valid, otherwise an error message letters = [] digits = [] for char in s: if char.isalpha(): letters.append(char) elif char.isdigit(): digits.append(char) else: return \\"Invalid input: string contains special characters.\\" return ''.join(letters), ''.join(digits)"},{"question":"def move_zeroes(arr): Move all zeroes in the array to the end while maintaining the order of non-zero elements. This function modifies the array in-place without using extra space. Parameters: arr (list): The input list with integer elements. Returns: None: The function modifies the list in-place and returns None. >>> arr = [0, 1, 0, 3, 12] >>> move_zeroes(arr) >>> arr [1, 3, 12, 0, 0] >>> arr = [1, 2, 3, 4, 5] >>> move_zeroes(arr) >>> arr [1, 2, 3, 4, 5] >>> arr = [0, 0, 0, 0, 0] >>> move_zeroes(arr) >>> arr [0, 0, 0, 0, 0] >>> arr = [4, 2, 0, 1, 0, 3] >>> move_zeroes(arr) >>> arr [4, 2, 1, 3, 0, 0] >>> arr = [0] >>> move_zeroes(arr) >>> arr [0] >>> arr = [5] >>> move_zeroes(arr) >>> arr [5]","solution":"def move_zeroes(arr): Move all zeroes in the array to the end while maintaining the order of non-zero elements. This function modifies the array in-place without using extra space. Parameters: arr (list): The input list with integer elements. Returns: None: The function modifies the list in-place and returns None. non_zero_index = 0 # Move all non-zero elements to the front for i in range(len(arr)): if arr[i] != 0: arr[non_zero_index] = arr[i] non_zero_index += 1 # Fill the remaining positions with zeroes for i in range(non_zero_index, len(arr)): arr[i] = 0"},{"question":"def count_characters(s: str) -> dict: Returns a dictionary with each unique character in the input string as the key and the number of times each character appears in the string as the value. >>> count_characters(\\"HelloWorld\\") {'H': 1, 'e': 1, 'l': 3, 'o': 2, 'W': 1, 'r': 1, 'd': 1} >>> count_characters(\\"a1b1c1\\") {'a': 1, '1': 3, 'b': 1, 'c': 1}","solution":"def count_characters(s): Returns a dictionary with each unique character in the input string as the key and the number of times each character appears in the string as the value. character_count = {} for char in s: if char in character_count: character_count[char] += 1 else: character_count[char] = 1 return character_count"},{"question":"def factorial(n): Calculate the factorial of a non-negative integer using iteration. Includes error handling for invalid inputs. Args: n: A non-negative integer. Returns: The factorial of the number n. Raises: ValueError: If the input is not a non-negative integer. Example Usage: >>> factorial(5) 120 >>> factorial(0) 1","solution":"def factorial(n): Calculate the factorial of a non-negative integer using iteration. Includes error handling for invalid inputs. Args: n: A non-negative integer. Returns: The factorial of the number n. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return 1 result = 1 for i in range(2, n + 1): result *= i return result"},{"question":"def max_profit(prices): Simulate a simple stock trading system. The function accepts stock prices as a list of integers and returns the best days to buy and sell to maximize profit. If no profit can be made, it returns \\"No profit\\". If the input is invalid, it returns \\"Invalid input\\". Args: prices (List[int]): A list of daily stock prices. Returns: Union[Tuple[int, int, int], str]: A tuple with buy day, sell day, and maximum profit, or a string indicating no profit or invalid input. >>> max_profit([10, 7, 5, 8, 11, 9]) (2, 4, 6) >>> max_profit([10, 9, 8, 7, 6, 5]) 'No profit' >>> max_profit([5, 5, 5, 5, 5]) 'No profit' >>> max_profit([]) 'Invalid input' >>> max_profit(\\"12345\\") 'Invalid input' >>> max_profit([10, '9', 8, 7, 6, 5]) 'Invalid input' >>> max_profit([5]) 'No profit' >>> max_profit([5, 10]) (0, 1, 5) >>> max_profit([10, 5]) 'No profit' def test_max_profit(): assert max_profit([10, 7, 5, 8, 11, 9]) == (2, 4, 6) assert max_profit([10, 9, 8, 7, 6, 5]) == \\"No profit\\" def test_no_profit(): assert max_profit([10, 9, 8, 7, 6, 5]) == \\"No profit\\" def test_all_equal(): assert max_profit([5, 5, 5, 5, 5]) == \\"No profit\\" def test_empty_input(): assert max_profit([]) == \\"Invalid input\\" def test_non_list_input(): assert max_profit(\\"12345\\") == \\"Invalid input\\" def test_non_integer_prices(): assert max_profit([10, '9', 8, 7, 6, 5]) == \\"Invalid input\\" def test_single_day(): assert max_profit([5]) == \\"No profit\\" def test_two_days_case_profit(): assert max_profit([5, 10]) == (0, 1, 5) def test_two_days_case_no_profit(): assert max_profit([10, 5]) == \\"No profit\\"","solution":"def max_profit(prices): # Handle potential input errors if not prices or not isinstance(prices, list) or not all(isinstance(price, int) for price in prices): return \\"Invalid input\\" min_price = float('inf') max_profit = 0 buy_day = sell_day = -1 for i in range(len(prices)): if prices[i] < min_price: min_price = prices[i] buy_day = i if prices[i] - min_price > max_profit: max_profit = prices[i] - min_price sell_day = i if max_profit > 0: return buy_day, sell_day, max_profit else: return \\"No profit\\""},{"question":"def is_prime(n: int) -> bool: Determines if the given number n is a prime number. >>> is_prime(2) True >>> is_prime(4) False def filter_and_sort_primes(numbers: List[int]) -> List[int]: Filters the prime numbers from the input list and returns them sorted in ascending order. >>> filter_and_sort_primes([3, 6, 8, 5, 12, 7, 2]) [2, 3, 5, 7] >>> filter_and_sort_primes([4, 6, 8, 10]) []","solution":"import math def is_prime(n): Determines if the given number n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_and_sort_primes(numbers): Filters the prime numbers from the input list and returns them sorted in ascending order. primes = [num for num in numbers if is_prime(num)] return sorted(primes)"},{"question":"import string def clean_string(s: str) -> str: Cleans the input string by removing spaces, punctuation, and converting to lowercase. pass def are_anagrams(s1: str, s2: str) -> bool: Determines if two strings are anagrams of each other, ignoring case, spaces, and punctuation. >>> are_anagrams(\\"The eyes\\", \\"They see\\") True >>> are_anagrams(\\"A gentleman\\", \\"Elegant man\\") True >>> are_anagrams(\\"Hello, World!\\", \\"world Hello!\\") True >>> are_anagrams(\\"Dormitory\\", \\"Dirty rooms\\") False pass def are_anagrams_strict(s1: str, s2: str) -> bool: Determines if two strings are anagrams of each other, considering lengths after removing spaces, punctuation, and ignoring case. >>> are_anagrams_strict(\\"The eyes\\", \\"They see\\") True >>> are_anagrams_strict(\\"A gentleman\\", \\"Elegant man\\") True >>> are_anagrams_strict(\\"Hello, World!\\", \\"world Hello!\\") True >>> are_anagrams_strict(\\"Dormitory\\", \\"Dirty room\\") True >>> are_anagrams_strict(\\"Dormitory\\", \\"Dirty rooms\\") False >>> are_anagrams_strict(\\"Rats\\", \\"Starry\\") False >>> are_anagrams_strict(\\"listen\\", \\"silent\\") True >>> are_anagrams_strict(\\"listen\\", \\"silentt\\") False # different lengths pass","solution":"import string def clean_string(s): Cleans the input string by removing spaces, punctuation, and converting to lowercase. return ''.join(e for e in s if e.isalnum()).lower() def are_anagrams(s1, s2): Determines if two strings are anagrams of each other, ignoring case, spaces, and punctuation. cleaned_s1 = clean_string(s1) cleaned_s2 = clean_string(s2) return sorted(cleaned_s1) == sorted(cleaned_s2) def are_anagrams_strict(s1, s2): Determines if two strings are anagrams of each other, considering lengths after removing spaces, punctuation, and ignoring case. cleaned_s1 = clean_string(s1) cleaned_s2 = clean_string(s2) if len(cleaned_s1) != len(cleaned_s2): return False return sorted(cleaned_s1) == sorted(cleaned_s2)"},{"question":"def filter_primes(input_list): Takes a list of integers and returns a new list containing only the prime numbers from the input list. Excludes negative numbers, zero, and non-numeric data. Raises ValueError for non-list input. >>> filter_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [2, 3, 5, 7] >>> filter_primes([-10, -5, 0, 1, 2, 3, 11]) == [2, 3, 11] >>> filter_primes([2, '3', 5, 'hello', 7]) == [2, 5, 7] >>> filter_primes([0, 1, -1, 4, 6, 8, 9, 10]) == [] >>> filter_primes([]) == [] >>> filter_primes([2.5, 3.1, 5, 7.2]) == [5] >>> filter_primes('not a list') Traceback (most recent call last): ... ValueError: Input must be a list. >>> filter_primes(123) Traceback (most recent call last): ... ValueError: Input must be a list.","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(input_list): Returns a new list containing only the prime numbers from the input list. Excludes negative numbers, zero, and non-numeric data. if not isinstance(input_list, list): raise ValueError(\\"Input must be a list.\\") primes = [] for item in input_list: if isinstance(item, int) and is_prime(item): primes.append(item) return primes"},{"question":"def max_product_of_three(nums): Implement a function that takes a list of integers and returns the maximum product of any three distinct numbers in the list. For instance: max_product_of_three([1, 2, 3]) => 6 max_product_of_three([-10, -10, 5, 2]) => 500 max_product_of_three([1, 10, -5, 1, -100]) => 5000 max_product_of_three([1, 2, 3, 4]) => 24 max_product_of_three([-1, -2, -3, -4]) => -6 from solution import max_product_of_three def test_positive_numbers(): assert max_product_of_three([1, 2, 3]) == 6 assert max_product_of_three([1, 2, 3, 4]) == 24 assert max_product_of_three([10, 20, 30]) == 6000 def test_negative_numbers(): assert max_product_of_three([-1, -2, -3, -4]) == -6 assert max_product_of_three([-10, -10, -5, -2]) == -100 assert max_product_of_three([-5, -5, -5]) == -125 def test_mixed_sign_numbers(): assert max_product_of_three([-10, -10, 5, 2]) == 500 assert max_product_of_three([1, 10, -5, 1, -100]) == 5000 assert max_product_of_three([-4, -3, 2, 3, 4]) == 48 def test_contains_zeros(): assert max_product_of_three([0, 0, 0, 1, 2, 3]) == 6 assert max_product_of_three([-1, 0, 1, 2, -1]) == 2 def test_edge_cases(): assert max_product_of_three([1, 1, 1]) == 1 assert max_product_of_three([0, 0, 1, 2, 3]) == 6","solution":"def max_product_of_three(nums): Returns the maximum product of any three numbers in the list \`nums\`. :param nums: List of integers :return: Maximum product of any three distinct numbers in the list nums.sort() # Maximum product can be either from the largest three numbers # or from two smallest (most negative) numbers and the largest number return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def unique_elements(arr): Refactor the code to return a list of unique elements from the input array. Remove duplicates while maintaining the original order of elements. Also, fix the mistake in the provided code. Example: unique_elements([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 3, 4, 5] Identified error for rectification: result = [] seen = sit() for item in arr: if item not seen: seen.append(item) result.append(item) return result from solution import unique_elements def test_unique_elements_with_duplicates(): assert unique_elements([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 3, 4, 5] def test_unique_elements_no_duplicates(): assert unique_elements([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_unique_elements_all_same(): assert unique_elements([1, 1, 1, 1]) == [1] def test_unique_elements_empty(): assert unique_elements([]) == [] def test_unique_elements_mixed_types(): assert unique_elements([1, 'a', 'a', 2, 2, 3, 'b']) == [1, 'a', 2, 3, 'b']","solution":"def unique_elements(arr): Returns a list of unique elements from the input array, removing duplicates while maintaining the original order of elements. Example: unique_elements([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 3, 4, 5] result = [] seen = set() for item in arr: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"def average_scores(scores_dict): Given a dictionary where each key is a string representing a person's name and the corresponding value is a list of integers indicating their scores in different subjects, determine and return the average score of each person rounded to the nearest integer. :param scores_dict: Dictionary with names as keys and lists of scores as values :return: Dictionary with names as keys and their average score rounded to the nearest integer >>> average_scores({ \\"Alice\\": [90, 85, 88], \\"Bob\\": [70, 80], \\"Charlie\\": [100, 95, 92, 88] }) {\\"Alice\\": 88, \\"Bob\\": 75, \\"Charlie\\": 94} >>> average_scores({ \\"Alice\\": [], \\"Bob\\": [], \\"Charlie\\": [] }) {\\"Alice\\": 0, \\"Bob\\": 0, \\"Charlie\\": 0} >>> average_scores({ \\"Alice\\": [90], \\"Bob\\": [80], \\"Charlie\\": [95] }) {\\"Alice\\": 90, \\"Bob\\": 80, \\"Charlie\\": 95} >>> average_scores({ \\"Alice\\": [90, 85, 88], \\"Bob\\": [], \\"Charlie\\": [60, 70, 80, 90] }) {\\"Alice\\": 88, \\"Bob\\": 0, \\"Charlie\\": 75}","solution":"def average_scores(scores_dict): Given a dictionary where each key is a string representing a person's name and the corresponding value is a list of integers indicating their scores in different subjects, determine and return the average score of each person rounded to the nearest integer. :param scores_dict: Dictionary with names as keys and lists of scores as values :return: Dictionary with names as keys and their average score rounded to the nearest integer avg_scores = {} for name, scores in scores_dict.items(): if scores: avg_scores[name] = round(sum(scores) / len(scores)) else: avg_scores[name] = 0 # Handle the case of empty score lists return avg_scores"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def get_intersection(head1: ListNode, head2: ListNode) -> ListNode: Find intersection of two linked lists. >>> node1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) >>> node2 = ListNode(2, ListNode(3, ListNode(5))) >>> result = get_intersection(node1, node2) >>> while result: >>> print(result.val, end=\\" \\") >>> result = result.next 2 3","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def get_intersection(head1: ListNode, head2: ListNode) -> ListNode: Find intersection of two linked lists. set2 = set() while head2: set2.add(head2.val) head2 = head2.next dummy = ListNode() current = dummy while head1: if head1.val in set2: current.next = ListNode(head1.val) current = current.next head1 = head1.next return dummy.next"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root: TreeNode) -> bool: Checks whether the given binary tree is a valid binary search tree (BST). >>> root = TreeNode(2) >>> root.left = TreeNode(1) >>> root.right = TreeNode(3) >>> is_valid_bst(root) True >>> root = TreeNode(5) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.right.left = TreeNode(3) >>> root.right.right = TreeNode(6) >>> is_valid_bst(root) False pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root): Checks whether the given binary tree is a valid binary search tree (BST). def validate(node, low=float('-inf'), high=float('inf')): if not node: return True if not (low < node.val < high): return False return validate(node.left, low, node.val) and validate(node.right, node.val, high) return validate(root)"},{"question":"def rotate_matrix(matrix, k): Rotates a square matrix (2D array) k times by 90 degrees clockwise. If k is negative, performs counterclockwise rotations instead. :param matrix: List[List[int]] - A square matrix :param k: int - Number of 90-degree rotations (positive for clockwise, negative for counterclockwise) :return: List[List[int]] - Rotated matrix >>> rotate_matrix([[1, 2], [3, 4]], 1) [[3, 1], [4, 2]] >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], -1) [[3, 6, 9], [2, 5, 8], [1, 4, 7]]","solution":"def rotate_matrix(matrix, k): Rotates a square matrix (2D array) k times by 90 degrees clockwise. If k is negative, performs counterclockwise rotations instead. :param matrix: List[List[int]] - A square matrix :param k: int - Number of 90-degree rotations (positive for clockwise, negative for counterclockwise) :return: List[List[int]] - Rotated matrix def rotate_once(mat): Rotates the matrix 90 degrees clockwise once. :param mat: List[List[int]] - A square matrix :return: List[List[int]] - Rotated matrix N = len(mat) rotated = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): rotated[j][N - 1 - i] = mat[i][j] return rotated k = k % 4 # Only 4 unique rotations needed as 4 rotations brings the matrix back to original if k == 0: return matrix if k < 0: k += 4 # Converting negative rotations to positive equivalent rotated_matrix = matrix for _ in range(k): rotated_matrix = rotate_once(rotated_matrix) return rotated_matrix"},{"question":"def char_frequency(s: str) -> str: Returns a new string where each character from the original string is followed by its frequency of occurrence while preserving the order of first occurrences of each character. >>> char_frequency(\\"abcd\\") == \\"a1b1c1d1\\" >>> char_frequency(\\"aaaa\\") == \\"a4\\" >>> char_frequency(\\"aabccdeee\\") == \\"a2b1c2d1e3\\" >>> char_frequency(\\"abcabcabc\\") == \\"a3b3c3\\" >>> char_frequency(\\"\\") == \\"\\" >>> char_frequency(\\"a\\") == \\"a1\\" >>> char_frequency(\\"b\\") == \\"b1\\" >>> char_frequency(\\"AaBb\\") == \\"A1a1B1b1\\"","solution":"from collections import Counter def char_frequency(s): Returns a new string where each character from the original string is followed by its frequency of occurrence. counter = Counter(s) result = [] for char in s: if char in counter: result.append(f\\"{char}{counter[char]}\\") del counter[char] # Ensures each character is processed only once return ''.join(result)"},{"question":"def compress_string(s: str) -> str: Implement a function \`compress_string\` that compresses a given string using the following rules: 1. If the length of the string is less than or equal to 2, return the string as is. 2. For longer strings, replace consecutive occurrences of the same character with that character followed by the count of its consecutive occurrences. 3. If the compressed string is not shorter than the original string, return the original string. >>> compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" >>> compress_string(\\"abc\\") == \\"abc\\" >>> compress_string(\\"aa\\") == \\"aa\\" pass if __name__ == \\"__main__\\": # Example test cases print(compress_string(\\"aabcccccaaa\\")) # Output: \\"a2b1c5a3\\" print(compress_string(\\"abc\\")) # Output: \\"abc\\" print(compress_string(\\"aa\\")) # Output: \\"aa\\"","solution":"def compress_string(s: str) -> str: if len(s) <= 2: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def is_isomorphic(str1: str, str2: str) -> bool: Determine if two strings are isomorphic. Strings are isomorphic if there is a one-to-one correspondence between their characters. >>> is_isomorphic(\\"egg\\", \\"add\\") True >>> is_isomorphic(\\"foo\\", \\"bar\\") False >>> is_isomorphic(\\"paper\\", \\"title\\") True >>> is_isomorphic(\\"ab\\", \\"aa\\") False >>> is_isomorphic(\\"a\\", \\"b\\") True >>> is_isomorphic(\\"aaaa\\", \\"bbbb\\") True >>> is_isomorphic(\\"a\\", \\"bb\\") False","solution":"def is_isomorphic(str1, str2): Determine if two strings are isomorphic. Strings are isomorphic if there is a one-to-one correspondence between their characters. if len(str1) != len(str2): return False # Dictionaries to store character mappings map_str1_to_str2 = {} map_str2_to_str1 = {} for char1, char2 in zip(str1, str2): if (char1 in map_str1_to_str2 and map_str1_to_str2[char1] != char2) or (char2 in map_str2_to_str1 and map_str2_to_str1[char2] != char1): return False map_str1_to_str2[char1] = char2 map_str2_to_str1[char2] = char1 return True"},{"question":"def evaluate_expression(s: str) -> int: Evaluate a simple mathematical expression involving positive integers and the operators +, -, *, / without any parentheses, following standard operator precedence rules. The division operator '/' performs integer division. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\"3+5 / 2\\") 5","solution":"def evaluate_expression(s: str) -> int: Evaluate a simple mathematical expression involving positive integers and the operators +, -, *, / without any parentheses, following standard operator precedence rules. The division operator '/' performs integer division. # Remove whitespace from the input string s = s.replace(\\" \\", \\"\\") # Initialize stack and variables to keep current number and last operator stack = [] num = 0 last_operator = '+' # Loop through characters in the string for i, ch in enumerate(s): if ch.isdigit(): num = num * 10 + int(ch) # Handle the operation when encountering an operator or the end of the string if ch in \\"+-*/\\" or i == len(s) - 1: if last_operator == \\"+\\": stack.append(num) elif last_operator == \\"-\\": stack.append(-num) elif last_operator == \\"*\\": stack[-1] = stack[-1] * num elif last_operator == \\"/\\": stack[-1] = int(stack[-1] / num) # Reset num and update last operator num = 0 last_operator = ch return sum(stack)"},{"question":"def find_max_subsequence(arr): Implement a function to locate a continuous subsequence with the highest sum within a list of integers. The function should return a tuple of the starting and ending indices of this subsequence. When the list contains multiple subsequences with the same highest sum, it should return the subsequence with the smallest starting index. If all elements are negative, return the indices of the least negative number. Examples: >>> find_max_subsequence([1, -2, 3, 4, -1, 2, -5, 4]) (2, 5) >>> find_max_subsequence([-3, -2, -1]) (2, 2) from solution import find_max_subsequence def test_all_positive_numbers(): assert find_max_subsequence([1, 2, 3, 4]) == (0, 3) def test_including_negative_numbers(): assert find_max_subsequence([1, -2, 3, 4, -1, 2, -5, 4]) == (2, 5) def test_all_negative_numbers(): assert find_max_subsequence([-3, -2, -1]) == (2, 2) def test_single_element_list(): assert find_max_subsequence([5]) == (0, 0) def test_empty_list(): assert find_max_subsequence([]) == (0, 0) def test_mix_of_positive_and_negative(): assert find_max_subsequence([-3, 1, -2, 4, -1, 2, 1, -5, 4]) == (3, 6) def test_multiple_subsequences_with_same_sum(): assert find_max_subsequence([1, 2, 3, -6, 3, 2, 1]) == (0, 2) def test_large_list(): arr = list(range(-1000, 1000)) assert find_max_subsequence(arr) == (1000, 1999)","solution":"def find_max_subsequence(arr): Locates a continuous subsequence with the highest sum within a list of integers. Returns a tuple of the starting and ending indices of this subsequence. When the list contains multiple subsequences with the same highest sum, the subsequence with the smallest starting index is returned. If all elements are negative, the indices of the least negative number are returned. if not arr: return (0, 0) max_sum = current_sum = float('-inf') start = end = temp_start = 0 least_negative_idx = None least_negative_val = float('-inf') for idx, value in enumerate(arr): if value >= least_negative_val: least_negative_idx = idx least_negative_val = value if current_sum < 0: current_sum = value temp_start = idx else: current_sum += value if current_sum > max_sum or (current_sum == max_sum and temp_start < start): max_sum = current_sum start = temp_start end = idx if max_sum < 0: return (least_negative_idx, least_negative_idx) return (start, end)"},{"question":"from typing import List def longest_arith_seq_length(nums: List[int]) -> int: Implement a function that takes in a list of integers and returns the length of the longest subsequence where the difference between consecutive integers is the same. Parameters: nums (List[int]): A list of integers. Returns: int: The length of the longest subsequence with the same difference between consecutive integers. Examples: >>> longest_arith_seq_length([1, 5, 7, 8, 5, 3, 4, 2]) 3 >>> longest_arith_seq_length([3, 6, 9, 12]) 4 >>> longest_arith_seq_length([9, 4, 7, 2, 10]) 3 # Test cases def test_longest_arith_seq_length_1(): assert longest_arith_seq_length([1, 5, 7, 8, 5, 3, 4, 2]) == 3 def test_longest_arith_seq_length_2(): assert longest_arith_seq_length([3, 6, 9, 12]) == 4 def test_longest_arith_seq_length_3(): assert longest_arith_seq_length([9, 4, 7, 2, 10]) == 3 def test_longest_arith_seq_length_empty(): assert longest_arith_seq_length([]) == 0 def test_longest_arith_seq_length_single_element(): assert longest_arith_seq_length([10]) == 1 def test_longest_arith_seq_length_all_same(): assert longest_arith_seq_length([2, 2, 2, 2, 2]) == 5 def test_longest_arith_seq_length_negative_numbers(): assert longest_arith_seq_length([-1, -5, -7, -8, -5, -3, -4, -2]) == 3 def test_longest_arith_seq_length_mixed(): assert longest_arith_seq_length([-1, -2, -3, 0, 3, 6, -6, -9, -12]) == 4","solution":"def longest_arith_seq_length(nums): if len(nums) == 0: return 0 longest_length = 1 dp = [{} for _ in range(len(nums))] for i in range(1, len(nums)): for j in range(i): diff = nums[i] - nums[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 longest_length = max(longest_length, dp[i][diff]) return longest_length"},{"question":"class InventoryItem: A class to represent an item in inventory and handle stock updates. Attributes: identifier (str): The unique identifier for the item. name (str): The name of the item. quantity (int): The current stock level of the item. def __init__(self, identifier: str, name: str, quantity: int): Initializes an inventory item with a unique identifier, name, and initial quantity. pass def receive(self, amount: int): Increases the stock level by the amount received. Args: amount (int): The amount of stock to add (must be non-negative). Raises: ValueError: If the amount is negative. pass def sell(self, amount: int): Decreases the stock level by the amount sold. If the amount to be sold is greater than the available stock, raise an exception. Args: amount (int): The amount of stock to subtract (must be non-negative and must not exceed available stock). Raises: ValueError: If the amount is negative or exceeds available stock. pass def get_stock_level(self) -> int: Returns the current stock level of the item. Returns: int: The current stock level. pass # Sample usage try: item = InventoryItem('A101', 'Widget', 10) item.receive(5) print(f\\"Stock after receiving 5 units: {item.get_stock_level()}\\") item.sell(3) print(f\\"Stock after selling 3 units: {item.get_stock_level()}\\") item.sell(20) # This should raise an exception except ValueError as e: print(f\\"Error: {e}\\") # Unit tests def test_receive_positive_amount(): item = InventoryItem('A102', 'Gadget', 10) item.receive(5) assert item.get_stock_level() == 15 def test_receive_negative_amount(): item = InventoryItem('A103', 'Thingamajig', 10) try: item.receive(-5) except ValueError as e: assert str(e) == \\"Receive amount must be non-negative.\\" def test_sell_positive_amount(): item = InventoryItem('A104', 'Device', 10) item.sell(3) assert item.get_stock_level() == 7 def test_sell_negative_amount(): item = InventoryItem('A105', 'Apparatus', 10) try: item.sell(-3) except ValueError as e: assert str(e) == \\"Sell amount must be non-negative.\\" def test_sell_more_than_available_stock(): item = InventoryItem('A106', 'Contraption', 10) try: item.sell(11) except ValueError as e: assert str(e) == \\"Cannot sell more than available stock.\\" def test_get_stock_level(): item = InventoryItem('A107', 'Machine', 25) assert item.get_stock_level() == 25 def test_sample_usage(): item = InventoryItem('A101', 'Widget', 10) item.receive(5) assert item.get_stock_level() == 15 item.sell(3) assert item.get_stock_level() == 12 try: item.sell(20) except ValueError as e: assert str(e) == \\"Cannot sell more than available stock.\\"","solution":"class InventoryItem: def __init__(self, identifier, name, quantity): Initializes an inventory item with a unique identifier, name, and initial quantity. self.identifier = identifier self.name = name self.quantity = quantity def receive(self, amount): Increases the stock level by the amount received. if amount < 0: raise ValueError(\\"Receive amount must be non-negative.\\") self.quantity += amount def sell(self, amount): Decreases the stock level by the amount sold. If the amount to be sold is greater than the available stock, raise an exception. if amount < 0: raise ValueError(\\"Sell amount must be non-negative.\\") if amount > self.quantity: raise ValueError(\\"Cannot sell more than available stock.\\") self.quantity -= amount def get_stock_level(self): Returns the current stock level of the item. return self.quantity # Sample usage try: item = InventoryItem('A101', 'Widget', 10) item.receive(5) print(f\\"Stock after receiving 5 units: {item.get_stock_level()}\\") item.sell(3) print(f\\"Stock after selling 3 units: {item.get_stock_level()}\\") item.sell(20) # This should raise an exception except ValueError as e: print(f\\"Error: {e}\\")"},{"question":"def most_common_word(paragraph: str, banned: List[str]) -> str: Returns the most common word in the paragraph that is not in the banned list. >>> most_common_word(\\"This is a test. This test is only a test.\\", [\\"is\\", \\"a\\"]) 'test' >>> most_common_word(\\"Hello world world\\", [\\"hello\\", \\"world\\"]) None >>> most_common_word(\\"Hello hello Hello\\", [\\"hello\\"]) None >>> most_common_word(\\"Apple apple Banana banana\\", [\\"apple\\"]) 'banana' >>> most_common_word(\\"Red blue blue green green green\\", []) 'green' >>> most_common_word(\\"This is a test!!! This test is only a test?!?!?\\", [\\"is\\", \\"a\\"]) 'test'","solution":"def most_common_word(paragraph, banned): Returns the most common word in the paragraph that is not in the banned list. import re from collections import Counter # Normalize paragraph by removing non-alphabetic characters and lowercasing words = re.findall(r'bw+b', paragraph.lower()) # Filter out banned words filtered_words = [word for word in words if word not in banned] # Count word frequencies word_counts = Counter(filtered_words) # Find the most common word that is not banned max_count = 0 common_word = None for word in filtered_words: if word_counts[word] > max_count: max_count = word_counts[word] common_word = word return common_word"},{"question":"def is_prime(num): Check if a number is a prime number. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(7) == True >>> is_prime(9) == False pass def filter_primes(lst): Filter prime numbers from the input list. >>> filter_primes([12, 15, 7, 5, 8, 17]) == [7, 5, 17] >>> filter_primes([2, 3, 5, 7, 11]) == [2, 3, 5, 7, 11] >>> filter_primes([4, 6, 8, 10, 12]) == [] >>> filter_primes([]) == [] pass # Filtering prime numbers from the list [12, 15, 7, 5, 8, 17] and displaying the resulting list primes_list = filter_primes([12, 15, 7, 5, 8, 17]) print(\\"Filtered Primes List:\\", primes_list)","solution":"def is_prime(num): Check if a number is a prime number. if num <= 1: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def filter_primes(lst): Filter prime numbers from the input list. return [num for num in lst if is_prime(num)] # Filtering prime numbers from the list [12, 15, 7, 5, 8, 17] and displaying the resulting list primes_list = filter_primes([12, 15, 7, 5, 8, 17]) print(\\"Filtered Primes List:\\", primes_list)"},{"question":"def validate_input(lst): Ensure the input list is non-empty and does not contain nested lists. Raises: ValueError: If the input list is empty or contains non-integer elements. def max_subarray(lst): Given a list of integers, identify and return the subarray with the maximum sum. If there are multiple subarrays with the same maximum sum, return the one that appears latest in the list. >>> max_subarray([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == [4, -1, 2, 1] >>> max_subarray([5]) == [5] >>> max_subarray([-1, -2, -3, -4]) == [-1] >>> max_subarray([1, -2, 1, -2, 1, -2, 1]) == [1]","solution":"def validate_input(lst): if not lst: raise ValueError(\\"Input list must not be empty\\") if not all(isinstance(i, int) for i in lst): raise ValueError(\\"Input list must only contain integers\\") def max_subarray(lst): validate_input(lst) max_sum = float('-inf') current_sum = 0 end = start = 0 best_start = best_end = -1 for index in range(len(lst)): current_sum += lst[index] if current_sum > max_sum: max_sum = current_sum best_start = start best_end = index if current_sum == max_sum and (best_start == -1 or index > best_end): best_start = start best_end = index if current_sum < 0: current_sum = 0 start = index + 1 return lst[best_start:best_end+1]"},{"question":"def evaluate_expressions(expressions): Given a list of strings expressions, each string contains a basic arithmetic expression. The function should evaluate each expression and return a list of results. If any expression involves a division by zero, return None for that specific expression. Example: >>> evaluate_expressions([\\"2 + 3\\", \\"4 * 5\\", \\"10 / 2\\", \\"8 - 3\\"]) == [5, 20, 5.0, 5] >>> evaluate_expressions([\\"2 + 3\\", \\"4 / 0\\", \\"10 * 2\\"]) == [5, None, 20] >>> evaluate_expressions([]) == []","solution":"def evaluate_expressions(expressions): Given a list of strings expressions, each string contains a basic arithmetic expression. The function should evaluate each expression and return a list of results. If any expression involves a division by zero, return None for that specific expression. Parameters: expressions (list of str): List containing mathematical expressions as strings. Returns: list: List of results of the evaluated expressions. For divisions by zero, return None. results = [] for expr in expressions: try: result = eval(expr, {\\"__builtins__\\": None}, {}) results.append(result) except ZeroDivisionError: results.append(None) except: results.append(None) # To handle any other potential evaluation error return results"},{"question":"import hashlib import time class Block: def __init__(self, data, previous_hash=''): self.timestamp = time.time() self.data = data self.previous_hash = previous_hash self.hash = self.calculate_hash() def calculate_hash(self): block_string = f\\"{self.timestamp}{self.data}{self.previous_hash}\\" return hashlib.sha256(block_string.encode()).hexdigest() class Blockchain: def __init__(self): self.chain = [self.create_genesis_block()] def create_genesis_block(self): return Block(\\"Genesis Block\\", \\"0\\") def get_latest_block(self): return self.chain[-1] def add_block(self, new_block): Add a new block to the blockchain. >>> blockchain = Blockchain() >>> blockchain.add_block(Block(\\"Block 1 Data\\")) >>> len(blockchain.chain) 2 >>> blockchain.chain[1].data 'Block 1 Data' new_block.previous_hash = self.get_latest_block().hash new_block.hash = new_block.calculate_hash() self.chain.append(new_block) def is_chain_valid(self): Check if the blockchain is valid. >>> blockchain = Blockchain() >>> blockchain.is_chain_valid() True >>> blockchain.add_block(Block(\\"Block 1 Data\\")) >>> blockchain.add_block(Block(\\"Block 2 Data\\")) >>> blockchain.chain[1].data = \\"Tampered Data\\" >>> blockchain.is_chain_valid() False for i in range(1, len(self.chain)): current_block = self.chain[i] previous_block = self.chain[i - 1] if current_block.hash != current_block.calculate_hash(): return False if current_block.previous_hash != previous_block.hash: return False return True def display_chain(self): Display the blocks in the blockchain. >>> blockchain = Blockchain() >>> blockchain.add_block(Block(\\"Block 1 Data\\")) >>> blockchain.display_chain() Block Hash: <hash> Previous Hash: <previous_hash> Data: Block 1 Data Timestamp: <timestamp> <other blocks information> for block in self.chain: print(f\\"Block Hash: {block.hash}\\") print(f\\"Previous Hash: {block.previous_hash}\\") print(f\\"Data: {block.data}\\") print(f\\"Timestamp: {block.timestamp}n\\")","solution":"import hashlib import time class Block: def __init__(self, data, previous_hash=''): self.timestamp = time.time() self.data = data self.previous_hash = previous_hash self.hash = self.calculate_hash() def calculate_hash(self): block_string = f\\"{self.timestamp}{self.data}{self.previous_hash}\\" return hashlib.sha256(block_string.encode()).hexdigest() class Blockchain: def __init__(self): self.chain = [self.create_genesis_block()] def create_genesis_block(self): return Block(\\"Genesis Block\\", \\"0\\") def get_latest_block(self): return self.chain[-1] def add_block(self, new_block): new_block.previous_hash = self.get_latest_block().hash new_block.hash = new_block.calculate_hash() self.chain.append(new_block) def is_chain_valid(self): for i in range(1, len(self.chain)): current_block = self.chain[i] previous_block = self.chain[i - 1] if current_block.hash != current_block.calculate_hash(): return False if current_block.previous_hash != previous_block.hash: return False return True def display_chain(self): for block in self.chain: print(f\\"Block Hash: {block.hash}\\") print(f\\"Previous Hash: {block.previous_hash}\\") print(f\\"Data: {block.data}\\") print(f\\"Timestamp: {block.timestamp}n\\") # Example usage blockchain = Blockchain() blockchain.add_block(Block(\\"Block 1 Data\\")) blockchain.add_block(Block(\\"Block 2 Data\\")) blockchain.display_chain() print(\\"Is blockchain valid?\\", blockchain.is_chain_valid())"},{"question":"def reverse_middle(lst: List[int]) -> List[int]: Write a Python function that takes a list of integers and returns a new list with the elements in reversed order, except for the first and last elements which should remain in their original positions. >>> reverse_middle([10, 20, 30, 40, 50]) [10, 40, 30, 20, 50] >>> reverse_middle([]) [] >>> reverse_middle([10]) [10] >>> reverse_middle([10, 20]) [10, 20] >>> reverse_middle([10, 20, 30]) [10, 20, 30] >>> reverse_middle([1, 2, 3, 3, 2, 1]) [1, 2, 3, 3, 2, 1] >>> reverse_middle(list(range(1, 101))) [1] + list(range(99, 1, -1)) + [100] >>> reverse_middle([-10, -20, -30, -40, -50]) [-10, -40, -30, -20, -50]","solution":"def reverse_middle(lst): Returns a new list with the elements in reversed order except for the first and last elements. if len(lst) <= 2: return lst return [lst[0]] + lst[-2:0:-1] + [lst[-1]]"},{"question":"def rearrange_string(s: str) -> str: Rearrange the characters in the string so that no two adjacent characters are the same. Args: s (str): The input string to be rearranged. Returns: str: The rearranged string or an empty string if not possible. Examples: >>> rearrange_string(\\"aabb\\") 'abab' >>> rearrange_string(\\"aaab\\") ''","solution":"from heapq import heappop, heappush from collections import Counter def rearrange_string(s: str) -> str: Rearrange the characters in the string so that no two adjacent characters are the same. If it's not possible to rearrange, return an empty string. Args: s (str): The input string to be rearranged. Returns: str: The rearranged string or an empty string if not possible. Examples: >>> rearrange_string(\\"aabb\\") 'abab' >>> rearrange_string(\\"aaab\\") '' # Create a frequency counter for the characters in the string counter = Counter(s) # Create a max heap based on character frequency # Use negative counts because Python's heapq implements a min heap max_heap = [] for char, freq in counter.items(): heappush(max_heap, (-freq, char)) result = [] prev_freq, prev_char = 0, \\"\\" while max_heap: freq, char = heappop(max_heap) result.append(char) if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char # freq is negative, so add 1 to reduce absolute value rearranged_str = \\"\\".join(result) if len(rearranged_str) == len(s): return rearranged_str else: return \\"\\""},{"question":"def balance_brackets(s): Returns True if all types of brackets in the string s are balanced, and False otherwise. Includes error handling for non-string inputs and invalid characters. >>> balance_brackets(\\"()\\") True >>> balance_brackets(\\"({})\\") True >>> balance_brackets(\\"([])\\") True >>> balance_brackets(\\"{[()]}\\") True >>> balance_brackets(\\"([)]\\") False >>> balance_brackets(\\"((())\\") False >>> balance_brackets(\\"[[[]\\") False >>> balance_brackets(\\"{(})\\") False >>> balance_brackets(\\"\\") True >>> balance_brackets(\\"{[]}\\") True >>> balance_brackets(\\"{[}]\\") False","solution":"def balance_brackets(s): Returns True if all types of brackets in the string s are balanced, and False otherwise. if not isinstance(s, str): raise TypeError(\\"Input should be a string.\\") brackets = {'(': ')', '{': '}', '[': ']'} open_brackets = set(brackets.keys()) close_brackets = set(brackets.values()) stack = [] for char in s: if char in open_brackets: stack.append(char) elif char in close_brackets: if not stack or brackets[stack.pop()] != char: return False else: raise ValueError(\\"Input string should contain only brackets.\\") return not stack"},{"question":"def calculate_total_revenue_by_customer(orders): Calculate total revenue for each customer from a list of orders. Args: orders (list of dict): Each dictionary contains \\"order_id\\", \\"customer_id\\", and \\"total_amount\\". Returns: list of dict: Each dictionary contains \\"customer_id\\" and \\"total_revenue\\", sorted by descending revenue. >>> calculate_total_revenue_by_customer([ ... {\\"order_id\\": 1, \\"customer_id\\": 1, \\"total_amount\\": 100}, ... {\\"order_id\\": 2, \\"customer_id\\": 2, \\"total_amount\\": 200}, ... {\\"order_id\\": 3, \\"customer_id\\": 1, \\"total_amount\\": 150}, ... {\\"order_id\\": 4, \\"customer_id\\": 3, \\"total_amount\\": 300} ... ]) [{'customer_id': 3, 'total_revenue': 300}, {'customer_id': 1, 'total_revenue': 250}, {'customer_id': 2, 'total_revenue': 200}] >>> calculate_total_revenue_by_customer([ ... {\\"order_id\\": 1, \\"customer_id\\": 1, \\"total_amount\\": 100}, ... {\\"order_id\\": 2, \\"customer_id\\": 1, \\"total_amount\\": 200} ... ]) [{'customer_id': 1, 'total_revenue': 300}] >>> calculate_total_revenue_by_customer([]) [] >>> calculate_total_revenue_by_customer([ ... {\\"order_id\\": 1, \\"customer_id\\": 1, \\"total_amount\\": 100}, ... {\\"order_id\\": 2, \\"customer_id\\": 2, \\"total_amount\\": 200}, ... {\\"order_id\\": 3, \\"customer_id\\": 3, \\"total_amount\\": 300} ... ]) [{'customer_id': 3, 'total_revenue': 300}, {'customer_id': 2, 'total_revenue': 200}, {'customer_id': 1, 'total_revenue': 100}] >>> calculate_total_revenue_by_customer([ ... {\\"order_id\\": 1, \\"customer_id\\": 1, \\"total_amount\\": 100}, ... {\\"order_id\\": 2, \\"customer_id\\": 2, \\"total_amount\\": 100}, ... {\\"order_id\\": 3, \\"customer_id\\": 3, \\"total_amount\\": 100} ... ]) [{'customer_id': 1, 'total_revenue': 100}, {'customer_id': 2, 'total_revenue': 100}, {'customer_id': 3, 'total_revenue': 100}]","solution":"def calculate_total_revenue_by_customer(orders): Calculate total revenue for each customer from a list of orders. Args: orders (list of dict): Each dictionary contains \\"order_id\\", \\"customer_id\\", and \\"total_amount\\". Returns: list of dict: Each dictionary contains \\"customer_id\\" and \\"total_revenue\\", sorted by descending revenue. revenue_by_customer = {} for order in orders: customer_id = order['customer_id'] total_amount = order['total_amount'] if customer_id in revenue_by_customer: revenue_by_customer[customer_id] += total_amount else: revenue_by_customer[customer_id] = total_amount # Convert to list of dictionaries and sort by total_revenue in descending order sorted_revenue_list = [{\\"customer_id\\": k, \\"total_revenue\\": v} for k, v in sorted(revenue_by_customer.items(), key=lambda item: item[1], reverse=True)] return sorted_revenue_list"},{"question":"def multiply_matrices(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: Performs element-wise multiplication of two matrices. :param matrix1: List of lists representing the first matrix :param matrix2: List of lists representing the second matrix :return: A new matrix which is the element-wise product of matrix1 and matrix2 :raises ValueError: If the matrices are not of the same dimensions Example: >>> multiply_matrices([[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]) [[7, 16, 27], [40, 55, 72]] >>> multiply_matrices([[2]], [[3]]) [[6]]","solution":"def multiply_matrices(matrix1, matrix2): Performs element-wise multiplication of two matrices. :param matrix1: List of lists representing the first matrix :param matrix2: List of lists representing the second matrix :return: A new matrix which is the element-wise product of matrix1 and matrix2 :raises ValueError: If the matrices are not of the same dimensions # Check if the dimensions match if len(matrix1) != len(matrix2) or any(len(row1) != len(row2) for row1, row2 in zip(matrix1, matrix2)): raise ValueError(\\"Matrices are not of the same dimensions.\\") result = [] for i in range(len(matrix1)): row = [] for j in range(len(matrix1[i])): row.append(matrix1[i][j] * matrix2[i][j]) result.append(row) return result"},{"question":"def three_largest_distinct(nums: List[int]) -> List[int]: Returns a list of the three largest distinct integers in ascending order. If there are fewer than three distinct integers, return all distinct integers sorted in ascending order. >>> three_largest_distinct([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) [5, 6, 9] >>> three_largest_distinct([5, 5, 5]) [5] >>> three_largest_distinct([1, 2]) [1, 2]","solution":"def three_largest_distinct(nums): Returns a list of the three largest distinct integers in ascending order. If there are fewer than three distinct integers, return all distinct integers sorted in ascending order. distinct_nums = sorted(set(nums)) return distinct_nums[-3:] if len(distinct_nums) >= 3 else distinct_nums"},{"question":"from collections import defaultdict def group_anagrams(words: list) -> list: Find all anagrams in a list of words and group them together. Args: words (list of str): A list of words to be grouped by anagram. Returns: list of list of str: A list of lists where each sublist contains words that are anagrams of each other. Examples: >>> group_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"rat\\", \\"tar\\", \\"art\\", \\"star\\", \\"tars\\"]) [['listen', 'silent', 'enlist'], ['rat', 'tar', 'art'], ['star', 'tars']] >>> group_anagrams([\\"apple\\", \\"banana\\", \\"carrot\\"]) [['apple'], ['banana'], ['carrot']] pass def test_group_anagrams_basic(): assert group_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"rat\\", \\"tar\\", \\"art\\", \\"star\\", \\"tars\\"]) == [ ['listen', 'silent', 'enlist'], ['rat', 'tar', 'art'], ['star', 'tars'] ] def test_group_anagrams_no_anagrams(): assert group_anagrams([\\"apple\\", \\"banana\\", \\"carrot\\"]) == [ ['apple'], ['banana'], ['carrot'] ] def test_group_anagrams_all_anagrams(): assert group_anagrams([\\"abc\\", \\"bca\\", \\"cab\\"]) == [['abc', 'bca', 'cab']] def test_group_anagrams_single_word(): assert group_anagrams([\\"word\\"]) == [['word']] def test_group_anagrams_empty_list(): assert group_anagrams([]) == [] def test_group_anagrams_mixed_case(): assert group_anagrams([\\"bat\\", \\"tab\\", \\"cat\\", \\"act\\"]) == [['bat', 'tab'], ['cat', 'act']]","solution":"from collections import defaultdict def group_anagrams(words): Groups anagrams together from a list of words. Args: words (list of str): A list of words to be grouped by anagram. Returns: list of list of str: A list of lists where each sublist contains words that are anagrams of each other. anagrams = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"def factorial(n: int) -> int: Returns the factorial of a non-negative integer n. If n is negative, returns -1 as factorial is undefined for negative numbers. >>> factorial(-5) -1 >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(5) 120 >>> factorial(10) 3628800","solution":"def factorial(n): Returns the factorial of a non-negative integer n. If n is negative, returns -1 as factorial is undefined for negative numbers. if n < 0: return -1 elif n == 0 or n == 1: return 1 else: result = 1 for i in range(2, n + 1): result *= i return result"},{"question":"def num_subarray_product_less_than_k(arr: List[int], k: int) -> int: Given an array of integers \`arr\` and an integer \`k\`, find the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than \`k\`. >>> num_subarray_product_less_than_k([10, 5, 2, 6], 100) 8 >>> num_subarray_product_less_than_k([1, 2, 3], 0) 0","solution":"def num_subarray_product_less_than_k(arr, k): if k <= 1: return 0 start = 0 product = 1 count = 0 for end in range(len(arr)): product *= arr[end] while product >= k: product /= arr[start] start += 1 count += end - start + 1 return count"},{"question":"def find_largest_subarray_sum(nums): Create a function \`find_largest_subarray_sum\` in Python that takes a list of integers as input and returns the largest sum of contiguous subarray using the Kadane's algorithm. >>> find_largest_subarray_sum([1, -2, 3, 5, -1, 2]) (9, [3, 5, -1, 2]) >>> find_largest_subarray_sum([-1, -2, -3, -4]) (-1, [-1]) >>> find_largest_subarray_sum([]) 0 >>> find_largest_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) (6, [4, -1, 2, 1]) >>> find_largest_subarray_sum([5]) (5, [5]) >>> find_largest_subarray_sum([1, 2, 3, 4]) (10, [1, 2, 3, 4])","solution":"def find_largest_subarray_sum(nums): Returns the largest sum of contiguous subarray using Kadane's algorithm. if not nums: return 0 max_current = max_global = nums[0] start = end = s = 0 for i in range(1, len(nums)): if nums[i] > max_current + nums[i]: max_current = nums[i] s = i else: max_current += nums[i] if max_current > max_global: max_global = max_current start = s end = i return max_global, nums[start:end+1]"},{"question":"from collections import Counter import re def count_unique_words(sentence: str): Counts unique words in a sentence and returns a dictionary with word counts and the number of unique words. >>> count_unique_words(\\"This is a test. This test is only a test.\\") ({'this': 2, 'is': 2, 'a': 2, 'test': 3, 'only': 1}, 5) >>> count_unique_words(\\"\\") ({}, 0) >>> count_unique_words(\\"Every word here is unique\\") ({'every': 1, 'word': 1, 'here': 1, 'is': 1, 'unique': 1}, 5) >>> count_unique_words(\\"Hello hello HELLO!\\") ({'hello': 3}, 1) >>> count_unique_words(\\"Hello, world! This is a test: one, two, three... Test, test, TEST!\\") ({'hello': 1, 'world': 1, 'this': 1, 'is': 1, 'a': 1, 'test': 4, 'one': 1, 'two': 1, 'three': 1}, 9)","solution":"from collections import Counter import re def count_unique_words(sentence): Counts unique words in a sentence and returns a dictionary with word counts and the number of unique words. Parameters: sentence (str): The input sentence. Returns: dict: A dictionary where keys are unique words and values are their counts. int: Total number of unique words. # Normalize the sentence to handle punctuation and case words = re.findall(r'bw+b', sentence.lower()) # Get the word counts using Counter word_counts = Counter(words) # Extract the total number of unique words unique_word_count = len(word_counts) return word_counts, unique_word_count"},{"question":"import re from typing import List def filter_strings_with_target(strings: List[str], target: str) -> List[str]: Filters the list of strings to include only those that contain the target word (case-insensitive, ignoring punctuation). >>> filter_strings_with_target([ ... \\"Hello, world!\\", ... \\"Python is awesome.\\", ... \\"This world is beautiful.\\", ... \\"WORLD of programming.\\"], \\"world\\") ['Hello, world!', 'This world is beautiful.', 'WORLD of programming.'] >>> filter_strings_with_target([ ... \\"Hello, everyone!\\", ... \\"Python is a great language.\\", ... \\"Beautiful day outside.\\"], \\"world\\") [] >>> filter_strings_with_target([ ... \\"Hello, World!\\", ... \\"Python World of programming.\\", ... \\"WORLD of Warcraft.\\"], \\"world\\") ['Hello, World!', 'Python World of programming.', 'WORLD of Warcraft.'] >>> filter_strings_with_target([ ... \\"Isn't the world beautiful?\\", ... \\"Yes, it is! The world is indeed beautiful.\\", ... \\"worldwide impact.\\"], \\"world\\") [\\"Isn't the world beautiful?\\", \\"Yes, it is! The world is indeed beautiful.\\"] >>> filter_strings_with_target([], \\"world\\") [] >>> filter_strings_with_target([ ... \\"worldly matters\\", ... \\"simple world\\", ... \\"the world of wonders\\", ... \\"anotherworld\\"], \\"world\\") ['simple world', 'the world of wonders']","solution":"import re def filter_strings_with_target(strings, target): Filters the list of strings to include only those that contain the target word (case-insensitive, ignoring punctuation). target_re = re.compile(r'b' + re.escape(target) + r'b', re.IGNORECASE) return [s for s in strings if target_re.search(s)]"},{"question":"def count_words(s: str) -> dict: Create a function that accepts a string containing words separated by spaces, and returns a dictionary mapping each unique word in the string to the number of times it appears. Ignore differences in capitalization. >>> count_words(\\"hello\\") {\\"hello\\": 1} >>> count_words(\\"test test test\\") {\\"test\\": 3} >>> count_words(\\"Hello hello HELLO\\") {\\"hello\\": 3} >>> count_words(\\"one two three one\\") {\\"one\\": 2, \\"two\\": 1, \\"three\\": 1} >>> count_words(\\"\\") {} >>> count_words(\\"hello! hello.\\") {\\"hello!\\": 1, \\"hello.\\": 1} >>> count_words(\\"Hello, hello, HELLO!\\") {\\"hello,\\": 2, \\"hello!\\": 1}","solution":"def count_words(s): Returns a dictionary mapping each unique word in the string \`s\` to the number of times it appears. The function is case-insensitive. # Convert the string to lowercase to ignore differences in capitalization s = s.lower() # Split the string into words based on spaces words = s.split() # Create a dictionary to store the word counts word_counts = {} # Iterate through each word in the list for word in words: # If the word is already in the dictionary, increment its count if word in word_counts: word_counts[word] += 1 # If the word is not in the dictionary, add it with a count of 1 else: word_counts[word] = 1 return word_counts"},{"question":"def find_unique_elements(lst): Returns a list of unique elements from the given list, keeping their original order. >>> find_unique_elements([1, 1, 1, 1]) [1] >>> find_unique_elements([1, 2, 3, 4]) [1, 2, 3, 4] >>> find_unique_elements([4, 5, 5, 3, 4, 7, 8, 8, 3]) [4, 5, 3, 7, 8] >>> find_unique_elements([]) [] >>> find_unique_elements([1, 'a', 2, 'a', 1, 3]) [1, 'a', 2, 3]","solution":"def find_unique_elements(lst): Returns a list of unique elements from the given list, keeping their original order. seen = set() unique_elements = [] for item in lst: if item not in seen: seen.add(item) unique_elements.append(item) return unique_elements"},{"question":"def average_ratings(ratings): Calculate the average rating for each item based on individual user ratings. Args: ratings (list of tuples): A list where each tuple contains an item name and a rating. Returns: dict: A dictionary where keys are item names and values are the average rating for each item rounded to one decimal place. # Your code here # Example input ratings = [ ('item1', 4), ('item2', 5), ('item2', 3), ('item1', 5), ('item3', 2), ('item2', 4) ] # Calling the function print(average_ratings(ratings)) # Expected output: # { # 'item1': 4.5, # 'item2': 4.0, # 'item3': 2.0 # }","solution":"def average_ratings(ratings): Calculate the average rating for each item based on individual user ratings. Args: ratings (list of tuples): A list where each tuple contains an item name and a rating. Returns: dict: A dictionary where keys are item names and values are the average rating for each item rounded to one decimal place. from collections import defaultdict ratings_dict = defaultdict(list) for item, rating in ratings: ratings_dict[item].append(rating) average_rating_dict = {} for item, rating_list in ratings_dict.items(): average_rating_dict[item] = round(sum(rating_list) / len(rating_list), 1) return average_rating_dict"},{"question":"def find_unique_substrings(s: str, k: int) -> list: Finds all unique substrings of length k from the given string s. The substrings are listed in the order they first appeared in s. Parameters: s (str): The input string. k (int): The length of the substrings. Returns: list: A list of unique substrings of length k. Examples: >>> find_unique_substrings(\\"abac\\", 2) [\\"ab\\", \\"ba\\", \\"ac\\"] >>> find_unique_substrings(\\"aaa\\", 1) [\\"a\\"] >>> find_unique_substrings(\\"abcd\\", 3) [\\"abc\\", \\"bcd\\"] >>> find_unique_substrings(\\"abc\\", 4) [] >>> find_unique_substrings(\\"\\", 2) []","solution":"def find_unique_substrings(s: str, k: int) -> list: Finds all unique substrings of length k from the given string s. The substrings are listed in the order they first appeared in s. Parameters: s (str): The input string. k (int): The length of the substrings. Returns: list: A list of unique substrings of length k. if k > len(s) or k <= 0: return [] unique_substrings = set() result = [] for i in range(len(s) - k + 1): substring = s[i:i+k] if substring not in unique_substrings: unique_substrings.add(substring) result.append(substring) return result"},{"question":"def largest_number_by_deleting_one_digit(s: str) -> str: Returns the largest number that can be obtained by deleting one digit from the input string. If the string has only one digit, returns the digit itself. >>> largest_number_by_deleting_one_digit('132') == '32' >>> largest_number_by_deleting_one_digit('1001') == '101' >>> largest_number_by_deleting_one_digit('9') == '9'","solution":"def largest_number_by_deleting_one_digit(s): Returns the largest number that can be obtained by deleting one digit from the input string. If the string has only one digit, returns the digit itself. if len(s) == 1: return s max_num = \\"\\" for i in range(len(s)): current_num = s[:i] + s[i+1:] if current_num > max_num: max_num = current_num return max_num"},{"question":"from typing import List def find_max_length(nums: List[int]) -> int: Finds the maximum length of a contiguous subarray with an equal number of 0s and 1s. Args: nums (List[int]): The input array containing only 0s and 1s. Returns: int: The length of the longest contiguous subarray with equal number of 0s and 1s. Example: >>> find_max_length([1, 0, 0, 1, 0, 1, 1]) 6 >>> find_max_length([0, 0, 0, 0]) 0 >>> find_max_length([1, 1, 1, 1]) 0 pass def test_example_case(): assert find_max_length([1, 0, 0, 1, 0, 1, 1]) == 6 def test_all_zeros(): assert find_max_length([0, 0, 0, 0]) == 0 def test_all_ones(): assert find_max_length([1, 1, 1, 1]) == 0 def test_alternating_zeros_and_ones(): assert find_max_length([0, 1, 0, 1, 0, 1, 0, 1]) == 8 def test_no_contiguous_subarray(): assert find_max_length([0, 1, 1, 1, 1]) == 2 def test_single_element(): assert find_max_length([0]) == 0 assert find_max_length([1]) == 0 def test_empty_array(): assert find_max_length([]) == 0","solution":"def find_max_length(nums): Finds the maximum length of a contiguous subarray with an equal number of 0s and 1s. count_map = {0: -1} # Dictionary to store the first occurrence of a cumulative count max_length = 0 count = 0 # This count variable will track the balance between 0s and 1s for index, num in enumerate(nums): # Increase count for 1 and decrease count for 0 count += 1 if num == 1 else -1 if count in count_map: max_length = max(max_length, index - count_map[count]) else: count_map[count] = index return max_length"},{"question":"def summarize_text(text: str) -> str: Returns a summary of the text by extracting the first sentence from each paragraph. >>> summarize_text(\\"This is the first sentence. This is the second sentence.\\") \\"This is the first sentence.\\" >>> summarize_text(\\"First paragraph first sentence. First paragraph second sentence.nSecond paragraph first sentence. Second paragraph second sentence.\\") \\"First paragraph first sentence.nSecond paragraph first sentence.\\"","solution":"def summarize_text(text): Returns a summary of the text by extracting the first sentence from each paragraph. Parameters: text (str): The input text which may contain multiple paragraphs. Returns: str: A summary of the text formed by the first sentence of each paragraph. paragraphs = text.strip().split('n') summary = [] for paragraph in paragraphs: if paragraph: sentences = paragraph.strip().split('. ') first_sentence = sentences[0] + '.' summary.append(first_sentence) return 'n'.join(summary)"},{"question":"def rotate_right(arr, k): Rotates the array to the right by k steps. Parameters: arr (list): The array of integers. k (int): The number of steps to rotate the array to the right. Returns: list: The modified array, rotated to the right by k steps. >>> rotate_right([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_right([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_right([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_right([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_right([1], 10) [1] >>> rotate_right([], 3) [] # The function implementation goes here","solution":"def rotate_right(arr, k): Rotates the array to the right by k steps. Parameters: arr (list): The array of integers. k (int): The number of steps to rotate the array to the right. Returns: list: The modified array, rotated to the right by k steps. if not arr: return [] n = len(arr) k = k % n # Normalize k if it's larger than the length of the array arr[:] = arr[-k:] + arr[:-k] # Rotate in place return arr"},{"question":"from typing import List def longest_contiguous_subsequence(lst: List[int]) -> int: Takes a list of integers and returns the length of the longest contiguous subsequence where the difference between consecutive elements is always 1. Additionally, handle exceptions where the input is not a list of integers or if the list is empty. >>> longest_contiguous_subsequence([1, 2, 3, 5, 6, 7, 8]) == 4 >>> longest_contiguous_subsequence([10]) == 1 >>> longest_contiguous_subsequence([10, 20, 30]) == 1 >>> longest_contiguous_subsequence([1, 2, 3, 4, 5]) == 5 >>> longest_contiguous_subsequence([-3, -2, -1, 0, 1]) == 5 pass # Unit tests import pytest def test_longest_contiguous_subsequence_basic(): assert longest_contiguous_subsequence([1, 2, 3, 5, 6, 7, 8]) == 4 def test_longest_contiguous_subsequence_single_element(): assert longest_contiguous_subsequence([10]) == 1 def test_longest_contiguous_subsequence_no_contiguous(): assert longest_contiguous_subsequence([10, 20, 30]) == 1 def test_longest_contiguous_subsequence_entire_list(): assert longest_contiguous_subsequence([1, 2, 3, 4, 5]) == 5 def test_longest_contiguous_subsequence_with_negatives(): assert longest_contiguous_subsequence([-3, -2, -1, 0, 1]) == 5 def test_longest_contiguous_subsequence_empty_list(): with pytest.raises(ValueError, match=\\"Input list must not be empty.\\"): longest_contiguous_subsequence([]) def test_longest_contiguous_subsequence_invalid_input(): with pytest.raises(ValueError, match=\\"Input must be a list of integers.\\"): longest_contiguous_subsequence(\\"not a list\\") with pytest.raises(ValueError, match=\\"Input must be a list of integers.\\"): longest_contiguous_subsequence([1, 2, \\"three\\", 4])","solution":"def longest_contiguous_subsequence(lst): Takes a list of integers and returns the length of the longest contiguous subsequence where the difference between consecutive elements is always 1. if not isinstance(lst, list) or not all(isinstance(i, int) for i in lst): raise ValueError(\\"Input must be a list of integers.\\") if not lst: raise ValueError(\\"Input list must not be empty.\\") max_length = 0 current_length = 1 for i in range(1, len(lst)): if lst[i] - lst[i-1] == 1: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Given a string containing lowercase letters, return the length of the longest subsequence that is palindrome. Note: A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. >>> longest_palindromic_subsequence(\\"abca\\") 3 >>> longest_palindromic_subsequence(\\"aaaa\\") 4 >>> longest_palindromic_subsequence(\\"racecar\\") 7 from solution import longest_palindromic_subsequence def test_example(): assert longest_palindromic_subsequence(\\"abca\\") == 3 def test_single_character(): assert longest_palindromic_subsequence(\\"a\\") == 1 def test_two_characters(): assert longest_palindromic_subsequence(\\"aa\\") == 2 assert longest_palindromic_subsequence(\\"ab\\") == 1 def test_palindromic_string(): assert longest_palindromic_subsequence(\\"racecar\\") == 7 assert longest_palindromic_subsequence(\\"madam\\") == 5 def test_non_palindromic_string(): assert longest_palindromic_subsequence(\\"abcdefg\\") == 1 def test_mixed_chars(): assert longest_palindromic_subsequence(\\"character\\") == 5 def test_repeated_chars(): assert longest_palindromic_subsequence(\\"aaaa\\") == 4 assert longest_palindromic_subsequence(\\"abababababa\\") == 11 def test_long_string(): assert longest_palindromic_subsequence(\\"agbdba\\") == 5","solution":"def longest_palindromic_subsequence(s): Returns the length of the longest palindromic subsequence in the given string \`s\`. n = len(s) # Create a table to store results of subproblems dp = [[0 for _ in range(n)] for _ in range(n)] # All substrings of length 1 are palindromic for i in range(n): dp[i][i] = 1 # Build the table for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1]"},{"question":"from typing import List def calculate_range(numbers: List[int]) -> int: Calculate the range of a list of integers (difference between max and min values). The function should not use Python's built-in \`min\` and \`max\` functions. Args: numbers (List[int]): A non-empty list of integers. Returns: int: The range of the list. Examples: >>> calculate_range([10, 3, 5, 6, 2, 8, 1]) 9 >>> calculate_range([7]) 0 >>> calculate_range([-10, -3, -5, -1, -7]) 9 >>> calculate_range([10, -3, 5, 6, -2, 8, 1]) 13 >>> calculate_range([1000000, 500000, 1500000, 750000]) 1000000 >>> calculate_range([5, 5, 5, 5]) 0","solution":"def calculate_range(numbers): Calculate the range of a list of integers (difference between max and min values). if not numbers: return 0 # Return 0 for an empty list (though the problem states list is non-empty) min_val = float('inf') max_val = float('-inf') for number in numbers: if number < min_val: min_val = number if number > max_val: max_val = number return max_val - min_val # Example usage: input_list = [10, 3, 5, 6, 2, 8, 1] print(calculate_range(input_list)) # Output should be 9"},{"question":"def string_with_most_unique_chars(strings: List[str]) -> str: Takes a list of strings and returns the string with the highest number of unique characters. If there is a tie, returns the string that appears first in the list. If the list is empty, returns an empty string. >>> string_with_most_unique_chars([\\"abc\\", \\"abcd\\", \\"aabbcc\\"]) == \\"abcd\\" >>> string_with_most_unique_chars([\\"abc\\", \\"def\\", \\"ghi\\"]) == \\"abc\\" >>> string_with_most_unique_chars([\\"a\\", \\"ab\\", \\"abc\\"]) == \\"abc\\" >>> string_with_most_unique_chars([\\"abc\\", \\"bca\\", \\"cab\\"]) == \\"abc\\" >>> string_with_most_unique_chars([\\"xx\\", \\"yy\\"]) == \\"xx\\" >>> string_with_most_unique_chars([]) == \\"\\" >>> string_with_most_unique_chars([\\"single\\"]) == \\"single\\" >>> string_with_most_unique_chars([\\"short\\", \\"longer\\", \\"lengthiest\\"]) == \\"lengthiest\\" >>> string_with_most_unique_chars([\\"abc\\", \\"abcde\\", \\"aaccee\\"]) == \\"abcde\\" >>> string_with_most_unique_chars([\\"aaaa\\", \\"bbbbb\\", \\"ccccc\\"]) == \\"aaaa\\"","solution":"def string_with_most_unique_chars(strings): Takes a list of strings and returns the string with the highest number of unique characters. If there is a tie, returns the string that appears first in the list. If the list is empty, returns an empty string. if not strings: return \\"\\" def unique_char_count(s): return len(set(s)) return max(strings, key=lambda s: (unique_char_count(s), -strings.index(s)))"},{"question":"import random # Sample dataset target = \\"HELLO, WORLD!\\" population_size = 200 mutation_rate = 0.01 generations = 1000 # Genetic Algorithm functions def create_individual(length): Create random individual with given length >>> len(create_individual(len(target))) == len(target) def calculate_fitness(individual): Fitness score based on matching characters with target >>> calculate_fitness(\\"HELLO, WORLD!\\") == len(\\"HELLO, WORLD!\\") >>> calculate_fitness(\\"HELLO, WORLDS\\") < len(\\"HELLO, WORLD!\\") def mutate(individual): Mutate randomly according to mutation rate >>> len(mutate(\\"HELLO, WORLD!\\")) == len(\\"HELLO, WORLD!\\") def crossover(parent1, parent2): Single point crossover >>> len(crossover(\\"HELLO, WORLDS\\", \\"GENETIC ALGO!\\")) == len(\\"HELLO, WORLDS\\") def genetic_algorithm(): Perform a genetic algorithm to evolve towards target string >>> type(genetic_algorithm()) == str >>> len(genetic_algorithm()) == len(target)","solution":"import random # Sample dataset target = \\"HELLO, WORLD!\\" population_size = 200 mutation_rate = 0.01 generations = 1000 # Genetic Algorithm functions def create_individual(length): # Create random individual with given length return ''.join(random.choice(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ, !\\") for _ in range(length)) def calculate_fitness(individual): # Fitness score based on matching characters with target return sum(t == i for t, i in zip(target, individual)) def mutate(individual): # Mutate randomly according to mutation rate individual = list(individual) for i in range(len(individual)): if random.random() < mutation_rate: individual[i] = random.choice(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ, !\\") return ''.join(individual) def crossover(parent1, parent2): # Single point crossover cross_point = random.randint(0, len(parent1) - 1) return parent1[:cross_point] + parent2[cross_point:] def genetic_algorithm(): # Initialize population population = [create_individual(len(target)) for _ in range(population_size)] for generation in range(generations): # Calculate fitness for population fitness_scores = [calculate_fitness(ind) for ind in population] # Select parents based on fitness selected_individuals = random.choices( population=population, weights=fitness_scores, k=population_size ) # Create new population through crossover and mutation population = [ mutate(crossover(selected_individuals[i], selected_individuals[i+1])) for i in range(0, population_size, 2) ] # Print best individual from current generation best_individual = max(population, key=calculate_fitness) if calculate_fitness(best_individual) == len(target): print(f\\"Solution found in generation {generation}: {best_individual}\\") return best_individual print(f\\"No solution found in {generations} generations. Best guess: {best_individual}\\") return best_individual # Run the genetic algorithm genetic_algorithm()"},{"question":"from typing import List, Tuple import re from collections import Counter def most_frequent_words(text: str) -> List[Tuple[str, int]]: Identifies and extracts the most frequently occurring word(s) from a given text document. Excludes common stop words and is case-insensitive. Args: text (str): The input text in which to find the most frequent words. Returns: List[Tuple[str, int]]: A list of tuples of the most frequent word(s) and their corresponding counts. >>> most_frequent_words(\\"The quick brown fox jumps over the lazy dog\\") [('quick', 1), ('brown', 1), ('fox', 1), ('jumps', 1), ('over', 1), ('lazy', 1), ('dog', 1)] >>> most_frequent_words(\\"apple orange banana apple orange apple\\") [('apple', 3)] >>> most_frequent_words(\\"This is a test of the system with some stop words in use.\\") [('test', 1), ('system', 1), ('some', 1), ('stop', 1), ('words', 1), ('use', 1)] >>> most_frequent_words(\\"\\") [] >>> most_frequent_words(\\"Apple apple apple Orange orange\\") [('apple', 3)] >>> most_frequent_words(\\"the is in and to a with of on for as by at an be this that which\\") []","solution":"from collections import Counter import re def most_frequent_words(text): Identifies and extracts the most frequently occurring word(s) from a given text document. Excludes common stop words and is case-insensitive. stop_words = {'the', 'is', 'in', 'and', 'to', 'a', 'with', 'of', 'on', 'for', 'as', 'by', 'at', 'an', 'be', 'this', 'that', 'which'} # Convert text to lowercase and split into words words = re.findall(r'bw+b', text.lower()) # Filter out stop words filtered_words = [word for word in words if word not in stop_words] # Count the occurrences of each word word_counts = Counter(filtered_words) if not word_counts: return [] # Find the maximum frequency max_count = max(word_counts.values()) # Extract the most frequent words most_frequent = [(word, count) for word, count in word_counts.items() if count == max_count] return most_frequent"},{"question":"class Book: def __init__(self, identifier, title, author, publication_year): Initialize a new book. Args: identifier (int): Unique identifier for the book. title (str): Title of the book. author (str): Author of the book. publication_year (int): Publication year of the book. self.identifier = identifier self.title = title self.author = author self.publication_year = publication_year class Library: def __init__(self): Initialize a new library collection. self.books = {} def add_book(self, book): Add a new book to the collection. Args: book (Book): The book to add. Returns: str: Success or error message. def remove_book(self, identifier): Remove a book from the collection using its unique identifier. Args: identifier (int): Unique identifier of the book to remove. Returns: str: Success or error message. def search_books(self, search_term, search_type): Search for books by title, author, or publication year. Args: search_term (str): The term to search for. search_type (str): Type of search (title, author, publication_year). Returns: list: List of matching books. def show_books(self, sort_by='title', descending=False): Show all books in the collection sorted by a given attribute. Args: sort_by (str): Attribute to sort by ('title', 'author', 'publication_year'). descending (bool): Sort order, ascending or descending. Returns: list: List of sorted books. def total_books(self): Compute the total number of books in the collection. Returns: int: Total number of books. def average_publication_year(self): Calculate the average publication year of the books in the collection. Returns: float: Average publication year. # Unit tests def test_add_book(): library = Library() book = Book(1, \\"Test Title\\", \\"Test Author\\", 2020) assert library.add_book(book) == \\"Book added successfully.\\" assert library.add_book(book) == \\"Error: Book with the same unique identifier already exists.\\" def test_remove_book(): library = Library() book = Book(1, \\"Test Title\\", \\"Test Author\\", 2020) library.add_book(book) assert library.remove_book(1) == \\"Book removed successfully.\\" assert library.remove_book(1) == \\"Error: No such book exists.\\" def test_search_books(): library = Library() book1 = Book(1, \\"Python Programming\\", \\"John Doe\\", 2020) book2 = Book(2, \\"Data Science\\", \\"Jane Doe\\", 2019) library.add_book(book1) library.add_book(book2) result = library.search_books(\\"Python\\", \\"title\\") assert len(result) == 1 assert result[0].title == \\"Python Programming\\" result = library.search_books(\\"Doe\\", \\"author\\") assert len(result) == 2 result = library.search_books(\\"2019\\", \\"publication_year\\") assert len(result) == 1 assert result[0].title == \\"Data Science\\" def test_show_books(): library = Library() book1 = Book(1, \\"Python Programming\\", \\"John Doe\\", 2020) book2 = Book(2, \\"Advanced Python\\", \\"Jane Doe\\", 2019) book3 = Book(3, \\"Data Science\\", \\"Alice\\", 2021) library.add_book(book1) library.add_book(book2) library.add_book(book3) sorted_books = library.show_books(sort_by='title') titles = [book.title for book in sorted_books] assert titles == [\\"Advanced Python\\", \\"Data Science\\", \\"Python Programming\\"] sorted_books = library.show_books(sort_by='author', descending=True) authors = [book.author for book in sorted_books] assert authors == [\\"John Doe\\", \\"Jane Doe\\", \\"Alice\\"] def test_total_books(): library = Library() assert library.total_books() == 0 book = Book(1, \\"Test Title\\", \\"Test Author\\", 2020) library.add_book(book) assert library.total_books() == 1 def test_average_publication_year(): library = Library() assert library.average_publication_year() == 0 book1 = Book(1, \\"Book One\\", \\"Author One\\", 2020) book2 = Book(2, \\"Book Two\\", \\"Author Two\\", 2010) library.add_book(book1) library.add_book(book2) assert library.average_publication_year() == 2015","solution":"class Book: def __init__(self, identifier, title, author, publication_year): self.identifier = identifier self.title = title self.author = author self.publication_year = publication_year class Library: def __init__(self): self.books = {} def add_book(self, book): if book.identifier in self.books: return \\"Error: Book with the same unique identifier already exists.\\" self.books[book.identifier] = book return \\"Book added successfully.\\" def remove_book(self, identifier): if identifier not in self.books: return \\"Error: No such book exists.\\" del self.books[identifier] return \\"Book removed successfully.\\" def search_books(self, search_term, search_type): search_term = search_term.lower() result = [] for book in self.books.values(): if search_type == 'title' and search_term in book.title.lower(): result.append(book) elif search_type == 'author' and search_term in book.author.lower(): result.append(book) elif search_type == 'publication_year' and search_term == str(book.publication_year): result.append(book) return result def show_books(self, sort_by='title', descending=False): sorted_books = sorted(self.books.values(), key=lambda x: getattr(x, sort_by), reverse=descending) return sorted_books def total_books(self): return len(self.books) def average_publication_year(self): if not self.books: return 0 total_years = sum(book.publication_year for book in self.books.values()) return total_years / len(self.books) library = Library()"},{"question":"def balanced_parentheses(s: str) -> bool: Determines if the given string of parentheses is valid. The input string contains only the characters '(', ')', '{', '}', '[' and ']'. An input string is valid if: 1. Open brackets are closed by the same type of brackets. 2. Open brackets are closed in the correct order. 3. Every close bracket has a corresponding open bracket of the same type. >>> balanced_parentheses(\\"{[()]}\\") True >>> balanced_parentheses(\\"([)]\\") False >>> balanced_parentheses(\\"{[]}\\") True >>> balanced_parentheses(\\"{[}\\") False >>> balanced_parentheses(\\"{[(([]))]}\\") True","solution":"def balanced_parentheses(s: str) -> bool: Determines if the given string of parentheses is valid. stack = [] mapping = {')': '(', '}': '{', ']': '['} for char in s: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def evaluate_expression(expression: str) -> int: Write a Python function that takes a string representing a mathematical expression containing only non-negative integers, the plus sign (+), and the minus sign (-). The function should evaluate the expression and return the result as an integer. The function should handle multiple consecutive operations and whitespace correctly. >>> evaluate_expression(\\"2 + 3\\") == 5 >>> evaluate_expression(\\"10 - 4\\") == 6 >>> evaluate_expression(\\"2 + 3 - 4 + 5\\") == 6 >>> evaluate_expression(\\"2+3-4+5-1+6-7\\") == 4 >>> evaluate_expression(\\" 2 + 3 - 4 + 5 \\") == 6 >>> evaluate_expression(\\"5\\") == 5 >>> evaluate_expression(\\"123 + 456 - 789 + 1011\\") == 801","solution":"def evaluate_expression(expression): Takes a string representing a mathematical expression containing only non-negative integers, the plus sign (+), and the minus sign (-). Evaluates the expression and returns the result as an integer. # Remove any whitespace from the expression expression = expression.replace(\\" \\", \\"\\") # Initialize variables for the result and the current number result = 0 current_number = 0 sign = 1 # Iterate through the characters of the expression for char in expression: if char.isdigit(): current_number = current_number * 10 + int(char) else: # If we encounter an operator, add the current number to the result # then update the sign for the next number result += sign * current_number current_number = 0 if char == '+': sign = 1 elif char == '-': sign = -1 # Add the last number in the expression result += sign * current_number return result"},{"question":"import json from typing import Dict, Any def process_employee_data(json_string: str) -> Dict[str, Any]: Create a function that takes a JSON string representing employee data and processes it to calculate metrics for each department. The JSON string contains an array of objects, where each object represents an employee with the following fields: \`name\` (string), \`age\` (integer), \`department\` (string), \`salary\` (float), \`years_of_experience\` (integer), and \`is_manager\` (boolean). Parameters: json_string (str): JSON string representing employee data. Returns: dict: A dictionary where the keys are the department names, and the values are dictionaries containing the calculated metrics. Raises: ValueError: If a field is missing from an employee object. TypeError: If a field contains a value that cannot be converted to the required type. The function should handle erroneous data gracefully and also handle an empty array gracefully by returning an empty dictionary. Example: >>> process_employee_data('[]') {} >>> process_employee_data('[{\\"name\\": \\"Alice\\", \\"age\\": thirty, \\"department\\": \\"HR\\", \\"salary\\": 50000, \\"years_of_experience\\": 5, \\"is_manager\\": false}]') ... TypeError: Incorrect field type in employee data for Alice: invalid literal for int() with base 10: 'thirty'","solution":"import json def process_employee_data(json_string): employees = json.loads(json_string) if not employees: return {} departments = {} for emp in employees: if not all(k in emp for k in (\\"name\\", \\"age\\", \\"department\\", \\"salary\\", \\"years_of_experience\\", \\"is_manager\\")): raise ValueError(f\\"Missing fields in employee data for {emp.get('name', 'unknown name')}\\") try: age = int(emp[\\"age\\"]) salary = float(emp[\\"salary\\"]) years_of_experience = int(emp[\\"years_of_experience\\"]) is_manager = bool(emp[\\"is_manager\\"]) except ValueError as e: raise TypeError(f\\"Incorrect field type in employee data for {emp['name']}: {e}\\") dept = emp[\\"department\\"] if dept not in departments: departments[dept] = { 'total_salary': 0.0, 'total_age': 0, 'num_employees': 0, 'num_managers': 0, 'total_years_of_experience': 0, 'max_salary': 0.0 } departments[dept]['total_salary'] += salary departments[dept]['total_age'] += age departments[dept]['num_employees'] += 1 if is_manager: departments[dept]['num_managers'] += 1 departments[dept]['total_years_of_experience'] += years_of_experience if salary > departments[dept]['max_salary']: departments[dept]['max_salary'] = salary for dept in departments: departments[dept]['average_salary'] = departments[dept]['total_salary'] / departments[dept]['num_employees'] departments[dept]['average_age'] = departments[dept]['total_age'] / departments[dept]['num_employees'] departments[dept]['average_years_of_experience'] = departments[dept]['total_years_of_experience'] / departments[dept]['num_employees'] # Remove intermediate data we used for calculation del departments[dept]['total_salary'] del departments[dept]['total_age'] del departments[dept]['total_years_of_experience'] return departments"},{"question":"def first_non_repeated_character(s: str) -> str: Returns the first non-repeated character in a given string s. If no such character exists, returns an empty string. >>> first_non_repeated_character(\\"a\\") == \\"a\\" >>> first_non_repeated_character(\\"aabbcc\\") == \\"\\" >>> first_non_repeated_character(\\"abacabad\\") == \\"c\\" >>> first_non_repeated_character(\\"aabbccddeeffg\\") == \\"g\\" >>> first_non_repeated_character(\\"\\") == \\"\\" >>> first_non_repeated_character(\\"abcdef\\") == \\"a\\" >>> first_non_repeated_character(\\"abacb\\") == \\"c\\"","solution":"def first_non_repeated_character(s): Returns the first non-repeated character in a given string s. If no such character exists, returns an empty string. # Dictionary to store character counts char_count = {} # First pass to count occurrences for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass to find the first non-repeated character for char in s: if char_count[char] == 1: return char return \\"\\" # Time complexity: O(n) - where n is the length of the string"},{"question":"from typing import List def filter_and_reverse_evens(nums: List[int]) -> List[int]: Returns a list of even numbers in reverse order from the input list of integers. >>> filter_and_reverse_evens([2, 4, 6, 8]) [8, 6, 4, 2] >>> filter_and_reverse_evens([1, 2, 3, 4, 5, 6]) [6, 4, 2] >>> filter_and_reverse_evens([1, 3, 5, 7]) [] >>> filter_and_reverse_evens([]) [] >>> filter_and_reverse_evens([2]) [2] >>> filter_and_reverse_evens([3]) [] >>> filter_and_reverse_evens([1, -2, 3, -4, 5, -6]) [-6, -4, -2] >>> filter_and_reverse_evens([-1, -2, 3, 4, -5, 6]) [6, 4, -2] pass","solution":"from typing import List def filter_and_reverse_evens(nums: List[int]) -> List[int]: Returns a list of even numbers in reverse order from the input list of integers. evens = [num for num in nums if num % 2 == 0] return evens[::-1]"},{"question":"def max_subarray_sum(nums: List[int]) -> Tuple[int, int, int]: Returns the sum, starting index, and ending index of the contiguous subarray with the largest sum. :param nums: List of integers :return: Tuple containing the largest sum, start index, and end index >>> max_subarray_sum([1]) (1, 0, 0) >>> max_subarray_sum([-1]) (-1, 0, 0) >>> max_subarray_sum([1, 2, 3, 4, 5]) (15, 0, 4) >>> max_subarray_sum([-1, -2, -3, -4]) (-1, 0, 0) >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) (6, 3, 6) >>> max_subarray_sum([]) (0, -1, -1) >>> max_subarray_sum([1, -2, 3, 10, -4, 7, 2, -5]) (18, 2, 6) >>> max_subarray_sum([-1, -2, 3, 4, -5, 9]) (11, 2, 5) >>> max_subarray_sum([-1, 2, 4, -3, 5, 2]) (10, 1, 5) >>> max_subarray_sum([3, -1, 4, -1, 5, -13]) (10, 0, 4)","solution":"def max_subarray_sum(nums): Returns the sum, starting index, and ending index of the contiguous subarray with the largest sum. :param nums: List of integers :return: Tuple containing the largest sum, start index, and end index if not nums: return 0, -1, -1 # In case of empty list max_sum = current_sum = nums[0] start = end = s = 0 for i in range(1, len(nums)): if nums[i] > current_sum + nums[i]: current_sum = nums[i] s = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start = s end = i return max_sum, start, end"},{"question":"from typing import List def find_subsets(integers: List[int]) -> List[List[int]]: Given a list of unique integers, find all the possible subsets of the list. Each subset should be sorted in ascending order, and the subsets themselves should also be arranged in ascending order based on their lexicographic order. :param integers: List of unique integers :return: List of subsets sorted as described >>> find_subsets([1, 2, 3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> find_subsets([5]) [[], [5]] >>> find_subsets([1, 2]) [[], [1], [2], [1, 2]] >>> find_subsets([]) [[]] >>> find_subsets([3, 1, 2]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]","solution":"from itertools import combinations def find_subsets(integers): Given a list of unique integers, find all the possible subsets of the list. Each subset should be sorted in ascending order, and the subsets themselves should also be arranged in ascending order based on their lexicographic order. :param integers: List of unique integers :return: List of subsets sorted as described integers.sort() subsets = [] for i in range(len(integers) + 1): for combo in combinations(integers, i): subsets.append(list(combo)) return subsets"},{"question":"from typing import List, Tuple import math def has_pair_with_distance(points: List[Tuple[int, int]], d: int) -> bool: Determines if there are any two points with a distance of exactly d units. >>> has_pair_with_distance([(0, 0), (3, 4), (6, 8)], 5) True >>> has_pair_with_distance([(0, 0), (1, 1), (2, 2)], 3) False >>> has_pair_with_distance([(0, 0), (1, 1), (4, 5)], 5) True","solution":"from typing import List, Tuple import math def has_pair_with_distance(points: List[Tuple[int, int]], d: int) -> bool: Determines if there are any two points with a distance of exactly d units. n = len(points) for i in range(n): for j in range(i + 1, n): # Calculate the distance between points[i] and points[j] dist = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) if dist == d: return True return False"},{"question":"class InvalidInputException(Exception): pass def is_prime(n: int) -> bool: Check if a number is prime. pass def sort_misplaced_primes(input_list: list) -> list: This function takes a list of integers and returns the list sorted in ascending order with all prime numbers positioned at the end of the list. >>> sort_misplaced_primes([10, 3, 5, 7, 2, 1]) == [1, 10, 3, 5, 7, 2] >>> sort_misplaced_primes([14, 3, 2, 9, 10]) == [9, 10, 14, 3, 2] pass def test_sort_simple_case(): assert sort_misplaced_primes([10, 3, 5, 7, 2, 1]) == [1, 10, 3, 5, 7, 2] def test_sort_with_only_non_primes(): assert sort_misplaced_primes([8, 10, 4, 1]) == [1, 4, 8, 10] def test_sort_with_only_primes(): assert sort_misplaced_primes([3, 5, 7, 2]) == [3, 5, 7, 2] def test_sort_with_mixed_primes_and_non_primes(): assert sort_misplaced_primes([14, 3, 2, 9, 10]) == [9, 10, 14, 3, 2] def test_sort_with_zero_and_negative_numbers(): assert sort_misplaced_primes([0, -1, -2, 5]) == [-2, -1, 0, 5] def test_sort_empty_list(): assert sort_misplaced_primes([]) == [] def test_invalid_input_not_a_list(): try: sort_misplaced_primes(\\"10, 3, 5\\") except InvalidInputException as e: assert str(e) == \\"Input should be a list.\\" def test_invalid_input_non_integer_elements(): try: sort_misplaced_primes([10, 3, '5', 7]) except InvalidInputException as e: assert str(e) == \\"All elements in the list should be integers.\\"","solution":"class InvalidInputException(Exception): pass def is_prime(n): Check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def sort_misplaced_primes(input_list): This function takes a list of integers and returns the list sorted in ascending order with all prime numbers positioned at the end of the list. if not isinstance(input_list, list): raise InvalidInputException(\\"Input should be a list.\\") if not all(isinstance(i, int) for i in input_list): raise InvalidInputException(\\"All elements in the list should be integers.\\") non_primes = sorted([x for x in input_list if not is_prime(x)]) primes = [x for x in input_list if is_prime(x)] return non_primes + primes"},{"question":"def square_elements(input_list: List[int]) -> List[int]: Returns a list where each element is the square of the corresponding element in the input list. >>> square_elements([1, 2, 3]) [1, 4, 9] >>> square_elements([0, 4, 5]) [0, 16, 25] >>> square_elements([-1, -2, -3]) [1, 4, 9] >>> square_elements([-1, 2, -3, 4]) [1, 4, 9, 16] >>> square_elements([]) [] :param input_list: List of integers :return: List of integers where each element is squared","solution":"def square_elements(input_list): Returns a list with each element being the square of the corresponding element in input_list. :param input_list: List of integers :return: List of integers where each element is squared return [x * x for x in input_list]"},{"question":"def calculate_sum(expression: str) -> int: Parses a string representing a mathematical addition expression and returns the sum. Parameters: expression (str): The string containing the addition expression (e.g., \\"3+25+7+40\\") Returns: int: The sum of all the integers in the expression >>> calculate_sum(\\"1+2+3\\") == 6 >>> calculate_sum(\\"10+20+30\\") == 60 >>> calculate_sum(\\"3+25+7+40\\") == 75 >>> calculate_sum(\\"1000+2000+3000\\") == 6000 >>> calculate_sum(\\"0+0+0\\") == 0 >>> calculate_sum(\\"0+5+10+0\\") == 15","solution":"def calculate_sum(expression): Parses a string representing a mathematical addition expression and returns the sum. Parameters: expression (str): The string containing the addition expression (e.g., \\"3+25+7+40\\") Returns: int: The sum of all the integers in the expression # Split the expression by the plus signs and convert the parts to integers numbers = map(int, expression.split('+')) # Return the sum of the integers return sum(numbers)"},{"question":"def sum_adjacent_pairs(numbers: List[int]) -> List[int]: Returns a new list that contains the sum of every adjacent pair of integers in the original list. If the input list is empty or contains only one integer, return an empty list. Time Complexity: O(n), where n is the length of the input list. >>> sum_adjacent_pairs([]) [] >>> sum_adjacent_pairs([1]) [] >>> sum_adjacent_pairs([1, 2]) [3] >>> sum_adjacent_pairs([1, 2, 3, 4]) [3, 5, 7] >>> sum_adjacent_pairs([-1, -2, -3, -4]) [-3, -5, -7] >>> sum_adjacent_pairs([1, -2, 3, -4]) [-1, 1, -1]","solution":"def sum_adjacent_pairs(numbers): Returns a new list that contains the sum of every adjacent pair of integers in the original list. If the input list is empty or contains only one integer, return an empty list. Time Complexity: O(n), where n is the length of the input list. if len(numbers) < 2: return [] result = [numbers[i] + numbers[i + 1] for i in range(len(numbers) - 1)] return result"},{"question":"def sort_letters_keep_numbers(input_str: str) -> str: Sorts the letters alphabetically while keeping the numbers in their original positions. >>> sort_letters_keep_numbers(\\"hello\\") 'ehllo' >>> sort_letters_keep_numbers(\\"12345\\") '12345' >>> sort_letters_keep_numbers(\\"4h3e5l2l1o\\") '4e3h5l2l1o' >>> sort_letters_keep_numbers(\\"\\") '' >>> sort_letters_keep_numbers(\\"h e l l o\\") 'e h l l o' >>> sort_letters_keep_numbers(\\"4 h 3 e 5 l 2 l 1 o\\") '4 e 3 h 5 l 2 l 1 o' >>> sort_letters_keep_numbers(\\"4h3!e5@l2#l1o\\") '4e3!h5@l2#l1o' >>> sort_letters_keep_numbers(\\"a1z2b3y4c5x\\") 'a1b2c3x4y5z' pass","solution":"def sort_letters_keep_numbers(input_str): Sorts the letters alphabetically while keeping the numbers in their original positions. Parameters: input_str (str): The input string containing both letters and numbers. Returns: str: A string with letters sorted alphabetically and numbers in their original positions. letters = sorted([char for char in input_str if char.isalpha()]) result = list(input_str) letter_index = 0 for i, char in enumerate(input_str): if char.isalpha(): result[i] = letters[letter_index] letter_index += 1 return ''.join(result)"},{"question":"class EmployeeDatabase: A class to manage an employee database. It allows adding, updating, deleting, and displaying employee records. def __init__(self): Initialize the database with an empty dictionary. self.database = {} def add_employee(self, emp_id: int, name: str, position: str, salary: float) -> str: Add a new employee to the database. Args: emp_id (int): Employee ID name (str): Employee name position (str): Employee position salary (float): Employee salary Returns: str: Result message # Code to add an employee def update_employee(self, emp_id: int, name: str = None, position: str = None, salary: float = None) -> str: Update employee details in the database. Args: emp_id (int): Employee ID name (str): Updated employee name position (str): Updated employee position salary (float): Updated employee salary Returns: str: Result message # Code to update an employee def delete_employee(self, emp_id: int) -> str: Delete an employee from the database by ID. Args: emp_id (int): Employee ID Returns: str: Result message # Code to delete an employee def display_employees(self) -> dict: Display all employee records. Returns: dict: A dictionary of all employee records # Code to display all employees Test cases: def test_add_employee(): db = EmployeeDatabase() result = db.add_employee(1, \\"John Doe\\", \\"Developer\\", 60000) assert result == \\"Employee added successfully.\\" assert db.database == {1: {\\"name\\": \\"John Doe\\", \\"position\\": \\"Developer\\", \\"salary\\": 60000}} result = db.add_employee(1, \\"Jane Smith\\", \\"Manager\\", 80000) assert result == \\"Employee ID already exists.\\" assert len(db.database) == 1 def test_update_employee(): db = EmployeeDatabase() db.add_employee(1, \\"John Doe\\", \\"Developer\\", 60000) result = db.update_employee(2, \\"Jane Smith\\", \\"Manager\\", 80000) assert result == \\"Employee not found.\\" result = db.update_employee(1, \\"John Smith\\", \\"Senior Developer\\", 70000) assert result == \\"Employee details updated successfully.\\" assert db.database[1] == {\\"name\\": \\"John Smith\\", \\"position\\": \\"Senior Developer\\", \\"salary\\": 70000} def test_delete_employee(): db = EmployeeDatabase() db.add_employee(1, \\"John Doe\\", \\"Developer\\", 60000) result = db.delete_employee(2) assert result == \\"Employee not found.\\" result = db.delete_employee(1) assert result == \\"Employee deleted successfully.\\" assert len(db.database) == 0 def test_display_employees(): db = EmployeeDatabase() assert db.display_employees() == {} db.add_employee(1, \\"John Doe\\", \\"Developer\\", 60000) db.add_employee(2, \\"Jane Smith\\", \\"Manager\\", 80000) assert db.display_employees() == { 1: {\\"name\\": \\"John Doe\\", \\"position\\": \\"Developer\\", \\"salary\\": 60000}, 2: {\\"name\\": \\"Jane Smith\\", \\"position\\": \\"Manager\\", \\"salary\\": 80000} }","solution":"class EmployeeDatabase: def __init__(self): self.database = {} def add_employee(self, emp_id, name, position, salary): if emp_id in self.database: return \\"Employee ID already exists.\\" self.database[emp_id] = {\\"name\\": name, \\"position\\": position, \\"salary\\": salary} return \\"Employee added successfully.\\" def update_employee(self, emp_id, name=None, position=None, salary=None): if emp_id not in self.database: return \\"Employee not found.\\" if name: self.database[emp_id][\\"name\\"] = name if position: self.database[emp_id][\\"position\\"] = position if salary: self.database[emp_id][\\"salary\\"] = salary return \\"Employee details updated successfully.\\" def delete_employee(self, emp_id): if emp_id not in self.database: return \\"Employee not found.\\" del self.database[emp_id] return \\"Employee deleted successfully.\\" def display_employees(self): return self.database"},{"question":"def is_pangram(sentence: str) -> bool: Determines if a given sentence is a pangram. A pangram is a sentence that contains every letter of the alphabet at least once. Args: sentence (str): The sentence to be checked. Returns: bool: True if the sentence is a pangram, False otherwise. >>> is_pangram('The quick brown fox jumps over the lazy dog.') True >>> is_pangram('The Quick Brown FoX JumpS Over The Lazy DOG') True >>> is_pangram('1234567890! The quick, brown fox; jumps: over the lazy dog...') True >>> is_pangram('The quick brown fox jumps over the lahjskdwpery') False >>> is_pangram('') False >>> is_pangram('!@#%^&*()') False >>> is_pangram('ABCDEFGHIJKLMNOPQRSTUVWXYZ') True >>> is_pangram('Hello, world!') False >>> is_pangram('@# #% 1235467890 The quick brown fox jumps over the lazy dog!@#') True","solution":"import string def is_pangram(sentence): Determines if a given sentence is a pangram. A pangram is a sentence that contains every letter of the alphabet at least once. Args: sentence (str): The sentence to be checked. Returns: bool: True if the sentence is a pangram, False otherwise. alphabet = set(string.ascii_lowercase) sentence_letters = set(c.lower() for c in sentence if c.isalpha()) return alphabet.issubset(sentence_letters)"},{"question":"class BankAccount: A class representing a bank account. def __init__(self, account_number, holder_name, balance=0.0): self.account_number = account_number self.holder_name = holder_name self.balance = balance def deposit(self, amount): Deposit the given amount into the bank account. >>> acc = BankAccount(\\"123\\", \\"John Doe\\") >>> acc.deposit(100) >>> acc.check_balance() == 100 True >>> acc.deposit(-50) Traceback (most recent call last): ... ValueError: Deposit amount must be positive pass def withdraw(self, amount): Withdraw the given amount from the bank account. >>> acc = BankAccount(\\"123\\", \\"John Doe\\", 100) >>> acc.withdraw(50) >>> acc.check_balance() == 50 True >>> acc.withdraw(-50) Traceback (most recent call last): ... ValueError: Withdrawal amount must be positive >>> acc.withdraw(200) Traceback (most recent call last): ... ValueError: Insufficient funds pass def check_balance(self): Check the current balance of the bank account. >>> acc = BankAccount(\\"123\\", \\"John Doe\\", 100) >>> acc.check_balance() 100 pass def transfer(self, amount, target_account): Transfer the given amount to the target bank account. >>> acc1 = BankAccount(\\"123\\", \\"John Doe\\", 100) >>> acc2 = BankAccount(\\"456\\", \\"Jane Roe\\") >>> acc1.transfer(50, acc2) >>> acc1.check_balance() 50 >>> acc2.check_balance() 50 >>> acc1.transfer(100, acc2) Traceback (most recent call last): ... ValueError: Insufficient funds >>> acc1.transfer(50, \\"not a bank account\\") Traceback (most recent call last): ... ValueError: Target account must be a BankAccount instance pass","solution":"class BankAccount: A class representing a bank account. def __init__(self, account_number, holder_name, balance=0.0): self.account_number = account_number self.holder_name = holder_name self.balance = balance def deposit(self, amount): if amount <= 0: raise ValueError(\\"Deposit amount must be positive\\") self.balance += amount def withdraw(self, amount): if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive\\") if amount > self.balance: raise ValueError(\\"Insufficient funds\\") self.balance -= amount def check_balance(self): return self.balance def transfer(self, amount, target_account): if not isinstance(target_account, BankAccount): raise ValueError(\\"Target account must be a BankAccount instance\\") self.withdraw(amount) target_account.deposit(amount)"},{"question":"from collections import deque # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root): Returns the level order traversal of node values of a binary tree. Parameters: root (TreeNode): The root of the binary tree. Returns: List[List[int]]: The level order traversal where each inner list represents one level of the tree. Example: >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> levelOrder(root) [[3], [9, 20], [15, 7]] >>> root = TreeNode(1) >>> levelOrder(root) [[1]] >>> levelOrder(None) []","solution":"from collections import deque # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root): Returns the level order traversal of node values of a binary tree. result = [] if not root: return result queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"class Inventory: A class to simulate an inventory management system for a small shop. def __init__(self): Initialize the inventory with an empty dictionary. pass def add_item(self, item: str, quantity: int) -> None: Add a new item to the inventory with a given initial quantity. If the item already exists, update the quantity by adding the new quantity to the existing quantity. The inventory is case-insensitive. Args: item (str): The name of the item to add. quantity (int): The quantity of the item to add. >>> inventory = Inventory() >>> inventory.add_item(\\"apple\\", 10) >>> inventory.add_item(\\"Apple\\", 5) >>> inventory.check_inventory(\\"APPLE\\") == 15 True pass def remove_item(self, item: str, quantity: int) -> None: Remove a specified quantity of an item from the inventory. Ensure the quantity to be removed does not exceed the quantity on hand. If it does, adjust the quantity to zero. The inventory is case-insensitive. Args: item (str): The name of the item to remove. quantity (int): The quantity of the item to remove. >>> inventory = Inventory() >>> inventory.add_item(\\"banana\\", 8) >>> inventory.remove_item(\\"banana\\", 3) >>> inventory.check_inventory(\\"banana\\") == 5 True pass def check_inventory(self, item: str) -> int: Return the current quantity of a specified item. If the item does not exist, return -1. The inventory is case-insensitive. Args: item (str): The name of the item to check. Returns: int: The quantity of the item or -1 if item does not exist. >>> inventory = Inventory() >>> inventory.check_inventory(\\"orange\\") == -1 True pass","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, item: str, quantity: int) -> None: item_lower = item.lower() if item_lower in self.items: self.items[item_lower] += quantity else: self.items[item_lower] = quantity def remove_item(self, item: str, quantity: int) -> None: item_lower = item.lower() if item_lower in self.items: if self.items[item_lower] > quantity: self.items[item_lower] -= quantity else: self.items[item_lower] = 0 def check_inventory(self, item: str) -> int: item_lower = item.lower() return self.items.get(item_lower, -1)"},{"question":"import pandas as pd import numpy as np from sklearn.model_selection import train_test_split from sklearn.metrics import mean_squared_error from scipy.sparse.linalg import svds def load_data(file_path): Loads the dataset from a given file path. return pd.read_csv(file_path) def preprocess_data(data): Preprocess data to create user-item interaction matrix. user_item_matrix = data.pivot(index='user_id', columns='item_id', values='interaction').fillna(0) return user_item_matrix def perform_svd(user_item_matrix, k): Perform Singular Value Decomposition (SVD) on the user-item matrix. R = user_item_matrix.values user_ratings_mean = np.mean(R, axis=1) R_demeaned = R - user_ratings_mean.reshape(-1, 1) U, sigma, Vt = svds(R_demeaned, k=k) sigma = np.diag(sigma) predicted_ratings = np.dot(np.dot(U, sigma), Vt) + user_ratings_mean.reshape(-1, 1) return pd.DataFrame(predicted_ratings, columns=user_item_matrix.columns) def recommend_items(predictions, user_id, user_item_matrix, num_recommendations): Recommend items for a specific user based on predicted ratings. user_row_number = user_id - 1 sorted_user_predictions = predictions.iloc[user_row_number].sort_values(ascending=False) user_data = user_item_matrix.loc[user_id] known_items = user_data[user_data > 0].index.tolist() recommendations = sorted_user_predictions.drop(known_items).index[:num_recommendations] return recommendations.tolist() def evaluate_rmse(y_true, y_pred): Evaluates the RMSE between true ratings and predicted ratings. return mean_squared_error(y_true, y_pred, squared=False)","solution":"import pandas as pd import numpy as np from sklearn.model_selection import train_test_split from sklearn.metrics import mean_squared_error from scipy.sparse.linalg import svds def load_data(file_path): Loads the dataset from a given file path. return pd.read_csv(file_path) def preprocess_data(data): Preprocess data to create user-item interaction matrix. user_item_matrix = data.pivot(index='user_id', columns='item_id', values='interaction').fillna(0) return user_item_matrix def perform_svd(user_item_matrix, k): Perform Singular Value Decomposition (SVD) on the user-item matrix. R = user_item_matrix.values user_ratings_mean = np.mean(R, axis=1) R_demeaned = R - user_ratings_mean.reshape(-1, 1) U, sigma, Vt = svds(R_demeaned, k=k) sigma = np.diag(sigma) predicted_ratings = np.dot(np.dot(U, sigma), Vt) + user_ratings_mean.reshape(-1, 1) return pd.DataFrame(predicted_ratings, columns=user_item_matrix.columns) def recommend_items(predictions, user_id, user_item_matrix, num_recommendations): Recommend items for a specific user based on predicted ratings. user_row_number = user_id - 1 sorted_user_predictions = predictions.iloc[user_row_number].sort_values(ascending=False) user_data = user_item_matrix.loc[user_id] known_items = user_data[user_data > 0].index.tolist() recommendations = sorted_user_predictions.drop(known_items).index[:num_recommendations] return recommendations.tolist() def evaluate_rmse(y_true, y_pred): Evaluates the RMSE between true ratings and predicted ratings. return mean_squared_error(y_true, y_pred, squared=False) # Example main program if __name__ == \\"__main__\\": file_path = \\"user_item_interactions.csv\\" data = load_data(file_path) user_item_matrix = preprocess_data(data) k = 50 # Number of latent features predicted_ratings = perform_svd(user_item_matrix, k) user_id_to_recommend = 1 recommendations = recommend_items(predicted_ratings, user_id_to_recommend, user_item_matrix, 5) print(f\\"Top 5 recommendations for user {user_id_to_recommend}: {recommendations}\\")"},{"question":"def calculate_total_cost(item_costs): Calculate the total cost including a 15% sales tax for a list of items. Parameters: item_costs (list of float): List containing the cost of each item. Returns: float: The total cost including sales tax. # Write your implementation here # Example usage: items = [12.99, 23.45, 9.99, 5.49, 3.00] total = calculate_total_cost(items) print(\\"The total cost of the items is:\\", total) # Unit tests def test_calculate_total_cost_no_items(): assert calculate_total_cost([]) == 0.00 def test_calculate_total_cost_single_item(): assert calculate_total_cost([10.00]) == round(10.00 * 1.15, 2) def test_calculate_total_cost_multiple_items(): assert calculate_total_cost([12.99, 23.45, 9.99, 5.49, 3.00]) == round((12.99 + 23.45 + 9.99 + 5.49 + 3.00) * 1.15, 2) def test_calculate_total_cost_with_high_precision(): assert calculate_total_cost([10.987, 20.987]) == round((10.987 + 20.987) * 1.15, 2)","solution":"def calculate_total_cost(item_costs): Calculate the total cost including a 15% sales tax for a list of items. Parameters: item_costs (list of float): List containing the cost of each item. Returns: float: The total cost including sales tax. sales_tax_rate = 0.15 total_cost = sum(item_costs) * (1 + sales_tax_rate) return round(total_cost, 2) # Example usage: items = [12.99, 23.45, 9.99, 5.49, 3.00] total = calculate_total_cost(items) print(\\"The total cost of the items is:\\", total)"},{"question":"def reverse_words(sentence: str) -> str: Reverse the words in a given sentence. >>> reverse_words(\\"Hello world! Welcome to the coding assessment.\\") == \\"assessment. coding the to Welcome world! Hello\\" >>> reverse_words(\\"\\") == \\"\\" >>> reverse_words(\\"Hello\\") == \\"Hello\\" >>> reverse_words(\\"Hello world\\") == \\"world Hello\\" >>> reverse_words(\\"This is a test\\") == \\"test a is This\\" >>> reverse_words(\\"How are you?\\") == \\"you? are How\\"","solution":"def reverse_words(sentence: str) -> str: if not sentence: return \\"\\" words = sentence.split() reversed_words = words[::-1] reversed_sentence = \\" \\".join(reversed_words) return reversed_sentence"},{"question":"class LibrarySystem: Library management system to track books and their availability, as well as manage user information and their borrowed books. def __init__(self): Initialize the library system. pass def add_book(self, title: str, author: str, copies: int) -> None: Add a new book along with its details. Args: title: The title of the book. author: The author of the book. copies: Number of copies of the book. pass def remove_book(self, title: str) -> None: Remove a book from the system. Args: title: The title of the book to be removed. pass def register_user(self, user_id: str, name: str) -> None: Register a new user with their details. Args: user_id: The user ID. name: The name of the user. pass def remove_user(self, user_id: str) -> None: Remove a user from the system. Args: user_id: The user ID to be removed. pass def checkout_book(self, user_id: str, title: str) -> None: Allow a user to check out a book. Args: user_id: The user ID checking out the book. title: The title of the book to check out. pass def return_book(self, user_id: str, title: str) -> None: Allow a user to return a book. Args: user_id: The user ID returning the book. title: The title of the book to return. pass def view_available_books(self) -> dict: View a list of all available books. pass def view_user_borrowed_books(self, user_id: str) -> list: View a list of books currently borrowed by a particular user. Args: user_id: The user ID whose borrowed books are to be viewed. pass","solution":"class LibrarySystem: def __init__(self): self.books = {} # Dictionary to store book details: title -> {'author': author_name, 'copies': num_of_copies} self.users = {} # Dictionary to store user details: user_id -> {'name': user_name, 'borrowed_books': []} def add_book(self, title, author, copies): if title in self.books: self.books[title]['copies'] += copies else: self.books[title] = {'author': author, 'copies': copies} def remove_book(self, title): if title in self.books: del self.books[title] else: raise ValueError(\\"Book not found in the system\\") def register_user(self, user_id, name): if user_id in self.users: raise ValueError(\\"User ID already exists\\") self.users[user_id] = {'name': name, 'borrowed_books': []} def remove_user(self, user_id): if user_id in self.users: del self.users[user_id] else: raise ValueError(\\"User ID not found in the system\\") def checkout_book(self, user_id, title): if user_id not in self.users: raise ValueError(\\"User ID not found in the system\\") if title not in self.books: raise ValueError(\\"Book not found in the system\\") if self.books[title]['copies'] <= 0: raise ValueError(\\"No copies of the book are available\\") self.books[title]['copies'] -= 1 self.users[user_id]['borrowed_books'].append(title) def return_book(self, user_id, title): if user_id not in self.users: raise ValueError(\\"User ID not found in the system\\") if title not in self.users[user_id]['borrowed_books']: raise ValueError(\\"This user did not borrow the specified book\\") self.books[title]['copies'] += 1 self.users[user_id]['borrowed_books'].remove(title) def view_available_books(self): return {title: details for title, details in self.books.items() if details['copies'] > 0} def view_user_borrowed_books(self, user_id): if user_id not in self.users: raise ValueError(\\"User ID not found in the system\\") return self.users[user_id]['borrowed_books']"},{"question":"from typing import List def unique_sorted_squares(numbers: List[int]) -> List[int]: Returns a sorted list of unique squares from the input list of integers. >>> unique_sorted_squares([2, -3, 2, 4]) [4, 9, 16] >>> unique_sorted_squares([0, 1, -1, 2, -2]) [0, 1, 4] >>> unique_sorted_squares([1, 1, 1, 1]) [1] >>> unique_sorted_squares([]) [] >>> unique_sorted_squares([-1, -2, -3]) [1, 4, 9] >>> unique_sorted_squares([2, -2, 0, 5, -5]) [0, 4, 25]","solution":"def unique_sorted_squares(numbers): Returns a sorted list of unique squares from the input list of integers. # Calculate the square of each number and put it in a set to remove duplicates squared_set = {num ** 2 for num in numbers} # Convert the set to a sorted list sorted_squares = sorted(squared_set) return sorted_squares"},{"question":"def calculate(expression: str) -> int: Takes a string containing mathematical operations (addition and subtraction) and calculates the result. Parameters: expression (str): A string with positive integers and operations \`+\` and \`-\` separated by spaces. Returns: int: The result of the calculation. >>> calculate(\\"3 + 5\\") 8 >>> calculate(\\"10 - 5\\") 5 >>> calculate(\\"3 + 5 - 2\\") 6 >>> calculate(\\"10 + 2 - 7 + 3\\") 8 >>> calculate(\\"20 - 5 + 2\\") 17 >>> calculate(\\"1000 + 2000 - 1500\\") 1500 >>> calculate(\\"1 + 2 + 3 + 4 - 5 + 6 - 7 + 8 - 9 + 10\\") 13 >>> calculate(\\"50 - 20 - 5 - 5\\") 20","solution":"def calculate(expression: str) -> int: Takes a string containing mathematical operations (addition and subtraction) and calculates the result. Parameters: expression (str): A string with positive integers and operations \`+\` and \`-\` separated by spaces. Returns: int: The result of the calculation. tokens = expression.split() result = int(tokens[0]) i = 1 while i < len(tokens): if tokens[i] == '+': result += int(tokens[i + 1]) elif tokens[i] == '-': result -= int(tokens[i + 1]) i += 2 return result"},{"question":"morse_code_dict = { '.-': 'A', '-...': 'B', '-.-.': 'C', '-..': 'D', '.': 'E', '..-.': 'F', '--.': 'G', '....': 'H', '..': 'I', '.---': 'J', '-.-': 'K', '.-..': 'L', '--': 'M', '-.': 'N', '---': 'O', '.--.': 'P', '--.-': 'Q', '.-.': 'R', '...': 'S', '-': 'T', '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X', '-.--': 'Y', '--..': 'Z' } def decodeMorse(morse_code: str) -> str: Decodes a Morse code string into an alphanumeric string. Parameters: morse_code (str): A string representing the Morse code. Returns: str: Decoded alphanumeric string. >>> decodeMorse(\\"... --- ...\\") 'SOS' >>> decodeMorse(\\"... --- ... .... . .-.. .--.\\") 'SOS HELP' >>> decodeMorse(\\".\\") 'E' >>> decodeMorse(\\"\\") '' >>> decodeMorse(\\"- .... .. ... .. ... .- .-.. --- -. --. -- . ... ... .- --. .\\") 'THIS IS A LONG MESSAGE'","solution":"morse_code_dict = { '.-': 'A', '-...': 'B', '-.-.': 'C', '-..': 'D', '.': 'E', '..-.': 'F', '--.': 'G', '....': 'H', '..': 'I', '.---': 'J', '-.-': 'K', '.-..': 'L', '--': 'M', '-.': 'N', '---': 'O', '.--.': 'P', '--.-': 'Q', '.-.': 'R', '...': 'S', '-': 'T', '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X', '-.--': 'Y', '--..': 'Z' } def decodeMorse(morse_code): Decodes a Morse code string into an alphanumeric string. Parameters: morse_code (str): A string representing the Morse code. Returns: str: Decoded alphanumeric string. words = morse_code.split(' ') decoded_message = [] for word in words: decoded_word = ''.join(morse_code_dict[letter] for letter in word.split()) decoded_message.append(decoded_word) return ' '.join(decoded_message)"},{"question":"def filter_unique_even_numbers(numbers): This function takes a list of numbers and returns a new list containing only unique even numbers. :param numbers: List of numbers (integers or floats) :return: List of unique even numbers pass # Below are the unit tests def test_empty_list(): assert filter_unique_even_numbers([]) == [] def test_all_odd_numbers(): assert filter_unique_even_numbers([1, 3, 5, 7, 9]) == [] def test_all_even_numbers(): assert filter_unique_even_numbers([2, 4, 6, 8, 2, 4]) == [2, 4, 6, 8] def test_mixed_numbers(): assert filter_unique_even_numbers([1, 2, 3, 4, 2, 5, 6, 6]) == [2, 4, 6] def test_non_numeric_values(): assert filter_unique_even_numbers([1, 2, 'a', 4, 'b', 6, 4]) == [2, 4, 6] def test_negative_numbers(): assert filter_unique_even_numbers([-2, -4, -2, 4, 6, -6]) == [-2, -4, 4, 6, -6] def test_floats(): assert filter_unique_even_numbers([2.0, 4.0, 6.0, 8.0, 2.0, 4.0]) == [2.0, 4.0, 6.0, 8.0] def test_integers_and_floats(): assert filter_unique_even_numbers([2, 4, 6.0, 8, 2.0, 4]) == [2, 4, 6.0, 8]","solution":"def filter_unique_even_numbers(numbers): This function takes a list of numbers and returns a new list containing only unique even numbers. :param numbers: List of numbers (integers or floats) :return: List of unique even numbers even_numbers = {} for number in numbers: if isinstance(number, (int, float)) and number % 2 == 0: even_numbers[number] = True return list(even_numbers.keys())"},{"question":"def append_frequency(s: str) -> str: Takes in a string s and returns the string with each character's frequency appended to it consecutively. >>> append_frequency(\\"apple\\") 'a1p1p2l1e1' >>> append_frequency(\\"aaaa\\") 'a1a2a3a4' >>> append_frequency(\\"\\") '' >>> append_frequency(\\"AaAa\\") 'A1a1A2a2' >>> append_frequency(\\"abac\\") 'a1b1a2c1'","solution":"def append_frequency(s): Takes in a string s and returns the string with each character's frequency appended to it consecutively. freq = {} result = [] for char in s: freq[char] = freq.get(char, 0) + 1 result.append(f\\"{char}{freq[char]}\\") return ''.join(result)"},{"question":"def three_longest_subsequences(arr): Given a list of integers, returns the lengths of the three longest consecutive subsequences of the same number. >>> three_longest_subsequences([1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 2, 2]) [4, 3, 2] >>> three_longest_subsequences([7, 7, 7, 1, 1, 3, 3, 8, 8, 8, 8]) [4, 3, 2] >>> three_longest_subsequences([5, 5, 5, 5, 5, 5]) [6] >>> three_longest_subsequences([]) [] >>> three_longest_subsequences([1]) [1] >>> three_longest_subsequences([1, 2, 3, 4, 5]) [1, 1, 1] >>> three_longest_subsequences([1, 1, 2, 2, 3, 3]) [2, 2, 2] >>> three_longest_subsequences([1, 1, 1, 2, 2, 3, 3, 3, 3, 4]) [4, 3, 2] >>> three_longest_subsequences([1, 1, 1, 1, 1, 1, 1]) [7] >>> three_longest_subsequences([2, 2, 2, 2, 1, 1, 1, 1, 1, 3, 4, 4]) [5, 4, 2]","solution":"def three_longest_subsequences(arr): Given a list of integers, returns the lengths of the three longest consecutive subsequences of the same number. if not arr: return [] subsequences = [] current_length = 1 # Iterate through the list and identify consecutive subsequences for i in range(1, len(arr)): if arr[i] == arr[i-1]: current_length += 1 else: subsequences.append(current_length) current_length = 1 # Append the last subsequence subsequences.append(current_length) # Sort subsequences by length in descending order subsequences.sort(reverse=True) # Return the lengths of the three longest subsequences return subsequences[:3]"},{"question":"def split_list(input_list, n): Splits the input list into sublists, each of length n. If the number of elements in the original list is not perfectly divisible by n, the last inner list may contain fewer than n elements. Input: - input_list: List of integers to be split. - n: Length of each sublist. Output: - List of sublists. Examples: >>> split_list([1, 2, 3, 4, 5, 6, 7], 3) [[1, 2, 3], [4, 5, 6], [7]] >>> split_list([1, 2, 3, 4], 2) [[1, 2], [3, 4]] >>> split_list([], 2) [] >>> split_list([1, 2, 3], 0) [] >>> split_list([1, 2, 3, 4, 5], -2) [] >>> split_list([1], 1) [[1]] >>> split_list([1], 2) [[1]] >>> split_list([1, 2, 3], 5) [[1, 2, 3]]","solution":"def split_list(input_list, n): Splits the input list into sublists, each of length n. :param input_list: List of integers to be split. :param n: Length of each sublist. :return: List of sublists. if n <= 0: return [] return [input_list[i:i+n] for i in range(0, len(input_list), n)]"},{"question":"def first_missing_positive(nums): Returns the smallest positive integer that does not appear in the list. Uses constant space and modifies the input list in-place. >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([]) 1","solution":"def first_missing_positive(nums): Returns the smallest positive integer that does not appear in the list. Uses constant space and modifies the input list in-place. n = len(nums) # Base case if n == 0: return 1 # First pass, place each number in its corresponding index position for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Second pass, find the first place where the index doesn't match the value for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def average_sales_on_date(transactions, target_date): Returns the average sales amount for transactions on the target_date. If no transactions on that date, return 0. :param transactions: List of tuples in the form (transaction_id, customer_id, date, amount) :param target_date: The specific date to calculate the average sales :return: The average sales amount for transactions on the target_date. If no transactions, return 0. >>> transactions = [ ... (1, 101, '2023-01-01', 100), ... (2, 102, '2023-01-01', 200), ... (3, 103, '2023-01-02', 300), ... (4, 104, '2023-01-02', 400) ... ] >>> average_sales_on_date(transactions, '2023-01-01') 150 >>> average_sales_on_date(transactions, '2023-01-03') 0 >>> average_sales_on_date([], '2023-01-01') 0 >>> transactions = [ ... (1, 101, '2023-01-01', 100) ... ] >>> average_sales_on_date(transactions, '2023-01-01') 100 >>> average_sales_on_date(transactions, '2023-01-02') 0 >>> transactions = [ ... (1, 101, '2023-01-01', 100), ... (2, 102, '2023-01-01', 100) ... ] >>> average_sales_on_date(transactions, '2023-01-01') 100","solution":"def average_sales_on_date(transactions, target_date): Returns the average sales amount for transactions on the target_date. If no transactions on that date, return 0. :param transactions: List of tuples in the form (transaction_id, customer_id, date, amount) :param target_date: The specific date to calculate the average sales :return: The average sales amount for transactions on the target_date. If no transactions, return 0. total_sales = 0 count = 0 for transaction in transactions: transaction_id, customer_id, date, amount = transaction if date == target_date: total_sales += amount count += 1 if count == 0: return 0 return total_sales / count"},{"question":"class Counter: A class to represent a counter with a customizable increment. Methods: __init__(start=0): Initializes the counter with an optional start value. increment(amount=1): Increments the counter by a specified amount. reset(): Resets the counter to zero. >>> counter = Counter() >>> counter.increment() >>> counter.increment() >>> counter.count 2 >>> counter.reset() >>> counter.count 0 def __init__(start=0): Initialize the Counter with a starting value. def increment(amount=1): Increment the counter by a specified amount. def reset(): Reset the counter to zero.","solution":"class Counter: def __init__(self, start=0): self.count = start def increment(self, amount=1): self.count += amount def reset(self): self.count = 0"},{"question":"from typing import List def is_subset_sum(arr: List[int], target: int) -> bool: Write a Python function that takes a list of integers and a target integer as inputs. The function should use a recursive algorithm to determine if there is a subset of the list that adds up to the target integer. The function should return a boolean value indicating whether such a subset exists. >>> is_subset_sum([3, 34, 4, 12, 5, 2], 9) True >>> is_subset_sum([3, 34, 4, 12, 5, 2], 30) False >>> is_subset_sum([], 0) True >>> is_subset_sum([5], 5) True >>> is_subset_sum([1, 2, 3, 4, 5], 20) False pass","solution":"def is_subset_sum(arr, target): def subset_sum_recursive(arr, n, target): # Base Cases if target == 0: return True if n == 0 and target != 0: return False # If the last element is greater than target, ignore it if arr[n-1] > target: return subset_sum_recursive(arr, n-1, target) # Otherwise, check if target can be obtained by including or excluding the last element return subset_sum_recursive(arr, n-1, target) or subset_sum_recursive(arr, n-1, target - arr[n-1]) return subset_sum_recursive(arr, len(arr), target) # Example use of the function arr = [3, 34, 4, 12, 5, 2] target = 9 print(is_subset_sum(arr, target))"},{"question":"def partition(arr, low, high): Helper function to partition the array on the basis of pivot element for quicksort. pass def quickSort(arr, low, high): Implement quicksort algorithm to sort a list of integers in ascending order. >>> arr = [3, 7, 8, 5, 2, 1, 9, 5, 4] >>> quickSort(arr, 0, len(arr)-1) >>> arr [1, 2, 3, 4, 5, 5, 7, 8, 9] pass def merge(arr, l, m, r): Helper function to merge two halves for mergesort. pass def mergeSort(arr, l, r): Implement mergesort algorithm to sort a list of integers in ascending order. >>> arr = [3, 7, 8, 5, 2, 1, 9, 5, 4] >>> mergeSort(arr, 0, len(arr)-1) >>> arr [1, 2, 3, 4, 5, 5, 7, 8, 9] pass def compare_efficiency(): Compare the efficiencies of Quicksort and Mergesort by analyzing their time complexities. >>> result = compare_efficiency() >>> result[\\"Quicksort\\"] 'Average Case: O(n log n), Worse Case: O(n^2)' >>> result[\\"Merge Sort\\"] 'Average Case: O(n log n), Worse Case: O(n log n)' pass","solution":"def partition(arr, low, high): i = (low-1) pivot = arr[high] for j in range(low, high): if arr[j] < pivot: i = i+1 arr[i], arr[j] = arr[j], arr[i] arr[i+1], arr[high] = arr[high], arr[i+1] return (i+1) def quickSort(arr, low, high): if low < high: pi = partition(arr, low, high) quickSort(arr, low, pi-1) quickSort(arr, pi+1, high) def merge(arr, l, m, r): n1 = m - l + 1 n2 = r - m L = [0] * (n1) R = [0] * (n2) for i in range(0, n1): L[i] = arr[l + i] for j in range(0, n2): R[j] = arr[m + 1 + j] i = 0 j = 0 k = l while i < n1 and j < n2: if L[i] <= R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i < n1: arr[k] = L[i] i += 1 k += 1 while j < n2: arr[k] = R[j] j += 1 k += 1 def mergeSort(arr, l, r): if l < r: m = l+(r-l)//2 mergeSort(arr, l, m) mergeSort(arr, m+1, r) merge(arr, l, m, r) # Analyze the efficiencies def compare_efficiency(): return { \\"Quicksort\\": \\"Average Case: O(n log n), Worse Case: O(n^2)\\", \\"Merge Sort\\": \\"Average Case: O(n log n), Worse Case: O(n log n)\\" } arr = [3, 7, 8, 5, 2, 1, 9, 5, 4] quickSort(arr, 0, len(arr)-1) arr2 = [3, 7, 8, 5, 2, 1, 9, 5, 4] mergeSort(arr2, 0, len(arr2)-1)"},{"question":"def process_student_grades(students): Processes a list of student grades and returns the average grade, highest grade, students with the highest grade, and any errors in the data formatting. Args: students (list of str): List of strings where each string contains a student name and grade separated by a colon. Returns: tuple: A tuple containing the average grade (float or None if there are no valid grades), highest grade (int or None if there are no valid grades), list of student names with the highest grade (sorted alphabetically), and list of errors (if any). pass # Test cases def test_valid_data(): students = [\\"Alice:85\\", \\"Bob:92\\", \\"Charlie:85\\", \\"David:89\\"] average_grade, highest_grade, highest_grade_students, errors = process_student_grades(students) assert average_grade == 87.75 assert highest_grade == 92 assert highest_grade_students == [\\"Bob\\"] assert errors == [] def test_invalid_grade(): students = [\\"Alice:85\\", \\"Bob:92\\", \\"Eve:invalid\\"] average_grade, highest_grade, highest_grade_students, errors = process_student_grades(students) assert average_grade == 88.5 assert highest_grade == 92 assert highest_grade_students == [\\"Bob\\"] assert errors == [\\"Invalid grade for Eve\\"] def test_multiple_highest_grades(): students = [\\"Alice:92\\", \\"Bob:92\\", \\"Charlie:85\\"] average_grade, highest_grade, highest_grade_students, errors = process_student_grades(students) assert average_grade == 89.66666666666667 assert highest_grade == 92 assert highest_grade_students == [\\"Alice\\", \\"Bob\\"] assert errors == [] def test_no_valid_grades(): students = [\\"Alice:invalid\\", \\"Bob:invalid\\"] average_grade, highest_grade, highest_grade_students, errors = process_student_grades(students) assert average_grade is None assert highest_grade is None assert highest_grade_students == [] assert errors == [\\"Invalid grade for Alice\\", \\"Invalid grade for Bob\\"] def test_empty_input(): students = [] average_grade, highest_grade, highest_grade_students, errors = process_student_grades(students) assert average_grade is None assert highest_grade is None assert highest_grade_students == [] assert errors == []","solution":"def process_student_grades(students): Processes a list of student grades and returns the average grade, highest grade, students with the highest grade, and any errors in the data formatting. Args: students (list of str): List of strings where each string contains a student name and grade separated by a colon. Returns: tuple: A tuple containing the average grade (float or None if there are no valid grades), highest grade (int or None if there are no valid grades), list of student names with the highest grade (sorted alphabetically), and list of errors (if any). valid_grades = [] highest_grade_students = [] errors = [] for entry in students: try: name, grade_str = entry.split(\\":\\") grade = int(grade_str) valid_grades.append((name, grade)) except ValueError: errors.append(f\\"Invalid grade for {entry.split(':')[0] if ':' in entry else entry}\\") if valid_grades: average_grade = sum(grade for name, grade in valid_grades) / len(valid_grades) highest_grade = max(grade for name, grade in valid_grades) highest_grade_students = sorted([name for name, grade in valid_grades if grade == highest_grade]) else: average_grade = None highest_grade = None highest_grade_students = [] return average_grade, highest_grade, highest_grade_students, errors"},{"question":"def get_consecutive_differences(numbers: List[int]) -> List[int]: Create a Python function that takes a numerical list as input and returns a new list where each element is the difference between the consecutive elements of the original list. >>> get_consecutive_differences([1, 2, 3, 4, 5]) == [1, 1, 1, 1] >>> get_consecutive_differences([5, 4, 3, 2, 1]) == [-1, -1, -1, -1] >>> get_consecutive_differences([10, 20, 30, 40]) == [10, 10, 10] >>> get_consecutive_differences([0, 0, 0, 0]) == [0, 0, 0] >>> get_consecutive_differences([1]) == [] >>> get_consecutive_differences([]) == [] >>> get_consecutive_differences([-1, 1, -1, 1]) == [2, -2, 2] >>> get_consecutive_differences([1, -2, 4, 0]) == [-3, 6, -4]","solution":"def get_consecutive_differences(numbers): Returns a new list where each element is the difference between the consecutive elements of the original list. if len(numbers) < 2: return [] return [numbers[i+1] - numbers[i] for i in range(len(numbers) - 1)]"},{"question":"def filter_and_sort_emails(email_addresses, allowed_domains): Filters the email addresses to include only those that belong to the allowed domains and sorts them alphabetically. Parameters: email_addresses (list): A list of email addresses (strings) allowed_domains (list): A list of allowed domains (strings) Returns: list: A list of filtered and sorted email addresses >>> filter_and_sort_emails([\\"bob@gmail.com\\", \\"alice@yahoo.com\\", \\"carol@gmail.com\\", \\"dave@hotmail.com\\", \\"eve@gmail.com\\"], [\\"gmail.com\\", \\"hotmail.com\\"]) [\\"bob@gmail.com\\", \\"carol@gmail.com\\", \\"dave@hotmail.com\\", \\"eve@gmail.com\\"] >>> filter_and_sort_emails([\\"bob@gmail.com\\", \\"alice@yahoo.com\\", \\"carol@gmail.com\\"], [\\"hotmail.com\\"]) [] >>> filter_and_sort_emails([], [\\"gmail.com\\", \\"hotmail.com\\"]) [] >>> filter_and_sort_emails([\\"bob@gmail.com\\", \\"carol@gmail.com\\", \\"eve@gmail.com\\"], [\\"gmail.com\\"]) [\\"bob@gmail.com\\", \\"carol@gmail.com\\", \\"eve@gmail.com\\"] >>> filter_and_sort_emails([\\"eve@gmail.com\\", \\"bob@gmail.com\\", \\"alice@yahoo.com\\", \\"dave@hotmail.com\\", \\"carol@gmail.com\\"], [\\"gmail.com\\", \\"hotmail.com\\"]) [\\"bob@gmail.com\\", \\"carol@gmail.com\\", \\"dave@hotmail.com\\", \\"eve@gmail.com\\"]","solution":"def filter_and_sort_emails(email_addresses, allowed_domains): Filters the email addresses to include only those that belong to the allowed domains and sorts them alphabetically. Parameters: email_addresses (list): A list of email addresses (strings) allowed_domains (list): A list of allowed domains (strings) Returns: list: A list of filtered and sorted email addresses filtered_emails = [email for email in email_addresses if email.split('@')[1] in allowed_domains] return sorted(filtered_emails) # Example usage emails = [\\"bob@gmail.com\\", \\"alice@yahoo.com\\", \\"carol@gmail.com\\", \\"dave@hotmail.com\\", \\"eve@gmail.com\\"] allowed_domains = [\\"gmail.com\\", \\"hotmail.com\\"] print(filter_and_sort_emails(emails, allowed_domains)) # [\\"bob@gmail.com\\", \\"carol@gmail.com\\", \\"dave@hotmail.com\\", \\"eve@gmail.com\\"]"},{"question":"from typing import List def rearrange_list(nums: List[int], k: int) -> List[int]: Rearranges the list so that each integer appears at most \`k\` times, while retaining the relative order of their first appearance. Args: nums (list of int): List of integers. k (int): The maximum number of times an integer can appear. Returns: list of int: Rearranged list. pass def test_example_case(): assert rearrange_list([1, 1, 1, 2, 3, 3, 3, 3, 4, 4], 2) == [1, 1, 2, 3, 3, 4, 4] def test_no_occurrences_allowed(): assert rearrange_list([1, 2, 3, 4], 0) == [] def test_single_occurrences_allowed(): assert rearrange_list([1, 2, 2, 3, 3, 3], 1) == [1, 2, 3] def test_more_than_max_occurrences(): assert rearrange_list([1, 2, 2, 3, 3, 3], 2) == [1, 2, 2, 3, 3] def test_all_elements_unique(): assert rearrange_list([1, 2, 3, 4], 2) == [1, 2, 3, 4] def test_all_elements_within_limit(): assert rearrange_list([1, 1, 2, 2, 3, 3], 3) == [1, 1, 2, 2, 3, 3] def test_empty_list(): assert rearrange_list([], 2) == [] def test_k_greater_than_list_length(): assert rearrange_list([1, 1, 1, 2, 2], 10) == [1, 1, 1, 2, 2]","solution":"def rearrange_list(nums, k): Rearranges the list so that each integer appears at most \`k\` times, while retaining the relative order of their first appearance. Args: nums (list of int): List of integers. k (int): The maximum number of times an integer can appear. Returns: list of int: Rearranged list. count = {} result = [] for num in nums: if count.get(num, 0) < k: result.append(num) count[num] = count.get(num, 0) + 1 return result"},{"question":"from typing import List, Dict from collections import defaultdict import re def word_frequency(words: List[str], ignore_stop_words: bool = True) -> Dict[str, int]: Returns a dictionary with each unique word as the key and the number of times it appears as the value. Ignores common English stop words if ignore_stop_words is True. >>> word_frequency([\\"Hello\\",\\"world\\",\\"hello\\"]) {'hello': 2, 'world': 1} >>> word_frequency([\\"Hello, World!\\", \\"Hello, world.\\"]) {'hello': 2, 'world': 2} >>> word_frequency([\\"The quick brown fox jumps over the lazy dog\\"]) {'quick': 1, 'brown': 1, 'fox': 1, 'jumps': 1, 'over': 1, 'lazy': 1, 'dog': 1} >>> word_frequency([\\"The quick brown fox jumps over the lazy dog\\"], ignore_stop_words=False) {'the': 2, 'quick': 1, 'brown': 1, 'fox': 1, 'jumps': 1, 'over': 1, 'lazy': 1, 'dog': 1} >>> word_frequency([\\"Word\\", \\"word\\", \\"word\\", \\"WoRd\\", \\"WORD\\"]) {'word': 5}","solution":"from collections import defaultdict import re def word_frequency(words, ignore_stop_words=True): Returns a dictionary with each unique word as the key and the number of times it appears as the value. Ignores common English stop words if ignore_stop_words is True. # List of common English stop words stop_words = {'the', 'is', 'in', 'and', 'or', 'an', 'a', 'of', 'to', 'it', 'that', 'on', 'for', 'with', 'as', 'by', 'at', 'from'} # Collect all words in a single string and normalize to lower case text = ' '.join(words).lower() # Remove punctuation text = re.sub(r'[^ws]', '', text) # Split text into words word_list = text.split() # Use a defaultdict for counting words frequency = defaultdict(int) for word in word_list: if ignore_stop_words and word in stop_words: continue frequency[word] += 1 return dict(frequency)"},{"question":"import logging import requests import time class StockTradingBot: def __init__(self, stock_symbol): self.stock_symbol = stock_symbol self.highest_price = 0 self.bought_price = None self.logging_setup() def logging_setup(self): logging.basicConfig( filename=f'stock_trading_bot_{self.stock_symbol}.log', level=logging.INFO, format='%(asctime)s - %(message)s' ) def get_stock_price(self): Retrieve the stock price from an API pass def check_buy_condition(self, current_price): Check if the current price is a buy condition pass def check_sell_condition(self, current_price): Check if the current price is a sell condition pass def update_stock_symbol(self, new_stock_symbol): Update the stock symbol being monitored pass def run(self): Run the stock trading bot pass import pytest from unittest.mock import patch, MagicMock @patch('solution.requests.get') def test_get_stock_price(mock_get): bot = StockTradingBot(\\"AAPL\\") mock_get.return_value.json.return_value = {\\"price\\": 150} assert bot.get_stock_price() == 150 def test_check_buy_condition(): bot = StockTradingBot(\\"AAPL\\") bot.highest_price = 100 assert bot.check_buy_condition(94) is True assert bot.check_buy_condition(96) is False def test_check_sell_condition(): bot = StockTradingBot(\\"AAPL\\") bot.bought_price = 100 assert bot.check_sell_condition(106) is True assert bot.check_sell_condition(104) is False def test_update_stock_symbol(): bot = StockTradingBot(\\"AAPL\\") bot.update_stock_symbol(\\"GOOGL\\") assert bot.stock_symbol == \\"GOOGL\\" assert bot.highest_price == 0 assert bot.bought_price is None","solution":"import time import logging import requests class StockTradingBot: def __init__(self, stock_symbol): self.stock_symbol = stock_symbol self.highest_price = 0 self.bought_price = None self.logging_setup() def logging_setup(self): logging.basicConfig( filename=f'stock_trading_bot_{self.stock_symbol}.log', level=logging.INFO, format='%(asctime)s - %(message)s' ) def get_stock_price(self): # Placeholder function to retrieve the stock price. # Replace with actual implementation such as calling a real-time stock price API. return requests.get(f'https://api.example.com/stock/{self.stock_symbol}/price').json()[\\"price\\"] def check_buy_condition(self, current_price): return current_price < self.highest_price * 0.95 def check_sell_condition(self, current_price): return self.bought_price and current_price > self.bought_price * 1.05 def update_stock_symbol(self, new_stock_symbol): self.stock_symbol = new_stock_symbol self.highest_price = 0 self.bought_price = None self.logging_setup() logging.info(f\\"Stock symbol updated to {new_stock_symbol}\\") def run(self): while True: try: current_price = self.get_stock_price() if current_price > self.highest_price: self.highest_price = current_price if self.bought_price: if self.check_sell_condition(current_price): profit = current_price - self.bought_price logging.info(f\\"Sell: {current_price}, Profit: {profit}\\") self.bought_price = None else: if self.check_buy_condition(current_price): self.bought_price = current_price logging.info(f\\"Buy: {current_price}\\") time.sleep(60) # Check every minute except requests.exceptions.RequestException as e: logging.error(f\\"Network error: {e}. Retrying in 60 seconds\\") time.sleep(60) except Exception as e: logging.error(f\\"Unexpected error: {e}. Retrying in 60 seconds\\") time.sleep(60)"},{"question":"from queue import Queue class StackUsingQueues: A Stack implemented using two queues. Methods: - push(x): Push element x onto stack. - pop(): Removes the element on top of the stack and returns that element. - top(): Get the top element. Example: >>> stack = StackUsingQueues() >>> stack.push(1) >>> stack.push(2) >>> stack.top() # returns 2 2 >>> stack.pop() # returns 2 2 >>> stack.top() # returns 1 1 def __init__(self): self.queue1 = Queue() self.queue2 = Queue() def push(self, x): pass def pop(self): pass def top(self): pass def test_push_pop(): stack = StackUsingQueues() stack.push(1) stack.push(2) stack.push(3) assert stack.pop() == 3 assert stack.pop() == 2 assert stack.pop() == 1 assert stack.pop() is None def test_top(): stack = StackUsingQueues() stack.push(1) assert stack.top() == 1 stack.push(2) assert stack.top() == 2 stack.pop() assert stack.top() == 1 stack.pop() assert stack.top() is None def test_push(): stack = StackUsingQueues() stack.push(5) assert stack.top() == 5 stack.push(10) assert stack.top() == 10 stack.push(15) assert stack.top() == 15","solution":"from queue import Queue class StackUsingQueues: def __init__(self): self.queue1 = Queue() self.queue2 = Queue() def push(self, x): self.queue2.put(x) while not self.queue1.empty(): self.queue2.put(self.queue1.get()) self.queue1, self.queue2 = self.queue2, self.queue1 def pop(self): if not self.queue1.empty(): return self.queue1.get() return None def top(self): if not self.queue1.empty(): return self.queue1.queue[0] return None"},{"question":"def convert_grades_to_letters(grades): Converts numerical grades to letter grades based on the following scale: - A: 90-100 - B: 80-89 - C: 70-79 - D: 60-69 - F: 0-59 Args: grades (list of int): List of numerical grades. Returns: list of str: List of letter grades corresponding to the input numerical grades. pass def test_convert_grades_to_letters(): assert convert_grades_to_letters([85, 92, 78, 60, 45]) == ['B', 'A', 'C', 'D', 'F'] assert convert_grades_to_letters([100, 99, 90]) == ['A', 'A', 'A'] assert convert_grades_to_letters([89, 80, 81]) == ['B', 'B', 'B'] assert convert_grades_to_letters([75, 72, 79, 70]) == ['C', 'C', 'C', 'C'] assert convert_grades_to_letters([65, 64, 62, 60]) == ['D', 'D', 'D', 'D'] assert convert_grades_to_letters([59, 50, 30, 0]) == ['F', 'F', 'F', 'F'] def test_convert_grades_to_letters_out_of_range(): try: convert_grades_to_letters([101]) except ValueError as e: assert str(e) == \\"Grade out of valid range: 0-100\\" try: convert_grades_to_letters([-1]) except ValueError as e: assert str(e) == \\"Grade out of valid range: 0-100\\"","solution":"def convert_grades_to_letters(grades): Converts numerical grades to letter grades based on the following scale: - A: 90-100 - B: 80-89 - C: 70-79 - D: 60-69 - F: 0-59 Args: grades (list of int): List of numerical grades. Returns: list of str: List of letter grades corresponding to the input numerical grades. letter_grades = [] for grade in grades: if 90 <= grade <= 100: letter_grades.append('A') elif 80 <= grade <= 89: letter_grades.append('B') elif 70 <= grade <= 79: letter_grades.append('C') elif 60 <= grade <= 69: letter_grades.append('D') elif 0 <= grade <= 59: letter_grades.append('F') else: raise ValueError(\\"Grade out of valid range: 0-100\\") return letter_grades"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression given as a string. Supports +, -, *, / operators and parentheses. Returns the result as a float or None if division by zero is encountered. >>> evaluate_expression(\\"3 + 5\\") == 8.0 >>> evaluate_expression(\\"(2+3) * 4\\") == 20.0 >>> evaluate_expression(\\"10 / 2\\") == 5.0 >>> evaluate_expression(\\"10 / 0\\") == None >>> evaluate_expression(\\"\\") == 0.0 def test_evaluate_expression(): assert evaluate_expression(\\"3 + 5\\") == 8.0 assert evaluate_expression(\\"10 - 2\\") == 8.0 assert evaluate_expression(\\"4 * 2\\") == 8.0 assert evaluate_expression(\\"16 / 2\\") == 8.0 assert evaluate_expression(\\"(2+3) * 4\\") == 20.0 assert evaluate_expression(\\"((2+3) * (4 - 1)) / 5\\") == 3.0 assert evaluate_expression(\\"3.5 + 2.1\\") == 5.6 assert evaluate_expression(\\"10 / 0\\") == None assert evaluate_expression(\\"\\") == 0.0 assert evaluate_expression(\\" 3 + 5 \\") == 8.0 assert evaluate_expression(\\" 4* (2 + 3)\\") == 20.0","solution":"def evaluate_expression(expression): Evaluates a mathematical expression given as a string. Supports +, -, *, / operators and parentheses. Returns the result as a float or None if division by zero is encountered. import re def parse_expression(expr): # Helper functions for basic mathematical operations def add(x, y): return x + y def subtract(x, y): return x - y def multiply(x, y): return x * y def divide(x, y): return None if y == 0 else x / y operators = {'+': add, '-': subtract, '*': multiply, '/': divide} precedence = {'+': 1, '-': 1, '*': 2, '/': 2} def shunting_yard(expression): Shunting Yard algorithm to convert infix to postfix output = [] stack = [] number = '' for token in expression: if token.isdigit() or token == '.': number += token else: if number: output.append(float(number)) number = '' if token in operators: while (stack and stack[-1] in operators and precedence[token] <= precedence[stack[-1]]): output.append(stack.pop()) stack.append(token) elif token == '(': stack.append(token) elif token == ')': while stack and stack[-1] != '(': output.append(stack.pop()) stack.pop() # Pop the '(' if number: output.append(float(number)) while stack: output.append(stack.pop()) return output def evaluate_postfix(postfix): stack = [] for token in postfix: if isinstance(token, float): stack.append(token) else: y, x = stack.pop(), stack.pop() result = operators[token](x, y) if result is None: return None stack.append(result) return stack[0] if stack else 0.0 # Clean spaces in expression expression = re.sub(r's+', '', expr) if not expression: return 0.0 postfix = shunting_yard(expression) return evaluate_postfix(postfix) if not expression.strip(): return 0.0 return parse_expression(expression)"},{"question":"def multiples_of_largest_even(lst): Returns a new list containing the elements which are multiples of the largest even number in the list. If there are no even numbers or the input is not a valid list of integers, return an empty list. >>> multiples_of_largest_even([2, 4, 6, 7, 8, 15, 20, 25]) [20] >>> multiples_of_largest_even([3, 5, 9, 11]) [] >>> multiples_of_largest_even([-2, -4, -6, 7, 8, 15, 20, 25]) [20] >>> multiples_of_largest_even(list(range(1, 10001))) [10000] >>> multiples_of_largest_even([]) [] >>> multiples_of_largest_even(\\"not a list\\") [] >>> multiples_of_largest_even([1, 2, 3, \\"four\\", 5]) [] >>> multiples_of_largest_even([2, 4, 8, 16]) [16]","solution":"def multiples_of_largest_even(lst): Returns a list of elements which are multiples of the largest even number in the list. If there are no even numbers or the input is not a valid list of integers, return an empty list. if not isinstance(lst, list) or not all(isinstance(i, int) for i in lst): return [] even_numbers = [num for num in lst if num % 2 == 0] if not even_numbers: return [] largest_even = max(even_numbers) return [num for num in lst if num % largest_even == 0]"},{"question":"def pairwise_swap(lst): Returns a new list where each pair of adjacent elements has been swapped. If the list has an odd number of elements, the last element remains in its original position. :param lst: List of elements to be swapped :return: A new list with swapped pairs >>> pairwise_swap([1, 2, 3, 4]) == [2, 1, 4, 3] >>> pairwise_swap([1, 2, 3, 4, 5]) == [2, 1, 4, 3, 5] >>> pairwise_swap([]) == [] >>> pairwise_swap([1]) == [1] >>> pairwise_swap(['a', 'b', 'c', 'd', 'e']) == ['b', 'a', 'd', 'c', 'e']","solution":"def pairwise_swap(lst): Returns a new list where each pair of adjacent elements has been swapped. If the list has an odd number of elements, the last element remains in its original position. :param lst: List of elements to be swapped :return: A new list with swapped pairs result = lst[:] for i in range(0, len(result) - 1, 2): result[i], result[i+1] = result[i+1], result[i] return result"},{"question":"def get_primes(numbers: List[int]) -> List[int]: Returns a new list containing only the prime numbers from the given list. >>> get_primes([1, 4, 6, 8, 9, 10, 12]) [] >>> get_primes([2, 3, 5, 7, 11, 13, 17]) [2, 3, 5, 7, 11, 13, 17] >>> get_primes([10, 11, 12, 13, 14, 15, 16, 17]) [11, 13, 17] >>> get_primes([-10, -3, 0, 1, 2, 3, 5]) [2, 3, 5] >>> get_primes([]) [] >>> get_primes([101, 103, 107, 109, 113, 117, 200, 113]) [101, 103, 107, 109, 113, 113] def is_prime(n: int) -> bool: Checks if a number is a prime number.","solution":"def is_prime(n): Checks if a number is a prime number. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False limit = int(n ** 0.5) + 1 for i in range(3, limit, 2): if n % i == 0: return False return True def get_primes(numbers): Returns a list of prime numbers from the given list. return [num for num in numbers if is_prime(num)]"},{"question":"import pandas as pd def analyze_sales_data(input_csv_path: str, output_csv_path: str): Reads the input CSV file, processes the sales data, and writes the results to a new CSV file. Parameters: input_csv_path (str): Path to the input CSV file containing sales data. output_csv_path (str): Path to the output CSV file where the summarized results will be stored. # Unit test for the completion task import pandas as pd import os from solution import analyze_sales_data def test_analyze_sales_data(tmp_path): # Create a sample input CSV file input_csv_path = tmp_path / \\"input_sales_data.csv\\" data = { 'Date': ['2023-01-01', '2023-01-02', '2023-01-03', '2023-01-03'], 'Product ID': [1, 2, 1, 3], 'Quantity Sold': [10, 20, 15, 8], 'Sales Amount': [100.0, 200.0, 150.0, 80.0] } df_input = pd.DataFrame(data) df_input.to_csv(input_csv_path, index=False) # Define the path for the output CSV file output_csv_path = tmp_path / \\"output_sales_summary.csv\\" # Call the function to analyze sales data analyze_sales_data(input_csv_path, output_csv_path) # Read the output CSV file df_output = pd.read_csv(output_csv_path) # Create the expected output DataFrame expected_data = { 'Product ID': [1, 2, 3], 'Total_Quantity_Sold': [25, 20, 8], 'Total_Sales_Amount': [250.0, 200.0, 80.0], 'Average_Sales_Amount_per_Transaction': [125.0, 200.0, 80.0] } df_expected = pd.DataFrame(expected_data) # Compare the output DataFrame with the expected DataFrame pd.testing.assert_frame_equal(df_output, df_expected) # Clean up temporary files os.remove(input_csv_path) os.remove(output_csv_path)","solution":"import pandas as pd def analyze_sales_data(input_csv_path, output_csv_path): Reads the input CSV file, processes the sales data, and writes the results to a new CSV file. Parameters: input_csv_path (str): Path to the input CSV file containing sales data. output_csv_path (str): Path to the output CSV file where the summarized results will be stored. # Read the CSV file into a DataFrame df = pd.read_csv(input_csv_path) # Group the data by 'Product ID' and calculate the required metrics summary = df.groupby('Product ID').agg( Total_Quantity_Sold=('Quantity Sold', 'sum'), Total_Sales_Amount=('Sales Amount', 'sum'), Average_Sales_Amount_per_Transaction=('Sales Amount', 'mean') ).reset_index() # Sort the summarized data by 'Product ID' summary = summary.sort_values('Product ID') # Write the summary to a new CSV file summary.to_csv(output_csv_path, index=False)"},{"question":"def longest_common_subsequence(text1: str, text2: str) -> int: Returns the length of the longest common subsequence between text1 and text2. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 pass from solution import longest_common_subsequence def test_example1(): assert longest_common_subsequence(\\"abcde\\", \\"ace\\") == 3 def test_example2(): assert longest_common_subsequence(\\"abc\\", \\"abc\\") == 3 def test_example3(): assert longest_common_subsequence(\\"abc\\", \\"def\\") == 0 def test_no_common_subsequence(): assert longest_common_subsequence(\\"abcdefgh\\", \\"ijklmnop\\") == 0 def test_one_character_common(): assert longest_common_subsequence(\\"a\\", \\"a\\") == 1 def test_large_inputs_same_length(): text1 = \\"a\\" * 1000 text2 = \\"a\\" * 1000 assert longest_common_subsequence(text1, text2) == 1000 def test_large_inputs_different_length(): text1 = \\"abcdefgh\\" * 125 text2 = \\"bdfh\\" * 250 assert longest_common_subsequence(text1, text2) == 500 def test_strings_with_repeated_characters(): assert longest_common_subsequence(\\"abacabad\\", \\"bacacaba\\") == 6","solution":"def longest_common_subsequence(text1: str, text2: str) -> int: Returns the length of the longest common subsequence between text1 and text2. m, n = len(text1), len(text2) # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"from typing import List def unique_elements(input_list: List[int]) -> List[int]: Construct a function that takes in a list of integers and returns a new list containing only the unique elements from the original list, maintaining their original order of appearance. >>> unique_elements([]) == [] >>> unique_elements([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> unique_elements([1, 1, 2, 2, 3, 3]) == [1, 2, 3] >>> unique_elements([1, 2, 1, 3, 2, 4, 5, 4]) == [1, 2, 3, 4, 5] >>> unique_elements([2, 2, 2, 2]) == [2] >>> unique_elements([10]) == [10]","solution":"def unique_elements(input_list): Returns a list of unique elements from the input list, maintaining their original order. seen = set() unique_list = [] for item in input_list: if item not in seen: seen.add(item) unique_list.append(item) return unique_list"},{"question":"def update_inventory(inventory: dict, new_stock: dict) -> dict: Updates the inventory dictionary by adding quantities from the new stock dictionary. Args: inventory: The current inventory dictionary where keys are product names and values are the stock quantities. new_stock: The new stock dictionary where keys are product names and values are the quantities to be added. Returns: Updated inventory dictionary with quantities from the new stock added. >>> update_inventory({'apples': 10, 'bananas': 5}, {'apples': 5, 'bananas': 3}) {'apples': 15, 'bananas': 8} >>> update_inventory({'apples': 10}, {'oranges': 3, 'grapes': 7}) {'apples': 10, 'oranges': 3, 'grapes': 7} # Write your code here def find_low_stock_items(inventory: dict, threshold: int) -> list: Returns a list of product names whose stock is below the given threshold. Args: inventory: The inventory dictionary where keys are product names and values are the stock quantities. threshold: The threshold value below which a product is considered low in stock. Returns: List of product names with stock quantities below the threshold. >>> find_low_stock_items({'apples': 10, 'bananas': 3, 'oranges': 2}, 5) ['bananas', 'oranges'] >>> find_low_stock_items({'apples': 1, 'bananas': 2, 'oranges': 3}, 5) ['apples', 'bananas', 'oranges'] # Write your code here # Example usage if __name__ == \\"__main__\\": current_inventory = {'apples': 10, 'bananas': 5, 'oranges': 2} new_stock = {'apples': 5, 'oranges': 3, 'grapes': 7} threshold_value = 5 updated_inventory = update_inventory(current_inventory, new_stock) print(updated_inventory) low_stock_items = find_low_stock_items(updated_inventory, threshold_value) print(low_stock_items)","solution":"def update_inventory(inventory, new_stock): Updates the inventory dictionary by adding quantities from the new stock dictionary. for key, quantity in new_stock.items(): inventory[key] = inventory.get(key, 0) + quantity return inventory def find_low_stock_items(inventory, threshold): Returns a list of product names whose stock is below the given threshold. low_stock = [key for key, value in inventory.items() if value < threshold] return low_stock"},{"question":"def index_of_first_largest(lst: List[int]) -> int: Returns the index of the first occurrence of the largest integer in the list. Parameters: lst (list): A list of integers. Returns: int: The index of the first occurrence of the largest integer. >>> index_of_first_largest([4, 2, 7, 1, 7, 5]) == 2 >>> index_of_first_largest([10]) == 0 >>> index_of_first_largest([]) == -1 >>> index_of_first_largest([3, 3, 3]) == 0 >>> index_of_first_largest([-1, -4, -3, -2, -5]) == 0 >>> index_of_first_largest([-1, 0, -4, 10, 5, 10, 7]) == 3","solution":"def index_of_first_largest(lst): Returns the index of the first occurrence of the largest integer in the list. Parameters: lst (list): A list of integers. Returns: int: The index of the first occurrence of the largest integer. if not lst: return -1 largest = max(lst) return lst.index(largest)"},{"question":"def double_characters(input_string: str) -> str: Returns a new string where each character in the original string is repeated once. >>> double_characters(\\"hello\\") 'hheelllloo' >>> double_characters(\\"Python\\") 'PPyytthhoonn' >>> double_characters(\\"\\") '' >>> double_characters(\\"A\\") 'AA' >>> double_characters(\\"a1! \\") 'aa11!! '","solution":"def double_characters(input_string): Returns a new string where each character in the original string is repeated once. result = \\"\\" for char in input_string: result += char * 2 return result"},{"question":"def is_balanced(input_str: str) -> bool: Check if the input string has balanced parentheses, brackets, and curly braces. >>> is_balanced(\\"()\\") == True >>> is_balanced(\\"(())\\") == True >>> is_balanced(\\"(()())\\") == True >>> is_balanced(\\"(()\\") == False >>> is_balanced(\\"())\\") == False >>> is_balanced(\\"[]\\") == True >>> is_balanced(\\"[[]]\\") == True >>> is_balanced(\\"[[][]]\\") == True >>> is_balanced(\\"[[\\") == False >>> is_balanced(\\"]]\\") == False >>> is_balanced(\\"{}\\") == True >>> is_balanced(\\"{{}}\\") == True >>> is_balanced(\\"{{}{}}\\") == True >>> is_balanced(\\"{{}\\") == False >>> is_balanced(\\"{}}\\") == False >>> is_balanced(\\"{[()]}\\") == True >>> is_balanced(\\"{[(())]}\\") == True >>> is_balanced(\\"{[(])}\\") == False >>> is_balanced(\\"{[}\\") == False >>> is_balanced(\\"\\") == True >>> is_balanced(\\"hello world\\") == True","solution":"def is_balanced(input_str: str) -> bool: Check if the input string has balanced parentheses, brackets, and curly braces. stack = [] matching_bracket = {')': '(', ']': '[', '}': '{'} for char in input_str: if char in \\"({[\\": stack.append(char) elif char in \\")}]\\": if not stack or stack.pop() != matching_bracket[char]: return False return not stack"},{"question":"def find_unique_elements(list1, list2): Returns a sorted list of elements that are unique to each list (i.e., present in one list but not the other). >>> find_unique_elements([1, 2, 3], [2, 3, 4]) [1, 4] >>> find_unique_elements([5, 6, 7], [7, 8, 9]) [5, 6, 8, 9] >>> find_unique_elements([10, 10, 11], [11, 12, 13]) [10, 12, 13]","solution":"def find_unique_elements(list1, list2): Returns a sorted list of elements that are unique to each list (i.e., present in one list but not the other). set1, set2 = set(list1), set(list2) unique_elements = (set1 - set2) | (set2 - set1) return sorted(unique_elements)"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcde\\") == 5 >>> length_of_longest_substring(\\"aaaaa\\") == 1 >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\"x\\") == 1 >>> length_of_longest_substring(\\"aabbccddababcdef\\") == 6","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_len = 0 for right in range(len(s)): if s[right] in char_map: left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right max_len = max(max_len, right - left + 1) return max_len"},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. >>> sieve_of_eratosthenes(0) [] >>> sieve_of_eratosthenes(1) [] >>> sieve_of_eratosthenes(2) [2] >>> sieve_of_eratosthenes(3) [2, 3] >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> sieve_of_eratosthenes(100) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not primes for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False return [num for num in range(n + 1) if sieve[num]]"},{"question":"from typing import List, Dict def count_strings(strings: List[str]) -> Dict[str, int]: Takes a list of strings and returns a dictionary with the count of each unique string. Args: strings (list of str): A list of strings. Returns: dict: A dictionary with unique strings as keys and their counts as values. >>> count_strings(['apple', 'banana', 'cherry']) == {'apple': 1, 'banana': 1, 'cherry': 1} >>> count_strings(['apple', 'banana', 'apple', 'cherry', 'banana', 'banana']) == {'apple': 2, 'banana': 3, 'cherry': 1} >>> count_strings([]) == {} >>> count_strings(['apple', 'Apple', 'APPLE']) == {'apple': 1, 'Apple': 1, 'APPLE': 1} >>> count_strings(['', 'apple', '', 'banana', '']) == {'': 3, 'apple': 1, 'banana': 1} >>> count_strings(['apple'] * 1000000 + ['banana'] * 500000 + ['cherry'] * 250000) == {'apple': 1000000, 'banana': 500000, 'cherry': 250000}","solution":"from collections import defaultdict def count_strings(strings): Takes a list of strings and returns a dictionary with the count of each unique string. Args: strings (list of str): A list of strings. Returns: dict: A dictionary with unique strings as keys and their counts as values. count_dict = defaultdict(int) for s in strings: count_dict[s] += 1 return dict(count_dict)"},{"question":"class StockMarket: def __init__(self): self.companies = {} def add_company(self, name, share_price, available_shares): Add a new company with its initial share price and number of shares. Args: name (str): The name of the company. share_price (float): The price per share. available_shares (int): The number of shares available. pass def buy_shares(self, name, shares): Buy a certain number of shares from a company. Args: name (str): The name of the company. shares (int): The number of shares to buy. pass def sell_shares(self, name, shares): Sell a certain number of shares of a company. Args: name (str): The name of the company. shares (int): The number of shares to sell. pass def display_market(self): Display the current status of the market in a table format. pass # Demonstrate the usage of the StockMarket class. def test_stock_market(): market = StockMarket() market.add_company(\\"TechCorp\\", 100, 1000) market.add_company(\\"HealthInc\\", 200, 500) market.add_company(\\"AutoWorks\\", 150, 300) market.buy_shares(\\"TechCorp\\", 50) market.sell_shares(\\"HealthInc\\", 50) market.buy_shares(\\"AutoWorks\\", 30) market.sell_shares(\\"TechCorp\\", 20) market.display_market()","solution":"class StockMarket: def __init__(self): self.companies = {} def add_company(self, name, share_price, available_shares): if name not in self.companies: self.companies[name] = { 'share_price': share_price, 'available_shares': available_shares } def buy_shares(self, name, shares): if name in self.companies: company = self.companies[name] if shares <= company['available_shares']: company['available_shares'] -= shares else: raise ValueError(\\"Not enough shares available to buy.\\") def sell_shares(self, name, shares): if name in self.companies: company = self.companies[name] company['available_shares'] += shares def display_market(self): print(f\\"{'Company Name':<20}{'Share Price':<15}{'Available Shares'}\\") print(\\"=\\"*50) for name, data in self.companies.items(): print(f\\"{name:<20}{data['share_price']:<15}{data['available_shares']}\\")"},{"question":"def find_anagrams_of_binary(words): Returns a list containing only the strings from the input list that are anagrams of the word \\"binary\\". This function is case-insensitive. from solution import find_anagrams_of_binary def test_no_anagrams(): assert find_anagrams_of_binary([\\"hello\\", \\"world\\", \\"python\\"]) == [] def test_all_anagrams(): assert find_anagrams_of_binary([\\"binary\\", \\"Brainy\\", \\"RIBANY\\"]) == [\\"binary\\", \\"Brainy\\", \\"RIBANY\\"] def test_partial_anagrams(): assert find_anagrams_of_binary([\\"binary\\", \\"cabiny\\", \\"brainy\\", \\"notanagram\\", \\"binray\\"]) == [\\"binary\\", \\"brainy\\", \\"binray\\"] def test_empty_list(): assert find_anagrams_of_binary([]) == [] def test_mixed_case_anagrams(): assert find_anagrams_of_binary([\\"BiNarY\\", \\"bInAry\\", \\"BINARY\\", \\"brain\\", \\"yarn\\"]) == [\\"BiNarY\\", \\"bInAry\\", \\"BINARY\\"]","solution":"def find_anagrams_of_binary(words): Returns a list containing only the strings from the input list that are anagrams of the word \\"binary\\". This function is case-insensitive. target = \\"binary\\" target_sorted = sorted(target.lower()) # Sort letters of the target word anagrams = [] for word in words: if sorted(word.lower()) == target_sorted: anagrams.append(word) return anagrams"},{"question":"class Account: A class representing a basic Account with common attributes. Attributes: - account_number : str : Unique identifier for the account - holder_name : str : The name of the account holder - balance : float : The balance amount in the account Methods: - deposit(amount: float) -> float : Adds money to the account balance - withdraw(amount: float) -> float : Deducts money from the account balance - display_details() -> dict : Returns account details as a dictionary >>> acc = Account(\\"123\\", \\"John Doe\\", 1000) >>> acc.deposit(500) 1500 >>> acc.withdraw(400) 600 >>> acc.display_details() {'Account Number': '123', 'Holder Name': 'John Doe', 'Balance': 600} class SavingsAccount(Account): A class representing a SavingsAccount, inheriting from Account. Attributes: - interest_rate : float : The interest rate applicable to the savings account Methods: - display_details() -> dict : Returns detailed account information including interest rate >>> sa = SavingsAccount(\\"456\\", \\"Jane Doe\\", 2000, 2.5) >>> sa.display_details() {'Account Number': '456', 'Holder Name': 'Jane Doe', 'Balance': 2000, 'Interest Rate': 2.5} class CurrentAccount(Account): A class representing a CurrentAccount, inheriting from Account. Attributes: - overdraft_limit : float : The maximum overdraft limit allowed for the account Methods: - withdraw(amount: float) -> float : Deducts money from the account balance considering overdraft limit - display_details() -> dict : Returns detailed account information including overdraft limit >>> ca = CurrentAccount(\\"789\\", \\"Richard Roe\\", 500, 1000) >>> ca.withdraw(1200) -700 >>> ca.display_details() {'Account Number': '789', 'Holder Name': 'Richard Roe', 'Balance': -700, 'Overdraft Limit': 1000}","solution":"class Account: def __init__(self, account_number, holder_name, balance=0.0): self.account_number = account_number self.holder_name = holder_name self.balance = balance def deposit(self, amount): if amount <= 0: raise ValueError(\\"Deposit amount must be positive.\\") self.balance += amount return self.balance def withdraw(self, amount): if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive.\\") if amount > self.balance: raise ValueError(\\"Insufficient balance.\\") self.balance -= amount return self.balance def display_details(self): return { \\"Account Number\\": self.account_number, \\"Holder Name\\": self.holder_name, \\"Balance\\": self.balance } class SavingsAccount(Account): def __init__(self, account_number, holder_name, balance=0.0, interest_rate=0.0): super().__init__(account_number, holder_name, balance) self.interest_rate = interest_rate def display_details(self): details = super().display_details() details[\\"Interest Rate\\"] = self.interest_rate return details class CurrentAccount(Account): def __init__(self, account_number, holder_name, balance=0.0, overdraft_limit=0.0): super().__init__(account_number, holder_name, balance) self.overdraft_limit = overdraft_limit def withdraw(self, amount): if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive.\\") if amount > self.balance + self.overdraft_limit: raise ValueError(\\"Exceeding overdraft limit.\\") self.balance -= amount return self.balance def display_details(self): details = super().display_details() details[\\"Overdraft Limit\\"] = self.overdraft_limit return details"},{"question":"def count_unique_elements(input_list: List[int]) -> List[Tuple[int, int]]: Takes a list of integers and returns a list of tuples. Each tuple contains an integer from the original list and the count of how many times that integer appears after duplicate removals. :param input_list: List of positive integers :return: List of tuples (integer, count) >>> count_unique_elements([4, 4, 4, 9, 9, 10]) [(4, 1), (9, 1), (10, 1)] >>> count_unique_elements([1, 2, 3]) [(1, 1), (2, 1), (3, 1)] >>> count_unique_elements([4, 4, 4, 4]) [(4, 1)] >>> count_unique_elements([4, 4, 5, 5, 5, 6]) [(4, 1), (5, 1), (6, 1)] >>> count_unique_elements([7]) [(7, 1)] >>> count_unique_elements([]) [] def test_no_duplicates(): assert count_unique_elements([1, 2, 3]) == [(1, 1), (2, 1), (3, 1)] def test_all_duplicates(): assert count_unique_elements([4, 4, 4, 4]) == [(4, 1)] def test_some_duplicates(): assert count_unique_elements([4, 4, 5, 5, 5, 6]) == [(4, 1), (5, 1), (6, 1)] def test_single_element(): assert count_unique_elements([7]) == [(7, 1)] def test_empty_list(): assert count_unique_elements([]) == [] def test_large_input(): large_input = list(range(1, 1001)) * 2 expected_output = [(i, 1) for i in range(1, 1001)] assert count_unique_elements(large_input) == expected_output","solution":"def count_unique_elements(input_list): Takes a list of integers and returns a list of tuples. Each tuple contains an integer from the original list and the count of how many times that integer appears after duplicate removals. :param input_list: List of positive integers :return: List of tuples (integer, count) unique_elements = list(set(input_list)) return [(element, 1) for element in unique_elements]"},{"question":"def distribute_tasks(tasks, time_slots): Distribute tasks across the given time slots. Parameters: tasks (list): A list of tuples where each tuple contains the task's name (string) and its duration in hours (int). time_slots (list): A list of tuples where each tuple contains the day (string) and the available time in hours (int). Returns: dict: A dictionary where the keys are the days (string), and the values are lists of tuples containing task's name (string) and the assigned duration in hours (int).","solution":"def distribute_tasks(tasks, time_slots): Distribute tasks across the given time slots. Parameters: tasks (list): A list of tuples where each tuple contains the task's name (string) and its duration in hours (int). time_slots (list): A list of tuples where each tuple contains the day (string) and the available time in hours (int). Returns: dict: A dictionary where the keys are the days (string), and the values are lists of tuples containing task's name (string) and the assigned duration in hours (int). distribution = {} current_task_index = 0 remaining_duration = tasks[0][1] for day, available_time in time_slots: if day not in distribution: distribution[day] = [] while available_time > 0 and current_task_index < len(tasks): task_name, task_duration = tasks[current_task_index] if remaining_duration <= available_time: distribution[day].append((task_name, remaining_duration)) available_time -= remaining_duration current_task_index += 1 if current_task_index < len(tasks): remaining_duration = tasks[current_task_index][1] else: distribution[day].append((task_name, available_time)) remaining_duration -= available_time available_time = 0 return distribution"},{"question":"def calculate_squares(start, end): Calculates the square of each integer within a specified range and returns a formatted list of the results. :param start: The starting integer of the range (inclusive). :param end: The ending integer of the range (exclusive). :return: A list of strings with each string giving the square of an integer. >>> calculate_squares(1, 6) [\\"The square of 1 is 1\\", \\"The square of 2 is 4\\", \\"The square of 3 is 9\\", \\"The square of 4 is 16\\", \\"The square of 5 is 25\\"] >>> calculate_squares(3, 4) [\\"The square of 3 is 9\\"] >>> calculate_squares(5, 5) [] >>> calculate_squares(-2, 3) [\\"The square of -2 is 4\\", \\"The square of -1 is 1\\", \\"The square of 0 is 0\\", \\"The square of 1 is 1\\", \\"The square of 2 is 4\\"]","solution":"def calculate_squares(start, end): Calculates the square of each integer within a specified range and returns a formatted list of the results. :param start: The starting integer of the range (inclusive). :param end: The ending integer of the range (exclusive). :return: A list of strings with each string giving the square of an integer. results = [] for num in range(start, end): squared_value = num ** 2 results.append(f\\"The square of {num} is {squared_value}\\") return results"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given 2D matrix 90 degrees clockwise and returns the result. Validates the matrix to ensure all rows are of the same length and the matrix is non-empty. >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1]]) [[1]] # Implementation here","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given 2D matrix 90 degrees clockwise and returns the result. Validates the matrix to ensure all rows are of the same length and the matrix is non-empty. # Validate the matrix if not matrix or any(len(row) != len(matrix[0]) for row in matrix): raise ValueError(\\"Matrix must be non-empty and all rows must be of the same length.\\") # Rotate the matrix rotated_matrix = list(zip(*matrix[::-1])) return [list(row) for row in rotated_matrix]"},{"question":"def is_prime(n: int) -> bool: Check if a number is a prime number. Returns True if n is prime, False otherwise. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(11) True pass def sort_with_primes_first(arr: List[int]) -> List[int]: Takes a list of integers and returns a new list with the integers sorted in ascending order, but with all prime numbers appearing before non-prime numbers. >>> sort_with_primes_first([3, 8, 5, 2, 11, 4]) [2, 3, 5, 11, 4, 8] >>> sort_with_primes_first([17, 12, 19, 1, 6, 13]) [13, 17, 19, 1, 6, 12] pass","solution":"def is_prime(n): Check if a number is a prime number. Returns True if n is prime, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sort_with_primes_first(arr): Takes a list of integers and returns a new list with the integers sorted in ascending order, but with all prime numbers appearing before non-prime numbers. primes = sorted([x for x in arr if is_prime(x)]) non_primes = sorted([x for x in arr if not is_prime(x)]) return primes + non_primes"},{"question":"import re def isPalindrome(s: str) -> bool: Write a function \`isPalindrome\` which takes a string as input and returns \`True\` if the string is a palindrome (reads the same backward as forward), and \`False\` otherwise. Ignore spaces, punctuation, and case differences when determining if the string is a palindrome. >>> isPalindrome(\\"racecar\\") True >>> isPalindrome(\\"RaceCar\\") True >>> isPalindrome(\\"A man a plan a canal Panama\\") True >>> isPalindrome(\\"Was it a car or a cat I saw?\\") True >>> isPalindrome(\\"No 'x' in Nixon\\") True >>> isPalindrome(\\"This is not a palindrome\\") False >>> isPalindrome(\\"Random string\\") False","solution":"import re def isPalindrome(s): Returns True if the input string is a palindrome, False otherwise. Ignores spaces, punctuation, and case differences. # Remove non-alphanumeric characters and convert to lowercase cleaned_string = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if the cleaned string is the same forwards and backwards return cleaned_string == cleaned_string[::-1]"},{"question":"from typing import List def find_triplet_with_sum(arr: List[int], target_sum: int) -> bool: Determines if there exist three distinct elements in the array whose sum equals the target sum. Parameters: arr (list): The input array of integers target_sum (int): The target sum Returns: bool: True if there exists a triplet with the sum equal to target_sum, False otherwise. pass # Unit Test def test_find_triplet_with_sum_exists(): assert find_triplet_with_sum([12, 3, 4, 1, 6, 9], 24) == True assert find_triplet_with_sum([1, 2, 3, 4, 5], 9) == True assert find_triplet_with_sum([1, 4, 45, 6, 10, 8], 22) == True def test_find_triplet_with_sum_not_exists(): assert find_triplet_with_sum([1, 2, 3, 4, 5], 100) == False assert find_triplet_with_sum([], 1) == False assert find_triplet_with_sum([1, 2], 3) == False def test_find_triplet_with_sum_edge_cases(): assert find_triplet_with_sum([1, 1, 1, 1, 1], 3) == True assert find_triplet_with_sum([0, 0, 0, 0], 0) == True assert find_triplet_with_sum([-1, 0, 1, 2], 0) == True assert find_triplet_with_sum([1, 2, 3], 6) == True assert find_triplet_with_sum([1, 2, 3], 7) == False if __name__ == \\"__main__\\": test_find_triplet_with_sum_exists() test_find_triplet_with_sum_not_exists() test_find_triplet_with_sum_edge_cases() print(\\"All tests passed.\\")","solution":"def find_triplet_with_sum(arr, target_sum): Determines if there exist three distinct elements in the array whose sum equals the target sum. Parameters: arr (list): The input array of integers target_sum (int): The target sum Returns: bool: True if there exists a triplet with the sum equal to target_sum, False otherwise. arr.sort() n = len(arr) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target_sum: return True elif current_sum < target_sum: left += 1 else: right -= 1 return False"},{"question":"def canReachEnd(grid): Determines if there exists a path from the top-left corner to the bottom-right corner of the grid. :param grid: List[List[int]] - 2D list representing the grid where 0 is free space and 1 is an obstacle :return: bool - True if there exists a path, otherwise False >>> canReachEnd([[0, 0, 1, 0], [0, 0, 0, 0], [1, 0, 1, 0], [0, 0, 0, 0]]) True >>> canReachEnd([[0, 1], [1, 0]]) False >>> canReachEnd([[0]]) True >>> canReachEnd([[1]]) False >>> canReachEnd([[0]*50 + [1] + [0]*49 for _ in range(100)]) False >>> canReachEnd([[0]*100 for _ in range(100)]) True >>> canReachEnd([[1, 0], [0, 0]]) False >>> canReachEnd([[0, 0], [0, 1]]) False","solution":"def canReachEnd(grid): Determines if there exists a path from the top-left corner to the bottom-right corner of the grid. from collections import deque if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return False M, N = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (M - 1, N - 1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False"},{"question":"def sort_odd_numbers(arr): Given a list of unsorted integers, this function sorts the list in ascending order but only sorts the odd numbers while leaving the even numbers in their original positions. >>> sort_odd_numbers([5, 3, 2, 8, 1, 4]) [1, 3, 2, 8, 5, 4] >>> sort_odd_numbers([]) [] >>> sort_odd_numbers([2, 4, 6, 8]) [2, 4, 6, 8] >>> sort_odd_numbers([5, 3, 1, 7]) [1, 3, 5, 7] >>> sort_odd_numbers([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) [1, 8, 3, 6, 5, 4, 7, 2, 9, 0] >>> sort_odd_numbers([7]) [7] >>> sort_odd_numbers([2]) [2] >>> sort_odd_numbers([9, 2, 4, 6, 1]) [1, 2, 4, 6, 9]","solution":"def sort_odd_numbers(arr): odds = sorted([x for x in arr if x % 2 != 0]) result = [] odd_index = 0 for x in arr: if x % 2 == 0: result.append(x) else: result.append(odds[odd_index]) odd_index += 1 return result"},{"question":"def multiply_tuples(input_list: List[Tuple[int, int]]) -> List[int]: Multiplies elements of each tuple in the input list and returns a new list with the results. Args: input_list (list): A list of tuples, each containing a pair of integers. Returns: list: A list of integers where each element is the product of the elements of the corresponding tuple. >>> multiply_tuples([(2, 3), (4, 5), (6, 7)]) == [6, 20, 42] >>> multiply_tuples([]) == [] >>> multiply_tuples([(8, 9)]) == [72] >>> multiply_tuples([(0, 1), (5, 0)]) == [0, 0] >>> multiply_tuples([(-1, -2), (3, -4)]) == [2, -12] >>> multiply_tuples([(1, 2), (0, 3), (-4, 5), (6, -7)]) == [2, 0, -20, -42] >>> multiply_tuples([(0, 0), (0, 0)]) == [0, 0]","solution":"def multiply_tuples(input_list): Multiplies elements of each tuple in the input list and returns a new list with the results. Args: input_list (list): A list of tuples, each containing a pair of integers. Returns: list: A list of integers where each element is the product of the elements of the corresponding tuple. return [a * b for a, b in input_list]"},{"question":"def is_valid_ipv4_address(ip: str) -> bool: Determines if a given string is a valid IPv4 address. >>> is_valid_ipv4_address(\\"192.168.1.1\\") True >>> is_valid_ipv4_address(\\"0.0.0.0\\") True >>> is_valid_ipv4_address(\\"255.255.255.255\\") True >>> is_valid_ipv4_address(\\"128.0.0.1\\") True >>> is_valid_ipv4_address(\\"256.256.256.256\\") False >>> is_valid_ipv4_address(\\"192.168.1.256\\") False >>> is_valid_ipv4_address(\\"192.168.1\\") False >>> is_valid_ipv4_address(\\"192.168.1.1.1\\") False >>> is_valid_ipv4_address(\\"192.168.1.a\\") False >>> is_valid_ipv4_address(\\"\\") False >>> is_valid_ipv4_address(\\"...\\") False >>> is_valid_ipv4_address(\\"1.1.1.01\\") False >>> is_valid_ipv4_address(\\"01.01.01.01\\") False >>> is_valid_ipv4_address(\\"1.1.1.1\\") True","solution":"def is_valid_ipv4_address(ip): Determines if a given string is a valid IPv4 address. Parameters: ip (str): The string to be verified as an IPv4 address. Returns: bool: True if the string is a valid IPv4 address, otherwise False. parts = ip.split('.') if len(parts) != 4: return False for part in parts: if not part.isdigit(): return False num = int(part) if num < 0 or num > 255: return False if part != str(num): return False return True"},{"question":"def is_palindrome(s: str) -> bool: Analyze a given string and determine if it's a valid palindrome, ignoring case and non-alphanumeric characters. The function should return True if the string is a palindrome and False otherwise. >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") == True >>> is_palindrome(\\"No lemon, no melon\\") == True >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"Able , was I saw eLba\\") == True >>> is_palindrome(\\"This is not a palindrome\\") == False >>> is_palindrome(\\"12345\\") == False >>> is_palindrome(\\"abcdefg\\") == False >>> is_palindrome(\\"Racecar\\") == True >>> is_palindrome(\\"12321\\") == True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"Z\\") == True","solution":"import re def is_palindrome(s): Returns True if the given string is a valid palindrome, ignoring case and non-alphanumeric characters. Returns False otherwise. # Remove all non-alphanumeric characters and convert to lowercase cleaned_s = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if the cleaned string is equal to its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"def can_partition_k_subsets(arr: List[int], k: int) -> bool: Given an array of integers \`arr\` and an integer \`k\`, determine if you can divide the array into \`k\` non-empty subsets whose sums are all the same. >>> can_partition_k_subsets([4, 3, 2, 3, 5, 2, 1], 4) True >>> can_partition_k_subsets([1, 2, 3, 4], 3) False","solution":"def can_partition_k_subsets(arr, k): total_sum = sum(arr) if total_sum % k != 0: return False target_sum = total_sum // k used = [False] * len(arr) def can_partition(start_index, k_remaining, current_sum): if k_remaining == 0: return True if current_sum == target_sum: return can_partition(0, k_remaining - 1, 0) for i in range(start_index, len(arr)): if not used[i] and current_sum + arr[i] <= target_sum: used[i] = True if can_partition(i + 1, k_remaining, current_sum + arr[i]): return True used[i] = False return False return can_partition(0, k, 0)"},{"question":"import random class DiceRoller: A class to simulate rolling of two six-sided dice and keep the roll count. Methods: roll_dice -- Simulate rolling of two six-sided dice, return their sum and print roll count. >>> dice_roller = DiceRoller() >>> dice_roller.roll_dice() # Random result between 2 and 12 Roll count: 1 >>> dice_roller.roll_dice() # Another random result between 2 and 12 Roll count: 2 def __init__(self): self.counter = 0 def roll_dice(self): pass","solution":"import random class DiceRoller: def __init__(self): self.counter = 0 def roll_dice(self): self.counter += 1 die1 = random.randint(1, 6) die2 = random.randint(1, 6) result = die1 + die2 print(f\\"Roll count: {self.counter}\\") return result dice_roller = DiceRoller()"},{"question":"def find_common_elements(list1: list, list2: list) -> list: Given two lists of integers, return a list containing only the common elements between the two lists. The returned list should not contain duplicate elements, and the elements should be sorted in ascending order. >>> find_common_elements([1, 2, 3, 4, 5], [4, 5, 6, 7, 8]) [4, 5] >>> find_common_elements([10, 20, 30, 40], [50, 60, 70]) [] >>> find_common_elements([10, 10, 20, 20], [10, 30, 10]) [10] >>> find_common_elements([], [1, 2, 3]) [] >>> find_common_elements([1, 2, 3], []) [] >>> find_common_elements([1, 2, 3], [3, 2, 1]) [1, 2, 3] >>> find_common_elements([1], [1]) [1] >>> find_common_elements([1, 2], [1, 3]) [1] >>> find_common_elements([5, 10, 15], [10, 20, 25]) [10] >>> find_common_elements([-1, -2, -3], [1, 2, 3]) [] >>> find_common_elements([1, 2, 3, 4], [4, 5, 6, 2]) [2, 4]","solution":"def find_common_elements(list1: list, list2: list) -> list: Returns a list of common elements between list1 and list2 without duplicates and in ascending order. # Convert lists to sets to find common elements and eliminate duplicates set1 = set(list1) set2 = set(list2) # Find common elements common_elements = set1 & set2 # Convert to list and sort result = sorted(list(common_elements)) return result"},{"question":"def group_emails_by_domain(emails): Groups emails by their domain and returns a dictionary with domains as keys and lists of usernames as values. Filters out invalid email addresses. Args: emails (list of str): List containing email addresses as strings. Returns: dict: A dictionary with domain names as keys and lists of usernames as values. >>> emails = [ ... \\"alice@example.com\\", ... \\"bob@example.net\\", ... \\"carol@example.com\\", ... \\"dave@example.org\\", ... \\"eve@example.net\\", ... \\"invalid-email\\", ... \\"frank@@example.com\\" ... ] >>> group_emails_by_domain(emails) {'example.com': ['alice', 'carol'], 'example.net': ['bob', 'eve'], 'example.org': ['dave']} from solution import group_emails_by_domain def test_group_emails_by_domain_simple(): emails = [ \\"alice@example.com\\", \\"bob@example.net\\", \\"carol@example.com\\", \\"dave@example.org\\", \\"eve@example.net\\", \\"invalid-email\\", \\"frank@@example.com\\" ] result = group_emails_by_domain(emails) expected = { \\"example.com\\": [\\"alice\\", \\"carol\\"], \\"example.net\\": [\\"bob\\", \\"eve\\"], \\"example.org\\": [\\"dave\\"] } assert result == expected def test_empty_list(): assert group_emails_by_domain([]) == {} def test_all_invalid_emails(): emails = [ \\"invalid-email\\", \\"another-invalid-email\\", \\"yet-another-invalid-email\\" ] assert group_emails_by_domain(emails) == {} def test_multiple_emails_with_same_domain(): emails = [ \\"john@example.com\\", \\"jane@example.com\\", \\"joe@example.com\\" ] result = group_emails_by_domain(emails) expected = { \\"example.com\\": [\\"john\\", \\"jane\\", \\"joe\\"] } assert result == expected def test_mixed_valid_and_invalid_emails(): emails = [ \\"john@example.com\\", \\"invalid-email\\", \\"jane@sample.net\\", \\"@missing_username.com\\", \\"joe@\\", \\"missing_at_symbol.com\\" ] result = group_emails_by_domain(emails) expected = { \\"example.com\\": [\\"john\\"], \\"sample.net\\": [\\"jane\\"] } assert result == expected def test_empty_username_and_domain(): emails = [ \\"@\\", \\"normal@example.com\\", \\"@invalid\\", \\"also_invalid@\\", \\"@missing_both\\", \\"@@invalid\\" ] result = group_emails_by_domain(emails) expected = { \\"example.com\\": [\\"normal\\"] } assert result == expected","solution":"def group_emails_by_domain(emails): Groups emails by their domain and returns a dictionary with domains as keys and lists of usernames as values. Filters out invalid email addresses. Args: emails (list of str): List containing email addresses as strings. Returns: dict: A dictionary with domain names as keys and lists of usernames as values. email_dict = {} for email in emails: if '@' in email and email.count('@') == 1: username, domain = email.split('@') if domain and username: # Ensure both username and domain are non-empty if domain not in email_dict: email_dict[domain] = [] email_dict[domain].append(username) return email_dict"},{"question":"def merge_dicts(dict1: dict, dict2: dict) -> dict: Merges two dictionaries. In case of key conflict, sums the values from both dictionaries. >>> merge_dicts({'a': 1, 'b': 2}, {'c': 3, 'd': 4}) == {'a': 1, 'b': 2, 'c': 3, 'd': 4} >>> merge_dicts({'a': 1, 'b': 2}, {'a': 3, 'd': 4}) == {'a': 4, 'b': 2, 'd': 4} >>> merge_dicts({}, {'a': 3, 'b': 4}) == {'a': 3, 'b': 4}","solution":"def merge_dicts(dict1, dict2): Merges two dictionaries. In case of key conflict, sums the values from both dictionaries. result = dict1.copy() # start with keys and values of dict1 for key, value in dict2.items(): if key in result: result[key] += value # sum values if key exists in both dictionaries else: result[key] = value # add new key-value pair return result"},{"question":"import random from typing import List def generate_matrix(n: int) -> List[List[int]]: Generates an n x n matrix filled with random integers between 1 and 50 with each column in ascending order. >>> matrix = generate_matrix(4) >>> len(matrix) == 4 True >>> all(len(row) == 4 for row in matrix) True >>> all(matrix[row][col] <= matrix[row + 1][col] for col in range(4) for row in range(3)) True def rotate_matrix_90_degrees(matrix: List[List[int]]) -> List[List[int]]: Rotates the given matrix 90 degrees clockwise. >>> rotate_matrix_90_degrees([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix_90_degrees([[1]]) [[1]] >>> rotate_matrix_90_degrees([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16]]) [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]","solution":"import random def generate_matrix(n): Generates an n x n matrix filled with random integers between 1 and 50 with each column in ascending order. matrix = [] for _ in range(n): col = sorted(random.randint(1, 50) for _ in range(n)) matrix.append(col) # Transpose the columns into the correct form transposed_matrix = [[matrix[j][i] for j in range(n)] for i in range(n)] return transposed_matrix def rotate_matrix_90_degrees(matrix): Rotates the given matrix 90 degrees clockwise. n = len(matrix) rotated_matrix = [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] return rotated_matrix"},{"question":"def longest_increasing_path(matrix: List[List[int]]) -> int: Given a matrix of size m x n, find the length of the longest increasing path in the matrix. You can move in four directions: left, right, up, or down, and you may not move diagonally or revisit a cell. >>> longest_increasing_path([ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ]) 4 >>> longest_increasing_path([ ... [3, 4, 5], ... [3, 2, 6], ... [2, 2, 1] ... ]) 4 pass import pytest def test_example_one(): matrix = [ [9, 9, 4], [6, 6, 8], [2, 1, 1] ] assert longest_increasing_path(matrix) == 4 def test_example_two(): matrix = [ [3, 4, 5], [3, 2, 6], [2, 2, 1] ] assert longest_increasing_path(matrix) == 4 def test_single_element(): matrix = [ [42] ] assert longest_increasing_path(matrix) == 1 def test_all_elements_same(): matrix = [ [1, 1], [1, 1] ] assert longest_increasing_path(matrix) == 1 def test_large_increasing_path(): matrix = [ [1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9] ] assert longest_increasing_path(matrix) == 25 if __name__ == \\"__main__\\": pytest.main()","solution":"def longest_increasing_path(matrix): def dfs(x, y): if dp[x][y] != -1: return dp[x][y] max_path = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] > matrix[x][y]: max_path = max(max_path, 1 + dfs(nx, ny)) dp[x][y] = max_path return max_path if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] dp = [[-1] * n for _ in range(m)] return max(dfs(x, y) for x in range(m) for y in range(n))"},{"question":"def get_primes(n: int) -> List[int]: Returns a list of the first n prime numbers. >>> get_primes(0) [] >>> get_primes(1) [2] >>> get_primes(5) [2, 3, 5, 7, 11] >>> get_primes(10) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]","solution":"def get_primes(n): Returns a list of the first n prime numbers. if n < 1: return [] primes = [] candidate = 2 while len(primes) < n: for p in primes: if p * p > candidate: primes.append(candidate) break if candidate % p == 0: break else: primes.append(candidate) candidate += 1 return primes"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def findCycleStart(head: ListNode) -> ListNode: Write a function that identifies the start of a cycle in a singly linked list. If the list contains a cycle, your function should return the node where the cycle begins. If there is no cycle, return \`None\`. >>> head = ListNode(3) >>> node2 = ListNode(2) >>> head.next = node2 >>> node3 = ListNode(0) >>> node2.next = node3 >>> node4 = ListNode(-4) >>> node3.next = node4 >>> node4.next = node2 >>> findCycleStart(head) == node2 True >>> head = ListNode(1) >>> assert findCycleStart(head) == None # Your code here","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def findCycleStart(head: ListNode) -> ListNode: if not head or not head.next: return None slow = head fast = head # Detect if a cycle exists using the slow and fast pointers while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If no cycle exists, return None if not fast or not fast.next: return None # Move one pointer to the head and keep the other at the collision point # Each are k steps from the cycle start, where k is the distance to cycle start slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"def find_combinations(nums: List[int], target: int) -> List[List[int]]: Implement a function that takes a positive integer array as input, identifies all possible combinations of the array elements that sum up to a positive integer target, and returns the lists of these combinations in a non-decreasing order. Ensure each unique combination is returned only once, even if the elements in the array contain duplicates, and the elements in each combination must also be in non-decreasing order. >>> find_combinations([2, 3, 6, 7, 7], 7) [[2, 2, 3], [7]] >>> find_combinations([2, 2, 2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> find_combinations([2, 3, 5, 7], 10) [[2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 3, 5], [3, 7], [5, 5]]","solution":"from typing import List def find_combinations(nums: List[int], target: int) -> List[List[int]]: nums.sort() result = [] def backtrack(start, path, target): if target == 0: result.append(path) return for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue if nums[i] > target: break backtrack(i, path + [nums[i]], target - nums[i]) backtrack(0, [], target) return result"},{"question":"def remove_duplicates(lst): Extracts duplicates from the provided list while keeping the order of first appearances. >>> remove_duplicates([1, 2, 2, 3, 4, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([4, 5, 4, 6, 6, 7, 8, 8]) [4, 5, 6, 7, 8] >>> remove_duplicates([1, 2, 3, 1, 2, 3]) [1, 2, 3] >>> remove_duplicates([10, 20, 20, 30, 40, 50, 50, 60]) [10, 20, 30, 40, 50, 60] >>> remove_duplicates([5, 6, 7, 5, 6, 7, 8]) [5, 6, 7, 8] >>> remove_duplicates([]) [] >>> remove_duplicates([9, 8, 7, 6, 5]) [9, 8, 7, 6, 5]","solution":"def remove_duplicates(lst): Extracts duplicates from the provided list while keeping the order of first appearances. seen = set() result = [] for item in lst: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"def reverse_strings(strings: List[str]) -> List[str]: Returns a new list where each string from the input list is reversed. Args: strings (list of str): The list of strings to be reversed. Returns: list of str: The list with each string reversed. pass # Unit tests def test_reverse_strings_basic(): assert reverse_strings([\\"apple\\", \\"banana\\", \\"cherry\\"]) == [\\"elppa\\", \\"ananab\\", \\"yrrehc\\"] def test_reverse_strings_empty_list(): assert reverse_strings([]) == [] def test_reverse_strings_single_character_strings(): assert reverse_strings([\\"a\\", \\"b\\", \\"c\\"]) == [\\"a\\", \\"b\\", \\"c\\"] def test_reverse_strings_palindromes(): assert reverse_strings([\\"madam\\", \\"racecar\\", \\"level\\"]) == [\\"madam\\", \\"racecar\\", \\"level\\"] def test_reverse_strings_mixed_case(): assert reverse_strings([\\"Apple\\", \\"BaNana\\", \\"CheRry\\"]) == [\\"elppA\\", \\"anaNaB\\", \\"yrRehC\\"] def test_reverse_strings_with_spaces(): assert reverse_strings([\\"apple pie\\", \\"banana split\\", \\"cherry tart\\"]) == [\\"eip elppa\\", \\"tilps ananab\\", \\"trat yrrehc\\"]","solution":"def reverse_strings(strings): Returns a new list where each string from the input list is reversed. Args: strings (list of str): The list of strings to be reversed. Returns: list of str: The list with each string reversed. return [string[::-1] for string in strings]"},{"question":"def first_non_repeating_character(s: str) -> str: Write a function that takes a string as input and returns the first non-repeating character. If all characters are repeating, return a message indicating that. Consider case sensitivity. >>> first_non_repeating_character(\\"aabc\\") == 'b' >>> first_non_repeating_character(\\"abcabc\\") == \\"All characters are repeating\\" >>> first_non_repeating_character(\\"abcdef\\") == 'a' >>> first_non_repeating_character(\\"AaBbCc\\") == 'A' >>> first_non_repeating_character(\\"aA\\") == 'a' >>> first_non_repeating_character(\\"Aa\\") == 'A' >>> first_non_repeating_character(\\"\\") == \\"All characters are repeating\\" def test_first_non_repeating_character(): assert first_non_repeating_character(\\"aabc\\") == 'b' assert first_non_repeating_character(\\"abcabc\\") == \\"All characters are repeating\\" assert first_non_repeating_character(\\"abcdef\\") == 'a' assert first_non_repeating_character(\\"AaBbCc\\") == 'A' assert first_non_repeating_character(\\"aA\\") == 'a' assert first_non_repeating_character(\\"Aa\\") == 'A' assert first_non_repeating_character(\\"\\") == \\"All characters are repeating\\"","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If all characters are repeating, returns a message indicating that. Consider case sensitivity. char_count = {} # Count the occurrences of each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first non-repeating character for char in s: if char_count[char] == 1: return char return \\"All characters are repeating\\""},{"question":"def fibonacci_series(n: int) -> List[int]: Generates the Fibonacci series up to a given number \`n\`. Parameters: n (int): The upper limit for the Fibonacci series. Returns: List[int]: A list containing Fibonacci numbers up to \`n\`. >>> fibonacci_series(10) [0, 1, 1, 2, 3, 5, 8] >>> fibonacci_series(5) [0, 1, 1, 2, 3, 5] >>> fibonacci_series(0) [] >>> fibonacci_series(-2) []","solution":"def fibonacci_series(n): Generates the Fibonacci series up to a given number \`n\`. Parameters: n (int): The upper limit for the Fibonacci series. Returns: List[int]: A list containing Fibonacci numbers up to \`n\`. if n <= 0: return [] series = [0, 1] while True: next_value = series[-1] + series[-2] if next_value > n: break series.append(next_value) return series"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the given string. If there are no non-repeating characters, returns an empty string. The function is case-sensitive. :param s: Input string :return: First non-repeating character or empty string >>> first_non_repeating_character(\\"stress\\") 't' >>> first_non_repeating_character(\\"sTreSs\\") 'T' >>> first_non_repeating_character(\\"aabbcc\\") ''","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the given string. If there are no non-repeating characters, returns an empty string. The function is case-sensitive. :param s: Input string :return: First non-repeating character or empty string # Create a dictionary to store the count of each character char_count = {} # Count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character with a count of 1 for char in s: if char_count[char] == 1: return char # If no non-repeating character found, return empty string return \\"\\""},{"question":"def next_date(date_str: str) -> str: Calculate the next date given a date string in the format \\"DD-MM-YYYY\\". Ensure your function takes into account leap years and the varying number of days in each month. >>> next_date(\\"28-02-2020\\") '29-02-2020' >>> next_date(\\"31-12-2021\\") '01-01-2022' pass # Test cases def test_next_date_simple_cases(): assert next_date(\\"01-01-2022\\") == \\"02-01-2022\\" assert next_date(\\"28-02-2021\\") == \\"01-03-2021\\" assert next_date(\\"31-03-2021\\") == \\"01-04-2021\\" assert next_date(\\"30-04-2021\\") == \\"01-05-2021\\" assert next_date(\\"31-12-2021\\") == \\"01-01-2022\\" def test_next_date_leap_year(): assert next_date(\\"28-02-2020\\") == \\"29-02-2020\\" assert next_date(\\"29-02-2020\\") == \\"01-03-2020\\" def test_next_date_end_of_month(): assert next_date(\\"30-06-2021\\") == \\"01-07-2021\\" assert next_date(\\"31-12-2020\\") == \\"01-01-2021\\" def test_next_date_end_of_year(): assert next_date(\\"31-12-2020\\") == \\"01-01-2021\\" def test_next_date_start_of_new_year(): assert next_date(\\"31-12-1999\\") == \\"01-01-2000\\" assert next_date(\\"28-02-1900\\") == \\"01-03-1900\\" # not a leap year","solution":"def is_leap_year(year): Check if a given year is a leap year. return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0) def next_date(date_str): Calculate the next date given a date string in the format \\"DD-MM-YYYY\\". days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] # Parse the date string day, month, year = map(int, date_str.split('-')) # Check for leap year and adjust days in February if month == 2 and is_leap_year(year): days_in_month[1] = 29 # Increment the day day += 1 # Check if day exceeds the days in the current month if day > days_in_month[month - 1]: day = 1 month += 1 if month > 12: month = 1 year += 1 return f\\"{day:02d}-{month:02d}-{year:04d}\\""},{"question":"from typing import List def longest_consecutive(nums: List[int]) -> int: Finds the length of the longest consecutive sequence of integers in a list. Args: nums: A list of integers. Returns: An integer representing the length of the longest consecutive sequence. Examples: >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([0,3,7,2,5,8,4,6,0,1]) 9 >>> longest_consecutive([1,2,0,1]) 3 >>> longest_consecutive([]) 0 def test_longest_consecutive(): assert longest_consecutive([100, 4, 200, 1, 3, 2]) == 4 assert longest_consecutive([0,3,7,2,5,8,4,6,0,1]) == 9 assert longest_consecutive([1,2,0,1]) == 3 assert longest_consecutive([]) == 0 assert longest_consecutive([1]) == 1 assert longest_consecutive([10]) == 1 assert longest_consecutive([1, 10, 100]) == 1 assert longest_consecutive([5, 3, 7]) == 1 assert longest_consecutive([5, 5, 5]) == 1 assert longest_consecutive([-1, -2, -3, -4, 0, 1, 2, 3, 4]) == 9 assert longest_consecutive([-1, -2, -3, 0, 2, 3]) == 4","solution":"from typing import List def longest_consecutive(nums: List[int]) -> int: Finds the length of the longest consecutive sequence of integers in a list. Args: nums: A list of integers. Returns: An integer representing the length of the longest consecutive sequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: # Only start counting from numbers that are the beginning of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from typing import List def most_frequent_element(arr: List[int]) -> int: Returns the most frequent element in the array. If multiple elements have the same frequency, the smallest one is returned. >>> most_frequent_element([4, 1, 2, 2, 3, 3, 3, 4, 4, 4]) == 4 >>> most_frequent_element([1, 2, 2, 3, 3]) == 2 >>> most_frequent_element([7]) == 7 >>> most_frequent_element([]) raises ValueError >>> most_frequent_element([-1, -1, -2, -2, -3]) == -2 >>> most_frequent_element([9999999, 9999999, 1, 1, 1]) == 1 >>> most_frequent_element([5, 5, 5, 5, 5]) == 5 pass","solution":"from collections import Counter def most_frequent_element(arr): Returns the most frequent element in the array. If multiple elements have the same frequency, the smallest one is returned. if not arr: raise ValueError(\\"Input list is empty\\") # Count the frequency of each element in the list counter = Counter(arr) # Find the maximum frequency max_freq = max(counter.values()) # Find all elements that have the maximum frequency most_frequent = [k for k, v in counter.items() if v == max_freq] # Return the smallest element among those with the highest frequency return min(most_frequent)"},{"question":"def is_prime(n: int) -> bool: Determines if a number is prime. >>> is_prime(1) == False >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(7) == True >>> is_prime(9) == False def filter_primes(numbers: List[int]) -> List[int]: Returns a new list containing only the prime numbers from the original list. >>> filter_primes([10, 15, 3, 7, 19, 24, 5, 11]) == [3, 7, 19, 5, 11] >>> filter_primes([4, 6, 8, 12]) == [] >>> filter_primes([2, 3, 5, 11]) == [2, 3, 5, 11] >>> filter_primes([0, -1, -3, 17, 23]) == [17, 23] >>> filter_primes([]) == []","solution":"def is_prime(n): Determines if a number is prime. if n <= 1: return False for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return False return True def filter_primes(numbers): Returns a new list containing only the prime numbers from the original list. return [num for num in numbers if is_prime(num)]"},{"question":"def word_lengths(sentence: str) -> List[int]: '''Given a string of words, return the lengths of all the words in the string. >>> word_lengths(\\"The quick brown fox jumps over the lazy dog\\") [3, 5, 5, 3, 5, 4, 3, 4, 3] >>> word_lengths(\\"hello\\") [5] >>> word_lengths(\\"word\\") [4] >>> word_lengths(\\"\\") [] >>> word_lengths(\\"This is a TEST\\") [4, 2, 1, 4] >>> word_lengths(\\" Leading and trailing spaces \\") [7, 3, 8, 6] '''","solution":"def word_lengths(sentence): Given a string of words, return the lengths of all the words in the string. Parameters: sentence (str): A string of words separated by spaces. Returns: List[int]: A list of integers representing the lengths of each word. # Split the sentence into words words = sentence.split() # Return a list of the lengths of the words return [len(word) for word in words]"},{"question":"import re from collections import Counter def most_frequent_word(file_path): Reads a text file and returns the most frequently occurring word (case insensitive, punctuation ignored) along with its frequency. In case of a tie, returns any one of the most frequent words. pass import pytest @pytest.fixture(scope=\\"module\\") def setup_file(tmpdir_factory): Setup a sample file for testing. file = tmpdir_factory.mktemp(\\"data\\").join(\\"sample.txt\\") file.write(\\"Hello world! Hello everyone. This is a test. Hello test world.\\") return file def test_most_frequent_word_with_tie(setup_file): file = setup_file word, freq = most_frequent_word(str(file)) assert word in ['hello', 'test'], f\\"Expected 'hello' or 'test', but got '{word}'\\" assert freq == 3, f\\"Expected frequency 3, but got {freq}\\" def test_most_frequent_word_single_occurrence(tmpdir): file_path = tmpdir.join(\\"test.txt\\") file_path.write(\\"Only one word is here.\\") word, freq = most_frequent_word(str(file_path)) assert word == 'only' or word == 'one' or word == 'word' or word == 'is' or word == 'here', f\\"Unexpected word: {word}\\" assert freq == 1, f\\"Expected frequency 1, but got {freq}\\" def test_most_frequent_word_different_case(tmpdir): file_path = tmpdir.join(\\"case_test.txt\\") file_path.write(\\"Case case CASE test.\\") word, freq = most_frequent_word(str(file_path)) assert word == 'case', f\\"Expected 'case', but got '{word}'\\" assert freq == 3, f\\"Expected frequency 3, but got {freq}\\" def test_most_frequent_word_ignores_punctuation(tmpdir): file_path = tmpdir.join(\\"punctuation_test.txt\\") file_path.write(\\"Punctuation, should; not: affect! word.\\") word, freq = most_frequent_word(str(file_path)) assert word in ['punctuation', 'should', 'not', 'affect', 'word'], f\\"Unexpected word: {word}\\" assert freq == 1, f\\"Expected frequency 1, but got {freq}\\"","solution":"import re from collections import Counter def most_frequent_word(file_path): Reads a text file and returns the most frequently occurring word (case insensitive, punctuation ignored) along with its frequency. In case of a tie, returns any one of the most frequent words. with open(file_path, 'r') as file: text = file.read().lower() # Remove punctuation text = re.sub(r'[^ws]', '', text) # Split into words words = text.split() # Count frequencies word_counts = Counter(words) # Get the most common word most_common_word, frequency = word_counts.most_common(1)[0] return most_common_word, frequency"},{"question":"def sum_of_primes(n: int) -> int: Return the sum of all prime numbers less than a given number n using the Sieve of Eratosthenes algorithm. If n is less than or equal to 2, the function should return 0. Args: n (int): The upper limit (exclusive) to find the sum of primes. Returns: int: The sum of all prime numbers less than n. Examples: >>> sum_of_primes(10) 17 >>> sum_of_primes(20) 77 >>> sum_of_primes(0) 0 >>> sum_of_primes(2) 0 >>> sum_of_primes(3) 2 >>> sum_of_primes(4) 5 >>> sum_of_primes(100) 1060 from solution import sum_of_primes def test_sum_of_primes_less_than_10(): assert sum_of_primes(10) == 17 def test_sum_of_primes_less_than_20(): assert sum_of_primes(20) == 77 def test_sum_of_primes_with_zero(): assert sum_of_primes(0) == 0 def test_sum_of_primes_with_two(): assert sum_of_primes(2) == 0 def test_sum_of_primes_with_small_primes(): assert sum_of_primes(3) == 2 assert sum_of_primes(4) == 5 def test_sum_of_primes_large_number(): assert sum_of_primes(100) == 1060 # Additional edge case to test def test_sum_of_primes_with_negative_number(): assert sum_of_primes(-10) == 0","solution":"def sum_of_primes(n: int) -> int: Returns the sum of all prime numbers less than a given number n using the Sieve of Eratosthenes algorithm. if n <= 2: return 0 # Initialize a boolean array \\"prime[0..n-1]\\" and set all entries it as true # A value in prime[i] will finally be false if i is Not a prime, else true prime = [True] * n p = 2 while (p * p <= n): # If prime[p] is not changed, then it is a prime if prime[p]: # Updating all multiples of p to not be prime for i in range(p * p, n, p): prime[i] = False p += 1 # Sum all prime numbers return sum(p for p in range(2, n) if prime[p])"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_left_leaves(root: TreeNode) -> int: This function returns the sum of all left leaves in a binary tree. :param root: TreeNode, the root node of the binary tree :return: int, sum of all left leaves >>> tree = TreeNode(3) >>> tree.left = TreeNode(9) >>> tree.right = TreeNode(20) >>> tree.right.left = TreeNode(15) >>> tree.right.right = TreeNode(7) >>> sum_of_left_leaves(tree) 24 >>> sum_of_left_leaves(None) 0 >>> tree2 = TreeNode(1) >>> tree2.right = TreeNode(2) >>> sum_of_left_leaves(tree2) 0 >>> tree3 = TreeNode(1) >>> tree3.left = TreeNode(2) >>> tree3.left.left = TreeNode(3) >>> sum_of_left_leaves(tree3) 3 >>> tree4 = TreeNode(1) >>> tree4.left = TreeNode(2) >>> tree4.right = TreeNode(3) >>> tree4.left.left = TreeNode(4) >>> sum_of_left_leaves(tree4) 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_left_leaves(root): This function returns the sum of all left leaves in a binary tree. :param root: TreeNode, the root node of the binary tree :return: int, sum of all left leaves if not root: return 0 def is_leaf(node): return node and not node.left and not node.right def dfs(node): if not node: return 0 total_sum = 0 if is_leaf(node.left): total_sum += node.left.val total_sum += dfs(node.left) total_sum += dfs(node.right) return total_sum return dfs(root)"},{"question":"def total_distance(trips: list) -> float: Calculate the total distance covered by the vehicle given the series of recorded trip distances. >>> total_distance([15.2]) == 15.2 >>> total_distance([15.2, 23.6, 7.4, 10.1]) == 56.3 >>> total_distance([]) == 0.0 >>> total_distance([15.2, -5.2, 7.4]) == 17.4 >>> total_distance([1e6, 2e6, 3e6]) == 6e6","solution":"def total_distance(trips): Returns the total distance covered by summing all trip distances in the list. Args: trips (list of float): List of recorded trip distances. Returns: float: Total distance covered. return sum(trips)"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression string containing integers, +, -, *, /, and parentheses. Returns the result and ensures the standard order of operations (PEMDAS). The function should also validate the expression for balanced parentheses, invalid characters, and handle division by zero. >>> evaluate_expression(\\"2 + 3\\") == 5 >>> evaluate_expression(\\"(2 + 3) * 4\\") == 20 >>> evaluate_expression(\\"2 + (3 * 4)\\") == 14","solution":"def evaluate_expression(expression): Evaluates a mathematical expression string containing integers, +, -, *, /, and parentheses. Returns the result and ensures the standard order of operations (PEMDAS). # Ensure expression is a string if not isinstance(expression, str): raise TypeError(\\"Expression must be a string\\") # Check for invalid characters in the expression valid_chars = \\"0123456789+-*/() \\" for char in expression: if char not in valid_chars: raise ValueError(f\\"Invalid character found in the expression: {char}\\") # Evaluate the expression using Python's eval safely try: result = eval(expression, {\\"__builtins__\\": {}}, {}) except ZeroDivisionError: raise ZeroDivisionError(\\"Division by zero is not allowed\\") except Exception as e: raise ValueError(f\\"Invalid mathematical expression: {expression}\\") return result"},{"question":"def first_duplicate(nums: List[int]) -> int: Find the first duplicate number in a list of integers. If there are no duplicates, return -1. >>> first_duplicate([2, 3, 1, 2, 4, 3]) 2 >>> first_duplicate([1, 2, 3, 4, 5]) -1 >>> first_duplicate([-1, -2, -3, -4, -2]) -2","solution":"def first_duplicate(nums): Returns the first duplicate number in the list nums. If there are no duplicates, returns -1. seen = set() for num in nums: if num in seen: return num seen.add(num) return -1"},{"question":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number using dynamic programming. The function is optimized for large inputs. >>> fibonacci(0) == 0 >>> fibonacci(1) == 1 >>> fibonacci(2) == 1 >>> fibonacci(3) == 2 >>> fibonacci(4) == 3 >>> fibonacci(5) == 5 >>> fibonacci(10) == 55 >>> fibonacci(15) == 610 >>> fibonacci(50) == 12586269025 >>> fibonacci(100) == 354224848179261915075","solution":"def fibonacci(n): Returns the nth Fibonacci number using dynamic programming. The function is optimized for large inputs. if n <= 0: return 0 elif n == 1: return 1 # Initialize base cases fib = [0] * (n + 1) fib[1] = 1 # Compute Fibonacci numbers from 2 to n for i in range(2, n + 1): fib[i] = fib[i - 1] + fib[i - 2] return fib[n]"},{"question":"def celsius_to_fahrenheit(celsius_list): Converts a list of temperatures in Celsius to Fahrenheit. :param celsius_list: List of temperatures in Celsius :return: List of temperatures in Fahrenheit # Your code here","solution":"def celsius_to_fahrenheit(celsius_list): Converts a list of temperatures in Celsius to Fahrenheit. :param celsius_list: List of temperatures in Celsius :return: List of temperatures in Fahrenheit return [(c * 9/5) + 32 for c in celsius_list]"},{"question":"import re from collections import Counter def count_word_frequency(file_path: str) -> dict: Reads a text file, counts the frequency of each word, and returns a dictionary with words as keys and their frequency as values, sorted in descending order of frequency. The function handles punctuation and is case-insensitive. Empty lines in the text file are ignored gracefully. >>> count_word_frequency('sample.txt') {'test': 3, 'hello': 2, 'this': 2, 'is': 2, 'a': 2, 'world': 1, 'again': 1, 'testing': 1, 'one': 1, 'two': 1, 'three': 1, 'only': 1} >>> count_word_frequency('empty.txt') {}","solution":"import re from collections import Counter def count_word_frequency(file_path): Reads a text file, counts the frequency of each word, and returns a dictionary with words as keys and their frequency as values, sorted in descending order of frequency. with open(file_path, 'r') as file: text = file.read().lower() # Remove punctuation and split into words words = re.findall(r'bw+b', text) # Count the frequency of each word word_counts = Counter(words) # Sort words by frequency in descending order sorted_word_counts = dict(sorted(word_counts.items(), key=lambda item: item[1], reverse=True)) return sorted_word_counts"},{"question":"from typing import List def find_duplicate(nums: List[int]) -> int: Takes a list of integers and returns the element that appears more than once. If no such element exists, returns -1. The function should have a time complexity of O(n) and a space complexity of O(n). >>> find_duplicate([1, 2, 3, 4, 5]) == -1 >>> find_duplicate([1, 2, 3, 4, 2]) == 2 >>> find_duplicate([3, 3, 3, 3, 3, 3]) == 3 # Your code here","solution":"from typing import List def find_duplicate(nums: List[int]) -> int: Takes a list of integers and returns the element that appears more than once. If no such element exists, returns -1. seen = set() for num in nums: if num in seen: return num seen.add(num) return -1"},{"question":"def longest_common_substring(s1: str, s2: str) -> str: Given two strings, find the length of their longest common substring. If there are multiple longest common substrings of the same length, return the one which appears first in the first string. >>> longest_common_substring(\\"abcdef\\", \\"zcdemf\\") == \\"cde\\" >>> longest_common_substring(\\"abc\\", \\"def\\") == \\"\\" >>> longest_common_substring(\\"abcdef\\", \\"ghijkl\\") == \\"\\" >>> longest_common_substring(\\"abcdef\\", \\"bcdea\\") == \\"bcde\\"","solution":"def longest_common_substring(s1: str, s2: str) -> str: n = len(s1) m = len(s2) # Initialize the table with zeros dp = [[0] * (m + 1) for _ in range(n + 1)] longest_length = 0 longest_end_pos = 0 # Fill dp table for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 if dp[i][j] > longest_length: longest_length = dp[i][j] longest_end_pos = i else: dp[i][j] = 0 # The longest common substring return s1[longest_end_pos - longest_length: longest_end_pos]"},{"question":"from typing import List def most_frequent_char(text: str) -> str: Given a string, find the most frequently occurring character(s) while ignoring spaces and punctuation, considering only alphabetic characters and treating uppercase and lowercase as the same. In case of a tie, return all the characters tied for the most frequent, sorted alphabetically. >>> most_frequent_char(\\"aabbbcc\\") == \\"b\\" >>> most_frequent_char(\\"aabbcc\\") == \\"abc\\" >>> most_frequent_char(\\"AaBbCc\\") == \\"abc\\" >>> most_frequent_char(\\"a!@#b123c\\") == \\"abc\\" >>> most_frequent_char(\\"\\") == \\"\\" >>> most_frequent_char(\\"aaaa\\") == \\"a\\" >>> most_frequent_char(\\"The quick brown fox jumps over the lazy dog\\") == \\"o\\"","solution":"from collections import Counter import string def most_frequent_char(text): Returns the most frequently occurring characters in the given text. Ignores spaces, punctuation, and is case-insensitive. If there is a tie, returns all characters tied for most frequent, sorted alphabetically. # Filter out non-alphabetic characters and convert to lowercase filtered_text = ''.join([ch for ch in text.lower() if ch in string.ascii_lowercase]) # Count the frequency of each character freq = Counter(filtered_text) # Find the maximum frequency max_freq = max(freq.values(), default=0) # Find all characters with the maximum frequency most_frequent = [char for char, count in freq.items() if count == max_freq] # Sort alphabetically most_frequent.sort() return ''.join(most_frequent)"},{"question":"def closest_duration_pair(durations, target_duration): Find a pair of durations from the list whose sum is closest to the target duration. In case of multiple pairs with the same closest sum, return the pair with the smallest difference between the durations. If there are still multiple pairs, return the pair with the smallest individual duration first. >>> closest_duration_pair([45, 30, 60, 70, 15], 75) (30, 45) >>> closest_duration_pair([45, 30, 60, 70, 15], 85) (15, 70) >>> closest_duration_pair([10, 20, 30, 40], 50) (20, 30) >>> closest_duration_pair([5, 25, 30, 45, 50], 50) (5, 45) >>> closest_duration_pair([10, 1, 9, 20, 30], 11) (1, 10)","solution":"def closest_duration_pair(durations, target_duration): Finds the pair of durations whose sum is closest to the target duration. In case of multiple closest sums, returns the pair with the smallest difference. If still a tie, returns the pair with the smallest individual duration first. import itertools # If there are fewer than 2 durations, return None as we cannot form a pair if len(durations) < 2: return None closest_pair = None closest_sum_diff = float('inf') closest_diff = float('inf') # Checking all pairs of durations for dur1, dur2 in itertools.combinations(durations, 2): current_sum = dur1 + dur2 current_sum_diff = abs(current_sum - target_duration) current_diff = abs(dur1 - dur2) if current_sum_diff < closest_sum_diff: closest_pair = (min(dur1, dur2), max(dur1, dur2)) closest_sum_diff = current_sum_diff closest_diff = current_diff elif current_sum_diff == closest_sum_diff: if current_diff < closest_diff: closest_pair = (min(dur1, dur2), max(dur1, dur2)) closest_diff = current_diff elif current_diff == closest_diff: closest_pair = (min(dur1, dur2), max(dur1, dur2)) return closest_pair"},{"question":"def can_construct_words(word_list, char_list): Returns the number of words that can be constructed using the characters of the given list of strings. Each character in the second list may only be used once per string formation. >>> can_construct_words([\\"apple\\", \\"banana\\", \\"orange\\", \\"grape\\"], [\\"aelpp\\", \\"aaabnn\\", \\"ognera\\", \\"grape\\"]) 4 >>> can_construct_words([\\"apple\\", \\"banana\\", \\"orange\\", \\"grape\\"], [\\"aelpp\\", \\"nnaa\\", \\"ognera\\", \\"grape\\"]) 3 >>> can_construct_words([\\"apple\\", \\"banana\\", \\"orange\\", \\"grape\\"], [\\"elp\\", \\"an\\", \\"org\\", \\"grp\\"]) 0 >>> can_construct_words([\\"hello\\", \\"world\\", \\"python\\"], [\\"helo\\", \\"wodrl\\", \\"pytohn\\", \\"lllhello\\"]) 3 >>> can_construct_words([], [\\"aelpp\\", \\"aaabnn\\", \\"ognera\\", \\"grape\\"]) 0 >>> can_construct_words([\\"apple\\", \\"banana\\", \\"orange\\", \\"grape\\"], []) 0","solution":"from collections import Counter def can_construct_words(word_list, char_list): Returns the number of words that can be constructed using the characters of the given list of strings. Each character in the second list may only be used once per string formation. count = 0 for word in word_list: word_counter = Counter(word) for char_set in char_list: char_counter = Counter(char_set) if all(word_counter[char] <= char_counter[char] for char in word_counter): count += 1 break # Move to the next word if this one can be constructed return count"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> bool: Returns True if there are two distinct numbers in the list that add up to the target. >>> two_sum([1, 2, 3, 9], 8) False >>> two_sum([1, 2, 4, 4], 8) True >>> two_sum([], 8) False >>> two_sum([5], 5) False >>> two_sum([-1, -2, -3, -4], -6) True >>> two_sum([1, 5, 3, -2, 10], 8) True >>> two_sum([10, 5, 3, -2, 1], 8) True >>> two_sum([4, 4, 4, 4], 8) True >>> two_sum([10000000, 15000000, -30000000, 50000000], 20000000) True","solution":"def two_sum(nums, target): Returns True if there are two distinct numbers in the list that add up to the target. Args: nums: List of integers. target: Integer target. Returns: A boolean value indicating if there are two distinct numbers in the list that add up to the target. seen = set() for num in nums: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"def process_list(lst: List[int]) -> List[int]: Returns a new list where each integer is squared if it is odd, and left unchanged if it is even. >>> process_list([1, 3, 5, 7]) [1, 9, 25, 49] >>> process_list([2, 4, 6, 8]) [2, 4, 6, 8] >>> process_list([4, 7, 2, 9, 3, 8, 6]) [4, 49, 2, 81, 9, 8, 6] >>> process_list([]) [] >>> process_list([5]) [25] >>> process_list([8]) [8] pass # Your implementation goes here","solution":"def process_list(lst): Returns a new list where each integer is squared if it is odd, and left unchanged if it is even. return [x**2 if x % 2 != 0 else x for x in lst] # Apply the function to the given list result = process_list([4, 7, 2, 9, 3, 8, 6]) print(result) # result should be: [4, 49, 2, 81, 9, 8, 6]"},{"question":"from typing import List, Tuple def two_sum(nums: List[int], target: int) -> Tuple[int, int]: Find indices of two numbers in the list that add up to the target. Args: nums: List of integers. target: Target sum. Returns: A tuple containing indices of the two numbers. >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([3, 2, 4], 6) (1, 2) >>> two_sum([3, 3], 6) (0, 1) >>> two_sum([-1, -2, -3, -4, -5], -8) (2, 4) >>> two_sum([1, -2, 3, 4, -3], 0) (2, 4)","solution":"from typing import List, Tuple def two_sum(nums: List[int], target: int) -> Tuple[int, int]: Find indices of two numbers in the list that add up to the target. Args: nums: List of integers. target: Target sum. Returns: A tuple containing indices of the two numbers. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index"},{"question":"from typing import List def findSubsequences(nums: List[int]) -> List[List[int]]: Return all possible subsequences of nums in strictly increasing order. >>> sorted(findSubsequences([4, 6, 7, 7])) [[4, 6], [4, 6, 7], [4, 6, 7, 7], [4, 7], [4, 7, 7], [6, 7], [6, 7, 7], [7, 7]] >>> findSubsequences([10]) [] >>> sorted(findSubsequences([1, 2, 3])) [[1, 2], [1, 2, 3], [1, 3], [2, 3]] >>> findSubsequences([1, 1, 1]) [[1, 1], [1, 1, 1]] >>> sorted(findSubsequences([-1, 0, 1])) [[-1, 0], [-1, 0, 1], [-1, 1], [0, 1]]","solution":"from typing import List def findSubsequences(nums: List[int]) -> List[List[int]]: def backtrack(start: int, path: List[int]): if len(path) > 1: result.add(tuple(path)) for i in range(start, len(nums)): if not path or nums[i] >= path[-1]: path.append(nums[i]) backtrack(i + 1, path) path.pop() result = set() backtrack(0, []) return [list(seq) for seq in result]"},{"question":"def evaluate_expression(expression: str) -> str: Evaluates the given arithmetic expression string according to PEMDAS/BODMAS rules. Handles exceptions and returns meaningful messages for incorrect input formats. >>> evaluate_expression(\\"2 + 3\\") 5 >>> evaluate_expression(\\"10 - 3\\") 7 >>> evaluate_expression(\\"4 * 5\\") 20 >>> evaluate_expression(\\"10 / 2\\") 5 >>> evaluate_expression(\\"2 + 3 * 4 - 5\\") 9 >>> evaluate_expression(\\"(2 + 3) * 4 - 5\\") 15 >>> evaluate_expression(\\"10 / 0\\") 'Division by zero error' >>> evaluate_expression(\\"10 + abc\\") 'Invalid characters in the expression' >>> evaluate_expression(\\"10 + * 3\\") 'Syntax error in the expression'","solution":"def evaluate_expression(expression): Evaluates the given arithmetic expression string according to PEMDAS/BODMAS rules. try: # Define the allowed characters allowed_chars = set(\\"0123456789+-*/(). \\") # Check for any invalid characters in the expression if not all(char in allowed_chars for char in expression): return \\"Invalid characters in the expression\\" # Evaluate the expression result = eval(expression) return result except ZeroDivisionError: return \\"Division by zero error\\" except SyntaxError: return \\"Syntax error in the expression\\" except Exception as e: return f\\"Error: {str(e)}\\""},{"question":"from typing import List def list_intersection(list1: List[int], list2: List[int]) -> List[int]: Write a Python function that receives two lists of integers and returns a new list that includes the elements found in both input lists (intersection), sorted in ascending order. Each number should appear in the resulting list only once, even if it is repeated in the input lists. Avoid using built-in set operations. >>> list_intersection([4, 9, 5], [9, 4, 9, 8, 4]) == [4, 9] >>> list_intersection([1, 2, 2, 1], [2, 2]) == [2] >>> list_intersection([1, 2, 3], [4, 5, 6]) == []","solution":"def list_intersection(list1, list2): Returns a sorted list containing unique elements found in both input lists. intersection = [] for num in list1: if num in list2 and num not in intersection: intersection.append(num) return sorted(intersection)"},{"question":"def count_unique_elements(lst: List[int]) -> int: Returns the number of unique elements in the given list. >>> count_unique_elements([1, 2, 3, 2, 1, 4]) 4 >>> count_unique_elements([-1, -1, 0, 1, 2, -1, 2]) 4 >>> count_unique_elements([1, 2, 3, 4, 5]) 5 >>> count_unique_elements([7, 7, 7, 7, 7]) 1 >>> count_unique_elements([]) 0 >>> count_unique_elements([8]) 1","solution":"def count_unique_elements(lst): Returns the number of unique elements in the given list. return len(set(lst))"},{"question":"import re import collections def most_frequent_word(text: str) -> str: Returns the word that appears the most frequently in the given text. In case of a tie, return any one of the most frequent words. Only considers alphabetic words for frequency counting. >>> most_frequent_word(\\"the quick brown fox jumps over the lazy dog the fox was quick\\") 'the' >>> most_frequent_word(\\"\\") '' >>> most_frequent_word(\\"cat dog mouse cat dog mouse\\") 'cat' >>> most_frequent_word(\\"hello, world! Hello... world? HELLO: world.\\") 'hello' >>> most_frequent_word(\\"unique\\") 'unique' # Your code here pass","solution":"import collections import re def most_frequent_word(text): Returns the word that appears the most frequently in the given text. If the text is empty or words have same frequency, returns any one of the most frequent words. Only considers alphabetic words for frequency counting. if not text: return \\"\\" words = re.findall(r'b[a-zA-Z]+b', text) word_count = collections.Counter(words) most_common_word = word_count.most_common(1) return most_common_word[0][0] if most_common_word else \\"\\""},{"question":"def remove_duplicates(lst): Returns a list with all duplicate entries removed, preserving the original order. >>> remove_duplicates([4, 5, 4, 2, 3, 2, 1, 5]) [4, 5, 2, 3, 1] >>> remove_duplicates([]) [] >>> remove_duplicates([1, 2, 3]) [1, 2, 3] >>> remove_duplicates([42]) [42] >>> remove_duplicates([7, 7, 7, 7]) [7]","solution":"def remove_duplicates(lst): Returns a list with all duplicate entries removed, preserving the original order. seen = set() result = [] for item in lst: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"def spiral_order(matrix: List[List[int]]) -> List[int]: Returns the elements of the matrix in spiral order. >>> spiral_order([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiral_order([ ... [1] ... ]) [1] >>> spiral_order([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10] >>> spiral_order([ ... [1, 2, 3], ... [4, 5, 6] ... ]) [1, 2, 3, 6, 5, 4] >>> spiral_order([]) []","solution":"def spiral_order(matrix): Returns the elements of the matrix in spiral order. if not matrix: return [] result = [] while matrix: result += matrix.pop(0) if matrix and matrix[0]: for row in matrix: result.append(row.pop()) if matrix: result += matrix.pop()[::-1] if matrix and matrix[0]: for row in matrix[::-1]: result.append(row.pop(0)) return result"},{"question":"def evaluate_expression(expression: str) -> int: Write a function that takes a string containing a mathematical expression and evaluates it. The expression will contain non-negative integers and the operators \`+\`, \`-\`, \`*\`, and \`/\` (integer division). The expression might contain spaces for enhanced readability. You need to handle operator precedence correctly (multiplication and division before addition and subtraction). >>> evaluate_expression(\\"3+5 / 2\\") 5 >>> evaluate_expression(\\" 3+2*2 \\") 7 >>> evaluate_expression(\\" 12 + 3 / 3 * 2\\") 14 >>> evaluate_expression(\\"100\\") 100 >>> evaluate_expression(\\"1 - 1 + 1 \\") 1","solution":"def evaluate_expression(expression: str) -> int: def operate(a, b, op): if op == '+': return a + b elif op == '-': return a - b elif op == '*': return a * b elif op == '/': return a // b num, stack, sign, i = 0, [], '+', 0 while i < len(expression): if expression[i].isdigit(): while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack.append(stack.pop() * num) elif sign == '/': stack.append(int(stack.pop() / num)) num = 0 elif expression[i] in '+-*/': sign = expression[i] i += 1 else: i += 1 return sum(stack)"},{"question":"def find_max_length(nums: List[int]) -> int: Returns the length of the longest contiguous subarray with an equal number of 0s and 1s. >>> find_max_length([0, 0, 1, 0, 1, 1, 0]) == 6 >>> find_max_length([0, 0, 0, 0]) == 0 >>> find_max_length([1, 1, 1, 1]) == 0 >>> find_max_length([0, 1, 0, 1, 0, 1, 1, 0]) == 8 >>> find_max_length([0, 1]) == 2 >>> find_max_length([0, 0, 1]) == 2 >>> find_max_length([0, 1, 1, 0, 1, 1, 0, 0]) == 8","solution":"def find_max_length(nums): Returns the length of the longest contiguous subarray with an equal number of 0s and 1s. count = 0 max_length = 0 count_map = {0: -1} # Initialize with count 0 at index -1 for i, num in enumerate(nums): if num == 0: count -= 1 else: count += 1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"import random def f(x): The function to be maximized: f(x) = -x^2 + 6x - 5 return -x**2 + 6*x - 5 def hill_climb(start=None, step_size=0.1, interval=(0, 5)): Basic hill climbing algorithm to find the maximum value of f(x) on the interval [0, 5]. Parameters: - start: Initial point to start the search (optional, if not provided, a random point within the interval will be chosen) - step_size: The size of the steps to take - interval: The interval to search within Returns: - A tuple (x, value) where \`x\` is the point at which the function's maximum value is found and \`value\` is the maximum value of the function \`f(x)\`. Example: >>> x, value = hill_climb() >>> 0 <= x <= 5 True >>> np.allclose(value, 4, atol=0.1) True from solution import hill_climb, f import numpy as np def test_is_in_interval(): x, value = hill_climb(start=2.5) assert 0 <= x <= 5, f\\"x = {x} not within the interval [0, 5].\\" def test_maximum_value(): x, value = hill_climb(start=2.5) # As per the given quadratic function, maximum should be around x=3 for f(x)=4 assert np.allclose(x, 3, atol=0.1), f\\"x = {x} is not close to 3.\\" assert np.allclose(value, 4, atol=0.1), f\\"f(x) = {value} is not close to 4.\\" def test_edge_cases(): for start in [0, 5]: x, value = hill_climb(start=start) assert 0 <= x <= 5, f\\"x = {x} not within the interval [0, 5].\\" def test_random_starts(): for _ in range(5): x, value = hill_climb() assert 0 <= x <= 5, f\\"x = {x} not within the interval [0, 5].\\" # As per the given quadratic function, maximum should be around x=3 for f(x)=4 assert np.allclose(x, 3, atol=0.1), f\\"x = {x} is not close to 3.\\" assert np.allclose(value, 4, atol=0.1), f\\"f(x) = {value} is not close to 4.\\"","solution":"import random def f(x): The function to be maximized: f(x) = -x^2 + 6x - 5 return -x**2 + 6*x - 5 def hill_climb(start=None, step_size=0.1, interval=(0, 5)): Basic hill climbing algorithm to find the maximum value of f(x) on the interval [0, 5]. if start is None: start = random.uniform(interval[0], interval[1]) current_x = start current_val = f(current_x) while True: next_x_left = max(current_x - step_size, interval[0]) next_x_right = min(current_x + step_size, interval[1]) next_val_left = f(next_x_left) next_val_right = f(next_x_right) if next_val_left > current_val: current_x = next_x_left current_val = next_val_left elif next_val_right > current_val: current_x = next_x_right current_val = next_val_right else: break return current_x, current_val"},{"question":"def longest_palindrome(s: str) -> str: Returns the longest palindromic substring in s. If there are multiple palindromes of the same length, return the first one that appears. >>> longest_palindrome(\\"\\") \\"\\" >>> longest_palindrome(\\"a\\") \\"a\\" >>> longest_palindrome(\\"aa\\") \\"aa\\" >>> longest_palindrome(\\"ab\\") \\"a\\" >>> longest_palindrome(\\"racecar\\") \\"racecar\\" >>> longest_palindrome(\\"babad\\") \\"bab\\" or \\"aba\\" >>> longest_palindrome(\\"abacdfgdcaba\\") \\"aba\\" >>> longest_palindrome(\\"xyzzyx\\") \\"xyzzyx\\" >>> longest_palindrome(\\"abacdfgdcabba\\") \\"abba\\" >>> longest_palindrome(\\"forgeeksskeegfor\\") \\"geeksskeeg\\" >>> longest_palindrome(\\"abcdefg\\") \\"a\\" pass # your implementation here","solution":"def longest_palindrome(s): Returns the longest palindromic substring in s. If there are multiple palindromes of the same maximum length, the first one is returned. if not s: return \\"\\" n = len(s) start, max_length = 0, 1 # The longest palindrome's start index and length # Create a 2D DP table to keep track of palindromes dp = [[False for _ in range(n)] for _ in range(n)] # All substrings of length 1 are palindromes for i in range(n): dp[i][i] = True # Check for substrings of length 2 for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True start = i max_length = 2 # Check for lengths greater than 2 for k in range(3, n+1): # k is the length of the substring for i in range(n-k+1): j = i + k - 1 # Ending index of the current substring # dp[i+1][j-1] was true and the characters at i and j are the same if dp[i+1][j-1] and s[i] == s[j]: dp[i][j] = True if k > max_length: start = i max_length = k return s[start:start + max_length]"},{"question":"def process_floats(strings: List[str]) -> Tuple[float, List[float]]: Takes a list of strings, where each string represents a floating-point number. Returns a tuple containing the sum of all the floating-point numbers, and a list of those floating-point numbers rounded to one decimal place. :param strings: List of strings :return: Tuple containing the sum of floating-point numbers and the list of rounded floats >>> process_floats([\\"1.234\\", \\"5.678\\", \\"9.1011\\"]) (16.0131, [1.2, 5.7, 9.1]) >>> process_floats([\\"0.0\\", \\"0.0\\", \\"0.0\\"]) (0.0, [0.0, 0.0, 0.0]) >>> process_floats([]) (0.0, []) >>> process_floats([\\"-1.5\\", \\"-2.5\\", \\"-3.4444\\"]) (-7.4444, [-1.5, -2.5, -3.4]) >>> process_floats([\\"1.234\\", \\"-5.678\\", \\"0.0\\", \\"2.222\\"]) (-2.222, [1.2, -5.7, 0.0, 2.2]) >>> process_floats([\\"123456.789\\", \\"987654.321\\"]) (1111111.11, [123456.8, 987654.3])","solution":"def process_floats(strings): Takes a list of strings, where each string represents a floating-point number. Returns a tuple containing the sum of all the floating-point numbers, and a list of those floating-point numbers rounded to one decimal place. :param strings: list of strings :return: tuple (sum of floating-point numbers, list of rounded floating-point numbers) floats = [float(s) for s in strings] total_sum = sum(floats) rounded_floats = [round(f, 1) for f in floats] return total_sum, rounded_floats"},{"question":"def longest_substring_distinct(s: str) -> int: Returns the length of the longest substring with all distinct characters. >>> longest_substring_distinct(\\"pwwkew\\") 3 >>> longest_substring_distinct(\\"\\") 0 >>> longest_substring_distinct(\\"a\\") 1 >>> longest_substring_distinct(\\"bbbbbb\\") 1 >>> longest_substring_distinct(\\"abcdef\\") 6 >>> longest_substring_distinct(\\"abcddefgh\\") 5 >>> longest_substring_distinct(\\"abcdefghijj\\") 10 >>> longest_substring_distinct(\\"aaaaabcdefghij\\") 10","solution":"def longest_substring_distinct(s): Returns the length of the longest substring with all distinct characters. if len(s) <= 1: return len(s) max_length = 0 start = 0 seen = {} for end in range(len(s)): if s[end] in seen: start = max(start, seen[s[end]] + 1) seen[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List, Tuple def find_pairs_with_target_sum(arr: List[int], target: int) -> List[Tuple[int, int]]: Returns a list of unique pairs where the sum of each pair equals the target integer. The pairs in the resulting array are in non-decreasing order based on the first element, and if the first elements are the same, based on the second element. >>> find_pairs_with_target_sum([1, 2, 3, 4, 5, 6], 7) == [(1, 6), (2, 5), (3, 4)] >>> find_pairs_with_target_sum([1, 1, 2, 45, 46, 46], 47) == [(1, 46), (2, 45)] >>> find_pairs_with_target_sum([3, 3, 4, 4], 8) == [(4, 4)] >>> find_pairs_with_target_sum([1, 2, 3], 10) == []","solution":"from typing import List, Tuple def find_pairs_with_target_sum(arr: List[int], target: int) -> List[Tuple[int, int]]: Returns a list of unique pairs where the sum of each pair equals the target integer. The pairs in the resulting array are in non-decreasing order based on the first element, and if the first elements are the same, based on the second element. arr.sort() left, right = 0, len(arr) - 1 result = [] seen = set() while left < right: current_sum = arr[left] + arr[right] if current_sum == target: if (arr[left], arr[right]) not in seen: result.append((arr[left], arr[right])) seen.add((arr[left], arr[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return result"},{"question":"def divisible_by_n(n: int, lst: List[int]) -> List[int]: Returns a list of integers from the input list that are divisible by n. >>> divisible_by_n(3, [1, 2, 4, 5]) == [] >>> divisible_by_n(3, [3, 1, 4, 9, 6, 10]) == [3, 9, 6] >>> divisible_by_n(2, [2, 4, 6, 8, 10]) == [2, 4, 6, 8, 10] >>> divisible_by_n(3, [-3, -6, -7, -9]) == [-3, -6, -9] >>> divisible_by_n(3, [0, 1, 2, 3]) == [0, 3] >>> divisible_by_n(100, [1, 2, 3, 4, 5]) == []","solution":"def divisible_by_n(n, lst): Returns a list of integers from the input list that are divisible by n. Parameters: n (int): The divisor. lst (list): The list of integers. Returns: list: A list of integers divisible by n. return [x for x in lst if x % n == 0] # Time Complexity: O(m), where m is the length of the input list. # We iterate through each element of the list once to check if it is divisible by n."},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def find_middle_element(head: ListNode) -> int: Finds and returns the middle element of a linked list. If the linked list has an even number of elements, it returns the second of the two middle elements. >>> head = create_linked_list([4]) >>> find_middle_element(head) 4 >>> head = create_linked_list([4, 5, 1, 8, 9]) >>> find_middle_element(head) 1 >>> head = create_linked_list([4, 5, 1, 8]) >>> find_middle_element(head) 1 >>> head = create_linked_list([4, 5]) >>> find_middle_element(head) 5 def create_linked_list(values): head = ListNode(values[0]) current = head for val in values[1:]: current.next = ListNode(val) current = current.next return head","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def find_middle_element(head): Finds and returns the middle element of a linked list. If the linked list has an even number of elements, it returns the second of the two middle elements. slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next return slow.val"},{"question":"def permutable_palindrome(s: str) -> bool: Returns True if the input string s can be rearranged to form a palindrome, otherwise returns False. Example usage: >>> permutable_palindrome(\\"carrace\\") True >>> permutable_palindrome(\\"hello\\") False","solution":"def permutable_palindrome(s: str) -> bool: Returns True if the input string s can be rearranged to form a palindrome, otherwise returns False. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be permuted to a palindrome if it has at most one character # with an odd frequency. return odd_count <= 1"},{"question":"def remove_duplicates(lst): Returns a new list with duplicates removed while maintaining the original order of their first occurrences. Args: lst: List of positive integers Returns: List of integers with duplicates removed >>> remove_duplicates([1, 2, 3, 2, 1]) == [1, 2, 3] >>> remove_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> remove_duplicates([1, 1, 1, 1, 1]) == [1] >>> remove_duplicates([]) == [] >>> remove_duplicates([1, 2, 3, 4, 5] * 100) == [1, 2, 3, 4, 5]","solution":"def remove_duplicates(lst): Returns a new list with duplicates removed while maintaining the original order of their first occurrences. Args: lst: List of positive integers Returns: List of integers with duplicates removed seen = set() result = [] for num in lst: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"def length_of_shortest_word(s: str) -> int: Returns the length of the shortest word in the string s. >>> length_of_shortest_word(\\"The quick brown fox jumps over the lazy dog\\") 3 >>> length_of_shortest_word(\\"Hello\\") 5 >>> length_of_shortest_word(\\"This is a test sentence\\") 1 >>> length_of_shortest_word(\\"dog cat bat rat\\") 3 >>> length_of_shortest_word(\\"a b c d e\\") 1 >>> length_of_shortest_word(\\"\\") 0 >>> length_of_shortest_word(\\" \\") 0 >>> length_of_shortest_word(\\" Leading and trailing spaces \\") 3 >>> length_of_shortest_word(\\"Word with mixed spaces\\") 4 >>> length_of_shortest_word(\\"Hello, world! This, is a test.\\") 1","solution":"def length_of_shortest_word(s): Returns the length of the shortest word in the string s. words = s.split() if not words: return 0 shortest_length = min(len(word) for word in words) return shortest_length"},{"question":"def longest_valid_parentheses(s: str) -> int: Find the length of the longest valid (well-formed) parentheses substring. >>> longest_valid_parentheses(\\"(()())\\") 6 >>> longest_valid_parentheses(\\")()())\\") 4 >>> longest_valid_parentheses(\\"\\") 0 >>> longest_valid_parentheses(\\")))(((\\") 0 >>> longest_valid_parentheses(\\"()(()\\") 2 >>> longest_valid_parentheses(\\"(((((\\") 0 >>> longest_valid_parentheses(\\")))))\\") 0 >>> longest_valid_parentheses(\\"()()()\\") 6 >>> longest_valid_parentheses(\\")(()())(\\") 6","solution":"def longest_valid_parentheses(s: str) -> int: Function to find the length of the longest valid (well-formed) parentheses substring. stack = [-1] max_length = 0 for i, char in enumerate(s): if char == '(': stack.append(i) else: stack.pop() if len(stack) == 0: stack.append(i) else: max_length = max(max_length, i - stack[-1]) return max_length"},{"question":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.linear_model import LogisticRegression from sklearn.metrics import accuracy_score def classify_text_messages(file_path: str) -> float: Classify text messages into categories such as \\"spam\\" or \\"ham\\". Args: file_path (str): Path to the CSV file containing text messages and their labels. Returns: float: Accuracy of the Logistic Regression model on the test data. Example: >>> classify_text_messages(\\"test_text_messages.csv\\") 0.8 # Load dataset data = pd.read_csv(file_path) # Ensure labels are of categorical type data['label'] = data['label'].astype(str) # Feature extraction vectorizer = TfidfVectorizer() X = vectorizer.fit_transform(data['message']) y = data['label'] # Split the data X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Train the model model = LogisticRegression() model.fit(X_train, y_train) # Predict on test data predictions = model.predict(X_test) # Calculate accuracy accuracy = accuracy_score(y_test, predictions) return accuracy # Unit Tests def test_classify_text_messages(): # Create a simple dataset for testing data = { 'message': ['hello world', 'buy now', 'hello', 'limited time offer', 'discount available'], 'label': ['ham', 'spam', 'ham', 'spam', 'spam'] } df = pd.DataFrame(data) # Save the DataFrame to a CSV file test_file_path = \\"test_text_messages.csv\\" df.to_csv(test_file_path, index=False) # Run the classification function accuracy = classify_text_messages(test_file_path) # Check if accuracy is a float and within valid range [0.0, 1.0] assert isinstance(accuracy, float) assert 0.0 <= accuracy <= 1.0","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.linear_model import LogisticRegression from sklearn.metrics import accuracy_score def classify_text_messages(file_path): # Load dataset data = pd.read_csv(file_path) # Ensure labels are of categorical type data['label'] = data['label'].astype(str) # Feature extraction vectorizer = TfidfVectorizer() X = vectorizer.fit_transform(data['message']) y = data['label'] # Split the data X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Train the model model = LogisticRegression() model.fit(X_train, y_train) # Predict on test data predictions = model.predict(X_test) # Calculate accuracy accuracy = accuracy_score(y_test, predictions) return accuracy # Usage # file_path = \\"path_to_file/text_messages.csv\\" # print(classify_text_messages(file_path))"},{"question":"from typing import List def sum_neighbors(lst: List[int]) -> List[int]: Takes a list of integers and returns a new list with each element being the sum of its neighbors and itself. If the list has fewer than 3 elements, the original list is returned. >>> sum_neighbors([1, 2, 3, 4]) == [3, 6, 9, 7] >>> sum_neighbors([5, 10, 15, 20, 25]) == [15, 30, 45, 60, 45] >>> sum_neighbors([1, 1, 1, 1]) == [2, 3, 3, 2] >>> sum_neighbors([1, 2]) == [1, 2] >>> sum_neighbors([1]) == [1] >>> sum_neighbors([]) == [] >>> sum_neighbors([-1, -2, -3, -4]) == [-3, -6, -9, -7] pass","solution":"def sum_neighbors(lst): Takes a list of integers and returns a new list with each element being the sum of its neighbors and itself. If the list has fewer than 3 elements, the original list is returned. if len(lst) < 3: return lst result = [] for i in range(len(lst)): if i == 0: result.append(lst[i] + lst[i+1]) elif i == len(lst) - 1: result.append(lst[i-1] + lst[i]) else: result.append(lst[i-1] + lst[i] + lst[i+1]) return result"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Given a list of stock prices for a company over a period of time, find the maximum possible profit you can achieve by buying and selling the stock at most once. The function should return 0 if no profit can be made. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([5]) 0 >>> max_profit([3, 5]) 2 >>> max_profit([5, 3]) 0 >>> max_profit([4, 4, 4, 4]) 0 >>> max_profit([3, 2, 6, 1, 3, 8]) 7 >>> prices = list(range(10000, 0, -1)) + list(range(10001)) >>> max_profit(prices) 10000","solution":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved by buying and selling the stock at most once. If no profit can be made, returns 0. if not prices or len(prices) == 1: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"import random class BattleshipGame: A class to simulate a simple version of the classic \\"Battleship\\" game. def __init__(self): Initializes the game with a 5x5 grid and a single ship of length 3. The ship is placed automatically, either horizontally or vertically. self.grid_size = 5 self.ship_length = 3 self.max_attempts = 10 self.guesses = set() self.ship_positions = self.place_ship() self.hits = set() def place_ship(self): Randomly places a ship of length 3 on a 5x5 grid. direction = random.choice(['horizontal', 'vertical']) if direction == 'horizontal': row = random.randint(0, self.grid_size - 1) col_start = random.randint(0, self.grid_size - self.ship_length) return {(row, col_start + i) for i in range(self.ship_length)} else: col = random.randint(0, self.grid_size - 1) row_start = random.randint(0, self.grid_size - self.ship_length) return {(row_start + i, col) for i in range(self.ship_length)} def guess(self, row, col): Allows the player to guess the location of the ship. Parameters: row: An integer, the row coordinate of the guess col: An integer, the column coordinate of the guess Returns: A string indicating the result of the guess (\\"Hit\\", \\"Miss\\", \\"Already Guessed\\", \\"You sank the battleship!\\") Example: >>> game = BattleshipGame() >>> result = game.guess(0, 0) pass def is_game_over(self): Checks if the game is over. Returns: A boolean indicating whether the game is over. pass def test_ship_placement(): game = BattleshipGame() positions = game.ship_positions assert len(positions) == 3 rows = [pos[0] for pos in positions] cols = [pos[1] for pos in positions] assert len(set(rows)) == 1 or len(set(cols)) == 1 # Ensure either all rows or all cols are the same if len(set(rows)) == 1: assert max(cols) - min(cols) == 2 else: assert max(rows) - min(rows) == 2 def test_guess_hit(): game = BattleshipGame() hit_position = next(iter(game.ship_positions)) assert game.guess(hit_position[0], hit_position[1]) == \\"Hit\\" def test_guess_miss(): game = BattleshipGame() miss_position = (0, 0) while miss_position in game.ship_positions: miss_position = (miss_position[0], miss_position[1] + 1) assert game.guess(miss_position[0], miss_position[1]) == \\"Miss\\" def test_guess_already_guessed(): game = BattleshipGame() position = (0, 0) game.guess(position[0], position[1]) assert game.guess(position[0], position[1]) == \\"Already Guessed\\" def test_sinking_ship(): game = BattleshipGame() for position in game.ship_positions: assert game.guess(position[0], position[1]) in [\\"Hit\\", \\"You sank the battleship!\\"] assert game.is_game_over() def test_game_over_with_attempts(): game = BattleshipGame() non_ship_positions = {(i, j) for i in range(5) for j in range(5)} - game.ship_positions for position in non_ship_positions: result = game.guess(position[0], position[1]) assert result == \\"Miss\\" or result == \\"Already Guessed\\" if game.is_game_over(): break assert game.is_game_over()","solution":"import random class BattleshipGame: def __init__(self): self.grid_size = 5 self.ship_length = 3 self.max_attempts = 10 self.guesses = set() self.ship_positions = self.place_ship() self.hits = set() def place_ship(self): direction = random.choice(['horizontal', 'vertical']) if direction == 'horizontal': row = random.randint(0, self.grid_size - 1) col_start = random.randint(0, self.grid_size - self.ship_length) return {(row, col_start + i) for i in range(self.ship_length)} else: col = random.randint(0, self.grid_size - 1) row_start = random.randint(0, self.grid_size - self.ship_length) return {(row_start + i, col) for i in range(self.ship_length)} def guess(self, row, col): if (row, col) in self.guesses: return \\"Already Guessed\\" self.guesses.add((row, col)) if (row, col) in self.ship_positions: self.hits.add((row, col)) if self.hits == self.ship_positions: return \\"You sank the battleship!\\" return \\"Hit\\" else: return \\"Miss\\" def is_game_over(self): return len(self.guesses) >= self.max_attempts or self.hits == self.ship_positions"},{"question":"def first_non_repeating_character(s: str) -> str: Write a function that takes a string as input and returns the first non-repeating character in the string. If there is no non-repeating character, return an underscore ('_'). Your solution should demonstrate efficient use of data structures to achieve optimal time complexity. >>> first_non_repeating_character(\\"abacabad\\") == 'c' True >>> first_non_repeating_character(\\"abacabaabacaba\\") == '_' True >>> first_non_repeating_character(\\"a\\") == 'a' True >>> first_non_repeating_character(\\"\\") == '_' True >>> first_non_repeating_character(\\"aabbccdd\\") == '_' True >>> first_non_repeating_character(\\"abcd\\") == 'a' True >>> first_non_repeating_character(\\"aabbccdde\\") == 'e' True >>> first_non_repeating_character(\\"a@bc@a\\") == 'b' True >>> first_non_repeating_character(\\"#a#a^*\\") == '' True >>> first_non_repeating_character(\\"^^&&**\\") == '_' True","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If there is no non-repeating character, returns an underscore ('_'). from collections import Counter # Count frequency of each character char_count = Counter(s) # Find the first non-repeating character for char in s: if char_count[char] == 1: return char return '_'"},{"question":"def perfect_squares(n): Create a function that takes an integer \`n\` as input and returns a list of all the integer values from 1 to \`n\` that are perfect squares, arranged in descending order. A perfect square is an integer that is the square of an integer (e.g., 1, 4, 9, 16, etc.). The function should handle cases where \`n\` is less than 1 by returning an empty list. >>> perfect_squares(16) [16, 9, 4, 1] >>> perfect_squares(20) [16, 9, 4, 1] >>> perfect_squares(0) [] >>> perfect_squares(5) [4, 1]","solution":"import math def perfect_squares(n): Returns a list of all perfect squares from 1 to n in descending order. If n is less than 1, returns an empty list. if n < 1: return [] squares = [] for i in range(int(math.sqrt(n)), 0, -1): squares.append(i * i) return squares"},{"question":"def IndexParity(arr): Write a function that takes a list of integers and returns a dictionary with the keys \\"even\\" and \\"odd\\". The values should be lists of indices where even and odd numbers occur in the original list, respectively. >>> IndexParity([10, 23, 36, 41, 52, 65]) == {\\"even\\": [0, 2, 4], \\"odd\\": [1, 3, 5]} >>> IndexParity([2, 4, 6, 8]) == {\\"even\\": [0, 1, 2, 3], \\"odd\\": []} >>> IndexParity([1, 3, 5, 7]) == {\\"even\\": [], \\"odd\\": [0, 1, 2, 3]} >>> IndexParity([]) == {\\"even\\": [], \\"odd\\": []} >>> IndexParity([-2, -3, 0, 1, -4]) == {\\"even\\": [0, 2, 4], \\"odd\\": [1, 3]}","solution":"def IndexParity(arr): Returns a dictionary with the keys \\"even\\" and \\"odd\\". The values are lists of indices where even and odd numbers occur in the original list, respectively. result = {\\"even\\": [], \\"odd\\": []} for index, value in enumerate(arr): if value % 2 == 0: result[\\"even\\"].append(index) else: result[\\"odd\\"].append(index) return result"},{"question":"Code: products/models.py products/models.py class User: def __init__(self, email: str, password: str, name: str): Initializes a new User instance. Args: email (str): User's email address. password (str): User's password. name (str): User's name. self.email = email self.password = password self.name = name self.orders = [] def add_order(self, order): Adds an order to the user's list of orders. Args: order (dict): An order dictionary to add to the user's orders. Returns: list: Updated list of the user's orders. self.orders.append(order) return self.orders Test for User class and add_order method # Test for User class and add_order method from products.models import User def test_create_user(): user = User(\\"test@example.com\\", \\"password\\", \\"Test User\\") assert user.email == \\"test@example.com\\" assert user.password == \\"password\\" assert user.name == \\"Test User\\" assert user.orders == [] def test_add_order(): user = User(\\"test@example.com\\", \\"password\\", \\"Test User\\") order1 = {\\"order_id\\": 1, \\"products\\": [\\"product1\\", \\"product2\\"], \\"total_price\\": 100.0} order2 = {\\"order_id\\": 2, \\"products\\": [\\"product3\\"], \\"total_price\\": 50.0} user.add_order(order1) user.add_order(order2) assert len(user.orders) == 2 assert user.orders[0] == order1 assert user.orders[1] == order2","solution":"e-commerce platform class User and its methods class User: def __init__(self, email: str, password: str, name: str): self.email = email self.password = password self.name = name self.orders = [] def add_order(self, order): self.orders.append(order) return self.orders"},{"question":"def unique_chars_sorted_by_frequency(s: str) -> list: Create a function that takes a string as input and returns a list of all the unique characters in the string sorted by their frequency in descending order. If two characters have the same frequency, they should be sorted by their order of appearance in the string. >>> unique_chars_sorted_by_frequency('a') == ['a'] >>> unique_chars_sorted_by_frequency('abc') == ['a', 'b', 'c'] >>> unique_chars_sorted_by_frequency('aaabbc') == ['a', 'b', 'c'] >>> unique_chars_sorted_by_frequency('aAaBb') == ['a', 'A', 'B', 'b'] >>> unique_chars_sorted_by_frequency('') == [] >>> unique_chars_sorted_by_frequency('112233') == ['1', '2', '3'] >>> unique_chars_sorted_by_frequency('!@!@#') == ['!', '@', '#'] >>> unique_chars_sorted_by_frequency('abab') == ['a', 'b'] >>> unique_chars_sorted_by_frequency('baba') == ['b', 'a']","solution":"def unique_chars_sorted_by_frequency(s): from collections import Counter, OrderedDict # Count the frequency of each character count = Counter(s) # Keep original order of characters ordered_char_count = OrderedDict((char, count[char]) for char in s if count[char] > 0) # Sort characters by frequency (descending) sorted_chars = sorted(ordered_char_count.keys(), key=lambda x: (-ordered_char_count[x], s.index(x))) return sorted_chars"},{"question":"def longest_unique_substring(s: str) -> str: Write a Python function that takes a string as input and returns the longest substring without repeating characters. In case of a tie, return the substring that appears first in the input. Ensure the solution has an O(n) time complexity. Example: >>> longest_unique_substring(\\"abcabcbb\\") \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") \\"wke\\"","solution":"def longest_unique_substring(s): Returns the longest substring without repeating characters. char_index = {} start = 0 longest = \\"\\" for i, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = i if i - start + 1 > len(longest): longest = s[start:i + 1] return longest"},{"question":"import sys import select def is_balanced_parentheses(s: str) -> bool: Determines if a given string of parentheses is balanced. A string of parentheses is considered balanced if each opening parenthesis '(' has a corresponding closing parenthesis ')' and they are correctly nested. >>> is_balanced_parentheses(\\"()\\") True >>> is_balanced_parentheses(\\"()()\\") True >>> is_balanced_parentheses(\\"(())\\") True >>> is_balanced_parentheses(\\"(()))\\") False >>> is_balanced_parentheses(\\"((())\\") False >>> is_balanced_parentheses(\\"(()(())())\\") True >>> is_balanced_parentheses(\\"\\") True pass def read_input_non_blocking() -> str: Reads input from stdin in a non-blocking way to handle large strings efficiently. pass","solution":"import sys import select def is_balanced_parentheses(s: str) -> bool: Determines if a given string of parentheses is balanced. A string of parentheses is considered balanced if each opening parenthesis '(' has a corresponding closing parenthesis ')' and they are correctly nested. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0 def read_input_non_blocking() -> str: Reads input from stdin in a non-blocking way to handle large strings efficiently. input_string = \\"\\" while sys.stdin in select.select([sys.stdin], [], [], 0)[0]: input_string += sys.stdin.read(1024) if not input_string: break return input_string"},{"question":"from typing import List def is_prime(num: int) -> bool: Helper function to check if a number is prime. pass def prime_diff(lst: List[int], n: int) -> int: Given a list lst and its length n, returns the difference between the smallest prime number and the largest prime number in the list. If there are no prime numbers, return -1. >>> prime_diff([10, 15, 3, 7, 2, 8, 5], 7) 5 >>> prime_diff([4, 6, 8, 10], 4) -1 >>> prime_diff([3, 2, 5, 7], 4) 5 >>> prime_diff([3], 1) 0 >>> prime_diff([], 0) -1 >>> prime_diff([10, 15, 3, 7, 2, 8, 5, 101, 103], 9) 101 pass","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def prime_diff(lst, n): Given a list lst and its length n, returns the difference between the smallest prime number and the largest prime number in the list. If there are no prime numbers, return -1. primes = [num for num in lst if is_prime(num)] if not primes: return -1 return max(primes) - min(primes)"},{"question":"def count_unique_characters(s: str) -> int: Counts the number of unique alphabetic characters in a given string, ignoring case, non-alphabetic characters, and spaces. Args: s (str): Input string Returns: int: Number of unique alphabetic characters >>> count_unique_characters(\\"Hello, World!\\") 7 >>> count_unique_characters(\\"12345!!!\\") 0 >>> count_unique_characters(\\"H e l l o\\") 4","solution":"def count_unique_characters(s): This function counts the number of unique alphabetic characters in a given string, ignoring case, non-alphabetic characters, and spaces. Args: s (str): Input string Returns: int: Number of unique alphabetic characters # Normalize the string to lower case and filter only alphabetic characters cleaned_string = [char.lower() for char in s if char.isalpha()] # Use a set to count unique characters unique_chars = set(cleaned_string) return len(unique_chars)"},{"question":"class Stack: def __init__(self): self.items = [] def push(self, item): Adds an item to the top of the stack. pass def pop(self): Removes and returns the item from the top of the stack. If the stack is empty, returns None. pass def peek(self): Returns the item at the top of the stack without removing it. If the stack is empty, returns None. pass def is_empty(self): Checks if the stack is empty. pass def size(self): Returns the number of items in the stack. pass # Unit tests def test_stack_push(): stack = Stack() stack.push(1) stack.push(2) assert stack.items == [1, 2] def test_stack_pop(): stack = Stack() stack.push(1) stack.push(2) assert stack.pop() == 2 assert stack.pop() == 1 assert stack.pop() == None def test_stack_peek(): stack = Stack() assert stack.peek() == None stack.push(1) assert stack.peek() == 1 stack.push(2) assert stack.peek() == 2 def test_stack_is_empty(): stack = Stack() assert stack.is_empty() stack.push(1) assert not stack.is_empty() stack.pop() assert stack.is_empty() def test_stack_size(): stack = Stack() assert stack.size() == 0 stack.push(1) assert stack.size() == 1 stack.push(2) assert stack.size() == 2 stack.pop() assert stack.size() == 1 stack.pop() assert stack.size() == 0","solution":"class Stack: def __init__(self): self.items = [] def push(self, item): Adds an item to the top of the stack. self.items.append(item) def pop(self): Removes and returns the item from the top of the stack. If the stack is empty, returns None. if self.is_empty(): return None return self.items.pop() def peek(self): Returns the item at the top of the stack without removing it. If the stack is empty, returns None. if self.is_empty(): return None return self.items[-1] def is_empty(self): Checks if the stack is empty. return len(self.items) == 0 def size(self): Returns the number of items in the stack. return len(self.items)"},{"question":"from typing import List, Tuple def triangular_sums(matrix: List[List[int]]) -> Tuple[int, int]: Calculate the sum of elements in the upper and lower triangular parts of an n x n matrix. Args: matrix (List[List[int]]): A 2D list of integers representing the matrix. Returns: Tuple[int, int]: A tuple containing the sums of the upper and lower triangular parts of the matrix. >>> triangular_sums([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) (26, 34) >>> triangular_sums([[5]]) (5, 5) >>> triangular_sums([ ... [1, 2], ... [3, 4] ... ]) (7, 8) >>> triangular_sums([ ... [0, 0, 0], ... [4, 0, 0], ... [7, 8, 0] ... ]) (0, 19) >>> triangular_sums([ ... [1, 2, 3], ... [0, 5, 6], ... [0, 0, 9] ... ]) (26, 15) >>> matrix = [[j for j in range(100)] for i in range(100)] >>> upper_sum = sum(sum(range(i, 100)) for i in range(100)) >>> lower_sum = sum(sum(range(i+1)) for i in range(100)) >>> triangular_sums(matrix) == (upper_sum, lower_sum) True pass","solution":"from typing import List, Tuple def triangular_sums(matrix: List[List[int]]) -> Tuple[int, int]: n = len(matrix) upper_sum = 0 lower_sum = 0 for i in range(n): for j in range(n): if i <= j: upper_sum += matrix[i][j] if i >= j: lower_sum += matrix[i][j] return (upper_sum, lower_sum)"},{"question":"class Vector: Class representing a simple mathematical vector in a 2-dimensional space. >>> v1 = Vector(1, 2) >>> v2 = Vector(3, 4) >>> v3 = v1 + v2 >>> v3 Vector(4, 6) >>> v4 = v1 * 3 >>> v4 Vector(3, 6) >>> result = v1.dot(v2) >>> result 11 >>> print(v1) Vector(1, 2) def __init__(self, x, y): pass def __add__(self, other): pass def __mul__(self, scalar): pass def dot(self, other): pass def __repr__(self): pass","solution":"class Vector: def __init__(self, x, y): self.x = x self.y = y def __add__(self, other): return Vector(self.x + other.x, self.y + other.y) def __mul__(self, scalar): return Vector(self.x * scalar, self.y * scalar) def dot(self, other): return self.x * other.x + self.y * other.y def __repr__(self): return f\\"Vector({self.x}, {self.y})\\""},{"question":"def sort_decimal_strings(decimal_strings: List[str]) -> List[str]: Sorts a list of strings representing decimal numbers in ascending order based on their numeric value. Parameters: decimal_strings (list): List of strings where each string represents a decimal number. Returns: list: Sorted list of strings based on their numeric values. >>> sort_decimal_strings([\\"1.1\\", \\"2.3\\", \\"0.5\\"]) [\\"0.5\\", \\"1.1\\", \\"2.3\\"] >>> sort_decimal_strings([\\"-1.1\\", \\"2.3\\", \\"-0.5\\"]) [\\"-1.1\\", \\"-0.5\\", \\"2.3\\"] >>> sort_decimal_strings([\\"1.1\\", \\"-2.3\\", \\"0.5\\", \\"-1.1\\"]) [\\"-2.3\\", \\"-1.1\\", \\"0.5\\", \\"1.1\\"] >>> sort_decimal_strings([\\"1.1\\", \\"2.3\\", \\"1.1\\"]) [\\"1.1\\", \\"1.1\\", \\"2.3\\"] >>> sort_decimal_strings([\\"1.10\\", \\"1.2\\", \\"1.01\\", \\"1.001\\"]) [\\"1.001\\", \\"1.01\\", \\"1.10\\", \\"1.2\\"]","solution":"def sort_decimal_strings(decimal_strings): Sorts a list of strings representing decimal numbers in ascending order based on their numeric value. Parameters: decimal_strings (list): List of strings where each string represents a decimal number. Returns: list: Sorted list of strings based on their numeric values. return sorted(decimal_strings, key=float)"},{"question":"from typing import List, Union def evaluate_expressions(expressions: List[str]) -> List[Union[float, None]]: Takes a list of strings representing mathematical expressions and returns a list of results. Handles division by zero and invalid expressions by returning None for those cases. >>> evaluate_expressions([\\"3 + 2\\", \\"10 / 0\\", \\"5 * 6\\", \\"a + b\\"]) [5, None, 30, None] >>> evaluate_expressions([\\"3 + 2\\", \\"5 * 6\\", \\"10 - 3\\", \\"8 / 2\\"]) [5, 30, 7, 4.0]","solution":"def evaluate_expressions(expressions): Takes a list of strings representing mathematical expressions and returns a list of results. Handles division by zero and invalid expressions by returning None for those cases. results = [] for expr in expressions: try: result = eval(expr, {\\"__builtins__\\": None}, {}) results.append(result) except ZeroDivisionError: results.append(None) except Exception: results.append(None) return results"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Determines if two strings are anagrams of each other ignoring spaces and capitalization. Args: str1 (str): The first string to be compared. str2 (str): The second string to be compared. Returns: bool: True if str1 and str2 are anagrams, False otherwise. >>> are_anagrams(\\"binary\\", \\"brainy\\") True >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"a gentleman\\", \\"elegant man\\") True >>> are_anagrams(\\"Dormitory\\", \\"dirty room\\") True >>> are_anagrams(\\"School Master\\", \\"The Classroom\\") True >>> are_anagrams(\\"Astronomer\\", \\"Moon Starer\\") True >>> are_anagrams(\\"hello\\", \\"world\\") False >>> are_anagrams(\\"apple\\", \\"paddle\\") False >>> are_anagrams(\\"ring\\", \\"bring\\") False >>> are_anagrams(\\"evil\\", \\"vile \\") True","solution":"def are_anagrams(str1, str2): Determines if two strings are anagrams of each other ignoring spaces and capitalization. Args: str1 (str): The first string to be compared. str2 (str): The second string to be compared. Returns: bool: True if str1 and str2 are anagrams, False otherwise. # Remove spaces and convert to lower case str1 = str1.replace(\\" \\", \\"\\").lower() str2 = str2.replace(\\" \\", \\"\\").lower() # Check if sorted characters of both strings are the same return sorted(str1) == sorted(str2)"},{"question":"def replace_char(s: str, old_char: str, new_char: str) -> str: Replaces all occurrences of old_char in the string s with new_char. Ensures the function handles both lowercase and uppercase characters correctly. >>> replace_char(\\"hello world\\", 'l', 'x') 'hexxo worxd' >>> replace_char(\\"Hello World\\", 'l', 'x') 'Hexxo Worxd' >>> replace_char(\\"Hello World\\", 'z', 'x') 'Hello World' >>> replace_char(\\"\\", 'a', 'b') '' >>> replace_char(\\"aaaa\\", 'a', 'a') 'aaaa' >>> replace_char(\\"HelloWorld\\", 'H', 'Y') 'YelloWorld' >>> replace_char(\\"HelloWorld\\", 'h', 'y') 'HelloWorld' >>> replace_char(\\"Hello World\\", 'l', '') 'Heo Word'","solution":"def replace_char(s, old_char, new_char): Replaces all occurrences of old_char in the string s with new_char. return s.replace(old_char, new_char)"},{"question":"def is_valid_serialization(preorder: str) -> bool: Check if a string is a valid serialized binary tree preorder traversal. >>> is_valid_serialization(\\"9,3,4,#,#,1,#,#,2,#,6,#,#\\") True >>> is_valid_serialization(\\"1,#\\") False >>> is_valid_serialization(\\"9,#,#,1\\") False","solution":"def is_valid_serialization(preorder: str) -> bool: # Split the input into elements based on commas nodes = preorder.split(',') # Initialize a variable to keep track of the current capacity # or \\"number of slots\\" in the tree capacity = 1 # Iterate over each node in the list for node in nodes: # A node consumes one slot capacity -= 1 # If at any point capacity drops below zero, it means the structure is invalid if capacity < 0: return False # If the node is not a null node, it adds two more slots (children) if node != '#': capacity += 2 # All slots should be exactly used up for the tree to be valid return capacity == 0"},{"question":"from typing import List def find_pair(nums: List[int], target: int) -> List[int]: Design a function that takes a list of integers and a target integer. The function should return the indices of the two numbers in the list that add up to the target. If no such pair exists, return an empty list. Assume that there is exactly one solution, and you may not use the same element twice. >>> find_pair([2, 7, 11, 15], 9) [0, 1] >>> find_pair([-1, -2, -3, -4, -5], -8) [2, 4]","solution":"from typing import List def find_pair(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers in the list that add up to the target. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return []"},{"question":"def count_occurrences(lst: List[int]) -> Dict[int, int]: Takes a list of integers and returns a dictionary where the keys are the integers and the values are the number of times each integer appears in the list. >>> count_occurrences([1, 2, 3]) == {1: 1, 2: 1, 3: 1} >>> count_occurrences([4, 5, 7, 4, 2, 7, 4, 5, 6, 7]) == {4: 3, 5: 2, 7: 3, 2: 1, 6: 1} >>> count_occurrences([]) == {} >>> count_occurrences([1, -1, 4, 1, -1, -1]) == {1: 2, -1: 3, 4: 1} >>> count_occurrences([1, 1, 1, 1]) == {1: 4}","solution":"def count_occurrences(lst): Takes a list of integers and returns a dictionary where the keys are the integers and the values are the number of times each integer appears in the list. Args: lst (list): A list of integers Returns: dict: A dictionary with integers as keys and their counts as values. occurrence_dict = {} for item in lst: if item in occurrence_dict: occurrence_dict[item] += 1 else: occurrence_dict[item] = 1 return occurrence_dict"},{"question":"def longest_substring_with_two_distinct(s: str) -> str: Calculate and return the longest substring in a given string \`s\` that contains at most two distinct characters. >>> longest_substring_with_two_distinct(\\"eceba\\") \\"ece\\" >>> longest_substring_with_two_distinct(\\"ccaabbb\\") \\"aabbb\\" pass def test_example_case_1(): assert longest_substring_with_two_distinct(\\"eceba\\") == \\"ece\\" def test_example_case_2(): assert longest_substring_with_two_distinct(\\"ccaabbb\\") == \\"aabbb\\" def test_single_character_string(): assert longest_substring_with_two_distinct(\\"a\\") == \\"a\\" def test_two_characters_string(): assert longest_substring_with_two_distinct(\\"aa\\") == \\"aa\\" def test_string_with_exactly_two_distinct_characters(): assert longest_substring_with_two_distinct(\\"abac\\") == \\"aba\\" def test_string_with_all_different_characters(): assert longest_substring_with_two_distinct(\\"abcdef\\") == \\"ab\\" def test_string_with_repeated_pattern(): assert longest_substring_with_two_distinct(\\"ababababab\\") == \\"ababababab\\" def test_string_with_multiple_substrings_max_length(): assert longest_substring_with_two_distinct(\\"abcabcabc\\") == \\"ab\\" def test_empty_string(): assert longest_substring_with_two_distinct(\\"\\") == \\"\\" def test_string_with_non_consecutive_two_distinct_characters(): assert longest_substring_with_two_distinct(\\"abaccc\\") == \\"accc\\"","solution":"def longest_substring_with_two_distinct(s): Returns the longest substring with at most two distinct characters. if not s: return \\"\\" start = 0 max_length = 0 max_substring = \\"\\" char_map = {} for end in range(len(s)): char_map[s[end]] = char_map.get(s[end], 0) + 1 while len(char_map) > 2: char_map[s[start]] -= 1 if char_map[s[start]] == 0: del char_map[s[start]] start += 1 current_length = end - start + 1 if current_length > max_length: max_length = current_length max_substring = s[start:end + 1] return max_substring"},{"question":"class BookingSystem: def __init__(self): self.bookings = [] def book_slot(self, start, end): Book a slot given the start time and end time. Returns a message indicating if the booking was successful or if there was an issue. pass def cancel_booking(self, start, end): Cancel a booking given the start time and end time. Returns a message indicating if the booking was successfully cancelled or if the booking was not found. pass def is_available(self, start, end): Check if a slot is available given the start time and end time. Returns True if the slot is available and False otherwise. pass def get_all_bookings(self): Return a list of all bookings in chronological order. pass # Example usage: venue = BookingSystem() # Example bookings print(venue.book_slot(9, 12)) # Should return \\"Booking successful.\\" print(venue.book_slot(13, 15)) # Should return \\"Booking successful.\\" print(venue.is_available(10, 11)) # Should return False print(venue.is_available(12, 13)) # Should return True print(venue.get_all_bookings()) # Should return [(9, 12), (13, 15)] print(venue.cancel_booking(9, 12)) # Should return \\"Booking cancelled.\\" print(venue.get_all_bookings()) # Should return [(13, 15)] # Unit Tests def test_book_slot_overlapping(): venue = BookingSystem() assert venue.book_slot(9, 12) == \\"Booking successful.\\" assert venue.book_slot(10, 11) == \\"Slot overlaps with an existing booking.\\" assert venue.get_all_bookings() == [(9, 12)] def test_book_slot_valid(): venue = BookingSystem() assert venue.book_slot(9, 12) == \\"Booking successful.\\" assert venue.book_slot(12, 15) == \\"Booking successful.\\" assert venue.get_all_bookings() == [(9, 12), (12, 15)] def test_cancel_booking(): venue = BookingSystem() venue.book_slot(9, 12) venue.book_slot(12, 15) assert venue.cancel_booking(9, 12) == \\"Booking cancelled.\\" assert venue.get_all_bookings() == [(12, 15)] assert venue.cancel_booking(9, 12) == \\"Booking not found.\\" def test_is_available(): venue = BookingSystem() venue.book_slot(9, 12) venue.book_slot(13, 15) assert not venue.is_available(10, 11) assert venue.is_available(12, 13) def test_invalid_booking_times(): venue = BookingSystem() assert venue.book_slot(-1, 10) == \\"Invalid booking time.\\" assert venue.book_slot(10, 25) == \\"Invalid booking time.\\" assert venue.book_slot(10, 10) == \\"Invalid booking time.\\" assert not venue.is_available(-1, 10) assert not venue.is_available(10, 25) assert not venue.is_available(10, 10) def test_get_all_bookings(): venue = BookingSystem() assert venue.get_all_bookings() == [] venue.book_slot(9, 12) venue.book_slot(13, 15) assert venue.get_all_bookings() == [(9, 12), (13, 15)]","solution":"class BookingSystem: def __init__(self): self.bookings = [] def book_slot(self, start, end): if start < 0 or end > 24 or start >= end: return \\"Invalid booking time.\\" for booking in self.bookings: if max(start, booking[0]) < min(end, booking[1]): return \\"Slot overlaps with an existing booking.\\" self.bookings.append((start, end)) self.bookings.sort() return \\"Booking successful.\\" def cancel_booking(self, start, end): if (start, end) in self.bookings: self.bookings.remove((start, end)) return \\"Booking cancelled.\\" return \\"Booking not found.\\" def is_available(self, start, end): if start < 0 or end > 24 or start >= end: return False for booking in self.bookings: if max(start, booking[0]) < min(end, booking[1]): return False return True def get_all_bookings(self): return self.bookings"},{"question":"import numpy as np import pandas as pd import matplotlib.pyplot as plt def create_dataframe_and_plot(): Using Python's numpy, pandas, and matplotlib.pyplot libraries, create a DataFrame containing 15 entries with 'Time' and 'Distance' columns. The 'Time' column should consist of equally spaced values ranging from 0 to 7 hours. The 'Distance' column should contain random float values between 0 and 50 kilometers. After constructing the DataFrame, plot 'Distance' versus 'Time' using a line plot. Customize the plot by adding gridlines, setting the line color to 'blue', and changing the line style to dashed lines. Finally, label the x-axis as 'Time (hours)' and the y-axis as 'Distance (km)'. >>> df = create_dataframe_and_plot() >>> 'Time' in df.columns True >>> 'Distance' in df.columns True >>> len(df) 15 >>> np.allclose(df['Time'], np.linspace(0, 7, 15), atol=1e-8) True >>> df['Distance'].between(0, 50).all() True","solution":"import numpy as np import pandas as pd import matplotlib.pyplot as plt def create_dataframe_and_plot(): # Seed for reproducibility np.random.seed(0) # Creating DataFrame time_values = np.linspace(0, 7, 15) distance_values = np.random.uniform(0, 50, 15) data = {'Time': time_values, 'Distance': distance_values} df = pd.DataFrame(data) # Plotting plt.figure(figsize=(10, 6)) plt.plot(df['Time'], df['Distance'], color='blue', linestyle='--') plt.grid(True) plt.xlabel('Time (hours)') plt.ylabel('Distance (km)') plt.title('Distance vs Time Plot') plt.show() return df"},{"question":"def merge_two_dicts(dict1, dict2): Merges two dictionaries. If there are common keys, sums their values. Args: dict1 (dict): The first dictionary. dict2 (dict): The second dictionary. Returns: dict: A new dictionary containing the merged data. >>> merge_two_dicts({'a': 1, 'b': 2}, {'b': 3, 'c': 4}) {'a': 1, 'b': 5, 'c': 4} >>> merge_two_dicts({'a': 1, 'b': 2}, {'c': 3, 'd': 4}) {'a': 1, 'b': 2, 'c': 3, 'd': 4} >>> merge_two_dicts({}, {'a': 1, 'b': 2}) {'a': 1, 'b': 2} >>> merge_two_dicts({'a': 1, 'b': 2}, {}) {'a': 1, 'b': 2} >>> merge_two_dicts({'a': 5, 'b': 2}, {'a': 3, 'b': 1}) {'a': 8, 'b': 3}","solution":"def merge_two_dicts(dict1, dict2): Merges two dictionaries. If there are common keys, sums their values. Args: dict1 (dict): The first dictionary. dict2 (dict): The second dictionary. Returns: dict: A new dictionary containing the merged data. merged_dict = dict1.copy() for key, value in dict2.items(): if key in merged_dict: merged_dict[key] += value else: merged_dict[key] = value return merged_dict"},{"question":"def decimal_to_binary(decimal: int) -> str: Converts a decimal number to its binary equivalent. >>> decimal_to_binary(156) '10011100' >>> decimal_to_binary(0) '0' >>> decimal_to_binary(10) '1010' def decimal_to_octal(decimal: int) -> str: Converts a decimal number to its octal equivalent. >>> decimal_to_octal(156) '234' >>> decimal_to_octal(0) '0' >>> decimal_to_octal(10) '12' def decimal_to_hexadecimal(decimal: int) -> str: Converts a decimal number to its hexadecimal equivalent. >>> decimal_to_hexadecimal(156) '9C' >>> decimal_to_hexadecimal(0) '0' >>> decimal_to_hexadecimal(10) 'A'","solution":"def decimal_to_binary(decimal): Converts a decimal number to its binary equivalent. return bin(decimal)[2:] def decimal_to_octal(decimal): Converts a decimal number to its octal equivalent. return oct(decimal)[2:] def decimal_to_hexadecimal(decimal): Converts a decimal number to its hexadecimal equivalent. return hex(decimal)[2:].upper() # Example conversions for decimal number 156 decimal_number = 156 binary_equivalent = decimal_to_binary(decimal_number) # '10011100' octal_equivalent = decimal_to_octal(decimal_number) # '234' hexadecimal_equivalent = decimal_to_hexadecimal(decimal_number) # '9C'"},{"question":"def find_longest_arith_seq(lst): Finds the longest subsequence in the list that forms an arithmetic progression. If the list contains non-integer elements, raises a ValueError. >>> find_longest_arith_seq([1, 3, 6, 4, 7, 8, 10]) [1, 4, 7, 10] >>> find_longest_arith_seq([5, 10, 15, 20, 25]) [5, 10, 15, 20, 25] >>> find_longest_arith_seq([1, 2]) [1, 2] >>> find_longest_arith_seq([]) [] >>> find_longest_arith_seq([1]) [1] >>> find_longest_arith_seq([5, 7, 10, 13, 16]) [7, 10, 13, 16] >>> find_longest_arith_seq([3, 6, 9, 12, 15, 1, 2, 4]) [3, 6, 9, 12, 15] >>> find_longest_arith_seq([10, 7, 4, 1, -2, 13, 16, -5]) [-5, -2, 1, 4, 7, 10, 13, 16]","solution":"def find_longest_arith_seq(lst): Finds the longest subsequence in the list that forms an arithmetic progression. if not lst: return [] for item in lst: if not isinstance(item, int): raise ValueError(\\"All elements in the input list must be integers.\\") n = len(lst) if n <= 2: return lst lst.sort() longest_ap = [] dp = [{} for _ in range(n)] for i in range(n - 1): for j in range(i + 1, n): diff = lst[j] - lst[i] if diff in dp[i]: dp[j][diff] = dp[i][diff] + [lst[j]] else: dp[j][diff] = [lst[i], lst[j]] if len(dp[j][diff]) > len(longest_ap): longest_ap = dp[j][diff] return longest_ap"},{"question":"from typing import List, Tuple def detect_cycle(n: int, edges: List[Tuple[int, int]]) -> str: Determine whether the graph contains a cycle. If a cycle exists, output \\"Cycle detected\\"; otherwise, output \\"No cycle\\". >>> detect_cycle(5, [(0, 1), (1, 2), (2, 3), (3, 1), (3, 4)]) \\"Cycle detected\\" >>> detect_cycle(4, [(0, 1), (1, 2), (2, 3)]) \\"No cycle\\"","solution":"def detect_cycle(n, edges): from collections import defaultdict def dfs(v, parent): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: if dfs(neighbor, v): return True elif neighbor != parent: return True return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * n for i in range(n): if not visited[i]: if dfs(i, -1): return \\"Cycle detected\\" return \\"No cycle\\""},{"question":"def largest_number(nums): Returns the largest possible number formed by concatenating the integers together. :param nums: List of integers :return: A string representing the largest possible concatenated number >>> largest_number([3, 5, 1, 4, 2]) == '54321' >>> largest_number([3, 30, 34, 5, 9]) == '9534330' >>> largest_number([1, 1, 1, 1]) == '1111' >>> largest_number([0, 0, 0]) == '0' >>> largest_number([10, 2]) == '210' >>> largest_number([823, 8238]) == '8238823' >>> largest_number([930, 931]) == '931930'","solution":"from functools import cmp_to_key def largest_number(nums): Returns the largest possible number formed by concatenating the integers together. :param nums: List of integers :return: A string representing the largest possible concatenated number # Convert all integers to strings nums = list(map(str, nums)) # Custom comparator to decide the order of concatenation def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Sort numbers using the comparator nums.sort(key=cmp_to_key(compare)) # Join the numbers to form the largest number result = ''.join(nums) # Edge case: If the highest number is '0', the result is '0' return result if result[0] != '0' else '0'"},{"question":"from typing import List def group_anagrams(strs: List[str]) -> List[List[str]]: Groups anagrams together from the given list of strings. Parameters: strs (List[str]): A list of strings. Returns: List[List[str]]: A list of sublists, each containing strings that are anagrams of each other. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] >>> group_anagrams([]) [] >>> group_anagrams([\\"abc\\", \\"bca\\", \\"cab\\", \\"bac\\", \\"cba\\"]) [[\\"abc\\", \\"bca\\", \\"cab\\", \\"bac\\", \\"cba\\"]]","solution":"from collections import defaultdict def group_anagrams(strs): Groups anagrams together from the given list of strings. Parameters: strs (List[str]): A list of strings. Returns: List[List[str]]: A list of sublists, each containing strings that are anagrams of each other. anagrams = defaultdict(list) for word in strs: sorted_word = tuple(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"import pandas as pd def process_large_csv(filepath, output_path, group_by_cols, fill_na_strategy='mean'): Processes a large CSV file to identify and remove duplicate records, fill missing values, and perform aggregation operations grouped by specified columns. Saves the result to a new CSV file. :param filepath: Path to the input CSV file :param output_path: Path to save the output CSV file :param group_by_cols: List of columns to group by for aggregation :param fill_na_strategy: Strategy to fill missing values (default is 'mean') # Your code here to process the CSV file # Sample Unit Test def test_process_large_csv(): import os sample_data = { 'A': [1, 2, 2, 4, 5, 6, 6], 'B': [5, 6, 7, 8, None, 6, 7], 'C': [10, 12, 12, 14, 15, 16, 16] } sample_df = pd.DataFrame(sample_data) sample_filepath = 'sample_input.csv' sample_df.to_csv(sample_filepath, index=False) output_filepath = 'sample_output.csv' process_large_csv(sample_filepath, output_filepath, group_by_cols=['A'], fill_na_strategy='mean') output_df = pd.read_csv(output_filepath) assert not output_df.duplicated().any() assert not output_df.isna().any().any() expected_data = { 'A': [1, 2, 4, 5, 6], 'B_sum': [5, 13, 8, 6.5, 13], 'B_mean': [5.0, 6.5, 8.0, 6.5, 6.5], 'B_count': [1, 2, 1, 1, 2], 'C_sum': [10, 24, 14, 15, 32], 'C_mean': [10.0, 12.0, 14.0, 15.0, 16.0], 'C_count': [1, 2, 1, 1, 2] } expected_df = pd.DataFrame(expected_data) pd.testing.assert_frame_equal(output_df, expected_df) os.remove(sample_filepath) os.remove(output_filepath)","solution":"import pandas as pd def process_large_csv(filepath, output_path, group_by_cols, fill_na_strategy='mean'): Processes a large CSV file to identify and remove duplicate records, fill missing values, and perform aggregation operations grouped by specified columns. Saves the result to a new CSV file. :param filepath: Path to the input CSV file :param output_path: Path to save the output CSV file :param group_by_cols: List of columns to group by for aggregation :param fill_na_strategy: Strategy to fill missing values (default is 'mean') # Read the CSV file in chunks to handle large files chunk_size = 100000 chunks = pd.read_csv(filepath, chunksize=chunk_size) # Initialize an empty DataFrame to append processed chunks processed_df = pd.DataFrame() for chunk in chunks: # Drop duplicate records chunk = chunk.drop_duplicates() # Fill missing values if fill_na_strategy == 'mean': chunk = chunk.fillna(chunk.mean()) elif fill_na_strategy == 'median': chunk = chunk.fillna(chunk.median()) elif fill_na_strategy == 'mode': chunk = chunk.fillna(chunk.mode().iloc[0]) else: raise ValueError(\\"Invalid fill_na_strategy. Choose from 'mean', 'median', 'mode'.\\") # Append processed chunk to the DataFrame processed_df = pd.concat([processed_df, chunk], ignore_index=True) # Perform aggregation operations aggregation_funcs = {col: ['sum', 'mean', 'count'] for col in processed_df.columns if col not in group_by_cols} aggregated_df = processed_df.groupby(group_by_cols).agg(aggregation_funcs) # Flatten MultiIndex columns aggregated_df.columns = ['_'.join(col).strip() for col in aggregated_df.columns.values] # Save the cleaned and aggregated data to a new CSV file aggregated_df.to_csv(output_path)"},{"question":"def even_palindrome_list(integers): Returns a list of even palindromes from the given list of integers. An even palindrome is a number that reads the same forwards and backwards and is divisible by 2. >>> even_palindrome_list([282, 1331, 1221, 4884, 484, 12321, 1234]) [282, 4884, 484] >>> even_palindrome_list([]) [] >>> even_palindrome_list([484]) [484] >>> even_palindrome_list([123]) [] >>> even_palindrome_list([123, 13531, 1357]) [] >>> even_palindrome_list([246, 1357, 2468, 13579]) [] pass # Incorrect solution: def even_palindrome_list(integers): def is_palindrome(n): s = str(n) return s = s[::-1] # Syntax error with the assignment operator return [x for x in integers if x % 2 == 0 and is_palindrom(x)] # Typo in function call","solution":"def even_palindrome_list(integers): Returns a list of even palindromes from the given list of integers. An even palindrome is a number that reads the same forwards and backwards and is divisible by 2. def is_palindrome(n): s = str(n) return s == s[::-1] return [x for x in integers if x % 2 == 0 and is_palindrome(x)]"}]`),C={name:"App",components:{PoemCard:N},data(){return{searchQuery:"",visibleCount:4,poemsData:E,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},F={class:"search-container"},D={class:"card-container"},I={key:0,class:"empty-state"},j=["disabled"],S={key:0},P={key:1};function z(n,e,l,m,i,a){const f=h("PoemCard");return s(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"prompts chat")])],-1)),t("div",F,[e[3]||(e[3]=t("span",{class:"search-icon"},"",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(s(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")},"  ")):u("",!0)]),t("div",D,[(s(!0),r(y,null,v(a.displayedPoems,(o,p)=>(s(),w(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),r("div",I,' No results found for "'+d(i.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(s(),r("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(s(),r("span",P,"Loading...")):(s(),r("span",S,"See more"))],8,j)):u("",!0)])}const B=_(C,[["render",z],["__scopeId","data-v-140a5b62"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"grok/17.md","filePath":"grok/17.md"}'),O={name:"grok/17.md"},H=Object.assign(O,{setup(n){return(e,l)=>(s(),r("div",null,[x(B)]))}});export{M as __pageData,H as default};
