import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as w,e as v,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const C=c(k,[["render",A],["__scopeId","data-v-8f3bb11c"]]),S=JSON.parse('[{"question":"# Problem Statement: Counting Islands in a 2D Grid You are given a 2D binary grid where `1` represents land and `0` represents water. Your task is to create a function that counts the number of islands. An island is formed by connecting adjacent lands horizontally or vertically. Assume all four edges of the grid are surrounded by water. Function Signature ```python def count_islands(grid: List[List[int]]) -> int: Counts the number of islands in a 2D binary grid. :param grid: A 2D list representing the map where 1 indicates land and 0 indicates water. :return: The number of islands. pass ``` Input * `grid`: A 2D list of integers where each element is either `0` (water) or `1` (land). Output * The function should return an integer representing the number of islands in the grid. Constraints 1. The grid is rectangular and its dimensions are at most `300 x 300`. 2. The grid will always have at least one element. Example ```python grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ] num_islands = count_islands(grid) # Output: 3 ``` Requirements 1. Implement the function with the specified constraints. 2. Ensure to handle edge cases such as grids full of water or land. 3. Optimize for typical grid sizes up to the maximum constraint. This question assesses the candidate\'s ability to work with 2D arrays, understand graph traversal algorithms such as Depth-First Search (DFS) or Breadth-First Search (BFS), and handle edge cases while maintaining efficiency.","solution":"from typing import List def count_islands(grid: List[List[int]]) -> int: if not grid: return 0 def dfs(r, c): if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]) or grid[r][c] == 0: return grid[r][c] = 0 # Mark as visited dfs(r - 1, c) dfs(r + 1, c) dfs(r, c - 1) dfs(r, c + 1) island_count = 0 for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == 1: island_count += 1 dfs(r, c) return island_count"},{"question":"# Problem Statement You are developing a component of a low-level operating system that requires converting signed integers into their binary two’s complement representation. Given a negative integer, your task is to implement a function that converts this integer into its corresponding two’s complement binary representation as a string. # Requirements: 1. Your function needs to throw an exception if the input is not a negative integer. 2. Do NOT use Python’s built-in functionalities such as `bin()` or `format()` for direct conversion in your final return statement. 3. You must calculate the binary length and two’s complement manually through bit manipulation. # Function Signature: ```python def twos_complement_custom(number: int) -> str: pass ``` # Expected Input and Output: 1. **Input**: A single integer `number` where -2^31 <= number < 0 2. **Output**: A string representing the two\'s complement binary code prefixed with `0b`. **Example**: ```python twos_complement_custom(-5) # Output: \'0b11111111111111111111111111111011\' twos_complement_custom(-17) # Output: \'0b11111111111111111111111111101111\' ``` # Constraints: 1. The input must be a negative integer. 2. The output must be a valid string of 32-bit two’s complement binary prefixed by `0b`. 3. The function should be optimized for both time and space complexities. **Note**: - Focus on the precise bit manipulation and manual conversion instead of relying on standard library functions for this operation.","solution":"def twos_complement_custom(number: int) -> str: Converts a negative integer to its two\'s complement binary string representation. :param number: Negative integer :return: Two\'s complement binary string prefixed with \'0b\' if not isinstance(number, int): raise ValueError(\\"Input must be an integer.\\") if number >= 0: raise ValueError(\\"Input must be a negative integer.\\") # Inverting the bits using bitwise NOT (~) and adding one to get the two\'s complement. twos_complement_val = (1 << 32) + number binary_str = format(twos_complement_val, \'032b\') return \'0b\' + binary_str"},{"question":"# Coding Assessment Question **Context**: You are given a list of positive integers where each integer represents the height of a building. You need to calculate how much water would be trapped between these buildings after it rains. Water trapping between buildings is determined by finding the local valleys and the amount of water they can hold. This problem is commonly encountered in computational geometry and data analysis. **Function Specification**: **Function Name**: trap_water **Parameters**: * `heights: list[int]`: A list of positive integers representing the heights of the buildings. **Return**: * `int`: An integer representing the total amount of water trapped between the buildings. **Constraints**: * The length of the list `heights` will not exceed 10^5. * The integer values in the list will be positive and fit within the range of a standard 32-bit integer. **Example**: ```python # Example 1: print(trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])) # Output: 6 # Example 2: print(trap_water([4, 2, 0, 3, 2, 5])) # Output: 9 # Example 3: print(trap_water([1, 1, 1, 1, 1])) # Output: 0 # Example 4: print(trap_water([0, 0, 0, 0])) # Output: 0 # Example 5: print(trap_water([5, 4, 1, 2])) # Output: 1 ``` # Instructions: 1. Implement the function `trap_water` that takes in a list of building heights and returns the total amount of water that would be trapped between the buildings after it rains. 2. Handle edge cases, especially when the list contains all the same height or when there is no valley to trap any water. 3. Ensure the function is efficient and runs within acceptable time limits for large datasets.","solution":"def trap_water(heights): if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) water_trapped += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += max(0, right_max - heights[right]) return water_trapped"},{"question":"# Question: Longest Increasing Subsequence **Context**: You are developing a feature for a playlist manager that needs to identify the longest sequences of songs, determined by their play counts, that have continually increasing popularity. **Task**: Implement a function `longest_increasing_subsequence` that finds the length of the longest increasing subsequence in a given list of play counts. **Function signature**: ```python def longest_increasing_subsequence(play_counts: List[int]) -> int: pass ``` **Input**: - `play_counts` (List[int]): A list of integers representing the play counts of the songs. **Output**: - Returns the length of the longest increasing subsequence of play counts. **Constraints**: - All input integers are non-negative. - The length of `play_counts` will not exceed 1,000. **Sample Input**: ```python play_counts = [10, 22, 9, 33, 21, 50, 41, 60, 80] ``` **Sample Output**: ```python 6 ``` **Explanation**: The longest increasing subsequence is [10, 22, 33, 50, 60, 80], and its length is 6. While there may be other increasing sequences, none are longer than this one.","solution":"from typing import List def longest_increasing_subsequence(play_counts: List[int]) -> int: if not play_counts: return 0 n = len(play_counts) lis = [1] * n # Initialize LIS values for all indexes # Compute optimized LIS values in a bottom up manner for i in range(1, n): for j in range(0, i): if play_counts[i] > play_counts[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Pick the maximum of all LIS values return max(lis)"},{"question":"# Scenario You are a developer at a logistics company. The company needs to optimize the delivery routes for its fleet. Specifically, your task is to determine the shortest path from the central warehouse to a set of delivery locations using a simple form of routing strategy. # Task Description Implement a Python function `shortest_delivery_path` that calculates the shortest path from the central warehouse to all specified delivery locations based on given distances. The distances are provided as a 2D matrix, where each entry `(i, j)` represents the distance from location `i` to location `j`. The central warehouse is represented by index `0`. # Function Signature ```python def shortest_delivery_path(distances: list[list[int]]) -> list[int]: ``` # Input - `distances`: A 2D list where `distances[i][j]` is a non-negative integer that represents the distance from location `i` to location `j`. It is guaranteed to be a square matrix (the number of rows is equal to the number of columns). # Output - A list of integers where each value represents the shortest distance from the central warehouse (location `0`) to each delivery location. The list should include the distance to the warehouse itself (which is `0`). # Constraints - The number of locations (including the central warehouse) will be between 2 and 100. - All distances are non-negative integers. - It is guaranteed that there is at least one path from the warehouse to each delivery location. # Performance Requirements - Your solution should aim for a time complexity of O(n^2), where `n` is the number of locations. - Use Dijkstra\'s algorithm or an equivalent efficient shortest path algorithm. # Example ```python # Example 1 distances = [ [0, 2, 9, inf], [1, 0, 6, 4], [inf, 7, 0, 8], [6, 3, inf, 0] ] # Expected: [0, 2, 8, 6] print(shortest_delivery_path(distances)) # Example 2 distances = [ [0, 10, 20], [10, 0, 30], [20, 30, 0] ] # Expected: [0, 10, 20] print(shortest_delivery_path(distances)) ``` # Notes - Use the value `inf` (infinity) to represent locations that are not directly connected. - Return the shortest path distances in the same order as the locations. - Explicitly handle edge cases such as: - Only one delivery location. - Direct connections only from the warehouse. - Multiple indirect paths with varying distances.","solution":"import heapq def shortest_delivery_path(distances): Finds the shortest path from the central warehouse (location 0) to all other locations. Parameters: distances (list[list[int]]): A 2D list representing the distance matrix. Returns: list[int]: A list of shortest distances from the warehouse to each location. n = len(distances) shortest_paths = [float(\'inf\')] * n shortest_paths[0] = 0 min_heap = [(0, 0)] # (distance, node) while min_heap: current_distance, current_node = heapq.heappop(min_heap) if current_distance > shortest_paths[current_node]: continue for neighbor in range(n): distance = distances[current_node][neighbor] if distance < float(\'inf\'): total_distance = current_distance + distance if total_distance < shortest_paths[neighbor]: shortest_paths[neighbor] = total_distance heapq.heappush(min_heap, (total_distance, neighbor)) return shortest_paths"},{"question":"# Minimum Edit Distance Given two strings, `str1` and `str2`, write a function to compute the minimum edit distance between the two strings using dynamic programming. The minimum edit distance is defined as the minimum number of operations (insertions, deletions, or substitutions) required to transform one string into the other. Function Signature ```python def min_edit_distance(str1: str, str2: str) -> int: pass ``` Input - `str1`: A string (1 ≤ length of str1 ≤ 1000). - `str2`: A string (1 ≤ length of str2 ≤ 1000). Output - Return an integer, the minimum number of operations required to transform `str1` into `str2`. Constraints - The function should handle the length of the strings within time limits (use efficient dynamic programming methods). Examples ```python # Example 1 str1 = \\"kitten\\" str2 = \\"sitting\\" # Expected Output: 3 # Example 2 str1 = \\"flaw\\" str2 = \\"lawn\\" # Expected Output: 2 ``` Note 1. You can implement additional helper functions if needed. 2. Ensure that your implementation handles edge cases, such as empty strings, gracefully.","solution":"def min_edit_distance(str1: str, str2: str) -> int: m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Substitution return dp[m][n]"},{"question":"# Coding Question Write a function that takes a list of strings and a target character, and returns a list of words from the original list that start with the given target character. The function should be case-insensitive, meaning it should treat \'A\' and \'a\' as the same character. # Function Signature ```python def words_starting_with(words: List[str], target: str) -> List[str]: pass ``` # Input Format - `words`: A list of strings where each string represents a word. - `target`: A single character string representing the target character. # Output Format - Returns a list of strings from the original list `words` that start with the target character, in the same order they appeared in the original list. # Constraints - `words` list will have at most 10,000 elements. - Each word in `words` is non-empty and will contain only alphabetical characters. - `target` will always be a single alphabetical character. # Examples ```python >>> words_starting_with([\\"Apple\\", \\"banana\\", \\"Avocado\\", \\"cherry\\", \\"Apricot\\"], \'a\') [\'Apple\', \'Avocado\', \'Apricot\'] >>> words_starting_with([\\"Dog\\", \\"cat\\", \\"Dolphin\\", \\"elephant\\", \\"duck\\"], \'D\') [\'Dog\', \'Dolphin\', \'duck\'] >>> words_starting_with([\\"apple\\", \\"Banana\\", \\"avocado\\", \\"Cherry\\", \\"apricot\\"], \'C\') [\'Cherry\'] ```","solution":"from typing import List def words_starting_with(words: List[str], target: str) -> List[str]: Returns a list of words from the original list that start with the given target character. The function is case-insensitive. target = target.lower() return [word for word in words if word.lower().startswith(target)]"},{"question":"# Problem Statement Develop a function that formats a given date string into a human-readable format. The function should handle a variety of common date formats, ensuring robustness and flexibility in parsing and formatting. # Objectives 1. **Design a function that can parse multiple date string formats**. 2. **Output the date in a consistent, human-readable format**. 3. **Implement comprehensive error handling for invalid date strings**. # Requirements 1. Implement the function `format_date_string` which accepts the following parameter: * `date_str` (str): The date string to format. 2. Handle multiple input date formats including but not limited to: * \\"YYYY-MM-DD\\" * \\"DD/MM/YYYY\\" * \\"MM-DD-YYYY\\" * \\"Month DD, YYYY\\" 3. Convert the input date string to the format \\"DD MMMM YYYY\\", where \\"MMMM\\" is the full month name. 4. Include error handling to check for: * Invalid date formats. * Impossible dates (e.g., February 30th). # Input Format * `date_str`: A string representing a date, in one of the supported formats. # Output Format A string representing the formatted date in \\"DD MMMM YYYY\\" format. If the input date string is invalid, return `\\"Invalid date format\\"`. # Example ```python format_date_string(\\"2023-10-25\\") # Output: \\"25 October 2023\\" format_date_string(\\"25/10/2023\\") # Output: \\"25 October 2023\\" format_date_string(\\"10-25-2023\\") # Output: \\"25 October 2023\\" format_date_string(\\"October 25, 2023\\") # Output: \\"25 October 2023\\" format_date_string(\\"02/30/2023\\") # Output: \\"Invalid date format\\" ``` # Constraint * Your solution should efficiently handle the date parsing and formatting with a maximum time complexity of O(1).","solution":"from datetime import datetime def format_date_string(date_str): Formats a given date string into \\"DD MMMM YYYY\\". Handles multiple date formats and ensures invalid dates are handled gracefully. :param date_str: str :return: str date_formats = [\\"%Y-%m-%d\\", \\"%d/%m/%Y\\", \\"%m-%d-%Y\\", \\"%B %d, %Y\\"] for fmt in date_formats: try: date_obj = datetime.strptime(date_str, fmt) return date_obj.strftime(\\"%d %B %Y\\") except ValueError: continue return \\"Invalid date format\\""},{"question":"Data Preprocessing for Time Series Forecasting Given the partially implemented preprocessing class `TimeSeriesPreprocessor` above, your task is to extend its functionality to prepare a dataset for time series forecasting. You will need to: 1. **Implement the `window_data` method** in the `TimeSeriesPreprocessor` class to create data windows (subsets of the time series) suitable for forecasting. 2. **Implement the `split_data` method** to divide the dataset into training and testing datasets based on a specified ratio. # Implementation Details: 1. **`window_data` method** should: - Accept a time series data array and a window size. - Return two arrays: one containing input sequences (windows) and another containing target values (the value to be predicted). 2. **`split_data` method** should: - Accept the windowed dataset and a split ratio. - Return the training and testing subsets of the dataset. # Input/Output: - **Input**: - For `window_data` method: ```python def window_data(self, data, window_size): # data: The complete time series data (e.g., a numpy array) # window_size: The size of each window of input data ``` - For `split_data` method: ```python def split_data(self, windowed_inputs, windowed_targets, split_ratio): # windowed_inputs: The windowed input sequences # windowed_targets: The target values corresponding to the input sequences # split_ratio: The ratio of training data to the whole dataset (e.g., 0.8 for 80% training, 20% testing) ``` - **Output**: - For `window_data` method: It should return two numpy arrays: - `windowed_inputs`: The windowed input sequences. - `windowed_targets`: The corresponding target values for each window. - For `split_data` method: It should return four numpy arrays: - `train_inputs`: The training input sequences. - `train_targets`: The training target values. - `test_inputs`: The testing input sequences. - `test_targets`: The testing target values. # Constraints: 1. The input time series data is assumed to be a one-dimensional numpy array. 2. Window size should be a positive integer less than the length of the time series data. 3. The split ratio should be a float value between 0 and 1. # Example Scenario: ```python # Assuming data is a numpy array of time series data data = np.array([...]) # Creating an object of the TimeSeriesPreprocessor class preprocessor = TimeSeriesPreprocessor() # Creating windows of size 5 windowed_inputs, windowed_targets = preprocessor.window_data(data, window_size=5) # Splitting the data into 80% training and 20% testing train_inputs, train_targets, test_inputs, test_targets = preprocessor.split_data(windowed_inputs, windowed_targets, split_ratio=0.8) ``` # Notes: - Focus on creating robust preprocessing steps suitable for time series forecasting. - Ensure the implementation is efficient, especially for large time series datasets. - Validate your methods through unit tests to confirm they work as expected.","solution":"import numpy as np class TimeSeriesPreprocessor: def window_data(self, data, window_size): Create data windows suitable for forecasting. Parameters: - data: numpy array of time series data - window_size: size of each window of input data Returns: - windowed_inputs: numpy array of input sequences - windowed_targets: numpy array of target values n = len(data) windowed_inputs = [] windowed_targets = [] for i in range(n - window_size): windowed_inputs.append(data[i:i + window_size]) windowed_targets.append(data[i + window_size]) return np.array(windowed_inputs), np.array(windowed_targets) def split_data(self, windowed_inputs, windowed_targets, split_ratio): Split the windowed dataset into training and testing datasets. Parameters: - windowed_inputs: numpy array of input sequences - windowed_targets: numpy array of target values - split_ratio: float value between 0 and 1 indicating training data proportion Returns: - train_inputs: numpy array of training input sequences - train_targets: numpy array of training target values - test_inputs: numpy array of testing input sequences - test_targets: numpy array of testing target values n = len(windowed_inputs) split_index = int(n * split_ratio) train_inputs = windowed_inputs[:split_index] train_targets = windowed_targets[:split_index] test_inputs = windowed_inputs[split_index:] test_targets = windowed_targets[split_index:] return train_inputs, train_targets, test_inputs, test_targets"},{"question":"# Problem Statement: You are developing a simple in-memory key-value store (like a basic version of a database). Extend the provided `KVStore` class to add support for atomic transactions. # Class Signature: ```python class KVStore: def __init__(self): self.store = {} def get(self, key: str) -> str: return self.store.get(key, \\"\\") def set(self, key: str, value: str) -> None: self.store[key] = value def delete(self, key: str) -> None: if key in self.store: del self.store[key] # Implement the following methods def begin(self) -> None: pass def commit(self) -> None: pass def rollback(self) -> None: pass ``` # Requirements: 1. **Methods**: - `begin() -> None`: Start a new transaction block. Any subsequent operations should be part of this transaction. - `commit() -> None`: Commit the transaction, making all changes permanent. - `rollback() -> None`: Roll back all changes made in the current transaction, reverting to the state before the transaction began. 2. **Constraints**: - Nested transactions are not required. Begin should not be called within an active transaction. - Only one active transaction is supported at any given time. - `get`, `set`, and `delete` operations should have their usual semantics outside of a transaction context. 3. **Performance Consideration**: - The operations should efficiently handle key-value pairs up to a maximum of 1000 entries. # Example: ```python # Create an instance of KVStore kv = KVStore() kv.set(\\"key1\\", \\"value1\\") kv.set(\\"key2\\", \\"value2\\") # Begin a transaction kv.begin() kv.set(\\"key1\\", \\"value3\\") print(kv.get(\\"key1\\")) # Should print \\"value3\\" kv.rollback() print(kv.get(\\"key1\\")) # Should print \\"value1\\" # Begin another transaction kv.begin() kv.set(\\"key1\\", \\"value4\\") kv.commit() print(kv.get(\\"key1\\")) # Should print \\"value4\\" ``` **Note**: - Ensure data integrity and consistency when performing transaction operations. - Handle edge cases, such as commit or rollback without a transaction gracefully.","solution":"class KVStore: def __init__(self): self.store = {} self.transaction_log = [] self.in_transaction = False def get(self, key: str) -> str: return self.store.get(key, \\"\\") def set(self, key: str, value: str) -> None: if self.in_transaction: self.transaction_log.append((\\"set\\", key, self.store.get(key, None))) self.store[key] = value def delete(self, key: str) -> None: if self.in_transaction: self.transaction_log.append((\\"delete\\", key, self.store.get(key, None))) if key in self.store: del self.store[key] def begin(self) -> None: if self.in_transaction: raise ValueError(\\"Already in a transaction\\") self.in_transaction = True self.transaction_log = [] def commit(self) -> None: if not self.in_transaction: raise ValueError(\\"No transaction to commit\\") self.transaction_log = [] self.in_transaction = False def rollback(self) -> None: if not self.in_transaction: raise ValueError(\\"No transaction to rollback\\") while self.transaction_log: operation, key, value = self.transaction_log.pop() if operation == \\"set\\": if value is None: del self.store[key] else: self.store[key] = value elif operation == \\"delete\\": if value is not None: self.store[key] = value self.in_transaction = False"},{"question":"# Task: Text Compression You are tasked with developing a small text compression utility. The utility should be able to compress a string using a simple Run-Length Encoding (RLE) technique and also decompress an RLE-encoded string back to its original form. Part 1: Compression Write a function `compress(text: str) -> str` that: - Takes a string `text` as input. - Returns a string representing the Run-Length Encoded version of the input text. Run-Length Encoding works by replacing consecutive repeated characters with the character followed by the number of occurrences. For example: - Input: `\\"aaabbcccc\\"` - Output: `\\"a3b2c4\\"` If the input string is empty, the function should return an empty string. Constraints: - The input string will only contain uppercase and lowercase English letters (a-z, A-Z). Part 2: Decompression Write a function `decompress(encoded_text: str) -> str` that: - Takes a string `encoded_text` representing the Run-Length Encoded text. - Returns the original, uncompressed string. For example: - Input: `\\"a3b2c4\\"` - Output: `\\"aaabbcccc\\"` If the input string is empty, the function should return an empty string. Example ```python >>> compress(\\"aaabbcccc\\") \'a3b2c4\' >>> decompress(\\"a3b2c4\\") \'aaabbcccc\' >>> compress(\\"\\") \'\' >>> decompress(\\"\\") \'\' ``` Requirements - Ensure that both compression and decompression handle edge cases such as an empty string correctly. - Provide appropriate error messages for invalid inputs (e.g., invalid format for decompression). - Implement both the `compress` and `decompress` functions in Python.","solution":"def compress(text: str) -> str: if not text: return \\"\\" compressed = [] count = 1 previous_char = text[0] for char in text[1:]: if char == previous_char: count += 1 else: compressed.append(f\\"{previous_char}{count}\\") previous_char = char count = 1 compressed.append(f\\"{previous_char}{count}\\") return \'\'.join(compressed) def decompress(encoded_text: str) -> str: if not encoded_text: return \\"\\" decompressed = [] length = len(encoded_text) i = 0 while i < length: char = encoded_text[i] i += 1 num_start = i while i < length and encoded_text[i].isdigit(): i += 1 count = int(encoded_text[num_start:i]) decompressed.append(char * count) return \'\'.join(decompressed)"},{"question":"Problem Statement Create a function `find_duplicates` that efficiently identifies all duplicate elements in a list of integers. The function should take a list as its input and return a list of the duplicate elements sorted in ascending order. Each duplicate should appear only once in the output list, regardless of how many times it appears in the input list. # Requirements 1. Implement the `find_duplicates` function. 2. Ensure the function can handle both positive and negative integers. 3. Aim for a time complexity better than O(n^2), preferably O(n log n) or better. # Input - A list of integers, which may include both positive and negative values. # Output - A list of duplicate integers sorted in ascending order. # Constraints - The input list can have up to (10^6) elements. - Elements in the list can range from -(10^9) to (10^9). # Example ```python >>> find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]) [2, 3] >>> find_duplicates([10, 20, -10, 30, -10, 40, 50, 20]) [-10, 20] >>> find_duplicates([1, 2, 3, 4, 5]) [] ``` # Note - Ensure that the function handles lists with no duplicates correctly by returning an empty list. - The output list should not contain any duplicates and should be in ascending order as specified. - Make effective use of data structures such as sets or dictionaries to ensure efficient lookup and storage operations where suitable.","solution":"def find_duplicates(nums): Identifies all duplicate elements in a list of integers and returns them sorted in ascending order. Each duplicate appears only once in the output list. from collections import Counter counter = Counter(nums) duplicates = [num for num, count in counter.items() if count > 1] return sorted(duplicates)"},{"question":"# Question: Implement a Function to Calculate the Intersection of Two Rectangles Create a function that takes two rectangles on a Cartesian coordinate plane and computes the area of their intersection. If the rectangles do not intersect, the function should return 0. Requirements: * Implement a function named `rectangle_intersection(rect1: dict, rect2: dict) -> int` where: * `rect1` and `rect2` are dictionaries each containing the keys: `\'x1\'`, `\'y1\'`, `\'x2\'`, and `\'y2\'`. - `\'x1\'` and `\'y1\'` represent the coordinates of the bottom-left corner of the rectangle. - `\'x2\'` and `\'y2\'` represent the coordinates of the top-right corner of the rectangle. * The function should: * Validate the input rectangles to ensure `x1 < x2` and `y1 < y2` for both rectangles. * Calculate the dimensions of the intersection rectangle if it exists. * Return the area of the intersection rectangle as an integer. Constraints: * You may assume that the input coordinates are integers. * Rectangles should be aligned with the axes (i.e., no rotation). * The function should handle cases where rectangles do not overlap or just touch at the edges (return 0). Examples: ```python >>> rect1 = {\'x1\': 1, \'y1\': 1, \'x2\': 3, \'y2\': 3} >>> rect2 = {\'x1\': 2, \'y1\': 2, \'x2\': 4, \'y2\': 4} >>> rectangle_intersection(rect1, rect2) 1 >>> rect1 = {\'x1\': 1, \'y1\': 1, \'x2\': 3, \'y2\': 3} >>> rect2 = {\'x1\': 3, \'y1\': 3, \'x2\': 4, \'y2\': 4} >>> rectangle_intersection(rect1, rect2) 0 >>> rect1 = {\'x1\': 0, \'y1\': 0, \'x2\': 5, \'y2\': 5} >>> rect2 = {\'x1\': 2, \'y1\': 2, \'x2\': 3, \'y2\': 3} >>> rectangle_intersection(rect1, rect2) 1 ``` **Note**: Ensure the implementation correctly handles edge cases, such as when the rectangles overlap along only one dimension or are completely separate. The solution should be efficient with time and space complexity around O(1).","solution":"def rectangle_intersection(rect1, rect2): Calculate the area of intersection between two rectangles. :param dict rect1: A dictionary containing the coordinates of the first rectangle :param dict rect2: A dictionary containing the coordinates of the second rectangle :return: The area of the intersection of the two rectangles :rtype: int # Validate the rectangles if not (rect1[\'x1\'] < rect1[\'x2\'] and rect1[\'y1\'] < rect1[\'y2\'] and rect2[\'x1\'] < rect2[\'x2\'] and rect2[\'y1\'] < rect2[\'y2\']): raise ValueError(\\"Invalid rectangle coordinates\\") # Calculate the intersection coordinates left = max(rect1[\'x1\'], rect2[\'x1\']) right = min(rect1[\'x2\'], rect2[\'x2\']) bottom = max(rect1[\'y1\'], rect2[\'y1\']) top = min(rect1[\'y2\'], rect2[\'y2\']) # Calculate the dimensions of the intersection rectangle width = right - left height = top - bottom # If the rectangles do not intersect or just touch at the edges if width <= 0 or height <= 0: return 0 return width * height"},{"question":"# Currency Exchange Rate Converter **Context**: You\'re tasked with developing a currency exchange application that allows users to convert amounts between different currencies based on the latest exchange rates. This application will be used frequently for international transactions and must provide accurate and up-to-date conversions. **Task**: Implement a function `exchange_rate_converter` that converts a given amount from one currency to another using provided exchange rates. The function should accept the amount to be converted, the source currency, the target currency, and a dictionary of exchange rates. **Function Signature**: ```python def exchange_rate_converter(amount: float, source_currency: str, target_currency: str, rates: dict) -> float: pass ``` **Input**: * `amount`: The amount of money to be converted (as a float). * `source_currency`: The currency code of the amount\'s current currency (as a string). * `target_currency`: The currency code of the currency to convert the amount into (as a string). * `rates`: A dictionary with currency codes as keys and their corresponding exchange rates to a common reference currency (e.g., USD) as values. **Output**: * The converted amount in the target currency (as a float). **Constraints**: * The amount must be a non-negative number. * The currency codes will always be valid ISO 4217 currency codes. * The rates dictionary will contain valid and up-to-date exchange rates. * Floating-point precision should be considered to avoid significant numerical errors. **Example**: ```python # Example exchange rates dictionary exchange_rates = { \\"USD\\": 1.0, # Base currency is USD \\"EUR\\": 0.85, # 1 USD = 0.85 EUR \\"JPY\\": 110.0 # 1 USD = 110.0 JPY } # Example conversion amount = 100.0 source_currency = \\"USD\\" target_currency = \\"EUR\\" # Expected result # 100 USD * 0.85 EUR/USD = 85 EUR print(f\\"{exchange_rate_converter(amount, source_currency, target_currency, exchange_rates):0.2f} EUR\\") # Should be 85.00 EUR ``` # Guidelines: 1. Use the provided code snippet as a reference. 2. Ensure the function handles various currency pairs gracefully and accurately. 3. Test your solution with multiple sets of currencies and amounts to ensure precision and correctness. Note that you are responsible for ensuring the function returns the correct converted amount, considering all edge cases like converting between the same currency and dealing with very small or large amounts.","solution":"def exchange_rate_converter(amount: float, source_currency: str, target_currency: str, rates: dict) -> float: Converts a given amount from one currency to another using the given exchange rates. Parameters: amount (float): The amount of money to be converted. source_currency (str): The currency code of the amount\'s current currency. target_currency (str): The currency code of the currency to convert the amount into. rates (dict): A dictionary with currency codes as keys and their corresponding exchange rates to a common reference currency. Returns: float: The converted amount in the target currency. if amount < 0: raise ValueError(\\"Amount cannot be negative\\") if source_currency not in rates or target_currency not in rates: raise ValueError(\\"Currency code not found in rates dictionary\\") if source_currency == target_currency: return amount # Convert amount from source currency to base currency (USD) amount_in_base = amount / rates[source_currency] # Convert amount from base currency (USD) to target currency converted_amount = amount_in_base * rates[target_currency] return converted_amount"},{"question":"# Problem Statement: Imagine you are working with a list of numeric stock prices for a company over a period. Your task is to write a function that identifies the best days to buy and sell stock to maximize profit. However, with an additional condition: the transaction fee associated with each buy/sell transaction is a fixed amount. # Function Definition Implement a function `max_profit_with_fee(prices: List[int], fee: int) -> int` that computes the maximum profit that can be achieved after considering the transaction fee for each buy/sell. # Input - `prices`: A list of integers where `prices[i]` is the stock price on day `i`. - `fee`: An integer representing the fixed transaction fee for each buy or sell. # Output - Return an integer representing the maximum profit achievable after taking into account the transaction fees. # Constraints - All prices will be in the range of 0 to 10^4. - The length of the `prices` list will be between 1 and 10^5. - The `fee` will be a non-negative integer within the range [0, 500]. # Examples ```python # Example 1: >>> max_profit_with_fee([1, 3, 2, 8, 4, 9], 2) 8 Explanation: Buy on day 0 (price = 1) and sell on day 3 (price = 8) profit = 8 - 1 - 2 = 5. Buy on day 4 (price = 4) and sell on day 5 (price = 9) profit = 9 - 4 - 2 = 3. Total profit = 5 + 3 = 8. # Example 2: >>> max_profit_with_fee([1, 3, 7, 5, 10, 3], 3) 6 Explanation: Buy on day 0 (price = 1) and sell on day 2 (price = 7) profit = 7 - 1 - 3 = 3. Buy on day 3 (price = 5) and sell on day 4 (price = 10) profit = 10 - 5 - 3 = 2. Total profit = 3 + 2 = 5, but a better approach is to keep holding until day 4, so the profit remains 6. ``` # Notes - Ensure the function handles edge cases like no profit scenario. - The algorithm must operate within a time complexity of O(n), where n is the length of the `prices` list. - Comment your code appropriately explaining the logic behind your approach. - Think effectively about minimizing state transitions and avoiding unnecessary calculations for achieving optimal efficiency.","solution":"def max_profit_with_fee(prices, fee): Returns the maximum profit achievable after taking into account the transaction fee. :param prices: List[int] - List of stock prices :param fee: int - Transaction fee for each buy/sell transaction :return: int - Maximum profit if not prices or len(prices) == 1: return 0 cash = 0 # The maximum profit we could have if we did not have a share. hold = -prices[0] - fee # The maximum profit we could have if we hold a share. for price in prices[1:]: cash = max(cash, hold + price) # Max profit if we sell the share today hold = max(hold, cash - price - fee) # Max profit if we buy the share today return max(cash, hold)"},{"question":"# List Merging and Sorting Function Write a function in Python called `merge_and_sort_lists` that accepts two parameters: 1. `list1` (List[int]): A list of integers. 2. `list2` (List[int]): Another list of integers. The function should merge the two lists, sort the resulting list in ascending order, and remove any duplicate values. Finally, it should return the sorted list of unique values. # Constraints: * The input lists, `list1` and `list2`, can have lengths in the range of 0 to 10<sup>5</sup>. * Each list can contain integers from -10<sup>9</sup> to 10<sup>9</sup>. * Your function should be optimized to handle large inputs efficiently. # Inputs: * `list1`: a list containing 0 to 100,000 integers. * `list2`: a list containing 0 to 100,000 integers. # Outputs: * A sorted list of unique integers. # Example: ```python print(merge_and_sort_lists([5, 3, 1], [6, 2, 3, 1])) ``` Should return: ```python [1, 2, 3, 5, 6] ``` # Hints: * Consider using Python\'s set data structure to remove duplicates efficiently. * Utilize the `sorted()` function to sort the list. # Additional Example: ```python print(merge_and_sort_lists([], [4, 2, 2, 3, 9])) ``` Should return: ```python [2, 3, 4, 9] ```","solution":"def merge_and_sort_lists(list1, list2): Merges two lists, sorts the resulting list in ascending order, and removes duplicates. Parameters: list1 (list of int): The first list of integers. list2 (list of int): The second list of integers. Returns: list of int: A sorted list of unique integers. merged_set = set(list1) | set(list2) sorted_list = sorted(merged_set) return sorted_list"},{"question":"# Radix Sort Implementation You are required to implement the `radix_sort` function to sort a list of non-negative integers using the radix sort algorithm. This sorting algorithm processes the integers digit by digit from the least significant to the most significant digit. Function Signature ```python def radix_sort(arr: List[int]) -> List[int]: pass ``` Input - `arr (List[int])`: A list of non-negative integers that need to be sorted. Output - `List[int]`: The sorted list of integers. Constraints - All integers in `arr` will be non-negative. - The length of `arr` is within the range [1, 10000]. Example ```python arr = [170, 45, 75, 90, 802, 24, 2, 66] sorted_arr = radix_sort(arr) print(sorted_arr) # expected output: [2, 24, 45, 66, 75, 90, 170, 802] ``` Explanation 1. Initialize the maximum number to determine the number of digits in the largest number. 2. Iterate through the digits from the least significant to the most significant. 3. Use a stable sorting algorithm (e.g., counting sort) to sort numbers based on the current digit. 4. Repeat the process for subsequent digits until all digits in the largest number are processed. 5. Return the sorted array. Notes - Use the base-10 (decimal) system for digit extraction. - Ensure the algorithm leverages stable sorting techniques to maintain the order of values with the same digit. - A series of counting sort operations can be used in each digit pass for efficiency. - Handle edge cases like single-element arrays or arrays where all elements are the same.","solution":"from typing import List def counting_sort(arr: List[int], exp: int) -> List[int]: n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 for i in range(n): arr[i] = output[i] return arr def radix_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return arr max_val = max(arr) exp = 1 while max_val // exp > 0: arr = counting_sort(arr, exp) exp *= 10 return arr"},{"question":"# Implementing a File System with In-Memory Structure Scenario You are tasked with developing an in-memory file system to manage directories and files. The file system should allow hierarchical directory structures and support basic operations like creating, deleting, and listing files and directories. Objective * **Implement**: Implement a `FileSystem` class that supports efficient file and directory management. * **Test**: Write test cases to ensure your implementation is correct. # Requirements `FileSystem` Class 1. **Init Method**: Initialize the class with a root directory. ```python def __init__(self): pass ``` 2. **Make Directory Method**: Implement a method to create a new directory at a specified path. ```python def mkdir(self, path: str) -> None: pass ``` 3. **Add File Method**: Implement a method to create a new file with content at a specified path. ```python def add_file(self, path: str, content: str) -> None: pass ``` 4. **Read File Method**: Implement a method to read the content of a file at a specified path. ```python def read_file(self, path: str) -> str: pass ``` 5. **List Directory Method**: Implement a method to list all files and directories at a specified path. ```python def ls(self, path: str) -> List[str]: pass ``` # Example Usage ```python # Initialize the file system fs = FileSystem() # Create directories fs.mkdir(\\"/a/b/c\\") # Add files fs.add_file(\\"/a/b/c/d.txt\\", \\"Hello world\\") # Read files assert fs.read_file(\\"/a/b/c/d.txt\\") == \\"Hello world\\" # List directories and files assert fs.ls(\\"/\\") == [\\"a\\"] assert fs.ls(\\"/a/b/c\\") == [\\"d.txt\\"] assert fs.ls(\\"/a/b\\") == [\\"c\\"] # Create more directories and files fs.mkdir(\\"/a/b/e\\") fs.add_file(\\"/a/b/e/f.txt\\", \\"Another file\\") assert fs.ls(\\"/a/b\\") == [\\"c\\", \\"e\\"] assert fs.ls(\\"/a/b/e\\") == [\\"f.txt\\"] assert fs.read_file(\\"/a/b/e/f.txt\\") == \\"Another file\\" ``` # Constraints * Path strings will always start with \\"/\\" and will not end with \\"/\\". * 1 ≤ length of any directory name or file name ≤ 100 * 1 ≤ depth of any path ≤ 100 * The text content of files will only contain ASCII characters. # Instructions 1. Implement the class and its methods as described. 2. Create a suite of test cases to verify the correctness of your implementation. 3. Ensure your implementation is efficient and can handle edge cases.","solution":"class FileSystem: def __init__(self): self.fs = {} def mkdir(self, path: str) -> None: dirs = path.split(\'/\')[1:] current = self.fs for d in dirs: if d not in current: current[d] = {} current = current[d] def add_file(self, path: str, content: str) -> None: dirs, file_name = path.rsplit(\'/\', 1) self.mkdir(dirs) current = self.fs for d in dirs.split(\'/\')[1:]: current = current[d] current[file_name] = content def read_file(self, path: str) -> str: dirs, file_name = path.rsplit(\'/\', 1) current = self.fs for d in dirs.split(\'/\')[1:]: current = current[d] return current[file_name] def ls(self, path: str) -> [str]: if path == \\"/\\": return sorted(self.fs.keys()) else: dirs = path.split(\'/\')[1:] current = self.fs for d in dirs: current = current[d] if isinstance(current, dict): return sorted(current.keys()) else: return []"},{"question":"# Problem Statement Implement a function to perform run-length encoding of a given string. Run-length encoding is a simple form of data compression where consecutive identical elements (characters in this case) are replaced with a single instance of the element followed by a count of the number of occurrences. Create a function `run_length_encode(input_string: str) -> str` that takes in a string and returns its run-length encoded version. # Input: * A single string `input_string` consisting of only uppercase and lowercase alphabet characters. # Output: * A single string representing the run-length encoded version of the input string. # Constraints: * The length of `input_string` will be between 1 and 10^5. * The input string will contain only alphabetic characters (both uppercase and lowercase). # Example: ```python def test_run_length_encode(): assert run_length_encode(\\"aaaabbbcc\\") == \\"a4b3c2\\" assert run_length_encode(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" assert run_length_encode(\\"abcd\\") == \\"a1b1c1d1\\" assert run_length_encode(\\"aaAA\\") == \\"a2A2\\" test_run_length_encode() ``` # Explanation: * For the first assertion, \\"aaaabbbcc\\" becomes \\"a4b3c2\\". * For the second assertion, \\"aabcccccaaa\\" becomes \\"a2b1c5a3\\". * For the third assertion, \\"abcd\\" becomes \\"a1b1c1d1\\". * For the fourth assertion, \\"aaAA\\" becomes \\"a2A2\\" because the encoding is case-sensitive. # Performance Considerations: * Ensure the solution efficiently handles large strings as per the constraints. * Aim for an optimal time complexity in terms of traversal and manipulation of the string.","solution":"def run_length_encode(input_string: str) -> str: if not input_string: return \\"\\" encoded_string = [] current_char = input_string[0] count = 1 for char in input_string[1:]: if char == current_char: count += 1 else: encoded_string.append(current_char + str(count)) current_char = char count = 1 encoded_string.append(current_char + str(count)) # append the last group return \'\'.join(encoded_string)"},{"question":"# Question: Implement an LRU (Least Recently Used) Cache Implement an LRU (Least Recently Used) cache. The cache should store a fixed number of key-value pairs and should evict the least recently used item when the cache reaches its capacity. Class Specification: 1. `class LRUCache` - **Method Signatures**: - `__init__(self, capacity: int)` - `get(self, key: int) -> int` - `put(self, key: int, value: int) -> None` - **Attributes**: - `capacity`: An integer representing the maximum number of items the cache can hold. - **Example**: ```python cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # Cache is {1=1, 2=2} cache.put(3, 3) # Evicts key 2, Cache is {1=1, 3=3} assert cache.get(2) == -1 # Key 2 not found cache.put(4, 4) # Evicts key 1, Cache is {4=4, 3=3} assert cache.get(1) == -1 # Key 1 not found assert cache.get(3) == 3 # Cache is {3=3, 4=4} assert cache.get(4) == 4 # Cache is {4=4, 3=3} ``` Requirements: - Use a combination of a dictionary and a doubly linked list to achieve average time complexity of O(1) for both `get` and `put` operations. - Make sure the `get` method returns the value for the provided key if it exists in the cache, otherwise return `-1`. - If the cache reaches its capacity, the `put` method should evict the least recently used item before adding the new key-value pair. Constraints: - `1 <= capacity <= 3000` - `0 <= key, value <= 10^4` - At most `3 * 10^4` calls will be made to `get` and `put`. Note: Implementing the `LRUCache` class with the specified methods and behaviors using efficient data structures is key to matching the LRU requirement as described.","solution":"class Node: def __init__(self, key=None, value=None): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} # Dummy head and tail nodes to avoid empty states self.head = Node() self.tail = Node() self.head.next = self.tail self.tail.prev = self.head def _add_node(self, node: Node): # Always add the new node right after head node.prev = self.head node.next = self.head.next self.head.next.prev = node self.head.next = node def _remove_node(self, node: Node): # Remove an existing node from the linked list prev = node.prev new = node.next prev.next = new new.prev = prev def _move_to_head(self, node: Node): # Move certain node to the head (as most recently used) self._remove_node(node) self._add_node(node) def _pop_tail(self) -> Node: # Pop the current tail (least recently used) node = self.tail.prev self._remove_node(node) return node def get(self, key: int) -> int: node = self.cache.get(key, None) if node is None: return -1 # Move the accessed node to the head self._move_to_head(node) return node.value def put(self, key: int, value: int) -> None: node = self.cache.get(key) if node is None: # Create a new node newNode = Node(key, value) self.cache[key] = newNode self._add_node(newNode) if len(self.cache) > self.capacity: # Pop the tail tail = self._pop_tail() del self.cache[tail.key] else: # Update the value node.value = value self._move_to_head(node)"},{"question":"# Scenario You are tasked with developing a feature for a warehouse management application that tracks the inventory status of different products. The aim is to determine if it is possible to fulfill a customer\'s order given the current stock levels of various products and the requested quantities. # Task Write a function `can_fulfill_order` that accepts two lists: `stock_levels`, which represents the current stock quantities for `n` products, and `order_quantities`, which represents the requested quantities for the same `n` products. The function should return a boolean value indicating whether the customer\'s order can be completely fulfilled with the available stock. # Function Signature ```python def can_fulfill_order(stock_levels: list[int], order_quantities: list[int]) -> bool: ``` # Input * `stock_levels` - a list of integers, where each element represents the current stock level of a product. * Constraints: * The length of the list will be between 1 and 1000. * Each stock level will be a non-negative integer less than or equal to 1000. * `order_quantities` - a list of integers, where each element represents the requested quantity of a corresponding product. * Constraints: * The length of the list will be identical to `stock_levels`. * Each order quantity will be a non-negative integer less than or equal to 1000. # Output * A boolean value indicating whether the customer\'s order can be fulfilled (`True` if it can be fulfilled, `False` otherwise). # Example ```python assert can_fulfill_order([5, 2, 8], [3, 2, 5]) == True assert can_fulfill_order([3, 4, 2], [4, 1, 2]) == False assert can_fulfill_order([0, 5, 7], [0, 5, 7]) == True ```","solution":"def can_fulfill_order(stock_levels: list[int], order_quantities: list[int]) -> bool: Determines if the customer\'s order can be fulfilled with the available stock. Args: stock_levels (list[int]): List of integers representing the current stock levels. order_quantities (list[int]): List of integers representing the requested quantities. Returns: bool: True if the order can be fulfilled, False otherwise. for stock, order in zip(stock_levels, order_quantities): if stock < order: return False return True # Example assertions for testing assert can_fulfill_order([5, 2, 8], [3, 2, 5]) == True assert can_fulfill_order([3, 4, 2], [4, 1, 2]) == False assert can_fulfill_order([0, 5, 7], [0, 5, 7]) == True"},{"question":"**Scenario**: Imagine you are given the task to develop a more varied version of the standard problem of generating all permutations of a list. While the conventional problem involves simply permuting all possible arrangements of items in a list, this variation introduces constraints on the positions certain elements can occupy. **Problem Statement**: Given a list of `n` unique elements and a set of positional constraints, write a function `constrained_permutations` that generates all possible permutations of the list while respecting the given constraints. **Function Signature**: ```python def constrained_permutations(elements: List[str], constraints: List[Tuple[str, int]]) -> List[List[str]]: pass ``` **Input**: - `elements` (List[str]): The list of unique elements. - `constraints` (List[Tuple[str, int]]): A list of tuples where each tuple `(x, y)` means the element `x` must be at the `y`th index (0-indexed) in the permutations. **Output**: - A list of all permutations that satisfy the positional constraints. **Constraints**: 1. 1 <= len(elements) <= 8 2. 0 <= len(constraints) <= len(elements) 3. Elements of `elements` are distinct. 4. Elements of `elements` appear only once in `constraints`. 5. The indices in `constraints` are valid positions within the range of the list\'s length. # Example: ```python # Example usage print(constrained_permutations([\'a\', \'b\', \'c\'], [(\'a\', 1)])) # Expected Output [[\'b\', \'a\', \'c\'], [\'c\', \'a\', \'b\']] ``` **Explanation**: Here, the list consists of 3 elements: [\'a\', \'b\', \'c\']. The constraint specifies that \'a\' must be at index 1 (second position). Only permutations respecting this constraint are returned. In this example, the valid permutations are: 1. \'b\' at index 0, \'a\' at index 1, and \'c\' at index 2. 2. \'c\' at index 0, \'a\' at index 1, and \'b\' at index 2. Feel free to add additional constraints and test cases to fully understand and verify the function and its constraints.","solution":"from itertools import permutations from typing import List, Tuple def constrained_permutations(elements: List[str], constraints: List[Tuple[str, int]]) -> List[List[str]]: # Create a dictionary from constraints for easy access constraint_dict = {element: index for element, index in constraints} # Generate all permutations of the elements all_permutations = permutations(elements) valid_permutations = [] for perm in all_permutations: # Check if the current permutation satisfies all constraints if all(perm[index] == element for element, index in constraints): valid_permutations.append(list(perm)) return valid_permutations"},{"question":"# Question: Longest Increasing Subsequence with Dynamic Programming Context: You are designing a feature for a data analysis tool that recommends an optimal sequence of data points (elements) in a strictly increasing order. To accomplish this, you need to determine the longest increasing subsequence within a series of data points. The existing algorithms are either too slow for the large datasets you are working with, or they are not flexible enough to handle different data types. Task: Write a function `longest_increasing_subsequence` that identifies the length of the longest strictly increasing subsequence from a given list of integers. The implementation must utilize dynamic programming for efficiency. 1. **Input**: * A single list, `sequence`, containing N integers, where 0 ≤ N ≤ 1000. 2. **Output**: * Return the length of the longest strictly increasing subsequence as an integer. 3. **Constraints**: * The list may be empty (N = 0), in which case the output should be 0. * The elements of the list can be positive or negative integers. 4. **Performance**: * Aim to implement the function with a time complexity of O(n^2). 5. **Edge Cases**: * An empty list. * A list with all identical elements. * A list that is already in strictly increasing order. * A list in strictly decreasing order. Example Usage: ```python def longest_increasing_subsequence(sequence: List[int]) -> int: # Your implementation goes here pass # Example test cases print(longest_increasing_subsequence([10, 20, 10, 30, 40, 50])) # Output: 5 print(longest_increasing_subsequence([3, 10, 2, 1, 20])) # Output: 3 print(longest_increasing_subsequence([3, 2, 1])) # Output: 1 print(longest_increasing_subsequence([50, 3, 10, 7, 40, 80])) # Output: 4 # Handling edge cases print(longest_increasing_subsequence([])) # Output: 0 print(longest_increasing_subsequence([5, 5, 5, 5])) # Output: 1 print(longest_increasing_subsequence([1, 2, 3, 4, 5])) # Output: 5 print(longest_increasing_subsequence([5, 4, 3, 2, 1])) # Output: 1 ``` Notes: Test cases should cover a variety of scenarios, including edge cases, to ensure the robustness and correctness of the function.","solution":"def longest_increasing_subsequence(sequence): if not sequence: return 0 n = len(sequence) dp = [1] * n # dp[i] will be the length of LIS ending at index i for i in range(1, n): for j in range(i): if sequence[i] > sequence[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Problem Statement You are given a string representing a binary number. Your task is to develop a function `next_greater_binary` that returns the next greater binary number in lexicographical order. If the given binary number is the maximum possible for its length, the function should wrap around and return the smallest binary number of the same length. # Function Signature ```python def next_greater_binary(binary: str) -> str: pass ``` # Input * **binary**: A string representing a binary number. The length of the string will be at least 1 and at most 1000. # Output * A string representing the next greater binary number in lexicographical order, or the smallest binary number if the input is the largest possible binary number of that length. # Constraints * The input string will only contain characters \'0\' and \'1\'. * The length of the binary string will not exceed 1000. # Performance Requirements * The solution should handle strings of length up to 1000 efficiently. # Example ```python >>> next_greater_binary(\\"101\\") \\"110\\" >>> next_greater_binary(\\"111\\") \\"000\\" >>> next_greater_binary(\\"000\\") \\"001\\" >>> next_greater_binary(\\"0101\\") \\"0110\\" >>> next_greater_binary(\\"0111\\") \\"1000\\" >>> next_greater_binary(\\"1100\\") \\"1101\\" >>> next_greater_binary(\\"1\\") \\"0\\" >>> next_greater_binary(\\"1111\\") \\"0000\\" ``` # Edge Cases To Consider * Strings with only one character. * Strings where all bits are \'1\'. * Strings where all bits are \'0\'. * Large strings up to the maximum length. # Hints 1. Consider how binary numbers increment naturally in integer arithmetic. 2. You may need to use a loop or find a way to simulate the binary addition to get the next lexicographical order. 3. Handle the wrap-around by checking if the number is the maximum possible for its length.","solution":"def next_greater_binary(binary: str) -> str: Returns the next greater binary number in lexicographical order. If the given binary number is the maximum possible for its length, returns the smallest binary number of the same length. n = len(binary) if binary == \'1\' * n: return \'0\' * n # Convert the binary string to a list of characters for manipulation binary_list = list(binary) # Find the right-most \'0\' and set it to \'1\' for i in range(n - 1, -1, -1): if binary_list[i] == \'0\': binary_list[i] = \'1\' break # Set all bits to the right of the changed bit to \'0\' for j in range(i + 1, n): binary_list[j] = \'0\' return \'\'.join(binary_list)"},{"question":"# Coding Assessment Question You are given a list of integers representing the daily net profit or loss for a company over a period of days. The company wants to identify a sequence of consecutive days where the profit was maximized. Your task is to write a function that finds the maximum profit that can be achieved from any subarray (consecutive sequence of days) within the list. If all values are negative, the maximum profit is considered to be 0. # Function Signature ```python def max_subarray_profit(profits: list) -> int: pass ``` # Input * `profits` (list of integers): A list of integers where each integer represents the net profit or loss for a specific day. # Output * Returns an integer representing the maximum profit that can be achieved from any subarray. # Constraints * 1 ≤ len(profits) ≤ 10^4 * -10^4 ≤ profits[i] ≤ 10^4 # Examples ```python # Example 1: # Given the profits list [3, -1, 2, 1, -5, 4], the maximum profit subarray is [3, -1, 2, 1] assert max_subarray_profit([3, -1, 2, 1, -5, 4]) == 5 # Example 2: # Given the profits list [-2, -3, 4, -1, -2, 1, 5, -3], the maximum profit subarray is [4, -1, -2, 1, 5] assert max_subarray_profit([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 # Example 3: # Given the profits list [-1, -2, -3, -4], since all are negative, the maximum profit is considered 0 assert max_subarray_profit([-1, -2, -3, -4]) == 0 # Example 4: # Given the profits list [1, 2, 3, 4, 5], the maximum profit subarray is [1, 2, 3, 4, 5] assert max_subarray_profit([1, 2, 3, 4, 5]) == 15 ``` # Explanation The function should: 1. Iterate through the list of integers, considering each subarray of consecutive days. 2. Use a cumulative approach to determine the maximum subarray profit, resetting to 0 if the cumulative profit becomes negative. 3. Return the highest cumulative profit observed, with special consideration for an all-negative list where the result should be 0. # Notes - Handle edge cases such as all elements being negative or having only one day. - Optimize for performance within the given constraints. --- This question should align with the original set in terms of style, complexity, and scope, ensuring a consistent examination experience for candidates.","solution":"def max_subarray_profit(profits: list) -> int: Finds the maximum profit that can be achieved from any subarray within the list. If all values are negative, the maximum profit is considered to be 0. max_current = max_global = 0 for profit in profits: max_current = max(0, max_current + profit) max_global = max(max_global, max_current) return max_global"},{"question":"# Matrix Determinant Calculation Context Matrix operations are fundamental in various fields of computer science, including computer graphics, cryptography, and solving linear equations. One of the key matrix operations is the determinant, which is a scalar value that can be computed from the elements of a square matrix and has various applications in calculus and linear algebra. Task Implement the function `matrix_determinant` that calculates the determinant of a given square matrix. Your function should be able to handle matrices of varying sizes and ensure efficient computation. Function Signature ```python def matrix_determinant(matrix): Function to calculate the determinant of a square matrix. :param matrix: 2D list representing the square matrix. :return: Float value representing the determinant of the matrix. pass ``` Parameters - **matrix** (`list[list[float]]`): A 2D list where each inner list represents a row of the matrix. The matrix is guaranteed to be square, i.e., having the same number of rows and columns. Constraints - The matrix will be non-empty and have dimensions n x n where 1 ≤ n ≤ 10. - The elements of the matrix will be integers or floats in the range [-1000, 1000]. Expected Output - Return a single float value representing the determinant of the matrix. Example ```python # Example matrix matrix = [[4, 3], [6, 3]] # Calling the function determinant = matrix_determinant(matrix) # `determinant` is expected to be -6.0 print(determinant) # Output: -6.0 ``` Notes - One way to compute the determinant is by using the Laplace expansion (recursive method). - It is recommended to implement a helper function for calculating the minors and cofactors. - Validate the input matrix to ensure it is square. - Optimize for performance, though simplicity can be prioritized given the constraint n ≤ 10. # Further Instructions 1. Make sure to handle edge cases like matrices of size 1x1. 2. Implement necessary helper functions within the main function if required. 3. You are allowed to use standard libraries but avoid using any built-in function for determinant calculation. By creating a question about calculating the determinant of a square matrix, this task tests understanding of recursion and matrix operations while ensuring the complexity level aligns with the existing questions.","solution":"def matrix_determinant(matrix): Function to calculate the determinant of a square matrix. :param matrix: 2D list representing the square matrix. :return: Float value representing the determinant of the matrix. def get_minor(matrix, i, j): # Return the minor of the matrix by removing row i and column j return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def determinant(matrix): # Base case for 1x1 matrix if len(matrix) == 1: return matrix[0][0] # Base case for 2x2 matrix if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 # Expand along the first row for c in range(len(matrix)): det += ((-1) ** c) * matrix[0][c] * determinant(get_minor(matrix, 0, c)) return det return determinant(matrix)"},{"question":"# Implement a Basic Stack Data Structure Context Implementing a data structure involves defining how data is stored, accessed, and manipulated. A Stack is a linear data structure that follows the Last In First Out (LIFO) principle. The primary operations are `push` (to add an element to the top), `pop` (to remove the top element), and `peek` (to view the top element without removing it). Task Write a class `Stack` that implements the following methods: 1. `push(item: Any) -> None`: Adds `item` to the top of the stack. 2. `pop() -> Any`: Removes and returns the item from the top of the stack. If the stack is empty, raise an `IndexError` with a message \\"pop from empty stack\\". 3. `peek() -> Any`: Returns the item at the top of the stack without removing it. If the stack is empty, raise an `IndexError` with a message \\"peek from empty stack\\". 4. `is_empty() -> bool`: Returns `True` if the stack is empty, `False` otherwise. 5. `size() -> int`: Returns the number of items in the stack. Requirements * **Input Format**: - Each method should handle its respective input type correctly. * **Output Format**: - Methods should return the appropriate type based on their functionality. Constraints - The stack should handle generic data types. - The stack should be implemented using a Python list. Example Usage ```python # Example s = Stack() s.push(10) s.push(20) print(s.peek()) # Output: 20 print(s.pop()) # Output: 20 print(s.size()) # Output: 1 print(s.is_empty()) # Output: False s.pop() print(s.is_empty()) # Output: True try: s.pop() # Should raise IndexError with the message \\"pop from empty stack\\" except IndexError as e: print(e) ``` Edge Cases * Handling operations on an empty stack (e.g., pop or peek when the stack is empty). * Ensure that the stack can handle different data types (e.g., integers, strings, objects).","solution":"from typing import Any, List class Stack: def __init__(self): self._stack: List[Any] = [] def push(self, item: Any) -> None: self._stack.append(item) def pop(self) -> Any: if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self._stack.pop() def peek(self) -> Any: if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self._stack[-1] def is_empty(self) -> bool: return len(self._stack) == 0 def size(self) -> int: return len(self._stack)"},{"question":"# Coding Assessment Question Unique Anagram Finder You are working on an algorithm to assist in the detection and analysis of anagrams within large datasets of words, which is critical for a text analysis tool you\'re developing. # Problem Statement Write a Python function `find_unique_anagrams(words: list[str]) -> list[str]` that takes a list of strings (words) and returns a list of words that do not have any anagrams within the given list. # Function Signature ```python def find_unique_anagrams(words: list[str]) -> list[str]: ``` # Input * `words`: A list of strings representing the words to analyze. # Output * Returns a list of words that do not have any anagrams in the given list. # Constraints * The length of `words` will be between 1 and 10^5. * Each word will have a length between 1 and 100. * All words will consist of lowercase English letters only. # Example ```python # The word \'abc\' has an anagram \'bca\', \'bat\' has an anagram \'tab\', \'car\' has an anagram \'arc\'. # The only words without an anagram in this list are \'hello\' and \'world\'. print(find_unique_anagrams([\'abc\', \'bca\', \'bat\', \'tab\', \'hello\', \'world\', \'car\', \'arc\'])) # The word \'code\' has an anagram \'oced\', \'decode\' has no anagrams in this list. print(find_unique_anagrams([\'code\', \'oced\', \'shell\', \'decode\'])) # No words have anagrams. print(find_unique_anagrams([\'one\', \'two\', \'three\'])) # All words are anagrams of each other. print(find_unique_anagrams([\'listen\', \'silent\', \'inlets\'])) ``` # Guidelines 1. Normalize each word by sorting the characters (i.e., `\'dormitory\'` -> `\'dimoorrty\'`) to determine if two words are anagrams. 2. Use a dictionary to count frequencies of these normalized forms. 3. Collect words that appear exactly once in the normalized form dictionary. 4. Return the list of original words that do not have any anagrams. # Hints * Consider using a dictionary where keys are the normalized forms and values are counts and lists of original words. * Optimize the solution to handle large inputs efficiently, both in terms of space and time complexity. This question requires you to effectively use data structures such as dictionaries and lists, as well as to implement basic string manipulation and sorting techniques.","solution":"def find_unique_anagrams(words): Returns a list of words that do not have any anagrams in the given list. norm_to_words = {} # Normalize and collect words in dictionary for word in words: norm_word = \'\'.join(sorted(word)) if norm_word in norm_to_words: norm_to_words[norm_word].append(word) else: norm_to_words[norm_word] = [word] # Collect words that do not have anagrams result = [] for norm_word, word_list in norm_to_words.items(): if len(word_list) == 1: result.append(word_list[0]) return result"},{"question":"# Question Title: Real-Time Streaming Data Averaging in Python # Question Description In this task, you are required to write a function that processes streaming data to calculate the moving average for a given window size. This is particularly useful in scenarios where you need to continuously monitor and smooth out fluctuations in real-time data. # Function Signature ```python def moving_average(stream_data: List[int], window_size: int) -> List[float]: pass ``` # Inputs - `stream_data` (List of int): List containing the streaming integers data. - `window_size` (int): The size of the moving window to compute the average. # Output - Returns a `List` of `float`: The list containing the moving average values for each position in the stream data. # Instructions 1. **Window Slide**: - For each position in the list `stream_data`, calculate the average of the elements within the current window. - If there are fewer than `window_size` elements before the current position, calculate the average using all available elements up to the current position. 2. **Maintaining Precision**: - Round the resulting average to two decimal places for each position. # Constraints 1. 1 ≤ `window_size` ≤ len(`stream_data`). 2. The input list `stream_data` will always contain at least one element, and all elements are valid integers. # Example Cases Example 1 ```python stream_data = [1, 2, 3, 4, 5] window_size = 3 result = moving_average(stream_data, window_size) # Expected output: [1.0, 1.5, 2.0, 3.0, 4.0] ``` Example 2 ```python stream_data = [10, 20, 30, 40, 50, 60] window_size = 2 result = moving_average(stream_data, window_size) # Expected output: [10.0, 15.0, 25.0, 35.0, 45.0, 55.0] ``` Example 3 ```python stream_data = [10, 20, 30] window_size = 1 result = moving_average(stream_data, window_size) # Expected output: [10.0, 20.0, 30.0] ``` Notes - The moving average for the first position with a window size larger than 1 will just be the value of the first element itself. - As the position progresses, each moving average is calculated for the current and previous elements up to the `window_size`. This question will help assess the candidate\'s ability to handle streaming data, utilize sliding windows, and maintain precision in calculations, matching the complexity and topic alignment with the existing questions.","solution":"from typing import List def moving_average(stream_data: List[int], window_size: int) -> List[float]: Calculates the moving average for a given window size from the stream data. averages = [] for i in range(len(stream_data)): window_start = max(i - window_size + 1, 0) window_elements = stream_data[window_start:i+1] average = sum(window_elements) / len(window_elements) averages.append(round(average, 2)) return averages"},{"question":"# Coding Assessment Question Scenario You are working on a simulation project that involves generating random points within a given boundary and evaluating the distance from the origin for each point generated. One specific task in your project requires finding the top `n` points that are farthest from the origin. Task Write a function `find_top_farthest_points(n, points)` that finds and returns the top `n` points that are farthest from the origin (0, 0). Each point is represented as a tuple of two integers, `(x, y)`, denoting its coordinates in a 2D plane. Function Signature ```python def find_top_farthest_points(n: int, points: list[tuple[int, int]]) -> list[tuple[int, int]]: ``` Input - `n` (int): The number of top farthest points to find. Must be a positive integer less than or equal to the length of the `points` list. - `points` (list of tuples): A list of tuples where each tuple contains two integers `(x, y)` representing the coordinates of the point. Output - (list of tuples): A list of `n` tuples representing the top `n` points that are farthest from the origin. Constraints - The function should raise a `ValueError` if `n` is not a positive integer or if `n` is greater than the number of available points. - The function should handle ties by including all points that have the same distance if they fall within the top `n`. Example ```python >>> points = [(1, 2), (3, 4), (-5, -6), (7, 8), (0, 0)] >>> find_top_farthest_points(2, points) [(7, 8), (-5, -6)] >>> find_top_farthest_points(-1, points) Traceback (most recent call last): ... ValueError: n must be a positive integer and within the range of the points list >>> find_top_farthest_points(2, [(2, 3), (2, 3), (1, 1)]) [(2, 3), (2, 3)] >>> find_top_farthest_points(0, points) Traceback (most recent call last): ... ValueError: n must be a positive integer and within the range of the points list >>> find_top_farthest_points(6, points) Traceback (most recent call last): ... ValueError: n must be a positive integer and within the range of the points list ``` Note that your implementation should validate the inputs and handle edge cases as demonstrated in the example.","solution":"import math def find_top_farthest_points(n: int, points: list[tuple[int, int]]) -> list[tuple[int, int]]: if not isinstance(n, int) or n <= 0 or n > len(points): raise ValueError(\\"n must be a positive integer and within the range of the points list\\") # Calculate the Euclidean distance from the origin for each point distances = [(math.sqrt(x**2 + y**2), (x, y)) for x, y in points] # Sort the distances in descending order distances.sort(reverse=True, key=lambda pair: pair[0]) # Collect the top n points top_n_points = [point for _, point in distances[:n]] return top_n_points"},{"question":"# Question: Remove Duplicates and Return Frequency Count You are tasked to implement a function that removes duplicate characters from a given string and returns a dictionary containing the count of each unique character in the original string. Function Signature ```python def remove_duplicates_and_count(s: str) -> dict: ``` Input - `s` (str): The input string consisting of any characters from a-z, A-Z, 0-9, and special characters. Output - (dict): A dictionary where the keys are the unique characters from the original string (preserving their first occurrence order) and the values are their respective counts in the original string. Constraints - The input string can have a maximum length of 1000. Examples 1. ```python remove_duplicates_and_count(\\"abracadabra\\") ``` Output: `{\'a\': 5, \'b\': 2, \'r\': 2, \'c\': 1, \'d\': 1}` 2. ```python remove_duplicates_and_count(\\"hello world!\\") ``` Output: `{\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \' \': 1, \'w\': 1, \'r\': 1, \'d\': 1, \'!\': 1}` 3. ```python remove_duplicates_and_count(\\"112233\\") ``` Output: `{\'1\': 2, \'2\': 2, \'3\': 2}` 4. ```python remove_duplicates_and_count(\\"aA!@#%^&*()\\") ``` Output: `{\'a\': 1, \'A\': 1, \'!\': 1, \'@\': 1, \'#\': 1, \'\': 1, \'%\': 1, \'^\': 1, \'&\': 1, \'*\': 1, \'(\': 1, \')\': 1}` # Performance Considerations - Consider optimizing your solution to run efficiently even for the maximum input size. - Ensure that the function handles edge cases such as empty strings gracefully. Implement the function keeping the provided constraints and requirements in mind.","solution":"def remove_duplicates_and_count(s: str) -> dict: Removes duplicate characters from a string and returns a dictionary containing the count of each unique character. Parameters: s (str): The input string. Returns: dict: A dictionary with unique characters as keys and their counts as values. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"# Question: Finding Steiner Tree Approximation in an Undirected Graph The Steiner tree problem for a given graph and a set of required vertices can be seen as finding a minimal subgraph that spans all the given required vertices. In this task, you are required to implement an approximation algorithm for the Steiner tree problem. # Objective Implement a function `approximate_steiner_tree(graph: dict[str, list[str]], required_vertices: set[str]) -> set[tuple[str, str]]` that takes an adjacency list representation of an undirected graph and a set of required vertices, and returns an approximate Steiner tree represented as a set of edges (each edge being a tuple of node identifiers). # Input * `graph` (dictionary): A dictionary where keys are node identifiers (as strings), and values are lists of adjacent nodes (as strings). * `required_vertices` (set): A set of node identifiers (as strings) that must be included in the Steiner tree. # Output * A set of edges (tuples of node identifiers) that form an approximate Steiner tree containing all the required vertices. # Constraints * All node identifiers will be non-negative integers converted to strings. * The input graph will not have multiple edges between the same pair of nodes (no parallel edges). # Performance Requirement * Aim for implementation with reasonable performance given the complexity of the Steiner tree problem (considering both time and space complexity). # Example ```python graph = { \\"1\\": [\\"2\\", \\"3\\"], \\"2\\": [\\"1\\", \\"3\\", \\"4\\", \\"5\\"], \\"3\\": [\\"1\\", \\"2\\", \\"5\\"], \\"4\\": [\\"2\\"], \\"5\\": [\\"2\\", \\"3\\"] } required_vertices = {\\"1\\", \\"4\\", \\"5\\"} print(approximate_steiner_tree(graph, required_vertices)) # Output could be {(\'1\', \'2\'), (\'2\', \'4\'), (\'2\', \'5\')} ``` # Note The exact set of edges may vary due to the nature of approximation algorithms. Ensure that the output edges span all required vertices with minimal total edge count. # Guidelines To approximate the Steiner tree: 1. Begin by connecting the nearest pairs of required vertices using shortest paths. 2. Use a greedy approach to iteratively connect components until all required vertices are included. 3. Aim to minimize the total number of edges in the resulting subgraph.","solution":"import heapq from collections import defaultdict, deque def dijkstra(graph, start): Helper function to perform Dijkstra\'s algorithm to find shortest paths. distances = {node: float(\'infinity\') for node in graph} distances[start] = 0 priority_queue = [(0, start)] predecessors = {node: None for node in graph} while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor in graph[current_node]: distance = current_distance + 1 # Assume all edges have the same weight if distance < distances[neighbor]: distances[neighbor] = distance predecessors[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) return distances, predecessors def get_shortest_path(predecessors, start, end): Helper function to reconstruct the shortest path from start to end. path = [] while end: path.append(end) end = predecessors[end] path.reverse() return path def approximate_steiner_tree(graph, required_vertices): Approximation algorithm for the Steiner Tree problem that returns an approximate Steiner tree. if not required_vertices: return set() edges = set() all_pairs_distances = {} all_pairs_predecessors = {} # Step 1: Compute shortest paths between all pairs of required vertices for rv in required_vertices: distances, predecessors = dijkstra(graph, rv) all_pairs_distances[rv] = distances all_pairs_predecessors[rv] = predecessors # Step 2: Initialize components for required vertices components = {rv: {rv} for rv in required_vertices} component_leader = {rv: rv for rv in required_vertices} def find_leader(node): while node != component_leader[node]: component_leader[node] = component_leader[component_leader[node]] node = component_leader[node] return node def union_components(node1, node2): leader1 = find_leader(node1) leader2 = find_leader(node2) if leader1 != leader2: components[leader1].update(components[leader2]) for n in components[leader2]: component_leader[n] = leader1 del components[leader2] # Step 3: Greedily add edges to form the Steiner tree all_edges = [] for i in required_vertices: for j in required_vertices: if i != j: all_edges.append((all_pairs_distances[i][j], i, j)) all_edges.sort() for distance, i, j in all_edges: leader_i = find_leader(i) leader_j = find_leader(j) if leader_i != leader_j: union_components(i, j) path = get_shortest_path(all_pairs_predecessors[i], i, j) for k in range(len(path) - 1): edges.add((path[k], path[k + 1])) if len(components) == 1: break return edges"},{"question":"# Problem Statement You are given a linked list with possibly repeating values. Your task is to remove the duplicates from the list, but you must retain one instance of each value and preserve the original order of their first occurrences. Write a function `remove_duplicates(head: Optional[ListNode]) -> Optional[ListNode]` that takes the head of a singly linked list and returns the head of the modified list with duplicates removed. Input * `ListNode` is a class representing a node in a singly linked list, with `val` as its integer value and `next` as a pointer to the next node. * `head` is the head of a singly linked list. (0 ≤ number of nodes ≤ 10^5, 1 ≤ node\'s value ≤ 10^5) Output * The head of the singly linked list after duplicates have been removed. Example ``` Input: head = [1, 3, 3, 2, 2, 1, 4] Output: [1, 3, 2, 4] ``` In this example: - The first 1 is kept, subsequent 1\'s are removed. - The first 3 is kept, subsequent 3\'s are removed. - The first 2 is kept, subsequent 2\'s are removed. - The 4 is unique and is kept. Constraints * The solution should utilize O(n) time complexity. * Use additional space only as necessary, but aim for optimal usage. Implement the function `remove_duplicates(head: Optional[ListNode]) -> Optional[ListNode]` that adheres to these requirements.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def remove_duplicates(head: ListNode) -> ListNode: if not head: return None seen = set() current = head seen.add(current.val) while current and current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head"},{"question":"# Scenario A logistics company uses a fleet of drones to deliver packages. Each drone has a maximum payload capacity and a battery life that restricts its operation to a certain distance. The company wants to optimize the loading process by determining the maximum number of packages that can be delivered in one trip without violating the drone\'s capacity constraints. Packages have varying weights and delivery distances. # Problem Statement Implement the function `maximize_packages(packages: List[Tuple[int, int]], capacity: int, max_distance: int) -> int` which returns the maximum number of packages that can be loaded onto a drone without exceeding its total payload capacity and ensuring that all delivery distances are within the allowed maximum distance. # Function Signature ```python def maximize_packages(packages: List[Tuple[int, int]], capacity: int, max_distance: int) -> int: ``` # Input - `packages` (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers: - The first integer is the weight of the package. - The second integer is the distance to the delivery location. - `capacity` (int): The maximum payload capacity of the drone. - `max_distance` (int): The maximum operational distance of the drone. # Output - `int`: The maximum number of packages that can be loaded onto the drone. # Constraints - The input list `packages` will contain between 0 and 1000 tuples. - The weights and distances in `packages` will be non-negative integers. - The capacity and max_distance will be positive integers. # Examples ```python maximize_packages([(10, 5), (15, 7), (20, 3)], 30, 10) -> 2 maximize_packages([(10, 12), (20, 15)], 50, 10) -> 0 maximize_packages([(5, 2), (25, 8), (10, 6)], 40, 10) -> 3 ``` # Guidelines 1. Filter the list of packages to discard those with delivery distances exceeding `max_distance`. 2. Use a greedy or dynamic programming approach to determine the maximum set of packages that can be selected without exceeding the `capacity`. 3. Ensure the solution is efficient and considers the edge cases like empty package lists and scenarios where no packages fit within the constraints. # Hints - Consider sorting the packages by weight or implementing a knapsack variant to maximize the number of items selected. - Make use of memoization or iterative methods to maintain a balance between performance and computational efficiency.","solution":"from typing import List, Tuple def maximize_packages(packages: List[Tuple[int, int]], capacity: int, max_distance: int) -> int: # Filter out packages that exceed the maximum distance valid_packages = [pkg for pkg in packages if pkg[1] <= max_distance] # Sort valid packages by weight valid_packages.sort() total_weight = 0 package_count = 0 for weight, distance in valid_packages: if total_weight + weight <= capacity: total_weight += weight package_count += 1 else: break return package_count"},{"question":"# Integer Partition Problem You are tasked with creating a feature for a mathematical software application that involves partitioning an integer into parts. Specifically, you need to develop two functions to compute and display different ways to partition an integer. # Problem Description 1. **generate_partitions(n: int) -> list[list[int]]** This function generates all possible partitions of a given integer `n`. A partition of `n` is a way of writing `n` as a sum of positive integers where the order of addends does not matter. The generated partitions should be in non-increasing order. 2. **display_partitions(partitions: list[list[int]]) -> None** This function prints the generated partitions in a readable format. Each partition should be displayed on a new line, with its components separated by plus signs (`+`). # Input 1. `generate_partitions`: - `n`: The integer to be partitioned. 2. `display_partitions`: - `partitions`: A list of partitions as returned by `generate_partitions`. # Output 1. `generate_partitions`: A list of lists, where each inner list represents a partition of `n`. 2. `display_partitions`: None. This function prints the partitions in the required format. # Example Usage ```python partitions = generate_partitions(4) display_partitions(partitions) # Expected output: # 4 # 3 + 1 # 2 + 2 # 2 + 1 + 1 # 1 + 1 + 1 + 1 ``` # Debugging Constraints 1. Ensure that all partitions of the integer are generated correctly without duplication. 2. Check that partitions are generated in non-increasing order. 3. Validate the correct handling of edge cases such as `n = 0` and `n = 1`. 4. Optimize the algorithms for both time and space complexity, ensuring scalability for larger integers.","solution":"def generate_partitions(n: int) -> list[list[int]]: Generates all partitions of a given integer `n` in non-increasing order. def _generate_partitions(n): if n == 0: yield [] return for i in range(n, 0, -1): for partition in _generate_partitions(n - i): if not partition or i >= partition[0]: yield [i] + partition return list(_generate_partitions(n)) def display_partitions(partitions: list[list[int]]) -> None: Prints the partitions in a readable format. Each partition is displayed on a new line with its components separated by plus signs (`+`). for partition in partitions: print(\\" + \\".join(map(str, partition)))"},{"question":"# Question: Subarray Product Less Than K You are working as a data scientist for an e-commerce platform. One of the analyses you need to perform is to find subarrays of products whose total sales (product of subarray elements) are less than a specific threshold. Implement a function `num_subarrays_with_product_less_than_k(arr: list[int], k: int) -> int` that returns the number of contiguous subarrays where the product of all the elements in the subarray is less than `k`. # Input - A list of integers `arr`. - An integer `k`. # Output - An integer representing the count of subarrays whose product of elements is less than `k`. # Constraints - Each element in the array is a positive integer. - The length of the array, `len(arr)`, can be at most `10^3`. - `1 <= k <= 10^9`. # Example ```python # Example 1 arr = [10, 5, 2, 6] k = 100 num_subarrays_with_product_less_than_k(arr, k) # Expected Output: 8 # Explanation: The 8 subarrays are [10], [5], [2], [6], [5, 2], [2, 6], [5, 2, 6], and [10, 5, 2] # Example 2 arr = [1, 2, 3] k = 0 num_subarrays_with_product_less_than_k(arr, k) # Expected Output: 0 # Explanation: No subarray\'s product is less than 0. # Example 3 arr = [1, 1, 1] k = 2 num_subarrays_with_product_less_than_k(arr, k) # Expected Output: 6 # Explanation: The 6 subarrays are [1], [1], [1], [1, 1], [1, 1], [1, 1, 1] ``` # Notes - Consider edge cases such as when `k` is very small or very large. - Ensure an efficient approach to handle larger lists, potentially aiming for a solution involving a sliding window to achieve O(N) complexity.","solution":"def num_subarrays_with_product_less_than_k(arr, k): Returns the number of contiguous subarrays where the product of all elements in the subarray is less than `k`. if k <= 1: return 0 count = 0 product = 1 left = 0 # Use a sliding window approach to find the count of desired subarrays for right in range(len(arr)): product *= arr[right] while product >= k and left <= right: product //= arr[left] left += 1 count += right - left + 1 return count"},{"question":"# Question In a software development environment, you\'ve been assigned to build a tool that assists developers in monitoring the efficiency of their code submissions. Your task is to implement a function `analyze_execution_time` that measures and collects the execution times of solutions for different coding problems. The function should: 1. Collect all solution file paths in the specified directory. 2. Load each solution module dynamically using `importlib`. 3. Capture the execution times of each solution. 4. Return a dictionary with the file paths as keys and their respective execution times (in seconds) as values. **Function Signature:** ```python def analyze_execution_time(directory: pathlib.Path) -> dict[pathlib.Path, float]: pass ``` # Input: - `directory`: A `pathlib.Path` object pointing to the directory containing solution files. # Output: - Returns a dictionary where the keys are `pathlib.Path` objects representing file paths and the values are floats representing the execution times in seconds. # Constraints: - Assume each solution file has a function named `solution` that contains the logic whose execution time needs to be measured. - You can use any function or utility from the `time` module. - Raise appropriate errors if critical issues occur, e.g., file not found or invalid file structure. # Example: Given a directory structure: **Directory Structure**: ``` project_euler/ ├── problem_001/ │ └── sol.py ├── problem_002/ │ └── sol.py ``` ```python # Example Usage: from pathlib import Path execution_times = analyze_execution_time(Path(\\"project_euler\\")) print(execution_times) # Possible Output: {Path(\\"project_euler/problem_001/sol.py\\"): 0.005, Path(\\"project_euler/problem_002/sol.py\\"): 0.002} ``` ```python import importlib.util import pathlib import time def analyze_execution_time(directory: pathlib.Path) -> dict[pathlib.Path, float]: results = {} for sol_file in directory.rglob(\'*.py\'): spec = importlib.util.spec_from_file_location(\\"solution_module\\", sol_file) module = importlib.util.module_from_spec(spec) spec.loader.exec_module(module) start = time.time() module.solution() # Assuming each module has a `solution` function end = time.time() execution_time = end - start results[sol_file] = execution_time return results ```","solution":"import importlib.util import pathlib import time def analyze_execution_time(directory: pathlib.Path) -> dict[pathlib.Path, float]: results = {} for sol_file in directory.rglob(\'*.py\'): spec = importlib.util.spec_from_file_location(\\"solution_module\\", sol_file) module = importlib.util.module_from_spec(spec) spec.loader.exec_module(module) start = time.time() module.solution() # Assuming each module has a `solution` function end = time.time() execution_time = end - start results[sol_file] = execution_time return results"},{"question":"# Coding Assessment Question: Efficient Fibonacci Sequence Generator **Context**: The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. For large values of `n`, simple recursive calculations can be highly inefficient. **Objective**: Your task is to create a highly efficient generator for the Fibonacci sequence that can handle very large values of `n`. The goal is to optimize both time and space complexity to ensure fast computations. **Function Signature**: ```python class EfficientFibonacci: def __init__(self) -> None: Initializes the class with any necessary attributes. pass def fib(self, n: int) -> int: Returns the nth Fibonacci number efficiently. pass ``` **Expected Input/Output**: * `fib(n)`: Computes the `nth` Fibonacci number where `n` is a non-negative integer. **Constraints**: 1. `n` will be a positive integer within the range [0, 10^18]. **Requirements**: - **Edge Cases**: Handle the smallest values correctly, such as `n=0` and `n=1`. - **Performance**: Use an optimized algorithm (like matrix exponentiation, dynamic programming, or memoization) to compute the Fibonacci number. **Challenge**: Optimize the `fib` method to handle very large `n` values with minimal performance bottlenecks. Ensure your solution is feasible within the upper constraint limits. # Example Usage: ```python fib_gen = EfficientFibonacci() print(fib_gen.fib(0)) # Should return 0 print(fib_gen.fib(1)) # Should return 1 print(fib_gen.fib(10)) # Should return 55 print(fib_gen.fib(100)) # Should return 354224848179261915075 ```","solution":"class EfficientFibonacci: def __init__(self) -> None: Initializes the class with any necessary attributes. pass def fib(self, n: int) -> int: Returns the nth Fibonacci number efficiently using matrix exponentiation. if n == 0: return 0 if n == 1: return 1 def matrix_mult(A, B): return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]] ] def matrix_pow(matrix, power): result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power: if power % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) power //= 2 return result F = [[1, 1], [1, 0]] result_matrix = matrix_pow(F, n-1) return result_matrix[0][0]"},{"question":"# Coding Question **Objective**: Write a function to evaluate the reachability of a target sum using a list of coin denominations. # Problem Statement You are given a target sum and a list of coin denominations. You need to write a function `can_reach_sum(target: int, coins: List[int]) -> bool` that takes these inputs and returns a boolean value indicating whether it is possible to reach the target sum using any combination of the provided coin denominations. # Input Format - An integer `target` representing the desired sum. - A list of integers `coins` representing the coin denominations. - Example: `12, [1, 2, 5]` # Output Format - A boolean value `True` or `False` indicating whether the target sum can be reached. - Example: `True` # Constraints - 0 <= target <= 1000 - 1 <= len(coins) <= 100 - 1 <= coins[i] <= 100 # Example ```python assert can_reach_sum(12, [1, 2, 5]) == True assert can_reach_sum(11, [2, 4, 6]) == False assert can_reach_sum(0, [1, 2, 5]) == True assert can_reach_sum(10, []) == False ``` # Requirements - The function must account for all possible combinations of the provided coin denominations to determine if the target sum can be reached. - Ensure that your implementation is efficient and can handle the upper limits of the input constraints. # Notes - You can assume that the list of coin denominations will contain distinct values. - The problem is similar to the subset-sum problem, which can be solved using dynamic programming. Consider this approach to ensure an efficient solution.","solution":"from typing import List def can_reach_sum(target: int, coins: List[int]) -> bool: Function to determine if the target sum can be reached using any combination of given coin denominations. # Create a boolean array to store results for all sums up to the target dp = [False] * (target + 1) dp[0] = True # base case: 0 sum can always be reached for coin in coins: for i in range(coin, target + 1): if dp[i - coin]: dp[i] = True return dp[target]"},{"question":"# Problem Statement You are part of a software engineering team developing a financial application. Your task is to implement a function that analyzes stock price data to identify periods of local highs and lows in order to assist traders in making buying and selling decisions. The stock data is provided as a list of prices, where each element represents the stock price at a specific timestamp. A price is considered a local high if it is higher than the prices directly before and after it. Conversely, a price is considered a local low if it is lower than the prices directly before and after it. # Function Signature ```python def find_local_extrema(prices): Identifies local highs and lows in a list of stock prices. Arguments: prices -- a list of float values representing stock prices at consecutive timestamps. Returns: A tuple of two lists: - List of integers representing the indices of local highs. - List of integers representing the indices of local lows. pass ``` # Input * `prices` (List[float]): A list of stock prices at consecutive timestamps. # Output * Tuple of two lists: * `local_highs` (List[int]): Indices of local highs. * `local_lows` (List[int]): Indices of local lows. # Constraints * The length of the `prices` list is at least 3 (you need at least three points to determine a local high or low). * The length of the `prices` list will not exceed ( 10^6 ). * Each element in `prices` is a positive float value. # Performance Requirements * The solution should be efficient, ideally with O(n) complexity, where n is the length of the `prices` list. # Example ```python # Define the parameters prices = [100.0, 101.5, 102.0, 99.0, 100.5, 101.0, 98.5, 99.5] # Call the function highs, lows = find_local_extrema(prices) # Expected output # highs = [2, 5] # lows = [3, 6] ``` # Explanation In the provided example: - The price at index 2 (102.0) is a local high because it is greater than the prices at indices 1 (101.5) and 3 (99.0). - The price at index 5 (101.0) is also a local high because it is greater than the prices at indices 4 (100.5) and 6 (98.5). - The price at index 3 (99.0) is a local low because it is lower than the prices at indices 2 (102.0) and 4 (100.5). - The price at index 6 (98.5) is also a local low because it is lower than the prices at indices 5 (101.0) and 7 (99.5). You need to develop a function that can efficiently identify and return such local highs and lows for any given list of stock prices.","solution":"def find_local_extrema(prices): Identifies local highs and lows in a list of stock prices. Arguments: prices -- a list of float values representing stock prices at consecutive timestamps. Returns: A tuple of two lists: - List of integers representing the indices of local highs. - List of integers representing the indices of local lows. local_highs = [] local_lows = [] for i in range(1, len(prices) - 1): if prices[i] > prices[i - 1] and prices[i] > prices[i + 1]: local_highs.append(i) elif prices[i] < prices[i - 1] and prices[i] < prices[i + 1]: local_lows.append(i) return (local_highs, local_lows)"},{"question":"# Tree Traversal with Specific Node Skipping You are provided with a basic class definition for a binary tree node and a method that performs a level-order traversal (breadth-first traversal). Your task is to implement a new method `level_order_skip_val` for the `BinaryTree` class, which performs a level-order traversal but skips any nodes with a specified value. Requirements: 1. **Input**: The `level_order_skip_val` method should take an integer `skip_val` as its input parameter (in addition to `self` for the class method). 2. **Output**: The method should return a list of node values resulting from the level-order traversal, excluding any nodes with the value equal to `skip_val`. 3. **Performance Constraints**: The method should ideally run in O(n) time complexity, where n is the number of nodes in the tree. 4. **Corner Cases**: Handle edge cases where the binary tree is empty or all nodes have the value to be skipped. Function Signature: ```python def level_order_skip_val(self, skip_val: int) -> List[int]: ``` Example: ```python # Definition for a binary tree node. class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right # Definition for the binary tree. class BinaryTree: def __init__(self, root=None): self.root = root def level_order_skip_val(self, skip_val: int) -> List[int]: if not self.root: return [] queue = [self.root] result = [] while queue: node = queue.pop(0) if node.value != skip_val: result.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result # Example 1 root = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))) binary_tree = BinaryTree(root) assert binary_tree.level_order_skip_val(3) == [1, 2, 4, 5] # skips node with value 3 # Example 2 root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) binary_tree = BinaryTree(root) assert binary_tree.level_order_skip_val(2) == [1, 3] # skips node with value 2 and its children (4 and 5) ``` **Note**: Make sure you thoroughly test your implementation with various edge cases to ensure its robustness. This new question fits well with the existing coding questions by focusing on tree traversal and implementing a specific traversal method while maintaining consistency in the complexity and length.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def level_order_skip_val(self, skip_val: int) -> list: if not self.root: return [] queue = [self.root] result = [] while queue: node = queue.pop(0) if node.value != skip_val: result.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"# Scenario: You are developing an application that manages employee records in your organization. Each employee has a unique ID, a name, an email address, and a department to which they belong. Your task is to create a system that can add new employees, update existing employee records, and retrieve employee details. # Task: Implement a class `EmployeeDatabase` with methods to add, update, and retrieve employee records. Use a dictionary to store the employee data, where each key is the employee ID, and the value is another dictionary containing the employee\'s details. # Instructions: 1. **Class Implementation**: * Implement the `EmployeeDatabase` class. * Use a dictionary to maintain the employee records. 2. **Methods**: * `add_employee(employee_id, name, email, department)`: Adds a new employee to the database. * `update_employee(employee_id, name=None, email=None, department=None)`: Updates the details of an existing employee. * `get_employee(employee_id)`: Retrieves the details of an employee by their ID. # Constraints: * Ensure that the employee ID is unique. * Raise an appropriate error if attempting to add an employee with an existing ID. * Raise an appropriate error if attempting to update or retrieve a non-existent employee. # Expected Functions: You need to implement the `EmployeeDatabase` class with the following methods: - `add_employee(employee_id, name, email, department)` - `update_employee(employee_id, name=None, email=None, department=None)` - `get_employee(employee_id)` # Example: ```python class EmployeeDatabase: def __init__(self): self.database = {} def add_employee(self, employee_id, name, email, department): if employee_id in self.database: raise ValueError(\\"Employee ID already exists.\\") self.database[employee_id] = { \'name\': name, \'email\': email, \'department\': department } def update_employee(self, employee_id, name=None, email=None, department=None): if employee_id not in self.database: raise ValueError(\\"Employee not found.\\") if name: self.database[employee_id][\'name\'] = name if email: self.database[employee_id][\'email\'] = email if department: self.database[employee_id][\'department\'] = department def get_employee(self, employee_id): if employee_id not in self.database: raise ValueError(\\"Employee not found.\\") return self.database[employee_id] # Example usage: db = EmployeeDatabase() db.add_employee(1, \\"John Doe\\", \\"johndoe@example.com\\", \\"Engineering\\") print(db.get_employee(1)) # Output: {\'name\': \'John Doe\', \'email\': \'johndoe@example.com\', \'department\': \'Engineering\'} db.update_employee(1, email=\\"john.doe@company.com\\") print(db.get_employee(1)) # Output: {\'name\': \'John Doe\', \'email\': \'john.doe@company.com\', \'department\': \'Engineering\'} ``` # Additional Requirements: * Ensure proper error handling and informative error messages. * Provide comprehensive docstrings for each method in the class.","solution":"class EmployeeDatabase: def __init__(self): self.database = {} def add_employee(self, employee_id, name, email, department): Adds a new employee to the database. :param employee_id: Unique identifier for the employee. :param name: Name of the employee. :param email: Email address of the employee. :param department: Department to which the employee belongs. :raises ValueError: If the employee ID already exists. if employee_id in self.database: raise ValueError(\\"Employee ID already exists.\\") self.database[employee_id] = { \'name\': name, \'email\': email, \'department\': department } def update_employee(self, employee_id, name=None, email=None, department=None): Updates the details of an existing employee. :param employee_id: Unique identifier for the employee. :param name: (Optional) New name of the employee. :param email: (Optional) New email address of the employee. :param department: (Optional) New department of the employee. :raises ValueError: If the employee ID does not exist. if employee_id not in self.database: raise ValueError(\\"Employee not found.\\") if name: self.database[employee_id][\'name\'] = name if email: self.database[employee_id][\'email\'] = email if department: self.database[employee_id][\'department\'] = department def get_employee(self, employee_id): Retrieves the details of an employee by their ID. :param employee_id: Unique identifier for the employee. :return: Dictionary containing the employee details. :raises ValueError: If the employee ID does not exist. if employee_id not in self.database: raise ValueError(\\"Employee not found.\\") return self.database[employee_id]"},{"question":"# Task Implement a function to perform topological sort on a Directed Acyclic Graph (DAG). Your function should also detect if the graph contains cycles and return an appropriate message. # Function Signature ```python def topological_sort(graph: dict[int, list[int]]) -> list[int]: ``` # Input - `graph`: A dictionary where keys are node values and values are lists of neighboring nodes that the key node points to. # Output - Returns a list representing the topological order of the nodes. - If the graph contains a cycle, returns \\"Graph contains a cycle.\\" # Constraints - The graph can contain up to 100 nodes. - Nodes are represented by integers. - Node values are unique. # Requirements - Implement the function using Depth-First Search (DFS). - Detect cycles in the graph to ensure it’s a DAG. - If a cycle is detected, return the message \\"Graph contains a cycle.\\" - Output the topological order if the graph is acyclic. # Example ```python graph = { 1: [2, 3], 2: [4], 3: [4], 4: [] } print(topological_sort(graph)) # Expected Output: [1, 3, 2, 4] or [1, 2, 3, 4] cyclic_graph = { 1: [2], 2: [3], 3: [1] } print(topological_sort(cyclic_graph)) # Expected Output: \\"Graph contains a cycle\\" ``` # Notes - Ensure your implementation handles edge cases such as graphs with no nodes, graphs with a single node, and graphs with multiple valid topological orders. - Your function should efficiently manage the graph traversal and cycle detection to handle the upper limit of node constraints.","solution":"def topological_sort(graph): def dfs(node, visited, recursion_stack, sorted_order): visited[node] = True recursion_stack[node] = True if node in graph: for neighbor in graph[node]: if not visited[neighbor]: if not dfs(neighbor, visited, recursion_stack, sorted_order): return False elif recursion_stack[neighbor]: return False recursion_stack[node] = False sorted_order.append(node) return True visited = {node: False for node in graph} recursion_stack = {node: False for node in graph} sorted_order = [] for node in graph: if not visited[node]: if not dfs(node, visited, recursion_stack, sorted_order): return \\"Graph contains a cycle\\" sorted_order.reverse() return sorted_order"},{"question":"# Context As a software developer, you need to implement a specialized data structure for prioritized job scheduling. To achieve this, you\'ll utilize a Min-Heap, which allows you to efficiently retrieve and remove the smallest element. # Problem Statement Implement a **MinHeap** class that supports efficient insertion, finding the minimum element, and extracting the minimum element, ensuring that the heap property is maintained throughout. # Function Requirements 1. **Initializer**: `__init__(self) -> None` - Initialize an empty Min-Heap. 2. **Insert**: `insert(self, value: int) -> None` - Insert a value into the heap. - Time Complexity: (O(log n)) 3. **Get Minimum**: `get_min(self) -> int` - Return the smallest element in the heap without removing it. - Time Complexity: (O(1)) 4. **Extract Minimum**: `extract_min(self) -> int` - Remove and return the smallest element in the heap. - Reorganize the heap to maintain the heap property. - Time Complexity: (O(log n)) 5. **Decrease Key**: `decrease_key(self, index: int, new_value: int) -> None` - Decrease the value of a specific key to a new value that is lower. - Time Complexity: (O(log n)) 6. **Delete**: `delete(self, index: int) -> None` - Delete the element at a given index in the heap. - Time Complexity: (O(log n)) # Input Format - Inputs differ for each function and are described above where applicable. # Output Format - Outputs should match the function descriptions mentioned above. # Constraints - All values in the heap will be within the range ([-10^9, 10^9]). # Example ```python # Initialize the min-heap heap = MinHeap() # Insert values into the heap heap.insert(3) heap.insert(2) heap.insert(15) # Get the minimum value print(heap.get_min()) # Outputs 2 # Extract the minimum value print(heap.extract_min()) # Outputs 2 # Insert additional values heap.insert(5) heap.insert(4) # Decrease the key at index 1 to 1 heap.decrease_key(1, 1) # Get the new minimum value print(heap.get_min()) # Outputs 1 # Delete the element at index 0 heap.delete(0) # Get the new minimum value after deletion print(heap.get_min()) # Outputs 4 ``` By maintaining the consistency in question style, length, complexity, and topic alignment, the new question integrates seamlessly with the existing set.","solution":"class MinHeap: def __init__(self) -> None: self.heap = [] def insert(self, value: int) -> None: self.heap.append(value) self._heapify_up(len(self.heap) - 1) def get_min(self) -> int: if self.heap: return self.heap[0] raise IndexError(\\"get_min() called on empty heap\\") def extract_min(self) -> int: if not self.heap: raise IndexError(\\"extract_min() called on empty heap\\") min_value = self.heap[0] last_value = self.heap.pop() if self.heap: self.heap[0] = last_value self._heapify_down(0) return min_value def decrease_key(self, index: int, new_value: int) -> None: if index < 0 or index >= len(self.heap): raise IndexError(\\"Index out of range\\") if new_value >= self.heap[index]: raise ValueError(\\"new_value must be smaller than current value\\") self.heap[index] = new_value self._heapify_up(index) def delete(self, index: int) -> None: if index < 0 or index >= len(self.heap): raise IndexError(\\"Index out of range\\") self.decrease_key(index, float(\'-inf\')) self.extract_min() def _heapify_up(self, index: int) -> None: parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index: int) -> None: smallest = index left_child = 2 * index + 1 right_child = 2 * index + 2 if left_child < len(self.heap) and self.heap[left_child] < self.heap[smallest]: smallest = left_child if right_child < len(self.heap) and self.heap[right_child] < self.heap[smallest]: smallest = right_child if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest)"},{"question":"# Coding Assessment: Genetic Algorithm for Knapsack Problem Problem Statement You are provided with a basic implementation of a genetic algorithm to solve the 0/1 knapsack problem. Your task is to extend and improve the algorithm to handle additional constraints and optimize performance. Objectives 1. Implement a `genetic_algorithm_knapsack` function to optimize the value of items selected within the given weight limit. 2. Your implementation should also consider an additional constraint: the total volume of selected items must not exceed a specified limit. 3. Implement a `KnapsackProblem` class with appropriate methods to support the optimization process. Input - **Items**: A list of tuples, where each tuple contains the weight, value, and volume of an item `(weight, value, volume)`. - **Weight Limit**: The maximum allowable weight of the selected items. - **Volume Limit**: The maximum allowable volume of the selected items. - **Algorithm Parameters**: Population size, crossover rate, mutation rate, and number of generations. Output - A list representing the selected items, and the total value of these items. # Constraints 1. **Class Implementation**: Your `KnapsackProblem` class must have the following methods: - `__init__(self, items: List[Tuple[float, float, float]], weight_limit: float, volume_limit: float)` - `initialize_population(self, population_size: int) -> List[List[int]]` - `fitness(self, individual: List[int]) -> float` - `select_parents(self, population: List[List[int]]) -> Tuple[List[int], List[int]]` - `crossover(self, parent1: List[int], parent2: List[int]) -> List[int]` - `mutate(self, individual: List[int], mutation_rate: float) -> List[int]` 2. **Genetic Algorithm Function**: Your `genetic_algorithm_knapsack` function must have the following signature: ```python def genetic_algorithm_knapsack( problem, population_size: int = 100, crossover_rate: float = 0.8, mutation_rate: float = 0.02, generations: int = 100 ) -> Any: ``` 3. **Performance Requirement**: Your implementation should efficiently converge to an optimal or near-optimal solution within a reasonable time frame for typical inputs. # Example Usage ```python # Define items as tuples of (weight, value, volume) items = [ (2, 3, 1.5), (3, 4, 2.0), (4, 5, 3.0), (5, 8, 2.5), ] # Create knapsack problem instance knapsack_problem = KnapsackProblem(items=items, weight_limit=10, volume_limit=5) # Perform genetic algorithm optimization result = genetic_algorithm_knapsack( knapsack_problem, population_size=50, crossover_rate=0.85, mutation_rate=0.05, generations=200 ) selected_items = [item for idx, item in enumerate(items) if result[idx] == 1] total_value = sum(item[1] for item in selected_items) print(f\\"Selected items: {selected_items}\\") print(f\\"Total value: {total_value}\\") ``` Ensure your function is well-tested with various sets of items to validate its correctness and performance.","solution":"import random class KnapsackProblem: def __init__(self, items, weight_limit, volume_limit): self.items = items self.weight_limit = weight_limit self.volume_limit = volume_limit def initialize_population(self, population_size): population = [] for _ in range(population_size): individual = [random.randint(0, 1) for _ in range(len(self.items))] population.append(individual) return population def fitness(self, individual): total_weight = total_value = total_volume = 0 for selected, item in zip(individual, self.items): if selected: total_weight += item[0] total_value += item[1] total_volume += item[2] if total_weight > self.weight_limit or total_volume > self.volume_limit: return 0 return total_value def select_parents(self, population): weights = [self.fitness(individual) for individual in population] total_fitness = sum(weights) if total_fitness == 0: return random.choice(population), random.choice(population) probabilities = [weight / total_fitness for weight in weights] parent1, parent2 = random.choices(population, weights=probabilities, k=2) return parent1, parent2 def crossover(self, parent1, parent2): point = random.randint(1, len(parent1) - 1) child = parent1[:point] + parent2[point:] return child def mutate(self, individual, mutation_rate): mutated_individual = individual[:] for i in range(len(individual)): if random.random() < mutation_rate: mutated_individual[i] = 1 - mutated_individual[i] return mutated_individual def genetic_algorithm_knapsack(problem, population_size=100, crossover_rate=0.8, mutation_rate=0.02, generations=100): population = problem.initialize_population(population_size) for _ in range(generations): new_population = [] for _ in range(population_size): parent1, parent2 = problem.select_parents(population) child = problem.crossover(parent1, parent2) if random.random() < crossover_rate else parent1 child = problem.mutate(child, mutation_rate) new_population.append(child) population = new_population[:] best_individual = max(population, key=problem.fitness) return best_individual"},{"question":"Binary Tree Diameter Determination In this task, you are asked to find the diameter of a binary tree. The diameter of a binary tree is defined as the length of the longest path between any two nodes in the tree. This path may or may not pass through the root. **Function Signature**: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameter_of_binary_tree(root: TreeNode) -> int: pass ``` **Input**: - `root`: The root node of the binary tree, constructed using `TreeNode`, which can have the following attributes: - `val` (integer): The value of the node. - `left` (TreeNode): Reference to the left child node. - `right` (TreeNode): Reference to the right child node. **Output**: - An integer representing the diameter of the binary tree. **Constraints**: - The number of nodes in the tree is in the range [1, 10^4]. - The value of each node is in the range [-100, 100]. **Example**: ```python >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> diameter_of_binary_tree(root) 3 >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> diameter_of_binary_tree(root) 2 >>> root = TreeNode(1) >>> diameter_of_binary_tree(root) 0 ``` **Explanation**: 1. For the first example: - The longest path is [4, 2, 1, 3] or [5, 2, 1, 3], both paths have length 3. 2. For the second example: - The longest path is [1, 2, 3], with length 2. 3. For the third example: - The tree has only one node with no path, so the diameter is 0. **Performance Consideration**: - An efficient solution should calculate the diameter in linear time `O(n)` with respect to the number of nodes. - Utilize a depth-first search (DFS) strategy to find the longest path through each node. **Real-world Scenarios**: - Used to determine efficient routing in network systems. - Assists in finding the most distant connected nodes in hierarchical data structures or filesystem trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameter_of_binary_tree(root: TreeNode) -> int: def depth(node): nonlocal diameter if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) diameter = max(diameter, left_depth + right_depth) return max(left_depth, right_depth) + 1 diameter = 0 depth(root) return diameter"},{"question":"# Coding Challenge: Unique Characters in String Array You are developing a text analysis tool and need to determine if each word in a list is composed of unique characters. This function is critical for identifying distinct patterns in text data, which could be useful in a variety of language processing tasks. Function Specification **Function 1**: `unique_chars_in_words(words: list[str]) -> list[bool]` Your task is to complete the implementation of a function that returns a list of boolean values indicating whether each word in the input list contains only unique characters (without repetitions). - **Input**: - `words` (list of strings): The list of words to be analyzed. - **Output**: - A list of boolean values: - Each element corresponds to whether the respective word has all unique characters (True) or not (False). - **Constraints**: - `words` will contain between 1 and 10^4 words. - Each word consists of alphabetic characters only, and the length of each word will be between 1 and 100. - **Performance**: - Your solution must operate efficiently even with the maximum input sizes. Example: ```python assert unique_chars_in_words([\'hello\', \'world\', \'python\', \'abcd\', \'aa\']) == [False, True, True, True, False] assert unique_chars_in_words([\'apple\', \'banana\', \'grape\', \'kiwi\', \'plum\']) == [False, False, True, True, True] assert unique_chars_in_words([\'abracadabra\', \'wizard\', \'magic\', \'spell\', \'wow\']) == [False, True, True, False, False] ``` Implementation Requirements: 1. Ensure that the function runs efficiently, considering both time and space complexity. 2. Use appropriate data structures to achieve the desired performance. Start analyzing your text data more effectively with this function that checks for unique characters in each word. Good luck!","solution":"def unique_chars_in_words(words): Returns a list of boolean values indicating whether each word in the input list contains only unique characters. Parameters: words (list of str): List of words to analyze for unique characters Returns: list of bool: List of boolean values where each value corresponds to whether the respective word has all unique characters. result = [] for word in words: if len(word) == len(set(word)): result.append(True) else: result.append(False) return result"},{"question":"# Coding Question: Efficient Pathfinding Algorithm **Context**: You are working on a navigation system for a fleet of delivery drones. To ensure timely deliveries, you need to determine the shortest path between distribution points efficiently. A common challenge is dealing with varying weights between different paths in a city represented as a weighted graph. **Task**: Implement the **Dijkstra\'s Algorithm** to find the shortest path from a starting node to a target node in a weighted graph. **Input**: * An integer `n` representing the number of nodes. * A list of tuples `edges` where each tuple `(u, v, w)` represents an edge from node `u` to node `v` with weight `w`. * Two integers `start` and `end` representing the start node and the end node. **Output**: * An integer representing the total weight of the shortest path from the start node to the end node. If there\'s no path, return -1. **Constraints**: * All nodes are labeled from `0` to `n-1`. * The edges are guaranteed to be non-negative. * Ensure the implementation is efficient with a time complexity of O(E log V), where E is the number of edges and V is the number of nodes. * Follow good engineering practices and write clean, readable code. **Specification**: Function Signature: `def dijkstra(n: int, edges: list[tuple[int, int, int]], start: int, end: int) -> int:` **Example**: ```python >>> dijkstra(5, [(0, 1, 2), (0, 2, 4), (1, 2, 1), (1, 3, 7), (2, 4, 3), (3, 4, 1)], 0, 4) 6 >>> dijkstra(3, [(0, 1, 1), (1, 2, 2), (0, 2, 4)], 0, 2) 3 >>> dijkstra(4, [(0, 1, 1), (2, 3, 1)], 0, 3) -1 >>> dijkstra(6, [(0, 1, 5), (1, 2, 2), (0, 3, 9), (3, 4, 7), (4, 5, 1), (2, 5, 4)], 0, 5) 11 >>> dijkstra(2, [(0, 1, 1)], 0, 1) 1 ```","solution":"import heapq from collections import defaultdict def dijkstra(n, edges, start, end): Implements Dijkstra\'s algorithm to find the shortest path from start to end in a weighted graph. Parameters: n (int): Number of nodes in the graph. edges (list[tuple[int, int, int]]): List of edges represented as (u, v, w) tuples, where u is the start node, v is the end node, and w is the weight of the edge. start (int): The start node. end (int): The end node. Returns: int: The total weight of the shortest path from start to end. If there\'s no path, returns -1. graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) min_heap = [(0, start)] distances = {i: float(\'inf\') for i in range(n)} distances[start] = 0 while min_heap: current_distance, current_node = heapq.heappop(min_heap) if current_node == end: return current_distance if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return -1 if distances[end] == float(\'inf\') else distances[end]"},{"question":"# Reverse Nodes in k-Group Given a singly linked list, write a `reverse_k_group` method to reverse the nodes of the list `k` at a time and return its modified list. Nodes within each group of `k` should be reversed, while any remaining nodes with fewer than `k` should remain as is, in their original order. # Guidelines 1. **Input**: The linked list is provided through multiple insert operations. By default, insertions can happen either at the head or the tail. 2. **Output**: A modified linked list where the nodes are reversed in groups of `k`. 3. **Constraints**: * Do not use any auxiliary data structures like arrays or additional lists. * You can use only the given linked list to perform the operations. * Ensure the original order outside of the reversed groups is maintained. # Details **Function Signature**: ```python def reverse_k_group(self, k: int) -> None: ``` **Input Format**: - The initial linked list provided through multiple calls to insert methods (either `insert_tail` or `insert_head`). - An integer `k` representing the group size for reversing. **Output Format**: - The method modifies the linked list directly and when printed, it should appear with nodes reversed in groups of `k`. # Example **Input**: ``` LinkedList: 1 -> 2 -> 3 -> 4 -> 5, k=3 ``` **Output**: ``` Reversed LinkedList: 3 -> 2 -> 1 -> 4 -> 5 ``` **Explanation**: The first group of 3 nodes (1, 2, 3) is reversed to become (3, 2, 1), while the remaining nodes (4, 5) are left unchanged because they do not form a complete group of 3. ```python # Define Node and LinkedList Class as provided above def reverse_k_group(self, k: int): # Implement your solution here # Add the new function definition to LinkedList class as a method and test it using given tests. ``` # Notes * Consider edge cases such as an empty list, a list with one element, a list with fewer nodes than `k`, and `k` greater than the list length. * Aim for a time complexity of O(n) for this rearrangement where n is the number of nodes in the linked list.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def insert_tail(self, value): new_node = Node(value) if not self.head: self.head = new_node return current = self.head while current.next: current = current.next current.next = new_node def reverse_k_group(self, k: int): def reverse(first, last): prev = last while first != last: temp = first.next first.next = prev prev = first first = temp return prev dummy = Node(0) dummy.next = self.head group_prev = dummy while True: kth = group_prev for _ in range(k): kth = kth.next if not kth: self.head = dummy.next return group_next = kth.next prev, current = kth.next, group_prev.next group_prev.next = reverse(current, group_next) group_prev = current def to_list(self): result = [] current = self.head while current: result.append(current.value) current = current.next return result"},{"question":"Coding Assessment Question # Objective Write a function that handles multiple input sources to build a cohesive dataset. Your task also includes implementing data cleaning procedures to ensure dataset consistency and preparation for analytical purposes. # Scenario Imagine you are part of a data science team at a retail company. You need to create a unified sales dataset by merging multiple CSV files containing monthly sales data. Different months have slightly different schema, and certain columns may be missing in some files. Your function should standardize the merged dataset. # Task Implement the function `merge_sales_data` with the following requirements: 1. **Input**: * A list of CSV file paths, each containing sales data for different months. 2. **Output**: * A Pandas DataFrame with standardized columns: Date, Product ID, Product Name, Sales Quantity, Sales Amount, Store Location. 3. **Data Cleaning Constraints**: * If any column is missing in a monthly file, fill the missing values with \'0\' for numerical columns and \'Unknown\' for categorical columns. * Ensure dates are in consistent format (YYYY-MM-DD) and clean any inconsistencies. * Remove duplicate records, if any. * Examine and standardize inconsistent column names (e.g., \\"productid\\", \\"Product_ID\\" should both be \\"Product ID\\"). 4. **Performance Requirements**: * Ensure efficient handling of potentially large datasets. * Document any assumptions or decisions made during the process. # Constraints: * Each CSV file may have up to 50,000 records. * The standard columns should all be included in the final DataFrame, even if missing in the input files. * Use `pandas` for data management and processing. * Must handle exceptions related to file reading and data processing gracefully. # Function Signature ```python def merge_sales_data(file_paths: List[str]) -> DataFrame: ``` # Example ```python file_paths = [\\"january_sales.csv\\", \\"february_sales.csv\\", \\"march_sales.csv\\"] df = merge_sales_data(file_paths) print(df.head()) ``` # Additional Task * Write a test script that validates your function with at least three different sets of CSV files, each containing different variations in schema and data inconsistencies to ensure robust handling and merging of the datasets.","solution":"import pandas as pd from typing import List def merge_sales_data(file_paths: List[str]) -> pd.DataFrame: # Standard column names columns = [\'Date\', \'Product ID\', \'Product Name\', \'Sales Quantity\', \'Sales Amount\', \'Store Location\'] # Container for dataframes dataframes = [] for file_path in file_paths: try: df = pd.read_csv(file_path) # Standardize column names df.columns = df.columns.str.lower().str.replace(\' \', \'_\').str.replace(\'-\', \'_\') df = df.rename(columns={ \'date\': \'Date\', \'productid\': \'Product ID\', \'product_id\': \'Product ID\', \'productname\': \'Product Name\', \'product_name\': \'Product Name\', \'salesquantity\': \'Sales Quantity\', \'sales_quantity\': \'Sales Quantity\', \'salesamount\': \'Sales Amount\', \'sales_amount\': \'Sales Amount\', \'storelocation\': \'Store Location\', \'store_location\': \'Store Location\', }) # Add missing columns with default values for column in columns: if column not in df: if \'Sales\' in column: df[column] = 0 else: df[column] = \'Unknown\' # Ensure correct column order df = df[columns] # Convert Date column to consistent format df[\'Date\'] = pd.to_datetime(df[\'Date\'], errors=\'coerce\').dt.strftime(\'%Y-%m-%d\') dataframes.append(df) except Exception as e: print(f\\"Error reading {file_path}: {e}\\") # Concatenate all dataframes merged_df = pd.concat(dataframes, ignore_index=True) # Drop duplicates merged_df.drop_duplicates(inplace=True) return merged_df"},{"question":"# Coding Assessment Question You are developing software for an online retail platform that offers various seasonal discounts. A part of your task is to calculate the final price of items after applying one or more discounts. Discounts can be either percentage-based or fixed amount reductions. The order of applying discounts can affect the final price. Create a function `final_price(initial_price: float, discounts: List[Union[Dict[str, float], float]]) -> float` that computes the final price of an item after applying the given discounts in sequence. * **Input/Output Formats**: * **Input**: * `initial_price` (float): The original price of the item, must be greater than 0. * `discounts` (List[Union[Dict[str, float], float]]): A list with multiple discounts. Each discount can either be a: * Percentage-based discount represented as a dictionary with a single key-value pair `{\\"percent\\": float}`, where the value must be between 0 and 100. * Fixed discount represented directly as a float, where the value must be non-negative. * **Output**: * (float): The final price after applying all the discounts in the order they are given. * **Constraints and Limitations**: * The function should raise exceptions with meaningful messages if the inputs are invalid: * If `initial_price` is less than or equal to 0, raise Exception with the message \\"Initial price must be > 0\\". * If a percentage-based discount value is not between 0 and 100, raise Exception with the message \\"Percentage discount must be between 0 and 100\\". * If a fixed discount value is negative, raise Exception with the message \\"Fixed discount must be non-negative\\". * Always ensure the final price is not less than 0. Return 0 if the final calculation results in a negative price. * **Performance Requirements**: * Ensure that the function runs efficiently with a time complexity of O(n) and a space complexity of O(1), where n is the number of discounts. * **Example**: ```python def final_price(initial_price: float, discounts: List[Union[Dict[str, float], float]]) -> float: # your implementation here # Test Cases print(final_price(100.0, [{\\"percent\\": 10}, 5.0])) # Expected output: 85.0 print(final_price(200.0, [50.0, {\\"percent\\": 20}])) # Expected output: 120.0 print(final_price(100.0, [{\\"percent\\": 50}, {\\"percent\\": 50}])) # Expected output: 25.0 try: final_price(-100.0, [{\\"percent\\": 10}, 5.0]) # Expected output: Exception(\\"Initial price must be > 0\\") except Exception as e: print(e) try: final_price(100.0, [-10.0]) # Expected output: Exception(\\"Fixed discount must be non-negative\\") except Exception as e: print(e) try: final_price(100.0, [{\\"percent\\": 150}]) # Expected output: Exception(\\"Percentage discount must be between 0 and 100\\") except Exception as e: print(e) ```","solution":"from typing import List, Union, Dict def final_price(initial_price: float, discounts: List[Union[Dict[str, float], float]]) -> float: Calculates the final price after applying a series of discounts. Parameters: initial_price (float): The original price of the item. discounts (List[Union[Dict[str, float], float]]): A list with multiple discounts. Returns: float: The final price after applying all the discounts. if initial_price <= 0: raise Exception(\\"Initial price must be > 0\\") final_price = initial_price for discount in discounts: if isinstance(discount, dict): if \'percent\' in discount: percent_value = discount[\'percent\'] if percent_value < 0 or percent_value > 100: raise Exception(\\"Percentage discount must be between 0 and 100\\") final_price -= final_price * (percent_value / 100) elif isinstance(discount, float): if discount < 0: raise Exception(\\"Fixed discount must be non-negative\\") final_price -= discount if final_price < 0: return 0.0 return round(final_price, 2)"},{"question":"# Problem Description You are working with a data processing system that processes numerical sensor data coming from various sensors in real time. Each sensor sends an array of measurements, and your task is to implement some basic statistical analysis on the sensor data. Objective Write two functions `mean` and `standard_deviation` that calculate the mean and standard deviation of an array of sensor measurements, respectively. Function Signatures * `mean(measurements: List[float]) -> float` * `standard_deviation(measurements: List[float]) -> float` # Function Definitions 1. **mean** This function calculates the mean (average) of a list of measurements using the formula: [ text{Mean} = frac{1}{n} sum_{i=1}^n x_i ] where `n` is the number of measurements, and `x_i` is each individual measurement. 2. **standard_deviation** This function calculates the standard deviation of a list of measurements using the formula: [ text{Standard Deviation} = sqrt{frac{1}{n} sum_{i=1}^n (x_i - text{Mean})^2} ] First, compute the mean of the measurements, and then use it to calculate the standard deviation. # Input * `measurements` (List[float]): A list of numerical sensor measurements (the list can be empty). # Output * Returns the respective computed statistic as a float. * For an empty list of measurements, the mean and standard deviation should both return 0. # Constraints * The input list can contain any valid floating-point numbers, including negative values. * Handle edge cases such as an empty list appropriately. # Examples ```python # Example for mean print(mean([1, 2, 3, 4, 5])) # Expected Output: 3.0 print(mean([])) # Expected Output: 0.0 print(mean([10, -10, 10, -10]))# Expected Output: 0.0 # Example for standard_deviation print(standard_deviation([1, 2, 3, 4, 5])) # Expected Output: 1.4142135623730951 print(standard_deviation([])) # Expected Output: 0.0 print(standard_deviation([10, -10, 10, -10]))# Expected Output: 10.0 ``` # Instructions 1. Ensure efficient and correct handling of edge cases. 2. Consider using built-in functions for calculations where applicable to ensure accuracy. 3. Make sure to test your code thoroughly using the provided examples and additional test cases if necessary.","solution":"from typing import List import math def mean(measurements: List[float]) -> float: Calculate the mean (average) of a list of measurements. if not measurements: return 0.0 return sum(measurements) / len(measurements) def standard_deviation(measurements: List[float]) -> float: Calculate the standard deviation of a list of measurements. if not measurements: return 0.0 m = mean(measurements) variance = sum((x - m) ** 2 for x in measurements) / len(measurements) return math.sqrt(variance)"},{"question":"# Question You are tasked to develop a function that calculates the shortest path between two users in a social network. The social network is represented as an unweighted graph, where each user is a node and each connection between users is an edge. The objective is to determine the minimum number of connections required to link the two given users. # Function Specification **Function Signature** ```python def shortest_path(network: Dict[str, List[str]], user1: str, user2: str) -> int: pass ``` **Input** - `network` (dict): A dictionary that represents the social network, where keys are user names (strings) and values are lists of names (strings) representing direct connections (friends) of the key user. - `user1` (string): The name of the starting user. - `user2` (string): The name of the target user. **Output** - Returns an integer representing the shortest path (number of connections) between `user1` and `user2`. If no such path exists, return `-1`. **Constraints** - Each user name is a string of lowercase alphabetic characters. - There can be up to 10,000 users in the network. - The network graph is undirected. # Example ```python network = { \\"alice\\": [\\"bob\\", \\"clare\\"], \\"bob\\": [\\"alice\\", \\"clare\\", \\"dave\\"], \\"clare\\": [\\"alice\\", \\"bob\\", \\"dave\\"], \\"dave\\": [\\"bob\\", \\"clare\\", \\"eli\\"], \\"eli\\": [\\"dave\\"] } print(shortest_path(network, \\"alice\\", \\"eli\\")) # Output: 3 print(shortest_path(network, \\"alice\\", \\"frank\\")) # Output: -1 ``` **Performance Requirements** - The function should efficiently handle a sparse graph with up to 10,000 users using appropriate graph traversal techniques (e.g., Breadth-First Search). # Instructions 1. Familiarize yourself with basic graph theory concepts, such as shortest path and graph traversal algorithms. 2. Implement the `shortest_path` function to use a Breadth-First Search algorithm for calculating the minimum number of connections between two users. 3. Ensure the function gracefully handles cases where one or both users are not present in the network, or where no path exists between the specified users. 4. Test the function with various networks and user pairs to validate its correctness and performance.","solution":"from collections import deque from typing import List, Dict def shortest_path(network: Dict[str, List[str]], user1: str, user2: str) -> int: Calculates the shortest path (number of connections) between user1 and user2. Returns -1 if no path exists. if user1 == user2: return 0 # Check if both users are in the network if user1 not in network or user2 not in network: return -1 # Initialize BFS queue = deque([(user1, 0)]) # (current_user, current_distance) visited = set() while queue: current_user, current_distance = queue.popleft() # mark the current user as visited if current_user in visited: continue visited.add(current_user) # Check all neighbors for neighbor in network.get(current_user, []): if neighbor == user2: return current_distance + 1 if neighbor not in visited: queue.append((neighbor, current_distance + 1)) return -1 # No path found"},{"question":"# Trie - Auto-Complete System Background: A Trie (prefix tree) is a data structure used to efficiently store and retrieve keys in a dataset of strings. This problem extends the Trie data structure to implement an auto-complete feature useful for applications like search engines. Task: 1. **Construct the Trie**: Implement code to construct a Trie from a given list of words. 2. **Implement Auto-Complete**: Write a function to return all the words in the Trie that start with a given prefix. Function Signatures: 1. `build_trie(words: list[str]) -> TrieNode` * **Input**: * `words` - A list of words represented as strings. * **Output**: * The root node of the constructed Trie. 2. `autocomplete(prefix: str, root: TrieNode) -> list[str]` * **Input**: * `prefix` - The prefix for which we need to find matching words. * `root` - The root node of the Trie. * **Output**: * A list of words from the Trie that start with the given prefix. Constraints: * The number of words `n` is large (e.g., n < 10^6). * Each word\'s length is reasonable (e.g., length ≤ 100). * Prefix length ≤ 100. Example: ```python # Define the TrieNode class as given above. # Example words and prefix words = [ \\"apple\\", \\"app\\", \\"application\\", \\"bat\\", \\"ball\\", \\"batman\\", \\"ape\\" ] prefix = \\"app\\" trie_root = build_trie(words) autocomplete_words = autocomplete(prefix, trie_root) print(autocomplete_words) # Output should be words in \'words\' that start with \'prefix\': [\\"apple\\", \\"app\\", \\"application\\"] ``` Notes: * You are required to implement the `build_trie` and `autocomplete` functions. * Ensure consideration of edge cases such as prefix longer than any words or no words with the given prefix. * Handle duplicates appropriately (e.g., storing each distinct word only once). # Trie Node Class Definition: ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False def build_trie(words): root = TrieNode() for word in words: current = root for letter in word: if letter not in current.children: current.children[letter] = TrieNode() current = current.children[letter] current.is_end_of_word = True return root def autocomplete(prefix, root): current = root for letter in prefix: if letter not in current.children: return [] current = current.children[letter] result = [] search_helper(current, prefix, result) return result def search_helper(node, prefix, result): if node.is_end_of_word: result.append(prefix) for letter, next_node in node.children.items(): search_helper(next_node, prefix + letter, result) ``` By implementing the `build_trie` and `autocomplete` functions as specified, you will create a useful auto-complete feature within a Trie data structure. This feature is commonly used in search engines, text editors, and other applications requiring efficient retrieval of words with a common prefix.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False def build_trie(words): root = TrieNode() for word in words: current = root for letter in word: if letter not in current.children: current.children[letter] = TrieNode() current = current.children[letter] current.is_end_of_word = True return root def autocomplete(prefix, root): current = root for letter in prefix: if letter not in current.children: return [] current = current.children[letter] result = [] search_helper(current, prefix, result) return result def search_helper(node, prefix, result): if node.is_end_of_word: result.append(prefix) for letter, next_node in node.children.items(): search_helper(next_node, prefix + letter, result)"},{"question":"# Graph Traversal: Shortest Path in Weighted Directed Graph Write a function to find the shortest path in a weighted directed graph using Dijkstra\'s algorithm. Your task is to implement the algorithm and provide a test harness to verify the functionality. Problem Statement: 1. **Objective**: Implement a function to find the shortest path from a source node to a target node in a weighted directed graph using Dijkstra\'s algorithm. 2. **Function Definition**: ```python def dijkstra(graph: Dict[str, Dict[str, int]], start: str, end: str) -> Tuple[List[str], int]: ``` 3. **Inputs**: - `graph` : A dictionary representing the weighted directed graph, where keys are node identifiers and values are dictionaries of adjacent nodes with edge weights. - `start` : A string representing the start node. - `end` : A string representing the target node. 4. **Outputs**: - A tuple containing: - A list of strings representing the nodes in the shortest path from start to end. - An integer representing the total weight of the shortest path. 5. **Constraints**: - The graph is represented as an adjacency list. - The edge weights are non-negative integers. - The function must handle cases where no path exists between the start and end nodes. - Ensure that your function handles edge cases and potential errors robustly. # Example Usage: ```python graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'C\': 2, \'D\': 5}, \'C\': {\'D\': 1}, \'D\': {} } # Calculate Shortest Path path, distance = dijkstra(graph, \'A\', \'D\') print(path, distance) # Expected Output: [\'A\', \'B\', \'C\', \'D\'] 4 ``` # Guidelines: 1. **Implement the `dijkstra` function** with the following steps: - Initialize a priority queue with the start node. - Maintain a dictionary to keep track of the shortest known distance to each node from the start node. - Maintain a dictionary to reconstruct the shortest path. - While the priority queue is not empty, extract the node with the minimum distance. - For the current node, update the distances to its adjacent nodes if a shorter path is found. - Continue the process until reaching the target node or the queue is empty. - Reconstruct the shortest path from the start node to the target node using the path dictionary. 2. **Test your implementation** with varying inputs to ensure correctness and robustness. Good Luck!","solution":"import heapq from typing import Dict, List, Tuple def dijkstra(graph: Dict[str, Dict[str, int]], start: str, end: str) -> Tuple[List[str], int]: Implements Dijkstra\'s algorithm to find the shortest path in a weighted directed graph. priority_queue = [(0, start)] shortest_distances = {node: float(\'inf\') for node in graph} shortest_distances[start] = 0 previous_nodes = {node: None for node in graph} while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_node == end: break if current_distance > shortest_distances[current_node]: continue for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance < shortest_distances[neighbor]: shortest_distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) path = [] current = end if shortest_distances[end] == float(\'inf\'): return path, float(\'inf\') # No path found while current: path.insert(0, current) current = previous_nodes[current] return path, shortest_distances[end]"},{"question":"# Balanced Binary Search Tree Construction and Searching You are tasked with creating a balanced Binary Search Tree (BST) structure for efficient insertion, deletion, and search operations. Implement the core functionalities from scratch. Your task is to: 1. **Construct the BST** from a given set of nodes ensuring it remains balanced. 2. **Search for a specific node value** within this BST. 3. **Delete a specific node value** from the BST and maintain its balanced property. # Function Definitions Implement the following functions: 1. **`insert_node`**: Inserts a node into the BST while maintaining balance. ```python def insert_node(root: Optional[Dict], value: int) -> Dict: Inserts a node with the given value into the BST, and returns the new root. :param root: The root of the BST, represented as a dictionary. :param value: The value to insert. :return: The new root of the BST after insertion and balancing. pass ``` 2. **`search_node`**: Searches for a node with the given value in the BST. ```python def search_node(root: Optional[Dict], value: int) -> bool: Searches for a node with the given value in the BST. :param root: The root of the BST, represented as a dictionary. :param value: The value to search for. :return: True if the value is found, otherwise False. pass ``` 3. **`delete_node`**: Deletes a node with the given value from the BST while maintaining balance. ```python def delete_node(root: Optional[Dict], value: int) -> Optional[Dict]: Deletes a node with the given value from the BST, and returns the new root. :param root: The root of the BST, represented as a dictionary. :param value: The value to delete. :return: The new root of the BST after deletion and balancing. pass ``` # Requirements 1. **Performance**: * Ensure the insertion and deletion time complexity is **O(log n)** on average. * Ensure the search time complexity is **O(log n)** on average. 2. **Edge Cases**: * Handle cases where the BST is empty. * Test with duplicate values. * Test with large varied sets of input numbers. # Input and Output * **Input**: A list of values to construct the BST, insertions, deletions, and a value to search. * **Output**: The updated BST structure, search results, and balanced property checks. # Example ```python # Example values to build the BST values = [10, 20, 5, 6, 15, 30, 25] # Build BST and insert values root = None for val in values: root = insert_node(root, val) # Search for a value search_result = search_node(root, 15) print(search_result) # Expected Output: True # Delete a value root = delete_node(root, 6) # Search for the deleted value search_result = search_node(root, 6) print(search_result) # Expected Output: False ``` *Expected Output*: ```python True # The value 15 is present in the BST False # The value 6 has been deleted and is no longer present in the BST ```","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 def get_height(node): if not node: return 0 return node.height def update_height(node): if node: node.height = 1 + max(get_height(node.left), get_height(node.right)) def get_balance(node): if not node: return 0 return get_height(node.left) - get_height(node.right) def rotate_right(y): x = y.left T2 = x.right x.right = y y.left = T2 update_height(y) update_height(x) return x def rotate_left(x): y = x.right T2 = y.left y.left = x x.right = T2 update_height(x) update_height(y) return y def balance_tree(node): update_height(node) balance = get_balance(node) if balance > 1: if get_balance(node.left) < 0: node.left = rotate_left(node.left) return rotate_right(node) if balance < -1: if get_balance(node.right) > 0: node.right = rotate_right(node.right) return rotate_left(node) return node def insert_node(root, key): if not root: return TreeNode(key) if key < root.key: root.left = insert_node(root.left, key) else: root.right = insert_node(root.right, key) return balance_tree(root) def search_node(root, key): if not root: return False if key == root.key: return True elif key < root.key: return search_node(root.left, key) else: return search_node(root.right, key) def get_min_value_node(root): if root is None or root.left is None: return root return get_min_value_node(root.left) def delete_node(root, key): if not root: return root if key < root.key: root.left = delete_node(root.left, key) elif key > root.key: root.right = delete_node(root.right, key) else: if root.left is None: temp = root.right root = None return temp elif root.right is None: temp = root.left root = None return temp temp = get_min_value_node(root.right) root.key = temp.key root.right = delete_node(root.right, temp.key) return balance_tree(root)"},{"question":"# **Coding Assessment Question** **Combinatorial Algorithm Implementation** In this task, you are required to implement a class `Combinatorics` that provides methods to handle permutations and combinations. This will test your understanding of combinatorial mathematics and your ability to implement algorithms in Python. **Task** 1. **Permutations Method**: Implement a method `permutations` that generates all possible permutations of a given list of elements. ```python def permutations(self, elements: list) -> list: Return a list of all possible permutations of the given list \'elements\'. >>> Combinatorics().permutations([1, 2]) [[1, 2], [2, 1]] >>> Combinatorics().permutations([1, 2, 3]) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> Combinatorics().permutations([]) [[]] # Implement the method here ``` 2. **Combinations Method**: Implement a method `combinations` that generates all possible combinations of a given list of elements for a specified length. ```python def combinations(self, elements: list, length: int) -> list: Return a list of all possible combinations of \'length\' elements from the given list \'elements\'. >>> Combinatorics().combinations([1, 2, 3], 2) [[1, 2], [1, 3], [2, 3]] >>> Combinatorics().combinations([1, 2, 3, 4], 3) [[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]] >>> Combinatorics().combinations([1, 2], 3) [] # Implement the method here ``` 3. **Factorial Method**: Implement a method `factorial` that computes the factorial of a non-negative integer. ```python def factorial(self, n: int) -> int: Return the factorial of the non-negative integer n. >>> Combinatorics().factorial(5) 120 >>> Combinatorics().factorial(0) 1 >>> Combinatorics().factorial(3) 6 # Implement the method here ``` **Function Signature** ```python class Combinatorics: # Existing or placeholder methods def permutations(self, elements: list) -> list: # Implement here pass def combinations(self, elements: list, length: int) -> list: # Implement here pass def factorial(self, n: int) -> int: # Implement here pass ``` **Input and Output Formats** * The `permutations` method should return a list of lists consisting of all possible permutations of the input list. * The `combinations` method should return a list of lists consisting of all possible combinations of the specified length from the input list. * The `factorial` method should return an integer representing the factorial of the input number. **Constraints/Limitations** * The `elements` list can have zero or more elements and can contain integers or other comparable elements. * The length parameter in the `combinations` method must be a non-negative integer. * The integer `n` in the `factorial` method must be a non-negative integer. * Ensure you handle edge cases and invalid inputs appropriately, such as length values greater than the size of the element list for combinations, and non-integer values for the factorial function.","solution":"import itertools class Combinatorics: def permutations(self, elements: list) -> list: Return a list of all possible permutations of the given list \'elements\'. return [list(p) for p in itertools.permutations(elements)] def combinations(self, elements: list, length: int) -> list: Return a list of all possible combinations of \'length\' elements from the given list \'elements\'. return [list(c) for c in itertools.combinations(elements, length)] def factorial(self, n: int) -> int: Return the factorial of the non-negative integer n. if n < 0: raise ValueError(\\"n must be a non-negative integer\\") if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"# Problem Statement Create a function that takes two positive integers `start` and `end` and returns a list of prime numbers in the given range `[start, end]` (inclusive). The function should employ the Sieve of Eratosthenes algorithm for efficiency. # Function Signature ```python def primes_in_range(start: int, end: int) -> list: ``` # Input - Two integers `start` and `end`, where (1 leq start leq end leq 10^6). # Output - Return a list of integers representing the prime numbers within the range `[start, end]`. # Constraints - (1 leq start leq end leq 10^6) # Example 1. Example 1: - Input: `start = 10`, `end = 20` - Output: `[11, 13, 17, 19]` - Explanation: The prime numbers between 10 and 20 are 11, 13, 17, and 19. 2. Example 2: - Input: `start = 1`, `end = 10` - Output: `[2, 3, 5, 7]` - Explanation: The prime numbers between 1 and 10 are 2, 3, 5, and 7. 3. Example 3: - Input: `start = 50`, `end = 60` - Output: `[53, 59]` - Explanation: The prime numbers between 50 and 60 are 53 and 59. # Additional Notes - The Sieve of Eratosthenes is an ancient algorithm used to find all prime numbers up to any given limit and is highly efficient for this task. - Ensure the function handles edge cases, such as the `start` and `end` values being equal, and large ranges approaching the upper limit. - Optimize for performance, as ranges can span up to one million. # Testing Utilize provided test cases and construct additional edge cases to verify the correctness of your implementation. ```python def primes_in_range(start: int, end: int) -> list: if start < 1 or end < start or end > 10**6: raise ValueError(\\"Invalid inputnstart and end must be within 1 to 10^6, and start must be less than or equal to end.\\") def sieve(n): is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if (is_prime[p] == True): for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 prime_list = [p for p in range(2, n + 1) if is_prime[p]] return prime_list max_limit = end prime_list = sieve(max_limit) return [prime for prime in prime_list if prime >= start] if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"def primes_in_range(start: int, end: int) -> list: Returns a list of prime numbers in the range [start, end] inclusive. The implementation uses the Sieve of Eratosthenes for efficiency. if start < 1 or end < start or end > 10**6: raise ValueError(\\"Invalid inputnstart and end must be within 1 to 10^6, and start must be less than or equal to end.\\") def sieve(n): is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if is_prime[p] == True: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 return [p for p in range(2, n + 1) if is_prime[p]] all_primes = sieve(end) return [prime for prime in all_primes if prime >= start]"},{"question":"Problem Statement You are tasked with implementing a library management system in which you will maintain records of books in a library and provide functionalities to add, issue, return, and search for books. Each book has a unique identifier (Book ID) and a title. # Requirements 1. **Initialization:** - Initialize the library with an empty collection of books. 2. **Operations:** - **Add Book (add_book(book_id, title))**: Add a new book with a unique ID and title to the library collection. Assume that the Book ID is unique. - **Issue Book (issue_book(book_id))**: Mark the book with the given Book ID as issued. If the book does not exist or is already issued, return \\"Book not available\\". - **Return Book (return_book(book_id))**: Mark the book with the given Book ID as returned. If the book does not exist or is not issued, return \\"Invalid operation\\". - **Search Book (search_book(title))**: Search for a book by its title. If multiple books have the same title, return the list of their Book IDs. If no book is found, return an empty list. # Input Format - A sequence of operations and their values. # Output Format - For an **issue_book** or **return_book** operation, return the corresponding status message as specified above. - For a **search_book** operation, return a list of Book IDs that match the title. - For **add_book** operation, no output is required. # Constraints - Each operation is provided in the form of a list of tuples, where each tuple contains the operation name and necessary parameters. - Book IDs are unique integers. - Book titles are case-sensitive strings. - Operations will be valid (e.g., book IDs and titles will be non-empty). # Example ```python # Sequence of operations operations = [ (\\"add_book\\", 101, \\"The Great Gatsby\\"), (\\"add_book\\", 102, \\"1984\\"), (\\"add_book\\", 103, \\"To Kill a Mockingbird\\"), (\\"issue_book\\", 101), # \\"Book issued\\" (\\"issue_book\\", 101), # \\"Book not available\\" (\\"return_book\\", 101), # \\"Book returned\\" (\\"return_book\\", 101), # \\"Invalid operation\\" (\\"search_book\\", \\"1984\\"), # [102] (\\"search_book\\", \\"The Great Gatsby\\"), # [101] (\\"search_book\\", \\"Unknown Title\\"), # [] ] library = Library() for operation in operations: if operation[0] == \\"add_book\\": library.add_book(operation[1], operation[2]) elif operation[0] == \\"issue_book\\": print(library.issue_book(operation[1])) elif operation[0] == \\"return_book\\": print(library.return_book(operation[1])) elif operation[0] == \\"search_book\\": print(library.search_book(operation[1])) ``` # Boilerplate Code: Implement the required methods in the provided class: ```python class Library: def __init__(self) -> None: self.books = {} # A dictionary to store book ID and title self.issued_books = set() # A set to store issued book IDs def add_book(self, book_id: int, title: str) -> None: # Add a new book to the library ... def issue_book(self, book_id: int) -> str: # Issue a book to a user ... def return_book(self, book_id: int) -> str: # Return a book to the library ... def search_book(self, title: str) -> list: # Search for a book by its title ... ```","solution":"class Library: def __init__(self) -> None: self.books = {} # A dictionary to store book ID and title self.issued_books = set() # A set to store issued book IDs def add_book(self, book_id: int, title: str) -> None: # Add a new book to the library self.books[book_id] = title def issue_book(self, book_id: int) -> str: # Issue a book to a user if book_id not in self.books or book_id in self.issued_books: return \\"Book not available\\" self.issued_books.add(book_id) return \\"Book issued\\" def return_book(self, book_id: int) -> str: # Return a book to the library if book_id not in self.books or book_id not in self.issued_books: return \\"Invalid operation\\" self.issued_books.remove(book_id) return \\"Book returned\\" def search_book(self, title: str) -> list: # Search for a book by its title return [book_id for book_id, book_title in self.books.items() if book_title == title]"},{"question":"# Coding Assessment Question Context In data processing and analysis, string normalization is a common task to ensure uniformity in text data. This involves operations such as converting to lowercase, removing special characters, and normalizing whitespace. We will focus on a particular type of normalization commonly used in preparing textual data for analysis. Task Implement a function `normalize_string` in Python that normalizes a given string. The function should convert all characters to lowercase, remove special characters (non-alphanumeric except spaces), and reduce multiple consecutive spaces to a single space. Function Signature ```python def normalize_string(input_string: str) -> str: pass ``` Input * **input_string**: a string containing up to 10^6 characters. Output * **normalized_string**: a string that has been normalized following the specified rules. Constraints * The input string will consist of printable ASCII characters (values between 32 and 126 inclusive). Examples ```python >>> normalize_string(\\"Hello, World!\\") \'hello world\' >>> normalize_string(\\"This is an example.\\") \'this is an example\' >>> normalize_string(\\"Normalize; THIS STR@NG 123!\\") \'normalize this strng 123\' >>> normalize_string(\\"Edge-case: multiple --- special CHARACTERS!!\\") \'edge-case multiple special characters\' ``` Additional Requirement * Ensure that your function can handle edge cases efficiently, such as strings with no alphanumeric characters or strings already normalized. * Employ appropriate error handling for unexpected inputs.","solution":"import re def normalize_string(input_string: str) -> str: Normalizes the given string by converting to lowercase, removing special characters, and reducing multiple consecutive spaces to a single space. # Convert to lowercase input_string = input_string.lower() # Remove special characters (non-alphanumeric except spaces) input_string = re.sub(r\'[^a-z0-9s]\', \'\', input_string) # Reduce multiple consecutive spaces to a single space input_string = re.sub(r\'s+\', \' \', input_string).strip() return input_string"},{"question":"# Common Elements in Multiple Lists Problem Statement You are given a function `common_elements` that finds the common elements across a given list of lists. Your task is to implement this function. Function Signature ```python def common_elements(lists: List[List[int]]) -> List[int]: pass ``` Detailed Description * `lists` (List[List[int]]): A list of lists, where each internal list contains integers. The list will be non-empty, and each internal list will contain at least one integer. Input Constraints - Each internal list will have a length between 1 and 1000. - The integers in each internal list will be between -10^6 and 10^6. - The outer list will contain between 1 and 1000 internal lists. Output - Return a list of integers that appear in each of the internal lists. - If there are no common elements, return an empty list. Example Usage Implement the function with the following behavior: ```python >>> common_elements([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [] >>> common_elements([[1, 2, 3], [2, 3, 4], [3, 4, 5]]) [3] >>> common_elements([[1, 2], [2, 3], [2]]) [2] >>> common_elements([[1, 2, 2, 3], [2, 4, 2, 2], [2, 2, 5]]) [2] ``` Hints - Utilize Python\'s built-in set operations to easily find intersections between lists. - Convert each list to a set to remove duplicate elements and use the `intersection` method to find common elements iteratively across all internal lists. - Handle special cases where the input might be a single list by returning that list as it is. Ensure that your implementation passes these test cases and handles additional edge cases such as lists of different lengths and lists with no common elements.","solution":"from typing import List def common_elements(lists: List[List[int]]) -> List[int]: if not lists: return [] # Start with the set of the first list common_set = set(lists[0]) # Iterate through the remaining lists and find the intersection for lst in lists[1:]: common_set &= set(lst) return sorted(common_set)"},{"question":"# Problem Statement You are tasked with helping a farmer organize and measure his crop yield efficiently. The farmer has a large field divided into multiple sections, and each section produces a certain amount of crop. To make better decisions about his agricultural strategies, the farmer wants to quickly compute the total yield for any arbitrary range of sections. To assist the farmer, you need to implement a function that pre-processes the section yields data and allows rapid computation of the total yield for any given range of sections. # Function Signature ```python def range_sum_crop_yields(yields: list[int], queries: list[tuple[int, int]]) -> list[int]: pass ``` # Input - `yields`: A list of integers where each integer represents the crop yield of a section. - Constraints: (1 leq text{len}(yields) leq 10^5) and (0 leq text{yield} leq 10^3) - `queries`: A list of tuples, where each tuple contains two integers `(start, end)`, indicating the start and end indices (inclusive) for the range of sections to sum up the yields. - Constraints: (1 leq text{len}(queries) leq 10^4) and (0 leq text{start} leq text{end} < text{len}(yields)) # Output - A list of integers where each integer represents the total crop yield for the corresponding range specified in `queries`. # Requirements - Your implementation should efficiently handle the preprocessing and query answering to ensure fast response times even for large datasets. - Optimize for both preprocessing time and query time. # Examples 1. `range_sum_crop_yields([1, 2, 3, 4, 5], [(0, 2), (1, 3), (0, 4)])` should return `[6, 9, 15]`. 2. `range_sum_crop_yields([10, 15, 20, 25], [(0, 1), (1, 2), (2, 3)])` should return `[25, 35, 45]`. 3. `range_sum_crop_yields([5, 5, 5, 5], [(0, 3), (1, 2), (0, 0)])` should return `[20, 10, 5]`. # Edge Cases - Queries that ask for the yield of the entire range should be handled efficiently. - Queries with the start and end indices referring to the same section should return the yield of that specific section. - Ensure that the function performs well with the maximum constraints. # Constraints - You should preprocess the yields data in such a way that each query can be answered in constant time, (O(1)). Solution To achieve this, you can make use of a prefix sum array where each element at index `i` in the prefix sum array stores the sum of yields from the start up to index `i`. This way, you can quickly compute the sum of yields for any range using the prefix sums.","solution":"def range_sum_crop_yields(yields, queries): Returns the sum of crop yields for specified ranges of sections. Parameters: yields (list[int]): A list of integers representing crop yields of sections. queries (list[tuple[int, int]]): A list of tuples, each containing two integers (start, end) indicating the range of sections. Returns: list[int]: A list of integers representing the total crop yield for each range in queries. # Compute prefix sums prefix_sums = [0] * (len(yields) + 1) for i in range(1, len(prefix_sums)): prefix_sums[i] = prefix_sums[i-1] + yields[i-1] # Answer each query result = [] for start, end in queries: total_yield = prefix_sums[end + 1] - prefix_sums[start] result.append(total_yield) return result"},{"question":"# Scenario In a warehouse management system, it is essential to keep track of inventory levels to prevent overstocking or running out of items. One core feature of such a system is the ability to handle purchase orders efficiently by updating the inventory levels as items are received. **Your Task**: Implement a warehouse inventory tracking system that processes a list of purchase orders. Each order indicates the item being restocked and the quantity received. After processing all orders, your program should output the final inventory levels for all items, ensuring that no item has a negative stock level. # Input Format You will be given: 1. An integer `m` representing the initial number of distinct items in the inventory. 2. A list of `m` integers representing the initial stock levels of each item. 3. A dictionary with keys as item names (strings) and values as the corresponding index (integer) in the initial stock list. 4. An integer `n` representing the number of purchase orders. 5. A list of `n` dictionaries, where each dictionary represents a purchase order with the following keys: - `item`: the name of the item (string) - `quantity`: the quantity of the item received (integer) # Output Format Your program should print the final stock levels of all items in the inventory. # Constraints 1. 1 <= m <= 100 2. 0 <= initial_stock[i] <= 10^6 3. 1 <= n <= 1000 4. Each purchase order\'s `quantity` will be a non-negative integer. # Example ```python m = 3 initial_stock = [10, 5, 8] item_index = {\\"apple\\": 0, \\"banana\\": 1, \\"orange\\": 2} n = 4 purchase_orders = [ {\\"item\\": \\"apple\\", \\"quantity\\": 5}, {\\"item\\": \\"banana\\", \\"quantity\\": 2}, {\\"item\\": \\"orange\\", \\"quantity\\": 7}, {\\"item\\": \\"apple\\", \\"quantity\\": 3} ] ``` Expected output: ``` Final inventory levels: apple: 18 banana: 7 orange: 15 ``` # Function Signature ```python def update_inventory(m: int, initial_stock: List[int], item_index: Dict[str, int], n: int, purchase_orders: List[Dict[str, int]]) -> None: # your code here ``` # Notes * Handle duplicate purchase orders for the same item correctly by accumulating the quantities. * Ensure that the inventory levels are updated efficiently even for the maximum input size. * Print the final inventory levels in the same order as the `initial_stock` list.","solution":"def update_inventory(m, initial_stock, item_index, n, purchase_orders): # Update the stock levels based on the purchase orders for order in purchase_orders: item = order[\\"item\\"] quantity = order[\\"quantity\\"] # Find the corresponding index for the item and update the stock level index = item_index[item] initial_stock[index] += quantity # Print the final inventory levels print(\\"Final inventory levels:\\") for item, index in item_index.items(): print(f\\"{item}: {initial_stock[index]}\\")"},{"question":"# Problem Statement You aim to develop a function to process a CSV file containing user data, enhance it by including additional functionality and output requirements. Your task: 1. **CSV Parsing**: Parse a given CSV file containing user data with columns: `id`, `name`, `email`, `signup_date`, and `last_login_date`. 2. **Validation**: Ensure that `email` contains a valid email address. 3. **Filtering**: Allow filtering by a minimum `signup_date` and a minimum `last_login_date`. 4. **Data Transformation**: Add an additional field called `account_age` to each user, representing the number of days since the `signup_date`. Function Signature: ```python def process_user_data( csv_file: str, min_signup_date: str | None = None, min_last_login_date: str | None = None ) -> list: csv_file : str : Path to the CSV file containing user data. min_signup_date : str | None : Minimum signup date to filter users (format: YYYY-MM-DD). min_last_login_date : str | None : Minimum last login date to filter users (format: YYYY-MM-DD). ``` Guidelines: 1. **CSV Parsing**: Read the CSV file and parse the user data into a list of dictionaries. 2. **Email Validation**: Ensure that each email address is valid using a regular expression. 3. **Date Filtering**: Filter users by comparing their `signup_date` and `last_login_date` with the provided minimum dates. 4. **Account Age Calculation**: Use the current date to calculate the `account_age` (in days) for each user based on their `signup_date`. 5. If a date field is provided, filter users such that only those who signed up after `min_signup_date` and logged in after `min_last_login_date` are included. Input and Output: * **Input**: - `csv_file` : A string representing the path to the CSV file. - `min_signup_date` : A string in the format \'YYYY-MM-DD\' representing the minimum signup date for filtering (or `None` to disable this filter). - `min_last_login_date` : A string in the format \'YYYY-MM-DD\' representing the minimum last login date for filtering (or `None` to disable this filter). * **Output**: A list of dictionaries, each representing a user with filtered and transformed data. Constraints: * Assume the CSV file is well-formed. * Return an empty list if no users meet the filtering criteria. * Ensure that the function handles up to 10,000 users efficiently. * Use the Python `datetime` module for date manipulations and ensure all dates are in the format `YYYY-MM-DD`. Example: ```python # Sample CSV content: # id,name,email,signup_date,last_login_date # 1,John Doe,john@example.com,2022-01-01,2023-01-01 # 2,Jane Doe,jane@example.com,2022-06-01,2023-01-02 # 3,Invalid User,invalid-email,2022-07-01,invalid-date # Basic invocation with date filtering and one invalid email excluded results = process_user_data( \\"user_data.csv\\", min_signup_date=\\"2022-01-01\\", min_last_login_date=\\"2023-01-01\\" ) # Output example [ {\\"id\\": \\"1\\", \\"name\\": \\"John Doe\\", \\"email\\": \\"john@example.com\\", \\"signup_date\\": \\"2022-01-01\\", \\"last_login_date\\": \\"2023-01-01\\", \\"account_age\\": 365}, {\\"id\\": \\"2\\", \\"name\\": \\"Jane Doe\\", \\"email\\": \\"jane@example.com\\", \\"signup_date\\": \\"2022-06-01\\", \\"last_login_date\\": \\"2023-01-02\\", \\"account_age\\": 214} # ... other users ] ```","solution":"import csv import re from datetime import datetime def process_user_data(csv_file, min_signup_date=None, min_last_login_date=None): Process the user data from a CSV file based on the given parameters. Args: csv_file (str): Path to the CSV file containing user data. min_signup_date (str | None): Minimum signup date to filter users (format: YYYY-MM-DD). min_last_login_date (str | None): Minimum last login date to filter users (format: YYYY-MM-DD). Returns: list: A list of dictionaries representing the filtered and transformed user data. def is_valid_email(email): pattern = r\\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}\\" return re.match(pattern, email) min_signup_date = datetime.strptime(min_signup_date, \\"%Y-%m-%d\\") if min_signup_date else None min_last_login_date = datetime.strptime(min_last_login_date, \\"%Y-%m-%d\\") if min_last_login_date else None current_date = datetime.now() users = [] with open(csv_file, mode=\\"r\\") as file: reader = csv.DictReader(file) for row in reader: if not is_valid_email(row[\'email\']): continue signup_date = datetime.strptime(row[\'signup_date\'], \\"%Y-%m-%d\\") last_login_date = datetime.strptime(row.get(\'last_login_date\', \\"\\"), \\"%Y-%m-%d\\") if row.get(\'last_login_date\') else None if min_signup_date and signup_date < min_signup_date: continue if min_last_login_date and (last_login_date is None or last_login_date < min_last_login_date): continue account_age = (current_date - signup_date).days row[\'account_age\'] = account_age users.append(row) return users"},{"question":"# Coding Assessment Question [Question 2] Implement a function to decode a given encoded string based on a given pattern of repetitions. Task Write a function `decode_string(s: str) -> str`. Given an encoded string containing digits and characters, the function should decode it by repeating the characters as specified by the digits and return the final decoded string. Input * `s` is a string containing digits and lowercase alphabetic characters only. Output * Returns a decoded string based on the given encoding pattern. Examples ```python s = \\"3[a]2[bc]\\" result = decode_string(s) # Expected output: \\"aaabcbc\\" s = \\"3[a2[c]]\\" result = decode_string(s) # Expected output: \\"accaccacc\\" s = \\"2[abc]3[cd]ef\\" result = decode_string(s) # Expected output: \\"abcabccdcdcdef\\" ``` Constraints * The input string `s` will be a valid encoded string according to the described pattern. * Digits can range from 1 to 9 only, representing the number of times characters should be repeated. * Nested encoding is allowed, e.g., \\"3[a2[c]]\\". Notes * Aim for an efficient approach by using a stack or recursion to handle nested encodings. * Consider edge cases such as empty input string or single-character input.","solution":"def decode_string(s: str) -> str: Decodes an encoded string where numbers indicate how many times the subsequent characters should be repeated. Args: s (str): Encoded string containing digits and letters. Returns: str: Decoded string. stack = [] current_num = 0 current_str = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_str, current_num)) current_str, current_num = \\"\\", 0 elif char == \']\': prev_str, num = stack.pop() current_str = prev_str + num * current_str else: current_str += char return current_str"},{"question":"# Principal Component Analysis (PCA) Implementation **Scenario**: You are tasked with reducing the dimensionality of a dataset for a data visualization project in order to capture the most significant variance in the data. To accomplish this, you decide to implement Principal Component Analysis (PCA) from scratch using Singular Value Decomposition (SVD). **Task**: Implement a PCA class in Python that performs dimensionality reduction based on PCA. The class should include methods for: 1. Fitting the model to the dataset. 2. Transforming the dataset to the reduced dimensional space. 3. Reconstructing the dataset from the reduced space back to the original space. **Function Signature**: ```python class PCA: def __init__(self, n_components: int) -> None: pass def fit(self, data: np.ndarray) -> None: pass def transform(self, data: np.ndarray) -> np.ndarray: pass def inverse_transform(self, transformed_data: np.ndarray) -> np.ndarray: pass ``` # Constraints: 1. **Inputs**: - `data`: 2-D numpy array of shape (N, D) where N is the number of samples and D is the number of features. - `n_components`: Integer, the number of principal components to retain. 2. **Outputs**: - Transformed data as a 2-D numpy array of shape (N, n_components). - Reconstructed original data as a 2-D numpy array of shape (N, D). **Example**: ```python import numpy as np data = np.array([[2.5, 2.4], [0.5, 0.7], [2.2, 2.9], [1.9, 2.2], [3.1, 3.0]]) pca = PCA(n_components=1) pca.fit(data) # Transform the data to 1 principal component transformed_data = pca.transform(data) print(transformed_data) # Output might be a 2-D array with shape (5, 1) # Reconstruct the original data from the transformed data reconstructed_data = pca.inverse_transform(transformed_data) print(reconstructed_data) # Output should be close to the original data shape (5,2) and values # Ensure raising errors for invalid cases try: PCA(n_components=-1) except ValueError as e: print(e) # Expected: \\"Number of components must be positive and less than the number of features\\" try: pca_error = PCA(n_components=2) data_invalid = np.array([[1]]) pca_error.fit(data_invalid) except ValueError as e: print(e) # Expected: \\"Data must have more dimensions than the number of components\\" ``` # Performance Requirements: 1. Handle numerical stability and optimization during SVD efficiently for high-dimensional data. 2. Ensure proper handling of edge cases such as singular matrices where the number of components requested exceeds the rank of the data matrix.","solution":"import numpy as np class PCA: def __init__(self, n_components: int) -> None: if n_components <= 0: raise ValueError(\\"Number of components must be positive and less than the number of features\\") self.n_components = n_components self.mean = None self.components = None def fit(self, data: np.ndarray) -> None: if data.ndim != 2 or data.shape[1] <= self.n_components: raise ValueError(\\"Data must have more dimensions than the number of components\\") # Center the data self.mean = np.mean(data, axis=0) centered_data = data - self.mean # Compute SVD U, S, Vt = np.linalg.svd(centered_data, full_matrices=False) self.components = Vt[:self.n_components] def transform(self, data: np.ndarray) -> np.ndarray: if self.components is None: raise RuntimeError(\\"PCA is not fitted yet. Please call \'fit\' before \'transform\'.\\") centered_data = data - self.mean return np.dot(centered_data, self.components.T) def inverse_transform(self, transformed_data: np.ndarray) -> np.ndarray: if self.components is None: raise RuntimeError(\\"PCA is not fitted yet. Please call \'fit\' before \'inverse_transform\'.\\") return np.dot(transformed_data, self.components) + self.mean"},{"question":"# Coding Challenge: Detect Cycle in a Directed Graph Scenario: You are given a task to determine whether a directed graph contains a cycle. In a cycle, starting from a particular node, by following a sequence of directed edges, you can return to the initial node. Task: Implement a function `detect_cycle` that takes the number of nodes and the directed edges of the graph as input and returns a boolean indicating whether there is a cycle in the graph. Function Signature: ```python def detect_cycle(n: int, edges: list[tuple[int, int]]) -> bool: ``` Input: - `n` (int): The number of nodes in the graph. - `edges` (list of tuples of int): Each tuple (u, v) represents a directed edge from node u to node v. Output: - `bool`: Return `True` if the graph contains a cycle, otherwise return `False`. Constraints: - `1 <= n <= 10^4` (number of nodes) - `0 <= len(edges) <= 5 * 10^4` (number of edges) - Node IDs are numbered from 0 to n-1. Example: ```python n = 4 edges = [(0, 1), (1, 2), (2, 0), (3, 2)] print(detect_cycle(n, edges)) # Expected Output: True n = 3 edges = [(0, 1), (1, 2)] print(detect_cycle(n, edges)) # Expected Output: False ``` Requirements: - You may use Depth-First Search (DFS) or any other efficient algorithm to detect cycles. - Ensure that your function handles the provided constraints efficiently. - Write additional helper functions if necessary. Notes: - Consider edge cases such as an empty graph, self-loops, and multiple disjoint subgraphs. - Your function should handle large input sizes within reasonable time limits.","solution":"def detect_cycle(n: int, edges: list[tuple[int, int]]) -> bool: from collections import defaultdict def is_cyclic(v, visited, rec_stack): visited[v] = True rec_stack[v] = True for neighbour in graph[v]: if not visited[neighbour]: if is_cyclic(neighbour, visited, rec_stack): return True elif rec_stack[neighbour]: return True rec_stack[v] = False return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = [False] * n rec_stack = [False] * n for node in range(n): if not visited[node]: if is_cyclic(node, visited, rec_stack): return True return False"},{"question":"# Coding Assessment Question Scenario: You are tasked with creating a function to detect and return the starting index of a substring\'s first occurrence in a given string. This is a common string manipulation problem used to verify understanding of pattern matching and string traversal concepts. Problem Statement: Implement a Python function `strStr(haystack: str, needle: str) -> int` that returns the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. Requirements: 1. The function should handle empty `needle` and `haystack`. 2. The function should not use any built-in string methods for finding substrings. 3. It should handle the case where `needle` is an empty string, which should return 0 according to the problem definition. 4. Optimize the solution to run efficiently, focusing on minimizing unnecessary comparisons. Input: - A string `haystack` which represents the string to be searched. - A string `needle` which represents the substring to be found in `haystack`. Output: - An integer indicating the zero-based index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not present. Constraints: - Both `haystack` and `needle` consist only of printable ASCII characters. - The length of `haystack` and `needle` will be at most (10^4). Function Signature: ```python def strStr(haystack: str, needle: str) -> int: ``` Example Cases: ```python assert strStr(\\"hello\\", \\"ll\\") == 2 assert strStr(\\"aaaaa\\", \\"bba\\") == -1 assert strStr(\\"\\", \\"\\") == 0 assert strStr(\\"mississippi\\", \\"issip\\") == 4 assert strStr(\\"a\\", \\"a\\") == 0 ``` Additional Information: - Consider using a sliding window approach to traverse through `haystack`. - Think about edge cases such as when `needle` is longer than `haystack`, or either of the strings is empty. Implement the `strStr` function as per the outlined requirements.","solution":"def strStr(haystack: str, needle: str) -> int: Returns the starting index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Parameters: haystack (str): The string to search within. needle (str): The substring to search for. Returns: int: Index of the first occurrence of needle in haystack, or -1 if not found. if needle == \\"\\": return 0 len_haystack, len_needle = len(haystack), len(needle) if len_needle > len_haystack: return -1 for i in range(len_haystack - len_needle + 1): # Check the substring from the current index if haystack[i:i+len_needle] == needle: return i return -1 # Adding call to check the implementation print(strStr(\\"hello\\", \\"ll\\")) # should return 2 print(strStr(\\"aaaaa\\", \\"bba\\")) # should return -1 print(strStr(\\"\\", \\"\\")) # should return 0 print(strStr(\\"mississippi\\", \\"issip\\")) # should return 4 print(strStr(\\"a\\", \\"a\\")) # should return 0"},{"question":"# Problem: Implement a Class for Tracking and Analyzing Real-time Network Metrics **Context**: You are working as a software engineer for a network monitoring company. To improve the efficiency of your monitoring tools, you need to implement a class that can track real-time network metrics such as latency, throughput, and packet loss for different network nodes. This class will allow clients to query the average metrics over a given time window. **Problem Statement**: Implement the class `NetworkMetrics` to manage and analyze real-time network metrics. Your implementation should allow adding metric samples for different nodes, and querying the average metrics over a specified time window. # Requirements * **Class**: `NetworkMetrics` * Store real-time metrics for latency, throughput, and packet loss. * Provide methods to add metric samples and calculate average metrics over a specific time window. * **Method Implementations**: * `add_metric_sample(node: str, timestamp: float, latency: float, throughput: float, packet_loss: float) -> None` * Inputs: - `node`: The network node identifier. - `timestamp`: The timestamp of the sample (in seconds). - `latency`: The latency value (in milliseconds). - `throughput`: The throughput value (in Mbps). - `packet_loss`: The packet loss percentage. * Adds the given sample to the respective node\'s metrics list. * `get_average_metrics(node: str, start_time: float, end_time: float) -> dict[str, float]` * Inputs: - `node`: The network node identifier. - `start_time`: The start time of the query window. - `end_time`: The end time of the query window. * Outputs: - A dictionary with keys `latency`, `throughput`, and `packet_loss`, each mapping to the average value of the respective metric over the given time window. * Calculates and returns the average values of the metrics for the specified node in the given time window. # Example ```python nm = NetworkMetrics() nm.add_metric_sample(\'node1\', 1632867460.0, 20.5, 100.0, 0.01) nm.add_metric_sample(\'node1\', 1632867465.0, 23.0, 98.5, 0.02) nm.add_metric_sample(\'node1\', 1632867470.0, 22.0, 99.0, 0.015) nm.add_metric_sample(\'node2\', 1632867475.0, 30.0, 95.0, 0.005) # Query average metrics for node1 between 1632867460.0 and 1632867470.0 result = nm.get_average_metrics(\'node1\', 1632867460.0, 1632867470.0) # result is expected to return: # {\'latency\': 21.666666666666668, \'throughput\': 99.16666666666667, \'packet_loss\': 0.015} ``` # Constraints * Ensure that samples added are within reasonable timestamps (e.g., non-negative and within typical Unix epoch boundaries). * Handle cases where no samples exist for a node within the specified time window gracefully. * Aim for efficient querying even when a large number of metric samples are tracked. **Note**: Consider time-window management and ensure calculations are performed only on relevant samples within the window to optimize performance.","solution":"from collections import defaultdict import bisect class NetworkMetrics: def __init__(self): self.metrics = defaultdict(list) def add_metric_sample(self, node: str, timestamp: float, latency: float, throughput: float, packet_loss: float) -> None: metric_sample = (timestamp, latency, throughput, packet_loss) self.metrics[node].append(metric_sample) def get_average_metrics(self, node: str, start_time: float, end_time: float) -> dict[str, float]: if node not in self.metrics or start_time >= end_time: return {\'latency\': 0.0, \'throughput\': 0.0, \'packet_loss\': 0.0} samples = self.metrics[node] relevant_samples = [sample for sample in samples if start_time <= sample[0] <= end_time] if not relevant_samples: return {\'latency\': 0.0, \'throughput\': 0.0, \'packet_loss\': 0.0} avg_latency = sum(sample[1] for sample in relevant_samples) / len(relevant_samples) avg_throughput = sum(sample[2] for sample in relevant_samples) / len(relevant_samples) avg_packet_loss = sum(sample[3] for sample in relevant_samples) / len(relevant_samples) return { \'latency\': avg_latency, \'throughput\': avg_throughput, \'packet_loss\': avg_packet_loss }"},{"question":"# Question Implement a class named `Matrix` that represents a matrix and provides methods for basic matrix operations. The class should have the following methods: 1. `__init__(self, data: List[List[float]])` - Initializes the matrix with the given data, which is a two-dimensional list of floats. 2. `transpose(self) -> \'Matrix\'` - Returns the transpose of the matrix. 3. `determinant(self) -> float` - Returns the determinant of the matrix. If the matrix is not square, it should raise a `ValueError` with a descriptive message. 4. `add(self, other: \'Matrix\') -> \'Matrix\'` - Adds the current matrix with another matrix and returns the resultant matrix. If the dimensions do not match, it should raise a `ValueError` with a descriptive message. 5. `multiply(self, other: \'Matrix\') -> \'Matrix\'` - Multiplies the current matrix with another matrix and returns the resultant matrix. If the dimensions do not allow matrix multiplication, it should raise a `ValueError` with a descriptive message. # Required Class Signature ```python class Matrix: def __init__(self, data: List[List[float]]): pass def transpose(self) -> \'Matrix\': pass def determinant(self) -> float: pass def add(self, other: \'Matrix\') -> \'Matrix\': pass def multiply(self, other: \'Matrix\') -> \'Matrix\': pass ``` # Examples ```python # Example matrix initialization matrix_1 = Matrix([[1, 2], [3, 4]]) matrix_2 = Matrix([[5, 6], [7, 8]]) # Transpose of matrix transpose_matrix_1 = matrix_1.transpose() print(transpose_matrix_1) # Output: Matrix([[1, 3], [2, 4]]) # Determinant of matrix determinant_matrix_1 = matrix_1.determinant() print(determinant_matrix_1) # Output: -2.0 # Addition of two matrices sum_matrix = matrix_1.add(matrix_2) print(sum_matrix) # Output: Matrix([[6, 8], [10, 12]]) # Multiplication of two matrices product_matrix = matrix_1.multiply(matrix_2) print(product_matrix) # Output: Matrix([[19, 22], [43, 50]]) # Error cases try: invalid_matrix = Matrix([[1, 2], [3]]) except ValueError as e: print(e) # Output: Invalid matrix data try: non_square_matrix = Matrix([[1, 2, 3], [4, 5, 6]]) non_square_matrix.determinant() except ValueError as e: print(e) # Output: Determinant can only be calculated for square matrices try: mismatched_matrix = Matrix([[1, 2, 3], [4, 5, 6]]) matrix_1.add(mismatched_matrix) except ValueError as e: print(e) # Output: Matrices must have the same dimensions for addition try: incompatible_matrix = Matrix([[1], [2], [3]]) matrix_1.multiply(incompatible_matrix) except ValueError as e: print(e) # Output: Matrices have incompatible dimensions for multiplication ``` # Constraints * The matrix data will always be valid two-dimensional lists of floats. * All methods should handle cases where operations are not feasible and raise descriptive errors as specified. # Notes * Consider edge cases such as empty matrices or invalid matrix shapes. * Implement the methods efficiently, especially for operations like the determinant, which can be computationally intensive for large matrices.","solution":"from typing import List class Matrix: def __init__(self, data: List[List[float]]): # Validate the matrix row_len = len(data[0]) for row in data: if len(row) != row_len: raise ValueError(\\"Invalid matrix data\\") self.data = data self.rows = len(data) self.cols = len(data[0]) def transpose(self) -> \'Matrix\': transposed_data = [[self.data[j][i] for j in range(self.rows)] for i in range(self.cols)] return Matrix(transposed_data) def determinant(self) -> float: if self.rows != self.cols: raise ValueError(\\"Determinant can only be calculated for square matrices\\") return self._calculate_determinant(self.data) def _calculate_determinant(self, matrix: List[List[float]]) -> float: # base case for 2x2 matrix if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] determinant = 0 for c in range(len(matrix)): sub_matrix = [row[:c] + row[c+1:] for row in matrix[1:]] sign = (-1) ** c determinant += sign * matrix[0][c] * self._calculate_determinant(sub_matrix) return determinant def add(self, other: \'Matrix\') -> \'Matrix\': if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrices must have the same dimensions for addition\\") added_data = [[self.data[i][j] + other.data[i][j] for j in range(self.cols)] for i in range(self.rows)] return Matrix(added_data) def multiply(self, other: \'Matrix\') -> \'Matrix\': if self.cols != other.rows: raise ValueError(\\"Matrices have incompatible dimensions for multiplication\\") product_data = [[sum(self.data[i][k] * other.data[k][j] for k in range(self.cols)) for j in range(other.cols)] for i in range(self.rows)] return Matrix(product_data)"},{"question":"# Coding Assessment Question You are given an array of integers, `nums`, and a target integer, `target`. Write a function `two_sum(nums: List[int], target: int) -> List[int]` that finds two distinct indices (`i` and `j`) in the array such that `nums[i] + nums[j] == target`. The function should return the pair of indices in a list. If no such pair exists, return an empty list. Ensure that your function is efficient and leverages optimal algorithms for finding the solution. Additionally, implement a brute-force approach to compare against your optimized method and measure their execution times. # Input - A list of integers `nums` where each element is an integer. The length of `nums` can be up to 10^5. - An integer `target`. # Output - A list containing the two distinct indices `[i, j]` where `nums[i] + nums[j] == target`. If no such pair exists, return an empty list. # Constraints - The list `nums` can contain both positive and negative integers. - The integers in `nums` and the `target` value will be between -10^9 and 10^9. - Assume there\'s exactly one solution, and you may not use the same element twice. Here is the skeleton of the function you need to implement: ```python from typing import List def two_sum(nums: List[int], target: int) -> List[int]: # Your implementation here pass def test_two_sum(): # Your test cases here pass if __name__ == \\"__main__\\": test_two_sum() ``` # Example ```python nums1 = [2, 7, 11, 15] target1 = 9 print(two_sum(nums1, target1)) # Output: [0, 1] nums2 = [3, 2, 4] target2 = 6 print(two_sum(nums2, target2)) # Output: [1, 2] nums3 = [-1, -2, -3, -4, -5] target3 = -8 print(two_sum(nums3, target3)) # Output: [2, 4] ``` # Performance Comparison Measure the execution time of your optimized function and compare it against a brute-force method like the one provided in the reference code snippet. Discuss the performance results in your comments. ```python def brute_force_two_sum(nums: List[int], target: int) -> List[int]: for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == target: return [i, j] return [] ``` # Expected Performance Given the constraints, the optimized solution should run in (O(n)) time complexity, where (n) is the length of the input list `nums`, utilizing a hash map for efficient lookup. The brute-force method, which runs in (O(n^2)) time complexity, should be significantly slower for large inputs. Implement and compare both methods to validate their efficiencies.","solution":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Finds two distinct indices in the array such that nums[i] + nums[j] == target. Utilizes a hash map for efficient lookup. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return [] def brute_force_two_sum(nums: List[int], target: int) -> List[int]: A brute-force approach to find two distinct indices in the array such that nums[i] + nums[j] == target. length = len(nums) for i in range(length): for j in range(i + 1, length): if nums[i] + nums[j] == target: return [i, j] return []"},{"question":"# Task: Implementing a Scalable LRU Cache As a systems engineer for a high-performance server application, you need to implement a strategically sound Least Recently Used (LRU) cache to efficiently manage memory usage and improve time complexity for frequent data access. # Problem Statement You are given a certain capacity for a caching system. Implement an LRU cache that supports `get` (retrieving data) and `put` (inserting/updating data) operations. The `get` operation retrieves an element by key and updates its position to mark it as recently used, while the `put` operation inserts or updates the value associated with a key, possibly removing the least recently used element if the cache exceeds its capacity. # Requirements * You need to design a class `LRUCache` with the following methods: - `__init__(self, capacity: int)`: Initialize the LRU cache with a given capacity. - `get(self, key: int) -> int`: Return the value of the key if it exists, otherwise return -1. Move the accessed key to the most recently used position. - `put(self, key: int, value: int) -> None`: Insert a new key-value pair or update an existing key\'s value. Move the key to the most recently used position. If the cache exceeds capacity, remove the least recently used item. # Constraints * The number of `get` and `put` operations will be between 1 and 100,000. * The capacity is between 1 and 10,000. * The keys and values are non-negative integers. # Input Format * `operations` (list of tuples): Each tuple contains an operation and corresponding parameters (either a single integer or two integers). # Output Format * A list of integers where the output corresponds to the result of each `get` operation (in order). # Example ```python class LRUCache: def __init__(self, capacity: int): # Your implementation here def get(self, key: int) -> int: # Your implementation here def put(self, key: int, value: int) -> None: # Your implementation here # Example use case lru_cache = LRUCache(2) print(lru_cache.put(1, 1)) # Output: None print(lru_cache.put(2, 2)) # Output: None print(lru_cache.get(1)) # Output: 1 print(lru_cache.put(3, 3)) # Output: None print(lru_cache.get(2)) # Output: -1 print(lru_cache.put(4, 4)) # Output: None print(lru_cache.get(1)) # Output: -1 print(lru_cache.get(3)) # Output: 3 print(lru_cache.get(4)) # Output: 4 ``` # Considerations 1. Use an efficient data structure to maintain the order of elements and support fast lookups, insertions, and deletions. 2. Employ a combination of a doubly linked list and a hash table (dictionary) to optimize both time and space complexity. 3. Ensure your implementation efficiently handles large numbers of operations and adheres to the space constraints. By implementing the LRU cache, you will improve the efficiency of memory management, ensuring that the most frequently accessed data is always readily available while keeping memory usage within bounds.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 self.cache.move_to_end(key) # Move the accessed item to the end to denote it as recently used return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) # Move the existing item to the end to denote it as recently used self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) # Remove the first item (least recently used)"},{"question":"# Problem Description Given two integers, `num1` and `num2`, your task is to implement a function that finds the Greatest Common Divisor (GCD) of these two numbers using both the Euclidean algorithm and the Binary GCD algorithm. # Function Signature - **Euclidean Algorithm**: `def gcd_euclidean(num1: int, num2: int) -> int` - **Binary GCD Algorithm**: `def gcd_binary(num1: int, num2: int) -> int` # Input - `num1`: An integer between (-10^6) and (10^6). - `num2`: An integer between (-10^6) and (10^6). # Output Return the GCD of the two input integers. # Constraints 1. Both input integers can be negative or positive. 2. The input integers can be zero. # Examples ```python assert gcd_euclidean(48, 18) == 6 assert gcd_euclidean(-48, 18) == 6 assert gcd_euclidean(0, 18) == 18 assert gcd_binary(48, 18) == 6 assert gcd_binary(-48, 18) == 6 assert gcd_binary(0, 18) == 18 ``` # Explanation - In the first example, the GCD of `48` and `18` is `6` using both algorithms. - In the second example, even with one negative input, the GCD is still `6`. - In the third example, when one of the inputs is zero, the GCD is the absolute value of the other input, which is `18`. - The same results are expected using the binary GCD (Stein\'s) algorithm. # Notes - The Euclidean algorithm is based on the principle that the GCD of two numbers does not change if the larger number is replaced with its difference with the smaller number, until one of the numbers becomes zero. - The Binary GCD algorithm reduces the problem of finding the GCD to the problem of shifting the numbers (which is computationally less expensive) and uses the properties of even and odd numbers to compute the result. - Handle edge cases like both numbers being zero, where the GCD is conventionally defined as zero.","solution":"def gcd_euclidean(num1: int, num2: int) -> int: Computes the Greatest Common Divisor (GCD) of two integers using the Euclidean algorithm. num1 = abs(num1) num2 = abs(num2) while num2: num1, num2 = num2, num1 % num2 return num1 def gcd_binary(num1: int, num2: int) -> int: Computes the Greatest Common Divisor (GCD) of two integers using the Binary GCD algorithm. # Handling the case where either number is zero if num1 == 0: return abs(num2) if num2 == 0: return abs(num1) num1 = abs(num1) num2 = abs(num2) shift = 0 # Remove common factors of 2 while ((num1 | num2) & 1) == 0: num1 >>= 1 num2 >>= 1 shift += 1 # Divide num1 by 2 until it becomes odd while (num1 & 1) == 0: num1 >>= 1 while num2 != 0: # Divide num2 by 2 until it becomes odd while (num2 & 1) == 0: num2 >>= 1 if num1 > num2: num1, num2 = num2, num1 num2 = num2 - num1 return num1 << shift"},{"question":"# Coding Assessment Question You are tasked with implementing a function that determines if a given string is a palindrome, ignoring case and non-alphabetical characters. A palindrome is a string that reads the same forwards and backwards once the non-alphabetical characters are excluded and case is ignored. **Function Signature**: ```python def is_palindrome(s: str) -> bool: Determine if the given string is a palindrome, ignoring case and non-alphabetical characters. Parameters: s (str): The input string to be checked. Returns: bool: True if the input string is a palindrome, False otherwise. Raises: TypeError: If input is not a string. Sample Input/Output: >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") True >>> is_palindrome(\\"No lemon, no melon!\\") True >>> is_palindrome(\\"Hello, World!\\") False >>> is_palindrome(12321) Traceback (most recent call last): ... TypeError: Expected a string as input ``` **Constraints**: * The function must handle input validation: * Should raise a `TypeError` for non-string inputs. * The input is guaranteed not to be `None`. **Scenarios**: 1. Mainstream inputs that are valid strings containing only alphabetical characters. 2. Typical strings containing mixed characters, to test the strip and case normalization process. 3. Ensuring robustness and reliability for input with non-alphabetical characters. *Assumption*: The function does not take into account empty string scenarios separately as input is guaranteed not to be `None`. --- # Implementation To solve this problem, you will have to: 1. Validate the input to raise a `TypeError` if the input is not a string. 2. Normalize the string by converting it to lowercase and removing all non-alphabetical characters. 3. Compare the normalized string with its reverse to determine if it is a palindrome.","solution":"def is_palindrome(s: str) -> bool: Determine if the given string is a palindrome, ignoring case and non-alphabetical characters. Parameters: s (str): The input string to be checked. Returns: bool: True if the input string is a palindrome, False otherwise. Raises: TypeError: If input is not a string. if not isinstance(s, str): raise TypeError(\\"Expected a string as input\\") # Normalize the string: remove non-alphabetical characters and convert to lowercase normalized_str = \'\'.join(char.lower() for char in s if char.isalpha()) # Check if the normalized string is a palindrome return normalized_str == normalized_str[::-1]"},{"question":"# Unique Binary Search Trees Given an integer `n`, implement the function `num_unique_bst(n: int) -> int` that returns the number of structurally unique Binary Search Trees (BSTs) that can be formed using values 1 to `n`. Input: * A single integer `n` (1 ≤ n ≤ 19). Output: * A single integer representing the number of structurally unique BSTs. Constraints: * The solution must appropriately utilize dynamic programming to ensure efficient computation. Example: ```python assert num_unique_bst(1) == 1 assert num_unique_bst(2) == 2 assert num_unique_bst(3) == 5 assert num_unique_bst(4) == 14 assert num_unique_bst(19) == 1767263190 ``` # Explanation: * Construct a list `dp` where `dp[i]` stores the number of unique BSTs that can be formed with `i` nodes. * Initialize `dp[0]` to 1 because an empty tree is considered one unique BST. * Iterate through tree sizes from 1 to `n`, and for each size, sum the possibilities of having a root at each position to compute the total unique BSTs. * The final result will be stored in `dp[n]`. ```python def num_unique_bst(n: int) -> int: # Initialize a list to store the number of unique BSTs for each count of nodes dp = [0] * (n + 1) dp[0] = 1 # An empty tree is one unique BST for nodes in range(1, n + 1): total = 0 for root in range(1, nodes + 1): left = root - 1 # Nodes on the left side of the root right = nodes - root # Nodes on the right side of the root total += dp[left] * dp[right] dp[nodes] = total return dp[n] ```","solution":"def num_unique_bst(n: int) -> int: # Initialize a list to store the number of unique BSTs for each count of nodes dp = [0] * (n + 1) dp[0] = 1 # An empty tree is one unique BST for nodes in range(1, n + 1): total = 0 for root in range(1, nodes + 1): left = root - 1 # Nodes on the left side of the root right = nodes - root # Nodes on the right side of the root total += dp[left] * dp[right] dp[nodes] = total return dp[n]"},{"question":"# Median Finder Context: You are tasked with implementing a class that maintains a dynamic dataset and can efficiently fetch the median value at any point. Problem: Design and implement a class `MedianFinder` that supports the following operations: 1. **Add a Number**: An operation to add a new number to the dataset. 2. **Find Median**: An operation to find and return the median of the current dataset. Requirements: 1. **Constructor**: - Initialize the data structures needed for the `MedianFinder` class. 2. **`add_number` Method**: - Input: A single floating-point number. - Output: None. - Example: ```python >>> mf = MedianFinder() >>> mf.add_number(1.0) >>> mf.add_number(2.0) >>> mf.add_number(3.0) # No output for add_number method ``` 3. **`find_median` Method**: - Input: None. - Output: A single floating-point number representing the median. - Example: ```python >>> mf = MedianFinder() >>> mf.add_number(1.0) >>> mf.find_median() 1.0 >>> mf.add_number(2.0) >>> mf.find_median() 1.5 >>> mf.add_number(3.0) >>> mf.find_median() 2.0 ``` Constraints: - The `add_number` method will be called at most 10^4 times. - You may assume that all input numbers are valid floating-point numbers. Below is a skeleton for the `MedianFinder` class to help you start: ```python import heapq class MedianFinder: def __init__(self): # Initialize min-heap and max-heap self.min_heap = [] self.max_heap = [] def add_number(self, num: float) -> None: # Add number to one of the heaps and rebalance if necessary pass def find_median(self) -> float: # Calculate and return the median pass ```","solution":"import heapq class MedianFinder: def __init__(self): # Initialize min-heap and max-heap self.min_heap = [] self.max_heap = [] def add_number(self, num: float) -> None: # Add number to max_heap (negative values for max behavior) heapq.heappush(self.max_heap, -num) # Ensure max_heap\'s largest is not bigger than min_heap\'s smallest if self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0]): heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) # Balance the sizes of the heaps if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def find_median(self) -> float: if len(self.max_heap) > len(self.min_heap): return float(-self.max_heap[0]) else: return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"# Coding Assessment Question You are given two functions implemented using the NumPy library: 1. **is_upper_triangular(matrix: np.ndarray) -> bool**: This function checks if a given matrix is upper triangular. 2. **matrix_determinant(matrix: np.ndarray) -> float**: This function computes the determinant of the provided square matrix. Your task is to extend the given functionality in the following ways: 1. Implement a function `find_largest_determinant(matrix_list: List[np.ndarray]) -> Tuple[np.ndarray, float]` that takes in a list of square matrices and returns the matrix that has the largest determinant along with its determinant value. 2. Ensure your function handles edge cases, such as empty lists and non-square matrices, raising appropriate errors if necessary. 3. Provide adequate tests for your solution. Function Signature: ```python def find_largest_determinant(matrix_list: List[np.ndarray]) -> Tuple[np.ndarray, float]: pass ``` # Input: * `matrix_list`: A list of square matrices (NumPy arrays), each of dimension (n times n). # Output: * Returns a tuple with: * The matrix (NumPy array) that has the largest determinant. * The value of this largest determinant. # Constraints: * The input list may contain matrices of different sizes. * The input list is guaranteed to have at least one matrix. # Example: ```python import numpy as np mat1 = np.array([ [1, 2], [0, 1] ]) mat2 = np.array([ [3, 1], [2, 2] ]) mat3 = np.array([ [1, 0, 0], [4, 1, 0], [7, 8, 1] ]) matrix, determinant = find_largest_determinant([mat1, mat2, mat3]) print(\\"Matrix with Largest Determinant:n\\", matrix) print(\\"Largest Determinant Value:\\", determinant) ``` # Expected Outputs: 1. `matrix` should be the matrix from `matrix_list` that has the largest determinant. 2. `determinant` should be the numerical value of the largest determinant. Ensure to test your solution thoroughly and consider edge cases.","solution":"import numpy as np from typing import List, Tuple def find_largest_determinant(matrix_list: List[np.ndarray]) -> Tuple[np.ndarray, float]: Find the matrix with the largest determinant in the list, and return the matrix along with its determinant value. Parameters: matrix_list (List[np.ndarray]): List of square matrices. Returns: Tuple[np.ndarray, float]: The matrix with the largest determinant and its determinant value. if not matrix_list: raise ValueError(\\"The input list should not be empty.\\") for matrix in matrix_list: if matrix.shape[0] != matrix.shape[1]: raise ValueError(\\"All matrices must be square.\\") max_determinant = None max_determinant_matrix = None for matrix in matrix_list: determinant = np.linalg.det(matrix) if (max_determinant is None) or (determinant > max_determinant): max_determinant = determinant max_determinant_matrix = matrix return max_determinant_matrix, max_determinant"},{"question":"# Prime Factors Counter You are tasked with implementing a function that computes the number of distinct prime factors for a given integer. The function should return a dictionary where the keys represent the distinct prime factors, and the values represent the count of each prime factor within the factorization of the number. # Function Signature: ```python def prime_factors_count(n: int) -> dict: pass ``` # Input: - **n**: A positive integer greater than 1 for which the prime factors need to be computed. # Output: - **Dictionary**: A dictionary with distinct prime factors as keys and their corresponding counts as values. # Constraints: - The input integer will be a positive integer greater than 1 and less than or equal to 10^6. # Example: ```python n = 60 print(prime_factors_count(n)) # Output: {2: 2, 3: 1, 5: 1} n = 100 print(prime_factors_count(n)) # Output: {2: 2, 5: 2} ``` # Detailed Explanation: 1. **Factorization**: Decompose the given integer into its prime factors. 2. **Count the Factors**: For each prime factor found, count the occurrences in the factorization process. 3. **Build the Dictionary**: Populate the dictionary with prime factors as keys and their counts as values. # Requirements: - Efficiently determine the prime factors and their counts within constraints. - Ensure that the solution handles large values within the input range efficiently. - Avoid redundant computations by implementing an optimized factorization approach. Implement the function such that it performs well for the upper limits of the input range.","solution":"def prime_factors_count(n: int) -> dict: Returns a dictionary where the keys are the distinct prime factors of the number n and the values are the counts of each prime factor. factors = {} divisor = 2 while n >= 2: if n % divisor == 0: if divisor in factors: factors[divisor] += 1 else: factors[divisor] = 1 n //= divisor else: divisor += 1 return factors"},{"question":"# Coding Assessment Question You are required to design a function that processes temperature data from a CSV file and analyzes it for specific usage requirements. The function should be able to handle large datasets efficiently, support filtering of data within a specific date range, and return statistical summaries such as the average temperature, highest temperature, and lowest temperature within that range. Function Specification **Function Name**: `analyze_temperature_data` **Input Parameters**: 1. `file_path`: (str) The path to the CSV file containing the temperature data. 2. `start_date`: (str) Start date in `YYYY-MM-DD` format, indicating the beginning of the date range to filter. 3. `end_date`: (str) End date in `YYYY-MM-DD` format, indicating the end of the date range to filter. **Output**: - Returns a dictionary containing the following key-value pairs: - `\'average_temperature\'`: (float) The average temperature within the specified date range. - `\'highest_temperature\'`: (float) The highest temperature recorded within the specified date range. - `\'lowest_temperature\'`: (float) The lowest temperature recorded within the specified date range. - In case of invalid inputs or errors, returns an appropriate error message. **Constraints**: - The CSV file is expected to have columns: `date` (in `YYYY-MM-DD` format) and `temperature` (float values). - The `start_date` should not be after the `end_date`. - Handle missing or invalid data gracefully. Example Usage ```python def analyze_temperature_data(file_path: str, start_date: str, end_date: str) -> dict: # Your implementation here pass # Example call summary = analyze_temperature_data(\\"temperature_data.csv\\", \\"2022-01-01\\", \\"2022-01-31\\") print(summary) # Expected Output (example): # { # \'average_temperature\': 15.5, # \'highest_temperature\': 23.3, # \'lowest_temperature\': 8.7 # } ``` # Requirements: 1. **Error Handling**: Ensure the function handles cases such as missing files, invalid date formats, dates outside the data range in the CSV, and empty datasets. 2. **Efficiency**: The solution should be optimized to handle large datasets without significant performance issues. 3. **Data Validation**: Verify the presence and validity of temperature values in the CSV file. 4. **Clear Documentation and Code**: Provide meaningful function and variable names, and ensure your code is well-documented. You have 2 hours to complete this task. Good luck!","solution":"import csv from datetime import datetime def analyze_temperature_data(file_path: str, start_date: str, end_date: str) -> dict: try: # Convert dates to datetime objects start_date = datetime.strptime(start_date, \\"%Y-%m-%d\\") end_date = datetime.strptime(end_date, \\"%Y-%m-%d\\") if start_date > end_date: return {\\"error\\": \\"Start date cannot be after end date\\"} temperatures = [] with open(file_path, \'r\') as file: reader = csv.DictReader(file) for row in reader: row_date = datetime.strptime(row[\'date\'], \\"%Y-%m-%d\\") if start_date <= row_date <= end_date: try: temperature = float(row[\'temperature\']) temperatures.append(temperature) except ValueError: continue if not temperatures: return {\\"error\\": \\"No temperatures found in the given date range\\"} average_temperature = sum(temperatures) / len(temperatures) highest_temperature = max(temperatures) lowest_temperature = min(temperatures) return { \'average_temperature\': average_temperature, \'highest_temperature\': highest_temperature, \'lowest_temperature\': lowest_temperature } except FileNotFoundError: return {\\"error\\": \\"File not found\\"} except ValueError as ve: return {\\"error\\": str(ve)} # Additional helper function to create a sample CSV for testing def create_sample_csv(file_path: str, data: list): headers = [\\"date\\", \\"temperature\\"] with open(file_path, \'w\', newline=\'\') as file: writer = csv.DictWriter(file, fieldnames=headers) writer.writeheader() for row in data: writer.writerow(row)"},{"question":"# Question: Identifying Missing Row in a Matrix Context Given a matrix of integers where one row is missing, you need to identify the missing row. The given rows and the missing row contain unique elements that range from 1 to n, where `n` is the total number of unique elements across all rows, including the missing row. Function Definition Complete the function `find_missing_row` that accepts a list of lists `matrix` representing the matrix with one row missing. Each sublist represents a row of the matrix, and each element is an integer. The function should return a list representing the missing row. Example: ```python def find_missing_row(matrix: list[list[int]]) -> list[int]: Returns the missing row in the matrix, where each row contains unique integers. >>> find_missing_row([[1, 2, 3], [4, 5, 6]]) [7, 8, 9] >>> find_missing_row([[1, 5, 9], [2, 6, 10], [3, 7, 11]]) [4, 8, 12] >>> find_missing_row([[1, 4], [2, 5]]) [3, 6] # Your implementation here # Example usage find_missing_row([[1, 2, 3], [4, 5, 6]]) ``` Constraints: - The matrix will have all its rows except one. - All integers in the matrix are unique and within a determined range. - The number of rows and columns will be such that the problem is computationally feasible within typical constraints.","solution":"def find_missing_row(matrix): Returns the missing row in the matrix, where each row contains unique integers. from itertools import chain # Flatten the matrix to get all the present numbers present_numbers = set(chain.from_iterable(matrix)) # Determine the supposed length of each row row_length = len(matrix[0]) # Determine the expected total number of elements n = len(present_numbers) + row_length # Expected set of numbers from 1 to n expected_numbers = set(range(1, n + 1)) # The missing numbers are the difference between expected and present numbers missing_numbers = expected_numbers - present_numbers return sorted(missing_numbers) # Example usage print(find_missing_row([[1, 2, 3], [4, 5, 6]])) # [7, 8, 9]"},{"question":"# Coding Question You are tasked to implement a function which finds the most frequent element in an unsorted list of numbers. If there are multiple elements with the same highest frequency, return any one of them. Make sure to handle edge cases such as an empty list. # Function Signature ```python def most_frequent_element(numbers: list) -> int: pass ``` # Input * `numbers` (list of int): A list of integers which can potentially be unsorted. # Output * The most frequent element in the list, if the list is non-empty. * If the list is empty, the function should return `None`. # Constraints * The length of the list, `n` is such that `0 ≤ n ≤ 10^4`. * The value of each element in the list is an integer in the range `[-10^3, 10^3]`. # Example ```python print(most_frequent_element([1, 3, 2, 3, 4, 3])) # Output: 3 print(most_frequent_element([1, 2, 3, 2, 1, 2])) # Output: 2 print(most_frequent_element([5, 5, 3, 3])) # Output: 5 or 3 print(most_frequent_element([])) # Output: None print(most_frequent_element([7, 7, -1, -1, 7])) # Output: 7 ``` # Description Implement the `most_frequent_element` function to find and return the most frequent element in an unsorted list of integers. If the list is empty, return `None`. If there are multiple elements with the same highest frequency, return any one of them.","solution":"def most_frequent_element(numbers: list) -> int: Returns the most frequent element in the list. If the list is empty, returns None. Parameters: numbers (list of int): A list of integers which can potentially be unsorted. Returns: int: The most frequent element in the list, if the list is non-empty. None if the list is empty. if not numbers: return None frequency_dict = {} for num in numbers: if num in frequency_dict: frequency_dict[num] += 1 else: frequency_dict[num] = 1 most_frequent = max(frequency_dict, key=frequency_dict.get) return most_frequent"},{"question":"# Rotating Squares in NxN Matrix **Background**: An NxN matrix can be visualized as a grid containing N rows and N columns, and its elements are integers. One common operation on such matrices is rotating the elements, particularly in squares or layers. Your task is to implement a rotation algorithm for the outer layer of any given NxN matrix. **Function Specification**: Implement the function `rotate_outer_layer(matrix)` that rotates the outermost layer of an NxN matrix by 90 degrees clockwise. The rotation should be performed in-place, meaning the input matrix itself should be modified. **Input**: - `matrix`: A list of lists where each inner list represents a row in the NxN integer matrix. **Output**: - The function does not return any value. Instead, it modifies the input matrix in-place. **Examples**: ```python def rotate_outer_layer(matrix): # Your code here # Examples matrix1 = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] rotate_outer_layer(matrix1) print(matrix1) # Output: # [ # [13, 9, 5, 1], # [14, 6, 7, 2], # [15, 10, 11, 3], # [16, 12, 8, 4] # ] matrix2 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_outer_layer(matrix2) print(matrix2) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix3 = [ [1] ] rotate_outer_layer(matrix3) print(matrix3) # Output: # [ # [1] # ] ``` **Constraints**: - The function should handle any NxN matrix where N > 0. - Try to solve the problem with a time complexity of O(N). **Notes**: - Focus on rotating the outermost elements in one sweep. Do not rotate inner elements or nested layers for this task. - Ensure that the resultant matrix retains its original dimensions NxN.","solution":"def rotate_outer_layer(matrix): Rotates the outermost layer of an NxN matrix by 90 degrees clockwise. Modifies the input matrix in-place. n = len(matrix) if n <= 1: return # We will rotate in four steps: top -> right, right -> bottom, bottom -> left, left -> top # Copy the four sides\' outer edges top_edge = matrix[0][:] # Top row right_edge = [matrix[i][n-1] for i in range(n)] # Right column bottom_edge = matrix[n-1][:] # Bottom row left_edge = [matrix[i][0] for i in range(n)] # Left column # Rotate the edges # Move left column to top row for i in range(n): matrix[0][i] = left_edge[n-i-1] # Move top row to right column for i in range(n): matrix[i][n-1] = top_edge[i] # Move right column to bottom row for i in range(n): matrix[n-1][i] = right_edge[n-i-1] # Move bottom row to left column for i in range(n): matrix[i][0] = bottom_edge[i]"},{"question":"# Course Prerequisites Evaluation You are working on an academic tool to help students determine if they are eligible to enroll in a given course based on their completed courses and the prerequisites defined for that course. Each course might have some prerequisite courses that need to be completed. **Objective**: Implement a system that determines whether a student can enroll in a specified course by checking their completed courses against the prerequisite requirements. **Requirements**: 1. **Initialization**: * Accept a dictionary `course_prerequisites` where the keys are course names and the values are lists of prerequisite courses. 2. **Methods**: - `can_enroll(student_courses: List[str], target_course: str) -> bool`: * Return `True` if the student can enroll in `target_course` (i.e., all prerequisite courses of `target_course` are in `student_courses`); otherwise, `False`. - `get_unmet_prerequisites(student_courses: List[str], target_course: str) -> List[str]`: * Return a list of prerequisite courses that are not met from the student\'s list of completed courses for the `target_course`. * If all prerequisites are met, return an empty list. **Constraints**: * `len(course_prerequisites) <= 1000` * `len(student_courses) <= 1000` * Course names consist of alphanumeric characters and have a maximum length of 100. **Example**: ```python # Define course prerequisites prerequisites = { \\"Advanced Mathematics\\": [\\"Calculus\\", \\"Linear Algebra\\"], \\"Machine Learning\\": [\\"Linear Algebra\\", \\"Probability\\"], \\"Artificial Intelligence\\": [\\"Machine Learning\\"], \\"Algorithms\\": [\\"Data Structures\\"], } # Initialize the system academic_tool = CoursePrerequisites(prerequisites) # Check enrollment eligibility student_courses_1 = [\\"Calculus\\", \\"Linear Algebra\\"] print(academic_tool.can_enroll(student_courses_1, \\"Advanced Mathematics\\")) # Expected: True student_courses_2 = [\\"Data Structures\\"] print(academic_tool.can_enroll(student_courses_2, \\"Algorithms\\")) # Expected: True student_courses_3 = [\\"Calculus\\"] print(academic_tool.can_enroll(student_courses_3, \\"Advanced Mathematics\\")) # Expected: False # Get unmet prerequisites student_courses_4 = [\\"Linear Algebra\\"] print(academic_tool.get_unmet_prerequisites(student_courses_4, \\"Machine Learning\\")) # Expected: [\\"Probability\\"] student_courses_5 = [\\"Data Structures\\", \\"Probability\\"] print(academic_tool.get_unmet_prerequisites(student_courses_5, \\"Machine Learning\\")) # Expected: [\\"Linear Algebra\\"] ```","solution":"from typing import List, Dict class CoursePrerequisites: def __init__(self, course_prerequisites: Dict[str, List[str]]): self.course_prerequisites = course_prerequisites def can_enroll(self, student_courses: List[str], target_course: str) -> bool: if target_course not in self.course_prerequisites: return True # If the target course has no prerequisites prerequisites = self.course_prerequisites[target_course] return all(prerequisite in student_courses for prerequisite in prerequisites) def get_unmet_prerequisites(self, student_courses: List[str], target_course: str) -> List[str]: if target_course not in self.course_prerequisites: return [] # If the target course has no prerequisites prerequisites = self.course_prerequisites[target_course] return [prerequisite for prerequisite in prerequisites if prerequisite not in student_courses] # Example creation of the CoursePrerequisites object prerequisites = { \\"Advanced Mathematics\\": [\\"Calculus\\", \\"Linear Algebra\\"], \\"Machine Learning\\": [\\"Linear Algebra\\", \\"Probability\\"], \\"Artificial Intelligence\\": [\\"Machine Learning\\"], \\"Algorithms\\": [\\"Data Structures\\"], } # Initialize the system academic_tool = CoursePrerequisites(prerequisites) # Example usage student_courses_1 = [\\"Calculus\\", \\"Linear Algebra\\"] print(academic_tool.can_enroll(student_courses_1, \\"Advanced Mathematics\\")) # Expected: True print(academic_tool.get_unmet_prerequisites(student_courses_1, \\"Advanced Mathematics\\")) # Expected: [] student_courses_2 = [\\"Data Structures\\"] print(academic_tool.can_enroll(student_courses_2, \\"Algorithms\\")) # Expected: True print(academic_tool.get_unmet_prerequisites(student_courses_2, \\"Algorithms\\")) # Expected: [] student_courses_3 = [\\"Calculus\\"] print(academic_tool.can_enroll(student_courses_3, \\"Advanced Mathematics\\")) # Expected: False print(academic_tool.get_unmet_prerequisites(student_courses_3, \\"Advanced Mathematics\\")) # Expected: [\\"Linear Algebra\\"] student_courses_4 = [\\"Linear Algebra\\"] print(academic_tool.get_unmet_prerequisites(student_courses_4, \\"Machine Learning\\")) # Expected: [\\"Probability\\"] student_courses_5 = [\\"Data Structures\\", \\"Probability\\"] print(academic_tool.get_unmet_prerequisites(student_courses_5, \\"Machine Learning\\")) # Expected: [\\"Linear Algebra\\"]"},{"question":"# Context Sorting algorithms are fundamental to computer science and often serve as the basis for more complex operations. One such algorithm is the QuickSort, which uses a divide-and-conquer strategy to sort elements by recursively partitioning the array. # Problem Statement Write a function, `quick_sort(arr)`, that sorts an array of integers in ascending order using the QuickSort algorithm. You should implement the QuickSort algorithm from scratch without using any built-in sorting functions. # Function Signature ```python def quick_sort(arr: list) -> list: pass ``` # Input * `arr`: A list of integers that needs to be sorted. # Output * A list of integers sorted in ascending order. # Constraints * The elements of `arr` will be integers. * The length of `arr` will be between 1 and 1000. * Duplicate elements may exist in `arr`. # Example ```python # Sample list: arr = [3, 6, 8, 10, 1, 2, 1] sorted_arr = quick_sort(arr) print(sorted_arr) # Output: [1, 1, 2, 3, 6, 8, 10] ``` # Explanation In this example, the `quick_sort` function sorts the list using the QuickSort algorithm, resulting in a sorted list `[1, 1, 2, 3, 6, 8, 10]`. # Performance Requirements Your solution should be efficient enough to handle lists of size up to 1000 elements in a reasonable time frame.","solution":"def quick_sort(arr): Function that implements the QuickSort algorithm to sort a given list of integers in ascending order. if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"# Coding Question Context A common task in data processing and transformation is reorganizing data into specific formats or orders. This problem focuses on array rearrangement, which is a fundamental operation in many algorithms and data manipulation tasks. Problem Statement Write a function `rearrange_array` that takes a list of integers `arr` as input and returns a new list where all the zeros in the original list are moved to the end while maintaining the relative order of the non-zero elements. Function Signature ```python def rearrange_array(arr: list[int]) -> list[int]: pass ``` Input * `arr`: A list of integers. (0 <= len(arr) <= 10^4) Output * The function should return a list of integers with all zeros moved to the end, maintaining the relative order of the non-zero elements. Constraints * The integers can be positive, negative, or zero. * If the input list is empty, return an empty list. Example ```python assert rearrange_array([0, 1, 0, 3, 12]) == [1, 3, 12, 0, 0] assert rearrange_array([4, 0, 0, 1]) == [4, 1, 0, 0] assert rearrange_array([1, 2, 3, 0, 0]) == [1, 2, 3, 0, 0] assert rearrange_array([0, 0, 0]) == [0, 0, 0] assert rearrange_array([]) == [] assert rearrange_array([1, 2, 3]) == [1, 2, 3] ``` This question requires the candidate to handle basic array manipulation, dealing with zero values specifically, while maintaining the general structure and complexity similar to the original questions.","solution":"def rearrange_array(arr: list[int]) -> list[int]: Moves all zeros in the list to the end while maintaining the relative order of the non-zero elements. Parameters: arr (list of int): The input list of integers. Returns: list of int: The rearranged list with all zeros moved to the end. non_zero_elements = [x for x in arr if x != 0] zero_count = arr.count(0) return non_zero_elements + [0] * zero_count"},{"question":"Problem Statement You are given a puzzle game grid represented as a 2D list of integers. Your task is to implement a class representing this game grid and to use breadth-first search (BFS) to determine the shortest path from the top-left corner to the bottom-right corner while only moving through cells containing the value `1`. The movements can be horizontal or vertical, but not diagonal. # Function Signature ```python def shortest_path(game_grid: GridGame) -> int ``` # Class `GridGame` Implement the necessary methods for the `GridGame` class: * `add_row(row: list[int]) -> None`: Adds a row to the grid. # Requirements 1. **Grid Representation**: * The grid is a 2D list of integers (`0` or `1`). * `1` indicates a walkable cell, while `0` indicates an obstacle. 2. **Breadth-First Search Algorithm**: * Use a queue to manage the BFS, where each entry contains the current cell\'s coordinates and the distance from the start. * Keep track of visited cells to avoid cycles and redundant calculations. * Begin the search from the top-left corner `(0, 0)`. 3. **Output**: * Return an integer representing the length of the shortest path from `(0, 0)` to the bottom-right corner `(m-1, n-1)`. If no such path exists, return `-1`. # Example ```python grid = GridGame() grid.add_row([1, 0, 0, 1]) grid.add_row([1, 1, 1, 1]) grid.add_row([0, 0, 1, 0]) grid.add_row([1, 1, 1, 1]) path_length = shortest_path(grid) # Expect: # path_length = 7 ``` In the example, the shortest path from the top-left corner to the bottom-right corner is represented by the `1`s in the following way: ``` 1 0 0 1 1 1 1 1 0 0 1 0 1 1 1 1 The path is (0,0) -> (1,0) -> (1,1) -> (1,2) -> (1,3) -> (2,2) -> (3,2) -> (3,3). ``` # Constraints * The number of rows (`m`) in the grid is between 1 and 100. * The number of columns (`n`) in the grid is between 1 and 100. * Cells contain either `0` or `1`. # Note - The start and end cells will always be `1`, meaning the top-left corner and bottom-right corners are guaranteed to be walkable cells.","solution":"from collections import deque class GridGame: def __init__(self): self.grid = [] def add_row(self, row): self.grid.append(row) def shortest_path(game_grid): grid = game_grid.grid if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == m - 1 and y == n - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"# Problem Statement Your task is to implement a function that simulates a simple scheduling system for processing multiple tasks on two processors. The objective is to distribute the tasks in such a way that the maximum workload on any processor is minimized. # Function to Implement 1. `schedule_tasks(tasks: List[int]) -> Tuple[List[int], List[int]]` Requirements * **schedule_tasks**: - **Input**: * `tasks` (List[int]): A list of task durations. (Constraints: 1 <= len(tasks) <= 1000, 1 <= tasks[i] <= 1000) - **Output**: * A tuple of two lists, where each list contains the task indices (0-based) assigned to the corresponding processor. The goal is to balance the workload between the two processors as evenly as possible. # Example ```python def test_schedule_tasks(): tasks = [5, 2, 9, 4, 7, 1] proc1, proc2 = schedule_tasks(tasks) # One possible valid output could be: # proc1 = [0, 3, 5] (tasks with durations [5, 4, 1]) # proc2 = [1, 2, 4] (tasks with durations [2, 9, 7]) assert set(proc1 + proc2) == set(range(len(tasks))), \\"All tasks should be assigned.\\" assert set(proc1).isdisjoint(proc2), \\"Task assignments should be unique.\\" proc1_load = sum(tasks[i] for i in proc1) proc2_load = sum(tasks[i] for i in proc2) # Ensure the difference in the total load assignments is minimized assert abs(proc1_load - proc2_load) <= max(tasks), \\"Workload should be balanced.\\" test_schedule_tasks() ``` **Note**: When multiple valid solutions exist, any of them is acceptable as long as the function distributes the tasks according to the specified constraints and objectives.","solution":"from typing import List, Tuple def schedule_tasks(tasks: List[int]) -> Tuple[List[int], List[int]]: proc1 = [] proc2 = [] proc1_load = 0 proc2_load = 0 # Sort tasks based on their durations in descending order with original indices sorted_tasks = sorted(enumerate(tasks), key=lambda x: x[1], reverse=True) for i, task in sorted_tasks: if proc1_load <= proc2_load: proc1.append(i) proc1_load += task else: proc2.append(i) proc2_load += task return proc1, proc2"},{"question":"# Coding Question: You are given a list of integers representing the daily temperature readings over a span of days. Your task is to determine the number of days you would have to wait for a warmer temperature for each day in the list. If there is no future day with a warmer temperature, the answer for that day should be 0. * **Input Format**: - You will be provided with a variable, `temperatures`, which is a list of integers representing the daily temperatures. * **Output Format**: - Return a list of integers where the value at each index represents the number of days until a warmer temperature is reached. If no warmer day exists, put 0. * **Constraints**: - The length of the `temperatures` list will be between 1 and 10,000. - The temperatures will be integers between 30 and 100. * **Performance requirements**: - The solution should efficiently handle the upper constraints of the input size. # Example: Given the following temperatures: ``` [73, 74, 75, 71, 69, 72, 76, 73] ``` The output should be: ``` [1, 1, 4, 2, 1, 1, 0, 0] ``` # Explanation: - For day 0 (temperature 73), you would have to wait 1 day until temperature 74. - For day 1 (temperature 74), you would have to wait 1 day until temperature 75. - For day 2 (temperature 75), you would have to wait 4 days until temperature 76. - For day 3 (temperature 71), you would have to wait 2 days until temperature 72. - For day 4 (temperature 69), you would have to wait 1 day until temperature 72. - For day 5 (temperature 72), you would have to wait 1 day until temperature 76. - For day 6 (temperature 76), there is no future day with a warmer temperature. - For day 7 (temperature 73), there is no future day with a warmer temperature. # Function Signature: ```python def daily_temperatures(temperatures: List[int]) -> List[int]: # Your code here ``` # Example Usage: ```python temperatures = [73, 74, 75, 71, 69, 72, 76, 73] assert daily_temperatures(temperatures) == [1, 1, 4, 2, 1, 1, 0, 0] ```","solution":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: Returns a list of integers where the value at each index represents the number of days until a warmer temperature is reached. If no warmer day exists, the value is 0. n = len(temperatures) answer = [0] * n stack = [] # This will store indices of the `temperatures` list for current_day in range(n): # We pop from stack if the current day\'s temperature is greater than the temperature at stack\'s top index while stack and temperatures[current_day] > temperatures[stack[-1]]: previous_day = stack.pop() answer[previous_day] = current_day - previous_day # Push the current day\'s index on the stack stack.append(current_day) return answer"},{"question":"# Find Missing Element in an Array You are developing a tool that verifies the integrity of data arrays received from a third-party API. Occasionally, due to network issues, one data element is missing. Write a function `find_missing_element` that identifies this missing element. The data arrays consist of consecutive integers starting from 1 up to n, but one integer from this range is missing. Your task is to find that missing number. # Input: - A list of integers `nums` of length n-1 (1 <= n <= 10^6), containing integers from 1 to n with exactly one integer missing. # Output: - An integer representing the missing number in the range from 1 to n. # Constraints: - `nums` contains unique integers. - The integers in `nums` are in the range [1, n] inclusive. - No integer will be repeated, and exactly one integer will be missing. # Example: ```python >>> find_missing_element([1, 2, 4, 5, 6]) 3 >>> find_missing_element([3, 4, 2, 1]) 5 >>> find_missing_element([2, 3, 1]) 4 ``` # Performance: Aim for a solution with O(n) time complexity and O(1) additional space complexity. # Note: The function should handle large arrays efficiently given the constraint that n can be as large as 10^6.","solution":"def find_missing_element(nums): Finds the missing element in a list of consecutive integers starting from 1 to n. Args: nums (List[int]): List of integers from 1 to n with one missing. Returns: int: The missing integer. n = len(nums) + 1 total_sum = n * (n + 1) // 2 array_sum = sum(nums) return total_sum - array_sum"},{"question":"# Unique Word Abbreviation Checker **Scenario**: As a software developer, you have been tasked with creating an efficient algorithm for an online text editor that checks whether every abbreviation of a word in a given dictionary is unique. The abbreviation for a word is formed by retaining the first and last character of the word and replacing the intermediate characters with their count. **Task**: Implement a class `ValidWordAbbr` that includes the following methods: - `__init__(self, dictionary: List[str]) -> None`: Initializes the class with a list of non-empty words. - `isUnique(self, word: str) -> bool`: Checks if the abbreviation of `word` is unique among the dictionary entries. Input: - A list of non-empty words `dictionary` (with length constraints defined below). Output: - A boolean value indicating if the word\'s abbreviation is unique. Examples: ```python vwa = ValidWordAbbr([\\"deer\\", \\"door\\", \\"cake\\", \\"card\\"]) assert vwa.isUnique(\\"dear\\") == False # \\"dear\\" gets abbreviated to \\"d2r\\" which conflicts with \\"deer\\" assert vwa.isUnique(\\"cart\\") == True # \\"cart\\" gets abbreviated to \\"c2t\\" which is unique assert vwa.isUnique(\\"cane\\") == False # \\"cane\\" gets abbreviated to \\"c2e\\" which conflicts with \\"cake\\" assert vwa.isUnique(\\"make\\") == True # \\"make\\" gets abbreviated to \\"m2e\\" which is unique assert vwa.isUnique(\\"door\\") == False # \\"door\\" gets abbreviated to \\"d2r\\" which is not unique due to \\"deer\\" ``` Constraints: - 1 ≤ len(dictionary) ≤ 3 * 10^4 - 1 ≤ len(word) ≤ 20 - All input strings consist of lowercase English letters. Instructions: 1. Implement the class `ValidWordAbbr` with the methods `__init__` and `isUnique`. 2. Ensure the implementation is efficient and handles the dictionary constraints effectively. ```python class ValidWordAbbr: def __init__(self, dictionary: List[str]): # Implement the constructor to initialize the abbreviation dictionary pass def isUnique(self, word: str) -> bool: # Implement this method to check the uniqueness of the word\'s abbreviation return False # Example usage: vwa = ValidWordAbbr([\\"deer\\", \\"door\\", \\"cake\\", \\"card\\"]) print(vwa.isUnique(\\"dear\\")) # Output: False ```","solution":"from typing import List, Dict class ValidWordAbbr: def __init__(self, dictionary: List[str]): self.abbreviation_map = {} self.dictionary = set(dictionary) # to handle duplicates in the initial dictionary for word in self.dictionary: abbr = self._abbr(word) if abbr not in self.abbreviation_map: self.abbreviation_map[abbr] = {word} else: self.abbreviation_map[abbr].add(word) def _abbr(self, word: str) -> str: if len(word) <= 2: return word return f\\"{word[0]}{len(word) - 2}{word[-1]}\\" def isUnique(self, word: str) -> bool: abbr = self._abbr(word) if abbr not in self.abbreviation_map: return True # Check if the abbreviation is associated with more than one word word_set = self.abbreviation_map[abbr] return word_set == {word} or word_set == set() # Example usage: vwa = ValidWordAbbr([\\"deer\\", \\"door\\", \\"cake\\", \\"card\\"]) print(vwa.isUnique(\\"dear\\")) # Output: False print(vwa.isUnique(\\"cart\\")) # Output: True print(vwa.isUnique(\\"cane\\")) # Output: False print(vwa.isUnique(\\"make\\")) # Output: True print(vwa.isUnique(\\"door\\")) # Output: False"},{"question":"# Coding Assessment Question **Context:** You have been tasked with developing a text analysis tool that identifies the most frequently occurring word in a given text. The tool needs to be efficient and handle large inputs typical for processing literary works. **Function Specification:** - **Function Name**: `most_frequent_word` - **Input**: - `text` (str): A string containing the text to be analyzed. - **Output**: - A string representing the most frequently occurring word in the given text. In case of a tie (multiple words with the same highest frequency), return any one of those words. **Input Constraints**: - The text can contain alphanumeric characters, spaces, and punctuation. - Words are defined as sequences of alphanumeric characters. - The function should ignore case (i.e., \\"Word\\" and \\"word\\" should be treated the same). **Edge Cases to Consider**: - Text with no words (e.g., empty string or text with only punctuation and spaces). - Text where all words occur with the same frequency. - Large inputs (hundreds of thousands of words) to test performance and efficiency. **Examples**: ```python >>> most_frequent_word(\\"The quick brown fox jumps over the lazy dog. The dog was not amused.\\") \'the\' >>> most_frequent_word(\\"To be, or not to be: that is the question.\\") \'to\' >>> most_frequent_word(\\"\\") \'\' ``` **Implementation Notes**: - Optimize for both speed and memory usage. - Ensure your solution handles punctuation and varying cases appropriately. - Do not use any external libraries except Python\'s standard libraries.","solution":"import re from collections import Counter def most_frequent_word(text): Returns the most frequently occurring word in the given text. # Normalize the text to lowercase and split into words words = re.findall(r\'bw+b\', text.lower()) if not words: return \'\' # Count the frequency of each word word_counts = Counter(words) # Find the most frequent word most_frequent = max(word_counts, key=word_counts.get) return most_frequent"},{"question":"# Question: Implement a Polymorphic Calculator in Python You will be creating a polymorphic calculator with the ability to handle different types of numbers and mathematical operations, ensuring extensibility for future operations. # Task: 1. Define an abstract base class `Operation` with a method `compute(self, a, b)` that will be overridden by specific operation classes. 2. Define the following operation classes that inherit from `Operation`: * `Addition` - Implements the addition operation. * `Subtraction` - Implements the subtraction operation. * `Multiplication` - Implements the multiplication operation. * `Division` - Implements the division operation. 3. Write a class `PolymorphicCalculator` that will: * Contain a method `add_operation(self, op_name, operation)` to add operations. * Contain a method `compute(self, op_name, a, b)` to perform the computation using the specified operation. # Constraints: * The calculator should correctly handle integer and floating-point number inputs. * Must raise appropriate exceptions for invalid operations or division by zero. # Example: ```python # Define operation classes class Addition(Operation): def compute(self, a, b): return a + b class Subtraction(Operation): def compute(self, a, b): return a - b class Multiplication(Operation): def compute(self, a, b): return a * b class Division(Operation): def compute(self, a, b): if b == 0: raise ValueError(\\"Cannot divide by zero\\") return a / b # Create an instance of PolymorphicCalculator and register operations calculator = PolymorphicCalculator() calculator.add_operation(\\"add\\", Addition()) calculator.add_operation(\\"subtract\\", Subtraction()) calculator.add_operation(\\"multiply\\", Multiplication()) calculator.add_operation(\\"divide\\", Division()) # Perform computations result_add = calculator.compute(\\"add\\", 10, 5) # 15 result_subtract = calculator.compute(\\"subtract\\", 10, 5) # 5 result_multiply = calculator.compute(\\"multiply\\", 10, 5) # 50 result_divide = calculator.compute(\\"divide\\", 10, 5) # 2.0 assert result_add == 15 assert result_subtract == 5 assert result_multiply == 50 assert result_divide == 2.0 ``` # Notes: * Implement error handling for cases where the operation is not registered with the calculator. * Your solution should allow for easy addition of new operations in the future by creating new classes that inherit from `Operation`.","solution":"from abc import ABC, abstractmethod class Operation(ABC): @abstractmethod def compute(self, a, b): pass class Addition(Operation): def compute(self, a, b): return a + b class Subtraction(Operation): def compute(self, a, b): return a - b class Multiplication(Operation): def compute(self, a, b): return a * b class Division(Operation): def compute(self, a, b): if b == 0: raise ValueError(\\"Cannot divide by zero\\") return a / b class PolymorphicCalculator: def __init__(self): self.operations = {} def add_operation(self, op_name, operation): if not issubclass(operation.__class__, Operation): raise ValueError(\\"operation must be an instance of Operation subclass\\") self.operations[op_name] = operation def compute(self, op_name, a, b): if op_name not in self.operations: raise ValueError(f\\"Operation \'{op_name}\' not found\\") operation = self.operations[op_name] return operation.compute(a, b) # Example Usage calculator = PolymorphicCalculator() calculator.add_operation(\\"add\\", Addition()) calculator.add_operation(\\"subtract\\", Subtraction()) calculator.add_operation(\\"multiply\\", Multiplication()) calculator.add_operation(\\"divide\\", Division()) result_add = calculator.compute(\\"add\\", 10, 5) # 15 result_subtract = calculator.compute(\\"subtract\\", 10, 5) # 5 result_multiply = calculator.compute(\\"multiply\\", 10, 5) # 50 result_divide = calculator.compute(\\"divide\\", 10, 5) # 2.0"},{"question":"# Sorting a List of Strings Based on Custom Alphabet Order Problem Statement: You are given a list of strings and a custom alphabet order string. Your task is to implement a function that sorts the strings in the list according to the custom alphabet order. Function Signature: ```python def custom_sort( strings: list[str], custom_order: str, ) -> list[str]: ``` Parameters: - `strings (list[str])`: A list of strings consisting of alphabetic characters. - `custom_order (str)`: A string representing the custom order of the alphabet. Returns: A list of strings sorted according to the custom alphabet order provided. Constraints: - The `strings` list is not empty. - The `custom_order` string contains all the letters needed for sorting within the input strings and no duplicates. - The input strings only contain alphabetic characters within the `custom_order`. Examples: ```python custom_sort([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"abcdefghijklmnopqrstuvwxyz\\") # Expected Output: [\'apple\', \'banana\', \'cherry\'] custom_sort([\\"dog\\", \\"cat\\", \\"bat\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") # Expected Output: [\'dog\', \'cat\', \'bat\'] custom_sort([\\"ace\\", \\"bed\\", \\"bad\\"], \\"abcdefghij\\") # Expected Output: [\'ace\', \'bad\', \'bed\'] ``` Notes: - Use the custom order strictly for sorting. - Handle all letters in respective cases if the custom order implies different cases. - Implement efficient sorting by leveraging the custom order.","solution":"def custom_sort(strings, custom_order): Sorts a list of strings according to a custom alphabet order. Args: strings (list[str]): List of strings consisting of alphabetic characters. custom_order (str): A string representing the custom order of the alphabet. Returns: list[str]: List of strings sorted according to the custom alphabet order. # Create a dictionary to map each character in custom_order to its index order_map = {char: idx for idx, char in enumerate(custom_order)} # Define a key function that transforms each string into its \\"position\\" equivalent tuple def sort_key(s): return [order_map[char] for char in s] # Sort the strings using the sort_key return sorted(strings, key=sort_key)"},{"question":"# K-d Tree Implementation You are required to implement and extend the functionality of a K-d tree in Python. A K-d tree is a binary search tree used for organizing points in a k-dimensional space. You have been provided with classes `Node` and `KDTree`. Your task is to implement the following additional functionality for the KDTree class: 1. **Insert**: Implement a method `insert(self, point)` that adds a point to the K-d tree. Each point is a tuple representing its coordinates in k-dimensional space. 2. **Search**: Implement a method `search(self, point)` that searches for a specific point in the K-d tree and returns `True` if the point exists, otherwise returns `False`. 3. **Find Minimum**: Implement a method `find_min(self, dimension)` that finds the minimum value along the specified dimension in the K-d tree. Your implementation must maintain the properties of a K-d tree and be efficient. Pay special attention to edge cases such as when the tree is empty. **Input Format**: - `insert(self, point)` - a point represented as a tuple of integers. - `search(self, point)` - a point represented as a tuple of integers. - `find_min(self, dimension)` - an integer representing the dimension to find the minimum value in. **Output Format**: - `insert(self, point)` - `None`. - `search(self, point)` - `True` or `False`. - `find_min(self, dimension)` - an integer, the minimum value along the specified dimension. **Constraints**: - All points in the tree are unique. - The k-dimensional space is defined by the length of the input tuples. - The dimension input for `find_min` is a valid dimension with 0 being the first dimension. **Example**: ```python # Create a new K-d Tree kd_tree = KDTree() # Insert points kd_tree.insert((2, 3)) kd_tree.insert((5, 4)) kd_tree.insert((9, 6)) kd_tree.insert((4, 7)) kd_tree.insert((8, 1)) kd_tree.insert((7, 2)) # Search for a point print(kd_tree.search((5, 4))) # Should return True print(kd_tree.search((10, 10))) # Should return False # Find the minimum value along the 0-th dimension print(kd_tree.find_min(0)) # Should return 2 # Find the minimum value along the 1st dimension print(kd_tree.find_min(1)) # Should return 1 ``` Write your solution and perform appropriate tests to ensure all methods work as expected.","solution":"class Node: def __init__(self, point, left=None, right=None): self.point = point self.left = left self.right = right class KDTree: def __init__(self): self.root = None self.k = None def insert(self, point): if self.root is None: self.k = len(point) self.root = Node(point) else: self._insert(self.root, point, 0) def _insert(self, node, point, depth): cd = depth % self.k if point[cd] < node.point[cd]: if node.left is None: node.left = Node(point) else: self._insert(node.left, point, depth + 1) else: if node.right is None: node.right = Node(point) else: self._insert(node.right, point, depth + 1) def search(self, point): return self._search(self.root, point, 0) def _search(self, node, point, depth): if node is None: return False if node.point == point: return True cd = depth % self.k if point[cd] < node.point[cd]: return self._search(node.left, point, depth + 1) else: return self._search(node.right, point, depth + 1) def find_min(self, dimension): if not self.root: return None return self._find_min(self.root, dimension, 0) def _find_min(self, node, dimension, depth): if node is None: return float(\'inf\') cd = depth % self.k if cd == dimension: if node.left is None: return node.point[dimension] return min(node.point[dimension], self._find_min(node.left, dimension, depth + 1)) return min(node.point[dimension], self._find_min(node.left, dimension, depth + 1), self._find_min(node.right, dimension, depth + 1))"},{"question":"Rotational Symmetry Identifier You are given a string and tasked with finding whether it can form a rotationally symmetric string. A string is defined to be rotationally symmetric if its characters can be rearranged such that it reads the same when rotated 180 degrees. Note that only certain digits (\'0\', \'1\', \'6\', \'8\', \'9\') support rotational symmetry. # Function Signature ```python def is_rotationally_symmetric(s: str) -> bool: Determines if the given string can be rearranged to form a rotationally symmetric string. Args: s (str): The input string to check. Returns: bool: True if the string can be rearranged to be rotationally symmetric, otherwise False. ``` # Input & Output - **Input**: A string ( s ) consisting of digits. - **Output**: Returns a boolean value, `True` if the string can be rearranged to be rotationally symmetric, otherwise `False`. # Example ```python assert is_rotationally_symmetric(\\"1961\\") == True assert is_rotationally_symmetric(\\"1089\\") == True assert is_rotationally_symmetric(\\"1234\\") == False assert is_rotationally_symmetric(\\"69\\") == True ``` # Explanation 1. \\"1961\\" can be rearranged as \\"1691\\", which remains the same when rotated 180 degrees. 2. \\"1089\\" can be rearranged as \\"6091\\", which remains the same when rotated 180 degrees. 3. \\"1234\\" contains digits (\'2\', \'3\', \'4\') that do not support rotational symmetry, hence it cannot be rearranged to form a rotationally symmetric string. 4. \\"69\\" is naturally rotationally symmetric (it reads the same when rotated). # Constraints - ( s ) will only contain characters from \'0\' to \'9\'. - The length of ( s ) will be greater than or equal to 1 and less than or equal to 100.","solution":"def is_rotationally_symmetric(s: str) -> bool: Determines if the given string can be rearranged to form a rotationally symmetric string. Args: s (str): The input string to check. Returns: bool: True if the string can be rearranged to be rotationally symmetric, otherwise False. # Define the valid characters that support rotational symmetry valid_chars = {\'0\', \'1\', \'6\', \'8\', \'9\'} # Check if all characters in the string are valid if any(char not in valid_chars for char in s): return False return True"},{"question":"# Custom Data Structure Implementation Description You are designing a custom data structure that will store and keep track of a collection of elements with quick access to the maximum element in the collection. This data structure should allow for adding elements, removing the last added element, and querying the maximum element efficiently. Task Implement the `CustomStack` class, which will encapsulate the functionality described. The class should manage the elements internally and provide methods to add, remove, and get the maximum element. Class Signature ```python class CustomStack: def __init__(self): pass def push(self, value: int) -> None: pass def pop(self) -> int: pass def get_max(self) -> int: pass ``` Methods - `__init__(self)`: Initializes the data structure. - `push(self, value: int) -> None`: Adds an element to the collection. - `pop(self) -> int`: Removes and returns the last added element. - `get_max(self) -> int`: Returns the maximum element in the collection without modifying the collection. Constraints - All elements are integers. - The collection should handle at least `10^5` operations in total. - The `push`, `pop`, and `get_max` operations should run in `O(1)` time. Example ```python cs = CustomStack() cs.push(3) cs.push(1) cs.push(5) print(cs.get_max()) # Output: 5 cs.pop() print(cs.get_max()) # Output: 3 cs.push(4) print(cs.get_max()) # Output: 4 ``` The task is to ensure that the `CustomStack` class performs efficiently, particularly in terms of retrieving the maximum element and handling a large number of operations. Implement internal mechanisms to keep track of the maximum value as elements are added and removed.","solution":"class CustomStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, value: int) -> None: self.stack.append(value) if not self.max_stack or value >= self.max_stack[-1]: self.max_stack.append(value) def pop(self) -> int: if not self.stack: raise IndexError(\\"pop from empty stack\\") value = self.stack.pop() if self.max_stack and value == self.max_stack[-1]: self.max_stack.pop() return value def get_max(self) -> int: if not self.max_stack: raise IndexError(\\"get_max from empty stack\\") return self.max_stack[-1]"},{"question":"# Counting Triangles in a Graph **Objective**: Write a function that counts the number of triangles in an undirected graph. A triangle in a graph is defined as a set of three nodes where each node is connected to the other two nodes by an edge. Function Signature ```python def count_triangles(graph: dict) -> int: ``` Input * A dictionary `graph` where: * The keys are integers representing nodes in the graph. * The values are lists of integers representing the adjacent nodes. * The graph is undirected and can contain between `0 <= n <= 100` nodes. * There are no self-loops, and there will be no duplicate edges. Output * An integer representing the number of triangles in the graph. Constraints * The function should handle empty graphs and graphs with one or two nodes without errors. * The function can assume that the input graph is a valid undirected graph. Example ```python >>> graph = { ... 0: [1, 2, 5], ... 1: [0, 2], ... 2: [0, 1, 3], ... 3: [2, 4], ... 4: [3, 5], ... 5: [0, 4] ... } >>> count_triangles(graph) 1 >>> graph = { ... 0: [1], ... 1: [0] ... } >>> count_triangles(graph) 0 >>> graph = { ... 0: [1, 2], ... 1: [0, 2], ... 2: [0, 1] ... } >>> count_triangles(graph) 1 ``` Scenario You are working on a social network analysis project where understanding the density of connections is crucial. One way to measure this is by counting the number of triangles in the network graph since triangles signify a high density of connections. Implementing the triangle counting function will aid in analyzing the structural properties of the social networks efficiently. Performance Requirements * The function should efficiently count the number of triangles within the given constraints. * Your implementation should ensure that it counts each triangle exactly once, regardless of the order of the nodes.","solution":"def count_triangles(graph): Counts the number of triangles in an undirected graph. Parameters: graph (dict): A dictionary where the keys are nodes and the values are lists of adjacent nodes. Returns: int: The number of triangles in the graph. triangles = 0 nodes = list(graph.keys()) for i in range(len(nodes)): u = nodes[i] for j in range(i + 1, len(nodes)): v = nodes[j] if v in graph[u]: for k in range(j + 1, len(nodes)): w = nodes[k] if w in graph[u] and w in graph[v]: triangles += 1 return triangles"},{"question":"# Coding Challenge: Maximum Product of Two Elements in an Array You are tasked with writing a function that calculates the maximum product of two distinct elements in a given array. This exercise will test your understanding of arrays and basic algorithm design. Problem Description Implement a function named `max_product` that takes a list of integers as input and returns the maximum product of any two distinct elements in the list. Function Signature: ```python def max_product(nums: list[int]) -> int: ``` Input: * `nums`: A list of integers. The array will contain at least two elements. Output: * Returns the maximum product obtained by multiplying two distinct elements. Example: ```python assert max_product([1, 2, 3, 4]) == 12 assert max_product([-10, -20, 1, 2, 3]) == 200 assert max_product([5, 6, 2, 7, 4]) == 42 assert max_product([-1, -3, -4, 2, 0]) == 12 assert max_product([1, 0, -1, -3, -5]) == 15 ``` Constraints: * The list will have at least two elements. * The elements of the array can be positive, negative, or zero. * Execution should be efficient with a time complexity better than O(n^2). Additional Considerations: Consider edge cases where the largest product might involve negative numbers due to the negative times negative equals positive rule. Be sure to handle lists with both large positive and large negative numbers effectively.","solution":"def max_product(nums: list[int]) -> int: Returns the maximum product of any two distinct elements in the list. if len(nums) < 2: raise ValueError(\\"The list must contain at least two elements\\") # Initialize two smallest and two largest elements smallest = float(\'inf\') second_smallest = float(\'inf\') largest = float(\'-inf\') second_largest = float(\'-inf\') for num in nums: # Update smallest and second smallest if num <= smallest: second_smallest = smallest smallest = num elif num < second_smallest: second_smallest = num # Update largest and second largest if num >= largest: second_largest = largest largest = num elif num > second_largest: second_largest = num return max(smallest * second_smallest, largest * second_largest)"},{"question":"# Scenario You are developing a library management system that manages book records. This system needs to categorize books according to their publication years and titles. # Problem Statement Write a function `classify_books(books: List[Dict[str, Union[str, int]]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]` that takes a list of book information dictionaries and classifies the books into multiple categories based on the following rules: 1. Books published before the year 2000. 2. Books published from the year 2000 onwards. 3. Books with titles starting with a vowel. 4. Books with titles containing more than 3 words. Additionally, ensure the function can gracefully handle an incorrect data structure. Input * `books` (List of dictionaries): A list of dictionaries where each dictionary represents a book with the following keys: - `\\"title\\"`: A string representing the title of the book. - `\\"year\\"`: An integer representing the publication year of the book. Output * `result` (dictionary): A dictionary containing: - `\\"before_2000\\"`: List of book titles published before the year 2000. - `\\"from_2000\\"`: List of book titles published from the year 2000 onwards. - `\\"vowel_titles\\"`: List of book titles starting with a vowel (case-insensitive). - `\\"long_titles\\"`: List of book titles containing more than 3 words. Function Signature ```python def classify_books(books: List[Dict[str, Union[str, int]]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]: pass ``` Constraints * The solution should handle empty lists and incorrect data gracefully. * Ignore case for checking titles starting with a vowel. Example ```python books = [ {\\"title\\": \\"A Tale of Two Cities\\", \\"year\\": 1859}, {\\"title\\": \\"Effective Python\\", \\"year\\": 2015}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"year\\": 1960}, {\\"title\\": \\"The Great Gatsby\\", \\"year\\": 1925}, {\\"title\\": \\"1984\\", \\"year\\": 1949}, {\\"title\\": \\"Python Programming\\", \\"year\\": 2020}, ] expected_output = { \\"before_2000\\": [\\"A Tale of Two Cities\\", \\"To Kill a Mockingbird\\", \\"The Great Gatsby\\", \\"1984\\"], \\"from_2000\\": [\\"Effective Python\\", \\"Python Programming\\"], \\"vowel_titles\\": [\\"A Tale of Two Cities\\", \\"Effective Python\\"], \\"long_titles\\": [\\"A Tale of Two Cities\\", \\"To Kill a Mockingbird\\"] } result = classify_books(books) assert result == expected_output ``` Note Ensure your solution checks for edge cases, operates efficiently, and handles invalid inputs appropriately. Document any assumptions made.","solution":"from typing import List, Dict, Union def is_vowel(char: str) -> bool: return char.lower() in \'aeiou\' def classify_books(books: List[Dict[str, Union[str, int]]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]: categorized_books = { \\"before_2000\\": [], \\"from_2000\\": [], \\"vowel_titles\\": [], \\"long_titles\\": [], } for book in books: if not isinstance(book, dict) or \'title\' not in book or \'year\' not in book: continue title = book[\'title\'] year = book[\'year\'] if not isinstance(title, str) or not isinstance(year, int): continue if year < 2000: categorized_books[\\"before_2000\\"].append(title) else: categorized_books[\\"from_2000\\"].append(title) if title and is_vowel(title[0]): categorized_books[\\"vowel_titles\\"].append(title) if len(title.split()) > 3: categorized_books[\\"long_titles\\"].append(title) return categorized_books"},{"question":"# Coding Assessment Question Write a function to simulate a simple job scheduling system that assigns jobs to available workers based on their availability and job priorities. Your function should accept a list of jobs, each with a priority, and a list of workers. Each worker can handle only one job at a time, and jobs with higher priority should be assigned first. If multiple jobs have the same priority, assign them in the order they appear in the job list. Function Signature ```python def schedule_jobs( jobs: List[Tuple[int, int]], workers: List[str] ) -> Dict[str, Tuple[int, int]]: ``` Input Specifications: - **jobs** (*List[Tuple[int, int]]*): A list of tuples where each tuple contains two integers. The first integer is the job id, and the second integer is the priority (higher value indicates higher priority). - **workers** (*List[str]*): A list of worker names (strings) who are available to take jobs. Output Specifications: - **output** (*Dict[str, Tuple[int, int]]*): A dictionary where each key is a worker\'s name, and the value is a tuple representing the assigned job (the job id and its priority). If there are more workers than jobs, the remaining workers should not be included in the output. Example Usage: ```python jobs = [(1, 3), (2, 1), (3, 2)] workers = [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] assignment = schedule_jobs(jobs, workers) # Expected output: # { # \\"Alice\\": (1, 3), # \\"Charlie\\": (3, 2), # \\"Bob\\": (2, 1) # } ``` Constraints: - Each worker can be assigned only one job. - The total number of jobs will not exceed 1000. - There will be at least one job and one worker. - Job priorities are represented by non-negative integers. Higher values indicate higher priority. - If there are fewer jobs than workers, some workers will remain without an assigned job. - You may assume that the jobs list is always provided in the same format with unique job ids and valid priorities. Additional Notes: - The main aim is to ensure that jobs with higher priority are assigned before those with lower priority. - The function should handle any discrepancies in the number of jobs and workers gracefully.","solution":"from typing import List, Tuple, Dict def schedule_jobs(jobs: List[Tuple[int, int]], workers: List[str]) -> Dict[str, Tuple[int, int]]: # Sort jobs based on priority in descending order sorted_jobs = sorted(jobs, key=lambda job: (-job[1], jobs.index(job))) # Assign jobs to workers assignments = {} for i in range(min(len(workers), len(jobs))): assignments[workers[i]] = sorted_jobs[i] return assignments"},{"question":"# Coding Assessment Question You have been provided with an implementation of the Convolutional Neural Network (CNN) and are familiar with pooling layers, which are crucial components in reducing the spatial dimensions of feature maps. To test your understanding of pooling operations, you are tasked with implementing a custom pooling function called Max-Out Pooling. # Scenario Your task is to implement a pooling operation called Max-Out Pooling. Max-Out Pooling selects the maximum value from each region of the input feature map, similar to Max Pooling but with a specific configuration. # Function Definition Implement the function `max_out_pooling` that takes a 2D array (feature map), a window size, and a stride, and applies the Max-Out Pooling operation to the input feature map. # Mathematical Definition For an input tensor `feature_map`, the Max-Out Pooling function `f(x)` is defined as: ``` f(x) = max(feature_map[i:i+window_size, j:j+window_size]) ``` where `i` and `j` are the starting indices of the pooling window. # Function Signature ```python def max_out_pooling(feature_map: np.ndarray, window_size: int, stride: int) -> np.ndarray: pass ``` # Input * `feature_map` (np.ndarray): A 2D array representing the input feature map. * `window_size` (int): The size of the pooling window. * `stride` (int): The stride of the pooling window. # Output * Returns (np.ndarray): A 2D array representing the downsampled feature map after Max-Out Pooling. # Constraints * The input feature map must be a NumPy array of real numbers. * The values of window_size and stride will be positive integers. * The dimensions of the output array should be calculated based on the input size, window_size, and stride. # Performance Requirements Your implementation must perform the calculation efficiently in an appropriate time complexity given the dimensions of the input feature map. # Examples ```python >>> feature_map = np.array([ ... [1, 3, 2, 4], ... [5, 6, 7, 8], ... [9, 2, 3, 1], ... [0, 1, 5, 6] ... ]) >>> max_out_pooling(feature_map, window_size=2, stride=2) array([[6, 8], [9, 6]]) >>> feature_map = np.array([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) >>> max_out_pooling(feature_map, window_size=2, stride=2) array([[ 6, 8], [14, 16]]) ```","solution":"import numpy as np def max_out_pooling(feature_map: np.ndarray, window_size: int, stride: int) -> np.ndarray: Apply Max-Out Pooling on the input feature map with the given window size and stride. Parameters: feature_map (np.ndarray): A 2D numpy array representing the input feature map. window_size (int): The size of the pooling window. stride (int): The stride of the pooling window. Returns: np.ndarray: A 2D numpy array representing the downsampled feature map after Max-Out Pooling. output_height = (feature_map.shape[0] - window_size) // stride + 1 output_width = (feature_map.shape[1] - window_size) // stride + 1 pooled_output = np.zeros((output_height, output_width)) for i in range(output_height): for j in range(output_width): start_i = i * stride start_j = j * stride window = feature_map[start_i:start_i + window_size, start_j:start_j + window_size] pooled_output[i, j] = np.max(window) return pooled_output"},{"question":"# Scenario You are developing a financial modeling application that requires simulation of stock price paths using the geometric Brownian motion model. This is a widely used model in finance for representing the time evolution of stock prices. Your task is to implement an algorithm that generates these simulation paths. # Problem Statement **Task**: Implement a function that simulates stock price paths using the geometric Brownian motion (GBM) model. # Input & Output **Function Name**: `simulate_gbm` **Input**: - `S0`: A float, representing the initial stock price. - `mu`: A float, representing the drift coefficient (annual return rate). - `sigma`: A float, representing the volatility of the stock (annual standard deviation). - `T`: A float, representing the total time horizon (in years). - `N`: An integer, representing the number of time steps over the interval `[0, T]`. - `M`: An integer, representing the number of simulation paths. **Output**: - `paths`: A numpy array of shape (M, N+1), representing the simulated stock price paths. # Constraints - Ensure that `S0`, `mu`, `sigma`, `T`, and `N` are positive numbers. - `M` should be a positive integer. - The function should handle the calculation using vectorized operations when possible for efficiency. # Performance Requirements - The solution should have a time complexity of O(M * N). - The space complexity should be O(M * N). # Example ```python import numpy as np def simulate_gbm(S0: float, mu: float, sigma: float, T: float, N: int, M: int) -> np.ndarray: Simulate geometric Brownian motion paths. dt = T / N paths = np.zeros((M, N+1)) paths[:, 0] = S0 for t in range(1, N+1): Z = np.random.standard_normal(M) paths[:, t] = paths[:, t-1] * np.exp((mu - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * Z) return paths # Example usage initial_price = 100 annual_return = 0.05 volatility = 0.2 time_horizon = 1 time_steps = 252 simulations = 10000 simulated_paths = simulate_gbm(initial_price, annual_return, volatility, time_horizon, time_steps, simulations) print(simulated_paths) ```","solution":"import numpy as np def simulate_gbm(S0: float, mu: float, sigma: float, T: float, N: int, M: int) -> np.ndarray: Simulate geometric Brownian motion paths. Parameters: S0 (float): Initial stock price mu (float): Drift coefficient (annual return rate) sigma (float): Volatility of the stock (annual standard deviation) T (float): Total time horizon (in years) N (int): Number of time steps over the interval [0, T] M (int): Number of simulation paths Returns: np.ndarray: Simulated stock price paths of shape (M, N+1) dt = T / N paths = np.zeros((M, N+1)) paths[:, 0] = S0 for t in range(1, N+1): Z = np.random.standard_normal(M) paths[:, t] = paths[:, t-1] * np.exp((mu - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * Z) return paths"},{"question":"# Coding Question: Calculate Average Score with Dropped Lowest and Highest Scores Imagine you\'re building a grading system for an online course. You need to calculate the average score of a student based on multiple assignments. However, to provide a fair assessment, you will drop the lowest and highest scores from the set before computing the average. Write a function `average_score` that takes a list of scores and returns the average score after removing the lowest and highest scores. If there are fewer than three scores, return the average of those scores as-is. # Example ```python >>> average_score([50, 80, 90, 70, 60]) 75.0 ``` Explanation: - Scores: [50, 80, 90, 70, 60] - After removing the lowest (50) and highest (90) scores: [80, 70, 60] - Average of remaining scores: (80 + 70 + 60) / 3 = 75.0 # Constraints 1. The scores list will be non-empty and contain at least one score. 2. All scores are non-negative integers. 3. The function should handle cases where the number of scores is less than three correctly (i.e., no scores are dropped). # Input - `scores`: a list of non-negative integers representing scores. # Output - Returns a float representing the average score after dropping the lowest and highest scores, or the average of the original scores if there are fewer than three. ```python def average_score(scores: list) -> float: # Your implementation here ```","solution":"def average_score(scores): Returns the average score after removing the lowest and highest scores from the list. If there are fewer than three scores, returns the average of those scores as-is. if len(scores) < 3: return sum(scores) / len(scores) sorted_scores = sorted(scores) trimmed_scores = sorted_scores[1:-1] # Remove lowest and highest return sum(trimmed_scores) / len(trimmed_scores)"},{"question":"# Problem Scenario You are tasked with developing a system to manage an online store\'s product catalog. The system needs to filter products based on various criteria such as category, price range, and availability. One feature of this system is to find the highest-priced product within a specific category that is currently in stock. Write a function `highest_priced_product` to determine the highest-priced product in a specified category that is available in stock from a given list of products. Each product has a `name`, `category`, `price`, and `in_stock` attributes. Function Signature ```python def highest_priced_product(products: List[Dict], category: str) -> Union[str, None]: ``` Input - `products` (List[Dict]): A list of dictionaries, where each dictionary represents a product with keys `name` (str), `category` (str), `price` (float), and `in_stock` (bool). - `category` (str): The category of the product to filter by. Output - Returns the name of the highest-priced product in the specified category that is in stock. - If no product meets the criteria, returns `None`. Constraints - Lists of up to 10^4 products will be provided. - The `price` will have a precision of up to two decimal places. - Ensure the function handles edge cases where no product matches the category or availability criteria. Examples ```python >>> products = [ ... {\\"name\\": \\"Laptop\\", \\"category\\": \\"Electronics\\", \\"price\\": 1000.00, \\"in_stock\\": True}, ... {\\"name\\": \\"Smartphone\\", \\"category\\": \\"Electronics\\", \\"price\\": 800.00, \\"in_stock\\": False}, ... {\\"name\\": \\"Tablet\\", \\"category\\": \\"Electronics\\", \\"price\\": 600.00, \\"in_stock\\": True}, ... {\\"name\\": \\"Headphones\\", \\"category\\": \\"Accessories\\", \\"price\\": 200.00, \\"in_stock\\": True} ... ] >>> highest_priced_product(products, \\"Electronics\\") \'Laptop\' >>> highest_priced_product(products, \\"Accessories\\") \'Headphones\' >>> highest_priced_product(products, \\"Home\\") None ``` In this problem, you need to filter the products by the provided `category` and check their `in_stock` status, then find the product with the highest price among the filtered results.","solution":"from typing import List, Dict, Union def highest_priced_product(products: List[Dict], category: str) -> Union[str, None]: Returns the name of the highest-priced product in the specified category that is in stock. max_price = float(\'-inf\') max_product = None for product in products: if product[\'category\'] == category and product[\'in_stock\']: if product[\'price\'] > max_price: max_price = product[\'price\'] max_product = product[\'name\'] return max_product"},{"question":"# Question: Design a text-based game where the player must collect all keys hidden in a grid to unlock a door and win the game. Your task is to implement a function `can_win_game` which determines if the player can collect all the keys and reach the door. The player can move up, down, left, or right within the grid. **Function Signature**: ```python def can_win_game(grid: List[List[str]]) -> bool: # implement the function ``` # Requirements: 1. **Input Format**: - `grid`: A 2D list of strings where each string represents a cell in the grid. It consists of the following characters: - `\'.\'` representing an empty space where the player can move. - `\'#\'` representing an obstacle that the player cannot pass through. - `\'K\'` representing a key that the player must collect. - `\'D\'` representing the door that the player needs to reach after collecting all keys. - `\'S\'` representing the starting position of the player. 2. **Output Format**: - A boolean value, `True` if the player can collect all keys and reach the door, `False` otherwise. # Constraints: - The grid dimensions will be in the range `1` to `100` for both rows and columns. - The grid will contain at least one key and one door. - There will be exactly one starting position `S`. # Performance Requirements: - The algorithm should efficiently handle grids up to the maximum size. # Example: ```python grid = [ [\'S\', \'.\', \'.\', \'#\', \'K\'], [\'#\', \'#\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'K\', \'#\', \'D\'] ] print(can_win_game(grid)) # Output: True ``` # Function Behavior: 1. Identify the start position `S`, keys `\'K\'`, and the door `\'D\'`. 2. Use a search algorithm (like BFS or DFS) to determine if all keys can be collected and the door can be reached. 3. Return `True` if it is possible to collect all keys and reach the door, otherwise return `False`. # Additional Notes: - Ensure to handle edge cases where the grid has isolated sections. - Consider the shortest path for efficiency, especially in larger grids. # Hints: * Use a queue or stack to explore the grid from the starting position. * Keep track of collected keys and visited positions to avoid redundant checks and optimize the search.","solution":"from typing import List def can_win_game(grid: List[List[str]]) -> bool: from collections import deque nrows, ncols = len(grid), len(grid[0]) def find_start(): for r in range(nrows): for c in range(ncols): if grid[r][c] == \'S\': return (r, c) def bfs(start): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(*start, set(), False)]) visited = set() total_keys = sum(row.count(\'K\') for row in grid) while queue: x, y, keys, found_door = queue.popleft() if (x, y, frozenset(keys)) in visited: continue visited.add((x, y, frozenset(keys))) if grid[x][y] == \'K\': keys.add((x, y)) if grid[x][y] == \'D\' and len(keys) == total_keys: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < nrows and 0 <= ny < ncols and grid[nx][ny] != \'#\': queue.append((nx, ny, keys.copy(), found_door)) return False start_pos = find_start() if start_pos is None: return False return bfs(start_pos)"},{"question":"# Question **Background**: You are developing a web scraping tool and need to accurately parse and count word occurrences from HTML content. Given a chunk of HTML content, you want to extract the text content while ignoring the HTML tags and then count the occurrence of each word. **Task**: Write a function `word_count_from_html` that takes a string of HTML content, extracts the text, removes any HTML tags, and returns a dictionary with words as keys and their corresponding counts as values. Use basic Python operations and the built-in `re` library for regular expression operations. **Function Signature**: ```python def word_count_from_html(html_content: str) -> dict[str, int]: pass ``` **Input**: * `html_content` (string): A string containing HTML content from which text needs to be extracted and word counts calculated. **Output**: * (dict): A dictionary where keys are words found in the text and values are their respective counts. **Constraints**: * HTML content length will be ( 1 leq t leq 10^6 ). * Words are considered as sequences of alphanumeric characters. * Words should be treated case-insensitively, i.e., \\"Word\\" and \\"word\\" are the same. * Punctuation marks and any non-alphanumeric characters should be ignored. **Examples**: ```python # Example 1 html_content = \\"<html><body><p>This is a test. This test is simple.</p></body></html>\\" result = word_count_from_html(html_content) print(result) # Expected: {\\"this\\": 2, \\"is\\": 2, \\"a\\": 1, \\"test\\": 2, \\"simple\\": 1} # Example 2 html_content = \\"<div>Python is great. Python is versatile.</div><div>Python is easy to learn.</div>\\" result = word_count_from_html(html_content) print(result) # Expected: {\\"python\\": 3, \\"is\\": 3, \\"great\\": 1, \\"versatile\\": 1, \\"easy\\": 1, \\"to\\": 1, \\"learn\\": 1} ``` **Notes**: * For parsing text and removing HTML tags, use Python\'s `re` module. * Normalize all words to lowercase before counting to ensure case insensitivity. * Ignore any extra spaces and punctuation using regular expressions.","solution":"import re from collections import Counter def word_count_from_html(html_content: str) -> dict[str, int]: Extracts text from HTML content, removes HTML tags, and counts word occurrences. Parameters: html_content (str): A string containing HTML content. Returns: dict: A dictionary with words as keys and their corresponding counts as values. # Remove HTML tags text = re.sub(\'<[^>]+>\', \'\', html_content) # Normalize text to lowercase text = text.lower() # Extract words (alphanumeric only) words = re.findall(r\'bw+b\', text) # Count word occurrences word_count = Counter(words) return dict(word_count)"},{"question":"# Binary Search - Finding the Peak Element You are part of a team working on a new search algorithm for identifying peak elements in arrays. A peak element is defined as an element that is greater than or equal to its neighbors. The team lead has assigned you the task of implementing a function to find a peak element using a binary search approach. Problem Description Given an integer array `nums`, find a peak element, and return its index. The array may contain multiple peaks; in that case, return the index to any one of the peaks. # Task You need to implement a function `find_peak(nums: list[int]) -> int` that finds the index of a peak element using binary search. # Input and Output Formats * **Input**: - `nums`: A list of integers representing the input array. * **Output**: - An integer representing the index of a peak element. # Example: ```python print(find_peak([1, 2, 3, 1])) # Output: 2 (element 3 is a peak element) print(find_peak([1, 2, 1, 3, 5, 6, 4])) # Output: 1 or 5 (either index 1 or 5 corresponds to a peak element with values 2 or 6, respectively) ``` # Constraints: * `1 <= len(nums) <= 10^4` * The elements in `nums` are unique. * `nums[i] != nums[i+1]` for all valid `i`. # Performance: * The function should run in O(log n) time complexity. # Hints: 1. You can use a modified binary search to find a peak element. 2. Compare the middle element with its neighbors to decide in which half of the array the peak lies. ```python def find_peak(nums: list[int]) -> int: left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left ``` In the provided solution, the binary search approach is used efficiently by comparing the middle element with its neighbors and narrowing down the search range until a peak element is found.","solution":"def find_peak(nums: list[int]) -> int: Finds the index of a peak element using binary search. A peak element is an element that is greater than or equal to its neighbors. :param nums: List[int] - a list of integers representing the input array :return: int - the index of a peak element in the input array left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"# Coding Assessment Question **Context**: You are developing a scheduling application that organizes and displays a user\'s tasks for the day. The application needs to provide a summary of tasks, along with their respective priorities and time slots. # Task Write a function `task_summary` that takes a list of tasks, each with a specified priority and duration, and returns a formatted summary of the tasks for the day. Each task should be assigned a time slot starting from 9:00 AM, distributed according to their durations. # Function Signature ```python def task_summary(tasks: list) -> str: ``` # Input - `tasks` (list): A list of dictionaries where each dictionary represents a task with the following keys: - `name` (str): The name of the task. - `priority` (int): The priority of the task (1 for highest priority, 5 for lowest priority). - `duration` (int): The duration of the task in minutes. # Output - Returns a string containing a formatted summary of the tasks for the day. Each task should be listed with its name, priority, start time, and end time. # Constraints - The tasks should be sorted in the summary first by priority (ascending) and then by start time (ascending). - Assume a typical workday starts at 9:00 AM, and each task follows consecutively. - Ensure proper handling if task durations result in exceeding typical working hours. # Performance Requirements - The function should be efficient in handling a reasonable number of tasks (up to 100). - Correctly handle edge cases, such as overlapping tasks due to misspecified durations. # Example ```python tasks = [ {\'name\': \'Task 1\', \'priority\': 2, \'duration\': 60}, {\'name\': \'Task 2\', \'priority\': 1, \'duration\': 30}, {\'name\': \'Task 3\', \'priority\': 3, \'duration\': 90} ] print(task_summary(tasks)) ``` Expected Output: ``` 1. Task 2 (Priority: 1) Time: 09:00 AM - 09:30 AM 2. Task 1 (Priority: 2) Time: 09:30 AM - 10:30 AM 3. Task 3 (Priority: 3) Time: 10:30 AM - 12:00 PM ``` # Additional Information 1. Consider edge cases like no tasks or tasks with zero duration. 2. The formatted summary should be easily readable and follow a logical sequence for a typical workday. 3. Use appropriate error messages and handling for invalid task specifications (e.g., negative durations).","solution":"def task_summary(tasks: list) -> str: from datetime import datetime, timedelta def format_time(time_obj): return time_obj.strftime(\'%I:%M %p\') def get_task_end_time(start_time, duration): return start_time + timedelta(minutes=duration) # Initial workday start time at 9:00 AM workday_start_time = datetime.strptime(\'09:00 AM\', \'%I:%M %p\') # Sort tasks by priority and then by duration sorted_tasks = sorted(tasks, key=lambda x: (x[\'priority\'], x[\'duration\'])) summary_lines = [] current_time = workday_start_time for idx, task in enumerate(sorted_tasks): end_time = get_task_end_time(current_time, task[\'duration\']) summary_lines.append(f\\"{idx + 1}. {task[\'name\']} (Priority: {task[\'priority\']})\\") summary_lines.append(f\\" Time: {format_time(current_time)} - {format_time(end_time)}\\") current_time = end_time return \\"n\\".join(summary_lines)"},{"question":"# Question Scenario Imagine you are developing a software system to help restaurants manage and prioritize their customers\' orders. Each order has a certain amount of preparation time and a deadline by which it should be completed. To ensure customer satisfaction, it\'s critical that the orders are managed in a way that adheres to these deadlines as closely as possible. Task Write a function `schedule_orders(orders: List[Tuple[int, int]]) -> List[int]` that takes a list of tuples where each tuple represents an order with a preparation time and a deadline. The function should return a list of order indices representing the sequence in which the orders should be executed to minimize the number of missed deadlines. Input and Output formats * **Input**: * `orders`: A list of tuples where each tuple `(t, d)` consists of an integer `t` representing the preparation time in minutes and an integer `d` representing the deadline (time by which the order should be completed) in minutes from the start of the day. The orders are given in the sequence they were placed. * **Output**: * A list of indices representing the order in which the orders should be executed to minimize the number of missed deadlines. If multiple sequences are possible, return any one of them. Constraints * The number of orders is at most 100. * Each preparation time and deadline is a positive integer. * The total preparation time and deadlines are such that they allow for a feasible scheduling solution. Example ```python orders = [ (3, 10), # Order 0: takes 3 minutes, deadline at minute 10 (2, 5), # Order 1: takes 2 minutes, deadline at minute 5 (1, 2), # Order 2: takes 1 minute, deadline at minute 2 (4, 20), # Order 3: takes 4 minutes, deadline at minute 20 (5, 15) # Order 4: takes 5 minutes, deadline at minute 15 ] print(schedule_orders(orders)) # Possible Output: # [2, 1, 0, 4, 3] ``` Use the given list of orders to demonstrate the function in action and ensure that the list of indices correctly represents an optimal execution sequence.","solution":"from typing import List, Tuple def schedule_orders(orders: List[Tuple[int, int]]) -> List[int]: Schedule orders to minimize missed deadlines. Parameters: orders (List[Tuple[int, int]]): A list of tuples where each tuple contains preparation time and deadline. Returns: List[int]: A list of indices representing the optimal execution sequence. # Sort orders by deadline first, and then by preparation time sorted_orders = sorted(enumerate(orders), key=lambda x: (x[1][1], x[1][0])) order_indices = [order[0] for order in sorted_orders] return order_indices"},{"question":"# Coding Assessment Question **Problem Statement**: An Armstrong number (also known as a narcissistic number or pluperfect number) is a number that is the sum of its own digits each raised to the power of the number of digits. For example: - 153 has three digits, and (1^3 + 5^3 + 3^3 = 153), so it is an Armstrong number. - 9474 has four digits, and (9^4 + 4^4 + 7^4 + 4^4 = 9474), so it is an Armstrong number. Write a function that checks if a given number is an Armstrong number and within the given range return all Armstrong numbers. **Function Signature**: ```python def find_armstrong_numbers(start: int, end: int) -> List[int]: pass ``` **Input**: - `start` (int): The starting range of the number (inclusive). - `end` (int): The ending range of the number (inclusive). **Output**: - (List[int]): A list of Armstrong numbers between the start and end range. **Constraints**: - 1 ≤ start ≤ end ≤ 100000 **Examples**: ```python >>> find_armstrong_numbers(1, 1000) [1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407] >>> find_armstrong_numbers(1000, 10000) [1634, 8208, 9474] ``` **Guidelines**: * Use an efficient method to check if a number is an Armstrong number. * Ensure your function handles the edge cases where start and end are very close or far apart. * Write clear, readable code, and include comments explaining key parts of your implementation. * Test your function to ensure it performs well within the given constraints.","solution":"def find_armstrong_numbers(start: int, end: int) -> list: Finds all Armstrong numbers in the given range from start to end (inclusive). Parameters: - start (int): the starting number of the range (inclusive). - end (int): the ending number of the range (inclusive). Returns: - List[int]: a list of Armstrong numbers in the range. def is_armstrong(number: int) -> bool: digits = [int(d) for d in str(number)] num_digits = len(digits) return sum(d**num_digits for d in digits) == number return [num for num in range(start, end + 1) if is_armstrong(num)]"},{"question":"Question [Question 2]: # Implementing a Decision Tree Classifier with Pruning You are tasked with implementing a simple decision tree classifier with an additional functionality of post-pruning to avoid overfitting. Your task is to build the decision tree classifier based on the provided requirements and thereafter incorporate the logic for pruning. # Requirements: 1. Implement a `DecisionTreeClassifier` class with methods for fitting (training) and predicting. 2. The tree should be built using the ID3 algorithm for split criteria based on Information Gain. 3. Implement a post-pruning strategy based on a validation set to decide whether to keep or prune a subtree. 4. Ensure the classifier can handle both numerical and categorical features. 5. Provide appropriate documentation and tests for your implementation. # Constraints: * Ensure that the maximum depth of the tree can be adjusted. * Data might contain missing values; handle them appropriately. * Assume that the number of observations in the dataset is reasonably small (e.g., less than 2000) considering computational complexity. * You should not use external libraries beyond NumPy and Pandas. # Input Format: You will receive: * A list of `observations` where each observation is a dictionary with features as keys and corresponding values. * A list of `classes` corresponding to each observation. * A `validation_set` containing observation-class pairs to use for post-pruning. # Output Format: The classifier should: * Fit the model using the provided observations and classes. * Predict the class for new given observations. # Example Usage: ```python # Sample training data observations = [ {\\"feature1\\": 1, \\"feature2\\": \\"A\\"}, {\\"feature1\\": 2, \\"feature2\\": \\"B\\"}, {\\"feature1\\": 3, \\"feature2\\": \\"A\\"}, {\\"feature1\\": 4, \\"feature2\\": \\"B\\"}, ] classes = [1, 0, 1, 0] # Sample validation data for pruning validation_set = [ ({\\"feature1\\": 2, \\"feature2\\": \\"A\\"}, 1), ({\\"feature1\\": 3, \\"feature2\\": \\"B\\"}, 0), ] # Creating instance of DecisionTreeClassifier dt = DecisionTreeClassifier(max_depth=3) dt.fit(observations, classes, validation_set) print(dt.predict({\\"feature1\\": 1, \\"feature2\\": \\"A\\"})) # Output: 1 or 0 print(dt.predict({\\"feature1\\": 4, \\"feature2\\": \\"B\\"})) # Output: 1 or 0 ``` Implement the decision tree ID3 algorithm and integrate a post-pruning strategy to improve the performance and reduce overfitting.","solution":"import numpy as np import pandas as pd from collections import Counter class DecisionTreeClassifier: def __init__(self, max_depth=5): self.max_depth = max_depth self.tree = None def fit(self, observations, classes, validation_set=None): # Convert data to a DataFrame data = pd.DataFrame(observations) data[\'class\'] = classes self.tree = self._build_tree(data, depth=0) if validation_set: self._post_prune(self.tree, validation_set) def predict(self, observation): node = self.tree while isinstance(node, dict): feature = list(node.keys())[0] node = node[feature].get(observation.get(feature), node[feature][None]) return node def _build_tree(self, data, depth): if len(set(data[\'class\'])) == 1 or depth == self.max_depth: return Counter(data[\'class\']).most_common(1)[0][0] best_feature = self._find_best_split(data) tree = {best_feature: {}} for value in data[best_feature].unique(): sub_data = data[data[best_feature] == value] sub_tree = self._build_tree(sub_data.drop(columns=[best_feature]), depth + 1) tree[best_feature][value] = sub_tree tree[best_feature][None] = Counter(data[\'class\']).most_common(1)[0][0] return tree def _find_best_split(self, data): best_feature = None best_info_gain = -1 for feature in data.columns[:-1]: info_gain = self._information_gain(data, feature) if info_gain > best_info_gain: best_info_gain = info_gain best_feature = feature return best_feature def _entropy(self, data): probs = data.value_counts(normalize=True) return -sum(probs * np.log2(probs)) def _information_gain(self, data, feature): original_entropy = self._entropy(data[\'class\']) values, counts = np.unique(data[feature], return_counts=True) weighted_entropy = sum((counts[i]/len(data) * self._entropy(data[data[feature] == values[i]][\'class\']) for i in range(len(values)))) return original_entropy - weighted_entropy def _post_prune(self, tree, validation_set): def prune(node, validation_set): if not isinstance(node, dict): return node feature = list(node.keys())[0] for value in node[feature].keys(): if node[feature][value] is not None: node[feature][value] = prune(node[feature][value], [(obs, cls) for obs, cls in validation_set if obs.get(feature) == value]) # Calculate accuracy of pruned vs non-pruned tree on validation set if all(not isinstance(subtree, dict) for subtree in node[feature].values()): current_accuracy = self._accuracy(node, validation_set) majority_class = Counter(cls for obs, cls in validation_set).most_common(1)[0][0] pruned_accuracy = sum(cls == majority_class for obs, cls in validation_set) / len(validation_set) if pruned_accuracy >= current_accuracy: return majority_class return node self.tree = prune(tree, validation_set) def _accuracy(self, subtree, validation_set): correct = 0 for obs, cls in validation_set: prediction = subtree while isinstance(prediction, dict): feature = list(prediction.keys())[0] prediction = prediction[feature].get(obs.get(feature), prediction[feature][None]) if prediction == cls: correct += 1 return correct / len(validation_set)"},{"question":"# Coding Assessment Question Scenario You are designing a data structures library and wish to evaluate students\' capability to work with tree structures. To assess this, you decide to examine their ability to implement a function that finds the lowest common ancestor (LCA) of two nodes in a binary search tree (BST). Task Implement a function `find_lca` that finds the lowest common ancestor of two given nodes in a binary search tree. Function Signature ```python def find_lca(root: TreeNode, node1: int, node2: int) -> TreeNode: ``` Parameters - `root`: A `TreeNode` object representing the root of the binary search tree. - `node1`: An integer representing the value of the first node. - `node2`: An integer representing the value of the second node. Requirements 1. Traverse the BST to find the node containing `node1` and the node containing `node2`. 2. Determine the lowest common ancestor of these two nodes. 3. The function should handle edge cases such as when one or both nodes are not present in the tree. 4. The function should return the `TreeNode` representing the LCA, or `None` if one or both nodes are not present. Example Usage ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example Tree # 5 # / # 3 8 # / # 2 4 10 root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(8) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right.right = TreeNode(10) lca = find_lca(root, 2, 4) print(f\\"Lowest common ancestor of 2 and 4: {lca.val if lca else \'None\'}\\") # Output: 3 lca = find_lca(root, 2, 10) print(f\\"Lowest common ancestor of 2 and 10: {lca.val if lca else \'None\'}\\") # Output: 5 ``` Constraints - The binary search tree contains unique values. - The tree can be empty; handle such edge cases gracefully. Performance Requirements - The function should be efficient with a time complexity of O(h), where h is the height of the tree. - Minimize the number of traversals of the tree to ensure optimal performance.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_lca(root: TreeNode, node1: int, node2: int) -> TreeNode: # Base case: if root is None, return None if not root: return None # If both node1 and node2 are smaller than root, then LCA lies in the left subtree if node1 < root.val and node2 < root.val: return find_lca(root.left, node1, node2) # If both node1 and node2 are greater than root, then LCA lies in the right subtree elif node1 > root.val and node2 > root.val: return find_lca(root.right, node1, node2) # If one of the node values is equal to root\'s value or node1 and node2 lie on either side of the root else: return root"},{"question":"# Coding Question Introduction: Matrix traversal is a common problem in computer science and has many applications in various domains like graphics, image processing, and grid-based games. In this exercise, you will implement a function to find the maximum sum of values along a path from the top-left to the bottom-right corner of a grid, where you can only move right or down. Task: Write a function `max_path_sum` that takes a 2D list of integers `grid` as input and returns the maximum sum of values along any path from the top-left corner to the bottom-right corner of the grid. The movement is restricted to either right or down at each step. Function Signature: ```python def max_path_sum(grid: List[List[int]]) -> int: ``` Input: - `grid`: A 2D list of integers representing the grid (1 <= len(grid), len(grid[0]) <= 100). - Each element in the grid will be an integer (-100 <= grid[i][j] <= 100). Output: - An integer representing the maximum sum of values along any valid path from the top-left to the bottom-right corner. Constraints: - The grid will always have at least one row and one column. - Both the starting cell (top-left corner) and the ending cell (bottom-right corner) are included in the path. Example: ```python # Example call grid = [ [5, 3, 2, 1], [1, 2, 1, 6], [7, 1, 6, 5], [9, 1, 5, 6] ] result = max_path_sum(grid) # Example output # 34 # Explanation: # The path with the maximum sum is 5 -> 7 -> 9 -> 1 -> 5 -> 6, with a total sum of 34. ``` Notes: 1. Implement a dynamic programming approach to keep track of the maximum sum path efficiently. 2. Handle edge cases, such as grids with only one row or one column. 3. Ensure your function runs efficiently within the given constraints. 4. You may assume that the input grid is always a valid, non-empty list of lists.","solution":"from typing import List def max_path_sum(grid: List[List[int]]) -> int: Returns the maximum sum of values along any path from the top-left corner to the bottom-right corner of the grid. Moves allowed are only right and down. rows, cols = len(grid), len(grid[0]) # Initialize a DP table with the same dimensions as the grid dp = [[0] * cols for _ in range(rows)] # Start point dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the DP table for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner will have the result return dp[rows-1][cols-1]"},{"question":"# Problem Statement You are tasked with implementing a basic singly linked list and a function to remove elements that have a specified value. Your goal is to complete the `remove_elements` function that takes the head of a linked list and an integer value, and removes all nodes that have the specified value from the list. # Requirements: 1. Complete the `remove_elements` function. The function should remove all nodes with the specified value. 2. Your function should handle edge cases gracefully, such as: - The list is empty. - The list has only one element, which is the value to be removed. 3. Implement efficient handling such that the function runs in linear time O(n) and uses constant space O(1). # Function Signature ```python def remove_elements(head: Node | None, value: int) -> Node | None: pass ``` # Examples: ```python >>> head = insert_node(None, 1) >>> head = insert_node(head, 2) >>> head = insert_node(head, 6) >>> head = insert_node(head, 3) >>> head = insert_node(head, 4) >>> head = insert_node(head, 5) >>> head = insert_node(head, 6) >>> new_head = remove_elements(head, value=6) >>> print_linked_list(new_head) 1->2->3->4->5 >>> new_head = remove_elements(None, value=1) ValueError: The linked list is empty. >>> head = insert_node(None, 6) >>> new_head = remove_elements(head, value=6) None ``` # Input Constraints: - `head`: The head of a singly linked list. Each `Node` contains an integer `data` and a reference `next_node` to the next `Node`. - `value`: An integer representing the value to remove from the linked list. (-10^3 ≤ `value` ≤ 10^3) # Notes: 1. You should not use any additional libraries or data structures. 2. Consider efficiency in both time and space complexity. 3. Handle edge cases as mentioned in the analysis. # Provided Code: ```python from dataclasses import dataclass @dataclass class Node: data: int next_node: Node | None = None def insert_node(head: Node | None, data: int) -> Node: new_node = Node(data) if head is None: return new_node temp_node = head while temp_node.next_node: temp_node = temp_node.next_node temp_node.next_node = new_node return head def remove_elements(head: Node | None, value: int) -> Node | None: pass def print_linked_list(head: Node | None) -> None: if head is None: return while head.next_node is not None: print(head.data, end=\\"->\\") head = head.next_node print(head.data) ``` Complete the `remove_elements` function based on the provided analysis and requirements.","solution":"from dataclasses import dataclass from typing import Union, Optional @dataclass class Node: data: int next_node: Optional[\'Node\'] = None def insert_node(head: Optional[Node], data: int) -> Node: new_node = Node(data) if head is None: return new_node temp_node = head while temp_node.next_node: temp_node = temp_node.next_node temp_node.next_node = new_node return head def remove_elements(head: Optional[Node], value: int) -> Optional[Node]: dummy_head = Node(0) dummy_head.next_node = head current = dummy_head while current.next_node: if current.next_node.data == value: current.next_node = current.next_node.next_node else: current = current.next_node return dummy_head.next_node def print_linked_list(head: Optional[Node]) -> None: if head is None: print(\\"None\\") return while head.next_node is not None: print(head.data, end=\\"->\\") head = head.next_node print(head.data)"},{"question":"# Coding Assessment Question **Context**: You are developing an inventory management system for a warehouse. Part of the requirement is to track shipments coming in and going out, and generate reports to show the current stock level of each item. **Task**: Implement a function `update_inventory` that takes two lists of tuples. The first list, `current_inventory`, contains the current stock level of items in the warehouse, and the second list, `shipment_data`, contains the items being added or removed from the inventory. # Function Signature ```python def update_inventory(current_inventory: list, shipment_data: list) -> dict: ``` # Input * `current_inventory` (list): A list of tuples where each tuple contains: * `item_name` (str): The name of the item. * `quantity` (int): The quantity of the item in stock. * `shipment_data` (list): A list of tuples where each tuple contains: * `item_name` (str): The name of the item. * `quantity` (int): The quantity of the item being added (positive value) or removed (negative value). # Output * A dictionary where each key is the item name (str) and the value is the updated quantity (int) after processing the shipments. Items with zero or negative quantity should not be included in the final inventory. # Constraints * All item names are non-empty strings. * Quantity values in `current_inventory` and `shipment_data` are integers. * The same item can appear multiple times in both lists. * Handle the case where an item in the `shipment_data` does not exist in the `current_inventory`. # Example ```python current_inventory = [ (\\"apple\\", 50), (\\"banana\\", 20), (\\"orange\\", 75) ] shipment_data = [ (\\"apple\\", 10), (\\"banana\\", -5), (\\"orange\\", -100), (\\"grape\\", 30) ] result = update_inventory(current_inventory, shipment_data) # Expected Output Example: # { # \\"apple\\": 60, # \\"banana\\": 15, # \\"grape\\": 30 # } ``` # Notes 1. Ensure the function handles the case where an item\'s shipment quantity results in zero or negative stock, and such items should be removed from the final dictionary. 2. Consider edge cases like items appearing multiple times in shipment data and/or current inventory. 3. Use efficient algorithms to process the lists as these could become large.","solution":"def update_inventory(current_inventory: list, shipment_data: list) -> dict: Updates the warehouse inventory based on the shipment data. Args: - current_inventory (list of tuples): The current stock levels. - shipment_data (list of tuples): The shipment data containing items added or removed. Returns: - dict: The updated dictionary of item stock levels. inventory_dict = {} for item, quantity in current_inventory: if item in inventory_dict: inventory_dict[item] += quantity else: inventory_dict[item] = quantity for item, quantity in shipment_data: if item in inventory_dict: inventory_dict[item] += quantity else: inventory_dict[item] = quantity # Remove items with zero or negative inventory final_inventory = {item: qty for item, qty in inventory_dict.items() if qty > 0} return final_inventory"},{"question":"# Question You need to implement a function `find_duplicated_numbers` that finds all the elements that appear more than once in a given list of integers. The resultant list should contain no duplicates and be sorted in ascending order. # Function Signature ```python def find_duplicated_numbers(nums: list[int]) -> list[int]: ``` # Input * `nums` (1 ≤ len(nums) ≤ 1000): A list of integers where each integer can be from `-1000` to `1000`. # Output * Returns a list of integers representing the elements that appear more than once in the given list, sorted in ascending order. # Example ```python assert find_duplicated_numbers([4, 3, 2, 7, 8, 2, 3, 1]) == [2, 3] assert find_duplicated_numbers([1, 1, 2]) == [1] assert find_duplicated_numbers([1]) == [] ``` # Constraints * The solution should aim for linear time complexity O(n) and should not use more than O(n) additional space. * The list can contain both positive and negative integers and duplicates. # Notes * You may use any available standard libraries for sorting. * Be mindful of edge cases such as empty lists and lists with no duplicates.","solution":"def find_duplicated_numbers(nums: list[int]) -> list[int]: Returns a list of elements that appear more than once in the given list, sorted in ascending order. if not nums: return [] num_count = {} for num in nums: if num in num_count: num_count[num] += 1 else: num_count[num] = 1 result = [num for num, count in num_count.items() if count > 1] result.sort() return result"},{"question":"# Scenario An online learning platform is offering scholarships to students based on their performance across multiple courses. Each student has a priority ranking for the courses they prefer, and each course has limited spots available for scholarships. The platform needs an algorithm to distribute scholarships optimally, considering both students\' preferences and course capacities. # Problem Given the priority rankings of students and the capacities of courses, implement the function `optimal_scholarship_distribution(student_pref: list[list[int]], course_capacities: list[int]) -> list[list[int]]` to assign students to courses in an optimal manner that maximizes overall student satisfaction within the course capacity constraints. Input * `student_pref`: A list of lists. Each sublist represents a student\'s ranked preferences for courses. * `course_capacities`: A list of integers where each value represents the maximum number of students that the corresponding course can enroll. Output * A list of lists where each sublist contains the indices of students assigned to that course. Constraints * The length of `course_capacities` will be equal to the number of unique courses in `student_pref`. * The total number of students will not exceed the sum of all course capacities. * Each student\'s preference list will contain unique integers within the valid range of course indices. # Example ```python def optimal_scholarship_distribution(student_pref: list[list[int]], course_capacities: list[int]) -> list[list[int]]: # Function body here # Example data student_pref = [[0, 2, 1], [1, 2, 0], [1, 0, 2], [2, 0, 1]] course_capacities = [1, 2, 1] result = optimal_scholarship_distribution(student_pref, course_capacities) print(result) # Should print a list of lists such as [[0], [2, 1], [3]] ``` Performance Requirement * The solution must run in O(nm) time complexity, where n is the number of students and m is the number of courses. # Note Ensure that the implemented function distributes scholarships optimally, respecting both the students\' preferences and the predefined capacities of each course. Students should be assigned in a way that maximizes the overall satisfaction based on their priority rankings.","solution":"def optimal_scholarship_distribution(student_pref, course_capacities): Distributes scholarships optimally based on students\' preferences and course capacities. :param student_pref: List of lists where each sublist represents a student\'s ranked preferences for courses. :param course_capacities: List of integers where each value represents the maximum number of students for the corresponding course. :return: A list of lists where each sublist contains the indices of students assigned to that course. from collections import deque, defaultdict n_students = len(student_pref) m_courses = len(course_capacities) # Initialize students\' queue student_queue = deque(range(n_students)) # Initialize preferences counters for students student_choice_index = [0] * n_students # Initialize course assignment and count course_assignment = defaultdict(list) course_count = [0] * m_courses while student_queue: student = student_queue.popleft() choice_index = student_choice_index[student] if choice_index < len(student_pref[student]): preferred_course = student_pref[student][choice_index] if course_count[preferred_course] < course_capacities[preferred_course]: course_assignment[preferred_course].append(student) course_count[preferred_course] += 1 else: student_choice_index[student] += 1 student_queue.append(student) # Convert defaultdict to list of lists result = [[] for _ in range(m_courses)] for course, students in course_assignment.items(): result[course] = students return result"},{"question":"# Partitioning an Array to Minimize Maximum Subarray Sum Problem Description: You are tasked with partitioning an array into `k` or fewer non-empty continuous subarrays such that the maximum sum among these subarrays is minimized. Write two functions: one to implement this partitioning and another to help visualize the resulting partitions. Function Signatures: ```python def partition_array(arr: List[int], k: int) -> int: Partitions an array into `k` or fewer non-empty continuous subarrays to minimize the maximum subarray sum. Args: - arr (List[int]): A list of integers representing the array to be partitioned. - k (int): The maximum number of partitions allowed. Returns: - int: The minimized maximum sum among the `k` or fewer subarrays. pass def visualize_partitions(arr: List[int], k: int) -> List[List[int]]: Partitions an array into `k` or fewer non-empty continuous subarrays and returns the partitions. Args: - arr (List[int]): A list of integers representing the array to be partitioned. - k (int): The maximum number of partitions allowed. Returns: - List[List[int]]: A list of lists where each inner list is a partitioned subarray. pass ``` Input: - For `partition_array` and `visualize_partitions`: - `arr`: A list of integers representing the array to be partitioned. - `k`: An integer representing the maximum number of partitions allowed. Output: - For `partition_array`: An integer representing the minimized maximum sum among the `k` or fewer subarrays. - For `visualize_partitions`: A list of lists where each inner list is a partitioned subarray. Constraints: - The length of `arr` is between 1 and 1000 inclusive. - Each element in `arr` is between -10^5 and 10^5 inclusive. - `k` is a positive integer less than or equal to the length of `arr`. Performance Requirements: - The functions should handle large and varied inputs efficiently. - Minimize time complexity to handle edge cases effectively, balancing between binary search and dynamic programming approaches. Example: ```python # Example usage of the functions. array = [7, 2, 5, 10, 8] max_partitions = 2 # Get the minimized maximum subarray sum minimized_max_sum = partition_array(array, max_partitions) print(\\"Minimized Maximum Subarray Sum:\\", minimized_max_sum) # Output might be 18 # Visualize the resulting partitions partitions = visualize_partitions(array, max_partitions) print(\\"Partitioned Subarrays:\\", partitions) # Output might be [[7, 2, 5], [10, 8]] ``` By creating a question that asks for practical functionality, visualization, and algorithmic thinking, you effectively ensure it aligns with the skill validation objectives of the assessment.","solution":"def partition_array(arr, k): Partitions an array into `k` or fewer non-empty continuous subarrays to minimize the maximum subarray sum. Args: - arr (List[int]): A list of integers representing the array to be partitioned. - k (int): The maximum number of partitions allowed. Returns: - int: The minimized maximum sum among the `k` or fewer subarrays. def canPartition(max_sum): current_sum = 0 partition_count = 1 for num in arr: if current_sum + num > max_sum: partition_count += 1 current_sum = num if partition_count > k: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if canPartition(mid): right = mid else: left = mid + 1 return left def visualize_partitions(arr, k): Partitions an array into `k` or fewer non-empty continuous subarrays and returns the partitions. Args: - arr (List[int]): A list of integers representing the array to be partitioned. - k (int): The maximum number of partitions allowed. Returns: - List[List[int]]: A list of lists where each inner list is a partitioned subarray. def canPartitionWithResult(max_sum): current_sum = 0 current_partition = [] partitions = [] for num in arr: if current_sum + num > max_sum: partitions.append(current_partition) current_partition = [num] current_sum = num else: current_partition.append(num) current_sum += num partitions.append(current_partition) return partitions min_max_sum = partition_array(arr, k) return canPartitionWithResult(min_max_sum)"},{"question":"# Question: Implementing Depth-First Search on a Directed Graph Write a Python function to perform a depth-first search (DFS) on a directed graph and return the order of vertices visited during the traversal starting from a given start vertex. If the start vertex is not in the graph, return an empty list. If there are multiple valid traversal orders, any one of them is acceptable. Function Signature: ```python def depth_first_search(graph: dict, start_vertex: int) -> list: ``` # Input - `graph`: a dictionary where keys are vertices and values are lists of adjacent vertices. The graph is directed, so if vertex `u` is in the adjacency list of vertex `v`, then `v` is not necessarily in the adjacency list of `u`. - `start_vertex`: the vertex from which to start the depth-first search. # Output - Return a list representing the order of vertices visited during the depth-first search starting from `start_vertex`. If `start_vertex` is not in the graph, return an empty list. # Constraints - The number of vertices will not exceed `1000`. # Example ```python graph1 = {0: [1, 2], 1: [2, 3], 2: [3], 3: [], 4: [4]} assert depth_first_search(graph1, 0) == [0, 1, 2, 3] graph2 = {1: [2], 2: [3], 3: [1], 4: []} assert depth_first_search(graph2, 1) == [1, 2, 3] graph3 = {0: [1], 1: [2], 2: [0], 3: [4], 4: []} assert depth_first_search(graph3, 3) == [3, 4] graph4 = {0: [1, 2], 1: [3], 2: [], 3: [2]} assert depth_first_search(graph4, 0) == [0, 1, 3, 2] ``` # Notes - Ensure that your solution can handle graphs with cycles and self-loops. - Test with graphs containing isolated nodes and verify your solution against multiple test cases to validate its correctness. - Optimize your implementation for performance and memory usage.","solution":"def depth_first_search(graph: dict, start_vertex: int) -> list: Perform a depth-first search (DFS) on a directed graph starting from start_vertex. Parameters: graph (dict): A dictionary representing the adjacency list of the graph. start_vertex (int): The starting vertex for DFS. Returns: list: The order of vertices visited during the DFS. if start_vertex not in graph: return [] visited = set() result = [] def dfs(v): if v in visited: return visited.add(v) result.append(v) for neighbor in graph.get(v, []): dfs(neighbor) dfs(start_vertex) return result"},{"question":"# Question: Find Unique Element in List Given an array of integers where every element appears twice except for one, write a function to find that unique element. Your algorithm should have a linear runtime complexity and should be implemented without using extra memory. **Function Signature**: `def find_unique_element(nums: List[int]) -> int:` **Input**: - An array of integers `nums` where `1 <= len(nums) <= 3 * 10^4` and every element appears twice except for one. **Output**: - Return the integer that appears only once. **Constraints**: - The implemented function should not use extra memory (i.e., O(1) space complexity). - Assume all numbers in the input are non-negative integers. **Example**: ```python assert find_unique_element([2, 2, 1]) == 1 assert find_unique_element([4, 1, 2, 1, 2]) == 4 assert find_unique_element([1]) == 1 assert find_unique_element([17, 15, 15, 17, 16]) == 16 assert find_unique_element([9, 3, 9, 3, 7, 5, 5]) == 7 ``` **Notes**: 1. Think about how you can leverage properties of XOR to achieve the desired results in linear time and constant space. 2. Ensure the function handles all given constraints efficiently. 3. Consider edge cases such as arrays with only one element or arrays where the unique element is the largest or smallest integer in the array. Implement your solution in the following function definition: ```python def find_unique_element(nums: List[int]) -> int: # Your code here ```","solution":"from typing import List def find_unique_element(nums: List[int]) -> int: Finds the unique element in a list where every other element appears exactly twice. Uses XOR to achieve O(n) time complexity and O(1) space complexity. Args: nums: List of integers where each integer except one appears twice. Returns: int: The unique element that appears only once. unique_element = 0 for num in nums: unique_element ^= num return unique_element"},{"question":"# Sum of All Even Fibonacci Numbers Objective Implement a function to compute the sum of all even Fibonacci numbers that do not exceed a given threshold. The Fibonacci sequence is defined as: - `F(1) = 1` and `F(2) = 1` - For `n > 2`: `F(n) = F(n-1) + F(n-2)` Your task is to sum all the even Fibonacci numbers that are less than or equal to the provided threshold. Input You will implement a function `sum_even_fibonacci(threshold: int) -> int`, which: - Takes an integer `threshold` as input. - Assumes `threshold` is a positive integer greater than or equal to 2. Output The function should return the sum of all even Fibonacci numbers that do not exceed the `threshold`. Constraints - `2 <= threshold <= 10^18` Example ```python def sum_even_fibonacci(threshold: int) -> int: # Your code here # Example test cases print(sum_even_fibonacci(10)) # Output: 10 print(sum_even_fibonacci(34)) # Output: 44 print(sum_even_fibonacci(100)) # Output: 44 print(sum_even_fibonacci(4000000)) # Output: 4613732 ``` Notes - Your implementation should be efficient and avoid unnecessary computations. - Consider edge cases such as when the threshold is very small or very large. Good luck, and happy coding!","solution":"def sum_even_fibonacci(threshold: int) -> int: Computes the sum of all even Fibonacci numbers that do not exceed the given threshold. a, b = 1, 2 total_sum = 0 while a <= threshold: if a % 2 == 0: total_sum += a a, b = b, a + b return total_sum"},{"question":"# Your Task You need to implement a function that calculates the distance of a point from the origin in a 2D plane, and a function that sorts a list of such points based on their distance from the origin. # Detailed Requirements 1. **Calculate Distance**: * Implement the `distance_from_origin` function that takes two integers representing the x and y coordinates of a point and returns the Euclidean distance of the point from the origin. 2. **Sort Points by Distance**: * Implement the `sort_points` function that takes a list of tuples, where each tuple contains two integers representing the coordinates of a point in a 2D plane and returns a list of tuples sorted by their distance from the origin in ascending order. # Input and Output Format Function Signatures ```python import math from typing import List, Tuple def distance_from_origin(x: int, y: int) -> float: Computes the Euclidean distance of a point (x, y) from the origin (0, 0). :param x: int - The x-coordinate of the point :param y: int - The y-coordinate of the point :return: float - The distance from the origin pass def sort_points(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Sorts a list of points (tuples) based on their distance from the origin (0, 0) in ascending order. :param points: List[Tuple[int, int]] - The list of points to sort :return: List[Tuple[int, int]] - The list of points sorted by distance from the origin pass ``` Constraints * The input list can contain up to 10^5 points. * Each point is represented as a tuple of two integers. * Coordinates are in the range [-10^6, 10^6]. Examples ```python # Distance Calculation >>> distance_from_origin(3, 4) 5.0 >>> distance_from_origin(-3, -4) 5.0 # Sorting Points >>> sort_points([(3, 4), (1, 1), (-1, -1), (0, 0)]) [(0, 0), (1, 1), (-1, -1), (3, 4)] ``` # Performance Requirements * Your solution should efficiently handle lists of up to 10^5 points and should aim for a time complexity of no worse than O(n log n).","solution":"import math from typing import List, Tuple def distance_from_origin(x: int, y: int) -> float: Computes the Euclidean distance of a point (x, y) from the origin (0, 0). :param x: int - The x-coordinate of the point :param y: int - The y-coordinate of the point :return: float - The distance from the origin return math.sqrt(x**2 + y**2) def sort_points(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Sorts a list of points (tuples) based on their distance from the origin (0, 0) in ascending order. :param points: List[Tuple[int, int]] - The list of points to sort :return: List[Tuple[int, int]] - The list of points sorted by distance from the origin return sorted(points, key=lambda point: distance_from_origin(point[0], point[1]))"},{"question":"# Question: Intersecting Sorted Arrays Write a function `intersect_sorted_arrays` that takes two sorted lists as input and returns a sorted list of elements that are common to both input lists. The resulting list should not contain any duplicates, and it should maintain the sorted order. Requirements: 1. Write a function `intersect_sorted_arrays` that accepts two parameters: `list1` and `list2`, each being a sorted list of integers. 2. The function should return a sorted list containing the intersection of the two input lists without any duplicates. Function Signature: ```python def intersect_sorted_arrays(list1: list[int], list2: list[int]) -> list[int]: pass ``` Input: * `list1` – A sorted list of integers. * `list2` – Another sorted list of integers. Output: * A sorted list of integers representing the intersection of the input lists, with no duplicates. Constraints: * Each list can have up to `10^4` elements. * The elements in each list are in sorted order, and the values range from `-10^5` to `10^5`. Example Usage: ```python >>> print(intersect_sorted_arrays([1, 2, 2, 3, 4], [2, 2, 4, 4, 6])) [2, 4] >>> print(intersect_sorted_arrays([1, 1, 2, 5, 12], [2, 4, 5, 10, 12])) [2, 5, 12] >>> print(intersect_sorted_arrays([], [1, 2, 3])) [] >>> print(intersect_sorted_arrays([-5, -3, 0, 2, 4], [-4, -3, 1, 2, 3, 4])) [-3, 2, 4] ``` # Explanation * In the first example, the common elements between the two lists are `2` and `4`, and they appear in the output list in sorted order. * In the second example, the common elements are `2`, `5`, and `12`, all appearing once in the sorted output list. * For the third example, one of the lists is empty, so the intersection is an empty list. * In the fourth example, the common elements are `-3`, `2`, and `4`, following the sort order of the input lists. Ensure efficiency and correct handling of edge cases.","solution":"def intersect_sorted_arrays(list1: list[int], list2: list[int]) -> list[int]: Returns a sorted list of the intersection of two sorted lists without duplicates. intersection = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] == list2[j]: if not intersection or list1[i] != intersection[-1]: intersection.append(list1[i]) i += 1 j += 1 elif list1[i] < list2[j]: i += 1 else: j += 1 return intersection"},{"question":"# Task: You need to implement a function to calculate the moving average of stock prices over a specified period. # Function Signature: ```python def calculate_moving_average(prices: List[float], period: int) -> List[float]: pass ``` # Description: Your task is to write a function `calculate_moving_average` that computes the moving average of stock prices over a given period. The moving average is a statistical calculation used to analyze data points by creating a series of averages of different subsets of the full data set. # Requirements: 1. **Input**: - `prices`: A list of floats representing the stock prices over time. - `period`: An integer representing the period over which to calculate the moving average. 2. **Output**: - A list of floats where each element is the moving average of the stock prices for the given period. 3. **Constraints**: - The list of prices will have at least one element. - The period will be a positive integer less than or equal to the length of the prices list. 4. **Performance**: - The function should efficiently handle large lists of prices. # Example: ```python prices = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0] period = 3 print(calculate_moving_average(prices, period)) # Output: [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0] ``` # Hints: - To compute the moving average, sum the elements of the subset and divide by the period. - You can efficiently manage the calculations by avoiding redundant summations. - Edge cases: Consider what happens when the period is 1 (the output should be the same as the input prices) or when the prices list is very short.","solution":"from typing import List def calculate_moving_average(prices: List[float], period: int) -> List[float]: This function calculates the moving average of stock prices over a specified period. Parameters: - prices (List[float]): A list of floats representing stock prices. - period (int): An integer representing the period over which to calculate the moving average. Returns: - List[float]: A list of floats representing the moving average of stock prices. if period == 1: return prices.copy() moving_averages = [] current_sum = sum(prices[:period]) moving_averages.append(current_sum / period) for i in range(period, len(prices)): current_sum += prices[i] - prices[i - period] moving_averages.append(current_sum / period) return moving_averages"},{"question":"Problem Statement You are tasked with developing a solution to search for a target value in a rotated sorted array with distinct integers. The rotated sorted array is an array that has been sorted and then rotated at an unknown pivot. # Function to Implement ```python def search_rotated_array(nums, target): Search for a target value in a rotated sorted array. @param nums: a list of distinct integers which has been sorted and then rotated. @param target: an integer target to search for in the list. @return: the index of the target if found, otherwise -1. # Your code here pass ``` # Input and Output Formats Input - `nums`: a list of distinct integers, which is a rotated sorted array. - `target`: an integer representing the value to be searched within `nums`. Output - The function returns an integer representing the index of the target in `nums`, or `-1` if the target is not found. # Constraints - The length of `nums` will be between `1` and `10^4`. - The integer values in `nums` and `target` will be between `-10^4` and `10^4`. # Example ```python # Example Input: nums = [4, 5, 6, 7, 0, 1, 2] target = 0 # Example Output: # 4 print(search_rotated_array(nums, target)) # Example Input: nums = [4, 5, 6, 7, 0, 1, 2] target = 3 # Example Output: # -1 print(search_rotated_array(nums, target)) ``` # Notes - The array is rotated at an unknown pivot index X, meaning it is non-decreasing from `nums[0]` to `nums[X-1]` and continues from `nums[X]` to `nums[n-1]`, then loops back to `nums[0]`. - Use an efficient search algorithm with O(log n) time complexity. - Utilize binary search to take advantage of the sorted nature of the array sections.","solution":"def search_rotated_array(nums, target): Search for a target value in a rotated sorted array. @param nums: a list of distinct integers which has been sorted and then rotated. @param target: an integer target to search for in the list. @return: the index of the target if found, otherwise -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid # Check if the left half is sorted if nums[left] <= nums[mid]: # Target is in the left half if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 # Otherwise, the right half must be sorted else: # Target is in the right half if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"User Session Tracking Objective Write a Python function to analyze user sessions from a log and identify users who have session durations exceeding a given threshold. # Detailed Description **Task**: Create a function `identify_long_sessions` that processes a list of user log events and returns a list of user IDs with session durations that exceed a specified threshold. Each log event is represented as a dictionary containing the following keys: - `user_id`: unique identifier for the user. - `event`: can be either \\"login\\" or \\"logout\\". - `timestamp`: Unix timestamp of the event. Constraints: * A user session starts with a \\"login\\" event and ends with the next \\"logout\\" event. * Events are guaranteed to be in chronological order, but multiple logins without a corresponding logout are possible and should be handled appropriately. * A session duration is the difference between logout and login timestamps. * Only complete sessions (with both login and logout) should be considered. * Ensure the function efficiently processes a large number of log events. Function Signature: ```python def identify_long_sessions(logs: list, threshold: int) -> list: pass ``` # Input: * `logs`: List of dictionaries, each representing a user log event, sorted chronologically. * `threshold`: Integer representing the minimum session duration in seconds to be considered long. # Output: * List of user IDs (strings) who have at least one session exceeding the threshold duration. # Example: ```python logs = [ {\\"user_id\\": \\"abc\\", \\"event\\": \\"login\\", \\"timestamp\\": 1609459200}, {\\"user_id\\": \\"abc\\", \\"event\\": \\"logout\\", \\"timestamp\\": 1609462800}, {\\"user_id\\": \\"xyz\\", \\"event\\": \\"login\\", \\"timestamp\\": 1609459200}, {\\"user_id\\": \\"xyz\\", \\"event\\": \\"logout\\", \\"timestamp\\": 1609480800}, {\\"user_id\\": \\"abc\\", \\"event\\": \\"login\\", \\"timestamp\\": 1609502400}, {\\"user_id\\": \\"abc\\", \\"event\\": \\"logout\\", \\"timestamp\\": 1609506000}, ] threshold = 3600 # 1 hour print(identify_long_sessions(logs, threshold)) # Expected output: [\'xyz\'] ``` # Hints: * Use a dictionary to track the ongoing sessions and compute their durations efficiently. * Ensure the correct handling of multiple logins without corresponding logouts and vice versa. * Carefully manage the comparison of timestamps to correctly calculate session durations. This question tests the candidate\'s ability to handle event-driven data processing, use data structures for efficient time complexity, and deal with practical issues such as incomplete event pairs.","solution":"def identify_long_sessions(logs, threshold): sessions = {} long_sessions = set() for log in logs: user_id = log[\\"user_id\\"] event = log[\\"event\\"] timestamp = log[\\"timestamp\\"] if event == \\"login\\": sessions[user_id] = timestamp elif event == \\"logout\\" and user_id in sessions: login_time = sessions.pop(user_id) session_duration = timestamp - login_time if session_duration > threshold: long_sessions.add(user_id) return list(long_sessions)"},{"question":"**Problem Statement:** Write a function `count_triplets(arr, r)` to count the number of triplets in a given array that form a geometric progression with a given common ratio `r`. # Function Signature ```python def count_triplets(arr: list[int], r: int) -> int: ``` # Input: * **arr (list[int])**: A list of integers representing the sequence (1 ≤ len(arr) ≤ 10^5, 1 ≤ arr[i] ≤ 10^9). * **r (int)**: An integer representing the common ratio (1 ≤ r ≤ 10^9). # Output: * **int**: An integer denoting the count of triplets that form a geometric progression with the ratio `r`. # Constraints: * The list `arr` can have up to 100,000 elements. * The function should account for performance and handle the upper limits efficiently. # Example: ```python assert count_triplets([1, 4, 16, 64], 4) == 2 assert count_triplets([1, 2, 2, 4], 2) == 2 assert count_triplets([1, 3, 9, 9, 27, 81], 3) == 6 ``` # Implementation Requirements: Design a program that: 1. Using dictionaries or other appropriate data structures to efficiently track occurrences of elements. 2. Iteratively processes the list `arr`, utilizing the common ratio `r` to dynamically check and count valid triplets. 3. Ensures efficient counting without directly testing every possible triplet. # Note: Explore optimal strategies such as utilizing hashmaps for frequency counting and checking the necessary conditions for triplets as the array is processed.","solution":"def count_triplets(arr, r): v2 = {} v3 = {} count = 0 for k in arr: # When k completes the triplet if k in v3: count += v3[k] # When k can be the second element of a triplet if k in v2: if k * r not in v3: v3[k * r] = 0 v3[k * r] += v2[k] # When k is the first element of a triplet if k * r not in v2: v2[k * r] = 0 v2[k * r] += 1 return count"},{"question":"# Cyclic Array Shift Objective You are required to implement a function that performs a cyclic shift on an array of integers. The function should shift the elements of the array a specified number of positions to the right. Function Signature ```python def cyclic_shift(arr: list[int], k: int) -> list[int]: pass ``` Inputs * List of integers `arr` which represents the array to be shifted. * An integer `k` that represents the number of positions by which to shift the array to the right. Outputs * Return the shifted array as a list of integers. Constraints * (0 leq text{len(arr)} leq 10^5) * ( -10^9 leq text{arr[i]} leq 10^9 ) * (0 leq k leq 10^5) Contextual Example Consider an array with elements: ```python arr = [1, 2, 3, 4, 5] ``` and you are required to shift the array 2 positions to the right. # Requirements * Perform the cyclic shift on the array. * Ensure the function handles cases where the array length `n` is significantly smaller than `k`. Example ```python arr = [1, 2, 3, 4, 5] k = 2 ``` Output: ```python [4, 5, 1, 2, 3] # The array is shifted 2 positions to the right ``` ```python arr = [1, 2, 3] k = 4 ``` Output: ```python [3, 1, 2] # The array is shifted 4 modulo the length of the array (i.e., 4 % 3 = 1) ``` # Constraints & Hints * Consider using modulo operation to optimize the shift for values of `k` larger than the length of the array. * Ensure the function handles edge cases, such as empty arrays or arrays with a single element. * Aim for a time complexity of O(n), where n is the length of the array, by avoiding unnecessary multiple shifts. Good luck with implementing an efficient cyclic shift function!","solution":"def cyclic_shift(arr: list[int], k: int) -> list[int]: Perform a cyclic shift on an array of integers. Shifts the elements of the array \'k\' positions to the right. :param arr: List of integers to be shifted. :param k: Number of positions to shift the array. :return: The shifted array as a list of integers. n = len(arr) if n == 0: return arr k = k % n # Reduce k if it\'s larger than the array length if k == 0: return arr return arr[-k:] + arr[:-k]"},{"question":"# Dynamic Programming Path Finder You are tasked with implementing a dynamic programming solution to find the minimum cost path in a grid. The goal is to go from the top-left corner to the bottom-right corner of a grid, minimizing the cost as you move. **Input/Output:** - **Input**: The input consists of: 1. `grid` - A 2D list of positive integers representing the cost at each cell. - **Output**: The minimum cost to reach the bottom-right corner from the top-left corner of the grid. # Requirements: 1. **Move Directions**: - You can move right or down from your current cell to an adjacent cell. 2. **Grid Validation**: - Ensure `grid` is not empty and has at least one cell. - All cells contain positive integer costs. 3. **Edge Case Handling**: - Ensure proper handling of smallest grids (e.g., 1x1). # Function Signature: ```python def min_cost_path(grid: List[List[int]]) -> int: pass ``` # Example: ```python # Example usage: grid = [ [1, 3, 5], [2, 1, 2], [4, 3, 1] ] minimum_cost = min_cost_path(grid) print(minimum_cost) # Output: 7 # With grid diagnostics grid = [ [1] ] minimum_cost = min_cost_path(grid) print(minimum_cost) # Output: 1 ``` # Constraints: - The grid contains positive integers only. - Optimize for performance in handling larger grids. # Notes: - You may use a bottom-up approach to fill a `dp` table where `dp[i][j]` represents the minimum cost to reach cell `(i, j)`. - Initialize the first cell `dp[0][0]` with the cost of the starting cell and fill the table accordingly. - Return `dp[N-1][M-1]` as the result, where `N` is the number of rows and `M` is the number of columns in the grid. Good luck!","solution":"def min_cost_path(grid): Returns the minimum cost to traverse from the top-left corner to the bottom-right corner of the grid. if not grid or not grid[0]: raise ValueError(\\"The grid must have at least one cell.\\") # Retrieve the dimensions of the grid rows = len(grid) cols = len(grid[0]) # Create a 2D dp array with the same dimensions as the grid dp = [[0 for _ in range(cols)] for _ in range(rows)] # Initialize the starting point dp[0][0] = grid[0][0] # Initialize the first row (only horizontal moves) for j in range(1, cols): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize the first column (only vertical moves) for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]) # The last cell contains the minimum cost to reach the bottom-right corner return dp[rows - 1][cols - 1]"},{"question":"# Coding Assessment Question **Context**: You are developing a recommendation engine for an online book store. One of the features you need to implement is a similarity score between two books based on their genres. Each book can belong to multiple genres. You will use these genre lists to determine how similar two books are. # Task Your task is to implement a function that calculates the Jaccard similarity score between two books based on their genre lists. **Specifications**: 1. Implement the function `calculate_genre_similarity(genres_book1, genres_book2)` to calculate the Jaccard similarity between two books. - Parameters: * `genres_book1`: A list of genres (strings) for the first book. * `genres_book2`: A list of genres (strings) for the second book. - Returns: A float representing the Jaccard similarity score. - Constraints: * Both lists can have a variable number of genres. * The genres are case-sensitive and can include spaces. **Steps**: 1. Convert the lists of genres into sets. 2. Compute the intersection and union of the two sets. 3. Calculate the Jaccard similarity score as the size of the intersection divided by the size of the union. **Example**: ```python genres_book1 = [\\"Fantasy\\", \\"Adventure\\", \\"Magic\\"] genres_book2 = [\\"Magic\\", \\"Drama\\", \\"Fantasy\\"] calculate_genre_similarity(genres_book1, genres_book2) # Expected output: 0.5 ``` **Note**: - Consider edge cases where one or both genre lists might be empty and handle them appropriately. - Ensure case-sensitivity by not altering the case of the genres while processing.","solution":"def calculate_genre_similarity(genres_book1, genres_book2): Calculates the Jaccard similarity score between two books based on their genre lists. Parameters: - genres_book1: A list of genres (strings) for the first book. - genres_book2: A list of genres (strings) for the second book. Returns: A float representing the Jaccard similarity score. set1 = set(genres_book1) set2 = set(genres_book2) intersection = set1.intersection(set2) union = set1.union(set2) if len(union) == 0: return 0.0 return len(intersection) / len(union)"},{"question":"# Problem: Longest Continuous Subarray with Distinct Elements You are provided with an integer array, and you need to determine the length of the longest subarray that contains all distinct elements. The subarray should be continuous, meaning you cannot skip elements; they must appear in order. **Objective**: Your goal is to write a function `longest_distinct_subarray(arr: List[int]) -> int` that computes and returns the length of the longest subarray with all distinct elements. **Function Signature**: `def longest_distinct_subarray(arr: List[int]) -> int:` **Input**: - `arr` (List[int]): A list of integers where each number can be positive, negative, or zero. (0 ≤ len(arr) ≤ 1000, -10^5 ≤ arr[i] ≤ 10^5) **Output**: - An integer representing the length of the longest continuous subarray with all distinct elements. **Constraints**: - The subarray must be continuous. - The elements within the subarray should all be unique. **Examples**: ```python print(longest_distinct_subarray([1, 2, 1, 3, 4, 3, 5])) # Output: 4 print(longest_distinct_subarray([1, 2, 3, 4, 5, 6])) # Output: 6 print(longest_distinct_subarray([7, 7, 7, 7, 7])) # Output: 1 print(longest_distinct_subarray([])) # Output: 0 ``` **Detailed Explanation**: 1. Use a sliding window approach to track the longest subarray with distinct elements. 2. Utilize a set to keep track of elements within the current window. 3. Iterate through the array, expanding and contracting the window as necessary to maintain distinct elements. 4. Keep track of the maximum length encountered during the traversal. 5. Return the length of the longest such subarray. **Requirements**: - The solution should handle edge cases such as an empty array or an array with all identical elements. - Ensure the implementation is efficient to handle the upper constraint of the array length.","solution":"from typing import List def longest_distinct_subarray(arr: List[int]) -> int: if not arr: return 0 last_seen = {} max_length = 0 start = 0 for end, value in enumerate(arr): if value in last_seen and last_seen[value] >= start: start = last_seen[value] + 1 last_seen[value] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"# Audio Frequency Analyzer You have been provided with an implementation to analyze audio signals stored in `.wav` files. We need to enhance this functionality to filter out specific frequencies from the audio and save the filtered audio to a new file. **Task**: Extend the given audio frequency analyzer to filter out frequencies below a certain threshold and save the filtered audio to a new file named `filtered_output.wav`. # Function Signature ```python def filter_audio_frequencies(input_file: str, frequency_threshold: float) -> None: Filters out frequencies below the specified threshold from the audio file and saves the result. Args: input_file (str): Path to the input .wav file. frequency_threshold (float): Frequency threshold in Hz. Returns: None ``` # Requirements 1. **Input**: - `input_file` (str): The path to the input .wav file containing the audio signal. - `frequency_threshold` (float): The threshold frequency in Hz. Frequencies below this threshold should be filtered out. 2. **Output**: - Saves the filtered audio to a file named `filtered_output.wav` in the same directory as the input file. # Instructions 1. Use a suitable Python library to read the `.wav` file and convert the audio signal to the frequency domain using Fast Fourier Transform (FFT). 2. Filter out frequencies below the specified `frequency_threshold`. 3. Convert the filtered signal back to the time domain using Inverse Fast Fourier Transform (IFFT). 4. Save the filtered audio signal to a new file named `filtered_output.wav`. 5. Ensure that the output file has the same sample rate as the input file. 6. Handle and log any errors gracefully including file not found, incorrect file format, or potential I/O issues. # Constraints: - The input `.wav` file will be a single-channel audio (mono). - The file size does not exceed 100MB. - The implementation should handle a variety of frequency thresholds ranging from 0 Hz to half the sample rate of the audio file. # Performance - Optimize for minimal memory usage and efficient processing of FFT and IFFT. # Example ```python >>> filter_audio_frequencies(\\"input.wav\\", 500.0) ``` This should create a new file named `filtered_output.wav` with the frequencies below 500 Hz removed from the original audio signal. Ensure your solution handles standard edge cases and avoids common performance pitfalls.","solution":"import numpy as np from scipy.io import wavfile import logging def filter_audio_frequencies(input_file: str, frequency_threshold: float) -> None: try: # Read the input wav file sample_rate, data = wavfile.read(input_file) # Check if the audio is mono if len(data.shape) != 1: raise ValueError(f\\"Inpput file {input_file} is not a mono audio file.\\") # Perform Fast Fourier Transform (FFT) fft_data = np.fft.fft(data) frequencies = np.fft.fftfreq(len(fft_data), 1/sample_rate) # Filter out frequencies below the specified threshold filtered_fft_data = np.where(np.abs(frequencies) < frequency_threshold, 0, fft_data) # Perform Inverse Fast Fourier Transform (IFFT) filtered_data = np.fft.ifft(filtered_fft_data).real.astype(data.dtype) # Save the filtered audio to a new file output_file = \\"filtered_output.wav\\" wavfile.write(output_file, sample_rate, filtered_data) except FileNotFoundError: logging.error(f\\"The file {input_file} was not found.\\") except ValueError as ve: logging.error(str(ve)) except Exception as e: logging.error(f\\"An error occurred while processing the file: {e}\\")"},{"question":"# Unique Substrings Challenge Objective Write a Python function that returns a list of all unique substrings of a given string that are of a specified length. Your function should handle invalid inputs gracefully and should efficiently generate the possible substrings. Input - A string `s` containing only lowercase English letters (1 ≤ length of `s` ≤ 1000). - An integer `k` representing the length of the substrings (1 ≤ k ≤ length of `s`). Output - A list of strings representing all unique substrings of length `k` from the input string `s`. Function Signature ```python def find_unique_substrings(s: str, k: int) -> list[str]: pass ``` Constraints - The function should raise a ValueError if `k` is less than 1 or greater than the length of `s`. - The function should raise a TypeError if `s` is not a string or if `k` is not an integer. - The function should handle inputs efficiently within the given constraints. Examples ```python >>> find_unique_substrings(\\"hello\\", 2) [\'he\', \'el\', \'ll\', \'lo\'] >>> find_unique_substrings(\\"banana\\", 3) [\'ban\', \'ana\', \'nan\'] >>> find_unique_substrings(\\"abcabc\\", 3) [\'abc\', \'bca\', \'cab\'] >>> find_unique_substrings(\\"repeat\\", 1) [\'r\', \'e\', \'p\', \'a\', \'t\'] ``` Notes Ensure your implementation is optimized for performance and handles edge cases effectively. Consider the scenarios where the input string has repeated characters and the desired substring length spans across these characters.","solution":"def find_unique_substrings(s: str, k: int) -> list[str]: Returns a list of all unique substrings of length k from the input string s. if not isinstance(s, str): raise TypeError(\\"The input \'s\' must be a string.\\") if not isinstance(k, int): raise TypeError(\\"The input \'k\' must be an integer.\\") if k < 1 or k > len(s): raise ValueError(\\"The input \'k\' must be between 1 and the length of the string \'s\'.\\") unique_substrings = set() for i in range(len(s) - k + 1): substring = s[i:i+k] unique_substrings.add(substring) return list(unique_substrings)"},{"question":"# Find Missing Number in Consecutive Series You are tasked with writing a function that finds the single missing number from a list of consecutive integers. The list will have a range of numbers, all unique and one of them is missing. # Function Signature ```python def find_missing_number(nums: List[int]) -> int: pass ``` # Input Format - A single list `nums` of unique integers in ascending order. # Output Format - An integer representing the missing number in the list of consecutive integers. # Constraints - The input list will contain at least two elements and at most 100,000 elements. - The integers in the list will be in the range of 0 to 100,000. # Performance Requirements - The solution should ensure optimal performance, with a linear time complexity. # Example ```python >>> find_missing_number([0, 1, 2, 3, 5]) 4 >>> find_missing_number([10, 11, 12, 13, 15]) 14 >>> find_missing_number([-3, -2, -1, 0, 1, 3]) 2 ```","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Finds the single missing number from a list of consecutive integers. n = len(nums) total_sum = (n + 1) * (nums[0] + nums[-1]) // 2 actual_sum = sum(nums) return total_sum - actual_sum"},{"question":"# Scenario Your company uses a file server to manage shared resources among employees. Each file has metadata containing the file\'s owner, creation date, and size. You are required to implement a function that lists all files in a given directory, sorted by file size. You also need to write unit tests to verify that the function behaves correctly with various edge cases. # Task 1. Implement a function `list_files_by_size` that takes a directory path as an argument and returns a list of tuples, where each tuple contains the file name and its size, sorted in ascending order of file size. 2. Write unit tests for your function to ensure it handles different scenarios (empty directory, files with the same size, very large files, etc.). # Requirements **Function Signature**: ```python def list_files_by_size(directory: str) -> list: # Your implementation here ``` # Example ```python # Example directory structure # directory/ # ├── file1.txt (200 bytes) # ├── file2.txt (100 bytes) # └── file3.txt (300 bytes) # Example of function call list_files_by_size(\\"directory/\\") # Expected output: [(\\"file2.txt\\", 100), (\\"file1.txt\\", 200), (\\"file3.txt\\", 300)] ``` # Constraints - Assume all inputs are valid directory paths. - The function should raise an exception if the directory does not exist. - Do not use any external libraries other than built-in Python libraries. # Testing - Use the `os` and `pytest` libraries to mock file system operations. - Verify that the function correctly processes directories with various file sizes and edge cases. # Additional Information - You can use the `assert` statements to ensure that the list is correctly sorted. - Provide meaningful test cases that cover all potential edge cases of the function. **Note:** Ensure all unit tests are self-contained and do not depend on any actual file system state. Use mocking to simulate directory and file structures.","solution":"import os def list_files_by_size(directory: str) -> list: Lists all files in a given directory, sorted by file size in ascending order. :param directory: Directory path to list files from :return: A list of tuples where each tuple contains the file name and its size # Check if the directory exists if not os.path.exists(directory): raise FileNotFoundError(f\\"The directory \'{directory}\' does not exist.\\") # Get a list of files and their sizes files_with_sizes = [] for root, dirs, files in os.walk(directory): for file in files: file_path = os.path.join(root, file) file_size = os.path.getsize(file_path) files_with_sizes.append((file, file_size)) # Sort the list by file size files_with_sizes.sort(key=lambda x: x[1]) return files_with_sizes"},{"question":"# Thread-safe Banking System You are tasked to implement a thread-safe banking system using Python. Specifically, you should create a `BankAccount` class that supports concurrent deposits and withdrawals. The account should maintain the correct balance even when multiple threads try to deposit or withdraw money simultaneously. Function Signature ```python class BankAccount: def __init__(self, initial_balance: float = 0.0) -> None: pass def deposit(self, amount: float) -> None: pass def withdraw(self, amount: float) -> bool: pass def get_balance(self) -> float: pass ``` Requirements 1. **Initialization**: - Initialize the account with an optional initial balance (default is 0.0). 2. **Deposit Method**: - Implement a `deposit` method that safely adds a specified amount to the account balance. 3. **Withdraw Method**: - Implement a `withdraw` method that safely subtracts a specified amount from the account balance if the balance is sufficient. - If the balance is insufficient, the method should return `False` and the withdrawal should not occur. 4. **Get Balance Method**: - Implement a `get_balance` method that returns the current account balance. 5. **Concurrency Handling**: - Ensure that all methods are thread-safe, using locking mechanisms to prevent race conditions. Example ```python from threading import Thread import time # Define the BankAccount class with the necessary functionality class BankAccount: def __init__(self, initial_balance: float = 0.0) -> None: self.balance = initial_balance self.lock = threading.Lock() def deposit(self, amount: float) -> None: with self.lock: self.balance += amount def withdraw(self, amount: float) -> bool: with self.lock: if self.balance >= amount: self.balance -= amount return True return False def get_balance(self) -> float: with self.lock: return self.balance # Create a bank account instance account = BankAccount(100.0) # Define worker functions that deposit and withdraw concurrently def deposit_worker(account: BankAccount, amount: float, count: int): for _ in range(count): account.deposit(amount) def withdraw_worker(account: BankAccount, amount: float, count: int): for _ in range(count): success = account.withdraw(amount) if not success: print(\\"Withdrawal failed due to insufficient funds\\") # Create threads for adding and withdrawing money threads = [] for i in range(5): t1 = Thread(target=deposit_worker, args=(account, 50, 20)) t2 = Thread(target=withdraw_worker, args=(account, 30, 20)) threads.append(t1) threads.append(t2) # Start all threads for t in threads: t.start() # Ensure all threads have finished for t in threads: t.join() # Print the final account balance print(f\\"Final balance: {account.get_balance()}\\") # Expected output (final balance may vary due to timing of operations): # Withdrawal failed due to insufficient funds # Final balance: (depends on the number of successful withdrawals and deposits) ```","solution":"import threading class BankAccount: def __init__(self, initial_balance: float = 0.0) -> None: self.balance = initial_balance self.lock = threading.Lock() def deposit(self, amount: float) -> None: with self.lock: self.balance += amount def withdraw(self, amount: float) -> bool: with self.lock: if self.balance >= amount: self.balance -= amount return True return False def get_balance(self) -> float: with self.lock: return self.balance"},{"question":"# Rotating Array Elements by K Positions **Scenario**: You are developing a feature for a data processing application that requires manipulation of array elements. The specific task at hand involves rotating the elements of an array to the right by `K` positions. # Task: Implement a function `rotate_array` to take an array of integers and an integer `K` as input and return the array after it has been rotated to the right by `K` positions. # Function Signature: ```python def rotate_array(arr: list[int], k: int) -> list[int]: ``` # Input: 1. `arr` (list[int]): The array of integers to be rotated. Assume it is non-empty. 2. `k` (int): The number of positions to rotate the array to the right. Assume `K` is a non-negative integer. # Output: - Return the rotated array (list[int]). # Constraints: - The solution should handle cases where `K` is greater than the length of the array by effectively considering `K % len(arr)`. # Example: ```python print(rotate_array([1, 2, 3, 4, 5], 2)) # Output: [4, 5, 1, 2, 3] print(rotate_array([10, 20, 30, 40, 50], 3)) # Output: [30, 40, 50, 10, 20] print(rotate_array([1, 2, 3], 0)) # Output: [1, 2, 3] print(rotate_array([7, 8, 9], 10)) # Output: [9, 7, 8] (Because 10 % 3 = 1) ``` # Notes: - The rotation operation can be visualized as taking the last `K` elements of the array and putting them at the front, shifting the remaining elements to the right. - For example, rotating `[1, 2, 3, 4, 5]` by 2 positions results in `[4, 5, 1, 2, 3]`.","solution":"def rotate_array(arr: list[int], k: int) -> list[int]: Rotates an array to the right by k positions. Parameters: arr (list[int]): The array of integers to be rotated. k (int): The number of positions to rotate the array to the right. Returns: list[int]: The rotated array. n = len(arr) k = k % n # Handle cases where k is greater than the length of the array return arr[-k:] + arr[:-k]"},{"question":"# Scenario During quantitative analysis, analysts often require extracting and formatting specific pieces of information from structured data. Imagine you are building a tool to process CSV files that contain sales data. These files include multiple columns like `Date`, `Sale Amount`, `Salesperson`, and `Region`. The tool\'s purpose is to summarize the total sales amount for each salesperson in a specific region within a given date range. # Task Implement a Python function `summarize_sales(file_path: str, start_date: str, end_date: str, region: str) -> Dict[str, float]` that performs the following: 1. Reads the CSV file specified by `file_path`. 2. Filters the records based on the `start_date`, `end_date`, and `region`. 3. Sums the sales amounts grouped by each salesperson. 4. Returns a dictionary where keys are salesperson names and values are the total sales amounts for that salesperson in the specified region and date range. # Constraints * The CSV file has columns: `Date` (in `YYYY-MM-DD` format), `Sale Amount`, `Salesperson`, and `Region`. * Input `start_date` and `end_date` are strings in `YYYY-MM-DD` format. * The `region` input is a string representing a valid region. * Assume the file is well-formed and contains no missing values. * The expected output is a dictionary with salesperson names as keys and total sales amounts as values. # Function Signature ```python from typing import Dict def summarize_sales(file_path: str, start_date: str, end_date: str, region: str) -> Dict[str, float]: pass ``` # Example Given a CSV file `sales_data.csv` with the following content: ``` Date,Sale Amount,Salesperson,Region 2023-01-01,100.00,John Doe,North 2023-01-05,200.00,Jane Smith,North 2023-01-10,150.00,John Doe,North 2023-01-20,300.00,Jane Smith,South 2023-01-25,250.00,John Doe,North ``` Calling the function with: ```python result = summarize_sales(\\"sales_data.csv\\", \\"2023-01-01\\", \\"2023-01-20\\", \\"North\\") print(result) # Output: {\'John Doe\': 250.00, \'Jane Smith\': 200.00} ``` # Requirements * Ensure to parse the dates correctly and filter the records based on the provided date range. * Handle edge cases like no matching records found. * Use Python\'s `csv` module for reading CSV files. * Return an empty dictionary if no records match the given criteria.","solution":"import csv from typing import Dict from datetime import datetime def summarize_sales(file_path: str, start_date: str, end_date: str, region: str) -> Dict[str, float]: sales_summary = {} start_date = datetime.strptime(start_date, \\"%Y-%m-%d\\") end_date = datetime.strptime(end_date, \\"%Y-%m-%d\\") with open(file_path, mode=\'r\') as file: reader = csv.DictReader(file) for row in reader: sale_date = datetime.strptime(row[\'Date\'], \\"%Y-%m-%d\\") if start_date <= sale_date <= end_date and row[\'Region\'] == region: salesperson = row[\'Salesperson\'] sale_amount = float(row[\'Sale Amount\']) if salesperson in sales_summary: sales_summary[salesperson] += sale_amount else: sales_summary[salesperson] = sale_amount return sales_summary"},{"question":"# Context: Queues, as abstract data structures, support operations based on the First In, First Out (FIFO) principle. They are essential in various applications like scheduling tasks, handling web requests, and managing resources. In this exercise, you will implement a queue using two stacks. # Objective: Implement a queue using two stacks. Your queue should support the standard queue operations `enqueue` and `dequeue`. # Problem Statement: Write a class `QueueUsingStacks` that simulates a queue using two stacks. The class should have the following methods: - `__init__(self)`: Initializes the queue. - `enqueue(self, element: int)`: Adds an element to the end of the queue. - `dequeue(self) -> int`: Removes and returns the element at the front of the queue. If the queue is empty, raise an exception with the message `\\"Queue is empty\\"`. You are only allowed to use the stack operations `push` (append to list) and `pop` (pop from list) to implement the queue operations. Class Signature: ```python class QueueUsingStacks: def __init__(self): pass def enqueue(self, element: int): pass def dequeue(self) -> int: pass ``` Methods: 1. `__init__(self)`: Initializes two stacks to simulate the queue. 2. `enqueue(self, element: int)`: Adds an element to the queue. 3. `dequeue(self) -> int`: Removes and returns the front element of the queue. Throws an exception if the queue is empty. Examples: ```python >>> q = QueueUsingStacks() >>> q.enqueue(10) >>> q.enqueue(20) >>> q.dequeue() 10 >>> q.dequeue() 20 >>> q.dequeue() Exception: Queue is empty >>> q.enqueue(30) >>> q.enqueue(40) >>> q.dequeue() 30 >>> q.enqueue(50) >>> q.dequeue() 40 >>> q.dequeue() 50 ``` # Note: - The queue should maintain the correct order of elements as per FIFO principle. - The operations for enqueue and dequeue should maintain their average expected time complexities. Now implement the `QueueUsingStacks` class with above specified methods and logic.","solution":"class QueueUsingStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, element: int): self.stack1.append(element) def dequeue(self) -> int: if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if not self.stack2: raise Exception(\\"Queue is empty\\") return self.stack2.pop()"},{"question":"# Context: Sorting algorithms are fundamental to computer science, and an understanding of different approaches to sorting is crucial. One of the popular sorting techniques is the merge sort, which utilizes a divide-and-conquer strategy. # Problem Statement: Implement the merge sort algorithm to sort a list of integers. Write a function `merge_sort` that takes a list of integers and returns a new list with the integers sorted in ascending order. # Function Signature: ```python def merge_sort(arr: List[int]) -> List[int]: ``` # Input: - `arr`: a list of integers that need to be sorted. # Output: - Returns a new list with the integers sorted in ascending order. # Constraints: - The function should handle lists of varying lengths, including an empty list and lists with a single element. - The function should have an average time complexity of O(n log n). # Example: ```python >>> merge_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] >>> merge_sort([5, 2, 4, 6, 1, 3]) [1, 2, 3, 4, 5, 6] >>> merge_sort([]) [] >>> merge_sort([1]) [1] ``` # Additional Information: Use the following helper function to assist in merging two halves of the array: ```python def merge(left: List[int], right: List[int]) -> List[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result ```","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Performs merge sort on a list of integers and returns a new sorted list. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted lists into a single sorted list. result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result"},{"question":"# Problem Statement: You are tasked with implementing a solution to manage and query a dynamic array of integers that supports the following operations efficiently: 1. **Insert Element**: Insert a new integer at the end of the array. 2. **Delete Element**: Delete an integer at a specified index. 3. **Subarray Sum Query**: Compute the sum of elements within a specified subarray range (inclusive). The objective is to optimize the given functionalities to handle large datasets and high-frequency operations effectively. # Function Signature: ```python class DynamicArray: def __init__(self): pass def insert(self, value: int): pass def delete(self, index: int): pass def subarray_sum(self, left: int, right: int) -> int: pass ``` # Input: * `value`: Integer to be inserted into the array (~-10^9 <= value <= 10^9~). * `index`: Zero-based index at which the element is to be deleted (~0 <= index < current length~). * `left`, `right`: Indices specifying the range of the subarray for which the sum is to be computed (~0 <= left <= right < current length~). # Output: * The function `insert` inserts a value and returns nothing. * The function `delete` deletes a value at the specified index and returns nothing. * The function `subarray_sum` returns the sum of elements in the specified subarray range. # Constraints: * The solution should handle arrays with up to 10^5 elements. * Each operation (insert, delete, and subarray sum) should be optimized to run in O(log n), O(log n), and O(log n) time respectively if possible. * Use data structures that facilitate efficient insertion, deletion, and range query operations, such as balanced binary trees, Fenwick trees, or segment trees. # Example Usage: ```python da = DynamicArray() da.insert(1) da.insert(2) da.insert(3) assert da.subarray_sum(0, 2) == 6 # 1 + 2 + 3 = 6 da.delete(1) assert da.subarray_sum(0, 1) == 4 # 1 + 3 = 4 da.insert(4) assert da.subarray_sum(1, 2) == 7 # 3 + 4 = 7 ``` # Note: Ensure that memory utilization is efficient and edge cases, such as out-of-range indices for delete and sum operations, are handled gracefully with appropriate error messages or conditions. Implement the `DynamicArray` class from scratch without resorting to built-in or external libraries for the primary operations, but auxiliary data structures are permissible.","solution":"class DynamicArray: def __init__(self): self.array = [] self.prefix_sum = [] def insert(self, value: int): self.array.append(value) if len(self.prefix_sum) > 0: self.prefix_sum.append(self.prefix_sum[-1] + value) else: self.prefix_sum.append(value) def delete(self, index: int): if 0 <= index < len(self.array): del self.array[index] self.prefix_sum = list(self.array) for i in range(1, len(self.prefix_sum)): self.prefix_sum[i] += self.prefix_sum[i - 1] def subarray_sum(self, left: int, right: int) -> int: if left < 0 or right >= len(self.array) or left > right: raise IndexError(\\"Invalid subarray range.\\") if left == 0: return self.prefix_sum[right] else: return self.prefix_sum[right] - self.prefix_sum[left - 1]"},{"question":"# Problem Statement A palindrome is a word or phrase that reads the same backward as forward. Given a string `s`, you are to implement a function `longest_palindromic_substring(s: str) -> str` that finds the longest palindromic substring within `s`. # Requirements * Implement the `longest_palindromic_substring` function using an efficient algorithm with a time complexity better than (O(n^3)). The optimal solution should have a time complexity of around (O(n^2)). * The function should handle both mixed-case sensitivity and ignore non-alphanumeric characters. # Function Definition ```python def longest_palindromic_substring(s: str) -> str: # Your code here ``` # Input/Output Examples ```python assert longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] # Either \\"bab\\" or \\"aba\\" are correct. assert longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" assert longest_palindromic_substring(\\"a\\") == \\"a\\" assert longest_palindromic_substring(\\"\\") == \\"\\" assert longest_palindromic_substring(\\"A man, a plan, a canal, Panama\\") == \\"A man, a plan, a canal, Panama\\" ``` # Constraints * The input string `s` can contain lower-case letters, upper-case letters, digits, and special characters. * The length of `s` will be between 0 and 1000. * Consider only the alphanumeric characters when checking for palindromes. # Additional Context Palindromes are interesting problems in computer science due to their simple definition but complex nature when it comes to efficiently identifying them within larger strings. The longest palindromic substring problem highlights the importance of dynamic programming and other optimization techniques in solving time-constrained challenges.","solution":"def longest_palindromic_substring(s: str) -> str: def is_palindrome(sub: str) -> bool: return sub == sub[::-1] def preprocess(s: str) -> str: return \'\'.join(c for c in s if c.isalnum()).lower() s = preprocess(s) n = len(s) if n == 0: return \\"\\" longest_palindrome = \\"\\" for i in range(n): for j in range(i, n): substr = s[i:j+1] if is_palindrome(substr): if len(substr) > len(longest_palindrome): longest_palindrome = substr return longest_palindrome"},{"question":"# Reverse Nodes in k-Group You are given a linked list and an integer **k**. The task is to reverse the nodes of the list **k** at a time and return its modified list. If the number of nodes is not a multiple of **k** then left-out nodes at the end should remain as they are. Requirements: 1. **Function**: Implement the function `reverse_k_group(head: ListNode, k: int) -> ListNode` which takes the head of the linked list and an integer **k**. 2. **In-place Reversal**: Reverse the nodes of the list **k** at a time and modify the list in-place. 3. **Constraints**: You are not allowed to alter the values in the nodes, only the nodes themselves may be changed. # Input: * `head: ListNode` - The head node of the linked list, which can be None. * `k: int` - An integer representing the size of the groups to reverse. # Output: * Returns the head of the modified linked list. # Constraints: * The number of nodes in the list will not exceed `10^4`. * Each node in the list contains an integer value. # Example: Given the linked list: ``` 1 -> 2 -> 3 -> 4 -> 5 ``` For k = 2, the linked list should become: ``` 2 -> 1 -> 4 -> 3 -> 5 ``` For k = 3, the linked list should become: ``` 3 -> 2 -> 1 -> 4 -> 5 ``` # Note: - You can use a helper function if necessary but should not modify the primary ListNode structure. - Ensure your solution efficiently handles edge cases, such as the list having fewer than k nodes. Good luck and happy coding! # Classes: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_k_group(head: ListNode, k: int) -> ListNode: def reverse_linked_list(start, end): prev, curr = None, start while curr != end: temp = curr.next curr.next = prev prev = curr curr = temp return prev if head is None or k == 1: return head dummy = ListNode(0) dummy.next = head group_prev = dummy group_end = head while True: count = 0 while count < k and group_end: group_end = group_end.next count += 1 if count == k: group_start = group_prev.next new_group_start = reverse_linked_list(group_start, group_end) group_prev.next = new_group_start group_start.next = group_end group_prev = group_start else: break return dummy.next"},{"question":"# Palindrome Checker with Permutation Problem Description You are asked to create a palindrome checker that determines if it\'s possible to rearrange the characters of a given string to form a palindrome. Implementation Details 1. **Character Frequency Count**: * First, count the frequency of each character in the given string. 2. **Palindrome Condition**: * A palindrome can have at most one character with an odd frequency. All other characters must appear an even number of times. 3. **Checker Function**: * Implement a `can_form_palindrome` function that takes a single string as input and returns `True` if the characters can be rearranged to form a palindrome, and `False` otherwise. 4. **Main Function**: * Read an input string from the user. * Use the `can_form_palindrome` function to check if the string can be rearranged to form a palindrome. * Print `\\"YES\\"` if it can form a palindrome and `\\"NO\\"` otherwise. Input Format * **String Input**: A single string containing only lowercase alphabetic characters. Output Format * **String Output**: Either `\\"YES\\"` or `\\"NO\\"`. Constraints * The input string will only contain lowercase alphabetic characters. * The length of the string will be between 1 and 1000 characters. # Example Input ``` Type your string: civic ``` Output ``` YES ``` Input ``` Type your string: ivicc ``` Output ``` YES ``` Input ``` Type your string: hello ``` Output ``` NO ``` Your Task Implement the `can_form_palindrome` function and the main functionality to read input and print the outcome. Ensure the function correctly identifies whether a string\'s characters can be rearranged to form a palindrome.","solution":"def can_form_palindrome(s): Determines if the characters of the given string can be rearranged to form a palindrome. :param s: input string :return: True if the characters can be rearranged to form a palindrome, False otherwise from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1 def main(): input_string = input(\\"Type your string:n\\") if can_form_palindrome(input_string): print(\\"YES\\") else: print(\\"NO\\")"},{"question":"# Traffic Light Management System Problem Statement You are tasked with designing a basic traffic light management system for an intersection. The system will control two traffic lights for a two-way street intersection. Each traffic light can be either green or red, and there is a simple rule: when one light is green, the other must be red and vice versa. You must implement a function that simulates the traffic light system over a given number of time units. The system should start with one light green and the other red, and switch the lights at each time unit. Function to Implement Implement the function `traffic_light_simulation` with the following parameters: 1. **initial_state**: A tuple of two strings representing the initial state of the traffic lights. Each string is either \\"green\\" or \\"red\\". 2. **time_units**: An integer representing the number of time units the simulation will run. The function should return a list of tuples, where each tuple represents the state of the traffic lights at each time unit. Example Input ```python initial_state = (\\"green\\", \\"red\\") time_units = 5 ``` Example Output ```python [ (\\"green\\", \\"red\\"), (\\"red\\", \\"green\\"), (\\"green\\", \\"red\\"), (\\"red\\", \\"green\\"), (\\"green\\", \\"red\\") ] ``` Constraints - The `initial_state` will always be a tuple of two strings where one string is \\"green\\" and the other is \\"red\\". - The number of time units will be between 1 and 1000. ```python def traffic_light_simulation(initial_state, time_units): Simulate the traffic light system over the given number of time units. :param initial_state: Tuple representing initial state of traffic lights (\\"green\\" or \\"red\\") :param time_units: Number of time units for simulation :return: List of tuples representing the state of traffic lights at each time unit states = [initial_state] current_state = initial_state for _ in range(1, time_units): current_state = (\\"red\\", \\"green\\") if current_state == (\\"green\\", \\"red\\") else (\\"green\\", \\"red\\") states.append(current_state) return states ```","solution":"def traffic_light_simulation(initial_state, time_units): Simulate the traffic light system over the given number of time units. :param initial_state: Tuple representing initial state of traffic lights (\\"green\\" or \\"red\\") :param time_units: Number of time units for simulation :return: List of tuples representing the state of traffic lights at each time unit states = [initial_state] current_state = initial_state for _ in range(1, time_units): current_state = (\\"red\\", \\"green\\") if current_state == (\\"green\\", \\"red\\") else (\\"green\\", \\"red\\") states.append(current_state) return states"},{"question":"# Question You are required to implement a K-Means clustering model to segment a given dataset into clusters based on similarity of features. Your task is to preprocess the data, train the K-Means model, and visualize the results using a scatter plot with clusters color-coded. # Requirements: - Implement the K-Means model using `KMeans` from the scikit-learn library. - Preprocess the dataset by handling missing values and scaling the features. - Train the model and assign each instance to a cluster. - Visualize the clusters on a 2D scatter plot if the feature space has more than two dimensions, use PCA to reduce it to two principal components. - Evaluate the clustering performance using the silhouette score. # Input: - `features`: a list of lists where each inner list represents the feature vector of an instance. - `n_clusters`: an integer representing the number of clusters to form. # Output: - A 2D scatter plot with instances color-coded by their cluster assignment. - A silhouette score indicating the quality of the clustering. # Constraints: - The `features` list may contain missing values which should be handled appropriately. - Feature scaling should be done to standardize the feature values. - The dataset should have at least 2 and at most 10 clusters. # Scenario: Consider you have been given the Iris dataset (from sklearn.datasets) without the target variable. Implement the `perform_kmeans_clustering` function to preprocess the data, train the model, and visualize the results. ```python import numpy as np import pandas as pd from matplotlib import pyplot as plt from sklearn.datasets import load_iris from sklearn.cluster import KMeans from sklearn.decomposition import PCA from sklearn.metrics import silhouette_score from sklearn.preprocessing import StandardScaler from sklearn.impute import SimpleImputer def data_handling(dataset: dict) -> np.ndarray: Extract features from the dataset return dataset[\\"data\\"] def perform_kmeans_clustering(features: np.ndarray, n_clusters: int) -> None: Implement K-Means clustering, visualize the clusters, and print the silhouette score # Handle missing values imputer = SimpleImputer(strategy=\'mean\') features = imputer.fit_transform(features) # Scale the features scaler = StandardScaler() features_scaled = scaler.fit_transform(features) # Apply PCA for dimensionality reduction pca = PCA(n_components=2) features_pca = pca.fit_transform(features_scaled) # Create and fit the K-Means model kmeans = KMeans(n_clusters=n_clusters) cluster_labels = kmeans.fit_predict(features_scaled) # Calculate silhouette score score = silhouette_score(features_scaled, cluster_labels) print(f\\"Silhouette Score: {score:.2f}\\") # Visualize the clusters plt.scatter(features_pca[:, 0], features_pca[:, 1], c=cluster_labels, cmap=\'viridis\') plt.xlabel(\'Principal Component 1\') plt.ylabel(\'Principal Component 2\') plt.title(\'K-Means Clustering\') plt.colorbar(label=\'Cluster Label\') plt.show() def main() -> None: # Load Iris dataset iris = load_iris() features = data_handling(iris) # Set the number of clusters n_clusters = 3 # Perform K-Means clustering and visualize results perform_kmeans_clustering(features, n_clusters) if __name__ == \\"__main__\\": main() ``` **Note**: Ensure to install the required library using `pip install scikit-learn matplotlib pandas` before running your script.","solution":"import numpy as np import pandas as pd from matplotlib import pyplot as plt from sklearn.datasets import load_iris from sklearn.cluster import KMeans from sklearn.decomposition import PCA from sklearn.metrics import silhouette_score from sklearn.preprocessing import StandardScaler from sklearn.impute import SimpleImputer def data_handling(dataset: dict) -> np.ndarray: Extract features from the dataset return dataset[\\"data\\"] def perform_kmeans_clustering(features: np.ndarray, n_clusters: int) -> float: Implement K-Means clustering, visualize the clusters, and print the silhouette score # Handle missing values imputer = SimpleImputer(strategy=\'mean\') features = imputer.fit_transform(features) # Scale the features scaler = StandardScaler() features_scaled = scaler.fit_transform(features) # Apply PCA for dimensionality reduction pca = PCA(n_components=2) features_pca = pca.fit_transform(features_scaled) # Create and fit the K-Means model kmeans = KMeans(n_clusters=n_clusters) cluster_labels = kmeans.fit_predict(features_scaled) # Calculate silhouette score score = silhouette_score(features_scaled, cluster_labels) print(f\\"Silhouette Score: {score:.2f}\\") # Visualize the clusters plt.scatter(features_pca[:, 0], features_pca[:, 1], c=cluster_labels, cmap=\'viridis\') plt.xlabel(\'Principal Component 1\') plt.ylabel(\'Principal Component 2\') plt.title(\'K-Means Clustering\') plt.colorbar(label=\'Cluster Label\') plt.show() return score def main() -> None: # Load Iris dataset iris = load_iris() features = data_handling(iris) # Set the number of clusters n_clusters = 3 # Perform K-Means clustering and visualize results perform_kmeans_clustering(features, n_clusters) if __name__ == \\"__main__\\": main()"},{"question":"# Problem Statement You are given the root of a binary search tree (BST). Implement functions to find the following: 1. `lowest_common_ancestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode` * **Input**: `TreeNode` representing the root of the BST and two `TreeNode` instances `p` and `q` whose lowest common ancestor you need to find. * **Output**: TreeNode which represents the lowest common ancestor of `p` and `q`. 2. `validate_bst(root: TreeNode) -> bool` * **Input**: `TreeNode` representing the root of the BST. * **Output**: Boolean value indicating whether the tree is a valid BST. 3. `find_kth_smallest_element(root: TreeNode, k: int) -> int` * **Input**: `TreeNode` representing the root of the BST and an integer `k`. * **Output**: Integer value of the k-th smallest element in the BST. 4. `is_symmetric_tree(root: TreeNode) -> bool` * **Input**: `TreeNode` representing the root of the binary tree. * **Output**: Boolean value indicating whether the tree is symmetric around its center. # Constraints: * The number of nodes in the BST is in the range `[1, 1000]`. * `-1000 <= Node.val <= 1000` * `1 <= k <= number of nodes in the BST` * The input tree is guaranteed to be a binary search tree for `lowest_common_ancestor` and `find_kth_smallest_element` functions. * For the `is_symmetric_tree` function, the input can be any binary tree. # Examples For the following BST: ``` 6 / 2 8 / / 0 4 7 9 / 3 5 ``` 1. `lowest_common_ancestor(root, TreeNode(2), TreeNode(8))` should return `TreeNode(6)`. 2. `lowest_common_ancestor(root, TreeNode(2), TreeNode(4))` should return `TreeNode(2)`. 3. `validate_bst(root)` should return `True`. 4. `find_kth_smallest_element(root, 3)` should return `3`. 5. `is_symmetric_tree(root)` should return `False` as the BST is not symmetric. For a symmetric tree: ``` 1 / 2 2 / / 3 4 4 3 ``` 1. `is_symmetric_tree(root)` should return `True`. # Directions: * Implement each function as described. * Aim for optimal time and space complexity. * Consider edge cases like empty trees or trees with only one node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowest_common_ancestor(root, p, q): while root: if p.val < root.val and q.val < root.val: root = root.left elif p.val > root.val and q.val > root.val: root = root.right else: return root def validate_bst(root): def validate(node, low=-float(\'inf\'), high=float(\'inf\')): if not node: return True if not (low < node.val < high): return False return validate(node.left, low, node.val) and validate(node.right, node.val, high) return validate(root) def find_kth_smallest_element(root, k): def in_order_traversal(node): if not node: return [] return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) return in_order_traversal(root)[k-1] def is_symmetric_tree(root): def is_mirror(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val and is_mirror(t1.right, t2.left) and is_mirror(t1.left, t2.right)) return is_mirror(root, root)"},{"question":"# Question: Roll Dice and Sum Coins Context: In game design, probability and resource management are important aspects. Suppose you have a dice-based game where each side of the dice can yield different amounts of coins. You need to calculate the expected value of coins after a certain number of dice rolls to aid in setting game balance. Objective You need to implement a function `expected_coins` to calculate the expected number of coins after rolling an `n`-sided dice `r` times. Function Signature ```python def expected_coins(sides: int, rolls: int, coin_values: list) -> float: pass ``` Parameters: * `sides` (int): Number of sides on the dice (1 ≤ sides ≤ 20). * `rolls` (int): The number of times the dice will be rolled (1 ≤ rolls ≤ 1000). * `coin_values` (list): A list of integers representing the number of coins each side of the dice yields. The length of this list is equal to the sides of the dice. Returns: * `float`: The expected total number of coins obtained after rolling the dice `rolls` times. Round the result to two decimal places. Example: ```python assert round(expected_coins(6, 10, [1, 2, 3, 4, 5, 6]), 2) == 35.00 assert round(expected_coins(4, 5, [0, 5, 10, 15]), 2) == 37.50 ``` Constraints: * Ensure your function handles large numbers of rolls efficiently. * Use probability theory to calculate expected values accurately. * Validate input to handle edge cases, such as sides being less than 1 and rolls being 1 or more.","solution":"def expected_coins(sides: int, rolls: int, coin_values: list) -> float: Calculates the expected total number of coins obtained after rolling the dice. Parameters: sides (int): Number of sides on the dice. rolls (int): Number of times the dice will be rolled. coin_values (list): A list of integers representing the number of coins each side of the dice yields. Returns: float: The expected total number of coins, rounded to two decimal places. if sides != len(coin_values) or sides < 1 or rolls < 1: raise ValueError(\\"Invalid input\\") # Calculate the average coins per roll avg_coins_per_roll = sum(coin_values) / sides # Expected total coins after all rolls expected_total_coins = avg_coins_per_roll * rolls return round(expected_total_coins, 2)"},{"question":"# Question You are tasked to create an automated system that tracks the daily temperature of a specified city and logs any significant temperature changes. The function will fetch data from an open weather API and compare the current temperature with the previously logged temperature to determine if there has been a significant change (defined as a change of more than 5 degrees Celsius). # Function Specification **Function Signature** ```python def track_temperature(city: str) -> str: pass ``` **Input** - `city` (string): The name of the city for which the temperature needs to be tracked. This input should be a valid city name supported by the weather API. **Output** - Returns a string indicating if there has been a significant change or not: - If the temperature change is more than 5 degrees: \\"Significant temperature change detected.\\" - Otherwise: \\"Temperature change is within the normal range.\\" **Constraints** - Assume the function logs the last known temperature to a file named `\\"last_temp.txt\\"` in the format `city:temperature`. - The function should handle network-related errors and invalid city names gracefully. - Make sure that the function can handle cases where the file does not exist (first-time execution). # Example ```python result = track_temperature(\\"London\\") print(result) ``` # Instructions 1. The function should use the OpenWeatherMap API to fetch the current temperature of the specified city. For example, the API endpoint could be `http://api.openweathermap.org/data/2.5/weather?q={city}&appid={API_KEY}&units=metric`. 2. Parse the API response to extract the current temperature. 3. If the `last_temp.txt` exists, read the last recorded temperature for the given city. 4. Compare the current temperature with the last recorded temperature. 5. Log the current temperature to the file and return an appropriate message based on the comparison. 6. Implement error handling for HTTP errors, parsing errors, and any issues related to file I/O. **Note:** You will need to sign up for an API key from the OpenWeatherMap API to test this function.","solution":"import os import requests API_KEY = \'your_api_key_here\' # Replace with your actual OpenWeatherMap API key def track_temperature(city: str) -> str: # OpenWeatherMap API URL url = f\'http://api.openweathermap.org/data/2.5/weather?q={city}&appid={API_KEY}&units=metric\' try: response = requests.get(url) response.raise_for_status() # Raise an error for bad HTTP status except requests.exceptions.RequestException as e: return f\\"Unable to fetch data from the weather service: {e}\\" # Parse the current temperature data = response.json() if \'main\' in data: current_temp = data[\'main\'][\'temp\'] else: return f\\"Invalid response received: {data}\\" last_temp_file = \\"last_temp.txt\\" last_temp = None # Check if the last temperature log file exists and read it if os.path.exists(last_temp_file): with open(last_temp_file, \\"r\\") as file: for line in file: city_recorded, temp_recorded = line.strip().split(\':\') if city_recorded == city: last_temp = float(temp_recorded) break # Determine if there is a significant temperature change if last_temp is None: message = \\"First-time temperature check for this city.\\" elif abs(current_temp - last_temp) > 5: message = \\"Significant temperature change detected.\\" else: message = \\"Temperature change is within the normal range.\\" # Log the current temperature to the file with open(last_temp_file, \\"w\\") as file: file.write(f\\"{city}:{current_temp}\\") return message"},{"question":"# Coding Assessment Question Context You are required to implement a function that generates a list of prime numbers up to a given number `n`. The function should be designed to balance between the memory usage and execution time, leveraging optimal algorithms and data structures. Requirements Write a function `generate_primes` that: 1. Generates a list of all prime numbers up to a given integer `n` using an efficient algorithm. 2. Ensures the solution handles large values of `n` without excessive memory usage. 3. Should use the Sieve of Eratosthenes or any other efficient prime generation algorithm. Constraints * `n` will be a positive integer (1 ≤ `n` ≤ 10^6). Input & Output # Input * `n`: int — The upper limit for generating prime numbers. # Output * Returns a list of integers — The prime numbers up to `n`. Example ```python >>> generate_primes(10) [2, 3, 5, 7] >>> generate_primes(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ``` Function Signature ```python def generate_primes(n: int) -> List[int]: pass ```","solution":"def generate_primes(n: int) -> list: Generates a list of all prime numbers up to a given integer n using the Sieve of Eratosthenes algorithm. :param n: The upper limit for generating prime numbers. :return: A list of prime numbers up to n. if n < 2: return [] # Initialize a boolean array to prime status is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False p = 2 while (p * p <= n): if is_prime[p] == True: # Marking multiples of p as False for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 # Collecting all prime numbers primes = [p for p in range(n + 1) if is_prime[p]] return primes"},{"question":"# Scenario A travel agency is managing bookings for multiple tour guides who can offer guided tours to tourists. Each tour guide has a preference list of tourists they would like to guide, and similarly, each tourist has a preference list of tour guides. The agency needs an algorithm that can match tour guides and tourists in a stable manner such that no tour guide-tourist pair would prefer each other over their current matches. # Problem Given the details of tour guides\' and tourists’ preferences, implement the function `stable_tour_matching(guide_pref: list[list[int]], tourist_pref: list[list[int]]) -> list[int]` to find a stable match where no two individuals prefer each other over their current matched partners. Input * `guide_pref`: A list of lists. Each sublist represents a tour guide’s ranked preferences over tourists. * `tourist_pref`: A list of lists. Each sublist represents a tourist’s ranked preferences over tour guides. Output * A list of integers where the ith index is the tour guide and the value is the corresponding tourist they matched with. Constraints * The lengths of `guide_pref` and `tourist_pref` will be equal. * Each tourist’s and tour guide’s preference list will contain unique integers within the valid range. # Example ```python def stable_tour_matching(guide_pref: list[list[int]], tourist_pref: list[list[int]]) -> list[int]: # Function body here # Example data guide_pref = [[1, 0, 2], [2, 1, 0], [0, 2, 1]] tourist_pref = [[0, 1, 2], [1, 2, 0], [2, 0, 1]] result = stable_tour_matching(guide_pref, tourist_pref) print(result) # Should print a stable matching list such as [0, 2, 1] ``` Performance Requirement * The solution must run in O(n^2) time complexity. # Note You need to ensure that the implemented function always results in a stable pairing where no tour guide-tourist pair exists that would both prefer each other over their current matches.","solution":"def stable_tour_matching(guide_pref, tourist_pref): n = len(guide_pref) # Each tourist\'s tour guide preference priorities tourist_priority = [{} for _ in range(n)] for t in range(n): for rank in range(n): tour_guide = tourist_pref[t][rank] tourist_priority[t][tour_guide] = rank # Each tour guide\'s current match (initially none) guide_match = [-1] * n # Each tourist’s current partner (initially none) and availability status tourist_match = [-1] * n tourist_available = [True] * n # Lists of which tourist each guide will propose to next guide_proposals = [0] * n free_guide_count = n while free_guide_count > 0: for g in range(n): if guide_match[g] == -1: # The current tourist this guide is proposing to current_tourist = guide_pref[g][guide_proposals[g]] if tourist_available[current_tourist]: # The tourist is free and gets matched with this guide guide_match[g] = current_tourist tourist_match[current_tourist] = g tourist_available[current_tourist] = False free_guide_count -= 1 else: current_partner = tourist_match[current_tourist] # The tourist prefers this new guide more than their current partner if tourist_priority[current_tourist][g] < tourist_priority[current_tourist][current_partner]: # Unmatch current partner and match with new guide guide_match[current_partner] = -1 guide_match[g] = current_tourist tourist_match[current_tourist] = g # Update that this guide has proposed to the next tourist in their list guide_proposals[g] += 1 return guide_match"},{"question":"# Problem Statement A company\'s warehouse has a list of product inventories represented by integers in a list. Each integer represents the number of units of a product. The company wants to ensure that no product type is stored in excess units, defined by a maximum threshold `k`. Write a function `adjust_inventory` that takes in a list of integers and an integer `k`, and returns a new list where any inventory count greater than `k` is reduced to `k`. Consequently, if a product\'s inventory exceeds the threshold `k`, reduce the inventory to `k`. # Function Signature ```python def adjust_inventory(inventories: List[int], k: int) -> List[int]: ``` # Input - `inventories` (1 ≤ len(inventories) ≤ 10^5): A list of integers where each integer represents the number of units for a type of product. - `k` (1 ≤ k ≤ 10^4): An integer representing the maximum allowed units for each product. # Output - A list of integers where each inventory count is adjusted to be at most `k`. # Examples ```python >>> adjust_inventory([120, 50, 75, 200], 100) [100, 50, 75, 100] >>> adjust_inventory([10, 20, 30, 40], 25) [10, 20, 25, 25] >>> adjust_inventory([5, 5, 5, 5], 10) [5, 5, 5, 5] ``` # Constraints - The solution should aim for linear time complexity, maximum O(n). - Consider edge cases like empty inputs or very large lists. # Notes - Think about how to efficiently iterate and modify the list in place if possible. - Remember to handle cases where no changes are necessary because all inventories are within the allowed threshold.","solution":"from typing import List def adjust_inventory(inventories: List[int], k: int) -> List[int]: Adjusts each product inventory in the list to ensure no inventory count exceeds k units. If an inventory count is greater than k, it is reduced to k. Args: inventories (List[int]): List of inventory counts. k (int): Maximum allowed units for each product. Returns: List[int]: A new list with adjusted inventory counts. return [min(inventory, k) for inventory in inventories]"},{"question":"# Question Write a function `invert_binary_tree` which takes the root of a binary tree and inverts the tree. The inversion of a binary tree means swapping the left and right children of all nodes in the tree. **Function Signature**: ```python def invert_binary_tree(root: Node | None) -> Node | None: ``` # Input - `root` is the root node of the binary tree which can be `None` if the tree is empty. # Output - The function should return the root node of the inverted binary tree. # Constraints - The number of nodes in the tree will be in the range [0, 1000]. - The value of nodes will be in the range [-1000, 1000]. # Examples ```python # Example 1 root = Node(4) root.left = Node(2) root.right = Node(7) root.left.left = Node(1) root.left.right = Node(3) root.right.left = Node(6) root.right.right = Node(9) inverted_tree = invert_binary_tree(root) print_preorder(inverted_tree) # Expected Output for pre-order traversal: 4, 7, 9, 6, 2, 3, 1 # Example 2 root = None inverted_tree = invert_binary_tree(root) print_preorder(inverted_tree) # Expected Output: None ``` # Notes - Ensure to handle cases where the root node might be `None` (i.e., the tree is empty). - Provide `print_preorder` function to help in visualizing the tree structure via pre-order traversal.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def invert_binary_tree(root): if root is None: return None # Recursively invert the left and right subtrees left_inverted = invert_binary_tree(root.left) right_inverted = invert_binary_tree(root.right) # Swap the left and right children root.left = right_inverted root.right = left_inverted return root def print_preorder(root): if root is None: return print(root.value, end=\\" \\") print_preorder(root.left) print_preorder(root.right)"},{"question":"# Range Sum Query Problem In this problem, you need to design a data structure that can efficiently perform range sum queries and updates on an array of integers. Requirements * Implement the class `RangeSumQuery` that supports the following operations: * `update(index: int, value: int)`: Updates the element at the specified index to the given value. * `sumRange(left: int, right: int) -> int`: Returns the sum of the elements between the indices `left` and `right` (both inclusive). Class Signature ```python class RangeSumQuery: def __init__(self, nums: List[int]): pass def update(self, index: int, value: int) -> None: pass def sumRange(self, left: int, right: int) -> int: pass ``` # Input * `nums`: A list of integers, representing the initial array. * `index`: An integer, representing the position to be updated. * `value`: An integer, representing the new value at the specified index. * `left` and `right`: Integers, representing the range for sum calculation. # Output * `update` method does not return a value. * `sumRange` returns an integer representing the sum of the elements within the specified range. # Example ```python nums = [1, 3, 5] # Initialize rsq = RangeSumQuery(nums) # Sum of elements between indices 0 and 2 assert rsq.sumRange(0, 2) == 9 # 1 + 3 + 5 = 9 # Update index 1 to 2 rsq.update(1, 2) # Sum of elements between indices 0 and 2 after update assert rsq.sumRange(0, 2) == 8 # 1 + 2 + 5 = 8 ``` # Constraints * The input array length `n` will be in the range `[1, 100000]`. * The update and sumRange operations must be performed in O(log n) time on average. # Notes * Utilize a Segment Tree or Binary Indexed Tree (Fenwick Tree) to achieve the efficiency required for large inputs. * Handle edge cases where `left` and `right` are the same, which should return the value of the single element. # Explanation * The `__init__` method initializes the data structure with the given list of integers. * The `update` method modifies the value at the specified index and maintains the integrity of the data structure. * The `sumRange` method computes the sum of the array elements within the given range efficiently.","solution":"from typing import List class RangeSumQuery: def __init__(self, nums: List[int]): self.n = len(nums) self.tree = [0] * (2 * self.n) self.build(nums) def build(self, nums: List[int]): # Initialize leaves of the segment tree for i in range(self.n): self.tree[self.n + i] = nums[i] # Build the segment tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, index: int, value: int) -> None: pos = self.n + index self.tree[pos] = value # Update the segment tree from the changed position to the root while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def sumRange(self, left: int, right: int) -> int: # Get the sum from range `left` to `right` (inclusive) left += self.n right += self.n sum = 0 while left <= right: if left % 2 == 1: sum += self.tree[left] left += 1 if right % 2 == 0: sum += self.tree[right] right -= 1 left //= 2 right //= 2 return sum"},{"question":"# Problem Statement Design and implement a system for managing a small library\'s book collection. Your program should allow librarians to add new books, remove books, search for a book by title or author\'s name, and list all books in the library. # Requirements - The book collection should support the following operations: - `add_book(title, author)`: Adds a new book with the given title and author to the collection. Raises ValueError if the book already exists. - `remove_book(title)`: Removes the book with the given title from the collection. Raises KeyError if the book does not exist. - `search_by_title(title)`: Returns the list of books that match the given title (exact match). Returns an empty list if no match found. - `search_by_author(author)`: Returns the list of books by the given author. Returns an empty list if no match found. - `list_books()`: Returns a list of all books in the collection, each represented as a (title, author) tuple. # Input and Output - **add_book(title, author)**: - Input: `title` (string), `author` (string) - Output: None - **remove_book(title)**: - Input: `title` (string) - Output: None - **search_by_title(title)**: - Input: `title` (string) - Output: List of matching (title, author) tuples - **search_by_author(author)**: - Input: `author` (string) - Output: List of matching (title, author) tuples - **list_books()**: - Input: None - Output: List of (title, author) tuples # Constraints - Book titles and author names must be strings. - The collection should support efficiently adding and removing books. - Handle duplicate book titles appropriately. - Ensure proper error handling for removing a book that doesn’t exist and adding a duplicate book. # Performance Requirements - Ensure efficient storage and retrieval of books. - Search operations should be optimized for quick lookup. # Example ```python # Creating a library collection library = Library() # Add books library.add_book(\'1984\', \'George Orwell\') library.add_book(\'To Kill a Mockingbird\', \'Harper Lee\') # List all books print(library.list_books()) # [(\'1984\', \'George Orwell\'), (\'To Kill a Mockingbird\', \'Harper Lee\')] # Search by title print(library.search_by_title(\'1984\')) # [(\'1984\', \'George Orwell\')] # Search by author print(library.search_by_author(\'Harper Lee\')) # [(\'To Kill a Mockingbird\', \'Harper Lee\')] # Remove a book library.remove_book(\'1984\') # List all books after removal print(library.list_books()) # [(\'To Kill a Mockingbird\', \'Harper Lee\')] ``` # Implementation Please write a class named `Library` in Python that meets the requirements mentioned above. Ensure to include proper docstrings and test cases.","solution":"class Library: def __init__(self): self.books = {} def add_book(self, title, author): Adds a new book with the given title and author to the collection. Raises ValueError if the book already exists. if title in self.books: raise ValueError(\\"Book already exists in the collection.\\") self.books[title] = author def remove_book(self, title): Removes the book with the given title from the collection. Raises KeyError if the book does not exist. if title not in self.books: raise KeyError(\\"Book not found in the collection.\\") del self.books[title] def search_by_title(self, title): Returns the list of books that match the given title (exact match). Returns an empty list if no match found. if title in self.books: return [(title, self.books[title])] return [] def search_by_author(self, author): Returns the list of books by the given author. Returns an empty list if no match found. return [(title, author) for title, book_author in self.books.items() if book_author == author] def list_books(self): Returns a list of all books in the collection, each represented as a (title, author) tuple. return list(self.books.items())"},{"question":"# Question: Operations on Cryptographic Permutations Background You are tasked with cryptographic operations involving permutations. Consider a permutation of the first N natural numbers (0 to N-1). Your task is to apply a series of operations on this permutation to transform it into its reverse permutation. Task Write a function `min_operations_to_reverse(n: int, operations: List[str]) -> int` that returns the minimum number of operations required to reverse a permutation. The permissible operations are: 1. `swap(i, j)`: Swap the elements at indices `i` and `j`. 2. `rotate_left(k)`: Rotate the first `k` elements to the left by one position. 3. `rotate_right(k)`: Rotate the first `k` elements to the right by one position. Input - An integer `n` (2 ≤ n ≤ 10^5), representing the size of the permutation. - A list of strings `operations`, each representing a permissible operation in the form `\\"swap(i, j)\\"`, `\\"rotate_left(k)\\"`, or `\\"rotate_right(k)\\"`. Output - Returns an integer representing the minimum number of operations required to transform the permutation into its reverse permutation. Example ```python from typing import List def min_operations_to_reverse(n: int, operations: List[str]) -> int: # Your code here # Example usage: print(min_operations_to_reverse(4, [\\"swap(0, 3)\\", \\"rotate_left(4)\\"])) # Expected output can vary ``` Constraints 1. The permutation of numbers is initially in sorted order `[0, 1, 2, ..., N-1]`. 2. Ensure optimal implementation to handle the upper constraint efficiently. Hints 1. Consider the initial state and the target state (reverse permutation) for strategic operation placement. 2. Use rotational symmetry and swapping properties to minimize the number of operations. 3. Think about simulating operations and tracking the transformation state.","solution":"from typing import List def min_operations_to_reverse(n: int, operations: List[str]) -> int: # This problem requires observation. # For the reversed permutation, the minimum moves usually would be one swap per pair: # For example: for n=4: [3, 2, 1, 0] # We can swap (0, 3) and (1, 2) # Therefore, we need exactly `n // 2` swaps to completely reverse the array. return n // 2 # Simulation of operations won\'t be more efficient than the above approach, # since we can deterministically calculate the minimum number of operations."},{"question":"# Coding Question **Context**: A library is expanding its digital catalog and needs a function to help manage and filter book data. They want to be able to list books that match a specific genre and an optional criteria of minimum average rating. **Task**: Write a Python function `filter_books` that: 1. Accepts a list of dictionaries representing books, a target genre, and an optional minimum average rating. 2. Returns a list of book titles that match the given genre and have an average rating equal to or higher than the specified minimum rating. **Function Signature**: ```python def filter_books(books: list, genre: str, min_rating: float=None) -> list: Filters a list of books based on genre and optionally on minimum average rating. :param books: list - a list of dictionaries where each dictionary represents a book with keys \'title\', \'genre\', and \'avg_rating\' :param genre: str - the genre to filter books by :param min_rating: float - optional, the minimum average rating to filter books by :return: list - a list of book titles that match the genre and minimum rating criteria pass ``` **Constraints**: * The function should handle cases where the `min_rating` is not provided (i.e., it should filter books based on genre only). * If no books match the criteria, the function should return an empty list. * Ensure to handle edge cases such as an empty list of books or invalid data types gracefully by raising appropriate exceptions. **Example**: Given the input list of books: ```python books = [ {\\"title\\": \\"Book One\\", \\"genre\\": \\"Science Fiction\\", \\"avg_rating\\": 4.5}, {\\"title\\": \\"Book Two\\", \\"genre\\": \\"Fantasy\\", \\"avg_rating\\": 4.0}, {\\"title\\": \\"Book Three\\", \\"genre\\": \\"Science Fiction\\", \\"avg_rating\\": 3.8}, {\\"title\\": \\"Book Four\\", \\"genre\\": \\"Science Fiction\\", \\"avg_rating\\": 4.9}, {\\"title\\": \\"Book Five\\", \\"genre\\": \\"Self-Help\\", \\"avg_rating\\": 4.2} ] ``` When calling `filter_books(books, \\"Science Fiction\\")`, the output should be: ``` [\\"Book One\\", \\"Book Three\\", \\"Book Four\\"] ``` When calling `filter_books(books, \\"Science Fiction\\", 4.5)`, the output should be: ``` [\\"Book One\\", \\"Book Four\\"] ``` When calling `filter_books(books, \\"Fantasy\\", 4.1)`, the output should be: ``` [] ``` Consider implementing efficient methods to handle filtering, and ensure the function remains performant even with a large dataset of books.","solution":"def filter_books(books: list, genre: str, min_rating: float = None) -> list: Filters a list of books based on genre and optionally on minimum average rating. :param books: list - a list of dictionaries where each dictionary represents a book with keys \'title\', \'genre\', and \'avg_rating\' :param genre: str - the genre to filter books by :param min_rating: float - optional, the minimum average rating to filter books by :return: list - a list of book titles that match the genre and minimum rating criteria if not isinstance(books, list) or not all(isinstance(book, dict) for book in books): raise ValueError(\\"Books must be a list of dictionaries\\") filtered_books = [] for book in books: if book.get(\\"genre\\") == genre and (min_rating is None or book.get(\\"avg_rating\\", 0) >= min_rating): filtered_books.append(book.get(\\"title\\")) return filtered_books"},{"question":"# Coding Assessment Question: Scenario: You are a software engineer tasked with implementing a system to manage the launch sequence for a series of rockets. Safety is a top priority, so you need a precise way to track the sequence, ensuring no two rockets are launched simultaneously. For this purpose, you are required to write a function that verifies if the launch times are set correctly and adjust them if necessary. Task: Write a function `adjust_launch_times(launch_times)` that takes a list of integers representing the proposed launch times for the rockets and adjusts them so that each rocket has a unique launch time. If two or more rockets have the same launch time, increment the subsequent launch times as necessary to ensure all launch times are unique. Function Specifications: 1. **Function**: adjust_launch_times - **Input**: - `launch_times` (List[int]): A list of integers where each integer represents a proposed launch time. - **Output**: - (List[int]): A list of integers where each integer represents an adjusted launch time with all times being unique. Constraints: - `1 <= len(launch_times) <= 10^6` - `0 <= launch_times[i] <= 10^9` for each `i` - The solution should handle large lists effectively and have a time complexity of O(n log n) or better. # Example: ```python launch_times = [5, 3, 5, 3, 1] adjusted = adjust_launch_times(launch_times) print(adjusted) # Output could be [5, 3, 6, 4, 1], ensuring all times are unique launch_times = [1, 2, 3, 4, 5] adjusted = adjust_launch_times(launch_times) print(adjusted) # Should output [1, 2, 3, 4, 5] since all times are already unique ``` **Note**: Your solution should efficiently handle various edge cases such as duplicate launch times, very large values, and already unique times. The goal is to ensure that the resultant list contains significantly unique launch times for each rocket, maintaining the order as much as possible and only incrementing where necessary.","solution":"def adjust_launch_times(launch_times): Adjust the launch times to ensure all launch times are unique. Args: - launch_times (List[int]): A list of integers representing proposed launch times. Returns: - List[int]: A list of integers where all launch times are unique. if not launch_times: return launch_times launch_times.sort() for i in range(1, len(launch_times)): if launch_times[i] <= launch_times[i - 1]: launch_times[i] = launch_times[i - 1] + 1 return launch_times"},{"question":"# Problem Statement You are given an array of integers and a target sum. Your goal is to find the total number of distinct pairs (i, j) in the array such that the sum of array[i] and array[j] equals the target sum, and i < j. # Input * An integer N (1 <= N <= 10^5) representing the number of elements in the array. * A list of N integers where each integer can be between -10^9 and 10^9. * An integer target which is the desired sum, target can also be between -10^9 and 10^9. # Output * An integer representing the total number of distinct pairs that sum up to the target. # Constraints * Each element in the array can be paired with itself. * The array may contain duplicate elements. * The solution should be efficient with respect to time complexity. # Example ```python Input N = 5 array = [1, 5, 7, -1, 5] target = 6 Output 3 ``` # Explanation The pairs that sum up to 6 are: (1, 5), (5, 1), and (7, -1). Note that (5, 1) is not counted as a distinct pair because the condition i < j is not met. The distinct pairs are (1, 5), (7, -1), and (5, 1) resulting in a total count of 3. # Function Signature ```python def count_pairs_with_sum(N: int, array: [int], target: int) -> int: # Implement your solution here ``` # Notes 1. Consider edge cases, such as when the array has fewer than 2 elements. 2. Optimize for large inputs to ensure the solution runs within a reasonable time frame. The above question aligns well with the provided example in terms of complexity, style, scope, and presentation. It explores an additional fundamental concept in programming, that of finding pairs which sum to a target value using an efficient approach, possibly involving a hash map for linear time complexity.","solution":"def count_pairs_with_sum(N, array, target): # Create a hashmap to store counts of each element count_map = {} pair_count = 0 for num in array: complement = target - num if complement in count_map: pair_count += count_map[complement] if num in count_map: count_map[num] += 1 else: count_map[num] = 1 return pair_count"},{"question":"# Coding Assessment Question **Scenario**: You work as a software developer at a transportation company. Your team is tasked with developing a scheduling application to ensure the optimal assignment of drivers to shifts. A key aspect of the scheduling algorithm involves calculating the total hours worked by each driver over a week and ensuring they do not exceed a regulated limit of 60 hours. To assist in this task, you need to write functions to calculate the total hours worked by each driver for a given week and identify if any driver exceeds the 60-hour limit. The data is provided as a dictionary where the keys are driver IDs and the values are lists containing the hours worked per day over a 7-day period. # Task Implement two functions, `calculate_total_hours` and `find_overworked_drivers`, as specified below: 1. **calculate_total_hours(daily_hours)** * **Input**: - `daily_hours` (dict): A dictionary where the key is a driver ID (str) and the value is a list of 7 floats representing hours worked each day. * **Output**: - A dictionary where the key is a driver ID (str) and the value is the total hours worked in the week (float). * **Constraints**: - Ensure the dictionary values are lists of exactly 7 elements (one for each day of the week). - Each element in the list must be a non-negative float representing the hours worked each day. 2. **find_overworked_drivers(total_hours)** * **Input**: - `total_hours` (dict): A dictionary where the key is a driver ID (str) and the value is the total hours worked in the week (float). * **Output**: - A list of driver IDs (str) who have worked more than 60 hours in the week. * **Constraints**: - Ensure precise comparison for floating-point numbers to avoid false positives or negatives. # Example Usage ```python daily_hours = { \\"driver1\\": [8.0, 8.5, 9.0, 8.0, 7.5, 6.0, 0.0], \\"driver2\\": [10.0, 9.5, 10.0, 10.0, 9.0, 8.0, 5.0], \\"driver3\\": [7.0, 6.0, 7.5, 8.0, 7.0, 8.0, 7.0] } total_hours = calculate_total_hours(daily_hours) print(total_hours) # Output: {\'driver1\': 47.0, \'driver2\': 61.5, \'driver3\': 50.5} overworked_drivers = find_overworked_drivers(total_hours) print(overworked_drivers) # Output: [\'driver2\'] ``` # Implementation Write your solution in Python. The overall time complexity for each function should be O(n), where n is the number of drivers in the input data.","solution":"def calculate_total_hours(daily_hours): Calculates the total hours worked by each driver over a week. :param daily_hours: A dictionary where key is a driver ID (str) and value is a list of 7 floats representing hours worked each day. :return: A dictionary where the key is a driver ID (str) and the value is the total hours worked in the week (float). total_hours = {} for driver, hours in daily_hours.items(): if len(hours) != 7: raise ValueError(f\\"Driver {driver} does not have 7 days of work hours recorded.\\") if not all(isinstance(hour, (int, float)) and hour >= 0 for hour in hours): raise ValueError(f\\"Driver {driver} has invalid hour entries.\\") total_hours[driver] = sum(hours) return total_hours def find_overworked_drivers(total_hours): Identifies drivers who have worked more than 60 hours in a week. :param total_hours: A dictionary where the key is a driver ID (str) and the value is the total hours worked in the week (float). :return: A list of driver IDs (str) who have worked more than 60 hours in the week. overworked_drivers = [driver for driver, hours in total_hours.items() if hours > 60] return overworked_drivers"},{"question":"# **In-Place Linked List Reversal with Tracking** **Scenario:** Your goal is to reverse a singly linked list in place while also keeping track of the number of node swaps required. This task is essential for optimizing algorithms in a memory-constrained environment where external storage for a list copy is not feasible. **Task:** Implement the `reverse_linked_list` function, which reverses a singly linked list in place and returns a tuple consisting of the head of the reversed list and the count of node swaps performed during the reversal process. **Specifications:** # **Function Signature:** ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_linked_list(head: ListNode) -> tuple[ListNode, int]: ``` # **Input:** - `head`: The head of the singly linked list. # **Output:** - A tuple containing two elements: - The first element is the head of the reversed linked list. - The second element is an integer representing the count of node swaps made during the reversal process. # **Constraints:** - The function should reverse the list in place without using extra space for a copy of the list. - Consider edge cases such as an empty list and a single-element list. **Example:** ```python # Linked list: 1 -> 2 -> 3 -> 4 # Reversed linked list: 4 -> 3 -> 2 -> 1 with 3 swaps >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) >>> new_head, swap_count = reverse_linked_list(head) >>> linked_list_to_list(new_head) [4, 3, 2, 1] >>> swap_count 3 # Linked list: 1 -> 2 # Reversed linked list: 2 -> 1 with 1 swap >>> head = ListNode(1, ListNode(2)) >>> new_head, swap_count = reverse_linked_list(head) >>> linked_list_to_list(new_head) [2, 1] >>> swap_count 1 # Linked list: None # Reversed linked list: None with 0 swaps >>> head = None >>> new_head, swap_count = reverse_linked_list(head) >>> linked_list_to_list(new_head) [] >>> swap_count 0 ``` *Note: The `linked_list_to_list` function is assumed to convert the linked list to a Python list for easy output validation in examples.* **Hints:** - Use a three-pointer approach to reverse the linked list in place. - Keep a counter to track the number of nodes swapped during the reversal.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_linked_list(head: ListNode) -> tuple[ListNode, int]: prev = None current = head swap_count = 0 while current is not None: next_node = current.next current.next = prev prev = current current = next_node swap_count += 1 return (prev, max(0, swap_count - 1)) def linked_list_to_list(head: ListNode) -> list: result = [] current = head while current: result.append(current.value) current = current.next return result"},{"question":"# Problem Statement You are given a string representing a sequence of operations involving an imaginary stack, where each operation is one of the following: - `PUSH` (push an item onto the stack) - `POP` (remove the top item from the stack) - `TOP` (retrieve the top item from the stack without removing it) Your task is to implement a function `stack_sequence_operations(operations: str) -> list` that simulates these operations using a stack and returns a list of results for each `TOP` operation. The sequence of operations is provided as a single string where each operation code is separated by a space. # Input - `operations` (str): A sequence of space-separated operations (`PUSH`, `POP`, `TOP`). # Output - A list containing the results of each `TOP` operation. If a `TOP` or `POP` operation is attempted on an empty stack, the function should append `-1` to the results list for that operation. # Constraints - `1 <= len(operations) <= 10^5` # Example ```python assert stack_sequence_operations(\\"PUSH 5 PUSH 3 TOP POP TOP POP POP TOP\\") == [3, 5, -1, -1] assert stack_sequence_operations(\\"PUSH 10 TOP POP TOP\\") == [10, -1] assert stack_sequence_operations(\\"TOP PUSH 100 TOP PUSH 200 TOP POP POP POP\\") == [-1, 100, 200, -1] ``` # Notes - Each `PUSH` is followed by an integer value which should be pushed onto the stack. - Ensure to handle and maintain the correct sequence of operations efficiently given the constraints. **Implementation Hints**: - Use a list to simulate the stack operations. - Traverse through the operations string and handle each operation accordingly. - Pay close attention to the edge cases (e.g., popping or retrieving the top of an empty stack).","solution":"def stack_sequence_operations(operations: str): stack = [] result = [] operation_list = operations.split() i = 0 while i < len(operation_list): if operation_list[i] == \\"PUSH\\": i += 1 stack.append(int(operation_list[i])) elif operation_list[i] == \\"POP\\": if stack: stack.pop() else: result.append(-1) elif operation_list[i] == \\"TOP\\": if stack: result.append(stack[-1]) else: result.append(-1) i += 1 return result"},{"question":"# Context Bob enjoys solving problems that involve string manipulation and regular expressions. He has encountered a task where he needs to identify valid email addresses from a large chunk of text. An email address is considered valid if it follows the standard email format `local-part@domain`, where the local part can include letters, digits, and special characters `.`, `_`, `+`, and the domain part can include letters, digits, and hyphens, followed by a `.` and a top-level domain (which consists of letters only). # Task Write a function `extract_valid_emails` that accepts a string containing a large text block and returns a list of all valid email addresses found within the text. The function should use regular expressions to identify and validate the email addresses. # Input - A single string `text` that contains the text block. - The text block can be of any length and contain any characters, including whitespace and special characters. # Output - A list of strings, each string being a valid email address extracted from the input text. - The list should be sorted in the order of appearance within the text. # Example ```python text = Hello Bob, you can reach me at alice@example.com for the project updates. Additionally, send an email to hr@company.com for human resources related queries. On a personal note, don\'t forget to CC to support@domain.co.uk for any technical issues. Best regards, Jane extract_valid_emails(text) ``` Expected Output: ``` [\'alice@example.com\', \'hr@company.com\', \'support@domain.co.uk\'] ``` # Constraints - The input text can be arbitrarily large, up to several kilobytes in size. # Performance Requirements - Use efficient string processing techniques to handle large inputs without significant performance degradation.","solution":"import re def extract_valid_emails(text): Extract valid email addresses from the given text. Args: text (str): The input text containing potential email addresses. Returns: List[str]: A list of valid email addresses in the order of appearance. email_pattern = re.compile( r\'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}\' ) return email_pattern.findall(text)"},{"question":"Objective Your task is to implement a function that determines whether a given string is a valid identifier in a programming language. An identifier is valid if it starts with a letter (a-z, A-Z) or an underscore (_), and is followed by any number of letters, digits (0-9), or underscores. Function Signature ```python def is_valid_identifier(s: str) -> bool: ``` Input * **s (str)**: The input string representing the identifier. The string consists of printable ASCII characters. `0 <= len(s) <= 100`. Output * **Return (bool)**: `True` if the string is a valid identifier, `False` otherwise. Constraints * Ensure the function handles both upper and lower-case letters appropriately. * Consider edge cases such as empty strings or strings that start with a digit. Example ```python # Example 1: input: s = \\"variable1\\" output: True # Example 2: input: s = \\"1variable\\" output: False # Example 3: input: s = \\"valid_variable_2\\" output: True # Example 4: input: s = \\"\\" output: False ``` Scenario Context Consider a scenario where you are developing a feature for a text editor that checks if user-input strings are valid variable names based on programming language rules. Valid identifiers are crucial for correct syntax and avoiding errors during code execution. **Your task** is to implement the `is_valid_identifier` function to verify if the input string complies with the identifier rules as described above.","solution":"def is_valid_identifier(s: str) -> bool: Determines if the given string is a valid identifier. A valid identifier starts with a letter (a-z, A-Z) or an underscore (_), and is followed by any number of letters, digits (0-9), or underscores. Parameters: s (str): The input string representing the identifier. Returns: bool: True if the string is a valid identifier, False otherwise. if not s: return False if s[0].isalpha() or s[0] == \'_\': for char in s[1:]: if not (char.isalnum() or char == \'_\'): return False return True return False"},{"question":"# Scenario You are working on a software that helps manage a library system. One of the requirements is to develop a function that will help librarians quickly find the most popular books based on the number of times they have been borrowed. The system records each borrowing event, and your task is to process this data to determine the most frequently borrowed book(s). # Task Write a Python function `most_borrowed_books(records: List[str]) -> List[str]` that takes a list of records, where each element is a book title representing a borrowing event, and returns a list of the most borrowed book title(s). If multiple books are tied for the highest number of borrows, return them in lexicographical (alphabetical) order. # Input/Output Formats * **Input**: A list `records` containing up to 10^5 strings, each representing a book title that was borrowed. * **Output**: A list of strings representing the most borrowed book title(s), sorted in lexicographical order if there are ties. # Constraints * Each book title is a non-empty string of up to 100 characters. * All characters in book titles are printable ASCII characters. # Performance Requirements Your function should efficiently handle lists containing up to 10^5 book titles. # Examples ```python >>> most_borrowed_books([\\"Harry Potter\\", \\"The Hobbit\\", \\"Harry Potter\\", \\"1984\\", \\"The Hobbit\\", \\"The Hobbit\\"]) [\\"The Hobbit\\"] >>> most_borrowed_books([\\"Book A\\", \\"Book B\\", \\"Book A\\", \\"Book B\\", \\"Book A\\", \\"Book C\\", \\"Book C\\", \\"Book C\\"]) [\\"Book A\\", \\"Book C\\"] >>> most_borrowed_books([\\"Gone Girl\\", \\"To Kill a Mockingbird\\", \\"Gone Girl\\", \\"Gone Girl\\", \\"1984\\"]) [\\"Gone Girl\\"] >>> most_borrowed_books([]) [] >>> most_borrowed_books([\\"Single Book\\"]) [\\"Single Book\\"] >>> most_borrowed_books([\\"Book Z\\", \\"Book Y\\", \\"Book X\\", \\"Book X\\", \\"Book Y\\", \\"Book Z\\", \\"Book Z\\", \\"Book Y\\", \\"Book X\\"]) [\\"Book X\\", \\"Book Y\\", \\"Book Z\\"] ``` # Edge Cases * If there are no borrowing records, the function should return an empty list. * The function should handle ties by returning book titles in alphabetical order.","solution":"from typing import List from collections import Counter def most_borrowed_books(records: List[str]) -> List[str]: Determine the most frequently borrowed book(s) based on borrowing records. Args: - records (List[str]): List of book titles representing borrowing events. Returns: - List[str]: List of the most borrowed book title(s), sorted in lexicographical order if tied. if not records: return [] # Count the frequency of each book title book_counts = Counter(records) # Determine the maximum borrow count max_borrow_count = max(book_counts.values()) # Find all books with the maximum borrow count most_borrowed = [book for book, count in book_counts.items() if count == max_borrow_count] # Sort the result in lexicographical order most_borrowed.sort() return most_borrowed"},{"question":"**Context**: In a text-based game, the player can navigate in a 2D grid world starting at position (0, 0). The player can issue several movement commands in the form of a string where each character represents a direction: \'U\' for up, \'D\' for down, \'L\' for left, and \'R\' for right. The goal of the player is to return to the origin (0, 0). **Task**: Implement the function `is_back_to_origin(movements: str) -> bool` that checks if a sequence of movement commands leads the player back to the origin after all commands are executed. **Function Signature**: ```python def is_back_to_origin(movements: str) -> bool: pass ``` **Input**: * `movements` (str): A string of characters where each character can be \'U\', \'D\', \'L\', or \'R\'. **Output**: * (bool): `True` if the player returns to the origin, `False` otherwise. **Constraints**: * The input string can be of any length, up to 10^4 characters. * Assume that the input only contains valid characters (\'U\', \'D\', \'L\', \'R\') and is case-sensitive. **Requirements**: * The function should run in linear time complexity O(n). **Examples**: ```python assert is_back_to_origin(\\"UDLR\\") == True assert is_back_to_origin(\\"UUDDLLRR\\") == True assert is_back_to_origin(\\"UDDLLR\\") == False assert is_back_to_origin(\\"LLRR\\") == True assert is_back_to_origin(\\"UDUDUDUD\\") == True assert is_back_to_origin(\\"RRU\\") == False ```","solution":"def is_back_to_origin(movements: str) -> bool: Determines if a sequence of movement commands returns the player to the origin (0, 0) in a 2D grid. :param movements: A string of movement commands (\'U\', \'D\', \'L\', \'R\') :return: True if the player returns to the origin, False otherwise x, y = 0, 0 for move in movements: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"# Merge K Sorted Lists Objective You need to implement a function that merges `k` sorted linked lists and returns the merged sorted linked list. The implementation should efficiently handle the merging process to maintain optimal performance. Requirements 1. **Function Signature**: `merge_k_sorted_lists(lists: list[Optional[ListNode]]) -> Optional[ListNode]` 2. **Input**: * `lists`: A list containing `k` head nodes of sorted linked lists. * Each list is singly linked and is sorted in non-decreasing order. * The total number of nodes across all `k` lists does not exceed 2000. 3. **Output**: * A head node of the merged sorted linked list. Constraints * You are not allowed to use built-in sorting functions. * Your solution should focus on efficient space and time complexity. * Consider edge cases such as empty lists and lists of varying lengths. Performance Requirements * The solution should ideally run in O(N log k) time complexity, where N is the total number of nodes, and k is the number of lists. The space complexity should be O(1) for the merging process. Scenario Imagine you are given several sorted lists of student scores from different class sections. Your task is to merge all these lists into one sorted list to form a consolidated leaderboard. Example ```python # Definition for singly-linked list. class ListNode: def __init__(self, val: int = 0, next: Optional[\'ListNode\'] = None): self.val = val self.next = next # Example usage: # Input: lists = [[1,4,5],[1,3,4],[2,6]] # List1: 1 -> 4 -> 5 # List2: 1 -> 3 -> 4 # List3: 2 -> 6 # Expected Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6 # Note: The example assumes ListNode class and merge function embedding. def list_to_nodes(list_array): if not list_array: return None head = ListNode(list_array[0]) current = head for val in list_array[1:]: current.next = ListNode(val) current = current.next return head lists = [list_to_nodes([1, 4, 5]), list_to_nodes([1, 3, 4]), list_to_nodes([2, 6])] merged_head = merge_k_sorted_lists(lists) # Function to convert the linked list back to a python list for easy output verification. def nodes_to_list(head): current = head result = [] while current: result.append(current.val) current = current.next return result print(nodes_to_list(merged_head)) # Expected Output: [1, 1, 2, 3, 4, 4, 5, 6] ```","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val: int = 0, next: Optional[\'ListNode\'] = None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: min_heap = [] # Initialize the heap for index, node in enumerate(lists): if node: heapq.heappush(min_heap, (node.val, index, node)) dummy = ListNode() current = dummy while min_heap: val, index, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, index, node.next)) return dummy.next"},{"question":"# Coding Assessment Question: Sorting a List of Tuples by Multiple Criteria Scenario You are tasked with implementing a function to sort a list of tuples based on multiple criteria. Each tuple contains three elements: a string, an integer, and a float. The tuples should be sorted primarily by the string in ascending order, then by the integer in descending order, and finally by the float in ascending order. Function Signature ```python def sort_tuples(tuples: List[Tuple[str, int, float]]) -> List[Tuple[str, int, float]]: pass ``` Input - `tuples`: A list of tuples `[(str, int, float), ...]` where each tuple contains: - A string - An integer - A float Output - Returns a sorted list of tuples based on the specified criteria. Constraints - The input list will contain at most 1000 tuples. - Strings contain only lowercase alphabets and have a maximum length of 50 characters. - Integers and floats can be both positive and negative. Performance Requirements - The solution should efficiently handle lists with up to 1000 tuples. - Aim for a time complexity of O(n log n), where n is the number of tuples. Example ```python tuples = [ (\\"apple\\", 3, 1.2), (\\"banana\\", 2, 3.4), (\\"apple\\", 2, 2.1), (\\"banana\\", 5, 1.1), (\\"apple\\", 3, 0.5) ] # Sorted Tuples: # [ # (\\"apple\\", 3, 0.5), # (\\"apple\\", 3, 1.2), # (\\"apple\\", 2, 2.1), # (\\"banana\\", 5, 1.1), # (\\"banana\\", 2, 3.4) # ] assert sort_tuples(tuples) == [ (\\"apple\\", 3, 0.5), (\\"apple\\", 3, 1.2), (\\"apple\\", 2, 2.1), (\\"banana\\", 5, 1.1), (\\"banana\\", 2, 3.4) ] ``` Detailed Steps 1. Implement a function that takes in the list of tuples. 2. Use the `sorted` function with a custom key to sort the tuples. 3. The custom key should sort by the following order: - First by the string element in ascending order. - Secondly by the integer element in descending order. - Lastly, by the float element in ascending order. 4. Return the sorted list of tuples. Edge Cases - Handle an empty list (should return an empty list). - Handle lists with tuples having identical elements (should still maintain relative order where applicable). - Ensure the function accounts for negative integers and floats in the sorting logic.","solution":"from typing import List, Tuple def sort_tuples(tuples: List[Tuple[str, int, float]]) -> List[Tuple[str, int, float]]: Sorts a list of tuples by multiple criteria: 1. Primarily by the string in ascending order 2. Secondarily by the integer in descending order 3. Finally by the float in ascending order return sorted(tuples, key=lambda x: (x[0], -x[1], x[2]))"},{"question":"# File System Path Simplifier Scenario You are working on a project that involves simplifying file paths. In Unix-like operating systems, a file path might contain \\".\\", \\"..\\", and \\"//\\", representing the current directory, a move to the parent directory, and redundant slashes respectively. Your task is to simplify these paths. Task Implement a function that simplifies a given Unix-like file path. Function Signature ```python def simplify_path(path: str) -> str: pass ``` Requirements 1. Treat multiple consecutive slashes as a single slash. 2. Treat \\".\\" as the current directory and it can be ignored. 3. Treat \\"..\\" as going up one directory; ignore \\"..\\" if it attempts to go beyond the root directory \\"/\\". 4. Return the simplified path from the root directory. Constraints * The path will be a non-empty string. * The path will start with a \\"/\\". * The path will only contain alphanumeric characters, \\".\\", \\"..\\", \\"/\\", and empty spaces will not be considered. Examples ```python # Example 1 assert simplify_path(\\"/home/\\") == \\"/home\\" # Example 2 assert simplify_path(\\"/../\\") == \\"/\\" # Example 3 assert simplify_path(\\"/home//foo/\\") == \\"/home/foo\\" # Example 4 assert simplify_path(\\"/a/./b/../../c/\\") == \\"/c\\" # Example 5 assert simplify_path(\\"/a/../../b/../c//.//\\") == \\"/c\\" # Example 6 assert simplify_path(\\"/a//b////c/d//././/..\\") == \\"/a/b/c\\" ``` This question ensures that candidates understand how to manipulate strings and use a stack to handle directory navigation.","solution":"def simplify_path(path: str) -> str: Simplifies the given Unix-like file path. parts = path.split(\'/\') stack = [] for part in parts: if part == \'..\': if stack: stack.pop() elif part and part != \'.\': stack.append(part) return \'/\' + \'/\'.join(stack)"},{"question":"# Coding Assessment: Genetic Algorithm for Function Optimization Problem Statement You are provided with an implementation of a Genetic Algorithm for optimizing a two-dimensional function. Your task is to implement a similar optimization algorithm but for a multi-dimensional function. Objectives 1. Implement a `genetic_algorithm` function that optimizes a given function in `n` dimensions. 2. Your implementation should be able to find either the maximum or minimum value of the function based on a flag. 3. Implement a `SearchProblemND` class with appropriate methods to support the optimization process. Input - **Function to Optimize**: A function `f(*args)` that takes `n` arguments and returns a floating-point value. - **Initial Population**: A list of individuals, each represented by a list of coordinates. - **Population Size**: The number of individuals in the population. - **Bounds**: The minimum and maximum bounds for each coordinate. - **Algorithm Parameters**: Number of generations, mutation rate, and crossover rate. Output - A state object with the optimized coordinates and the corresponding function value. # Constraints 1. **Function Implementation**: Your `SearchProblemND` class must have the following methods: - `__init__(self, coordinates: List[float], function_to_optimize)` - `mutate(self, mutation_rate: float) -> \'SearchProblemND\'` - `crossover(self, other: \'SearchProblemND\', crossover_rate: float) -> Tuple[\'SearchProblemND\', \'SearchProblemND\']` - `score(self) -> float` 2. **Genetic Algorithm**: Your `genetic_algorithm` function must have the following signature: ```python def genetic_algorithm( initial_population: List[SearchProblemND], find_max: bool = True, bounds: List[Tuple[float, float]] = None, num_generations: int = 100, population_size: int = 50, mutation_rate: float = 0.01, crossover_rate: float = 0.7 ) -> Any: ``` 3. **Performance Requirement**: The algorithm should effectively converge towards an optimal or near-optimal solution within a reasonable number of generations for typical multi-dimensional functions. # Example Usage ```python # Define a sample function to optimize def function_to_optimize(*coords): return -sum((x - (i+1))**2 for i, x in enumerate(coords)) + 100 # Define bounds for each dimension bounds = [(-10, 10)] * 3 # Initialize population initial_population = [SearchProblemND( coordinates=[random.uniform(b[0], b[1]) for b in bounds], function_to_optimize=function_to_optimize ) for _ in range(50)] # Perform genetic algorithm search result = genetic_algorithm( initial_population, find_max=True, bounds=bounds, num_generations=200, population_size=50, mutation_rate=0.02, crossover_rate=0.75 ) print(f\\"Optimal state: coordinates={result.coordinates}, value={result.score()}\\") ``` Ensure your function is thoroughly tested with various multi-dimensional functions to validate its correctness and performance.","solution":"import random from typing import List, Tuple, Callable, Any class SearchProblemND: def __init__(self, coordinates: List[float], function_to_optimize: Callable): self.coordinates = coordinates self.function_to_optimize = function_to_optimize def mutate(self, mutation_rate: float, bounds: List[Tuple[float, float]]) -> \'SearchProblemND\': new_coords = self.coordinates[:] for i in range(len(new_coords)): if random.random() < mutation_rate: new_coords[i] = random.uniform(bounds[i][0], bounds[i][1]) return SearchProblemND(new_coords, self.function_to_optimize) def crossover(self, other: \'SearchProblemND\', crossover_rate: float) -> Tuple[\'SearchProblemND\', \'SearchProblemND\']: if random.random() < crossover_rate: point = random.randint(1, len(self.coordinates) - 1) new_coords1 = self.coordinates[:point] + other.coordinates[point:] new_coords2 = other.coordinates[:point] + self.coordinates[point:] return SearchProblemND(new_coords1, self.function_to_optimize), SearchProblemND(new_coords2, self.function_to_optimize) else: return self, other def score(self) -> float: return self.function_to_optimize(*self.coordinates) def genetic_algorithm( initial_population: List[SearchProblemND], find_max: bool = True, bounds: List[Tuple[float, float]] = None, num_generations: int = 100, population_size: int = 50, mutation_rate: float = 0.01, crossover_rate: float = 0.7 ) -> Any: population = initial_population for _ in range(num_generations): population = sorted(population, key=lambda ind: ind.score(), reverse=find_max) new_population = population[:population_size//2] while len(new_population) < population_size: parent1 = random.choice(new_population) parent2 = random.choice(new_population) offspring1, offspring2 = parent1.crossover(parent2, crossover_rate) new_population.append(offspring1.mutate(mutation_rate, bounds)) new_population.append(offspring2.mutate(mutation_rate, bounds)) population = new_population[:population_size] return max(population, key=lambda ind: ind.score()) if find_max else min(population, key=lambda ind: ind.score())"},{"question":"# Coding Question: String Permutation Checker Your task is to write a function `is_permutation(s1: str, s2: str) -> bool` that checks if one string is a permutation of another, considering case sensitivity and special characters. Input: * The function will take two strings `s1` and `s2`. Output: * The function should return `True` if `s1` is a permutation of `s2`, otherwise `False`. Constraints: * Both strings can contain uppercase and lowercase letters, digits, spaces, and special characters. * The strings can be empty. # Example: ```python def is_permutation(s1: str, s2: str) -> bool: >>> is_permutation(\'abcd\', \'dcba\') True >>> is_permutation(\'abc d\', \'d cba\') True >>> is_permutation(\'aBc!\', \'c ba!\') False >>> is_permutation(\'\', \'\') True >>> is_permutation(\'1234\', \'4321\') True ``` # Notes: * Ensure that your function handles edge cases, such as empty strings, correctly. * Optimize the function to handle longer strings efficiently. * Avoid using libraries that directly solve the permutation problem. Instead, demonstrate your understanding by implementing the logic.","solution":"def is_permutation(s1: str, s2: str) -> bool: Returns True if s1 is a permutation of s2, otherwise False. if len(s1) != len(s2): return False # Sort the strings and compare return sorted(s1) == sorted(s2)"},{"question":"# Problem Statement You are assigned to build a text editor with a basic undo functionality. The editor supports standard operations like inserting and deleting characters, with an ability to undo the most recent operation. **Specifications**: Implement a `TextEditor` class with the following methods: 1. `insert(position: int, character: str)`: Insert a single character at the specified position. 2. `delete(position: int)`: Delete the character at the specified position. 3. `undo()`: Undo the most recent operation. This works for either insert or delete operations. 4. `get_text() -> str`: Return the current state of the text in the editor. **Error Handling**: - *IndexError*: Raised when attempting to insert or delete at an invalid position. - *UndoError*: Raised when attempting to undo an operation when no operations have been performed yet. **Input/Output**: - Ensure that operations handle boundary cases like inserting at the end or beginning of the text properly. - The text editor should maintain an efficient state and history of operations for undo functionality. # Inputs: - Sequence of operations requests including `insert`, `delete`, `undo`, and `get_text`. # Outputs: - For `get_text`: The current text in the editor. - For `insert` and `delete`: None. - For `undo`: None (but it affects the internal state of the text). # Example: ```python editor = TextEditor() editor.insert(0, \'h\') editor.insert(1, \'e\') editor.insert(2, \'l\') editor.insert(3, \'l\') editor.insert(4, \'o\') print(editor.get_text()) # Output: \\"hello\\" editor.delete(4) print(editor.get_text()) # Output: \\"hell\\" editor.undo() print(editor.get_text()) # Output: \\"hello\\" editor.undo() print(editor.get_text()) # Output: \\"hell\\" ``` # Constraints: - The text length ranges from 0 to 10^5 characters. - Operations on the text editor should be optimized for efficiency. # Task: Implement the `TextEditor` class described above, ensuring proper function and error handling compliance.","solution":"class UndoError(Exception): pass class TextEditor: def __init__(self): self.text = [] self.history = [] def insert(self, position: int, character: str): if position < 0 or position > len(self.text): raise IndexError(\\"Position out of bounds.\\") self.text.insert(position, character) self.history.append((\'insert\', position)) def delete(self, position: int): if position < 0 or position >= len(self.text): raise IndexError(\\"Position out of bounds.\\") removed_char = self.text.pop(position) self.history.append((\'delete\', position, removed_char)) def undo(self): if not self.history: raise UndoError(\\"No operations to undo.\\") last_action = self.history.pop() if last_action[0] == \'insert\': self.text.pop(last_action[1]) elif last_action[0] == \'delete\': self.text.insert(last_action[1], last_action[2]) def get_text(self) -> str: return \'\'.join(self.text)"},{"question":"# Problem Statement Scenario: You are tasked with creating a word frequency counter for a given text. This utility will be useful in analyzing the occurrence of each word within a body of text. Given a string of text, your program should accurately count the frequency of each word and be able to display this information sorted by frequency and alphabetically. Task: Implement various functions required to parse the text, count word frequencies, and display the results. The program should handle different text input sources and correctly manage punctuation and casing differences. Requirements: - Define a function `count_words(text: str) -> dict` to count the frequency of each word in the given text. - Define a function `sort_frequencies(word_dict: dict) -> list` to sort the word frequency dictionary first by frequency (highest to lowest) and then alphabetically for words with the same frequency. - Define a function `display_frequencies(sorted_word_list: list) -> None` to print out each word and its frequency in the required order. Inputs: 1. `text` (str): A string containing the text to be analyzed. Outputs: - Returns a dictionary with words as keys and their corresponding frequencies as values. - Prints out the list of words and their frequencies sorted by the specified criteria. Constraints: - The text will be a non-empty string with at most 10^6 characters. - Words are considered case-insensitively (\\"The\\" and \\"the\\" are the same word). - The text contains standard punctuation (.,!?:;\'\\"-). Example: ```python # Example input text text = \\"This is a test. This test is only a test.\\" # Expected Output: # a: 2 # is: 2 # test: 3 # this: 2 # only: 1 # Display Output: # test: 3 # a: 2 # is: 2 # this: 2 # only: 1 ``` Code Usage: ```python if __name__ == \\"__main__\\": text_input = \\"This is a test. This test is only a test.\\" word_frequencies = count_words(text_input) sorted_list = sort_frequencies(word_frequencies) display_frequencies(sorted_list) ``` Ensure that the implementation accurately handles different casing and punctuation within the text to correctly count and sort word frequencies. Consider edge cases such as punctuation directly attached to words and varying cases for the same words.","solution":"import re from collections import Counter def count_words(text: str) -> dict: Count the frequency of each word in the given text. # Convert to lowercase text = text.lower() # Use regex to find words words = re.findall(r\'bw+b\', text) # Count frequency of each word word_count = Counter(words) return dict(word_count) def sort_frequencies(word_dict: dict) -> list: Sort the word frequency dictionary by frequency and then alphabetically. # Sort by frequency (descending) and then alphabetically sorted_list = sorted(word_dict.items(), key=lambda item: (-item[1], item[0])) return sorted_list def display_frequencies(sorted_word_list: list) -> None: Print out each word and its frequency in the required order. for word, freq in sorted_word_list: print(f\\"{word}: {freq}\\")"},{"question":"# Weather Data Analyzer You are required to build a script that fetches weather data from a public API and processes it to determine weather trends. The current script fetches basic weather data such as temperature and humidity. Your goal is to extend the script to provide more advanced analysis. Requirements: 1. **Function `fetch_weather_data`**: - Takes an endpoint URL and an API key as input. - Asynchronously fetches current weather data from the given endpoint. - Includes robust error handling for network request failures and missing data fields. - Validates the JSON response to ensure it contains the expected structure. 2. **Function `calculate_avg_temperature`**: - Takes a list of temperature readings. - Returns the average temperature. 3. **Function `detect_weather_trend`**: - Takes a list of temperature readings. - Returns a string indicating if the temperature trend is \\"rising\\", \\"falling\\", or \\"steady\\". 4. **Constraints**: - You must use the `aiohttp` library for making asynchronous requests. - Timeout for the HTTP request should be 5 seconds. - Ensure efficient use of resources and handle potential exceptions gracefully. Input & Output Formats: * The `fetch_weather_data` function should return a list of temperature readings. * The `calculate_avg_temperature` function should return the average temperature as a float. * The `detect_weather_trend` function should return a trend as a string. Example: Given a hypothetical API key `\\"test_api_key\\"` and endpoint `\\"https://api.open-meteo.com/v1/forecast\\"`, the script should: 1. Fetch the weather data. 2. Handle any potential errors gracefully. 3. Calculate the average temperature. 4. Identify the temperature trend. ```python import aiohttp import asyncio import json _WEATHER_API = \\"https://api.open-meteo.com/v1/forecast?latitude=35&longitude=139&hourly=temperature_2m&start=2022-01-01T00:00:00Z&end=2022-01-02T00:00:00Z&current_weather=true&apikey=\\" async def fetch_weather_data(api_url: str, api_key: str) -> list: async with aiohttp.ClientSession() as session: try: async with session.get(f\\"{api_url}&apikey={api_key}\\", timeout=5) as response: if response.status != 200: raise Exception(f\\"Error fetching data: {response.status}\\") json_response = await response.json() return [hourly_data.get(\'temperature_2m\', 0) for hourly_data in json_response.get(\'hourly\', {}).get(\'temperature_2m\', [])] except Exception as e: print(f\\"An error occurred: {e}\\") return [] def calculate_avg_temperature(temperatures: list) -> float: if not temperatures: return 0.0 return sum(temperatures) / len(temperatures) def detect_weather_trend(temperatures: list) -> str: if not temperatures or len(temperatures) < 2: return \\"steady\\" positive = sum(1 for i in range(1, len(temperatures)) if temperatures[i] > temperatures[i-1]) negative = sum(1 for i in range(1, len(temperatures)) if temperatures[i] < temperatures[i-1]) if positive > negative: return \\"rising\\" elif negative > positive: return \\"falling\\" else: return \\"steady\\" if __name__ == \\"__main__\\": api_key = \\"<Your Weather API key goes here>\\" temperatures = asyncio.run(fetch_weather_data(_WEATHER_API, api_key)) avg_temp = calculate_avg_temperature(temperatures) trend = detect_weather_trend(temperatures) print(f\\"Average Temperature: {avg_temp}\\") print(f\\"Weather Trend: {trend}\\") ```","solution":"import aiohttp import asyncio async def fetch_weather_data(api_url: str, api_key: str) -> list: Asynchronously fetches current weather data from the given endpoint. async with aiohttp.ClientSession() as session: try: async with session.get(f\\"{api_url}&apikey={api_key}\\", timeout=5) as response: if response.status != 200: raise Exception(f\\"Error fetching data: {response.status}\\") json_response = await response.json() return [hourly_data.get(\'temperature_2m\', 0) for hourly_data in json_response.get(\'hourly\', {}).get(\'temperature_2m\', [])] except Exception as e: print(f\\"An error occurred: {e}\\") return [] def calculate_avg_temperature(temperatures: list) -> float: Calculate the average temperature. if not temperatures: return 0.0 return sum(temperatures) / len(temperatures) def detect_weather_trend(temperatures: list) -> str: Returns a string indicating if the temperature trend is \\"rising\\", \\"falling\\", or \\"steady\\". if not temperatures or len(temperatures) < 2: return \\"steady\\" positive = sum(1 for i in range(1, len(temperatures)) if temperatures[i] > temperatures[i-1]) negative = sum(1 for i in range(1, len(temperatures)) if temperatures[i] < temperatures[i-1]) if positive > negative: return \\"rising\\" elif negative > positive: return \\"falling\\" else: return \\"steady\\""},{"question":"Maximum Binary Tree Width In this task, you are asked to determine the maximum width of a binary tree. The width of a binary tree is defined as the maximum width among all levels. The width of one level is defined as the number of nodes present in that level. # Problem Statement Implement a function `max_width_of_binary_tree` which takes the root node of a binary tree as input and returns the maximum width of the binary tree. # Function Signature ```python def max_width_of_binary_tree(root: TreeNode) -> int: pass ``` # Input * root: `TreeNode` - The root node of the binary tree. # Output * `int`: The maximum width of the binary tree. # Constraints * The number of nodes in the tree is in the range ([1, 10^4]). * The value of each node is in the range ([-10^5, 10^5]). # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right >>> root = TreeNode(1) >>> root.left = TreeNode(3) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(9) >>> result = max_width_of_binary_tree(root) >>> print(result) 4 >>> root = TreeNode(1) >>> root.left = TreeNode(3) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(5) >>> root.right.right = TreeNode(9) >>> root.left.left.left = TreeNode(6) >>> root.right.right.right = TreeNode(7) >>> result = max_width_of_binary_tree(root) >>> print(result) 8 ``` # Explanation In the first example, the binary tree is ``` 1 / 3 2 / 5 3 9 ``` The maximum width is 4 at the third level. In the second example, the binary tree is ``` 1 / 3 2 / 5 9 / 6 7 ``` The maximum width is 8 at the fourth level. # Notes - You may need to use level-order traversal (BFS) to determine the width of each level. - Consider using a queue to manage the nodes at each level and track their position indices to calculate the width effectively. - Ensure edge cases are handled, such as trees with only one node or trees that are not fully populated at certain levels.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_width_of_binary_tree(root: TreeNode) -> int: if not root: return 0 max_width = 0 queue = deque([(root, 0)]) # Use a deque to store (node, index) tuples while queue: level_length = len(queue) _, first_index = queue[0] # Get the index of the first node at this level for _ in range(level_length): node, index = queue.popleft() if node.left: queue.append((node.left, 2 * index)) if node.right: queue.append((node.right, 2 * index + 1)) # Calculate the width of the current level _, last_index = queue[-1] if queue else (None, index) max_width = max(max_width, last_index - first_index + 1) return max_width"},{"question":"Range Sum Query - Immutable You are tasked with creating a range sum query function for a list of integers. The function should be able to calculate the sum of the elements between two given indices, inclusive. Function Signature ```python def range_sum_query(nums: List[int], left: int, right: int) -> int: Calculate the sum of the elements between two given indices in the list. :param nums: List of integers :param left: The starting index of the range (inclusive) :param right: The ending index of the range (inclusive) :return: The sum of the elements between indices left and right, inclusive ``` Input - `nums (List[int])`: A list of integers. - `left (int)`: The starting index of the range for which the sum is to be computed. - `right (int)`: The ending index of the range for which the sum is to be computed. Output - `int`: The sum of the elements between the provided indices (inclusive). Constraints 1. `0 <= left <= right < len(nums)` 2. List length can be up to (10^5). Example ```python >>> range_sum_query([1,2,3,4,5], 0, 2) 6 >>> range_sum_query([-1, 2, -3, 4, 5], 1, 4) 8 >>> range_sum_query([10, 20, 30, 40, 50], 2, 4) 120 >>> range_sum_query([5, 10, 15, 20, 25], 0, 4) 75 >>> range_sum_query([100, 200, 300, 400, 500], 1, 3) 900 ``` Additional Notes - The function should handle the summation efficiently even with large lists. - Ensure the function adheres to the constraints given and performs within acceptable limits for time complexity, ideally O(1) for each query after an initial setup phase. Note: Consider using a prefix sum array to achieve a very efficient query time.","solution":"from typing import List def range_sum_query(nums: List[int], left: int, right: int) -> int: Calculate the sum of the elements between two given indices in the list. :param nums: List of integers :param left: The starting index of the range (inclusive) :param right: The ending index of the range (inclusive) :return: The sum of the elements between indices left and right, inclusive # Precompute the prefix sums prefix_sums = [0] * (len(nums) + 1) for i in range(len(nums)): prefix_sums[i + 1] = prefix_sums[i] + nums[i] # Calculate range sum using prefix sums return prefix_sums[right + 1] - prefix_sums[left]"},{"question":"# Coding Assessment Question: **Problem Description**: You are required to design and implement a collaborative filtering recommendation system using the Singular Value Decomposition (SVD) method. The primary objective of this exercise is to test your understanding of collaborative filtering, matrix factorization techniques, and your implementation skills in linear algebra operations. **Requirements**: Implement the `CustomSVDRecommender` class to generate user recommendations based on past user-item interactions. Your recommender system should include the following methods: 1. **Constructor `__init__(self, n_factors: int = 10, n_iterations: int = 20, learning_rate: float = 0.005, regularization: float = 0.02)`** - Initialize the recommender with parameters for the number of latent factors in the SVD, number of iterations for gradient descent optimizations, learning rate, and regularization term. 2. **Method `fit(self, user_item_matrix: np.ndarray) -> None`** - Fit the model to the given user-item interaction matrix by performing matrix factorization using SVD. 3. **Method `predict(self, user_idx: int, item_idx: int) -> float`** - Predict the rating for a specific user and item pair. 4. **Method `recommend(self, user_idx: int, n_recommendations: int = 5) -> List[int]`** - Provide top-N item recommendations for a given user. **Input/Output**: 1. **Constructor Parameters**: - `n_factors` (int): Number of latent factors. - `n_iterations` (int): Number of iterations for training the model. - `learning_rate` (float): Learning rate for gradient descent. - `regularization` (float): Regularization parameter to avoid overfitting. 2. **Method Parameters for `fit`**: - `user_item_matrix` (np.ndarray): User-item interaction matrix of shape (num_users, num_items). 3. **Method Parameters for `predict`**: - `user_idx` (int): Index of the user. - `item_idx` (int): Index of the item. 4. **Method Output for `predict`**: - Return (float): Predicted rating for the given user-item pair. 5. **Method Parameters for `recommend`**: - `user_idx` (int): Index of the user. - `n_recommendations` (int): Number of recommendations to provide (default is 5). 6. **Method Output for `recommend`**: - Return (List[int]): List of item indices recommended for the user. **Constraints**: - Handle typical edge cases and ensure numerical stability in your SVD implementation. - Optimize for efficiency in both time and space complexity, ensuring scalability. **Example**: ```python import numpy as np from typing import List class CustomSVDRecommender: def __init__(self, n_factors: int = 10, n_iterations: int = 20, learning_rate: float = 0.005, regularization: float = 0.02): # Implement the constructor pass def fit(self, user_item_matrix: np.ndarray) -> None: # Implement the fit method pass def predict(self, user_idx: int, item_idx: int) -> float: # Implement the predict method pass def recommend(self, user_idx: int, n_recommendations: int = 5) -> List[int]: # Implement the recommend method pass if __name__ == \\"__main__\\": # Sample user-item interaction matrix (users as rows, items as columns) user_item_matrix = np.array([ [5, 4, 0, 0, 3], [4, 0, 0, 2, 4], [0, 3, 0, 3, 0], [4, 0, 4, 0, 0], [0, 0, 0, 5, 5], ]) # Initialize and train the SVD recommender svd_rec = CustomSVDRecommender(n_factors=2, n_iterations=50, learning_rate=0.01, regularization=0.1) svd_rec.fit(user_item_matrix) # Predict rating for a specific user-item pair predicted_rating = svd_rec.predict(user_idx=0, item_idx=2) print(f\\"Predicted rating: {predicted_rating:.2f}\\") # Generate recommendations for a specific user recommendations = svd_rec.recommend(user_idx=0, n_recommendations=2) print(f\\"Recommendations: {recommendations}\\") ``` **Objective**: Demonstrate your understanding of collaborative filtering through SVD and implement a practical recommender system that can generate reliable recommendations based on user-item interactions.","solution":"import numpy as np from typing import List class CustomSVDRecommender: def __init__(self, n_factors: int = 10, n_iterations: int = 20, learning_rate: float = 0.005, regularization: float = 0.02): self.n_factors = n_factors self.n_iterations = n_iterations self.learning_rate = learning_rate self.regularization = regularization def fit(self, user_item_matrix: np.ndarray) -> None: self.user_item_matrix = user_item_matrix self.n_users, self.n_items = user_item_matrix.shape # Initialize user and item latent factor matrices self.user_factors = np.random.normal(scale=1./self.n_factors, size=(self.n_users, self.n_factors)) self.item_factors = np.random.normal(scale=1./self.n_factors, size=(self.n_items, self.n_factors)) # Perform stochastic gradient descent for matrix factorization for iteration in range(self.n_iterations): for i in range(self.n_users): for j in range(self.n_items): if self.user_item_matrix[i, j] > 0: # Non-zero rating prediction = self.predict(i, j) error = self.user_item_matrix[i, j] - prediction # Update user and item latent factors self.user_factors[i, :] += self.learning_rate * (error * self.item_factors[j, :] - self.regularization * self.user_factors[i, :]) self.item_factors[j, :] += self.learning_rate * (error * self.user_factors[i, :] - self.regularization * self.item_factors[j, :]) def predict(self, user_idx: int, item_idx: int) -> float: return self.user_factors[user_idx, :].dot(self.item_factors[item_idx, :]) def recommend(self, user_idx: int, n_recommendations: int = 5) -> List[int]: # Predict ratings for all items for given user predictions = np.array([self.predict(user_idx, item_idx) for item_idx in range(self.n_items)]) # Recommend items with highest predicted ratings that were not rated by the user rated_items = self.user_item_matrix[user_idx, :] > 0 predictions[rated_items] = -np.inf # Exclude already rated items recommended_items = np.argsort(predictions)[-n_recommendations:][::-1] return recommended_items.tolist()"},{"question":"# Coding Assessment Question Context: Design an efficient algorithm to simulate the behavior of a Least Recently Used (LRU) cache. An LRU cache evicts the least recently used item when it reaches its capacity. The cache should support O(1) operations for both fetching and storing items. Task: Implement the class `LRUCache` which: 1. Is initialized with a capacity. 2. Supports two methods: - `get(key: int) -> int`: Returns the value associated with the key if the key exists in the cache, otherwise it returns `-1`. - `put(key: int, value: int) -> None`: Updates the value associated with the key if the key exists. Otherwise, adds the key-value pair to the cache. If the cache reaches its capacity, evicts the least recently used item before adding the new one. Input: Class initialization and method calls as described above. Output: `get` method returns an integer value. `put` method returns nothing. Constraints: 1. The number of operations will be in the range `[1, 10^5]`. 2. The key and values will be non-negative integers. Example: ```python cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # returns 1 cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 # returns -1 (not found) cache.put(4, 4) # evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4 ``` Note: Efficiency is critical for passing all tests due to the upper limit on the number of operations. Use appropriate data structures to ensure O(1) time complexity for `get` and `put` methods. You may use the following class skeleton: ```python class LRUCache: def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass ```","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: if key in self.cache: value = self.cache.pop(key) self.cache[key] = value return value else: return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = value"},{"question":"# Problem Description Write a function that simulates a simple ATM system which allows users to perform basic banking operations such as checking their balance, depositing money, and withdrawing money. The ATM should also maintain a log of all transactions performed by each user. # Objective **Implement the function** `atm_system` **that meets the following requirements**: - The function should perform banking operations based on user commands. - Each user has a separate account that starts with a balance of zero. - The function should return appropriate responses for each command and update the user\'s account accordingly. # Function Signature ```python def atm_system(commands: List[str]) -> List[str]: pass ``` # Input - `commands` (List[str]): A list of commands where each command is formatted as follows: - `\\"CREATE user_id\\"`: Creates a new account for the user with the given `user_id`. - `\\"BALANCE user_id\\"`: Returns the current balance for the user with the given `user_id`. - `\\"DEPOSIT user_id amount\\"`: Deposits the specified `amount` in the user\'s account. - `\\"WITHDRAW user_id amount\\"`: Withdraws the specified `amount` from the user\'s account. - `\\"TRANSACTIONS user_id\\"`: Returns a list of all transactions for the user with the given `user_id`. # Output - The function should return a list of strings, one for each command. Each string should represent the result of the corresponding command: - For `\\"CREATE\\"`: Return `\\"Account created for user_id\\"`. - For `\\"BALANCE\\"`: Return `\\"Balance for user_id: current_balance\\"`. - For `\\"DEPOSIT\\"`: Return `\\"Deposited amount to user_id\\"`. - For `\\"WITHDRAW\\"`: Return `\\"Withdrew amount from user_id\\"` or `\\"Insufficient balance\\"`. - For `\\"TRANSACTIONS\\"`: Return the list of transactions in the format `[\\"Transaction 1\\", \\"Transaction 2\\", ...]`. # Constraints - All `user_id` and `amount` fields are positive integers. - The withdrawals should not exceed the current balance. # Example ```python commands = [ \\"CREATE 1\\", \\"DEPOSIT 1 100\\", \\"BALANCE 1\\", \\"WITHDRAW 1 50\\", \\"BALANCE 1\\", \\"WITHDRAW 1 100\\", \\"TRANSACTIONS 1\\" ] result = atm_system(commands) print(result) # Expected Output: # [ # \\"Account created for 1\\", # \\"Deposited 100 to 1\\", # \\"Balance for 1: 100\\", # \\"Withdrew 50 from 1\\", # \\"Balance for 1: 50\\", # \\"Insufficient balance\\", # [\\"Deposited 100\\", \\"Withdrew 50\\"] # ] ``` # Hints - Use a dictionary to store the user\'s balances and their transaction logs. - Ensure to handle edge cases such as creating an account that already exists or performing operations on a non-existent account.","solution":"def atm_system(commands): accounts = {} results = [] for command in commands: parts = command.split() action = parts[0] user_id = int(parts[1]) if action == \\"CREATE\\": if user_id not in accounts: accounts[user_id] = {\\"balance\\": 0, \\"transactions\\": []} results.append(f\\"Account created for {user_id}\\") else: results.append(f\\"Account for {user_id} already exists\\") elif action == \\"BALANCE\\": if user_id in accounts: results.append(f\\"Balance for {user_id}: {accounts[user_id][\'balance\']}\\") else: results.append(f\\"Account for {user_id} does not exist\\") elif action == \\"DEPOSIT\\": amount = int(parts[2]) if user_id in accounts: accounts[user_id][\\"balance\\"] += amount accounts[user_id][\\"transactions\\"].append(f\\"Deposited {amount}\\") results.append(f\\"Deposited {amount} to {user_id}\\") else: results.append(f\\"Account for {user_id} does not exist\\") elif action == \\"WITHDRAW\\": amount = int(parts[2]) if user_id in accounts: if accounts[user_id][\\"balance\\"] >= amount: accounts[user_id][\\"balance\\"] -= amount accounts[user_id][\\"transactions\\"].append(f\\"Withdrew {amount}\\") results.append(f\\"Withdrew {amount} from {user_id}\\") else: results.append(\\"Insufficient balance\\") else: results.append(f\\"Account for {user_id} does not exist\\") elif action == \\"TRANSACTIONS\\": if user_id in accounts: results.append(accounts[user_id][\\"transactions\\"]) else: results.append(f\\"Account for {user_id} does not exist\\") return results"},{"question":"# Problem Statement: Write a function `compress_string(s: str) -> str` that implements a basic run-length encoding algorithm to compress a given string. The function should return the compressed version of the string if the compressed string is shorter than the original; otherwise, it should return the original string unchanged. # Input: * `s` (str): A string consisting of alphanumeric characters. # Output: * Returns a string which is the compressed version of the input if it\'s shorter than the original, otherwise, it returns the original string. # Examples: ```python assert compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" assert compress_string(\\"abcdef\\") == \\"abcdef\\" assert compress_string(\\"aabbccddeeff\\") == \\"aabbccddeeff\\" assert compress_string(\\"aaaaa\\") == \\"a5\\" ``` # Constraints: * The string can contain both uppercase and lowercase letters. * The input string length will not exceed 10^4. # Performance Requirements: 1. The function should efficiently handle strings up to the maximum limit. 2. Ensure the algorithm is optimized for both space and time complexities. # Implementation Guidelines: 1. Traverse the input string and count consecutive characters. 2. Build the compressed string using the counts and corresponding characters. 3. Compare lengths of the compressed and original strings to decide the return value. 4. Ensure proper handling of edge cases, such as empty strings or strings with no repeated characters.","solution":"def compress_string(s: str) -> str: Compress a string using run-length encoding. If the compressed string is not shorter than the original, returns the original string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_str = \'\'.join(compressed) return compressed_str if len(compressed_str) < len(s) else s"},{"question":"# Context You are provided with a class `CircularDeque` that models a circular double-ended queue (deque) using an array. However, the current implementation has limitations on how it handles operations, particularly when the capacity limit is reached. # Task Refactor the provided `CircularDeque` class to enhance its functionality, ensuring that it can dynamically resize the underlying array when necessary. This will allow the deque to handle more elements even after reaching its initial capacity. # Requirements 1. Implement methods – `insertFront(item)`, `insertLast(item)`, `deleteFront()`, `deleteLast()`, `getFront()`, `getRear()`, `isEmpty()`, `isFull()`, and `size()`. 2. Ensure `insertFront(item)` and `insertLast(item)` can handle dynamic resizes seamlessly. 3. The `deleteFront()` and `deleteLast()` methods should correctly handle underflow conditions by preventing invalid deletions when the deque is empty. 4. The `size()` method should return the current number of elements in the deque. # Input/Output - The `insertFront(item)` method adds an item to the front of the deque if not full. - The `insertLast(item)` method adds an item to the rear of the deque if not full. - The `deleteFront()` method removes and returns the item from the front of the deque. Assumption: the deque will not be empty when deleteFront is called. - The `deleteLast()` method removes and returns the item from the rear of the deque. Assumption: the deque will not be empty when deleteLast is called. - The `getFront()` method returns the item at the front without removing it. - The `getRear()` method returns the item at the rear without removing it. - The `isEmpty()` method returns `True` if the deque is empty, `False` otherwise. - The `isFull()` method returns `True` if the deque is full, `False` otherwise. - The `size()` method returns the number of elements in the deque. # Example ```python dq = CircularDeque(3) print(dq.isEmpty()) # Output: True dq.insertLast(1) dq.insertLast(2) dq.insertFront(3) print(dq.insertFront(4)) # Output: False (since the deque is already full with initial capacity) print(dq.getRear()) # Output: 2 print(dq.isFull()) # Output: True dq.deleteLast() print(dq.insertFront(4)) # This insert will now be possible print(dq.getFront()) # Output: 4 print(dq.size()) # Output: 3 ``` # Notes * Focus on managing the circular nature of the deque to optimize space usage and maintain O(1) complexity for insertion and deletion from both ends where possible. * Ensure that resizing the array maintains the state of elements in the correct order.","solution":"class CircularDeque: def __init__(self, k: int): self.capacity = k self.deque = [None] * k self.size = 0 self.front = 0 self.rear = -1 def insertFront(self, item: int) -> bool: if self.size == self.capacity: self.resize() if self.size == 0: self.front = self.rear = 0 else: self.front = (self.front - 1) % self.capacity self.deque[self.front] = item self.size += 1 return True def insertLast(self, item: int) -> bool: if self.size == self.capacity: self.resize() if self.size == 0: self.front = self.rear = 0 else: self.rear = (self.rear + 1) % self.capacity self.deque[self.rear] = item self.size += 1 return True def deleteFront(self) -> int: if self.size == 0: return -1 # Underflow condition, deque is empty item = self.deque[self.front] self.deque[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return item def deleteLast(self) -> int: if self.size == 0: return -1 # Underflow condition, deque is empty item = self.deque[self.rear] self.deque[self.rear] = None self.rear = (self.rear - 1) % self.capacity self.size -= 1 return item def getFront(self) -> int: if self.size == 0: return -1 # Empty deque return self.deque[self.front] def getRear(self) -> int: if self.size == 0: return -1 # Empty deque return self.deque[self.rear] def isEmpty(self) -> bool: return self.size == 0 def isFull(self) -> bool: return self.size == self.capacity def size(self) -> int: return self.size def resize(self): new_capacity = self.capacity * 2 new_deque = [None] * new_capacity for i in range(self.size): new_deque[i] = self.deque[(self.front + i) % self.capacity] self.front = 0 self.rear = self.size - 1 self.capacity = new_capacity self.deque = new_deque"},{"question":"# Subarray with Given Sum Problem Statement You are given an array of integers and a target sum. Your task is to identify if there exists a contiguous subarray within the array that adds up to the given target sum. This problem can be efficiently solved using the sliding window technique or hashing. Function Signature ```python def subarray_with_sum(arr: list[int], target: int) -> bool: pass ``` Input * The input parameters are: * `arr` - a list of integers representing the array. * `target` - an integer representing the target sum. Output * The function should return a boolean: * `True` if there exists a contiguous subarray that sums up to the target. * `False` otherwise. Constraints 1. The length of the array is at most 10^5. 2. Each element in the array is between -10^4 and 10^4. 3. The target sum is between -10^9 and 10^9. Examples ```python >>> subarray_with_sum([1, 2, 3, 7, 5], 12) True >>> subarray_with_sum([1, 2, 3, 7, 5], 15) True >>> subarray_with_sum([-1, 2, 3, -4, 5], 0) True >>> subarray_with_sum([1, 2, 3, 4, 5], 20) False >>> subarray_with_sum([10, 2, -2, -20, 10], -10) True ``` Explanation 1. In the first example, the subarray `[2, 3, 7]` sums up to 12. 2. In the second example, the entire array sums up to 15. 3. In the third example, the subarray `[2, 3, -4, -1]` sums up to 0. 4. In the fourth example, no subarray sums up to 20. 5. In the fifth example, the subarray `[10, 2, -2, -20]` sums up to -10.","solution":"def subarray_with_sum(arr: list[int], target: int) -> bool: Determines if there exists a contiguous subarray within the array that adds up to the given target sum. current_sum = 0 sum_map = {} for idx, value in enumerate(arr): current_sum += value if current_sum == target: return True if (current_sum - target) in sum_map: return True sum_map[current_sum] = idx return False"},{"question":"# Subarray with Maximum Sum Problem Statement Given an array of integers, find the subarray with the maximum sum. A subarray is a contiguous part of an array. The problem is often referred to as the \\"maximum subarray problem.\\" Task Write a function `max_subarray_sum` that computes the sum of the subarray with the maximum sum. # Function Signature ```python def max_subarray_sum(arr: List[int]) -> int: ``` Parameters - `arr` (List[int]): A list of integers. Returns - `int`: The sum of the subarray with the maximum sum. Example ```python assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 # Explanation: [4, -1, 2, 1] has the largest sum = 6 assert max_subarray_sum([1]) == 1 # Explanation: [1] has the largest sum = 1 assert max_subarray_sum([5, 4, -1, 7, 8]) == 23 # Explanation: [5, 4, -1, 7, 8] has the largest sum = 23 ``` Constraints - 1 ≤ len(arr) ≤ 10^5 - -10^4 ≤ arr[i] ≤ 10^4 Scenario You are developing a feature for a financial application where users can track their expenses and income. To assist users in identifying periods of highest financial gain, you need to implement an algorithm that finds the contiguous time period where the user\'s net income was maximized. This task will help ensure users gain better insights into their finances.","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Computes the sum of the subarray with the maximum sum using Kadane\'s algorithm. if not arr: return 0 current_sum = max_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Coding Assessment Question Problem Statement: You are given a string `s` consisting of only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', and you need to decide if the string forms a valid set of nested parentheses. A string is considered valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. Write a function `isValid(s)` that returns `True` if the string is valid, and `False` otherwise. Function Signature: ```python def isValid(s: str) -> bool: ``` Parameters: - `s` (str): A string containing characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. Returns: - `bool`: Returns `True` if the string forms a valid set of nested parentheses, otherwise returns `False`. Example: ```python assert isValid(\\"()\\") == True assert isValid(\\"()[]{}\\") == True assert isValid(\\"(]\\") == False assert isValid(\\"([)]\\") == False assert isValid(\\"{[]}\\") == True ``` Constraints: - The length of the string `s` will be between 1 and 10,000. Performance Requirements: - Your solution should have a time complexity of O(n), where `n` is the length of the string. - Your solution should use O(n) additional space for the stack. Scenario: Imagine you are working on a code editor that needs to check for balanced parentheses to assist with syntax highlighting and code formatting. The editor needs to determine if the parentheses in a given code snippet are properly opened and closed according to the rules of nested parentheses.","solution":"def isValid(s: str) -> bool: Function to check if the string s is a valid set of nested parentheses. Parameters: s (str): A string containing characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. Returns: bool: Returns True if the string forms a valid set of nested parentheses, otherwise returns False. stack = [] # Mapping of closing to opening parentheses parentheses_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in parentheses_map: top_element = stack.pop() if stack else \'#\' if parentheses_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"# Problem Statement You are tasked with writing a function that mimics the behavior of cycling through a list. The function should take a list and an integer `n` as arguments and rotate the list to the right `n` times. # Function Signature ```python def cycle_list(lst: list, n: int) -> list: Rotates the list to the right n times. :param lst: The input list to be cycled. :param n: The number of rotations to perform. :return: A new list that has been rotated. ``` # Input Format * The `lst` parameter is a list of integers. * The `n` parameter is a non-negative integer. # Output Format * A new list that has been rotated to the right `n` times. # Constraints * The input list `lst` will have a length of (0 leq |text{lst}| leq 10^4). * The integers in the list are within the range of (-10^6) to (10^6). * (0 leq n leq 10^5). # Example ```python >>> cycle_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> cycle_list([10, 20, 30, 40], 1) [40, 10, 20, 30] >>> cycle_list([], 3) [] >>> cycle_list([7, 8, 9], 0) [7, 8, 9] ``` # Explanation In the example `cycle_list([1, 2, 3, 4, 5], 2)`, the function rotates the list to the right by 2 positions, resulting in the list `[4, 5, 1, 2, 3]`. # Additional Notes Consider edge cases such as: * When the list is empty. * When the number of rotations exceeds the length of the list (in which case, rotations should cycle back to the start). Implement the function to conform to the given constraints and handle edge cases gracefully.","solution":"def cycle_list(lst: list, n: int) -> list: Rotates the list to the right n times. :param lst: The input list to be cycled. :param n: The number of rotations to perform. :return: A new list that has been rotated. if not lst: # If the list is empty, return it as is. return lst n = n % len(lst) # Handle cases where n is larger than the length of the list. return lst[-n:] + lst[:-n]"},{"question":"# Fibonacci Sequence Iterator Implement an iterator class that generates the Fibonacci sequence up to a given number of elements. The Fibonacci sequence is defined as follows: - The first two numbers are 0 and 1. - Each subsequent number is the sum of the previous two numbers. Class Signature ```python class Fibonacci: def __init__(self, n: int): pass def __iter__(self): pass def __next__(self): pass ``` # Input - `n` (int): The number of elements in the Fibonacci sequence to generate. (1 <= n <= 1000) # Output - `__iter__` should return the iterator object itself. - `__next__` should return the next Fibonacci number in the sequence until the total number `n` is reached. # Example ```python fib = Fibonacci(10) output = list(fib) # Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ``` # Constraints - You must use the iterator protocol (`__iter__` and `__next__` methods). - The class should handle cases where `n` is 1 or 2, returning [0] and [0, 1] respectively. - The solution should be efficient with respect to both time and space. Performance Requirements - The time complexity should be O(n) where n is the number of Fibonacci elements. - The space complexity should be O(1) for storing the internal state of the iterator. # Notes - Ensure the class handles edge cases such as `n` being 1 and the sequence generating correctly in these cases. - Implement error handling where appropriate, particularly ensuring that after `n` elements, `StopIteration` is raised. **Hint:** Use two internal variables to keep track of the last two Fibonacci numbers.","solution":"class Fibonacci: def __init__(self, n: int): self.n = n self.current_index = 0 self.a = 0 self.b = 1 def __iter__(self): return self def __next__(self): if self.current_index >= self.n: raise StopIteration if self.current_index == 0: self.current_index += 1 return self.a if self.current_index == 1: self.current_index += 1 return self.b next_value = self.a + self.b self.a = self.b self.b = next_value self.current_index += 1 return next_value"},{"question":"# Problem Statement Create a library system that helps manage book loans and returns. The system should support the following functionalities: 1. **Book Borrowing**: - A function to borrow a book by providing the book\'s title and the member\'s ID. - Ensure that the book is marked as borrowed by the member and not available for others. 2. **Book Returning**: - A function to return a borrowed book using the book\'s title and the member\'s ID. - Ensure the book is marked as available for others once it is returned. 3. **Overdue Notification**: - Implement a method to notify members about overdue books. - A book is considered overdue if it is not returned within 14 days. # Method Signatures ```python from datetime import datetime, timedelta class LibrarySystem: def __init__(self): Initialize the LibrarySystem with an empty collection of books and an empty record of borrowed books. pass def add_book(self, title: str) -> None: Add a book to the library collection by title. Args: - title (str): The title of the book. pass def borrow_book(self, title: str, member_id: int) -> bool: Borrow a book from the library. Args: - title (str): The title of the book to be borrowed. - member_id (int): The ID of the member borrowing the book. Returns: - bool: True if the book was successfully borrowed, False if the book is not available. pass def return_book(self, title: str, member_id: int) -> bool: Return a borrowed book to the library. Args: - title (str): The title of the book to be returned. - member_id (int): The ID of the member returning the book. Returns: - bool: True if the book was successfully returned, False if there was an issue (e.g., wrong member ID). pass def overdue_books(self) -> dict[int, list[str]]: Notify members about overdue books. Returns: - dict[int, list[str]]: A dictionary where the key is the member\'s ID and the value is a list of overdue book titles. pass ``` # Constraints - Assume each book title is unique. - The return process only needs to handle valid (previously borrowed) cases. - The library operates on a 24-hour basis, and all times are considered in UTC. # Example Usage ```python # Initialize the LibrarySystem library = LibrarySystem() # Add books to the library library.add_book(\\"Python Programming\\") library.add_book(\\"Data Structures and Algorithms\\") # Member 101 borrows \\"Python Programming\\" assert library.borrow_book(\\"Python Programming\\", 101) == True # Successfully borrowed # Attempt to borrow the same book by another member should fail assert library.borrow_book(\\"Python Programming\\", 102) == False # Already borrowed # Member 101 returns \\"Python Programming\\" assert library.return_book(\\"Python Programming\\", 101) == True # Successfully returned # The same book can now be borrowed by another member assert library.borrow_book(\\"Python Programming\\", 102) == True # Successfully borrowed # Simulate book overdue for member 102 # Assume the current date is 2023-10-18 and the books were borrowed 15 days ago from datetime import datetime, timedelta overdue_list = library.overdue_books() print(overdue_list) # May print: {102: [\'Python Programming\']} ``` **Your task is to complete the implementation of the `LibrarySystem` class as specified above. Ensure to handle borrowing, returning, and overdue notifications appropriately.**","solution":"from datetime import datetime, timedelta class LibrarySystem: def __init__(self): self.books = {} # Holds book titles and their availability status self.borrowed_books = {} # Holds borrowed books with member ID and borrow date def add_book(self, title: str) -> None: if title not in self.books: self.books[title] = True # Mark book as available def borrow_book(self, title: str, member_id: int) -> bool: if title in self.books and self.books[title]: # Check if book exists and is available self.books[title] = False # Mark book as borrowed self.borrowed_books[title] = {\'member_id\': member_id, \'borrow_date\': datetime.utcnow()} return True return False def return_book(self, title: str, member_id: int) -> bool: if title in self.borrowed_books and self.borrowed_books[title][\'member_id\'] == member_id: self.books[title] = True # Mark book as available del self.borrowed_books[title] # Remove it from the borrowed records return True return False def overdue_books(self) -> dict[int, list[str]]: overdue_threshold = timedelta(days=14) current_time = datetime.utcnow() overdue_notifications = {} for title, info in self.borrowed_books.items(): borrow_date = info[\'borrow_date\'] if current_time - borrow_date > overdue_threshold: member_id = info[\'member_id\'] if member_id not in overdue_notifications: overdue_notifications[member_id] = [] overdue_notifications[member_id].append(title) return overdue_notifications"},{"question":"# Finding the Missing Number in an Arithmetic Progression You are asked to implement a function that identifies the missing number in an arithmetic progression (AP). An arithmetic progression is a sequence of numbers such that the difference between consecutive terms is constant. Given a list representing an incomplete arithmetic progression with exactly one number missing, your task is to find the missing number. Requirements - **Function Name**: `find_missing_number` - **Input**: A list of numbers `sequence: list`. - **Output**: The missing number as a single integer or floating-point number. Constraints 1. The input list will have at least 3 elements and at most 10^4 elements. 2. The elements in the list are part of a valid arithmetic progression with exactly one number missing. 3. The difference between consecutive terms (common difference) in the progression can be positive or negative, and it can be a whole number or a floating-point number. 4. The list elements can be integers or floating-point numbers. Expected Performance - The implementation should run in O(n) time complexity where n is the length of the input list. - Space complexity should be O(1). # Example ```python find_missing_number([2, 4, 8, 10]) # Output: 6 find_missing_number([3, 7, 11, 15, 19, 27]) # Output: 23 find_missing_number([-3.0, -2.0, 0.0, 1.0]) # Output: -1.0 find_missing_number([1.5, 2.0, 2.5, 3.5]) # Output: 3.0 find_missing_number([50, 60, 80, 90]) # Output: 70 ``` # Implementation Details - Identify the common difference by examining the differences between the first few terms. - Traverse the list to find where the arithmetic progression fails. - Calculate and return the missing number. - Make sure to handle floating-point arithmetic precision appropriately. Note Do not use any built-in functions to find the common difference or the missing term directly. Implement the logic from scratch to calculate the missing number.","solution":"def find_missing_number(sequence): Identifies the missing number in an arithmetic progression. :param sequence: List of numbers representing the incomplete arithmetic progression. :return: The missing number as a single integer or floating-point number. n = len(sequence) + 1 total_sum = n * (sequence[0] + sequence[-1]) / 2 missing_number = total_sum - sum(sequence) return missing_number"},{"question":"# Question: Mathematical Functions Implementation and Validation You are required to implement three functions that perform different mathematical operations: calculating the factorial of a non-negative integer, determining if a number is prime, and finding the greatest common divisor (GCD) of two integers. Each function must handle input validations and return appropriate results following mathematical principles. Function 1: `factorial(n: int) -> int` **Calculate the factorial of a non-negative integer.** - **Input**: - `n` (int): A non-negative integer. - **Output**: - `int`: The factorial of `n`. - **Constraints**: - `n` must be a non-negative integer (i.e., `n >= 0`). Function 2: `is_prime(number: int) -> bool` **Determine if a given number is a prime number.** - **Input**: - `number` (int): An integer to check for primality. - **Output**: - `bool`: `True` if the number is prime, `False` otherwise. - **Constraints**: - `number` must be a non-negative integer (i.e., `number >= 0`). Function 3: `gcd(a: int, b: int) -> int` **Find the greatest common divisor of two integers using the Euclidean algorithm.** - **Input**: - `a` (int): The first integer. - `b` (int): The second integer. - **Output**: - `int`: The greatest common divisor of `a` and `b`. - **Constraints**: - Both `a` and `b` must be non-negative integers (i.e., `a >= 0` and `b >= 0`). # Testing & Validation - Include checks for invalid inputs, such as negative values. - Use various test cases to validate the correctness of your implementations. Example Usage ```python # Factorial print(factorial(5)) # Output: 120 # Prime checking print(is_prime(11)) # Output: True print(is_prime(4)) # Output: False # GCD print(gcd(54, 24)) # Output: 6 print(gcd(48, 180)) # Output: 12 ```","solution":"def factorial(n: int) -> int: Calculate the factorial of a non-negative integer n. if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") result = 1 for i in range(1, n + 1): result *= i return result def is_prime(number: int) -> bool: Determine if a given number is a prime number. if number < 2: return False for i in range(2, int(number ** 0.5) + 1): if number % i == 0: return False return True def gcd(a: int, b: int) -> int: Find the greatest common divisor of two integers using the Euclidean algorithm. if a < 0 or b < 0: raise ValueError(\\"Inputs must be non-negative integers.\\") while b: a, b = b, a % b return a"},{"question":"# Question: Implement a System for Matching Projects to Teams with Preferences **Context**: You are part of a project management team at a tech company where different project ideas need to be assigned to development teams based on both the projects\' preferences for teams and the teams\' preferences for projects. The goal is to find a stable matching, ensuring that no team and project would both prefer to be matched with each other over their current assignments. You will implement a function `stable_project_team_matching` that takes in preferences for projects and teams, and returns a stable matching. **Function Signature**: ```python def stable_project_team_matching( project_pref: list[list[int]], team_pref: list[list[int]] ) -> list[int]: pass ``` **Input**: - `project_pref`: A list of lists where each sub-list contains the preferences of the respective project for teams indexed from 0 to n-1. - `team_pref`: A list of lists where each sub-list contains the preferences of the respective team for projects indexed from 0 to n-1. **Output**: - Returns a list of integers where the index represents a project and the value at that index represents the team assigned to that project. **Constraints**: - Each list (projects\' and teams\' preferences) will have the same number of sub-lists indicating that every project and every team has a full list of preferences. - All preferences are valid and contain no repetitions. **Example**: ```python project_pref = [ [1, 0, 2], # Project 0\'s preferences for teams [2, 1, 0], # Project 1\'s preferences for teams [0, 2, 1] # Project 2\'s preferences for teams ] team_pref = [ [2, 0, 1], # Team 0\'s preferences for projects [0, 1, 2], # Team 1\'s preferences for projects [1, 2, 0] # Team 2\'s preferences for projects ] stable_project_team_matching(project_pref, team_pref) # Expected output: [1, 2, 0] ``` # Guidelines: 1. Adapt the stable marriage problem principles to ensure a stable matching where no project and team would both prefer to be matched with each other over their current assignments. 2. Consider how projects may need to re-apply if their most preferred teams are unavailable. 3. Ensure the algorithm continues until every project is assigned to a team, making sure all matchings are stable.","solution":"def stable_project_team_matching(project_pref, team_pref): n = len(project_pref) # Tracking which team each project ends up being matched to project_match = [-1] * n # Tracking which project each team ends up being matched to team_match = [-1] * n # List for each team, keeping track of their preference index for projects team_next_proposal = [0] * n # Convert preferences to ranking for quick comparison project_rank = [ {team: rank for rank, team in enumerate(prefs)} for prefs in project_pref ] # Projects which are currently not matched to any team free_projects = list(range(n)) while free_projects: project = free_projects.pop(0) # Project\'s next highest preference (based on team_next_proposal) preferred_team_index = team_next_proposal[project] preferred_team = project_pref[project][preferred_team_index] current_project_match = team_match[preferred_team] if current_project_match == -1: # Team is free, match the project and the team project_match[project] = preferred_team team_match[preferred_team] = project else: # Team is currently matched, decide whether to swap preference_current = team_pref[preferred_team].index(current_project_match) preference_new = team_pref[preferred_team].index(project) if preference_new < preference_current: # Team prefers the new project over the current match project_match[current_project_match] = -1 free_projects.append(current_project_match) project_match[project] = preferred_team team_match[preferred_team] = project else: # Team prefers the current match, reject the new project free_projects.append(project) # Move to next team preference for the project team_next_proposal[project] += 1 return project_match"},{"question":"Scenario: You are developing a system for managing a collection of books in a library. Each book has a unique identifier, title, author, and year of publication. Your task is to implement a `Library` class that can add new books, update the information of existing books, search for books by their title, and remove books from the collection. Instructions: - Implement the `Library` class as described. - The `add_book` method should add a new book to the collection. - The `update_book` method should update an existing book\'s information. - The `find_book_by_title` method should search and return a list of books that match the given title. - The `remove_book` method should remove a book from the collection based on its unique identifier. Function Signature: The function signatures should be as follows: ```python class Library: def __init__(self): # Initialization code goes here def add_book(self, book_id: int, title: str, author: str, year: int): # Code to add book goes here def update_book(self, book_id: int, title: str, author: str, year: int): # Code to update book information goes here def find_book_by_title(self, title: str) -> List[Dict[str, Any]]: # Code to find books by title goes here def remove_book(self, book_id: int): # Code to remove book goes here ``` Expected Input and Output: **Input**: - Book information provided as individual parameters. **Output**: - The `find_book_by_title` should return a list of dictionaries containing book information that matches the search title. Sample Input: ```python library = Library() library.add_book(1, \\"The Catcher in the Rye\\", \\"J.D. Salinger\\", 1951) library.add_book(2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) library.add_book(3, \\"1984\\", \\"George Orwell\\", 1949) library.add_book(4, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925) library.update_book(3, \\"Nineteen Eighty-Four\\", \\"George Orwell\\", 1949) print(library.find_book_by_title(\\"The Great Gatsby\\")) # Output should be [{\'id\': 4, \'title\': \'The Great Gatsby\', \'author\': \'F. Scott Fitzgerald\', \'year\': 1925}] print(library.find_book_by_title(\\"1984\\")) # Output should be [] library.remove_book(2) print(library.find_book_by_title(\\"To Kill a Mockingbird\\")) # Output should be [] ``` Constraints: - Book titles, authors\' names, and publication years are stored as strings and integers respectively. - Book identifiers are unique within the library. Performance Requirements: The data structure chosen should allow efficient addition, updating, searching, and deletion operations. Notes: - Raise exceptions for operations involving non-existent book identifiers. - Ensure the return format for `find_book_by_title` is consistent as specified.","solution":"class Library: def __init__(self): self.books = {} def add_book(self, book_id: int, title: str, author: str, year: int): if book_id in self.books: raise ValueError(\\"Book with this ID already exists.\\") self.books[book_id] = {\'title\': title, \'author\': author, \'year\': year} def update_book(self, book_id: int, title: str, author: str, year: int): if book_id not in self.books: raise ValueError(\\"Book with this ID does not exist.\\") self.books[book_id] = {\'title\': title, \'author\': author, \'year\': year} def find_book_by_title(self, title: str): return [{\'id\': book_id, **info} for book_id, info in self.books.items() if info[\'title\'] == title] def remove_book(self, book_id: int): if book_id not in self.books: raise ValueError(\\"Book with this ID does not exist.\\") del self.books[book_id]"},{"question":"# Matrix Rotation by 90 Degrees Background Matrix manipulation is a common topic in computer science and can be essential in various applications, such as image processing and computer graphics. One frequent operation is the rotation of a matrix by 90 degrees. Task Implement a function that rotates a given ( n times n ) matrix by 90 degrees clockwise. The rotation should be done in place, meaning you should not use any additional storage for another matrix. Your function should have the following signature: ```python def rotate_matrix(matrix: list[list[int]]) -> None: ``` Constraints * The matrix will have dimensions ( n times n ) where ( 1 leq n leq 1000 ). * Elements of the matrix will be integers in the range (-10^9 leq text{element} leq 10^9). Example Usage ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ], \\"Test Case 1 Failed\\" matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_matrix(matrix) assert matrix == [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ], \\"Test Case 2 Failed\\" print(\\"All test cases passed!\\") ``` Notes * Write appropriate unit tests to verify your matrix rotation implementation. * Handle edge cases and potential exceptions properly. * Ensure the solution is efficient given the constraints.","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the given n x n matrix by 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Question Scenario: You are tasked with optimizing a legacy code base for a warehouse management system. One of the improvements needed is on a function that determines the number of unique products. The original function is slow due to its use of nested loops. Your goal is to write a more efficient solution using a dictionary-based approach. Task: Write a Python function `count_unique_products` that takes a list of product IDs (integers) and returns the count of unique product IDs using dictionary data structures for increased efficiency. Function Signature: ```python def count_unique_products(product_ids: list[int]) -> int: ``` Input: - A list of integers, `product_ids` (0 <= len(product_ids) <= 10^5). Output: - An integer representing the number of unique product IDs. Constraints: - The function should have a time complexity of (O(n)), where (n) is the length of the product_ids list. - The space complexity should be (O(n)) to store the unique product IDs in a dictionary. - Handle edge cases such as an empty list and lists with all duplicate values. Example Usage: ```python >>> count_unique_products([101, 102, 103, 101, 104]) 4 >>> count_unique_products([100, 100, 100, 100]) 1 >>> count_unique_products([1, 2, 3, 4, 5]) 5 >>> count_unique_products([]) 0 >>> count_unique_products([99, 98, 99, 97, 96, 96, 98]) 4 ```","solution":"def count_unique_products(product_ids: list[int]) -> int: Returns the count of unique product IDs. Args: product_ids (list of int): List of product IDs. Returns: int: Number of unique product IDs. unique_products = {} for pid in product_ids: unique_products[pid] = True return len(unique_products)"},{"question":"# Context: You have been hired to develop a data management function that handles user profile information. The function needs to support the addition of new user profiles and retrieval of existing profiles based on a unique user ID. Each profile includes the user ID, name, email, and age. # Task: **Implement** the profile management mechanism as described below. # Function Definitions: 1. **add_profile**(`profiles: dict, user_id: int, name: str, email: str, age: int`) -> `None`: - **Input**: - `profiles`: A dictionary to store user profiles where the key is the user ID and the value is another dictionary with the keys `name`, `email`, and `age`. - `user_id`: An integer representing the unique ID of the user. - `name`: A string representing the name of the user. - `email`: A string representing the email address of the user. - `age`: An integer representing the age of the user. - **Output**: None. The function should modify the `profiles` dictionary in-place by adding the new user profile. 2. **get_profile**(`profiles: dict, user_id: int`) -> `dict`: - **Input**: - `profiles`: The dictionary containing user profiles. - `user_id`: An integer representing the unique ID of the user whose profile needs to be retrieved. - **Output**: A dictionary containing the user\'s profile details (`name`, `email`, `age`) if the user ID exists, otherwise return an empty dictionary. # Constraints: - User IDs are unique integers. - Name and email are non-empty strings. - Age is a positive integer. # Example: ```python def add_profile(profiles: dict, user_id: int, name: str, email: str, age: int) -> None: # Your implementation here profiles[user_id] = {\\"name\\": name, \\"email\\": email, \\"age\\": age} def get_profile(profiles: dict, user_id: int) -> dict: # Your implementation here return profiles.get(user_id, {}) if __name__ == \\"__main__\\": user_profiles = {} add_profile(user_profiles, 1, \\"Alice\\", \\"alice@example.com\\", 25) add_profile(user_profiles, 2, \\"Bob\\", \\"bob@example.com\\", 30) print(get_profile(user_profiles, 1)) # Output: {\'name\': \'Alice\', \'email\': \'alice@example.com\', \'age\': 25} print(get_profile(user_profiles, 3)) # Output: {} ``` **Example Usage**: ```python user_profiles = {} add_profile(user_profiles, 1, \\"Alice\\", \\"alice@example.com\\", 25) add_profile(user_profiles, 2, \\"Bob\\", \\"bob@example.com\\", 30) profile1 = get_profile(user_profiles, 1) # profile1 => {\'name\': \'Alice\', \'email\': \'alice@example.com\', \'age\': 25} profile2 = get_profile(user_profiles, 3) # profile2 => {} ```","solution":"def add_profile(profiles: dict, user_id: int, name: str, email: str, age: int) -> None: Adds a new user profile to the profiles dictionary. Args: profiles (dict): A dictionary to store user profiles. user_id (int): An integer representing the unique ID of the user. name (str): A string representing the name of the user. email (str): A string representing the email address of the user. age (int): An integer representing the age of the user. Returns: None. The function modifies the profiles dictionary in-place. profiles[user_id] = {\\"name\\": name, \\"email\\": email, \\"age\\": age} def get_profile(profiles: dict, user_id: int) -> dict: Retrieves a user profile from the profiles dictionary based on the user ID. Args: profiles (dict): The dictionary containing user profiles. user_id (int): An integer representing the unique ID of the user whose profile needs to be retrieved. Returns: dict: A dictionary containing the user\'s profile details (`name`, `email`, `age`) if the user ID exists, otherwise an empty dictionary. return profiles.get(user_id, {})"},{"question":"# Question Implement a function `find_k_closest_points(points: List[Tuple[int, int]], k: int) -> List[Tuple[int, int]]` that returns the `k` closest points to the origin (0, 0) from a given list of points in a 2D plane. The distance between two points (x1, y1) and (x2, y2) is defined as the Euclidean distance: `sqrt((x1 - x2)^2 + (y1 - y2)^2)`. For the purposes of comparison, you can ignore the square root operation to avoid unnecessary floating-point arithmetic. Input - `points` (List[Tuple[int, int]]): A list of tuples where each tuple represents the coordinates `(x, y)` of a point in the 2D plane. - `k` (int): An integer representing the number of closest points to return. Output - Returns a list of `k` points closest to the origin, sorted by their Euclidean distance from the origin. Constraints - 1 ≤ `len(points)` ≤ 10,000 - `k` ≤ `len(points)` - Each coordinate will be an integer within the range [-10^4, 10^4] # Example ```python >>> find_k_closest_points([(1, 3), (-2, 2), (5, 8), (0, 1)], 2) [(-2, 2), (0, 1)] >>> find_k_closest_points([(3, 3), (5, -1), (-2, 4)], 1) [(3, 3)] >>> find_k_closest_points([(1, 2), (2, 1), (2, 2), (4, 5)], 3) [(1, 2), (2, 1), (2, 2)] ``` Additional Notes - In case there are multiple points at the same distance from the origin, any order of these points within the result is acceptable. - The algorithm should efficiently handle the constraints, preferably achieving a time complexity better than O(n log n) for sorting all points. --- This question tests the ability to manipulate and sort data structures, focusing on understanding and computing Euclidean distances efficiently. It also requires implementing efficient algorithms to select the top `k` elements, leveraging common techniques such as heaps or the Quickselect algorithm.","solution":"from typing import List, Tuple import heapq def find_k_closest_points(points: List[Tuple[int, int]], k: int) -> List[Tuple[int, int]]: Returns the k closest points to the origin (0, 0) from a list of points in a 2D plane. def euclidean_distance_squared(point: Tuple[int, int]) -> int: x, y = point return x * x + y * y # Use a max-heap to keep track of the k smallest elements max_heap = [] for point in points: dist = euclidean_distance_squared(point) if len(max_heap) < k: heapq.heappush(max_heap, (-dist, point)) else: heapq.heappushpop(max_heap, (-dist, point)) return [point for _, point in max_heap]"},{"question":"# Problem Statement Implement a Sudoku solver that fills in the empty spaces in a 9x9 Sudoku board. The board will be partially filled with digits from 1 to 9, where empty cells are represented by the character \'.\'. The solution must adhere to these constraints: - Each row must contain the digits 1 to 9 without repetition. - Each column must contain the digits 1 to 9 without repetition. - Each of the 9 sub-grids (3x3 sections) must contain the digits 1 to 9 without repetition. Your program should modify the input board in-place. # Input/Output Formats - **Input**: - A 9x9 list of lists, where each element is a character representing either a digit \'1\' to \'9\' or \'.\' for empty cells. Example: ```python board = [[\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"]] ``` - **Output**: - The solved board as a 9x9 list of lists, with the digits filling in the empty cells. # Constraints - The given Sudoku board will have a valid configuration that can be solved. - There will always be exactly one solution to the given Sudoku puzzle. # Example ```python def solveSudoku(board): Modify the 9x9 board with characters representing digits 1-9 and \'.\' for empty cells to solve the Sudoku puzzle with the given constraints. # Your code here board = [[\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"]] solveSudoku(board) print(board) # Expected Output: # [[\\"5\\",\\"3\\",\\"4\\",\\"6\\",\\"7\\",\\"8\\",\\"9\\",\\"1\\",\\"2\\"], # [\\"6\\",\\"7\\",\\"2\\",\\"1\\",\\"9\\",\\"5\\",\\"3\\",\\"4\\",\\"8\\"], # [\\"1\\",\\"9\\",\\"8\\",\\"3\\",\\"4\\",\\"2\\",\\"5\\",\\"6\\",\\"7\\"], # [\\"8\\",\\"5\\",\\"9\\",\\"7\\",\\"6\\",\\"1\\",\\"4\\",\\"2\\",\\"3\\"], # [\\"4\\",\\"2\\",\\"6\\",\\"8\\",\\"5\\",\\"3\\",\\"7\\",\\"9\\",\\"1\\"], # [\\"7\\",\\"1\\",\\"3\\",\\"9\\",\\"2\\",\\"4\\",\\"8\\",\\"5\\",\\"6\\"], # [\\"9\\",\\"6\\",\\"1\\",\\"5\\",\\"3\\",\\"7\\",\\"2\\",\\"8\\",\\"4\\"], # [\\"2\\",\\"8\\",\\"7\\",\\"4\\",\\"1\\",\\"9\\",\\"6\\",\\"3\\",\\"5\\"], # [\\"3\\",\\"4\\",\\"5\\",\\"2\\",\\"8\\",\\"6\\",\\"1\\",\\"7\\",\\"9\\"]] ``` # Task Implement the `solveSudoku` function to solve the given Sudoku puzzle by replacing the empty cells with digits from 1 to 9, ensuring all constraints of the game are satisfied. The function should modify the input board in-place.","solution":"def solveSudoku(board): Modify the 9x9 board with characters representing digits 1-9 and \'.\' for empty cells to solve the Sudoku puzzle with the given constraints. def is_valid(board, row, col, char): for i in range(9): if board[row][i] == char: return False if board[i][col] == char: return False if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == char: return False return True def solve(board): for row in range(9): for col in range(9): if board[row][col] == \'.\': for char in \'123456789\': if is_valid(board, row, col, char): board[row][col] = char if solve(board): return True board[row][col] = \'.\' return False return True solve(board)"},{"question":"# Coding Assessment Question Background A statistics tracking application is required to monitor the performance of a sequence of stock prices over time. We need a function to identify regions of maximum gain within the stock prices, specifically identifying the start and end of the period where the maximum gain occurs. Objective Your task is to implement a function that finds the contiguous subarray (containing at least one number) which has the largest sum and returns the maximum sum along with the start and end indices of this subarray. Function Signature ```python def max_gain(prices: list) -> (int, int, int): ``` Input * `prices` (list): A list of integers representing the daily stock prices. Output A tuple with three elements: 1. The maximum gain (int) 2. The starting index of the subarray (int) 3. The ending index of the subarray (int) Constraints 1. The length of the prices list will be between 1 and 10^5. 2. All prices will be integers ranging from -10^4 to 10^4. Example 1 ```python max_gain([1, -2, 3, 5, -3, 2]) ``` Output: ``` (8, 2, 3) ``` Example 2 ```python max_gain([-3, -1, -2]) ``` Output: ``` (-1, 1, 1) ``` Notes * If multiple subarrays provide the same maximum gain, return the subarray that appears first. * You should handle the negative prices effectively. * The output indices should be 0-based. * Ensure efficiency in implementation, aiming for O(n) complexity. Your implementation should be tested against various edge cases and optimize the search for the maximum gain in the stock prices to handle large inputs efficiently.","solution":"def max_gain(prices): Find the contiguous subarray which has the largest sum and return the maximum sum along with the starting and ending indices of this subarray. :param prices: List of integers representing the daily stock prices. :return: A tuple (maximum sum, starting index, ending index) if not prices: return 0, 0, 0 max_sum = current_sum = prices[0] start = end = temp_start = 0 for i in range(1, len(prices)): if current_sum < 0: current_sum = prices[i] temp_start = i else: current_sum += prices[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return max_sum, start, end"},{"question":"# Stack-based Queue Implementation Task Objective: Your task is to implement a `StackQueue` class that emulates queue operations using two stacks to ensure the proper order of elements (FIFO). The goal is to have the main queue operations (`enqueue`, `dequeue`, `is_empty`) function effectively and maintain average-case constant time complexity. Requirements: 1. Implement a new class `StackQueue` that uses two stacks (`input_stack` and `output_stack`). 2. Ensure the `enqueue` operation adds elements to `input_stack`. 3. Implement the `dequeue` operation to remove elements from `output_stack`. If `output_stack` is empty, transfer all elements from `input_stack` to `output_stack` before performing the dequeue. 4. Implement an `is_empty` method that checks if both stacks are empty. 5. Override necessary methods to maintain and use the two-stack structure. Class Definition: ```python class StackQueue: def __init__(self) -> None: self.input_stack = [] self.output_stack = [] def enqueue(self, item: Any) -> None: self.input_stack.append(item) def dequeue(self) -> Any: if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") if not self.output_stack: while self.input_stack: self.output_stack.append(self.input_stack.pop()) return self.output_stack.pop() def is_empty(self) -> bool: return not self.input_stack and not self.output_stack def clear(self) -> None: self.input_stack.clear() self.output_stack.clear() ``` Testing: - Create multiple test cases to validate behavior: 1. Enqueue and Dequeue sequences. 2. Empty and non-empty checks during operations. 3. Edge cases like empty queue, single element, transferring elements between stacks. Example: ```python queue = StackQueue() print(queue.is_empty()) # True queue.enqueue(1) queue.enqueue(2) print(queue.is_empty()) # False print(queue.dequeue()) # 1 queue.clear() print(queue.is_empty()) # True ``` **Output**: ```shell True False 1 True ``` Ensure to handle edge cases and make sure the operation efficiency is maintained through the stack transfers.","solution":"class StackQueue: def __init__(self) -> None: self.input_stack = [] self.output_stack = [] def enqueue(self, item) -> None: self.input_stack.append(item) def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") if not self.output_stack: while self.input_stack: self.output_stack.append(self.input_stack.pop()) return self.output_stack.pop() def is_empty(self) -> bool: return not self.input_stack and not self.output_stack def clear(self) -> None: self.input_stack.clear() self.output_stack.clear()"},{"question":"# Asynchronous Task Scheduler with Priority Queuing You are tasked with developing an asynchronous task scheduler that can execute tasks based on their priority. The scheduler should support adding tasks with a specified priority and execute them asynchronously in order of their priority. Function Specification: Implement a class `TaskScheduler` with the following methods: 1. `add_task(task_id: int, priority: int, delay: float, action: Callable[[], Any]) -> None`: This method adds a task to the scheduler. 2. `run(tasks_to_run: int) -> None`: This method runs the specified number of tasks in the order of their priority, where a lower numeric value indicates a higher priority. Tasks are executed with the specified delay. The `TaskScheduler` class should: - Maintain a priority queue of tasks. - Execute tasks asynchronously using `asyncio`. - Handle tasks with the same priority in the order they were added. Input: - `add_task`method parameters: - `task_id` (int): An identifier for the task. - `priority` (int): The priority of the task, where a lower number indicates higher priority. - `delay` (float): The delay before executing the task in seconds. - `action` (Callable[[], Any]): A task action that the scheduler will execute. - `run` method parameter: - `tasks_to_run` (int): The number of tasks to execute. Constraints: - The task priority is an integer. Lower numbers have higher priority. - The task `action` is callable and has no arguments. - Tasks with the same priority should be executed in the order they were added to the scheduler. - Use `asyncio` for asynchronous task execution. - Limit task execution to those with lesser delay values first in the case of same priority. Example Usage: ```python import asyncio import random class TaskScheduler: def __init__(self): self.tasks = [] def add_task(self, task_id: int, priority: int, delay: float, action: Callable[[], Any]) -> None: # Add the task to the scheduler. pass async def _execute(self, delay, action): # Delays the task by specified time, then runs the action. pass async def run(self, tasks_to_run: int) -> None: # Run the tasks asynchronously in order of their priority. pass # Define some task actions async def task_a(): print(\\"Task A executed\\") async def task_b(): print(\\"Task B executed\\") async def task_c(): print(\\"Task C executed\\") if __name__ == \\"__main__\\": scheduler = TaskScheduler() scheduler.add_task(task_id=1, priority=2, delay=1, action=task_a) scheduler.add_task(task_id=2, priority=1, delay=2, action=task_b) scheduler.add_task(task_id=3, priority=2, delay=0.5, action=task_c) asyncio.run(scheduler.run(tasks_to_run=3)) ``` In this example, the `TaskScheduler` will execute the tasks in the following order based on their priority and delay: 1. `task_c` (priority=2, delay=0.5) 2. `task_b` (priority=1, delay=2) 3. `task_a` (priority=2, delay=1) Notes: - You may need to install the `asyncio` library if not already available. - Consider adding logging to track the scheduling and execution of tasks.","solution":"import asyncio from typing import Callable, Any import heapq class PriorityQueue: def __init__(self): self.pq = [] self.counter = 0 # unique sequence count def push(self, priority, delay, task_id, action): heapq.heappush(self.pq, (priority, delay, self.counter, task_id, action)) self.counter += 1 def pop(self): if self.pq: return heapq.heappop(self.pq) return None def is_empty(self): return len(self.pq) == 0 class TaskScheduler: def __init__(self): self.tasks = PriorityQueue() def add_task(self, task_id: int, priority: int, delay: float, action: Callable[[], Any]) -> None: self.tasks.push(priority, delay, task_id, action) async def _execute(self, delay, action): await asyncio.sleep(delay) await action() async def run(self, tasks_to_run: int) -> None: tasks_executed = 0 while tasks_executed < tasks_to_run and not self.tasks.is_empty(): priority, delay, count, task_id, action = self.tasks.pop() asyncio.create_task(self._execute(delay, action)) tasks_executed += 1 await asyncio.sleep(0.1) # Ensure all tasks start execution"},{"question":"# Fibonacci Sequence Check You are tasked with creating a function that determines if a given number is part of the Fibonacci sequence. **Fibonacci Sequence**: * The Fibonacci sequence is a series of numbers where: * The first two numbers are 0 and 1. * Each subsequent number is the sum of the previous two numbers. **Input**: - A single integer `number`. **Output**: - Returns `True` if the `number` is part of the Fibonacci sequence. - Returns `False` otherwise. - Raises a `ValueError` for incorrect input types. **Constraints**: - The `number` input will be a non-negative integer. - Do not use external libraries. # Task: 1. Implement the function `is_fibonacci_number(number: int) -> bool` that checks if the provided number is in the Fibonacci sequence. 2. The function should handle large integers efficiently. # Example Usages: ```python assert is_fibonacci_number(0) == True # 0 is part of the Fibonacci sequence assert is_fibonacci_number(1) == True # 1 is part of the Fibonacci sequence assert is_fibonacci_number(13) == True # 13 is part of the Fibonacci sequence assert is_fibonacci_number(20) == False # 20 is not part of the Fibonacci sequence assert is_fibonacci_number(144) == True # 144 is part of the Fibonacci sequence assert is_fibonacci_number(\\"ten\\") # Raises ValueError: incorrect input type ```","solution":"def is_fibonacci_number(number): Returns True if the number is part of the Fibonacci sequence, False otherwise. if not isinstance(number, int) or number < 0: raise ValueError(\\"The input must be a non-negative integer.\\") if number in (0, 1): return True a, b = 0, 1 while b < number: a, b = b, a + b return b == number"},{"question":"# Coding Challenge: Detecting Palindromic Subsequences Scenario As part of a security feature in a messaging application, you have been asked to investigate the presence of subsequences that are palindromic within user messages. A palindrome is a string that reads the same forwards and backwards. Question Write a Python function that returns the longest palindromic subsequence in a given string. If more than one subsequence of the same maximum length exists, return the lexicographically smallest one. Function Signature ```python def longest_palindromic_subsequence(s: str) -> str: Returns the longest palindromic subsequence in the given string. If there are multiple, return the lexicographically smallest one. ``` Input/Output * **Input Format**: A single string `s` with a length between 1 and 1000 characters. * **Output Format**: A string representing the longest palindromic subsequence. If multiple subsequences of the same length exist, return the one that comes first lexicographically. Constraints 1. The input string `s` will only contain lowercase English letters (\'a\' to \'z\'). 2. The solution should handle the case where the input string is already a palindrome. Performance Requirement Ensure your solution is efficient enough to handle a string up to 1000 characters in length. Example ```python longest_palindromic_subsequence(\\"character\\") # Expected output: \\"carac\\" longest_palindromic_subsequence(\\"racecar\\") # Expected output: \\"racecar\\" ``` **Note**: Do not use any additional libraries that simplify this problem to maintain the challenge\'s integrity.","solution":"def longest_palindromic_subsequence(s: str) -> str: n = len(s) dp = [[\\"\\" for _ in range(n)] for _ in range(n)] # Initial population of the dp table with single letter palindromes for i in range(n): dp[i][i] = s[i] # Build the dp table for length in range(2, n+1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = s[i] + dp[i+1][j-1] + s[j] else: # If the two options have the same length, take the lexicographically smaller one if len(dp[i+1][j]) > len(dp[i][j-1]): dp[i][j] = dp[i+1][j] elif len(dp[i+1][j]) < len(dp[i][j-1]): dp[i][j] = dp[i][j-1] else: dp[i][j] = min(dp[i+1][j], dp[i][j-1]) return dp[0][n-1]"},{"question":"# Find Largest Network Component You are given a list of connections in a network where each connection represents a bidirectional link between two nodes. Your task is to find the size of the largest connected component in this network, where a connected component is defined as a set of nodes such that there is a path between any two nodes in this set. **Problem Statement:** Write a function `largest_component` that computes the size of the largest connected component in the network. The network is represented as an undirected graph using an adjacency list format. - The first parameter `n` is the number of nodes in the network. - The second parameter `connections` is a list of tuples. Each tuple `(a, b)` represents a bidirectional edge between nodes `a` and `b`. **Function Signature:** ```python def largest_component(n: int, connections: list[tuple[int, int]]) -> int: ``` **Input Format:** - `n`: an integer representing the number of nodes (1-indexed). - `connections`: a list of tuples where each tuple `(a, b)` contains two integers within the range [1, n]. **Output Format:** - Return an integer representing the size of the largest connected component. **Examples:** ```python >>> largest_component(5, [(1, 2), (2, 3), (4, 5)]) 3 >>> largest_component(6, [(1, 2), (2, 3), (3, 4), (4, 5)]) 5 >>> largest_component(4, [(1, 2), (2, 3)]) 3 >>> largest_component(4, [(1, 2), (3, 4)]) 2 ``` **Constraints:** - The number of nodes `n` will be in the range [1, 10^3]. - The array `connections` may be empty, implying no edges in the network. - All connections are valid, meaning they will only refer to nodes within the range [1, n]. **Scoring:** - Correctness: Solutions will be verified based on correct identification of connected components and accurate computation of their sizes. - Efficiency: Solutions must handle the upper range of inputs efficiently. **Hints:** - Consider using graph traversal techniques like Depth-First Search (DFS) or Breadth-First Search (BFS) to explore the components. - Utilize data structures that efficiently manage the node connections to achieve optimal performance.","solution":"def largest_component(n: int, connections: list[tuple[int, int]]) -> int: from collections import defaultdict, deque # Create adjacency list adj_list = defaultdict(list) for a, b in connections: adj_list[a].append(b) adj_list[b].append(a) # Keeps track of visited nodes visited = set() def bfs(start): queue = deque([start]) visited.add(start) component_size = 0 while queue: node = queue.popleft() component_size += 1 for neighbor in adj_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return component_size largest = 0 for i in range(1, n+1): if i not in visited: component_size = bfs(i) largest = max(largest, component_size) return largest"},{"question":"**Scenario**: You have been hired by a logistics company to streamline their package tracking system. They want to ensure that their package IDs follow a specific pattern, which will help in quickly validating and searching for packages in their database. Each package ID should be an alphanumeric string in a predetermined format with a consistent length. This pattern helps to demonstrate an understanding of string manipulation and validation using regular expressions. **Task**: Write a class implementation that can generate and validate package IDs according to the given pattern. Your class should be named `PackageIDHandler` and include the following methods: 1. `generate_id(prefix: str, number: int) -> str` 2. `validate_id(package_id: str) -> bool` # Method Details - `generate_id(prefix: str, number: int) -> str`: - Takes a string `prefix` (2 uppercase letters) and an integer `number` (1 to 9999) as inputs. - Returns a string representing the package ID in the format: `prefix` followed by the number zero-padded to 4 digits. - Example: `generate_id(\\"AB\\", 123)` returns `\\"AB0123\\"`. - `validate_id(package_id: str) -> bool`: - Takes a string `package_id` as input. - Returns a boolean indicating if the package ID matches the required pattern (2 uppercase letters followed by 4 digits). - Example: `validate_id(\\"AB0123\\")` returns `True`. # Constraints 1. The length of the `prefix` must always be exactly 2 uppercase letters. 2. The number must always be between 1 and 9999. 3. The length of the generated and validated package ID must always be 6 characters. # Requirements 1. Ensure that the `generate_id` method properly formats the package ID. 2. Ensure that the `validate_id` method accurately checks if a package ID conforms to the specified pattern using regular expressions. 3. Provide error handling for potential issues, such as invalid inputs for `prefix` or `number` outside the allowed range. # Expected Input and Output Format * **generate_id(prefix: str, number: int) -> str** - **Input**: `prefix = \\"AB\\"`, `number = 123` - **Output**: `\\"AB0123\\"` * **validate_id(package_id: str) -> bool** - **Input**: `package_id = \\"AB0123\\"` - **Output**: `True` # Performance 1. The solution should be efficient, running in constant time relative to the length of the inputs since the format and length are fixed. Below is the suggested implementation for the class: ```python import re class PackageIDHandler: @staticmethod def generate_id(prefix: str, number: int) -> str: if not (prefix.isupper() and len(prefix) == 2): raise ValueError(\\"Prefix must be exactly 2 uppercase letters.\\") if not (1 <= number <= 9999): raise ValueError(\\"Number must be between 1 and 9999.\\") return f\\"{prefix}{number:04d}\\" @staticmethod def validate_id(package_id: str) -> bool: pattern = r\\"^[A-Z]{2}d{4}\\" return bool(re.match(pattern, package_id)) # Example usage: # package_handler = PackageIDHandler() # generated_id = package_handler.generate_id(\\"AB\\", 123) # print(generated_id) # Output: \\"AB0123\\" # is_valid = package_handler.validate_id(\\"AB0123\\") # print(is_valid) # Output: True ```","solution":"import re class PackageIDHandler: @staticmethod def generate_id(prefix: str, number: int) -> str: if not (prefix.isupper() and len(prefix) == 2): raise ValueError(\\"Prefix must be exactly 2 uppercase letters.\\") if not (1 <= number <= 9999): raise ValueError(\\"Number must be between 1 and 9999.\\") return f\\"{prefix}{number:04d}\\" @staticmethod def validate_id(package_id: str) -> bool: pattern = r\\"^[A-Z]{2}d{4}\\" return bool(re.match(pattern, package_id))"},{"question":"**Scenario**: You are working as a software engineer, and you\'ve been tasked to create a simplified version of a markdown processor. Specifically, you need to handle the conversion of specific markdown syntax to HTML tags. This will demonstrate your understanding of string manipulation and basic syntax parsing. **Task**: Write a class implementation that can convert a subset of markdown syntax to HTML. Your class should be named `MarkdownToHTML` and include the following methods: 1. `convert_to_html(markdown: str) -> str` The `convert_to_html` method should: - Take a string `markdown` as input. - Convert headers, bold and italic markdown syntax to their corresponding HTML tags. - Specifically, it should handle: - `#` for headers, converting `# Header` to `<h1>Header</h1>` - `` for sub-headers, converting ` Sub-header` to `<h2>Sub-header</h2>` - `**` for bold text, converting `**bold**` to `<b>bold</b>` - `*` for italic text, converting `*italic*` to `<i>italic</i>` # Constraints 1. Input `markdown` will have a maximum length of 2000 characters. 2. The markdown text will only contain the supported markdown features specified above. # Requirements 1. Handle edge cases such as empty strings and no markdown. 2. Ensure proper HTML escaping for other characters if necessary. # Expected Input and Output Format * **convert_to_html(markdown: str) -> str** - **Input**: `\\"# Hellon Sub-headernThis is **bold** text and this is *italic* text.\\"` - **Output**: `\\"<h1>Hello</h1><h2>Sub-header</h2>This is <b>bold</b> text and this is <i>italic</i> text.\\"` # Performance 1. The solution should be efficient, running in linear time relative to the input string length.","solution":"import re class MarkdownToHTML: def convert_to_html(self, markdown: str) -> str: # Convert headers markdown = re.sub(r\'^# (.*)\', r\'<h1>1</h1>\', markdown, flags=re.MULTILINE) markdown = re.sub(r\'^ (.*)\', r\'<h2>1</h2>\', markdown, flags=re.MULTILINE) # Convert bold text markdown = re.sub(r\'**(.*?)**\', r\'<b>1</b>\', markdown) # Convert italic text markdown = re.sub(r\'*(.*?)*\', r\'<i>1</i>\', markdown) return markdown"},{"question":"# Coding Question You are working with DNA sequences and need to identify specific motifs within a given sequence. To handle this efficiently for large datasets, you are to construct a Trie data structure to store the motifs and implement a pattern matching function using the Trie. Your implementation must demonstrate an understanding of Trie construction and pattern matching principles. Function Signature ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: pass def search(self, text: str) -> bool: pass ``` Task 1. **Build Trie**: - Implement the `insert` method to add a given motif to the Trie. - Each character of the motif should be added as a child node, and mark the end of a motif with `is_end_of_word`. 2. **Search for Motif**: - Implement the `search` method to check if a motif exists within a given text. - The search should return `True` if any motif in the Trie is found in the text and `False` otherwise. - Ensure the search operation runs in linear time concerning the length of the text. Input - An instance of the `Trie` is initialized, and various motifs are inserted into it using the `insert(motif)` method. - The `search(text)` method is called with a string `text` that needs to be searched for any of the inserted motifs. Output - The `search` method should return `True` if any motif exists in the text, `False` otherwise. Constraints - `1 <= len(motif) <= 100` - `1 <= len(text) <= 10^5` - `motif` and `text` consist of uppercase letters \'A\', \'C\', \'G\', \'T\' only, representing DNA sequences. Example Usage ```python trie = Trie() trie.insert(\\"ACG\\") trie.insert(\\"CGT\\") trie.insert(\\"TGC\\") assert trie.search(\\"AATGCT\\") == True # \\"TGC\\" is found in the text assert trie.search(\\"CACGTAC\\") == True # \\"ACG\\" is found in the text assert trie.search(\\"TGGA\\") == False # No motif is found in the text assert trie.search(\\"TGCGACGT\\") == True # \\"CGT\\" is found in the text assert trie.search(\\"GACGACTC\\") == True # \\"ACG\\" is found in the text ``` Notes - You are required to write both methods in the `Trie` class. - Ensure optimal performance by adhering to the specified constraints.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.is_end_of_word = True def search(self, text: str) -> bool: for i in range(len(text)): current = self.root for j in range(i, len(text)): char = text[j] if char in current.children: current = current.children[char] if current.is_end_of_word: return True else: break return False"},{"question":"# Inventory Management System Enhancement You are provided with a class `InventoryManager` that partially implements an inventory management system. The class has basic functionality to add, remove, and update items in the inventory. Your task is to extend this class to add the following features: 1. **Batch Addition and Removal**: * Implement methods for adding and removing multiple items at once. * Each item should be a dictionary with at least `id`, `name`, and `quantity`. 2. **Inventory Export**: * Implement a method to export the inventory to a CSV file. * The CSV should contain columns for `id`, `name`, and `quantity`. **Input**: - For batch addition and removal: A list of dictionaries, where each dictionary represents an item. - For inventory export: A string `filename` specifying the name of the output CSV file. **Output**: - For batch addition and removal: A boolean indicating the success or failure of the operation. - For inventory export: A boolean indicating the success or failure of the export operation. **Performance Requirements**: - The batch addition and removal methods should handle up to 1000 items efficiently. - Ensure that the export operation writes the CSV file in a time complexity of O(n), where n is the number of items in the inventory. **Constraints**: - Each item dictionary must contain at least the `id`, `name`, and `quantity` keys. - The quantity must be a non-negative integer. - Ensure robust error handling for file I/O operations during export. **Example Usage**: ```python inventory = InventoryManager() # Batch add items items_to_add = [ {\\"id\\": 101, \\"name\\": \\"Item A\\", \\"quantity\\": 15}, {\\"id\\": 102, \\"name\\": \\"Item B\\", \\"quantity\\": 25}, {\\"id\\": 103, \\"name\\": \\"Item C\\", \\"quantity\\": 10} ] if inventory.add_items(items_to_add): print(\\"Items added successfully\\") else: print(\\"Failed to add items\\") # Batch remove items items_to_remove = [ {\\"id\\": 101, \\"name\\": \\"Item A\\", \\"quantity\\": 5}, {\\"id\\": 103, \\"name\\": \\"Item C\\", \\"quantity\\": 10} ] if inventory.remove_items(items_to_remove): print(\\"Items removed successfully\\") else: print(\\"Failed to remove items\\") # Export inventory to CSV if inventory.export_to_csv(\\"inventory_output.csv\\"): print(\\"Inventory exported successfully\\") else: print(\\"Failed to export inventory\\") ``` Write the enhanced class `InventoryManager` with the specified improvements.","solution":"import csv class InventoryManager: def __init__(self): self.inventory = {} # inventory is stored as a dictionary with item ID as key. def add_item(self, item): Add a single item to the inventory. if item[\'id\'] in self.inventory: self.inventory[item[\'id\']][\'quantity\'] += item[\'quantity\'] else: self.inventory[item[\'id\']] = { \'name\': item[\'name\'], \'quantity\': item[\'quantity\'] } def remove_item(self, item): Remove a single item from the inventory. if item[\'id\'] in self.inventory and self.inventory[item[\'id\']][\'quantity\'] >= item[\'quantity\']: self.inventory[item[\'id\']][\'quantity\'] -= item[\'quantity\'] if self.inventory[item[\'id\']][\'quantity\'] == 0: del self.inventory[item[\'id\']] return True return False def add_items(self, items): Batch addition of multiple items. for item in items: self.add_item(item) return True def remove_items(self, items): Batch removal of multiple items. for item in items: if not self.remove_item(item): return False return True def export_to_csv(self, filename): Export the inventory to a CSV file. try: with open(filename, mode=\'w\', newline=\'\') as file: writer = csv.writer(file) writer.writerow([\'id\', \'name\', \'quantity\']) for item_id, item_info in self.inventory.items(): writer.writerow([item_id, item_info[\'name\'], item_info[\'quantity\']]) return True except Exception as e: print(f\\"Error exporting inventory: {e}\\") return False"},{"question":"# Problem Statement You are given an array of integers. Your task is to write a function that finds the total number of continuous subarrays whose sum is equal to a given number `k`. A subarray is a contiguous part of an array. Write a function called `subarray_sum` that takes in the array and the integer `k` and returns the number of continuous subarrays that sum up to `k`. # Function Signature ```python def subarray_sum(nums: List[int], k: int) -> int: pass ``` # Input * `nums` (List[int]): The array of integers, -10^4 ≤ nums[i] ≤ 10^4 and 1 ≤ len(nums) ≤ 2 * 10^4. * `k` (int): The target sum, -10^9 ≤ k ≤ 10^9. # Output * Returns an integer representing the number of continuous subarrays that sum up to `k`. # Constraints * You may assume the given array contains at least one element. # Example ```python assert subarray_sum([1, 1, 1], 2) == 2 assert subarray_sum([1, 2, 3], 3) == 2 assert subarray_sum([1], 0) == 0 assert subarray_sum([1, -1, 1, -1], 0) == 4 ``` # Additional Notes Consider using an efficient approach to solve this problem: 1. Use a hash map to store the cumulative sums and their frequencies. 2. Traverse the array while keeping a cumulative sum. For each element, check if there is a previous cumulative sum such that the difference between the current cumulative sum and this previous sum equals `k`. 3. If such a previous cumulative sum exists, it means there is a subarray that sums to `k`. 4. Keep track of the number of such subarrays as you traverse the array. This optimal approach will ensure you handle large arrays efficiently without needing a nested loop.","solution":"from typing import List def subarray_sum(nums: List[int], k: int) -> int: count = 0 curr_sum = 0 prefix_sums = {0: 1} for num in nums: curr_sum += num if (curr_sum - k) in prefix_sums: count += prefix_sums[curr_sum - k] if curr_sum in prefix_sums: prefix_sums[curr_sum] += 1 else: prefix_sums[curr_sum] = 1 return count"},{"question":"# Coding Question Context As part of your responsibilities at a logistics company, you are tasked with improving the efficiency of route planning. To achieve this goal, you need to develop an algorithm that calculates the shortest path between different delivery points in a city. Problem Given a weighted, directed graph representing the city\'s delivery points and routes between them, implement an algorithm to find the shortest path from a starting delivery point to all other delivery points. Requirements 1. Implement Dijkstra\'s algorithm to find the shortest path from the starting point to all other points. 2. The algorithm should handle graphs with varying numbers of nodes and edges efficiently. 3. Represent the graph as an adjacency list, where each entry is a list of tuples (neighbor, weight). Function Signature ```python def dijkstra(graph: dict[int, list[tuple[int, int]]], start: int) -> dict[int, int]: Finds the shortest path from the start node to all other nodes using Dijkstra\'s algorithm. :param graph: A dictionary where keys are node IDs and values are lists of (neighbor, weight) tuples. :param start: The starting node ID. :return: A dictionary where keys are node IDs and values are the shortest distance from the start node. Example: >>> dijkstra({ 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] }, 0) {0: 0, 1: 3, 2: 1, 3: 4} >>> dijkstra({ 0: [(1, 10), (2, 3)], 1: [(3, 2)], 2: [(1, 4), (3, 8)], 3: [(4, 7)], 4: [] }, 0) {0: 0, 1: 7, 2: 3, 3: 9, 4: 16} ``` Constraints 1. The graph can have up to 10000 nodes. 2. The weights of the edges are non-negative integers. 3. The graph does not contain negative weight cycles. Input/Output Format * **Input**: A dictionary representing the graph and an integer representing the start node. * **Output**: A dictionary where each key is a node and the associated value is the shortest distance from the start node. Examples 1. `dijkstra({ 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] }, 0)` should return `{0: 0, 1: 3, 2: 1, 3: 4}`. 2. `dijkstra({ 0: [(1, 10), (2, 3)], 1: [(3, 2)], 2: [(1, 4), (3, 8)], 3: [(4, 7)], 4: [] }, 0)` should return `{0: 0, 1: 7, 2: 3, 3: 9, 4: 16}`. Notes 1. Make sure to test the implementation with various graph structures, including disconnected graphs and graphs with multiple paths between nodes. 2. Optimize for both time and space complexity to handle larger datasets efficiently.","solution":"import heapq def dijkstra(graph, start): Finds the shortest path from the start node to all other nodes using Dijkstra\'s algorithm. :param graph: A dictionary where keys are node IDs and values are lists of (neighbor, weight) tuples. :param start: The starting node ID. :return: A dictionary where keys are node IDs and values are the shortest distance from the start node. distances = {node: float(\'inf\') for node in graph} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Background In many real-world applications, the reversal of sequences of data is a common operation. This can be seen in algorithms related to data compression, cryptography, and data storage optimization. By understanding how to effectively reverse sequences, programmers can ensure data accuracy and integrity in diverse scenarios. # Problem Statement You are required to implement a function `reverse_string` that takes an input string and returns the reversed version of the string. Your task is to perform this without using any built-in functions that directly handle string reversal, such as Python\'s slicing or the `reversed()` function. # Function Signature ```python def reverse_string(s: str) -> str: pass ``` # Input Format - `s`: A string of arbitrary length. The string will consist of ASCII characters only. # Output Format - Returns the reversed string. # Constraints - The string will contain between 1 to (10^5) characters. # Performance Requirements - The solution should complete in linear time relative to the length of the string. - Ensure that the function uses (O(1)) additional space, apart from the output storage. Example ```python assert reverse_string(\\"hello\\") == \\"olleh\\" assert reverse_string(\\"abc\\") == \\"cba\\" assert reverse_string(\\"A man, a plan, a canal, Panama\\") == \\"amanaP ,lanac a ,nalp a ,nam A\\" ``` # Notes - You are NOT allowed to use slicing or Python\'s built-in `reversed()` function. - The function must efficiently reverse the string using iterative or recursive approaches. - Pay attention to edge cases such as empty strings or strings with special characters. ____ By following the provided guidelines, the new question aligns with the style, length, complexity, and topic area of the original set. This question focuses on string manipulation, which is a fundamental concept in programming, similar to image processing in terms of basic operations on data structures.","solution":"def reverse_string(s: str) -> str: Reverses the input string without using slicing or the built-in reversed() function. reversed_list = list(s) left, right = 0, len(s) - 1 while left < right: # Swap characters at positions left and right reversed_list[left], reversed_list[right] = reversed_list[right], reversed_list[left] left += 1 right -= 1 return \'\'.join(reversed_list)"},{"question":"# Problem Statement You need to implement a feature to track the minimum element in a stack. The stack operates on LIFO (Last In, First Out) principle and initially supports `push`, `pop`, `peek`, and `is_empty` operations. Your objective is to add a method to the stack class which will allow you to get the minimum element in the stack in constant time. 1. **Get Minimum**: Write a method `get_min` within the `LinkedStack` class that returns the minimum element present in the stack. This method should operate in constant time O(1). # Expected Input and Output 1. **Get Minimum**: - **Input**: None (invoked on a stack instance) - **Output**: The minimum element in the stack - **Example**: ```python stack = LinkedStack() stack.push(3) stack.push(1) stack.push(4) stack.get_min() # Output: 1 stack.pop() stack.get_min() # Output: 1 ``` # Constraints * The minimum method should run in constant time O(1). * You may use additional data structures only if necessary to achieve the constant time complexity. * Assume the stack only contains comparable elements (with implemented `__lt__` method). * The stack may contain any number of elements, including zero. * Ensure the `LinkedStack` implementation maintains its LIFO behavior. Implement the `get_min` method in the `LinkedStack` class and make sure it is efficient and maintains the stack\'s properties.","solution":"class Node: def __init__(self, value, next_node=None): self.value = value self.next_node = next_node class LinkedStack: def __init__(self): self.head = None self.min_stack = [] # Auxiliary stack to keep track of minimum elements def push(self, value): if self.is_empty(): self.head = Node(value) self.min_stack.append(value) else: new_node = Node(value, self.head) self.head = new_node if value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self): if not self.is_empty(): pop_value = self.head.value self.head = self.head.next_node if pop_value == self.min_stack[-1]: self.min_stack.pop() return pop_value return None def peek(self): if not self.is_empty(): return self.head.value return None def is_empty(self): return self.head is None def get_min(self): Returns the minimum value in the stack. if not self.is_empty(): return self.min_stack[-1] return None"},{"question":"# Task: Implement a Function to Validate Brackets in a String Problem Statement: You are required to implement a function `is_valid_brackets(sequence: str) -> bool` that verifies if a given string consisting of brackets `(`, `)`, `{`, `}`, `[` and `]` is valid. A sequence of brackets is considered valid if all types of brackets are correctly matched and nested. Details: - **Input**: - `sequence (str)` : A string consisting only of characters `(`, `)`, `{`, `}`, `[` and `]`. - **Output**: - `bool` : Returns `True` if the bracket sequence is valid, otherwise `False`. Constraints: - The length of the string does not exceed 1000 characters. - The function should aim to operate within O(n) time complexity. Example: - `is_valid_brackets(\\"(){}[]\\")` should return `True` as all brackets are correctly matched. - `is_valid_brackets(\\"({[)]}\\")` should return `False` due to incorrect nesting. Scenario: Imagine developing a text editor that supports syntax highlighting. One of the features is to check if the programming code has matching brackets to ensure the code structure is correct and avoid compilation errors. Edge Cases: - Empty string: The function should return `True`. - Single type of bracket used multiple times: The function should ensure nested brackets are correctly matched. - Mixed types with correct nesting: The function should validate combinations of different brackets in correct order. Skeleton Code: ```python def is_valid_brackets(sequence: str) -> bool: stack = [] bracket_pairs = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in sequence: if char in bracket_pairs.values(): stack.append(char) elif char in bracket_pairs.keys(): if stack == [] or stack.pop() != bracket_pairs[char]: return False else: continue return stack == [] # Example usage: # print(is_valid_brackets(\\"(){}[]\\")) # Should return True # print(is_valid_brackets(\\"({[)]}\\")) # Should return False ``` Hints: 1. Using a stack data structure can help to manage the opening and closing brackets effectively. 2. Make sure to handle cases where closing brackets appear before any opening bracket. 3. Consider the input sequence has only brackets and no other types of characters. Implement the `is_valid_brackets` function and write corresponding test cases to verify its correctness, including edge cases mentioned.","solution":"def is_valid_brackets(sequence: str) -> bool: stack = [] bracket_pairs = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in sequence: if char in bracket_pairs.values(): stack.append(char) elif char in bracket_pairs.keys(): if stack == [] or stack.pop() != bracket_pairs[char]: return False else: continue return stack == []"},{"question":"# Problem Statement: Logging System You are required to design a logging system for a software application that captures log messages with severity levels. The severity levels are defined as follows: 1. **DEBUG**: Detailed information, typically of interest only when diagnosing problems. 2. **INFO**: Confirmation that things are working as expected. 3. **WARNING**: An indication that something unexpected happened, or indicative of some problem in the near future. 4. **ERROR**: Due to a more serious problem, the software has not been able to perform some function. 5. **CRITICAL**: A serious error, indicating that the program itself may be unable to continue running. **Context and Functions:** 1. **Log Message Structure**: A log message has the following attributes: - `timestamp` (string): The date and time when the log was created, in the format \\"YYYY-MM-DD HH:MM:SS\\". - `severity` (string): The severity level of the log message. - `message` (string): The actual log message. 2. **Log Storage**: You should create a list to store log messages. Each log message is a dictionary. **Tasks**: 1. **Implement the class `Logger` with the following methods:** - **`def __init__(self):`** * Initialize an empty list to store log messages. - **`def log(self, timestamp: str, severity: str, message: str) -> None:`** * Append a log message as a dictionary to the list. The dictionary should contain the keys `\\"timestamp\\"`, `\\"severity\\"`, and `\\"message\\"`. * Raise a `ValueError` if the severity level is not one of the predefined levels (DEBUG, INFO, WARNING, ERROR, CRITICAL). **Example**: ```python logger = Logger() logger.log(\\"2023-09-21 14:08:55\\", \\"INFO\\", \\"Application started successfully.\\") logger.log(\\"2023-09-21 14:09:25\\", \\"DEBUG\\", \\"Initial configuration loaded.\\") logger.log(\\"2023-09-21 14:10:01\\", \\"ERROR\\", \\"Failed to connect to the database.\\") ``` - **`def get_logs(self, severity: Optional[str] = None) -> List[Dict[str, str]]:`** * Return a list of all log messages. * If a severity level is provided, return only the log messages that have the specified severity. * Raise a `ValueError` if the severity level is not one of the predefined levels. **Example**: ```python logger.get_logs() # returns: [{\'timestamp\': \'2023-09-21 14:08:55\', \'severity\': \'INFO\', \'message\': \'Application started successfully.\'}, # {\'timestamp\': \'2023-09-21 14:09:25\', \'severity\': \'DEBUG\', \'message\': \'Initial configuration loaded.\'}, # {\'timestamp\': \'2023-09-21 14:10:01\', \'severity\': \'ERROR\', \'message\': \'Failed to connect to the database.\'}] logger.get_logs(\\"ERROR\\") # returns: [{\'timestamp\': \'2023-09-21 14:10:01\', \'severity\': \'ERROR\', \'message\': \'Failed to connect to the database.\'}] ``` **Input Constraints**: - The `timestamp` should be a valid string in the format \\"YYYY-MM-DD HH:MM:SS\\". - The `severity` should be one of the predefined levels (DEBUG, INFO, WARNING, ERROR, CRITICAL). - The `message` should be a non-empty string. **Assumptions**: - The `timestamp`, `severity`, and `message` are always provided. - The logger system operates with a minimum of boilerplate for simplicity.","solution":"from typing import List, Dict, Optional class Logger: SEVERITY_LEVELS = {\\"DEBUG\\", \\"INFO\\", \\"WARNING\\", \\"ERROR\\", \\"CRITICAL\\"} def __init__(self): self.logs = [] def log(self, timestamp: str, severity: str, message: str) -> None: if severity not in Logger.SEVERITY_LEVELS: raise ValueError(f\\"Invalid severity level: {severity}\\") self.logs.append({ \\"timestamp\\": timestamp, \\"severity\\": severity, \\"message\\": message }) def get_logs(self, severity: Optional[str] = None) -> List[Dict[str, str]]: if severity: if severity not in Logger.SEVERITY_LEVELS: raise ValueError(f\\"Invalid severity level: {severity}\\") return [log for log in self.logs if log[\\"severity\\"] == severity] return self.logs"},{"question":"# Coding Assessment Question Context In computer science, graph traversal techniques are fundamental for solving a variety of problems. Two of the most common traversal methods are Breadth-First Search (BFS) and Depth-First Search (DFS). These algorithms are useful for searching and processing nodes in a graph. Task Implement a function `shortest_path_bfs` in Python that finds the shortest path between two nodes in an unweighted graph using Breadth-First Search. The function should return a list of nodes representing the shortest path if it exists, or an empty list if there is no path between the nodes. Function Signature ```python def shortest_path_bfs( graph: dict[int, list[int]], start: int, goal: int ) -> list[int]: pass ``` Input * **graph**: a dictionary where keys are node identifiers (integers) and values are lists of adjacent nodes (integers). * **start**: an integer representing the starting node. * **goal**: an integer representing the target node. Output * **path**: a list of integers representing the nodes in the shortest path from the starting node to the goal node, inclusive. If no path exists, return an empty list. Constraints * The graph will contain at most 10^5 nodes and 10^6 edges. * There will be no parallel edges or self-loops. * All node identifiers will be unique and within the range [0, 10^5 - 1]. * The start and goal nodes will always exist in the graph. Examples ```python >>> shortest_path_bfs( ... {0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2, 4], 4: [3], 5: [6], 6: [5]}, ... 0, ... 4 ... ) [0, 1, 3, 4] >>> shortest_path_bfs( ... {0: [1], 1: [0]}, ... 0, ... 1 ... ) [0, 1] >>> shortest_path_bfs( ... {0: [1, 2], 1: [0, 2], 2: [0, 1]}, ... 0, ... 3 ... ) [] ``` Additional Requirement * Ensure that your function efficiently handles large graphs and can process them within reasonable time limits. * Validate input parameters and implement error handling for cases where input constraints are violated.","solution":"from collections import deque def shortest_path_bfs(graph: dict[int, list[int]], start: int, goal: int) -> list[int]: if start == goal: return [start] visited = set() queue = deque([(start, [start])]) while queue: current_node, path = queue.popleft() if current_node in visited: continue visited.add(current_node) for neighbor in graph[current_node]: if neighbor == goal: return path + [neighbor] if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return []"},{"question":"# Coding Assessment Question Scenario: You are developing a utility to manage hierarchical data, such as the structure of a file system. One feature of this utility is to convert a given file path into a simplified version without redundant components like \\".\\" (current directory) or \\"..\\" (parent directory). Your task is to implement a function that simplifies an absolute file path according to the Unix-style file path simplification rules. Task: Write a Python function `simplify_path(path: str) -> str` that: * Takes a string `path` which represents an absolute Unix-style file path. * Returns the simplified canonical path. # Specifications: * **Input**: A single string `path` representing an absolute Unix-style file path. * **Output**: A string representing the simplified canonical path. # Constraints: * The absolute path will always start with a single slash `/`. * The output path must end with a single slash `/` unless it is the root `/`. * Consecutive slashes `//` in the input should be treated as a single slash `/`. * Dot `.` in the path represents the current directory and should be ignored. * Double dot `..` moves up one directory level unless already at the root `/`. * The length of the input path will be within the range `[1, 3000]`. Example Inputs and Outputs: 1. `simplify_path(\\"/home/\\")` should return `\\"/home/\\"`. 2. `simplify_path(\\"/../\\")` should return `\\"/\\"`. 3. `simplify_path(\\"/home//foo/\\")` should return `\\"/home/foo/\\"`. 4. `simplify_path(\\"/a/./b/../../c/\\")` should return `\\"/c/\\"`. 5. `simplify_path(\\"/a//b////c/d//././/..\\")` should return `\\"/a/b/c/\\"`. # Edge Cases: 1. Input: `\\"/../..\\"`, Expected output: `\\"/\\"` 2. Input: `\\"/../../../../\\"`, Expected output: `\\"/\\"` 3. Input: `\\"/a/../../b/../c//.//\\"`, Expected output: `\\"/c/\\"` 4. Input: `\\"/.\\"`, Expected output: `\\"/\\"` # Example Error Handling: No error handling is required for this task since inputs will always be valid strings. # Note: Ensure that the simplified path maintains the Unix-style file path rules and outputs the canonical form correctly.","solution":"def simplify_path(path: str) -> str: Simplifies the given Unix-style path and returns the canonical path. :param path: str - The absolute Unix-style path to simplify. :return: str - The simplified canonical path. components = path.split(\'/\') stack = [] for component in components: if component == \'\' or component == \'.\': continue elif component == \'..\': if stack: stack.pop() else: stack.append(component) simplified_path = \'/\' + \'/\'.join(stack) if len(simplified_path) > 1: simplified_path = simplified_path.rstrip(\'/\') + \'/\' return simplified_path"},{"question":"# Coding Assessment Question Problem Statement You are given an array of integers and you need to form a list of all distinct subsets of this array. Your task is to implement a function that returns these subsets in lexicographical order. Function Signature ```python def find_subsets(arr): Generates all distinct subsets of the given array in lexicographical order. Parameters: arr (List[int]): An array of integers. Returns: List[List[int]]: A list of lists where each list represents a subset of the input array. # your code here ``` Input Format - `arr`: A list of integers which may contain duplicates. Output Format - A list of lists where each list is a subset of the original array. The subsets must be listed in lexicographical order. Constraints - The length of the array ( N ) ( (0 leq N leq 15) ). - The integers in the array ( arr ) lie in the range (-10 leq arr[i] leq 10 ). Example Given the array: ```python test_arr = [1, 2, 2] ``` calling `find_subsets(test_arr)` should return: ``` [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]] ``` # Requirements 1. Sort the array to handle duplicates and ensure lexicographical order. 2. Use a backtracking approach to generate all possible subsets. 3. Ensure that only unique subsets are included in the result.","solution":"def find_subsets(arr): Generates all distinct subsets of the given array in lexicographical order. Parameters: arr (List[int]): An array of integers. Returns: List[List[int]]: A list of lists where each list represents a subset of the input array. arr.sort() res = [] dfs(arr, 0, [], res) return res def dfs(arr, index, path, res): res.append(path) for i in range(index, len(arr)): if i > index and arr[i] == arr[i - 1]: continue dfs(arr, i + 1, path + [arr[i]], res)"},{"question":"# Binary Search Tree (BST) Deletion Objective: Implement the delete operation in a Binary Search Tree (BST) and ensure the tree retains its properties after deletion. # Task: Write a function `delete_node` that deletes a node with a given value from a BST. Ensure that the tree remains a valid BST after the deletion. # Function Specifications: 1. **delete_node(root: \'TreeNode\', key: int) -> \'TreeNode\'**: * Deletes the node with the value `key` from the BST and returns the new root of the BST. * **Input**: * root: The root node of the BST. * key: The integer value to be deleted from the BST. * **Output**: The new root of the BST after deletion. # Constraints: - The values in the BST nodes are unique. - The algorithm should run in O(h) time complexity where h is the height of the tree. - You may assume the tree is not empty, and the key to be deleted exists in the tree. # Example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example tree: # 5 # / # 3 6 # / # 2 4 7 root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(6) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right.right = TreeNode(7) >>> new_root = delete_node(root, 3) # After deletion, the tree should be: # 5 # / # 4 6 # / # 2 7 >>> new_root = delete_node(root, 6) # After deletion, the tree should be: # 5 # / # 3 7 # / # 2 4 ``` # Notes: - Make sure the tree remains balanced if any balancing properties were part of the BST invariant. - Consider various edge cases, including deleting the root node, nodes with one child, nodes with two children, and leaf nodes. - You are not required to handle the balancing for self-balancing BSTs like AVL trees or Red-Black trees—simply ensure the standard BST properties are maintained.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def delete_node(root, key): Deletes the node with the given key from the BST and returns the new root. if not root: # base case return root # recursively find the node to be deleted if key < root.val: root.left = delete_node(root.left, key) elif key > root.val: root.right = delete_node(root.right, key) else: # root is the node to be deleted # node with only one child or no child if not root.left: return root.right elif not root.right: return root.left # node with two children: # get the inorder successor (smallest in the right subtree) min_node = get_min_node(root.right) # copy the inorder successor\'s content to root root.val = min_node.val # delete the inorder successor root.right = delete_node(root.right, min_node.val) return root def get_min_node(node): current = node while current.left: current = current.left return current"},{"question":"# Problem Statement Implement a `Trie` class for storing a collection of strings efficiently. A `Trie` (or prefix tree) allows for fast insertion, searching, and prefix matching operations. You need to provide the following methods for the `Trie`: 1. **insert** a word into the trie. 2. **search** for a word in the trie. 3. **starts_with** to check if there is any word in the trie that starts with the given prefix. 4. **delete** a word from the trie. 5. **get_words_with_prefix** to return all words in the trie that start with a given prefix. 6. **clear** to remove all words from the trie. # Input and Output - **insert(word)**: Adds a word to the trie. - **Input**: Single string containing the word. - **Output**: None - **search(word)**: Returns True if the word is in the trie, otherwise False. - **Input**: Single string containing the word. - **Output**: Boolean - **starts_with(prefix)**: Returns True if there is any word in the trie that starts with the given prefix. - **Input**: Single string containing the prefix. - **Output**: Boolean - **delete(word)**: Removes the word from the trie. - **Input**: Single string containing the word. - **Output**: None - **get_words_with_prefix(prefix)**: Returns a list of all words in the trie that start with the given prefix. - **Input**: Single string containing the prefix. - **Output**: List of strings - **clear()**: Removes all words from the trie. - **Output**: None # Constraints - `<word>` and `<prefix>` are non-empty strings containing lowercase alphabets only. - All operations should be performed efficiently. - Handle cases where operations are performed on an empty trie gracefully. # Example Usage ```python trie = Trie() trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"application\\") print(trie.search(\\"apple\\")) # Output: True print(trie.search(\\"app\\")) # Output: True print(trie.search(\\"appliant\\")) # Output: False print(trie.starts_with(\\"app\\")) # Output: True print(trie.starts_with(\\"banana\\")) # Output: False print(trie.get_words_with_prefix(\\"app\\")) # Output: [\'apple\', \'app\', \'application\'] trie.delete(\\"apple\\") print(trie.search(\\"apple\\")) # Output: False trie.clear() print(trie.search(\\"app\\")) # Output: False ``` You must implement the entire `Trie` class with the specified methods and properties.","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.end_of_word = True def search(self, word): current = self.root for char in word: if char not in current.children: return False current = current.children[char] return current.end_of_word def starts_with(self, prefix): current = self.root for char in prefix: if char not in current.children: return False current = current.children[char] return True def delete(self, word): def _delete(current, word, index): if index == len(word): if not current.end_of_word: return False current.end_of_word = False return len(current.children) == 0 char = word[index] if char not in current.children: return False if _delete(current.children[char], word, index + 1): del current.children[char] return not current.end_of_word and len(current.children) == 0 return False _delete(self.root, word, 0) def get_words_with_prefix(self, prefix): def _collect_words(node, prefix, words): if node.end_of_word: words.append(prefix) for char, next_node in node.children.items(): _collect_words(next_node, prefix + char, words) current = self.root for char in prefix: if char not in current.children: return [] current = current.children[char] words = [] _collect_words(current, prefix, words) return words def clear(self): self.root = TrieNode()"},{"question":"**Question: Counting Anagrams in a Dictionary** Given a list of words, determine how many unique anagram groups can be formed. Words are considered anagrams if they can be rearranged to form the same word. **Function Signature:** ```python def count_anagram_groups(words: List[str]) -> int: pass ``` **Input:** - `words` : a list of strings where each string only contains lowercase alphabets. ( 1 leq text{len(words)} leq 10^5 ), ( 1 leq text{len(word)} leq 100 ) for each word in `words`. **Output:** - Return an integer representing the number of unique anagram groups. **Example:** ```plaintext Input: [\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\", \\"google\\", \\"gooegl\\", \\"abc\\", \\"cab\\"] Output: 3 Input: [\\"rat\\", \\"tar\\", \\"art\\", \\"star\\", \\"tars\\", \\"cheese\\"] Output: 4 ``` **Constraints:** - The comparison should be case-insensitive. - The list of words can contain up to 100,000 entries. - Each word may contain up to 100 characters. **Performance Requirements:** - The function should efficiently handle the worst-case input sizes. **Edge Cases:** - Consider scenarios with no anagrams (all input words are unique). - Consider the minimum and maximum input sizes.","solution":"from typing import List def count_anagram_groups(words: List[str]) -> int: anagram_groups = set() for word in words: # Sorting the word and converting it to a tuple of characters sorted_word = tuple(sorted(word)) anagram_groups.add(sorted_word) return len(anagram_groups)"},{"question":"Problem Statement You are required to implement a function that simulates a stack data structure using two queues. Recall that a stack processes elements in a Last In, First Out (LIFO) order and supports two main operations: push (adds an element to the top) and pop (removes the top element). Design a class `QueueStack` that simulates the operations of a stack using two queues. The class should implement the following methods: * `push(self, x: int) -> None`: Pushes element `x` onto the stack. * `pop(self) -> int`: Removes the element on the top of the stack and returns that element. * `top(self) -> int`: Gets the top element of the stack. * `empty(self) -> bool`: Returns `True` if the stack is empty, otherwise returns `False`. # Input * The methods of the `QueueStack` class will be called with respective parameters. # Output * `push` method does not return anything. * `pop` method returns the popped element. * `top` method returns the top element. * `empty` method returns a boolean indicating if the stack is empty. # Constraints * You should use two queues to implement the stack functionality. * Consider all calls to `pop` and `top` are valid and will not be called on an empty stack. * The elements pushed will be in the range of 32-bit signed integers. * The number of elements in the stack will not exceed 10^5. # Example: Input: ```python obj = QueueStack() obj.push(1) obj.push(2) print(obj.top()) # Output: 2 print(obj.pop()) # Output: 2 print(obj.empty()) # Output: False ``` Explanation: 1. An instance of `QueueStack` is created. 2. Pushed element `1` onto the stack. 3. Pushed element `2` onto the stack. 4. Called `top` which returns `2` as it is the most recently added element. 5. Called `pop` which returns `2` and removes it from the stack. 6. Called `empty` which returns `False` since the stack is not empty (it contains one element: `1`).","solution":"from collections import deque class QueueStack: def __init__(self): self.q1 = deque() self.q2 = deque() def push(self, x: int) -> None: self.q2.append(x) while self.q1: self.q2.append(self.q1.popleft()) self.q1, self.q2 = self.q2, self.q1 def pop(self) -> int: return self.q1.popleft() def top(self) -> int: return self.q1[0] def empty(self) -> bool: return len(self.q1) == 0"},{"question":"# List Rotation by K You are asked to create a function that rotates elements of a list to the right by `k` steps. The function should modify the list in place without creating an additional list. The elements that get shifted out on the right will come around to the left side of the list. Function Signature ```python def rotate_list(nums: list[int], k: int) -> None: Rotates the given list `nums` to the right by `k` steps. Args: nums: List of integers to rotate. k: Number of steps to rotate the list. Returns: None. The function modifies the list in place. Example: >>> lst = [1, 2, 3, 4, 5] >>> rotate_list(lst, 2) >>> lst [4, 5, 1, 2, 3] >>> lst2 = [0, 1, 2] >>> rotate_list(lst2, 4) >>> lst2 [2, 0, 1] # Your code goes here ``` Input and Output * **Input**: * `nums` (list of int): The list of integers to rotate. * `k` (int): The number of steps to rotate the list. Can be zero or negative and should handle cases where `k` is larger than the length of the list. * **Output**: - The function modifies the input list `nums` in place without returning anything. Constraints * The input list may be of any length from 0 and up. * The rotation steps `k` will be a valid integer. Performance Requirements * The function should operate in O(n) complexity where n is the length of the `nums` list. * In-place modification of the list with constant space usage is required.","solution":"def rotate_list(nums: list[int], k: int) -> None: Rotates the given list `nums` to the right by `k` steps. Args: nums: List of integers to rotate. k: Number of steps to rotate the list. Returns: None. The function modifies the list in place. if not nums or k <= 0: return n = len(nums) k = k % n # Handle cases where k is larger than the list length nums[:] = nums[-k:] + nums[:-k]"},{"question":"# Coding Assessment Question Scenario You are developing a utility that will help to process a collection of data records. Each record contains multiple pieces of information, including names, ages, and heights. The task is to filter and sort these records based on specific criteria. Task Description Write a function `process_records` that takes the following parameters: * `records`: A list of dictionaries, where each dictionary represents a record with keys `\'name\'`, `\'age\'`, and `\'height\'`. * `age_threshold`: An integer indicating the age threshold for filtering records. * `sort_by`: A string indicating the attribute by which to sort the records (`\'name\'`, `\'age\'`, or `\'height\'`). * `ascending`: A boolean indicating whether to sort the records in ascending order (`True`) or descending order (`False`). Your function should filter the records to include only those where the age is greater than or equal to the `age_threshold`, then sort the filtered records based on the `sort_by` attribute and the `ascending` flag. Input and Output Formats ```python def process_records(records, age_threshold, sort_by, ascending): pass # Example usage: records = [ {\'name\': \'Alice\', \'age\': 31, \'height\': 165}, {\'name\': \'Bob\', \'age\': 25, \'height\': 175}, {\'name\': \'Charlie\', \'age\': 30, \'height\': 160}, {\'name\': \'David\', \'age\': 27, \'height\': 180}, {\'name\': \'Eve\', \'age\': 29, \'height\': 170} ] age_threshold = 28 sort_by = \'height\' ascending = False result = process_records(records, age_threshold, sort_by, ascending) print(f\\"Filtered and sorted records: {result}\\") # Expected output: [{\'name\': \'Eve\', \'age\': 29, \'height\': 170}, {\'name\': \'Alice\', \'age\': 31, \'height\': 165}, {\'name\': \'Charlie\', \'age\': 30, \'height\': 160}] ``` Constraints * `records` will contain at least one record. * Each record in `records` will have only the keys `\'name\'`, `\'age\'`, and `\'height\'`. * The values for `\'name\'` will be strings, and values for `\'age\'` and `\'height\'` will be integers. Performance Requirements * Ensure that your function can handle lists of up to 1,000 records efficiently. * Make sure to perform the sorting function accurately and in accordance with the provided `ascending` flag.","solution":"def process_records(records, age_threshold, sort_by, ascending): Filters and sorts a list of records based on specified criteria. Args: records (list of dict): List of records, each containing \'name\', \'age\', and \'height\'. age_threshold (int): The age threshold for filtering records. sort_by (str): The attribute by which to sort the records (\'name\', \'age\', or \'height\'). ascending (bool): Whether to sort in ascending order. Returns: list of dict: Filtered and sorted list of records. # Step 1: Filter records based on the age threshold filtered_records = [record for record in records if record[\'age\'] >= age_threshold] # Step 2: Sort the filtered records based on the sort_by attribute and ascending flag sorted_records = sorted(filtered_records, key=lambda x: x[sort_by], reverse=not ascending) return sorted_records"},{"question":"# Question: Implement a Circle Packing Algorithm You are tasked with implementing a Circle Packing algorithm that fills a predefined rectangular area with the maximum number of non-overlapping circles. The circles should all have a predefined radius and be placed within the bounds of the rectangle, starting from a given position. # Requirements: 1. Implement the function `pack_circles(x: float, y: float, width: float, height: float, radius: float)`: * **`x` (float)**: The x-coordinate of the bottom-left corner of the rectangle. * **`y` (float)**: The y-coordinate of the bottom-left corner of the rectangle. * **`width` (float)**: The width of the rectangle. * **`height` (float)**: The height of the rectangle. * **`radius` (float)**: The radius of the circles to be packed within the rectangle. 2. Ensure that the algorithm places the maximum number of non-overlapping circles within the rectangular bounds. 3. The circles should be evenly spaced, and no two circles should overlap. # Example: ```python pack_circles(0, 0, 100, 100, 10) ``` This should place as many circles with radius `10` as possible within a `100x100` rectangle starting at the bottom-left corner `(0, 0)`. # Constraints: * 0 < width <= 1000 * 0 < height <= 1000 * 1 <= radius <= 100 # Performance Requirements: * The algorithm should efficiently handle the packing of circles and minimize computational time complexity.","solution":"def pack_circles(x: float, y: float, width: float, height: float, radius: float): Packs the maximum number of non-overlapping circles within a given rectangular area. Parameters: - x (float): The x-coordinate of the bottom-left corner of the rectangle. - y (float): The y-coordinate of the bottom-left corner of the rectangle. - width (float): The width of the rectangle. - height (float): The height of the rectangle. - radius (float): The radius of the circles to be packed within the rectangle. Returns: A list of tuples, where each tuple represents the (x, y) center coordinates of a circle. centers = [] diameter = 2 * radius n_x = int(width // diameter) n_y = int(height // diameter) for i in range(n_x): for j in range(n_y): circle_x = x + radius + i * diameter circle_y = y + radius + j * diameter centers.append((circle_x, circle_y)) return centers"},{"question":"# Problem Statement You are given an unsorted list of integers where each integer represents the daily temperature. Implement the function `daily_temperatures` that returns a list of integers. For each day in the input list, the function should indicate how many days until a warmer temperature. If there is no future day with a warmer temperature, the output for that day should be 0. # Function Signature ```python def daily_temperatures(temperatures: List[int]) -> List[int]: ``` # Input - `temperatures`: A list of integers ranging from -100 to 100 representing the daily temperatures, where `1 <= len(temperatures) <= 30000`. # Output - A list of integers where each integer represents the number of days until a warmer temperature for that day. If no such warmer temperature exists in the future, the corresponding output is 0. # Constraints - The temperatures can vary between highly negative to highly positive values. - Ensure your solution is optimized for large input sizes up to 30,000 in length. # Example ```python print(daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73])) # Outputs: [1, 1, 4, 2, 1, 1, 0, 0] print(daily_temperatures([30, 40, 50, 60])) # Outputs: [1, 1, 1, 0] ``` # Execution Requirements - The function should operate efficiently with a linear time complexity most suitable for larger lists. - Ensure edge cases are considered, such as a list with all the same temperatures or random non-repeating temperatures. # Scenario Imagine you are designing a weather forecast application where users can see predictions of how many days it will take for a warmer day. The efficient and quick calculation of this prediction is crucial for providing real-time updates to users based on incoming temperature data. # Notes - Test the function under various scenarios including lists where all temperatures are the same, strictly increasing or decreasing temperatures, and random values. - Ensure the solution makes use of efficient algorithms to handle large inputs within acceptable time limits.","solution":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: Returns a list where each element represents the number of days until a warmer temperature for that day. If there is no future day with a warmer temperature, the output for that day is 0. n = len(temperatures) result = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: prev_day = stack.pop() result[prev_day] = i - prev_day stack.append(i) return result"},{"question":"# Coding Problem You are tasked with implementing a `CircularBuffer` data structure, which should support efficient insertion and deletion of elements in a fixed-size buffer that operates in a circular manner. Your implementation must adhere to the following specifications: Specifications 1. **Class Structure**: Implement the `CircularBuffer` class with the following methods: - `__init__(self, capacity: int) -> None` - `__bool__(self) -> bool` - `is_full(self) -> bool` - `is_empty(self) -> bool` - `insert(self, value: T) -> None` - `remove(self) -> T` - `peek(self) -> T` - `clear(self) -> None` - `__iter__(self) -> Iterator[T]` 2. **Buffer Properties**: - The buffer should operate in a circular manner such that once it reaches the end, it wraps around to the beginning. - The buffer should maintain the order of elements as they are inserted until the capacity is reached. Once full, new elements should overwrite the oldest elements. 3. **Functionality**: - `insert(value: T)`: Inserts a new value into the buffer. If the buffer is full, it should overwrite the oldest element. - `remove() -> T`: Removes and returns the oldest element from the buffer. Raises an `IndexError` if the buffer is empty. - `peek() -> T`: Returns the oldest element without removing it. Raises an `IndexError` if the buffer is empty. - `clear() -> None`: Removes all elements from the buffer. - `__bool__() -> bool`: Returns `True` if the buffer is not empty, otherwise `False`. - `is_full() -> bool`: Returns `True` if the buffer is full, otherwise `False`. - `is_empty() -> bool`: Returns `True` if the buffer is empty, otherwise `False`. - `__iter__() -> Iterator[T]`: Returns an iterator that provides the elements of the buffer in order, starting from the oldest element. 4. **Constraints**: - Elements should be of a type that supports comparison operations if the buffer operations require them. - The buffer\'s capacity should be a positive integer. 5. **Performance Requirements**: - Insertion and removal operations must have an average time complexity of O(1). Example Usage ```python cb = CircularBuffer(3) cb.insert(1) cb.insert(2) cb.insert(3) assert cb.peek() == 1 assert cb.is_full() == True assert list(cb) == [1, 2, 3] cb.insert(4) # This should overwrite the oldest element (1) assert cb.peek() == 2 assert cb.remove() == 2 assert cb.remove() == 3 assert cb.remove() == 4 assert cb.is_empty() == True cb.insert(5) cb.insert(6) assert list(cb) == [5, 6] ``` Notes * You may implement additional helper methods if necessary. * Make sure to handle edge cases such as operations on an empty buffer appropriately.","solution":"from typing import List, TypeVar, Iterator T = TypeVar(\'T\') class CircularBuffer: def __init__(self, capacity: int) -> None: self.capacity = capacity self.buffer: List[T] = [None] * capacity self.start = 0 self.count = 0 def __bool__(self) -> bool: return self.count > 0 def is_full(self) -> bool: return self.count == self.capacity def is_empty(self) -> bool: return self.count == 0 def insert(self, value: T) -> None: end = (self.start + self.count) % self.capacity self.buffer[end] = value if self.is_full(): self.start = (self.start + 1) % self.capacity else: self.count += 1 def remove(self) -> T: if self.is_empty(): raise IndexError(\\"remove from an empty buffer\\") value = self.buffer[self.start] self.start = (self.start + 1) % self.capacity self.count -= 1 return value def peek(self) -> T: if self.is_empty(): raise IndexError(\\"peek into an empty buffer\\") return self.buffer[self.start] def clear(self) -> None: self.start = 0 self.count = 0 def __iter__(self) -> Iterator[T]: for i in range(self.count): yield self.buffer[(self.start + i) % self.capacity]"},{"question":"# Coding Assessment Question You are a systems engineer working on a project that involves sorting and processing large datasets. To showcase your ability to handle data efficiently, you need to write a function that performs custom sorting. Write a function `custom_sort(data: list[tuple[str, int, float]]) -> list[tuple[str, int, float]]` which sorts a list of tuples based on the following rules: 1. **Primary Sort**: By the string element, lexicographically (case-insensitive). 2. **Secondary Sort**: By the integer element in ascending order if the primary sort keys are equal. 3. **Tertiary Sort**: By the float element in descending order if both primary and secondary sort keys are equal. Function Signature ```python def custom_sort(data: list[tuple[str, int, float]]) -> list[tuple[str, int, float]]: pass ``` Input Conditions * The input list `data` will contain tuples of the form `(str, int, float)`. * The string element will contain alphabetic characters only. * The list is non-empty and may contain up to 10^5 elements. Expected Output The function should return a new list sorted based on the rules specified above. Example Usage ```python # Sorting the list of tuples data = [(\\"apple\\", 2, 0.5), (\\"banana\\", 1, 0.75), (\\"apple\\", 2, 0.3), (\\"banana\\", 1, 0.5)] print(custom_sort(data)) # Output: [(\'apple\', 2, 0.5), (\'apple\', 2, 0.3), (\'banana\', 1, 0.75), (\'banana\', 1, 0.5)] data = [(\\"carrot\\", 5, 3.2), (\\"apple\\", 2, 2.1), (\\"banana\\", 3, 2.7), (\\"apple\\", 3, 1.5)] print(custom_sort(data)) # Output: [(\'apple\', 2, 2.1), (\'apple\', 3, 1.5), (\'banana\', 3, 2.7), (\'carrot\', 5, 3.2)] ``` Make sure your implementation is efficient and can handle the upper limit of input size. Your solution should be well-tested to ensure it handles a variety of edge cases.","solution":"def custom_sort(data: list[tuple[str, int, float]]) -> list[tuple[str, int, float]]: Sorts the list of tuples based on the following rules: 1. By the string element, lexicographically (case-insensitive). 2. By the integer element in ascending order if the primary sort keys are equal. 3. By the float element in descending order if both primary and secondary sort keys are equal. return sorted(data, key=lambda x: (x[0].lower(), x[1], -x[2]))"},{"question":"# Coding Assessment Question: You are developing a software library for handling operations on polynomials. As part of this library, you need to implement a function that multiplies two polynomials and returns the resulting polynomial in its canonical form. A polynomial is represented as a list of integers, where each element corresponds to the coefficient of the x^i term in the polynomial. The result should also be represented in the same format. Function Signature: ```python def multiply_polynomials(poly1: list[int], poly2: list[int]) -> list[int]: Multiplies two polynomials and returns the resulting polynomial. Args: poly1 (list of int): The first polynomial represented as a list of coefficients. poly2 (list of int): The second polynomial represented as a list of coefficients. Returns: list of int: The resulting polynomial after multiplication. ``` Input: - Two lists `poly1` and `poly2`, representing polynomials where the index of each element corresponds to the power of x, and the value at each index corresponds to the coefficient for that power. Output: - A list of integers representing the resulting polynomial after multiplication, in its canonical form. Example: ```python >>> multiply_polynomials([1, 2], [3, 4]) [3, 10, 8] >>> multiply_polynomials([2, 0, 3], [1, 2]) [2, 4, 3, 6] >>> multiply_polynomials([0, 0, 0], [1, 2, 3]) [0, 0, 0, 0, 0] ``` Constraints: 1. Both `poly1` and `poly2` will have a length between 1 and 1000. 2. Each coefficient in `poly1` and `poly2` will be an integer between -1000 and 1000. 3. Handle the multiplication efficiently such that the time complexity does not become prohibitive for larger polynomials. Additional Notes: - You may use Python\'s built-in functions and operations for list manipulation. - Ensure that the resulting polynomial is in its canonical form, meaning no trailing zeros unless it is a zero polynomial.","solution":"def multiply_polynomials(poly1: list[int], poly2: list[int]) -> list[int]: Multiplies two polynomials and returns the resulting polynomial. Args: poly1 (list of int): The first polynomial represented as a list of coefficients. poly2 (list of int): The second polynomial represented as a list of coefficients. Returns: list of int: The resulting polynomial after multiplication. # Resultant polynomial will be of degree len(poly1) + len(poly2) - 2 result = [0] * (len(poly1) + len(poly2) - 1) for i, coef1 in enumerate(poly1): for j, coef2 in enumerate(poly2): result[i + j] += coef1 * coef2 return result"},{"question":"# Coding Assessment Question Context You are given a task to create a function that filters out duplicate integers from a list while maintaining their order of appearance. The function should also raise an error if any of the list items are not integers. Task Write a Python function `remove_duplicates(nums: list[int]) -> list[int]` that takes a list of integers and returns a new list with duplicates removed, preserving the order of the first occurrence of each unique integer. If any element in the list is not an integer, raise a `TypeError`. Function Signature ```python def remove_duplicates(nums: list[int]) -> list[int]: pass ``` Inputs - `nums` (list of int): A list containing integers that may have duplicates. Output - Returns a new list with duplicates removed, preserving the order of the original list. Constraints - All elements in `nums` are of type `int`. - The function should raise a `TypeError` if any element in `nums` is not an integer. Examples ```python >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([10, 10, 10]) [10] >>> remove_duplicates([7, 8, 9, 7, 8, 9, 10]) [7, 8, 9, 10] >>> remove_duplicates([1]) [1] >>> remove_duplicates([]) [] >>> remove_duplicates([1, 1, \'a\']) Traceback (most recent call last): ... TypeError: remove_duplicates() accepts only integers ``` Notes - Consider edge cases such as an empty list or a list with only one element. - The order of elements in the resultant list should be the same as their first appearance in the input list. - Test the function with various inputs to confirm its robustness.","solution":"def remove_duplicates(nums: list[int]) -> list[int]: Filter out duplicate integers from the list while maintaining order of appearance. Raise a TypeError if any of the elements is not an integer. :param nums: List of integers :return: List of integers without duplicates if not all(isinstance(n, int) for n in nums): raise TypeError(\\"remove_duplicates() accepts only integers\\") seen = set() result = [] for num in nums: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"# Question: String Permutation Checker # Scenario You are working on a system that needs to verify if two given strings are permutations of each other. A permutation is a rearrangement of letters. The system needs to rapidly compare strings and determine their permutation status. # Task Write a function `are_permutations(str1: str, str2: str) -> bool` that checks if two given strings are permutations of each other. Input: * `str1` - a string containing alphanumeric characters and/or spaces. * `str2` - a string containing alphanumeric characters and/or spaces. Output: * A boolean value; `True` if the strings are permutations of each other, and `False` otherwise. Constraints: * The strings may contain both upper-case and lower-case letters. Treat \'A\' and \'a\' as different characters. * Consider strings containing only letters and digits and spaces. Example: ```python >>> are_permutations(\\"listen\\", \\"silent\\") True >>> are_permutations(\\"triangle\\", \\"integral\\") True >>> are_permutations(\\"hello\\", \\"billion\\") False >>> are_permutations(\\"aabbcc\\", \\"abcabc\\") True >>> are_permutations(\\"apple\\", \\"pale\\") False ``` Implementation Tips: 1. Compare the lengths of the two strings. If they are not equal, they cannot be permutations. 2. Use a frequency counter (e.g., collections.Counter in Python) to count the occurrences of each character in both strings. 3. Compare the frequency counters of both strings. # Performance Requirements The implementation should ideally have a time complexity of (O(n)), where (n) is the length of the strings, because the comparison of characters and their frequencies should be linear.","solution":"from collections import Counter def are_permutations(str1: str, str2: str) -> bool: Checks if two strings are permutations of each other. :param str1: First string. :param str2: Second string. :return: True if str1 and str2 are permutations of each other, False otherwise. # If lengths are not equal, they cannot be permutations if len(str1) != len(str2): return False # Use Counter to compare character counts return Counter(str1) == Counter(str2)"},{"question":"# Problem Statement You are given a list of integers and you need to write a function `top_k_frequent` that returns the list of `k` most frequent elements in the provided list in descending order of their frequency. If two elements have the same frequency, they should be ordered based on their value in descending order. # Function Signature ```python def top_k_frequent(arr: list, k: int) -> list: pass ``` # Inputs - `arr`: A list of integers where 1 <= len(arr) <= 10^5. - `k`: An integer representing the number of most frequent elements to extract (1 <= k <= len(arr)). # Output - A list of the `k` most frequent integers from the input list `arr`, sorted by their frequency in descending order. If two elements have the same frequency, sort by their value in descending order. # Constraints - The input list may contain both positive and negative integers. - Elements in the resulting list should be in descending order based on frequency and value. # Example ```python assert top_k_frequent([1, 1, 1, 2, 2, 3], 2) == [1, 2] assert top_k_frequent([4, 4, 4, 5, 5, -1, -1, -1, -1, 2, 3, 3], 3) == [-1, 4, 5] ``` # Requirements - The solution should be efficient, possibly leveraging data structures that assist in frequency counting and sorting effectively. - Handle edge cases such as when `k` is equal to the length of the array or when there are ties in frequency of elements. - Ensure the solution is well-optimized to handle the upper limits of the input constraints.","solution":"def top_k_frequent(arr, k): from collections import Counter # Count the frequency of each element in the array frequency_counter = Counter(arr) # Sort values first by frequency (descending) and then by value (descending) sorted_elements = sorted(frequency_counter.items(), key=lambda x: (-x[1], -x[0])) # Extract the top k elements based on the sorted order top_k_elements = [elem[0] for elem in sorted_elements[:k]] return top_k_elements"},{"question":"# Coding Question You are tasked to implement a function that calculates the distance between two points on a Cartesian plane. The points are given as tuples with their x and y coordinates. Function Signature ```python def calculate_distance(point1: tuple[float, float], point2: tuple[float, float]) -> float: pass ``` Input - `point1` (tuple of two floats): The coordinates (x1, y1) of the first point. - `point2` (tuple of two floats): The coordinates (x2, y2) of the second point. Output - (float): The Euclidean distance between the two points. Constraints - The values for each coordinate are real numbers (float), which can be positive or negative. Examples ```python >>> round(calculate_distance((1, 2), (4, 6)), 2) 5.0 >>> round(calculate_distance((0, 0), (0, 0)), 2) 0.0 >>> round(calculate_distance((1.1, 2.2), (3.3, 4.4)), 2) 3.11 >>> round(calculate_distance((-1, -1), (-4, -5)), 2) 5.0 >>> round(calculate_distance((2, -3), (-1, 4)), 2) 7.62 ``` Additional Notes - You can use the distance formula: [ sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2} ] - Ensure your function handles negative coordinates correctly.","solution":"import math def calculate_distance(point1: tuple[float, float], point2: tuple[float, float]) -> float: Calculates the Euclidean distance between two points on a Cartesian plane. Parameters: - point1: tuple (x1, y1) for the first point - point2: tuple (x2, y2) for the second point Returns: - float: the Euclidean distance between the two points x1, y1 = point1 x2, y2 = point2 return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)"},{"question":"# Question: Implement a Merge Sort for Linked Lists You are given a singly linked list where each node contains an integer. Your task is to implement the merge sort algorithm to sort this linked list in ascending order. The linked list is represented as follows: - A node class `ListNode` representing each node in the linked list. # Definition of ListNode ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` # Input * A ListNode `head` which is the head of the linked list. # Output * The head of the sorted linked list. # Example ```python Input: head = ListNode(4, ListNode(2, ListNode(1, ListNode(3)))) Output: sorted_head => 1 -> 2 -> 3 -> 4 Explanation: The input linked list is 4 -> 2 -> 1 -> 3. The sorted linked list is 1 -> 2 -> 3 -> 4. ``` # Constraints * The number of nodes in the linked list will be in the range [0, 5000]. * -10^5 <= Node.val <= 10^5 # Note - Ensure the efficient O(n log n) time complexity of merge sort for linked lists. - Handle edge cases such as empty linked list or a linked list with only one node. Implement the function `merge_sort_linked_list(head)` to solve the problem.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort_linked_list(head): if not head or not head.next: return head # Split the list into two halves def split_list(head): slow = head fast = head.next while fast and fast.next: slow = slow.next fast = fast.next.next mid = slow.next slow.next = None return head, mid # Merge two sorted linked lists def merge_lists(l1, l2): dummy = ListNode() tail = dummy while l1 and l2: if l1.val < l2.val: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next if l1: tail.next = l1 else: tail.next = l2 return dummy.next # Recursive merge sort first_half, second_half = split_list(head) sorted_first_half = merge_sort_linked_list(first_half) sorted_second_half = merge_sort_linked_list(second_half) return merge_lists(sorted_first_half, sorted_second_half)"},{"question":"# Context Sorting algorithms are fundamental in computer science. One interesting algorithm is the \\"merge sort,\\" which divides the input array into two halves, recursively sorts them, and then merges the sorted halves. # Problem Statement Implement the Merge Sort algorithm in Python. Your task is to write a function `merge_sort` that takes a list of integers and returns a new list that is sorted in ascending order. # Requirements 1. **merge_sort(arr: List[int]) -> List[int]**: Takes a list of integers `arr` and returns a new sorted list. # Input and Output Formats * **Input**: A list of integers. * **Output**: A new list of integers sorted in ascending order. # Constraints * The input list can contain negative numbers. * The function should handle the edge cases of empty lists and lists with a single element. # Performance Considerations * Aim for an average time complexity of O(n log n), where n is the number of elements in the array. # Example ```python # Example usage: arr = [38, 27, 43, 3, 9, 82, 10] sorted_arr = merge_sort(arr) assert sorted_arr == [3, 9, 10, 27, 38, 43, 82] arr = [] sorted_arr = merge_sort(arr) assert sorted_arr == [] arr = [1] sorted_arr = merge_sort(arr) assert sorted_arr == [1] ``` # Edge Cases to Consider * Empty list. * List with a single element. * List with duplicate elements. * List sorted in descending order. Implement the function: ```python from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) ```","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right)"},{"question":"# Prime Number Partition Function Implement a function that partitions a given list of integers into multiple sublists, such that each sublist only contains prime numbers, and the sum of each sublist is as close to an even split of the total sum as possible. Follow these steps: 1. **Prime Identification**: Create a helper function to check if a number is prime. 2. **Filter Primes**: Filter out all non-prime numbers from the input list. 3. **Partitioning**: Partition the list of prime numbers into sublists, ensuring the sum of each sublist is as close to the total sum divided by the number of partitions as possible. # Input and Output Input * `numbers`: A list of integers. * `num_partitions`: An integer representing the number of partitions. Output * A list of lists, where each sublist contains prime numbers, and the sum of these sublists is balanced. # Constraints * You are provided the following function: * `is_prime(n)`: Returns `True` if `n` is a prime number, otherwise returns `False`. ```python from math import sqrt def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def partition_primes(numbers, num_partitions): # Helper function to split list into num_partitions parts with minimal sum difference def balanced_partition(sorted_numbers, num_partitions): partitions = [[] for _ in range(num_partitions)] sums = [0] * num_partitions for number in sorted_numbers: min_index = sums.index(min(sums)) partitions[min_index].append(number) sums[min_index] += number return partitions # Filter prime numbers from the input list primes = [n for n in numbers if is_prime(n)] # Sort the prime numbers in descending order to help balance the partition primes.sort(reverse=True) # Partition the sorted primes list partitions = balanced_partition(primes, num_partitions) return partitions # Example usage: numbers = [29, 2, 3, 5, 11, 23, 17, 19, 8, 10, 22] num_partitions = 3 print(partition_primes(numbers, num_partitions)) # Output will be a list of 3 sublists with balanced prime sums. ```","solution":"from math import sqrt def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def partition_primes(numbers, num_partitions): # Helper function to split list into num_partitions parts with minimal sum difference def balanced_partition(sorted_numbers, num_partitions): partitions = [[] for _ in range(num_partitions)] sums = [0] * num_partitions for number in sorted_numbers: min_index = sums.index(min(sums)) partitions[min_index].append(number) sums[min_index] += number return partitions # Filter prime numbers from the input list primes = [n for n in numbers if is_prime(n)] # Sort the prime numbers in descending order to help balance the partition primes.sort(reverse=True) # Partition the sorted primes list partitions = balanced_partition(primes, num_partitions) return partitions"},{"question":"# Fibonacci Number Finder Problem Statement As part of a technical screening, you need to implement a function that finds the n-th Fibonacci number efficiently. The Fibonacci sequence is defined as follows: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n > 1 Given an integer `n`, your task is to find the n-th Fibonacci number. Objectives 1. Write a function `find_fibonacci` to compute the n-th Fibonacci number. Function Signature ```python def find_fibonacci(n: int) -> int: Computes the n-th Fibonacci number. Parameters: n (int): The index of the Fibonacci number to compute Returns: int: The n-th Fibonacci number pass ``` Example ```python n = 10 result = find_fibonacci(n) print(f\\"The {n}-th Fibonacci number is: {result}\\") ``` Expected Output ``` The 10-th Fibonacci number is: 55 ``` Constraints 1. `0 <= n <= 50` Ensure your function is optimized to handle the upper constraint efficiently. This problem tests your understanding of dynamic programming or iterative sequence computation techniques, ensuring efficiency and optimal performance.","solution":"def find_fibonacci(n: int) -> int: Computes the n-th Fibonacci number. Parameters: n (int): The index of the Fibonacci number to compute Returns: int: The n-th Fibonacci number if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Problem Description You are given a list of integers and an integer ( k ). Your task is to write a function `find_k_most_frequent_elements` that returns a list of the ( k ) most frequent elements in the given list. If there are multiple elements with the same frequency, break the ties by choosing the smaller elements. # Function Signature ```python def find_k_most_frequent_elements(nums: List[int], k: int) -> List[int]: ``` # Input * `nums` (List[int]): A list of integers where each integer fits within the 32-bit signed integer range. The length of the list is at least 1 and at most ( 10^5 ). * `k` (int): An integer indicating the number of most frequent elements to return. ( 1 leq k leq ) number of unique elements in `nums`. # Output * (List[int]): A list of the ( k ) most frequent elements in ascending order of elements (if needed). # Constraints * You must use an efficient approach to ensure your solution runs within a reasonable time frame for the maximum input size. * Elements in the output list should be sorted based on their value, in ascending order, in case of frequency ties. # Examples ```python >>> find_k_most_frequent_elements([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> find_k_most_frequent_elements([1], 1) [1] >>> find_k_most_frequent_elements([4, 4, 4, 5, 5, 5, 1, 1, 1], 2) [1, 4] ``` # Notes * Use suitable data structures to handle frequency counting and efficient retrieval of the most frequent elements. * Handle the edge case where the list contains only one unique element. * Consider using a heap or sorting mechanism to manage the frequency and order of elements efficiently.","solution":"from typing import List from collections import Counter import heapq def find_k_most_frequent_elements(nums: List[int], k: int) -> List[int]: Returns the k most frequent elements in nums. If there is a tie in frequency, the smaller elements are chosen first. # Count the frequency of each element in nums freq_map = Counter(nums) # Construct a list of tuples (-frequency, element) for the heap # Negative frequency is used to create a max-heap based on frequency heap = [(-freq, num) for num, freq in freq_map.items()] # Convert the list into a heap heapq.heapify(heap) # Extract k most frequent elements most_frequent = [] for _ in range(k): most_frequent.append(heapq.heappop(heap)[1]) # Sort the result in ascending order most_frequent.sort() return most_frequent"},{"question":"# Problem Statement Write a function that processes a CSV file containing student names and their corresponding grades. The function should calculate the average grade for each student and save the results to a new CSV file. # Function Signature ```python def calculate_student_averages(input_file: str, output_file: str) -> None: Calculates the average grade for each student and saves the result to a new file. Parameters: input_file (str): The file path to the input CSV file, which contains student names and grades. output_file (str): The file path to the output CSV file, where the average grades will be saved. Returns: None ``` # Input * `input_file` (str): A valid file path to an input CSV file. The file will contain rows in the format: `student_name,grade_1,grade_2,...,grade_n`. * `output_file` (str): A valid file path where the output CSV file will be saved. The output CSV file format should be `student_name,average_grade`. # Output * The function should save the output CSV file with the computed average grades for each student, retaining only up to 2 decimal places. # Constraints * You can assume that the input CSV file is well-formed and contains valid data. * Each student will have at least one grade. * The input file path and output file path will be valid. # Performance Requirements * The implementation should efficiently handle up to 10,000 students, each with up to 20 grades. # Example ```python # Input CSV file content (students_grades.csv): # john,85,90,78 # jane,80,70,88,92 # doe,95,100 calculate_student_averages(\\"students_grades.csv\\", \\"averages.csv\\") # Output CSV file content (averages.csv): # john,84.33 # jane,82.50 # doe,97.50 ``` # Notes * The grades are all floating-point numbers. * The average grade should be rounded to 2 decimal places before saving. * Use built-in Python libraries for file handling and CSV processing for this task. # Hints * Use the `csv` module from the Python standard library to handle CSV file operations. * Consider using the `csv.DictReader` and `csv.DictWriter` for more convenient processing.","solution":"import csv def calculate_student_averages(input_file: str, output_file: str) -> None: with open(input_file, mode=\'r\') as infile: reader = csv.reader(infile) student_grades = {row[0]: list(map(float, row[1:])) for row in reader} student_averages = {student: round(sum(grades) / len(grades), 2) for student, grades in student_grades.items()} with open(output_file, mode=\'w\', newline=\'\') as outfile: writer = csv.writer(outfile) for student, avg in student_averages.items(): writer.writerow([student, avg])"},{"question":"# Problem Statement Write a function to compute the largest possible rectangular area in a histogram. You are given a list of integers representing the heights of bars in a histogram. The width of each bar is 1. The function should return the area of the largest rectangle that can be formed within the confines of the histogram. # Requirements * Implement a function `max_histogram_area(heights: List[int]) -> int` that computes this area. * The function should use an efficient algorithm, ideally with a time complexity of O(n). # Function Definition ```python def max_histogram_area(heights: List[int]) -> int: # Your code here ``` # Input/Output Examples ```python assert max_histogram_area([2, 1, 5, 6, 2, 3]) == 10 assert max_histogram_area([2, 1, 2]) == 3 assert max_histogram_area([6, 2, 5, 4, 5, 1, 6]) == 12 assert max_histogram_area([2, 4]) == 4 assert max_histogram_area([]) == 0 ``` # Constraints * The input list `heights` will have a length in the range [0, 1000]. * Each height in the `heights` list will be a non-negative integer (0 ≤ heights[i] ≤ 1000). * The function should handle edge cases such as an empty list or all heights being zero. # Additional Context This problem is a classic example of using stack-based techniques to solve problems involving linear data structures efficiently. Understanding how to calculate the maximum area in a histogram is a useful skill, relevant in computational geometry and various real-world applications, such as image processing and data analysis.","solution":"from typing import List def max_histogram_area(heights: List[int]) -> int: Calculates the largest rectangular area possible in a histogram represented by a list of integers, where each integer represents the height of a bar. n = len(heights) max_area = 0 stack = [] index = 0 while index < n: # If stack is empty or current bar is taller than the bar at the stack top if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with the popped index height area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area if needed max_area = max(max_area, area) # Now pop the remaining bars from the stack and calculate area while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"**Question 2]:** **Longest Substring with Distinct Characters** **Problem Statement:** Write a function `longest_substring_distinct(s: str) -> str` that finds the longest substring of a given string `s` where all characters are distinct. **Input:** - `s` (0 <= len(s) <= 10^5): The input string which can include lowercase, uppercase letters, digits, and special characters. **Output:** - Returns a string representing the longest substring with all distinct characters from the input string. **Constraints:** - The length of the input string will be between 0 and 100,000 characters. **Function Signature:** ```python def longest_substring_distinct(s: str) -> str: pass ``` **Example:** ```python assert longest_substring_distinct(\\"abcabcbb\\") == \\"abc\\" assert longest_substring_distinct(\\"bbbbb\\") == \\"b\\" assert longest_substring_distinct(\\"pwwkew\\") == \\"wke\\" assert longest_substring_distinct(\\"\\") == \\"\\" ``` **Requirements:** - Your solution must handle large inputs efficiently using an optimized algorithm, such as sliding window technique. - Consider scenarios with uppercase and lowercase letters. - Handle edge cases like empty string and strings with no repeating characters. **Hint:** - Use a sliding window strategy with two pointers to traverse the string, and a set to track characters within the window. - Adjust the window by moving the pointers based on character repetition to maintain all distinct characters.","solution":"def longest_substring_distinct(s: str) -> str: Finds the longest substring of a given string s where all characters are distinct. n = len(s) if n == 0: return \\"\\" char_index_map = {} longest_substr = \\"\\" left = 0 for right in range(n): if s[right] in char_index_map: left = max(left, char_index_map[s[right]] + 1) char_index_map[s[right]] = right if right - left + 1 > len(longest_substr): longest_substr = s[left:right+1] return longest_substr"},{"question":"# Scenario You are developing software for a library management system which requires categorizing books based on their genres. To optimize the system\'s searching mechanism, you need to implement a tag-based system where each book can be assigned multiple genre tags. # Task Description Implement a Python class `Library` that manages a collection of books and allows books to be tagged with genres. The class should provide functionality to add and search for books based on their tags. # Class Signature ```python class Library: def __init__(self): # Initialize an empty dictionary to store books and their tags pass def add_book(self, title: str, tags: list[str]) -> None: Adds a book with specified title and genre tags to the library. pass def search_books(self, tags: list[str]) -> list[str]: Searches for books that contain all specified genre tags and returns a list of book titles. pass ``` # Input - The `add_book` method receives a `title` (a non-empty string) and `tags` (a list of non-empty strings) representing genres of the book. - The `search_books` method receives `tags` (a list of non-empty strings) used for searching books that contain all specified tags. # Output - The `add_book` method does not have a return value. - The `search_books` method returns a list of book titles (strings) that have all the specified genre tags. # Constraints - No two books will have the same title. - The tags in each list for both adding and searching will be unique. # Performance Requirements - Adding a book should be an O(1) operation on average. - Searching for books should be optimized for quick look-up. # Example ```python # Scenario setup library = Library() # Adding books library.add_book(\'The Great Gatsby\', [\'classic\', \'novel\', \'fiction\']) library.add_book(\'To Kill a Mockingbird\', [\'classic\', \'novel\', \'drama\']) library.add_book(\'1984\', [\'classic\', \'dystopian\', \'fiction\']) # Searching books # Expected: [\'The Great Gatsby\', \'1984\'] print(library.search_books([\'classic\', \'fiction\'])) # Expected: [\'To Kill a Mockingbird\'] print(library.search_books([\'classic\', \'drama\'])) ``` # Notes - Ensure your implementation allows for efficient and scalable addition and search operations. - The order of book titles in the result of `search_books` does not matter. - Use appropriate data structures to maintain efficient searching and insertion.","solution":"class Library: def __init__(self): Initialize an empty dictionary to store books and their tags self.books = {} self.tags_to_books = {} def add_book(self, title: str, tags: list[str]) -> None: Adds a book with specified title and genre tags to the library. self.books[title] = set(tags) for tag in tags: if tag not in self.tags_to_books: self.tags_to_books[tag] = set() self.tags_to_books[tag].add(title) def search_books(self, tags: list[str]) -> list[str]: Searches for books that contain all specified genre tags and returns a list of book titles. if not tags: return list(self.books.keys()) common_books = None for tag in tags: if tag not in self.tags_to_books: return [] if common_books is None: common_books = self.tags_to_books[tag] else: common_books = common_books.intersection(self.tags_to_books[tag]) return list(common_books)"},{"question":"# Minimum Spanning Tree with Kruskal\'s Algorithm You are given an undirected, weighted graph represented by a list of edges where each edge is a tuple of the form (u, v, w) indicating an edge between vertex u and vertex v with weight w. Your task is to find the Minimum Spanning Tree (MST) of the graph using Kruskal\'s algorithm. A Minimum Spanning Tree is a subset of the edges that connects all vertices together, without any cycles and with the minimum possible total edge weight. Input Format 1. `edges`: A list of tuples where each tuple (u, v, w) represents an edge connecting vertex `u` to vertex `v` with weight `w`. 2. `num_vertices`: An integer representing the number of vertices in the graph. Example: ```python edges = [ (0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4) ] num_vertices = 4 ``` Output Format - Return a list of tuples representing the edges in the MST. Each tuple should be of the form (u, v, w) indicating an edge between vertex `u` and vertex `v` with weight `w`. Example: ```python [(2, 3, 4), (0, 3, 5), (0, 1, 10)] ``` Constraints 1. The graph will have at least one vertex. 2. The number of vertices (V) will be up to 10^4. 3. The number of edges (E) will be up to 10^5. 4. The weights of the edges (w) will be non-negative integers. Task Implement the following function: ```python def minimum_spanning_tree(edges: list[tuple[int, int, int]], num_vertices: int) -> list[tuple[int, int, int]]: pass ``` **Note**: Your solution should aim to use Kruskal\'s algorithm efficiently with a Union-Find data structure to achieve nearly linear time complexity. Examples ```python edges = [ (0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4) ] num_vertices = 4 print(minimum_spanning_tree(edges, num_vertices)) # Output: [(2, 3, 4), (0, 3, 5), (0, 1, 10)] edges = [ (0, 1, 1), (1, 2, 2), (2, 3, 1), (3, 0, 2), (0, 2, 2), (1, 3, 3) ] num_vertices = 4 print(minimum_spanning_tree(edges, num_vertices)) # Output: [(0, 1, 1), (2, 3, 1), (1, 2, 2)] ```","solution":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def minimum_spanning_tree(edges, num_vertices): edges.sort(key=lambda x: x[2]) uf = UnionFind(num_vertices) mst = [] for u, v, w in edges: if uf.find(u) != uf.find(v): uf.union(u, v) mst.append((u, v, w)) return mst"},{"question":"# Problem Statement Given a list of integers, you need to implement a function to find the k-th smallest element in the list. The function should be able to handle large lists efficiently. This is to ensure your understanding of efficient selection algorithms like the Quickselect algorithm. # Function to Implement Implement the function `kth_smallest(arr: List[int], k: int) -> int` in Python, where: * `arr` is a list of integers. * `k` is an integer representing the position (1-based) of the smallest element you want to find. # Input and Output * **Input**: A list `arr` of integers and an integer `k`. * **Output**: The k-th smallest element in the list. # Constraints 1. The list length will be between `1` and `10^6`. 2. Elements in the list are between `-10^9` and `10^9`. 3. `1 ≤ k ≤ len(arr)` # Examples ```python assert kth_smallest([3, 2, 1, 5, 4], 3) == 3 assert kth_smallest([1, 1, 1, 1], 2) == 1 assert kth_smallest([5, 4, 3, 2, 1], 1) == 1 assert kth_smallest([7, 10, 4, 3, 20, 15], 4) == 10 assert kth_smallest([-1, -2, -3, 0], 1) == -3 ``` # Performance Requirements * Your solution should operate efficiently for large lists, ensuring that the time complexity remains average O(n) due to the Quickselect algorithm, and space complexity should be O(1). # Additional Notes Consider edge cases such as: * Lists where all elements are the same. * Lists with negative numbers. * Lists where the k-th smallest element is at the boundaries (first or last in sorted order). Implement your function to handle all edge cases effectively.","solution":"from typing import List def quickselect(arr: List[int], left: int, right: int, k: int) -> int: Quickselect helper function to find k-th smallest element. if left == right: return arr[left] pivot_index = partition(arr, left, right) if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(arr, left, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, right, k) def partition(arr: List[int], left: int, right: int) -> int: Partition the array and return the pivot index. pivot = arr[right] store_index = left for i in range(left, right): if arr[i] < pivot: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def kth_smallest(arr: List[int], k: int) -> int: Find the k-th smallest element in the array. return quickselect(arr, 0, len(arr) - 1, k - 1)"},{"question":"```markdown # Binary Tree Search Problem Statement You are given a binary search tree (BST) and an integer value. Your task is to implement a function `search_bst` that searches for the integer in the given BST and returns `True` if the integer is present, otherwise `False`. A binary search tree is defined as follows: - A Binary Search Tree is a binary tree in which all the left subtree values are less than the root value, and all the right subtree values are greater than the root value. - Each node in the tree has an integer value and pointers to its left and right children (which may be `None`). The tree and the target integer are provided to your function as an instance of the `TreeNode` class and a target value respectively. The `TreeNode` class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Implement the `search_bst` function with the following signature: ```python def search_bst(root: TreeNode, target: int) -> bool: ``` Constraints - The number of nodes in the binary search tree is in the range [1, 1000]. - The values of the nodes in the binary search tree are unique. - Node values are integer values within the range [-10^4, 10^4]. - The target is an integer value within the range [-10^4, 10^4]. Examples ```python # Example 1: tree = TreeNode(4) tree.left = TreeNode(2, TreeNode(1), TreeNode(3)) tree.right = TreeNode(7) print(search_bst(tree, 2)) # Output: True # Example 2: tree = TreeNode(4) tree.left = TreeNode(2, TreeNode(1), TreeNode(3)) tree.right = TreeNode(7) print(search_bst(tree, 5)) # Output: False # Example 3: tree = TreeNode(5) tree.left = TreeNode(3, TreeNode(2), TreeNode(4)) tree.right = TreeNode(6) print(search_bst(tree, 6)) # Output: True # Example 4: tree = TreeNode(5) tree.left = TreeNode(3, TreeNode(2), TreeNode(4)) tree.right = TreeNode(6) print(search_bst(tree, 7)) # Output: False ``` Ensure your function is optimized for performance, leveraging the properties of the binary search tree to minimize the number of node comparisons. ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def search_bst(root: TreeNode, target: int) -> bool: Searches for the target value in the binary search tree. Args: root (TreeNode): The root node of the BST. target (int): The target value to search for. Returns: bool: True if the target value is found, otherwise False. current = root while current: if current.val == target: return True elif target < current.val: current = current.left else: current = current.right return False"},{"question":"# Problem Statement Implement a class `QueueWithMax` that supports the following operations efficiently: 1. **Enqueue**: The method `enqueue` should add a new element to the end of the queue. 2. **Dequeue**: The method `dequeue` should remove the element at the front of the queue. 3. **Max**: The method `max` should return the maximum element currently in the queue. Input Format - You will be given a sequence of operations to perform on the queue. Each operation will be one of the following: - \\"enqueue X\\" where X is an integer to be added to the queue, - \\"dequeue\\" to remove the front element of the queue, - \\"max\\" to return the maximum element in the queue. Output Format - For each \\"max\\" operation, output the maximum element in the queue. Constraints - The sequence of operations will contain at most 10^5 operations. - Each integer to be enqueued will be in the range of -10^9 to 10^9. Methods to Implement ```python class QueueWithMax: def __init__(self): self.queue = [] self.max_queue = [] def enqueue(self, value: int) -> None: pass def dequeue(self) -> None: pass def max(self) -> int: pass ``` Example ```python q = QueueWithMax() # Enqueue operation q.enqueue(10) q.enqueue(20) q.enqueue(5) # Max operation print(q.max()) # Output: 20 # Dequeue operation q.dequeue() # Max operation print(q.max()) # Output: 20 q.enqueue(25) # Max operation print(q.max()) # Output: 25 # Dequeue operation q.dequeue() # Max operation print(q.max()) # Output: 25 ``` Note: The operations should be performed efficiently, ideally in O(1) time for each `enqueue`, `dequeue`, and `max` operation.","solution":"class QueueWithMax: def __init__(self): self.queue = [] self.max_queue = [] def enqueue(self, value: int) -> None: self.queue.append(value) while self.max_queue and self.max_queue[-1] < value: self.max_queue.pop() self.max_queue.append(value) def dequeue(self) -> None: if not self.queue: return None value = self.queue.pop(0) if value == self.max_queue[0]: self.max_queue.pop(0) return value def max(self) -> int: if not self.max_queue: return None return self.max_queue[0]"},{"question":"# Problem Statement You are developing a utility tool for a geometric modeling application, where you need to simplify a list of 2D points by removing redundant points that form straight lines. Implement a function that retains only essential points to represent the same shape accurately. Function Signature ```python def simplify_points(points: List[Tuple[float, float]]) -> List[Tuple[float, float]]: pass ``` # Input * `points` - a list of tuples, each containing two floats representing the x and y coordinates of a point in 2D space. The list always contains at least two points. # Output * Returns a list of tuples representing the simplified list of points. # Constraints * The points are given in the sequence they need to be connected, i.e., the order matters. * No two consecutive points are the same. # Requirements * If a sequence of three points lie on a straight line, remove the middle one. * Ensure that the simplified list maintains the overall shape and order of the original list. # Examples ```python >>> simplify_points([(0, 0), (1, 1), (2, 2), (3, 3), (4, 0)]) [(0, 0), (3, 3), (4, 0)] >>> simplify_points([(0, 0), (1, 1), (1, 2), (2, 3), (3, 3), (4, 0)]) [(0, 0), (1, 1), (1, 2), (2, 3), (3, 3), (4, 0)] >>> simplify_points([(1, 1), (2, 2), (3, 3)]) [(1, 1), (3, 3)] ``` # Notes * A point (C) lies on the line formed by points (A) and (B) if the cross product of vectors (AB) and (AC) is zero. More formally, given points (A (x1, y1)), (B (x2, y2)), and (C (x3, y3)), (C) is on the line formed by (A) and (B) if ((y2 - y1) * (x3 - x2) = (y3 - y2) * (x2 - x1)). * Be mindful of edge cases and handle them appropriately.","solution":"from typing import List, Tuple def simplify_points(points: List[Tuple[float, float]]) -> List[Tuple[float, float]]: def is_collinear(p1, p2, p3): # Check if the three points are collinear return (p2[1] - p1[1]) * (p3[0] - p2[0]) == (p3[1] - p2[1]) * (p2[0] - p1[0]) if len(points) <= 2: return points simplified = [points[0]] for i in range(1, len(points) - 1): if not is_collinear(points[i - 1], points[i], points[i + 1]): simplified.append(points[i]) simplified.append(points[-1]) return simplified"},{"question":"# Coding Assessment Question **Scenario**: You are developing a software system that requires a flexible and efficient means of logging and querying events over a timeline. A suitable data structure for this task is a Fenwick Tree (also known as a Binary Indexed Tree). This will help you perform range sum queries and point updates efficiently. **Task**: Implement the `FenwickTree` class by completing the following methods: 1. **initialize**: ```python def initialize(self, n: int) -> None: ``` - **Input**: - `n` (int): The size of the array (range of the timeline). - **Output**: None 2. **update**: ```python def update(self, idx: int, delta: int) -> None: ``` - **Input**: - `idx` (int): Index to update (1-based index). - `delta` (int): Value to add at the given index. - **Output**: None 3. **query**: ```python def query(self, idx: int) -> int: ``` - **Input**: - `idx` (int): Index up to which the sum is queried (1-based index). - **Output**: Return the sum of the range from 1 to `idx`. **Constraints**: - The size of the Fenwick Tree will not exceed `10^5`. - The values in the update operation will range from `-10^4` to `10^4`. **Example**: ```python fenwick_tree = FenwickTree() fenwick_tree.initialize(10) fenwick_tree.update(1, 3) fenwick_tree.update(2, 2) fenwick_tree.update(3, -1) fenwick_tree.update(4, 5) fenwick_tree.update(5, 2) print(fenwick_tree.query(1)) # Output: 3 print(fenwick_tree.query(3)) # Output: 4 print(fenwick_tree.query(5)) # Output: 11 print(fenwick_tree.query(10)) # Output: 11 ``` **Your task**: Implement the `FenwickTree` class to ensure it handles these operations efficiently.","solution":"class FenwickTree: def initialize(self, n: int) -> None: Initializes the Fenwick Tree with a given size `n`. self.n = n self.tree = [0] * (n + 1) def update(self, idx: int, delta: int) -> None: Increases the value at index `idx` by `delta`. The index is 1-based. while idx <= self.n: self.tree[idx] += delta idx += idx & -idx def query(self, idx: int) -> int: Returns the sum of the range from 1 to `idx`. The index is 1-based. sum_ = 0 while idx > 0: sum_ += self.tree[idx] idx -= idx & -idx return sum_"},{"question":"# String Permutation Check Coding Assessment Given two strings, `s1` and `s2`, write a function to determine if `s2` contains a permutation of `s1`. In other words, check if one of the permutations of `s1` is a substring of `s2`. **Function Requirements:** 1. **`is_permutation_of_substring(s1: str, s2: str) -> bool`**: This function should return `True` if any permutation of `s1` is a substring of `s2`, otherwise `False`. # Requirements - **Input Format**: - `s1`: A non-empty string whose permutations need to be checked. - `s2`: Another string in which we will look for permutations of `s1`. - **Output Format**: - Return `True` if any permutation of `s1` is a substring of `s2`, otherwise `False`. - **Constraints**: - Both `s1` and `s2` will only contain lowercase alphabetic characters (\'a\' to \'z\'). - The length of `s1` will be at most 10. - The length of `s2` will be at most 10^4. - **Performance**: - The function should be optimized to handle the input size efficiently. # Example ```python # Example 1 s1 = \\"ab\\" s2 = \\"eidbaooo\\" # Expected output True # Explanation: s2 contains one permutation of s1 (\\"ba\\"). # Example 2 s1 = \\"ab\\" s2 = \\"eidboaoo\\" # Expected output False # Explanation: s2 does not contain any permutation of s1. def is_permutation_of_substring(s1: str, s2: str) -> bool: from collections import Counter len_s1 = len(s1) len_s2 = len(s2) if len_s1 > len_s2: return False s1_counter = Counter(s1) s2_counter = Counter(s2[:len_s1]) if s1_counter == s2_counter: return True for i in range(len_s1, len_s2): s2_counter[s2[i]] += 1 s2_counter[s2[i - len_s1]] -= 1 if s2_counter[s2[i - len_s1]] == 0: del s2_counter[s2[i - len_s1]] if s1_counter == s2_counter: return True return False ```","solution":"def is_permutation_of_substring(s1: str, s2: str) -> bool: from collections import Counter len_s1 = len(s1) len_s2 = len(s2) if len_s1 > len_s2: return False s1_counter = Counter(s1) s2_counter = Counter(s2[:len_s1]) if s1_counter == s2_counter: return True for i in range(len_s1, len_s2): s2_counter[s2[i]] += 1 s2_counter[s2[i - len_s1]] -= 1 if s2_counter[s2[i - len_s1]] == 0: del s2_counter[s2[i - len_s1]] if s1_counter == s2_counter: return True return False"},{"question":"# Coding Assessment Question Context You are developing a function that returns the longest contiguous subarray whose elements are all positive integers. This function has applications in data analysis where identifying subsequences of positive values is crucial for evaluating trends. Task Write a Python function `longest_positive_subarray(arr: List[int]) -> List[int]` that takes a list of integers `arr` and returns the longest contiguous subarray consisting entirely of positive integers. If there are multiple subarrays of the same maximum length, return the one that appears earliest in the array. Function Specification - **Input**: - `arr` (List[int]): A list of integers, where -10^6 <= arr[i] <= 10^6. - **Output**: - A list of integers representing the longest contiguous subarray of positive integers. Constraints - The input list `arr` will contain at least one element and will have a length of at most 10^6. Example ```python def longest_positive_subarray(arr: List[int]) -> List[int]: # Implement the function based on the given algorithm pass # Sample Test Cases print(longest_positive_subarray([1, 2, -3, 4, 5, 6, -1, 2, 3])) # Expected output: [4, 5, 6] print(longest_positive_subarray([-1, -2, -3])) # Expected output: [] print(longest_positive_subarray([1, 2, 3, -1, 4])) # Expected output: [1, 2, 3] ``` Explanation In the first example, [4, 5, 6] is the longest contiguous subarray of positive integers. In the second example, there are no positive integers, so the output is an empty list. In the third example, even though a positive subarray [4] appears later, [1, 2, 3] is the longest. Implementation Requirements - Ensure to handle edge cases, such as when all elements are negative or when the array itself is empty. - Consider the efficiency of your solution, targeting O(n) time complexity where n is the length of the input array.","solution":"from typing import List def longest_positive_subarray(arr: List[int]) -> List[int]: max_start = max_end = start = 0 max_len = 0 current_len = 0 for i in range(len(arr)): if arr[i] > 0: if current_len == 0: start = i current_len += 1 if current_len > max_len: max_len = current_len max_start = start max_end = i else: current_len = 0 return arr[max_start:max_end + 1] if max_len > 0 else []"},{"question":"# Coding Assessment Question: Prime Number Identifier **Context**: In computer science and cryptography, prime numbers play a crucial role. A prime number is a natural number greater than 1 that is not the product of two smaller natural numbers. Your task is to implement a function that determines whether a given integer is a prime number. **Requirements**: 1. Implement the function `is_prime(n: int) -> bool`: * The function should take an integer `n` as input and return `True` if `n` is a prime number, and `False` otherwise. * An integer `n` is considered a prime number if it is greater than 1 and has no positive divisors other than 1 and itself. 2. Ensure that your function handles edge cases and provides correct results for: * n = 0 and n = 1 (both are not prime). * Small prime numbers like 2, 3, 5, and 7. * Larger prime numbers, for example, 13, 17, and 19. * Larger composite numbers, for example, 15, 21, and 25. 3. Optimize your solution to handle larger values efficiently. * Use trial division to test divisibility from 2 up to the square root of `n`. 4. Your implementation should have: * **Time Complexity**: O(√n) * **Space Complexity**: O(1) 5. Validate your function with the following assertions: ```python assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(17) == True assert is_prime(19) == True assert is_prime(25) == False assert is_prime(37) == True assert is_prime(49) == False assert is_prime(97) == True assert is_prime(1) == False assert is_prime(0) == False ``` **Function Signature**: ```python def is_prime(n: int) -> bool: pass ```","solution":"import math def is_prime(n: int) -> bool: Returns True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Problem Statement You are required to implement a function to generate a list of prime numbers up to a given integer `n`. Additionally, implement a function that identifies the two prime numbers whose sum equals a given even integer `m`. If multiple pairs are possible, return any one of them. If no such pair exists, return `None`. # Function Signatures ```python def generate_primes(n: int) -> List[int]: pass def find_prime_sum_pair(m: int) -> Union[Tuple[int, int], None]: pass ``` # Parameters - **`n`** (int): The upper limit for generating prime numbers. - **`m`** (int): The even integer to be expressed as the sum of two prime numbers. # Returns - `generate_primes(n) -> List[int]`: Returns a list of all prime numbers less than or equal to `n`. - `find_prime_sum_pair(m) -> Union[Tuple[int, int], None]`: Returns a tuple (p1, p2) where p1 and p2 are prime numbers such that p1 + p2 = m. If no such pair exists, return `None`. # Constraints - `n` will be in the range of `[2, 10^6]`. - `m` will be an even integer in the range of `[4, 2 * 10^6]`. # Example ```python primes = generate_primes(30) # Output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] pair = find_prime_sum_pair(34) # Output: (3, 31) or any other valid pair such as (17, 17) ``` # Performance Requirements - The `generate_primes` function should efficiently generate primes up to `10^6`. - The `find_prime_sum_pair` function should efficiently identify the prime pair for even integers up to `2 * 10^6`. # Implementation Notes - Use the Sieve of Eratosthenes or an equivalent efficient algorithm to generate prime numbers. - Ensure that edge cases, such as the smallest even number `m = 4` (where the pair is (2, 2)), are handled properly.","solution":"from typing import List, Tuple, Union def generate_primes(n: int) -> List[int]: Generates a list of all prime numbers up to and including n. Args: n (int): The upper limit to generate prime numbers. Returns: List[int]: List of prime numbers. if n < 2: return [] is_prime = [True] * (n + 1) is_prime[0], is_prime[1] = False, False for start in range(2, int(n**0.5) + 1): if is_prime[start]: for multiple in range(start*start, n + 1, start): is_prime[multiple] = False primes = [num for num in range(n + 1) if is_prime[num]] return primes def find_prime_sum_pair(m: int) -> Union[Tuple[int, int], None]: Finds two prime numbers whose sum equals the given even integer m. Args: m (int): The even integer to find the prime sum pair. Returns: Union[Tuple[int, int], None]: Tuple of two prime numbers that sum to m, or None. if m < 4 or m % 2 != 0: return None primes = generate_primes(m) prime_set = set(primes) for prime in primes: if (m - prime) in prime_set: return (prime, m - prime) return None"},{"question":"# Context An ecommerce company wants to analyze their sales data. They have sales records for their products which are categorized into different regions. Each sale record contains the product name, region, and the number of units sold. The company wants to generate a summary report of the total units sold for each product across all regions they operate. # Problem Statement Write a function `sales_summary(sales_records: List[Dict[str, str]]) -> Dict[str, int]` that generates a summary report of the total units sold for each product. # Function Signature ```python def sales_summary(sales_records: List[Dict[str, str]]) -> Dict[str, int]: pass ``` # Input 1. `sales_records` - a list of dictionaries, where each dictionary contains three key-value pairs: - \\"product\\": a string representing the product name. - \\"region\\": a string representing the region. - \\"units_sold\\": a string representing the number of units sold (this will be numeric). # Output * A dictionary where the keys are product names and the values are the total units sold for that product across all regions. # Examples 1. `sales_summary([ {\\"product\\": \\"A\\", \\"region\\": \\"North\\", \\"units_sold\\": \\"10\\"}, {\\"product\\": \\"A\\", \\"region\\": \\"South\\", \\"units_sold\\": \\"20\\"}, {\\"product\\": \\"B\\", \\"region\\": \\"North\\", \\"units_sold\\": \\"5\\"} ])` should return `{\\"A\\": 30, \\"B\\": 5}`. 2. `sales_summary([ {\\"product\\": \\"C\\", \\"region\\": \\"West\\", \\"units_sold\\": \\"15\\"}, {\\"product\\": \\"C\\", \\"region\\": \\"East\\", \\"units_sold\\": \\"10\\"}, {\\"product\\": \\"D\\", \\"region\\": \\"East\\", \\"units_sold\\": \\"8\\"} ])` should return `{\\"C\\": 25, \\"D\\": 8}`. # Constraints * The `sales_records` list will contain at most 100,000 records. * Each record will have the format specified in the problem statement. * The `units_sold` value will be a non-negative integer (including zero, represented as a string). # Notes * You need to convert the `units_sold` from a string to an integer before performing any computations. * Your solution should efficiently handle the given constraints on the size of the input.","solution":"from typing import List, Dict def sales_summary(sales_records: List[Dict[str, str]]) -> Dict[str, int]: summary = {} for record in sales_records: product = record[\'product\'] units_sold = int(record[\'units_sold\']) if product in summary: summary[product] += units_sold else: summary[product] = units_sold return summary"},{"question":"# Coding Assessment Question Objective Write functions to implement and compare the A* Search and Dijkstra\'s algorithm on a grid to find the shortest path from a given start position to a goal position. Problem Statement You are given a grid represented as a 2D list where `0` represents free paths and `1` represents obstacles. Write two functions: 1. `dijkstra_search(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]`: * Implements Dijkstra\'s algorithm to find the shortest path. * Returns the list of coordinates forming the path from start to goal. 2. `a_star_search(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]`: * Implements the A* Search algorithm to find the shortest path. * Returns the list of coordinates forming the path from start to goal. Input * `grid`: A list of lists of integers where `0` is a free path and `1` is an obstacle. * `start`: A tuple (y, x) representing the starting coordinates. * `goal`: A tuple (y, x) representing the goal coordinates. Output * A list of tuples representing the shortest path from start to goal in the format [(y1, x1), (y2, x2), ...]. If no path exists, return `None`. Constraints * `0 <= len(grid) <= 100` * `0 <= len(grid[0]) <= 100` * `start` and `goal` are valid indices within grid bounds. * There will be at most one valid path from start to goal. Requirements * Implement both Dijkstra\'s algorithm and A* Search. * Compare the results and performance of both algorithms on the given grid. Example Cases **Case 1: Simple Path** Input: ```python grid = [ [0, 0, 0], [1, 1, 0], [0, 0, 0] ] start = (0, 0) goal = (2, 2) ``` Output using `dijkstra_search`: ```python [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)] ``` Output using `a_star_search`: ```python [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)] ``` **Case 2: No Path** Input: ```python grid = [ [0, 0, 0], [1, 1, 1], [0, 0, 0] ] start = (0, 0) goal = (2, 2) ``` Output using `dijkstra_search`: ```python None ``` Output using `a_star_search`: ```python None ``` Implementation Note Ensure that you handle edge cases such as scenarios with completely blocked paths and compare the performance differences between Dijkstra\'s algorithm and A* Search.","solution":"from typing import List, Tuple, Optional import heapq def dijkstra_search(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> Optional[List[Tuple[int, int]]]: def get_neighbors(node): y, x = node neighbors = [(y + dy, x + dx) for dy, dx in directions if 0 <= y + dy < len(grid) and 0 <= x + dx < len(grid[0])] return [n for n in neighbors if grid[n[0]][n[1]] == 0] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] pq = [(0, start)] distances = {start: 0} came_from = {start: None} while pq: current_distance, current_node = heapq.heappop(pq) if current_node == goal: path = [] while current_node: path.append(current_node) current_node = came_from[current_node] return path[::-1] for neighbor in get_neighbors(current_node): distance = current_distance + 1 if neighbor not in distances or distance < distances[neighbor]: distances[neighbor] = distance priority = distance heapq.heappush(pq, (priority, neighbor)) came_from[neighbor] = current_node return None def a_star_search(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> Optional[List[Tuple[int, int]]]: def get_neighbors(node): y, x = node neighbors = [(y + dy, x + dx) for dy, dx in directions if 0 <= y + dy < len(grid) and 0 <= x + dx < len(grid[0])] return [n for n in neighbors if grid[n[0]][n[1]] == 0] def heuristic(a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] open_set = [(0, start)] came_from = {start: None} g_score = {start: 0} f_score = {start: heuristic(start, goal)} while open_set: _, current = heapq.heappop(open_set) if current == goal: path = [] while current: path.append(current) current = came_from[current] return path[::-1] for neighbor in get_neighbors(current): tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal) if neighbor not in [i[1] for i in open_set]: heapq.heappush(open_set, (f_score[neighbor], neighbor)) return None"},{"question":"# Question: Fun with Sorting and Searching You are given a list of dictionaries representing a collection of books, where each dictionary has the following keys: `title`, `author`, `year_published`, and `rating`. Your task is to implement a function that filters and sorts the books based on specified criteria: year range and minimum rating. Additionally, if two books have the same rating, they should be sorted alphabetically by title. Requirements: 1. **Functionality to Implement**: Implement a function that filters books published within a specified range of years and with a rating above a given threshold. The filtered books should then be sorted based on their rating in descending order, and for books with the same rating, they should be sorted by title in ascending order. 2. **Input and Output Formats**: - **Input**: * `books (list[dict])`: A list of dictionaries where each dictionary has keys `title` (str), `author` (str), `year_published` (int), and `rating` (float). * `start_year (int)`: The starting year of the publication range. * `end_year (int)`: The ending year of the publication range. * `min_rating (float)`: The minimum rating threshold. - **Output**: A list of filtered and sorted dictionaries based on the specified criteria. 3. **Constraints**: - The list of books may be empty. - `start_year` will be less than or equal to `end_year`. - Ratings will be between 0.0 and 5.0. - There can be books with the same title, author, or year, but each entry represents a unique instance. 4. **Performance**: - Ensure the solution handles large datasets efficiently. ```python def sort_and_filter_books(books: list[dict], start_year: int, end_year: int, min_rating: float) -> list[dict]: Filter and sort books based on given criteria. :param books: List of book dictionaries. :param start_year: The starting year for the publication range. :param end_year: The ending year for the publication range. :param min_rating: The minimum rating threshold. :return: List of filtered and sorted book dictionaries. # Your code here pass ``` # Example: ```python books = [ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author X\\", \\"year_published\\": 2001, \\"rating\\": 4.5}, {\\"title\\": \\"Book B\\", \\"author\\": \\"Author Y\\", \\"year_published\\": 2005, \\"rating\\": 4.7}, {\\"title\\": \\"Book C\\", \\"author\\": \\"Author Z\\", \\"year_published\\": 2003, \\"rating\\": 4.8}, {\\"title\\": \\"Book D\\", \\"author\\": \\"Author X\\", \\"year_published\\": 2010, \\"rating\\": 4.2}, {\\"title\\": \\"Book E\\", \\"author\\": \\"Author Y\\", \\"year_published\\": 1999, \\"rating\\": 3.9} ] start_year = 2000 end_year = 2010 min_rating = 4.0 # Expected output: # [ # {\\"title\\": \\"Book C\\", \\"author\\": \\"Author Z\\", \\"year_published\\": 2003, \\"rating\\": 4.8}, # {\\"title\\": \\"Book B\\", \\"author\\": \\"Author Y\\", \\"year_published\\": 2005, \\"rating\\": 4.7}, # {\\"title\\": \\"Book A\\", \\"author\\": \\"Author X\\", \\"year_published\\": 2001, \\"rating\\": 4.5}, # {\\"title\\": \\"Book D\\", \\"author\\": \\"Author X\\", \\"year_published\\": 2010, \\"rating\\": 4.2} # ] filtered_books = sort_and_filter_books(books, start_year, end_year, min_rating) print(filtered_books) ``` **Scenarios to Consider**: - Books exactly on the boundary years. - Handling books with the same title but different ratings. - Filtering out all books if none meet the criteria. - Ensuring the sorting order is correct for books with the same rating. Write your function implementation and ensure to test it against the given scenarios to validate its correctness.","solution":"def sort_and_filter_books(books: list[dict], start_year: int, end_year: int, min_rating: float) -> list[dict]: Filter and sort books based on given criteria. :param books: List of book dictionaries. :param start_year: The starting year for the publication range. :param end_year: The ending year for the publication range. :param min_rating: The minimum rating threshold. :return: List of filtered and sorted book dictionaries. # Filter books based on the year range and minimum rating. filtered_books = [ book for book in books if start_year <= book[\'year_published\'] <= end_year and book[\'rating\'] >= min_rating ] # Sort the filtered books by rating (descending) and by title (ascending). sorted_books = sorted(filtered_books, key=lambda x: (-x[\'rating\'], x[\'title\'])) return sorted_books"},{"question":"# Coding Assessment Question Scenario You are developing a basic encryption mechanism for a messaging app. As part of the encryption process, you need to implement a function that performs a bitwise XOR (exclusive OR) operation on two given binary numbers. The XOR operation is a fundamental binary operation used in various encryption algorithms. Task Write a function `xor_operation` that takes in two binary inputs (0 or 1) and returns the result of the XOR operation. Function Signature ```python def xor_operation(input_1: int, input_2: int) -> int: ``` Input * `input_1`: An integer with a value of either 0 or 1. * `input_2`: An integer with a value of either 0 or 1. Output * An integer with a value of either 0 or 1, representing the result of the XOR operation. Constraints * Both inputs will always be binary (0 or 1). Examples ```python >>> xor_operation(0, 0) 0 >>> xor_operation(0, 1) 1 >>> xor_operation(1, 0) 1 >>> xor_operation(1, 1) 0 ``` Explanation of Examples * For `xor_operation(0, 0)`, since both inputs are 0, the output is 0 (False). * For `xor_operation(0, 1)`, since the inputs are different, the output is 1 (True). * For `xor_operation(1, 0)`, since the inputs are different, the output is 1 (True). * For `xor_operation(1, 1)`, since both inputs are 1, the output is 0 (False). Performance Requirements * The function should execute in constant time O(1).","solution":"def xor_operation(input_1: int, input_2: int) -> int: Perform bitwise XOR operation on two binary inputs. return input_1 ^ input_2 # Example runs # print(xor_operation(0, 0)) # should return 0 # print(xor_operation(0, 1)) # should return 1 # print(xor_operation(1, 0)) # should return 1 # print(xor_operation(1, 1)) # should return 0"},{"question":"# Question: Implement a Circular Array Rotation You are tasked with creating a function that rotates a list of integers to the right a given number of times. Each call to the function should return the new rotated list. Requirements: * Implement a function named `rotate_array(arr: list, rotations: int) -> list` where: * `arr` is the list of integers to be rotated. * `rotations` is the number of rightward rotations to be performed. * The function should: * Validate that `arr` is a non-empty list of integers. * Validate that `rotations` is a non-negative integer. * Perform the rightward rotation on the list. * Return the new rotated list. Constraints: * You must handle the case where `rotations` is greater than the length of the list (use modulo operation to account for this). * Maintain efficient time and space complexity (O(n) for both). Examples: ```python >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([0, -1, -2, -3, -4], 3) [-2, -3, -4, 0, -1] >>> rotate_array([7, 8, 9], 10) [8, 9, 7] >>> rotate_array([11, 12, 13, 14], 0) [11, 12, 13, 14] ``` **Note**: Ensure to properly handle scenarios where the input list might remain unchanged or when it should undergo significant alterations due to the number of rotations specified.","solution":"def rotate_array(arr, rotations): Rotates the array to the right by a given number of rotations. Parameters: arr (list): A non-empty list of integers. rotations (int): A non-negative integer representing the number of rotations. Returns: list: The rotated array. if not arr: raise ValueError(\\"The array must not be empty.\\") if not isinstance(rotations, int) or rotations < 0: raise ValueError(\\"The number of rotations must be a non-negative integer.\\") n = len(arr) rotations = rotations % n # to handle cases where rotations > n if rotations == 0: return arr return arr[-rotations:] + arr[:-rotations]"},{"question":"# Problem Statement You are given a rectangular grid of integers, and you need to implement a 2D segment tree data structure to handle range sum queries and updates efficiently. Specifically, you need to perform the following operations: 1. Build the 2D segment tree with the given grid. 2. Update the value at a specific cell. 3. Query the sum of values in a specific subrectangle. # Function Specifications Complete the following functions: 1. `__init__(self, grid: List[List[int]]) -> None` - **Input**: * `grid`: A 2D list of integers representing the initial grid. - **Output**: * None. - **Description**: - Initializes the 2D segment tree with the provided grid. 2. `update(self, row: int, col: int, val: int) -> bool` - **Input**: * `row`: Integer, 0-based index of the row to update. * `col`: Integer, 0-based index of the column to update. * `val`: Integer, the new value for the specified cell. - **Output**: * Returns `True` upon successful update. - **Description**: - Updates the value in the cell at (row, col) with the provided value in the 2D segment tree. 3. `query(self, row1: int, col1: int, row2: int, col2: int) -> int` - **Input**: * `row1`: Integer, 0-based index of the starting row of the query range (inclusive). * `col1`: Integer, 0-based index of the starting column of the query range (inclusive). * `row2`: Integer, 0-based index of the ending row of the query range (inclusive). * `col2`: Integer, 0-based index of the ending column of the query range (inclusive). - **Output**: * Returns the sum of values in the specified subrectangle [row1, col1, row2, col2]. - **Description**: - Queries the 2D segment tree to find the sum of values in the subrectangle specified by [row1, col1, row2, col2]. # Constraints 1. The dimensions of the grid `grid` are between `1x1` and `1000x1000`. 2. Elements in the grid can be between `-10^9` and `10^9`. 3. Indices `row`, `col`, `row1`, `col1`, `row2`, and `col2` are 0-based and will be within the bounds of the grid. # Example ```python # Example usage: grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] segtree2d = SegmentTree2D(grid) print(segtree2d.query(0, 0, 2, 2)) # Output: 45 ( sum of all elements ) print(segtree2d.query(1, 1, 2, 2)) # Output: 28 ( sum of elements: 5, 6, 8, 9 ) segtree2d.update(1, 1, 10) print(segtree2d.query(0, 0, 2, 2)) # Output: 50 ( sum after updating (1,1) to 10 ) print(segtree2d.query(1, 1, 2, 2)) # Output: 33 ( sum after updating (1,1) to 10 ) ```","solution":"class SegmentTree2D: def __init__(self, grid): if not grid or not grid[0]: return self.rows = len(grid) self.cols = len(grid[0]) self.tree = [[0] * (2 * self.cols) for _ in range(2 * self.rows)] # Build the segment tree with the given grid for r in range(self.rows): for c in range(self.cols): self.tree[self.rows + r][self.cols + c] = grid[r][c] # Build the segment tree for columns for r in range(self.rows, 2 * self.rows): for c in range(self.cols - 1, 0, -1): self.tree[r][c] = self.tree[r][2 * c] + self.tree[r][2 * c + 1] # Build the segment tree for rows for r in range(self.rows - 1, 0, -1): for c in range(2 * self.cols): self.tree[r][c] = self.tree[2 * r][c] + self.tree[2 * r + 1][c] def update(self, row, col, val): r, c = row + self.rows, col + self.cols self.tree[r][c] = val # Update columns while c > 1: c //= 2 self.tree[r][c] = self.tree[r][2 * c] + self.tree[r][2 * c + 1] # Update rows while r > 1: r //= 2 self.tree[r][self.cols + col] = self.tree[2 * r][self.cols + col] + self.tree[2 * r + 1][self.cols + col] c = col + self.cols while c > 1: c //= 2 self.tree[r][c] = self.tree[2 * r][c] + self.tree[2 * r + 1][c] return True def query(self, row1, col1, row2, col2): sum = 0 for r in range(row1 + self.rows, row2 + self.rows + 1): c1, c2 = col1 + self.cols, col2 + self.cols while c1 <= c2: if c1 % 2 == 1: sum += self.tree[r][c1] c1 += 1 if c2 % 2 == 0: sum += self.tree[r][c2] c2 -= 1 c1 //= 2 c2 //= 2 return sum"},{"question":"# Maximum Subarray Sum with a Twist **Objective**: Implement an algorithm that finds the maximum sum of a contiguous subarray within a one-dimensional numerical array, but with an additional twist. The algorithm should also be able to identify if there is a subarray sum that matches an optional specified target sum. **Task**: 1. **Core Functionality**: Implement a function `max_subarray_sum` to find the maximum sum of a contiguous subarray. 2. **Optional Target Matching**: Enhance the function to check if any subarray\'s sum matches a given target sum. 3. **Return Details**: The function should return a tuple containing the maximum subarray sum and a boolean indicating whether a subarray sum matched the target. **Input and Output Formats**: * **Input**: * `nums` (list of int): A list of integers representing the numerical array. * `target` (int, optional): An optional integer representing the target subarray sum to check for. * **Output**: A tuple containing: * an integer representing the maximum subarray sum, * a boolean indicating whether a contiguous subarray sum equals the target sum. **Constraints**: * The input list `nums` contains at least one and at most `10^4` integers, where each integer is within the range `[-10^4, 10^4]`. * The function should work efficiently with a linear time complexity, O(n). **Hints**: * Utilize Kadane\'s Algorithm for finding the maximum subarray sum. * Use a set to store cumulative sums to efficiently check for the target sum. **Function Signature**: ```python def max_subarray_sum(nums: list[int], target: int = None) -> tuple[int, bool]: pass ``` **Examples**: 1. `max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4])` should return `(6, False)` because the maximum sum is `6` from the subarray `[4, -1, 2, 1]`, and no subarray sums to `None`. 2. `max_subarray_sum([1,2,3,4,5], 9)` should return `(15, True)` because the maximum sum is `15` from the subarray `[1, 2, 3, 4, 5]`, and the subarray `[2, 3, 4]` sums to `9`. **Notes**: 1. If `target` is not provided, the function should only return the maximum subarray sum and `False`. 2. Consider edge cases such as very large arrays or arrays with negative numbers when designing your solution for efficiency.","solution":"def max_subarray_sum(nums: list[int], target: int = None) -> tuple[int, bool]: max_sum = float(\'-inf\') current_sum = 0 found_target = False # To check if any subarray sum equals target if target is not None: prefix_sums = set() current_prefix_sum = 0 prefix_sums.add(0) # Adding 0 helps to detect a subarray that sums up to target from the start for num in nums: current_sum += num if current_sum > max_sum: max_sum = current_sum if current_sum < 0: current_sum = 0 if target is not None: current_prefix_sum += num if (current_prefix_sum - target) in prefix_sums: found_target = True prefix_sums.add(current_prefix_sum) return max_sum, found_target"},{"question":"# Recursively Check Array Segment Balance Create a function that checks whether an array segment is \\"balanced.\\" An array segment is defined as balanced if the sum of the first half of the segment is equal to the sum of the second half of the segment. If the segment has an odd length, the middle element is included in both halves. # Requirements 1. Implement a function `is_segment_balanced(arr, start, length)` that recursively determines whether a segment of the array is balanced. 2. The function takes an array `arr`, a starting index `start`, and an integer `length` as its parameters. 3. Your function should return a boolean indicating whether the specified segment of the array is balanced. # Input - An integer array `arr`, starting index `start`, and the segment length `length`. # Output - Returns `True` if the segment is balanced, otherwise `False`. # Example ```python # Example usage print(is_segment_balanced([1, 2, 3, 2, 1], 0, 5)) # Output should be: True print(is_segment_balanced([1, 2, 3, 0, 0], 1, 4)) # Output should be: False ``` # Constraints 1. The segment specified by `start` and `length` must lie within the bounds of the array. 2. The `is_segment_balanced` function must be implemented recursively. 3. Aim for O(n) complexity for the length of the segment, where n is the segment length. # Notes - Consider the base cases carefully to ensure proper termination of the recursion. - The function should handle both even and odd length segments correctly.","solution":"def is_segment_balanced(arr, start, length): Checks if the array segment starting at `start` with `length` is balanced. A segment is balanced if the sum of the first half equals the sum of the second half. If the segment length is odd, the middle element is included in both halves. Parameters: - arr: list of integers - start: starting index of the segment - length: length of the segment Returns: - bool: True if the segment is balanced, False otherwise if length <= 1: return True mid = length // 2 if length % 2 == 0: # Even length sum_first_half = sum(arr[start:start+mid]) sum_second_half = sum(arr[start+mid:start+length]) else: # Odd length sum_first_half = sum(arr[start:start+mid+1]) sum_second_half = sum(arr[start+mid:start+length]) return sum_first_half == sum_second_half"},{"question":"Problem Statement In this problem, you need to manipulate a matrix and search for the presence of a target value within specific rules. Your task is to implement a function `search_target_in_matrix` that finds a given target number in an m x n matrix. This matrix has the following properties: 1. Each row is sorted in ascending order. 2. The first integer of each row is greater than the last integer of the previous row. # Function Signature ```python def search_target_in_matrix(matrix: list[list[int]], target: int) -> bool: pass ``` # Input - `matrix`: A list of lists of integers representing the matrix. - `target`: An integer you need to find within the matrix. # Output - Returns `True` if the target integer exists in the matrix, otherwise returns `False`. # Constraints - `m == len(matrix)` - `n == len(matrix[i])` for all valid `i` - `1 <= m, n <= 100` - `-10^9 <= matrix[i][j], target <= 10^9` # Requirements - Your implementation should efficiently utilize the sorted properties of the matrix to perform the search. - Aim for a time complexity better than O(m * n). # Example Example 1: ```python matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 search_target_in_matrix(matrix, target) ``` **Output**: `True` Example 2: ```python matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 13 search_target_in_matrix(matrix, target) ``` **Output**: `False` Example 3: ```python matrix = [ [5, 6, 10], [12, 15, 20], [24, 30, 40] ] target = 20 search_target_in_matrix(matrix, target) ``` **Output**: `True` # Solution Approach - Treat the matrix as a single sorted array and perform binary search on this array which essentially maps to the matrix. - Efficiently map the 1D array indices to the 2D matrix coordinates during binary search. # Hints - Use the conversion between 2D and 1D array indices to perform binary search on the virtual array.","solution":"def search_target_in_matrix(matrix: list[list[int]], target: int) -> bool: if not matrix or not matrix[0]: return False m, n = len(matrix), len(matrix[0]) left, right = 0, m * n - 1 while left <= right: mid = left + (right - left) // 2 mid_value = matrix[mid // n][mid % n] if mid_value == target: return True elif mid_value < target: left = mid + 1 else: right = mid - 1 return False"},{"question":"# Problem Statement You need to implement a function that evaluates a postfix expression and returns the result. A postfix expression (also known as Reverse Polish notation) is a mathematical notation in which every operator follows all of its operands. The expression contains integers and basic arithmetic operators (`+`, `-`, `*`, `/`). # Function Signature ```python def evaluate_postfix(expression_tokens: List[str]) -> int: pass ``` # Input * `expression_tokens` (List[str]): The postfix expression to evaluate. The list elements may contain: - Integers represented as strings (e.g., `\\"3\\"`, `\\"15\\"`). - Operators (`+`, `-`, `*`, `/`). # Output * (int): The result of evaluating the postfix expression. # Constraints * The operators are binary and will be applied to the most recent operands in the order they appear. * The length of `expression_tokens` will be between 0 and 100 elements. * There won\'t be any division by zero, and the result of the division operator should be an integer (use floor division). # Example ```python # Example 1 assert evaluate_postfix([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) == 9 # Example 2 assert evaluate_postfix([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) == 6 # Example 3 assert evaluate_postfix([\\"10\\", \\"6\\", \\"9\\", \\"3\\", \\"+\\", \\"-11\\", \\"*\\", \\"/\\", \\"*\\", \\"17\\", \\"+\\", \\"5\\", \\"+\\"]) == 22 ``` # Error Handling * Raise a `ValueError` with an appropriate message if the input is malformed or cannot produce a valid result. # Hints * Utilize a stack to handle the operands. * Iterate through the tokens, pushing numbers onto the stack and applying operators to the topmost numbers. * Ensure the operations respect the integer division requirement when applying the division operator.","solution":"from typing import List def evaluate_postfix(expression_tokens: List[str]) -> int: stack = [] for token in expression_tokens: if token.isdigit() or (token[0] == \'-\' and token[1:].isdigit()): stack.append(int(token)) else: if len(stack) < 2: raise ValueError(\\"Insufficient operands for the operation\\") b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(int(a / b)) # Perform integer division else: raise ValueError(f\\"Unknown operator: {token}\\") if len(stack) != 1: raise ValueError(\\"The input does not produce a single result\\") return stack.pop()"},{"question":"Custom Sorting Function You are required to implement a custom sorting function for a list of tuples. Each tuple contains an integer and a string. The sorting criterion is as follows: 1. First, sort the tuples by the integer in ascending order. 2. If two tuples have the same integer, then sort them by the string in lexicographical (dictionary) order. # Function Specification **Function**: `custom_sort(tuples_list: List[Tuple[int, str]]) -> List[Tuple[int, str]]` Input - `tuples_list` (List[Tuple[int, str]]): A list of tuples, each tuple containing an integer and a string. Output - `List[Tuple[int, str]]`: A list of tuples sorted according to the criteria specified. Constraints - The input list can contain between 1 and 1000 tuples. - Each string in the tuples will be non-empty and may contain only lowercase English alphabet letters. - The integers will be in the range `-10000` to `10000`. # Example ```python from typing import List, Tuple # Input tuples_list = [(3, \'banana\'), (1, \'apple\'), (2, \'pear\'), (3, \'apple\')] # Output # Result after applying custom sorting output = custom_sort(tuples_list) print(output) # Expected: [(1, \'apple\'), (2, \'pear\'), (3, \'apple\'), (3, \'banana\')] ``` # Notes: - Ensure the function handles edge cases, such as an empty list. - For clarity and maintainability, consider using Python\'s built-in sorting utilities. **Good luck!**","solution":"from typing import List, Tuple def custom_sort(tuples_list: List[Tuple[int, str]]) -> List[Tuple[int, str]]: Sort a list of tuples first by the integer in ascending order, and if two tuples have the same integer, then by the string in lexicographical order. :param tuples_list: List of tuples containing an integer and a string. :return: Sorted list of tuples. return sorted(tuples_list, key=lambda x: (x[0], x[1]))"},{"question":"# Scenario You are a software developer working for a company that provides digital library services. Your current task is to develop a function that helps in processing queries over a collection of books to find books by various authors. # Task Write a function `filter_books_by_author(library: List[Dict[str, str]], author_name: str) -> List[Dict[str, str]]` that filters the books in the library to only include those written by the specified author. # Input Format * `library`: A list of dictionaries where each dictionary represents a book. Each dictionary contains keys `title` and `author` with corresponding values as strings. * `author_name`: The name of the author for whom we need to filter the books (string). # Output Format * Return a list of dictionaries containing books written by `author_name`. If no books by `author_name` are found, return an empty list. # Constraints * The library contains at most (10^4) books. * Each book\'s title and author are non-empty strings. # Example ```python library = [ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author X\\"}, {\\"title\\": \\"Book B\\", \\"author\\": \\"Author Y\\"}, {\\"title\\": \\"Book C\\", \\"author\\": \\"Author X\\"}, {\\"title\\": \\"Book D\\", \\"author\\": \\"Author Z\\"}, ] author_name = \\"Author X\\" print(filter_books_by_author(library, author_name)) # Output: [{\\"title\\": \\"Book A\\", \\"author\\": \\"Author X\\"}, {\\"title\\": \\"Book C\\", \\"author\\": \\"Author X\\"}] ```","solution":"from typing import List, Dict def filter_books_by_author(library: List[Dict[str, str]], author_name: str) -> List[Dict[str, str]]: Filters the books in the library to only include those written by the specified author. Parameters: library (List[Dict[str, str]]): The list of books, each represented by a dictionary with keys \'title\' and \'author\'. author_name (str): The name of the author to filter the books by. Returns: List[Dict[str, str]]: A list of books written by the specified author. return [book for book in library if book[\\"author\\"] == author_name]"},{"question":"# Coding Challenge: Limited Edition Box Sum Checker You are part of a team responsible for quality assurance of limited edition box sets produced by a company. Each box set contains a sequence of individually numbered items, and there can be only one instance of each item number within a single box set. Your task is to implement a function that: 1. Calculates the total sum of the item numbers in each box set. 2. Checks if all box sets have the same total sum. 3. Returns `True` if all box sets have identical sums, otherwise returns `False`. # Function Signature ```python def check_identical_sums(boxes: list[list[int]]) -> bool: pass ``` # Parameters - `boxes`: A list of lists, where each sub-list contains the item numbers of a single box set. # Constraints - Each sub-list (box set) contains at least one item. - All item numbers are positive integers. # Output - A boolean value `True` if all box sets have the same sum of item numbers, `False` otherwise. # Example ```python boxes = [ [1, 2, 3, 4], [4, 3, 2, 1], [2, 2, 2, 2] ] are_sums_identical = check_identical_sums(boxes) print(are_sums_identical) ``` **Output:** ```python True ``` # Explanation - The sum of the first box set is 10 (1 + 2 + 3 + 4). - The sum of the second box set is 10 (4 + 3 + 2 + 1). - The sum of the third box set is 8 (2 + 2 + 2 + 2), which differs from the others. Hence, the function returns `False`. Write the function `check_identical_sums` to solve the problem.","solution":"def check_identical_sums(boxes): Checks if all box sets have the same sum of item numbers. Parameters: - boxes: A list of lists, where each sub-list contains the item numbers of a single box set. Returns: - True if all box sets have identical sums, otherwise False. if not boxes: return False first_sum = sum(boxes[0]) for box in boxes[1:]: if sum(box) != first_sum: return False return True"},{"question":"# Coding Assessment Question In a logistics company, packages need to be stored and retrieved efficiently based on their unique codes. These codes are composed of both alphabets and numbers. To simplify the retrieval process, you are required to implement two functions that manipulate these package codes according to specific formatting rules. # Task Details Implement the following two functions: 1. `format_package_code(package_code: str) -> str`: Formats the input package code by ensuring the alphabetical part is in uppercase and the numerical part is padded with zeros to make it at least 6 digits long. - **Input**: A string representing a valid package code (e.g., \\"abc123\\"). - **Output**: A string representing the formatted package code (e.g., \\"ABC000123\\"). - **Constraints**: - The input string will have the structure where the alphabetic characters precede the numeric characters. - Ensure no additional characters other than alphabets and numbers are present. - The function should raise a `ValueError` with a clear message if the input format is invalid (e.g., if there are no numbers or no alphabets in the input). 2. `is_valid_code_format(formatted_code: str) -> bool`: Validates if the given formatted code adheres to the formatting rules described above. - **Input**: A string representing a formatted package code (e.g., \\"XYZ001234\\"). - **Output**: A boolean indicating whether the formatted code is valid (True) or not (False). - **Constraints**: - The formatted code must have uppercase alphabets followed by at least 6 numeric digits. - Return `False` for any codes that do not meet these criteria. # Example Usage ```python >>> format_package_code(\\"abc123\\") \'ABC000123\' >>> format_package_code(\\"pkg9876\\") \'PKG009876\' >>> format_package_code(\\"123abc\\") Traceback (most recent call last): ... ValueError: Invalid package code format >>> is_valid_code_format(\\"ABC000123\\") True >>> is_valid_code_format(\\"PKG009876\\") True >>> is_valid_code_format(\\"INVALID\\") False >>> is_valid_code_format(\\"ABC123\\") False ``` # Additional Requirements - Ensure your implementation includes adequate comments and error handling. - Use efficient string manipulations to achieve the results. - Provide at least five unit tests that cover a variety of edge cases for both functions. Deliver the Python code that passes the above example usages and unit tests provided.","solution":"def format_package_code(package_code: str) -> str: Formats the input package code by ensuring the alphabetical part is in uppercase and the numerical part is padded with zeros to make it at least 6 digits long. :param package_code: str - A string representing a valid package code (e.g., \\"abc123\\"). :return: str - A string representing the formatted package code (e.g., \\"ABC000123\\"). :raises ValueError: If the input format is invalid. # Split the input based on where the alphabetical part ends and numeric part starts. for index, char in enumerate(package_code): if char.isdigit(): alpha_part = package_code[:index] num_part = package_code[index:] break else: raise ValueError(\\"Invalid package code format\\") if not alpha_part.isalpha() or not num_part.isdigit(): raise ValueError(\\"Invalid package code format\\") formatted_code = alpha_part.upper() + num_part.zfill(6) return formatted_code def is_valid_code_format(formatted_code: str) -> bool: Validates if the given formatted code adheres to the formatting rules described above. :param formatted_code: str - A string representing a formatted package code (e.g., \\"XYZ001234\\"). :return: bool - True if the formatted code is valid, False otherwise. # Check if the format is correct: uppercase alphabets followed by at least 6 digits for index, char in enumerate(formatted_code): if not char.isalpha(): break alpha_part = formatted_code[:index] num_part = formatted_code[index:] return alpha_part.isupper() and num_part.isdigit() and len(num_part) >= 6"},{"question":"# Newton\'s Method for Square Root Approximation **Objective**: Implement a function that approximates the square root of a given non-negative number using Newton\'s method to a specified precision. Context Newton\'s method, also known as the Newton-Raphson method, is an iterative root-finding algorithm that produces successively better approximations to the roots (or zeroes) of a real-valued function. In our case, we use it to approximate the square root. The formula to find the square root of a number ( text{n} ) is: [ x_{k+1} = frac{1}{2} left( x_k + frac{n}{x_k} right) ] where ( x_k ) is the current approximation. The iterations continue until the absolute difference between successive approximations is less than the specified precision. Function Signature ```python def sqrt_newton_method(n: float, precision: float = 1e-7) -> float: Approximates the square root of a non-negative number using Newton\'s method. Parameters: n (float): Non-negative number to find the square root of. precision (float): Desired precision of the result. Default is 1e-7. Returns: float: Approximated square root of the number. Raises: ValueError: If n is negative or precision is not positive. pass ``` Expected Input and Output 1. **Input**: - A float `n`, which is non-negative. - A float `precision` indicating the desired precision. It must be positive. 2. **Output**: - A float representing the approximated square root. Constraints - ( 0 leq text{n} leq 10^6 ) - ( 0 < text{precision} leq 1 ) Performance Requirements - **Time Complexity**: O(log(n) / log(precision)) - **Space Complexity**: O(1) Example * **Example 1**: ```python >>> sqrt_newton_method(4) 2.0 ``` * **Example 2**: ```python >>> sqrt_newton_method(16, 1e-6) 4.0 ``` * **Example 3**: ```python >>> sqrt_newton_method(10, 1e-9) 3.162277660168379 ``` * **Edge Case**: ```python >>> sqrt_newton_method(0) 0.0 ``` **Note**: You must handle invalid inputs by raising an appropriate exception.","solution":"def sqrt_newton_method(n: float, precision: float = 1e-7) -> float: Approximates the square root of a non-negative number using Newton\'s method. Parameters: n (float): Non-negative number to find the square root of. precision (float): Desired precision of the result. Default is 1e-7. Returns: float: Approximated square root of the number. Raises: ValueError: If n is negative or precision is not positive. if n < 0: raise ValueError(\\"n must be non-negative\\") if precision <= 0: raise ValueError(\\"precision must be positive\\") if n == 0: return 0.0 x = n while True: next_x = 0.5 * (x + n / x) if abs(next_x - x) < precision: return next_x x = next_x"},{"question":"# Track and Report Patient Blood Pressure You are required to write a Python function that tracks and reports a patient\'s blood pressure measurements over a period of time. Function Signature ```python def track_and_report_bp(patient_name: str, bp_readings: List[Tuple[str, int, int]]) -> None: ``` Expected Input and Output - The function `track_and_report_bp()` receives two parameters: - `patient_name` (string): The name of the patient. - `bp_readings` (List[Tuple[str, int, int]]): A list of tuples, where each tuple contains: - A date (string in the format \'YYYY-MM-DD\') - Systolic blood pressure (integer) - Diastolic blood pressure (integer) - The function will print the patient\'s name and blood pressure data in an easy-to-read format: ``` Patient: John Doe Date: YYYY-MM-DD - Systolic: 120, Diastolic: 80 Date: YYYY-MM-DD - Systolic: 125, Diastolic: 82 ... ``` Constraints - Handle cases where `bp_readings` is empty, e.g., print \\"No blood pressure readings available.\\" - Ensure the date format in `bp_readings` is validated. If an invalid date format is encountered, print an error message and skip that reading. - Assume all blood pressure readings are in valid integer ranges. Performance Requirements - The function should efficiently process and display a potentially large list of readings. - Avoid redundant computations and ensure the data is properly structured for readability. Example Usage ```python track_and_report_bp( patient_name=\\"John Doe\\", bp_readings=[ (\\"2023-01-01\\", 120, 80), (\\"2023-02-01\\", 125, 82), (\\"2023-03-01\\", 118, 78) ] ) ``` Additional Considerations - Include appropriate error messages for incorrect date formats. - Ensure that the function can handle a dynamic and potentially large set of blood pressure data without performance degradation.","solution":"from typing import List, Tuple from datetime import datetime def track_and_report_bp(patient_name: str, bp_readings: List[Tuple[str, int, int]]) -> None: Tracks and reports a patient\'s blood pressure measurements. Args: - patient_name (str): The name of the patient. - bp_readings (List[Tuple[str, int, int]]): A list of tuples containing date (YYYY-MM-DD), systolic, and diastolic BP. Returns: - None print(f\\"Patient: {patient_name}\\") if not bp_readings: print(\\"No blood pressure readings available.\\") return for reading in bp_readings: date_str, systolic, diastolic = reading try: datetime.strptime(date_str, \'%Y-%m-%d\') print(f\\"Date: {date_str} - Systolic: {systolic}, Diastolic: {diastolic}\\") except ValueError: print(f\\"Invalid date format for reading: {reading}. Skipping this reading.\\")"},{"question":"# Reverse Polish Notation (RPN) Calculator Context You are tasked with implementing a Reverse Polish Notation (RPN) calculator. RPN is a mathematical notation where every operator follows all of its operands. It is also known as postfix notation and is used in stack-based calculations without the need for parentheses. Task Implement a class `RPNCalculator` with a method `evaluate` that evaluates an expression in Reverse Polish Notation and returns the result. Method Details 1. **evaluate(expression: str) -> float**: - **Input**: A string `expression` representing a space-separated Reverse Polish Notation expression. The expression will contain numbers and operators (`+`, `-`, `*`, and `/`). - **Output**: The result of evaluating the expression as a float. - **Example**: ```python rpn_calculator = RPNCalculator() assert rpn_calculator.evaluate(\\"5 1 2 + 4 * + 3 -\\") == 14.0 ``` Constraints - The input expression is guaranteed to be valid and well-formed. - Use stack-based logic to evaluate the expression. - Handle division as floating point division. - Support both integer and floating-point numbers in the input. Performance - The evaluation process should run in linear time relative to the length of the expression. - Use only O(n) extra space for storing intermediate results. Implementation Hint - Utilize a list (stack) to keep track of operands. - Process each token in the RPN expression just once. Here is a starting template for the class: ```python class RPNCalculator: def evaluate(self, expression: str) -> float: stack = [] tokens = expression.split() for token in tokens: if token in \'+-*/\': b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(a / b) else: stack.append(float(token)) return stack[0] # Example usage: if __name__ == \\"__main__\\": rpn_calculator = RPNCalculator() print(rpn_calculator.evaluate(\\"5 1 2 + 4 * + 3 -\\")) # Output: 14.0 ``` Example Test - ```python rpn_calculator = RPNCalculator() assert rpn_calculator.evaluate(\\"3 4 + 2 * 7 /\\") == 2.0 assert rpn_calculator.evaluate(\\"5 1 2 + 4 * + 3 -\\") == 14.0 ```","solution":"class RPNCalculator: def evaluate(self, expression: str) -> float: stack = [] tokens = expression.split() for token in tokens: if token in \'+-*/\': b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(a / b) else: stack.append(float(token)) return stack[0] # Example usage: if __name__ == \\"__main__\\": rpn_calculator = RPNCalculator() print(rpn_calculator.evaluate(\\"5 1 2 + 4 * + 3 -\\")) # Output: 14.0"},{"question":"# Coding Assessment Question You are a software developer working on a machine learning project that requires performing feature scaling operations on datasets. Specifically, you need to implement a function that applies normalization to a list of numerical values, transforming them to a range between 0 and 1. Create a function `normalize_data(data: List[float]) -> List[float]` to normalize a given list of numerical data. The function should follow these criteria: * **Input/Output Formats**: * **Input**: * `data` (List[float]): A list of numerical values, length of which must be greater than 0. * **Output**: * (List[float]): A list of normalized float values transformed to the range between 0 and 1. * **Constraints and Limitations**: * The function should raise exceptions with meaningful messages if the inputs are invalid: * If `data` is an empty list, raise Exception with the message \\"Data should not be an empty list\\". * If all values in `data` are the same, raise Exception with the message \\"Data values should not all be the same\\". * **Performance Requirements**: * Ensure the function runs efficiently with a time complexity of O(n) and a space complexity of O(n). * **Example**: ```python def normalize_data(data: List[float]) -> List[float]: # your implementation here # Test Cases print(normalize_data([1.0, 2.0, 3.0, 4.0, 5.0])) # Expected output: [0.0, 0.25, 0.5, 0.75, 1.0] print(normalize_data([10.0, 20.0, 30.0, 40.0])) # Expected output: [0.0, 0.3333333333333333, 0.6666666666666666, 1.0] try: normalize_data([]) # Expected output: Exception(\\"Data should not be an empty list\\") except Exception as e: print(e) try: normalize_data([5, 5, 5, 5]) # Expected output: Exception(\\"Data values should not all be the same\\") except Exception as e: print(e) ```","solution":"from typing import List def normalize_data(data: List[float]) -> List[float]: Normalize a given list of numerical data to the range [0, 1]. Parameters: data (List[float]): A list of numerical values. Returns: List[float]: A list of normalized values. Raises: Exception: If the input data list is empty. Exception: If all values in the input data list are the same. if not data: raise Exception(\\"Data should not be an empty list\\") min_val = min(data) max_val = max(data) if min_val == max_val: raise Exception(\\"Data values should not all be the same\\") return [(x - min_val) / (max_val - min_val) for x in data]"},{"question":"# Problem: Implementing a Simple LRU Cache Context You are working on a system designed to optimize the retrieval of data from a slow database. To increase efficiency, one approach is to use a caching mechanism. The Least Recently Used (LRU) cache is particularly effective in such scenarios because it ensures that frequently accessed data stays in the cache while less frequently accessed data is evicted. Task 1. **Implement an LRU Cache class** with the core functionality of caching provided data. 2. **Incorporate operations to access and update the cache** based on usage patterns. Details 1. **Class and Method Definitions**: Implement the class `LRUCache` with the following methods: - `__init__(self, capacity: int)`: Initializes the cache with a given capacity. - `get(self, key: int) -> int`: Returns the value of the key if it exists in the cache; otherwise, returns -1. - `put(self, key: int, value: int) -> None`: Inserts the key-value pair into the cache; if the cache exceeds its capacity, it should evict the least recently used item. 2. **Data Structures**: - Use an ordered dictionary or similar data structure to maintain key-value pairs with quick access and modification times. 3. **Constraints and Requirements**: - The cache must follow a strict LRU eviction policy. - All methods should operate in O(1) time complexity. - Handle edge cases like accessing non-existent keys and filling the cache to its capacity. 4. **Example Usage**: ``` cache = LRUCache(2) cache.put(1, 1) # Cache is {1=1} cache.put(2, 2) # Cache is {1=1, 2=2} print(cache.get(1)) # Returns 1 cache.put(3, 3) # Evicts key 2, Cache is {1=1, 3=3} print(cache.get(2)) # Returns -1 (not found) cache.put(4, 4) # Evicts key 1, Cache is {4=4, 3=3} print(cache.get(1)) # Returns -1 (not found) print(cache.get(3)) # Returns 3 print(cache.get(4)) # Returns 4 ``` Implementation ```python from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): Initializes the LRU cache with a given capacity. self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: Returns the value of the key if the key exists, otherwise returns -1. Moves the accessed key to the end to show that it was recently used. if key not in self.cache: return -1 self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: Inserts a key-value pair into the cache. If the key is already in the cache, update the value and move it to the end. If the cache exceeds its capacity, remove the least recently used item. if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) # Example to test cache = LRUCache(2) cache.put(1, 1) # Cache is {1=1} cache.put(2, 2) # Cache is {1=1, 2=2} print(cache.get(1)) # Returns 1 cache.put(3, 3) # Evicts key 2, Cache is {1=1, 3=3} print(cache.get(2)) # Returns -1 (not found) cache.put(4, 4) # Evicts key 1, Cache is {4=4, 3=3} print(cache.get(1)) # Returns -1 (not found) print(cache.get(3)) # Returns 3 print(cache.get(4)) # Returns 4 ``` Write your implementation and ensure it passes all provided test cases.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): Initializes the LRU cache with a given capacity. self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: Returns the value of the key if the key exists, otherwise returns -1. Moves the accessed key to the end to show that it was recently used. if key not in self.cache: return -1 self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: Inserts a key-value pair into the cache. If the key is already in the cache, update the value and move it to the end. If the cache exceeds its capacity, remove the least recently used item. if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"# Advanced String Manipulation: Palindrome Partition Minimization In this problem, you are required to break down a string such that every substring is a palindrome, and to find the minimum number of cuts needed for such a partitioning. Your task is to implement a class `PalindromePartition` which uses dynamic programming to efficiently solve this problem. # Class and Methods Specification: Class: ```python class PalindromePartition: def __init__(self, s: str): self.s = s self.n = len(s) self.dp_cuts = [0] * self.n self.dp_palindrome = [[False] * self.n for _ in range(self.n)] def initialize_palindrome_table(self) -> None: pass def min_cut(self) -> int: pass ``` # Method Descriptions: * `__init__(self, s: str)`: Initialize the `PalindromePartition` instance with the string `s`. Creates a dynamic table `dp_cuts` to store the minimum cuts required for each prefix of the string, and a table `dp_palindrome` to store palindrome status for every substring. * `initialize_palindrome_table(self) -> None`: Initializes the `dp_palindrome` table to determine which substrings are palindromes. * `min_cut(self) -> int`: Calculates and returns the minimum number of cuts needed to partition the string into palindromic substrings using the dynamic programming approach. # Constraints: - The input string `s` consists of lowercase alphabets only. - The length of the string, 1 ≤ len(s) ≤ 1000. # Examples: ```python palindrome_partition = PalindromePartition(\\"aab\\") # Example for minimum cuts: min_cuts = palindrome_partition.min_cut() print(min_cuts) # Output: 1 palindrome_partition_2 = PalindromePartition(\\"abccbc\\") min_cuts_2 = palindrome_partition_2.min_cut() print(min_cuts_2) # Output: 2 ``` # Additional Details: 1. The `initialize_palindrome_table` method sets up the `dp_palindrome` table to mark all substrings that are palindromes. 2. The `min_cut` method calculates the actual minimum cuts by employing a nested loop to iteratively build the `dp_cuts` table based on `dp_palindrome` results.","solution":"class PalindromePartition: def __init__(self, s: str): self.s = s self.n = len(s) self.dp_cuts = [0] * self.n self.dp_palindrome = [[False] * self.n for _ in range(self.n)] def initialize_palindrome_table(self) -> None: # Every single character is a palindrome for i in range(self.n): self.dp_palindrome[i][i] = True # Check for two characters palindromes for i in range(self.n - 1): if self.s[i] == self.s[i + 1]: self.dp_palindrome[i][i + 1] = True # Check for palindromes longer than two characters for length in range(3, self.n + 1): for i in range(self.n - length + 1): j = i + length - 1 if self.s[i] == self.s[j] and self.dp_palindrome[i + 1][j - 1]: self.dp_palindrome[i][j] = True def min_cut(self) -> int: self.initialize_palindrome_table() for i in range(self.n): if self.dp_palindrome[0][i]: self.dp_cuts[i] = 0 else: self.dp_cuts[i] = min(self.dp_cuts[j] + 1 for j in range(i) if self.dp_palindrome[j + 1][i]) return self.dp_cuts[self.n - 1]"},{"question":"# Problem Statement **Repeated Substring Pattern** Given a non-empty string `s`, your task is to determine if the string can be constructed by taking a substring and appending multiple copies of the substring together. You need to implement a function that returns `True` if the given string `s` can be formed in such a way, and `False` otherwise. # Task Write a function `repeatedSubstringPattern(s: str) -> bool` that takes a string `s` as input and returns a boolean value indicating whether the string can be constructed by repeating a substring. # Input Format * A single string `s` consisting of lowercase English letters. # Output Format * A boolean value, `True` if `s` can be constructed by repeating a substring, `False` otherwise. # Constraints * ( 1 leq |s| leq 10^4 ) where ( |s| ) is the length of the string `s`. # Example *Example 1:* Input: ``` s = \\"abab\\" ``` Output: ``` True ``` Explanation: The string `\\"abab\\"` can be formed by repeating the substring `\\"ab\\"` twice. *Example 2:* Input: ``` s = \\"aba\\" ``` Output: ``` False ``` Explanation: The string `\\"aba\\"` cannot be formed by repeating any substring. *Example 3:* Input: ``` s = \\"abcabcabcabc\\" ``` Output: ``` True ``` Explanation: The string `\\"abcabcabcabc\\"` can be formed by repeating the substring `\\"abc\\"` four times. # Notes * The input string will always contain only lowercase English letters. Implement the function `repeatedSubstringPattern` as specified: ```python def repeatedSubstringPattern(s: str) -> bool: pass ```","solution":"def repeatedSubstringPattern(s: str) -> bool: Determines if a given string can be constructed by repeating a substring. n = len(s) # Check all possible lengths of the repeating substring for i in range(1, n // 2 + 1): if n % i == 0: # If the length is divisible by i, check if s can be constructed # by repeating the substring of length i if s[:i] * (n // i) == s: return True return False"},{"question":"# Question: Binary Tree Boundary Traversal Context You are tasked with developing a feature for a tree visualization tool. Part of the requirement is to provide a boundary traversal, where the output should list the nodes forming the boundary of a binary tree. This includes the nodes on the left boundary, leaf nodes (following an in-order traversal), and the right boundary in a top-down manner. Task Implement a Python function `boundary_traversal(root: Optional[TreeNode]) -> List[int]` that returns the boundary traversal of a binary tree. Input - `root`: The root node of the binary tree. Output - A list of integers representing the boundary node values of the binary tree in the order described. Constraints 1. A TreeNode is defined by: ```python class TreeNode: def __init__(self, value: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.value = value self.left = left self.right = right ``` 2. The number of nodes in the tree will not exceed 10,000. 3. Node values are integers and may include duplicates. Example ```python from typing import Optional, List class TreeNode: def __init__(self, value: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.value = value self.left = left self.right = right def boundary_traversal(root: Optional[TreeNode]) -> List[int]: # Function to be implemented pass # Example usage # Constructing the following binary tree: # 1 # / # 2 3 # /| | # 4 5 6 7 # # 8 9 root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5, None, TreeNode(8))), TreeNode(3, TreeNode(6, None, TreeNode(9)), TreeNode(7))) print(boundary_traversal(root)) # Output: [1, 2, 4, 8, 9, 7, 3] ``` Notes - The root is always part of the boundary. For a single node, it should return a list containing just the root. - To simplify, assume the tree is non-empty. - Ensure to handle both left and right boundaries properly, even if they share common leaf nodes.","solution":"from typing import Optional, List class TreeNode: def __init__(self, value: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.value = value self.left = left self.right = right def boundary_traversal(root: Optional[TreeNode]) -> List[int]: if not root: return [] def is_leaf(node): return not node.left and not node.right def add_left_boundary(node, res): while node: if not is_leaf(node): res.append(node.value) if node.left: node = node.left else: node = node.right def add_leaves(node, res): if node: if is_leaf(node): res.append(node.value) add_leaves(node.left, res) add_leaves(node.right, res) def add_right_boundary(node, res): tmp = [] while node: if not is_leaf(node): tmp.append(node.value) if node.right: node = node.right else: node = node.left while tmp: res.append(tmp.pop()) boundary = [] if not is_leaf(root): boundary.append(root.value) add_left_boundary(root.left, boundary) add_leaves(root, boundary) add_right_boundary(root.right, boundary) return boundary"},{"question":"# Problem Statement Write a function that takes a list of integers and returns a list of lists, where each sublist contains all the integers that are factors of the corresponding integer in the original list. The factors of a number are the integers that divide it without leaving a remainder, including 1 and the number itself. Your task is to implement the following function: # Function Signature ```python def list_factors(int_list: List[int]) -> List[List[int]]: ``` # Input * A list of integers `int_list`. # Output * A list of lists, where each sublist contains all the factors of the corresponding integer from the input list in ascending order. # Example ```python int_list = [6, 10, 13] expected_output = [[1, 2, 3, 6], [1, 2, 5, 10], [1, 13]] assert list_factors(int_list) == expected_output ``` # Note - Ensure your function handles cases where the input list contains a single element. - Consider edge cases like 0 (if applicable) and negative numbers (however, assume only positive integers for simplicity). - Aim to provide an efficient implementation that does not unnecessarily recompute factors.","solution":"from typing import List def list_factors(int_list: List[int]) -> List[List[int]]: Returns a list of lists, where each sublist contains all the factors of the corresponding integer in the original list. def get_factors(n: int) -> List[int]: Returns a list of factors for the given integer n. factors = [] for i in range(1, n + 1): if n % i == 0: factors.append(i) return factors return [get_factors(num) for num in int_list]"},{"question":"# Coding Question: Custom Round Function Context In mathematics, the round of a number is the nearest integer. If the fractional component of the number is halfway between two integers, it gets rounded towards the nearest even number (this is known as banker\'s rounding). Implementing a custom `round()` function will test your understanding of float-to-integer conversions and handling edge cases. Problem Statement Write a function `round_number(x: float) -> int` that returns the nearest integer to `x`. If the fractional part is exactly 0.5, round to the nearest even number. Input - A single float value `x`. Output - An integer representing the rounded value of `x`. Constraints - Your implementation must mirror the standard round function\'s behavior (with banker\'s rounding). - You should handle edge cases such as positive and negative values, zero, and boundary conditions. - You must implement the logic directly without using any library functions like `round`. Example ```python def round_number(x: float) -> int: # Your implementation here # Examples to test your solution print(round_number(3.5)) # Expected output: 4 print(round_number(4.5)) # Expected output: 4 print(round_number(-3.5)) # Expected output: -4 print(round_number(-4.5)) # Expected output: -4 print(round_number(2.0)) # Expected output: 2 print(round_number(-2.0)) # Expected output: -2 print(round_number(1.1)) # Expected output: 1 print(round_number(-1.1)) # Expected output: -1 print(round_number(0.0)) # Expected output: 0 print(round_number(1_000_000_000.5)) # Expected output: 1_000_000_000 print(round_number(1_000_000_001.5)) # Expected output: 1_000_000_002 ``` Additional Requirements - Your solution must have a time complexity of O(1). - Ensure that the function works for very large and very small floating-point numbers.","solution":"def round_number(x: float) -> int: Returns the nearest integer to x using banker\'s rounding. If the fractional component of x is 0.5, round to the nearest even number. integer_part = int(x) fractional_part = x - integer_part if fractional_part > 0.5 or (fractional_part == 0.5 and (integer_part % 2 != 0)): return integer_part + 1 elif fractional_part < -0.5 or (fractional_part == -0.5 and (integer_part % 2 != 0)): return integer_part - 1 else: return integer_part"},{"question":"# Problem Statement You are provided with a string that contains alphanumeric characters. Your task is to write a function that finds the longest substring of the input string containing at most two distinct characters. **Function Signature**: ```python def longest_substr_two_distinct(s: str) -> str: ``` # Input: * `s` (str): A string containing alphanumeric characters of length `n` (1 ≤ n ≤ 10^5). # Output: * Returns a substring of `s` that is the longest one with at most two distinct characters. If there are multiple such substrings, return the one that appears first. # Example: ```python s = \\"abcbbbbcccbdddadacb\\" print(longest_substr_two_distinct(s)) # Output: \\"bcbbbbcccb\\" s = \\"eceba\\" print(longest_substr_two_distinct(s)) # Output: \\"ece\\" ``` # Constraints: * The input string `s` can contain both lowercase and uppercase letters. # Notes: - Consider using sliding window technique to keep track of the current substring with at most two distinct characters. - Use a dictionary or similar data structure to count the frequency of characters within the window. - Carefully manage the window such that it is adjusted to always maintain at most two distinct characters while traversing through the string. # Hints: - Initialize two pointers for the window\'s start and end. - Expand the window by extending the end pointer until the window has more than two distinct characters. - When the window has more than two distinct characters, move the start pointer to reduce the window until it contains exactly two distinct characters again. - Keep track of the maximum length of such a window throughout the traversal to find the longest substring.","solution":"def longest_substr_two_distinct(s: str) -> str: if len(s) <= 2: return s left, right = 0, 0 max_len = 0 max_substr = \\"\\" char_freq = {} while right < len(s): char = s[right] if char in char_freq: char_freq[char] += 1 else: char_freq[char] = 1 while len(char_freq) > 2: left_char = s[left] char_freq[left_char] -= 1 if char_freq[left_char] == 0: del char_freq[left_char] left += 1 if (right - left + 1) > max_len: max_len = right - left + 1 max_substr = s[left:right + 1] right += 1 return max_substr"},{"question":"# Problem Statement You are developing a utility function that processes a list of logs from a software application. Each log entry contains a timestamp and a message in the format \\"HH:MM:SS Message\\". Your task is to implement a function that analyzes these logs to determine the range of activity for each unique message, defined as the time difference between the earliest and latest appearance of that message. # Function Signature ```python def analyze_logs(logs): Analyze log entries to determine the time range of activity for each unique message Parameters: logs -- List of strings, where each string represents a log entry in the format \\"HH:MM:SS Message\\" Output: A dictionary with messages as keys and their time range of activity as values in seconds pass ``` # Example Usage ```python >>> logs = [ ... \'12:00:00 Login\', ... \'12:30:15 Logout\', ... \'12:45:30 Login\', ... \'13:01:00 File Access\', ... \'13:20:00 Logout\', ... \'13:30:00 Login\' ... ] >>> analyze_logs(logs) { \'Login\': 5400, # Time range in seconds (from 12:00:00 to 13:30:00) \'Logout\': 2975, # Time range in seconds (from 12:30:15 to 13:20:00) \'File Access\': 0 # Time range in seconds (only one occurrence) } ``` # Requirements 1. **Input Constraints**: - Each log entry must be a string in the valid format \\"HH:MM:SS Message\\". - The list of logs can contain between 1 and 10,000 entries. 2. **Output**: - The function should return a dictionary where keys are unique messages and values are their time range in seconds. 3. **Performance Consideration**: - Ensure the function is optimized to handle the upper limit of entries without significant performance degradation. - Avoid multiple passes over the log list whenever possible. # Background Context Log analysis is crucial in identifying patterns and understanding the usage of various features in software applications. By determining activity ranges, developers can gain insights into the frequency and duration of specific actions. This function will aid in such analysis, providing an efficient way to track activity timelines for multiple entries.","solution":"from datetime import datetime def analyze_logs(logs): Analyze log entries to determine the time range of activity for each unique message. Parameters: logs -- List of strings, where each string represents a log entry in the format \\"HH:MM:SS Message\\" Output: A dictionary with messages as keys and their time range of activity as values in seconds message_times = {} for log in logs: time_str, message = log.split(\' \', 1) log_time = datetime.strptime(time_str, \\"%H:%M:%S\\") if message not in message_times: message_times[message] = {\'first\': log_time, \'last\': log_time} else: if log_time < message_times[message][\'first\']: message_times[message][\'first\'] = log_time if log_time > message_times[message][\'last\']: message_times[message][\'last\'] = log_time time_ranges = {} for message, times in message_times.items(): time_range = int((times[\'last\'] - times[\'first\']).total_seconds()) time_ranges[message] = time_range return time_ranges"},{"question":"# Compressed String Length Calculation Background As a data compression engineer, you are developing a feature for compressing strings by representing consecutive repeated characters as a single character followed by the count of repetitions. While the full implementation of the compression is straightforward, you have been tasked with ensuring the preliminary calculation of the length of the compressed string for efficiency analysis. Objective Implement a function `compressed_string_length` which, given a string, returns the length of the string when compressed using the following rules: - Consecutive sequences of the same character are replaced by the character followed by the number of repetitions. - For a character that appears once, it is just represented by the character itself without a number. Input Format * A single string `s` of length (1 leq |s| leq 10^5). The string contains only uppercase and lowercase letters (a-z, A-Z). Output Format * An integer representing the length of the string after compression. Constraints * The solution must run in linear time (O(n)) where (n) is the length of the string. * Use at most linear space. Examples ```plaintext Example 1: Input: \\"aaabccdddde\\" Output: 8 Description: The compressed string is \\"a3bc2d4e\\" Example 2: Input: \\"aabbcc\\" Output: 6 Description: The compressed string is \\"a2b2c2\\" Example 3: Input: \\"abcde\\" Output: 5 Description: The compressed string is \\"abcde\\" ``` Implementation Requirements Write the function `compressed_string_length(s: str) -> int` which follows the specified input and output format. Ensure the function handles edge cases such as a string consisting of a single character or a completely unique character sequence efficiently.","solution":"def compressed_string_length(s): Calculates the length of the compressed version of the string `s`. Consecutive sequences of the same character are replaced by the character followed by the count of repetitions. Parameters: s (str): The input string to be compressed. Returns: int: The length of the compressed string. if not s: return 0 compressed_length = 0 count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed_length += 1 + (len(str(count)) if count > 1 else 0) count = 1 # For the last character group compressed_length += 1 + (len(str(count)) if count > 1 else 0) return compressed_length"},{"question":"# Scenario You are part of a team designing a reservation system for a small library. One of the key features of the system is to keep track of book reservations, ensuring no book is double-booked for the same period. # Task Implement the `reserve_book` function that books a reservation for a given book and ensures no overlap with existing reservations. # Function Signature ```python def reserve_book( reservations: list[dict], book_id: int, start_date: str, end_date: str ) -> bool: pass ``` # Parameters * `reservations` (list[dict]): A list of dictionaries representing current reservations. Each dictionary contains the keys `book_id`, `start_date`, and `end_date`. * `book_id` (int): The ID of the book to be reserved. * `start_date` (str): The start date of the reservation in the format \\"YYYY-MM-DD\\". * `end_date` (str): The end date of the reservation in the format \\"YYYY-MM-DD\\". # Output * Returns a boolean value: `True` if the reservation is successfully added without conflicts, `False` otherwise. # Constraints * Dates are in the format `YYYY-MM-DD` and can be compared lexicographically. * A new reservation is invalid if it overlaps with any existing reservation for the same book. * The `end_date` must be later than the `start_date`. # Requirements 1. **Input Validation**: * Ensure the `end_date` is later than the `start_date`. * Validate the date format is correct for the provided `start_date` and `end_date`. 2. **Conflict Checking**: * Check for any overlapping reservations for the same book. 3. **Error Handling**: * Raise appropriate errors for invalid inputs. # Example ```python >>> current_reservations = [ ... {\\"book_id\\": 1, \\"start_date\\": \\"2023-10-01\\", \\"end_date\\": \\"2023-10-10\\"}, ... {\\"book_id\\": 2, \\"start_date\\": \\"2023-09-15\\", \\"end_date\\": \\"2023-09-20\\"}, ... ] >>> reserve_book(current_reservations, 1, \\"2023-10-11\\", \\"2023-10-15\\") True >>> reserve_book(current_reservations, 1, \\"2023-10-05\\", \\"2023-10-12\\") False >>> reserve_book(current_reservations, 3, \\"2023-09-01\\", \\"2023-09-10\\") True ``` # Notes * Make sure to handle edge cases such as date format errors and overlapping date ranges correctly. * Consider using datetime library to facilitate date comparisons and ranges.","solution":"from datetime import datetime def reserve_book(reservations: list[dict], book_id: int, start_date: str, end_date: str) -> bool: Tries to reserve a book for the given period, ensuring no conflict with existing reservations. Parameters: reservations (list[dict]): A list of current reservations. book_id (int): The ID of the book to be reserved. start_date (str): The start date of the reservation in \'YYYY-MM-DD\' format. end_date (str): The end date of the reservation in \'YYYY-MM-DD\' format. Returns: bool: True if reservation is successful, False if it conflicts with existing ones or invalid. try: new_start = datetime.strptime(start_date, \\"%Y-%m-%d\\") new_end = datetime.strptime(end_date, \\"%Y-%m-%d\\") except ValueError: raise ValueError(\\"Date format should be YYYY-MM-DD\\") if new_start >= new_end: return False for reservation in reservations: if reservation[\'book_id\'] == book_id: existing_start = datetime.strptime(reservation[\'start_date\'], \\"%Y-%m-%d\\") existing_end = datetime.strptime(reservation[\'end_date\'], \\"%Y-%m-%d\\") if not (new_end <= existing_start or new_start >= existing_end): return False reservations.append({ \\"book_id\\": book_id, \\"start_date\\": start_date, \\"end_date\\": end_date, }) return True"},{"question":"Sorting Algorithms - Merge Sort with Inversions Count You are tasked to write a function that performs the merge sort algorithm on a list of integers and simultaneously counts the number of inversions required to sort the list. An inversion is a situation where a larger number precedes a smaller one in the list. **Task** Implement the `merge_sort_and_count` function using the following steps: 1. Implement merge sort that recursively splits the list into halves and sorts them. 2. While merging two halves, count how many times elements from the right half are placed before elements from the left half in the sorted list, indicating an inversion. **Function Signature** ```python def merge_sort_and_count(arr: list[int]) -> tuple[list[int], int]: ``` # Input * `arr` (list[int]): The list of integers to be sorted and for which to count inversions. # Output * A tuple containing: * The sorted list of integers. * The total number of inversions found in the original list. # Constraints * The list can contain up to (10^5) integers. * Each integer is in the range from (-10^9) to (10^9). # Example ```python arr = [2, 3, 8, 6, 1] sorted_arr, inversions = merge_sort_and_count(arr) print(sorted_arr) # Output should be [1, 2, 3, 6, 8] print(inversions) # Output should be 5 ``` # Notes * An inversion is counted every time a smaller right half element moves before a larger left half element. * Consider edge cases such as: * An already sorted list should have zero inversions. * A list with all identical elements should also have zero inversions. * The function should handle lists with negative numbers appropriately. # Optimizations * Ensure that the merge process is efficiently counting inversions to maintain a time complexity of (O(n log n)).","solution":"def merge_sort_and_count(arr): Sorts the array using merge sort algorithm and counts inversions. Args: arr (list[int]): The list of integers to be sorted and for which to count inversions. Returns: tuple: A tuple containing the sorted list and the total number of inversions. if len(arr) < 2: return arr, 0 mid = len(arr) // 2 left, left_inv = merge_sort_and_count(arr[:mid]) right, right_inv = merge_sort_and_count(arr[mid:]) merged, split_inv = merge_and_count(left, right) return merged, left_inv + right_inv + split_inv def merge_and_count(left, right): Merges two halves into a sorted array and counts inversions. Args: left (list[int]): Left half of the array. right (list[int]): Right half of the array. Returns: tuple: Merged sorted array and the count of split inversions. sorted_arr = [] i = j = 0 inv_count = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_arr.append(left[i]) i += 1 else: sorted_arr.append(right[j]) j += 1 inv_count += len(left) - i # Count how many elements are remaining in left sorted_arr.extend(left[i:]) sorted_arr.extend(right[j:]) return sorted_arr, inv_count"},{"question":"Problem Statement You are given a class `CustomSet` that must implement a set data structure with the following operations: `add`, `remove`, and `clear`. Your task is to extend the functionality by implementing a method `union(self, other_set: \'CustomSet\') -> \'CustomSet\'` that returns a new `CustomSet` that is the union of the current set and `other_set`. # Requirements: 1. **union(self, other_set: \'CustomSet\') -> \'CustomSet\'**: - This method should return a new `CustomSet` that contains all unique elements from both the current set and `other_set`. # Constraints 1. You should not alter the existing methods `add`, `remove`, or `clear`. 2. The `CustomSet` class must not use the built-in `set` type. # Expected Input and Output Format * The `union` method takes another `CustomSet` object as input. * The `union` method outputs a new `CustomSet` containing the union of the current set and `other_set`. # Example ```python >>> set1 = CustomSet([1, 2, 3]) >>> set2 = CustomSet([3, 4, 5]) >>> set3 = set1.union(set2) >>> set3.elements() {1, 2, 3, 4, 5} >>> set4 = CustomSet([10, 20]) >>> set5 = CustomSet([]) >>> set6 = set4.union(set5) >>> set6.elements() {10, 20} ``` # Additional Instructions * The `elements` method is provided for testing purposes and returns the elements in the set as a Python dictionary. * Ensure your implementation of the `union` method correctly handles various scenarios, such as empty sets and large sets. ```python class CustomSet: def __init__(self, initial_data=[]): self.data = {} for item in initial_data: self.data[item] = True def add(self, item): self.data[item] = True def remove(self, item): if item in self.data: del self.data[item] else: raise KeyError(f\'{item} not found in the set\') def clear(self): self.data.clear() def elements(self): return self.data.keys() def union(self, other_set: \'CustomSet\') -> \'CustomSet\': union_set = CustomSet() for item in self.data: union_set.add(item) for item in other_set.elements(): union_set.add(item) return union_set ```","solution":"class CustomSet: def __init__(self, initial_data=[]): self.data = {} for item in initial_data: self.data[item] = True def add(self, item): self.data[item] = True def remove(self, item): if item in self.data: del self.data[item] else: raise KeyError(f\'{item} not found in the set\') def clear(self): self.data.clear() def elements(self): return self.data.keys() def union(self, other_set: \'CustomSet\') -> \'CustomSet\': union_set = CustomSet() for item in self.data: union_set.add(item) for item in other_set.elements(): union_set.add(item) return union_set"},{"question":"# Coding Assessment Question Context In a digital library system, you are tasked with developing a feature that helps in tracking and organizing the reading progress of users. One of the required functionalities is to determine the percentage of a book that a user has read based on the total number of pages and the number of pages the user has finished reading. Implementing this feature involves writing a function that computes the completion percentage. Task Implement a function `reading_progress(total_pages: int, pages_read: int) -> float` that calculates and returns the percentage of the book that has been read. The function takes two parameters: 1. `total_pages`: The total number of pages in the book (total_pages > 0). 2. `pages_read`: The number of pages read by the user (0 <= pages_read <= total_pages). Ensure the function correctly handles the specified input constraints and provides accurate results. Input and Output Format **Input**: * `total_pages`: int - the total number of pages in the book. * `pages_read`: int - the number of pages read so far. **Output**: * float - the percentage of the book that has been read, rounded to two decimal places. Constraints * `total_pages > 0` * `0 <= pages_read <= total_pages` Examples ```python # Example 1 total_pages = 300 pages_read = 150 reading_progress(total_pages, pages_read) # Expected Output: 50.0 # Example 2 total_pages = 450 pages_read = 200 reading_progress(total_pages, pages_read) # Expected Output: 44.44 # Example 3 total_pages = 120 pages_read = 60 reading_progress(total_pages, pages_read) # Expected Output: 50.0 ``` You are to ensure the implementation handles all edge cases and provides an accurate calculation for any valid inputs.","solution":"def reading_progress(total_pages: int, pages_read: int) -> float: Calculate the percentage of the book read. Args: total_pages (int): The total number of pages in the book. pages_read (int): The number of pages read by the user. Returns: float: The percentage of the book that has been read, rounded to two decimal places. if total_pages <= 0 or pages_read < 0 or pages_read > total_pages: raise ValueError(\\"Invalid input range for total_pages or pages_read\\") percentage_read = (pages_read / total_pages) * 100 return round(percentage_read, 2)"},{"question":"# Dijkstra’s Algorithm for Shortest Path You are required to implement Dijkstra\'s algorithm to find the shortest path from a given source vertex to all other vertices in an undirected, weighted graph. **Function Signature:** ```python def dijkstra_shortest_path(vertices, edges, source): :param vertices: List[int] - list of vertex identifiers (e.g., [0, 1, 2]). :param edges: List[Tuple[int, int, int]] - list of edges represented as tuples (v1, v2, weight). :param source: int - the source vertex from which to calculate shortest paths. :return: Dict[int, int] - dictionary of shortest path distances from source to each vertex. pass ``` **Specifications:** 1. **Input Format**: - `vertices`: List of `n` integers representing graph vertices. - `edges`: List of `m` tuples (v1, v2, weight) representing `m` edges with weights. - `source`: Single integer representing the source vertex. 2. **Constraints**: - Vertices are zero-indexed integers. - The graph does not contain self-loops or parallel edges. - Edges will have non-negative weights. 3. **Output**: - A dictionary where the keys are vertex identifiers and the values are the shortest path distances from the source vertex. **Performance Requirements**: Solution should be efficient and consider complexity close to O((V + E) log V) with heap optimizations. **Example**: ```python vertices = [0, 1, 2, 3] edges = [(0, 1, 4), (0, 2, 1), (1, 2, 2), (1, 3, 5), (2, 3, 8)] source = 0 print(dijkstra_shortest_path(vertices, edges, source)) # Expected Output: {0: 0, 1: 3, 2: 1, 3: 9} ``` **Description**: You should implement Dijkstra’s algorithm leveraging the given `vertices`, `edges`, and `source`. Your implementation should correctly compute the shortest distances from the source vertex to all other vertices, considering varying edge weights and without cycles. Handle scenarios where vertices might be disconnected, ensuring no unreachable vertices are present in the output with a valid shortest distance.","solution":"import heapq def dijkstra_shortest_path(vertices, edges, source): Returns the shortest path from the source vertex to all other vertices. # Initializations graph = {v: [] for v in vertices} for v1, v2, weight in edges: graph[v1].append((v2, weight)) graph[v2].append((v1, weight)) # Priority Queue and distances dictionary pq = [(0, source)] distances = {v: float(\'inf\') for v in vertices} distances[source] = 0 # Set of processed vertices processed = set() while pq: current_distance, current_vertex = heapq.heappop(pq) if current_vertex in processed: continue processed.add(current_vertex) for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances"},{"question":"# Question: First Non-Repeating Character Context: You need to identify the first non-repeating character in a given string. This is useful in various applications like data stream processing, where determining the first unique element is a common task. Your objective is to build an efficient solution to find this character. Instructions: 1. Implement the function `first_non_repeating_char(input_str: str) -> str` that returns the first non-repeating character in the input string. If all characters repeat, return an empty string \'\'. 2. Optimize for both time and space complexity. 3. Handle various edge cases such as empty strings, strings with all repeating characters, etc. Input: * A single string `input_str` (1 <= len(input_str) <= 10^6) Output: * A single character which is the first non-repeating character in the input string, or an empty string \'\' if no such character exists. Example: ``` first_non_repeating_char(\\"swiss\\") > \'w\' first_non_repeating_char(\\"aabbcc\\") > \'\' ``` Constraints: * Your implementation should be case sensitive (treat uppercase and lowercase characters as distinct). * The input string may contain any printable ASCII characters. Performance Requirements: * Time Complexity: O(n), where n is the length of input string. * Space Complexity: O(1).","solution":"def first_non_repeating_char(input_str: str) -> str: Returns the first non-repeating character in the input string. If all characters repeat, returns an empty string. # Dictionary to store frequency of each character char_count = {} # First pass: count frequency of each character for char in input_str: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass: find the first non-repeating character for char in input_str: if char_count[char] == 1: return char # If no non-repeating character found, return empty string return \'\'"},{"question":"# Problem Description You are given the implementation of a simple text editor that supports basic operations like inserting characters, deleting characters, and moving the cursor around. Your task is to extend this implementation with additional functionality to support undo and redo operations. # Function Specifications 1. **insert(character: str)**: Inserts a character at the current cursor position. - **Input**: A single character string. - **Output**: None 2. **delete()**: Deletes the character at the current cursor position, if any. - **Input**: None - **Output**: None 3. **move_cursor(position: int)**: Moves the cursor to the specified position. - **Input**: An integer representing the new cursor position (0-indexed). - **Output**: None 4. **undo()**: Reverts the last operation (insert or delete). - **Input**: None - **Output**: None 5. **redo()**: Redoes the last undone operation, if any. - **Input**: None - **Output**: None # Constraints - Only the most recent modification command (insert or delete) can be undone or redone. - The cursor position is always within the bounds of the text. # Example ```python editor = TextEditor() editor.insert(\\"a\\") editor.insert(\\"b\\") editor.insert(\\"c\\") print(editor.text) # \\"abc\\" editor.delete() print(editor.text) # \\"ab\\" editor.move_cursor(0) editor.insert(\\"x\\") print(editor.text) # \\"xab\\" editor.undo() print(editor.text) # \\"ab\\" editor.redo() print(editor.text) # \\"xab\\" ``` # Requirements - Ensure the text editor accurately and efficiently handles the specified operations. - Implement edge cases such as multiple undos, redoes at various cursor positions, and maintaining the integrity of the text.","solution":"class TextEditor: def __init__(self): self.text = [] self.cursor = 0 self.history = [] self.redo_stack = [] def insert(self, character): self.text.insert(self.cursor, character) self.history.append((\'insert\', character, self.cursor)) self.cursor += 1 self.redo_stack.clear() def delete(self): if self.cursor > 0: deleted_char = self.text.pop(self.cursor - 1) self.history.append((\'delete\', deleted_char, self.cursor - 1)) self.cursor -= 1 self.redo_stack.clear() def move_cursor(self, position): if 0 <= position <= len(self.text): self.cursor = position def undo(self): if self.history: last_action = self.history.pop() action, character, position = last_action if action == \'insert\': self.text.pop(position) self.cursor = position elif action == \'delete\': self.text.insert(position, character) self.cursor = position + 1 self.redo_stack.append(last_action) def redo(self): if self.redo_stack: last_undone_action = self.redo_stack.pop() action, character, position = last_undone_action if action == \'insert\': self.text.insert(position, character) self.cursor = position + 1 elif action == \'delete\': self.text.pop(position) self.cursor = position self.history.append(last_undone_action) def get_text(self): return \'\'.join(self.text)"},{"question":"# Problem Statement You are working on a text editor that helps people write more concisely. One feature is to detect redundant words and phrases. Write a function that takes a string and returns the same string but with redundant sequences of words removed. A sequence is considered redundant if it appears consecutively in the text. **Function Signature:** ```python def remove_redundant_phrases(text: str) -> str: pass ``` # Inputs: 1. **text (str):** The input text where phrases need to be checked for redundancy. (1 ≤ len(text) ≤ 1000) # Outputs: - **Returns (str):** The modified string with redundant sequences removed. # Constraints: - The text contains only lowercase and uppercase English letters and spaces. - Consecutive redundant phrases should be removed. - Punctuation marks are not considered. Treat the text as a sequence of words separated by spaces. - The function should be efficient to handle the length constraint. # Example: ```python print(remove_redundant_phrases(\\"this is is a test test\\")) # Output: \'this is a test\' ``` Explanation: In the given example, the phrase \\"is\\" is redundant as it appears consecutively. Similarly, \\"test\\" is also redundant. The function removes these redundant phrases to return the concise string \\"this is a test\\". **Additional Examples:** ```python print(remove_redundant_phrases(\\"Hello Hello Hello world\\")) # Output: \'Hello world\' print(remove_redundant_phrases(\\"I I I love love coding\\")) # Output: \'I love coding\' print(remove_redundant_phrases(\\"repetition is is not not a good good practice\\")) # Output: \'repetition is not a good practice\' ```","solution":"def remove_redundant_phrases(text: str) -> str: Removes redundant sequences of words that appear consecutively in the text. Parameters: - text (str): The input text where phrases need to be checked for redundancy. Returns: - str: The modified string with redundant sequences removed. words = text.split() if not words: return \\"\\" result = [] previous_word = None for word in words: if word != previous_word: result.append(word) previous_word = word return \' \'.join(result)"},{"question":"# Huffman Coding Tree Construction and Decoding You are required to implement a Huffman Coding Tree that can be used for efficient data compression. Your task is to build the Huffman Tree for a given set of characters and their frequencies, and then use this tree to encode and decode messages. Implement a class `HuffmanCoding` with the following methods: 1. **Constructor**: Initializes the Huffman Tree using the given frequencies. 2. **`build_tree`:** Constructs the Huffman Tree using the character frequencies. 3. **`encode`:** Encodes a given message using the constructed Huffman Tree. 4. **`decode`:** Decodes a given encoded string back to the original message using the Huffman Tree. Requirements: - Ensure the Huffman Tree is constructed correctly based on the input frequencies. - The `encode` and `decode` methods should function correctly based on the constructed Huffman Tree. # Implementation Details: ```python class HuffmanTreeNode: def __init__(self, char, freq): self.char = char self.freq = freq self.left = None self.right = None class HuffmanCoding: def __init__(self, frequencies: dict) -> None: Initializes the Huffman Coding Tree using the given character frequencies. Parameters: frequencies (dict): A dictionary mapping characters to their frequencies. self.frequencies = frequencies self.root = None self.codes = {} self.build_tree() def build_tree(self) -> None: Builds the Huffman Tree from the given character frequencies. # Your implementation goes here. pass def encode(self, text: str) -> str: Encodes the given text using the Huffman Tree. Parameters: text (str): The text to encode. Returns: str: The encoded text as a string of bits. # Your implementation goes here. pass def decode(self, encoded_text: str) -> str: Decodes the given encoded text using the Huffman Tree. Parameters: encoded_text (str): The encoded text as a string of bits. Returns: str: The decoded original text. # Your implementation goes here. pass # Example Use: frequencies = {\'a\': 5, \'b\': 2, \'c\': 1, \'d\': 1} huffman = HuffmanCoding(frequencies) encoded_message = huffman.encode(\\"abcd\\") print(encoded_message) # Should print the encoded representation of \\"abcd\\" decoded_message = huffman.decode(encoded_message) print(decoded_message) # Should print \\"abcd\\" ``` # Constraints: - The input frequencies dictionary will have at most 26 different characters (a-z). - The frequency of each character will be a positive integer. - Length of the text to encode/decode (n) will be in the range 1 <= n <= 10^5. # Performance: - Ensure the construction of the Huffman Tree has a time complexity of O(n log n), where n is the number of unique characters. - Ensure the encoding and decoding operations run efficiently, with both having a time complexity related to the length of the text to encode/decode. # Hints: - Use a priority queue to build the Huffman Tree. - Traverse the tree to generate the codes for each character.","solution":"import heapq class HuffmanTreeNode: def __init__(self, char, freq): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq class HuffmanCoding: def __init__(self, frequencies: dict) -> None: self.frequencies = frequencies self.root = None self.codes = {} self.reverse_codes = {} self.build_tree() def build_tree(self) -> None: heap = [HuffmanTreeNode(char, freq) for char, freq in self.frequencies.items()] heapq.heapify(heap) while len(heap) > 1: node1 = heapq.heappop(heap) node2 = heapq.heappop(heap) merged = HuffmanTreeNode(None, node1.freq + node2.freq) merged.left = node1 merged.right = node2 heapq.heappush(heap, merged) self.root = heap[0] self._generate_codes(self.root, \\"\\") def _generate_codes(self, node, current_code): if node is None: return if node.char is not None: self.codes[node.char] = current_code self.reverse_codes[current_code] = node.char return self._generate_codes(node.left, current_code + \\"0\\") self._generate_codes(node.right, current_code + \\"1\\") def encode(self, text: str) -> str: encoded_text = \\"\\" for char in text: encoded_text += self.codes[char] return encoded_text def decode(self, encoded_text: str) -> str: current_code = \\"\\" decoded_text = \\"\\" for bit in encoded_text: current_code += bit if current_code in self.reverse_codes: decoded_text += self.reverse_codes[current_code] current_code = \\"\\" return decoded_text"},{"question":"# Problem Statement You are organizing a charity fundraiser event and you need to allocate donation boxes to various locations around the city. Each donation box has a weight capacity and a certain value. You want to maximize the total value of the donation boxes allocated without exceeding a specified total weight capacity for a vehicle that will deliver these donation boxes. # Task Write a function `maximize_donation_value` that takes in three arguments: a list of integers `values` representing the value of each donation box, a list of integers `weights` representing the weight of each donation box, and an integer `max_capacity` representing the maximum weight capacity of the vehicle. Your function should return the maximum total value of the donation boxes that can be allocated without exceeding the maximum weight capacity. # Input * `values`: A list of integers where each integer represents the value of a donation box. * `weights`: A list of integers where each integer represents the weight of a donation box. * `max_capacity`: An integer representing the maximum weight capacity of the vehicle. # Output * An integer representing the maximum total value of the donation boxes that can be allocated without exceeding the weight capacity. # Constraints * The length of `values` and `weights` will be the same, and each will have at most 100 items. * Each value in `values` and `weights` will be a positive integer. * `max_capacity` will be a positive integer. # Example ```python def maximize_donation_value(values: list[int], weights: list[int], max_capacity: int) -> int: pass # Example Usage values = [60, 100, 120] weights = [10, 20, 30] max_capacity = 50 print(maximize_donation_value(values, weights, max_capacity)) # Output: 220 ``` # Notes You need to handle edge cases such as when the input lists are empty or the `max_capacity` is zero. Consider using a dynamic programming approach to solve the problem efficiently under the given constraints.","solution":"def maximize_donation_value(values, weights, max_capacity): Returns the maximum total value of the donation boxes that can be allocated without exceeding the max_capacity of weight. n = len(values) dp = [[0 for _ in range(max_capacity + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(1, max_capacity + 1): if weights[i-1] <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1]) else: dp[i][w] = dp[i-1][w] return dp[n][max_capacity]"},{"question":"# Scenario An API service provider requires a utility to decode a provided URL-encoded string. URL-encoded strings replace unsafe ASCII characters with a \\"%\\" followed by two hexadecimal digits representing the character\'s ASCII code. # Problem Create a function: 1. `url_decode(encoded_url: str) -> str`: This function should decode the given URL-encoded string. # Requirements - The function should correctly decode hexadecimal sequences back to their original characters. - Handle edge cases such as the presence of reserved characters (`%`, `+`, etc.) and ensure they are processed correctly. - Raise a `ValueError` with an appropriate message if the input string contains malformed hexadecimal sequences. # Function Signature ```python def url_decode(encoded_url: str) -> str: ... ``` # Input and Output - **Input**: A string `encoded_url` representing the URL-encoded string. - **Output**: A string representing the decoded URL with all hexadecimal sequences converted back to their original characters. Replace any occurrences of the \\"+\\" character with spaces. # Constraints - The `encoded_url` will contain a maximum of 1000 characters. # Examples - `url_decode(\\"Hello%20World%21\\")` should return `\\"Hello World!\\"`. - `url_decode(\\"%7Bfoo%7D\\")` should return `\\"{foo}\\"`. - `url_decode(\\"key%3Dvalue%26other%3Ddata\\")` should return `\\"key=value&other=data\\"`. - `url_decode(\\"a+%2B+b\\")` should return `\\"a + b\\"`. - `url_decode(\\"%%7A\\")` should raise a `ValueError` with the message \\"Malformed URL-encoded string.\\" # Testing Use Python\'s built-in `doctest` module to provide test cases demonstrating the usage and correctness of the function.","solution":"def url_decode(encoded_url: str) -> str: Decodes a URL-encoded string. import re def hex_to_char(match): hex_value = match.group(1) if len(hex_value) != 2 or not re.match(r\'^[0-9a-fA-F]{2}\', hex_value): raise ValueError(\\"Malformed URL-encoded string.\\") return chr(int(hex_value, 16)) decoded_url = encoded_url.replace(\'+\', \' \') decoded_url = re.sub(r\'%([0-9a-fA-F]{2})\', hex_to_char, decoded_url) return decoded_url"},{"question":"# Rotating a List to the Right **Objective**: Implement a function to rotate a given list to the right by a specified number of places. Rotating a list means shifting its elements to the right, with the last element wrapping around to the start of the list. Function Signature ```python def rotate_list(arr: list[int], k: int) -> list[int]: pass ``` Input * `arr` (list of integers): The list to be rotated. * `k` (integer): The number of places to rotate the list to the right. Output * A list of integers representing the rotated list. Constraints * The list will contain between `1` and `10^6` elements. * The integer `k` will be non-negative and can be larger than the length of the list. Requirements * Your solution should handle very large lists and large values of `k` efficiently. * Aim for a solution that handles rotations in O(n) time complexity. Example ```python print(rotate_list([1, 2, 3, 4, 5], 2)) # Output: [4, 5, 1, 2, 3] print(rotate_list([1, 2, 3], 4)) # Output: [3, 1, 2] ``` Additional Scenarios * If `k` is zero, the list should remain unchanged. * Minimal list sizes, such as a list with a single element, should be handled correctly. For example, `rotate_list([1], 1)` should return `[1]`. * Handling cases where `k` is a multiple of the list length should return the original list. For instance, `rotate_list([1, 2, 3], 3)` returns `[1, 2, 3]`. Write your solution in Python, ensuring you include edge case considerations and handle large input sizes efficiently.","solution":"def rotate_list(arr: list[int], k: int) -> list[int]: Rotates the given list to the right by k places. n = len(arr) if n == 0: return arr # If the list is empty, return it unchanged. k = k % n # Handles cases where k is greater than the length of the list. return arr[-k:] + arr[:-k]"},{"question":"# Problem Statement: Peak Element in 2D Array You are given a 2D grid of integers where each integer represents the height of a given cell. Implement a function that finds a \\"peak\\" element. A peak element in this context is a cell that is greater than or equal to all of its adjacent cells (no need to compare diagonally). # Function Signature ```python def find_peak_2d(grid: List[List[int]]) -> Tuple[int, int]: :param grid: 2D list of integers representing the grid. :return: Tuple representing the (row, column) of any one peak element if it exists. ``` # Input * **grid**: A 2D list of dimensions m x n where each cell grid[i][j] is an integer. (1 ≤ m, n ≤ 500) # Output * A tuple (r, c) representing the position (row, column) of a peak element. # Constraints * Your solution should aim for an efficient time complexity, ideally better than O(m * n). * All grid values are distinct. # Example ```python grid = [ [10, 20, 15], [21, 30, 14], [7, 16, 32] ] assert find_peak_2d(grid) == (1, 1) # In this example, 30 is a peak element grid = [ [10, 8, 10, 10], [14, 15, 14, 13], [15, 17, 16, 12], [13, 14, 11, 10] ] assert find_peak_2d(grid) == (2, 1) # In this example, 17 is a peak element ``` # Notes - The function should return any one peak element if multiple peak elements exist. - You can assume that the grid dimensions (m and n) will always be positive integers. - The solution will test your ability to work with 2D arrays and optimize search strategies within constrained input limits.","solution":"from typing import List, Tuple def find_peak_2d(grid: List[List[int]]) -> Tuple[int, int]: def find_peak_in_column(low, high, mid_col): max_row = 0 for i in range(len(grid)): if grid[i][mid_col] > grid[max_row][mid_col]: max_row = i is_peak = True if mid_col > 0 and grid[max_row][mid_col] < grid[max_row][mid_col - 1]: return find_peak_in_column(low, mid_col - 1, (low + mid_col - 1) // 2) if mid_col < len(grid[0]) - 1 and grid[max_row][mid_col] < grid[max_row][mid_col + 1]: return find_peak_in_column(mid_col + 1, high, (mid_col + 1 + high) // 2) return (max_row, mid_col) return find_peak_in_column(0, len(grid[0]) - 1, (len(grid[0]) - 1) // 2)"},{"question":"# Problem Statement: A popular game involves counting the unique ways to decode a string of digits where each digit or pair of digits can be mapped to a letter (\'A\'-\'Z\'). Specifically, \'1\' maps to \'A\', \'2\' to \'B\', ... , \'26\' to \'Z\'. Given a string of digits, determine the number of unique ways it can be decoded into a sequence of letters. Your task is to write a function `numDecodings` that determines the number of possible decodings for a given string of digits. Function Signature: ```python def numDecodings(s: str) -> int: # Your code here ``` Input: * A single string `s` consisting of digits where ( 1 leq text{len}(s) leq 100 ). Output: * An integer representing the number of unique decodings of the given string of digits. Constraints: * The string `s` will only contain valid digits and will not start with \'0\'. # Example: *Example 1*: ```python s = \\"12\\" numDecodings(s) ``` *Output*: ``` 2 ``` *Explanation*: The given string \\"12\\" can be decoded as \\"AB\\" (1 2) or \\"L\\" (12). So, there are 2 possible decodings. *Example 2*: ```python s = \\"226\\" numDecodings(s) ``` *Output*: ``` 3 ``` *Explanation*: The given string \\"226\\" can be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6). Hence, there are 3 possible decodings. *Example 3*: ```python s = \\"06\\" numDecodings(s) ``` *Output*: ``` 0 ``` *Explanation*: The string \\"06\\" is not a valid encoding since decoding cannot start with \'0\'. Therefore, there are 0 possible decodings. Explanation: The goal is to explore all possible ways to decode the string and count them. Use dynamic programming or another efficient method to handle the constraints and ensure your solution is optimal for the upper limit of input length. Consider edge cases and invalid sequences (like \\"06\\" which can\'t be decoded) in your implementation.","solution":"def numDecodings(s: str) -> int: if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 # Base case: An empty string can be decoded in one way for i in range(1, n + 1): single_digit = int(s[i-1:i]) if 1 <= single_digit <= 9: dp[i] += dp[i-1] if i > 1: double_digit = int(s[i-2:i]) if 10 <= double_digit <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"# Problem Statement You need to implement a function called `unique_combinations` that generates all unique combinations of a specified length `k` from a given list of integers. Each combination should be sorted in ascending order and the output should be a list of these unique combinations also sorted in ascending order lexicographically. # Function Signature ```python def unique_combinations(collection: list, k: int) -> list: pass ``` # Input * A mutable list `collection` of integers. The list may contain duplicate values. * An integer `k` representing the size of each combination. # Output * A list of tuples, where each tuple is a unique combination of `k` integers from `collection`, sorted in ascending order. # Example ```python # Example 1 assert unique_combinations([1, 2, 2, 3], 2) == [(1, 2), (1, 3), (2, 2), (2, 3)] # Example 2 assert unique_combinations([4, 4, 4, 1, 4], 2) == [(1, 4), (4, 4)] # Example 3 assert unique_combinations([0, -1, 1], 3) == [(-1, 0, 1)] ``` # Constraints * The size `k` will be an integer such that `0 <= k <= len(collection)`. * The function should handle edge cases like `k` being 0 or the `collection` being empty. * The function should avoid generating duplicate combinations. # Requirements * **Performance**: Ensure the function generates combinations efficiently. * **Correctness**: The function should handle all edge cases and sort the combinations as required. **Hint**: Consider using combinations from the itertools module for generating combinations, and remove duplicates by converting the resulting list to a set before sorting.","solution":"from itertools import combinations def unique_combinations(collection, k): Generates all unique combinations of a specified length `k` from a given list of integers. Each combination is sorted in ascending order and the output is a list of these unique combinations sorted in ascending order lexicographically. Args: collection (list): A mutable list of integers. k (int): The size of each combination. Returns: list: A list of tuples, where each tuple is a unique combination of `k` integers from `collection`, sorted in ascending order. sorted_collection = sorted(collection) combo_set = set(combinations(sorted_collection, k)) unique_combos = sorted(combo_set) return unique_combos"},{"question":"# Problem Statement Create a function named `count_prime_pairs` which takes an integer `n` and returns the number of distinct pairs of prime numbers (p1, p2) such that ( p1 + p2 = n ). Each prime pair should be counted as (p1, p2) where ( p1 leq p2 ). # Input * A single integer `n`, where 1 <= n <= 10^6. # Output * An integer representing the number of distinct prime pairs (p1, p2) such that ( p1 + p2 = n ). # Constraints * Raise a `ValueError` if `n` is not a positive integer. # Performance Requirements * The function should be optimized to handle input values up to 10^6 efficiently. # Example ```python count_prime_pairs(10) # Returns 2 (Pairs: (3,7), (5,5)) count_prime_pairs(26) # Returns 3 (Pairs: (3, 23), (7, 19), (13, 13)) count_prime_pairs(5) # Returns 1 (Pair: (2, 3)) count_prime_pairs(4) # Returns 1 (Pair: (2, 2)) count_prime_pairs(1) # Returns 0 (No pairs) ``` # Hints * Consider using a sieve algorithm to efficiently find all primes up to the value of `n`. * Use a set or other appropriate data structure to store primes for fast lookups.","solution":"def count_prime_pairs(n): Returns the number of distinct pairs of prime numbers (p1, p2) such that p1 + p2 = n. Each prime pair is counted as (p1, p2) where p1 <= p2. if not isinstance(n, int) or n < 1: raise ValueError(\\"Input must be a positive integer\\") def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(limit**0.5) + 1): if is_prime[i]: for j in range(i*i, limit + 1, i): is_prime[j] = False return [i for i, prime in enumerate(is_prime) if prime] primes = sieve_of_eratosthenes(n) prime_set = set(primes) count = 0 for prime in primes: if prime <= n - prime and (n - prime) in prime_set: count += 1 return count"},{"question":"# Coding Assessment Question: Calculating Longest Common Substring Scenario In many fields of computer science, including text processing and bioinformatics, finding the longest common substring among multiple strings is a critical problem. A substring is defined as a contiguous sequence of characters within a string. Task Write a function `longest_common_substring` that returns the longest common substring among the given list of strings. If there is more than one substring with the same maximum length, return the one that appears first. Function Signature ```python def longest_common_substring(strings: List[str]) -> str: pass ``` Input - `strings` (List[str]): A list of strings (at least two, each with at least one character). Output - Returns a string representing the longest common substring. Constraints 1. 2 ≤ len(strings) ≤ 100 2. 1 ≤ len(strings[i]) ≤ 1000 for each string in `strings` Requirements * Implement an efficient algorithm to find the longest common substring. * Handle special cases such as empty results gracefully. Example ```python >>> longest_common_substring([\\"flower\\",\\"flow\\",\\"flight\\"]) \\"fl\\" >>> longest_common_substring([\\"dog\\",\\"racecar\\",\\"car\\"]) \\"\\" >>> longest_common_substring([\\"interview\\",\\"integral\\",\\"internet\\"]) \\"inte\\" ``` Hints - Consider using dynamic programming techniques or suffix trees/arrays for more efficiency. - Think about the edge cases when the common substring might be empty.","solution":"from typing import List def longest_common_substring(strings: List[str]) -> str: def common_substrings(s1, s2): # Start with an empty set result = \\"\\" lengths = [[0] * (1 + len(s2)) for _ in range(1 + len(s1))] longest, x_longest = 0, 0 for x in range(1, 1 + len(s1)): for y in range(1, 1 + len(s2)): if s1[x - 1] == s2[y - 1]: lengths[x][y] = lengths[x - 1][y - 1] + 1 if lengths[x][y] > longest: longest = lengths[x][y] x_longest = x else: lengths[x][y] = 0 return s1[x_longest - longest: x_longest] if not strings: return \\"\\" longest_common = strings[0] for i in range(1, len(strings)): longest_common = common_substrings(longest_common, strings[i]) if not longest_common: break return longest_common"},{"question":"Coding Assessment Question Scenario You are tasked with developing a system to verify the integrity of a list of transactions in a blockchain. Each transaction has a unique identifier (UUID) and an associated timestamp. To ensure that no fraudulent transactions are injected, the order of transactions must strictly follow their timestamps. Your task is to implement an algorithm that verifies the list of transactions and identifies if only a single swap can restore any potential disruption in the order, otherwise deem it unsalvageable. Task Write a Python function `restore_transaction_order(transactions: list) -> Tuple[bool, List[Tuple[str, str]]]` that determines whether it\'s possible to restore the chronological order of the transactions with at most one swap. If a single swap can fix the order, return `True` and the pair of UUIDs of the transactions that need to be swapped. If no such swap can fix the order, return `False` and an empty list. Function Signature ```python def restore_transaction_order(transactions: list) -> Tuple[bool, List[Tuple[str, str]]]: ``` Input - `transactions`: a list of dictionaries where each dictionary represents a transaction with the keys: - `\'uuid\'`: a string representing the unique identifier of the transaction. - `\'timestamp\'`: a string in the format `\'YYYY-MM-DDTHH:MM:SS\'` representing the timestamp of the transaction. Output - Return a tuple containing a boolean and a list of tuples. The boolean indicates whether the order can be restored with at most one swap. The list consists of one tuple with the UUIDs of the transactions that need to be swapped to fix the order, or an empty list if restoring order is not possible with a single swap. Constraints - The length of the `transactions` list will be between 2 and 10^5. - Timestamps are assumed to be in ISO 8601 format. - UUIDs are unique and non-empty strings. Examples ```python >>> transactions = [ ... {\'uuid\': \'a1\', \'timestamp\': \'2023-01-01T10:00:00\'}, ... {\'uuid\': \'b2\', \'timestamp\': \'2023-01-01T09:00:00\'}, ... {\'uuid\': \'c3\', \'timestamp\': \'2023-01-01T11:00:00\'} ... ] >>> restore_transaction_order(transactions) (True, [(\'a1\', \'b2\')]) >>> transactions = [ ... {\'uuid\': \'a1\', \'timestamp\': \'2023-01-01T10:00:00\'}, ... {\'uuid\': \'b2\', \'timestamp\': \'2023-01-01T09:00:00\'}, ... {\'uuid\': \'c3\', \'timestamp\': \'2023-01-01T12:00:00\'}, ... {\'uuid\': \'d4\', \'timestamp\': \'2023-01-01T11:00:00\'} ... ] >>> restore_transaction_order(transactions) (False, []) >>> transactions = [ ... {\'uuid\': \'a1\', \'timestamp\': \'2023-01-01T10:00:00\'}, ... {\'uuid\': \'b2\', \'timestamp\': \'2023-01-01T11:00:00\'}, ... {\'uuid\': \'c3\', \'timestamp\': \'2023-01-01T12:00:00\'} ... ] >>> restore_transaction_order(transactions) (True, []) ``` Requirements - Ensure the function handles all edge cases, including when the list is already sorted or cannot be sorted by a single swap. - Provide efficient performance given the possible input size.","solution":"def restore_transaction_order(transactions): n = len(transactions) if n < 2: return True, [] # Convert timestamps to sortable format and collect UUIDs sorted_transactions = sorted(transactions, key=lambda x: x[\'timestamp\']) wrong_indices = [] for i in range(n): if transactions[i][\'timestamp\'] != sorted_transactions[i][\'timestamp\']: wrong_indices.append(i) # If no misplaced transactions if len(wrong_indices) == 0: return True, [] # If more than 2 misplaced transactions, no single swap can solve it if len(wrong_indices) != 2: return False, [] i, j = wrong_indices transactions[i], transactions[j] = transactions[j], transactions[i] return (True, [(transactions[j][\'uuid\'], transactions[i][\'uuid\'])] if sorted_transactions == sorted(transactions, key=lambda x: x[\'timestamp\']) else (False, []))"},{"question":"# Coding Assessment Question Context You are given a 2D grid representing a map, where each cell contains a non-negative integer representing the cost to move through that cell. Your goal is to find the minimum cost path from the top-left corner to the bottom-right corner of the grid. You can only move right or down from a cell. Task Write a function `min_cost_path(grid: List[List[int]]) -> int` that computes the minimum cost path from the top-left to the bottom-right of the grid. The grid is represented as a list of lists of integers. Input Format * `grid`: A 2D list of non-negative integers representing the cost grid. (e.g., `[[1, 3, 1], [1, 5, 1], [4, 2, 1]]`) Output Format * Return an integer representing the minimum cost to reach the bottom-right corner from the top-left corner of the grid. Constraints * The grid dimensions are `m x n` where `1 ≤ m, n ≤ 100`. * Each cell value is a non-negative integer not exceeding 1000. Example ```python grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]] print(min_cost_path(grid)) # Output: 7 ``` Performance Requirements * The solution should efficiently handle the provided constraints with a complexity of O(m * n). Edge Cases to Consider * Grid of size 1x1. * Grid with rows or columns consisting of a single line of cells. * Grid where the movement cost is uniformly the same across all cells. * Grid with the minimum and maximum possible cell values.","solution":"from typing import List def min_cost_path(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"# Coding Assessment Question Context You are given a code snippet that reads a large CSV file containing millions of rows and performs some data manipulations before calculating a metric. The current implementation is inefficient, leading to high memory consumption and longer processing times. Task Your task is to optimize the code to handle large datasets efficiently by implementing the following improvements: 1. **Chunk Processing**: Modify the code to read and process the CSV file in chunks rather than loading the entire file into memory. 2. **Vectorized Operations**: Implement vectorized operations instead of iterative row-by-row manipulations to improve performance. 3. **Memory Management**: Ensure to properly manage memory usage to prevent the program from crashing due to high memory consumption. Function Signature ```python import pandas as pd def process_large_csv(file_path: str, chunk_size: int): Optimized CSV processing in chunks with vectorized operations. Parameters: file_path (str): The path to the large CSV file. chunk_size (int): Number of rows to read per chunk. Outputs: The function should print the calculated metric. ``` Input * **file_path (str)**: The path to the large CSV file. * **chunk_size (int)**: Number of rows to read per chunk. Output * The function should print the calculated metric after processing the entire file. Constraints * Use efficient file handling to accommodate large datasets. * Implement vectorized operations using libraries like `pandas` to speed up the processing. * Ensure the code is robust and handles potential issues related to file reading and memory management. Example ```python # Call the function with file path and chunk size process_large_csv(file_path=\\"large_dataset.csv\\", chunk_size=10000) ``` **Expected Outcome**: The function should process the file in chunks, perform the required data manipulations efficiently using vectorized operations, and print the calculated metric without consuming excessive memory. Good luck!","solution":"import pandas as pd def process_large_csv(file_path: str, chunk_size: int): Optimized CSV processing in chunks with vectorized operations. Parameters: file_path (str): The path to the large CSV file. chunk_size (int): Number of rows to read per chunk. Outputs: The function should print the calculated metric. aggregate_metric = 0 total_rows = 0 for chunk in pd.read_csv(file_path, chunksize=chunk_size): # Example of vectorized operation: calculate the sum of a column chunk_sum = chunk[\'column_name\'].sum() # Replace \'column_name\' with the actual column name aggregate_metric += chunk_sum total_rows += len(chunk) # Can perform other vectorized operations on the chunk here if total_rows > 0: calculated_metric = aggregate_metric / total_rows else: calculated_metric = 0 print(f\\"Calculated Metric: {calculated_metric}\\")"},{"question":"# Parcel Sorting System **Context:** In a warehouse, parcels need to be sorted efficiently. Given different delivery routes with multiple parcels, the goal is to keep track of the total weight and maximum weight of parcels for each route to streamline load distribution and ensure safety compliance. **Task:** Implement the `ParcelSorter` class that can perform the following operations: 1. **add_parcel(route_id: int, weight: int) -> None** - Adds a parcel with a specified weight to a given route. The route is denoted by `route_id`. 2. **total_weight(route_id: int) -> int** - Returns the total weight of all parcels on the given route. 3. **max_parcel_weight(route_id: int) -> int** - Returns the weight of the heaviest parcel on the given route. **Specifications:** 1. **Method Signatures:** - `def add_parcel(self, route_id: int, weight: int) -> None` - `def total_weight(self, route_id: int) -> int` - `def max_parcel_weight(self, route_id: int) -> int` 2. **Constraints:** - `1 <= route_id <= 10^5` - `1 <= weight <= 10^4` 3. **Expected Time Complexity:** - Ensure operations can handle up to `10^5` parcels being added and queried efficiently. **Example Usage:** ```python P = ParcelSorter() P.add_parcel(1, 10) P.add_parcel(1, 20) P.add_parcel(2, 5) print(P.total_weight(1)) # 30 print(P.max_parcel_weight(1)) # 20 print(P.total_weight(2)) # 5 print(P.max_parcel_weight(2)) # 5 P.add_parcel(1, 50) print(P.total_weight(1)) # 80 print(P.max_parcel_weight(1)) # 50 ``` **Performance Requirements:** - Ensure that adding a parcel and querying the total and maximum weights for each route are efficient, considering the high number of possible routes and parcels.","solution":"class ParcelSorter: def __init__(self): # Initialize dictionaries to keep track of total weights and max weights for each route self.total_weights = {} self.max_weights = {} def add_parcel(self, route_id: int, weight: int) -> None: # Add the weight to the total weight of the route if route_id in self.total_weights: self.total_weights[route_id] += weight else: self.total_weights[route_id] = weight # Update the max weight of the route if necessary if route_id in self.max_weights: self.max_weights[route_id] = max(self.max_weights[route_id], weight) else: self.max_weights[route_id] = weight def total_weight(self, route_id: int) -> int: # Return the total weight of the route return self.total_weights.get(route_id, 0) def max_parcel_weight(self, route_id: int) -> int: # Return the max weight of the route return self.max_weights.get(route_id, 0)"},{"question":"# Problem Statement You are implementing a vending machine that provides snacks based on the amount of money inserted by the user. The machine has a predefined inventory of snacks, their prices, and quantities. Your task is to write a function named `vending_machine` that takes an amount of money and a requested snack ID, and returns the snack as well as any change returned to the user. If the transaction is not possible due to insufficient funds or the snack being out of stock, return an appropriate error message. # Function Signature ```python def vending_machine(money: float, snack_id: int) -> tuple[str, float]: ``` # Input - `money`: A float representing the amount of money inserted by the user. - `snack_id`: An integer representing the ID of the snack the user wishes to purchase. # Output - A tuple (str, float) where `str` is the name of the snack and `float` is the change returned to the user. - If the snack is out of stock, return a tuple (\\"Out of stock\\", 0.0). - If the money is insufficient, return a tuple (\\"Insufficient funds\\", 0.0). # Snaps Inventory ```python inventory = { 1: {\\"name\\": \\"Chips\\", \\"price\\": 2.50, \\"quantity\\": 10}, 2: {\\"name\\": \\"Soda\\", \\"price\\": 1.75, \\"quantity\\": 15}, 3: {\\"name\\": \\"Candy Bar\\", \\"price\\": 1.25, \\"quantity\\": 5}, 4: {\\"name\\": \\"Cookies\\", \\"price\\": 3.00, \\"quantity\\": 0}, 5: {\\"name\\": \\"Juice\\", \\"price\\": 2.00, \\"quantity\\": 7}, } ``` # Constraints - `money` will be a non-negative float. - `snack_id` will be an integer between 1 and 5 inclusive. - Ensure all calculations for change are handled to avoid floating-point inaccuracies. # Examples ```python >>> vending_machine(5.00, 1) (\'Chips\', 2.50) >>> vending_machine(1.00, 2) (\'Insufficient funds\', 0.0) >>> vending_machine(2.50, 4) (\'Out of stock\', 0.0) >>> vending_machine(1.50, 3) (\'Candy Bar\', 0.25) >>> vending_machine(2.00, 5) (\'Juice\', 0.0) ``` # Error Handling - If the provided `snack_id` does not exist in the inventory, the function should return a tuple (\\"Invalid snack ID\\", 0.0). - If the input is not valid (i.e., `money` is negative or `snack_id` is out of range), the function should return a tuple (\\"Invalid input\\", 0.0). This problem tests your ability to handle inventory management, perform basic arithmetic operations, and deal with edge cases while ensuring accurate financial transactions.","solution":"def vending_machine(money: float, snack_id: int) -> tuple[str, float]: # Inventory of snacks inventory = { 1: {\\"name\\": \\"Chips\\", \\"price\\": 2.50, \\"quantity\\": 10}, 2: {\\"name\\": \\"Soda\\", \\"price\\": 1.75, \\"quantity\\": 15}, 3: {\\"name\\": \\"Candy Bar\\", \\"price\\": 1.25, \\"quantity\\": 5}, 4: {\\"name\\": \\"Cookies\\", \\"price\\": 3.00, \\"quantity\\": 0}, 5: {\\"name\\": \\"Juice\\", \\"price\\": 2.00, \\"quantity\\": 7}, } if not isinstance(money, (int, float)) or not isinstance(snack_id, int): return (\\"Invalid input\\", 0.0) if money < 0 or snack_id not in inventory: return (\\"Invalid input\\", 0.0) snack = inventory[snack_id] if snack[\\"quantity\\"] == 0: return (\\"Out of stock\\", 0.0) if money < snack[\\"price\\"]: return (\\"Insufficient funds\\", 0.0) change = round(money - snack[\\"price\\"], 2) return (snack[\\"name\\"], change)"},{"question":"# String Manipulation and Pattern Matching Problem Statement You are tasked with writing a function to count occurrences of a pattern in a given text, taking into consideration overlapping patterns. The function should use a sliding window approach to efficiently find all occurrences, even if they overlap. Function to Implement Implement the function `count_pattern_occurrences` which takes the following parameters: 1. **text**: A string representing the text in which to search for the pattern. 2. **pattern**: A string representing the pattern to search for within the text. The function should return an integer representing the number of times the pattern occurs in the text, counting overlaps. Example Input ```python text = \\"abababa\\" pattern = \\"aba\\" ``` Example Output ```python 3 ``` Constraints - The length of the text will be between 1 and 10^5 characters. - The length of the pattern will be between 1 and 100 characters. - The text and pattern will only contain lowercase English letters. Additional Information Efficiently handle the input size by avoiding unnecessary re-computation of overlapping parts of the text. ```python def count_pattern_occurrences(text, pattern): Count occurrences of the pattern in the text, including overlapping ones. :param text: The string in which to search for the pattern :param pattern: The string pattern to search for :return: The count of occurrences of the pattern in the text including overlaps # Your implementation here pass ``` Notes - Implement an efficient algorithm for pattern matching by leveraging the sliding window approach. - Ensure that the function performs well with the upper bound of input sizes.","solution":"def count_pattern_occurrences(text, pattern): Count occurrences of the pattern in the text, including overlapping ones. :param text: The string in which to search for the pattern :param pattern: The string pattern to search for :return: The count of occurrences of the pattern in the text including overlaps count = 0 pattern_length = len(pattern) text_length = len(text) for i in range(text_length - pattern_length + 1): if text[i:i + pattern_length] == pattern: count += 1 return count"},{"question":"**Objective**: Write a function that finds the longest path in a tree represented by an adjacency list, where each node has a unique value. **Function Signature**: ```python def longest_path(tree: Dict[int, List[int]], root: int) -> int: pass ``` **Input Format**: - `tree`: A dictionary where keys are integers representing node values and values are lists of integers representing the values of adjacent nodes. - `root`: An integer representing the root node of the tree. **Output Format**: - An integer representing the length of the longest path between any two nodes in the tree. **Constraints**: - The tree will have at least one node. - Nodes are uniquely identified by integer values. - Adjacency lists may be empty, indicating leaf nodes. **Performance Requirements**: - The function should have a time complexity of (O(V + E)), where (V) is the number of vertices and (E) is the number of edges. **Example**: ```python tree = { 1: [2, 3], 2: [4, 5], 3: [], 4: [], 5: [] } root = 1 longest_path(tree, root) # Expected output: 3 ``` **Scenario**: Imagine you are given the structure of a biological tree representing gene mutations, where each node represents a mutation, and edges represent direct mutative relationships. Your task is to determine the longest sequence of mutative relationships, starting at the root mutation and potentially ending at any other mutation node in the tree. This will help identify the maximum evolutionary distance within the gene mutation tree. Your implementation should traverse the tree efficiently, considering all possible paths to find the longest one, and return its length.","solution":"def longest_path(tree: dict, root: int) -> int: def dfs(node: int) -> int: if node not in tree or not tree[node]: return 0 max_depth = 0 for child in tree[node]: max_depth = max(max_depth, dfs(child)) return max_depth + 1 if not tree or root is None: return 0 return dfs(root)"},{"question":"# Coding Question: Efficient Matrix Multiplication with Constraints **Context**: Matrix multiplication is a fundamental operation in various fields, including computer graphics, scientific computations, and machine learning. However, the time complexity of matrix multiplication can be quite high. Optimizing this process for specific constraints can significantly enhance performance. Your task is to efficiently implement matrix multiplication given two matrices, while respecting some constraints on matrix dimensions and element values. **Function Signature**: ```python def efficient_matrix_multiplication(A: list[list[int]], B: list[list[int]]) -> list[list[int]]: ``` **Inputs**: 1. `A` (list of list of int): A 2D list representing matrix A with dimensions m x n. 2. `B` (list of list of int): A 2D list representing matrix B with dimensions n x p. **Output**: A 2D list representing the result of the matrix multiplication A * B with dimensions m x p. **Constraints**: * 1 <= m, n, p <= 100 * -100 <= elements of A, B <= 100 * Matrix A\'s number of columns (n) must match matrix B\'s number of rows (n). **Example**: ```python >>> efficient_matrix_multiplication([[1, 2], [3, 4]], [[5, 6], [7, 8]]) [[19, 22], [43, 50]] >>> efficient_matrix_multiplication([[2, 0], [1, 2]], [[1, 2], [3, 4]]) [[2, 4], [7, 10]] >>> efficient_matrix_multiplication([[-1, -2], [-3, -4]], [[-5, -6], [-7, -8]]) [[19, 22], [43, 50]] ``` **Requirements**: 1. Validate input dimensions to ensure matrix multiplication is feasible. 2. Implement the matrix multiplication algorithm optimized for the given constraints. 3. Handle edge cases such as matrices filled with zeros or negatives effectively.","solution":"def efficient_matrix_multiplication(A, B): Perform matrix multiplication of matrices A and B. Parameters: A (list of list of int): matrix A with dimensions m x n B (list of list of int): matrix B with dimensions n x p Returns: list of list of int: Resultant matrix of dimensions m x p m = len(A) n = len(A[0]) p = len(B[0]) # Initialize the result matrix with zeros result = [[0] * p for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"# Coding Assessment Question Context: The Fibonacci sequence is a series of numbers in which each number (Fibonacci number) is the sum of the two preceding ones, usually starting with `0` and `1`. That is: - F(0) = 0 - F(1) = 1 - For n ≥ 2, F(n) = F(n-1) + F(n-2) Problem Statement: Given an integer `N`, calculate the sum of the even-valued terms in the Fibonacci sequence that do not exceed `N`. Function Signature: ```python def sum_even_fibonacci(N: int) -> int: pass ``` Input: - An integer `N` (1 ≤ N ≤ 4,000,000), representing the upper bound for Fibonacci terms considered. Output: - An integer, representing the sum of the even-valued Fibonacci numbers not exceeding `N`. Example: 1. **Input**: `N = 10` **Output**: `10` (The even Fibonacci numbers <= 10 are 2, 8, and their sum is 10) 2. **Input**: `N = 4000000` **Output**: `4613732` (The even Fibonacci numbers <= 4000000 are 2, 8, 34, 144, 610, 2584, 10946, 46368, 196418, 832040, 3524578, and their sum is 4613732) Constraints: - Aim for an efficient solution, ideally with a linear time complexity O(n). Note: - Consider using only the even-valued terms in your loop or computation. This can help reduce unnecessary calculations. Write the Python function to solve this problem. ```python def sum_even_fibonacci(N: int) -> int: sum_even_terms = 0 a, b = 0, 1 while b <= N: if b % 2 == 0: sum_even_terms += b a, b = b, a + b return sum_even_terms ```","solution":"def sum_even_fibonacci(N: int) -> int: sum_even_terms = 0 a, b = 0, 1 while b <= N: if b % 2 == 0: sum_even_terms += b a, b = b, a + b return sum_even_terms"},{"question":"# Problem Statement: Context: Given a list of integers, a \\"rotated sorted array\\" is defined as a sorted array that has been rotated at some pivot point. For example, the array `[4, 5, 6, 7, 0, 1, 2]` is a rotation of the sorted array `[0, 1, 2, 4, 5, 6, 7]`. Your task is to identify the pivot point index where the sorted array was rotated. Task: 1. Implement the `find_pivot(arr: list) -> int` function to determine the index of the smallest element in a rotated sorted array. 2. Enhance the function to handle arrays containing duplicates efficiently. Function Signature: ```python def find_pivot(arr: list) -> int ``` Input Formats: - `find_pivot(arr)`: A list of integers. Output Formats: - Returns an integer, the index of the pivot point in the array. Constraints: - The input list will have a length of up to 10,000 elements. - Elements in the array can be negative or positive integers. - The array may contain duplicate values. - The original sorted array does not have duplicate values. Example: ```python # Example inputs for find_pivot print(find_pivot([4, 5, 6, 7, 0, 1, 2])) # 4 print(find_pivot([6, 7, 9, 15, 2, 3, 5])) # 4 print(find_pivot([4, 5, 1, 2, 2, 2, 3])) # 2 # Example input for an array with no rotation print(find_pivot([1, 2, 3, 4, 5, 6])) # 0 ``` Performance Requirements: - Ensure efficient computation with minimal time complexity. - Properly handle edge cases and possibly empty arrays. Implementation Details: - Use a binary search approach to find the pivot index. - Consider edge cases like arrays of length 1, arrays with all identical elements, and already sorted arrays.","solution":"def find_pivot(arr): Determine the index of the smallest element in a rotated sorted array. Handles cases with duplicates efficiently. if not arr: return -1 # Return -1 for empty list as it doesn\'t have a pivot low, high = 0, len(arr) - 1 # Handle the case where the array is not rotated if arr[low] < arr[high]: return low while low < high: mid = (low + high) // 2 if mid > 0 and arr[mid] < arr[mid - 1]: return mid if arr[mid] > arr[high]: low = mid + 1 elif arr[mid] < arr[high]: high = mid else: # arr[mid] == arr[high], cannot decide the side, reduce high by 1 high -= 1 return low"},{"question":"# Question: Implement an Efficient Fibonacci Sequence Generator The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. The task is to implement an efficient algorithm to generate the nth Fibonacci number. Objective Write an optimized function that returns the nth Fibonacci number using an efficient method. Expected Input and Output * **Input**: An integer `n`. ```python int ``` * **Output**: The nth Fibonacci number. ```python int ``` Constraints * The input integer `n` will be within the range `1 <= n <= 90`. * The output should be the nth Fibonacci number. Performance Requirements * Time complexity: O(log n) * Space complexity: O(1) Scenario You are a software engineer developing a high-performance module for a financial forecasting application. This module requires the computation of Fibonacci numbers for accurate predictions and needs to handle large values of `n` efficiently. # Your Task: Write a Python function `fibonacci_generator` that takes an integer `n` and returns the nth Fibonacci number using an efficient algorithm. ```python def fibonacci_generator(n): :param n: integer :return: nth Fibonacci number # Implement your efficient Fibonacci sequence generator logic here pass ``` **Note**: Do not use simple recursion due to its exponential time complexity. Focus on optimizing the solution with techniques like matrix exponentiation or iterative methods. **Example**: ```python >>> fibonacci_generator(10) 55 >>> fibonacci_generator(50) 12586269025 ```","solution":"def fibonacci_generator(n): Efficiently calculates the nth Fibonacci number using matrix exponentiation. :param n: integer :return: nth Fibonacci number if n == 0: return 0 if n == 1: return 1 def matrix_mult(A, B): return [[A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]]] def matrix_pow(mat, exp): result = [[1, 0], [0, 1]] # Identity matrix base = mat while exp > 0: if exp % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) exp //= 2 return result # Initial Fibonacci matrix F = [[1, 1], [1, 0]] # Exponentiate the matrix to (n-1) result = matrix_pow(F, n-1) # The nth Fibonacci number is in the top left cell of the result matrix return result[0][0]"},{"question":"# Coding Assessment Question Context In this exercise, you will deal with analyzing strings and creating new strings based on specific patterns. This type of problem is common in text processing and has applications in data formatting, encryption, and more. Problem Statement Write a function `serial_concatenation(s: str, k: int) -> str` that returns a new string formed by serially concatenating the characters from the given string `s` in groups of `k`. If there are remaining characters that do not complete a group, place them at the end in the given order. Constraints * The function parameter `s` is a non-empty string consisting of lowercase letters. * The function parameter `k` is an integer between 1 and the length of `s`. Input * A string `s`. * An integer `k`. Output * A new string formed by concatenating characters in groups of `k`. Examples * `serial_concatenation(\\"abcdefgh\\", 2)` should return `\\"abetectionarationcddefgh\\"`. * `serial_concatenation(\\"interesting\\", 3)` should return `\\"inteinterestrigationesting\\"`. * `serial_concatenation(\\"xyz\\", 1)` should return `\\"xyzyz\\"`. * `serial_concatenation(\\"abcdefgh\\", 4)` should return `\\"abcdabcdationtermination\\"\',. Function Signature ```python def serial_concatenation(s: str, k: int) -> str: pass ``` Requirements * Ensure that the code correctly handles varying lengths of the input string and different values of `k`. * Optimize for time and space complexity where possible. * Include appropriate test cases to verify correctness of your implementation.","solution":"def serial_concatenation(s: str, k: int) -> str: Returns a new string formed by serially concatenating the characters from the given string `s` in groups of `k`. If there are remaining characters that do not complete a group, place them at the end in the given order. # Create a list to store segments of the string segments = [s[i:i+k] for i in range(0, len(s), k)] # Join the segments to form the result string result = \'\'.join(segments) return result"},{"question":"# Coding Assessment Question: String Manipulation and Validation Objective Create a pair of functions to manipulate and validate strings based on specified criteria and constraints. Problem Statement You are given various sets of strings. Your task is to: 1. Write a function `validate_strings(strings: list, valid_chars: set) -> list` that checks if each string in `strings` contains only characters from `valid_chars`. 2. Write a function `reverse_vowels(s: str) -> str` that reverses only the vowels in the input string `s`. Requirements 1. **validate_strings**: * For each string in the input list, return `True` if every character in the string is part of `valid_chars`, otherwise return `False`. * The output should be a list of boolean values corresponding to each string in the input list. 2. **reverse_vowels**: * Identify the vowels in the input string `s`. * Reverse the positions of the vowels, keeping all other characters in their original positions. * Consider `\'a\', \'e\', \'i\', \'o\', \'u\'` (both lowercase and uppercase) as vowels. Example ```python def validate_strings(strings: list, valid_chars: set) -> list: # Your implementation here def reverse_vowels(s: str) -> str: # Your implementation here # Example usage: strings = [\\"hello\\", \\"world\\", \\"123\\", \\"h!\\"] valid_chars = {\'h\', \'e\', \'l\', \'o\'} print(validate_strings(strings, valid_chars)) # Output: [True, False, False, False] s = \\"hello world\\" print(reverse_vowels(s)) # Output: \\"holle werld\\" ``` Constraints * The length of the input list `strings` will be at least 1 and at most (10^5). * Each string in `strings` will have a length of at least 1 and at most (10^3). * The length of the input string `s` will be at least 1 and at most (10^4). * The input strings may contain any printable ASCII characters.","solution":"def validate_strings(strings: list, valid_chars: set) -> list: Validates each string in the list to contain only characters from valid_chars. return [all(char in valid_chars for char in s) for s in strings] def reverse_vowels(s: str) -> str: Reverses only the vowels in the input string s. vowels = \\"aeiouAEIOU\\" s_list = list(s) left, right = 0, len(s) - 1 while left < right: if s_list[left] not in vowels: left += 1 elif s_list[right] not in vowels: right += 1 else: s_list[left], s_list[right] = s_list[right], s_list[left] left += 1 right -= 1 return \\"\\".join(s_list)"},{"question":"# Coding Task: Implement a Decision Tree Classifier from Scratch Description You are given a dataset where each sample belongs to one of two classes. Your task is to implement a basic Decision Tree Classifier from scratch using the CART (Classification and Regression Trees) algorithm. The Decision Tree should use Gini impurity as the criterion to split nodes. The goal is to correctly classify the samples in a test set based on the trained decision tree. Requirements 1. Implement the `DecisionTree` class. 2. The class should contain methods to fit the model and predict new data points. 3. Your implementation should handle numerical features and binary class labels. Input Format 1. Training data as a numpy ndarray where rows represent samples and columns represent features. The last column indicates the class (0 or 1). 2. Test data as a numpy ndarray where rows represent samples and columns represent features (without class labels). Output Format An array of predictions as (0 or 1) for the given test samples. Constraints 1. Implement the tree structure manually — do not use existing libraries such as `sklearn`. 2. The tree should be able to handle overfitting by using a maximum depth parameter. Example ```python import numpy as np # Training data train_data = np.array([ [2, 3, 0], [3, 4, 0], [1, 1, 1], [2, 2, 1] ]) # Test data test_samples = np.array([ [3, 3], [1, 2] ]) # Decision Tree Model Initialization decision_tree = DecisionTree(max_depth=3) # Fitting the model decision_tree.fit(train_data) # Predicting predictions = decision_tree.predict(test_samples) print(predictions) # Expected Output: array([0, 1]) ``` Implement the `DecisionTree` class based on the given example above.","solution":"import numpy as np class DecisionTree: def __init__(self, max_depth=10): self.max_depth = max_depth self.tree = None def fit(self, data): self.tree = self._build_tree(data, depth=0) def predict(self, X): return np.array([self._predict_single(x, self.tree) for x in X]) def _build_tree(self, data, depth): if len(set(data[:, -1])) == 1 or depth == self.max_depth: return self._create_leaf(data) split_column, split_value, left_data, right_data = self._find_best_split(data) if len(left_data) == 0 or len(right_data) == 0: return self._create_leaf(data) left_branch = self._build_tree(left_data, depth + 1) right_branch = self._build_tree(right_data, depth + 1) return (split_column, split_value, left_branch, right_branch) def _create_leaf(self, data): labels, counts = np.unique(data[:, -1], return_counts=True) return labels[np.argmax(counts)] def _find_best_split(self, data): best_gini = float(\'inf\') best_column = None best_value = None best_splits = (None, None) n_columns = data.shape[1] - 1 # exclude label for column in range(n_columns): values = data[:, column] for value in np.unique(values): left_mask = data[:, column] <= value right_mask = ~left_mask if left_mask.sum() == 0 or right_mask.sum() == 0: continue left_data = data[left_mask] right_data = data[right_mask] gini = self._gini_impurity(left_data, right_data) if gini < best_gini: best_gini = gini best_column = column best_value = value best_splits = (left_data, right_data) return best_column, best_value, best_splits[0], best_splits[1] def _gini_impurity(self, left_data, right_data): total_samples = len(left_data) + len(right_data) def calculate_gini(data): labels, counts = np.unique(data[:, -1], return_counts=True) impurity = 1.0 for count in counts: prob = count / len(data) impurity -= prob ** 2 return impurity gini_left = calculate_gini(left_data) gini_right = calculate_gini(right_data) weighted_gini = (len(left_data) / total_samples) * gini_left + (len(right_data) / total_samples) * gini_right return weighted_gini def _predict_single(self, x, tree): if not isinstance(tree, tuple): return tree column, value, left, right = tree if x[column] <= value: return self._predict_single(x, left) else: return self._predict_single(x, right)"},{"question":"# Question In this task, you are required to implement a function called `find_rectangles` which calculates the number of rectangles that can be formed within a given grid. Function Signature ```python def find_rectangles(rows: int, cols: int) -> int: ... ``` # Input - `rows` (int): The number of rows in the grid. - `cols` (int): The number of columns in the grid. # Output - (int): The total number of rectangles that can be formed using the grid intersections. # Constraints - `1 <= rows <= 1000` - `1 <= cols <= 1000` Example ```python res = find_rectangles(2, 3) # Expected output: 18 print(res) # Output should be 18 res = find_rectangles(4, 4) # Expected output: 100 print(res) # Output should be 100 ``` # Requirements 1. Understand the formula for calculating the total number of rectangles in a grid. 2. Implement efficient code to handle the upper limits of the constraints. 3. Ensure that the function limits potential overflow issues with large input values. # Explanation - For a grid with `rows` x `cols`, the number of rectangles that can be formed is calculated using the formula: [ text{Total Rectangles} = left(frac{rows cdot (rows + 1)}{2}right) cdot left(frac{cols cdot (cols + 1)}{2}right) ] - This formula derives from selecting two distinct horizontal lines from `rows+1` options and two distinct vertical lines from `cols+1` options. The product of these choices gives the total number of possible rectangles.","solution":"def find_rectangles(rows: int, cols: int) -> int: Calculate the number of rectangles that can be formed in a grid with given rows and columns. Parameters: rows (int): The number of rows in the grid. cols (int): The number of columns in the grid. Returns: int: The total number of rectangles that can be formed. # Total rectangles formula: (rows * (rows + 1) / 2) * (cols * (cols + 1) / 2) total_rectangles = (rows * (rows + 1) // 2) * (cols * (cols + 1) // 2) return total_rectangles"},{"question":"# Implementation Question: Enhanced Palindrome Checker with Ignorable Characters **Problem Statement**: You are given a function `is_palindrome` that checks if a given string is a palindrome, ignoring all non-alphanumeric characters and being case-insensitive. Extend this function to handle additional specifications. Specifically, your enhanced function should: 1. Ignore characters listed in a provided set of ignorable characters, in addition to non-alphanumeric characters. 2. Be case-insensitive. 3. Efficiently determine if the input string is a palindrome without constructing excessive intermediate copies of the string. **Function Signature**: ```python def enhanced_is_palindrome(input_str: str, ignorable_chars: set) -> bool: Checks if the input string is a palindrome, ignoring given ignorable characters and checking in a case-insensitive manner. Parameters: input_str (str): The string to be checked. ignorable_chars (set): A set of characters that should be ignored in the palindrome check. Returns: bool: True if the string is a palindrome ignoring the ignorable characters, otherwise False. Raises: ValueError: When the input is not a string. pass ``` **Input/Output Examples**: ```python >>> enhanced_is_palindrome(\\"A man, a plan, a canal, Panama!\\", {\\" \\"}) True >>> enhanced_is_palindrome(\\"No \'x\' in Nixon\\", {\\"\'\\", \\" \\"}) True >>> enhanced_is_palindrome(\\"Was it a car or a cat I saw?\\", set()) True >>> enhanced_is_palindrome(\\"Hello, World!\\", {\\",\\"}) False >>> enhanced_is_palindrome(\\"MadamInEdenImAdam\\", {\\"I\\", \\"m\\"}) False >>> enhanced_is_palindrome(12345, set()) Traceback (most recent call last): ... ValueError: Expected string as input, found <class \'int\'> ``` **Constraints**: * The input must be a string. * The set of characters to be ignored must contain only characters that are 1-length strings. * The length of the input string will be between 0 and 10^5 characters. # Hints: 1. Use two-pointer technique to efficiently check for palindrome properties. 2. Ensure to handle edge cases such as empty strings and strings with only ignorable characters.","solution":"def enhanced_is_palindrome(input_str: str, ignorable_chars: set) -> bool: Checks if the input string is a palindrome, ignoring given ignorable characters and checking in a case-insensitive manner. Parameters: input_str (str): The string to be checked. ignorable_chars (set): A set of characters that should be ignored in the palindrome check. Returns: bool: True if the string is a palindrome ignoring the ignorable characters, otherwise False. Raises: ValueError: When the input is not a string. if not isinstance(input_str, str): raise ValueError(f\\"Expected string as input, found {type(input_str)}\\") left, right = 0, len(input_str) - 1 ignorable_chars = set(ignorable_chars) # Ensure set to ignore duplicates while left < right: while left < right and (not input_str[left].isalnum() or input_str[left] in ignorable_chars): left += 1 while left < right and (not input_str[right].isalnum() or input_str[right] in ignorable_chars): right -= 1 if left < right and input_str[left].lower() != input_str[right].lower(): return False left += 1 right -= 1 return True"},{"question":"# String Compression Algorithm You are tasked with implementing a method that performs basic string compression using the counts of repeated characters. For example, the string \\"aabcccccaaa\\" would be compressed to \\"a2b1c5a3\\". If the compressed string would not become smaller than the original string, your method should return the original string. **Task**: Add the following method to the `StringCompressor` class: ```python def compress_string(self, input_string): Compresses the string using counts of repeated characters. :param input_string: The original string to be compressed. :return: The compressed string or the original string if compression does not reduce the size. compressed = [] count_consecutive = 0 for i in range(len(input_string)): count_consecutive += 1 if (i + 1 >= len(input_string)) or (input_string[i] != input_string[i + 1]): compressed.append(f\'{input_string[i]}{count_consecutive}\') count_consecutive = 0 compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(input_string) else input_string ``` **Objective**: You need to define this method to efficiently count consecutive characters in a string and construct the compressed form as specified. Ensure your implementation correctly handles edge cases such as empty strings and strings with no consecutive characters. **Input/Output**: * **Input**: A single `input_string` (string). * **Output**: A compressed string or the original string based on the conditions provided. **Constraints**: * The input string\'s length will be at most (10^5). * The input string will contain only lowercase alphabetic characters. **Performance**: Ensure your implementation processes the string in linear time relative to its length. **Scenario**: You are working on a data compression tool that helps to reduce the size of strings by encoding repeated characters. This algorithm is critical for effectively storing and transmitting text data. Example: ```python # Given input string input_string = \\"aabcccccaaa\\" # Expected Output # Compressed string: \\"a2b1c5a3\\" ``` ```python # Given input string input_string = \\"abcdef\\" # Expected Output # Compressed string: \\"abcdef\\" (since compression wouldn\'t reduce the length) ```","solution":"class StringCompressor: def compress_string(self, input_string): Compresses the string using counts of repeated characters. :param input_string: The original string to be compressed. :return: The compressed string or the original string if compression does not reduce the size. if not input_string: return input_string compressed = [] count_consecutive = 0 for i in range(len(input_string)): count_consecutive += 1 # If next character is different than current, append this char to result if i + 1 >= len(input_string) or input_string[i] != input_string[i + 1]: compressed.append(f\'{input_string[i]}{count_consecutive}\') count_consecutive = 0 compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(input_string) else input_string"},{"question":"# Coding Assessment Question You are tasked with designing a function that performs a breadth-first search (BFS) on a given graph and returns the shortest path from a start node to a target node. Function: `bfs_shortest_path` Objective: Find the shortest path from a start node to a target node using the breadth-first search algorithm. Requirements: 1. If the start node or target node does not exist in the graph, the function should raise a `ValueError` with an appropriate message. 2. If no path exists between the start node and the target node, the function should return `None`. Input: * `graph`(dict): A dictionary representing an unweighted graph where keys are node identifiers, and values are lists of neighboring node identifiers. * `start`(str): The node identifier from which to start the BFS. * `target`(str): The node identifier which is the target of the BFS. Output: * `list`: A list of nodes representing the shortest path from the `start` node to the `target` node. If no path exists, return `None`. Constraints: - The `graph` is a non-empty dictionary with string keys and list of string values. - `start` and `target` are strings. - Expected execution time: O(V + E), where V is the number of vertices (nodes) and E is the number of edges in the graph. Performance Requirements: - You must ensure that the function is efficient and works within the expected time complexity. Example: ```python >>> graph = { ... \'A\': [\'B\', \'C\'], ... \'B\': [\'A\', \'D\', \'E\'], ... \'C\': [\'A\', \'F\'], ... \'D\': [\'B\'], ... \'E\': [\'B\', \'F\'], ... \'F\': [\'C\', \'E\'] ... } >>> bfs_shortest_path(graph, \'A\', \'F\') [\'A\', \'C\', \'F\'] >>> bfs_shortest_path(graph, \'A\', \'D\') [\'A\', \'B\', \'D\'] >>> bfs_shortest_path(graph, \'A\', \'G\') ValueError: Target node \'G\' does not exist in the graph. ``` Error Handling: - The function should raise a `ValueError` with an appropriate message if the start or target node does not exist in the graph. Implement the function `bfs_shortest_path` as described.","solution":"from collections import deque def bfs_shortest_path(graph, start, target): Find the shortest path from start node to target node using BFS. if start not in graph: raise ValueError(f\\"Start node \'{start}\' does not exist in the graph.\\") if target not in graph: raise ValueError(f\\"Target node \'{target}\' does not exist in the graph.\\") queue = deque([(start, [start])]) visited = set([start]) while queue: current_node, path = queue.popleft() if current_node == target: return path for neighbor in graph[current_node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return None"},{"question":"**Unique Character Finder** # Problem Statement You are given a string consisting of lowercase characters. Your task is to find the first non-repeating character in the string. If all characters are repeating, return an underscore (`\'_\'`). # Function Signature ```python def first_non_repeating_character(s: str) -> str: pass ``` # Input * A single string `s` (1 ≤ len(s) ≤ 10^5) consisting of lowercase English letters. # Output * Return the first non-repeating character as a single character string. * If all characters are repeating, return an underscore (`\'_\'`). # Constraints * The string consists only of lowercase English letters (`a-z`). # Performance Requirements * Your solution should have a time complexity of O(n), where n is the length of the string. # Examples ```python assert first_non_repeating_character(\\"aabcc\\") == \\"b\\" assert first_non_repeating_character(\\"xxyz\\") == \\"y\\" assert first_non_repeating_character(\\"aabb\\") == \\"_\\" assert first_non_repeating_character(\\"abacabad\\") == \\"c\\" assert first_non_repeating_character(\\"a\\") == \\"a\\" ``` Good luck!","solution":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string `s`. If all characters are repeating, returns an underscore (\'_\'). from collections import Counter # Count frequency of each character in the string char_count = Counter(s) # Find the first character with a count of 1 for char in s: if char_count[char] == 1: return char # If no such character is found, return \'_\' return \'_\'"},{"question":"# Coding Question Context Sorting algorithms are fundamental in computer science and have numerous applications. One commonly used sorting algorithm is Merge Sort, which employs a divide-and-conquer strategy to sort an array efficiently. This algorithm recursively divides the array into two halves, sorts each half, and then merges the sorted halves to produce the fully sorted array. Your task is to implement the Merge Sort algorithm. Tasks 1. Implement the `merge_sort` function that takes a list of integers and returns a sorted list using the Merge Sort algorithm. 2. Implement the `merge` helper function that merges two sorted lists into a single sorted list. # Function Signatures ```python def merge_sort(arr: list) -> list: # your code here def merge(left: list, right: list) -> list: # your code here ``` # Requirements - The `merge_sort` function should use the `merge` function to combine sorted halves. - The algorithm should work for both empty lists and lists with both positive and negative integers. - Ensure efficiency by minimizing the number of comparisons and temporary arrays used. # Constraints - The list can be empty or contain up to (10^5) integers. - Each integer in the input list can range between (-10^9) to (10^9). # Example Usage ```python # Test cases for merge sort merge_sort([3, 5, 2, 9, 1]) # should return [1, 2, 3, 5, 9] # Test cases for merge function merge([1, 4, 6], [2, 3, 5]) # should return [1, 2, 3, 4, 5, 6] ``` Ensure your functions can handle edge cases such as an empty list and provide correct sorting for both positive and negative integers.","solution":"def merge_sort(arr: list) -> list: Sort a list of integers using the merge sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left: list, right: list) -> list: Merge two sorted lists into a single sorted list. sorted_list = [] i = 0 j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list"},{"question":"# Problem Statement A security system logs every user\'s access attempt in a building. Each user can log in multiple times a day. Your task is to implement a function that identifies the user who has made the maximum number of access attempts in a single day. # Function Signature ```python def max_access_user(logs: List[Tuple[str, str, int]]) -> str: pass ``` # Input * A list of tuples `logs`, where each tuple contains: * A string `user_id` (1 ≤ length ≤ 100), which represents the user\'s ID. * A string `date` (format \\"YYYY-MM-DD\\"), which represents the date of the access attempt. * An integer `timestamp` (1 ≤ timestamp), which represents the exact time of the access attempt in seconds since midnight. # Output * A single string representing the `user_id` who made the maximum number of access attempts on any single day. # Example ```python print(max_access_user([ (\\"user1\\", \\"2023-10-01\\", 3600), (\\"user2\\", \\"2023-10-01\\", 7200), (\\"user1\\", \\"2023-10-01\\", 10800), (\\"user3\\", \\"2023-10-02\\", 3600), (\\"user2\\", \\"2023-10-01\\", 14400), (\\"user1\\", \\"2023-10-01\\", 18000) ])) # Should output \'user1\' print(max_access_user([ (\\"user1\\", \\"2023-10-01\\", 3600), (\\"user2\\", \\"2023-10-01\\", 7200), (\\"user1\\", \\"2023-10-01\\", 10800), (\\"user3\\", \\"2023-10-02\\", 3600), (\\"user3\\", \\"2023-10-02\\", 4000), (\\"user2\\", \\"2023-10-01\\", 14400), (\\"user1\\", \\"2023-10-01\\", 18000), (\\"user3\\", \\"2023-10-02\\", 4500) ])) # Should output \'user1\' ``` # Constraints * The input list of tuples will contain at most 10^5 entries. * Each `user_id` and `date` combination is guaranteed to have at least one access attempt. * In case of a tie, return the lexicographically smallest `user_id`. # Performance Requirements Your implementation should be efficient enough to handle the upper limit of input size within reasonable time constraints.","solution":"from collections import defaultdict from typing import List, Tuple def max_access_user(logs: List[Tuple[str, str, int]]) -> str: access_count = defaultdict(lambda: defaultdict(int)) for user_id, date, timestamp in logs: access_count[date][user_id] += 1 max_accesses = 0 user_with_max_accesses = \\"\\" for date, user_counts in access_count.items(): for user_id, count in user_counts.items(): if count > max_accesses or (count == max_accesses and user_id < user_with_max_accesses): max_accesses = count user_with_max_accesses = user_id return user_with_max_accesses"},{"question":"# Regular Expression Matching In this task, you are asked to implement regular expression matching with support for \'.\' and \'*\'. The character \'.\' matches any single character. The character \'*\' matches zero or more of the preceding element. # Objective: Implement a function to perform regular expression matching given a text string and a pattern string. # Function Signature: ```python def is_match(text: str, pattern: str) -> bool: pass ``` # Input: - `text`: The input string that needs to be matched against the pattern (a non-empty string with length n). - `pattern`: The regular expression pattern (a non-empty string with length m). # Output: - Returns `True` if the string matches the pattern, otherwise `False`. # Constraints: - The `pattern` can only include lowercase letters, characters \'.\' and \'*\'. - Length of `text` (0 ≤ n ≤ 1000). - Length of `pattern` (0 ≤ m ≤ 1000). - Ensure efficient handling of time and space complexity. # Example Test Cases: 1. ```python text = \\"aa\\" pattern = \\"a\\" print(is_match(text, pattern)) # False ``` 2. ```python text = \\"aa\\" pattern = \\"a*\\" print(is_match(text, pattern)) # True ``` 3. ```python text = \\"ab\\" pattern = \\".*\\" print(is_match(text, pattern)) # True ``` 4. ```python text = \\"aab\\" pattern = \\"c*a*b\\" print(is_match(text, pattern)) # True ``` 5. ```python text = \\"mississippi\\" pattern = \\"mis*is*p*.\\" print(is_match(text, pattern)) # False ``` # Hints: 1. Consider using dynamic programming to implement the solution efficiently. 2. Think about how you handle zero or more repetitions of the preceding element when you encounter \'*\' in the pattern.","solution":"def is_match(text: str, pattern: str) -> bool: Return True if text matches pattern, otherwise False. The pattern supports \'.\' and \'*\'. dp = [[False] * (len(pattern) + 1) for _ in range(len(text) + 1)] dp[0][0] = True for j in range(2, len(pattern) + 1): dp[0][j] = dp[0][j - 2] if pattern[j - 1] == \'*\' else False for i in range(1, len(text) + 1): for j in range(1, len(pattern) + 1): if pattern[j - 1] == \'.\': dp[i][j] = dp[i - 1][j - 1] elif pattern[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] if pattern[j - 2] == text[i - 1] or pattern[j - 2] == \'.\' else False) else: dp[i][j] = dp[i - 1][j - 1] and text[i - 1] == pattern[j - 1] return dp[len(text)][len(pattern)]"},{"question":"**Scenario**: As part of a software development team working on an e-commerce application, you\'ve been assigned the task of improving the search functionality. Your goal is to implement a feature that can find all product names from a list which start with a given prefix. This will enhance user experience by providing real-time search recommendations. **Task**: Write a class implementation that can filter product names based on a provided prefix. Your class should be named `ProductSearch` and include the following methods: 1. `add_product(product: str) -> None` 2. `find_products(prefix: str) -> List[str]` Each method should: - `add_product` should take a string `product` and add it to an internal list of product names. - `find_products` should take a string `prefix` and return a list of all product names that start with the given prefix. # Constraints 1. Product names will consist of alphanumeric characters and spaces only. 2. The length of each product name will not exceed 200 characters. 3. The total number of product names stored will not exceed 10,000. # Requirements 1. Ensure that the implementation handles edge cases, such as empty prefix or no matches. 2. Implement the solution to handle large datasets efficiently. # Expected Input and Output Format * **add_product(product: str) -> None** - **Input**: `product = \\"Apple iPhone 13\\"` - **Output**: `None` (adds the product to internal storage) * **find_products(prefix: str) -> List[str]** - **Input**: `prefix = \\"Apple\\"` - **Output**: `[\\"Apple iPhone 13\\", \\"Apple iPad Air\\"]` # Performance 1. The solution should aim for efficient search operations, ideally running in logarithmic or near-linear time with respect to input size. > Note: Remember to account for case insensitivity in your product search functionality to ensure a robust user experience.","solution":"from typing import List class ProductSearch: def __init__(self): self.products = [] def add_product(self, product: str) -> None: self.products.append(product) def find_products(self, prefix: str) -> List[str]: prefix_lower = prefix.lower() result = [product for product in self.products if product.lower().startswith(prefix_lower)] return result"},{"question":"# Problem Statement You are tasked with implementing a Python function that generates all possible combinations of a given list of integers and computes the sum of each combination. Your objective is to write a function that returns the combination with the maximum sum, as well as the sum itself. This function will help in scenarios where you need to determine the maximum potential sum from any subset of elements. # Function Specifications Function: `max_combination_sum(collection)` - **Input**: A list of integers, `collection`. - **Output**: A tuple containing two elements: - A list representing the combination of integers that yields the maximum sum. - An integer representing the maximum sum. - **Constraints**: The input list can be empty. It may contain negative integers. # Examples Example 1: ```python >>> max_combination_sum([1, 2, 3]) ([1, 2, 3], 6) >>> max_combination_sum([]) ([], 0) >>> max_combination_sum([-1, -2, -3]) ([], 0) ``` # Detailed Instructions 1. **Handle the Edge Cases**: - If the input list is empty, return an empty list and 0 as the maximum sum. 2. **Generate All Combinations**: - Use itertools.combinations to generate all possible non-empty subsets of the input list. - Compute the sum for each subset. 3. **Determine Maximum Sum**: - Find the subset with the highest sum and return both the subset and the sum. - If the list contains strictly negative numbers, consider the empty subset as it yields the sum zero which is the highest possible in such cases. # Additional Notes - Ensure that your implementation efficiently handles lists of various lengths, including edge cases like empty lists or lists with all negative values. - The solution should identify subsets where the overall sum is maximized, not focusing solely on individual elements. - Test your function with various inputs to verify its correctness. Good luck! Make sure to test your function thoroughly with diverse cases to ensure robustness. ```python import itertools def max_combination_sum(collection): if not collection: return ([], 0) max_sum = float(\'-inf\') best_combination = [] for i in range(1, len(collection) + 1): for combo in itertools.combinations(collection, i): current_sum = sum(combo) if current_sum > max_sum: max_sum = current_sum best_combination = list(combo) return (best_combination, max_sum) # Example Usages print(max_combination_sum([1, 2, 3])) # Output: ([1, 2, 3], 6) print(max_combination_sum([])) # Output: ([], 0) print(max_combination_sum([-1, -2, -3])) # Output: ([], 0) ```","solution":"import itertools def max_combination_sum(collection): if not collection: return ([], 0) max_sum = float(\'-inf\') best_combination = [] for i in range(1, len(collection) + 1): for combo in itertools.combinations(collection, i): current_sum = sum(combo) if current_sum > max_sum: max_sum = current_sum best_combination = list(combo) # Handle the case where all numbers in the collection are negative if max_sum < 0: return ([], 0) return (best_combination, max_sum)"},{"question":"# Problem Statement You need to implement a system that calculates a unique series of numbers known as \\"Happy Primes.\\" A number is considered a Happy Prime if it is both a happy number and a prime number. A number is considered \\"happy\\" if repeatedly summing the squares of its digits eventually leads to the number 1. For example, 19 is a happy number because: [ 1^2 + 9^2 = 82 ] [ 8^2 + 2^2 = 68 ] [ 6^2 + 8^2 = 100 ] [ 1^2 + 0^2 + 0^2 = 1 ] A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. # Function Requirements You need to implement the following functions: 1. `is_prime(n: int) -> bool`: This function takes an integer `n` and returns `True` if the number `n` is prime and `False` otherwise. 2. `is_happy(n: int) -> bool`: This function takes an integer `n` and returns `True` if the number `n` is a happy number and `False` otherwise. 3. `next_happy_prime(start: int) -> int`: This function takes an integer `start` and returns the next Happy Prime number greater than the given `start`. # Input - `start` ( (1 leq text{start} leq 10^6) ): An integer indicating the starting point from where the search should begin. # Output - An integer which is the next Happy Prime number greater than the given `start` number. # Example ```python # Function tests >>> is_prime(13) True >>> is_prime(4) False >>> is_prime(17) True >>> is_happy(19) True >>> is_happy(20) False >>> is_happy(7) True # Solution test >>> next_happy_prime(10) 13 >>> next_happy_prime(19) 23 ``` # Hints - For `is_prime`, consider using an optimized method such as trial division up to the square root of `n`. - For `is_happy`, use a cycle detection algorithm like Floyd\'s Tortoise and Hare. - Ensure efficient calculation, especially for large values of `start`. # Constraints - The computation should be handled within a reasonable time complexity. - You may assume that a Happy Prime exists for any valid `start` in the given range.","solution":"import math def is_prime(n: int) -> bool: Returns True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_happy(n: int) -> bool: Returns True if n is a happy number, False otherwise. def sum_of_squares(num): return sum(int(digit) ** 2 for digit in str(num)) slow, fast = n, sum_of_squares(n) while fast != 1 and slow != fast: slow = sum_of_squares(slow) fast = sum_of_squares(sum_of_squares(fast)) return fast == 1 def next_happy_prime(start: int) -> int: Returns the next Happy Prime number greater than the given start. candidate = start + 1 while True: if is_prime(candidate) and is_happy(candidate): return candidate candidate += 1"},{"question":"# Scenario You are designing a feature for a social media platform where users can identify and extract trending hashtags from a stream of posts. As part of this feature, you need to count the occurrences of each hashtag in the stream to determine trending topics. # Task Implement a function `count_hashtags` that takes a list of strings (posts) and returns a dictionary where keys are hashtags and values are the number of their occurrences. # Function Signature ```python def count_hashtags(posts: list) -> dict: ``` # Input * `posts`: A list of strings where each string represents a post on the platform. Length of the list varies from 1 to 10000. Each post string length will not exceed 1000 characters. # Output * A dictionary where keys are the hashtags (strings starting with `#` followed by alphanumeric characters) found in the posts and values are their corresponding frequencies in the given list. # Constraints * Assume hashtags are case insensitive, meaning `#Cat` and `#cat` should be considered the same hashtag. * Hashtags appear as words in the posts, i.e., they are surrounded by spaces or are at the beginning/end of a string. # Example ```python posts = [ \\"I love #coding and #Python\\", \\"#Coding is great!\\", \\"Learn #Python and improve your #Coding skills.\\", \\"No hashtags here!\\" ] count_hashtags(posts) # Output: {\'#coding\': 3, \'#python\': 2} ``` # Hints * Consider using regular expressions to extract hashtags from posts. * Use a dictionary to keep track of the frequency of each hashtag, and handle case insensitivity accordingly.","solution":"import re from collections import defaultdict def count_hashtags(posts): Count the occurrences of each hashtag in a list of posts. :param posts: List of strings, each string representing a post :return: Dictionary with hashtags as keys and their counts as values hashtag_counts = defaultdict(int) hashtag_pattern = re.compile(r\\"#w+\\") for post in posts: hashtags = hashtag_pattern.findall(post) for hashtag in hashtags: normalized_hashtag = hashtag.lower() hashtag_counts[normalized_hashtag] += 1 return dict(hashtag_counts)"},{"question":"# Coding Assessment Question Context You are working on a system that deals with words and their transformations. One common task is to determine the length of the longest substring of a word that contains only unique characters. Problem Description Write a function `length_of_longest_unique_substring` that receives a single string parameter `s` and returns the length of the longest substring containing only unique characters. The function should handle errors gracefully for invalid input such as non-string types. Input and Output - **Input**: - `s` (str): The input string to analyze. - **Output**: - Returns the length of the longest substring with all unique characters (int). - Raises a `TypeError` if `s` is not a string. Constraints - The input string `s` can contain letters, digits, spaces, punctuation, etc. - You are only allowed to use standard Python libraries. - Performance should be reasonable for strings up to length 10,000. Examples ``` >>> length_of_longest_unique_substring(\\"abcabcbb\\") 3 >>> length_of_longest_unique_substring(\\"bbbbb\\") 1 >>> length_of_longest_unique_substring(\\"pwwkew\\") 3 >>> length_of_longest_unique_substring(\\"\\") 0 >>> length_of_longest_unique_substring(12345) Traceback (most recent call last): ... TypeError: The input must be a string. ``` Hints - Consider using a sliding window technique to optimize performance. - Maintaining a set of characters might help in tracking unique characters in the current window.","solution":"def length_of_longest_unique_substring(s): Returns the length of the longest substring with all unique characters. Raises a TypeError if the input is not a string. if not isinstance(s, str): raise TypeError(\\"The input must be a string.\\") n = len(s) char_set = set() left = 0 max_length = 0 for right in range(n): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Binary Tree Height Calculator You are tasked with creating a utility to determine the height of a binary tree. The height of a binary tree is the number of edges on the longest path from the root node to a leaf node. Write a class `BinaryTreeNode` representing a node in the binary tree and a function `calculate_height(root: BinaryTreeNode) -> int` to calculate the height of the tree. Input - The attribute `root` is a reference to the root node of the binary tree, which could be `None` if the tree is empty. - A node is defined by the class `BinaryTreeNode` which has: ```python class BinaryTreeNode: def __init__(self, value: int, left: \'BinaryTreeNode\' = None, right: \'BinaryTreeNode\' = None): self.value = value self.left = left self.right = right ``` Output - `calculate_height(root)` should return an integer representing the height of the tree. Constraints - Optimize for execution time and space, given the input size. - Handle edge cases including empty trees and trees with only one node. Example ```python # Example usage: # Creating the tree: # 1 # / # 2 3 # / # 4 5 root = BinaryTreeNode(1, BinaryTreeNode(2, BinaryTreeNode(4), BinaryTreeNode(5)), BinaryTreeNode(3)) print(calculate_height(root)) # Expected: 2 # Edge Case: Empty Tree print(calculate_height(None)) # Expected: -1 # Edge Case: Single Node Tree single_node_tree = BinaryTreeNode(1) print(calculate_height(single_node_tree)) # Expected: 0 ``` Implement the `calculate_height` function in Python to determine the height of a given binary tree.","solution":"class BinaryTreeNode: def __init__(self, value: int, left: \'BinaryTreeNode\' = None, right: \'BinaryTreeNode\' = None): self.value = value self.left = left self.right = right def calculate_height(root: BinaryTreeNode) -> int: Calculate the height of a binary tree. The height is the number of edges on the longest path from the root to a leaf node. :param root: BinaryTreeNode, root node of the binary tree :return: int, height of the binary tree if root is None: return -1 left_height = calculate_height(root.left) right_height = calculate_height(root.right) return 1 + max(left_height, right_height)"},{"question":"# Question: Disjoint Set Union-Find with Path Compression and Union by Rank Context: As part of a data structure optimization project, you need to implement a Disjoint Set, also known as Union-Find, which supports the following operations efficiently: - `find(v)`: Find the representative (root) of the set containing element `v` and apply path compression for efficiency. - `union(v, u)`: Merge the sets containing `v` and `u` using union by rank to keep the tree shallow. This structure is useful in various applications, such as network connectivity, image processing, and Kruskal\'s algorithm for finding the Minimum Spanning Tree (MST). Task: Implement the class `DisjointSet` with methods `find` and `union` that supports the mentioned operations using path compression and union by rank. Class Signature: ```python class DisjointSet: def __init__(self, n: int): # Initializes the disjoint set for \'n\' elements. self.parent = list(range(n)) self.rank = [0] * n def find(self, v: int) -> int: # Finds the representative of the set containing \'v\'. pass def union(self, v: int, u: int) -> None: # Merges the sets containing \'v\' and \'u\'. pass ``` Input: - Initialize the `DisjointSet` with an integer `n` representing the number of elements. - The `find` method takes an integer `v` and returns the representative of the set containing `v`. - The `union` method takes two integers `v` and `u` and merges the sets containing `v` and `u`. Output: - The `find` method returns the representative of the set containing `v`. - The `union` method does not return any value. Constraints: - `1 <= n <= 1000` (number of elements). Example: ```python ds = DisjointSet(5) ds.union(0, 2) ds.union(4, 2) ds.union(3, 1) assert ds.find(4) == ds.find(0) # Both should be in the same set now. assert ds.find(1) != ds.find(0) # These should be in different sets. ``` Notes: - Implement path compression in the `find` method to flatten the structure of the tree. - Use union by rank in the `union` method to attach the smaller tree under the root of the deeper tree. - Handle edge cases such as `union` or `find` involving elements out of range. - Ensure that each operation is efficient and the data structure remains balanced.","solution":"class DisjointSet: def __init__(self, n: int): self.parent = list(range(n)) self.rank = [0] * n def find(self, v: int) -> int: if self.parent[v] != v: self.parent[v] = self.find(self.parent[v]) # Path compression return self.parent[v] def union(self, v: int, u: int) -> None: rootV = self.find(v) rootU = self.find(u) if rootV != rootU: if self.rank[rootV] > self.rank[rootU]: self.parent[rootU] = rootV elif self.rank[rootV] < self.rank[rootU]: self.parent[rootV] = rootU else: self.parent[rootU] = rootV self.rank[rootV] += 1"},{"question":"# **Coding Assessment Question:** # Context: You are designing a function to help a library maintain its inventory by tracking the books issued to members. This requires familiarity with basic list operations, data structures, and handling edge cases effectively. # Question: Implement a Python function that, given a list of book titles and a list of book issuance requests, updates the inventory by removing issued books and returns the list of books that are still available in the library. # Function Signature: ```python def update_inventory(books: List[str], requests: List[str]) -> List[str]: ``` # Inputs: - **books** (List[str]): A list of strings representing the titles of books currently available in the library. - **requests** (List[str]): A list of strings representing the titles of books being issued. # Outputs: - **List[str]**: A list of strings representing the titles of books that remain available in the library after processing all the issuance requests. # Constraints: - Each book title is unique in the inventory. - If a requested book is not available in the inventory, it should be ignored. - The function should handle large lists efficiently. # Example: ```python print(update_inventory( [\\"The Great Gatsby\\", \\"1984\\", \\"To Kill a Mockingbird\\", \\"Pride and Prejudice\\"], [\\"1984\\", \\"Pride and Prejudice\\", \\"Moby Dick\\"] )) # Expected Output: # [\\"The Great Gatsby\\", \\"To Kill a Mockingbird\\"] ``` # Note: - Ensure your solution can handle every request gracefully even if some books in the requests list are not found in the inventory. - The order of books in the output list should be the same as the original list but with the requested books removed. - Document any assumptions and ensure your code follows best practices regarding readability, efficiency, and maintainability.","solution":"from typing import List def update_inventory(books: List[str], requests: List[str]) -> List[str]: Updates the list of books by removing those that have been requested and are available in the inventory. :param books: List of strings representing the titles of books currently available in the library. :param requests: List of strings representing the titles of books being issued. :return: List of strings representing the titles of books that remain available in the library. # Convert the list of requests into a set for O(1) membership checks requested_set = set(requests) # Filter out books that are requested updated_books = [book for book in books if book not in requested_set] return updated_books"},{"question":"# Longest Path in a Directed Acyclic Graph (DAG) Given a directed acyclic graph (DAG) represented by `n` vertices and a list of `edges`, write a function `longest_path_dag(n: int, edges: List[Tuple[int, int]]) -> List[int]` that finds the longest path in the DAG. # Function Signature ```python def longest_path_dag(n: int, edges: List[Tuple[int, int]]) -> List[int]: pass ``` # Input - `n`: An integer representing the number of vertices in the DAG. - `edges`: A list of tuples where each tuple `(u, v)` represents a directed edge from vertex `u` to vertex `v`. # Output - A list of integers representing the vertices in the longest path. If there are multiple longest paths, return any one of them. # Constraints - (1 leq n leq 1000) - (0 leq u, v < n) - No duplicate edges. - The graph is guaranteed to be a DAG. # Example ```python n = 6 edges = [(0, 1), (0, 2), (1, 3), (1, 4), (2, 4), (3, 5), (4, 5)] print(longest_path_dag(n, edges)) # Output: [0, 1, 3, 5] ``` # Explanation In the given DAG, there are multiple paths, but the longest paths have length 4. One of the longest paths is `[0, 1, 3, 5]`. Another valid longest path would be `[0, 2, 4, 5]`. # Implementation Details - Use topological sorting to find the order of vertices. - Use dynamic programming or depth-first search (DFS) to keep track of the longest path ending at each vertex. - Reconstruct the longest path from the computed data. _Private class or additional helper functions can be defined to maintain modularity and readability._","solution":"from typing import List, Tuple def longest_path_dag(n: int, edges: List[Tuple[int, int]]) -> List[int]: from collections import defaultdict, deque # Create an adjacency list adj_list = defaultdict(list) in_degree = [0] * n for u, v in edges: adj_list[u].append(v) in_degree[v] += 1 # Find topological order using Kahn\'s algorithm topological_order = [] zero_in_degree_queue = deque([i for i in range(n) if in_degree[i] == 0]) while zero_in_degree_queue: node = zero_in_degree_queue.popleft() topological_order.append(node) for neighbor in adj_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # Initialize distances and paths longest_path_length = [-1] * n longest_path_length[topological_order[0]] = 0 paths = [[] for _ in range(n)] paths[topological_order[0]].append(topological_order[0]) # Compute the longest paths using topological order for u in topological_order: for v in adj_list[u]: if longest_path_length[u] + 1 > longest_path_length[v]: longest_path_length[v] = longest_path_length[u] + 1 paths[v] = paths[u] + [v] # Find the maximum length path and its corresponding vertex max_length = max(longest_path_length) max_length_index = longest_path_length.index(max_length) return paths[max_length_index]"},{"question":"# Context In competitive programming and algorithmic problem solving, it is common to encounter problems where efficient and custom data structures can drastically improve performance. One such structure is the Binary Indexed Tree (Fenwick Tree), which allows for efficient updates and prefix sum calculations. # Question Design a class `FenwickTree` that supports efficient computation of prefix sums and updates of elements. Your class should implement methods to initialize the tree with a given list of integers, update a value at a specified index, and retrieve the sum of the elements from the start up to a given index. # Class Signature ```python class FenwickTree: def __init__(self, array: List[int]): Initializes the Fenwick Tree with the given list of integers. :param array: List of integers to build the Fenwick Tree from. def update(self, index: int, value: int): Updates the value at the specified index. :param index: Index of the element to be updated (0-based). :param value: New value to set at the specified index. def prefix_sum(self, index: int) -> int: Computes the sum of elements from the start up to the given index. :param index: Index up to which the prefix sum is calculated (inclusive, 0-based). :return: Sum of elements from the start up to the given index. ``` # Input * Initialization with `array`: List of integers, e.g., `[3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3]` * Method input: - `update`: `index` (integer), `value` (integer) - `prefix_sum`: `index` (integer) # Output * `prefix_sum`: Returns an integer representing the sum of elements from the start up to the specified index. # Constraints * The input list `array` can be of any non-negative length. * Updates and prefix sum calculations should be efficient, ideally in O(log n) time complexity. # Examples ```python # Initialize the Fenwick Tree with an example list array = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3] fenwick_tree = FenwickTree(array) # Retrieve prefix sums assert fenwick_tree.prefix_sum(4) == 15 # 3 + 2 - 1 + 6 + 5 assert fenwick_tree.prefix_sum(6) == 16 # 3 + 2 - 1 + 6 + 5 + 4 - 3 # Update values and check prefix sums again fenwick_tree.update(3, 10) # updating index 3 to 10 from original value 6 assert fenwick_tree.prefix_sum(4) == 19 # 3 + 2 - 1 + 10 + 5 assert fenwick_tree.prefix_sum(6) == 20 # 3 + 2 - 1 + 10 + 5 + 4 - 3 ```","solution":"class FenwickTree: def __init__(self, array): self.n = len(array) self.tree = [0] * (self.n + 1) self.array = array[:] for i, val in enumerate(array): self._add(i + 1, val) def _add(self, index, value): while index <= self.n: self.tree[index] += value index += index & -index def update(self, index, value): old_value = self.array[index] self.array[index] = value self._add(index + 1, value - old_value) def prefix_sum(self, index): index += 1 # Fenwick Tree is 1-based result = 0 while index > 0: result += self.tree[index] index -= index & -index return result"},{"question":"# Cyclic Sort Implementation You are asked to implement the cyclic sort algorithm. Cyclic sort is efficient for sorting arrays containing elements in a contiguous range from `1` to `n`. **Function Signature:** ```python def cyclic_sort(a: List[int]) -> None: pass ``` **Input:** * `a` (list of integers): The list `a` contains `n` integers, where each element is a unique integer ranging from 1 to `n`. **Output:** * The function should sort the list `a` in-place. **Constraints:** * 1 <= len(a) <= 10^5 * Each element of `a` is a unique integer within 1 to the length of the list `a` (i.e., 1 ≤ a[i] ≤ len(a)) **Example:** ```python a = [3, 1, 5, 4, 2] cyclic_sort(a) print(a) # Output: [1, 2, 3, 4, 5] ``` **Performance Requirements:** Your implementation should efficiently sort the array with a time complexity of O(n) and constant space complexity, excluding the input and the output. **Hints:** Cyclic sort is a non-comparative sorting algorithm beneficial when the elements to be sorted are essentially distinct and within a specific range. The basic idea involves placing each element in its correct position in one pass.","solution":"from typing import List def cyclic_sort(a: List[int]) -> None: This function sorts the array containing elements in a contiguous range from `1` to `n` in-place. i = 0 while i < len(a): correct_index = a[i] - 1 if a[i] != a[correct_index]: # Swap a[i] with a[correct_index] a[i], a[correct_index] = a[correct_index], a[i] else: i += 1"},{"question":"# Coding Assessment Question **Title**: String Transformation with Minimum Operations **Objective**: You are tasked with implementing a function that transforms one string into another using the minimum number of operations. The allowed operations are insertion, deletion, and substitution of characters. **Task**: Implement the function `min_operations_to_transform` which computes the minimum number of operations required to transform one string into another. This should be solved using dynamic programming techniques to ensure efficiency. **Specifications**: 1. **Function Signature**: `def min_operations_to_transform(s1: str, s2: str) -> int` 2. **Input**: * `s1`: String, the source string. * `s2`: String, the target string. 3. **Output**: * Returns an integer representing the minimum number of operations required to transform `s1` into `s2`. 4. **Constraints & Requirements**: * You must handle strings that can be empty. * The solution should be based on dynamic programming for optimal performance. 5. **Edge Cases**: * Include cases where `s1` and `s2` are the same, one is empty, or when both are empty. **Example**: ```python assert min_operations_to_transform(\\"kitten\\", \\"sitting\\") == 3 assert min_operations_to_transform(\\"flaw\\", \\"lawn\\") == 2 assert min_operations_to_transform(\\"\\", \\"abc\\") == 3 ``` ```python # Your implementation here ``` **Performance Requirements**: * The solution should efficiently handle reasonably sized strings. * Ensure the correctness and efficiency of your implementation. **Context**: This function is particularly useful in applications like spell checkers, DNA sequence analysis, and version control systems, where understanding the differences between strings and minimizing transformation effort is crucial.","solution":"def min_operations_to_transform(s1: str, s2: str) -> int: Calculate the minimum number of operations required to transform s1 into s2. Operations allowed: insertion, deletion, substitution. Uses dynamic programming for optimal performance. :param s1: str - source string :param s2: str - target string :return: int - minimum number of operations required m, n = len(s1), len(s2) # If one of the strings is empty if m == 0: return n if n == 0: return m # Create a DP table to store results of subproblems dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # Fill dp[][] in bottom up manner for i in range(m + 1): for j in range(n + 1): # If first string is empty, only option is to insert all characters of second string if i == 0: dp[i][j] = j # If second string is empty, only option is to remove all characters of first string elif j == 0: dp[i][j] = i # If last characters are the same, ignore last char and recur for remaining string elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If last characters are different, consider all possibilities and find minimum else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"# Coding Assessment Question As part of an automated health monitoring system, you are required to enhance a module that analyzes patient data to detect any health anomalies in real-time. Your task involves refactoring the existing system to ensure it is more efficient and capable of handling larger datasets. Your tasks are: 1. **Implement a function to read and process patient data from an enhanced API.** - The new API endpoint is \\"https://alternative-api.com/patient_data\\". - This endpoint provides patient details including heart rate, blood pressure, and temperature. 2. **Implement a robust anomaly detection mechanism:** - Develop a function `detect_anomalies` that identifies and flags abnormal readings based on predefined thresholds. - Heart rate: < 60 or > 100 bpm - Blood pressure (systolic/diastolic): < 90/60 mmHg or > 140/90 mmHg - Temperature: < 36°C or > 38°C 3. **Enhance error handling:** - Develop a mechanism to handle errors such as API failures, network issues, and unexpected data formats. - Implement logging of error messages and retry failed requests up to a predefined limit. 4. **Optimize data processing:** - Refactor the `process_patient_data` function to optimize for large-scale data processing. - Ensure efficient handling of datasets that could contain thousands of patient records. **Input:** - An integer representing the retry limit for failed network requests. - Threshold values for identifying anomalies. **Output:** - A summary table displaying the patient ID and the type of anomaly detected for each flagged patient. **Constraints:** - The API endpoint returns data in a JSON format containing patient details. - Ensure robust error handling with up to 3 retries for failed network requests. - Handle large datasets efficiently without performance degradation. **Scenario Context:** Imagine a health monitoring application used in a large hospital that needs to upgrade its system to detect and respond to patient anomalies in real-time. The new system must be resilient, efficient, and capable of managing a high volume of data to ensure patient safety.","solution":"import requests import logging from typing import List, Dict # Configure logging logging.basicConfig(level=logging.ERROR) logger = logging.getLogger() # Define thresholds for anomalies HEART_RATE_THRESHOLDS = (60, 100) BLOOD_PRESSURE_THRESHOLDS = ((90, 140), (60, 90)) TEMPERATURE_THRESHOLDS = (36, 38) # API endpoint API_URL = \\"https://alternative-api.com/patient_data\\" def fetch_patient_data(retry_limit: int) -> List[Dict]: Fetch patient data from the API with a specified limit for retries. Returns the patient data as a list of dictionaries. tries = 0 while tries < retry_limit: try: response = requests.get(API_URL) response.raise_for_status() return response.json() except requests.RequestException as e: tries += 1 logger.error(f\\"Attempt {tries} failed: {e}\\") if tries >= retry_limit: logger.error(\\"Failed to fetch patient data after multiple retries.\\") raise def detect_anomalies(patient_data: List[Dict]) -> List[Dict]: Detect anomalies in the patient data based on predefined thresholds. Returns a list of dictionaries with patient ID and type of anomaly detected. anomalies = [] for patient in patient_data: patient_id = patient[\'id\'] heart_rate = patient.get(\'heart_rate\') blood_pressure = patient.get(\'blood_pressure\', {}) systolic = blood_pressure.get(\'systolic\') diastolic = blood_pressure.get(\'diastolic\') temperature = patient.get(\'temperature\') anomaly = { \'patient_id\': patient_id, \'anomalies\': [] } if heart_rate is not None and (heart_rate < HEART_RATE_THRESHOLDS[0] or heart_rate > HEART_RATE_THRESHOLDS[1]): anomaly[\'anomalies\'].append(\'heart_rate\') if systolic is not None and diastolic is not None: if (systolic < BLOOD_PRESSURE_THRESHOLDS[0][0] or systolic > BLOOD_PRESSURE_THRESHOLDS[0][1] or diastolic < BLOOD_PRESSURE_THRESHOLDS[1][0] or diastolic > BLOOD_PRESSURE_THRESHOLDS[1][1]): anomaly[\'anomalies\'].append(\'blood_pressure\') if temperature is not None and (temperature < TEMPERATURE_THRESHOLDS[0] or temperature > TEMPERATURE_THRESHOLDS[1]): anomaly[\'anomalies\'].append(\'temperature\') if anomaly[\'anomalies\']: anomalies.append(anomaly) return anomalies def process_patient_data(retry_limit: int) -> List[Dict]: Main function to process patient data, detect anomalies and return the summary table. # Fetch patient data patient_data = fetch_patient_data(retry_limit) # Detect anomalies anomalies = detect_anomalies(patient_data) return anomalies"},{"question":"# Problem Statement You are given a list of strings, and you need to determine if each string is a palindrome. A palindrome is a string that reads the same forward and backward, ignoring case and non-alphanumeric characters. # Function Signature ```python def check_palindromes(strings: List[str]) -> List[bool]: Determine whether each string in a list is a palindrome. Args: strings - List of strings to be checked for palindrome property. Returns: A list of boolean values corresponding to whether each string is a palindrome. Raises: ValueError - If any element in the list is not a valid string. pass ``` # Input - `strings`: A list of strings. Each string can contain alphanumeric characters and spaces. # Output - A list of boolean values where each element corresponds to whether the string at the same index in the input list is a palindrome. # Constraints - Strings in the input list can contain up to 10^5 characters. - The input list can contain up to 10^5 elements. # Performance Requirements - The solution should handle all strings efficiently, ideally close to O(n * m), where `n` is the length of the list and `m` is the average length of the strings. # Example Given the input list: ```python strings = [\\"A man, a plan, a canal, Panama\\", \\"race a car\\", \\" \\", \\"121\\", \\"No \'x\' in Nixon\\"] ``` The output should be: ```python [True, False, True, True, True] ``` # Edge Cases - An empty list should return an empty list. - Lists with empty strings or strings containing only non-alphanumeric characters should be handled correctly. - Lists with invalid elements (non-string items) should raise a ValueError. Make sure your implementation is robust and handles all specified edge cases correctly. You should write your own tests to validate the correctness of your solution.","solution":"import re from typing import List def check_palindromes(strings: List[str]) -> List[bool]: def is_palindrome(s: str) -> bool: # Remove non-alphanumeric characters and convert to lower case cleaned = re.sub(r\'[^A-Za-z0-9]\', \'\', s).lower() # Check if the cleaned string is the same forward and backward return cleaned == cleaned[::-1] if not all(isinstance(s, str) for s in strings): raise ValueError(\\"All elements in the input list must be strings.\\") return [is_palindrome(s) for s in strings]"},{"question":"# Minimum Spanning Tree Construction As a programming task, you need to implement a class `Graph` that maintains a list of edges and constructs a Minimum Spanning Tree (MST) using Kruskal\'s algorithm. 1. **Graph Initialization**: The `Graph` class should be initialized with a list of edges where each edge is represented by a tuple of two vertices and the weight of the edge (v1, v2, weight). 2. **Edge Addition**: Provide a method to add edges to the graph dynamically. 3. **Kruskal’s Algorithm**: Implement Kruskal\'s algorithm to find the MST of the graph. # Input and Output Format * Implement three distinct functions in the `Graph` class: * `__init__(self, edges: List[Tuple[int, int, int]]) -> None`: Initializes the graph with a list of edges. * `add_edge(self, v1: int, v2: int, weight: int) -> None`: Adds a new edge to the graph. * `find_mst(self) -> List[Tuple[int, int, int]]`: Constructs the MST using Kruskal\'s algorithm and returns a list of edges included in the MST. # Constraints * The graph will contain at least 1 vertex and at most 1000 vertices. * The weight of the edges will be a positive integer. * Edges are undirected. # Examples ```python # Example usage: edges = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)] g = Graph(edges) # Adding an edge g.add_edge(1, 2, 8) # Finding the Minimum Spanning Tree mst = g.find_mst() print(mst) # The output will be a list of edges that form the MST ``` Implement the `Graph` class with the above requirements and guidelines.","solution":"class Graph: def __init__(self, edges): Initializes the graph with a list of edges. Each edge is represented as a tuple (v1, v2, weight). self.edges = edges def add_edge(self, v1, v2, weight): Adds a new edge to the graph. self.edges.append((v1, v2, weight)) def find_mst(self): Constructs the MST using Kruskal\'s algorithm and returns the list of edges. # Sort edges based on weight self.edges.sort(key=lambda edge: edge[2]) parent = dict() rank = dict() def find(v): if parent[v] != v: parent[v] = find(parent[v]) return parent[v] def union(v1, v2): root1 = find(v1) root2 = find(v2) if root1 != root2: if rank[root1] > rank[root2]: parent[root2] = root1 else: parent[root1] = root2 if rank[root1] == rank[root2]: rank[root2] += 1 # Initialize disjoint sets for v1, v2, weight in self.edges: if v1 not in parent: parent[v1] = v1 rank[v1] = 0 if v2 not in parent: parent[v2] = v2 rank[v2] = 0 mst = [] for v1, v2, weight in self.edges: if find(v1) != find(v2): union(v1, v2) mst.append((v1, v2, weight)) return mst"},{"question":"# Combinatorial String Generation **Objective**: Implement a function that generates all possible combinations of a given string\'s characters, such that each combination is of a specified length `k`. # Function Description ```python def generate_combinations(s: str, k: int) -> List[str]: Generates all possible combinations of the string\'s characters of length k. Parameters ---------- s: str The input string from which combinations are to be generated. k: int The length of each combination. Returns ------- List[str] A list of all possible combinations of length k. pass ``` # Input Format * `s`: A string consisting of lowercase English letters. * `k`: An integer representing the length of each combination. # Output Format * A list of strings, each representing a unique combination of the specified length `k`. # Constraints * `1 <= len(s) <= 20` * `1 <= k <= len(s)` # Example Input ```python s = \\"abc\\" k = 2 ``` Output ```python [ \\"ab\\", \\"ac\\", \\"bc\\" ] ``` # Explanation For the given input string \\"abc\\" and length `k = 2`, the possible combinations of two characters are \\"ab\\", \\"ac\\", and \\"bc\\". # Notes Ensure the output list contains unique combinations sorted in lexicographical order. Implement an efficient algorithm that handles the required combinatorial logic without redundancy. Consider edge cases such as `k` being equal to `1` or `k` being equal to the length of the string.","solution":"from itertools import combinations from typing import List def generate_combinations(s: str, k: int) -> List[str]: Generates all possible combinations of the string\'s characters of length k. Parameters ---------- s: str The input string from which combinations are to be generated. k: int The length of each combination. Returns ------- List[str] A list of all possible combinations of length k. return [\'\'.join(comb) for comb in combinations(s, k)]"},{"question":"# Problem Statement You are given an unsorted list of integers and must sort it using the insertion sort algorithm. However, instead of sorting in ascending order, you need to sort the list in **ascending order**. # Function Signature ```python def insertion_sort_ascending(collection: list[int]) -> list[int]: Sorts a list in ascending order using the insertion sort algorithm. :param collection: A list of integers to be sorted. :return: The sorted list in ascending order. ``` # Input - A list `collection` of integers: - Constraint: 1 <= len(collection) <= 10^3 - Constraint: -10^6 <= collection[i] <= 10^6 # Output - A list of integers sorted in ascending order. # Example ```python assert insertion_sort_ascending([4, 2, 7, 1, 3]) == [1, 2, 3, 4, 7] assert insertion_sort_ascending([-3, -1, -7, 0]) == [-7, -3, -1, 0] assert insertion_sort_ascending([]) == [] ``` # Additional Instructions - Ensure your implementation handles edge cases such as empty lists. - Aim to optimize for readability and correctness.","solution":"def insertion_sort_ascending(collection: list[int]) -> list[int]: Sorts a list in ascending order using the insertion sort algorithm. :param collection: A list of integers to be sorted. :return: The sorted list in ascending order. for i in range(1, len(collection)): key = collection[i] j = i - 1 while j >= 0 and key < collection[j]: collection[j + 1] = collection[j] j -= 1 collection[j + 1] = key return collection"},{"question":"# Summation of Prime Numbers in a Range Given two integers `a` and `b` with `0 ≤ a ≤ b ≤ 10000`, write a function called `sum_primes(a: int, b: int) -> int` that returns the sum of all prime numbers in the inclusive range from `a` to `b`. Core Functionality - Determine all prime numbers between `a` and `b`. - Compute their sum and return it. Input - Two integers `a` and `b` such that `0 ≤ a ≤ b ≤ 10000`. - Example input: `a = 10`, `b = 20` Output - An integer representing the sum of all prime numbers in the interval `[a, b]`. - Example output: `60` Constraints - The input values are non-negative and do not exceed 10000. - Efficiently handle the prime number determination to ensure quick computations even for larger ranges. Edge Cases - Scenarios where there are no prime numbers in the given range. - Where `a` is equal to `b`. - The smallest range with primes, such as between two consecutive prime numbers. Example ```python >>> sum_primes(10, 20) 60 >>> sum_primes(0, 10) 17 >>> sum_primes(2, 2) 2 >>> sum_primes(14, 16) 0 >>> sum_primes(17, 17) 17 ```","solution":"def is_prime(num): if num < 2: return False if num == 2: return True if num % 2 == 0: return False p = 3 while p * p <= num: if num % p == 0: return False p += 2 return True def sum_primes(a, b): return sum(num for num in range(a, b + 1) if is_prime(num))"},{"question":"# Problem Statement You are tasked with creating an efficient data structure that simulates an in-memory file system. This file system should support file and directory creation, storing content in files, and reading the content back from the files. # Objectives 1. **Directory and File Creation**: Implement the ability to create directories and files. 2. **Writing and Reading Content**: Implement methods to write content to a file and read content from a file. # Function Signatures - `mkdir(self, path: str) -> None` - `create_file(self, path: str, content: str) -> None` - `read_file(self, path: str) -> str` - `write_file(self, path: str, content: str) -> None` - `list_dir(self, path: str) -> list[str]` # Example ```python fs = FileSystem() # Creating directories fs.mkdir(\\"/a/b/c\\") fs.mkdir(\\"/a/b/d\\") # Creating files fs.create_file(\\"/a/b/c/file1.txt\\", \\"Hello\\") fs.create_file(\\"/a/b/d/file2.txt\\", \\"World\\") # Writing to a file fs.write_file(\\"/a/b/c/file1.txt\\", \\"Hello, how are you?\\") # Reading from file content1 = fs.read_file(\\"/a/b/c/file1.txt\\") content2 = fs.read_file(\\"/a/b/d/file2.txt\\") print(content1) # Output: Hello, how are you? print(content2) # Output: World # Listing directory listing = fs.list_dir(\\"/a/b\\") print(listing) # Output: [\'c\', \'d\'] ``` # Constraints - Paths and filenames are non-empty strings, each up to 200 characters in length. - The depth of the directory structure can be up to 100 levels. - File content lengths can vary up to 10^5 characters in length. - Total number of directories and files will not exceed 10^4. # Hints 1. Use dictionary data structures to store directories and their contents. 2. Treat each directory and file as a node in a tree, with paths representing the hierarchy. # Performance Requirements - Your solution should efficiently handle file system operations up to the maximum constraints within acceptable time limits. **Note:** Ensure that path strings are handled correctly and that invalid operations (like creating a file in a non-existing directory) are appropriately managed.","solution":"class FileSystem: def __init__(self): self.root = {} def mkdir(self, path: str) -> None: nodes = path.strip(\'/\').split(\'/\') current = self.root for node in nodes: if node not in current: current[node] = {} current = current[node] def create_file(self, path: str, content: str) -> None: parts = path.strip(\'/\').split(\'/\') file_name = parts.pop() current = self.root for part in parts: if part not in current: current[part] = {} current = current[part] current[file_name] = content def read_file(self, path: str) -> str: parts = path.strip(\'/\').split(\'/\') file_name = parts.pop() current = self.root for part in parts: current = current[part] return current[file_name] def write_file(self, path: str, content: str) -> None: parts = path.strip(\'/\').split(\'/\') file_name = parts.pop() current = self.root for part in parts: current = current[part] current[file_name] = content def list_dir(self, path: str) -> list[str]: parts = path.strip(\'/\').split(\'/\') current = self.root for part in parts: current = current[part] return sorted(current.keys())"},{"question":"# String Pattern Matching Write a Python function to find and highlight all occurrences of a given pattern within a larger text. Highlighting is done by enclosing the matching part of the text in square brackets. # Function Signature ```python def highlight_pattern(text: str, pattern: str) -> str: Find and highlight all occurrences of a given pattern in the text. :param text: str, input text to search within :param pattern: str, pattern to search for :return: str, text with all occurrences of the pattern highlighted pass ``` # Input - `text`: a string representing the text to search within. - `pattern`: a string representing the pattern to search for. # Output - A string with all occurrences of the pattern in the text highlighted by enclosing them in square brackets. # Constraints 1. The pattern and text consist only of printable ASCII characters. 2. The length of the text will not exceed 1000 characters. 3. The pattern length will not exceed 100 characters. 4. If the pattern is an empty string, return the original text unchanged. # Example Given the following inputs: ```python text = \\"This is a simple example. Simple solutions can be effective.\\" pattern = \\"simple\\" ``` Expected output: ```python highlighted_text = highlight_pattern(text, pattern) print(highlighted_text) # Expected result: \\"This is a [simple] example. Simple solutions can be effective.\\" ``` Another Example: Given the following inputs: ```python text = \\"ABABABA\\" pattern = \\"ABA\\" ``` Expected output: ```python highlighted_text = highlight_pattern(text, pattern) print(highlighted_text) # Expected result: \\"[ABA]B[ABA]\\" ``` # Tips - Use Python\'s built-in string methods for searching and replacing text. - Ensure to handle overlapping patterns appropriately in your implementation.","solution":"def highlight_pattern(text: str, pattern: str) -> str: Find and highlight all occurrences of a given pattern in the text. :param text: str, input text to search within :param pattern: str, pattern to search for :return: str, text with all occurrences of the pattern highlighted if not pattern: return text highlighted_text = \\"\\" i = 0 while i < len(text): if text[i:i+len(pattern)] == pattern: highlighted_text += f\\"[{pattern}]\\" i += len(pattern) - 1 else: highlighted_text += text[i] i += 1 return highlighted_text"},{"question":"# Rotated Sorted Array Search Context You are developing a feature for an e-commerce website where users often search for products. The product catalog is rotated at a certain pivot unknown to you beforehand. Subsequently, products are arranged in ascending order before the pivot, and continue in ascending order beyond the pivot. However, the search must account for this unknown rotation. Your task is to implement an efficient search that operates within this rotated sorted array. Task Write a function `search_rotated_sorted_array(nums: list[int], target: int) -> int` to search for a target value in the rotated sorted array `nums`. Input - `nums`: A list of integers `nums[]` of length `n` (1 <= n <= 10^5), which represents the sorted array that has been rotated. - `target`: An integer `target` which needs to be searched for within `nums`. Output - Returns an integer, which is the index of `target` in `nums` if it is present; otherwise, returns -1. Constraints - The function should operate in logarithmic time complexity, O(log n). - You may assume no duplicate exists in the array. - Handles different edge cases like the target being at the pivot or the end of the list. Example ```python print(search_rotated_sorted_array([4, 5, 6, 7, 0, 1, 2], 0)) # Output: 4 print(search_rotated_sorted_array([4, 5, 6, 7, 0, 1, 2], 3)) # Output: -1 print(search_rotated_sorted_array([1], 0)) # Output: -1 print(search_rotated_sorted_array([1, 3], 3)) # Output: 1 ``` Criteria - The solution must achieve a time complexity of O(log n). - The function should handle different rotated positions and still efficiently find the element or return -1 if it does not exist.","solution":"def search_rotated_sorted_array(nums, target): Searches for the target value in the rotated sorted array and returns its index. If the target is not found, returns -1. Parameters: num (list of int): The rotated sorted array. target (int): The target value to be searched for. Returns: int: The index of the target value if present, otherwise -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid # Check if the left half is sorted if nums[left] <= nums[mid]: if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # Right half must be sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Coding Assessment Question A critical aspect of data processing applications is to efficiently identify and extract prime numbers from a list of integers. Your task is to implement a function that accomplishes this efficiently, considering the constraints provided. Function Definition ```python def find_prime_numbers(arr: List[int]) -> List[int]: Given a list of integers, return a list of integers that are prime numbers from the input list. Args: arr : List[int] : a list containing integer values. Returns: List[int] : a list containing only the integers from the input list that are prime numbers. Constraints: - The input list may contain up to 10^6 elements. - Each integer in the list is within the range of -10^9 to 10^9. Example: >>> find_prime_numbers([10, 17, 18, 19, 23]) [17, 19, 23] >>> find_prime_numbers([4, 6, 8, 10]) [] ``` Detailed Requirements * **Determine Primality Efficiently:** * Implement a helper function `is_prime(n: int) -> bool` to determine if a given integer `n` is a prime number. * Consider performance optimization techniques, such as checking divisibility only up to the square root of `n` and skipping even numbers beyond 2. * **Edge Cases:** * Make sure to handle edge cases, such as negative numbers and extremely large values, appropriately. Recall that prime numbers are positive integers greater than 1. * **Consider List Size:** * The primary function `find_prime_numbers` should iterate over the original list only once, calling the helper function for each element. By solving this problem, students will demonstrate their understanding of primality testing, efficient algorithm design, and handling large input sizes.","solution":"from typing import List def is_prime(n: int) -> bool: Check if a given number n is a prime number. Args: n : int : the integer to be checked Returns: bool : True if n is a prime number, False otherwise if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_prime_numbers(arr: List[int]) -> List[int]: Given a list of integers, return a list of integers that are prime numbers from the input list. Args: arr : List[int] : a list containing integer values. Returns: List[int] : a list containing only the integers from the input list that are prime numbers. return [num for num in arr if is_prime(num)]"},{"question":"# Problem Statement You are required to create a class `CustomStack` which emulates the behavior of a stack but with additional functionalities, specifically the ability to perform batch updates to elements at specified levels within the stack. 1. **Initialization**: Create the stack with an optional specified maximum size. 2. **Push Element**: Add an element to the top of the stack. If the stack is full, the element should not be inserted. 3. **Pop Element**: Remove the top element of the stack and return it. If the stack is empty, return `-1`. 4. **Increment Level**: Add a specified value to the first `k` elements of the stack. # Function Signatures ```python class CustomStack: def __init__(self, maxSize: int) -> None: Initializes the stack with a maximum size. def push(self, x: int) -> None: Adds x to the top of the stack if the stack is not full. def pop(self) -> int: Removes the top element of the stack and returns it. Returns -1 if the stack is empty. def increment(self, k: int, val: int) -> None: Increments the bottom `k` elements of the stack by `val`. If there are fewer than `k` elements, increment all elements. ``` # Input Constraints - `maxSize` will be between `1` and `1000`. - Values pushed to the stack will be integers between `-1000` and `1000`. - The number of operations will not exceed `10000`. # Example Usage ```python # Initialize the stack with maximum size 5 customStack = CustomStack(5) # Perform push operations customStack.push(1) customStack.push(2) print(customStack.pop()) # Output: 2 customStack.push(2) customStack.push(3) customStack.push(4) customStack.push(5) customStack.push(6) # Stack is full, 6 will not be added # Performing increment operations customStack.increment(3, 100) # Increment bottom 3 elements by 100 print(customStack.pop()) # Output: 104 print(customStack.pop()) # Output: 103 print(customStack.pop()) # Output: 102 print(customStack.pop()) # Output: 1 # Attempt to pop from an empty stack print(customStack.pop()) # Output: -1 ``` # Constraints - Handle cases where the stack operations are attempted on an empty stack or a full stack. - Ensure the increment operation efficiently increments the stacked elements even under max load conditions.","solution":"class CustomStack: def __init__(self, maxSize: int) -> None: self.stack = [] self.maxSize = maxSize def push(self, x: int) -> None: if len(self.stack) < self.maxSize: self.stack.append(x) def pop(self) -> int: if not self.stack: return -1 else: return self.stack.pop() def increment(self, k: int, val: int) -> None: for i in range(min(k, len(self.stack))): self.stack[i] += val"},{"question":"# Problem Statement You are required to implement a parking system for a modern parking garage. The system should be able to track available parking slots for different types of vehicles and facilitate parking and removing vehicles efficiently. # Class Specifications You need to implement the following class: `ParkingSystem` 1. **Constructor**: - Initializes parking slots for three types of vehicles: big, medium, and small. - Input parameters are: - `big: int` - the number of slots available for big vehicles - `medium: int` - the number of slots available for medium vehicles - `small: int` - the number of slots available for small vehicles Example: ```python parking_system = ParkingSystem(2, 3, 4) ``` 2. **Methods**: - `def add_car(vehicle_type: int) -> bool`: - Tries to park a car of the given vehicle type in the parking garage. - Input parameter: - `vehicle_type: int` - the type of the car (1 for a big car, 2 for a medium car, or 3 for a small car) - Return: - `True` if the car can be parked; `False` otherwise. - `def remove_car(vehicle_type: int) -> bool`: - Tries to remove a car of the given vehicle type from the parking garage. - Input parameter: - `vehicle_type: int` - the type of the car to be removed (1 for a big car, 2 for a medium car, or 3 for a small car) - Return: - `True` if a car of this type exists and is removed; `False` otherwise. # Constraints 1. The parking garage can handle a maximum of 1000 slots for each type of vehicle. 2. The `vehicle_type` will always be one of the following: 1, 2, or 3. 3. The `remove_car` method will only attempt to remove a car if it exists. # Example ```python parking_system = ParkingSystem(1, 1, 1) print(parking_system.add_car(1)) # Output: True (1 big car has been parked) print(parking_system.add_car(2)) # Output: True (1 medium car has been parked) print(parking_system.add_car(3)) # Output: True (1 small car has been parked) print(parking_system.add_car(1)) # Output: False (No more slots for big cars) print(parking_system.remove_car(1)) # Output: True (1 big car has been removed) print(parking_system.add_car(1)) # Output: True (1 big car has been parked again) print(parking_system.remove_car(2)) # Output: True (1 medium car has been removed) print(parking_system.remove_car(2)) # Output: False (No medium cars left to remove) ```","solution":"class ParkingSystem: def __init__(self, big: int, medium: int, small: int): self.slots = { 1: big, 2: medium, 3: small } self.occupied = { 1: 0, 2: 0, 3: 0 } def add_car(self, vehicle_type: int) -> bool: if self.occupied[vehicle_type] < self.slots[vehicle_type]: self.occupied[vehicle_type] += 1 return True else: return False def remove_car(self, vehicle_type: int) -> bool: if self.occupied[vehicle_type] > 0: self.occupied[vehicle_type] -= 1 return True else: return False"},{"question":"Variable Freefall Time You need to write a function that calculates the time it takes for an object to fall to the ground from various heights when allowed to freefall under gravity. The time can be calculated using the formula: [ t = sqrt{frac{2h}{g}} ] where ( h ) is the height and ( g ) is the acceleration due to gravity. For this problem, assume ( g = 9.8 , text{m/s}^2 ). Function Signature ```python def freefall_times(heights: np.ndarray) -> np.ndarray: ``` Input 1. `heights`: A numpy ndarray of non-negative numeric values representing heights in meters. Example: `np.array([10.0, 20.0, 30.0])`. Output - Return a numpy ndarray of the same shape as input, where each element represents the time (in seconds) it takes for the object to freefall from that height to the ground. Constraints - The input vector will contain at most (10^5) elements. - All heights will be in the range ([0, 500]). - Ensure that your solution handles any numerical issues with precision. Example ```python import numpy as np heights = np.array([10, 20, 30, 15, 5, 0]) result = freefall_times(heights) print(result) # Output: [1.42857143, 2.02030509, 2.47487373, 1.74642492, 1.01015254, 0.0] ``` # Notes * You may import any necessary libraries, but standard Python libraries are sufficient. * Focus on accurate and efficient computation of the times.","solution":"import numpy as np def freefall_times(heights: np.ndarray) -> np.ndarray: Calculates the time it takes for an object to fall to the ground from various heights. Parameters: heights (np.ndarray): An array of heights in meters. Returns: np.ndarray: An array of times in seconds. g = 9.8 # acceleration due to gravity in m/s^2 times = np.sqrt(2 * heights / g) # calculate freefall times using the formula return times"},{"question":"# Question: Implement a Segment Tree for Range Sum Queries You are tasked with implementing a Segment Tree to support efficient range sum queries and updates on an array of integers. Your implementation should allow you to build the tree, perform range sum queries, and update elements of the array. Your implementation should include the following functions: 1. **`build(arr: List[int]) -> SegmentTree`**: This function should build a segment tree from the given list of integers. 2. **`update(idx: int, value: int) -> None`**: This function should update the value at the given index in the segment tree. 3. **`range_sum(l: int, r: int) -> int`**: This function should return the sum of the elements in the array between indices `l` and `r` inclusive. Input and Output Formats - The **`build`** function should take a list of integers as input and return a SegmentTree object. - The **`update`** function should take an index and a new value, update the segment tree with the new value at the specified index, and return `None`. - The **`range_sum`** function should take two integers representing the inclusive range for the summation query and return the sum of the elements within that range. Constraints - All integers in the array are within the range `[0, 10^9]`. - The initial array length will be between `1` and `10^5`. - Update and query operations will be performed on valid indices within the array. Example Usage ```python # Define the initial array arr = [1, 3, 5, 7, 9, 11] # Build the segment tree tree = build(arr) # Perform a range sum query print(range_sum(1, 3)) # Expected Output: 15 (3 + 5 + 7) # Update an element update(1, 10) # Perform the range sum query again print(range_sum(1, 3)) # Expected Output: 22 (10 + 5 + 7) ``` Implement your solutions to accurately manage the Segment Tree properties and handle edge cases efficiently.","solution":"from typing import List class SegmentTree: def __init__(self, arr: List[int]): self.n = len(arr) self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr: List[int]): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the segment tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, idx: int, value: int) -> None: idx += self.n self.tree[idx] = value while idx > 1: idx //= 2 self.tree[idx] = self.tree[2 * idx] + self.tree[2 * idx + 1] def range_sum(self, l: int, r: int) -> int: l += self.n r += self.n + 1 total = 0 while l < r: if l % 2 == 1: total += self.tree[l] l += 1 if r % 2 == 1: r -= 1 total += self.tree[r] l //= 2 r //= 2 return total def build(arr: List[int]) -> SegmentTree: return SegmentTree(arr)"},{"question":"# Problem Description You are given a partially implemented Trie (prefix tree) class. Tries are commonly used for quick retrieval of a word in a dictionary and are especially efficient for problems involving prefix searches. Your task is to extend this Trie class to add additional functionality. Specifically, your tasks are: 1. Implement a method to delete a word from the Trie. 2. Implement a method to check if there is any word in the Trie that starts with a given prefix. 3. Implement a method to list all words stored in the Trie. # Function Specifications 1. **delete(word: str)**: Deletes a word from the Trie if present. - **Input**: A string `word` which needs to be deleted. - **Output**: None - **Behavior**: The method should remove the word from the Trie while maintaining the structure for other words. 2. **starts_with(prefix: str) -> bool**: Checks if there is any word in the Trie that starts with the given prefix. - **Input**: A string `prefix` to check for. - **Output**: A boolean value indicating whether any word in the Trie starts with the given prefix. - **Behavior**: Return `True` if any word in the Trie starts with the given prefix, otherwise return `False`. 3. **list_words() -> List[str]**: Returns a list of all words stored in the Trie. - **Input**: None - **Output**: A list of strings representing all words in the Trie. - **Behavior**: Traverse the Trie to collect and return all complete words stored. # Constraints - The words and prefixes consist only of lowercase English letters (\'a\' to \'z\'). - The Trie should handle operations in a time-efficient manner. # Example ```python trie = Trie() trie.insert(\\"hello\\") trie.insert(\\"helium\\") trie.insert(\\"hero\\") # Delete a word trie.delete(\\"helium\\") # Check if any word starts with a given prefix result = trie.starts_with(\\"he\\") print(result) # True result = trie.starts_with(\\"heroic\\") print(result) # False # List all words in the Trie words = trie.list_words() print(words) # [\'hello\', \'hero\'] ``` # Requirements - Ensure your implementation handles edge cases, such as deleting non-existent words or finding prefixes not present in the Trie. - Make sure the Trie operations are efficient, especially for large sets of words.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): current_node = self.root for char in word: if char not in current_node.children: current_node.children[char] = TrieNode() current_node = current_node.children[char] current_node.is_end_of_word = True def search(self, word: str) -> bool: current_node = self.root for char in word: if char not in current_node.children: return False current_node = current_node.children[char] return current_node.is_end_of_word def starts_with(self, prefix: str) -> bool: current_node = self.root for char in prefix: if char not in current_node.children: return False current_node = current_node.children[char] return True def delete(self, word: str) -> None: def _delete(node, word, depth): if node: if depth == len(word): if node.is_end_of_word: node.is_end_of_word = False return len(node.children) == 0 else: char = word[depth] if char in node.children: should_delete_current_node = _delete(node.children[char], word, depth + 1) if should_delete_current_node: del node.children[char] return len(node.children) == 0 return False _delete(self.root, word, 0) def list_words(self): def _collect_words(node, prefix): words = [] if node.is_end_of_word: words.append(prefix) for char, next_node in node.children.items(): words.extend(_collect_words(next_node, prefix + char)) return words return _collect_words(self.root, \\"\\")"},{"question":"# Coding Assessment Question: Matrix Rotation for Image Processing **Problem Statement**: You are tasked with writing a function to assist in image processing tasks, specifically rotating a matrix. This is a common task when dealing with image transformations such as rotating an image by 90 degrees. Your goal is to implement a function `rotate_matrix` that rotates a given N x N matrix (a 2D list) by 90 degrees clockwise. This transformation should not use any additional matrices for storing intermediate results. Here\'s what you should focus on: 1. **Rotate an NxN matrix**: Transpose the matrix and then reverse each row to achieve the 90-degree clockwise rotation. **Function Signature**: ```python def rotate_matrix(matrix: list[list[int]]) -> None: pass ``` **Expected Inputs**: - `matrix` (`list[list[int]]`): A 2D list of integers with dimensions NxN (where 1 <= N <= 1000). **Expected Outputs**: - Modifies the given matrix in place so that it is rotated by 90 degrees clockwise. **Constraints**: - The input matrix is always square. - Handle edge cases like minimum matrix size (1x1) efficiently. **Examples**: 1. `rotate_matrix([[1, 2], [3, 4]])` modifies the matrix to `[[3, 1], [4, 2]]` 2. `rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])` modifies the matrix to `[[7, 4, 1], [8, 5, 2], [9, 6, 3]]` **Requirements**: - Use in-place rotation (no extra space for storing intermediate matrices). - Ensure the function is efficient and runs in O(N^2) time complexity. - Include Doctests to automatically validate the rotation logic. ```python def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the matrix by 90 degrees clockwise in place. Args: - matrix (list of list of int): The NxN matrix to be rotated Returns: - None: The matrix is modified in place Examples: >>> m1 = [[1, 2], [3, 4]] >>> rotate_matrix(m1) >>> print(m1) [[3, 1], [4, 2]] >>> m2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> rotate_matrix(m2) >>> print(m2) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] N = len(matrix) for i in range(N): for j in range(i, N): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] for i in range(N): matrix[i].reverse() ```","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the matrix by 90 degrees clockwise in place. Args: - matrix (list of list of int): The NxN matrix to be rotated Returns: - None: The matrix is modified in place Examples: >>> m1 = [[1, 2], [3, 4]] >>> rotate_matrix(m1) >>> print(m1) [[3, 1], [4, 2]] >>> m2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> rotate_matrix(m2) >>> print(m2) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] N = len(matrix) for i in range(N): for j in range(i, N): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] for i in range(N): matrix[i].reverse()"},{"question":"# Coding Assessment Question Scenario You have been tasked with creating part of an inventory management system for a local bookstore. The store\'s inventory needs to be analyzed to identify the top-k most frequent book titles borrowed by customers. Each borrowing transaction is logged with the title of the book, and you are required to generate a list of the most frequently borrowed book titles. Function Definition Write a function `top_k_frequent_books(transactions: List[str], k: int) -> List[str]` that takes a list of strings representing the book titles in the borrowing transactions and an integer `k`, and returns a list of the k most frequent book titles in descending order of frequency. If there are multiple books with the same frequency, order them alphabetically. Input * `transactions` (List[str]): A list of strings where each string represents a book title borrowed in a transaction (1 ≤ len(transactions) ≤ 10^5, 1 ≤ len(title) ≤ 100). * `k` (int): The number of top frequent books to be returned (1 ≤ k ≤ len(transactions)). Output * (List[str]): A list of k most frequently borrowed book titles in descending order of frequency. In case of ties, the titles should be sorted alphabetically. Example ```python >>> transactions = [ \\"To Kill a Mockingbird\\", \\"1984\\", \\"Harry Potter and the Philosopher\'s Stone\\", \\"To Kill a Mockingbird\\", \\"1984\\", \\"Harry Potter and the Philosopher\'s Stone\\", \\"To Kill a Mockingbird\\" ] >>> k = 2 >>> top_k_frequent_books(transactions, k) [\\"To Kill a Mockingbird\\", \\"1984\\"] >>> transactions = [\\"The Great Gatsby\\", \\"The Great Gatsby\\", \\"Crime and Punishment\\", \\"Crime and Punishment\\", \\"War and Peace\\"] >>> k = 2 >>> top_k_frequent_books(transactions, k) [\\"Crime and Punishment\\", \\"The Great Gatsby\\"] ``` Constraints * The list can be large, so the solution should be optimized for both time and space complexity. * The titles are case-sensitive and should be treated as unique even if they differ only in case. Performance Requirements Your solution should efficiently handle the upper limit of input size and maintain the required order of frequency and alphabetical ties. Edge Cases to Consider * If `k` equals the number of unique book titles, return the sorted, most frequent titles. * Handle scenarios where multiple titles have the same frequency and sort them alphabetically.","solution":"from typing import List from collections import Counter def top_k_frequent_books(transactions: List[str], k: int) -> List[str]: Returns the k most frequently borrowed book titles from the transactions list. If there are ties, the titles are sorted alphabetically. :param transactions: List of book titles in transactions. :param k: The number of top frequent books to return. :returns: List of k most frequent book titles in descending order of frequency. # Count the frequency of each book title count = Counter(transactions) # Sort the books first by frequency (descending) and then alphabetically sorted_books = sorted(count.items(), key=lambda x: (-x[1], x[0])) # Extract the top k book titles top_k_books = [book for book, freq in sorted_books[:k]] return top_k_books"},{"question":"# Coding Assessment Question Problem Statement You are given an undirected graph represented as an adjacency matrix and a starting vertex. Your task is to implement the Depth-First Search (DFS) algorithm to check whether the given graph is bipartite. A graph is bipartite if you can partition its set of vertices into two disjoint sets such that no two graph vertices within the same set are adjacent. Function Signature ```python def is_bipartite(graph, start): Determines if the undirected graph is bipartite starting from the given vertex. Parameters: graph (List[List[int]]): An adjacency matrix representing the graph. A 2D list where graph[i][j] is 1 if there is an edge between node i and node j, otherwise 0. start (int): The starting vertex. Returns: bool: True if the graph is bipartite, False otherwise. # your code here ``` Input Format - `graph`: A 2D list where graph[i][j] represents whether there is an edge between node i and node j (1 if there is an edge, 0 otherwise). - `start`: An integer representing the starting vertex. Output Format - A boolean value: `True` if the graph is bipartite, `False` otherwise. Constraints - The number of vertices ( V ) ( (1 leq V leq 100) ). - The adjacency matrix will contain only 0s and 1s. - The graph is undirected, which means `graph[i][j]` is equal to `graph[j][i]`. Example Given the graph: ```python test_graph = [ [0, 1, 0, 1], [1, 0, 1, 1], [0, 1, 0, 0], [1, 1, 0, 0] ] ``` with `start = 0`, calling `is_bipartite(test_graph, 0)` should return: ``` False ``` Given the graph: ```python test_graph = [ [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0] ] ``` with `start = 0`, calling `is_bipartite(test_graph, 0)` should return: ``` True ``` # Requirements 1. Implement the DFS algorithm to traverse the graph. 2. Use the traversal to check for bipartiteness by attempting to color the graph using two colors. 3. Return `True` if the graph can be colored with two colors such that no two adjacent vertices share the same color, otherwise return `False`.","solution":"def is_bipartite(graph, start): def dfs(v, color): colors[v] = color for u in range(len(graph)): if graph[v][u] == 1: # There is an edge between v and u if colors[u] == -1: # If this vertex has not been colored yet if not dfs(u, 1 - color): # Try to color with the opposite color return False elif colors[u] == color: # If the vertex has the same color, it\'s not bipartite return False return True # Initialize color assignment (-1 means no color assigned yet) colors = [-1] * len(graph) # Start DFS to color the graph return dfs(start, 0)"},{"question":"# Coding Assessment Question Problem Statement You are given an array of integers and a target integer `k`. Implement a function that finds all unique pairs of integers in the array whose sum equals `k`. Function Signature ```python def find_pairs_with_sum(nums: List[int], target: int) -> List[Tuple[int, int]]: Find all unique pairs in the array that sum up to the given target. :param nums: The list of integers. :param target: The target sum for the pairs. :return: A list of tuples, where each tuple contains a pair of integers that add up to `target`. ``` Input Format * A list of integers `nums`. * An integer `target`. Output Format * A list of tuples containing all unique pairs that sum to `target`. Example ```python nums = [1, 2, 3, 4, 3, 2, 1] target = 5 print(find_pairs_with_sum(nums, target)) # Output: [(1, 4), (2, 3)] ``` Constraints * The array can contain up to (10^4) integers. * Integers in the array can be positive, negative, or zero. * The resulting list should not contain duplicate pairs and each pair should be sorted in ascending order. Implementation Notes * Consider using a set to keep track of the pairs and ensure uniqueness. * Take care of edge cases such as when the array is empty or when no pairs add up to the target. * The provided solution should be efficient enough to handle edge cases within the constraints.","solution":"from typing import List, Tuple def find_pairs_with_sum(nums: List[int], target: int) -> List[Tuple[int, int]]: seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add(tuple(sorted((complement, num)))) seen.add(num) return list(pairs)"},{"question":"# Coding Assessment Question Context You are developing a game that involves various levels of challenges. To determine the difficulty for each player, you need to calculate the average score they have achieved across different levels. Each player\'s score data comprises multiple entries, which needs to be summarized efficiently. Task Write a function `average_score` that calculates the average score for each player given a list of score entries. Each score entry represents a player\'s ID, the level ID, and the score they obtained in that specific level. The function should handle edge cases such as no score entries provided. Function Signature ```python def average_score(score_entries: list[ScoreEntry]) -> dict: ``` Input - `score_entries`: A list of `ScoreEntry` objects where each entry is a named tuple with fields `player_id`, `level_id`, and `score`. Output - A dictionary where keys are player IDs and values are the average scores rounded to two decimal places. Constraints - Each score entry must have a valid `player_id`, `level_id`, and a non-negative `score`. - The list of score entries may be empty. - If the score of any entry is negative, the function should raise a `ValueError` with the message \\"Scores must be non-negative\\". - If the list of score entries is empty, the function should return an empty dictionary. Examples ```python >>> average_score([ ... ScoreEntry(\'player1\', \'level1\', 85), ... ScoreEntry(\'player2\', \'level1\', 90), ... ScoreEntry(\'player1\', \'level2\', 78), ... ScoreEntry(\'player2\', \'level2\', 82), ... ScoreEntry(\'player1\', \'level3\', 93) ... ]) {\'player1\': 85.33, \'player2\': 86.0} >>> average_score([ ... ScoreEntry(\'player1\', \'level1\', 70), ... ScoreEntry(\'player1\', \'level2\', 80) ... ]) {\'player1\': 75.0} >>> average_score([ ... ScoreEntry(\'player1\', \'level1\', 100), ... ScoreEntry(\'player2\', \'level1\', -50) ... ]) Traceback (most recent call last): ... ValueError: Scores must be non-negative ``` Use the provided `ScoreEntry` namedtuple definition for structuring the input data. ```python from collections import namedtuple ScoreEntry = namedtuple(\\"ScoreEntry\\", \\"player_id level_id score\\") ``` Your task is to implement the `average_score` function to match the above specifications.","solution":"from collections import namedtuple from typing import List, Dict ScoreEntry = namedtuple(\\"ScoreEntry\\", \\"player_id level_id score\\") def average_score(score_entries: List[ScoreEntry]) -> Dict[str, float]: if not score_entries: return {} player_scores = {} for entry in score_entries: if entry.score < 0: raise ValueError(\\"Scores must be non-negative\\") if entry.player_id not in player_scores: player_scores[entry.player_id] = [] player_scores[entry.player_id].append(entry.score) average_scores = {} for player, scores in player_scores.items(): average_scores[player] = round(sum(scores) / len(scores), 2) return average_scores"},{"question":"# Problem Statement: You are provided with an input string consisting of lowercase alphabetical characters. Your task is to implement two methods to determine the length of the longest substring that contains unique characters. Each solution should be encapsulated in a function with the following specifications: Functions Specifications: 1. **Using Sliding Window Algorithm** ```python def longest_unique_substring_sliding_window(s: str) -> int: Determines the length of the longest substring with unique characters using the Sliding Window Algorithm. :param s: Input string consisting of lowercase alphabetical characters. :return: The length of the longest substring with all unique characters. ``` 2. **Using Hash Set** ```python def longest_unique_substring_hash_set(s: str) -> int: Determines the length of the longest substring with unique characters using a Hash Set. :param s: Input string consisting of lowercase alphabetical characters. :return: The length of the longest substring with all unique characters. ``` Example: ```python >>> longest_unique_substring_sliding_window(\\"abcabcbb\\") 3 >>> longest_unique_substring_hash_set(\\"abcabcbb\\") 3 >>> longest_unique_substring_sliding_window(\\"bbbbb\\") 1 >>> longest_unique_substring_hash_set(\\"bbbbb\\") 1 >>> longest_unique_substring_sliding_window(\\"pwwkew\\") 3 >>> longest_unique_substring_hash_set(\\"pwwkew\\") 3 >>> longest_unique_substring_sliding_window(\\"\\") 0 >>> longest_unique_substring_hash_set(\\"\\") 0 ``` Constraints: * The input string `s` will only consist of lowercase alphabetical characters (`a` to `z`). * Performance matters for longer strings, so ensure your solution is optimized for efficiency. # Requirements: * Carefully handle edge cases, such as an empty string. * Benchmark and compare the performance of both functions using long strings, and include your findings in your submission. This problem tests the candidates\' understanding of string manipulation, implementation of sliding window, and utilization of hash sets for efficient lookup and iteration. The focus here is on both algorithmic thinking and performance optimization.","solution":"def longest_unique_substring_sliding_window(s: str) -> int: Determines the length of the longest substring with unique characters using the Sliding Window Algorithm. :param s: Input string consisting of lowercase alphabetical characters. :return: The length of the longest substring with all unique characters. n = len(s) if n == 0: return 0 max_length = 0 start = 0 char_index_map = {} for end in range(n): if s[end] in char_index_map: # Move start to the right of the previous index of s[end] start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length def longest_unique_substring_hash_set(s: str) -> int: Determines the length of the longest substring with unique characters using a Hash Set. :param s: Input string consisting of lowercase alphabetical characters. :return: The length of the longest substring with all unique characters. n = len(s) if n == 0: return 0 max_length = 0 start = 0 char_set = set() for end in range(n): while s[end] in char_set: char_set.remove(s[start]) start += 1 char_set.add(s[end]) max_length = max(max_length, end - start + 1) return max_length"},{"question":"# Problem Statement Write a function `compute_running_median(numbers: List[int]) -> List[float]` to compute the running median for a sequence of integers. The running median of a sequence up to a given element is the median of all elements seen so far. The median is the middle value of a sorted list of numbers. If the list contains an even number of elements, the median is the average of the two middle elements. Your task is to maintain the running medians after each new number is added to the sequence. # Input * `numbers`: A list of integers where 1 ≤ `len(numbers)` ≤ 10^5 and -10^9 ≤ `numbers[i]` ≤ 10^9. # Output * A list of floats representing the running medians after each integer is added to the sequence. # Example ```python def compute_running_median(numbers): import heapq min_heap = [] max_heap = [] medians = [] for num in numbers: heapq.heappush(max_heap, -heapq.heappushpop(min_heap, num)) if len(max_heap) > len(min_heap): heapq.heappush(min_heap, -heapq.heappop(max_heap)) if len(min_heap) == len(max_heap): medians.append((min_heap[0] - max_heap[0]) / 2.0) else: medians.append(float(min_heap[0])) return medians # Example usage numbers = [2, 1, 5, 7, 2, 0, 5] medians = compute_running_median(numbers) print(medians) # Output should be: [2.0, 1.5, 2.0, 3.5, 2.0, 2.0, 2.0] ``` # Constraints - Utilize efficient data structures to achieve a time complexity of O(log n) for each median computation. - Handle both positive and negative integers. - Ensure numerical precision for the median values. # Requirements * Maintain two heaps, one min-heap for the larger half of the numbers and one max-heap for the smaller half of the numbers. * Balance the heaps after each insertion to ensure that their sizes differ by at most one element. * Calculate the running median after each insertion into the sequence. * Handle both edge cases of even and odd number of total elements properly.","solution":"import heapq from typing import List def compute_running_median(numbers: List[int]) -> List[float]: Compute the running median for a sequence of integers. Args: numbers (List[int]): List of integers. Returns: List[float]: List of running medians as floats. min_heap = [] max_heap = [] medians = [] for num in numbers: heapq.heappush(max_heap, -heapq.heappushpop(min_heap, num)) if len(max_heap) > len(min_heap): heapq.heappush(min_heap, -heapq.heappop(max_heap)) if len(min_heap) == len(max_heap): medians.append((min_heap[0] - max_heap[0]) / 2.0) else: medians.append(float(min_heap[0])) return medians"},{"question":"# Coding Assessment Question You are tasked with writing a Python function to process a list of tasks, prioritize them according to certain criteria, and return the reordered list. **Function Description:** Write a function `prioritize_tasks(task_list: list) -> list` that takes a list of tasks, each represented as a dictionary, prioritizes them based on specific rules, and returns a new list with tasks ordered by their priority. Input: * `task_list` (list): A list of dictionaries, where each dictionary represents a task with the following keys: - `title` (str): The title of the task. - `priority` (str): The priority of the task, which can be \\"low\\", \\"medium\\", or \\"high\\". - `created_at` (str): A timestamp (formatted as \\"YYYY-MM-DD HH:MM:SS\\") representing when the task was created. Output: * A list of tasks (dictionaries) ordered by their priority. If two tasks have the same priority, order them by their creation time with the earliest task first. Sorting Criteria: 1. Tasks with \\"high\\" priority should appear before \\"medium\\" priority tasks, which should appear before \\"low\\" priority tasks. 2. Within the same priority level, order tasks by their `created_at` timestamp in ascending order (earlier tasks first). Example: For a list of tasks like this: ```python [ {\\"title\\": \\"Task A\\", \\"priority\\": \\"low\\", \\"created_at\\": \\"2023-10-01 10:00:00\\"}, {\\"title\\": \\"Task B\\", \\"priority\\": \\"high\\", \\"created_at\\": \\"2023-10-02 09:00:00\\"}, {\\"title\\": \\"Task C\\", \\"priority\\": \\"medium\\", \\"created_at\\": \\"2023-10-01 12:00:00\\"}, {\\"title\\": \\"Task D\\", \\"priority\\": \\"high\\", \\"created_at\\": \\"2023-10-01 08:00:00\\"} ] ``` The output should be: ```python [ {\\"title\\": \\"Task D\\", \\"priority\\": \\"high\\", \\"created_at\\": \\"2023-10-01 08:00:00\\"}, {\\"title\\": \\"Task B\\", \\"priority\\": \\"high\\", \\"created_at\\": \\"2023-10-02 09:00:00\\"}, {\\"title\\": \\"Task C\\", \\"priority\\": \\"medium\\", \\"created_at\\": \\"2023-10-01 12:00:00\\"}, {\\"title\\": \\"Task A\\", \\"priority\\": \\"low\\", \\"created_at\\": \\"2023-10-01 10:00:00\\"} ] ``` Constraints: * You must use the built-in `sorted` function for sorting. * Assume all timestamps are valid and properly formatted. # Notes - The `priority` field can only be \\"low\\", \\"medium\\", or \\"high\\". - The sorting should be stable, meaning that if two tasks have the same priority and creation time, their original order should be preserved. **Hints:** - Consider using a tuple of (priority, creation time) for the sorting key. - You may find it useful to map priority levels to numerical values to simplify the comparison.","solution":"def prioritize_tasks(task_list: list) -> list: Prioritizes tasks based on priority and creation time. :param task_list: List of dictionaries where each dictionary contains - title (str) - priority (str): \\"low\\", \\"medium\\", \\"high\\" - created_at (str): \\"YYYY-MM-DD HH:MM:SS\\" :return: List of dictionaries sorted by priority and creation time. priority_map = {\\"high\\": 1, \\"medium\\": 2, \\"low\\": 3} return sorted(task_list, key=lambda task: (priority_map[task[\'priority\']], task[\'created_at\']))"},{"question":"# RSA Key Pair Generation and Encryption RSA is a widely used asymmetric encryption algorithm. The RSA algorithm uses a pair of keys, a public key for encryption, and a private key for decryption. Generating these keys requires selecting two large prime numbers and performing some mathematical operations. **Your task** is to implement the RSA key pair generation and the encryption and decryption methods in Python. You should write three functions: `generate_keys`, `encrypt_message`, and `decrypt_message` according to the RSA algorithm. Requirements: 1. **generate_keys(bits: int) -> (int, int, int)** - Generate an RSA key pair (public and private keys). 2. **encrypt_message(message: str, public_key: (int, int)) -> list** - Encrypt the message using the RSA public key. 3. **decrypt_message(encrypted_message: list, private_key: (int, int), n: int) -> str** - Decrypt an RSA-encrypted message. Function Definitions and Arguments: - `generate_keys(bits: int) -> (int, int, int)`: - `bits`: Number of bits for the primes to be generated. - Returns a tuple containing the public key (e, n) and the private key (d, n). - `encrypt_message(message: str, public_key: (int, int)) -> list`: - `message`: String to be encrypted. - `public_key`: Tuple (e, n), the public key for RSA encryption. - Returns a list of integers representing the encrypted message. - `decrypt_message(encrypted_message: list, private_key: (int, int), n: int) -> str`: - `encrypted_message`: List of integers that represent the encrypted message. - `private_key`: Tuple (d, n), the private key for RSA decryption. - `n`: Integer, part of the private and public key. - Returns the decrypted string message. Constraints: - Prime number generation should use a cryptographic library or method to ensure security. - The `bits` parameter should be a positive integer representing the bit length of primes. - The message to be encrypted should only contain ASCII characters. Examples: ```python # Key Generation Example public_key, private_key, n = generate_keys(1024) # Encryption Example public_key = (65537, 999333599) encrypted_message = encrypt_message(\\"Hello, World!\\", public_key) assert isinstance(encrypted_message, list) # Decryption Example private_key = (2134319343, 999333599) decrypted_message = decrypt_message(encrypted_message, private_key, 999333599) assert decrypted_message == \\"Hello, World!\\" ``` **Notes**: - Focus on proper handling of encryption and decryption ensuring message integrity. - Consider security best practices for prime number generation and key sizes. - Handle edge cases like invalid keys or excessively large messages appropriately. This question requires understanding of RSA encryption, including key generation, message encoding, and secure prime number handling. It matches the complexity and scope of the sample questions provided.","solution":"import random import sympy def generate_keys(bits: int): Generate an RSA key pair. :param bits: Number of bits for the primes to be generated. :return: Tuple containing the public key (e, n) and private key (d, n). p = sympy.randprime(2**(bits - 1), 2**bits) q = sympy.randprime(2**(bits - 1), 2**bits) while p == q: q = sympy.randprime(2**(bits - 1), 2**bits) n = p * q phi = (p - 1) * (q - 1) e = sympy.randprime(1, phi) while sympy.gcd(e, phi) != 1: e = sympy.randprime(1, phi) d = pow(e, -1, phi) return (e, n), (d, n) def encrypt_message(message: str, public_key: (int, int)): Encrypt the message using the RSA public key. :param message: String to be encrypted. :param public_key: Tuple (e, n), the public key for RSA encryption. :return: List of integers representing the encrypted message. e, n = public_key encrypted_message = [pow(ord(char), e, n) for char in message] return encrypted_message def decrypt_message(encrypted_message: list, private_key: (int, int), n: int): Decrypt an RSA-encrypted message. :param encrypted_message: List of integers that represent the encrypted message. :param private_key: Tuple (d, n), the private key for RSA decryption. :param n: Integer, part of the private and public key. :return: Decrypted string message. d, n = private_key decrypted_message = \'\'.join([chr(pow(char, d, n)) for char in encrypted_message]) return decrypted_message"},{"question":"# Problem Statement You are required to create a program that simulates a simple text editor with undo and redo functionalities. The functionalities should include inserting text, deleting text, undoing the last operation, and redoing the last undone operation. # Requirements 1. **Class Definition**: Define the class `TextEditor` with the required methods. 2. **Insert Method**: Implement the `insert` method to add text at the end of the current content. 3. **Delete Method**: Implement the `delete` method to remove the last `k` characters from the current content. 4. **Undo Method**: Implement the `undo` method to revert the last operation (either insert or delete). 5. **Redo Method**: Implement the `redo` method to reapply the last undone operation. 6. **Content Property**: Create a `content` property to return the current state of the text editor. 7. **Edge Cases Handling**: Ensure that all methods gracefully handle cases such as undoing when no operations are present or redoing when no operations are undone. 8. **Constraints**: - Text operations should be efficient and support at least 10^4 operations. # Function Signature ```python class TextEditor: def insert(self, text: str) -> None: # Your code here def delete(self, k: int) -> None: # Your code here def undo(self) -> None: # Your code here def redo(self) -> None: # Your code here @property def content(self) -> str: # Your code here ``` # Input and Output * `insert(text: str) -> None`: inserts the text at the end of the current content. * `delete(k: int) -> None`: deletes the last `k` characters from the current content. * `undo() -> None`: reverts the last operation (Insert or Delete). * `redo() -> None`: reapplies the last undone operation. * `content -> str`: returns the current content of the text editor. # Example ```python editor = TextEditor() editor.insert(\\"Hello\\") editor.insert(\\" World\\") print(editor.content) # Output: \\"Hello World\\" editor.delete(6) print(editor.content) # Output: \\"Hello\\" editor.undo() print(editor.content) # Output: \\"Hello World\\" editor.redo() print(editor.content) # Output: \\"Hello\\" ``` # Performance Requirements * Ensure that all operations handle and perform efficiently for up to 10^4 operations. * Optimized handling of the undo and redo operations for quick access and updates. # Evaluation Criteria * **Correctness**: Accurate implementation of all required methods. * **Efficiency**: Time and space complexity of the solution must meet the requirements. * **Robustness**: Handling edge cases and constraints properly. * **Code Quality**: Clean, readable, and maintainable code.","solution":"class TextEditor: def __init__(self): self._content = \\"\\" self._undo_stack = [] self._redo_stack = [] def insert(self, text: str) -> None: self._undo_stack.append((\\"delete\\", len(text))) self._redo_stack.clear() self._content += text def delete(self, k: int) -> None: deleted_text = self._content[-k:] self._undo_stack.append((\\"insert\\", deleted_text)) self._redo_stack.clear() self._content = self._content[:-k] def undo(self) -> None: if self._undo_stack: operation, value = self._undo_stack.pop() if operation == \\"insert\\": self._redo_stack.append((\\"delete\\", len(value))) self._content += value elif operation == \\"delete\\": self._redo_stack.append((\\"insert\\", self._content[-value:])) self._content = self._content[:-value] def redo(self) -> None: if self._redo_stack: operation, value = self._redo_stack.pop() if operation == \\"insert\\": self._undo_stack.append((\\"delete\\", len(value))) self._content += value elif operation == \\"delete\\": self._undo_stack.append((\\"insert\\", self._content[-value:])) self._content = self._content[:-value] @property def content(self) -> str: return self._content"},{"question":"# Problem: Generating Fibonacci Sequence using Binet\'s Formula You are required to implement a function that generates the first `n` elements of the Fibonacci sequence using Binet’s formula. Binet’s formula provides an analytical method to find the nth Fibonacci number without iterating or using recursion. The formula is as follows: [ F(n) = frac{phi^n - hat{phi}^n}{sqrt{5}} ] where: - ( phi = frac{1 + sqrt{5}}{2} ) - ( hat{phi} = frac{1 - sqrt{5}}{2} ) Your task is to write a function `fibonacci_binet` that takes an integer `n` and returns a list containing the first `n` Fibonacci numbers. # Constraints: - `n geq 1` - The result should be correct up to the first 15 decimal places. # Expected Function Signature: ```python def fibonacci_binet(n: int) -> List[float]: pass ``` # Example: ```python # Get the first 10 Fibonacci numbers fib_sequence = fibonacci_binet(10) print(fib_sequence) # Output: [0.0, 1.0, 1.0, 2.0, 3.0, 5.0, 8.0, 13.0, 21.0, 34.0] ``` # Notes: 1. Ensure that you handle the case where `n` is less than 1 by raising a `ValueError`. 2. Use the `math.sqrt` function for computing the square root. 3. The returned values should be floating-point numbers. 4. Make sure the output matches the actual Fibonacci sequence precisely. Your function will be tested with various values of `n` to verify correctness and performance.","solution":"import math from typing import List def fibonacci_binet(n: int) -> List[float]: if n < 1: raise ValueError(\\"n must be greater than or equal to 1\\") phi = (1 + math.sqrt(5)) / 2 hat_phi = (1 - math.sqrt(5)) / 2 def binet_formula(k): return (phi**k - hat_phi**k) / math.sqrt(5) return [round(binet_formula(i)) for i in range(n)]"},{"question":"# Coding Assessment Question: Parenthesis Balancer with Enhanced Error Checking You are implementing a syntax checker for a code editor that verifies the proper use of parentheses in the code. Your responsibility is to enhance the basic parentheses balancing function to include detailed error checking and reporting. Your task is to create a function that: 1. Checks if the input string contains only valid characters (parentheses `()`, curly braces `{}`, and square brackets `[]`). If an invalid character is found, the function should return an error message. 2. Checks if the parentheses are balanced and correctly nested. 3. Returns a specific error message if the input string is empty. **Function Specification** ```python def check_parentheses(expression: str) -> str: Check if the given expression has balanced and correctly nested parentheses. Parameters: expression (str): The expression to be checked. Returns: str: \\"Balanced and Nested\\" if the parentheses are balanced and correctly nested, or a specific error message otherwise. ``` # Input * A string `expression` representing the code snippet to be checked for balanced parentheses. This can include any combination of parentheses `()`, curly braces `{}`, and square brackets `[]`. # Output * Return \\"Balanced and Nested\\" if the parentheses in the expression are both balanced and correctly nested. * Return \\"Empty input\\" if the input string is empty. * Return \\"Invalid character found\\" if the input string contains any characters other than `()`, `{}`, `[]`. * Return \\"Unbalanced parentheses\\" if the parentheses are not balanced correctly or are incorrectly nested. # Constraints * The function should handle strings of arbitrary length, including very large ones. * The focus should be on correctness and detailed error reporting. # Example ```python print(check_parentheses(\\"(){}[]\\")) # \\"Balanced and Nested\\" print(check_parentheses(\\"([{}])\\")) # \\"Balanced and Nested\\" print(check_parentheses(\\"([)]\\")) # \\"Unbalanced parentheses\\" print(check_parentheses(\\"((()))]]\\"))# \\"Unbalanced parentheses\\" print(check_parentheses(\\"{[a]}\\")) # \\"Invalid character found\\" print(check_parentheses(\\"\\")) # \\"Empty input\\" ``` # Notes - Ensure your function works efficiently with large inputs. - Provide reasoning in your comments for any specific approaches or data structures used.","solution":"def check_parentheses(expression: str) -> str: Check if the given expression has balanced and correctly nested parentheses. Parameters: expression (str): The expression to be checked. Returns: str: \\"Balanced and Nested\\" if the parentheses are balanced and correctly nested, or a specific error message otherwise. if expression == \\"\\": return \\"Empty input\\" valid_chars = {\\"(\\", \\")\\", \\"{\\", \\"}\\", \\"[\\", \\"]\\"} for char in expression: if char not in valid_chars: return \\"Invalid character found\\" stack = [] matching_parentheses = {\\")\\": \\"(\\", \\"}\\": \\"{\\", \\"]\\": \\"[\\"} for char in expression: if char in \\"({[\\": stack.append(char) elif char in \\")}]\\": if not stack: return \\"Unbalanced parentheses\\" if stack[-1] == matching_parentheses[char]: stack.pop() else: return \\"Unbalanced parentheses\\" if stack: return \\"Unbalanced parentheses\\" return \\"Balanced and Nested\\""},{"question":"# Problem: Circular Array Rotation You are developing a function to perform operations on an array by rotating its elements. The array is \\"circular,\\" meaning elements moved off one end reappear on the other. Specifically, you need to support rotations to the right, and determine the content of the array after a series of operations. Problem Statement Given an integer array `arr` and an integer `k`, rotate the array to the right by `k` steps, and return the resulting array. Circular array rotation means that elements shifted off the end of the array will reappear at the beginning. Implement the function `circular_array_rotation(arr: list[int], k: int) -> list[int]`: * **Input**: A list of integers `arr` with length `n` (1 ≤ n ≤ 10^5), and an integer `k` (0 ≤ k ≤ 10^9) representing the number of steps to rotate the array. * **Output**: A list representing the array after `k` rotations to the right. Constraints * The elements of `arr` are integers. * The integer array `arr` can be empty; return an empty list if it is. Example ```python >>> circular_array_rotation([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> circular_array_rotation([7, 9, 11], 5) [9, 11, 7] >>> circular_array_rotation([3, 8, 9, 7, 6], 3) [9, 7, 6, 3, 8] ``` Guidelines * **Edge Cases**: Handle cases where `k` is larger than the length of `arr`. * **Performance**: Take care to optimize the function to handle large values of `k` efficiently. * The function should work correctly even if `arr` is empty or if `k` is zero. # Explanation In the example `circular_array_rotation([1, 2, 3, 4, 5], 2)`, the array is rotated to the right by 2 steps. The outcome is `[4, 5, 1, 2, 3]`. The elements `4` and `5`, originally at positions 3 and 4, move to the beginning of the array, while the others are shifted right by 2 positions.","solution":"def circular_array_rotation(arr, k): Rotate the array to the right by k steps. Parameters: arr (list of int): The array to be rotated. k (int): The number of steps to rotate the array. Returns: list of int: The rotated array. n = len(arr) if n == 0 or k % n == 0: return arr k = k % n # To handle the case when k > n return arr[-k:] + arr[:-k]"},{"question":"**Problem Statement: Design a Custom Round Function** Implement a robust and efficient function to round a floating-point number to the nearest integer, with specific handling for halfway cases. # Function Signature ```python def custom_round(x: float) -> int: Return the rounded value of x to the nearest integer, with specific handling for midway cases. Parameters: x (float): The input floating-point number. Returns: int: Nearest integer to the input float. If x is exactly midway between two integers, round towards the even integer. ``` # Requirements 1. The function should correctly round numbers to the nearest integer. 2. For numbers exactly halfway between two integers (e.g., 2.5, 3.5, -1.5), the function should round towards the nearest even integer. 3. The function should handle very large and very small floating-point numbers accurately. 4. It must not use any external libraries (such as Python\'s built-in `round` function). 5. Provide documentation and at least 5 test cases demonstrating the correctness, including edge cases. # Input Format - A single float, ( x le 10^{18} ) or ( x ge -10^{18} ). # Output Format - An integer representing the nearest integer to the input float, with specified handling for halfway cases. # Constraints - The function should work within the float precision limits of Python. # Example ```python >>> custom_round(2.6) 3 >>> custom_round(2.5) 2 >>> custom_round(3.5) 4 >>> custom_round(-1.5) -2 >>> custom_round(999_999_999.5) 1_000_000_000 ``` Ensure to clearly document your function to enlighten the readers about your approach and edge cases considered. --- This problem is similar in style, complexity, and topic to the given sample question while testing a different aspect of numerical handling in floating-point operations.","solution":"def custom_round(x: float) -> int: Return the rounded value of x to the nearest integer, with specific handling for midway cases. Parameters: x (float): The input floating-point number. Returns: int: Nearest integer to the input float. If x is exactly midway between two integers, round towards the even integer. if x > 0: lower = int(x) upper = lower + 1 else: lower = int(x) - 1 upper = lower + 1 diff_lower = abs(x - lower) diff_upper = abs(x - upper) if diff_lower < diff_upper: return lower elif diff_upper < diff_lower: return upper else: # x is exactly midway between lower and upper if lower % 2 == 0: return lower else: return upper"},{"question":"# Question: Generate Combinations of Strings You are tasked with implementing a function that generates all possible combinations of a given string of distinct characters using a backtracking technique. The function should take a string as input and return a list of strings, where each string represents a unique combination of characters from the input. Requirements: - Implement a function `generate_combinations(s: str) -> list[str]` that performs the task. - The function should generate combinations of varying lengths, from 1 character up to the length of the input string. - Do not use Python\'s built-in library functions for combinations. - Aim for time complexity of `O(2^n * n)` and space complexity of `O(n)`, where `n` is the length of the input string. Constraints: - The input string `s` will have distinct characters. - The length of `s` will not exceed 15. # Input Example: ```python s = \\"abc\\" ``` # Output Example: ```python [\\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"ac\\", \\"bc\\", \\"abc\\"] ``` # Implementation Challenge: - Consider all edge cases, including input strings containing empty strings or one character. # Performance Considerations: - Ensure that your solution efficiently handles the required combinations within the given constraints.","solution":"def generate_combinations(s: str) -> list[str]: Generate all possible combinations of the given string using backtracking. result = [] def backtrack(start, path): # If path is not empty, append it to the result if path: result.append(\\"\\".join(path)) # Generate combinations by including one character at a time for i in range(start, len(s)): # Add the character to the current combination path.append(s[i]) # Recur with next starting index backtrack(i + 1, path) # Backtrack by removing the last character path.pop() # Start backtracking from the beginning of the string backtrack(0, []) return result"},{"question":"# Coding Assessment Question: Largest Palindromic Substring Your task is to find the largest palindromic substring within a given string. A palindrome is a word that reads the same forward and backward. For example, \\"madam\\" is a palindrome. # Input Format A single string `s` (1 ≤ |`s`| ≤ 1000). The string consists of lowercase and uppercase English letters. # Output Format Return the largest palindromic substring present in the input string. If there are multiple substrings of the same maximum length, return the first one that appears. # Constraints * The input string will always be valid, containing only English letters. * The solution should be efficient to handle up to the upper bound of the input length. # Example Example 1: ```python >> solution(\\"babad\\") ``` **Output:** ```python \\"bab\\" ``` (Note: \\"aba\\" is also a valid answer, \\"bab\\" appears first) Example 2: ```python >> solution(\\"cbbd\\") ``` **Output:** ```python \\"bb\\" ``` # Function Signature ```python def solution(s: str) -> str: pass ``` # Explanation: For the given example strings: * Implement a function to expand around the center of the string to check for the longest palindromic substring. * Iterate over each character, considering both odd and even-length palindromes. * Track the maximum length and corresponding substring using two pointers or a similar approach. Good luck!","solution":"def solution(s: str) -> str: def expand_around_center(left: int, right: int) -> str: while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] if s == \\"\\": return \\"\\" max_palindrome = \\"\\" for i in range(len(s)): # Check for odd length palindromes palindrome1 = expand_around_center(i, i) # Check for even length palindromes palindrome2 = expand_around_center(i, i + 1) # Update the max_palindrome if we find a longer one if len(palindrome1) > len(max_palindrome): max_palindrome = palindrome1 if len(palindrome2) > len(max_palindrome): max_palindrome = palindrome2 return max_palindrome"},{"question":"# String Permutation Check Given two strings `s1` and `s2`, write a function that determines if one string is a permutation of the other. Two strings are permutations of each other if they contain the same characters with the same frequencies. Function Signature ```python def are_permutations(s1: str, s2: str) -> bool: ``` Input - `s1`: A string consisting of lowercase English letters. - `s2`: Another string consisting of lowercase English letters. Output - Returns a boolean value `True` if `s1` is a permutation of `s2`, otherwise returns `False`. Example ```python s1 = \\"listen\\" s2 = \\"silent\\" are_permutations(s1, s2) # Should return True s1 = \\"hello\\" s2 = \\"billion\\" are_permutations(s1, s2) # Should return False ``` Constraints 1. The length of `s1` and `s2` is between 1 and 100,000. 2. Both strings consist of only lowercase English letters. # Additional Details The function should: 1. Consider edge cases where strings are of different lengths. 2. Efficiently compute the character counts to compare the two strings. 3. Handle large input sizes within a reasonable time frame, ensuring optimal performance. # Remarks Feel free to add additional helper functions if necessary, but the main logic must reside within `are_permutations`. The function will only consider valid English lowercase letters; however, proper defensive coding checks for input type and validity might still be recommended.","solution":"from collections import Counter def are_permutations(s1: str, s2: str) -> bool: Determines if one string is a permutation of the other. if len(s1) != len(s2): return False return Counter(s1) == Counter(s2) # Example Usage # s1 = \\"listen\\" # s2 = \\"silent\\" # print(are_permutations(s1, s2)) # Should return True # s1 = \\"hello\\" # s2 = \\"billion\\" # print(are_permutations(s1, s2)) # Should return False"},{"question":"# Binary Search Tree (BST) Insertion **Objective**: Assess the student\'s ability to implement a fundamental data structure, namely a binary search tree, and understand operations on that data structure. **Task**: Write a Python class `BinarySearchTree` with methods to insert elements into the tree and check if a given value is present in the tree. The class should document the core tree operations, edge handling, and expected behavior. **Function Details**: ```python class BinarySearchTree: def __init__(self): Initialize an empty BST. self.root = None class TreeNode: def __init__(self, value: int): Node of a BST. self.left = None self.right = None self.value = value def insert(self, value: int) -> None: Insert a new value into the BST. Parameters: - value (int): The value to be inserted. if self.root is None: self.root = self.TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value: int) -> None: if value < node.value: if node.left is None: node.left = self.TreeNode(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = self.TreeNode(value) else: self._insert_recursive(node.right, value) def contains(self, value: int) -> bool: Check if a value is present in the BST. Parameters: - value (int): The value to be checked. Returns: - bool: True if the value is present, otherwise False. return self._contains_recursive(self.root, value) def _contains_recursive(self, node, value: int) -> bool: if node is None: return False if node.value == value: return True elif value < node.value: return self._contains_recursive(node.left, value) else: return self._contains_recursive(node.right, value) ``` **Example**: ```python # Create a BinarySearchTree instance bst = BinarySearchTree() # Insert elements into the BST bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) # Check for the presence of elements print(bst.contains(7)) # Expected Output: True print(bst.contains(2)) # Expected Output: False ``` **Constraints**: - Handle cases where the tree is initially empty. - Allow duplicate values to be inserted (if necessary for the implementation). - Ensure that the `contains` method runs efficiently, matching the expected time complexity for a BST. **Notes**: - Explain any assumptions made about the input values or tree properties. - Provide appropriate comments within the code for clarity. **Testing**: - Validate the code using different sets of insertion sequences and search values. - Test with edge cases including very small trees and very large values.","solution":"class BinarySearchTree: def __init__(self): Initialize an empty BST. self.root = None class TreeNode: def __init__(self, value: int): Node of a BST. self.left = None self.right = None self.value = value def insert(self, value: int) -> None: Insert a new value into the BST. Parameters: - value (int): The value to be inserted. if self.root is None: self.root = self.TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value: int) -> None: Helper recursive function to insert a value into the BST. if value < node.value: if node.left is None: node.left = self.TreeNode(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = self.TreeNode(value) else: self._insert_recursive(node.right, value) def contains(self, value: int) -> bool: Check if a value is present in the BST. Parameters: - value (int): The value to be checked. Returns: - bool: True if the value is present, otherwise False. return self._contains_recursive(self.root, value) def _contains_recursive(self, node, value: int) -> bool: Helper recursive function to check if a value is present in the BST. if node is None: return False if node.value == value: return True elif value < node.value: return self._contains_recursive(node.left, value) else: return self._contains_recursive(node.right, value)"},{"question":"# Problem Statement You are given a list of `n` integers where `n` is guaranteed to be an even number. Your task is to partition these integers into two subsets such that the difference between the sums of the subsets is minimized. Specifications * Write a function `min_partition_difference(arr: List[int]) -> int` where `arr` is the list of integers. Input - A list `arr` of length `n` where `1 ≤ n ≤ 50` and `-1000 ≤ arr[i] ≤ 1000`. Output - Return an integer representing the minimum possible difference between the sums of the two subsets. Constraints - You must use dynamic programming to solve this problem. Example ```python min_partition_difference([1, 6, 11, 5]) # -> 1 min_partition_difference([1, 2, 3, 9]) # -> 3 min_partition_difference([3, 1, 4, 2, 2, 1]) # -> 1 ```","solution":"def min_partition_difference(arr): total_sum = sum(arr) n = len(arr) dp = [[False] * (total_sum + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True # a sum of 0 is always possible with empty subset for i in range(1, n + 1): for j in range(1, total_sum + 1): if j >= arr[i-1]: dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]] else: dp[i][j] = dp[i-1][j] min_diff = float(\'inf\') for j in range(total_sum // 2 + 1): if dp[n][j]: min_diff = min(min_diff, abs(total_sum - 2 * j)) return min_diff"},{"question":"Question: Implement a Linked List Intersection Checker # Context In this problem, you will use your knowledge of linked lists and basic algorithms to determine if two singly linked lists intersect. Two linked lists intersect if they share at least one node. Intersection is defined by reference, not by value (i.e., they cannot just have the same value; they must actually share a node). # Task Write a Python function `get_intersection_node(headA, headB)` that returns the intersection node of two singly linked lists. If no such intersection exists, return `None`. # Expected Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def get_intersection_node(headA: ListNode, headB: ListNode) -> ListNode: # Your implementation here ``` # Input - `headA`: The head node of the first singly linked list. - `headB`: The head node of the second singly linked list. # Output - Return the intersection node if the two lists intersect, otherwise return `None`. # Constraints - Each linked list is non-cyclic. - The number of nodes in each linked list is in the range [0, 10000]. - The values are not guaranteed to be unique. # Example ```python # Creating intersection linked list nodes intersect = ListNode(8, ListNode(10)) # List A: 4 -> 1 -> 8 -> 10 listA = ListNode(4, ListNode(1, intersect)) # List B: 5 -> 6 -> 1 -> 8 -> 10 (intersects at node 8) listB = ListNode(5, ListNode(6, ListNode(1, intersect))) # Expected Output: Node with value 8 result = get_intersection_node(listA, listB) print(result.val if result else None) # Output should be 8 ``` # Requirements - You may assume there are no cycles anywhere in the input linked lists. - Aim for a solution with time complexity better than O(n^2). Good luck, and remember, clarity in understanding linked lists will help you find intersection points efficiently!","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def get_intersection_node(headA: ListNode, headB: ListNode) -> ListNode: if not headA or not headB: return None # Initialize two pointers p1, p2 = headA, headB # Traverse the lists, switching to the other list when reaching the end while p1 != p2: p1 = p1.next if p1 else headB p2 = p2.next if p2 else headA return p1"},{"question":"# Coding Assessment Question **Context**: You have been given a dataset containing information about numerical scores from various assignments of students. Your task is to predict the final exam score based on the assignment scores using a Decision Tree Regressor. **Objective**: Implement a function `predict_final_score` that builds a Decision Tree Regressor model to predict the final exam score. You will also determine the optimal maximum depth of the tree using cross-validation. **Function Signature**: ```python def predict_final_score(features: np.ndarray, target: np.ndarray, depths: list, cv: int = 5) -> (dict, np.ndarray): Parameters: - features: np.ndarray, Training feature dataset. Shape (n_samples, n_features) - target: np.ndarray, Target values corresponding to the feature dataset. Shape (n_samples,) - depths: list, List of integers representing possible maximum depths of the tree. - cv: int, Number of cross-validation folds. Default is 5. Returns: - dict: Dictionary containing the best depth parameter. - np.ndarray: Array of predictions for the final exam scores using the best model. ``` **Input**: * `features`: A numpy array containing the features of the dataset. Shape `(n_samples, n_features)`. * `target`: A numpy array containing the target values (final exam scores). Shape `(n_samples,)`. * `depths`: A list of integers representing possible maximum depths of the Decision Tree. ```python depths = [3, 5, 7, 10] ``` * `cv`: Number of cross-validation splits to perform, default is 5. **Output**: * Returns a dictionary containing the best depth parameter found during cross-validation. * Returns a numpy array of predictions for the final exam scores using the model trained with the best depth. **Constraints**: * Use sklearn\'s `DecisionTreeRegressor` for building the model. * Use `cross_val_score` for cross-validation with the scoring parameter set to \'neg_mean_squared_error\'. * Optimize for performance efficiency. **Additional Information**: You should split the dataset into a train and test set using an 80-20 split for evaluating the model. The primary goal is to implement the `predict_final_score` function and verify its output using a predefined set of depths. **Example**: ```python import numpy as np from sklearn.tree import DecisionTreeRegressor from sklearn.model_selection import cross_val_score, train_test_split def predict_final_score(features: np.ndarray, target: np.ndarray, depths: list, cv: int = 5) -> (dict, np.ndarray): best_depth = None best_score = float(\'inf\') for depth in depths: model = DecisionTreeRegressor(max_depth=depth) scores = cross_val_score(model, features, target, scoring=\'neg_mean_squared_error\', cv=cv) mean_score = -scores.mean() if mean_score < best_score: best_score = mean_score best_depth = depth best_model = DecisionTreeRegressor(max_depth=best_depth) best_model.fit(features, target) predictions = best_model.predict(features) return {\'best_depth\': best_depth}, predictions # Dataset preparation (example mock dataset) np.random.seed(0) features = np.random.rand(100, 4) target = np.random.rand(100) depths = [3, 5, 7, 10] # Splitting the dataset train_features, test_features, train_target, test_target = train_test_split(features, target, test_size=0.2, random_state=0) # Running the function best_params, predictions = predict_final_score(train_features, train_target, depths) print(best_params) print(predictions) ``` **Note**: Ensure to test the function with an appropriate dataset and verify the optimal depth for effective model performance.","solution":"import numpy as np from sklearn.tree import DecisionTreeRegressor from sklearn.model_selection import cross_val_score, train_test_split def predict_final_score(features: np.ndarray, target: np.ndarray, depths: list, cv: int = 5) -> (dict, np.ndarray): best_depth = None best_score = float(\'inf\') for depth in depths: model = DecisionTreeRegressor(max_depth=depth) scores = cross_val_score(model, features, target, scoring=\'neg_mean_squared_error\', cv=cv) mean_score = -scores.mean() if mean_score < best_score: best_score = mean_score best_depth = depth best_model = DecisionTreeRegressor(max_depth=best_depth) best_model.fit(features, target) predictions = best_model.predict(features) return {\'best_depth\': best_depth}, predictions"},{"question":"# Question: Detecting Circular Primes A **circular prime** is a prime number that remains prime under all rotations of its digits. For example, 197 is a circular prime because all rotations of its digits (197, 971, and 719) are themselves prime numbers. Task Write a function `find_circular_primes(limit)` that identifies all circular primes up to a given limit (inclusive). The function should return a list of all circular primes less than or equal to the specified limit. Function Signature ```python def find_circular_primes(limit: int) -> List[int]: ``` Input - `limit` (int): The upper bound for finding circular primes. Output - List of integers representing all circular primes less than or equal to the specified limit. Constraints - `2 <= limit <= 10^6` - Your solution should efficiently handle the given range. Example ```python find_circular_primes(100) # Output: [2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, 97] ``` Performance Requirements Your implementation should efficiently handle the upper limit of the input size within reasonable time and space constraints. Note - Use a combination of efficient prime-checking and digit rotation techniques to ensure optimal performance.","solution":"from typing import List def is_prime(n: int) -> bool: Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def get_rotations(n: int) -> List[int]: Get all rotations of the digits of a number. s = str(n) return [int(s[i:] + s[:i]) for i in range(len(s))] def find_circular_primes(limit: int) -> List[int]: Find all circular primes up to the given limit. circular_primes = [] for num in range(2, limit + 1): rotations = get_rotations(num) if all(is_prime(rot) for rot in rotations): circular_primes.append(num) return circular_primes"},{"question":"# Problem Statement You are given a list of non-negative integers representing the heights of vertical lines drawn on a Cartesian plane, where the width of each line is 1 unit. Your task is to implement a function `max_area(heights: list[int]) -> int` that calculates the maximum area of water that can be contained between two lines. # Input - `heights`: A list of non-negative integers (2 ≤ len(heights) ≤ 10^4). # Output - An integer representing the maximum area of water that can be contained between two lines. # Constraints - Each line\'s height is a non-negative integer. # Requirements - Time Complexity: O(n) - Space Complexity: O(1) # Example ```python assert max_area([1,8,6,2,5,4,8,3,7]) == 49 # The vertical lines at heights 8 and 7 give max area of water between them. assert max_area([1,1]) == 1 # The two lines both of height 1 give max area of water between them. assert max_area([4,3,2,1,4]) == 16 # The vertical lines at height 4 give max area of water between them. assert max_area([1,2,1]) == 2 # The vertical lines at heights 1 and 2 give max area of water between them. ``` # Function Signature ```python def max_area(heights: list[int]) -> int: ``` # Scenario In designing a water storage system, you need to understand the maximum volume of water that can be captured between walls of different heights. Implement the `max_area` function to support efficient computation of the maximum containment given different wall heights. This can help in optimizing the design of water reservoirs, ensuring maximum storage capacity.","solution":"def max_area(heights: list[int]) -> int: Returns the maximum area of water that can be contained between two lines. left, right = 0, len(heights) - 1 max_area = 0 while left < right: # Calculate the area between the lines at index `left` and `right` height = min(heights[left], heights[right]) width = right - left current_area = height * width # Update max_area if the current area is larger if current_area > max_area: max_area = current_area # Move the pointers based on the smaller height if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"# Coding Assessment Question Context You have been provided a Python function that calculates the cumulative sum of a list of integers. However, you have noticed that the current implementation is not optimal for large datasets and does not handle special cases well, such as when the list contains non-integer elements or is empty. Task Your task is to refactor the existing function to enhance its performance and reliability. Specifically, you need to achieve the following improvements: 1. **Optimization for Large Datasets**: Make sure that the cumulative sum calculation is efficient for large lists. 2. **Type Handling**: Implement type-checking to ensure that all elements in the list are integers. If any element is not an integer, raise a `TypeError` with a suitable error message. 3. **Edge Case Handling**: Ensure that the function gracefully handles an empty list and returns an appropriate result. Function Signature ```python def optimized_cumulative_sum(numbers: List[int]) -> List[int]: Calculate the cumulative sum of a list of integers with performance and type handling improvements. Parameters: numbers (List[int]): List of integers. Returns: List[int]: Cumulative sum of the input list. Raises: TypeError: If any element in the list is not an integer. ``` Input * **numbers (List[int])**: A list of integers. Output * **List[int]**: The cumulative sum of the input list. Constraints * Ensure the function operates efficiently with lists containing up to 1,000,000 elements. * Implement appropriate error handling for invalid inputs. Example ```python # Example 1: Normal case print(optimized_cumulative_sum([1, 2, 3, 4])) # Output: [1, 3, 6, 10] # Example 2: Edge case with an empty list print(optimized_cumulative_sum([])) # Output: [] # Example 3: Type error handling print(optimized_cumulative_sum([1, \'2\', 3])) # Output: Raises TypeError with message \\"All elements must be integers\\" ``` **Expected Outcome**: The function should efficiently calculate the cumulative sum for large lists while handling type errors and edge cases appropriately. Handle and output clear error messages for cases with invalid input types. Good luck!","solution":"from typing import List def optimized_cumulative_sum(numbers: List[int]) -> List[int]: Calculate the cumulative sum of a list of integers with performance and type handling improvements. Parameters: numbers (List[int]): List of integers. Returns: List[int]: Cumulative sum of the input list. Raises: TypeError: If any element in the list is not an integer. if not all(isinstance(num, int) for num in numbers): raise TypeError(\\"All elements must be integers\\") cumulative_sums = [] current_sum = 0 for num in numbers: current_sum += num cumulative_sums.append(current_sum) return cumulative_sums"},{"question":"# Problem Statement You are tasked with implementing a function that converts a given decimal number into its equivalent Roman numeral representation. Roman numerals use combinations of letters from the Latin alphabet to represent values. # The context A software development company needs this feature for an educational application they\'re developing. The application will primarily be used by students to understand and practice number systems from different cultures and historical periods. # Function Specification Implement the `decimal_to_roman` function that converts a decimal number to a Roman numeral. Function Signature ```python def decimal_to_roman(number: int) -> str: pass ``` Inputs * `number`: An integer in the range from 1 to 3999, inclusive. Outputs * A string representing the Roman numeral equivalent of the given `number`. Constraints * Ensure `number` is an integer within the specified range. * Return an empty string for numbers outside this range. Assumptions * The Roman numeral system is limited to numbers from 1 to 3999. # Example ```python result = decimal_to_roman(1987) print(result) # Expected output: \\"MCMLXXXVII\\" result = decimal_to_roman(3999) print(result) # Expected output: \\"MMMCMXCIX\\" result = decimal_to_roman(0) print(result) # Expected output: \\"\\" ``` # Hints * Utilize the standard Roman numeral values and their respective symbols: I (1), IV (4), V (5), IX (9), X (10), XL (40), L (50), XC (90), C (100), CD (400), D (500), CM (900), and M (1000). * Approach the solution by iterating through the values starting from the largest to the smallest, and continuously subtracting the corresponding value from the number while appending the respective Roman numeral symbol to the result string.","solution":"def decimal_to_roman(number: int) -> str: if not (1 <= number <= 3999): return \\"\\" val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \\"\\" i = 0 while number > 0: for _ in range(number // val[i]): roman_numeral += syms[i] number -= val[i] i += 1 return roman_numeral"},{"question":"# Coding Assessment Question Scenario You are developing a text processing tool that needs to identify the longest substring in a given text that contains only unique characters. This functionality can help to analyze string properties and measure text variability. Task Write a function `longest_unique_substring(s)` that takes a string as input and returns the length of the longest substring that contains only unique characters. Input * `s`: A string consisting of lower and upper case alphabetic characters, digits (0-9), and common punctuation marks (.,!?). Output * An integer representing the length of the longest substring with unique characters. Constraints * The input string will have a length between 1 and 10,000 characters. * The input string will have printable ASCII characters only. Example Input ```python s = \\"abrkaabcdefghijjxxx\\" ``` Example Output ```python 10 ``` This output corresponds to the length of the substring `\\"abcdefghij\\"` which is the longest substring with all unique characters. Additional Instructions Ensure your solution efficiently handles the input up to the maximum length of 10,000 characters. Utilize suitable data structures to keep track of characters and their positions for optimal performance. Hint To solve the problem, consider using a sliding window approach: 1. Use two pointers to represent the current window of unique characters. 2. Expand the window by moving the end pointer, and contract it from the start to remove duplicates when they are found. 3. Track the maximum length of substrings that meet the criteria during this process.","solution":"def longest_unique_substring(s): Returns the length of the longest substring with unique characters. max_length = 0 start = 0 seen = {} for end in range(len(s)): if s[end] in seen and seen[s[end]] >= start: start = seen[s[end]] + 1 seen[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"# Coding Question: Implement the following function for the `ListNode` class provided: 1. **Function to remove duplicates from a sorted linked list**: Implement the method `remove_duplicates` which removes all duplicates from a sorted linked list so that each element appears only once. The function should return the head of the updated linked list. ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(self) -> \'ListNode\': Remove duplicates from a sorted linked list. Returns: The head of the updated linked list with duplicates removed. >>> head = ListNode(1, ListNode(1, ListNode(2))) >>> updated_head = head.remove_duplicates() >>> updated_head.val 1 >>> updated_head.next.val 2 >>> updated_head.next.next is None True >>> head = ListNode(1, ListNode(1, ListNode(2, ListNode(3, ListNode(3))))) >>> updated_head = head.remove_duplicates() >>> updated_head.val 1 >>> updated_head.next.val 2 >>> updated_head.next.next.val 3 >>> updated_head.next.next.next is None True # Your implementation here ``` # Constraints: * The input linked list is sorted in ascending order. * Each node in the list contains an integer. * The length of the list is not greater than 10000. # Examples: ```python # Example 1 head = ListNode(1, ListNode(1, ListNode(2))) updated_head = head.remove_duplicates() print(updated_head.val) # Output: 1 print(updated_head.next.val) # Output: 2 print(updated_head.next.next) # Output: None # Example 2 head = ListNode(1, ListNode(1, ListNode(2, ListNode(3, ListNode(3))))) updated_head = head.remove_duplicates() print(updated_head.val) # Output: 1 print(updated_head.next.val) # Output: 2 print(updated_head.next.next.val) # Output: 3 print(updated_head.next.next.next) # Output: None ``` # Additional Notes: * Ensure your implementation is efficient in both time and space complexity. * Your function should handle cases where the list has only one node or no duplicates efficiently. * The function should modify the list in place, and only return the head of the updated list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(self) -> \'ListNode\': Remove duplicates from a sorted linked list. Returns: The head of the updated linked list with duplicates removed. current = self while current and current.next: if current.val == current.next.val: current.next = current.next.next else: current = current.next return self"},{"question":"# Coding Assessment Question: Flatten a Multilevel Doubly Linked List Problem Statement You are given a multilevel doubly linked list. A multilevel doubly linked list is similar to a doubly linked list, but an additional \\"child\\" pointer is present in each node, which may point to a separate doubly linked list. These child lists can also contain one or more child doubly linked lists of their own, and so on, to produce a multilevel data structure. Write a function `flatten_list` that flattens the multilevel linked list so that all the nodes appear in a single-level, doubly linked list. Write a class `MultilevelDoublyLinkedListFlattener` that includes the following methods: 1. `__init__(self)`: Initialization method. 2. `flatten_list(self, head: Node) -> Node`: This method flattens the given multilevel linked list into a single-level doubly linked list and returns the head of the new flattened list. Requirements: - **Input Format**: - `head`: The head node of the multilevel doubly linked list (`Node | None`). - **Output Format**: - The head node of the flattened single-level doubly linked list (`Node`). Constraints: - Each node\'s value should be a non-negative integer. - The number of nodes in the linked list can be up to `10000`. - The child pointers may be `None` at any node. # Example: Consider the following linked list as an example: ``` 1 - 2 - 3 - 4 - 5 - 6 | 7 - 8 - 9 - 10 | 11 - 12 ``` Your function should return the head of the flattened list: ``` 1 - 2 - 3 - 7 - 8 - 11 - 12 - 9 - 10 - 4 - 5 - 6 ``` You can use the `Node` class provided below to create the multilevel linked list nodes. ```python class Node: A Node has value variable, and pointers to Nodes: next, prev, and child. def __init__(self, value: int) -> None: self.value = value self.next: Node | None = None self.prev: Node | None = None self.child: Node | None = None ``` Ensure your solution handles edge cases, such as lists without any child, entirely nested lists, or single node lists. Your solution should be optimized for performance, maintaining an O(n) traversal time where possible.","solution":"class Node: A Node has value variable, and pointers to Nodes: next, prev, and child. def __init__(self, value: int) -> None: self.value = value self.next: Node | None = None self.prev: Node | None = None self.child: Node | None = None class MultilevelDoublyLinkedListFlattener: def __init__(self): pass def flatten_list(self, head: Node) -> Node: if not head: return None # Create a dummy head to simplify edge cases dummy_head = Node(0) dummy_head.next = head current, stack = head, [] while current: if current.child: if current.next: stack.append(current.next) current.next = current.child current.child.prev = current current.child = None if not current.next and stack: next_node = stack.pop() current.next = next_node next_node.prev = current current = current.next # Disconnect the dummy head from the real head dummy_head.next.prev = None return dummy_head.next"},{"question":"# Coding Assessment Question Scenario You are tasked with processing a text file that contains a series of words. Your goal is to find and return the longest word that can be formed by deleting some characters of its subsequence which are themselves not the largest subsequence of the word. If there are multiple words of the same length, return all of them in a list. Task Write a function `find_longest_subsequence_word(filepath: str) -> List[str]` that reads the text file, processes the words, and returns a list of the longest words formed by deleting non-subsequences. Input - The function takes a single parameter, `filepath`, which is a string representing the path to the input file. - The input file contains one word per line. Output - The function should return a list of strings, each representing a word that is the longest by the described condition. Constraints - The input file contains only alphabetic characters and newlines. - Assume the input file is not empty and contains at least one word. - Words will be lowercase. Performance Requirements - The solution should be efficient and handle reasonably large files within computational limits. Function Signature ```python def find_longest_subsequence_word(filepath: str) -> List[str]: ``` Example Consider the content of the input file: ``` apple aple appple ale bale kangaroo ``` Example execution: ```python result = find_longest_subsequence_word(\\"input.txt\\") # input.txt contains the words listed above assert result == [\\"kangaroo\\"] ``` Explanation: - \\"kangaroo\\" is the longest word in the input file that can be formed by deleting some characters from any non-largest subsequence of itself and is itself the longest sequence word overall.","solution":"from typing import List def find_longest_subsequence_word(filepath: str) -> List[str]: with open(filepath, \'r\') as file: words = file.read().splitlines() # Initialize variables to keep track of the longest word(s) longest_words = [] max_length = 0 for word in words: word_length = len(word) if word_length > max_length: longest_words = [word] max_length = word_length elif word_length == max_length: longest_words.append(word) return longest_words"},{"question":"# Question: Implement a Custom Matrix Rotation Function Write a function `rotate_matrix_clockwise` that rotates a square matrix (2D list) 90 degrees clockwise. Function Signature ```python def rotate_matrix_clockwise(matrix: List[List[int]]) -> List[List[int]]: ``` Input * `matrix` (List[List[int]]): A 2D list of integers representing an `n x n` matrix where `n` is a positive integer. Output * Returns a 2D list: The rotated matrix. Constraints * You can assume that the matrix contains at least one element (i.e., `n >= 1`). * The rotation should be done in place if possible. Examples ```python >>> rotate_matrix_clockwise([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_clockwise([[1]]) [[1]] ``` # Requirements * The solution should demonstrate an understanding of matrix manipulation and indexing. * Ensure the function is optimized for time and space complexity where possible. * Consider edge cases such as a `1 x 1` matrix or a larger matrix with repeating elements.","solution":"from typing import List def rotate_matrix_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates a given n x n matrix 90 degrees clockwise. Parameters: matrix (List[List[int]]): A 2D list of integers representing an n x n matrix. Returns: List[List[int]]: A 2D list representing the rotated matrix. n = len(matrix) # Create a new matrix for the rotated matrix rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"**Problem Statement:** You are given a rectangular matrix `mat` of size `m x n` and an integer `target`. Your task is to determine whether `target` exists in the matrix. This matrix has the following properties: 1. Integers in each row are sorted in ascending order from left to right. 2. The first integer of each row is greater than the last integer of the previous row. **Function Signature:** ```python def search_matrix(mat: list[list[int]], target: int) -> bool: pass ``` # Input * `mat` - A list of lists of integers representing the `m x n` matrix where `1 <= m, n <= 300`. * `target` - An integer `target` to search for in the matrix. # Output * Return `True` if `target` exists in the matrix; otherwise, return `False`. # Constraints * Expected time complexity: O(log(m * n)) * Expected space complexity: O(1) # Example ```python assert search_matrix([[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]], 3) == True assert search_matrix([[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]], 13) == False assert search_matrix([[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]], 20) == True assert search_matrix([[1]], 1) == True assert search_matrix([[1]], 2) == False ``` # Explanation In the first example, the matrix is: ``` [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60] ] ``` The `target` value `3` exists in the first row of the matrix. Thus, the function returns `True`. In the second example, the `target` value `13` does not exist in the matrix. Thus, the function returns `False`. In the third example, the `target` value `20` exists in the second row of the matrix. Thus, the function returns `True`. In the fourth example, the matrix is `[[1]]` and the `target` is `1`. The function returns `True` as the single element matches the target. In the fifth example, the matrix is `[[1]]` and the `target` is `2`. The function returns `False` as the element does not match the target. **Note:** Ensure that the implementation uses binary search to achieve the expected time complexity in this problem.","solution":"def search_matrix(mat: list[list[int]], target: int) -> bool: This function searches for a target value in a given m x n matrix. The matrix has the following properties: 1. Integers in each row are sorted from left to right. 2. The first integer of each row is greater than the last integer of the previous row. Args: mat (list[list[int]]): The matrix to search in. target (int): The integer to search for. Returns: bool: True if target exists in the matrix, False otherwise. if not mat or not mat[0]: return False m, n = len(mat), len(mat[0]) left, right = 0, m * n - 1 while left <= right: mid = (left + right) // 2 mid_value = mat[mid // n][mid % n] if mid_value == target: return True elif mid_value < target: left = mid + 1 else: right = mid - 1 return False"},{"question":"# Problem Statement: Range Sum Query Execution You are tasked with implementing a class that efficiently handles both updates and queries on a list of integers. Specifically, the class should support setting the value of an element and querying the sum of elements over a specified range. Class Definition ```python class RangeSumQuery: def __init__(self, nums: List[int]): Initialize your data structure here. :param nums: List of integers to initialize the data structure with. pass def update(self, index: int, val: int) -> None: Update the value of the element at index to val. :param index: The index of the element to update. :param val: The new value of the element. pass def sumRange(self, left: int, right: int) -> int: Return the sum of elements nums[left..right] inclusive. :param left: The left index of the range. :param right: The right index of the range. :return: The sum of elements in the specified range. pass ``` Input * The `RangeSumQuery` class will be instantiated with `nums`, a list of integers. * The `update` method will be called with an index and a value. * The `sumRange` method will be called with two indices, `left` and `right`. Output * The `update` method does not need to return anything. * The `sumRange` method should return the integer sum of the elements within the specified range, inclusive. Constraints 1. `1 <= len(nums) <= 3 * 10^4` 2. `-100 <= nums[i] <= 100` 3. `0 <= index < len(nums)` 4. `-10^5 <= val <= 10^5` 5. `0 <= left <= right < len(nums)` 6. The number of calls to `update` and `sumRange` methods will not exceed 3 * 10^4. Example ```python # Example of usage nums = [1, 3, 5] obj = RangeSumQuery(nums) assert obj.sumRange(0, 2) == 9 # sum of [1, 3, 5] obj.update(1, 2) # nums becomes [1, 2, 5] assert obj.sumRange(0, 2) == 8 # sum of [1, 2, 5] ``` Requirements 1. Implement the `__init__`, `update`, and `sumRange` methods adhering to the requirements. 2. Optimize for both the update and query operations considering the constraints. 3. Handle edge cases, such as updating the first or the last element.","solution":"class RangeSumQuery: def __init__(self, nums): Initialize your data structure here. :param nums: List of integers to initialize the data structure with. self.nums = nums self.size = len(nums) self.tree = [0] * (self.size + 1) for i in range(self.size): self._increment(i + 1, nums[i]) def _increment(self, index, delta): while index <= self.size: self.tree[index] += delta index += index & -index def update(self, index, val): Update the value of the element at index to val. :param index: The index of the element to update. :param val: The new value of the element. delta = val - self.nums[index] self.nums[index] = val self._increment(index + 1, delta) def _prefix_sum(self, index): sum = 0 while index > 0: sum += self.tree[index] index -= index & -index return sum def sumRange(self, left, right): Return the sum of elements nums[left..right] inclusive. :param left: The left index of the range. :param right: The right index of the range. :return: The sum of elements in the specified range. return self._prefix_sum(right + 1) - self._prefix_sum(left)"},{"question":"# Problem: Rotate Image You are given an n x n 2D matrix `matrix` representing an image. Your task is to write a function `rotate_image(matrix: list[list[int]]) -> None` that rotates the image by 90 degrees (clockwise) in place. # Function Signature ```python def rotate_image(matrix: list[list[int]]) -> None: pass ``` # Input * `matrix`: A 2D list of integers representing the image. The matrix is guaranteed to be non-empty and all rows have the same number of columns. # Output * The function does not return anything. The input matrix is modified in place to represent the rotated image. # Example ```python # Example 1 matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_image(matrix1) assert matrix1 == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] # Example 2 matrix2 = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_image(matrix2) assert matrix2 == [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] # Example 3 matrix3 = [ [1] ] rotate_image(matrix3) assert matrix3 == [ [1] ] # Example 4 matrix4 = [ [1, 2] [3, 4] ] rotate_image(matrix4) assert matrix4 == [ [3, 1], [4, 2] ] ``` # Constraints - You may not allocate another 2D array for the rotation (in other words, no extra space for another matrix except for a few variables is allowed). - You can assume the matrix only contains integers. - The function should handle matrices of varying sizes efficiently. # Notes - Carefully think about the indices transformations needed to perform the rotation. - Remember to handle cases where the matrix elements have to be moved across different positions accurately.","solution":"def rotate_image(matrix: list[list[int]]) -> None: Rotates the input n x n matrix by 90 degrees clockwise in place. n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Coding Challenge: Calculate Contiguous Subarray Sum Problem Statement You are given an integer array `nums` of length `n`. Your task is to write a function `max_subarray_sum` that finds the maximum sum of any contiguous subarray within the provided array. Write the function in both O(n) time complexity using Kadane\'s Algorithm and O(n^2) time complexity using a brute force approach. Function Signature ```python def max_subarray_sum_kadane(nums: List[int]) -> int: pass def max_subarray_sum_bruteforce(nums: List[int]) -> int: pass ``` Input Parameters * `nums` (List[int]): A list of integers representing the array. (-10^5 ≤ nums[i] ≤ 10^5, 1 ≤ n ≤ 10^5) Output * Return an integer representing the maximum sum of any contiguous subarray within the provided array. Constraints * If the list `nums` is empty, raise a `ValueError`. Example ```python print(max_subarray_sum_kadane([-2,1,-3,4,-1,2,1,-5,4])) # Expected Output: 6 (subarray [4,-1,2,1]) print(max_subarray_sum_bruteforce([-2,1,-3,4,-1,2,1,-5,4])) # Expected Output: 6 (subarray [4,-1,2,1]) print(max_subarray_sum_kadane([1])) # Expected Output: 1 (subarray [1]) print(max_subarray_sum_bruteforce([1])) # Expected Output: 1 (subarray [1]) ``` Requirements * Implement both the optimal (`max_subarray_sum_kadane`) and the brute force (`max_subarray_sum_bruteforce`) versions. * Ensure that your solution handles edge cases effectively, including arrays with a single element and arrays with all negative numbers. * Include sufficient error handling for invalid input cases.","solution":"from typing import List def max_subarray_sum_kadane(nums: List[int]) -> int: if not nums: raise ValueError(\\"The input array is empty.\\") max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global def max_subarray_sum_bruteforce(nums: List[int]) -> int: if not nums: raise ValueError(\\"The input array is empty.\\") n = len(nums) max_sum = nums[0] for i in range(n): current_sum = 0 for j in range(i, n): current_sum += nums[j] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Question: Context: You are developing a system that requires determining the longest contiguous subarray where the sum of the elements equals zero. This functionality is important for analyzing sequences of financial data where periods of balance are critical. Task: Implement a function `longest_zero_sum_subarray(arr: List[int]) -> Tuple[int, int]` which finds the indices of the longest contiguous subarray with a sum of zero. If multiple subarrays qualify, return the one starting with the smallest index. * Edge cases such as no subarrays summing to zero should be handled by returning `(-1, -1)`. Constraints: * The length of `arr` should be between `1` and `10^5`. * The elements of `arr` are integers and can be negative or positive. Input: * A list of integers `arr`. Output: * A tuple of two integers representing the starting and ending indices (inclusive) of the longest zero-sum subarray. If no such subarray exists, return `(-1, -1)`. Example: ```python assert longest_zero_sum_subarray([1, 2, -3, 3, 1, -1, 2, -2]) == (2, 7) assert longest_zero_sum_subarray([1, -1]) == (0, 1) assert longest_zero_sum_subarray([1, 2, 3]) == (-1, -1) ``` Requirements: * Your solution must handle invalid inputs by raising an appropriate exception (TypeError). * The implementation should be efficient in terms of time complexity.","solution":"from typing import List, Tuple def longest_zero_sum_subarray(arr: List[int]) -> Tuple[int, int]: Finds the indices of the longest contiguous subarray with sum equal to zero. Parameters: arr (List[int]): A list of integers which can be positive or negative. Returns: Tuple[int, int]: A tuple containing the starting and ending indices of the longest zero-sum subarray. If no such subarray exists, returns (-1, -1). if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr): raise TypeError(\\"Input should be a list of integers.\\") prefix_sum = {} current_sum = 0 max_length = 0 start_index = -1 end_index = -1 for i, num in enumerate(arr): current_sum += num if current_sum == 0: max_length = i + 1 start_index = 0 end_index = i if current_sum in prefix_sum: if i - prefix_sum[current_sum] > max_length: max_length = i - prefix_sum[current_sum] start_index = prefix_sum[current_sum] + 1 end_index = i else: prefix_sum[current_sum] = i return (start_index, end_index) if max_length > 0 else (-1, -1)"},{"question":"# Question You are given an array of integers where each element appears exactly twice, except for one element which appears exactly once. Your task is to implement a function that finds the element that appears only once. Function Signature ```python def find_unique_element(arr: list[int]) -> int: pass ``` Input * arr: a list of integers, where 1 ≤ len(arr) ≤ 10^7 and -10^9 ≤ arr[i] ≤ 10^9 for all valid i. Output * An integer representing the unique element in the array. Constraints * Your solution should have a linear runtime complexity, O(n). * You should not use extra space larger than O(1). Example ```python assert find_unique_element([4, 1, 2, 1, 2]) == 4 assert find_unique_element([2, 2, 1]) == 1 assert find_unique_element([1, 2, 3, 4, 3, 2, 1]) == 4 ``` Explanation In this task, you need to find the element that appears only once in the array. Every other element in the array will appear exactly twice. Your solution should have linear time complexity and should only use constant space.","solution":"def find_unique_element(arr: list[int]) -> int: Returns the element that appears exactly once in the array. Every other element appears exactly twice. Uses XOR to find the unique element in linear time with constant space. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"# Fibonacci-like Sequence Calculation Write a Python function that calculates a Fibonacci-like sequence, where each term is the product of the previous two terms, for the first `n` terms of the sequence. The first two terms of the sequence are given as inputs. Function Signature ```python def fibonacci_like_sequence(first_term: int, second_term: int, n: int) -> list[int]: Calculate the first n terms of a Fibonacci-like sequence where each term is the product of the previous two terms. Args: first_term (int): The first term of the sequence. second_term (int): The second term of the sequence. n (int): The number of terms to calculate in the sequence. Returns: list[int]: A list of integers representing the first n terms of the sequence. ``` Input Format - An integer `first_term` representing the first term of the sequence. - An integer `second_term` representing the second term of the sequence. - An integer `n` (1 ≤ n ≤ 20) representing the total number of terms to calculate in the sequence. Output Format - A list of integers where each integer is a term in the Fibonacci-like sequence. Constraints 1. The function should handle cases where `n` is 1 or 2. 2. The sequence should be generated correctly and efficiently for the given constraints. Example ```python assert fibonacci_like_sequence(2, 3, 1) == [2] assert fibonacci_like_sequence(2, 3, 2) == [2, 3] assert fibonacci_like_sequence(2, 3, 5) == [2, 3, 6, 18, 108] ``` Scenario This sequence is particularly useful in similar contexts where multiplication growth needs to be studied, such as modeling population growth in biology or compound interest in finance. Suppose you are analyzing how a population grows where each generation\'s size is the product of the sizes of the previous two generations, this algorithm will help predict future sizes. Additional Requirements Ensure that your function handles edge cases properly and runs efficiently under the given constraints. You should provide a brief testing code to validate the implementation.","solution":"def fibonacci_like_sequence(first_term: int, second_term: int, n: int) -> list[int]: Calculate the first n terms of a Fibonacci-like sequence where each term is the product of the previous two terms. Args: first_term (int): The first term of the sequence. second_term (int): The second term of the sequence. n (int): The number of terms to calculate in the sequence. Returns: list[int]: A list of integers representing the first n terms of the sequence. if n == 1: return [first_term] elif n == 2: return [first_term, second_term] sequence = [first_term, second_term] for _ in range(2, n): sequence.append(sequence[-1] * sequence[-2]) return sequence"},{"question":"# Question: Rotate a List Left by K Positions Given a list of integers and a number `k`, you are required to rotate the list left by `k` positions. Rotating a list left means moving each element to the left by `k` positions and bringing elements that fall off to the end. Task Write a function `rotate_left(lst: List[int], k: int) -> List[int]` that returns the list rotated left by `k` positions. Function Signature ```python from typing import List def rotate_left(lst: List[int], k: int) -> List[int]: pass ``` Input - `lst` (List[int]): The list of integers to rotate. It can be empty. - `k` (int): The number of positions to rotate the list to the left. Must be a non-negative integer. Output - (List[int]): The list after being rotated left by `k` positions. Constraints - `0 <= len(lst) <= 10^5` (Handle large lists efficiently) - `0 <= k <= 10^5` - Raise a `ValueError` for any input value of `k` that is negative. Examples ```python >>> rotate_left([1, 2, 3, 4, 5], 2) [3, 4, 5, 1, 2] >>> rotate_left([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_left([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_left([], 3) [] >>> rotate_left([1, 2], -1) Traceback (most recent call last): ... ValueError: param `k` must be non-negative ``` Performance Requirements Ensure the function runs efficiently even for large lists. An optimal solution should have a linear time complexity, O(n), where n is the number of elements in the list.","solution":"from typing import List def rotate_left(lst: List[int], k: int) -> List[int]: Rotates the list \'lst\' to the left by \'k\' positions. Parameters: lst (List[int]): The list of integers to rotate. k (int): The number of positions to rotate the list to the left. Returns: List[int]: The list after being rotated left by \'k\' positions. Raises: ValueError: If \'k\' is negative. if k < 0: raise ValueError(\'param `k` must be non-negative\') n = len(lst) if n == 0: return [] k %= n # In case k is greater than the size of the list return lst[k:] + lst[:k]"},{"question":"# Task Implement a function that reads a list of integers from a given file and returns the length of the longest increasing subsequence. Function Signature ```python def longest_increasing_subsequence(file_path: str) -> int: Finds the length of the longest increasing subsequence in a list of integers read from a file. Args: file_path (str): Path to the text file containing a list of integers separated by spaces. Returns: int: The length of the longest increasing subsequence. ``` # Input * A text file (`file_path`) containing a single line with a list of integers separated by spaces. # Output * Return the length of the longest increasing subsequence in the list. # Constraints * The file contains at most 100,000 integers. * Each integer is within the range [-100,000, 100,000]. * You can assume the file will not be empty. # Example Given a file `numbers.txt` with the following content: ``` 10 22 9 33 21 50 41 60 80 ``` Calling `longest_increasing_subsequence(\\"numbers.txt\\")` should return `6`. # Notes * The longest increasing subsequence for the example above is [10, 22, 33, 50, 60, 80], which has a length of 6.","solution":"def longest_increasing_subsequence(file_path: str) -> int: Finds the length of the longest increasing subsequence in a list of integers read from a file. Args: file_path (str): Path to the text file containing a list of integers separated by spaces. Returns: int: The length of the longest increasing subsequence. with open(file_path, \'r\') as file: numbers = list(map(int, file.readline().strip().split())) if not numbers: return 0 # Implementing the Dynamic Programming approach for finding the longest increasing subsequence dp = [1] * len(numbers) for i in range(1, len(numbers)): for j in range(i): if numbers[i] > numbers[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Handling Nested Lists Given a nested list (a list of lists) where each inner list contains integers, write a function that flattens it into a single list of integers. Function Signature ```python def flatten_nested_list(nested_list: list) -> list: pass ``` Implementation Requirements: 1. Implement the function to iterate through each element in the nested list. 2. If an element is a list, iterate through its elements and add them to the flattened result. 3. If an element is not a list, directly add it to the flattened result. Input - `nested_list`: A list of lists where each inner list contains integers. Output - A list of integers representing the flattened version of the nested list. Example ```python >>> flatten_nested_list([[1, 2, [3]], [4, 5], 6]) [1, 2, 3, 4, 5, 6] >>> flatten_nested_list([[], [1, 2], [], [3]]) [1, 2, 3] ``` Constraints - Ensure your function correctly handles deeply nested lists. - Do not use any built-in functions specifically meant for flattening lists. Scenario Imagine you are creating a function for a data processing pipeline where data integrity involves flattening nested lists into a single sequence of integers. This task will assess your ability to manipulate lists and ensure proper extraction of all nested elements.","solution":"def flatten_nested_list(nested_list): Flattens a nested list into a single list of integers. Args: nested_list (list): A list of lists where each inner list contains integers. Returns: list: A list of integers representing the flattened version of the nested list. flattened_list = [] def flatten(element): if isinstance(element, list): for item in element: flatten(item) else: flattened_list.append(element) flatten(nested_list) return flattened_list"},{"question":"# **Question: Implement a Customizable Data Pipeline for Preprocessing** Your task is to design and implement a customizable data preprocessing pipeline in Python. This pipeline should be able to handle various preprocessing tasks such as normalization, missing value imputation, and feature encoding, all configurable by the user. **Requirements:** 1. **Pipeline Structure**: - Implement the `DataPipeline` class. - The pipeline should support loading data from a CSV file and applying a series of transformations. 2. **Function Implementation**: - `add_transformation(transformation_function)`: Adds a transformation function to the pipeline. - `load_data(file_path)`: Loads the data from a CSV file into a pandas DataFrame. - `apply_transformations()`: Applies all added transformations in sequence to the loaded data. - `get_processed_data()`: Returns the transformed data as a pandas DataFrame. 3. **I/O Specifications**: - **Input**: - `file_path`: String, path to the CSV file containing the data. - Each transformation function should handle specific tasks, such as normalization, missing value imputation, and feature encoding. - **Output**: - A pandas DataFrame with the processed data. 4. **Transformation Functions**: - `normalize_columns(columns)`: Normalizes specified columns to range [0, 1]. - `impute_missing_values(columns, strategy)`: Imputes missing values in specified columns using the given strategy (mean, median, mode). - `encode_categorical(columns)`: Encodes categorical columns using one-hot encoding. **Constraints**: - You are allowed to use the pandas and numpy libraries for data manipulation. # Example Usage: ```python import pandas as pd import numpy as np class DataPipeline: def __init__(self): self.transformations = [] self.data = None def add_transformation(self, transformation_function): self.transformations.append(transformation_function) def load_data(self, file_path): self.data = pd.read_csv(file_path) def apply_transformations(self): for transform in self.transformations: self.data = transform(self.data) def get_processed_data(self): return self.data # Define transformation functions def normalize_columns(columns): def transform(data): data[columns] = (data[columns] - data[columns].min()) / (data[columns].max() - data[columns].min()) return data return transform def impute_missing_values(columns, strategy=\'mean\'): def transform(data): if strategy == \'mean\': data[columns] = data[columns].fillna(data[columns].mean()) elif strategy == \'median\': data[columns] = data[columns].fillna(data[columns].median()) elif strategy == \'mode\': data[columns] = data[columns].fillna(data[columns].mode().iloc[0]) return data return transform def encode_categorical(columns): def transform(data): return pd.get_dummies(data, columns=columns) return transform # Example usage pipeline = DataPipeline() pipeline.load_data(\'data.csv\') pipeline.add_transformation(normalize_columns([\'age\', \'salary\'])) pipeline.add_transformation(impute_missing_values([\'age\', \'salary\'])) pipeline.add_transformation(encode_categorical([\'gender\', \'department\'])) pipeline.apply_transformations() processed_data = pipeline.get_processed_data() print(processed_data) ``` In the example above, you should design the pipeline\'s methods to ensure flexible data transformations. Users must be able to configure and add various preprocessing steps as needed and obtain the cleaned and processed data ready for further analysis or modeling.","solution":"import pandas as pd import numpy as np class DataPipeline: def __init__(self): self.transformations = [] self.data = None def add_transformation(self, transformation_function): self.transformations.append(transformation_function) def load_data(self, file_path): self.data = pd.read_csv(file_path) def apply_transformations(self): for transform in self.transformations: self.data = transform(self.data) def get_processed_data(self): return self.data # Define transformation functions def normalize_columns(columns): def transform(data): data[columns] = (data[columns] - data[columns].min()) / (data[columns].max() - data[columns].min()) return data return transform def impute_missing_values(columns, strategy=\'mean\'): def transform(data): if strategy == \'mean\': data[columns] = data[columns].fillna(data[columns].mean()) elif strategy == \'median\': data[columns] = data[columns].fillna(data[columns].median()) elif strategy == \'mode\': data[columns] = data[columns].fillna(data[columns].mode().iloc[0]) return data return transform def encode_categorical(columns): def transform(data): return pd.get_dummies(data, columns=columns) return transform"},{"question":"# Problem Statement You have been tasked with developing part of a library that deals with matrices. One of the required functionalities is to rotate a given square matrix (n x n) 90 degrees clockwise. Your task is to write a function `rotate_matrix` that takes a square matrix as input and returns a new matrix that has been rotated 90 degrees clockwise. Input: - `matrix`: List[List[int]] (a 2D list representing an n x n matrix, where 1 <= n <= 1000) Output: - A new list of lists, representing the matrix rotated 90 degrees clockwise. Constraints: - The input matrix will always be a square matrix (equal number of rows and columns). - The function should not modify the original matrix. - Aim for an efficient in-place algorithm if the constraints and language allow. # Examples: 1. `rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])` should return `[[7, 4, 1], [8, 5, 2], [9, 6, 3]]`. 2. `rotate_matrix([[1]])` should return `[[1]]`. 3. `rotate_matrix([[1, 2], [3, 4]])` should return `[[3, 1], [4, 2]]`. 4. `rotate_matrix([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])` should return `[[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]`. # Notes: - Think about how the indices of elements in the original matrix will map to indices in the rotated matrix. - Write the function to handle edge cases gracefully, ensuring no out-of-bound errors occur. - Avoid using excessive additional space; aiming for an in-place rotation should be considered.","solution":"def rotate_matrix(matrix): Rotate the given n x n matrix 90 degrees clockwise. Args: matrix (List[List[int]]): a square matrix (n x n). Returns: List[List[int]]: a new matrix that has been rotated 90 degrees clockwise. n = len(matrix) # Create a new matrix to hold the rotated values rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"},{"question":"# Reverse Words in a String **Problem Statement:** Write a function `reverse_words` that takes in a string and returns a string with the words reversed. Words are defined as sequences of characters separated by spaces. You should consider the following points: 1. If the input string is empty, return an empty string. 2. Ensure that multiple spaces between words are reduced to a single space in the output. 3. Trim leading and trailing spaces from the output. Your task is to implement the function ensuring it handles various edge cases, such as multiple spaces and empty inputs, appropriately. **Function Signature:** ```python def reverse_words(s: str) -> str: pass ``` **Input:** - `s` (str): The input string that may contain letters, numbers, spaces, and punctuation. **Output:** - (str): The string with each word reversed, and multiple spaces reduced to a single space. **Constraints:** - The input string will have a length of at most 10^5 characters. - The function should handle empty strings appropriately. **Examples:** ```python >>> reverse_words(\\"the sky is blue\\") \\"blue is sky the\\" >>> reverse_words(\\" hello world \\") \\"world hello\\" >>> reverse_words(\\"a good example\\") \\"example good a\\" >>> reverse_words(\\" this is another test \\") \\"test another is this\\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\"singleword\\") \\"singleword\\" ``` **Technical Notes:** 1. You can use Python string methods like `strip`, `split`, and `join` to handle spaces efficiently. 2. Ensure your function is optimized to handle large input sizes within the constraints.","solution":"def reverse_words(s: str) -> str: Returns the string with words reversed and multiple spaces reduced to a single space. # Trim the string to remove leading and trailing spaces trimmed_str = s.strip() # Split the trimmed string by spaces words = trimmed_str.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words with a single space reversed_str = \' \'.join(reversed_words) return reversed_str"},{"question":"**File Handling and Keyword Search Task** # Problem Statement You need to write a function that searches for a given keyword across multiple text files in a specified directory. The function should return the names of the files that contain the keyword at least once. # Requirements 1. **Function Definition**: Implement the function `find_keyword_in_files(keyword: str, directory: str) -> List[str]`. 2. **Inputs**: * `keyword` (str): The keyword to search for within the files. * `directory` (str): The directory path where text files are located. 3. **Output**: * A list of filenames (List[str]) found in the specified directory that contain the given keyword. 4. **Operational Steps**: * Traverse all text files in the given directory. * Read the contents of each file. * Check if the keyword is present in the content (case-insensitive). * Return the list of filenames that contain the keyword. 5. **Constraints**: * Handle file I/O errors gracefully. * Ensure the function processes only *.txt files. * Ignore hidden files and directories. # Example ```python result = find_keyword_in_files(\\"Python\\", \\"/path/to/directory\\") print(result) # Expected Output (depending on the files in the directory): # [\'file1.txt\', \'file3.txt\'] ``` # Notes * Make sure your solution manages potential I/O errors such as file not found or permission denied. * Ensure the keyword search is case-insensitive. * Optimize file reading to handle large files efficiently. * The function should not assume any specific file structure and should be usable with any directory containing text files. --- Implement your function considering the steps outlined above and ensure to handle edge cases like empty files or no matching files.","solution":"import os from typing import List def find_keyword_in_files(keyword: str, directory: str) -> List[str]: Searches for a given keyword across all text files in a specified directory. Returns the names of the files that contain the keyword at least once. :param keyword: The keyword to search for within the files. :param directory: The directory path where text files are located. :return: A list of filenames found in the specified directory that contain the given keyword. matching_files = [] keyword_lower = keyword.lower() if not os.path.isdir(directory): return matching_files for root, _, files in os.walk(directory): for file_name in files: if file_name.endswith(\\".txt\\") and not file_name.startswith(\\".\\"): try: file_path = os.path.join(root, file_name) with open(file_path, \'r\', encoding=\'utf-8\') as file: content = file.read() if keyword_lower in content.lower(): matching_files.append(file_name) except (IOError, OSError): continue return matching_files"},{"question":"# String Substitution Matcher You are provided with a list of template strings, each containing placeholder values enclosed in curly braces `{}`. You also have a dictionary where each key corresponds to a placeholder, and the value is the string that should replace it. Your task is to substitute all placeholders in each template string with their corresponding values from the dictionary. If a placeholder does not have a matching key in the dictionary, it should remain unchanged in the template. **Objective**: Write a Python function `substitute_placeholders(templates: list, dictionary: dict) -> list` that: 1. Takes a list of template strings and a dictionary of placeholder replacements. 2. Returns a list of strings where placeholders have been substituted with their respective values from the dictionary. **Function Signature**: ```python def substitute_placeholders(templates: list, dictionary: dict) -> list: pass ``` # Input - `templates`: A list of strings, each containing zero or more placeholders. - `dictionary`: A dictionary where each key is a placeholder (without the curly braces) and each value is the corresponding string to replace the placeholder. # Output - A list of strings with placeholders replaced by their respective values, if they exist in the dictionary. # Example: Suppose you have the following template strings and dictionary: **Templates**: ```python templates = [ \\"Hello, {name}!\\", \\"Welcome to {place}.\\", \\"The year is {year}.\\" ] ``` **Dictionary**: ```python dictionary = { \\"name\\": \\"Alice\\", \\"place\\": \\"Wonderland\\", \\"year\\": \\"2023\\" } ``` The function should return: ```python [\\"Hello, Alice!\\", \\"Welcome to Wonderland.\\", \\"The year is 2023.\\"] ``` # Constraints: - Template strings can contain multiple placeholders. - Placeholders are enclosed in curly braces and do not contain nested braces. - If a placeholder does not have a corresponding key in the dictionary, it remains unchanged. - The list of templates and the dictionary are guaranteed to be non-empty. # Notes: - Iterate through each template string and find all placeholders. - Substitute each placeholder with its corresponding value from the dictionary. - Ensure the function returns correctly substituted template strings. # Assumptions: - All template strings are valid and properly formatted with placeholders enclosed in curly braces `{}`. - The dictionary contains valid keys and corresponding values for substitution.","solution":"import re def substitute_placeholders(templates: list, dictionary: dict) -> list: def replace_placeholders(template): pattern = re.compile(r\'{(.*?)}\') def replacement(match): key = match.group(1) return dictionary.get(key, match.group(0)) return pattern.sub(replacement, template) return [replace_placeholders(template) for template in templates]"},{"question":"# Scenario: You are developing a text editor that supports a variety of text manipulation features. To efficiently manage the text data, you are required to implement a data structure that provides functionality similar to a gap buffer. # Requirements: 1. **Insert operation** should insert a character at the specified position in the text. 2. **Delete operation** should delete a character from the specified position in the text. 3. **Retrieve operation** should return the current text as a single string. # Function Specification: 1. **Insert Function**: ```python def insert(self, pos: int, char: str) -> None: Inserts a character at the specified position in the text. Parameters: pos (int): The position at which to insert the character. char (str): The character to be inserted. # Your implementation here ``` 2. **Delete Function**: ```python def delete(self, pos: int) -> None: Deletes the character at the specified position in the text. Parameters: pos (int): The position at which to delete the character. # Your implementation here ``` 3. **Retrieve Function**: ```python def retrieve(self) -> str: Retrieves the current text as a single string. Returns: str: The current text. # Your implementation here ``` # Constraints: - **Text Length**: 0 <= length of the text <= 10^6 - **Position Range**: 0 <= pos < current length of the text. - **Character Set**: The text consists of printable ASCII characters. # Performance Requirements: - Insert and delete operations should be efficient, ideally with amortized constant time complexity for small edits. # Example Usage: ```python # Initialize the text buffer buffer = GapBuffer() # Insert characters into the buffer buffer.insert(0, \'H\') buffer.insert(1, \'e\') buffer.insert(2, \'l\') buffer.insert(3, \'l\') buffer.insert(4, \'o\') # Retrieve the current text current_text = buffer.retrieve() # Should return \\"Hello\\" # Delete a character from the buffer buffer.delete(4) # Deletes the character \'o\' # Retrieve the modified text modified_text = buffer.retrieve() # Should return \\"Hell\\" # Insert a character in the middle buffer.insert(4, \'a\') # Inserts the character \'a\' at position 4 # Retrieve the modified text final_text = buffer.retrieve() # Should return \\"Hella\\" ``` Ensure that the operations insert, delete, and retrieve follow the constraints and perform efficiently.","solution":"class GapBuffer: def __init__(self): self.buffer = [] self.gap_start = 0 self.gap_end = 0 def _move_gap(self, pos): if pos < self.gap_start: while self.gap_start > pos: self.gap_start -= 1 self.gap_end -= 1 self.buffer[self.gap_end] = self.buffer[self.gap_start] else: while self.gap_start < pos: self.buffer[self.gap_start] = self.buffer[self.gap_end] self.gap_start += 1 self.gap_end += 1 def insert(self, pos: int, char: str) -> None: self._move_gap(pos) if self.gap_start == self.gap_end: self.buffer[self.gap_start:self.gap_start] = [\' \'] * 10 self.gap_end += 10 self.buffer[self.gap_start] = char self.gap_start += 1 def delete(self, pos: int) -> None: self._move_gap(pos) self.gap_end += 1 def retrieve(self) -> str: return \'\'.join(self.buffer[:self.gap_start] + self.buffer[self.gap_end:])"},{"question":"# Question: Implement Image Cropping Using Bounding Box You are given a grayscale image stored as a 2D NumPy array and a list of bounding box coordinates. Implement a function `crop_image` that extracts and returns the specified rectangular region from the image. # Function Signature ```python def crop_image(img: np.ndarray, bbox: list) -> np.ndarray: ``` # Input - `img`: A NumPy 2D array of shape (height, width) representing the grayscale image. - `bbox`: A list of four integers `[x_min, y_min, x_max, y_max]` specifying the coordinates of the top-left and bottom-right corners of the bounding box. # Output - Returns a new 2D NumPy array representing the cropped region of the image. # Constraints - `img` dimensions will be at most 1024x1024. - `bbox` coordinates will be within the bounds of the image dimensions. - `x_min`, `y_min` are the coordinates of the top-left corner of the bounding box. - `x_max`, `y_max` are the coordinates of the bottom-right corner of the bounding box. - The bounding box will always form a valid rectangle, i.e., `0 <= x_min < x_max < width` and `0 <= y_min < y_max < height`. # Example ```python gray_img = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=np.uint8) bbox = [0, 0, 2, 2] cropped_img = crop_image(gray_img, bbox) print(cropped_img) ``` Output: ``` [[1 2] [4 5]] ``` # Notes - Implement robust error-checking to ensure bounding box coordinates are valid. - Handle edge cases such as bounding boxes at the image boundaries correctly and efficiently. - Ensure your implementation avoids unnecessary memory usage and is optimized for performance, given the input constraints.","solution":"import numpy as np def crop_image(img: np.ndarray, bbox: list) -> np.ndarray: Extracts and returns the specified rectangular region from the image. Parameters: img (np.ndarray): A 2D NumPy array representing the grayscale image. bbox (list): A list of four integers [x_min, y_min, x_max, y_max] specifying the coordinates of the top-left and bottom-right corners of the bounding box. Returns: np.ndarray: A 2D NumPy array representing the cropped region of the image. x_min, y_min, x_max, y_max = bbox # Extract the region and return return img[y_min:y_max, x_min:x_max]"},{"question":"# Array Rotation You need to write a Python function that takes an array and rotates the elements to the right by a given number of steps. The rotation should be cyclic, meaning that elements shifted off the end of the array should wrap around and appear at the beginning. Write a Python function `rotate_array(arr: List[int], steps: int) -> List[int]` that: 1. Accepts an array of integers `arr` and an integer `steps` representing the number of positions to rotate. 2. Returns a new list where the elements have been rotated to the right by `steps` positions. 3. Handles the following constraints: - If `steps` is negative, rotate the array to the left instead. - If `arr` is empty, return an empty list. - Ensure the function efficiently handles large arrays and large `steps` values. # Input * An array of integers `arr`. * An integer `steps`. # Output * A list of integers where the elements have been rotated by the specified number of steps. # Example ```python >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], -3) [4, 5, 1, 2, 3] >>> rotate_array([], 2) [] >>> rotate_array([1, 2, 3], 0) [1, 2, 3] >>> rotate_array([1, 2, 3], 5) [1, 2, 3] ``` # Constraints * (0 leq text{len}(text{arr}) leq 10^5) * ( -10^9 leq text{steps} leq 10^9 ) Create the function `rotate_array` to meet the specifications above and ensure it handles both small and large inputs efficiently.","solution":"from typing import List def rotate_array(arr: List[int], steps: int) -> List[int]: if not arr: return [] n = len(arr) steps = steps % n # Ensure steps is within the bounds of the array length return arr[-steps:] + arr[:-steps]"},{"question":"# Binary Search Tree (BST) Height Calculation Task **Objective**: Implement a Binary Search Tree (BST) and write a function to calculate its height. **Requirements**: 1. Implement the `BSTNode` class and `BinarySearchTree` class with the following operations: - `BSTNode` constructor (`__init__(self, value: int)`) - Initialize a node with a given integer value and set the left and right children to None. - `BinarySearchTree` constructor (`__init__(self)`) - Initialize an empty BST. - `insert(self, value: int)` - Insert a node with the given value into the BST. - `height(self)` - Return the height of the BST. The height of an empty tree is -1, and the height of a tree with a single node is 0. **Inputs**: - `value`: An integer to be inserted into the BST. **Outputs**: - `height()`: An integer representing the height of the BST. **Constraints**: - All operations should run in logarithmic time, O(log n), on average, assuming the tree remains balanced. - Ensure your implementation handles cases of an empty BST, a BST with one element, and a BST with multiple elements. **Testing**: You should also write test cases to verify the correctness of your implementation, particularly focusing on edge cases such as an empty tree and a tree with only one node. **Example Usage**: ```python # Define the BSTNode class class BSTNode: def __init__(self, value: int): self.value = value self.left = None self.right = None # Define the BinarySearchTree class class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int): if not self.root: self.root = BSTNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left: self._insert_recursive(node.left, value) else: node.left = BSTNode(value) else: if node.right: self._insert_recursive(node.right, value) else: node.right = BSTNode(value) def height(self): return self._height_recursive(self.root) def _height_recursive(self, node): if not node: return -1 return 1 + max(self._height_recursive(node.left), self._height_recursive(node.right)) # Example usage bst = BinarySearchTree() print(bst.height()) # Output: -1 (empty tree) bst.insert(10) print(bst.height()) # Output: 0 (tree with one node) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) print(bst.height()) # Output: 2 (height of the current tree) ``` This problem helps to test the ability to handle fundamental tree-based structures and recursion for height calculation in a binary search tree. It aligns with the expected cognitive and technical challenges found in the original set of questions.","solution":"class BSTNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int): if not self.root: self.root = BSTNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left: self._insert_recursive(node.left, value) else: node.left = BSTNode(value) else: if node.right: self._insert_recursive(node.right, value) else: node.right = BSTNode(value) def height(self): return self._height_recursive(self.root) def _height_recursive(self, node): if not node: return -1 return 1 + max(self._height_recursive(node.left), self._height_recursive(node.right))"},{"question":"# Unique Element Identification **Scenario**: As a software developer, you are tasked with processing data where each element in a list appears exactly twice except for one. Your job is to identify this unique element. This type of problem often arises in data validation processes and optimizing the storage of unique identifiers. **Task**: Write a function that identifies the unique element in the list that doesn\'t have a duplicate. **Function Signature**: ```python def find_unique_element(data: list) -> int: Identify the unique element in the list where every other element appears exactly twice. Args: data (list): a list of integers where each element appears twice except for one. Returns: int: the unique element that does not have any duplicates. ``` **Input**: - `data`: a list of integers where `1 <= len(data) <= 3 * 10^4`. - Each element in `data` appears exactly twice except for one unique element that appears once. **Output**: - The function should return the single unique element that does not have any duplicates. **Constraints**: - The function should have a time complexity of O(n) and space complexity of O(1). - You may not use extra space other than a few variables. **Examples**: ```python # Sample Input/Output 1 >>> find_unique_element([2, 2, 3, 4, 4]) 3 # Sample Input/Output 2 >>> find_unique_element([1, 1, 5, 2, 2]) 5 # Sample Input/Output 3 >>> find_unique_element([10, 22, 22, 30, 10, 99, 99]) 30 # Sample Input/Output 4 >>> find_unique_element([7]) 7 # Sample Input/Output 5 >>> find_unique_element([-1, -1, -2, -3, -3]) -2 ``` **Requirements**: - Utilize bitwise XOR operation for an optimal solution. - Ensure the solution handles various edge cases effectively.","solution":"def find_unique_element(data: list) -> int: Identify the unique element in the list where every other element appears exactly twice. Args: data (list): a list of integers where each element appears twice except for one. Returns: int: the unique element that does not have any duplicates. unique = 0 for num in data: unique ^= num return unique"},{"question":"# Detect Cycles in an undirected Graph You are given an undirected graph represented as an adjacency list. Your task is to determine whether the graph contains any cycles. A cycle in an undirected graph is a path that starts and ends at the same vertex, with all edges and vertices distinct (except the starting and ending vertex). Write a function `has_cycle(graph: Dict[int, List[int]]) -> bool` that takes a dictionary representing the graph\'s adjacency list and returns a boolean indicating whether the graph contains a cycle. Input Format * A dictionary where the keys are integers representing nodes, and the values are lists of integers representing the neighboring nodes. Output Format * A boolean value `True` if the graph contains a cycle, and `False` otherwise. Constraints * The number of nodes in the graph will be at most 100. * Each node in the graph will be represented by a unique integer from 0 to 99. * Each list of neighbors will contain unique integers (no duplicate edges). Example ```python def has_cycle(graph: Dict[int, List[int]]) -> bool: # Your implementation here graph_1 = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2] } graph_2 = { 0: [1], 1: [0, 2], 2: [1, 3], 3: [2] } print(has_cycle(graph_1)) # Should return True, because there is a cycle: 0-1-2-0 print(has_cycle(graph_2)) # Should return False, because there is no cycle ```","solution":"def has_cycle(graph): def dfs(node, parent): visited.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor, node): return True elif neighbor != parent: return True return False visited = set() for node in graph: if node not in visited: if dfs(node, None): return True return False"},{"question":"# Longest Increasing Subsequence Objective Given an array of integers, implement a function to find the length of the longest increasing subsequence (LIS). A subsequence is derived from the array by deleting some or no elements without changing the order of the remaining elements. Function Signature ```python def length_of_lis(arr: List[int]) -> int: pass ``` Input 1. `arr` (List[int]): A list of integers. Output An integer representing the length of the longest increasing subsequence. Constraints - `1 <= len(arr) <= 2500` - `-10^4 <= arr[i] <= 10^4` Performance Requirements - The implementation should aim for a time complexity of O(N log N). Scenario Consider a scenario where a computer scientist is analyzing historical stock prices to determine the best time to invest. By finding the longest increasing subsequence of stock prices, they can gain insights on the optimal subsequence of days to hold onto the stocks for maximum profit based on historical performance. Example ```python arr = [10, 9, 2, 5, 3, 7, 101, 18] result = length_of_lis(arr) # Expected output: # 4 # Explanation: The LIS is [2, 3, 7, 101], which has length 4. ```","solution":"from typing import List import bisect def length_of_lis(arr: List[int]) -> int: Returns the length of the longest increasing subsequence. if not arr: return 0 tails = [] for num in arr: index = bisect.bisect_left(tails, num) if index == len(tails): tails.append(num) else: tails[index] = num return len(tails)"},{"question":"# Question: Implement Enhanced Dijkstra\'s Algorithm You are provided with the basic implementation of Dijkstra\'s Algorithm for finding the shortest paths between nodes in a graph. Your task is to enhance the existing implementation, ensuring that it handles all edge cases better, including disconnected graphs and negative weights (although Dijkstra\'s algorithm generally doesn\'t handle negative weights, you need to add checks to manage such inputs gracefully). # Objectives 1. Use the provided code snippet as a reference to understand the existing implementation of Dijkstra\'s Algorithm. 2. Enhance the implementation to correctly handle all edge cases such as disconnected graphs and ensure no negative weights are present. 3. Improve the performance where possible, possibly by optimizing data structures used in the implementation. 4. Write unit tests that cover a variety of scenarios, including edge cases. # Function Signature ```python def enhanced_dijkstra(graph: dict, start: str) -> dict: A refined implementation of Dijkstra\'s algorithm to find the shortest path. This enhanced version should correctly handle all edge cases and optimize performance. :param graph: a dictionary representing an adjacency list of the graph :param start: the starting node in the graph for which to find the shortest paths :return: a dictionary where the keys are nodes and the values are the shortest path distances from the start node Examples: >>> graph = { ... \'A\': {\'B\': 1, \'C\': 4}, ... \'B\': {\'A\': 1, \'C\': 2, \'D\': 5}, ... \'C\': {\'A\': 4, \'B\': 2, \'D\': 1}, ... \'D\': {\'B\': 5, \'C\': 1} ... } >>> enhanced_dijkstra(graph, \'A\') {\'A\': 0, \'B\': 1, \'C\': 3, \'D\': 4} >>> graph = {\'A\': {}, \'B\': {}, \'C\': {}} >>> enhanced_dijkstra(graph, \'A\') {\'A\': 0, \'B\': float(\'inf\'), \'C\': float(\'inf\')} >>> graph = {\'A\': {\'B\': -1}} >>> enhanced_dijkstra(graph, \'A\') ValueError: Graph contains negative weight edge pass ``` # Constraints * The graph is represented as a dictionary with nodes as keys and a dictionary of neighboring nodes and their edge weights as values. * The weights are assumed to be non-negative integers or floating-point numbers. * Your implementation should handle cases where the graph contains no edges, isolated nodes, and disconnected components. * Your solution should raise an error if a negative weight edge is detected. # Performance Requirements * The algorithm should perform efficiently on reasonably large graphs (up to 10,000 nodes and 50,000 edges). # Scenario Imagine you are tasked with designing a navigation system where you need to calculate the shortest path for vehicles from a starting point to various destinations. The system must handle cases with disconnected roads and ensure that no erroneous routes with negative distances are introduced. # Additional Notes * Utilize priority queues or min-heaps to manage the nodes efficiently. * Ensure your algorithm is well-documented and thoroughly tested with edge cases included.","solution":"import heapq def enhanced_dijkstra(graph, start): Returns the shortest paths from the start node to all other nodes in the graph using Dijkstra\'s algorithm. :param graph: a dictionary representing an adjacency list of the graph :param start: the starting node in the graph for which to find the shortest paths :return: a dictionary where the keys are nodes and the values are the shortest path distances from the start node # Check for negative weights in the graph for source in graph: for destination in graph[source]: if graph[source][destination] < 0: raise ValueError(\\"Graph contains negative weight edge\\") # Initialize distances and priority queue distances = {node: float(\'inf\') for node in graph} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Graph Traversal and Cycle Detection Context Graph traversal is a fundamental technique used to explore the nodes and edges of a graph. Detecting cycles within a graph is a common problem with many applications, including scheduling, deadlock prevention in operating systems, and analyzing dependencies. Task You are required to implement a function `detect_cycle_in_direct_graph` that determines if a cycle exists in a given directed graph using Depth-First Search (DFS). Your task involves writing a function `detect_cycle_in_direct_graph` that takes the following input: 1. `graph`: A dictionary representing an adjacency list of a directed graph, where the keys are node labels, and the values are lists of labels of nodes to which there is an outgoing edge. The function should return a boolean value indicating whether the graph contains a cycle (True if a cycle is present, False otherwise). Input - `graph`: A dictionary where the keys are node labels (strings) and the values are lists of node labels (strings). Output - Boolean value (True if a cycle exists, False otherwise). Constraints - Each node label is a unique string. - The graph can have up to `10^3` nodes and `10^4` edges. Performance Requirements - The function should efficiently handle graphs with up to `10^3` nodes and `10^4` edges. # Example ```python def detect_cycle_in_direct_graph(graph: dict[str, list[str]]) -> bool: # ... [Your Code Here] ... return has_cycle # Example usage: graph1 = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\"], } graph2 = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [], } has_cycle1 = detect_cycle_in_direct_graph(graph1) has_cycle2 = detect_cycle_in_direct_graph(graph2) print(has_cycle1) # True, because there is a cycle: A -> B -> C -> A print(has_cycle2) # False, there are no cycles ``` Note - Ensure that you implement the function using a DFS-based approach. Provide a well-commented solution to help understand the logic and approach taken.","solution":"def detect_cycle_in_direct_graph(graph): Detects if there is a cycle in a directed graph using Depth-First Search (DFS). Args: - graph (dict): A dictionary representing an adjacency list of a directed graph. Returns: - bool: True if a cycle exists, False otherwise. # Helper function for DFS def dfs(node): # Mark the node as being visited in the current path visited[node] = True rec_stack[node] = True # Visit all the neighbors for neighbor in graph.get(node, []): if not visited[neighbor]: # If neighbor hasn\'t been visited, do a DFS on it if dfs(neighbor): return True elif rec_stack[neighbor]: # If neighbor is in rec_stack, then it\'s a back edge and there\'s a cycle return True # Remove the node from recursion stack before backtracking rec_stack[node] = False return False # Keep track of visited nodes visited = {node: False for node in graph} rec_stack = {node: False for node in graph} # Check each node for cycle using DFS for node in graph: if not visited[node]: if dfs(node): return True return False"},{"question":"# Problem Statement You are tasked with designing and implementing a Circular Queue class that simulates the behavior of a circular buffer with a fixed-size capacity. The class should support basic queue operations along with one additional utility method. # Requirements 1. **Initialization:** - Initialize the CircularQueue with a specified size. 2. **Operations:** - **Enqueue(x)**: Add an element to the queue. If the queue is full, overwrite the oldest element. - **Dequeue()**: Remove and return the oldest element from the queue. If the queue is empty, return `None`. - **Front()**: Return the oldest element without removing it. If the queue is empty, return `None`. - **Rear()**: Return the most recently added element without removing it. If the queue is empty, return `None`. - **IsFull()**: Return `True` if the queue is full, otherwise `False`. - **IsEmpty()**: Return `True` if the queue is empty, otherwise `False`. - **Size()**: Return the number of elements currently in the queue. # Input Format - The queue size `n` (an integer `n > 0`). - A sequence of operations and their values. # Output Format - For the **dequeue** method, output the element being removed or `None`. - For the **size** method, output the current number of elements in the queue. - For the **front** and **rear** methods, output the respective elements or `None`. - For the **isFull** and **isEmpty** methods, return `True` or `False`. # Constraints - The size of the queue is a positive integer. - Operations are provided in the form of a list of tuples, where each tuple contains the operation name and the necessary parameters. # Example ```python # Initial queue size is 3 # Sequence of operations operations = [ (\\"enqueue\\", 1), (\\"enqueue\\", 2), (\\"enqueue\\", 3), (\\"isFull\\",), # True (\\"front\\",), # 1 (\\"rear\\",), # 3 (\\"dequeue\\",), # 1 (\\"front\\",), # 2 (\\"enqueue\\", 4), (\\"size\\",), # 3 (\\"enqueue\\", 5), (\\"rear\\",), # 5 ] circular_queue = CircularQueue(3) for operation in operations: if operation[0] == \\"enqueue\\": circular_queue.enqueue(operation[1]) elif operation[0] == \\"dequeue\\": print(circular_queue.dequeue()) elif operation[0] == \\"front\\": print(circular_queue.front()) elif operation[0] == \\"rear\\": print(circular_queue.rear()) elif operation[0] == \\"isFull\\": print(circular_queue.isFull()) elif operation[0] == \\"isEmpty\\": print(circular_queue.isEmpty()) elif operation[0] == \\"size\\": print(circular_queue.size()) ``` # Boilerplate Code: Implement the required methods in the provided class: ```python class CircularQueue: def __init__(self, n: int) -> None: # Initialize the circular queue with fixed capacity ... def enqueue(self, x: int): # Add an element to the queue, overwrite if full ... def dequeue(self) -> int: # Remove and return the oldest element, return None if empty ... def front(self) -> int: # Return the oldest element without removing it, return None if empty ... def rear(self) -> int: # Return the most recently added element without removing it, return None if empty ... def isFull(self) -> bool: # Check if the queue is full ... def isEmpty(self) -> bool: # Check if the queue is empty ... def size(self) -> int: # Return the number of elements in the queue ... ```","solution":"class CircularQueue: def __init__(self, n: int) -> None: Initialize the circular queue with a fixed capacity of n. self.capacity = n self.queue = [None] * n self.head = -1 self.tail = -1 self.count = 0 def enqueue(self, x: int): Add an element to the queue. Overwrite the oldest element if the queue is full. if self.isFull(): self.head = (self.head + 1) % self.capacity elif self.isEmpty(): self.head = 0 self.tail = (self.tail + 1) % self.capacity self.queue[self.tail] = x self.count = min(self.count + 1, self.capacity) def dequeue(self) -> int: Remove and return the oldest element from the queue. If the queue is empty, return None. if self.isEmpty(): return None result = self.queue[self.head] if self.head == self.tail: self.head = -1 self.tail = -1 else: self.head = (self.head + 1) % self.capacity self.count -= 1 return result def front(self) -> int: Return the oldest element without removing it. If the queue is empty, return None. if self.isEmpty(): return None return self.queue[self.head] def rear(self) -> int: Return the most recently added element without removing it. If the queue is empty, return None. if self.isEmpty(): return None return self.queue[self.tail] def isFull(self) -> bool: Return True if the queue is full, otherwise False. return self.count == self.capacity def isEmpty(self) -> bool: Return True if the queue is empty, otherwise False. return self.count == 0 def size(self) -> int: Return the number of elements currently in the queue. return self.count"},{"question":"# Kth Smallest Element in a Sorted Matrix **Objective**: Write a function to find the Kth smallest element in a given `n x n` matrix where each of the rows and columns is sorted in ascending order. This problem tests your ability to implement efficient search algorithms in a structured data format. Function Signature ```python def kth_smallest(matrix: list[list[int]], k: int) -> int: pass ``` Input * `matrix` (2D list of integers): An `n x n` matrix where each row and column is sorted in ascending order. * `k` (integer): An integer representing the Kth position in the sorted order of all elements in the matrix. Output * An integer representing the Kth smallest element in the matrix. Constraints * The matrix dimensions `1 ≤ n ≤ 1000`. * `1 ≤ matrix[i][j] ≤ 10^9` for all `0 ≤ i, j < n`. * `1 ≤ k ≤ n^2`. Requirements * Your solution must be efficient enough to handle the largest inputs under a reasonable time limit. * Utilize matrix properties to optimize the search process. Example ```python matrix = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] k = 8 print(kth_smallest(matrix, k)) # Output: 13 matrix = [ [1, 2], [1, 3] ] k = 2 print(kth_smallest(matrix, k)) # Output: 1 ``` Additional Scenarios * Handle the smallest matrix (1x1), for instance, `[[1]]` with `k=1` should return `1`. * Consider edge cases where `k` corresponds to the largest element in the matrix. Develop your solution in Python, keeping in mind the need for efficient handling of large matrices and making sure to cover edge cases.","solution":"import heapq def kth_smallest(matrix, k): Finds the kth smallest element in a sorted n x n matrix. n = len(matrix) min_heap = [] # Initialize the heap with the first element of each row (only the first k rows) for r in range(min(k, n)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract-min k times to get the kth smallest element for _ in range(k - 1): element, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return heapq.heappop(min_heap)[0]"},{"question":"You are given two strings representing two book titles. Your task is to determine if these two book titles can be made anagrams of each other by rearranging the characters. Write a function called `are_anagrams(title1: str, title2: str) -> bool` which takes two strings as arguments and returns `True` if the two titles can be made anagrams and `False` otherwise. # Input Format - Two strings `title1` and `title2`, each representing a book title. # Output Format - Return a boolean value `True` if the two titles can be made anagrams, otherwise return `False`. # Constraints - Titles are non-empty strings and may contain uppercase and lowercase letters, digits, spaces, and punctuation. - Comparisons should be case-insensitive. # Example ```python def test_are_anagrams(): assert are_anagrams(\\"deeR predator\\", \\"derEd partoer\\") == True assert are_anagrams(\\"Harry Potter\\", \\"Percy Jackson\\") == False test_are_anagrams() ``` # Performance Requirements * The function should complete within a reasonable time limit, even if the titles are quite long (up to 100 characters).","solution":"from collections import Counter def are_anagrams(title1: str, title2: str) -> bool: Determine if two book titles can be made anagrams of each other. :param title1: First book title :param title2: Second book title :return: True if the titles can be made anagrams, False otherwise # Normalize both titles by converting to lowercase and removing spaces title1 = \'\'.join(title1.lower().split()) title2 = \'\'.join(title2.lower().split()) # Use Counter to count the frequency of each character return Counter(title1) == Counter(title2)"},{"question":"# Question: Implement a Merge Sort algorithm Context: You are tasked with sorting a list of integers for a data processing application. To achieve this, you will implement the Merge Sort algorithm, a classic divide-and-conquer sorting technique known for its efficiency and stability. Task: Implement a function `merge_sort(nums: List[int]) -> List[int]` that sorts the given list of integers in ascending order using the Merge Sort algorithm. Function Signature: ```python from typing import List def merge_sort(nums: List[int]) -> List[int]: pass ``` # Input: * A list `nums` (0 ≤ len(nums) ≤ 1000) of integers where each integer `nums[i]` satisfies `-10^6 ≤ nums[i] ≤ 10^6`. # Output: * A list of integers sorted in ascending order. # Constraints: * Ensure your implementation follows the Merge Sort algorithm. * Be mindful of the time complexity (O(n log n)) and space complexity. # Examples ```python assert merge_sort([38, 27, 43, 3, 9, 82, 10]) == [3, 9, 10, 27, 38, 43, 82] assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert merge_sort([]) == [] assert merge_sort([0, 0, 0, 0]) == [0, 0, 0, 0] assert merge_sort([-1, -2, -3, -4, -5]) == [-5, -4, -3, -2, -1] assert merge_sort([-5, 0, 5, -10, 10]) == [-10, -5, 0, 5, 10] ``` # Notes: * You may use a helper function to merge two sorted lists. * Ensure to implement the recursive nature of the Merge Sort algorithm. * Handle edge cases like empty lists, already sorted lists, and lists with negative numbers appropriately.","solution":"from typing import List def merge_sort(nums: List[int]) -> List[int]: if len(nums) <= 1: return nums def merge(left: List[int], right: List[int]) -> List[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result mid = len(nums) // 2 left_half = merge_sort(nums[:mid]) right_half = merge_sort(nums[mid:]) return merge(left_half, right_half)"},{"question":"# Sum of Digits in Base Conversion Assessment Your task is to implement functions to convert an integer to any given base (between 2 and 36) and calculate the sum of digits in the converted base. Part 1: Base Conversion Implement the function `convert_to_base(n: int, base: int) -> str` that takes an integer `n` and a target `base`, and returns the string representation of `n` in the target base. # Input * `n` (int): An integer to be converted. * `base` (int): The target base for conversion (2 <= base <= 36). # Output * A string representing the integer in the given base. # Example ```python >>> convert_to_base(255, 16) \'FF\' >>> convert_to_base(255, 2) \'11111111\' ``` Part 2: Sum of Digits Implement the function `sum_of_digits_in_base(n: int, base: int) -> int` that takes an integer `n` and a target `base`, and returns the sum of the digits of `n` in the given base. # Input * `n` (int): An integer whose digits are to be summed after conversion. * `base` (int): The base for conversion and digit-sum calculation (2 <= base <= 36). # Output * An integer representing the sum of digits. # Example ```python >>> sum_of_digits_in_base(255, 16) 30 # 15 + 15 because \'FF\' -> 15 + 15 in decimal >>> sum_of_digits_in_base(255, 2) 8 # 1+1+1+1+1+1+1+1 because \'11111111\' ``` Constraints * You may assume the input integer `n` is non-negative. * The target base will be in the inclusive range `[2, 36]`. * For bases larger than 10, use \'A\' to \'Z\' for representing values 10 to 35 respectively. * Handle edge cases such as `n = 0` and `base = 2` appropriately to avoid errors. Performance Requirements * Aim for efficient algorithms with linear time complexity relative to the number of digits in the base-converted number. ```python def convert_to_base(n: int, base: int) -> str: # Your code here def sum_of_digits_in_base(n: int, base: int) -> int: # Your code here ```","solution":"def convert_to_base(n: int, base: int) -> str: if n == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" result = \\"\\" while n > 0: result = digits[n % base] + result n //= base return result def sum_of_digits_in_base(n: int, base: int) -> int: converted = convert_to_base(n, base) return sum(int(char, base) for char in converted)"},{"question":"# Question Write a function `rank_students` that processes a list of student names and their corresponding grades, then returns a list of student names sorted by their grades in descending order. If two students have the same grade, they should be sorted alphabetically by their names. Function: `rank_students` * **Input**: - `students` (list of tuples): Each tuple contains a student\'s name (string) and grade (integer). For example: `[(\\"Alice\\", 88), (\\"Bob\\", 91)]` * **Output**: A list of student names (strings) sorted based on the criteria mentioned. Requirements: 1. The list returned should sort students primarily by their grades in descending order. 2. For students with the same grade, sort their names alphabetically. 3. Treat names case-insensitively in terms of alphabetical sorting. Example Usage: ```python assert rank_students([(\\"Alice\\", 91), (\\"Bob\\", 88), (\\"Charlie\\", 88), (\\"Dave\\", 91)]) == [\\"Alice\\", \\"Dave\\", \\"Bob\\", \\"Charlie\\"] assert rank_students([(\\"Elena\\", 95), (\\"Faye\\", 95), (\\"Gina\\", 95), (\\"Holly\\", 92)]) == [\\"Elena\\", \\"Faye\\", \\"Gina\\", \\"Holly\\"] assert rank_students([(\\"Ivy\\", 100), (\\"Jack\\", 82), (\\"Kevin\\", 82), (\\"Liam\\", 70)]) == [\\"Ivy\\", \\"Jack\\", \\"Kevin\\", \\"Liam\\"] ``` Note: - Ensure that the implementation is efficient and handles a large number of students. Create this function and demonstrate its usage with the provided examples. ```python def rank_students(students): students.sort(key=lambda x: (-x[1], x[0].upper())) return [student[0] for student in students] # Example usages print(rank_students([(\\"Alice\\", 91), (\\"Bob\\", 88), (\\"Charlie\\", 88), (\\"Dave\\", 91)])) # Output: [\'Alice\', \'Dave\', \'Bob\', \'Charlie\'] print(rank_students([(\\"Elena\\", 95), (\\"Faye\\", 95), (\\"Gina\\", 95), (\\"Holly\\", 92)])) # Output: [\'Elena\', \'Faye\', \'Gina\', \'Holly\'] print(rank_students([(\\"Ivy\\", 100), (\\"Jack\\", 82), (\\"Kevin\\", 82), (\\"Liam\\", 70)])) # Output: [\'Ivy\', \'Jack\', \'Kevin\', \'Liam\'] ```","solution":"def rank_students(students): students.sort(key=lambda x: (-x[1], x[0].lower())) return [student[0] for student in students] # Example usages print(rank_students([(\\"Alice\\", 91), (\\"Bob\\", 88), (\\"Charlie\\", 88), (\\"Dave\\", 91)])) # Output: [\'Alice\', \'Dave\', \'Bob\', \'Charlie\'] print(rank_students([(\\"Elena\\", 95), (\\"Faye\\", 95), (\\"Gina\\", 95), (\\"Holly\\", 92)])) # Output: [\'Elena\', \'Faye\', \'Gina\', \'Holly\'] print(rank_students([(\\"Ivy\\", 100), (\\"Jack\\", 82), (\\"Kevin\\", 82), (\\"Liam\\", 70)])) # Output: [\'Ivy\', \'Jack\', \'Kevin\', \'Liam\']"},{"question":"# Coding Assessment Question Context Implement a function that transforms a string by reversing the characters of each word while preserving the order of words. This exercise aims to test string manipulation and basic algorithmic skills. Task Write a Python function `reverse_words(input_string: str) -> str` that takes a string containing multiple words separated by spaces and returns a new string where the characters of each word are reversed while maintaining the order of the words. Function Signature ```python def reverse_words(input_string: str) -> str: pass ``` Inputs - `input_string` (str): A string containing multiple words separated by spaces. Output - Returns a string where each word in the input string has its characters reversed while the order of the words remains unchanged. Constraints - Each word in the input string is separated by a single space. - The input string consists of only alphabetic characters and spaces. - Assume no leading, trailing, or multiple spaces. Examples ```python >>> reverse_words(\\"hello world\\") \'olleh dlrow\' >>> reverse_words(\\"python programming\\") \'nohtyp gnimmargorp\' >>> reverse_words(\\"madam racecar level\\") \'madam racecar level\' >>> reverse_words(\\"you are amazing\\") \'uoy era gnizama\' >>> reverse_words(\\"a b c\\") \'a b c\' >>> reverse_words(\\"\\") \'\' ``` Notes - Consider edge cases such as an empty string or a string with a single word. - Ensure the function handles strings properly without altering the order of the words.","solution":"def reverse_words(input_string: str) -> str: Reverses each word in the input string while preserving the order of words. if not input_string: return \\"\\" words = input_string.split(\' \') reversed_words = [word[::-1] for word in words] return \' \'.join(reversed_words)"},{"question":"# Coding Question: Generating Pascal\'s Triangle Pascal\'s Triangle is a triangular array of the binomial coefficients. The construction of the first few rows is as follows: ``` 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 ``` Each entry on a new row is computed by adding the number directly above and the number to the left above. Write a function that outputs the first *n* rows of Pascal\'s Triangle in a list of lists format. Ensure proper error handling for non-positive integers and invalid types. Function Signature ```python def generate_pascals_triangle(n: int) -> List[List[int]]: :param n: the number of rows to generate :return: a 2D list containing the first n rows of Pascal\'s Triangle Note: This function is only defined for positive integers >>> generate_pascals_triangle(1) [[1]] >>> generate_pascals_triangle(5) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] >>> generate_pascals_triangle(0) Traceback (most recent call last): ... ValueError: Input must be a positive integer >>> generate_pascals_triangle(-2) Traceback (most recent call last): ... ValueError: Input must be a positive integer >>> generate_pascals_triangle(2.5) Traceback (most recent call last): ... TypeError: Input value of [n=2.5] must be an integer pass ``` # Constraints 1. The input `n` should be a positive integer. 2. Handle scenarios where `n` is non-positive or non-integer gracefully by raising appropriate errors. # Task Implement the `generate_pascals_triangle` function that: - Takes `n` as an argument. - Returns a 2D list containing the first `n` rows of Pascal\'s Triangle. *Hints*: - Use iterative or recursive approaches to populate each row based on the previous row. - Validate the input before proceeding with the calculations.","solution":"from typing import List def generate_pascals_triangle(n: int) -> List[List[int]]: Generates the first n rows of Pascal\'s Triangle. :param n: the number of rows to generate; must be a positive integer. :return: a 2D list containing the first n rows of Pascal\'s Triangle. :raises ValueError: if n is not a positive integer. :raises TypeError: if n is not an integer. >>> generate_pascals_triangle(1) [[1]] >>> generate_pascals_triangle(5) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] >>> generate_pascals_triangle(0) Traceback (most recent call last): ... ValueError: Input must be a positive integer >>> generate_pascals_triangle(-2) Traceback (most recent call last): ... ValueError: Input must be a positive integer >>> generate_pascals_triangle(2.5) Traceback (most recent call last): ... TypeError: Input value of [n=2.5] must be an integer if not isinstance(n, int): raise TypeError(f\\"Input value of [n={n}] must be an integer\\") if n <= 0: raise ValueError(\\"Input must be a positive integer\\") result = [] for i in range(n): row = [1] * (i + 1) for j in range(1, i): row[j] = result[i - 1][j - 1] + result[i - 1][j] result.append(row) return result"},{"question":"# Scenario You are working on a social media platform where users can create and respond to posts. To promote user interaction, you are tasked with implementing a feature to identify the most frequently used words in the responses to a specific post. Your function should filter out common English stopwords and return the top N frequent words used in the responses. # Function Implementation Implement a function `top_frequent_words(responses: List[str], n: int) -> List[str]` in Python, which finds the top N most frequently used words in the provided list of responses. Words should be considered case-insensitive and should exclude common English stopwords. # Input and Output Formats * **Input**: - `responses`: A list of strings, where each string is a response to the post. - `n`: An integer representing the number of top frequent words to return. Constraints: `1 <= n <= 100`. * **Output**: A list of strings representing the top N most frequently used words, sorted in descending order of frequency. If there are ties, sort the words alphabetically. # Constraints * All characters in responses are alphanumeric or spaces. * Input `n` will not be greater than the total number of unique words after filtering stopwords. # Requirements 1. Ignore common English stopwords. A predefined set can be used for this task. 2. Words should be considered case-insensitive. 3. The result should be a list of words in descending order of frequency. If frequencies are tied, sort alphabetically. # Example ```python from typing import List # Example Usage responses = [ \\"I love the new feature! It\'s absolutely fantastic.\\", \\"Fantastic work on the new update. I love it!\\", \\"Love the changes. Fantastic job!\\" ] n = 3 print(top_frequent_words(responses, n)) # Output: [\'fantastic\', \'love\', \'new\'] ``` # Detailed Steps 1. Preprocess each response by converting to lower case and removing punctuation. 2. Tokenize each response into words. 3. Filter out common English stopwords from the tokens. 4. Count the frequency of each remaining word. 5. Sort the words primarily by frequency in descending order; if frequencies are tied, sort alphabetically. 6. Return the top N words as a list of strings.","solution":"from typing import List import re from collections import Counter def top_frequent_words(responses: List[str], n: int) -> List[str]: stopwords = set([ \\"i\\", \\"me\\", \\"my\\", \\"myself\\", \\"we\\", \\"our\\", \\"ours\\", \\"ourselves\\", \\"you\\", \\"your\\", \\"yours\\", \\"yourself\\", \\"yourselves\\", \\"he\\", \\"him\\", \\"his\\", \\"himself\\", \\"she\\", \\"her\\", \\"hers\\", \\"herself\\", \\"it\\", \\"its\\", \\"itself\\", \\"they\\", \\"them\\", \\"their\\", \\"theirs\\", \\"themselves\\", \\"what\\", \\"which\\", \\"who\\", \\"whom\\", \\"this\\", \\"that\\", \\"these\\", \\"those\\", \\"am\\", \\"is\\", \\"are\\", \\"was\\", \\"were\\", \\"be\\", \\"been\\", \\"being\\", \\"have\\", \\"has\\", \\"had\\", \\"having\\", \\"do\\", \\"does\\", \\"did\\", \\"doing\\", \\"a\\", \\"an\\", \\"the\\", \\"and\\", \\"but\\", \\"if\\", \\"or\\", \\"because\\", \\"as\\", \\"until\\", \\"while\\", \\"of\\", \\"at\\", \\"by\\", \\"for\\", \\"with\\", \\"about\\", \\"against\\", \\"between\\", \\"into\\", \\"through\\", \\"during\\", \\"before\\", \\"after\\", \\"above\\", \\"below\\", \\"to\\", \\"from\\", \\"up\\", \\"down\\", \\"in\\", \\"out\\", \\"on\\", \\"off\\", \\"over\\", \\"under\\", \\"again\\", \\"further\\", \\"then\\", \\"once\\", \\"here\\", \\"there\\", \\"when\\", \\"where\\", \\"why\\", \\"how\\", \\"all\\", \\"any\\", \\"both\\", \\"each\\", \\"few\\", \\"more\\", \\"most\\", \\"other\\", \\"some\\", \\"such\\", \\"no\\", \\"nor\\", \\"not\\", \\"only\\", \\"own\\", \\"same\\", \\"so\\", \\"than\\", \\"too\\", \\"very\\", \\"s\\", \\"t\\", \\"can\\", \\"will\\", \\"just\\", \\"don\\", \\"should\\", \\"now\\" ]) word_counter = Counter() for response in responses: # Convert to lower case and find all words words = re.findall(r\'bw+b\', response.lower()) filtered_words = [word for word in words if word not in stopwords] word_counter.update(filtered_words) most_common_words = word_counter.most_common() sorted_words = sorted(most_common_words, key=lambda x: (-x[1], x[0])) return [word for word, _ in sorted_words[:n]]"},{"question":"# Question: Calculate Water Trapped After Rainfall You are tasked with determining how much water can be trapped between buildings after a rainstorm. Each building is represented by a non-negative integer in an array where the position of the integer corresponds to the height of the building at that position. # Scenario In an urban landscape, you need to analyze how water pools between buildings of varying heights after heavy rainfall. Implement a function to calculate the amount of water trapped. # Function Signature ```python def calculate_trapped_water(heights: List[int]) -> int: pass ``` # Input - `heights` (List[int]): A list of non-negative integers representing the heights of buildings. # Output - Returns an integer representing the total amount of water trapped. # Constraints - `heights` contains at least one element and can have up to 100,000 elements. - Building heights are between 0 and 10,000. # Example ```python assert calculate_trapped_water([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 assert calculate_trapped_water([4,2,0,3,2,5]) == 9 assert calculate_trapped_water([1,0,1]) == 1 assert calculate_trapped_water([2,0,0,1]) == 1 ``` # Requirements - Implement an efficient algorithm to calculate the trapped water. - Consider both time and space complexity to ensure performance with larger lists. - Ensure your program handles various edge cases.","solution":"from typing import List def calculate_trapped_water(heights: List[int]) -> int: Calculate the total amount of water trapped between buildings, represented by height array. if not heights or len(heights) < 3: return 0 total_water = 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) total_water += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) total_water += max(0, right_max - heights[right]) return total_water"},{"question":"# Context and Problem Statement You are a data scientist tasked with cleaning a dataset containing tabular data. Each row in this dataset is a list of strings, with some of the strings potentially containing leading or trailing whitespace. You need to write a program that will remove this unwanted whitespace from every element in the dataset. # Task Implement a function `clean_dataset(dataset: List[List[str]]) -> List[List[str]]` that takes: 1. **dataset** (List[List[str]]): A list of lists where each inner list represents a row in the dataset, with each element being a string that may contain leading or trailing whitespace. Return a new dataset with the same structure but with leading and trailing whitespace removed from each string. # Input and Output Formats **Input:** * A list of lists of strings, `dataset`. **Output:** * A list of lists of strings with the leading and trailing whitespace removed from each string. # Constraints * `1 <= len(dataset) <= 10^5` * `1 <= len(dataset[i]) <= 100` * Each string in the dataset has a length of at most 100 characters. # Example ```python dataset = [ [\\" Alice \\", \\" Bob\\", \\" Eve \\"], [\\" Data \\", \\" Science \\", \\" is \\"], [\\" Important\\", \\" For \\", \\" Industry \\"] ] assert clean_dataset(dataset) == [ [\\"Alice\\", \\"Bob\\", \\"Eve\\"], [\\"Data\\", \\"Science\\", \\"is\\"], [\\"Important\\", \\"For\\", \\"Industry\\"] ] ``` # Explanation: 1. In the first example, the leading and trailing whitespace is removed from all the strings in each row, transforming `[\\" Alice \\", \\" Bob\\", \\" Eve \\"]` to `[\\"Alice\\", \\"Bob\\", \\"Eve\\"]`. 2. Similarly, all other rows have their strings cleaned of leading and trailing whitespace. # Follow-up: Discuss the efficiency of your function and how it handles large datasets within the provided constraints.","solution":"from typing import List def clean_dataset(dataset: List[List[str]]) -> List[List[str]]: Takes a list of lists where each inner list represents a row in the dataset, with each element being a string that may contain leading or trailing whitespace. Removes the leading and trailing whitespace from each string. # Iterate over each row in the dataset cleaned_data = [] for row in dataset: cleaned_row = [element.strip() for element in row] cleaned_data.append(cleaned_row) return cleaned_data"},{"question":"# Problem: Identifying Unique Characters in a String You need to implement a function that identifies if a string has all unique characters. Your goal is to create an efficient solution that determines whether all characters in the input string are unique without using any additional data structures. Implement a function `is_unique` which checks the uniqueness of characters in a string. The function should handle invalid inputs gracefully and operate within acceptable performance limits. # Function Definition ```python def is_unique(s: str) -> bool: # Your implementation here ``` # Method Specification The `is_unique` function should: - **Input**: A string `s` where `0 <= len(s) <= 10^5`. - **Output**: A boolean value `True` if all characters in the string are unique, `False` otherwise. # Constraints - The function should handle empty strings by returning `True`. - The function should handle non-string inputs gracefully, returning `False` and printing an appropriate message. - Ensure that the function is optimized in terms of time and space complexity. # Example ```python print(is_unique(\\"abcdef\\")) # Output: True print(is_unique(\\"aabcdef\\")) # Output: False print(is_unique(\\"\\")) # Output: True print(is_unique(12345)) # Output: False with a message \\"Input should be a string.\\" ``` # Additional Requirements - Include proper error handling for edge cases and invalid inputs. - Optimize for performance, especially given the constraint on string length. In your function, avoid using additional data structures like sets or dictionaries; instead, leverage bitwise operations or other space-efficient techniques.","solution":"def is_unique(s): Determines if all characters in the string are unique. Args: s (str): The input string. Returns: bool: True if all characters in the string are unique, False otherwise. if not isinstance(s, str): print(\\"Input should be a string.\\") return False if len(s) > 256: # There can\'t be more unique characters than the number of ASCII characters return False checker = 0 for char in s: val = ord(char) if (checker & (1 << val)) > 0: return False checker |= (1 << val) return True"},{"question":"# Coding Question: Chemical Solution Dilution You are a chemist creating a software tool to calculate the concentrations of chemical solutions. Given the formula for dilution, your task is to write a function that computes the final concentration of a solution after dilution. **Problem Statement**: Write a function to calculate the concentration of a solution after it has been diluted. Function Signature ```python def calculate_dilution(initial_volume: float, initial_concentration: float, final_volume: float) -> float: Calculates the final concentration of a solution after dilution. Args: initial_volume (float): initial volume of the solution in liters. initial_concentration (float): initial concentration of the solution in moles per liter (M). final_volume (float): final volume of the solution in liters after adding solvent. Returns: float: the final concentration of the solution in moles per liter (M). Raises: ValueError: if any of the input values are negative or if final_volume is less than the initial_volume. ``` Inputs: | Name | Units | Type | |---------------------|--------------|-------| | initial_volume | (in liters) | float | | initial_concentration | (in Moles/L) | float | | final_volume | (in liters) | float | Outputs: | Name | Units | Type | |---------------------|----------------|-------| | final_concentration | (in Moles/L) | float | Constraints: 1. All inputs must be non-negative. 2. The final volume must be greater than or equal to the initial volume. 3. Use the formula `final_concentration = (initial_volume * initial_concentration) / final_volume` to compute the final concentration. Example: ```python >>> calculate_dilution(1.0, 2.0, 3.0) 0.6666666666666666 >>> calculate_dilution(0.5, 1.5, 0.5) 1.5 ``` **Note**: Ensure robust handling of invalid inputs by raising `ValueError` if negative values are provided for initial_volume, initial_concentration, or final_volume, or if final_volume is less than the initial_volume. **Performance Requirements**: * The time complexity should remain O(1), as final concentration is computed using constant-time operations.","solution":"def calculate_dilution(initial_volume: float, initial_concentration: float, final_volume: float) -> float: Calculates the final concentration of a solution after dilution. Args: initial_volume (float): Initial volume of the solution in liters. initial_concentration (float): Initial concentration of the solution in moles per liter (M). final_volume (float): Final volume of the solution in liters after adding solvent. Returns: float: The final concentration of the solution in moles per liter (M). Raises: ValueError: If any of the input values are negative or if final_volume is less than the initial_volume. if initial_volume < 0 or initial_concentration < 0 or final_volume < 0: raise ValueError(\\"Volumes and concentrations must be non-negative.\\") if final_volume < initial_volume: raise ValueError(\\"Final volume must be greater than or equal to the initial volume.\\") final_concentration = (initial_volume * initial_concentration) / final_volume return final_concentration"},{"question":"**Question**: You are developing a system for a delivery drones service that calculates the total delivered weight and the total distance traveled by each drone. Each delivery job assigned to a drone consists of the weight of the package and the distance it needs to travel one way. At the end of the day, you need to generate a report to evaluate the performance of all drones. Given a list of delivery jobs for each drone, your task is to calculate the total weight delivered and the total distance traveled by a specified drone. Assume each drone completes all its assigned jobs and returns to the starting point after each delivery. **Function Specification**: You need to implement the function `drone_performance` which calculates the total delivered weight and returns the total distance traveled by a given drone ID. *Input Parameters*: - `jobs` (list of tuples): Each tuple contains three elements: (drone_id (int), weight (float) (in kilograms), distance (float) (in kilometers)). - `drone_id` (int): The ID of the drone for which the calculations are to be performed. *Output*: - A dictionary with two keys: - `\'total_weight\'`: the total weight delivered by the specified drone in kilograms. - `\'total_distance\'`: the total distance traveled by the specified drone in kilometers (including return trips). *Constraints*: 1. `drone_id` will be a positive integer. 2. Each weight and distance are positive floating-point numbers. 3. The list of jobs will not be empty, and each drone ID in the list is unique. *Example*: ```python >>> jobs = [(1, 5.0, 10.0), (2, 3.2, 5.5), (1, 2.5, 8.0), (3, 4.0, 12.0), (1, 1.2, 3.3)] >>> drone_performance(jobs, 1) {\'total_weight\': 8.7, \'total_distance\': 42.6} >>> drone_performance(jobs, 2) {\'total_weight\': 3.2, \'total_distance\': 11.0} >>> drone_performance(jobs, 3) {\'total_weight\': 4.0, \'total_distance\': 24.0} ``` *Error Handling*: - Raise a `ValueError` if the specified `drone_id` is not found in the list of jobs. - Raise a `ValueError` if any weight or distance in the input list of jobs is non-positive. Implement the function `drone_performance` to fulfill the above requirements.","solution":"def drone_performance(jobs, drone_id): Calculate the total weight delivered and the total distance traveled by a specified drone. Parameters: jobs (list of tuples): Each tuple contains (drone_id, weight, distance). drone_id (int): The ID of the drone for which the calculations are to be performed. Returns: dict: A dictionary with \'total_weight\' and \'total_distance\'. total_weight = 0 total_distance = 0 drone_found = False for job in jobs: if len(job) != 3: raise ValueError(\\"Each job must have exactly three elements: (drone_id, weight, distance)\\") job_drone_id, weight, distance = job if job_drone_id == drone_id: drone_found = True if weight <= 0 or distance <= 0: raise ValueError(\\"Weight and distance must be positive values.\\") total_weight += weight total_distance += 2 * distance # to account for round trip if not drone_found: raise ValueError(\\"Specified drone_id not found in the list of jobs.\\") return {\'total_weight\': total_weight, \'total_distance\': total_distance}"},{"question":"# Context Many software systems, including online multiplayer games and collaborative platforms, need to keep track of users\' real-time locations. Efficient management of user locations allows the system to quickly query and update each user\'s current position. # Problem Statement You are required to implement a data structure `UserLocationManager` that supports operations to set a user\'s location (`set_location`), get a user\'s location (`get_location`), and find all users within a given distance from a specific point (`find_nearby_users`). Additionally, implement a method to get the total number of users in the system (`total_users`). # Task Extend the provided data structure with the following functionalities: 1. **Set User Location**: * Implement a method `set_location(user_id: int, x: float, y: float) -> None` that updates the location of the user identified by `user_id` to the given coordinates `(x, y)`. 2. **Get User Location**: * Implement a method `get_location(user_id: int) -> Tuple[float, float]` that returns the current location `(x, y)` of the user identified by `user_id`. 3. **Find Nearby Users**: * Implement a method `find_nearby_users(x: float, y: float, distance: float) -> List[int]` that returns a list of user IDs who are within the specified `distance` from the point `(x, y)`. 4. **Total Users**: * Implement a method `total_users() -> int` that returns the total number of users currently being tracked by the system. # Function Signature ```python class UserLocationManager: def __init__(self): # Initialize your data structure here pass def set_location(self, user_id: int, x: float, y: float) -> None: pass def get_location(self, user_id: int) -> Tuple[float, float]: pass def find_nearby_users(self, x: float, y: float, distance: float) -> List[int]: pass def total_users(self) -> int: pass ``` # Input * A series of user ID-integer values and floating-point coordinate values that may be subjected to `set_location` and `get_location` operations. * Coordinates will be in the form of pairs `(x, y)`. * Distance will be specified as a floating-point value. # Output * **set_location**: No return value. * **get_location**: A tuple `(x, y)` representing the coordinates of the user. * **find_nearby_users**: A list of integers representing user IDs within the specified distance. * **total_users**: An integer representing the total number of users. # Example Usage ```python # Example Usage ulm = UserLocationManager() ulm.set_location(1, 1.0, 1.0) ulm.set_location(2, 2.0, 2.0) ulm.set_location(3, 3.0, 3.0) print(ulm.get_location(2)) # Should output (2.0, 2.0) print(ulm.find_nearby_users(1.0, 1.0, 2.0)) # Should output [1, 2] ulm.set_location(4, 10.0, 10.0) print(ulm.total_users()) # Should output 4 ``` # Constraints 1. Assume that user IDs are unique and are integers. 2. The total number of users will be less than or equal to 10,000. 3. Coordinates are floating-point values ranging from -100,000.0 to 100,000.0. 4. Distance will be a non-negative floating-point value. 5. The methods should handle the operations efficiently even when the number of users is near its upper limit.","solution":"import math from typing import Tuple, List, Dict class UserLocationManager: def __init__(self): # Initialize dictionary to store users\' locations self.user_locations: Dict[int, Tuple[float, float]] = {} def set_location(self, user_id: int, x: float, y: float) -> None: # Set the user location self.user_locations[user_id] = (x, y) def get_location(self, user_id: int) -> Tuple[float, float]: # Return the user location return self.user_locations.get(user_id, None) def find_nearby_users(self, x: float, y: float, distance: float) -> List[int]: # Find all users within a given distance from point (x, y) nearby_users = [] for user_id, (ux, uy) in self.user_locations.items(): if math.sqrt((ux - x) ** 2 + (uy - y) ** 2) <= distance: nearby_users.append(user_id) return nearby_users def total_users(self) -> int: # Return the total number of users return len(self.user_locations)"},{"question":"# Background You are working on a data analytics project that involves analyzing transactions. Among other tasks, you need to filter out fraudulent transactions based on a set of given rules. # Problem Write a function `find_fraudulent_transactions` that analyzes a list of transaction records and identifies which transactions are potentially fraudulent. A transaction is considered fraudulent if it meets any of the following criteria: 1. The amount exceeds 10,000. 2. The transaction occurs within 10 minutes of another transaction originating from the same account and the transaction amounts are identical. Your function should return a list of transaction IDs that are identified as fraudulent. # Function Signature ```python def find_fraudulent_transactions(transactions: List[Dict[str, Union[str, int]]]) -> List[str]: pass ``` # Input * `transactions` (List[Dict[str, Union[str, int]]]): A list of transaction records. Each transaction record is a dictionary with the following keys: * `id` (str): The transaction ID. * `account_id` (str): The account ID from which the transaction was made. * `amount` (int): The amount of the transaction in dollars. * `timestamp` (int): The time of the transaction in Unix timestamp format. # Output * Returns a list of transaction IDs (strings) that are considered fraudulent. # Example ```python transactions = [ {\\"id\\": \\"txn1\\", \\"account_id\\": \\"acc1\\", \\"amount\\": 15000, \\"timestamp\\": 1633035600}, {\\"id\\": \\"txn2\\", \\"account_id\\": \\"acc1\\", \\"amount\\": 2000, \\"timestamp\\": 1633035900}, {\\"id\\": \\"txn3\\", \\"account_id\\": \\"acc2\\", \\"amount\\": 5000, \\"timestamp\\": 1633036200}, {\\"id\\": \\"txn4\\", \\"account_id\\": \\"acc1\\", \\"amount\\": 2000, \\"timestamp\\": 1633036210}, {\\"id\\": \\"txn5\\", \\"account_id\\": \\"acc3\\", \\"amount\\": 11000, \\"timestamp\\": 1633036500} ] find_fraudulent_transactions(transactions) # Returns [\\"txn1\\", \\"txn4\\", \\"txn5\\"] ``` # Constraints * The number of transactions in the input list can be up to 100,000. * Transaction amounts and timestamps are positive integers. * Assume no two transactions have the same timestamp. # Additional Notes * Ensure efficiency in processing potentially large lists of transactions. * Consider using appropriate data structures to optimize for time complexity, especially for checking transactions within a 10-minute window.","solution":"from typing import List, Dict, Union def find_fraudulent_transactions(transactions: List[Dict[str, Union[str, int]]]) -> List[str]: fraudulent_transactions = [] transactions.sort(key=lambda x: x[\'timestamp\']) # Sort by timestamp account_transactions = {} # Dictionary to store transactions by account_id for txn in transactions: account_id = txn[\'account_id\'] # Check if the amount exceeds 10,000 if txn[\'amount\'] > 10000: fraudulent_transactions.append(txn[\'id\']) continue # Initialize the account in the dictionary if account_id not in account_transactions: account_transactions[account_id] = [] # Check for transactions within 10 minutes window and identical amount for past_txn in account_transactions[account_id]: if txn[\'timestamp\'] - past_txn[\'timestamp\'] <= 600 and txn[\'amount\'] == past_txn[\'amount\']: fraudulent_transactions.append(txn[\'id\']) break # Add the current transaction to the account\'s transaction list account_transactions[account_id].append(txn) return fraudulent_transactions"},{"question":"Scenario A game developer is creating an adventure game where players navigate through a grid filled with obstacles, with an objective of reaching the (\'Treasure Chest\') marked cell. The grid is represented as a 2D list where \'S\' denotes the starting position of the player, \'T\' denotes the treasure chest position, \'.\' represents passable cells, and \'#\' represents obstacles. Problem Given a grid, implement a function `shortest_path_to_treasure` that calculates the shortest path from the starting position \'S\' to the treasure chest \'T\'. You can move up, down, left, or right, but cannot pass through obstacles. # Function Signature ```python def shortest_path_to_treasure(grid: List[List[str]]) -> int: pass ``` # Input Format * `grid` (List[List[str]]): A 2D list representing the grid. # Output Format * **Return** (int): The length of the shortest path from \'S\' to \'T\'. If there is no path, return -1. # Constraints * The grid dimensions will be between 2x2 and 100x100. * Ensure robust handling of grids with no possible path to the treasure. # Example ```python # Example 1 grid = [ [\'S\', \'.\', \'.\'], [\'#\', \'#\', \'.\'], [\'.\', \'.\', \'T\'] ] print(shortest_path_to_treasure(grid)) # Expected output: 4 # Example 2 grid = [ [\'S\', \'#\', \'T\'], [\'#\', \'.\', \'#\'], [\'.\', \'.\', \'.\'] ] print(shortest_path_to_treasure(grid)) # Expected output: -1 ``` # Additional Requirements 1. Use a meaningful approach for solving shortest path problems such as Breadth-First Search (BFS). 2. Handle edge cases, like small grids or grids with no \'S\' or \'T\'. 3. Ensure the algorithm efficiently handles the upper grid size limits within reasonable time complexity. 4. Provide unit tests for the function covering typical cases, edge cases, blocked paths, and minimal paths.","solution":"from collections import deque from typing import List, Tuple def shortest_path_to_treasure(grid: List[List[str]]) -> int: def get_neighbors(x: int, y: int) -> List[Tuple[int, int]]: directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] neighbors = [] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] != \'#\': neighbors.append((nx, ny)) return neighbors # Find the starting point \'S\' start = None for i in range(len(grid)): for j in range(len(grid[i])): if grid[i][j] == \'S\': start = (i, j) break if start: break if not start: return -1 queue = deque([(start[0], start[1], 0)]) visited = set() visited.add(start) while queue: x, y, steps = queue.popleft() if grid[x][y] == \'T\': return steps for neighbor in get_neighbors(x, y): if neighbor not in visited: visited.add(neighbor) queue.append((*neighbor, steps + 1)) return -1"},{"question":"# Question: Optimized Fibonacci Number Calculation You are required to implement a function to compute the Nth Fibonacci number using an optimized approach to ensure efficiency. The Fibonacci sequence is defined as follows: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n > 1 __Requirements:__ * Your function should handle valid integer inputs only. * Ensure the function computes results efficiently for larger values of N. * You should implement the function using the iterative method to achieve linear time complexity. __Function Signature:__ ```python def optimized_fibonacci_number(n: int) -> int: pass ``` __Input:__ * An integer `n` where `0 <= n <= 10^5`. __Output:__ * Return the nth Fibonacci number. __Constraints:__ * The input `n` will be a non-negative integer. * The function should raise a `TypeError` if `n` is not an integer. __Example:__ ```python assert optimized_fibonacci_number(0) == 0 assert optimized_fibonacci_number(1) == 1 assert optimized_fibonacci_number(4) == 3 assert optimized_fibonacci_number(10) == 55 ``` __Explanation:__ * For `n=0`, the Fibonacci number is 0. * For `n=4`, the sequence is 0, 1, 1, 2, 3, hence F(4) = 3. * For `n=10`, the sequence includes ... 21, 34, 55, hence F(10) = 55.","solution":"def optimized_fibonacci_number(n: int) -> int: Returns the nth Fibonacci number using an optimized iterative approach. Raises a TypeError if the input is not an integer. if not isinstance(n, int): raise TypeError(\\"The input must be an integer.\\") if n < 0: raise ValueError(\\"The input must be a non-negative integer.\\") if n == 0: return 0 if n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Introduction You are developing a software system for monitoring rainfall data across various weather stations. The system needs to integrate historical rainfall data and provide statistics such as the average rainfall over a given period, the maximum rainfall recorded, and the total rainfall accumulation. # Problem Description Write two functions `average_rainfall` and `rainfall_statistics` that process the rainfall data and return the desired statistics. The input to each function will range from historical data spanning multiple years to recent records from new weather stations. Function 1: `average_rainfall` Write a function `average_rainfall` that calculates the average rainfall over a given period. **Function Signature**: ```python def average_rainfall(rainfall_records: List[float]) -> float: ``` **Input**: - `rainfall_records` (List[float]): A list of daily rainfall amounts in millimeters. **Output**: - (float): The average daily rainfall in millimeters. **Constraints**: - The list can be empty, which should result in an average rainfall of 0.0. - Rainfall amounts cannot be negative values. Function 2: `rainfall_statistics` Write a function `rainfall_statistics` that computes key statistics from the rainfall data. **Function Signature**: ```python def rainfall_statistics(rainfall_records: List[float]) -> Dict[str, float]: ``` **Input**: - `rainfall_records` (List[float]): A list of daily rainfall amounts in millimeters. **Output**: - (Dict[str, float]): A dictionary containing the total rainfall (`total`), maximum daily rainfall (`max`), and average daily rainfall (`average`). **Constraints**: - The list can be empty, which should be handled appropriately. - Rainfall amounts cannot be negative values. # Example ```python assert average_rainfall([10.5, 20.3, 0.0, 5.2]) == 9.0 assert rainfall_statistics([10.5, 20.3, 0.0, 5.2]) == {\'total\': 36.0, \'max\': 20.3, \'average\': 9.0} assert average_rainfall([]) == 0.0 assert rainfall_statistics([]) == {\'total\': 0.0, \'max\': 0.0, \'average\': 0.0} ``` # Note - Ensure to handle edge cases and invalid inputs as defined in the constraints. - The solution should include necessary imports, follow proper coding standards, and provide accurate results based on the inputs given.","solution":"from typing import List, Dict def average_rainfall(rainfall_records: List[float]) -> float: Calculates the average rainfall over a given period. :param rainfall_records: List of daily rainfall amounts in millimeters. :return: The average daily rainfall in millimeters. if not rainfall_records: return 0.0 return sum(rainfall_records) / len(rainfall_records) def rainfall_statistics(rainfall_records: List[float]) -> Dict[str, float]: Computes key statistics from the rainfall data. :param rainfall_records: List of daily rainfall amounts in millimeters. :return: A dictionary containing the total rainfall, maximum daily rainfall, and average daily rainfall. if not rainfall_records: return {\'total\': 0.0, \'max\': 0.0, \'average\': 0.0} total_rainfall = sum(rainfall_records) max_rainfall = max(rainfall_records) average_rainfall_value = total_rainfall / len(rainfall_records) return { \'total\': total_rainfall, \'max\': max_rainfall, \'average\': average_rainfall_value }"},{"question":"# Context In algorithm design, it\'s important to understand how to manipulate sequences of numbers efficiently. One common operation is reversing a sublist within a list. This problem tests your ability to handle sublist manipulations in an efficient manner. # Problem Statement Write a function `reverse_sublist` which takes a list of integers and two indices and reverses the sublist between (and including) the given indices. The function should modify the list in place and return `None`. # Requirements 1. **reverse_sublist(lst: List[int], start: int, end: int) -> None**: Reverses the part of the list from index `start` to index `end` (inclusive). # Input and Output Formats * **Input**: - `lst` : A list of integers. - `start` : An integer representing the starting index of the sublist. - `end` : An integer representing the ending index of the sublist. * **Output**: The function should not return anything. The list should be modified in place. # Constraints * 0 ≤ start ≤ end < len(lst) * The list can contain any integer values. * Handle lists of varying lengths including edge cases like empty lists or single-element lists. # Performance Considerations * Ensure an in-place operation is performed to reverse the sublist. # Example ```python lst = [1, 2, 3, 4, 5] reverse_sublist(lst, 1, 3) assert lst == [1, 4, 3, 2, 5] lst = [8, 6, 7, 5, 3, 0, 9] reverse_sublist(lst, 2, 5) assert lst == [8, 6, 0, 3, 5, 7, 9] lst = [10, 20, 30, 40] reverse_sublist(lst, 0, 2) assert lst == [30, 20, 10, 40] ``` # Edge Cases to Consider * Sublist range covers the entire list. * Sublist is a single element. * Start and end indices are the same. * Large lists to check performance. Implement the function: ```python from typing import List def reverse_sublist(lst: List[int], start: int, end: int) -> None: while start < end: lst[start], lst[end] = lst[end], lst[start] start += 1 end -= 1 ``` Ensure your implementation covers all the above-mentioned requirements and edge cases.","solution":"from typing import List def reverse_sublist(lst: List[int], start: int, end: int) -> None: Reverses the part of the list from index `start` to index `end` (inclusive) in place. Parameters: lst (List[int]): The list of integers. start (int): The starting index of the sublist. end (int): The ending index of the sublist. Returns: None: The list is modified in place. while start < end: lst[start], lst[end] = lst[end], lst[start] start += 1 end -= 1"},{"question":"# Graph Path Finder Algorithm In this task, you will implement a class to find paths in an undirected graph. The graph is composed of nodes and edges. Part A: Graph Implementation 1. `__init__(self)`: Initializes an empty dictionary to represent the adjacency list of the graph. 2. `add_edge(self, node1: int, node2: int)`: Adds an undirected edge between `node1` and `node2`. If `node1` or `node2` does not exist in the graph, they should be added. 3. `get_neighbors(self, node: int) -> list`: Returns a list of neighbors for a given node. If the node does not exist, return an empty list. Part B: Path Finder Implementation 1. `find_path(self, start: int, end: int) -> list`: Finds any path between the `start` and `end` nodes using Depth-First Search (DFS). If no path exists, return an empty list. If either `start` or `end` does not exist, return an empty list. The function should not use any previously visited nodes to find a path. # Input and Output * `add_edge(node1, node2)` accepts two integer node values. * `get_neighbors(node)` accepts a single integer node value. * `find_path(start, end)` accepts two integer node values and returns a list of nodes representing the path from `start` to `end`. # Performance Requirements Ensure that your implementation meets the specified time complexities: * `add_edge`: O(1) * `get_neighbors`: O(1) * `find_path`: O(V + E) where V is the number of vertices and E is the number of edges in the graph # Example ```python # Part A: Graph Implementation graph = Graph() graph.add_edge(1, 2) graph.add_edge(1, 3) graph.add_edge(2, 4) print(graph.get_neighbors(1)) # [2, 3] print(graph.get_neighbors(2)) # [1, 4] print(graph.get_neighbors(5)) # [] # Part B: Path Finder Implementation print(graph.find_path(1, 4)) # [1, 2, 4] or [1, 3, 4] depending on the graph structure print(graph.find_path(3, 4)) # [3, 1, 2, 4] or an equivalent valid path print(graph.find_path(1, 5)) # [] ``` Implement the class `Graph` with the specified methods and ensure your code passes the above examples.","solution":"class Graph: def __init__(self): Initializes an empty dictionary to represent the adjacency list of the graph. self.adjacency_list = {} def add_edge(self, node1: int, node2: int): Adds an undirected edge between node1 and node2. If node1 or node2 do not exist in the graph, they should be added. if node1 not in self.adjacency_list: self.adjacency_list[node1] = [] if node2 not in self.adjacency_list: self.adjacency_list[node2] = [] # Add the edge in both directions since it\'s an undirected graph self.adjacency_list[node1].append(node2) self.adjacency_list[node2].append(node1) def get_neighbors(self, node: int) -> list: Returns a list of neighbors for a given node. If the node does not exist, return an empty list. return self.adjacency_list.get(node, []) def find_path(self, start: int, end: int) -> list: Finds any path between the start and end nodes using Depth-First Search (DFS). If no path exists, return an empty list. If either start or end does not exist, return an empty list. if start not in self.adjacency_list or end not in self.adjacency_list: return [] def dfs(current, end, visited): if current == end: return [current] visited.add(current) for neighbor in self.adjacency_list[current]: if neighbor not in visited: path = dfs(neighbor, end, visited) if path: return [current] + path return [] return dfs(start, end, set())"},{"question":"# Problem Scenario You are given a list of integers, representing the number of daily calories consumed over a period. You need to find the maximum sum of calories that you can consume in any contiguous subarray of this list. This type of problem is often solved using Kadane\'s Algorithm, which optimizes the process significantly. # Task Write a function `max_contiguous_calories(calories: list) -> int`. Your function should: 1. Take as input a list of integers representing daily calories consumed. 2. Return the maximum sum of any contiguous subarray. # Expected Input and Output Input: * A list of integers, `calories`. - Example: `[1, -2, 3, 4, -1, 2, 1, -5, 4]` Output: * An integer representing the maximum sum of any contiguous subarray. - Example: `9` # Constraints: * The length of the list will be at most 100,000. * Each integer in the list will be in the range [-10,000, 10,000]. # Example ```python def max_contiguous_calories(calories: list) -> int: # Implement Kadane\'s Algorithm to find the maximum sum of a contiguous subarray. pass # Example usage: print(max_contiguous_calories([1, -2, 3, 4, -1, 2, 1, -5, 4])) # Output: 9 ``` Provide your implementation of the `max_contiguous_calories()` function utilizing Kadane\'s Algorithm to find the maximum sum of a contiguous subarray. # Solution To solve this problem, you can use Kadane\'s Algorithm. The algorithm scans through the array and calculates at each step the maximum sum of the subarray ending at the current position, updating the global maximum when a new maximum is found. Here\'s how you might implement it: ```python def max_contiguous_calories(calories: list) -> int: if not calories: return 0 max_ending_here = max_so_far = calories[0] for calorie in calories[1:]: max_ending_here = max(calorie, max_ending_here + calorie) max_so_far = max(max_so_far, max_ending_here) return max_so_far # Example usage: print(max_contiguous_calories([1, -2, 3, 4, -1, 2, 1, -5, 4])) # Output: 9 ```","solution":"def max_contiguous_calories(calories: list) -> int: if not calories: return 0 max_ending_here = max_so_far = calories[0] for calorie in calories[1:]: max_ending_here = max(calorie, max_ending_here + calorie) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"# Question: Designing a Simple Cache with Least Recently Used (LRU) Eviction Policy Context: You are tasked with designing a simple cache that can store a limited number of items and uses the Least Recently Used (LRU) policy for evictions. This cache should support O(1) time for insertion, deletion, and access. # Task: Create a class `LRUCache` that supports the following operations: 1. **Get Value by Key**: Method `get(key) -> value` returns the value associated with `key` if it exists in the cache; otherwise, it returns `-1`. 2. **Set Value by Key**: Method `put(key, value)` adds a new key-value pair to the cache. If the cache is already at capacity, it should evict the least recently used item before adding the new key-value pair. # Requirements: 1. **Input/Output**: - The `LRUCache` class should be initialized with a positive capacity `c`. - The `get` method should return the cached value for the given key or `-1` if the key does not exist. - The `put` method should insert or update the value associated with the given key. - Both methods should maintain the LRU order invariant in the cache. 2. **Constraints**: - Keys are integers, and values are also integers. - Multiple calls to `get` or `put` for the same key should update the usage order appropriately. - The cache cannot exceed the capacity defined during instantiation. 3. **Performance**: - Both `get` and `put` methods should have a time complexity of O(1). # Example: ```python # Creating LRUCache with capacity 2 cache = LRUCache(2) # Inserting key-value pairs cache.put(1, 1) cache.put(2, 2) # Retrieving values print(cache.get(1)) # Expected: 1 # Inserting another key-value pair cache.put(3, 3) # This will evict key 2 # Trying to retrieve evicted key print(cache.get(2)) # Expected: -1 # Adding another key-value pair cache.put(4, 4) # This will evict key 1 # Retrieving values print(cache.get(1)) # Expected: -1 print(cache.get(3)) # Expected: 3 print(cache.get(4)) # Expected: 4 ``` # Implementation Skeleton: ```python class LRUCache: def __init__(self, capacity: int): # Your code to initialize the LRUCache def get(self, key: int) -> int: # Your code to retrieve value by key def put(self, key: int, value: int) -> None: # Your code to insert key-value pair into cache ```","solution":"class LRUCache: class Node: def __init__(self, key, value): self.key = key self.value = value self.prev = None self.next = None def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = self.Node(0, 0) self.tail = self.Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _remove(self, node): prev = node.prev nxt = node.next prev.next = nxt nxt.prev = prev def _insert(self, node): prev = self.tail.prev prev.next = node self.tail.prev = node node.prev = prev node.next = self.tail def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._insert(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = self.Node(key, value) self._insert(node) self.cache[key] = node if len(self.cache) > self.capacity: lru = self.head.next self._remove(lru) del self.cache[lru.key]"},{"question":"# Scenario: You are responsible for processing reports submitted by various departments within your organization. Each report is submitted in a text file, and you need to implement a function that categorizes these reports based on specific keywords that appear in the filenames. The keywords for categorization are related to different departments. # Task: Implement a Python function `categorize_reports(file_names: List[str]) -> Dict[str, List[str]]` that: 1. Accepts a list of report file names. 2. Categorizes each file name based on the presence of specific department keywords. 3. Returns a dictionary where the keys are the department names (`\\"finance\\"`, `\\"hr\\"`, `\\"marketing\\"`, `\\"it\\"`) and the values are lists of file names that correspond to each department. # Input: - `file_names` (List[str]): A list of file name strings. - Department keywords: - `\\"finance\\"`: Keywords are `finance`, `budget`, `account` - `\\"hr\\"`: Keywords are `hr`, `human`, `resource` - `\\"marketing\\"`: Keywords are `marketing`, `promo`, `sales` - `\\"it\\"`: Keywords are `it`, `tech`, `support` # Output: - (Dict[str, List[str]]): A dictionary with lists of file names categorized by department. # Constraints: - File names will consist of alphanumeric characters and may include underscores or hyphens. - Each file name will contain at least one keyword. - File names are case-insensitive (e.g., `Finance_Report.txt` should be categorized under `\\"finance\\"`). # Example: ```python file_names = [ \\"Finance_Report_Jan.txt\\", \\"HR_Policies_December.txt\\", \\"marketing_campaign_june.txt\\", \\"IT_Support_Logs.txt\\", \\"budget_overview_2023.txt\\", \\"human_resources_guide.pdf\\", \\"SALES_ANALYSIS_APRIL.docx\\", \\"tech_upgrades_feb.pdf\\" ] result = categorize_reports(file_names) # Expected result: # { # \\"finance\\": [\\"Finance_Report_Jan.txt\\", \\"budget_overview_2023.txt\\"], # \\"hr\\": [\\"HR_Policies_December.txt\\", \\"human_resources_guide.pdf\\"], # \\"marketing\\": [\\"marketing_campaign_june.txt\\", \\"SALES_ANALYSIS_APRIL.docx\\"], # \\"it\\": [\\"IT_Support_Logs.txt\\", \\"tech_upgrades_feb.pdf\\"] # } ``` # Notes: - Ensure your function handles case insensitivity properly. - Test with different variations of keywords within the file names. - If a file matches multiple department keywords, prioritize the departments in the order given: `\\"finance\\"`, `\\"hr\\"`, `\\"marketing\\"`, `\\"it\\"`.","solution":"from typing import List, Dict def categorize_reports(file_names: List[str]) -> Dict[str, List[str]]: keywords = { \\"finance\\": [\\"finance\\", \\"budget\\", \\"account\\"], \\"hr\\": [\\"hr\\", \\"human\\", \\"resource\\"], \\"marketing\\": [\\"marketing\\", \\"promo\\", \\"sales\\"], \\"it\\": [\\"it\\", \\"tech\\", \\"support\\"] } categories = { \\"finance\\": [], \\"hr\\": [], \\"marketing\\": [], \\"it\\": [] } for file_name in file_names: file_name_lower = file_name.lower() for category, kw_list in keywords.items(): for kw in kw_list: if kw in file_name_lower: categories[category].append(file_name) break else: continue break return categories"},{"question":"# Problem: Efficient Fibonacci Sequence Calculation The Fibonacci sequence is defined as follows: - ( F(0) = 0 ) - ( F(1) = 1 ) - ( F(n) = F(n-1) + F(n-2) ) for ( n geq 2 ) Your task is to write a function `efficient_fibonacci(n: int) -> int` that computes the ( n )-th Fibonacci number efficiently. # Input * `n`: an integer (0 leq n leq 10^9). # Output * Returns an integer representing the ( n )-th Fibonacci number. # Example ```python efficient_fibonacci(10) # returns 55 efficient_fibonacci(50) # returns 12586269025 efficient_fibonacci(100) # returns 354224848179261915075 ``` # Constraints * The solution should be optimized for both time and space complexity. * Use iterative methods or matrix exponentiation rather than simple recursion to ensure that the function handles large values of `n`. Implement the function based on the provided description and ensure to handle edge cases effectively.","solution":"def efficient_fibonacci(n: int) -> int: Computes the n-th Fibonacci number using matrix exponentiation. if n <= 0: return 0 elif n == 1: return 1 def multiply_matrices(a, b): return [ [a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]], [a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]] ] def matrix_power(matrix, power): result = [[1, 0], [0, 1]] base = matrix while power: if power % 2 == 1: result = multiply_matrices(result, base) base = multiply_matrices(base, base) power //= 2 return result fib_matrix = [[1, 1], [1, 0]] result_matrix = matrix_power(fib_matrix, n - 1) return result_matrix[0][0]"},{"question":"# Context In numerical computing, solving systems of linear equations is a fundamental operation. One efficient method is to use Gaussian elimination, which transforms the system into an upper triangular form for easy back-substitution. # Problem Statement Write a function, `solve_linear_system(A, b)`, that takes a coefficient matrix `A` and a right-hand side vector `b`, and returns the solution vector `x` using Gaussian elimination. Do not use any built-in linear algebra functions for solving the system, but you can use NumPy for array manipulations. # Function Signature ```python def solve_linear_system(A: np.ndarray, b: np.ndarray) -> np.ndarray: pass ``` # Input * `A`: A 2D NumPy array of shape (n, n) representing the coefficient matrix. * `b`: A 1D NumPy array of length n representing the right-hand side vector. # Output * A 1D NumPy array of length n representing the solution vector `x` that satisfies the equation `A @ x = b`. # Constraints * The matrix `A` will be non-singular (i.e., it has an inverse). * The inputs will conform to the constraints of linear solvability: the dimensions of `A` and `b` will be compatible and valid for solving `Ax = b`. * The input matrix `A` will contain floating-point numbers and the vector `b` will also consist of floating-point numbers. * The dimensions of `A` and `b` will not exceed 1000. # Example ```python import numpy as np # Sample system of linear equations: # 2x + 3y = 8 # 3x + 4y = 11 A = np.array([ [2, 3], [3, 4] ], dtype=float) b = np.array([8, 11], dtype=float) x = solve_linear_system(A, b) print(x) # Output should be close to [1.0, 2.0] ``` # Explanation In this example, the `solve_linear_system` function should implement the Gaussian elimination process on matrix `A` and vector `b`, resulting in the solution vector `x` that satisfies the system of equations. # Performance Requirements Your solution should be efficient enough to handle matrices of size up to 1000x1000 in a reasonable time frame.","solution":"import numpy as np def solve_linear_system(A: np.ndarray, b: np.ndarray) -> np.ndarray: n = len(b) # Create an augmented matrix Ab = np.hstack((A, b.reshape(-1, 1))) # Perform Gaussian elimination for i in range(n): # Partial pivoting max_row = i + np.argmax(np.abs(Ab[i:, i])) if i != max_row: Ab[[i, max_row], :] = Ab[[max_row, i], :] # Make the diagonal contain all 1\'s Ab[i] = Ab[i] / Ab[i, i] # Make the elements below the pivot positions zero for j in range(i + 1, n): Ab[j] = Ab[j] - Ab[j, i] * Ab[i] # Perform back substitution x = np.zeros(n) for i in range(n - 1, -1, -1): x[i] = Ab[i, -1] - np.sum(Ab[i, i+1:n] * x[i+1:n]) return x"},{"question":"# Problem Statement Implement a function that performs in-place reversal of words in a given string. The words are separated by a single space, and there are no leading or trailing whitespace characters. # Input - A single string consisting of words separated by spaces. # Output - The same string with the words\' order reversed but the original word characters preserved. # Constraints - **Time Complexity**: The solution should operate in (O(n)) time, where (n) is the length of the string. - **Space Complexity**: Aim to achieve (O(1)) additional space complexity by performing the reversal in-place. # Function Signature ```python def reverse_words_in_place(sentence: str) -> str: pass ``` # Examples ```python >>> reverse_words_in_place(\\"hello world\\") \\"world hello\\" >>> reverse_words_in_place(\\"The quick brown fox\\") \\"fox brown quick The\\" ``` Detailed Explanation & Tips 1. **In-place Operation**: Since strings in Python are immutable, consider converting the string to a list of characters to modify it directly. 2. **Reversal Process**: First, reverse the entire string, and then reverse each word in-place to achieve the desired word order reversal. 3. **Helper Functions**: Develop helper functions to reverse individual segments of the list to help keep your code organized. Remember, the goal is to ensure minimal additional space usage while achieving the word order reversal directly on the input data structure.","solution":"def reverse_words_in_place(sentence: str) -> str: if not sentence: return sentence # Helper function to reverse part of the list from start to end def reverse(lst, start, end): while start < end: lst[start], lst[end] = lst[end], lst[start] start += 1 end -= 1 # Convert string to a list of characters (immutable workaround) sentence_lst = list(sentence) n = len(sentence_lst) # Reverse the entire list of characters reverse(sentence_lst, 0, n - 1) # Now, reverse each word in the list start = 0 for end in range(n): if sentence_lst[end] == \' \': reverse(sentence_lst, start, end - 1) start = end + 1 reverse(sentence_lst, start, n - 1) # Reverse the last word return \'\'.join(sentence_lst)"},{"question":"# Coding Assessment Question **Scenario**: You are developing a software module that requires pattern matching capabilities to detect occurrences of a given subsequence within a list of numbers. To accomplish this, you need to implement a function that finds all the starting indices of occurrences of a specified subsequence within a main sequence. # Problem Statement: Implement a function `find_subsequence_indices(main_sequence: List[int], sub_sequence: List[int])` that computes the starting indices where the subsequence `sub_sequence` appears in the sequence `main_sequence`. The function should return a list of indices. # Requirements: 1. **Input**: - A list of integers `main_sequence` with length `m`. - A list of integers `sub_sequence` with length `n`. 2. **Output**: - A list of integers, each representing a starting index where `sub_sequence` appears in `main_sequence`. 3. **Constraints**: - The lengths of `main_sequence` and `sub_sequence` will be between 0 and 10^4. - Elements of both sequences are integers within the range `[-10^9, 10^9]`. # Examples: ```python >>> find_subsequence_indices([1, 2, 3, 1, 2, 3, 4], [1, 2, 3]) [0, 3] >>> find_subsequence_indices([5, 3, 5, 3, 1], [5, 3]) [0, 2] >>> find_subsequence_indices([1, 2, 3, 4, 5], [6]) [] >>> find_subsequence_indices([1, 1, 1, 1], [1, 1]) [0, 1, 2] ``` # Guidelines: * Ensure your function handles edge cases such as empty sequences and scenarios where the subsequence does not appear in the main sequence. * The implementation should strive for efficiency, avoiding unnecessary computations. * Consider using a sliding window approach to identify the starting indices where the subsequence appears in the main sequence.","solution":"from typing import List def find_subsequence_indices(main_sequence: List[int], sub_sequence: List[int]) -> List[int]: Finds the starting indices where sub_sequence appears in main_sequence. if not sub_sequence or not main_sequence or len(sub_sequence) > len(main_sequence): return [] result = [] for i in range(len(main_sequence) - len(sub_sequence) + 1): if main_sequence[i:i+len(sub_sequence)] == sub_sequence: result.append(i) return result"},{"question":"# Question: Detect Cycles in a Directed Graph using DFS Problem Description: You are given a directed graph represented as an adjacency list. Your task is to write a Python function `detect_cycle(graph)` that detects whether the graph contains any cycles. If a cycle is detected, the function should return `True`. If no cycles are found, the function should return `False`. Input: * `graph`: A dictionary where the keys are vertices and the values are lists of adjacent vertices. Example: ```python { \'A\': [\'B\'], \'B\': [\'C\', \'D\'], \'C\': [\'A\'], \'D\': [] } ``` Output: * A boolean value indicating the presence of a cycle in the graph. Constraints: * The number of vertices `V` can be up to 10^5. * The graph is directed, and vertices are represented by strings. Function Signature: ```python def detect_cycle(graph: dict) -> bool: ``` Example: 1. **Input**: ```python graph = { \'A\': [\'B\'], \'B\': [\'C\', \'D\'], \'C\': [\'A\'], \'D\': [] } ``` **Output**: ```python True ``` 2. **Input**: ```python graph = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [] } ``` **Output**: ```python False ``` 3. **Input**: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [], \'C\': [] } ``` **Output**: ```python False ``` Notes: - Utilize Depth First Search (DFS) to explore the graph and detect cycles. - Maintain visited and recursion stack sets to track nodes during the DFS. You are required to implement the function `detect_cycle(graph)` to accurately determine if the given graph has any cycles, adhering to the constraints and handling edge cases effectively.","solution":"def detect_cycle(graph): def dfs(vertex, visited, rec_stack): visited.add(vertex) rec_stack.add(vertex) for neighbour in graph.get(vertex, []): if neighbour not in visited: if dfs(neighbour, visited, rec_stack): return True elif neighbour in rec_stack: return True rec_stack.remove(vertex) return False visited = set() rec_stack = set() for node in graph: if node not in visited: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Question: Frequency Analysis of Strings As a software engineer, you need to write a function that performs a frequency analysis of characters in a given string. Your task is to implement a function: 1. **char_frequency_analysis(input_string)**: - **Input**: A string `input_string`. - **Output**: A dictionary where keys are characters from the `input_string` and values are their frequencies as integers. - **Constraint**: The `input_string` can contain any characters including numbers and special symbols. - **Example**: ```python >>> char_frequency_analysis(\\"hello\\") {\'h\': 1, \'e\': 1, \'l\': 2, \'o\': 1} ``` # Implementation Requirements - **Function should be case-sensitive**: \'A\' and \'a\' are considered different characters. - Ensure to handle empty strings gracefully. - Optimize for O(n) time complexity where n is the length of `input_string`. # Test Cases You should test your function with the following cases: ```python assert char_frequency_analysis(\\"hello\\") == {\'h\': 1, \'e\': 1, \'l\': 2, \'o\': 1} assert char_frequency_analysis(\\"\\") == {} assert char_frequency_analysis(\\"AaaBBc\\") == {\'A\': 1, \'a\': 2, \'B\': 2, \'c\': 1} assert char_frequency_analysis(\\"123@3#\\") == {\'1\': 1, \'2\': 1, \'3\': 2, \'@\': 1, \'#\': 1} # Test with long string assert char_frequency_analysis(\\"a\\" * 1000 + \\"b\\" * 500) == {\'a\': 1000, \'b\': 500} ``` The added question analyzes string data by calculating character frequencies, aligning with the general domain of string manipulation and data analysis seen in the original question. The complexity and scope of the problem ensure sufficient challenge and depth for a coding assessment.","solution":"def char_frequency_analysis(input_string): Analyzes the frequency of each character in the given string. Args: input_string (str): The string to analyze. Returns: dict: A dictionary where keys are characters and values are their frequencies. frequency_dict = {} for char in input_string: if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict"},{"question":"# Question You have been given the task of creating a function that identifies all the unique subsequences of a given string and returns them in lexicographical order. A subsequence is formed by deleting zero or more characters from a string without reordering the remaining characters. Function signature ```python def generate_subsequences(s: str) -> list: ``` Input: - `s` (str): A string of lowercase alphabetical characters. Output: - A list of strings, where each string represents a unique subsequence of the given string, presented in lexicographical order. Constraints and Limitations: - The input string `s` will contain only lowercase alphabetical characters. - The length of string `s` will not exceed 16 characters. Performance Requirements: - Optimize to handle the string length constraint efficiently. Examples: ```python assert generate_subsequences(\\"abc\\") == [\'\', \'a\', \'ab\', \'abc\', \'ac\', \'b\', \'bc\', \'c\'] assert generate_subsequences(\\"aaa\\") == [\'\', \'a\', \'aa\', \'aaa\'] assert generate_subsequences(\\"abcd\\") == [\'\', \'a\', \'ab\', \'abc\', \'abcd\', \'abd\', \'ac\', \'acd\', \'ad\', \'b\', \'bc\', \'bcd\', \'bd\', \'c\', \'cd\', \'d\'] ```","solution":"def generate_subsequences(s: str) -> list: Returns all unique subsequences of the input string in lexicographical order. def subsequences_helper(s): if not s: return {\\"\\"} smaller_subsequences = subsequences_helper(s[1:]) combined_subsequences = {s[0] + sub for sub in smaller_subsequences} return smaller_subsequences | combined_subsequences return sorted(list(subsequences_helper(s)))"},{"question":"# Problem: Implementing the Simpson\'s 1/3 Rule for Numerical Integration You are tasked with implementing a numerical method to approximate definite integrals using Simpson\'s 1/3 Rule. This method is known for its accuracy, as it uses quadratic polynomials to approximate the integral of the function. Your task is to write a function `simpson_one_third` which takes in the following parameters: - `func`: A callable function representing ( f(x) ), the integrand. - `a`: The lower limit of integration. - `b`: The upper limit of integration. - `n`: The number of subintervals. It must be an even number. The function should return the approximate value of the definite integral of ( f(x) ) from ( a ) to ( b ). # Constraints: - ( a < b ) - ( n > 0 ) - ( n ) must be even # Expected Function Signature: ```python def simpson_one_third(func: Callable[[float], float], a: float, b: float, n: int) -> float: pass ``` # Example: ```python # Define the integrand f(x) = x^2 def f(x): return x ** 2 # Approximate the integral of f(x) from x=0 to x=1 with 4 subintervals result = simpson_one_third(f, 0, 1, 4) print(result) # Output: 0.3333333333333333 ``` # Notes: 1. Ensure that you raise a `ValueError` if the constraints `a < b`, `n > 0`, or `n` being even are not met. 2. The provided example should help you understand the expected behavior and implementation. 3. You can use numpy for array manipulations if needed. Your function will be tested with various integrands and limits of integration to ensure correctness and performance.","solution":"from typing import Callable def simpson_one_third(func: Callable[[float], float], a: float, b: float, n: int) -> float: if n <= 0: raise ValueError(\\"Number of subintervals n must be greater than 0.\\") if n % 2 != 0: raise ValueError(\\"Number of subintervals n must be even.\\") if a >= b: raise ValueError(\\"Lower limit a must be less than upper limit b.\\") h = (b - a) / n integral = func(a) + func(b) for i in range(1, n): x = a + i * h if i % 2 == 0: integral += 2 * func(x) else: integral += 4 * func(x) integral *= h / 3 return integral"},{"question":"**Scenario**: You are responsible for managing the backend of a social networking platform. As part of optimizing user interactions and content recommendations, you need to analyze the user engagement with different posts. The core components include user profiles and post interactions (likes, comments). You need to implement the functionality to identify the most popular posts based on user engagement. **Task**: Using the provided data structure implementation for managing users and posts, extend its functionalities by implementing the following additional methods: 1. `most_liked_post(self) -> Optional[int]`: This method should return the identifier of the post with the highest number of likes. If there are multiple posts with the same number of likes, return any one of them. If no posts are available, return `None`. 2. `user_with_most_comments(self) -> Optional[int]`: This method should determine the user who has made the highest number of comments on posts. If there are multiple users with the same number of comments, return any one of them. If no users have commented, return `None`. # Requirements: - **`most_liked_post` Method:** - **Output**: The identifier of the post with the highest number of likes, or `None` if no posts exist. - **`user_with_most_comments` Method:** - **Output**: The identifier of the user who has made the highest number of comments, or `None` if no comments exist. # Constraints: - The platform may handle up to 1,000,000 users and 10,000,000 posts. - Each user ID and post ID is an integer. - Each post can have likes and comments associated with it. - Users can like or comment on multiple posts. Implement these methods efficiently considering the constraints of the platform. **Function Signatures**: ```python def most_liked_post(self) -> Optional[int]: pass def user_with_most_comments(self) -> Optional[int]: pass ``` **Example**: ```python platform = SocialNetworkPlatform() platform.add_post(1) platform.add_post(2) platform.add_post(3) platform.like_post(1, 101) platform.like_post(1, 102) platform.like_post(2, 103) platform.like_post(3, 104) platform.like_post(3, 105) platform.like_post(3, 106) assert platform.most_liked_post() in [3] platform.add_comment(101, 1) platform.add_comment(101, 2) platform.add_comment(102, 3) platform.add_comment(103, 2) assert platform.user_with_most_comments() in [101, 102] ``` # Notes: Ensure to account for edge cases, such as: - No posts exist on the platform. - No likes or comments have been made. - Multiple posts or users having the same number of likes or comments.","solution":"from typing import Optional, Dict, Set class SocialNetworkPlatform: def __init__(self): self.posts = {} self.post_likes = {} self.user_comments = {} def add_post(self, post_id: int): self.posts[post_id] = {\'likes\': set(), \'comments\': []} def like_post(self, post_id: int, user_id: int): if post_id in self.posts: self.posts[post_id][\'likes\'].add(user_id) self.post_likes[user_id] = self.post_likes.get(user_id, 0) + 1 def add_comment(self, user_id: int, post_id: int): if post_id in self.posts: self.posts[post_id][\'comments\'].append(user_id) self.user_comments[user_id] = self.user_comments.get(user_id, 0) + 1 def most_liked_post(self) -> Optional[int]: if not self.posts: return None return max(self.posts.keys(), key=lambda pid: len(self.posts[pid][\'likes\'])) def user_with_most_comments(self) -> Optional[int]: if not self.user_comments: return None return max(self.user_comments.keys(), key=lambda uid: self.user_comments[uid])"},{"question":"# Shortest Path with Constraints You are given a directed graph where each edge has a weight and there is a specific constraint on the maximum number of edges that can be used in the path. Your task is to find the shortest path from the source node to the destination node such that the path does not use more than a given number of edges. **Problem**: Write a function `shortest_path_with_constraints` that computes the shortest path from the source to the destination node with the restriction on the maximum number of edges used. **Function signature**: ```python def shortest_path_with_constraints(graph: List[List[Tuple[int, int]]], source: int, destination: int, max_edges: int) -> int: pass ``` **Input**: - `graph`: A 2D list where every element `graph[u]` is a list of tuples `(v, w)` representing an edge from vertex `u` to vertex `v` with weight `w`. - `source`: An integer representing the source node. - `destination`: An integer representing the destination node. - `max_edges`: An integer representing the maximum number of edges that can be used in the path. **Output**: - Return an integer representing the shortest path from the source to the destination using at most `max_edges` edges. If no such path exists, return `-1`. **Constraints**: - The number of vertices `V` in the graph will be `2 <= V <= 100`. - The number of edges `E` in the graph will be `1 <= E <= 1000`. - Edge weights are positive integers. - Ensure that the graph is not necessarily connected. **Example**: ```python graph = [ [(1, 4), (2, 3)], # connections from node 0 [(2, 1), (3, 2)], # connections from node 1 [(3, 4)], # connections from node 2 [] # node 3 has no outgoing edges ] assert shortest_path_with_constraints(graph, 0, 3, 2) == 6 # 0 -> 2 -> 3 assert shortest_path_with_constraints(graph, 0, 3, 1) == -1 # No valid path within 1 edge ``` **Notes**: - The function should handle cases efficiently even if there are multiple paths with varying lengths and edge counts. - Consider edge cases such as when the source and destination are the same, or when no valid path exists within the given constraints.","solution":"from typing import List, Tuple import heapq def shortest_path_with_constraints(graph: List[List[Tuple[int, int]]], source: int, destination: int, max_edges: int) -> int: Find the shortest path from source to destination using at most max_edges. Returns the length of the shortest path or -1 if no such path exists. n = len(graph) # Priority queue to store (cost, node, edges_used) pq = [(0, source, 0)] # Distance table where dist[u][k] is the minimum cost to reach node u using k edges dist = [[float(\'inf\')] * (max_edges + 1) for _ in range(n)] dist[source][0] = 0 while pq: cost, node, edges_used = heapq.heappop(pq) if node == destination: return cost if edges_used < max_edges: for neighbor, weight in graph[node]: next_cost = cost + weight next_edges_used = edges_used + 1 if next_cost < dist[neighbor][next_edges_used]: dist[neighbor][next_edges_used] = next_cost heapq.heappush(pq, (next_cost, neighbor, next_edges_used)) min_cost = min(dist[destination]) return min_cost if min_cost != float(\'inf\') else -1"},{"question":"You are required to implement a basic heap data structure that supports both Min-Heap and Max-Heap operations. Your heap should allow for insertion of elements, extraction of the root element, and peeking at the root without removing it. # Implementation Details Implement the class `Heap` that supports the following methods: 1. `__init__(self, elements: list[int] = [], min_heap: bool = True) -> None`: - Initializes the heap with an optional list of elements. If `min_heap` is set to `True`, the heap behaves as a Min-Heap; otherwise, it behaves as a Max-Heap. 2. `insert(self, element: int) -> None`: - Inserts a new element into the heap. 3. `extract_root(self) -> int`: - Removes and returns the root element from the heap. Raises `IndexError` if the heap is empty. 4. `peek_root(self) -> int`: - Returns the root element without removing it. Raises `IndexError` if the heap is empty. 5. `clear_heap(self) -> None`: - Clears all elements from the heap. # Constraints - The heap can contain any comparable integers. - The heap should maintain its structure and ordering properties (Min-Heap or Max-Heap) after every operation. - Elements can be both positive and negative integers. # Example ```python heap = Heap(elements=[3, 1, 6, 5, 2, 4], min_heap=True) heap.insert(0) assert heap.peek_root() == 0 assert heap.extract_root() == 0 assert heap.peek_root() == 1 heap.insert(-1) assert heap.peek_root() == -1 heap.clear_heap() assert heap.peek_root() == IndexError(\'Heap is empty\') ``` # Notes - Ensure that the heap properties (Min-Heap or Max-Heap) are maintained after any modifications. - Handle edge cases such as extracting the root from an empty heap by raising appropriate exceptions. - Demonstrate proficiency with heap operations and algorithms ensuring optimal performance with both time and space complexity. - Your implementation should be efficient and properly handle dynamic changes in the heap structure.","solution":"class Heap: def __init__(self, elements: list[int] = [], min_heap: bool = True) -> None: self.min_heap = min_heap self.heap = [] for element in elements: self.insert(element) def insert(self, element: int) -> None: self.heap.append(element) self._heapify_up(len(self.heap) - 1) def extract_root(self) -> int: if not self.heap: raise IndexError(\\"Heap is empty\\") root = self.heap[0] last_element = self.heap.pop() if self.heap: self.heap[0] = last_element self._heapify_down(0) return root def peek_root(self) -> int: if not self.heap: raise IndexError(\\"Heap is empty\\") return self.heap[0] def clear_heap(self) -> None: self.heap = [] def _heapify_up(self, index: int) -> None: parent_index = (index - 1) // 2 if index > 0 and ( (self.min_heap and self.heap[index] < self.heap[parent_index]) or (not self.min_heap and self.heap[index] > self.heap[parent_index]) ): self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index: int) -> None: child_index = 2 * index + 1 if child_index < len(self.heap): if (child_index + 1 < len(self.heap) and ((self.min_heap and self.heap[child_index + 1] < self.heap[child_index]) or (not self.min_heap and self.heap[child_index + 1] > self.heap[child_index]))): child_index += 1 if ((self.min_heap and self.heap[child_index] < self.heap[index]) or (not self.min_heap and self.heap[child_index] > self.heap[index])): self.heap[index], self.heap[child_index] = self.heap[child_index], self.heap[index] self._heapify_down(child_index)"},{"question":"# Directory Structure Validation You are tasked with implementing a function to validate a given directory structure string. The directory structure string represents a hierarchy of directories and files, where `/` is used as a path separator and every directory or file name consists of alphanumeric characters. A valid directory structure string must follow these rules: 1. The directory structure string should start without any preceding slashes. 2. Directory names and file names must be separated by a single `/`. 3. No directory or file name should be empty. Your implementation should include a single method: - **validate_directory_structure()**: Takes a string representing the directory structure and returns `True` if it is valid based on the rules described above, otherwise returns `False`. Function Signature: ```python def validate_directory_structure(directory_structure: str) -> bool ``` Description: - `validate_directory_structure(directory_structure: str)`: This function accepts a string `directory_structure` and returns a boolean value `True` if the directory structure string is valid, otherwise returns `False`. Example: ```python >>> validate_directory_structure(\'home/user/docs/file.txt\') True >>> validate_directory_structure(\'/home/user/docs/file.txt\') False >>> validate_directory_structure(\'home//user/docs/file.txt\') False >>> validate_directory_structure(\'home/user//docs/file.txt\') False >>> validate_directory_structure(\'home/user/docs/\') False >>> validate_directory_structure(\'\') False ```","solution":"def validate_directory_structure(directory_structure: str) -> bool: Validates a given directory structure string. :param directory_structure: A string representing the directory structure. :return: True if the directory structure is valid, False otherwise. if not directory_structure: return False if directory_structure.startswith(\'/\'): return False parts = directory_structure.split(\'/\') if any(part == \'\' for part in parts): return False return True"},{"question":"# Coding Assessment Question **Context**: You are given two strings `str1` and `str2` where `str2` is a subsequence of `str1`. A subsequence of a string is a new string that is generated from the original string by deleting some characters without changing the relative order of the remaining characters. **Problem Statement**: Write a function `min_window_subsequence` that finds the minimum window in `str1` which will contain all the characters of `str2` in the same order. **Function Signature**: ```python def min_window_subsequence(str1: str, str2: str) -> str: pass ``` **Input**: * Two strings: `str1` and `str2`, where `1 <= len(str2) <= len(str1) <= 1000`. **Output**: * A string representing the minimum window in `str1` that contains `str2` in sequence. If no such window exists, return an empty string. **Constraints**: * The elements in the strings are lower case English letters. * If multiple minimum windows of the same length exist, return the one that appears first in `str1`. **Performance Requirements**: * The function should complete within a reasonable time frame for the given input size constraints. **Example**: ```python assert min_window_subsequence(\\"abcdebdde\\", \\"bde\\") == \\"bcde\\" assert min_window_subsequence(\\"jmeqksfrsdcmsiwvaovztaqenprpvnbstl\\", \\"k\\") == \\"k\\" assert min_window_subsequence(\\"abc\\", \\"d\\") == \\"\\" ```","solution":"def min_window_subsequence(str1: str, str2: str) -> str: Returns the minimum window in str1 which contains all characters of str2 in the same order. n, m = len(str1), len(str2) dp = [[-1 for _ in range(m)] for _ in range(n)] # Filling the dp array for i in range(n): if str1[i] == str2[0]: dp[i][0] = i for j in range(1, m): last = -1 for i in range(n): if last != -1 and str1[i] == str2[j]: dp[i][j] = last if dp[i][j-1] != -1: last = dp[i][j-1] start, length = 0, float(\'inf\') for i in range(n): if dp[i][m-1] != -1: if i - dp[i][m-1] + 1 < length: start = dp[i][m-1] length = i - dp[i][m-1] + 1 return \\"\\" if length == float(\'inf\') else str1[start:start+length]"},{"question":"# Question: Generate All Possible Subsets of a Set Context: Your task is to implement a function that generates all possible subsets (the power set) of a given set of unique integers. The power set of a set is the set of all its subsets, including the empty set and the set itself. Function Signature: ```python def generate_power_set(s: set) -> list: ``` Parameters: - `s`: a set of unique integers. Returns: - The function returns a list of lists, where each list represents a subset of the original set `s`. The order of subsets in the output list does not matter. Constraints: - The input set will have at most 10 elements to manage complexity. - Consider edge cases such as an empty set or a set with a single element. Examples: ```python # Example 1 print(generate_power_set({1, 2, 3})) # Output: [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] # Example 2 print(generate_power_set({0})) # Output: [[], [0]] # Example 3 print(generate_power_set(set())) # Output: [[]] # Example 4 print(generate_power_set({1, 2})) # Output: [[], [1], [2], [1, 2]] # Example 5 print(generate_power_set({5, 6, 7, 8})) # Output: [ # [], [5], [6], [7], [8], [5, 6], [5, 7], [5, 8], [6, 7], [6, 8], [7, 8], # [5, 6, 7], [5, 6, 8], [5, 7, 8], [6, 7, 8], [5, 6, 7, 8] # ] ``` Note: You need to implement the function to generate all subsets without using any built-in functions specifically designed for generating combinations or power sets. Focus on recursive algorithms or iterative approaches to solve the problem.","solution":"def generate_power_set(s: set) -> list: Generates all possible subsets (the power set) of a given set of unique integers. Parameters: - s: a set of unique integers. Returns: - A list of lists, where each list represents a subset of the original set `s`. def backtrack(start, current_subset): power_set.append(current_subset.copy()) for i in range(start, len(s_list)): current_subset.append(s_list[i]) backtrack(i + 1, current_subset) current_subset.pop() power_set = [] s_list = list(s) backtrack(0, []) return power_set"},{"question":"# Coding Assessment Question Context You are tasked with building a utility that reads from a structured JSON file and generates a CSV report. Each JSON entry contains details about a user\'s purchases on an online platform. Task Create a function `generate_purchase_report(json_data: str, output_file: str) -> int` which: 1. Parses the JSON string `json_data` to extract user purchase information. 2. Generates a CSV file named `output_file` with the necessary purchase details. 3. The CSV should have columns: `user_id`, `total_purchases`, `total_amount`. Requirements 1. Implement the function `generate_purchase_report(json_data: str, output_file: str) -> int`. 2. The function should return the number of users processed. 3. Calculate `total_purchases` which is the count of each user\'s purchases. 4. Calculate `total_amount` which is the sum of the purchase amounts for each user. 5. Implement error handling for malformed JSON data or I/O issues. Input and Output * **Input**: A string `json_data` representing the JSON-encoded data, and a string `output_file` specifying the name of the output CSV file. * **Output**: An integer count of users processed. Constraints * The JSON input structure is guaranteed to contain a valid list of dictionaries, each representing a purchase. * Assume the environment allows reading from and writing to files without special permissions. * The script must use the `json` library for JSON parsing and `csv` library for writing the CSV file. Example JSON data: ```json [ {\\"user_id\\": \\"user_1\\", \\"purchase_id\\": \\"1\\", \\"amount\\": 19.99}, {\\"user_id\\": \\"user_1\\", \\"purchase_id\\": \\"2\\", \\"amount\\": 5.49}, {\\"user_id\\": \\"user_2\\", \\"purchase_id\\": \\"3\\", \\"amount\\": 7.99} ] ``` Expected CSV output: ``` user_id,total_purchases,total_amount user_1,2,25.48 user_2,1,7.99 ``` Example: ```python >>> json_data = \'\'\' [{\\"user_id\\": \\"user_1\\", \\"purchase_id\\": \\"1\\", \\"amount\\": 19.99}, {\\"user_id\\": \\"user_1\\", \\"purchase_id\\": \\"2\\", \\"amount\\": 5.49}, {\\"user_id\\": \\"user_2\\", \\"purchase_id\\": \\"3\\", \\"amount\\": 7.99}] \'\'\' >>> file_name = \\"purchase_report.csv\\" >>> count = generate_purchase_report(json_data, file_name) >>> print(count) 2 ```","solution":"import json import csv def generate_purchase_report(json_data: str, output_file: str) -> int: try: data = json.loads(json_data) user_purchases = {} for purchase in data: user_id = purchase[\'user_id\'] amount = purchase[\'amount\'] if user_id not in user_purchases: user_purchases[user_id] = {\'total_purchases\': 0, \'total_amount\': 0.0} user_purchases[user_id][\'total_purchases\'] += 1 user_purchases[user_id][\'total_amount\'] += amount with open(output_file, \'w\', newline=\'\') as csvfile: fieldnames = [\'user_id\', \'total_purchases\', \'total_amount\'] writer = csv.DictWriter(csvfile, fieldnames=fieldnames) writer.writeheader() for user_id, details in user_purchases.items(): writer.writerow({ \'user_id\': user_id, \'total_purchases\': details[\'total_purchases\'], \'total_amount\': round(details[\'total_amount\'], 2) }) return len(user_purchases) except (json.JSONDecodeError, IOError) as e: print(f\\"An error occurred: {e}\\") return 0"},{"question":"# Coding Question Unique Pathways on a Grid **Scenario**: You are working on a logistics problem for a warehouse management system. The warehouse is represented as a grid with `m` rows and `n` columns. You need to determine the number of unique pathways from the top-left corner to the bottom-right corner of the grid, where you are only allowed to move either down or right at any point in time. **Task**: Implement a function that calculates the number of unique pathways from the top-left corner to the bottom-right corner of an `m x n` grid. **Function Signature**: ```python def unique_paths(m: int, n: int) -> int: pass ``` **Input Format**: * Two integers, `m` and `n` where ( 1 leq m, n leq 100 ). **Output Format**: * Return a single integer representing the number of unique pathways through the grid. **Constraints**: * The value of `m` and `n` will be within ( 1 leq m, n leq 100 ). **Example**: ```python print(unique_paths(3, 7)) # Output: 28 print(unique_paths(3, 2)) # Output: 3 ``` **Hints**: 1. Consider the use of dynamic programming to efficiently compute the number of unique paths. 2. You may also use combinatorial mathematics to derive the solution. Implement the `unique_paths` function to solve the problem, ensuring optimal performance for the given constraints.","solution":"def unique_paths(m, n): Function to calculate the number of unique pathways from top-left corner to bottom-right corner in an m x n grid, moving only down or right at each step. # Initialize a 2D grid with 1s, as there is only one way to reach any cell in # the first row or first column dp = [[1] * n for _ in range(m)] # Fill the rest of the grid for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Coding Assessment Question Context You are working on a system that processes and monitors server logs. To ensure the reliability and correctness of the `process_log_entry` function that parses and processes log entries, you need to write unit tests that validate its behavior under various conditions. Task Implement a function `test_process_log_entry` that tests the `process_log_entry` function using mock objects and assertions to simulate different log entry formats and scenarios. Function Signature ```python def test_process_log_entry(): pass ``` Description 1. **Setup Mocks**: - Use the `unittest.mock` library to mock any external dependencies that the `process_log_entry` function might rely on. - The `process_log_entry` function is to be tested with log entries of different formats — valid, malformed, and edge cases. - Simulate different scenarios such as missing fields, incorrect data types, and valid log structures. 2. **Interactions**: - Ensure the parsing and processing logic of `process_log_entry` is correctly handling various log formats. - Mock any necessary external service calls or database operations to simulate their behavior without actual execution. 3. **Assertions**: - Validate the correctness of the output generated by `process_log_entry` for valid log entries. - Ensure proper handling and error logging for malformed or invalid log entries. - Assert that the function calls any expected callbacks or event handlers if implemented. Example ```python def test_process_log_entry(): # Mock dependencies and log entries log_entries = [ \\"INFO 2023-10-05 12:00:00 User logged in\\", \\"ERROR 2023-10-05 12:05:00 Invalid password attempt\\", \\"WARN 2023-10-05 User disconnected\\", # Missing time \\"DEBUG Incorrect entry format\\", ] # Your goal is to thoroughly test the process_log_entry function ensuring it properly deals with different log entries. pass # You should verify the function\'s behavior by running it with various log entries. ``` Constraints - Use standard libraries only, such as `unittest` and `unittest.mock`. - Assume `process_log_entry` is a function from the `log_processor` module. - Handle a variety of log formats and ensure robustness against malformed entries. Additional Notes - Pay attention to the parsing logic and ensure that various edge cases are well-handled. - Consider performance implications when dealing with a large number of log entries or high-frequency log generation. - Ensure your tests are isolated and do not interfere with other parts of the system or tests.","solution":"def process_log_entry(log_entry): Processes a single log entry string and returns a dictionary with log details. import re log_pattern = r\'(?P<level>INFO|ERROR|WARN|DEBUG)s(?P<date>d{4}-d{2}-d{2})s(?P<time>d{2}:d{2}:d{2})s(?P<message>.+)\' match = re.match(log_pattern, log_entry) if match: return match.groupdict() else: return None"},{"question":"# Scenario As a software developer, you are working on a project related to data privacy and encryption. One of the tasks involves encoding and decoding messages using a simple substitution cipher where each letter in the alphabet is shifted by a fixed number of positions. The encoding is done by moving each letter forward in the alphabet by the given number of positions, wrapping around to the beginning if necessary (known as Caesar Cipher). Similarly, decoding reverses this process by shifting letters backward. # Task Write two functions, `encode_message` and `decode_message`, which implement the encoding and decoding of messages using the Caesar Cipher technique. Each function should handle both uppercase and lowercase letters, preserve non-alphabetic characters unchanged, and wrap around the alphabet correctly. # Functions - `encode_message(message: str, shift: int) -> str` - `decode_message(encoded_message: str, shift: int) -> str` # Input and Output Formats Input * `message` (str): The message to be encoded or decoded. * `shift` (int): The number of positions each letter is shifted. Can be positive or negative. Output * The encoded or decoded message as a string. # Example ```python # Example 1 # Encoding print(encode_message(message=\\"Hello, World!\\", shift=5)) # Output: \\"Mjqqt, Btwqi!\\" # Example 2 # Decoding print(decode_message(encoded_message=\\"Mjqqt, Btwqi!\\", shift=5)) # Output: \\"Hello, World!\\" # Example 3 # Encoding with negative shift print(encode_message(message=\\"abcXYZ\\", shift=-3)) # Output: \\"xyzUVW\\" # Example 4 # Decoding with negative shift print(decode_message(encoded_message=\\"xyzUVW\\", shift=-3)) # Output: \\"abcXYZ\\" ``` # Constraints - The shift value can be any integer (positive or negative). - The message can contain uppercase and lowercase letters, digits, punctuation, and whitespace. - Non-alphabetic characters must remain unchanged. **Complete the implementation in Python.** ```python def encode_message(message: str, shift: int) -> str: def shift_char(c, shift): if c.isalpha(): base = ord(\'A\') if c.isupper() else ord(\'a\') return chr((ord(c) - base + shift) % 26 + base) return c return \'\'.join(shift_char(c, shift) for c in message) def decode_message(encoded_message: str, shift: int) -> str: return encode_message(encoded_message, -shift) ``` # Notes - Ensure that shifting by more than 26 positions wraps around the alphabet as expected. - Preserve the case of each letter along with non-alphabetic characters as is.","solution":"def encode_message(message: str, shift: int) -> str: def shift_char(c, shift): if c.isalpha(): base = ord(\'A\') if c.isupper() else ord(\'a\') return chr((ord(c) - base + shift) % 26 + base) return c return \'\'.join(shift_char(c, shift) for c in message) def decode_message(encoded_message: str, shift: int) -> str: return encode_message(encoded_message, -shift)"},{"question":"# Minimum Window Substring **Problem Statement:** Given two strings `s` and `t`, write a function `min_window_substring(s: str, t: str) -> str` that finds the smallest window in `s` which will contain all the characters in `t` (including duplicates). If no such window exists, return an empty string. **Function Signature:** ```python def min_window_substring(s: str, t: str) -> str: pass ``` **Input:** - `s`: A string in which the window is searched. - `t`: A string containing the characters to be included in the window. **Output:** - Returns a string representing the smallest window in `s` which contains all characters of `t`. **Example:** ```python >>> min_window_substring(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" ``` **Constraints:** 1. `0 <= len(s) <= 10^5` 2. `0 <= len(t) <= 10^4` 3. Strings `s` and `t` consist of uppercase and lowercase English letters. **Hints:** 1. Use two pointers to create a sliding window. 2. Use a hashmap to count the frequency of characters in `t` and another to count characters in the current window. 3. Slide the window while maintaining a count of how many characters of `t` are inside the current window and check if they meet the requirements of `t`. **Additional Notes:** - Consider edge cases where `s` or `t` are empty. - Optimize time complexity to handle large input sizes efficiently by using the sliding window technique.","solution":"def min_window_substring(s: str, t: str) -> str: from collections import Counter if not t or not s: return \\"\\" dict_t = Counter(t) required = len(dict_t) l, r = 0, 0 formed = 0 window_counts = {} # (window length, left, right) ans = float(\\"inf\\"), None, None while r < len(s): character = s[r] window_counts[character] = window_counts.get(character, 0) + 1 if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 while l <= r and formed == required: character = s[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[1] is None else s[ans[1]: ans[2] + 1]"},{"question":"# Problem Statement You are given an array of integers representing temperatures in Fahrenheit over a week. Write a function that converts each temperature in the array to Celsius and returns a new array with the converted values. The conversion formula from Fahrenheit to Celsius is: [C = frac{5}{9} times (F - 32)] # Function Signature ```python def convert_temperatures(temps: list) -> list: Converts an array of temperatures from Fahrenheit to Celsius. :param temps: A list of integers representing temperatures in Fahrenheit. :return: A list of floats representing the converted temperatures in Celsius. Example: >>> convert_temperatures([32, 212, 0, 100, -40]) [0.0, 100.0, -17.7778, 37.7778, -40.0] >>> convert_temperatures([50, -4, 104, 86]) [10.0, -20.0, 40.0, 30.0] >>> convert_temperatures([73, 59, 115]) [22.7778, 15.0, 46.1111] >>> convert_temperatures([]) [] ``` # Input - `temps` (list of integers): The list of temperatures in Fahrenheit. The list can contain between 0 and 10,000 elements. # Output - Returns a new list of floats with each temperature converted to Celsius. # Constraints - The input list may include temperatures ranging from -1,000,000 to 1,000,000 degrees Fahrenheit. - The output should round the converted temperature to four decimal places. # Performance Requirements - The solution should handle the input constraints efficiently, with linear complexity in respect to the number of elements in the list, i.e., O(N) time complexity. # Examples 1. `convert_temperatures([32, 212, 0, 100, -40])` should return `[0.0, 100.0, -17.7778, 37.7778, -40.0]`. 2. `convert_temperatures([50, -4, 104, 86])` should return `[10.0, -20.0, 40.0, 30.0]`. 3. `convert_temperatures([73, 59, 115])` should return `[22.7778, 15.0, 46.1111]`. 4. `convert_temperatures([])` should return `[]`. # Additional Notes - Ensure to handle precision correctly by rounding the results to four decimal places. - Consider edge cases such as an empty list and extreme temperatures.","solution":"def convert_temperatures(temps): Converts an array of temperatures from Fahrenheit to Celsius. :param temps: A list of integers representing temperatures in Fahrenheit. :return: A list of floats representing the converted temperatures in Celsius. return [round((5 / 9) * (temp - 32), 4) for temp in temps]"},{"question":"# Question: Optimized Triangular Number Calculation You are required to implement a function to compute the Nth triangular number using an optimized approach to ensure efficiency. A triangular number is the sum of the natural numbers up to N and is defined as follows: - T(0) = 0 - T(n) = n + T(n-1) for n > 0 However, for this problem, you need to use the direct mathematical formula to compute it: - T(n) = n * (n + 1) / 2 __Requirements:__ * Your function should handle valid integer inputs only. * Ensure the function computes results efficiently for larger values of N. * You should implement the function using the direct formula to achieve constant time complexity. __Function Signature:__ ```python def optimized_triangular_number(n: int) -> int: pass ``` __Input:__ * An integer `n` where `0 <= n <= 10^5`. __Output:__ * Return the nth triangular number. __Constraints:__ * The input `n` will be a non-negative integer. * The function should raise a `TypeError` if `n` is not an integer. __Example:__ ```python assert optimized_triangular_number(0) == 0 assert optimized_triangular_number(1) == 1 assert optimized_triangular_number(3) == 6 assert optimized_triangular_number(10) == 55 ``` __Explanation:__ For `n=0`, the triangular number is 0. For `n=3`, the calculation is 3 * (3 + 1) / 2 = 6. For `n=10`, the calculation is 10 * (10 + 1) / 2 = 55.","solution":"def optimized_triangular_number(n: int) -> int: Returns the nth triangular number using the formula T(n) = n * (n + 1) / 2. Parameters: n (int): A non-negative integer. Returns: int: The nth triangular number. Raises: TypeError: If the input is not an integer. if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") return n * (n + 1) // 2"},{"question":"# Query Builder System **Scenario**: You are tasked with building a system that constructs SQL-like query strings for a simple database. The database only supports selecting records with specified field-value pairs and basic logical operators (`AND`, `OR`). **Task**: Develop the following methods for a custom `QueryBuilder` class: 1. `select_field`: Specifies fields to include in the query. 2. `where_clause`: Adds a WHERE clause with conditions combined using logical operators. 3. `and_condition`: Adds an additional condition to the WHERE clause using `AND`. 4. `or_condition`: Adds an additional condition to the WHERE clause using `OR`. 5. `build_query`: Constructs and returns the final query string. **Requirements**: - Initialize the `QueryBuilder` with optional table name. - Allow method chaining to build complex queries. - Ensure the query handles proper syntax for combining multiple conditions. **Function Signatures**: ```python class QueryBuilder: def __init__(self, table_name: str = \'\') -> None: pass def select_field(self, *fields: str) -> \'QueryBuilder\': pass def where_clause(self, field: str, value: str) -> \'QueryBuilder\': pass def and_condition(self, field: str, value: str) -> \'QueryBuilder\': pass def or_condition(self, field: str, value: str) -> \'QueryBuilder\': pass def build_query(self) -> str: pass ``` **Constraints**: - The `fields` are non-empty strings. - Conditions use format `field = value` in the WHERE clause. - All conditions and fields must be properly quoted in the final query string. **Example**: ```python query_builder = QueryBuilder(\\"users\\") query = ( query_builder .select_field(\\"name\\", \\"age\\", \\"email\\") .where_clause(\\"age\\", \\"30\\") .and_condition(\\"city\\", \\"New York\\") .or_condition(\\"occupation\\", \\"Engineer\\") .build_query() ) print(query) # Output: SELECT name, age, email FROM users WHERE age = \'30\' AND city = \'New York\' OR occupation = \'Engineer\' ``` Implement `QueryBuilder` considering the described behavior and constraints.","solution":"class QueryBuilder: def __init__(self, table_name: str = \'\') -> None: self.table_name = table_name self.fields = [] self.conditions = [] def select_field(self, *fields: str) -> \'QueryBuilder\': self.fields.extend(fields) return self def where_clause(self, field: str, value: str) -> \'QueryBuilder\': self.conditions.append(f\\"{field} = \'{value}\'\\") return self def and_condition(self, field: str, value: str) -> \'QueryBuilder\': if self.conditions: self.conditions.append(f\\"AND {field} = \'{value}\'\\") return self def or_condition(self, field: str, value: str) -> \'QueryBuilder\': if self.conditions: self.conditions.append(f\\"OR {field} = \'{value}\'\\") return self def build_query(self) -> str: fields_str = \', \'.join(self.fields) conditions_str = \' \'.join(self.conditions) query = f\\"SELECT {fields_str} FROM {self.table_name}\\" if self.conditions: query += f\\" WHERE {conditions_str}\\" return query"},{"question":"Write a function that calculates the number of ways to traverse a `m x n` grid when starting from the top-left corner and only being able to move either down or right until reaching the bottom-right corner. # Requirements: Implement a function `number_of_paths(m: int, n: int) -> int` with the following parameters: - `m` (int): The number of rows in the grid. (1 ≤ m ≤ 100) - `n` (int): The number of columns in the grid. (1 ≤ n ≤ 100) # Expected Output: The function should return an integer representing the number of ways to traverse the grid from the top-left corner to the bottom-right corner. # Constraints: * If either `m` or `n` is 0 or negative, return 0 as it is not a valid grid. * The function must handle large values of `m` and `n` efficiently. # Examples: ```python >>> number_of_paths(3, 3) 6 >>> number_of_paths(1, 5) 1 >>> number_of_paths(0, 4) 0 >>> number_of_paths(4, 0) 0 >>> number_of_paths(4, 4) 20 ``` # Hints: * Use dynamic programming to store and compute the number of ways to reach each cell in the grid. * The value at each cell is the sum of the values from the cell above it and the cell to the left of it, starting from the top-left corner. # Performance Considerations: Ensure the implementation can handle the potential upper limits of the grid size efficiently, particularly with respect to time complexity and memory usage.","solution":"def number_of_paths(m: int, n: int) -> int: # If either m or n is less than or equal to 0, the grid is not valid. if m <= 0 or n <= 0: return 0 # Initialize a 2D array with all elements set to 1. dp = [[1] * n for _ in range(m)] # Fill the 2D array with the number of ways to reach each cell. for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will contain the number of ways to reach it. return dp[m-1][n-1]"},{"question":"# Question: Optimized Palindrome Check Context Palindrome checking is a common task in string manipulation where we verify if a given string reads the same backward as forward. Instead of using costly string reversal or iteration methods, you\'ll leverage a more efficient approach to solve the problem. Problem Given a non-empty string `s`, determine if it is a palindrome. Your task is to write a function that checks whether the input string `s` is a palindrome using a two-pointer technique for optimal performance. Tasks Write a Python function `is_palindrome(s: str) -> bool` that returns `True` if the string `s` is a palindrome, and `False` otherwise. Input Format A string `s` containing only alphanumeric characters. Output Format Return a boolean value `True` if the string is a palindrome, otherwise `False`. Constraints * The length of `s` is between ( 1 ) and ( 10^5 ) Examples ```python >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"No lemon, no melon\\") True ``` Explanation For `s = \\"A man, a plan, a canal, Panama\\"`: 1. After removing non-alphanumeric characters and converting to lowercase, the string becomes \\"amanaplanacanalpanama\\". 2. Reading the string forward and backward results in the same sequence. 3. Thus, `is_palindrome` returns `True`. Note To achieve optimal performance: - Ignore any non-alphanumeric characters and consider only alphanumeric characters. - Consider case insensitivity by converting the entire string to lowercase before checking. Good luck!","solution":"def is_palindrome(s: str) -> bool: Checks if the input string s is a palindrome, considering only alphanumeric characters and ignoring case. s = \'\'.join(c.lower() for c in s if c.isalnum()) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return False left += 1 right -= 1 return True"},{"question":"# Scenario: You are developing a tool to assist in network security analysis and need to implement a function that analyzes network traffic logs. Given a log of IP addresses and the number of times each IP address has accessed the network, your task is to identify the top N IP addresses with the highest access frequency. # Function Requirements: * Implement the function `top_n_ip_addresses` to find the top N IP addresses based on their access frequency from the given log. * The log will be a list of tuples, where each tuple contains an IP address (string) and an integer representing the access count. * The returned result should be a list of the top N IP addresses sorted by access count in descending order. * If two IP addresses have the same access count, the result should present them in the order they appear in the input list. # Constraints: * The input list will have at least one tuple and will not exceed 100,000 tuples. * Each IP address will be a valid IPv4 address. * The value of N will always be a positive integer not greater than the length of the input list. # Function Signature: ```python def top_n_ip_addresses(log: list[tuple[str, int]], n: int) -> list[str]: pass ``` # Example: ```python log = [ (\\"192.168.0.1\\", 50), (\\"10.0.0.1\\", 60), (\\"172.16.0.1\\", 50), (\\"192.168.1.1\\", 70) ] assert top_n_ip_addresses(log, 2) == [\\"192.168.1.1\\", \\"10.0.0.1\\"] log = [ (\\"192.168.0.1\\", 100), (\\"10.0.0.1\\", 50), (\\"172.16.0.1\\", 100), (\\"192.168.1.1\\", 25) ] assert top_n_ip_addresses(log, 3) == [\\"192.168.0.1\\", \\"172.16.0.1\\", \\"10.0.0.1\\"] ``` # Input: - `log` (list): A list of tuples, where each tuple contains an IP address in string format and an integer representing access count. - `n` (int): The number of top IP addresses to return. # Output: - (list): A list of the top N IP addresses based on their access frequency.","solution":"def top_n_ip_addresses(log, n): Returns the top N IP addresses based on access frequency from the given log. Parameters: log (list of tuples): A log of IP addresses and their respective access counts. n (int): The number of top IP addresses to return. Returns: list: A list of the top N IP addresses sorted by access count in descending order. # Sort the log first by access count in descending order, and by order of appearance for ties log.sort(key=lambda x: x[1], reverse=True) # Extract the top N IP addresses top_n = [ip for ip, count in log[:n]] return top_n"},{"question":"# Question Addition for Coding Assessment You are given a `Warehouse` class that manages the storage and retrieval of items using a stack-based system (LIFO - Last In, First Out). Your task is to enhance this class to optimize the retrieval process such that you can retrieve an item with the specific `item_id` without disrupting the stack arrangement more than necessary. Requirements: 1. Implement a `retrieve_item` method in the `Warehouse` class that accepts `item_id` as an input parameter. 2. The method should return the `item_id` if it exists in the stack, otherwise return `None`. 3. After retrieving the specified item, the remaining items should be in the same order as they were before retrieval, except for the removed item. Expected Input and Output: - Input: An integer value representing `item_id`. - Output: The integer `item_id` if found, otherwise `None`. Constraints: - Item ids are unique non-negative integers. - The stack may contain up to (10^4) items. - Handle the retrieval efficiently to minimize stack operations. Performance Requirements: - Time Complexity: (O(n)), where (n) is the number of items in the stack. - Space Complexity: (O(n)), considering the auxiliary space used during retrieval. # Example: ```python warehouse = Warehouse() warehouse.add_item(200) warehouse.add_item(401) warehouse.add_item(502) warehouse.add_item(103) print(warehouse.retrieve_item(401)) # Output: 401 print(warehouse.retrieve_item(999)) # Output: None # After retrieval of 401, remaining items are in their initial order except 401 # Hence the current stack content from top to bottom will be: [103, 502, 200] ``` Implement the `retrieve_item` method in the `Warehouse` class to meet the above requirements.","solution":"class Warehouse: def __init__(self): self.stack = [] def add_item(self, item_id): Adds an item with the given item_id to the stack. self.stack.append(item_id) def retrieve_item(self, item_id): Retrieves and returns the item with the given item_id from the stack without disrupting the order more than necessary. If the item_id is not found, returns None. temp_stack = [] found_item = None # Pop items from the stack until we find the item_id or the stack is empty while self.stack: current_item = self.stack.pop() if current_item == item_id: found_item = item_id break else: temp_stack.append(current_item) # Push the items from temp_stack back to self.stack to maintain stack order while temp_stack: self.stack.append(temp_stack.pop()) return found_item"},{"question":"# Problem Scenario You are tasked with developing a system to manage event scheduling for a conference. The system should be able to add events, detect overlapping events, and retrieve a list of non-overlapping events given a specific time window. # Task Implement a class `EventScheduler` that supports adding events with start and end times, checking for overlapping events, and retrieving non-overlapping events within a specified time window. # Key Requirements: 1. Add events with a specified start and end time. 2. Check if an event can be added without overlapping existing events. 3. Retrieve a list of events within a specified time window that do not overlap with any other events in the system. # Specifications: 1. **Class**: `EventScheduler` 2. **Methods**: * `__init__(self)`: Initializes the event scheduler. * `add_event(self, event_id: int, start_time: int, end_time: int) -> bool`: Attempts to add an event to the scheduler. Returns `True` if successful, and `False` if the event overlaps with existing events. * `get_non_overlapping_events(self, start_time: int, end_time: int) -> list[int]`: Returns a list of event IDs that fall within the specified time window and do not overlap with any other events. 3. **Input/Output**: * The `add_event` method takes an `event_id` (integer), `start_time` (integer, time in minutes from the start of the day), and `end_time` (integer, time in minutes from the start of the day). Returns `True` if the event is added successfully, otherwise `False`. * The `get_non_overlapping_events` method takes `start_time` and `end_time` (both integers, time in minutes from the start of the day) and returns a list of event IDs that fit within the specified window without overlapping. * Assume all input times are valid (i.e., `0 <= start_time < end_time <= 1440`). # Constraints: * Assume event times do not extend beyond a single day (1440 minutes). * Start and end times are integers representing minutes since the start of the day. * Event IDs are unique integers. * The number of events is at most `10^4`. # Example: ```python # Example Usage scheduler = EventScheduler() scheduler.add_event(1, 60, 120) # Event 1 from 01:00 to 02:00, returns True scheduler.add_event(2, 120, 180) # Event 2 from 02:00 to 03:00, returns True scheduler.add_event(3, 90, 150) # Event 3 from 01:30 to 02:30, returns False scheduler.add_event(4, 500, 600) # Event 4 from 08:20 to 10:00, returns True events = scheduler.get_non_overlapping_events(50, 200) # Returns [1, 2], since events 1 and 2 do not overlap and fall within the specified window events = scheduler.get_non_overlapping_events(480, 700) # Returns [4], since only event 4 falls within the specified window without overlapping ``` # Notes: * Consider optimizing the scheduling to handle the constraints efficiently. * Ensure to handle edge cases, such as events touching at start or end.","solution":"class EventScheduler: def __init__(self): self.events = [] def add_event(self, event_id, start_time, end_time): for _, s, e in self.events: if not (end_time <= s or start_time >= e): return False self.events.append((event_id, start_time, end_time)) self.events.sort(key=lambda x: x[1]) return True def get_non_overlapping_events(self, start_time, end_time): non_overlapping_events = [] for event_id, s, e in self.events: if s >= start_time and e <= end_time: # Check if event overlaps with any non-overlapping events if all(not (s < ne[2] and e > ne[1]) for ne in non_overlapping_events): non_overlapping_events.append((event_id, s, e)) return [event[0] for event in non_overlapping_events]"},{"question":"# Prime Number Checker Objective You are required to write a Python function that determines whether a given positive integer is a prime number. The implementation should be efficient and adhere to standard prime-checking algorithms. Problem Statement Given a positive integer `n`, implement a function `is_prime(n: int) -> bool` that returns `True` if `n` is a prime number and `False` otherwise. Additionally, create a test suite to verify your implementation handles various input cases correctly. Input and Output Format * **Input**: A single positive integer `n` where (1 <= n <= 10^9). * **Output**: A boolean value `True` if `n` is a prime number, otherwise `False`. Constraints * The input value will be a positive integer within the specified range. * The solution should efficiently handle large integer values up to the limit. Performance Requirements * Time Complexity: O(√n) * Space Complexity: O(1) Example 1 * **Input**: `n = 29` * **Output**: `True` Example 2 * **Input**: `n = 15` * **Output**: `False` Example 3 * **Input**: `n = 2` * **Output**: `True` Tasks 1. Implement the function `is_prime(n: int) -> bool`. 2. Write a suite of test cases to ensure your implementation is correct, considering edge cases such as the smallest prime (2), very large prime numbers, and non-prime numbers within the limit. Notes * Prime numbers are greater than 1 and have no divisors other than 1 and themselves. * Pay attention to efficiently handle very large integers. * Ensure your function is well-tested for edge cases and performance limits.","solution":"def is_prime(n: int) -> bool: Returns True if n is a prime number, False otherwise. Prime numbers are greater than 1 and have no divisors other than 1 and themselves. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Task: Implement a Custom Integer Division Function Your task is to create a custom integer division function that extends the standard integer division operation with additional features and error handling. Specifically: 1. **Input Validation**: Ensure that the divisor is not zero. Raise a `ZeroDivisionError` with the message \\"Cannot divide by zero\\" if it is. 2. **List Support**: Extend the function to support lists of integers. When the inputs are lists of the same length, the function should return a new list where each element is the result of dividing the corresponding elements from the input lists. If the input lists are of different lengths, raise a `ValueError` with the message \\"List inputs must have the same length\\". # Function Signature ```python def custom_divide(dividend, divisor): Perform custom integer division with enhanced features and error handling. :param dividend: int or list of int :param divisor: int or list of int :return: int or list of int: Division result of input values >>> custom_divide(6, 2) 3 >>> custom_divide(5, 3) 1 >>> custom_divide([10, 20, 30], [2, 4, 6]) [5, 5, 5] >>> custom_divide([10, 5], [2, 5, 3]) Traceback (most recent call last): ... ValueError: List inputs must have the same length >>> custom_divide(10, 0) Traceback (most recent call last): ... ZeroDivisionError: Cannot divide by zero # Your implementation here ``` # Constraints 1. The divisor must not be zero. 2. The inputs can either be integers or lists of integers. 3. For list inputs, both lists must have the same length. # Example Usages - `custom_divide(6, 2)` should return `3`. - `custom_divide([10, 20, 30], [2, 4, 6])` should return `[5, 5, 5]`. - `custom_divide([8], [2])` should return `[4]`. - `custom_divide(5, 0)` should raise `ZeroDivisionError: Cannot divide by zero`. - `custom_divide([5, 10], [2, 0])` should raise `ZeroDivisionError: Cannot divide by zero`. - `custom_divide([10, 5], [2])` should raise `ValueError: List inputs must have the same length`.","solution":"def custom_divide(dividend, divisor): Perform custom integer division with enhanced features and error handling. :param dividend: int or list of int :param divisor: int or list of int :return: int or list of int: Division result of input values >>> custom_divide(6, 2) 3 >>> custom_divide(5, 3) 1 >>> custom_divide([10, 20, 30], [2, 4, 6]) [5, 5, 5] >>> custom_divide([10, 5], [2, 5, 3]) Traceback (most recent call last): ... ValueError: List inputs must have the same length >>> custom_divide(10, 0) Traceback (most recent call last): ... ZeroDivisionError: Cannot divide by zero # Check if inputs are lists if isinstance(dividend, list) and isinstance(divisor, list): if len(divisor) == 0 or any(d == 0 for d in divisor): raise ZeroDivisionError(\\"Cannot divide by zero\\") if len(dividend) != len(divisor): raise ValueError(\\"List inputs must have the same length\\") return [d // v for d, v in zip(dividend, divisor)] # Single integer division elif isinstance(dividend, int) and isinstance(divisor, int): if divisor == 0: raise ZeroDivisionError(\\"Cannot divide by zero\\") return dividend // divisor else: raise TypeError(\\"Both dividend and divisor should be of the same type (both int or both lists of int)\\")"},{"question":"Unique Character String Checker You are required to write a function that determines whether a string has all unique characters. This check should be case-sensitive (i.e., \'a\' and \'A\' are considered different characters). Use only additional data structures that optimize the performance. Function Signature: ```python def is_unique_string(s: str) -> bool: ``` # Input: * A string `s`. # Output: * A boolean value indicating whether all characters in `s` are unique (`True`) or not (`False`). # Examples: ```python >>> is_unique_string(\\"abcdef\\") True >>> is_unique_string(\\"aA\\") True >>> is_unique_string(\\"hello\\") False >>> is_unique_string(\\"1234567890\\") True >>> is_unique_string(\\"112233\\") False ``` # Constraints: * The function must raise a `TypeError` if the input is not a string. * The function should be optimized for both time and space complexity. * You cannot use built-in functions that perform the uniqueness check directly. # Additional Requirements: * Your solution must handle edge cases such as an empty string (`s=\\"\\"` which should return `True`). * Aim for a time complexity of O(n) and space complexity of O(1) assuming the character set is fixed (e.g., ASCII). # Hints: * Utilize a set or a boolean array to track seen characters efficiently. * Consider edge cases like strings with special characters, numbers, and varying cases. By following a similar structure, style, and complexity to the provided sample question, this newly created question integrates seamlessly as part of the original examination.","solution":"def is_unique_string(s: str) -> bool: if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") if len(s) > 128: # Assuming ASCII character set, if length > 128 then there must be a repeated character return False char_set = [False] * 128 # Boolean array to keep track of characters for char in s: val = ord(char) if char_set[val]: return False char_set[val] = True return True"},{"question":"# Quick Sort Implementation Challenge Context You are tasked with sorting a list of integers using the Quick Sort algorithm. Quick Sort is a divide-and-conquer algorithm that works by selecting a \'pivot\' element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. Task Write a function `quick_sort(arr: List[int]) -> List[int]` that sorts a given list of integers using the Quick Sort algorithm. The function should: 1. Select a pivot element from the array. 2. Partition the array into two sub-arrays based on the pivot. 3. Recursively apply the quick sort on the sub-arrays. 4. Combine the sorted sub-arrays with the pivot to produce a sorted array. Inputs and Outputs * **Input**: * `arr` - A list of integers. * **Output**: * A list of integers sorted in non-decreasing order. Constraints * The array can contain up to 10000 integers. * Integer values in the array will be between -100000 and 100000. Example ```python # Sample array arr = [34, 7, 23, 32, 5, 62] sorted_array = quick_sort(arr) print(\\"Sorted array:\\", sorted_array) ``` Expected output: ``` Sorted array: [5, 7, 23, 32, 34, 62] ``` In the given example, the function will sort the input list `[34, 7, 23, 32, 5, 62]` to `[5, 7, 23, 32, 34, 62]` using the Quick Sort algorithm.","solution":"from typing import List def quick_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"# Deduplicate Linked List Problem Statement You are required to implement a function that removes duplicate values from a singly linked list while retaining only the first occurrence of each value. The function should have O(n) time complexity. Task Write a function `deduplicate_linked_list(head: Optional[Node]) -> Node` that deduplicates a given singly linked list: # Input ```plaintext The function takes the head node of a singly linked list: - Node: where the linked list nodes have a `data` attribute storing the node\'s value, and a `next_node` attribute pointing to the next node in the list. ``` # Output ```plaintext The function returns the head node of the deduplicated singly linked list. ``` # Constraints * n: The total number of nodes in the linked list. (1 ≤ n ≤ 10<sup>6</sup>) # Example ```python class Node: def __init__(self, data: Any) -> None: self.data: Any = data self.next_node: \'Node\' = None # Example 1 root_node = Node(1) root_node.next_node = Node(2) root_node.next_node.next_node = Node(2) root_node.next_node.next_node.next_node = Node(3) deduplicated_list = deduplicate_linked_list(root_node) # Output: 1 -> 2 -> 3 # Example 2 root_node = Node(1) root_node.next_node = Node(1) root_node.next_node.next_node = Node(1) deduplicated_list = deduplicate_linked_list(root_node) # Output: 1 # Example 3 root_node = Node(1) root_node.next_node = Node(2) root_node.next_node.next_node = Node(3) root_node.next_node.next_node.next_node = Node(4) deduplicated_list = deduplicate_linked_list(root_node) # Output: 1 -> 2 -> 3 -> 4 ``` # Function Signature ```python from typing import Optional class Node: def __init__(self, data) -> None: self.data = data self.next_node = None def deduplicate_linked_list(head: Optional[Node]) -> Node: # Implement your solution here pass ``` # Notes: 1. Optimize the solution to handle the linked list efficiently. 2. Handle edge cases appropriately. 3. Use a set to track seen values and remove duplicates in a single pass of the linked list.","solution":"from typing import Optional class Node: def __init__(self, data) -> None: self.data = data self.next_node = None def deduplicate_linked_list(head: Optional[Node]) -> Optional[Node]: Removes duplicates from the linked list. Args: head (Optional[Node]): The head node of the linked list. Returns: Optional[Node]: The head node of the deduplicated linked list. if head is None: return head current_node = head seen = set([current_node.data]) while current_node.next_node: if current_node.next_node.data in seen: current_node.next_node = current_node.next_node.next_node else: seen.add(current_node.next_node.data) current_node = current_node.next_node return head"},{"question":"# Question: Implement a Function to Compute the Euclidean Distance Matrix You are asked to implement a function that computes the Euclidean distance matrix for a given set of points. The Euclidean distance matrix is a square matrix where the element at position `(i, j)` represents the Euclidean distance between the `i-th` and `j-th` points. # Function Signature ```python def euclidean_distance_matrix(points: np.ndarray) -> np.ndarray: pass ``` # Input - A NumPy array `points` of shape `(m, d)` where `m` is the number of points and `d` is the dimension of each point. # Output - A NumPy array of shape `(m, m)` containing the Euclidean distances between each pair of points. # Constraints - The function should handle a large number of points efficiently. # Examples 1. **Input**: `np.array([[0, 0], [3, 4]])` - **Output**: `array([[0., 5.], [5., 0.]])` 2. **Input**: `np.array([[1, 2], [3, 4], [5, 6]])` - **Output**: `array([[0., 2.82842712, 5.65685425], [2.82842712, 0., 2.82842712], [5.65685425, 2.82842712, 0.]])` 3. **Input**: `np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])` - **Output**: `array([[0., 1.73205081, 3.46410162], [1.73205081, 0., 1.73205081], [3.46410162, 1.73205081, 0.]])` # Sample Test ```python import numpy as np assert np.allclose(euclidean_distance_matrix(np.array([[0, 0], [3, 4]])), np.array([[0., 5.], [5., 0.]])) assert np.allclose(euclidean_distance_matrix(np.array([[1, 2], [3, 4], [5, 6]])), np.array([[0., 2.82842712, 5.65685425], [2.82842712, 0., 2.82842712], [5.65685425, 2.82842712, 0.]])) assert np.allclose(euclidean_distance_matrix(np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])), np.array([[0., 1.73205081, 3.46410162], [1.73205081, 0., 1.73205081], [3.46410162, 1.73205081, 0.]])) ``` # Hint Utilize broadcasting and vectorized operations in NumPy to efficiently compute the pairwise distances.","solution":"import numpy as np def euclidean_distance_matrix(points: np.ndarray) -> np.ndarray: Computes the Euclidean distance matrix for a given set of points. :param points: A numpy array of shape (m, d) where m is the number of points and d is the dimension of each point. :return: A numpy array of shape (m, m) containing the Euclidean distances between each pair of points. # Calculate the squared differences between each pair of points squared_diffs = np.sum((points[:, np.newaxis, :] - points[np.newaxis, :, :]) ** 2, axis=2) # Take the square root of the squared differences to get the Euclidean distances distances = np.sqrt(squared_diffs) return distances"},{"question":"# Problem Statement You are tasked with implementing a simple integer parsing and arithmetic evaluation function. This function will take a string input representing a basic mathematical expression involving non-negative integers and the operators `+` and `-`. The function should parse the input and compute the result of the expression. # Requirements 1. **Integer Parsing**: Parse the input string to identify non-negative integers. 2. **Operator Handling**: Correctly handle `+` and `-` operators. 3. **Evaluation**: Evaluate the expression following the standard order of operations. # Input * A string `expression` representing a mathematical expression. # Output * An integer representing the result of the evaluated expression. # Constraints 1. The input expression will contain only non-negative integers and operators `+` and `-`. 2. The input expression will be a valid mathematical expression. 3. The length of the input expression will be at most 1000 characters. 4. There will be no whitespace in the input expression. # Example **Input**: ``` \\"10+2-5\\" ``` **Output**: ``` 7 ``` # Function Signature ```python def evaluate_expression(expression: str) -> int: pass ``` # Note 1. Focus on accurately implementing the mechanism of parsing and evaluating the expression. 2. Your function should be able to handle edge cases and typical input sizes efficiently. 3. Comments and documentation within your code are encouraged to demonstrate your understanding of the algorithm.","solution":"def evaluate_expression(expression: str) -> int: Evaluates a basic expression containing non-negative integers and the operators `+` and `-`. Parameters: expression (str): The mathematical expression to evaluate. Returns: int: The result of the evaluated expression. total = 0 current_number = 0 sign = 1 # 1 for positive, -1 for negative for char in expression: if char.isdigit(): # Build the current number current_number = current_number * 10 + int(char) elif char in \'+-\': # Add the last built number to the total total += sign * current_number # Reset the current number current_number = 0 # Update the sign sign = 1 if char == \'+\' else -1 # Add the last built number to the total total += sign * current_number return total"},{"question":"# Problem Statement Write a function that rearranges an array of integers such that all negative numbers appear before all positive numbers. The negative and positive numbers do not need to be sorted in any particular order. Do not use any additional storage array or list; modify the input array in-place. # Function Signature ```python def rearrange_array(nums: list[int]) -> None: pass ``` # Input - A list of integers `nums` where 1 ≤ len(nums) ≤ 10^5. # Output - None (the function should modify the input list in-place). # Constraints - The function must run in linear time complexity, O(n). - The function should not use any extra space for another array, although usage of a few extra variables is allowed. # Example ```python nums = [1, -2, 3, -4, 5, -6] rearrange_array(nums) # After rearranging, nums could be [-2, -4, -6, 1, 3, 5] or any other combination where all negative numbers come before all positive numbers. nums = [-1, 2, -3, 4, 5] rearrange_array(nums) # After rearranging, nums could be [-1, -3, 2, 4, 5] or any other combination where all negative numbers come before all positive numbers. nums = [2, 1, 3, 5, 4, 6] rearrange_array(nums) # After rearranging, nums could be [2, 1, 3, 5, 4, 6] as there are no negative numbers. ``` # Notes - The function should handle both cases where there are multiple negative numbers, a single negative number, or no negative numbers at all. - If the input list contains only negative numbers, it should remain unchanged. # Performance Requirements - The rearranged array should maintain the same relative ordering of the negative and positive numbers within their respective groups. - The solution must achieve O(n) time complexity while using O(1) additional space. Good luck!","solution":"def rearrange_array(nums: list[int]) -> None: Rearranges an array such that all negative numbers come before all positive numbers. This is done in-place without using extra space. left = 0 right = len(nums) - 1 while left <= right: if nums[left] < 0: left += 1 elif nums[right] >= 0: right -= 1 else: nums[left], nums[right] = nums[right], nums[left] left += 1 right -= 1"},{"question":"# Scenario You are building a software system that involves processing large volumes of log data. One of the tasks requires you to identify the longest sequence of unique characters in a given log entry. This measure helps in understanding the complexity and variety within log entries. # Task Write a function `longest_unique_substring(s: str) -> int` that returns the length of the longest substring that contains only unique characters in the given string `s`. # Input * **s**: A string `0 <= len(s) <= 10^5`, consisting of alphanumeric characters and symbols. # Output * Return the length of the longest substring with all unique characters. # Function Signature ```python def longest_unique_substring(s: str) -> int: pass ``` # Examples * `longest_unique_substring(\\"abcabcbb\\")` should return `3` (the substring is \\"abc\\"). * `longest_unique_substring(\\"bbbbb\\")` should return `1` (the substring is \\"b\\"). * `longest_unique_substring(\\"pwwkew\\")` should return `3` (the substring is \\"wke\\"). # Constraints * Your implementation should ensure handling of large strings efficiently. * Consider edge cases where the string might be empty or have duplicate characters throughout. # Notes * Implement your solution using a sliding window approach or other efficient algorithms to handle the input size within optimal time complexity limits. * Ensure your function can process the maximum input size promptly without excessive memory usage.","solution":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. max_length = 0 # To keep track of the maximum length of unique substring start = 0 # Left boundary of the sliding window char_index_map = {} # To store the most recent index of each character for end in range(len(s)): if s[end] in char_index_map: # Move the start position to the right of the last occurrence of current character start = max(start, char_index_map[s[end]] + 1) # Update the most recent index of the current character char_index_map[s[end]] = end # Calculate the maximum length of the unique substring seen so far max_length = max(max_length, end - start + 1) return max_length"},{"question":"# Coding Assessment Question Task Given a list of non-negative integers representing the amount of money of each house, where each house is arranged in a circular manner, determine the maximum amount of money you can rob tonight without alerting the police. If two adjacent houses are robbed, then the police will be alerted. Function Signature ```python def rob_circular_houses(nums: List[int]) -> int: ``` # Input - `nums` (List[int]): A list of non-negative integers. # Output - (int): The maximum amount of money that can be robbed without alerting the police. # Constraints - `0 <= len(nums) <= 100` - `0 <= nums[i] <= 1000` for each `i` # Requirements * As the houses are arranged in a circle, the first and last houses are considered adjacent. * Make use of dynamic programming to efficiently calculate the solution. # Example Here is an example of how your function might be called and what the expected output would be: ```python assert rob_circular_houses([2, 3, 2]) == 3 assert rob_circular_houses([1, 2, 3, 1]) == 4 assert rob_circular_houses([0]) == 0 ``` # Notes * You should handle edge cases such as an empty list or a list with one house appropriately. * Consider splitting the problem into two linear robbing scenarios: one excluding the first house and one excluding the last house, then take the maximum of the two scenarios.","solution":"from typing import List def rob_linear_houses(nums: List[int]) -> int: prev = curr = 0 for num in nums: prev, curr = curr, max(curr, prev + num) return curr def rob_circular_houses(nums: List[int]) -> int: n = len(nums) if n == 0: return 0 if n == 1: return nums[0] return max(rob_linear_houses(nums[:-1]), rob_linear_houses(nums[1:]))"},{"question":"**Scenario**: You are developing a file system simulation where different operations can be performed on the directories and files. Implement a `FileSystem` class that can mimic the behavior of a simple file system, including creating directories and files, navigating between them, and listing directory contents. **Requirements**: 1. Implement class `FileSystem` to manage directories and files. 2. Support operations such as creating directories and files, navigating to a directory, and listing the contents of the current directory. 3. Ensure thread-safety for all operations. 4. Handle edge cases like trying to create a directory/file that already exists, navigating to non-existent directories, and listing contents of an empty directory. **Function Specifications**: - **create_directory(path: str):** - Input: A string `path` representing the directory path to be created. - Output: None. Raises an exception if the directory already exists or if the path is invalid. - **create_file(path: str, content: str):** - Input: A string `path` representing the file path to be created and a string `content` to be stored in the file. - Output: None. Raises an exception if the file already exists or if the path is invalid. - **navigate_to(path: str):** - Input: A string `path` representing the directory path to navigate to. - Output: None. Raises an exception if the path is invalid. - **list_contents():** - Input: None. - Output: A list of strings representing the names of directories and files in the current directory. - **get_file_content(path: str):** - Input: A string `path` representing the file path to retrieve the content from. - Output: A string containing the content of the file. Raises an exception if the file does not exist or if the path is invalid. ```python import threading class FileSystem: def __init__(self): self.lock = threading.Lock() self.root = {\'type\': \'dir\', \'content\': {}} self.current_directory = self.root def create_directory(self, path): with self.lock: dirs = path.split(\'/\') current = self.current_directory for d in dirs: if d not in current[\'content\']: current[\'content\'][d] = {\'type\': \'dir\', \'content\': {}} elif current[\'content\'][d][\'type\'] != \'dir\': raise Exception(f\\"Path component {d} is a file, not a directory\\") current = current[\'content\'][d] def create_file(self, path, content): with self.lock: dirs = path.split(\'/\') file_name = dirs.pop(-1) current = self.current_directory for d in dirs: if d not in current[\'content\']: current[\'content\'][d] = {\'type\': \'dir\', \'content\': {}} current = current[\'content\'][d] if file_name in current[\'content\']: raise Exception(f\\"File {file_name} already exists\\") current[\'content\'][file_name] = {\'type\': \'file\', \'content\': content} def navigate_to(self, path): with self.lock: dirs = path.split(\'/\') current = self.root for d in dirs: if d not in current[\'content\']: raise Exception(f\\"Directory {path} does not exist\\") current = current[\'content\'][d] if current[\'type\'] != \'dir\': raise Exception(f\\"Path {path} is not a directory\\") self.current_directory = current def list_contents(self): with self.lock: return list(self.current_directory[\'content\'].keys()) def get_file_content(self, path): with self.lock: dirs = path.split(\'/\') file_name = dirs.pop(-1) current = self.root for d in dirs: if d not in current[\'content\']: raise Exception(f\\"Directory {path} does not exist\\") current = current[\'content\'][d] if file_name not in current[\'content\'] or current[\'content\'][file_name][\'type\'] != \'file\': raise Exception(f\\"File {path} does not exist\\") return current[\'content\'][file_name][\'content\'] ``` **Constraints**: 1. The file system should support nested directories. 2. Only valid paths are expected (no absolute paths directly). 3. Each operation should be thread-safe. **Example**: ```python fs = FileSystem() fs.create_directory(\\"dir1\\") fs.create_file(\\"dir1/file1.txt\\", \\"Hello World\\") fs.navigate_to(\\"dir1\\") print(fs.list_contents()) # Output: [\\"file1.txt\\"] print(fs.get_file_content(\\"file1.txt\\")) # Output: \\"Hello World\\" ```","solution":"import threading class FileSystem: def __init__(self): self.lock = threading.Lock() self.root = {\'type\': \'dir\', \'content\': {}} self.current_directory = self.root def create_directory(self, path): with self.lock: dirs = path.split(\'/\') current = self.root for d in dirs: if d not in current[\'content\']: current[\'content\'][d] = {\'type\': \'dir\', \'content\': {}} elif current[\'content\'][d][\'type\'] != \'dir\': raise Exception(f\\"Path component {d} is a file, not a directory\\") current = current[\'content\'][d] def create_file(self, path, content): with self.lock: dirs = path.split(\'/\') file_name = dirs.pop(-1) current = self.root for d in dirs: if d not in current[\'content\']: current[\'content\'][d] = {\'type\': \'dir\', \'content\': {}} current = current[\'content\'][d] if file_name in current[\'content\']: raise Exception(f\\"File {file_name} already exists\\") current[\'content\'][file_name] = {\'type\': \'file\', \'content\': content} def navigate_to(self, path): with self.lock: dirs = path.split(\'/\') current = self.root for d in dirs: if d not in current[\'content\']: raise Exception(f\\"Directory {path} does not exist\\") current = current[\'content\'][d] if current[\'type\'] != \'dir\': raise Exception(f\\"Path {path} is not a directory\\") self.current_directory = current def list_contents(self): with self.lock: return list(self.current_directory[\'content\'].keys()) def get_file_content(self, path): with self.lock: dirs = path.split(\'/\') file_name = dirs.pop(-1) current = self.root for d in dirs: if d not in current[\'content\']: raise Exception(f\\"Directory {path} does not exist\\") current = current[\'content\'][d] if file_name not in current[\'content\'] or current[\'content\'][file_name][\'type\'] != \'file\': raise Exception(f\\"File {path} does not exist\\") return current[\'content\'][file_name][\'content\']"},{"question":"# Question # Logical Indexing in Arrays Scenario: You are given an array of integers and a target integer. Your task is to create a new array that contains elements from the original array which are greater than or equal to the target integer. Task: Write a function `filter_elements` that filters the elements of the input array according to the specified target integer. Function Signature: ```python def filter_elements(arr: list[int], target: int) -> list[int]: pass ``` Input: - `arr` (list of int): The original array of integers. - `target` (int): The target integer for filtering the array. Output: - Returns a new list (list of int) containing elements from the original array which are greater than or equal to the target integer. Constraints: - The input array `arr` can be empty but will not contain non-integer elements. - Elements in the array `arr` can be any integer value, both positive and negative. - Target integer can be any integer value, both positive and negative. Performance Requirements: - The function should operate efficiently with a time complexity of O(n), where n is the number of elements in the input array. Examples: ```python >>> filter_elements([1, 5, 8, 10, 3, -2, 4], 5) [5, 8, 10] >>> filter_elements([1, 2, 3, 4, 5], 3) [3, 4, 5] >>> filter_elements([10, 20, 30, 40], 25) [30, 40] >>> filter_elements([], 10) [] >>> filter_elements([0, -5, -10, 7, 3], -2) [0, 7, 3] ``` Ensure your function handles edge cases such as an empty input array appropriately.","solution":"def filter_elements(arr, target): Returns a new list containing elements from the original array which are greater than or equal to the target integer. :param arr: list of int, original array of integers. :param target: int, target integer for filtering the array. :return: list of int, filtered array. return [x for x in arr if x >= target]"},{"question":"# Problem Statement You are asked to implement a function that normalizes a given vector. # Detailed Description Vector normalization is the process of scaling a vector so that its magnitude (or length) is 1. The formula for normalizing a vector (vec{v} = (v_1, v_2, ..., v_n)) is given by: [ vec{u} = frac{vec{v}}{|vec{v}|} ] where (|vec{v}|) is the Euclidean norm (or length) of the vector, defined as: [ |vec{v}| = sqrt{v_1^2 + v_2^2 + ... + v_n^2} ] Input: * `vector` (list[float]): A list of floating-point numbers representing the components of the vector. Output: * A list of floats representing the normalized vector components, rounded to 2 decimal places. Constraints: * The input list must not be empty. * The vector components are real numbers. # Example: ```python def normalize_vector(vector: list[float]) -> list[float]: >>> normalize_vector([1, 2, 2]) [0.33, 0.67, 0.67] >>> normalize_vector([3, 4, 0]) [0.6, 0.8, 0.0] >>> normalize_vector([-2, -4, 4]) [-0.33, -0.67, 0.67] >>> normalize_vector([0, 0, 0]) [] >>> normalize_vector([5]) [1.0] import math if not vector: raise ValueError(\\"Input vector must not be empty\\") norm = math.sqrt(sum([x**2 for x in vector])) if norm == 0: return [] normalized_vector = [round(x / norm, 2) for x in vector] return normalized_vector ``` # Task: Implement the `normalize_vector` function which takes a `vector` as input and returns the normalized vector components, rounded to 2 decimal places.","solution":"def normalize_vector(vector: list[float]) -> list[float]: Normalizes a given vector to have a magnitude of 1. Parameters: vector (list[float]): A list of floating-point numbers representing the components of the vector. Returns: list[float]: A list of normalized vector components, rounded to 2 decimal places. Raises: ValueError: If the input vector is empty. import math if not vector: raise ValueError(\\"Input vector must not be empty\\") norm = math.sqrt(sum([x**2 for x in vector])) if norm == 0: return [] normalized_vector = [round(x / norm, 2) for x in vector] return normalized_vector"},{"question":"# Array Sum with Exclusion You are tasked with writing a function that calculates the sum of an array of integers but excludes specified indices from contributing to the sum. Objective Write a function `sum_excluding_indices` that computes the sum of a list of integers, excluding the values at specified indices. Function Signature ```python def sum_excluding_indices(array: List[int], exclude: List[int]) -> int: ``` # Input - A list of `n` integers `array`. - A list of `m` integers `exclude` representing the indices to be excluded from the sum calculation. # Output - An integer representing the sum of elements in `array`, excluding the elements at the specified indices. # Constraints - `1 <= n <= 10^6` - `0 <= array[i] <= 10^6` for all `0 <= i < n` - `0 <= m <= n` - `0 <= exclude[i] < n` for all `0 <= i < m` - The `exclude` list contains unique indices. # Examples ```python assert sum_excluding_indices([1, 2, 3, 4], [1, 3]) == 4 assert sum_excluding_indices([10, 20, 30, 40, 50], [0, 2, 4]) == 60 assert sum_excluding_indices([5, 5, 5, 5, 5], []) == 25 assert sum_excluding_indices([7, 8, 9], [0, 1, 2]) == 0 ``` **Explanation**: 1. For the first example, excluding elements at indices `[1, 3]` from `[1, 2, 3, 4]` results in `1 + 3 = 4`. 2. For the second example, excluding elements at indices `[0, 2, 4]` from `[10, 20, 30, 40, 50]` results in `20 + 40 = 60`. # Requirements - Ensure your implementation handles large inputs efficiently. - Consider edge cases such as the function receiving an empty exclusion list.","solution":"def sum_excluding_indices(array, exclude): Computes the sum of a list of integers, excluding the values at specified indices. exclude_set = set(exclude) return sum(array[i] for i in range(len(array)) if i not in exclude_set)"},{"question":"# Question: Recursive Directory Traversal Objective: As part of a file management system, you need to implement a function that recursively traverses directories and collects information about files. The function should be capable of handling large directory structures and return a summary of file types and their counts. Part 1: Implementing the Directory Traversal 1. **Function: `traverse_directory`** - Traverse the directory starting from a specified path. - Collect the count of different types of files (e.g., text, image, audio, video, and others). ```python def traverse_directory(start_path: str) -> dict: Traverse the directory recursively to count file types. Parameters: start_path (str): The path of the directory to start the traversal. Returns: dict: A dictionary with file type as the key and their count as the value. pass # Your implementation ``` Part 2: Filtering Certain File Types 2. **Function: `filter_file_types`** - From the collected directory information, filter out file types not listed in the provided allowed types (e.g., [\'text\', \'image\']). ```python def filter_file_types(file_summary: dict, allowed_types: list) -> dict: Filter the file summary to include only the allowed types. Parameters: file_summary (dict): The summary dictionary with file types and counts. allowed_types (list): List of allowed file types to be included in the result. Returns: dict: A filtered dictionary with only the allowed file types. pass # Your implementation ``` Part 3: Summarizing Total File Count 3. **Function: `total_file_count`** - Calculate the total number of files based on the filtered summary dictionary. ```python def total_file_count(filtered_summary: dict) -> int: Calculate the total number of files from the filtered summary. Parameters: filtered_summary (dict): The filtered dictionary with allowed file types and counts. Returns: int: The total number of files. pass # Your implementation ``` Constraints & Requirements: * Use the `os` module for directory and file operations. * The function should handle errors gracefully (e.g., inaccessible directories). * File types can be categorized using file extensions: - Text: [\'txt\', \'md\'] - Image: [\'jpg\', \'jpeg\', \'png\', \'gif\'] - Audio: [\'mp3\', \'wav\'] - Video: [\'mp4\', \'avi\'] - Others: Any other file types Example: ```python # Assuming the directory structure and files present: # /example # ├── file1.txt # ├── file2.jpg # ├── file3.mp3 # ├── file4.mp4 # ├── subdir # │ └── file5.md # └── subdir2 # └── file6.png file_summary = traverse_directory(\\"/example\\") Example Output: { \'text\': 2, \'image\': 2, \'audio\': 1, \'video\': 1, \'others\': 0 } filtered_summary = filter_file_types(file_summary, [\'text\', \'image\']) Example Output: { \'text\': 2, \'image\': 2 } total_files = total_file_count(filtered_summary) # Example Output: 4 ``` Ensure the implementation considers edge cases such as nested directories, different file types, and inaccessible files or directories.","solution":"import os def traverse_directory(start_path: str) -> dict: file_types = { \'text\': [\'txt\', \'md\'], \'image\': [\'jpg\', \'jpeg\', \'png\', \'gif\'], \'audio\': [\'mp3\', \'wav\'], \'video\': [\'mp4\', \'avi\'], \'others\': [] } summary = {key: 0 for key in file_types} for root, _, files in os.walk(start_path): for file in files: file_ext = file.split(\'.\')[-1].lower() found = False for file_type, extensions in file_types.items(): if file_ext in extensions: summary[file_type] += 1 found = True break if not found: summary[\'others\'] += 1 return summary def filter_file_types(file_summary: dict, allowed_types: list) -> dict: return {key: value for key, value in file_summary.items() if key in allowed_types} def total_file_count(filtered_summary: dict) -> int: return sum(filtered_summary.values())"},{"question":"# Coding Challenge **Context**: You have been hired to develop a feature for a new image processing tool. One of the functionalities required is the ability to manipulate RGB color values in images. A common task in image processing is to tonal inversion, which calculates the negative of each color. **Objective**: Write a function `invert_colors(rgb_colors)` that takes a list of RGB color tuples and returns a list with the colors inverted. The color inversion should be done by subtracting each color component value from 255. Function Signature ```python def invert_colors(rgb_colors: list) -> list: ... ``` # Input * `rgb_colors` (list): A list of tuples where each tuple contains three integers representing the RGB components of the color. Each integer is between 0 and 255, inclusive. # Output * A list of tuples where each tuple contains the inverted RGB components of the corresponding input color. # Constraints * The list will contain between 1 and 10^4 tuples. # Examples ```python assert invert_colors([(0, 0, 0)]) == [(255, 255, 255)] assert invert_colors([(255, 255, 255)]) == [(0, 0, 0)] assert invert_colors([(123, 234, 56)]) == [(132, 21, 199)] assert invert_colors([(45, 67, 89), (12, 34, 56)]) == [(210, 188, 166), (243, 221, 199)] assert invert_colors([(153, 102, 204), (204, 255, 102)]) == [(102, 153, 51), (51, 0, 153)] ``` # Guidelines 1. Ensure input validation. 2. Each tuple will always have exactly three integers. 3. Each integer in the tuple will always be between 0 and 255, inclusive. **Notes**: * You do not need to handle edge cases such as invalid input types or values outside the specified range. * Focus on implementing the inversion logic accurately and efficiently.","solution":"def invert_colors(rgb_colors): Takes a list of RGB color tuples and returns a list with the colors inverted. inverted_colors = [(255 - r, 255 - g, 255 - b) for r, g, b in rgb_colors] return inverted_colors"},{"question":"# Problem: Longest Common Subsequence You are tasked with finding the longest common subsequence (LCS) of two given strings. # Function Signature ```python def longest_common_subsequence(s1: str, s2: str) -> str: Parameters: - s1 : str : the first input string - s2 : str : the second input string Returns: - str : the longest common subsequence between s1 and s2 ``` # Input Format - `s1`: A string of length `n` (1 <= n <= 1000). - `s2`: A string of length `m` (1 <= m <= 1000). # Output Format - A string representing the longest common subsequence between `s1` and `s2`. In case of multiple LCS of the same length, return any one of them. # Constraints - Both strings may contain any characters, including special characters and spaces. - Solution should have an algorithmic complexity of O(n * m). # Performance Requirements - You must implement this using dynamic programming. - The solution should handle strings up to 1000 characters efficiently within an acceptable timeframe. # Scenario Imagine you are working on a version control system that needs to merge changes from two different versions of the same file. To assist with this merger, you need to find the longest common subsequence between two versions of a text to identify the common parts that remain unchanged. # Example ```python s1 = \\"ABCBDAB\\" s2 = \\"BDCAB\\" # Expected output: # \\"BCAB\\" or \\"BDAB\\" ``` Implement the function to solve the problem described.","solution":"def longest_common_subsequence(s1: str, s2: str) -> str: Returns the longest common subsequence between s1 and s2. n, m = len(s1), len(s2) dp = [[\\"\\" for _ in range(m+1)] for _ in range(n+1)] for i in range(1, n+1): for j in range(1, m+1): if s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] + s1[i-1] else: dp[i][j] = dp[i-1][j] if len(dp[i-1][j]) >= len(dp[i][j-1]) else dp[i][j-1] return dp[n][m]"},{"question":"# Problem Statement You are assisting a robotics team in optimizing the movement of an autonomous robot within a 2D grid. The grid is represented as an array of integers where each integer indicates the cost to move through that cell. The robot moves from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1). The robot can only move right or down at each step. Your task is to write a function that calculates the minimum cost path from the top-left to the bottom-right corner of the grid. # Function Signature ```python def min_cost_path(grid): Finds the minimum cost path for the robot from the top-left to the bottom-right corner of the grid. Arguments: grid -- a 2D list of integers representing the cost grid. Returns: An integer representing the minimum cost to reach the bottom-right corner. pass ``` # Input * `grid` (list of list of ints): A 2D list of integers where `grid[i][j]` represents the cost to move through cell (i, j). # Output * Integer value representing the minimum cost to reach the bottom-right corner of the grid from the top-left corner. # Constraints * ( 1 leq n, m leq 100 ) (n is the number of rows, m is the number of columns) * ( 0 leq grid[i][j] leq 100 ) (Cost values) # Performance Requirements * Your solution should run efficiently within the given constraints. # Example ```python # Define the cost grid grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] # Call the function min_cost = min_cost_path(grid) # Example output # 7 ``` # Explanation The function calculates the minimum cost to travel from the top-left to the bottom-right of the given grid. For the example provided, the optimal path is: right -> right -> down -> down, resulting in a total cost of 1 + 3 + 1 + 1 + 1 = 7.","solution":"def min_cost_path(grid): Finds the minimum cost path for the robot from the top-left to the bottom-right corner of the grid. Arguments: grid -- a 2D list of integers representing the cost grid. Returns: An integer representing the minimum cost to reach the bottom-right corner. if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) cost = [[0 for _ in range(m)] for _ in range(n)] cost[0][0] = grid[0][0] # Initialize the first row. for j in range(1, m): cost[0][j] = cost[0][j-1] + grid[0][j] # Initialize the first column. for i in range(1, n): cost[i][0] = cost[i-1][0] + grid[i][0] # Fill in the rest of the cost table. for i in range(1, n): for j in range(1, m): cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + grid[i][j] return cost[n-1][m-1]"},{"question":"# Coding Assessment Question **Title**: Generate All Possible Subsets **Objective**: Implement a function to generate all possible subsets of a given list of unique elements. **Context**: Given a list of unique elements (could be integers or characters), generate all possible subsets, also known as the power set. The subsets should be in lexicographical order. **Function Signature**: ```python def find_all_subsets(elements: list[int | str]) -> None: pass ``` **Input/Output Format**: * **Input**: A list of unique elements (`elements`) which can be integers or characters. The list will have at most 8 elements. * **Output**: Print each subset on a new line in lexicographical order. Each subset should be represented as a list and sorted in ascending order. **Constraints**: * No element repeats in the input list. * The input list has a maximum length of 8. **Examples**: Example 1: ```python elements = [1, 2, 3] find_all_subsets(elements) ``` Output: ``` [] [1] [1, 2] [1, 2, 3] [1, 3] [2] [2, 3] [3] ``` Example 2: ```python elements = [\\"A\\", \\"B\\", \\"C\\"] find_all_subsets(elements) ``` Output: ``` [] [\'A\'] [\'A\', \'B\'] [\'A\', \'B\', \'C\'] [\'A\', \'C\'] [\'B\'] [\'B\', \'C\'] [\'C\'] ``` **Hints**: 1. Use the backtracking approach to generate subsets. 2. An empty list would represent the empty subset. 3. Start with an empty subset and recursively add each element to generate further subsets maintaining the lexicographical order. 4. The subset list can include empty subsets. **Implementation Note**: Work independently to practice generating the power set using methods like recursion or iterative approaches to solidify understanding of subset generation.","solution":"def find_all_subsets(elements): Prints all subsets of the given list of elements in lexicographical order. def backtrack(start, path): result.append(path[:]) for i in range(start, len(elements)): path.append(elements[i]) backtrack(i + 1, path) path.pop() result = [] elements.sort() # Ensure the elements are in lexicographical order backtrack(0, []) for subset in result: print(subset)"},{"question":"# Palindromic Substrings: Count and Length Problem Statement Given a string `s`, you are required to find the total number of palindromic substrings and the length of the longest palindromic substring within `s`. A palindromic substring is a substring that reads the same backward as forward. Objective Implement a function `palindromic_substrings` that: - Takes a string input `s`. - Returns a tuple containing two integers: - The total number of palindromic substrings in `s`. - The length of the longest palindromic substring in `s`. Functional Requirements - The function should validate and handle incorrect inputs: - Raise a `TypeError` if `s` is not a string. - Handle edge cases where the string might be empty or consists of one character. - You must use an efficient algorithm to identify and count palindromic substrings. Constraints * 0 ≤ len(s) ≤ 10^3. Input Format - A string `s` consisting of lowercase English letters. Output Format - A tuple (total_palindromic_substrings, length_of_longest_palindromic_substring). Example ```python >>> palindromic_substrings(\\"abba\\") (6, 4) >>> palindromic_substrings(\\"abc\\") (3, 1) >>> palindromic_substrings(\\"a\\") (1, 1) >>> palindromic_substrings(\\"\\") (0, 0) ``` Function Signature ```python def palindromic_substrings(s: str) -> tuple: # Your code here ``` Scenario You are developing a feature for a text analysis tool that needs to extract insights related to palindromic patterns within the text data. The tool will identify and count palindromic substrings and also determine the longest palindromic sequence. This information will be useful for linguistic analysis and pattern detection in strings. The user will provide a string, and your function should return the required details efficiently.","solution":"def palindromic_substrings(s: str) -> tuple: if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") n = len(s) if n == 0: return (0, 0) total_palindromic_substrings = 0 length_of_longest_palindromic_substring = 0 dp = [[False] * n for _ in range(n)] for i in range(n): dp[i][i] = True total_palindromic_substrings += 1 length_of_longest_palindromic_substring = 1 for start in range(n - 1, -1, -1): for end in range(start + 1, n): if s[start] == s[end]: if end - start == 1 or dp[start + 1][end - 1]: dp[start][end] = True total_palindromic_substrings += 1 length_of_longest_palindromic_substring = max( length_of_longest_palindromic_substring, end - start + 1 ) return (total_palindromic_substrings, length_of_longest_palindromic_substring)"},{"question":"# Problem: Implement a Mini Markdown Parser Background Markdown is a lightweight markup language with plain text formatting syntax. It is widely used to format readme files, for writing messages in online discussion forums, and to create rich text using a plain text editor. For this task, you need to implement a mini markdown parser that supports a few basic features: headers, bold text, italics, and links. Task Implement a `MarkdownParser` class in Python that parses a given markdown string and converts it into HTML. Input - **markdown_text**: A string containing markdown formatted text. Output - A string containing the equivalent HTML formatted text. Supported Markdown Features 1. Headers: Lines starting with 1 to 6 `#` characters should be converted to `<h1>` to `<h6>` HTML tags respectively. 2. Bold: Text wrapped in double asterisks (`**text**`) should be converted to `<b>text</b>`. 3. Italics: Text wrapped in single asterisks (`*text*`) should be converted to `<i>text</i>`. 4. Links: Text formatted as `[link text](URL)` should be converted to `<a href=\\"URL\\">link text</a>`. Constraints 1. The input markdown string is non-empty. 2. Headers will be on their own lines. 3. Bold and italic text, and links will not be nested and can appear anywhere in the text. Example ```python class MarkdownParser: def __init__(self, markdown_text): self.markdown_text = markdown_text def parse(self): lines = self.markdown_text.split(\'n\') html_output = [] for line in lines: if line.startswith(\'#\'): header_level = len(line.split()[0]) line = line[header_level+1:].strip() line = f\'<h{header_level}>{line}</h{header_level}>\' else: line = self._parse_inline_format(line) html_output.append(line) return \'n\'.join(html_output) def _parse_inline_format(self, text): import re text = re.sub(r\'**(.+?)**\', r\'<b>1</b>\', text) text = re.sub(r\'*(.+?)*\', r\'<i>1</i>\', text) text = re.sub(r\'[(.+?)]((.+?))\', r\'<a href=\\"2\\">1</a>\', text) return text if __name__ == \\"__main__\\": md_text = # Header 1 Header 2 This is some **bold text** and some *italic text*. Check out this [link](http://example.com). parser = MarkdownParser(md_text.strip()) html = parser.parse() print(html) ``` Expected Output ``` <h1>Header 1</h1> <h2>Header 2</h2> This is some <b>bold text</b> and some <i>italic text</i>. Check out this <a href=\\"http://example.com\\">link</a>. ```","solution":"import re class MarkdownParser: def __init__(self, markdown_text): self.markdown_text = markdown_text def parse(self): lines = self.markdown_text.split(\'n\') html_output = [] for line in lines: if line.startswith(\'#\'): header_level = len(line.split()[0]) line = line[header_level:].strip() line = f\'<h{header_level}>{line}</h{header_level}>\' else: line = self._parse_inline_format(line) html_output.append(line) return \'n\'.join(html_output) def _parse_inline_format(self, text): text = re.sub(r\'**(.+?)**\', r\'<b>1</b>\', text) text = re.sub(r\'*(.+?)*\', r\'<i>1</i>\', text) text = re.sub(r\'[(.+?)]((.+?))\', r\'<a href=\\"2\\">1</a>\', text) return text def parse_markdown(markdown_text): parser = MarkdownParser(markdown_text) return parser.parse()"},{"question":"Question: Implement a Custom Fibonacci Generator You are tasked with implementing a custom generator function to produce the Fibonacci sequence up to a given number of terms. The Fibonacci sequence is characterized by the fact that every number after the first two is the sum of the two preceding ones. # Function Signature ```python def fibonacci_generator(n: int): Generate the first `n` terms of the Fibonacci sequence. Parameters: n (int): Number of terms to generate in the Fibonacci sequence. Yields: int: The next number in the Fibonacci sequence. ``` # Constraints - The input integer `n` will satisfy `0 <= n <= 50`. # Input Example ```python n = 5 ``` # Output Example ```python [0, 1, 1, 2, 3] ``` # Additional Examples Example 1 **Input**: ```python n = 8 ``` **Output**: ```python [0, 1, 1, 2, 3, 5, 8, 13] ``` Example 2 **Input**: ```python n = 0 ``` **Output**: ```python [] ``` # Scenario/Context Your generator function will be useful in applications requiring efficient on-demand generation of Fibonacci numbers, such as in real-time graphics and simulations or algorithmic problem-solving contexts. # Notes - Make sure the generator handles the edge case of `n = 0` by producing no output. - Consider the performance implications of generating Fibonacci numbers for the upper limit of `n = 50`. - Use yield to avoid memory inefficiency issues associated with storing large sequences.","solution":"def fibonacci_generator(n: int): Generate the first `n` terms of the Fibonacci sequence. Parameters: n (int): Number of terms to generate in the Fibonacci sequence. Yields: int: The next number in the Fibonacci sequence. if n <= 0: return a, b = 0, 1 for _ in range(n): yield a a, b = b, a + b"},{"question":"# Coding Assessment Question Objective Write a function that determines the next leap year after a given year. A leap year occurs every 4 years, but years divisible by 100 are not leap years, unless they are also divisible by 400. Background Leap years help synchronize the calendar year with the solar year. To determine if a year is a leap year: 1. If the year is divisible by 4, check further. 2. If the year is divisible by 100, check further. 3. If the year is also divisible by 400, it is a leap year. 4. Otherwise, if it is only divisible by 100 but not by 400, it is not a leap year. 5. If it is divisible by 4 but not by 100, it is a leap year. Task Implement the function `next_leap_year(year: int) -> int` that: 1. Determines whether the provided year is a leap year. 2. Finds and returns the next leap year after the provided year. Specifications * **Input**: A single integer `year` representing any year in the Gregorian calendar. * **Output**: The function should return an integer representing the next leap year after the input year. Example ```python >>> next_leap_year(2021) 2024 >>> next_leap_year(1900) 1904 >>> next_leap_year(2000) 2004 ``` Constraints 1. The year should be a valid Gregorian year (i.e., greater than 1582). 2. You may assume the input year is always a valid integer within the correct range. Additional Notes * Ensure that your implementation is efficient and runs within a reasonable time for large years. * Consider edge cases such as the years immediately before or after a leap year.","solution":"def is_leap_year(year: int) -> bool: Determines if a given year is a leap year. if year % 4 == 0: if year % 100 == 0: if year % 400 == 0: return True else: return False else: return True else: return False def next_leap_year(year: int) -> int: Finds and returns the next leap year after the given year. year += 1 # Start checking from the next year while not is_leap_year(year): year += 1 return year"},{"question":"# Coding Assessment Question Problem Statement You are given a 2D grid where each cell represents a bucket, filled with water or not. Water can flow from one bucket to another if: 1. They are adjacent (left, right, up, or down). 2. The next bucket has either the same or less water than the current bucket. Your task is to implement a function that determines if water can flow from the top-left bucket (grid[0][0]) to the bottom-right bucket (grid[n-1][m-1]) of the grid. Function Signature ```python def can_water_flow(grid): Determines if water can flow from the top-left bucket to the bottom-right bucket. Parameters: grid (List[List[int]]): A 2D grid where grid[i][j] represents the amount of water in the bucket at position (i, j). Returns: bool: True if water can flow from grid[0][0] to grid[n-1][m-1], False otherwise. # your code here ``` Input Format - `grid`: A 2D list where grid[i][j] is a non-negative integer representing the amount of water in the bucket at position (i, j). Output Format - Return `True` if water can flow from `grid[0][0]` to `grid[n-1][m-1]`, otherwise return `False`. Constraints - The dimensions of the grid ( n times m ) ( (1 leq n, m leq 100) ). - The water levels are non-negative integers. Example Given the grid: ```python test_grid = [ [2, 2, 1], [3, 2, 2], [4, 3, 2] ] ``` calling `can_water_flow(test_grid)` should return: ``` True ``` Given the grid: ```python test_grid = [ [2, 3, 4], [2, 2, 1], [4, 3, 2] ] ``` calling `can_water_flow(test_grid)` should return: ``` False ``` # Requirements 1. Utilize Depth-First Search (DFS) or Breadth-First Search (BFS) to explore the grid. 2. Ensure to handle edge cases where the grid is just a single bucket. 3. Optimize traversal within the constraint limits.","solution":"def can_water_flow(grid): Determines if water can flow from the top-left bucket to the bottom-right bucket. Parameters: grid (List[List[int]]): A 2D grid where grid[i][j] represents the amount of water in the bucket at position (i, j). Returns: bool: True if water can flow from grid[0][0] to grid[n-1][m-1], False otherwise. if not grid: return False n, m = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] def bfs(): from collections import deque queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n-1, m-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited: if grid[nx][ny] <= grid[x][y]: visited.add((nx, ny)) queue.append((nx, ny)) return False return bfs()"},{"question":"**Scenario**: You are working on a Natural Language Processing (NLP) project that requires generating summaries of news articles. You have a directory of text files, each containing the contents of a news article, and you need to create a summarization script that processes these articles. **Task**: 1. **Load Articles**: Implement functionality to load all text files from a specified directory into a list of strings. 2. **Summarize Articles**: Write a summarization function that takes a list of articles and returns a list of their summaries. Use a simple extractive summarization technique by selecting sentences that contain keywords indicative of importance (e.g., the title, any numbers, names, or specific entities). 3. **Save Summaries**: Ensure the generated summaries are saved into an output directory with the same base name as the original file but with \\"_summary\\" appended to the filename. **Constraints**: * The article directory should be specified as an input parameter. * Each summary should be concise, containing only the most critical information extracted. **Function Specifications**: ```python def load_articles(article_dir: str) -> list: - article_dir <type: str>: Path to the directory containing text files of news articles Returns <type: list>: - List of article contents as strings def summarize_articles(articles: list) -> list: - articles <type: list>: List of article contents as strings Returns <type: list>: - List of summaries for each article def save_summaries(summaries: list, original_paths: list, output_dir: str) -> None: - summaries <type: list>: List of summarized articles - original_paths <type: list>: List of original article file paths - output_dir <type: str>: Directory to save summary files def main() -> None: - Load the articles - Summarize the articles - Save the summaries if __name__ == \\"__main__\\": main() ``` **Input Format**: * Path to the article directory. * Output directory path. **Output Format**: * Summarized articles saved in the specified output directory with \\"_summary\\" appended to the file names.","solution":"import os def load_articles(article_dir: str) -> list: - article_dir <type: str>: Path to the directory containing text files of news articles Returns <type: list>: - List of article contents as strings articles = [] for filename in os.listdir(article_dir): if filename.endswith(\\".txt\\"): filepath = os.path.join(article_dir, filename) with open(filepath, \'r\', encoding=\'utf-8\') as file: articles.append(file.read()) return articles def summarize_articles(articles: list) -> list: - articles <type: list>: List of article contents as strings Returns <type: list>: - List of summaries for each article summarized_articles = [] for article in articles: sentences = article.split(\'.\') important_sentences = [sentence for sentence in sentences if any(keyword in sentence for keyword in (\\"the\\", \\"a\\", \\"an\\"))] summary = \' \'.join(important_sentences[:3]) # Taking up to 3 important sentences summarized_articles.append(summary.strip()) return summarized_articles def save_summaries(summaries: list, original_paths: list, output_dir: str) -> None: - summaries <type: list>: List of summarized articles - original_paths <type: list>: List of original article file paths - output_dir <type: str>: Directory to save summary files if not os.path.exists(output_dir): os.makedirs(output_dir) for summary, original_path in zip(summaries, original_paths): base_name = os.path.basename(original_path) save_name = f\\"{os.path.splitext(base_name)[0]}_summary.txt\\" save_path = os.path.join(output_dir, save_name) with open(save_path, \'w\', encoding=\'utf-8\') as file: file.write(summary) def main() -> None: import sys if len(sys.argv) != 3: print(\\"Usage: python script.py <article_directory> <output_directory>\\") return article_dir = sys.argv[1] output_dir = sys.argv[2] articles = load_articles(article_dir) summaries = summarize_articles(articles) save_summaries(summaries, [os.path.join(article_dir, filename) for filename in os.listdir(article_dir) if filename.endswith(\\".txt\\")], output_dir) if __name__ == \\"__main__\\": main()"},{"question":"# Fibonacci Sequence Sum Context The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The sequence goes 0, 1, 1, 2, 3, 5, 8, 13, 21, and so on. Task You are tasked with implementing a function `fibonacci_sum(n: int) -> int` that calculates the sum of the first `n` terms of the Fibonacci sequence (0 indexed). Requirements: 1. The function should return the sum of the first `n` terms of the Fibonacci sequence. 2. If `n` is non-positive, the function should raise a `ValueError` with the message: \\"n must be a positive integer\\". Input: * `n`: An integer representing the number of terms of the Fibonacci sequence to sum. Output: * An integer representing the sum of the first `n` terms of the Fibonacci sequence. Constraints: * The input `n` is a positive integer less than or equal to 100. * Ensure the solution is efficient and handles the largest possible input within the given constraints. Examples: ```python >>> fibonacci_sum(5) 7 # 0 + 1 + 1 + 2 + 3 = 7 >>> fibonacci_sum(10) 88 # 0 + 1 + 1 + 2 + 3 + 5 + 8 + 13 + 21 + 34 = 88 >>> fibonacci_sum(1) 0 # Only the first term which is 0. >>> fibonacci_sum(-3) Traceback (most recent call last): ... ValueError: n must be a positive integer >>> fibonacci_sum(0) Traceback (most recent call last): ... ValueError: n must be a positive integer ``` Implementation Note: Focus on correctly handling edge cases such as non-positive input and ensuring the efficient calculation and summation of Fibonacci sequence terms. --- The above question maintains the style, complexity, and scope of the sample question provided, ensuring seamless integration in a coding assessment.","solution":"def fibonacci_sum(n: int) -> int: Returns the sum of the first n terms of the Fibonacci sequence. If n is non-positive, it raises a ValueError. if n <= 0: raise ValueError(\\"n must be a positive integer\\") if n == 1: return 0 fib = [0, 1] sum_fib = fib[0] + fib[1] for i in range(2, n): fib.append(fib[-1] + fib[-2]) sum_fib += fib[-1] return sum_fib"},{"question":"Median of Sliding Window The sliding window median problem involves computing the median of the last `k` numbers for each position in a list of numbers. This is useful in many applications, such as signal processing or tracking the central tendency in a changing dataset. Your task is to write a function `sliding_window_median(nums: List[int], k: int) -> List[float]` that returns a list of medians corresponding to each position of a sliding window of size `k`. Input - `nums`: A list of integers representing the input data stream. - `k`: An integer representing the size of the sliding window. It should be greater than 0. Output - A list of floats representing the medians for each window position. Constraints - The input list `nums` length is at least `k` and can contain negative and positive integers. - The `k` is a positive integer less than or equal to the length of `nums`. - You should aim for an efficient algorithm, ideally better than (O(nk)). # Examples ```python >>> sliding_window_median([1, 3, -1, -3, 5, 3, 6, 7], 3) [1, -1, -1, 3, 5, 6] >>> sliding_window_median([1, 4, 2, 3], 4) [2.5] ``` Formal Explanation To calculate the median of each sliding window: 1. For each position in the list where the window can fit (from `0` to `len(nums) - k`): - Extract the current window of size `k` from the list. - Sort the values in this window. - If `k` is odd, the median is the middle element; if `k` is even, the median is the average of the two middle elements. 2. Continue this process until you have computed the median for all valid window positions and return the list of median values. Notes - Use appropriate data structures to keep track of the window and efficiently compute the median as you slide the window. - Implement error handling to ensure the function gracefully handles cases where `k` is out of bounds or the input list is empty.","solution":"from typing import List import bisect def sliding_window_median(nums: List[int], k: int) -> List[float]: Returns the median of each sliding window of size k. if k == 0 or not nums or k > len(nums): return [] medians = [] window = sorted(nums[:k]) def median(window): n = len(window) if n % 2 == 1: return float(window[n // 2]) else: return (window[n // 2 - 1] + window[n // 2]) / 2 for i in range(len(nums) - k + 1): medians.append(median(window)) if i + k < len(nums): old_elem = nums[i] new_elem = nums[i + k] window.remove(old_elem) bisect.insort(window, new_elem) return medians"},{"question":"# String Compression You are part of a data compression team tasked with optimizing storage for user-generated content on a social media platform. Your goal is to implement a simple lossless compression algorithm that reduces the size of a string by encoding sequences of repeated characters. Your task is to implement a function `compress_string(s: str) -> str` that compresses a given string using the following rules: - Consecutive occurrences of the same character are replaced by the character followed by the number of occurrences. - If the compressed string is not smaller than the original string, return the original string. **Function Signature:** ```python def compress_string(s: str) -> str: pass ``` **Input:** - `s`: A string containing only lowercase alphabetical characters. The length of the string is between 0 and 1,000. **Output:** - A compressed version of the input string, or the original string if the compressed version is not smaller. **Constraints:** - The input string length will range from 0 to 1,000. - The input string will only contain lowercase alphabetical characters. **Example:** ```python # Example 1 s = \\"aaabbcccc\\" # \\"aaabbcccc\\" can be compressed to \\"a3b2c4\\" assert compress_string(s) == \\"a3b2c4\\" # Example 2 s = \\"abcd\\" # \\"abcd\\" cannot be compressed further as its compressed form would be \\"a1b1c1d1\\" which is longer assert compress_string(s) == \\"abcd\\" # Example 3 s = \\"aabcccccaaa\\" # \\"aabcccccaaa\\" can be compressed to \\"a2b1c5a3\\" assert compress_string(s) == \\"a2b1c5a3\\" # Example 4 s = \\"\\" # An empty string should be returned as is assert compress_string(s) == \\"\\" ``` **Notes:** - Make sure to handle edge cases including strings with no repeated characters and very short strings. - Ensure your implementation is efficient and considers the possibility that compression might not always reduce the size.","solution":"def compress_string(s: str) -> str: if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(s[i-1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_str = \'\'.join(compressed) return compressed_str if len(compressed_str) < len(s) else s"},{"question":"# Coding Question: **Scenario:** You are creating a lightweight data compressor that uses Run-Length Encoding (RLE) to compress a string by summarizing consecutive repeated characters with a single character and the number of repetitions. **Task:** Write a function `run_length_encode` that takes a string and returns its run-length encoded version. **Function Signature:** ```python def run_length_encode(input_string: str) -> str: pass ``` **Parameters:** * `input_string` (str): A string containing the text to be encoded. **Returns:** * str: The run-length encoded string. **Algorithm:** - Traverse the input string while checking consecutive characters. - For each sequence of the same character, append the character followed by the number of repetitions to the result. **Example:** ```python input_string = \\"aaabbccdeee\\" assert run_length_encode(input_string) == \\"a3b2c2d1e3\\" input_string = \\"aabcccccaaa\\" assert run_length_encode(input_string) == \\"a2b1c5a3\\" ``` **Constraints:** * The input string will only contain uppercase and lowercase English letters. * The length of the input string will not exceed 10⁶ characters. * Ensure your function handles edge cases, including those with no repetitions and single-character strings. * Do not use any external libraries. * Optimize for both time and space complexity. **Performance Requirements:** Your implementation should be efficient, particularly in handling larger input strings.","solution":"def run_length_encode(input_string: str) -> str: if not input_string: return \\"\\" encoded_string = [] count = 1 previous_char = input_string[0] for i in range(1, len(input_string)): current_char = input_string[i] if current_char == previous_char: count += 1 else: encoded_string.append(f\\"{previous_char}{count}\\") previous_char = current_char count = 1 # Adding the last run encoded_string.append(f\\"{previous_char}{count}\\") return \'\'.join(encoded_string)"},{"question":"# Coding Assessment Question Context Factorials are a fundamental concept in mathematics, often used in permutations, combinations, and other areas of discrete mathematics and number theory. The factorial of a non-negative integer ( n ), denoted by ( n! ), is the product of all positive integers less than or equal to ( n ). The factorial of 0 is defined to be 1. The nth Catalan number ( C_n ) is an important sequence of natural numbers that occur in various counting problems, often involving recursively-defined objects. The nth Catalan number can be expressed in terms of factorials as: [ C_n = frac{(2n)!}{(n+1)!n!} ] Where: - ( C_n ) is the nth Catalan number. - ( n ) is the non-negative integer representing the position in the Catalan sequence. Problem Statement Write a Python function `generate_catalan_numbers(n: int) -> list[int]` that returns a list of the first `n` Catalan numbers. Your function should handle invalid inputs properly. # Constraints * The input `n` will be a non-negative integer (0 ≤ n ≤ 500). # Expected Function Signature ```python def generate_catalan_numbers(n: int) -> list[int]: ``` # Input * An integer `n` representing the number of Catalan numbers to be generated. # Output * List of integers representing the first `n` Catalan numbers. # Example ```python print(generate_catalan_numbers(10)) # Output: [1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862] print(generate_catalan_numbers(5)) # Output: [1, 1, 2, 5, 14] print(generate_catalan_numbers(1)) # Output: [1] print(generate_catalan_numbers(0)) # Output: [] ``` # Constraints 1. The function should return an empty list if the input is zero. 2. The function should raise a `ValueError` with the message \\"Input must be a non-negative integer.\\" if the input is a negative value. 3. The function should be efficient enough to compute up to the 500th Catalan number within a reasonable time frame. Additional Notes * Validate the input to ensure it is a non-negative integer. * Utilize efficient computation techniques to handle large values within limits of time and space.","solution":"def generate_catalan_numbers(n: int) -> list[int]: Generate the first n Catalan numbers. Args: n (int): The number of Catalan numbers to generate. Returns: list[int]: A list of the first n Catalan numbers. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return [] catalan_numbers = [1] # The very first Catalan number, C0 is 1 for i in range(1, n): next_catalan = (catalan_numbers[-1] * 2 * (2 * i - 1)) // (i + 1) catalan_numbers.append(next_catalan) return catalan_numbers"},{"question":"# Dynamic Programming Challenge: Fisherman\'s Profit Objective Given a list of profit values for a series of fishing spots along a linear river bank, write a function to find the maximum profit a fisherman can earn. The fisherman cannot fish in two adjacent spots to allow the fish population to recover and avoid detection. Description You are given a list of integers where each integer represents the profit from fishing at that particular spot. Your task is to implement a function that maximizes the total profit while ensuring that no two adjacent spots are chosen. Function Signature ```python def max_fishermans_profit(profits: List[int]) -> int: pass ``` Input * `profits` (List[int]): A list of integers representing the profit values. The list can contain up to 10^5 elements. Output * Returns an integer representing the maximum possible profit a fisherman can earn. Constraints * The list may contain both negative and positive integers. * Optimize to handle up to 10^5 elements efficiently using a dynamic programming approach. Examples ```python >>> max_fishermans_profit([3, 2, 5, 10, 7]) 15 # Choose spots 1 and 4 for profits 3 and 10. >>> max_fishermans_profit([3]) 3 # Only one spot available. >>> max_fishermans_profit([0, 0, 0]) 0 # No profits from any spots. >>> max_fishermans_profit([-1, -2, -3, -4]) 0 # Avoid all spots since all profits are negative. >>> max_fishermans_profit([10, -1, -1, 10, -1, -1, 10]) 30 # Choose spots 1, 4, and 7 for profits 10, 10, and 10. ``` Explanation * Use dynamic programming to store maximum profit up to each spot without selecting adjacent spots. * Define `dp[i]` as the maximum profit obtainable considering up to and including spot `i`. * Update `dp[i]` by choosing the best of either taking the previous spot\'s profit or including the current spot\'s profit plus the profit up to two spots back. * The result is the maximum value in the `dp` array.","solution":"from typing import List def max_fishermans_profit(profits: List[int]) -> int: if len(profits) == 0: return 0 if len(profits) == 1: return max(0, profits[0]) n = len(profits) dp = [0] * n dp[0] = max(0, profits[0]) if n > 1: dp[1] = max(dp[0], profits[1]) for i in range(2, n): dp[i] = max(dp[i-1], profits[i] + dp[i-2]) return dp[-1]"},{"question":"# Coding Assessment: Matrix Multiplication Context You are asked to implement a function to perform matrix multiplication on two matrices. Matrix multiplication is defined such that if (A) is an (M times N) matrix and (B) is an (N times P) matrix, the result (C) is an (M times P) matrix given by: [ C[i][j] = sum_{k=1}^{N} A[i][k] cdot B[k][j] ] Problem Description Implement the function `matrix_multiply(A: list[list[int]], B: list[list[int]]) -> list[list[int]]` that takes two matrices (A) and (B) as inputs and returns their product matrix (C). Input - `A`: An (M times N) matrix represented as a list of lists of integers. - `B`: An (N times P) matrix represented as a list of lists of integers. Output - The resulting (M times P) matrix (C) represented as a list of lists of integers. Constraints - Validate that the inner dimensions of the matrices agree (i.e., the number of columns in (A) is equal to the number of rows in (B)). If not, raise a ValueError with message \\"Matrices cannot be multiplied. Dimension mismatch.\\" - Assume the dimensions of matrices (A) and (B) will always be such that they can be multiplied if the dimensions agree. Examples ```python >>> matrix_multiply([[1, 2], [3, 4]], [[5, 6], [7, 8]]) [[19, 22], [43, 50]] >>> matrix_multiply([[2, 3], [4, 5], [6, 7]], [[1, 2, 3], [4, 5, 6]]) [[14, 19, 24], [24, 33, 42], [34, 47, 60]] >>> matrix_multiply([[1, 2, 3]], [[4], [5], [6]]) [[32]] >>> matrix_multiply([[1, 2]], [[3, 4], [5, 6], [7, 8]]) Traceback (most recent call last): ... ValueError: Matrices cannot be multiplied. Dimension mismatch. ```","solution":"def matrix_multiply(A, B): # Validate dimensions if len(A[0]) != len(B): raise ValueError(\\"Matrices cannot be multiplied. Dimension mismatch.\\") # Prepare result matrix with zeros result = [[0] * len(B[0]) for _ in range(len(A))] # Perform matrix multiplication for i in range(len(A)): for j in range(len(B[0])): for k in range(len(B)): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"# Second Most Frequent Element You are given a list of integers. Your task is to write a function that returns the second most frequent element in the list. If there are multiple elements with the same frequency, return the smallest one among them. If there is no such element, return `None`. Implement the function `find_second_most_frequent` that takes a list of integers as input and returns the second most frequent element. Function Signature ```python def find_second_most_frequent(nums: List[int]) -> int: pass ``` Input - `nums`: A list of integers. Output - An integer representing the second most frequent element, or `None` if no such element exists. Constraints - The number of integers in the list is in the range [1, 10^5]. - `-10^4 <= nums[i] <= 10^4` for any integer `nums[i]` in the list. Performance Requirements - The solution should run efficiently for large lists up to 10^5 elements. Example Given the following list: ```python nums = [1, 3, 3, 2, 2, 2, 5, 5, 5, 5] ``` Calling `find_second_most_frequent(nums)` should return `2` because `2` is the second most frequent element after `5`. Additional Information Use any standard libraries or data structures you need to accomplish the task efficiently. Focus on finding an optimal solution that works within the given constraints.","solution":"from typing import List, Optional from collections import Counter def find_second_most_frequent(nums: List[int]) -> Optional[int]: Returns the second most frequent element in the list. If there are multiple elements with the same frequency, return the smallest one among them. If no such element, return None. if not nums: return None frequency = Counter(nums) # Get the list of most common elements (element, count) sorted first by frequency then by value common = sorted(frequency.items(), key=lambda x: (-x[1], x[0])) if len(common) < 2: return None return common[1][0]"},{"question":"# Problem Statement Given a binary tree, implement a function to convert the binary tree to its mirror tree. The mirror of a binary tree is another binary tree with left and right children of all non-leaf nodes interchanged. You need to modify the tree in place. # Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mirror_tree(root: TreeNode) -> None: Convert the given binary tree to its mirror in place. Parameters: root (TreeNode): The root of the binary tree. Returns: None Example: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> mirror_tree(root) >>> print(root.left.val) # Output should be 3 3 >>> print(root.right.val) # Output should be 2 2 >>> print(root.right.left.val) # Output should be 5 5 >>> print(root.right.right.val) # Output should be 4 4 ``` # Constraints * The binary tree node values are not constrained by any values and could be any integer. * The binary tree might be empty (i.e., root can be None). * Your implementation should modify the tree in place. * Ensure your solution handles trees with maximally unbalanced structure. # Example Input ```python root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) ``` # Example Output ```python # After calling mirror_tree(root), the tree should be: root.val # 1 root.left # 3 root.right # 2 root.right.left # 5 root.right.right # 4 ``` # Performance Requirements * Your solution should handle binary trees of height up to 1000 efficiently. * Depth-first traversal methods may be used to ensure a space complexity of O(h), where h is the height of the tree. * Ensure correctness by thorough testing with assorted tree structures.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mirror_tree(root: TreeNode) -> None: Convert the given binary tree to its mirror in place. Parameters: root (TreeNode): The root of the binary tree. Returns: None if root is None: return # Swap the left and right children root.left, root.right = root.right, root.left # Recursively mirror the left and right subtrees mirror_tree(root.left) mirror_tree(root.right)"},{"question":"# Validate JSON Structure You are required to implement a function that validates the structure of a nested JSON object against a given schema. The schema specifies expected types and nested structures. Your function should traverse the JSON object recursively to verify that it conforms to the schema. Specifically, you need to: 1. Implement the `validate_json_structure` function that takes a JSON object and a schema. 2. Ensure that the function verifies each key in the JSON object matches the type specified in the schema and has the correct nested structures. 3. Handle nested objects and arrays, ensuring their elements are of the correct type and structure. Your function should: - Return `True` if the JSON object matches the schema. - Return `False` otherwise. # Input - A JSON object containing nested dictionaries and arrays. - A schema defined as a dictionary where values are types or nested schemas. - Constraints: - The JSON object may have a maximum depth of 10. - Types include `str`, `int`, `float`, `bool`, `None`, `dict`, `list`. # Output - A boolean indicating whether the JSON object matches the schema. # Example ```python json_obj = { \\"name\\": \\"John Doe\\", \\"age\\": 30, \\"address\\": { \\"street\\": \\"123 Main St\\", \\"city\\": \\"Anytown\\", \\"postal_code\\": \\"12345\\" }, \\"phone_numbers\\": [ {\\"type\\": \\"home\\", \\"number\\": \\"555-5555\\"}, {\\"type\\": \\"work\\", \\"number\\": \\"555-1234\\"} ] } schema = { \\"name\\": str, \\"age\\": int, \\"address\\": { \\"street\\": str, \\"city\\": str, \\"postal_code\\": str }, \\"phone_numbers\\": [ {\\"type\\": str, \\"number\\": str} ] } result = validate_json_structure(json_obj, schema) print(result) # Output: True ``` # Signature ```python def validate_json_structure(json_obj: dict, schema: dict) -> bool: ```","solution":"def validate_json_structure(json_obj, schema): Validates the JSON object against the schema recursively. if isinstance(schema, dict): if not isinstance(json_obj, dict): return False for key, subschema in schema.items(): if key not in json_obj or not validate_json_structure(json_obj[key], subschema): return False elif isinstance(schema, list): if not isinstance(json_obj, list): return False if len(schema) != 1: return False subschema = schema[0] return all(validate_json_structure(item, subschema) for item in json_obj) else: return isinstance(json_obj, schema) return True"},{"question":"# Question: Simulate Bank Account Transactions Design a class `BankAccount` that simulates basic transactions in a bank account. The `BankAccount` class should support the following operations: 1. Creating a new account with an initial balance. 2. Depositing a specified amount. 3. Withdrawing a specified amount. 4. Checking the current balance. # Class Signature ```python class BankAccount: def __init__(self, initial_balance: float): pass def deposit(self, amount: float) -> None: pass def withdraw(self, amount: float) -> None: pass def get_balance(self) -> float: pass ``` # Instructions 1. **Constructor (`__init__` method)** - Takes an initial balance and initializes the account balance. The initial balance must be a non-negative value. 2. **Deposit (`deposit` method)** - Takes an `amount` to be deposited and adds it to the account balance. The deposit amount must be a positive value. 3. **Withdraw (`withdraw` method)** - Takes an `amount` to be withdrawn from the account. The withdrawal amount must be positive and must not exceed the current balance. If the amount exceeds the balance, raise a `ValueError` indicating insufficient funds. 4. **Get Balance (`get_balance` method)** - Returns the current balance of the account. # Constraints - `initial_balance` >= 0.0 - `amount` > 0.0 # Example ```python >>> account = BankAccount(initial_balance=1000.0) >>> account.deposit(500.0) >>> account.get_balance() 1500.0 >>> account.withdraw(200.0) >>> account.get_balance() 1300.0 >>> account.withdraw(2000.0) ValueError: Insufficient funds ``` # Notes - Properly handle edge cases and invalid inputs by raising an appropriate exception (`ValueError`). - Ensure that the balance is always non-negative. - Provide comprehensive test cases to validate your implementation. This question ensures that you can handle the essential operations of a bank account in an object-oriented programming context.","solution":"class BankAccount: def __init__(self, initial_balance: float): if initial_balance < 0: raise ValueError(\\"Initial balance must be non-negative.\\") self.balance = initial_balance def deposit(self, amount: float) -> None: if amount <= 0: raise ValueError(\\"Deposit amount must be positive.\\") self.balance += amount def withdraw(self, amount: float) -> None: if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive.\\") if amount > self.balance: raise ValueError(\\"Insufficient funds.\\") self.balance -= amount def get_balance(self) -> float: return self.balance"},{"question":"# Problem Statement You are tasked with creating a function that sums all prime-indexed elements of an integer array. Prime indices refer to positions in the array that are prime numbers. Your function should take a list of integers and return the sum of the elements at those prime indices. # Requirements 1. Implement the function `sum_of_prime_indices(elements)`. - Input: List of integers. - Output: Integer representing the sum of elements located at prime indices. # Function Signature ```python def sum_of_prime_indices(elements): pass ``` # Constraints * Elements list should have a length \\"n\\" where (1 leq n leq 10^4). * List elements will be integers ranging from ( -10^5 ) to ( 10^5 ). # Example Usages ```python elements = [10, 20, 30, 40, 50, 60] print(sum_of_prime_indices(elements)) # Output: 90 (elements at indices 2, 3, 5 are 30, 40, 60) elements = [5, 15, 25, 35] print(sum_of_prime_indices(elements)) # Output: 60 (elements at indices 2, 3 are 25, 35) elements = [1] print(sum_of_prime_indices(elements)) # Output: 0 (no prime indices) elements = [2, 3, 5, 7, 11, 13, 17] print(sum_of_prime_indices(elements)) # Output: 41 (elements at indices 2, 3, 5 are 5, 7, 13) ``` # Notes * Consider the first element of the array to be at index 0. * Prime indices start from the number 2. * Ensure your solution is efficient and can handle the upper constraint of the list size. * If there are no prime indices within the list length, return 0.","solution":"def is_prime(n): Helper function to check if a number is prime. if n < 2: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def sum_of_prime_indices(elements): Function to sum all elements in the list that are at prime indices. Args: elements (list of int): List of integers to process. Returns: int: Sum of elements at prime indices. return sum(elements[i] for i in range(len(elements)) if is_prime(i))"},{"question":"You are given a list of integers where each element represents the height of a cliff above sea level. You need to identify the longest sequence of consecutive cliffs (a subarray) where every cliff in the sequence is taller than the previous one. Write a function called `longest_increasing_cliffs(heights: List[int]) -> int` which takes a list of integers representing the heights of cliffs and returns the length of the longest strictly increasing sequence of cliff heights. # Input Format - A list of integers `heights` where each integer represents the height of a cliff. # Output Format - Return an integer representing the length of the longest strictly increasing sequence of cliff heights. # Constraints - The list `heights` will have at least one element and at most 100,000 elements. - Each height will be a positive integer less than or equal to 10,000. # Example ```python def test_longest_increasing_cliffs(): assert longest_increasing_cliffs([1, 2, 3, 2, 4, 5, 6, 3, 4]) == 4 assert longest_increasing_cliffs([5, 10, 20, 4, 5, 6, 7, 8, 12]) == 6 assert longest_increasing_cliffs([10, 9, 8, 7, 5, 4, 3, 2, 1]) == 1 test_longest_increasing_cliffs() ``` # Performance Requirements * The function should efficiently handle lists up to 100,000 elements, achieving a solution with linear or near-linear time complexity.","solution":"from typing import List def longest_increasing_cliffs(heights: List[int]) -> int: Returns the length of the longest strictly increasing sequence of cliff heights. if not heights: return 0 max_length = 1 current_length = 1 for i in range(1, len(heights)): if heights[i] > heights[i-1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"# Question: Find the Missing Number in an Array Using XOR Problem Statement You are given an array containing `n - 1` unique numbers taken from the range `0` to `n - 1` (inclusive). This means that exactly one number is missing from the array. Your task is to write a function that finds and returns the missing number using XOR operations for optimal performance. Requirements: 1. Create a function named `find_missing_number`: ```python def find_missing_number(arr: list[int]) -> int: ... ``` 2. The function should find and return the missing number using XOR operations. 3. The function must handle any non-empty array that follows the input constraints. Input: - A list of integers `arr` of length `n-1` containing unique numbers from the range 0 to `n-1`. Output: - An integer representing the missing number in the array. Example: ```python assert find_missing_number([0, 1, 3, 4]) == 2 assert find_missing_number([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 0 assert find_missing_number([0, 2]) == 1 assert find_missing_number([3, 0, 1]) == 2 assert find_missing_number([0]) == 1 ``` Constraints: - The input list `arr` is guaranteed to contain `n-1` unique numbers from the range `0` to `n-1`, where `1 <= n <= 10^5`. Notes: - Efficiency is key; therefore, your implementation should aim for an optimal solution using XOR operations. - Ensure your code is clear and well-documented. - Pay attention to edge cases within the given constraints.","solution":"def find_missing_number(arr: list[int]) -> int: This function takes in an array of integers containing n-1 unique numbers from the range 0 to n-1, and returns the missing number using XOR operations. n = len(arr) + 1 # XOR all numbers from 0 to n-1 including n itself xor_all = 0 for i in range(n): xor_all ^= i # XOR all values in the array xor_arr = 0 for num in arr: xor_arr ^= num # The missing number will be the result of xor_all ^ xor_arr return xor_all ^ xor_arr"},{"question":"# Longest Common Subsequence You have been asked to solve a classical dynamic programming problem. Problem Statement Given two sequences, find the length of the longest subsequence present in both of them. Your task is to implement the function `longest_common_subsequence(seq1, seq2)` which computes the length of the longest common subsequence using dynamic programming. Function Signature ```python def longest_common_subsequence(seq1: str, seq2: str) -> int: pass ``` Input * Two sequences `seq1` and `seq2` where `1 <= len(seq1), len(seq2) <= 1000`. Output * An integer representing the length of the longest common subsequence. Constraints 1. The function must handle sequences of various characters. 2. The function should scale efficiently with the size of input sequences. Example ```python assert longest_common_subsequence(\\"abcde\\", \\"ace\\") == 3 assert longest_common_subsequence(\\"abc\\", \\"abc\\") == 3 assert longest_common_subsequence(\\"abc\\", \\"def\\") == 0 assert longest_common_subsequence(\\"xzyabc\\", \\"yabc\\") == 4 assert longest_common_subsequence(\\"longestsubsequence\\", \\"sequence\\") == 8 ``` Performance Requirements Your solution should ideally run with a time complexity of O(m * n) and use O(m * n) space, where `m` is the length of `seq1` and `n` is the length of `seq2`.","solution":"def longest_common_subsequence(seq1: str, seq2: str) -> int: Returns the length of the longest common subsequence of seq1 and seq2. m, n = len(seq1), len(seq2) # Create a 2D array to store lengths of longest common subsequence. # dp[i][j] will hold the length of LCS of seq1[0..i-1] and seq2[0..j-1]. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array from bottom up for i in range(1, m + 1): for j in range(1, n + 1): if seq1[i - 1] == seq2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"# Matrix Inversion using Gaussian Elimination Context In linear algebra, finding the inverse of a square matrix (A) is a common operation, utilizing it in solving linear systems and various applications. Gaussian elimination is a practical method to achieve this by converting the matrix into its reduced row echelon form. Objective Write a function `invert_matrix(matrix)` that takes a 2D list representing a square matrix (A) as input, and returns a 2D list representing the inverse of the matrix (A). You must implement the inversion using the Gaussian elimination method. Input - A 2D list `matrix` containing (n times n) elements, where (2 leq n leq 50). - Each element in the matrix is a float. - The input matrix is guaranteed to be invertible. Output - A 2D list representing the inverted matrix, which has the same dimensions as the input matrix. Example ```python matrix = [ [4, 7], [2, 6] ] inverse_matrix = invert_matrix(matrix) # inverse_matrix will be the inverted matrix of similar dimensions ``` Constraints 1. Do not use any external libraries except for basic mathematical operations. 2. Ensure the result is accurate to at least 5 decimal places. 3. Handle edge cases gracefully, such as very small or very large numbers. 4. Your function should terminate within a reasonable time for given constraints.","solution":"def invert_matrix(matrix): Returns the inverse of a given square matrix using Gaussian elimination. n = len(matrix) # Create an identity matrix of size n identity_matrix = [[float(i == j) for i in range(n)] for j in range(n)] # Append the identity matrix to the original matrix for i in range(n): matrix[i] += identity_matrix[i] # Perform Gaussian elimination for i in range(n): # Find the pivot and swap rows if necessary to make the pivot non-zero for j in range(i, n): if matrix[j][i] != 0: matrix[i], matrix[j] = matrix[j], matrix[i] break # Normalize the pivot row pivot = matrix[i][i] if pivot == 0: raise ValueError(\\"Matrix is not invertible\\") for j in range(2*n): matrix[i][j] /= pivot # Eliminate the column for k in range(n): if k != i: factor = matrix[k][i] for j in range(2*n): matrix[k][j] -= factor * matrix[i][j] # Extract the inverse matrix inverse_matrix = [row[n:] for row in matrix] return inverse_matrix"},{"question":"# Merge K Sorted Linked Lists You are required to write a Python function to merge k sorted linked lists and return it as one sorted linked list. Analyze the provided classes `ListNode` and `Solution`. Your task is to implement the following method within the `Solution` class: 1. **merge_k_lists(self, lists)**: This method accepts a list of k linked lists, each of which is sorted in ascending order. It should merge all the linked lists into one sorted linked list and return its head. You should solve this problem efficiently, preferably with a time complexity better than O(n*k^2), where n is the total number of nodes across all linked lists and k is the number of linked lists. **Input Format**: - `merge_k_lists(self, lists)` - a list of ListNode objects. **Output Format**: - Return a ListNode object which is the head of the merged sorted linked list. **Constraints**: - Each ListNode has an integer value. - The values in each linked list are sorted in ascending order. - The total number of nodes across all linked lists is at most 10^4. - The number of linked lists k is at most 10^2. **Example**: ```python # Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def merge_k_lists(self, lists): import heapq min_heap = [] for i, node in enumerate(lists): if node: heapq.heappush(min_heap, (node.val, i, node)) dummy = ListNode(0) current = dummy while min_heap: val, i, node = heapq.heappop(min_heap) current.next = node current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, i, node.next)) return dummy.next solution = Solution() # Create linked lists list1 = ListNode(1) list1.next = ListNode(4) list1.next.next = ListNode(5) list2 = ListNode(1) list2.next = ListNode(3) list2.next.next = ListNode(4) list3 = ListNode(2) list3.next = ListNode(6) lists = [list1, list2, list3] # Merge linked lists merged_head = solution.merge_k_lists(lists) # Print merged linked list current = merged_head while current: print(current.val, end=\\" \\") current = current.next # Output: 1 1 2 3 4 4 5 6 ``` Implement the `merge_k_lists` method in the `Solution` class to merge the provided k sorted linked lists into a single sorted linked list and ensure it runs efficiently.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def merge_k_lists(self, lists): import heapq min_heap = [] for i, node in enumerate(lists): if node: heapq.heappush(min_heap, (node.val, i, node)) dummy = ListNode(0) current = dummy while min_heap: val, i, node = heapq.heappop(min_heap) current.next = node current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, i, node.next)) return dummy.next"},{"question":"# Balanced String Check You are given a string containing only three types of characters: `\'(\'`, `\')\'`, and `\'*\'`. Your task is to write a function to check whether the given string can be considered valid. A string is considered valid if: - Any left parenthesis `\'(\'` must have a corresponding right parenthesis `\')\'`. - Any right parenthesis `\')\'` must have a corresponding left parenthesis `\'(\'`. - The character `\'*\'` can be treated as a single right parenthesis `\')\'` or a single left parenthesis `\'(\'` or an empty string. Write a function to determine if the string is valid. Input Format - `s`: A string consisting of the characters `\'(\'`, `\')\'`, and `\'*\'`. Output Format - Return `True` if the string is valid; otherwise, return `False`. Constraints - The length of the string will be between `1` and `100`. Example ```python s = \\"(*))\\" # True, the string can be considered as \\"()\\" which is valid s = \\"(*()\\" # True, the string can be considered as \\"()\\" which is valid s = \\"(*))(\\" # False, it is not possible to match all parenthesis # Implement the function def checkValidString(s): # Your code here # Test cases print(checkValidString(\\"(*)\\")) # True print(checkValidString(\\"(*()\\")) # True print(checkValidString(\\"(*)(\\")) # False ``` Your task is to implement the function `checkValidString` that checks if the string is valid or not. # Implementation ```python def checkValidString(s): # Your code here ```","solution":"def checkValidString(s): low = high = 0 for ch in s: if ch == \'(\': low += 1 high += 1 elif ch == \')\': if low > 0: low -= 1 high -= 1 else: # ch == \'*\' if low > 0: low -= 1 high += 1 if high < 0: return False return low == 0"},{"question":"# Question You need to design an algorithm for a basic text editor. This text editor should support the following operations: 1. **Insert**: Insert a given substring at a specified position in the current string. 2. **Delete**: Remove a substring from a specified position of a certain length. 3. **Undo**: Revert the last operation performed. Implement a class `TextEditor` with the following methods: Methods # `insert_text` * **Input**: A string `text` representing the substring to be inserted, and an integer `index` representing the position at which to insert the substring. * **Output**: None. Modify the internal state of the text editor. # `delete_text` * **Input**: An integer `index` representing the starting position, and an integer `length` representing the number of characters to delete starting from `index`. * **Output**: None. Modify the internal state of the text editor. # `undo` * **Input**: None. * **Output**: None. Revert the last operation (either insert or delete). # `get_text` * **Input**: None. * **Output**: A string representing the current state of the text editor. # Constraints * All input indices will be valid given the current state of the string. * The total number of operations will not exceed 10^5. * `text` will be a non-empty string with a maximum length of 10^4 characters. * The final string length will not exceed 10^6 characters. # Example ```python editor = TextEditor() # Initial state print(editor.get_text()) # Output: \\"\\" # Insert \\"hello\\" at index 0 editor.insert_text(\\"hello\\", 0) print(editor.get_text()) # Output: \\"hello\\" # Insert \\" world\\" at index 5 editor.insert_text(\\" world\\", 5) print(editor.get_text()) # Output: \\"hello world\\" # Delete 5 characters starting from index 5 editor.delete_text(5, 5) print(editor.get_text()) # Output: \\"hello\\" # Undo the last operation (deletion) editor.undo() print(editor.get_text()) # Output: \\"hello world\\" # Undo the last operation (insertion) editor.undo() print(editor.get_text()) # Output: \\"hello\\" # Undo the last operation (insertion) editor.undo() print(editor.get_text()) # Output: \\"\\" ``` Notes: * The undo operation should correctly revert the last change made by either `insert_text` or `delete_text`. * Ensure operations are performed efficiently to handle the constraints.","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.history = [] def insert_text(self, text, index): self.history.append((self.text, \'insert\')) self.text = self.text[:index] + text + self.text[index:] def delete_text(self, index, length): self.history.append((self.text, \'delete\')) self.text = self.text[:index] + self.text[index+length:] def undo(self): if self.history: self.text, _ = self.history.pop() def get_text(self): return self.text"},{"question":"# Coding Assessment Question: Problem Context: You are working on a data processing pipeline that involves filtering and transforming textual data. Specifically, you need an algorithm to extract specific patterns from lines of text and then format the extracted information in a structured way. Given a list of strings representing lines of text, you are to extract numerical data based on specific keywords and then organize the extracted data into a more readable format. Task: Write a function `extract_and_format(data: List[str]) -> Dict[str, List[int]]` that processes a given list of strings to extract numbers following certain keywords and formats them in a dictionary. Input: * A list of strings `data` representing lines of text. * Each line contains any number of words and numbers. * The keywords \\"Price:\\" and \\"Quantity:\\" followed by a number are guaranteed to appear in each line. Output: * A dictionary with keys as \\"Price\\" and \\"Quantity\\", and values as lists of integers extracted following the corresponding keywords. Constraints: * Ensure your solution processes each line correctly and handles any extraneous information. * Assume the input is well-formed and there are no missing keywords in any line. Example: ```python data = [ \\"Item A - Price: 10 Quantity: 5\\", \\"Item B - Price: 12 Quantity: 8\\", \\"Item C - Price: 5 Quantity: 3\\" ] extract_and_format(data) ``` This should return: ```python { \\"Price\\": [10, 12, 5], \\"Quantity\\": [5, 8, 3] } ``` Additional Notes: * Consider the use of regular expressions or string splitting techniques for extracting the numbers efficiently. * Pay attention to the accuracy of the parsed data and the order in which it is collated.","solution":"import re from typing import List, Dict def extract_and_format(data: List[str]) -> Dict[str, List[int]]: Extracts numerical values following keywords \\"Price:\\" and \\"Quantity:\\" from each line of text, and organizes them into a dictionary. price_pattern = re.compile(r\'Price:s*(d+)\') quantity_pattern = re.compile(r\'Quantity:s*(d+)\') prices = [] quantities = [] for line in data: price_match = price_pattern.search(line) quantity_match = quantity_pattern.search(line) if price_match and quantity_match: prices.append(int(price_match.group(1))) quantities.append(int(quantity_match.group(1))) return {\\"Price\\": prices, \\"Quantity\\": quantities}"},{"question":"# Matrix Transpose Challenge You need to write a function that takes a 2D matrix and returns its transpose. The transpose of a matrix is obtained by switching the rows and columns. **Function Signature**: ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: ``` **Input**: - A 2D list `matrix` containing integers, where each sublist represents a row. **Output**: - A 2D list representing the transposed matrix. **Constraints**: - The number of rows, `r`, and the number of columns, `c`, of the matrix can be up to 10^3. - Each element in the matrix will be an integer in the range [-10^9, 10^9]. **Performance Requirements**: - Aim for a solution that operates in O(rc) time complexity where `r` is the number of rows and `c` is the number of columns. **Scenario**: Imagine you are creating a data handling module for an analytics software, which requires datasets to be transposed for certain types of analysis. Your function needs to handle this transformation efficiently. **Example**: ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1]]) [[1]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] ``` Your task is to implement the `transpose_matrix` function as outlined above.","solution":"def transpose_matrix(matrix): Returns the transpose of the given 2D matrix. Parameters: matrix (List[List[int]]): A 2D list of integers representing the matrix. Returns: List[List[int]]: The transposed matrix. if not matrix or not matrix[0]: return [] rows = len(matrix) cols = len(matrix[0]) # Create an empty transposed matrix transposed = [[0] * rows for _ in range(cols)] # Fill the transposed matrix with values for r in range(rows): for c in range(cols): transposed[c][r] = matrix[r][c] return transposed"},{"question":"# Evaluate Arithmetic Expression You are required to implement a function to evaluate a simple arithmetic expression containing non-negative integers and the operators \'+\', \'-\', \'*\', and \'/\'. The expression will be provided as a string and may include spaces between numbers and operators. The operator \'/\' should perform integer division. **Input Format:** A single string `expression` representing the arithmetic expression to evaluate. **Output Format:** Return an integer representing the result of evaluating the expression. **Constraints:** 1. The expression will contain only non-negative integers and the operators \'+\', \'-\', \'*\', and \'/\'. 2. The expression will not contain parentheses. 3. Each operator and number will be separated by exactly one space. 4. The expression will be a valid arithmetic expression. **Performance Requirements:** The implementation should handle the expression evaluation efficiently with linear time complexity relative to the length of the input string. **Examples:** ```python evaluate_arithmetic_expression(\\"3 + 5\\") # 8 evaluate_arithmetic_expression(\\"10 + 2 * 6\\") # 22 evaluate_arithmetic_expression(\\"100 * 2 + 12\\") # 212 evaluate_arithmetic_expression(\\"100 * ( 2 + 12 ) / 14\\") # 100 evaluate_arithmetic_expression(\\"10 / 2\\") # 5 ``` **Function Signature:** ```python def evaluate_arithmetic_expression(expression: str) -> int: # Your code goes here pass ``` **Note:** The implementation should parse and evaluate the expression taking into account operator precedence (multiplication and division before addition and subtraction) and associativity (left to right for operators with the same precedence). Ensure to handle division results correctly as integers.","solution":"def evaluate_arithmetic_expression(expression: str) -> int: def apply_operator(operators, values): right = values.pop() left = values.pop() operator = operators.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(left // right) def precedence(operator): if operator in (\'+\', \'-\'): return 1 if operator in (\'*\', \'/\'): return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = val * 10 + int(expression[i]) i += 1 values.append(val) continue if expression[i] in \\"+-*/\\": while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"# Question: Extend the Robust Differentiation Function to Manage Complex Arithmetic You are tasked with enhancing the `GradientTracker` system to support complex arithmetic operations and ensure robust handling of edge cases, particularly involving zero or undefined values in complex calculations. Problem Statement Modify the `GradientTracker` class and `Variable` class to include functions for complex arithmetic operations while ensuring safe and accurate differentiation. Requirements 1. **Extend GradientTracker\'s Complex Derivative Function**: - Modify the derivative function to correctly compute the gradients for complex number operations. - Ensure that operations involving zero or undefined values are handled gracefully, returning NaN or predefined placeholder values as appropriate. 2. **Add Complex Arithmetic Operations to Variable**: - Implement functions for complex multiplication and division in the `Variable` class. - Ensure that division-by-zero and other complex edge cases are managed safely, returning predefined safe values. Input and Output - The extended functions should work within the existing framework of the `GradientTracker` and `Variable` classes, accepting complex numbers as inputs. - Outputs should include safe handling of operations that could result in undefined or NaN values. Constraints - Consider edge cases where variables can be zero or have undefined values. - Minimal changes should be made to avoid breaking existing functionalities. - Proper validation should be added to inform users of any unsafe attempted operations. Testing and Performance - Ensure that the extended functionality does not introduce significant performance degradation. - Add test cases to validate safe handling of complex arithmetic operations, including edge cases. Example ```python with GradientTracker() as tracker: a = Variable([2.0, 0.0+1j]) # Including a complex number for testing b = Variable([1.0, 2.0]) c = a * b gradient_a = tracker.gradient(c, a) # Should handle complex multiplication gradient_b = tracker.gradient(c, b) ``` Output: ```plaintext gradient_a: expected to handle and not produce Infinity or NaN gradient_b: expected to provide accurate gradients associated with complex calculations ``` Implement the solution and validate it using test cases that cover both complex arithmetic and the handling of zero or undefined values to ensure robust differentiation.","solution":"import numpy as np class Variable: def __init__(self, value, name=None): self.value = np.array(value, dtype=complex) self.name = name def __add__(self, other): return Variable(self.value + (other.value if isinstance(other, Variable) else other)) def __sub__(self, other): return Variable(self.value - (other.value if isinstance(other, Variable) else other)) def __mul__(self, other): return Variable(self.value * (other.value if isinstance(other, Variable) else other)) def __truediv__(self, other): if isinstance(other, Variable): if np.any(other.value == 0): return Variable(np.full(self.value.shape, np.nan + 1j*np.nan)) return Variable(self.value / other.value) else: if other == 0: return Variable(np.full(self.value.shape, np.nan + 1j*np.nan)) return Variable(self.value / other) def __repr__(self): return f\\"Variable(value={self.value}, name={self.name})\\" class GradientTracker: def gradient(self, output, input_var): Compute the gradient of `output` with respect to `input_var`. This is a stub implementation and should be extended based on your need. if np.any(np.isnan(input_var.value)): return Variable(np.full(input_var.value.shape, np.nan + 1j*np.nan)) if np.any(np.isnan(output.value)): return Variable(np.full(input_var.value.shape, np.nan + 1j*np.nan)) # Basic example: Assuming output = input_var^2, gradient would be 2 * input_var gradient_value = 2 * input_var.value return Variable(gradient_value) def __enter__(self): return self def __exit__(self, exc_type, exc_val, exc_tb): pass # Test the implementation if __name__ == \\"__main__\\": with GradientTracker() as tracker: a = Variable([2.0, 0.0 + 1j], name=\\"a\\") b = Variable([1.0, 0.0], name=\\"b\\") c = a / b grad_a = tracker.gradient(c, a) grad_b = tracker.gradient(c, b) print(f\\"c: {c}\\") print(f\\"gradient with respect to a: {grad_a}\\") print(f\\"gradient with respect to b: {grad_b}\\")"},{"question":"# Prim\'s Algorithm for Minimum Spanning Tree Problem Statement Implement Prim\'s Algorithm to find the Minimum Spanning Tree (MST) of a given undirected graph represented as an adjacency matrix. Function Signature ```python def prims_algorithm(adjacency_matrix: List[List[int]]) -> int: Finds the weight of the Minimum Spanning Tree (MST) of an undirected graph using Prim\'s Algorithm. :param adjacency_matrix: A 2D list where adjacency_matrix[i][j] represents the weight of the edge between node i and node j. A value of 0 indicates no direct edge between nodes i and j. :return: The total weight of the edges in the Minimum Spanning Tree. ``` Input - `adjacency_matrix`: A 2D list where each element `adjacency_matrix[i][j]` is an integer representing the edge weight between node `i` and node `j`. A zero indicates no direct edge between those nodes. Output - The function should return an integer representing the total weight of the Minimum Spanning Tree. Constraints - The adjacency matrix is a square matrix with sizes ranging from ( 2 times 2 ) to ( 50 times 50 ). - All the weights are non-negative integers, and a 0 indicates no edge, except the diagonal which is always 0. Requirements - Efficiently handle the graph using appropriate data structures. - Ensure that the algorithm correctly identifies the MST even in graphs with multiple components by starting from node 0. Example ```python from typing import List def main(): adjacency_matrix = [ [0, 2, 0, 6, 0], [2, 0, 3, 8, 5], [0, 3, 0, 0, 7], [6, 8, 0, 0, 9], [0, 5, 7, 9, 0] ] result = prims_algorithm(adjacency_matrix) print(result) # Output should be 16 if __name__ == \\"__main__\\": main() ``` Clarifications - The graph is assumed to be connected. However, if the provided graph is not connected, the function should consider only the connected components. - The diagonal of the adjacency matrix represents no self-loops and should always be 0. - Ensure the function handles cases where the adjacency matrix is not properly formatted, like when it\'s not a square matrix, by raising appropriate exceptions. Implement the `prims_algorithm` function according to the above specifications.","solution":"from typing import List def prims_algorithm(adjacency_matrix: List[List[int]]) -> int: import heapq n = len(adjacency_matrix) if any(len(row) != n for row in adjacency_matrix): raise ValueError(\\"Adjacency matrix must be square.\\") visited = [False] * n min_heap = [(0, 0)] # (cost, vertex) total_weight = 0 while min_heap: weight, u = heapq.heappop(min_heap) if visited[u]: continue visited[u] = True total_weight += weight for v, cost in enumerate(adjacency_matrix[u]): if cost != 0 and not visited[v]: heapq.heappush(min_heap, (cost, v)) if not all(visited): raise ValueError(\\"The graph is not connected.\\") return total_weight"},{"question":"Coding Assessment Question # Scenario: You are working on processing different lists of integers for a data analytics application. One of the crucial operations you need to perform frequently involves merging two sorted lists into a single sorted list, ensuring the final list maintains the order. # Task: Implement a function `merge_sorted_lists` that takes two sorted lists and merges them into a single sorted list. Your function should handle large inputs efficiently and maintain the sorted order of elements in the final list. # Requirements: 1. Implement the function `merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]`. 2. Ensure that your function is optimized for performance, considering the input constraints. 3. Your function should properly handle edge cases like empty lists and lists with duplicate elements. # Input Format: - Two sorted lists of integers, `list1` and `list2`. # Output Format: - A single sorted list containing all elements from `list1` and `list2`. # Constraints: - The total number of elements (n leq 10^5). - Each integer can be in the range (-10^9 ) to ( 10^9 ). - Optimal performance is required, considering the constraints. # Example: ```python # Example usage list1 = [1, 3, 5, 7] list2 = [2, 4, 6, 8] print(merge_sorted_lists(list1, list2)) # Output: [1, 2, 3, 4, 5, 6, 7, 8] ``` # Implementation: ```python from typing import List def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list ``` # Explanation: - **Input**: Two sorted lists of integers (`list1`, `list2`). - **Process**: Merge the two lists by comparing elements and maintaining the sorted order. - **Output**: A single sorted list containing all elements from both input lists.","solution":"from typing import List def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into a single sorted list. Parameters: list1 (List[int]): First sorted list of integers. list2 (List[int]): Second sorted list of integers. Returns: List[int]: A single merged and sorted list containing all elements from list1 and list2. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Scenario In a software application, a common task is to compress text for efficient storage and transmission. One simple form of text compression is Run-Length Encoding (RLE), where consecutive duplicate characters are replaced by the character followed by its count. # Task Write a function `rle_encode(s: str) -> str` that compresses a string `s` using Run-Length Encoding. # Function Signature ```python def rle_encode(s: str) -> str: ``` # Expected Input and Output - **Input**: A string `s` containing any printable ASCII characters. - **Output**: A string representing the Run-Length Encoded version of the input string. # Constraints - The length of the string `s` is between `0` and `10^5`. - If a character appears once, it should be followed by the number `1`. - The output string should be as short as possible. # Performance Requirements - The function should run in `O(n)` time complexity where `n` is the length of the input string. - The space complexity should be `O(n)`. # Examples ```python assert rle_encode(\\"aaabbbcc\\") == \\"a3b3c2\\" assert rle_encode(\\"abcd\\") == \\"a1b1c1d1\\" assert rle_encode(\\"\\") == \\"\\" assert rle_encode(\\"aaa\\") == \\"a3\\" assert rle_encode(\\"aaabbbaaac\\") == \\"a3b3a3c1\\" ``` # Notes - Implement the function such that it handles edge cases like empty strings and strings with no repeating characters. - Consider the optimal case where the output is significantly shorter than the input if the input contains many long sequences of the same character. This question assesses the ability to understand and implement simple string manipulation algorithms, while also testing the efficiency in terms of both time and space.","solution":"def rle_encode(s: str) -> str: if not s: return \\"\\" encoded_string = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: encoded_string.append(f\\"{s[i-1]}{count}\\") count = 1 # Append the last character and its count encoded_string.append(f\\"{s[-1]}{count}\\") return \'\'.join(encoded_string)"},{"question":"Path Sum in Binary Tree You are working on developing a feature for a path-finding application which includes identifying potential paths in a user\'s journey. One aspect of this is analyzing paths within a binary tree to determine if they sum to a target value. Write a function `has_path_sum` that takes a binary tree and an integer `sum`, and returns `True` if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum, `False` otherwise. # Input: - A binary tree `root` where each node contains an integer value. - An integer `sum` indicating the target sum to be checked for a root-to-leaf path. # Output: - A boolean value `True` if there is at least one root-to-leaf path in the binary tree whose sum of node values equals the given target sum. Otherwise, return `False`. # Constraints: - The number of nodes in the tree will not exceed `5000`. - Each node\'s value is an integer that can be positive, negative, or zero. - `-10^5 <= Node Value <= 10^5`. # Example: ```python # Example Binary Tree: # 5 # / # 4 8 # / / # 11 13 4 # / # 7 2 1 >>> tree = TreeNode(5) >>> tree.left = TreeNode(4) >>> tree.right = TreeNode(8) >>> tree.left.left = TreeNode(11) >>> tree.left.left.left = TreeNode(7) >>> tree.left.left.right = TreeNode(2) >>> tree.right.left = TreeNode(13) >>> tree.right.right = TreeNode(4) >>> tree.right.right.right = TreeNode(1) >>> has_path_sum(tree, 22) True >>> has_path_sum(tree, 26) True >>> has_path_sum(tree, 18) False ``` # Performance: Aim for a solution that checks the path sums in O(n) time complexity, where n is the number of nodes in the tree. # Note: A root-to-leaf path implies the path must start at the root and end at one of the leaf nodes (nodes with no children).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root, target_sum): if not root: return False target_sum -= root.val if not root.left and not root.right: # if it\'s a leaf node return target_sum == 0 return has_path_sum(root.left, target_sum) or has_path_sum(root.right, target_sum)"},{"question":"# Understanding of String Manipulation and Data Structures in Python Objective Design an efficient solution to manipulate and process a large string with specific pattern replacements. Task Write a class `StringProcessor` that provides various string manipulation functionalities. Implement the following methods: 1. **Replace Characters**: Replace every occurrence of a character with another character. 2. **Find Longest Substring Without Repeating Characters**: Return the length of the longest substring without repeating characters. 3. **Reverse Words in a String**: Reverse the words in a given string, maintaining the order of characters within each word. Requirements - Ensure proper handling of edge cases such as null inputs, empty strings, and strings with no spaces. - Your methods should follow these signatures: ```python class StringProcessor: def __init__(self, initial_string: str): pass def replace_char(self, old_char: str, new_char: str) -> str: pass def longest_unique_substring(self) -> int: pass def reverse_words(self) -> str: pass ``` Input and Output Formats - **Replace Characters** (`replace_char`): - **Input**: Character to be replaced `old_char`, Character to replace with `new_char` - **Output**: Modified string with characters replaced. - **Find Longest Substring Without Repeating Characters** (`longest_unique_substring`): - **Input**: None - **Output**: Integer representing the length of the longest substring without repeating characters. - **Reverse Words in a String** (`reverse_words`): - **Input**: None - **Output**: String with the order of words reversed. Constraints - Strings can have a length of up to 10,000 characters. - Only ASCII characters will be used. - Replacement characters will always be valid single characters. Example ```python # Sample string initialization processor = StringProcessor(\\"hello world\\") # Replace characters print(processor.replace_char(\'l\', \'x\')) # Example output: \\"hexxo worxd\\" # Find longest substring without repeating characters print(processor.longest_unique_substring()) # Example output: 5 (substring \\"hello\\" or \\"world\\") # Reverse words in string print(processor.reverse_words()) # Example output: \\"olleh dlrow\\" ``` Implement and test the functionalities with various string inputs to ensure correctness and performance.","solution":"class StringProcessor: def __init__(self, initial_string: str): self.initial_string = initial_string def replace_char(self, old_char: str, new_char: str) -> str: Replaces every occurrence of old_char with new_char in the initial string. if not old_char or not new_char or len(old_char) != 1 or len(new_char) != 1: raise ValueError(\\"old_char and new_char must be single characters\\") return self.initial_string.replace(old_char, new_char) def longest_unique_substring(self) -> int: Returns the length of the longest substring without repeating characters. seen = {} max_length = 0 start = 0 for end, char in enumerate(self.initial_string): if char in seen and start <= seen[char]: start = seen[char] + 1 else: max_length = max(max_length, end - start + 1) seen[char] = end return max_length def reverse_words(self) -> str: Reverses the order of words in the initial string. The characters within each word maintain their order. words = self.initial_string.split() reversed_words = [word[::-1] for word in words] return \' \'.join(reversed_words)"},{"question":"# Coding Assessment Question: Matrix Transpose and Sum of Main Diagonal You are required to implement a function that takes a square matrix (2D list) as input, computes its transpose, and then returns the sum of the main diagonal elements of the transposed matrix. # Task Implement a function `transpose_and_diagonal_sum(matrix: List[List[int]]) -> int` that processes a given square matrix `matrix` with the following steps: 1. Compute the transpose of the matrix. 2. Determine the sum of the main diagonal elements of the transposed matrix. 3. Return the computed sum. # Inputs * A square matrix `matrix` represented as a list of lists, where each sub-list represents a row of the matrix. # Outputs * An integer representing the sum of the main diagonal elements of the transposed matrix. # Constraints * The matrix will be square with dimensions n x n, where 1 ≤ n ≤ 100. * The matrix will contain integers in the range of -1000 to 1000. # Function Signature ```python def transpose_and_diagonal_sum(matrix: List[List[int]]) -> int: pass ``` # Example ```python >>> transpose_and_diagonal_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 15 # Explanation: Transposed matrix: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] # Main diagonal sum: 1 + 5 + 9 = 15 >>> transpose_and_diagonal_sum([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) -15 # Explanation: Transposed matrix: # [ # [-1, -4, -7], # [-2, -5, -8], # [-3, -6, -9] # ] # Main diagonal sum: -1 - 5 - 9 = -15 ``` # Performance Requirements * Time Complexity: O(n^2) * Space Complexity: O(n^2) # Notes * Transpose of a matrix is obtained by flipping it over its main diagonal, switching the row and column indices of the matrix elements. * The main diagonal of a square matrix are those elements that run from the top left to the bottom right.","solution":"def transpose_and_diagonal_sum(matrix): Computes the transpose of a square matrix and returns the sum of the main diagonal elements of the transposed matrix. Args: matrix (List[List[int]]): A square matrix. Returns: int: Sum of main diagonal elements of the transposed matrix. n = len(matrix) # Transpose the matrix transposed_matrix = [[matrix[j][i] for j in range(n)] for i in range(n)] # Sum the main diagonal elements of the transposed matrix diagonal_sum = sum(transposed_matrix[i][i] for i in range(n)) return diagonal_sum"},{"question":"# Coding Assessment Question: Topological Sort in a Directed Acyclic Graph (DAG) Scenario You are tasked with implementing a function to perform a topological sort of a given Directed Acyclic Graph (DAG). The graph is represented as an adjacency list, where each node is labeled with a unique integer. Function Signature ```python def topological_sort(graph: Dict[int, List[int]]) -> List[int]: pass ``` Input - `graph`: A dictionary where keys are node labels (integers) and values are lists of integers representing adjacent nodes. Output - Returns a list of integers representing one possible topological order of the nodes. If there are multiple valid topological sorts, return any one of them. Constraints - The graph will have at most 1000 vertices. - The graph will not contain cycles (it is guaranteed to be a DAG). - Vertices are labeled with unique integers from 0 to n-1 (if there are n vertices). Performance Requirements - The solution should efficiently handle graphs with up to 1000 vertices. - Aim for a time complexity of O(V + E) and space complexity of O(V). Example ```python graph = { 0: [1, 2], 1: [2], 2: [3], 3: [] } # One possible topological order: [0, 1, 2, 3] assert topological_sort(graph) == [0, 1, 2, 3] ``` Detailed Steps 1. Initialize an empty list to store the topological order. 2. Maintain a set to keep track of visited nodes and a temporary stack to assist in the depth-first search. 3. Iterate over each node in the graph: - If the node is not visited, start a DFS. - During DFS, add nodes in reverse postorder (processing a node after all its descendants) to the topological order. 4. Return the list of nodes in reverse of the postorder to get the topological sort. Edge Cases - Handle cases where the graph has only one node (single node is the topological order). - Handle cases where the graph has nodes that do not have any outgoing edges. - Ensure the solution works on DAGs with multiple valid topological sorts. # Implementation Notes Implement the DFS to explore each node, marking nodes as visited and placing them in the output list in reverse order of completion. Carefully manage the order of adding nodes to ensure it results in a valid topological sort.","solution":"def topological_sort(graph): Returns a list of nodes in topologically sorted order. def dfs(node): Helper function to perform depth-first search. visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: dfs(neighbor) topological_order.append(node) visited = set() topological_order = [] for node in graph: if node not in visited: dfs(node) return topological_order[::-1] # Reverse the order to get the sorted list"},{"question":"# Question: Convert Integer to Binary String Context: Your task is to write a function that converts a given non-negative integer to its binary string representation without using Python\'s built-in functions such as `bin()`. The solution should be implemented using recursion. Function Signature: ```python def int_to_binary(n: int) -> str: ``` Parameters: - `n`: a non-negative integer to be converted to a binary string. Returns: - The function returns the binary string representation of the integer `n`. Constraints: - The input `n` will be a non-negative integer (`0 <= n <= 10^6`). - Consider edge cases like when `n` is 0. Examples: ```python # Example 1 print(int_to_binary(5)) # Output: \'101\' # Example 2 print(int_to_binary(10)) # Output: \'1010\' # Example 3 print(int_to_binary(0)) # Output: \'0\' # Example 4 print(int_to_binary(1)) # Output: \'1\' # Example 5 print(int_to_binary(16)) # Output: \'10000\' ``` Note: You need to implement the function in such a way that it handles the cases correctly and efficiently. Ensure the function captures the essence of binary conversion through recursion without relying on predefined conversion functions.","solution":"def int_to_binary(n: int) -> str: Converts a non-negative integer to its binary string representation using recursion. Parameters: - n: a non-negative integer to be converted to a binary string. Returns: - The binary string representation of the integer `n`. if n == 0: return \'0\' elif n == 1: return \'1\' return int_to_binary(n // 2) + str(n % 2)"},{"question":"# Coding Assessment Question **Context**: In competitive programming, manipulating sequences of numbers based on specified conditions is a common challenge. **Question**: Implement a function `rearrange_digits(nums: List[int]) -> int` that takes a list of non-negative integers and rearranges them to form the largest possible integer. **Function Signature**: ```python def rearrange_digits(nums: List[int]) -> int: ``` **Input**: * `nums` (List[int]): A list of non-negative integers. **Output**: * An integer that is the largest possible number formed by the digits of the input integers when concatenated in a specific order. **Constraints**: * The input list will contain at most 10,000 elements. * Each element in the list is a non-negative integer between 0 and 9999. * The input parameters are valid and do not require additional validation. **Performance Requirements**: * The solution should aim for O(n log n) time complexity, where n is the number of integers in the input list. * The solution should use O(n) additional space at most. **Examples**: 1. `rearrange_digits([50, 2, 1, 9]) -> 95021` 2. `rearrange_digits([5, 56, 50]) -> 56550` 3. `rearrange_digits([420, 42, 423]) -> 42423420` 4. `rearrange_digits([1, 34, 3, 98, 9, 76, 45, 4]) -> 998764543431` 5. `rearrange_digits([0, 0, 0]) -> 0` **Notes**: * Carefully consider the order in which digits from different numbers should be combined to form the largest possible number. * Ensure the implementation is efficient and handles edge cases gracefully. * Maintain the natural order of concatenation without splitting individual digits of a number.","solution":"from typing import List def rearrange_digits(nums: List[int]) -> int: Takes a list of non-negative integers and rearranges them to form the largest possible integer. # Convert all numbers to strings for easier comparison num_strs = list(map(str, nums)) # Sort the string numbers based on custom logic that compares combined numbers num_strs.sort(key=lambda x: x*10, reverse=True) # Join sorted numbers into the largest possible integer string largest_number_str = \'\'.join(num_strs) # Convert the resulting string back to an integer return int(largest_number_str)"},{"question":"# Scenario You are working on a data processing system that frequently needs to filter large datasets based on specific conditions. To optimize performance, you need to implement an efficient filtering mechanism that can work with multiple conditions dynamically. # Task Write a function `filter_data` that filters a list of dictionaries based on a list of conditions. Each condition will be passed as a tuple, where the first element is the key to filter on, the second element is an operator (`\\"<\\"`, `\\">\\"`, `\\"==\\"`, `\\"!=\\"`, `\\"<=\\"`, or `\\">=\\"`), and the third element is the value to compare against. # Function Signature ```python def filter_data(data: list[dict], conditions: list[tuple[str, str, any]]) -> list[dict]: ``` # Input - `data`: A list of dictionaries, where each dictionary represents a data record. - `conditions`: A list of tuples where each tuple contains a key (string), an operator (string), and a value. The operator defines the type of comparison to be performed on the corresponding key\'s value. # Output - Returns a list of dictionaries that meet all the specified conditions. # Constraints - The keys in conditions will always exist in the dictionaries within the data list. - The values in the dictionaries and the condition values can be of any comparable type (e.g., int, float, str). - The list of conditions can be empty, in which case the function should return the original data unchanged. # Examples ```python data = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"Los Angeles\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Chicago\\"}, {\\"name\\": \\"David\\", \\"age\\": 40, \\"city\\": \\"New York\\"} ] # Example with a single condition print(filter_data(data, [(\\"age\\", \\">\\", 30)])) # Output: [{\'name\': \'Charlie\', \'age\': 35, \'city\': \'Chicago\'}, {\'name\': \'David\', \'age\': 40, \'city\': \'New York\'}] # Example with multiple conditions print(filter_data(data, [(\\"age\\", \\">\\", 30), (\\"city\\", \\"==\\", \\"New York\\")])) # Output: [{\'name\': \'David\', \'age\': 40, \'city\': \'New York\'}] # Example with no conditions print(filter_data(data, [])) # Output: [{\'name\': \'Alice\', \'age\': 30, \'city\': \'New York\'}, {\'name\': \'Bob\', \'age\': 25, \'city\': \'Los Angeles\'}, {\'name\': \'Charlie\', \'age\': 35, \'city\': \'Chicago\'}, {\'name\': \'David\', \'age\': 40, \'city\': \'New York\'}] ``` # Notes - Ensure the function handles different data types correctly within the dictionaries. - Optimize the function to handle large datasets efficiently. - Ensure the solution is robust and handles any edge cases that may arise with string comparisons or numerical comparisons.","solution":"def filter_data(data, conditions): Filters a list of dictionaries based on multiple conditions. Parameters: - data: list of dictionaries where each dictionary represents a data record - conditions: list of tuples, each containing a key (str), an operator (str), and a value (any) to compare against Returns: - A list of dictionaries that meet all specified conditions. def match_conditions(entry, conditions): for key, operator, value in conditions: if operator == \\"==\\": if not entry[key] == value: return False elif operator == \\"!=\\": if not entry[key] != value: return False elif operator == \\"<\\": if not entry[key] < value: return False elif operator == \\">\\": if not entry[key] > value: return False elif operator == \\"<=\\": if not entry[key] <= value: return False elif operator == \\">=\\": if not entry[key] >= value: return False return True return [item for item in data if match_conditions(item, conditions)]"},{"question":"**Scenario**: Your development team is tasked with improving the efficiency of an inventory management system. One of the critical parts of the system involves locating specific items in a large inventory dataset. This dataset can be in the form of a sorted list, and you need to implement a search algorithm to find items effectively. **Question**: Write a function `binary_search(arr, target)` that performs a binary search on a sorted list `arr` to find the position of a given `target`. If the target is found, return its index; otherwise, return -1. Implement the function based on the following information: * **Input Format**: * A sorted list `arr` of integers. * An integer `target` that represents the item you are searching for. * **Output Format**: * An integer representing the index of the `target` in the list `arr` if it is found, otherwise return -1. **Constraints**: * The length of the input list, n, is such that `1 <= n <= 10^4` * Each element of the input list is an integer within the range `-10^5` to `10^5` **Examples**: ```python def binary_search(arr, target): # Implementation goes here # Example Usage arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] target = 7 print(binary_search(arr, target)) # Output: 6 target = 11 print(binary_search(arr, target)) # Output: -1 ``` **Explanation**: In the first example, the target `7` is found at index `6` of the sorted list `arr`. In the second example, the target `11` is not present in the list, so the function returns `-1`. The binary search algorithm should be implemented iteratively or recursively to efficiently find the target in the sorted list.","solution":"def binary_search(arr, target): Perform binary search on a sorted list to find the index of the target. If the target is found, return its index. Otherwise, return -1. left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Problem Statement You are tasked with creating a function that evaluates string mutations to form valid palindromes, then calculating the necessary lifeline operations to reach the nearest perfect palindrome for each test case. A palindromic string is one that reads the same forwards and backwards, and you can perform a mutation operation by changing a single character at any position. # Function 1: nearest_palindrome Write a function `nearest_palindrome(s: str) -> int` that determines the minimum number of mutations needed to transform the given string `s` into its nearest palindromic form. If the string is already a palindrome, the function should return `0`. Input - `s`: A string consisting of lowercase alphabetic characters (1 ≤ |s| ≤ 10^4). Output - An integer representing the minimum number of mutations required to convert `s` into a palindrome. Example ```python >>> nearest_palindrome(\\"abca\\") 1 >>> nearest_palindrome(\\"racecar\\") 0 ``` # Function 2: transform_lifeline Write a function `transform_lifeline(limit: int) -> int` that calculates the minimum length of a string, such that any string of this length or longer will need a lifeline operation to ensure it can be mutated into a palindrome within the given limit of mutations. Input - `limit`: An integer representing the maximum number of allowed character mutations to convert a string into a palindrome (1 ≤ limit ≤ 10^6). Output - An integer representing the minimum length of a string such that it needs a lifeline operation beyond the specified `limit` to be transformed into a palindrome. Example ```python >>> transform_lifeline(1) 3 >>> transform_lifeline(2) 4 ``` Constraints - Assume that each test case will provide strings and limits within the acceptable input range. - Consider edge cases where the string length is at its minimum or when no mutations are required. # Additional Notes 1. For `nearest_palindrome`, consider using two-pointer technique to compare characters and optimize the mutation count calculation. 2. For `transform_lifeline`, devise a method to generate strings that will test the upper bound of the mutation limits efficiently. # Function Definitions ```python def nearest_palindrome(s: str) -> int: # Your implementation here def transform_lifeline(limit: int) -> int: # Your implementation here ```","solution":"def nearest_palindrome(s: str) -> int: Determines the minimum number of mutations needed to transform the given string `s` into its nearest palindromic form. If the string is already a palindrome, it returns 0. n = len(s) count = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: count += 1 return count def transform_lifeline(limit: int) -> int: Calculates the minimum length of a string, such that any string of this length or longer will need a lifeline operation to ensure it can be mutated into a palindrome within the given limit of mutations. # To form a palindrome, the maximum number of non-matching pairs should be <= limit # If the length of the string is `k`, number of non-matching pairs in worst case is k // 2 # We need to find smallest `k` such that (k // 2) > limit # Which means k needs to be greater than 2 * limit return 2 * limit + 1"},{"question":"You are tasked with creating a function `process_transaction` to simulate a simple banking application. This function will process a list of transactions (deposits and withdrawals) and return the final account balance. Additionally, you need to add checks to ensure the account never goes below a specified minimum threshold balance. If a transaction causes the account to go below this minimum balance, the function should raise a `ValueError` with a specific error message. # Requirements: 1. The function should accept an initial balance, a list of transactions, and a minimum threshold balance. 2. Validate that the minimum threshold balance is never breached. 3. If a transaction causes the balance to go below the minimum threshold, raise a `ValueError` with the message \\"Balance dropped below minimum threshold\\". 4. Update the Docstring with an explanation of the parameters, the return value, and the error raised. # Function Signature: ```python def process_transaction( initial_balance: float, transactions: list[float], min_threshold: float, ) -> float: Input Parameters ---------------- initial_balance : float The starting balance of the account. transactions : list of float A list of transactions where positive numbers are deposits and negative numbers are withdrawals. min_threshold : float The minimum allowable balance of the account. Returns ------- result : float The final balance of the account after processing all transactions. Raises ------ ValueError If at any point the balance goes below the minimum threshold. Examples -------- >>> process_transaction(100.0, [50.0, -30.0, -20.0], 10.0) 100.0 >>> process_transaction(100.0, [50.0, -200.0, 30.0], 10.0) Traceback (most recent call last): ... ValueError: Balance dropped below minimum threshold pass ``` # Constraints: * The initial balance and minimum threshold must be non-negative floats. * The function must raise appropriate errors as specified in the requirements. Implement this function and ensure it passes the given validation tests.","solution":"def process_transaction(initial_balance: float, transactions: list[float], min_threshold: float) -> float: Input Parameters ---------------- initial_balance : float The starting balance of the account. transactions : list of float A list of transactions where positive numbers are deposits and negative numbers are withdrawals. min_threshold : float The minimum allowable balance of the account. Returns ------- result : float The final balance of the account after processing all transactions. Raises ------ ValueError If at any point the balance goes below the minimum threshold. Examples -------- >>> process_transaction(100.0, [50.0, -30.0, -20.0], 10.0) 100.0 >>> process_transaction(100.0, [50.0, -200.0, 30.0], 10.0) Traceback (most recent call last): ... ValueError: Balance dropped below minimum threshold balance = initial_balance for transaction in transactions: balance += transaction if balance < min_threshold: raise ValueError(\\"Balance dropped below minimum threshold\\") return balance"},{"question":"# Coding Assessment Question Scenario You are tasked with implementing a function that calculates the largest rectangular area possible in a histogram. The histogram is represented as a list of integers where each integer represents the height of a bar in the histogram, and the width of each bar is 1. Task Implement a function `largest_rectangle_area` that computes the maximum rectangular area in the histogram. Function Signature ```python def largest_rectangle_area(heights: list) -> int: Calculate the largest rectangular area in a histogram. :param heights: List of integers representing the heights of the histogram bars. :return: The area of the largest rectangle that can be formed within the histogram. ``` Input * `heights`: A list of integers where each integer `h` represents the height of a bar in the histogram. Length of the list is between 0 and 10^5, and each height `h` is between 0 and 10^4. Output * An integer representing the area of the largest rectangle that can be formed within the histogram. Constraints * The input list can be empty or contain up to 100,000 elements. * Heights of the histogram bars are nonnegative integers. Examples ```python assert largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 assert largest_rectangle_area([2, 4]) == 4 assert largest_rectangle_area([]) == 0 assert largest_rectangle_area([0, 0, 0]) == 0 assert largest_rectangle_area([1]) == 1 ``` Notes * Ensure your implementation handles edge cases, such as empty lists and lists where all elements are 0. * Consider an efficient algorithm to handle the input size constraint, aiming for a time complexity of O(n).","solution":"def largest_rectangle_area(heights: list) -> int: Calculate the largest rectangular area in a histogram. :param heights: List of integers representing the heights of the histogram bars. :return: The area of the largest rectangle that can be formed within the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() height = heights[top_of_stack] width = index if not stack else index - stack[-1] - 1 max_area = max(max_area, height * width) while stack: top_of_stack = stack.pop() height = heights[top_of_stack] width = index if not stack else index - stack[-1] - 1 max_area = max(max_area, height * width) return max_area"},{"question":"# Scenario You are given a list of integers representing the prices of different items in a store. Your task is to design a function to calculate the maximum profit that can be achieved by buying and selling items multiple times. However, you must adhere to the rule that you cannot buy a new item before selling the previously bought item. # Task Implement a function that computes the maximum achievable profit given the prices of items over several days. # Function Signature ```python def max_profit(prices: List[int]) -> int: ``` # Input - `prices`: A list of integers representing the prices of items over `n` days. # Output - Returns an integer representing the maximum profit that can be obtained. # Constraints - All prices in the list are non-negative integers. - The length of the list `n` is between `1` and `10,000` (inclusive). - You cannot buy and sell on the same day. # Example ```python prices = [7, 1, 5, 3, 6, 4] max_profit(prices) ``` Expected Output ``` 7 ``` Explanation: - Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5 - 1 = 4. - Buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6 - 3 = 3. - Total profit = 4 + 3 = 7. **Note**: Ensure your implementation optimally processes the input list to handle the upper constraint efficiently. Focus on iterating through the list in a manner that captures all positive price differences whenever a sell follows a buy.","solution":"def max_profit(prices): This function returns the maximum profit that can be achieved by buying and selling stock on different days. Parameters: prices (List[int]): A list of prices where prices[i] is the price of a given stock on day i. Returns: int: Maximum profit possible. max_profit = 0 for i in range(1, len(prices)): # if selling today is profitable, do it if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"# Problem: String Compression and Decompression Utility Context You are developing a data storage system that values optimal storage utilization. For this purpose, it is crucial to implement efficient compression and decompression routines for strings. We will use a basic run-length encoding algorithm, which is particularly effective for strings with many repeated characters. Task 1. **Implement the Run-Length Encoding (RLE) compression function**. 2. **Implement the Run-Length Encoding (RLE) decompression function**. Details 1. **Functionality**: - You will first implement the `compress` function to perform run-length encoding on the provided string. - Then, implement the `decompress` function to restore the original string from its compressed form. 2. **Input and Output Formats**: - `compress(data: str) -> str`: Compresses the input string using run-length encoding. - `decompress(data: str) -> str`: Decompresses the run-length encoded string back to its original form. 3. **Constraints and Requirements**: - The RLE compression algorithm should work as follows: for a sequence of identical characters, it is replaced by a single occurrence of that character followed by the number of times it appears consecutively. - Ensure that the compress and decompress functions handle edge cases such as empty strings and single-character strings. - Handle valid RLE formats during decompression to avoid parsing errors. 4. **Example Usage**: - `compress(\'aaabbbbcc\')` should return `\'a3b4c2\'`. - `decompress(\'a3b4c2\')` should return `\'aaabbbbcc\'`. Implementation ```python def compress(data: str) -> str: Run-Length Encoding compression algorithm implementation. if not data: return \\"\\" compressed = [] count = 1 length = len(data) for i in range(1, length): if data[i] == data[i-1]: count += 1 else: compressed.append(f\\"{data[i-1]}{count}\\") count = 1 compressed.append(f\\"{data[-1]}{count}\\") return \'\'.join(compressed) def decompress(data: str) -> str: Run-Length Encoding decompression algorithm implementation. if not data: return \\"\\" decompressed = [] length = len(data) i = 0 while i < length: char = data[i] count = 0 i += 1 while i < length and data[i].isdigit(): count = count * 10 + int(data[i]) i += 1 decompressed.append(char * count) return \'\'.join(decompressed) # Example to test print(compress(\'aaabbbbcc\')) # Expected: \'a3b4c2\' print(decompress(\'a3b4c2\')) # Expected: \'aaabbbbcc\' ``` Write your implementation and ensure it passes all test cases provided.","solution":"def compress(data: str) -> str: Run-Length Encoding compression algorithm implementation. if not data: return \\"\\" compressed = [] count = 1 length = len(data) for i in range(1, length): if data[i] == data[i-1]: count += 1 else: compressed.append(f\\"{data[i-1]}{count}\\") count = 1 compressed.append(f\\"{data[-1]}{count}\\") return \'\'.join(compressed) def decompress(data: str) -> str: Run-Length Encoding decompression algorithm implementation. if not data: return \\"\\" decompressed = [] length = len(data) i = 0 while i < length: char = data[i] count = 0 i += 1 while i < length and data[i].isdigit(): count = count * 10 + int(data[i]) i += 1 decompressed.append(char * count) return \'\'.join(decompressed)"},{"question":"# Question: You are tasked with implementing a program that performs matrix transformation operations, specifically rotation and transposition, on a square matrix. **Objective:** Write two functions, `rotate_matrix` and `transpose_matrix`. 1. `rotate_matrix(matrix: List[List[int]]) -> List[List[int]]`: - Rotates a given square matrix 90 degrees clockwise. - The function modifies the matrix in-place. 2. `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]`: - Transposes a given square matrix. - The function modifies the matrix in-place. **Constraints:** - The input matrix will be an n x n matrix (square matrix) with n between 0 and 1000. - Elements of the matrix are integers ranging from -10^9 to 10^9. **Input and Output:** - For rotate_matrix: - **Input**: A square matrix of integers. - **Output**: A square matrix after a 90-degree clockwise rotation. - For transpose_matrix: - **Input**: A square matrix of integers. - **Output**: A square matrix after the transpose operation. **Examples:** 1. **Rotation Example:** ```python >>> matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] >>> rotate_matrix(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` 2. **Transpose Example:** ```python >>> matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] >>> transpose_matrix(matrix) >>> matrix [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] ``` **Function Signatures:** ```python from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: pass def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: pass ``` **Performance Requirements:** - The solution should handle matrices of size up to 1000x1000 efficiently.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] return matrix"},{"question":"**String Manipulation: Character Replacement** # Problem Statement: You are given a string `s` composed entirely of lowercase alphabet letters and an integer `k`. Your task is to implement a function `character_replacement(s: str, k: int) -> int` that returns the length of the longest substring that can be obtained by replacing at most `k` characters in the original string. # Input - A string `s` (1 ≤ `len(s)` ≤ 10^5), which contains only lowercase alphabet letters. - An integer `k` (0 ≤ `k` ≤ len(s)), representing the maximum number of character replacements allowed. # Output - An integer representing the length of the longest possible substring with at most `k` replacements. # Requirements - The solution must be optimized to handle large strings efficiently. - Consider edge cases such as when `k` is 0 or when all characters in the string are the same. # Example ```python >>> character_replacement(\\"AABABBA\\", 1) 4 >>> character_replacement(\\"ABAB\\", 2) 4 >>> character_replacement(\\"ABAA\\", 2) 4 ``` # Constraints - Your solution should not exceed O(n) time complexity. - Space complexity should be handled efficiently ensuring O(1) extra space apart from input storage. Write your code below: ```python def character_replacement(s: str, k: int) -> int: max_len = 0 max_count = 0 count = [0] * 26 left = 0 for right in range(len(s)): count[ord(s[right]) - ord(\'A\')] += 1 max_count = max(max_count, count[ord(s[right]) - ord(\'A\')]) while right - left + 1 - max_count > k: count[ord(s[left]) - ord(\'A\')] -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len # Example usage if __name__ == \\"__main__\\": print(character_replacement(\\"AABABBA\\", 1)) ```","solution":"def character_replacement(s: str, k: int) -> int: max_len = 0 max_count = 0 count = [0] * 26 # Since we are dealing with `A-Z` characters, preallocate 26 slots left = 0 for right in range(len(s)): count[ord(s[right]) - ord(\'A\')] += 1 max_count = max(max_count, count[ord(s[right]) - ord(\'A\')]) while right - left + 1 - max_count > k: count[ord(s[left]) - ord(\'A\')] -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"# Coding Question **Problem Statement**: Suppose you are given a string of lowercase alphabets. Your task is to determine the length of the smallest substring that contains all the unique characters present in the string. This kind of problem is helpful in text processing applications where certain character patterns need to be identified quickly. **Objective**: Write a function `length_of_smallest_substring_with_all_chars(s: str) -> int` that returns the length of the smallest substring that includes all the unique characters of the input string `s`. # Function Signature ```python def length_of_smallest_substring_with_all_chars(s: str) -> int: ``` # Input * A string `s` (1 <= len(s) <= 1000) consisting of only lowercase alphabetical characters. # Output * An integer representing the length of the smallest substring containing all unique characters of the input string. # Performance Requirements * Your function should run efficiently for the upper limit (len(s) = 1000). # Example ```python >>> length_of_smallest_substring_with_all_chars(\\"abcda\\") 4 >>> length_of_smallest_substring_with_all_chars(\\"aabcbcdbca\\") 4 >>> length_of_smallest_substring_with_all_chars(\\"aaaa\\") 1 >>> length_of_smallest_substring_with_all_chars(\\"abcdefghijklmnopqrstuvwxyz\\") 26 ``` # Constraints * Ensure the function handles strings up to 1000 characters efficiently. * Use sliding window or similar techniques to ensure minimal time complexity. # Scenario A software firm is working on a new text editor feature where users can highlight the smallest text segment that contains all distinct characters from a selected portion of the document. Your task is to create an efficient function that finds the length of such a segment, making the feature quick and responsive to user inputs.","solution":"def length_of_smallest_substring_with_all_chars(s: str) -> int: unique_chars = set(s) num_unique = len(unique_chars) left, right = 0, 0 char_count = {} smallest_length = len(s) + 1 while right < len(s): char = s[right] if char in char_count: char_count[char] += 1 else: char_count[char] = 1 while len(char_count) == num_unique: smallest_length = min(smallest_length, right - left + 1) left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 right += 1 return smallest_length"},{"question":"# Coding Assessment Question: Implementing a Decision Tree for Classification Context You are working on a classification problem as part of a machine learning project. To solve this, you decide to implement a Decision Tree classifier from scratch. Decision Trees are effective for both classification and regression tasks and provide a clear indication of which features are most important in predicting the target value. Task Write a function that builds a Decision Tree using the given training data, tests it on a given test sample, and returns a prediction for the test sample. Function Signature ```python def decision_tree_classifier(training_samples: list[list[int]], labels: list[int], test_sample: list[int], max_depth: int) -> int: ``` Input Format * `training_samples`: A 2D list of integers where each inner list represents a training sample with features. * `labels`: A list of integers where each element is the class label corresponding to the training samples. * `test_sample`: A list of integers representing the features of the sample to be classified. * `max_depth`: An integer representing the maximum depth of the decision tree. Output Format * The function returns an integer representing the predicted class label for the test sample. Constraints * You can assume the given training samples and test sample are of compatible dimensions. * The number of training samples is at least 2. * The depth of the decision tree (`max_depth`) will be a positive integer. Example ```python training_samples = [[1, 0, 1], [0, 1, 1], [1, 0, 0], [0, 1, 0]] labels = [1, 0, 1, 0] test_sample = [1, 1, 1] max_depth = 3 prediction = decision_tree_classifier(training_samples, labels, test_sample, max_depth) print(f\\"Predicted class: {prediction}\\") ``` **Note:** Ensure your implementation handles edge cases such as pure splits (nodes where all elements belong to a single class) and limits the depth of the tree as specified. Consider using metrics like information gain or Gini impurity for selecting the best splits.","solution":"import numpy as np def calculate_gini(labels): Function to compute the Gini impurity for a list of labels. _, label_counts = np.unique(labels, return_counts=True) impurity = 1 - sum((count / len(labels)) ** 2 for count in label_counts) return impurity def split_dataset(dataset, labels, feature_index, threshold): Splits the dataset based on the given feature index and threshold. left_dataset = [] right_dataset = [] left_labels = [] right_labels = [] for i in range(len(dataset)): if dataset[i][feature_index] <= threshold: left_dataset.append(dataset[i]) left_labels.append(labels[i]) else: right_dataset.append(dataset[i]) right_labels.append(labels[i]) return left_dataset, right_dataset, left_labels, right_labels def calculate_best_split(dataset, labels): Determines the best split for the dataset based on Gini impurity. best_gini = 1 best_split = None n_features = len(dataset[0]) for feature_index in range(n_features): thresholds = set([row[feature_index] for row in dataset]) for threshold in thresholds: left_dataset, right_dataset, left_labels, right_labels = split_dataset(dataset, labels, feature_index, threshold) p_left = len(left_labels) / len(labels) p_right = len(right_labels) / len(labels) gini = p_left * calculate_gini(left_labels) + p_right * calculate_gini(right_labels) if gini < best_gini: best_gini = gini best_split = { \'feature_index\': feature_index, \'threshold\': threshold, \'left\': (left_dataset, left_labels), \'right\': (right_dataset, right_labels) } return best_split def build_decision_tree(dataset, labels, max_depth, current_depth=0): Recursively builds a decision tree using the best splits. if current_depth >= max_depth or len(set(labels)) == 1: return np.argmax(np.bincount(labels)) best_split = calculate_best_split(dataset, labels) if best_split is None: return np.argmax(np.bincount(labels)) left_subtree = build_decision_tree(*best_split[\'left\'], max_depth, current_depth + 1) right_subtree = build_decision_tree(*best_split[\'right\'], max_depth, current_depth + 1) return { \'feature_index\': best_split[\'feature_index\'], \'threshold\': best_split[\'threshold\'], \'left\': left_subtree, \'right\': right_subtree } def classify(tree, sample): Classifies a sample using the trained decision tree. if isinstance(tree, dict): feature_index = tree[\'feature_index\'] threshold = tree[\'threshold\'] if sample[feature_index] <= threshold: return classify(tree[\'left\'], sample) else: return classify(tree[\'right\'], sample) else: return tree def decision_tree_classifier(training_samples, labels, test_sample, max_depth): tree = build_decision_tree(training_samples, labels, max_depth) return classify(tree, test_sample)"},{"question":"# Linked List Reversal **Scenario**: You have been tasked with writing a function that can reverse a singly linked list. A singly linked list is a data structure where each node points to the next node in the sequence, with the last node pointing to `None`. Your function should take the head of the linked list and return the new head of the reversed list. **Task**: Implement a function to reverse a singly linked list iteratively. **Function Signature**: ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverses a singly linked list. Args: head (ListNode): the head of the linked list. Returns: ListNode: the new head of the reversed linked list. ``` **Input**: - `head`: The head of the singly linked list where `0 <= number of nodes <= 10^6`. **Output**: - Return the new head of the reversed linked list. **Constraints**: - You must not use recursion. - The function should have a time complexity of O(n). **Examples**: ```python # Helper function to convert list into linked list def list_to_linkedlist(elements): if not elements: return None head = ListNode(elements[0]) current = head for element in elements[1:]: current.next = ListNode(element) current = current.next return head # Helper function to convert linked list into list def linkedlist_to_list(head): elements = [] while head: elements.append(head.value) head = head.next return elements # Example usage head = list_to_linkedlist([1, 2, 3, 4, 5]) reversed_head = reverse_linked_list(head) print(linkedlist_to_list(reversed_head)) # Output: [5, 4, 3, 2, 1] head = list_to_linkedlist([]) reversed_head = reverse_linked_list(head) print(linkedlist_to_list(reversed_head)) # Output: [] head = list_to_linkedlist([1]) reversed_head = reverse_linked_list(head) print(linkedlist_to_list(reversed_head)) # Output: [1] ``` **Requirements**: - The solution should efficiently handle reversing large linked lists. - Include test cases for validation across different edge cases like empty lists, single-element lists, and lists with multiple elements.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_linked_list(head: ListNode) -> ListNode: prev = None current = head while current is not None: next_node = current.next current.next = prev prev = current current = next_node return prev # Helper function to convert list into linked list def list_to_linkedlist(elements): if not elements: return None head = ListNode(elements[0]) current = head for element in elements[1:]: current.next = ListNode(element) current = current.next return head # Helper function to convert linked list into list def linkedlist_to_list(head): elements = [] while head: elements.append(head.value) head = head.next return elements"},{"question":"# Coding Question Scenario You are developing an application that processes large datasets to extract meaningful statistics. Your task is to implement a function that efficiently counts the number of unique prime factors for each element in a list of integers. Task Implement a function `count_unique_prime_factors` that takes a list of integers and returns a list of the same length where each element is the count of unique prime factors of the corresponding integer in the input list. Function Signature ```python def count_unique_prime_factors(numbers: List[int]) -> List[int]: Count the number of unique prime factors for each element in the list of integers. args: numbers: A list of integers to process. Returns: A list of the same length with counts of unique prime factors. ``` Constraints * Each integer in the input list will be a positive integer. * The length of the input list will not exceed 10^5. * The integers in the list will be between 1 and 10^6. Example Input and Output Hint: Consider the computational efficiency and choose an optimal algorithm. Example 1: ```python input_list = [10, 15, 21, 28] output = count_unique_prime_factors(input_list) expected_output = [2, 2, 2, 2] # 10 has prime factors 2 and 5. # 15 has prime factors 3 and 5. # 21 has prime factors 3 and 7. # 28 has prime factors 2 and 7. ``` Example 2: ```python input_list = [7, 14, 28, 49] output = count_unique_prime_factors(input_list) expected_output = [1, 2, 2, 1] # 7 has prime factor 7. # 14 has prime factors 2 and 7. # 28 has prime factors 2 and 7. # 49 has prime factor 7. ``` Example 3: ```python input_list = [1, 2, 3, 4] output = count_unique_prime_factors(input_list) expected_output = [0, 1, 1, 1] # 1 has no prime factors. # 2 has prime factor 2. # 3 has prime factor 3. # 4 has prime factor 2 (counts as 1 unique prime factor despite multiplicity). ``` # Notes * Ensure that your function efficiently handles the prime factorization, considering the upper limits of the constraints. * Utilize appropriate data structures and algorithms to optimize the factorization process, such as the Sieve of Eratosthenes for precomputing prime numbers.","solution":"def count_unique_prime_factors(numbers): Count the number of unique prime factors for each element in the list of integers. args: numbers: A list of integers to process. Returns: A list of the same length with counts of unique prime factors. from math import isqrt # Get the maximum number to set the limit for Sieve max_num = max(numbers) # Sieve of Eratosthenes to find smallest prime factor of each number up to max_number spf = list(range(max_num + 1)) # spf[x] will be the smallest prime factor of x for i in range(2, isqrt(max_num) + 1): if spf[i] == i: # i is a prime number for j in range(i * i, max_num + 1, i): if spf[j] == j: spf[j] = i def get_unique_prime_factors_count(n): unique_factors = set() while n != 1: unique_factors.add(spf[n]) n //= spf[n] return len(unique_factors) return [get_unique_prime_factors_count(number) for number in numbers]"},{"question":"# Sum of Digits in Large Numbers **Objective**: In this task, you will implement a function that reads a file containing very large integers and calculates the sum of digits for each number provided, determining the maximum sum of digits among all numbers. # Problem Statement: You are given a text file with one thousand lines, each containing a single large integer. These integers can have up to 100 digits. # Your Task: 1. Implement a function `sum_of_digits(number: str) -> int` that computes the sum of the digits of the provided large integer. 2. Implement a function `max_sum_of_digits(filename: str = \\"numbers.txt\\") -> int` that reads the file `numbers.txt`, utilizes `sum_of_digits`, and returns the maximum sum of digits found among all numbers. # Input: - `filename` (str): The name of the file containing large integers, one per line. # Output: - Returns (int): The maximum sum of digits among all numbers in the file. # Constraints: - Each number will have up to 100 digits. - The file will contain exactly 1000 lines. - All numbers are non-negative. # Example: Given an example file \\"example.txt\\" with the following contents: ``` 123456789 987654321 1111111111111111111111111111111111 ``` Running `max_sum_of_digits(\\"example.txt\\")` should return `34`. # Specification: ```python def sum_of_digits(number: str) -> int: Compute the sum of the digits of the provided large integer. def max_sum_of_digits(filename: str = \\"numbers.txt\\") -> int: Compute the maximum sum of digits among all numbers in the given file. ``` # Notes: * Ensure your solution is efficient and reads the file properly. * Be mindful of edge cases, such as extremely large numbers or lines with unexpected content. # Testing: You should provide unit tests to validate the correctness of both functions.","solution":"def sum_of_digits(number: str) -> int: Compute the sum of the digits of the provided large integer. return sum(int(digit) for digit in number) def max_sum_of_digits(filename: str = \\"numbers.txt\\") -> int: Compute the maximum sum of digits among all numbers in the given file. with open(filename, \\"r\\") as file: max_sum = 0 for line in file: line = line.strip() current_sum = sum_of_digits(line) if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"# Problem Statement You need to implement a function that determines if a given string is a palindrome after removing all non-alphabetic characters and ignoring case differences. # Function Signature ```python def is_clean_palindrome(text: str) -> bool: pass ``` # Input - `text` (str): The text to be checked. It can contain upper and lower case letters, digits, punctuation, and other special characters. # Output - (bool): Returns `True` if the cleaned text is a palindrome, and `False` otherwise. # Constraints - The function should treat empty strings as palindromes (return `True`). - The function should ignore special characters and digits while considering only alphabetic characters. # Examples ```python assert is_clean_palindrome(\'A man, a plan, a canal: Panama\') == True assert is_clean_palindrome(\'No lemon, no melon!\') == True assert is_clean_palindrome(\'Was it a car or a cat I saw?\') == True assert is_clean_palindrome(\'Hello, World!\') == False assert is_clean_palindrome(\'1234321\') == True # Because after removing non-alphabetic characters, it becomes an empty string assert is_clean_palindrome(\'\') == True ``` # Additional Notes - Pay attention to upper and lower case differences; they should be ignored. - Ensure the function handles both empty and non-empty strings properly.","solution":"def is_clean_palindrome(text: str) -> bool: Determines if the given text is a palindrome after removing all non-alphabetic characters and ignoring case differences. clean_text = \'\'.join(char.lower() for char in text if char.isalpha()) return clean_text == clean_text[::-1]"},{"question":"# Problem Statement As a data analyst, you are working on a project that requires you to clean up and validate a list of email addresses. Email validation is an important step to ensure correctness and avoid errors in further processing or communication. # Implementation Details Implement the `validate_emails` function in Python using the given signature: ```python def validate_emails(email_list: list) -> list: pass ``` * **Input**: - `email_list` (list): A list of strings where each string represents an email address. * **Output**: - Returns a list of valid email addresses from the input list. # Example ```python >>> emails = [\\"user@example.com\\", \\"invalid-email.com\\", \\"test@mydomain\\", \\"name@domain.org\\"] >>> validate_emails(emails) [\\"user@example.com\\", \\"name@domain.org\\"] ``` # Requirements Ensure your function adheres to the following: 1. Validates each email address to ensure it matches the standard email format (local_part@domain). 2. The local part cannot start or end with a special character (such as dot `.` or hyphen `-`), and must be between 1 and 64 characters. 3. The domain part must be a valid domain name with at least one dot, and cannot end with a dot or start with a special character. 4. The length of the domain part should not exceed 253 characters. 5. Use regular expressions for validation where appropriate. 6. Handle edge cases gracefully, such as empty or null strings in the input list. # Notes - Review proper email format specifications to understand the rules and common pitfalls in email validation. - Consider using Python\'s `re` module to formulate your regular expression for email validation. - Avoid using external libraries for the validation process.","solution":"import re def validate_emails(email_list): This function takes a list of email addresses and returns a list of valid email addresses. # Define the regular expression for validation email_regex = re.compile( r\\"^(?!.)(?!.*.)(?!.*?..)[A-Za-z0-9._%+-]{1,64}@[A-Za-z0-9.-]{1,253}.[A-Za-z]{2,}\\" ) valid_emails = [] for email in email_list: if email_regex.match(email): valid_emails.append(email) return valid_emails"},{"question":"# Question You have a list of integers and a target sum. Your task is to implement a function that determines if there are two distinct indices `i` and `j` in the list such that the sum of the elements at these indices is equal to the target sum. # Function Signature ```python def has_pair_with_sum(nums: List[int], target: int) -> bool: ... ``` # Input * `nums`: A list of integers. * `target`: An integer representing the target sum. # Output * Returns `True` if there are two distinct indices `i` and `j` such that `nums[i] + nums[j] = target`, otherwise `False`. # Constraints * The length of `nums` will be between 1 and 10^5. * Each element in `nums` will be a valid integer within the range `-10^9` to `10^9`. * The `target` will be a valid integer within the range `-10^9` to `10^9`. # Example ```python # Example 1 nums = [2, 7, 11, 15] target = 9 # There are two distinct indices (0, 1) since 2 + 7 = 9. assert has_pair_with_sum(nums, target) == True, \\"Test case 1 failed\\" # Example 2 nums = [1, 2, 3, 4, 5] target = 10 # There are no two distinct indices that add up to 10. assert has_pair_with_sum(nums, target) == False, \\"Test case 2 failed\\" ``` # Notes - **Edge Cases**: Consider lists with only one element, no elements, and scenarios where the target is a positive or negative value. - **Error Handling**: Ensure that the function handles large inputs efficiently without excessive time complexity. # Solution To solve this problem, you can use a set to keep track of the elements you have seen so far. For each element in the list, check if the difference between the target and the current element exists in the set. This approach ensures an O(n) time complexity.","solution":"from typing import List def has_pair_with_sum(nums: List[int], target: int) -> bool: seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"}]'),N={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},F={class:"search-container"},O={class:"card-container"},L={key:0,class:"empty-state"},R=["disabled"],P={key:0},D={key:1};function z(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",F,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",O,[(n(!0),i(b,null,w(a.displayedPoems,(o,f)=>(n(),v(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",L,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",D,"Loading...")):(n(),i("span",P,"See more"))],8,R)):u("",!0)])}const Y=c(N,[["render",z],["__scopeId","data-v-d3c217ec"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"quotes/56.md","filePath":"quotes/56.md"}'),j={name:"quotes/56.md"},U=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{M as __pageData,U as default};
