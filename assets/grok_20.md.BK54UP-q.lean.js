import{_,o as s,c as r,a as t,m as c,t as d,C as h,M as g,U as b,f as u,F as y,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},A={class:"review-title"},R={class:"review-content"};function L(n,e,l,m,i,a){return s(),r("div",q,[t("div",T,[t("div",A,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const F=_(k,[["render",L],["__scopeId","data-v-cd18d1dd"]]),C=JSON.parse(`[{"question":"def isValid(s: str) -> bool: Determine if the input string containing only characters '(', ')', '{', '}', '[' and ']' is valid. An input string is valid if: 1. Open brackets are closed by the same type of brackets. 2. Open brackets are closed in the correct order. >>> isValid(\\"()\\") == True >>> isValid(\\"()[]{}\\") == True >>> isValid(\\"(]\\") == False >>> isValid(\\"([)]\\") == False >>> isValid(\\"{[]}\\") == True >>> isValid(\\"\\") == True >>> isValid(\\"{\\") == False >>> isValid(\\"}\\") == False >>> isValid(\\"([{}])\\") == True >>> isValid(\\"((()))\\") == True >>> isValid(\\"(\\") == False >>> isValid(\\")\\") == False >>> isValid(\\"({}[()])\\") == True >>> isValid(\\"[{]}\\") == False >>> isValid(\\"{[()]}\\") == True >>> isValid(\\"{[()]}}\\") == False >>> isValid(\\"(({[]}))\\") == True","solution":"def isValid(s: str) -> bool: Determine if the input string containing only characters '(', ')', '{', '}', '[' and ']' is valid. An input string is valid if: 1. Open brackets are closed by the same type of brackets. 2. Open brackets are closed in the correct order. :param s: input string :return: True if the input string is valid, False otherwise # Define a matching map for parentheses matching_parentheses = {')': '(', '}': '{', ']': '['} # Use a stack to track the opening parentheses stack = [] for char in s: if char in matching_parentheses: # Pop the last opening parenthesis from the stack if it's a closing parenthesis top_element = stack.pop() if stack else '#' if matching_parentheses[char] != top_element: return False else: # Push every opening parenthesis to the stack stack.append(char) # For the string to be valid, the stack should be empty return not stack"},{"question":"from typing import List def analyze_string_patterns(strings: List[str]) -> str: Analyzes a list of strings and returns the most common substring of length at least 2. In case of a tie, returns the lexicographically smallest substring. >>> analyze_string_patterns([\\"abcab\\", \\"bca\\", \\"cab\\"]) 'ab' >>> analyze_string_patterns([\\"aaaa\\", \\"aaab\\", \\"aabaa\\"]) 'aa' >>> analyze_string_patterns([\\"xyz\\", \\"wxyz\\", \\"zx\\"]) 'xz' >>> analyze_string_patterns([]) '' >>> analyze_string_patterns([\\"a\\", \\"b\\", \\"c\\"]) '' >>> analyze_string_patterns([\\"aabbcc\\", \\"bbccaa\\", \\"ccaabb\\"]) 'aa' >>> analyze_string_patterns([\\"abcd\\", \\"efgh\\"]) 'ab' >>> analyze_string_patterns([\\"abcabc\\", \\"cababc\\"]) 'ab' >>> analyze_string_patterns([ \\"abcdabcdabcd\\", \\"abcdabcdabcd\\", \\"abcdabcdabcd\\" ]) 'ab' >>> analyze_string_patterns([\\"a\\" * 100]) 'aa'","solution":"from collections import defaultdict def analyze_string_patterns(strings): Analyzes a list of strings and returns the most common substring of length at least 2. In case of a tie, returns the lexicographically smallest substring. if not strings: return \\"\\" substring_count = defaultdict(int) for s in strings: length = len(s) for i in range(length): for j in range(i + 2, length + 1): substring = s[i:j] substring_count[substring] += 1 if not substring_count: return \\"\\" max_freq = max(substring_count.values()) most_common_substrings = [k for k, v in substring_count.items() if v == max_freq] most_common_substrings.sort() return most_common_substrings[0]"},{"question":"from typing import List from itertools import permutations def unique_permutations(s: str) -> List[str]: Write a function to find all unique permutations of a given string. The function should return these permutations as a list. Ensure the permutations do not contain any duplicate entries even if the input string has repeating characters. >>> unique_permutations(\\"abc\\") [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> unique_permutations(\\"aabc\\") [\\"aabc\\", \\"aacb\\", \\"abac\\", \\"abca\\", \\"acab\\", \\"acba\\", \\"baac\\", \\"baca\\", \\"bcaa\\", \\"caab\\", \\"caba\\", \\"cbaa\\"] >>> unique_permutations(\\"a\\") [\\"a\\"] >>> unique_permutations(\\"\\") [\\"\\"] >>> unique_permutations(\\"aaa\\") [\\"aaa\\"] # Your code here","solution":"from itertools import permutations def unique_permutations(s): Returns a list of all unique permutations of the input string s. return sorted(set([''.join(p) for p in permutations(s)]))"},{"question":"import time class Transaction: def __init__(self, amount, transaction_type): Initialize a Transaction with a specified amount, type, and timestamp. self.amount = amount self.transaction_type = transaction_type self.timestamp = time.time() class Account: def __init__(self, username, password): Initialize an Account with a username, password, balance, and list of transactions. self.username = username self.password = password self.balance = 0 self.transactions = [] def deposit(self, amount): Deposit a specified amount into the account and log the transaction. Args: amount (float): The amount to deposit. Returns: bool: True if the deposit is successful, False otherwise. def withdraw(self, amount): Withdraw a specified amount from the account if enough balance is available. Args: amount (float): The amount to withdraw. Returns: bool: True if the withdrawal is successful, False otherwise. def transfer(self, amount, target_account): Transfer a specified amount to another account if enough balance is available. Args: amount (float): The amount to transfer. target_account (Account): The target account to transfer the money to. Returns: bool: True if the transfer is successful, False otherwise. def get_balance(self): Return the current account balance. Returns: float: The current balance of the account. def apply_interest(self): Apply 1% monthly interest to the account balance and log the transaction. class Bank: def __init__(self): Initialize the Bank with a dictionary of accounts. self.accounts = {} def create_account(self, username, password): Create a new account with given username and password. Args: username (str): The username for the new account. password (str): The password for the new account. Returns: bool: True if the account creation is successful, False if username is already taken. def get_account(self, username, password): Retrieve an account with the given username and password. Args: username (str): The username of the account. password (str): The password of the account. Returns: Account: The account object if credentials are correct, None otherwise. def calculate_interest_for_all_accounts(self): Apply monthly interest to all accounts in the bank. import pytest def test_create_account(): bank = Bank() assert bank.create_account(\\"user1\\", \\"password\\") == True assert bank.create_account(\\"user1\\", \\"password\\") == False # Duplicate user def test_deposit(): bank = Bank() bank.create_account(\\"user1\\", \\"password\\") account = bank.get_account(\\"user1\\", \\"password\\") assert account.deposit(1000) == True assert account.get_balance() == 1000 def test_withdraw(): bank = Bank() bank.create_account(\\"user1\\", \\"password\\") account = bank.get_account(\\"user1\\", \\"password\\") account.deposit(1000) assert account.withdraw(500) == True assert account.get_balance() == 500 assert account.withdraw(600) == False # Insufficient funds def test_transfer(): bank = Bank() bank.create_account(\\"user1\\", \\"password\\") bank.create_account(\\"user2\\", \\"password\\") account1 = bank.get_account(\\"user1\\", \\"password\\") account2 = bank.get_account(\\"user2\\", \\"password\\") account1.deposit(500) assert account1.transfer(200, account2) == True assert account1.get_balance() == 300 assert account2.get_balance() == 200 assert account1.transfer(500, account2) == False # Insufficient funds def test_interest(): bank = Bank() bank.create_account(\\"user1\\", \\"password\\") account = bank.get_account(\\"user1\\", \\"password\\") account.deposit(1000) bank.calculate_interest_for_all_accounts() assert abs(account.get_balance() - 1010) < 1e-9 # 1% interest if __name__ == \\"__main__\\": pytest.main()","solution":"import time class Transaction: def __init__(self, amount, transaction_type): self.amount = amount self.transaction_type = transaction_type self.timestamp = time.time() class Account: def __init__(self, username, password): self.username = username self.password = password self.balance = 0 self.transactions = [] def deposit(self, amount): if amount > 0: self.balance += amount self.transactions.append(Transaction(amount, 'deposit')) return True return False def withdraw(self, amount): if amount <= self.balance: self.balance -= amount self.transactions.append(Transaction(amount, 'withdraw')) return True return False def transfer(self, amount, target_account): if self.withdraw(amount): target_account.deposit(amount) self.transactions.append(Transaction(amount, 'transfer')) return True return False def get_balance(self): return self.balance def apply_interest(self): interest = self.balance * 0.01 self.balance += interest self.transactions.append(Transaction(interest, 'interest')) class Bank: def __init__(self): self.accounts = {} def create_account(self, username, password): if username not in self.accounts: self.accounts[username] = Account(username, password) return True return False def get_account(self, username, password): account = self.accounts.get(username) if account and account.password == password: return account return None def calculate_interest_for_all_accounts(self): for account in self.accounts.values(): account.apply_interest()"},{"question":"def strings_starting_with_target(strings_list: List[str], target_string: str) -> List[str]: Create a Python function that takes a list of strings and a target string as input, and returns a new list containing only those strings from the original list that start with the target string. The function is case-insensitive. :param strings_list: List of strings to search through. :param target_string: Target string to match the start of each string in the list. :return: List of strings that start with the target string (case-insensitive). Example: >>> strings_starting_with_target([\\"hello\\", \\"world\\", \\"hi\\", \\"house\\"], \\"h\\") [\\"hello\\", \\"hi\\", \\"house\\"] >>> strings_starting_with_target([\\"Hello\\", \\"world\\", \\"Hi\\", \\"House\\"], \\"h\\") [\\"Hello\\", \\"Hi\\", \\"House\\"]","solution":"def strings_starting_with_target(strings_list, target_string): Returns a list of strings that start with the target string (case-insensitive). :param strings_list: List of strings to search through :param target_string: Target string to match the start of each string in the list :return: List of strings that start with the target string target_string_lower = target_string.lower() return [string for string in strings_list if string.lower().startswith(target_string_lower)]"},{"question":"def primes_less_than(n: int) -> List[int]: Returns a list of all prime numbers less than n. >>> primes_less_than(10) [2, 3, 5, 7] >>> primes_less_than(2) [] >>> primes_less_than(1) [] >>> primes_less_than(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> primes_less_than(3) [2] >>> primes_less_than(4) [2, 3] >>> primes_less_than(5) [2, 3]","solution":"def primes_less_than(n): Returns a list of all prime numbers less than n. if n <= 2: return [] primes = [] for num in range(2, n): is_prime = True for i in range(2, int(num**0.5) + 1): if num % i == 0: is_prime = False break if is_prime: primes.append(num) return primes"},{"question":"def second_largest_unique(nums: List[int]) -> Optional[int]: Write a Python function to determine the second largest unique number in a given list of integers. The function should return \`None\` if there are not enough unique numbers to determine the second largest one. It should handle cases with negative numbers and duplicates properly. Args: nums (List[int]): List of integers to check. Returns: Optional[int]: The second largest unique number or None if not applicable. Examples: >>> second_largest_unique([3, 1, 4, 1, 2, 5]) == 4 >>> second_largest_unique([4, 4, 4, 4]) == None >>> second_largest_unique([10, 20, 20, 10, 30, 30, 40]) == 30","solution":"def second_largest_unique(nums): Returns the second largest unique number from the list of integers. Returns None if there are not enough unique numbers. unique_nums = list(set(nums)) if len(unique_nums) < 2: return None unique_nums.sort(reverse=True) return unique_nums[1]"},{"question":"import re from typing import Optional def longest_word(sentence: str) -> Optional[str]: Returns the longest word from the input string. If there is a tie, returns the word that appears first. Ignores punctuation marks. If the input string is empty, returns a custom message. >>> longest_word(\\"hello world, this is a fantastic day!\\") \\"fantastic\\" >>> longest_word(\\"the quick brown fox jumped over the lazy dog\\") \\"jumped\\" >>> longest_word(\\"\\") \\"The input string is empty.\\" >>> longest_word(\\"!!!! ???\\") \\"The input string contains no valid words.\\" >>> longest_word(\\"a ab abc\\") \\"abc\\" >>> longest_word(\\"a b c\\") \\"a\\" >>> longest_word(\\"123 12345 1234\\") \\"12345\\" >>> longest_word(\\"Hello World thereIsAveryLongWord\\") \\"thereIsAveryLongWord\\"","solution":"import re def longest_word(sentence): Returns the longest word from the input string. If there is a tie, returns the word that appears first. Ignores punctuation marks. If the input string is empty, returns a custom message. if not sentence: return \\"The input string is empty.\\" # Remove punctuation using regex words = re.findall(r'bw+b', sentence) if not words: return \\"The input string contains no valid words.\\" longest = max(words, key=len) return longest"},{"question":"def prime_product(numbers: list) -> int: This function takes a list of integers and returns the product of all prime numbers in the list. If there are no prime numbers in the list, it should return an error message. If the input is not a list of integers, the function should return an appropriate error message. For an empty input list, it should return an appropriate error message. >>> prime_product([2, 3, 4, 5, 6]) 30 >>> prime_product([11, 13, 17]) 2431 >>> prime_product([4, 6, 8, 10]) 'Error: No prime numbers in the list.' >>> prime_product([]) 'Error: Input list is empty.' >>> prime_product([2, 'three', 5]) 'Error: Invalid input.'","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def prime_product(numbers: list) -> int: This function takes a list of integers and returns the product of all prime numbers in the list. If there are no prime numbers in the list, it should return an error message. If the input is not a list of integers, the function should return an appropriate error message. For an empty input list, it should return an appropriate error message. if not isinstance(numbers, list): return 'Error: Invalid input.' if len(numbers) == 0: return 'Error: Input list is empty.' product = 1 prime_found = False for num in numbers: if not isinstance(num, int): return 'Error: Invalid input.' if is_prime(num): product *= num prime_found = True if not prime_found: return 'Error: No prime numbers in the list.' return product"},{"question":"def merge_and_sort(A: List[str], B: List[str]) -> List[str]: Merge and sort two large datasets A and B, ensuring no duplicates in the concatenated list. Example: >>> merge_and_sort([\\"apple\\", \\"banana\\", \\"cherry\\"], [\\"date\\", \\"fig\\"]) [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"fig\\"] >>> merge_and_sort([\\"apple\\", \\"banana\\", \\"cherry\\"], [\\"banana\\", \\"date\\", \\"fig\\"]) [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"fig\\"] >>> merge_and_sort([\\"apple\\", \\"banana\\", \\"cherry\\"], [\\"apple\\", \\"banana\\", \\"cherry\\"]) [\\"apple\\", \\"banana\\", \\"cherry\\"] >>> merge_and_sort([], [\\"banana\\", \\"date\\", \\"fig\\"]) [\\"banana\\", \\"date\\", \\"fig\\"] >>> merge_and_sort([\\"apple\\", \\"banana\\", \\"cherry\\"], []) [\\"apple\\", \\"banana\\", \\"cherry\\"] >>> merge_and_sort([], []) []","solution":"def merge_and_sort(A, B): Merge two lists A and B, remove duplicates, and return the sorted result. Args: A (list of str): First list of strings. B (list of str): Second list of strings. Returns: list of str: Merged, de-duplicated, and sorted list of strings. # Combine the two lists and remove duplicates by using set combined_set = set(A).union(set(B)) # Convert the set back to a list and sort it sorted_list = sorted(combined_set) return sorted_list"},{"question":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges overlapping intervals. :param intervals: List of tuples, where each tuple represents an interval (start, end) :return: List of merged intervals >>> merge_intervals([(1, 3), (2, 6)]) [(1, 6)] >>> merge_intervals([(1, 3), (4, 6)]) [(1, 3), (4, 6)] pass","solution":"def merge_intervals(intervals): Merges overlapping intervals. :param intervals: List of tuples, where each tuple represents an interval (start, end) :return: List of merged intervals if not intervals: return [] # Sort intervals based on the starting time intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for i in range(1, len(intervals)): current_interval = intervals[i] last_merged_interval = merged[-1] # If the current interval overlaps with the last merged interval, merge them if current_interval[0] <= last_merged_interval[1]: merged[-1] = (last_merged_interval[0], max(last_merged_interval[1], current_interval[1])) else: merged.append(current_interval) return merged"},{"question":"def find_intersections(arr1, arr2): Function to find the intersection of two integer arrays preserving the order of first appearance and ignoring non-integer elements. Parameters: arr1 (list): First list of elements. arr2 (list): Second list of elements. Returns: list: List containing the intersection of the two input lists. >>> find_intersections([1, 2, 2, 3], [2, 2, 3, 4]) [2, 2, 3] >>> find_intersections([1, 'a', 3, 3], [3, 3, 3, 5]) [3, 3] >>> find_intersections([], [1, 2, 3]) [] >>> find_intersections([1, 2, 3], ['a', 'b', 'c']) []","solution":"def find_intersections(arr1, arr2): Function to find the intersection of two integer arrays preserving the order of first appearance and ignoring non-integer elements. Parameters: arr1 (list): First list of elements. arr2 (list): Second list of elements. Returns: list: List containing the intersection of the two input lists. def is_integer(n): return isinstance(n, int) counts1 = {} counts2 = {} for num in arr1: if is_integer(num): counts1[num] = counts1.get(num, 0) + 1 for num in arr2: if is_integer(num): counts2[num] = counts2.get(num, 0) + 1 intersection = [] for num in counts1: if num in counts2: intersection.extend([num] * min(counts1[num], counts2[num])) return [num for num in arr1 if num in intersection and is_integer(num) and intersection.remove(num) is None]"},{"question":"import re from typing import List, Dict def word_count(word_list: List[str], sentence: str) -> Dict[str, int]: Returns a dictionary with the count of each word from word_list found in the sentence. :param word_list: List of words to search for in the sentence :param sentence: The sentence in which to count the occurrences of the words :return: A dictionary with words as keys and their counts as values >>> word_count([\\"example\\", \\"words\\", \\"frequency\\", \\"ignore\\"], \\"This is an example sentence, with words to count and check frequency. We should also ignore punctuation.\\") {\\"example\\": 1, \\"words\\": 1, \\"frequency\\": 1, \\"ignore\\": 1} >>> word_count([\\"this\\", \\"is\\", \\"test\\"], \\"This is a TEST, this IS only a test.\\") {\\"this\\": 2, \\"is\\": 2, \\"test\\": 2} >>> word_count([\\"hello\\", \\"world\\"], \\"Hello, world! Hello world!!!\\") {\\"hello\\": 2, \\"world\\": 2} >>> word_count([\\"single\\"], \\"This sentence contains the word single just once.\\") {\\"single\\": 1} >>> word_count([\\"none\\", \\"here\\"], \\"This sentence does not contain the specified words.\\") {\\"none\\": 0, \\"here\\": 0}","solution":"import re from collections import defaultdict def word_count(word_list, sentence): Returns a dictionary with the count of each word from word_list found in the sentence. :param word_list: List of words to search for in the sentence :param sentence: The sentence in which to count the occurrences of the words :return: A dictionary with words as keys and their counts as values # Convert the sentence to lowercase to make the process case-insensitive sentence = sentence.lower() # Remove punctuation from the sentence processed_sentence = re.sub(r'[^ws]', '', sentence) # Split the sentence into words words_in_sentence = processed_sentence.split() # Initialize a dictionary with default value of 0 word_count_dict = defaultdict(int) # Count occurrences of each word in the word_list for word in word_list: word_count_dict[word.lower()] = words_in_sentence.count(word.lower()) return dict(word_count_dict)"},{"question":"def single_number(nums): Finds the single number in a list where every other number appears twice except for one. :param nums: List of integers where each element appears twice except for one. :return: The single integer that appears only once. pass def test_single_number(): assert single_number([4, 1, 2, 1, 2]) == 4 assert single_number([2, 3, 2]) == 3 assert single_number([1]) == 1 assert single_number([0, 0, 5, 3, 3, 5, 99]) == 99 assert single_number([-1, -2, -2, -1, -3]) == -3 def test_single_number_large_input(): assert single_number([i for i in range(10000)] * 2 + [123456]) == 123456","solution":"def single_number(nums): Finds the single number in a list where every other number appears twice. :param nums: List of integers where each element appears twice except for one. :return: The single integer that appears only once. result = 0 for num in nums: result ^= num return result"},{"question":"def maximum_difference(nums: List[int]) -> int: Returns the maximum difference between any two elements such that the larger element comes after the smaller element. If no such pair exists, returns 0. >>> maximum_difference([]) == 0 >>> maximum_difference([5]) == 0 >>> maximum_difference([1, 2]) == 1 >>> maximum_difference([2, 1]) == 0 >>> maximum_difference([4, 3, 10, 2, 9, 7]) == 7 >>> maximum_difference([10, 9, 8, 7, 6]) == 0 >>> maximum_difference([1, 2, 2, 3, 1]) == 2 >>> maximum_difference([7, 1, 5, 3, 6, 4]) == 5","solution":"def maximum_difference(nums): Returns the maximum difference between any two elements such that the larger element comes after the smaller element. If no such pair exists, returns 0. if len(nums) < 2: return 0 min_element = nums[0] max_diff = 0 for num in nums[1:]: if num > min_element: max_diff = max(max_diff, num - min_element) min_element = min(min_element, num) return max_diff"},{"question":"def letter_frequency_count(s: str) -> dict: Write a function in Python that takes a string as input and returns a dictionary with the frequency count of each letter in the string. The function should be case-insensitive and should ignore non-alphabet characters. Example: >>> letter_frequency_count(\\"The quick brown fox jumps over the lazy dog!\\") { 'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 3, 'f': 1, 'g': 1, 'h': 2, 'i': 1, 'j': 1, 'k': 1, 'l': 1, 'm': 1, 'n': 1, 'o': 4, 'p': 1, 'q': 1, 'r': 2, 's': 1, 't': 2, 'u': 2, 'v': 1, 'w': 1, 'x': 1, 'y': 1, 'z': 1 } from solution import letter_frequency_count def test_letter_frequency_count(): assert letter_frequency_count(\\"The quick brown fox jumps over the lazy dog!\\") == { 'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 3, 'f': 1, 'g': 1, 'h': 2, 'i': 1, 'j': 1, 'k': 1, 'l': 1, 'm': 1, 'n': 1, 'o': 4, 'p': 1, 'q': 1, 'r': 2, 's': 1, 't': 2, 'u': 2, 'v': 1, 'w': 1, 'x': 1, 'y': 1, 'z': 1 } def test_empty_string(): assert letter_frequency_count(\\"\\") == {} def test_mixed_case(): assert letter_frequency_count(\\"AaBbCc\\") == {'a': 2, 'b': 2, 'c': 2} def test_non_alphabet_characters(): assert letter_frequency_count(\\"123!@#abcABC\\") == {'a': 2, 'b': 2, 'c': 2} def test_all_same_letter(): assert letter_frequency_count(\\"aaaaa\\") == {'a': 5} def test_no_letters(): assert letter_frequency_count(\\"12345!@#%\\") == {}","solution":"def letter_frequency_count(s): Returns a dictionary with the frequency count of each letter in the input string. The function is case-insensitive and ignores non-alphabet characters. frequency = {} for char in s.lower(): if char.isalpha(): if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"def shift_characters(s): In a given input string \`s\`, replace each character with the next character in the ASCII table. If a character is 'z' or 'Z', it should wrap around to 'a' or 'A' respectively. Ignore non-alphabetical characters in the input string and keep them in their original position. Examples: >>> shift_characters('abcdxyz') == 'bcdeyza' >>> shift_characters('Hello, World!') == 'Ifmmp, Xpsme!' >>> shift_characters('Python3.8') == 'Qzuipo3.8' >>> shift_characters('Zebra') == 'Afcsb'","solution":"def shift_characters(s): In a given input string \`s\`, replace each character with the next character in the ASCII table. If a character is 'z' or 'Z', it should wrap around to 'a' or 'A' respectively. Ignore non-alphabetical characters in the input string and keep them in their original position. result = [] for char in s: if 'a' <= char <= 'y': result.append(chr(ord(char) + 1)) elif char == 'z': result.append('a') elif 'A' <= char <= 'Y': result.append(chr(ord(char) + 1)) elif char == 'Z': result.append('A') else: result.append(char) return ''.join(result)"},{"question":"import requests from concurrent.futures import ThreadPoolExecutor def fetch_status(url): Fetches the HTTP status code for a given URL. Handles exceptions for unreachable URLs. try: response = requests.get(url) return (url, response.status_code) except requests.RequestException: return (url, 'unreachable') def fetch_status_codes(urls): Fetches HTTP status codes for a list of URLs concurrently. results = [] with ThreadPoolExecutor(max_workers=10) as executor: results = list(executor.map(fetch_status, urls)) return results Develop a program that takes a list of URLs and fetches their HTTP status codes. Your program should be able to handle cases where URLs are unreachable and should accurately report failures alongside successful responses. Additionally, ensure the program is optimized to handle a large list of URLs concurrently to minimize execution time. >>> urls = [\\"https://httpbin.org/status/200\\", \\"https://httpbin.org/status/204\\"] >>> fetch_status_codes(urls) [(\\"https://httpbin.org/status/200\\", 200), (\\"https://httpbin.org/status/204\\", 204)] >>> urls = [\\"https://httpbin.org/status/200\\", \\"https://nonexistent.url\\"] >>> fetch_status_codes(urls) [(\\"https://httpbin.org/status/200\\", 200), (\\"https://nonexistent.url\\", 'unreachable')] >>> urls = [\\"https://definitely.fake.url\\", \\"https://anotherfake.url\\"] >>> fetch_status_codes(urls) [(\\"https://definitely.fake.url\\", 'unreachable'), (\\"https://anotherfake.url\\", 'unreachable')] >>> urls = [\\"https://httpbin.org/status/200\\", \\"https://nonexistent.url\\", \\"https://httpbin.org/status/404\\"] >>> fetch_status_codes(urls) [(\\"https://httpbin.org/status/200\\", 200), (\\"https://nonexistent.url\\", 'unreachable'), (\\"https://httpbin.org/status/404\\", 404)]","solution":"import requests from concurrent.futures import ThreadPoolExecutor def fetch_status(url): Fetches the HTTP status code for a given URL. Handles exceptions for unreachable URLs. try: response = requests.get(url) return (url, response.status_code) except requests.RequestException: return (url, 'unreachable') def fetch_status_codes(urls): Fetches HTTP status codes for a list of URLs concurrently. results = [] with ThreadPoolExecutor(max_workers=10) as executor: results = list(executor.map(fetch_status, urls)) return results"},{"question":"from typing import List, Dict, Callable def determine_upgrades(devices: Dict[str, Dict[str, int]], upgrade_conditions: List[Callable[[Dict[str, int]], bool]]) -> List[str]: Identifies devices that do not meet all upgrade conditions. Parameters: devices (dict): Dictionary of devices with their properties. upgrade_conditions (list): List of lambda functions representing upgrade conditions. Returns: list: List of device names that need an upgrade. >>> devices = { ... \\"Router1\\": {\\"RAM\\": 4, \\"Storage\\": 128}, ... \\"Router2\\": {\\"RAM\\": 16, \\"Storage\\": 512}, ... \\"Switch1\\": {\\"RAM\\": 8, \\"Storage\\": 128}, ... \\"Switch2\\": {\\"RAM\\": 4, \\"Storage\\": 256}, ... } >>> upgrade_conditions = [ ... lambda d: d[\\"RAM\\"] >= 8, ... lambda d: d[\\"Storage\\"] >= 256 ... ] >>> determine_upgrades(devices, upgrade_conditions) ['Router1', 'Switch1']","solution":"def determine_upgrades(devices, upgrade_conditions): Identifies devices that do not meet all upgrade conditions. Parameters: devices (dict): Dictionary of devices with their properties. upgrade_conditions (list): List of lambda functions representing upgrade conditions. Returns: list: List of device names that need an upgrade. to_upgrade = [] for device_name, device_props in devices.items(): if not all(condition(device_props) for condition in upgrade_conditions): to_upgrade.append(device_name) return to_upgrade"},{"question":"def find_max_product(nums): Returns the maximum product of any three numbers in the list. Raises a ValueError if the input list contains fewer than three numbers. Args: nums (List[int]): The list of integers. Returns: int: The maximum product of any three numbers. Example usage: >>> find_max_product([1, 10, -5, 1, -100]) 5000 >>> find_max_product([1, 2, 3, 4, 5]) 60 >>> find_max_product([-10, -10, 5, 2]) 500 >>> find_max_product([-1, -2, -3, -4]) -6 >>> find_max_product([-10, 0, 2, 3, 0, 1]) 6 >>> find_max_product([1, 2]) # should raise ValueError ValueError: Input list must contain at least three numbers.","solution":"def find_max_product(nums): Returns the maximum product of any three numbers in the list. Raises a ValueError if the input list contains fewer than three numbers. Args: nums (List[int]): The list of integers. Returns: int: The maximum product of any three numbers. Example usage: nums = [1, 10, -5, 1, -100] The maximum product of any three numbers is 5000 (-100 * -5 * 10) find_max_product(nums) -> 5000 if len(nums) < 3: raise ValueError(\\"Input list must contain at least three numbers.\\") nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def accumulate_sums(lst): Accepts a list of integers and returns a new list where each integer is increased by the sum of all preceding integers. :param lst: List of integers :return: New list with accumulated sums >>> accumulate_sums([1, 2, 3, 4]) [1, 3, 6, 10] >>> accumulate_sums([10]) [10] >>> accumulate_sums([]) [] >>> accumulate_sums([0, 1, 2]) [0, 1, 3] >>> accumulate_sums([1, -1, 3, -3]) [1, 0, 3, 0] >>> accumulate_sums([-1, 2, -3, 4]) [-1, 1, -2, 2]","solution":"def accumulate_sums(lst): Accepts a list of integers and returns a new list where each integer is increased by the sum of all preceding integers. :param lst: List of integers :return: New list with accumulated sums result = [] current_sum = 0 for num in lst: current_sum += num result.append(current_sum) return result"},{"question":"from typing import List, Dict def prime_factorials(numbers: List[int]) -> Dict[int, int]: Write a function that receives a list of integers and performs the following operations: 1. Find all the prime numbers in the list. 2. Compute the factorial of each prime number. 3. Return a dictionary where the keys are the prime numbers and the values are their respective factorials. >>> prime_factorials([2, 3, 4, 5, 6, 7, 8, 9, 10]) {2: 2, 3: 6, 5: 120, 7: 5040} >>> prime_factorials([4, 6, 8, 9, 10]) {} >>> prime_factorials([2, 3, 5, 7]) {2: 2, 3: 6, 5: 120, 7: 5040} >>> prime_factorials([1, 2, 3, 4]) {2: 2, 3: 6} >>> prime_factorials([-1, -2, 2, 3]) {2: 2, 3: 6} >>> prime_factorials([]) {}","solution":"from math import factorial def is_prime(n): if n <= 1: return False for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return False return True def prime_factorials(numbers): primes = [num for num in numbers if is_prime(num)] return {prime: factorial(prime) for prime in primes}"},{"question":"import pandas as pd import numpy as np from sklearn.model_selection import train_test_split from sklearn.decomposition import TruncatedSVD from sklearn.metrics import mean_squared_error, mean_absolute_error def load_sample_data(): Loads a sample dataset. >>> df = load_sample_data() >>> not df.empty True >>> list(df.columns) ['user_id', 'item_id', 'rating'] pass def perform_eda(df): Conducts exploratory data analysis on the given dataframe. >>> df = load_sample_data() >>> perform_eda(df) Ratings distribution: 5 3 4 3 3 2 2 1 Name: rating, dtype: int64 Unique users: 5 Unique items: 5 Missing values: user_id 0 item_id 0 rating 0 dtype: int64 pass def train_test_split_data(df): Splits the data into training and testing sets. >>> df = load_sample_data() >>> train_data, test_data = train_test_split_data(df) >>> not train_data.empty True >>> not test_data.empty True >>> len(train_data) + len(test_data) == len(df) True pass def create_matrix(df): Creates a user-item interaction matrix from the given dataframe. >>> df = load_sample_data() >>> matrix = create_matrix(df) >>> matrix.shape[0] == df['user_id'].nunique() True >>> matrix.shape[1] == df['item_id'].nunique() True pass def collaborative_filtering(train_matrix, test_data): Implement and evaluate collaborative filtering using SVD. >>> df = load_sample_data() >>> train_data, test_data = train_test_split_data(df) >>> train_matrix = create_matrix(train_data) >>> metrics = collaborative_filtering(train_matrix, test_data) >>> type(metrics) is dict True >>> 'RMSE' in metrics and 'MAE' in metrics True pass def content_based_filtering(new_user_profile, item_metadata): Implement content-based filtering using item metadata. >>> new_user_profile = {'user_id': 6, 'genre': 'Adventure'} >>> item_metadata = { 101: {'genre': 'Adventure'}, 102: {'genre': 'Horror'}, 103: {'genre': 'Comedy'}, 104: {'genre': 'Sci-Fi'}, 105: {'genre': 'Adventure'} } >>> recommended_items = content_based_filtering(new_user_profile, item_metadata) >>> recommended_items [101, 105] pass","solution":"import pandas as pd import numpy as np from sklearn.model_selection import train_test_split from sklearn.decomposition import TruncatedSVD from sklearn.metrics import mean_squared_error, mean_absolute_error # Load sample dataset def load_sample_data(): Loads a sample dataset. data = { 'user_id': [1, 2, 3, 4, 5, 1, 2, 3, 4, 5], 'item_id': [101, 101, 101, 102, 102, 103, 103, 104, 105, 105], 'rating': [5, 4, 4, 3, 5, 4, 2, 5, 3, 4] } df = pd.DataFrame(data) return df # Exploratory Data Analysis (EDA) def perform_eda(df): Conducts exploratory data analysis on the given dataframe. print(\\"Ratings distribution:n\\", df['rating'].value_counts()) print(\\"Unique users:\\", df['user_id'].nunique()) print(\\"Unique items:\\", df['item_id'].nunique()) print(\\"Missing values:n\\", df.isnull().sum()) # Train-test split def train_test_split_data(df): Splits the data into training and testing sets. train_data, test_data = train_test_split(df, test_size=0.2, random_state=42) return train_data, test_data # Create User-Item interaction matrix def create_matrix(df): Creates a user-item interaction matrix from the given dataframe. user_item_matrix = df.pivot(index='user_id', columns='item_id', values='rating').fillna(0) return user_item_matrix # Collaborative Filtering using SVD def collaborative_filtering(train_matrix, test_data): Implement and evaluate collaborative filtering using SVD. svd = TruncatedSVD(n_components=min(train_matrix.shape)-1, random_state=42) U = svd.fit_transform(train_matrix) sigma = np.diag(svd.singular_values_) Vt = svd.components_ predicted_matrix = np.dot(np.dot(U, sigma), Vt) results = [] test_matrix = test_data.pivot(index='user_id', columns='item_id', values='rating').fillna(0) for _, row in test_data.iterrows(): user_idx = row['user_id'] - 1 item_idx = row['item_id'] if item_idx in test_matrix.columns: item_idx = list(test_matrix.columns).index(item_idx) actual_rating = row['rating'] pred_rating = predicted_matrix[user_idx, item_idx] results.append((actual_rating, pred_rating)) y_true, y_pred = zip(*results) rmse = np.sqrt(mean_squared_error(y_true, y_pred)) mae = mean_absolute_error(y_true, y_pred) return {'RMSE': rmse, 'MAE': mae} # Content-Based Filtering def content_based_filtering(new_user_profile, item_metadata): Implement content-based filtering using item metadata. # Example item_metadata item_metadata = { 101: {'genre': 'Adventure'}, 102: {'genre': 'Horror'}, 103: {'genre': 'Comedy'}, 104: {'genre': 'Sci-Fi'}, 105: {'genre': 'Adventure'} } genre = new_user_profile['genre'] recommended_items = [item_id for item_id, meta in item_metadata.items() if meta['genre'] == genre] return recommended_items"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root: TreeNode) -> bool: Given a binary tree, checks if the tree is symmetric around its center. A tree is symmetric if the left subtree is a mirror reflection of the right subtree. Examples: >>> root1 = TreeNode(1) >>> root1.left = TreeNode(2) >>> root1.right = TreeNode(2) >>> root1.left.left = TreeNode(3) >>> root1.left.right = TreeNode(4) >>> root1.right.left = TreeNode(4) >>> root1.right.right = TreeNode(3) >>> isSymmetric(root1) True >>> root2 = TreeNode(1) >>> root2.left = TreeNode(2) >>> root2.right = TreeNode(2) >>> root2.left.right = TreeNode(3) >>> root2.right.right = TreeNode(3) >>> isSymmetric(root2) False pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root: TreeNode) -> bool: if not root: return True def isMirror(left: TreeNode, right: TreeNode) -> bool: if not left and not right: return True if not left or not right: return False return (left.val == right.val) and isMirror(left.left, right.right) and isMirror(left.right, right.left) return isMirror(root.left, root.right)"},{"question":"def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome, considering only alphanumeric characters and ignoring cases. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\" \\") True >>> is_palindrome(\\"Able was I, ere I saw Elba\\") True >>> is_palindrome(\\"No lemon, no melon\\") True def are_anagrams(s1: str, s2: str) -> bool: Checks if the two given strings are anagrams of each other. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"triangle\\", \\"integral\\") True >>> are_anagrams(\\"apple\\", \\"pale\\") False >>> are_anagrams(\\"Astronomer\\", \\"Moon starer\\") True >>> are_anagrams(\\"The eyes\\", \\"They see\\") True >>> are_anagrams(\\"dormitory\\", \\"dirty room\\") True >>> are_anagrams(\\"Hello\\", \\"Olelh\\") True >>> are_anagrams(\\"Conversation\\", \\"Voices rant on\\") True","solution":"def is_palindrome(s): Checks if the given string is a palindrome, considering only alphanumeric characters and ignoring cases. left, right = 0, len(s) - 1 while left < right: while left < right and not s[left].isalnum(): left += 1 while left < right and not s[right].isalnum(): right -= 1 if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True def are_anagrams(s1, s2): Checks if the two given strings are anagrams of each other. from collections import Counter return Counter(s1.replace(\\" \\", \\"\\").lower()) == Counter(s2.replace(\\" \\", \\"\\").lower())"},{"question":"def contains_duplicates(nums: List[int]) -> bool: Identify if a list of integers contains any duplicate values. >>> contains_duplicates([1, 2, 3, 4, 5]) == False >>> contains_duplicates([1, 2, 3, 1, 4, 5]) == True >>> contains_duplicates([]) == False >>> contains_duplicates([1]) == False >>> contains_duplicates([1, 1, 1, 1, 1]) == True >>> contains_duplicates(list(range(10000)) + [1]) == True","solution":"def contains_duplicates(nums): Returns True if the input list \`nums\` contains any duplicates, otherwise False. nums_set = set() for num in nums: if num in nums_set: return True nums_set.add(num) return False"},{"question":"def car_rental_price(days: int) -> str: Calculates the total cost of renting a car based on the number of rental days. The base daily rate is 40. Discounts are applied based on the number of days rented: - 20 discount for 3 or more days - 50 discount for 7 or more days Args: days (int): Number of days the car is rented. Returns: str: Description with the total cost of renting the car. >>> car_rental_price(2) \\"The total cost for renting the car for 2 days is: 80\\" >>> car_rental_price(3) \\"The total cost for renting the car for 3 days is: 100\\" >>> car_rental_price(4) \\"The total cost for renting the car for 4 days is: 140\\" >>> car_rental_price(7) \\"The total cost for renting the car for 7 days is: 230\\" >>> car_rental_price(8) \\"The total cost for renting the car for 8 days is: 270\\" >>> car_rental_price(10) \\"The total cost for renting the car for 10 days is: 350\\"","solution":"def car_rental_price(days): Calculates the total cost of renting a car based on the number of rental days. The base daily rate is 40. Discounts are applied based on the number of days rented: - 20 discount for 3 or more days - 50 discount for 7 or more days Args: days (int): Number of days the car is rented. Returns: str: Description with the total cost of renting the car. base_rate = 40 total_cost = base_rate * days if days >= 7: total_cost -= 50 elif days >= 3: total_cost -= 20 return f\\"The total cost for renting the car for {days} days is: {total_cost}\\""},{"question":"def find_longest_consecutive_sequence(nums): Finds the length of the longest consecutive sequence of numbers in the list \`nums\`. The function should efficiently handle large lists. :param nums: list of integers :return: length of the longest consecutive sequence >>> find_longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> find_longest_consecutive_sequence([1]) 1 >>> find_longest_consecutive_sequence([]) 0 >>> find_longest_consecutive_sequence([1, 2, 2, 3, 4, 5]) 5 >>> find_longest_consecutive_sequence([1, 10, 100]) 1 >>> find_longest_consecutive_sequence(list(range(10000))) 10000","solution":"def find_longest_consecutive_sequence(nums): Finds the length of the longest consecutive sequence of numbers in the list \`nums\`. The function should efficiently handle large lists. :param nums: list of integers :return: length of the longest consecutive sequence if not nums: return 0 num_set = set(nums) # Convert list to a set to remove duplicates and for O(1) look-up times max_length = 0 for num in num_set: if num - 1 not in num_set: # Check if it's the start of a sequence current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a string containing a mathematical expression with integers and the operators '+', '-', '*', '/' and parentheses, following the correct order of operations (PEMDAS/BODMAS rules). >>> evaluate_expression(\\"3 + 5\\") 8 >>> evaluate_expression(\\"2 + 3 * 4\\") 14 >>> evaluate_expression(\\"2 * (3 + 4)\\") 14 >>> evaluate_expression(\\"8 / 2\\") 4 >>> evaluate_expression(\\"2 + 3 * (2 + 3) / 2 - 5\\") 4 >>> evaluate_expression(\\"-2 + 3 * (-2 + 3)\\") 1 >>> evaluate_expression(\\"2 + * 3\\") # This should raise a ValueError Traceback (most recent call last): ... ValueError: Invalid mathematical expression pass","solution":"def evaluate_expression(expression): Evaluate the mathematical expression with integers and operators +, -, *, /, and parentheses. The function follows the correct order of operations (PEMDAS/BODMAS rules). try: # Safely evaluating the mathematical expression result = eval(expression) return int(result) except Exception as e: raise ValueError(\\"Invalid mathematical expression\\") from e"},{"question":"def count_string_frequencies(strings: List[str]) -> dict: Takes a list of strings as input and returns a dictionary where the keys are the strings and the values are the frequencies of each string in the list. The function should handle case sensitivity. >>> count_string_frequencies(['apple', 'banana', 'Apple', 'banana', 'banana']) {'apple': 1, 'banana': 3, 'Apple': 1} >>> count_string_frequencies(['Apple', 'apple', 'APPLE']) {'Apple': 1, 'apple': 1, 'APPLE': 1}","solution":"def count_string_frequencies(strings): Takes a list of strings and returns a dictionary with the strings as keys and their frequencies as values. Parameters: strings (list): A list of strings. Returns: dict: A dictionary with string frequencies. frequency_dict = {} for string in strings: if string in frequency_dict: frequency_dict[string] += 1 else: frequency_dict[string] = 1 return frequency_dict"},{"question":"def roman_to_int(roman: str) -> int: Converts a Roman numeral string to an integer. Raises ValueError for invalid Roman numerals. >>> roman_to_int('III') 3 >>> roman_to_int('IV') 4 >>> roman_to_int('IX') 9 >>> roman_to_int('LVIII') 58 >>> roman_to_int('MCMXCIV') 1994 >>> roman_to_int('IIII') ValueError: Invalid Roman numeral >>> roman_to_int('IC') ValueError: Invalid Roman numeral >>> roman_to_int('A') ValueError: Invalid Roman numeral","solution":"def roman_to_int(roman): Converts a Roman numeral string to an integer. :param roman: str: Roman numeral to convert :return: int: Equivalent integer value of the Roman numeral, or raises ValueError for invalid Roman numerals roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000} subtractive_combinations = {'IV': 4, 'IX': 9, 'XL': 40, 'XC': 90, 'CD': 400, 'CM': 900} # Validate Roman numeral validation_pattern = '^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})' import re if not re.match(validation_pattern, roman): raise ValueError(\\"Invalid Roman numeral\\") total = 0 i = 0 while i < len(roman): # Check for subtractive combination if i + 1 < len(roman) and roman[i:i+2] in subtractive_combinations: total += subtractive_combinations[roman[i:i+2]] i += 2 else: total += roman_values[roman[i]] i += 1 return total"},{"question":"Original Requirements The boss requires an event scheduling application that allows users to create events, send invites, and manage RSVPs. The application should integrate with popular calendar services like Google Calendar and Outlook. Product Goals [ \\"Create an event scheduling application to manage events and RSVPs.\\", \\"Enable integration with Google Calendar and Outlook.\\", \\"Allow users to send invites and track attendance.\\" ] User Stories [ \\"As a user, I want to create events and add them to my calendar so I can keep track of my schedule.\\", \\"As a user, I want to send invites to my contacts so I can share event details and get confirmations.\\", \\"As a user, I want to receive notifications about upcoming events so I don't miss them.\\", \\"As an admin, I want to manage RSVPs to know how many people are attending.\\", \\"As a user, I want the app to sync with my Google Calendar and Outlook so my events are always up-to-date.\\" ] Competitive Analysis [ \\"EventBrite: A widely used event management app with comprehensive event planning and ticketing options.\\", \\"Meetup: Focuses on social gatherings and community events, offering event creation and group management tools.\\", \\"Doodle: Simplifies event scheduling by coordinating availability among participants.\\", \\"Calendly: Primarily a scheduling tool but useful for setting up meetings and events.\\", \\"RSVPify: Focuses on digital invitations and RSVP management for various event types.\\", \\"Facebook Events: Integrates with social media to create and promote events among friends and followers.\\", \\"Evite: Specializes in customized invitations and RSVP tracking.\\" ] Competitive Quadrant Chart mermaid quadrantChart title Reach and engagement of event applications x-axis Low Reach --> High Reach y-axis Low Engagement --> High Engagement quadrant-1 Strong presence quadrant-2 Needs improvement quadrant-3 Limited appeal quadrant-4 Untapped potential \\"EventBrite\\": [0.8, 0.7] \\"Meetup\\": [0.7, 0.6] \\"Doodle\\": [0.5, 0.4] \\"Calendly\\": [0.6, 0.5] \\"RSVPify\\": [0.4, 0.3] \\"Facebook Events\\": [0.9, 0.8] \\"Evite\\": [0.3, 0.4] \\"Our Target App\\": [0.4, 0.7] Requirement Analysis The product should be an easy-to-use event scheduling tool that integrates with existing popular calendar services to ensure users can seamlessly manage their schedules and RSVPs. Requirement Pool [ (\\"Allow users to create events and add them to their calendars\\", \\"P0\\"), (\\"Enable sending invites and managing RSVPs\\", \\"P0\\"), (\\"Integrate with Google Calendar\\", \\"P1\\"), (\\"Integrate with Outlook Calendar\\", \\"P1\\"), (\\"Provide event notifications and reminders\\", \\"P2\\") ] UI Design draft The UI should include the following elements: 1. Event creation form with fields for event name, date, time, location, and description. 2. Invite management section for sending invites and tracking RSVPs. 3. Calendar view to see all scheduled events. 4. Integration options for syncing with Google Calendar and Outlook. 5. Notification settings for managing event reminders. Style: - Clean and modern design with a focus on usability. - Responsive layout to work on both desktop and mobile devices. - Intuitive navigation with clear labels and tooltips. Layout: - Main dashboard displaying upcoming events and recent activities. - Side navigation for accessing different sections like Event Management, Invites, Calendar Sync, and Notifications. Anything UNCLEAR Integration with additional calendar services beyond Google Calendar and Outlook could be clarified. It may also be important to define the extent of invite management features, such as the ability to send follow-up messages or to view statistics on RSVPs.","solution":"# Original Requirements Original Requirements: Provide as Plain text, place the polished complete original requirements here The boss requires an event scheduling application that allows users to create events, send invites, and manage RSVPs. The application should integrate with popular calendar services like Google Calendar and Outlook. Product Goals: Provided as Python list[str], up to 3 clear, orthogonal product goals. If the requirement itself is simple, the goal should also be simple [ \\"Create an event scheduling application to manage events and RSVPs.\\", \\"Enable integration with Google Calendar and Outlook.\\", \\"Allow users to send invites and track attendance.\\" ] User Stories: Provided as Python list[str], up to 5 scenario-based user stories, If the requirement itself is simple, the user stories should also be less [ \\"As a user, I want to create events and add them to my calendar so I can keep track of my schedule.\\", \\"As a user, I want to send invites to my contacts so I can share event details and get confirmations.\\", \\"As a user, I want to receive notifications about upcoming events so I don't miss them.\\", \\"As an admin, I want to manage RSVPs to know how many people are attending.\\", \\"As a user, I want the app to sync with my Google Calendar and Outlook so my events are always up-to-date.\\" ] Competitive Analysis: Provided as Python list[str], up to 7 competitive product analyses, consider as similar competitors as possible [ \\"EventBrite: A widely used event management app with comprehensive event planning and ticketing options.\\", \\"Meetup: Focuses on social gatherings and community events, offering event creation and group management tools.\\", \\"Doodle: Simplifies event scheduling by coordinating availability among participants.\\", \\"Calendly: Primarily a scheduling tool but useful for setting up meetings and events.\\", \\"RSVPify: Focuses on digital invitations and RSVP management for various event types.\\", \\"Facebook Events: Integrates with social media to create and promote events among friends and followers.\\", \\"Evite: Specializes in customized invitations and RSVP tracking.\\" ] Competitive Quadrant Chart: Use mermaid quadrantChart code syntax. up to 14 competitive products. Translation: Distribute these competitor scores evenly between 0 and 1, trying to conform to a normal distribution centered around 0.5 as much as possible. mermaid quadrantChart title Reach and engagement of event applications x-axis Low Reach --> High Reach y-axis Low Engagement --> High Engagement quadrant-1 Strong presence quadrant-2 Needs improvement quadrant-3 Limited appeal quadrant-4 Untapped potential \\"EventBrite\\": [0.8, 0.7] \\"Meetup\\": [0.7, 0.6] \\"Doodle\\": [0.5, 0.4] \\"Calendly\\": [0.6, 0.5] \\"RSVPify\\": [0.4, 0.3] \\"Facebook Events\\": [0.9, 0.8] \\"Evite\\": [0.3, 0.4] \\"Our Target App\\": [0.4, 0.7] Requirement Analysis: Provide as Plain text. Be simple. LESS IS MORE. Make your requirements less dumb. Delete the parts unnessasery. The product should be an easy-to-use event scheduling tool that integrates with existing popular calendar services to ensure users can seamlessly manage their schedules and RSVPs. Requirement Pool: Provided as Python list[str, str], the parameters are requirement description, priority(P0/P1/P2), respectively, comply with PEP standards; no more than 5 requirements and consider to make its difficulty lower [ (\\"Allow users to create events and add them to their calendars\\", \\"P0\\"), (\\"Enable sending invites and managing RSVPs\\", \\"P0\\"), (\\"Integrate with Google Calendar\\", \\"P1\\"), (\\"Integrate with Outlook Calendar\\", \\"P1\\"), (\\"Provide event notifications and reminders\\", \\"P2\\") ] UI Design draft: Provide as Plain text. Be simple. Describe the elements and functions, also provide a simple style description and layout description. The UI should include the following elements: 1. Event creation form with fields for event name, date, time, location, and description. 2. Invite management section for sending invites and tracking RSVPs. 3. Calendar view to see all scheduled events. 4. Integration options for syncing with Google Calendar and Outlook. 5. Notification settings for managing event reminders. Style: - Clean and modern design with a focus on usability. - Responsive layout to work on both desktop and mobile devices. - Intuitive navigation with clear labels and tooltips. Layout: - Main dashboard displaying upcoming events and recent activities. - Side navigation for accessing different sections like Event Management, Invites, Calendar Sync, and Notifications. Anything UNCLEAR: Provide as Plain text. Make clear here. Integration with additional calendar services beyond Google Calendar and Outlook could be clarified. It may also be important to define the extent of invite management features, such as the ability to send follow-up messages or to view statistics on RSVPs."},{"question":"def product_except_self(nums: List[int]) -> List[int]: Implement a function that takes a list of integers as input and returns a list of integers where each element is the product of all the integers in the input list except the one at the current index. You should solve this problem without using division. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([7, -2, -1, 3]) [6, -21, -42, 14] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_except_self([1, 0, 3, 4]) [0, 12, 0, 0] >>> product_except_self([1, 2]) [2, 1]","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: n = len(nums) result = [1] * n left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] right_product = 1 for i in range(n - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def substring_combinations(s, k): Returns a list of all distinct substrings of \`s\` with exactly \`k\` characters. :param s: Input string :param k: Length of the substrings :return: List of distinct substrings with length \`k\` >>> substring_combinations(\\"abcabc\\", 3) [\\"abc\\", \\"bca\\", \\"cab\\"] >>> substring_combinations(\\"abcdef\\", 2) [\\"ab\\", \\"bc\\", \\"cd\\", \\"de\\", \\"ef\\"] >>> substring_combinations(\\"\\", 3) [] >>> substring_combinations(\\"abc\\", 4) [] >>> substring_combinations(\\"abc\\", 0) [] >>> substring_combinations(\\"abc\\", -1) [] >>> substring_combinations(123, 2) raises TypeError >>> substring_combinations(\\"abc\\", \\"2\\") raises TypeError >>> substring_combinations(\\"aaaa\\", 1) [\\"a\\"] >>> substring_combinations(\\"aaaa\\", 2) [\\"aa\\"] >>> substring_combinations(\\"aabbcc\\", 2) [\\"aa\\", \\"ab\\", \\"bb\\", \\"bc\\", \\"cc\\"]","solution":"def substring_combinations(s, k): Returns a list of all distinct substrings of \`s\` with exactly \`k\` characters. :param s: Input string :param k: Length of the substrings :return: List of distinct substrings with length \`k\` if not isinstance(s, str): raise TypeError(\\"The input \`s\` must be a string\\") if not isinstance(k, int): raise TypeError(\\"The input \`k\` must be an integer\\") if k > len(s) or k <= 0 or len(s) == 0: return [] seen = set() result = [] for i in range(len(s) - k + 1): substring = s[i:i + k] if substring not in seen: seen.add(substring) result.append(substring) return result"},{"question":"def merge_and_sort(list1, list2): Merges two sorted lists into one sorted list with all duplicate values removed. >>> merge_and_sort([1, 3, 4, 5], [2, 3, 6, 7]) [1, 2, 3, 4, 5, 6, 7] >>> merge_and_sort([], []) [] >>> merge_and_sort([], [1, 2, 3]) [1, 2, 3] >>> merge_and_sort([1, 2, 3], [4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> merge_and_sort([1, 2, 3], [1, 2, 3]) [1, 2, 3] >>> merge_and_sort([-3, -2, -1, 0], [0, 1, 2, 3]) [-3, -2, -1, 0, 1, 2, 3] >>> merge_and_sort([1], [2]) [1, 2]","solution":"def merge_and_sort(list1, list2): Merges two sorted lists into one sorted list with all duplicate values removed. merged_list = list(set(list1 + list2)) merged_list.sort() return merged_list # Example usage list1 = [1, 3, 4, 5] list2 = [2, 3, 6, 7] result = merge_and_sort(list1, list2) print(result) # Output should be [1, 2, 3, 4, 5, 6, 7]"},{"question":"def count_trailing_zeros(n: int) -> int: Returns the number of trailing zeros in the factorial of n. >>> count_trailing_zeros(0) == 0 >>> count_trailing_zeros(1) == 0 >>> count_trailing_zeros(4) == 0 >>> count_trailing_zeros(5) == 1 >>> count_trailing_zeros(10) == 2 >>> count_trailing_zeros(25) == 6 >>> count_trailing_zeros(100) == 24 >>> count_trailing_zeros(125) == 31 >>> count_trailing_zeros(1000) == 249 >>> count_trailing_zeros(10000) == 2499 >>> count_trailing_zeros(100000) == 24999 >>> count_trailing_zeros(6) == 1 >>> count_trailing_zeros(11) == 2 >>> count_trailing_zeros(50) == 12","solution":"def count_trailing_zeros(n): Returns the number of trailing zeros in the factorial of n. count = 0 i = 5 while n >= i: count += n // i i *= 5 return count"},{"question":"def find_most_frequent_character(s: str) -> str: Returns the most frequent alphabetical character in the string \`s\`, ignoring case. If there are multiple characters with the same highest frequency, returns the one that appears first in the alphabet. In case of an empty string, returns an empty string. >>> find_most_frequent_character(\\"Hello World!\\") == \\"l\\" >>> find_most_frequent_character(\\"aAaAaaBbBbb\\") == \\"a\\" >>> find_most_frequent_character(\\"\\") == \\"\\" >>> find_most_frequent_character(\\"abcABC\\") == \\"a\\" >>> find_most_frequent_character(\\"1234abcdABCD!@#\\") == \\"a\\" >>> find_most_frequent_character(\\"aabbccddeeff\\") == \\"a\\"","solution":"def find_most_frequent_character(s: str) -> str: Returns the most frequent alphabetical character in the string \`s\`, ignoring case. If there are multiple characters with the same highest frequency, returns the one that appears first in the alphabet. In case of an empty string, returns an empty string. from collections import Counter # Convert string to lowercase and filter out non-alphabetical characters filtered_string = [char.lower() for char in s if char.isalpha()] # If the filtered string is empty, return an empty string if not filtered_string: return \\"\\" # Count the frequency of each character counter = Counter(filtered_string) # Find the most frequent character, preferring the one that appears first in the alphabet in case of ties most_frequent_char = min(counter.keys(), key=lambda x: (-counter[x], x)) return most_frequent_char"},{"question":"from typing import List def is_prime(n: int) -> bool: Check if a number is prime. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(17) == True >>> is_prime(20) == False >>> is_prime(1) == False >>> is_prime(0) == False >>> is_prime(-5) == False def sum_of_primes(a: int, b: int) -> int: Returns the sum of all prime numbers between a and b (inclusive). >>> sum_of_primes(10, 20) == 60 >>> sum_of_primes(20, 22) == 0 >>> sum_of_primes(17, 17) == 17 >>> sum_of_primes(15, 15) == 0 >>> sum_of_primes(-10, 10) == 17 >>> sum_of_primes(1, 100) == 1060","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sum_of_primes(a, b): Returns the sum of all prime numbers between a and b (inclusive). return sum(x for x in range(a, b + 1) if is_prime(x))"},{"question":"def rotate_left(lst: List[int], k: int) -> List[int]: Rotates the list lst to the left by k positions. >>> rotate_left([1, 2, 3, 4, 5], 2) [3, 4, 5, 1, 2] >>> rotate_left([1, 2, 3, 4, 5], 7) [3, 4, 5, 1, 2] >>> rotate_left([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_left([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_left([], 3) [] >>> rotate_left([1], 1) [1] >>> rotate_left([1], 100) [1]","solution":"def rotate_left(lst, k): Rotates the list lst to the left by k positions. Parameters: lst (list): The list of elements to be rotated. k (int): The number of positions to rotate the list. Returns: list: The rotated list. n = len(lst) if n == 0: return lst k = k % n # Handle cases where k is greater than n rotated_lst = lst[k:] + lst[:k] return rotated_lst"},{"question":"def remove_duplicates(int_list: list) -> list: Remove duplicate values from a list of integers while maintaining the original order. Parameters: - int_list (list): List of integers, which may contain both positive and negative values. Returns: - list: A new list with duplicates removed, original order maintained. >>> remove_duplicates([]) [] >>> remove_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([-1, -2, -3]) [-1, -2, -3] >>> remove_duplicates([1, 2, 2, 3, 4, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([-1, -1, -2, -3, -3, -4]) [-1, -2, -3, -4] >>> remove_duplicates([1, -1, 2, -2, 1, -1, 3, -3]) [1, -1, 2, -2, 3, -3] >>> remove_duplicates([1]) [1] >>> remove_duplicates([-1]) [-1]","solution":"def remove_duplicates(int_list): Remove duplicate values from a list of integers while maintaining the original order. Parameters: - int_list (list): List of integers, which may contain both positive and negative values. Returns: - list: A new list with duplicates removed, original order maintained. seen = set() result = [] for num in int_list: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"def find_max_length(nums): Creates a Python function that takes an integer array as input and returns the length of the longest contiguous subarray with an equal number of 0s and 1s. If no such subarray exists, the function should return 0. Args: nums (list of int): The input array containing integers (0s and 1s). Returns: int: The length of the longest contiguous subarray with an equal number of 0s and 1s. >>> find_max_length([0, 1]) == 2 >>> find_max_length([0, 0, 0]) == 0 >>> find_max_length([1, 1, 1]) == 0 >>> find_max_length([0, 1, 0, 1, 1, 0, 0]) == 6 >>> find_max_length([0, 1, 1, 0, 0, 1, 1, 0]) == 8 >>> find_max_length([0]) == 0 >>> find_max_length([1]) == 0 >>> find_max_length([0, 0, 1, 0, 1, 0, 1, 1]) == 8","solution":"def find_max_length(nums): Finds the length of the longest contiguous subarray with an equal number of 0s and 1s. Args: nums (list of int): The input array containing integers (0s and 1s). Returns: int: The length of the longest contiguous subarray with equal number of 0s and 1s. # Dictionary to store the first occurrence of a given count count_dict = {0: -1} max_len = 0 count = 0 for i, num in enumerate(nums): # Increment count for 1 and decrement for 0 count += 1 if num == 1 else -1 if count in count_dict: # If the count is seen before, it means the subarray between previous index and current index has equal 0s and 1s max_len = max(max_len, i - count_dict[count]) else: # Store the first occurrence of the count count_dict[count] = i return max_len"},{"question":"def intersection(arr1, arr2): Returns the intersection of two sorted arrays. The result array contains only the elements that are present in both arrays and without duplicates. Parameters: arr1 (list of int): First sorted array. arr2 (list of int): Second sorted array. Returns: list of int: An array containing the intersection elements. pass # Test cases def test_intersection_basic(): assert intersection([1, 3, 4, 5, 7], [2, 3, 5, 6]) == [3, 5] def test_intersection_no_common_elements(): assert intersection([1, 2, 3], [4, 5, 6]) == [] def test_intersection_with_duplicates(): assert intersection([1, 3, 3, 5, 7], [3, 3, 5, 6]) == [3, 5] def test_intersection_identical_arrays(): assert intersection([1, 2, 3], [1, 2, 3]) == [1, 2, 3] def test_intersection_empty_array(): assert intersection([], [1, 2, 3]) == [] assert intersection([1, 2, 3], []) == [] assert intersection([], []) == [] def test_intersection_single_element(): assert intersection([1], [1]) == [1] assert intersection([1], [2]) == []","solution":"def intersection(arr1, arr2): Returns the intersection of two sorted arrays. The result array contains only the elements that are present in both arrays and without duplicates. Parameters: arr1 (list of int): First sorted array. arr2 (list of int): Second sorted array. Returns: list of int: An array containing the intersection elements. i, j = 0, 0 result = [] while i < len(arr1) and j < len(arr2): if arr1[i] == arr2[j]: if not result or result[-1] != arr1[i]: # Ensure no duplicates in the result result.append(arr1[i]) i += 1 j += 1 elif arr1[i] < arr2[j]: i += 1 else: j += 1 return result"},{"question":"def arrayOddEvenSort(nums: List[int]) -> List[int]: Returns a new list where all the odd numbers appear in sorted ascending order followed by all the even numbers in sorted descending order. Parameters: nums (list): A list of integers. Returns: list: A list where all the odd numbers are sorted in ascending order followed by all the even numbers in descending order. >>> arrayOddEvenSort([5, 3, 2, 8, 1, 4]) [1, 3, 5, 8, 4, 2] >>> arrayOddEvenSort([7, 3, 11]) [3, 7, 11] >>> arrayOddEvenSort([]) [] >>> arrayOddEvenSort([2, 4, 6]) [6, 4, 2] >>> arrayOddEvenSort([0, 0, 0]) [0, 0, 0] >>> arrayOddEvenSort([-5, -1, -2, -3, -4]) [-5, -3, -1, -2, -4]","solution":"def arrayOddEvenSort(nums): Returns a new list where all the odd numbers appear in sorted ascending order followed by all the even numbers in sorted descending order. Parameters: nums (list): A list of integers. Returns: list: A list where all the odd numbers are sorted in ascending order followed by all the even numbers in descending order. odds = sorted([x for x in nums if x % 2 != 0]) evens = sorted([x for x in nums if x % 2 == 0], reverse=True) return odds + evens"},{"question":"from typing import List, Union def merge_alternate(list1: List[Union[int, str]], list2: List[Union[int, str]]) -> List[Union[int, str]]: Merge two lists by alternatingly taking elements from each list. If one list is longer than the other, append the remaining elements of the longer list at the end. >>> merge_alternate([1, 2, 3], ['a', 'b', 'c', 'd', 'e']) [1, 'a', 2, 'b', 3, 'c', 'd', 'e'] >>> merge_alternate([1, 2, 3], [4, 5]) [1, 4, 2, 5, 3] >>> merge_alternate([], ['a', 'b']) ['a', 'b']","solution":"from typing import List, Union def merge_alternate(list1: List[Union[int, str]], list2: List[Union[int, str]]) -> List[Union[int, str]]: result = [] len1, len2 = len(list1), len(list2) min_len = min(len1, len2) # Interleave the elements of both lists up to the length of the shorter list for i in range(min_len): result.append(list1[i]) result.append(list2[i]) # Append the remaining elements of the longer list if len1 > len2: result.extend(list1[min_len:]) else: result.extend(list2[min_len:]) return result"},{"question":"def reverse_words_in_string(s: str) -> str: Reverses each word in the input string while maintaining the original order of the words. Args: s (str): Input string. Returns: str: New string with each word reversed. >>> reverse_words_in_string(\\"Hello\\") == \\"olleH\\" >>> reverse_words_in_string(\\"Hello World\\") == \\"olleH dlroW\\" >>> reverse_words_in_string(\\"Hello, World!\\") == \\",olleH !dlroW\\" >>> reverse_words_in_string(\\" Hello World \\") == \\"olleH dlroW\\" >>> reverse_words_in_string(\\"\\") == \\"\\" >>> reverse_words_in_string(\\"123 456\\") == \\"321 654\\" >>> reverse_words_in_string(\\"Hello World\\") == \\"olleH dlroW\\"","solution":"def reverse_words_in_string(s): Reverses each word in the input string while maintaining the original order of the words. Args: s (str): Input string. Returns: str: New string with each word reversed. # Split the input string by spaces to get words words = s.split() # Reverse each word and join them with spaces to form the resultant string return ' '.join(word[::-1] for word in words)"},{"question":"def balance_parentheses(expression): balance_parentheses is a function that takes a string representing a mathematical expression and returns a list of positions of unbalanced parentheses. The positions are determined as per the 0-based index system. >>> balance_parentheses('') [] >>> balance_parentheses('(()') [0] >>> balance_parentheses('(a+b)') [] >>> balance_parentheses(')a+b(') [0, 4] >>> balance_parentheses('(a+b))') [5] >>> balance_parentheses('(a+b*(c-d)') [0] >>> balance_parentheses('((a+b)') [0] # Your code here","solution":"def balance_parentheses(expression): balance_parentheses is a function that takes a string representing a mathematical expression and returns a list of positions of unbalanced parentheses. The positions are determined as per the 0-based index system. >>> balance_parentheses('') [] >>> balance_parentheses('(()') [0] >>> balance_parentheses('(a+b)') [] >>> balance_parentheses(')a+b(') [0, 4] >>> balance_parentheses('(a+b))') [5] >>> balance_parentheses('(a+b*(c-d)') [0] >>> balance_parentheses('((a+b)') [0] stack = [] unbalanced_positions = [] for i, char in enumerate(expression): if char == '(': stack.append(i) elif char == ')': if stack: stack.pop() else: unbalanced_positions.append(i) # Positions of '('s left in stack are unbalanced unbalanced_positions.extend(stack) return unbalanced_positions"},{"question":"def find_pair_with_sum(numbers, target): Finds two numbers in the list that sum up to the target value. Args: numbers (list): List of integers. target (int): The target sum. Returns: tuple: A tuple of two integers that sum up to the target value or an empty tuple if no such pair exists. pass # Unit Tests def test_find_pair_with_sum_found(): assert find_pair_with_sum([2, 7, 11, 15], 9) == (2, 7) def test_find_pair_with_sum_not_found(): assert find_pair_with_sum([1, 2, 3, 4], 8) == () def test_find_pair_with_sum_multiple_pairs(): assert find_pair_with_sum([1, 2, 3, 4, 5], 6) in [(1, 5), (2, 4)] def test_find_pair_with_sum_negative_numbers(): assert find_pair_with_sum([-1, -2, -3, -4, 5, 1], -3) == (-1, -2) def test_find_pair_with_sum_large_numbers(): assert find_pair_with_sum([1000000, 2000000, 3000000, 4000000], 5000000) == (2000000, 3000000) def test_find_pair_with_sum_empty_list(): assert find_pair_with_sum([], 5) == () def test_find_pair_with_sum_single_element(): assert find_pair_with_sum([1], 1) == ()","solution":"def find_pair_with_sum(numbers, target): Finds two numbers in the list that sum up to the target value. Args: numbers (list): List of integers. target (int): The target sum. Returns: tuple: A tuple of two integers that sum up to the target value or an empty tuple if no such pair exists. seen = {} for number in numbers: complement = target - number if complement in seen: return (complement, number) seen[number] = True return ()"},{"question":"from typing import List def isBST(array: List[int]) -> bool: Determine if the given array can represent an in-order traversal of a valid Binary Search Tree (BST). Parameters: array (List[int]): An array of integers representing the in-order traversal of a BST. Returns: bool: True if the array can form a valid BST, False otherwise. Examples: >>> isBST([2, 3, 5, 7, 11, 13, 17]) True >>> isBST([3, 2, 5, 7, 11, 13, 17]) False >>> isBST([10]) True >>> isBST([]) True >>> isBST([2, 3, 5, 5, 11, 13, 17]) False >>> isBST([17, 13, 11, 7, 5, 3, 2]) False >>> isBST([10, 5, 15, 1, 20]) False","solution":"def isBST(array): Determine if the given array can represent an in-order traversal of a valid Binary Search Tree (BST). Parameters: array (List[int]): An array of integers representing the in-order traversal of a BST. Returns: bool: True if the array can form a valid BST, False otherwise. # An array can represent an in-order traversal of a BST if it is sorted in ascending order, # and all elements are unique. return all(array[i] < array[i+1] for i in range(len(array) - 1))"},{"question":"def sum_of_k_largest(numbers: List[int], k: int) -> int: Returns the sum of the k largest integers in the list. If k is greater than the length of the list, return the sum of all the integers. Examples: >>> sum_of_k_largest([4, 1, 7, 3, 8, 5], 3) 20 >>> sum_of_k_largest([4, 1, 7], 5) 12 >>> sum_of_k_largest([4, 1, 7, 3, 8, 5], 6) 28 >>> sum_of_k_largest([4, 1, 7, 3, 8, 5], 1) 8 >>> sum_of_k_largest([4, 1, 7, 3, 8, 5], 0) 0 >>> sum_of_k_largest([4, 1, 7, 3, 7, 5], 3) 19 >>> sum_of_k_largest([-4, -1, -7, -3, -8, -5], 3) -8","solution":"def sum_of_k_largest(numbers, k): Returns the sum of the k largest integers in the list. If k is greater than the length of the list, return the sum of all the integers. if k >= len(numbers): return sum(numbers) sorted_numbers = sorted(numbers, reverse=True) return sum(sorted_numbers[:k])"},{"question":"def longest_common_prefix(strs): Finds the longest common prefix string amongst an array of strings. If there is no common prefix, returns an empty string. :param strs: List of strings :return: Longest common prefix string or empty string >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) \\"\\" >>> longest_common_prefix([\\"single\\"]) \\"single\\" >>> longest_common_prefix([]) \\"\\" >>> longest_common_prefix([\\"\\", \\"\\", \\"\\"]) \\"\\" >>> longest_common_prefix([\\"prefix\\", \\"prefixes\\", \\"prefixation\\"]) \\"prefix\\" >>> longest_common_prefix([\\"Case\\", \\"Casing\\", \\"Casual\\"]) \\"Cas\\"","solution":"def longest_common_prefix(strs): Finds the longest common prefix string amongst an array of strings. If there is no common prefix, returns an empty string. :param strs: List of strings :return: Longest common prefix string or empty string if not strs: return \\"\\" # Start by assuming the longest common prefix is the entire first string prefix = strs[0] # Compare this prefix with each string in the list for string in strs[1:]: # Update the prefix by comparing it with the current string while string[:len(prefix)] != prefix and prefix: prefix = prefix[:len(prefix)-1] if not prefix: break return prefix"},{"question":"from typing import List, Dict, Union def top_students(records: List[Dict[str, Union[str, List[int]]]]) -> List[str]: Given a list of student records, each containing the student's name and their respective grades across multiple subjects, determine the student(s) with the highest average grade. If there are multiple students with the highest average, return a list of their names. >>> records = [ ... {\\"name\\": \\"Alice\\", \\"grades\\": [90, 95, 88]}, ... {\\"name\\": \\"Bob\\", \\"grades\\": [85, 92, 91]}, ... {\\"name\\": \\"Charlie\\", \\"grades\\": [91, 92, 90]}, ... ] >>> top_students(records) [\\"Alice\\", \\"Charlie\\"]","solution":"from typing import List, Dict, Union def top_students(records: List[Dict[str, Union[str, List[int]]]]) -> List[str]: highest_avg = -1 top_students_list = [] for record in records: avg_grade = sum(record['grades']) / len(record['grades']) if avg_grade > highest_avg: highest_avg = avg_grade top_students_list = [record['name']] elif avg_grade == highest_avg: top_students_list.append(record['name']) return top_students_list"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing only addition and multiplication operations without using Python's built-in eval function. >>> evaluate_expression(\\"3+5*2\\") == 13 >>> evaluate_expression(\\"10+2*6\\") == 22 >>> evaluate_expression(\\"3*4*5\\") == 60 >>> evaluate_expression(\\"10+20+30\\") == 60 >>> evaluate_expression(\\"1+2*3+4*5\\") == 27 >>> evaluate_expression(\\"42\\") == 42 >>> evaluate_expression(\\"1+2+3+4+5\\") == 15 >>> evaluate_expression(\\"2*3*4\\") == 24","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing only addition and multiplication operations without using Python's built-in eval function. # Split the expression by '+' to separate addition groups addition_groups = expression.split('+') # Process each group to handle multiplication total = 0 for group in addition_groups: # Split the group by '*' to handle multiplication multiplication_numbers = map(int, group.split('*')) # Calculate the product of the multiplication group product = 1 for num in multiplication_numbers: product *= num # Add the product to the total sum total += product return total"},{"question":"def lcs(arr1, arr2): Finds the longest common subsequence (LCS) between two unsorted arrays. Args: arr1 (list of int): A list of integers representing the first array. arr2 (list of int): A list of integers representing the second array. Returns: tuple: A tuple (list of int, int) where the first element is the LCS and the second element is its length. Example: >>> lcs([3, 10, 4, 5, 9, 6], [10, 4, 9, 3, 6, 5]) ([10, 4, 9], 3)","solution":"def lcs(arr1, arr2): Finds the longest common subsequence (LCS) between two unsorted arrays. Args: arr1 (list of int): A list of integers representing the first array. arr2 (list of int): A list of integers representing the second array. Returns: tuple: A tuple (list of int, int) where the first element is the LCS and the second element is its length. m, n = len(arr1), len(arr2) if m == 0 or n == 0: return [], 0 # Sorting arrays to apply LCS determination logic arr1.sort() arr2.sort() # Create DP table dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill DP table for i in range(m): for j in range(n): if arr1[i] == arr2[j]: dp[i+1][j+1] = dp[i][j] + 1 else: dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1]) # Backtrack to find the LCS lcs_seq = [] i, j = m, n while i > 0 and j > 0: if arr1[i-1] == arr2[j-1]: lcs_seq.append(arr1[i-1]) i -= 1 j -= 1 elif dp[i-1][j] > dp[i][j-1]: i -= 1 else: j -= 1 lcs_seq.reverse() return lcs_seq, len(lcs_seq)"},{"question":"def can_be_palindrome(s: str) -> bool: Determines if a given string can be rearranged to form a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward. >>> can_be_palindrome(\\"Tact Coa\\") True >>> can_be_palindrome(\\"hello\\") False >>> can_be_palindrome(\\"AabBbCc\\") True","solution":"def can_be_palindrome(s): Determines if the string can be rearranged to form a palindrome. from collections import Counter # Normalize the string: remove non-alphanumeric characters and convert to lowercase s = ''.join([ch.lower() for ch in s if ch.isalpha()]) # Count frequencies of each character char_count = Counter(s) # Check the number of characters with odd counts odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if there is at most 1 character with an odd count return odd_count <= 1"},{"question":"def basic_calculator(expression: str) -> float: Evaluates a simple mathematical expression and returns the result as a float. The expression can contain +, -, *, / operators and parentheses. Args: expression (str): A string containing the mathematical expression. Returns: float: The result of the evaluation. >>> basic_calculator(\\"2 + 3\\") == 5.0 >>> basic_calculator(\\"5 - 2\\") == 3.0 >>> basic_calculator(\\"3 * 4\\") == 12.0 >>> basic_calculator(\\"10 / 2\\") == 5.0 >>> basic_calculator(\\"2 + 3 * 4\\") == 14.0 >>> basic_calculator(\\"(2 + 3) * 4\\") == 20.0 >>> basic_calculator(\\"((2 + 3) * 4) / 2\\") == 10.0 >>> basic_calculator(\\"-2 + 3\\") == 1.0 >>> basic_calculator(\\"2 + 3 - 4 * 2 / 1\\") == -3.0 >>> basic_calculator(\\"((2 + 3) * (4 / 2))\\") == 10.0","solution":"def basic_calculator(expression): Evaluates a simple mathematical expression and returns the result as a float. The expression can contain +, -, *, / operators and parentheses. Args: expression (str): A string containing the mathematical expression. Returns: float: The result of the evaluation. try: result = eval(expression) return float(result) except Exception as e: raise ValueError(\\"Invalid mathematical expression\\") from e"},{"question":"def has_zero_sum_subarray(nums: List[int], k: int) -> bool: Given a list of integers nums and an integer k, return true if the list contains a subarray of at least length k that has a sum equal to zero. A subarray is a contiguous part of an array. Example 1: >>> has_zero_sum_subarray([1, 2, -3, 4, -2, -2, 5], 3) True Example 2: >>> has_zero_sum_subarray([5, -5, 1, 1, 1], 2) True Example 3: >>> has_zero_sum_subarray([1, 2, 3], 3) False Constraints: 1 <= nums.length <= 1000 -10^4 <= nums[i] <= 10^4 1 <= k <= nums.length","solution":"def has_zero_sum_subarray(nums, k): Checks if the list contains a subarray of at least length k that has a sum equal to zero. n = len(nums) for i in range(n): curr_sum = 0 for j in range(i, n): curr_sum += nums[j] if j - i + 1 >= k and curr_sum == 0: return True return False"},{"question":"from typing import List, Tuple def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Implement a function that takes a list of integers and a target sum as input and returns all unique pairs of integers from the list that add up to the target sum. The output list should not contain duplicate pairs, and each pair should be sorted in ascending order. The result should also be returned in a sorted manner, where each pair is sorted first by the first element, then by the second. >>> find_pairs([1, 2, 3, 4, 3], 6) [(2, 4), (3, 3)] >>> find_pairs([1, 1, 2, 2, 3, 3], 4) [(1, 3), (2, 2)]","solution":"def find_pairs(nums, target): Returns a list of unique pairs (in tuples) from nums that add up to target. Each pair is sorted in ascending order and the list of pairs is sorted. # Sort the list to start using two-pointer technique nums.sort() # List to hold the pairs pairs = [] # Two-pointer setup left = 0 right = len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: # Found a pair pairs.append((nums[left], nums[right])) # Move left pointer rightward to avoid duplicate pairs while left < right and nums[left] == pairs[-1][0]: left += 1 # Move right pointer leftward to avoid duplicate pairs while left < right and nums[right] == pairs[-1][1]: right -= 1 elif current_sum < target: left += 1 else: right -= 1 return pairs"},{"question":"def majority_element(nums: List[int]) -> int: Returns the majority element in an unsorted array of integers. The majority element is the element that appears more than n/2 times. :param nums: List of integers where the majority element exists :return: The majority element in the list >>> majority_element([3, 2, 3]) 3 >>> majority_element([2, 2, 1, 1, 1, 2, 2]) 2 >>> majority_element([1]) 1 >>> majority_element([1, 1, 2, 2, 2, 1, 1, 1, 1]) 1 >>> majority_element([-1, -1, -1, 2, 2]) -1 >>> majority_element([0, 0, 0, 0, 1, 1, 1]) 0 >>> majority_element([1000000000, 1000000000, -1000000000]) 1000000000","solution":"def majority_element(nums): Returns the majority element in an unsorted array of integers. The majority element is the element that appears more than n/2 times. count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map: left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def longest_increasing_subsequence(arr): Calculates the longest increasing subsequence within an array of integers. The array may contain both positive and negative numbers, as well as duplicate values. Leverage dynamic programming to ensure optimal time complexity. Parameters: arr (list): A list of integers. Returns: tuple: A tuple containing the length of the longest increasing subsequence and the subsequence itself. >>> longest_increasing_subsequence([]) == (0, []) >>> longest_increasing_subsequence([5]) == (1, [5]) >>> longest_increasing_subsequence([-1]) == (1, [-1]) >>> longest_increasing_subsequence([2, 2, 2, 2]) == (1, [2]) >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) == (5, [1, 2, 3, 4, 5]) >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) == (1, [5]) >>> length, subseq = longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) >>> assert length == 4 >>> assert subseq in ([2, 3, 7, 101], [2, 5, 7, 101]) >>> length, subseq = longest_increasing_subsequence([-1, 3, 4, 5, 2, 2, 2]) >>> assert length == 4 >>> assert subseq == [-1, 3, 4, 5] >>> length, subseq = longest_increasing_subsequence([3, 3, 4, 4, 5]) >>> assert length == 3 >>> assert subseq == [3, 4, 5]","solution":"def longest_increasing_subsequence(arr): Calculates the longest increasing subsequence within an array of integers. Parameters: arr (list): A list of integers. Returns: tuple: A tuple containing the length of the longest increasing subsequence and the subsequence itself. if not arr: return 0, [] n = len(arr) dp = [1] * n prev = [-1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j] and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 prev[i] = j max_length = max(dp) idx = dp.index(max_length) lis = [] while idx != -1: lis.append(arr[idx]) idx = prev[idx] lis.reverse() return max_length, lis"},{"question":"from typing import List def list_to_matrix(lst: List[int], rows: int, cols: int) -> List[List[int]]: Arranges the list of integers into a matrix with the specified number of rows and columns. If the number of elements in the list is not enough to fill the matrix, the remaining elements should be filled with zeroes from left to right. If there are more elements than needed, only include the required number of elements. >>> list_to_matrix([1, 2, 3, 4, 5, 6], 2, 3) [[1, 2, 3], [4, 5, 6]] >>> list_to_matrix([1, 2, 3], 2, 3) [[1, 2, 3], [0, 0, 0]] >>> list_to_matrix([1, 2, 3, 4, 5], 3, 2) [[1, 2], [3, 4], [5, 0]] >>> list_to_matrix([], 2, 3) [[0, 0, 0], [0, 0, 0]]","solution":"from typing import List def list_to_matrix(lst: List[int], rows: int, cols: int) -> List[List[int]]: Arranges the list of integers into a matrix with the specified number of rows and columns. If the number of elements in the list is not enough to fill the matrix, the remaining elements should be filled with zeroes from left to right. If there are more elements than needed, only include the required number of elements. result = [] total_elements = rows * cols filled_elements = lst[:total_elements] filled_elements.extend([0] * (total_elements - len(filled_elements))) for r in range(rows): result.append(filled_elements[r*cols:(r+1)*cols]) return result"},{"question":"def most_frequent_word(words): Write a function that takes a list of strings, where each string represents a word. Your function should return the word that appears the most frequently in the list. If there is a tie, return the word that comes first lexicographically. >>> most_frequent_word(['apple', 'banana', 'apple', 'orange', 'banana', 'banana']) \\"banana\\" >>> most_frequent_word([]) \\"\\" >>> most_frequent_word(['apple', 'banana', 'orange']) \\"apple\\" >>> most_frequent_word(['apple', 'banana', 'apple', 'banana']) \\"apple\\" >>> most_frequent_word(['banana', 'apple', 'cherry', 'banana', 'apple']) \\"apple\\" >>> most_frequent_word(['apple', 'apple', 'apple', 'apple']) \\"apple\\"","solution":"from collections import Counter def most_frequent_word(words): Returns the most frequent word in the list of words. In case of a tie, the word that comes first lexicographically is returned. if not words: return \\"\\" word_count = Counter(words) max_frequency = max(word_count.values()) # Filtering only words with the maximum frequency candidates = [word for word, count in word_count.items() if count == max_frequency] return min(candidates)"},{"question":"from typing import List def max_area(buildings: List[int]) -> int: Finds and returns the maximum amount of water that can be held between any two buildings. :param buildings: List[int] - a list of integers representing the heights of buildings :return: int - the maximum amount of water that can be held >>> max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_area([1, 2]) 1 >>> max_area([4, 4, 4, 4, 4]) 16 >>> max_area([5, 4, 3, 2, 1]) 6 >>> max_area([1, 2, 3, 4, 5]) 6 >>> max_area([2, 3, 10, 5, 7, 8, 9]) 36","solution":"def max_area(buildings): Finds and returns the maximum amount of water that can be held between any two buildings. :param buildings: List[int] - a list of integers representing the heights of buildings :return: int - the maximum amount of water that can be held max_water = 0 left = 0 right = len(buildings) - 1 while left < right: height = min(buildings[left], buildings[right]) width = right - left water = height * width max_water = max(max_water, water) if buildings[left] < buildings[right]: left += 1 else: right -= 1 return max_water"},{"question":"def sum_even_and_greater_than_30(numbers): Returns the sum of all numbers in the list that are even and greater than 30. :param numbers: List of integers. :return: Sum of integers meeting the criteria. >>> sum_even_and_greater_than_30([44, 55, 66]) == 110 >>> sum_even_and_greater_than_30([11, 22, 33]) == 0 >>> sum_even_and_greater_than_30([11, 22, 33, 44, 55, 66]) == 110 >>> sum_even_and_greater_than_30([]) == 0 >>> sum_even_and_greater_than_30([29]) == 0 >>> sum_even_and_greater_than_30([42]) == 42","solution":"def sum_even_and_greater_than_30(numbers): Returns the sum of all numbers in the list that are even and greater than 30. :param numbers: List of integers. :return: Sum of integers meeting the criteria. return sum(number for number in numbers if number % 2 == 0 and number > 30)"},{"question":"import time def factorial(n: int, memo: dict = {}) -> str: Calculate the factorial of a given non-negative integer with optimization for large inputs using memoization. Returns the result as a string to handle very large numbers effectively. >>> factorial(0) '1' >>> factorial(1) '1' >>> factorial(2) '2' >>> factorial(3) '6' >>> factorial(4) '24' >>> factorial(5) '120' >>> factorial(10) '3628800' >>> factorial(15) '1307674368000' >>> factorial(20) '2432902008176640000' >>> factorial(50) '30414093201713378043612608166064768844377641568960512000000000000' pass def test_factorial(): assert factorial(0) == \\"1\\" assert factorial(1) == \\"1\\" assert factorial(2) == \\"2\\" assert factorial(3) == \\"6\\" assert factorial(4) == \\"24\\" assert factorial(5) == \\"120\\" assert factorial(10) == \\"3628800\\" assert factorial(15) == \\"1307674368000\\" assert factorial(20) == \\"2432902008176640000\\" assert factorial(50) == \\"30414093201713378043612608166064768844377641568960512000000000000\\" try: factorial(-1) except ValueError as e: assert str(e) == \\"Input must be a non-negative integer\\" start_time = time.time() factorial(100) first_call_duration = time.time() - start_time start_time = time.time() factorial(100) second_call_duration = time.time() - start_time assert second_call_duration < first_call_duration # The second call should be faster due to memoization test_factorial()","solution":"def factorial(n, memo={}): Returns the factorial of a non-negative integer n. Uses memoization to store intermediate results. Returns the result as a string to handle very large numbers effectively. if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n in memo: return memo[n] if n <= 1: return \\"1\\" result = int(factorial(n - 1, memo)) * n memo[n] = str(result) return memo[n]"},{"question":"def sum_of_digits(n: int) -> int: Returns the sum of the digits of a given integer using recursion. Handles both positive and negative integers. Args: n (int): The integer whose digits are to be summed. Returns: int: Sum of the digits of the given integer. # Implementation here def test_sum_of_digits_single_digit(): assert sum_of_digits(5) == 5 assert sum_of_digits(0) == 0 def test_sum_of_digits_multiple_digits(): assert sum_of_digits(12345) == 15 assert sum_of_digits(987) == 24 def test_sum_of_digits_negative_numbers(): assert sum_of_digits(-12345) == 15 assert sum_of_digits(-111) == 3 def test_sum_of_digits_large_number(): assert sum_of_digits(123456789) == 45","solution":"def sum_of_digits(n): Returns the sum of the digits of a given integer using recursion. Handles both positive and negative integers. Args: n (int): The integer whose digits are to be summed. Returns: int: Sum of the digits of the given integer. n = abs(n) # Handle negative numbers if n == 0: return 0 return n % 10 + sum_of_digits(n // 10)"},{"question":"def calculate_average_grade(students: List[Dict[str, Union[str, int, List[int]]]]) -> List[Dict[str, Union[str, int, float]]]: Takes a list of dictionaries with student information and adds an average grade to each student. Parameters: students (list): A list of dictionaries with keys 'name', 'age', and 'grades'. Returns: list: A new list of dictionaries with an additional 'average' key. Examples: >>> students = [ ... {\\"name\\": \\"Alice\\", \\"age\\": 20, \\"grades\\": [90, 85, 88]}, ... {\\"name\\": \\"Bob\\", \\"age\\": 22, \\"grades\\": [78, 82]}, ... {\\"name\\": \\"Charlie\\", \\"age\\": 23, \\"grades\\": []} ... ] >>> calculate_average_grade(students) [ {\\"name\\": \\"Alice\\", \\"age\\": 20, \\"grades\\": [90, 85, 88], \\"average\\": 87.67}, {\\"name\\": \\"Bob\\", \\"age\\": 22, \\"grades\\": [78, 82], \\"average\\": 80.0}, {\\"name\\": \\"Charlie\\", \\"age\\": 23, \\"grades\\": [], \\"average\\": 0} ] >>> calculate_average_grade([]) []","solution":"def calculate_average_grade(students): Takes a list of dictionaries with student information and adds an average grade to each student. Parameters: students (list): A list of dictionaries with keys 'name', 'age', and 'grades'. Returns: list: A new list of dictionaries with an additional 'average' key. result = [] for student in students: grades = student.get('grades', []) average = sum(grades) / len(grades) if grades else 0 new_student = student.copy() new_student['average'] = round(average, 2) result.append(new_student) return result"},{"question":"def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges overlapping intervals from a list of intervals. >>> merge_intervals([(1, 3), (2, 4), (5, 7), (6, 8)]) [(1, 4), (5, 8)] >>> merge_intervals([(1, 5), (2, 6), (3, 7)]) [(1, 7)] >>> merge_intervals([(1, 4), (4, 5), (6, 8)]) [(1, 5), (6, 8)] >>> merge_intervals([(6, 8), (1, 3), (2, 4)]) [(1, 4), (6, 8)] >>> merge_intervals([(1, 4), (2, 4), (3, 4)]) [(1, 4)]","solution":"def merge_intervals(intervals): Merges overlapping intervals from a list of intervals. :param intervals: List of tuples where each tuple represents an interval (start, end) :return: List of merged intervals if not intervals: return [] # First, sort the intervals based on the starting value intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: merged_intervals[-1] = (last_merged[0], max(last_merged[1], current[1])) else: merged_intervals.append(current) return merged_intervals"},{"question":"def longest_consecutive(nums: List[int]) -> int: Returns the length of the longest consecutive elements sequence. The elements in the sequence should be consecutive integers. The function should have a time complexity of O(n). >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([0, -1, 1, 3, 5, 4, 7, 6, 8]) 6 >>> longest_consecutive([10]) 1 >>> longest_consecutive([]) 0 >>> longest_consecutive([1, 9, 3, 10, 4, 20, 2]) 4 >>> longest_consecutive([1, 1, 1, 1, 1, 1]) 1 >>> longest_consecutive([10, 1, 2, 3, 50, 20, 21, 22, 23, 24, 25]) 6","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence. num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: # It means it's the start of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"import random def dice_game(player1: str, player2: str) -> str: Simulate rolling two six-sided dice for each player and determine the winner. Randomly roll two dice for each player, sum their values, and compare. Args: player1 (str): The name of the first player. player2 (str): The name of the second player. Returns: str: A statement declaring the winner or if there is a tie. Examples: >>> random.seed(0) # Setting seed for reproducibility of this example >>> dice_game(\\"Alice\\", \\"Bob\\") 'Alice wins with a sum of 8 against 5' >>> random.seed(1) >>> dice_game(\\"Charlie\\", \\"Dana\\") 'Dana wins with a sum of 10 against 6' >>> random.seed(2) >>> dice_game(\\"Eve\\", \\"Frank\\") 'It is a tie with both summing to 7'","solution":"import random def dice_game(player1: str, player2: str) -> str: Simulate rolling two six-sided dice for each player and determine the winner. Randomly roll two dice for each player, sum their values, and compare. Args: player1 (str): The name of the first player. player2 (str): The name of the second player. Returns: str: A statement declaring the winner or if there is a tie. roll1_p1 = random.randint(1, 6) roll2_p1 = random.randint(1, 6) roll1_p2 = random.randint(1, 6) roll2_p2 = random.randint(1, 6) sum_p1 = roll1_p1 + roll2_p1 sum_p2 = roll1_p2 + roll2_p2 if sum_p1 > sum_p2: return f'{player1} wins with a sum of {sum_p1} against {sum_p2}' elif sum_p1 < sum_p2: return f'{player2} wins with a sum of {sum_p2} against {sum_p1}' else: return f'It is a tie with both summing to {sum_p1}'"},{"question":"def unique_sorted(lst): Returns a list containing only the unique elements from the original list but sorted in ascending order. >>> unique_sorted([4, 5, 6, 3, 4, 5, 2, 1, 6]) [1, 2, 3, 4, 5, 6] >>> unique_sorted([1, 3, 2, 2, 3, 1]) [1, 2, 3] >>> unique_sorted([7, 6, 4, 2, 6, 1]) [1, 2, 4, 6, 7] >>> unique_sorted([10, 10, 10, 5]) [5, 10] >>> unique_sorted([1, 2, 3]) [1, 2, 3] >>> unique_sorted([]) [] >>> unique_sorted([-1, -2, -3, -1, -2, -3, 0]) [-3, -2, -1, 0] >>> unique_sorted([1]) [1]","solution":"def unique_sorted(lst): Returns a list containing only the unique elements from the original list but sorted in ascending order. unique_elements = [] for elem in lst: if elem not in unique_elements: unique_elements.append(elem) # Implementing bubble sort algorithm to sort the unique elements in ascending order n = len(unique_elements) for i in range(n): for j in range(0, n-i-1): if unique_elements[j] > unique_elements[j+1]: unique_elements[j], unique_elements[j+1] = unique_elements[j+1], unique_elements[j] return unique_elements"},{"question":"def reverse_words_and_count(input_string: str) -> (str, int): Reverses the order of the words in the input string and counts the number of words. Returns a tuple containing the transformed string and the word count. >>> reverse_words_and_count(\\"The quick brown fox jumps over the lazy dog\\") (\\"dog lazy the over jumps fox brown quick The\\", 9) >>> reverse_words_and_count(\\"Hello\\") (\\"Hello\\", 1) >>> reverse_words_and_count(\\" Python is fun \\") (\\"fun is Python\\", 3) >>> reverse_words_and_count(\\"\\") (\\"\\", 0) >>> reverse_words_and_count(\\"Multiple words with trailing spaces \\") (\\"spaces trailing with words Multiple\\", 5)","solution":"def reverse_words_and_count(input_string): Reverses the order of the words in the input string and counts the number of words. Returns a tuple containing the transformed string and the word count. words = input_string.split() reversed_words = ' '.join(reversed(words)) word_count = len(words) return reversed_words, word_count"},{"question":"def replace_vowels(s: str) -> str: Replaces all vowels in the input string with the following vowel in the alphabet, wrapping around to 'a' after 'u'. The function is case-insensitive and returns the transformed string in the same case as the input. >>> replace_vowels(\\"hello\\") \\"hillu\\" >>> replace_vowels(\\"HELLO\\") \\"HILLU\\" >>> replace_vowels(\\"HeLLo\\") \\"HiLLu\\" >>> replace_vowels(\\"rhythm\\") \\"rhythm\\" >>> replace_vowels(\\"aeiou\\") \\"eioua\\" >>> replace_vowels(\\"\\") \\"\\" >>> replace_vowels(\\"bcdfghjklmnpqrstvwxyz\\") \\"bcdfghjklmnpqrstvwxyz\\"","solution":"def replace_vowels(s): Replaces all vowels in the input string with the following vowel in the alphabet, wrapping around to 'a' after 'u'. The function is case-insensitive and returns the transformed string in the same case as the input. vowels = 'aeiou' vowel_map = {v: vowels[(i + 1) % len(vowels)] for i, v in enumerate(vowels)} vowel_map.update({v.upper(): vowel_map[v].upper() for v in vowels}) return ''.join(vowel_map[char] if char in vowel_map else char for char in s)"},{"question":"def aggregateStudentsByGPA(students, gpas): Aggregates students by their GPAs rounded to the nearest tenth. Args: students (list of str): List of students' names. gpas (list of float): List of students' GPAs. Returns: dict: A dictionary where keys are the rounded GPAs and values are lists of students with that GPA. >>> aggregateStudentsByGPA([\\"Alice\\"], [3.67]) == {3.7: [\\"Alice\\"]} >>> aggregateStudentsByGPA([\\"Alice\\", \\"Bob\\"], [3.67, 3.67]) == {3.7: [\\"Alice\\", \\"Bob\\"]} >>> aggregateStudentsByGPA([\\"Alice\\", \\"Bob\\", \\"Charlie\\"], [3.67, 3.92, 3.67]) == {3.7: [\\"Alice\\", \\"Charlie\\"], 3.9: [\\"Bob\\"]} >>> aggregateStudentsByGPA([\\"Alice\\", \\"Bob\\", \\"Charlie\\"], [3.67, 2.75, 4.00]) == {3.7: [\\"Alice\\"], 2.8: [\\"Bob\\"], 4.0: [\\"Charlie\\"]} >>> aggregateStudentsByGPA([\\"Alice\\", \\"Bob\\", \\"Charlie\\"], [3.95, 3.94, 3.99]) == {4.0: [\\"Alice\\", \\"Charlie\\"], 3.9: [\\"Bob\\"]}","solution":"def aggregateStudentsByGPA(students, gpas): Aggregates students by their GPAs rounded to the nearest tenth. Args: students (list of str): List of students' names. gpas (list of float): List of students' GPAs. Returns: dict: A dictionary where keys are the rounded GPAs and values are lists of students with that GPA. gpa_dict = {} for student, gpa in zip(students, gpas): rounded_gpa = round(gpa, 1) if rounded_gpa in gpa_dict: gpa_dict[rounded_gpa].append(student) else: gpa_dict[rounded_gpa] = [student] return gpa_dict"},{"question":"from typing import List def longest_even_subsequence(arr: List[int]) -> int: Returns the length of the longest contiguous subsequence of even integers. >>> longest_even_subsequence([1, 2, 4, 6, 8, 10, 3, 5, 7, 8, 12]) 5 >>> longest_even_subsequence([1, 3, 5, 7, 9]) 0 >>> longest_even_subsequence([2, 4, 1, 2, 4, 6, 8, 10, 11, 14, 18]) 5 >>> longest_even_subsequence([10, 12, 14, 7, 8, 6, 4, 2, 9, 3, 11]) 4 >>> longest_even_subsequence([2]) 1 >>> longest_even_subsequence([1]) 0 >>> longest_even_subsequence([2, 4, 6, 8, 10]) 5 >>> longest_even_subsequence([1, 3, 5, 7, 9]) 0","solution":"from typing import List def longest_even_subsequence(arr: List[int]) -> int: Returns the length of the longest contiguous subsequence of even integers. max_length = 0 current_length = 0 for num in arr: if num % 2 == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def sieve_of_eratosthenes(start: int, end: int) -> List[int]: Finds all prime numbers within a given range using the Sieve of Eratosthenes algorithm. Parameters: start (int): The starting range value. end (int): The ending range value. Returns: list: A list of prime numbers within the range [start, end]. Example usage: >>> sieve_of_eratosthenes(10, 30) [11, 13, 17, 19, 23, 29] >>> sieve_of_eratosthenes(2, 5) [2, 3, 5] pass # Your implementation here","solution":"def sieve_of_eratosthenes(start, end): Finds all prime numbers within a given range using the Sieve of Eratosthenes algorithm. Parameters: start (int): The starting range value. end (int): The ending range value. Returns: list: A list of prime numbers within the range [start, end]. if start > end or end < 2: return [] if start < 2: start = 2 # Create a boolean array \\"prime[0..end]\\" and initialize # all entries as true. A value in prime[i] will # finally be false if i is Not a prime, true if i is a prime. prime = [True for i in range(end + 1)] p = 2 while (p * p <= end): if prime[p]: for i in range(p * p, end + 1, p): prime[i] = False p += 1 # Collecting all prime numbers within the range [start, end] prime_numbers = [p for p in range(start, end + 1) if prime[p]] return prime_numbers"},{"question":"def longest_consecutive(nums: List[int]) -> int: Returns the length of the longest consecutive elements sequence. >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) 9 >>> longest_consecutive([1]) 1 >>> longest_consecutive([]) 0 >>> longest_consecutive([10, 5, 12, 3, 55, 7, 2, 6]) 3 >>> longest_consecutive([5, 5, 5, 5]) 1 >>> longest_consecutive([-1, -2, -3, -4, 1]) 4","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # check if it is the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from typing import List, Dict class Item: def __init__(self, item_id: int, name: str, price: float, discount: float): Represents an item in the e-commerce system. Args: item_id (int): The unique identifier for the item. name (str): The name of the item. price (float): The original price of the item. discount (float): The percentage discount applied to the item. pass def discounted_price(self) -> float: Calculates the price after discount. pass class ShoppingCart: def __init__(self): Represents the shopping cart. pass def add_item(self, item: Item): Adds an item to the shopping cart. pass def remove_item(self, item_id: int): Removes an item from the shopping cart by its ID. pass def apply_coupon(self, coupon_discount: float): Applies a coupon discount to the shopping cart. Args: coupon_discount (float): The percentage discount of the coupon. pass def total_price(self) -> float: Calculates the total price of items in the cart after applying discounts and coupon. pass def summary(self) -> (List[Dict[str, float]], float): Provides a summary of the shopping cart, including original price, discount applied, and final price for each item, and the total price. Returns: List[Dict[str, float]]: A list of dictionaries containing item details. float: The total price after discounts and coupon. pass # Unit Tests: def test_add_item(): cart = ShoppingCart() item = Item(1, 'Test Item', 100.0, 10) cart.add_item(item) assert len(cart.items) == 1 def test_remove_item(): cart = ShoppingCart() item1 = Item(1, 'Item 1', 100.0, 10) item2 = Item(2, 'Item 2', 200.0, 20) cart.add_item(item1) cart.add_item(item2) cart.remove_item(1) assert len(cart.items) == 1 assert cart.items[0].item_id == 2 def test_apply_coupon(): cart = ShoppingCart() item = Item(1, 'Test Item', 100.0, 10) cart.add_item(item) cart.apply_coupon(10) assert cart.coupon_discount == 10 def test_total_price_without_coupon(): cart = ShoppingCart() item1 = Item(1, 'Item 1', 100.0, 10) item2 = Item(2, 'Item 2', 200.0, 20) cart.add_item(item1) cart.add_item(item2) total = cart.total_price() assert total == (90 + 160) def test_total_price_with_coupon(): cart = ShoppingCart() item1 = Item(1, 'Item 1', 100.0, 10) item2 = Item(2, 'Item 2', 200.0, 20) cart.add_item(item1) cart.add_item(item2) cart.apply_coupon(10) total = cart.total_price() assert total == (90 + 160) * 0.9 def test_summary(): cart = ShoppingCart() item1 = Item(1, 'Item 1', 100.0, 10) item2 = Item(2, 'Item 2', 200.0, 20) cart.add_item(item1) cart.add_item(item2) summary, total = cart.summary() assert len(summary) == 2 assert summary[0]['Item ID'] == 1 assert summary[0]['Original Price'] == 100.0 assert summary[0]['Discounted Price'] == 90.0 assert summary[1]['Item ID'] == 2 assert summary[1]['Original Price'] == 200.0 assert summary[1]['Discounted Price'] == 160.0 assert total == 90 + 160","solution":"class Item: def __init__(self, item_id, name, price, discount): self.item_id = item_id self.name = name self.price = price self.discount = discount def discounted_price(self): return self.price - (self.price * self.discount / 100.0) class ShoppingCart: def __init__(self): self.items = [] self.coupon_discount = 0 def add_item(self, item): self.items.append(item) def remove_item(self, item_id): self.items = [item for item in self.items if item.item_id != item_id] def apply_coupon(self, coupon_discount): self.coupon_discount = coupon_discount def total_price(self): total = sum(item.discounted_price() for item in self.items) total -= (total * self.coupon_discount / 100.0) return total def summary(self): summary_list = [] for item in self.items: summary_list.append({ 'Item ID': item.item_id, 'Name': item.name, 'Original Price': item.price, 'Discount Applied': item.discount, 'Discounted Price': item.discounted_price() }) total = self.total_price() return summary_list, total"},{"question":"def three_sum(nums: List[int]) -> List[List[int]]: Returns a list of all unique triplets in the given list that add up to zero. >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([1, 2, 3, 4, 5]) [] >>> three_sum([-1, 0, 1]) [[-1, 0, 1]] >>> three_sum([-1, -1, -1, 2, 2, 2, 0, 1, 1, 1]) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([]) [] >>> three_sum([0, 0, 0, 0]) [[0, 0, 0]]","solution":"def three_sum(nums): Returns a list of all unique triplets in the given list that add up to zero. nums.sort() result = [] n = len(nums) for i in range(n-2): if i > 0 and nums[i] == nums[i-1]: continue left, right = i+1, n-1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left+1]: left += 1 while left < right and nums[right] == nums[right-1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return result"},{"question":"from typing import List def find_unique_elements(list1: List[int], list2: List[int]) -> List[int]: Write a Python function named \`find_unique_elements\` that takes two lists of integers as input and returns a new list containing the elements that are unique to each list (i.e., elements that are in one list but not the other). Ensure your function efficiently handles duplicated numbers and provides the correct unique elements. Additionally, explain how your function works and discuss its time complexity. Example: list1 = [1, 2, 3, 4, 4, 5, 6] list2 = [4, 5, 6, 7, 8, 9] find_unique_elements(list1, list2) -> [1, 2, 3, 7, 8, 9] >>> find_unique_elements([1, 2, 3, 4, 4, 5, 6], [4, 5, 6, 7, 8, 9]) [1, 2, 3, 7, 8, 9] >>> find_unique_elements([1, 2, 3, 4], [1, 2, 3, 4]) [] >>> find_unique_elements([], []) [] >>> find_unique_elements([1, 2, 3], [4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> find_unique_elements([1, 1, 2, 2, 3, 3], [3, 3, 4, 4, 5, 5]) [1, 2, 4, 5]","solution":"def find_unique_elements(list1, list2): Returns a new list containing the elements that are unique to each list. Elements in the result list are in either of the input lists but not in both. # Convert the lists to sets set1 = set(list1) set2 = set(list2) # Find elements unique to each set unique_to_list1 = set1 - set2 unique_to_list2 = set2 - set1 # Combine the unique elements unique_elements = list(unique_to_list1 | unique_to_list2) return unique_elements"},{"question":"def reverse_vowels(s: str) -> str: This function reverses the vowels in the given string \`s\` while leaving other characters in their original positions. >>> reverse_vowels(\\"hello\\") \\"holle\\" >>> reverse_vowels(\\"programming\\") \\"prigrammong\\" >>> reverse_vowels(\\"\\") \\"\\" >>> reverse_vowels(\\"bcdfghjklmnpqrstvwxyz\\") \\"bcdfghjklmnpqrstvwxyz\\" >>> reverse_vowels(\\"aeiouAEIOU\\") \\"UOIEAuoiea\\" >>> reverse_vowels(\\"a\\") \\"a\\" >>> reverse_vowels(\\"b\\") \\"b\\"","solution":"def reverse_vowels(s): This function reverses the vowels in the given string \`s\` while leaving other characters in their original positions. vowels = \\"aeiouAEIOU\\" s = list(s) i, j = 0, len(s) - 1 while i < j: if s[i] in vowels and s[j] in vowels: s[i], s[j] = s[j], s[i] i += 1 j -= 1 elif s[i] in vowels: j -= 1 else: i += 1 return ''.join(s) # Test cases: # reverse_vowels(\\"hello\\") => \\"holle\\" # reverse_vowels(\\"programming\\") => \\"prigrammong\\""},{"question":"def flatten_dictionary(d, parent_key='', separator='.'): Flattens a nested dictionary. Args: d (dict): The input nested dictionary. parent_key (str, optional): The base key to start with, for recursion. Default is ''. separator (str, optional): The separator to use between keys. Default is '.'. Returns: dict: A new dictionary with flattened keys. # Your code here def test_flatten_simple(): nested_dict = {'a': 1, 'b': 2} expected = {'a': 1, 'b': 2} assert flatten_dictionary(nested_dict) == expected def test_flatten_with_one_level_of_nesting(): nested_dict = {'a': 1, 'b': {'c': 2, 'd': 3}} expected = {'a': 1, 'b.c': 2, 'b.d': 3} assert flatten_dictionary(nested_dict) == expected def test_flatten_with_multiple_levels_of_nesting(): nested_dict = {'a': 1, 'b': {'c': 2, 'd': {'e': 3, 'f': 4}}, 'g': 5} expected = {'a': 1, 'b.c': 2, 'b.d.e': 3, 'b.d.f': 4, 'g': 5} assert flatten_dictionary(nested_dict) == expected def test_flatten_with_different_separator(): nested_dict = {'a': 1, 'b': {'c': 2, 'd': 3}} expected = {'a': 1, 'b+c': 2, 'b+d': 3} assert flatten_dictionary(nested_dict, separator='+') == expected def test_flatten_empty_dict(): nested_dict = {} expected = {} assert flatten_dictionary(nested_dict) == expected","solution":"def flatten_dictionary(d, parent_key='', separator='.'): Flattens a nested dictionary. Args: d (dict): The input nested dictionary. parent_key (str, optional): The base key to start with, for recursion. Default is ''. separator (str, optional): The separator to use between keys. Default is '.'. Returns: dict: A new dictionary with flattened keys. items = [] for k, v in d.items(): new_key = f\\"{parent_key}{separator}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dictionary(v, new_key, separator=separator).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def merge_and_intersect(list1: List[int], list2: List[int]) -> Tuple[List[int], List[int]]: Design a function \`merge_and_intersect\` that takes two lists of integers as arguments. The function should return a tuple containing two lists: 1. The first list should contain all elements that appear in either of the input lists (union), without duplicates. 2. The second list should contain only those elements that appear in both input lists (intersection), without duplicates. >>> merge_and_intersect([1, 3, 4, 6, 7, 9], [1, 2, 4, 5, 9, 10]) ([1, 2, 3, 4, 5, 6, 7, 9, 10], [1, 4, 9]) >>> merge_and_intersect([1, 3, 5], [2, 4, 6]) ([1, 2, 3, 4, 5, 6], []) >>> merge_and_intersect([1, 2, 3], [1, 2, 3]) ([1, 2, 3], [1, 2, 3]) >>> merge_and_intersect([], []) ([], []) >>> merge_and_intersect([1, 2, 3], []) ([1, 2, 3], [])","solution":"def merge_and_intersect(list1, list2): This function returns a tuple containing two lists: 1. The union of list1 and list2 without duplicates. 2. The intersection of list1 and list2 without duplicates. Args: list1 (list): First list of integers. list2 (list): Second list of integers. Returns: tuple: A tuple containing the union and intersection of the two lists. set1 = set(list1) set2 = set(list2) union = list(set1.union(set2)) intersection = list(set1.intersection(set2)) return (union, intersection)"},{"question":"import asyncio import websockets import json async def start_server(): Create a program that implements a basic chat server using WebSockets in Python. The server should be capable of handling multiple simultaneous client connections and implement the following features: 1. A way for new users to connect to the chat by providing a unique username. 2. Broadcast a new user's arrival to all connected clients. 3. Allow users to send messages to all other connected clients. 4. Notify all clients when a user disconnects from the chat. Ensure the server manages connections and messages accurately, preventing any data loss or misrouting. Handle cases where users try to connect with a username that is already in use, and respond with appropriate error messages. Test cases: >>> import asyncio >>> import websockets >>> import json >>> import pytest >>> from solution import start_server >>> @pytest.fixture ... def event_loop(): ... loop = asyncio.get_event_loop() ... yield loop ... loop.close() >>> @pytest.fixture ... async def server(event_loop): ... server = await start_server ... yield server ... server.close() ... await server.wait_closed() >>> async def connect_client(username): ... async with websockets.connect(\\"ws://localhost:12345\\") as websocket: ... await websocket.send(json.dumps({\\"action\\": \\"register\\", \\"username\\": username})) ... response = await websocket.recv() ... response_data = json.loads(response) ... return websocket, response_data >>> @pytest.mark.asyncio ... async def test_user_registration(): ... websocket, response = await connect_client(\\"user1\\") ... assert response[\\"action\\"] == \\"message\\" ... assert response[\\"message\\"] == \\"user1 has joined the chat\\" ... await websocket.close() >>> @pytest.mark.asyncio ... async def test_username_already_taken(): ... websocket1, response = await connect_client(\\"user1\\") ... websocket2, response = await connect_client(\\"user1\\") ... assert response[\\"action\\"] == \\"error\\" ... assert response[\\"message\\"] == \\"Username already taken\\" ... await websocket1.close() ... await websocket2.close() >>> @pytest.mark.asyncio ... async def test_broadcast_message(server): ... websocket1, _ = await connect_client(\\"user1\\") ... websocket2, _ = await connect_client(\\"user2\\") ... ... await websocket1.send(json.dumps({\\"action\\": \\"message\\", \\"message\\": \\"Hello!\\"})) ... response = await websocket2.recv() ... response_data = json.loads(response) ... assert response_data[\\"action\\"] == \\"message\\" ... assert response_data[\\"message\\"] == \\"user1: Hello!\\" ... ... await websocket1.close() ... await websocket2.close() >>> @pytest.mark.asyncio ... async def test_user_departure_notification(server): ... websocket1, _ = await connect_client(\\"user1\\") ... websocket2, _ = await connect_client(\\"user2\\") ... ... await websocket1.close() ... response = await websocket2.recv() ... response_data = json.loads(response) ... assert response_data[\\"action\\"] == \\"message\\" ... assert response_data[\\"message\\"] == \\"user1 has left the chat\\" ... ... await websocket2.close()","solution":"import asyncio import websockets import json clients = {} usernames = set() async def register_client(websocket): while True: msg = await websocket.recv() msg_data = json.loads(msg) if msg_data[\\"action\\"] == \\"register\\": username = msg_data[\\"username\\"] if username in usernames: await websocket.send(json.dumps({\\"action\\": \\"error\\", \\"message\\": \\"Username already taken\\"})) else: usernames.add(username) clients[websocket] = username await broadcast(f\\"{username} has joined the chat\\") break async def unregister_client(websocket): username = clients[websocket] del clients[websocket] usernames.remove(username) await broadcast(f\\"{username} has left the chat\\") async def broadcast(message): if clients: msg_data = {\\"action\\": \\"message\\", \\"message\\": message} await asyncio.wait([client.send(json.dumps(msg_data)) for client in clients.keys()]) async def handler(websocket, path): await register_client(websocket) try: async for message in websocket: msg_data = json.loads(message) if msg_data[\\"action\\"] == \\"message\\": await broadcast(f\\"{clients[websocket]}: {msg_data['message']}\\") finally: await unregister_client(websocket) start_server = websockets.serve(handler, \\"localhost\\", 12345) if __name__ == \\"__main__\\": asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever()"},{"question":"import requests from datetime import datetime, timedelta def get_recent_users(api_url: str, days: int = 30) -> list: Retrieves user data from a RESTful API and filters users who registered within the last 'days' days. Parameters: api_url (str): The URL of the RESTful API endpoint. days (int): The number of days to check for recent registrations. Returns: list: A list of filtered user data. Raises: requests.exceptions.RequestException: For network-related errors. ValueError: If the response JSON structure is unexpected. Example: >>> get_recent_users(\\"https://example.com/api/users\\", 30) [{'id': 1, 'registration_date': '2023-09-15'}, ...] pass import pytest from unittest.mock import patch, Mock def test_get_recent_users_successful_response(): # Mock API data mock_users = [ {\\"id\\": 1, \\"registration_date\\": (datetime.now() - timedelta(days=10)).strftime('%Y-%m-%d')}, {\\"id\\": 2, \\"registration_date\\": (datetime.now() - timedelta(days=40)).strftime('%Y-%m-%d')}, ] # Mock requests.get to return a mock response with patch('requests.get') as mock_get: mock_response = Mock() mock_response.raise_for_status = Mock() mock_response.json = Mock(return_value=mock_users) mock_get.return_value = mock_response # Call the function recent_users = get_recent_users(\\"https://example.com/api/users\\", 30) # Assert only the user registered within the last 30 days is returned assert len(recent_users) == 1 assert recent_users[0]['id'] == 1 def test_get_recent_users_invalid_json_format(): # Invalid data format (e.g., missing 'registration_date') mock_users = [ {\\"id\\": 1, \\"not_registration_date\\": \\"2023-10-01\\"}, ] # Mock requests.get to return the invalid response with patch('requests.get') as mock_get: mock_response = Mock() mock_response.raise_for_status = Mock() mock_response.json = Mock(return_value=mock_users) mock_get.return_value = mock_response # Call the function and expect a ValueError with pytest.raises(ValueError): get_recent_users(\\"https://example.com/api/users\\", 30) def test_get_recent_users_http_error(): # Mock requests.get to raise an HTTP error with patch('requests.get') as mock_get: mock_get.side_effect = requests.exceptions.HTTPError(\\"HTTP error occurred\\") # Call the function and expect a SystemExit with pytest.raises(SystemExit): get_recent_users(\\"https://example.com/api/users\\", 30) def test_get_recent_users_empty_list(): # Mock API returns an empty list with patch('requests.get') as mock_get: mock_response = Mock() mock_response.raise_for_status = Mock() mock_response.json = Mock(return_value=[]) mock_get.return_value = mock_response # Call the function and assert an empty list is returned recent_users = get_recent_users(\\"https://example.com/api/users\\", 30) assert recent_users == []","solution":"import requests from datetime import datetime, timedelta def get_recent_users(api_url, days=30): Retrieves user data from a RESTful API and filters users who registered within the last 'days' days. Parameters: api_url (str): The URL of the RESTful API endpoint. days (int): The number of days to check for recent registrations. Returns: list: A list of filtered user data. Raises: requests.exceptions.RequestException: For network-related errors. ValueError: If the response JSON structure is unexpected. try: response = requests.get(api_url) response.raise_for_status() users = response.json() recent_users = [] cutoff_date = datetime.now() - timedelta(days=days) for user in users: registration_date = datetime.strptime(user['registration_date'], '%Y-%m-%d') if registration_date >= cutoff_date: recent_users.append(user) return recent_users except requests.exceptions.RequestException as e: raise SystemExit(e) except (ValueError, KeyError) as e: raise ValueError(f\\"Invalid data format received: {e}\\") # Note: # - This script assumes that the RESTful API endpoint returns user data in JSON format. # - Each user object is expected to have a 'registration_date' field in 'YYYY-MM-DD' format. # Example API URL: \\"https://example.com/api/users\\""},{"question":"from typing import List def anagram_groups(strings: List[str]) -> List[List[str]]: Groups the list of strings into anagram groups. Args: strings (List[str]): The list of strings to group. Returns: List[List[str]]: A list of lists containing anagram groups. pass def test_anagram_groups_example(): assert anagram_groups([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) == [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] def test_anagram_groups_empty_list(): assert anagram_groups([]) == [] def test_anagram_groups_no_anagrams(): assert anagram_groups([\\"abc\\", \\"def\\", \\"ghi\\"]) == [[\\"abc\\"], [\\"def\\"], [\\"ghi\\"]] def test_anagram_groups_single_character_strings(): assert anagram_groups([\\"a\\", \\"b\\", \\"a\\"]) == [[\\"a\\", \\"a\\"], [\\"b\\"]] def test_anagram_groups_same_string_multiple_times(): assert anagram_groups([\\"abc\\", \\"abc\\", \\"cba\\"]) == [[\\"abc\\", \\"abc\\", \\"cba\\"]]","solution":"from collections import defaultdict from typing import List def anagram_groups(strings: List[str]) -> List[List[str]]: Groups the list of strings into anagram groups. Args: strings (List[str]): The list of strings to group. Returns: List[List[str]]: A list of lists containing anagram groups. anagram_dict = defaultdict(list) for string in strings: sorted_string = ''.join(sorted(string)) anagram_dict[sorted_string].append(string) return list(anagram_dict.values())"},{"question":"import math from typing import List, Dict def is_prime(n: int) -> bool: Return True if n is a prime number. # Implementation required def is_perfect_square(n: int) -> bool: Return True if n is a perfect square. # Implementation required def factorial(n: int) -> int: Return the factorial of n. # Implementation required def analyze_numbers(numbers: List[int]) -> Dict[int, Dict[str, int]]: Analyze a list of numbers for prime, perfect square, and factorial properties. >>> analyze_numbers([2, 4, 5, -1, 0]) {2: {'is_prime': True, 'is_perfect_square': False, 'factorial': 2}, 4: {'is_prime': False, 'is_perfect_square': True, 'factorial': 24}, 5: {'is_prime': True, 'is_perfect_square': False, 'factorial': 120}, -1: {'is_prime': False, 'is_perfect_square': False, 'factorial': None}, 0: {'is_prime': False, 'is_perfect_square': True, 'factorial': 1}} # Implementation required","solution":"import math def is_prime(n): Return True if n is a prime number. if n <= 1: return False for i in range(2, int(math.sqrt(n)) + 1): if n % i == 0: return False return True def is_perfect_square(n): Return True if n is a perfect square. if n < 0: return False return int(math.sqrt(n))**2 == n def factorial(n): Return the factorial of n. if n < 0: return None # Factorial for negative numbers is not defined if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result def analyze_numbers(numbers): Analyze a list of numbers for prime, perfect square, and factorial properties. result = {} for number in numbers: result[number] = { \\"is_prime\\": is_prime(number), \\"is_perfect_square\\": is_perfect_square(number), \\"factorial\\": factorial(number) } return result"},{"question":"def spiral_matrix(n: int) -> list: Generates a spiral matrix of size n filled with numbers from 1 to n*n. >>> spiral_matrix(1) [[1]] >>> spiral_matrix(2) [[1, 2], [4, 3]] >>> spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> spiral_matrix(-1) [] >>> spiral_matrix(0) []","solution":"def spiral_matrix(n): Generates a spiral matrix of size n filled with numbers from 1 to n*n. Args: n (int): The size of the matrix (n x n) Returns: list of list: A 2D list representing the spiral matrix. if n <= 0: return [] matrix = [[0] * n for _ in range(n)] left, right, top, bottom = 0, n - 1, 0, n - 1 num = 1 while left <= right and top <= bottom: for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"def modify_list_with_sum(input_list): Given a list of integers, return a new list where each element at index i is the sum of all elements in the input list except the one at i. You are not allowed to use division in your solution. The function should have a linear runtime complexity. Example 1: Input: input_list = [1, 2, 3, 4] Output: [9, 8, 7, 6] Example 2: Input: input_list = [5, 3, 2, 1] Output: [6, 8, 9, 10] Constraints: * The length of the input list can range from 1 to 10^4 * Each element in the list can be a value between -10^5 and 10^5 # Tests def test_modify_list_with_sum_example1(): input_list = [1, 2, 3, 4] expected_output = [9, 8, 7, 6] assert modify_list_with_sum(input_list) == expected_output def test_modify_list_with_sum_example2(): input_list = [5, 3, 2, 1] expected_output = [6, 8, 9, 10] assert modify_list_with_sum(input_list) == expected_output def test_modify_list_with_sum_single_element(): input_list = [10] expected_output = [0] assert modify_list_with_sum(input_list) == expected_output def test_modify_list_with_sum_negative_numbers(): input_list = [-1, -2, -3, -4] expected_output = [-9, -8, -7, -6] assert modify_list_with_sum(input_list) == expected_output def test_modify_list_with_sum_mixed_numbers(): input_list = [-1, 2, -3, 4] expected_output = [3, 0, 5, -2] assert modify_list_with_sum(input_list) == expected_output def test_modify_list_with_sum_large_list(): input_list = [i for i in range(10000)] expected_output = [sum(input_list) - i for i in input_list] assert modify_list_with_sum(input_list) == expected_output","solution":"def modify_list_with_sum(input_list): Given a list of integers, return a new list where each element at index i is the sum of all elements in the input list except the one at i. total_sum = sum(input_list) return [total_sum - x for x in input_list]"},{"question":"def square_even_numbers(nums: List[int]) -> List[int]: Create a function that receives a list of integers and returns a new list with each integer squared, but only if the integer is an even number. >>> square_even_numbers([1, 2, 3, 4, 5, 6]) [4, 16, 36] >>> square_even_numbers([2, 4, 6, 8]) [4, 16, 36, 64] >>> square_even_numbers([1, 3, 5, 7]) [] >>> square_even_numbers([]) [] >>> square_even_numbers([-2, -4, -6]) [4, 16, 36]","solution":"def square_even_numbers(nums): Returns a list of squares of even numbers from the input list. result = [] for num in nums: if num % 2 == 0: print(f\\"Squaring even number: {num}\\") result.append(num ** 2) else: print(f\\"Skipping odd number: {num}\\") if not nums: print(\\"Input list is empty.\\") elif not result: print(\\"No even numbers found.\\") return result"},{"question":"def fibonacci(n: int) -> int: Returns the n-th Fibonacci number. The Fibonacci sequence is a series of numbers where the next number is found by adding up the two numbers before it. The sequence starts with 0 and 1. >>> fibonacci(1) # 1st Fibonacci number is 0 0 >>> fibonacci(2) # 2nd Fibonacci number is 1 1 >>> fibonacci(10) # 10th Fibonacci number is 34 34 >>> fibonacci(50) # 50th Fibonacci number is 7778742049 7778742049","solution":"def fibonacci(n: int) -> int: Returns the n-th Fibonacci number. if n <= 0: raise ValueError(\\"n must be a positive integer\\") if n == 1: return 0 elif n == 2: return 1 a, b = 0, 1 for _ in range(2, n): a, b = b, a + b return b"},{"question":"def is_palindrome(s: str) -> bool: Check if the input string is a valid palindrome considering only alphanumeric characters and ignoring cases. Args: s (str): The input string to check. Returns: bool: True if the string is a valid palindrome, False otherwise. Examples: >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"!!!\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"Aba\\") True >>> is_palindrome(\\"Aa\\") True","solution":"def is_palindrome(s): Check if the input string is a valid palindrome considering only alphanumeric characters and ignoring cases. Args: s (str): The input string to check. Returns: bool: True if the string is a valid palindrome, False otherwise. # Remove non-alphanumeric characters and transform to lowercase cleaned = ''.join(char.lower() for char in s if char.isalnum()) # Compare the cleaned string with its reverse return cleaned == cleaned[::-1]"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") == 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") == 5 from solution import length_of_longest_substring_two_distinct def test_example_cases(): assert length_of_longest_substring_two_distinct(\\"eceba\\") == 3 assert length_of_longest_substring_two_distinct(\\"ccaabbb\\") == 5 def test_empty_string(): assert length_of_longest_substring_two_distinct(\\"\\") == 0 def test_single_char_string(): assert length_of_longest_substring_two_distinct(\\"a\\") == 1 def test_all_same_char(): assert length_of_longest_substring_two_distinct(\\"aaaaaa\\") == 6 def test_no_repeating_char(): assert length_of_longest_substring_two_distinct(\\"abcdefg\\") == 2 def test_string_length_two(): assert length_of_longest_substring_two_distinct(\\"ab\\") == 2 def test_string_length_three(): assert length_of_longest_substring_two_distinct(\\"abc\\") == 2 assert length_of_longest_substring_two_distinct(\\"aab\\") == 3 def test_larger_string(): assert length_of_longest_substring_two_distinct(\\"abcabcabcabc\\") == 2 assert length_of_longest_substring_two_distinct(\\"abaccc\\") == 4","solution":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. if len(s) == 0: return 0 left, right = 0, 0 max_length = 0 char_count = {} while right < len(s): char = s[right] if char in char_count: char_count[char] += 1 else: char_count[char] = 1 while len(char_count) > 2: left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def move_digits_to_end(s: str) -> str: 'move_digits_to_end' relocates all the digits in the string to the end while maintaining the order of both digits and non-digits. >>> move_digits_to_end(\\"a3bc2d1!@\\") 'abcd!@321' >>> move_digits_to_end(\\"h4ell2o6!\\") 'hello!426' from solution import move_digits_to_end def test_example_case_1(): assert move_digits_to_end(\\"a3bc2d1!@\\") == \\"abcd!@321\\" def test_example_case_2(): assert move_digits_to_end(\\"h4ell2o6!\\") == \\"hello!426\\" def test_no_digits(): assert move_digits_to_end(\\"abcdef\\") == \\"abcdef\\" def test_only_digits(): assert move_digits_to_end(\\"123456\\") == \\"123456\\" def test_empty_string(): assert move_digits_to_end(\\"\\") == \\"\\" def test_mixed_characters(): assert move_digits_to_end(\\"a1!2b3@4\\") == \\"a!b@1234\\" def test_all_special_characters(): assert move_digits_to_end(\\"!@#%^&\\") == \\"!@#%^&\\"","solution":"def move_digits_to_end(s: str) -> str: 'move_digits_to_end' relocates all the digits in the string to the end while maintaining the order of both digits and non-digits. letters = [] digits = [] for char in s: if char.isdigit(): digits.append(char) else: letters.append(char) return ''.join(letters) + ''.join(digits)"},{"question":"def evaluate_expression(s: str) -> int: Evaluate an algebraic expression containing the characters '(', ')', '+', '-', '*', '/', and non-negative integers. >>> evaluate_expression(\\"3 + 5\\") #8 >>> evaluate_expression(\\"( 2 + 3 ) * 4\\") #20 >>> evaluate_expression(\\"( 3 + ( 2 * 2 ) ) / 2\\") #3 # Example test cases print(evaluate_expression(\\"3 + 5\\")) #=> 8 print(evaluate_expression(\\"( 2 + 3 ) * 4\\")) #=> 20 print(evaluate_expression(\\"( 3 + ( 2 * 2 ) ) / 2\\")) #=> 3","solution":"def evaluate_expression(s): def parse(tokens): if tokens and tokens[0] == '(': tokens.pop(0) # Remove the opening parenthesis value = parse_expression(tokens) tokens.pop(0) # Remove the closing parenthesis return value else: return int(tokens.pop(0)) def parse_term(tokens): value = parse(tokens) while tokens and tokens[0] in '*/': op = tokens.pop(0) if op == '*': value *= parse(tokens) elif op == '/': value //= parse(tokens) return value def parse_expression(tokens): value = parse_term(tokens) while tokens and tokens[0] in '+-': op = tokens.pop(0) if op == '+': value += parse_term(tokens) elif op == '-': value -= parse_term(tokens) return value tokens = s.replace('(', ' ( ').replace(')', ' ) ').split() return parse_expression(tokens)"},{"question":"def generate_combinations(arr: List[int], k: int) -> List[List[int]]: Generate all possible combinations of \`k\` numbers from the list \`arr\` using a recursive approach. >>> generate_combinations([1, 2, 3, 4], 2) [ [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4] ] >>> generate_combinations([1, 2, 3, 4], 1) [[1], [2], [3], [4]] >>> generate_combinations([1, 2, 3, 4], 4) [[1, 2, 3, 4]] >>> generate_combinations([], 2) [] >>> generate_combinations([1, 2], 3) [] >>> generate_combinations([1, 2, 3, 4], 0) [[]] result = [] def backtrack(start, current_combination): if len(current_combination) == k: result.append(current_combination[:]) print(f\\"Current Combination: {current_combination}\\") return for i in range(start, len(arr)): current_combination.append(arr[i]) print(f\\"Adding {arr[i]}: {current_combination}\\") backtrack(i + 1, current_combination) removed_element = current_combination.pop() print(f\\"Removing {removed_element}: {current_combination}\\") backtrack(0, []) return result","solution":"def generate_combinations(arr, k): def backtrack(start, current_combination): if len(current_combination) == k: result.append(current_combination[:]) print(f\\"Current Combination: {current_combination}\\") return for i in range(start, len(arr)): current_combination.append(arr[i]) print(f\\"Adding {arr[i]}: {current_combination}\\") backtrack(i + 1, current_combination) removed_element = current_combination.pop() print(f\\"Removing {removed_element}: {current_combination}\\") result = [] backtrack(0, []) return result"},{"question":"from typing import List def max_sum_subarray(arr: List[int]) -> int: Returns the maximum sum of a contiguous subarray using Kadane's Algorithm. >>> max_sum_subarray([1, 2, 3, -2, 5]) 9 >>> max_sum_subarray([-1, -2, -3, -4]) -1 >>> max_sum_subarray([-1, -2, -3, 0]) 0 >>> max_sum_subarray([3, -2, 5, -1]) 6 def max_subarray_start_index(arr: List[int]) -> int: Returns the starting index of the subarray with the maximum sum using Kadane's Algorithm. >>> max_subarray_start_index([1, 2, 3, -2, 5]) 0 >>> max_subarray_start_index([-1, -2, -3, -4]) 0 >>> max_subarray_start_index([-1, -2, -3, 0]) 3 >>> max_subarray_start_index([3, -2, 5, -1]) 0 def max_subarray_end_index(arr: List[int]) -> int: Returns the ending index of the subarray with the maximum sum using Kadane's Algorithm. >>> max_subarray_end_index([1, 2, 3, -2, 5]) 4 >>> max_subarray_end_index([-1, -2, -3, -4]) 0 >>> max_subarray_end_index([-1, -2, -3, 0]) 3 >>> max_subarray_end_index([3, -2, 5, -1]) 2 import pytest def test_max_sum_subarray(): assert max_sum_subarray([1, 2, 3, -2, 5]) == 9 assert max_sum_subarray([-1, -2, -3, -4]) == -1 assert max_sum_subarray([-1, -2, -3, 0]) == 0 assert max_sum_subarray([3, -2, 5, -1]) == 6 def test_max_sum_subarray_empty_list(): with pytest.raises(ValueError, match=\\"Input list cannot be empty\\"): max_sum_subarray([]) def test_max_subarray_start_index(): assert max_subarray_start_index([1, 2, 3, -2, 5]) == 0 assert max_subarray_start_index([-1, -2, -3, -4]) == 0 assert max_subarray_start_index([-1, -2, -3, 0]) == 3 assert max_subarray_start_index([3, -2, 5, -1]) == 0 def test_max_subarray_start_index_empty_list(): with pytest.raises(ValueError, match=\\"Input list cannot be empty\\"): max_subarray_start_index([]) def test_max_subarray_end_index(): assert max_subarray_end_index([1, 2, 3, -2, 5]) == 4 assert max_subarray_end_index([-1, -2, -3, -4]) == 0 assert max_subarray_end_index([-1, -2, -3, 0]) == 3 assert max_subarray_end_index([3, -2, 5, -1]) == 2 def test_max_subarray_end_index_empty_list(): with pytest.raises(ValueError, match=\\"Input list cannot be empty\\"): max_subarray_end_index([])","solution":"def max_sum_subarray(arr): Returns the maximum sum of a contiguous subarray using Kadane's Algorithm. if not arr: raise ValueError(\\"Input list cannot be empty\\") max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum def max_subarray_start_index(arr): Returns the starting index of the subarray with the maximum sum. if not arr: raise ValueError(\\"Input list cannot be empty\\") max_sum = current_sum = arr[0] start_index = temp_start = 0 for i in range(1, len(arr)): if arr[i] > current_sum + arr[i]: temp_start = i current_sum = arr[i] else: current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start_index = temp_start return start_index def max_subarray_end_index(arr): Returns the ending index of the subarray with the maximum sum. if not arr: raise ValueError(\\"Input list cannot be empty\\") max_sum = current_sum = arr[0] start_index = end_index = temp_start = 0 for i in range(1, len(arr)): if arr[i] > current_sum + arr[i]: temp_start = i current_sum = arr[i] else: current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start_index = temp_start end_index = i return end_index"},{"question":"from typing import List def generate_fibonacci_sequence(n: int) -> List[int]: Function to generate Fibonacci sequence up to n numbers >>> generate_fibonacci_sequence(0) == [] >>> generate_fibonacci_sequence(1) == [0] >>> generate_fibonacci_sequence(2) == [0, 1] >>> generate_fibonacci_sequence(5) == [0, 1, 1, 2, 3] >>> generate_fibonacci_sequence(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def generate_fibonacci_sequence(n): Function to generate Fibonacci sequence up to n numbers sequence = [] # Initialize an empty list to store Fibonacci sequence a, b = 0, 1 # Initialize the first two numbers of the sequence while len(sequence) < n: sequence.append(a) # Append the current value of 'a' to the sequence a, b = b, a + b # Update 'a' to 'b' and 'b' to 'a+b' return sequence # Return the generated Fibonacci sequence # Example usage print(generate_fibonacci_sequence(10)) # Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]"},{"question":"def first_non_repeating_char(s: str) -> str: Returns the first non-repeating character in the string s. If all characters are repeating or the string is empty, returns None. >>> first_non_repeating_char(\\"swiss\\") == 'w' >>> first_non_repeating_char(\\"repetition\\") == 'r' >>> first_non_repeating_char(\\"aabbcc\\") == None >>> first_non_repeating_char(\\"abcdefghijklmnopqrstuvwxyz\\") == 'a' >>> first_non_repeating_char(\\"\\") == None >>> first_non_repeating_char(\\"aabbccd\\") == 'd' >>> first_non_repeating_char(\\"abcabc\\") == None >>> first_non_repeating_char(\\"z\\") == 'z' # Write your code here","solution":"def first_non_repeating_char(s: str) -> str: Returns the first non-repeating character in the string s. If all characters are repeating or the string is empty, returns None. from collections import Counter char_count = Counter(s) # Count occurrences of each character for char in s: if char_count[char] == 1: return char return None"},{"question":"def second_smallest_unique(nums): Returns the second smallest unique integer from the list nums. If there are fewer than two unique integers, returns an appropriate message. If there are non-integer elements in the list, returns a message indicating invalid input. >>> second_smallest_unique([1, 2, 3, 4, 5]) == 2 >>> second_smallest_unique([4, 1, 2, 2, 3, 4, 5]) == 2 >>> second_smallest_unique([1]) == \\"Not enough unique integers in the list.\\" >>> second_smallest_unique([2, 2, 2]) == \\"Not enough unique integers in the list.\\" >>> second_smallest_unique([1, \\"a\\", 2]) == \\"Invalid input: all elements must be integers\\" >>> second_smallest_unique([]) == \\"Not enough unique integers in the list.\\" >>> second_smallest_unique([1, 1, 1, 1]) == \\"Not enough unique integers in the list.\\" >>> second_smallest_unique([5, -1, -3, -3, -1, 4]) == -1","solution":"def second_smallest_unique(nums): Returns the second smallest unique integer from the list nums. If there are fewer than two unique integers, returns an appropriate message. if not all(isinstance(i, int) for i in nums): return \\"Invalid input: all elements must be integers\\" unique_nums = list(set(nums)) if len(unique_nums) < 2: return \\"Not enough unique integers in the list.\\" unique_nums.sort() return unique_nums[1]"},{"question":"from typing import List def unique_elements(lst: List[int]) -> List[int]: Returns a list containing only the unique elements from the input list. >>> unique_elements([1, 2, 2, 3, 4, 4, 5]) [1, 3, 5] >>> unique_elements([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> unique_elements([1, 1, 2, 2, 3, 3]) [] >>> unique_elements([]) [] >>> unique_elements([1]) [1] >>> unique_elements([4, 5, 6, 7, 5, 6, 8, 9, 9, 10]) [4, 7, 8, 10]","solution":"def unique_elements(lst): Returns a list containing only the unique elements from the input list. element_count = {} # Count the occurrences of each element for element in lst: if element in element_count: element_count[element] += 1 else: element_count[element] = 1 # Filter out elements that occur more than once result = [element for element in lst if element_count[element] == 1] return result"},{"question":"import random from collections import deque from typing import List, Tuple def generate_random_maze(size: int) -> List[List[int]]: Generates a random maze of a specified size. 0 - open cell, 1 - blocked cell Ensures there is at least one valid path from the top-left to the bottom-right corner of the maze. pass def bfs_solver(maze: List[List[int]]) -> List[Tuple[int, int]]: Solves the maze using Breadth-First Search (BFS) algorithm and returns the shortest path if exists or indicates no path. pass","solution":"import random from collections import deque def generate_random_maze(size): Generates a random maze of a specified size. 0 - open cell, 1 - blocked cell Ensures there is at least one valid path from the top-left to the bottom-right corner of the maze. maze = [[1 if random.random() < 0.3 else 0 for _ in range(size)] for _ in range(size)] maze[0][0] = 0 # Ensure start is open maze[size - 1][size - 1] = 0 # Ensure finish is open # Ensure there is a valid path def mark_valid_path(): x, y = 0, 0 while x < size - 1 or y < size - 1: maze[x][y] = 0 if x < size - 1 and (y == size - 1 or random.random() > 0.5): x += 1 elif y < size - 1: y += 1 maze[x][y] = 0 maze[x][y] = 0 mark_valid_path() return maze def bfs_solver(maze): Solves the maze using Breadth-First Search (BFS) algorithm and returns the shortest path if exists or indicates no path. size = len(maze) start = (0, 0) goal = (size - 1, size - 1) queue = deque([(start, [start])]) visited = set() while queue: (x, y), path = queue.popleft() if (x, y) == goal: return path for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < size and 0 <= ny < size and maze[nx][ny] == 0 and (nx, ny) not in visited: queue.append(((nx, ny), path + [(nx, ny)])) visited.add((nx, ny)) return \\"No path exists\\""},{"question":"import datetime class Account: account_counter = 1000 def __init__(self, owner_name: str): Initialize a new account with the owner's name and a unique account number. self.account_number = Account.account_counter self.owner_name = owner_name self.balance = 0.0 self.transactions = [] Account.account_counter += 1 def deposit(self, amount: float) -> float: Deposit an amount into the account and return the new balance. Raises ValueError if the amount is not positive. # Implementation here def withdraw(self, amount: float) -> float: Withdraw an amount from the account and return the new balance. Raises ValueError if the amount is not positive or exceeds the current balance. # Implementation here def transfer(self, amount: float, other_account: 'Account') -> None: Transfer an amount to another account. Raises ValueError if the amount is not positive or exceeds the current balance. # Implementation here def get_statement(self, start_date: datetime.datetime, end_date: datetime.datetime): Generate a statement of transactions between the start and end dates. # Implementation here class BankingSystem: def __init__(self): Initialize the banking system with an empty account dictionary. self.accounts = {} def create_account(self, owner_name: str) -> int: Create a new account with the owner's name and return the account number. # Implementation here def delete_account(self, account_number: int) -> None: Delete an existing account by its account number. Raises ValueError if the account number does not exist. # Implementation here def get_account(self, account_number: int) -> Account: Retrieve an account by its account number. Raises ValueError if the account number does not exist. # Implementation here import pytest def test_create_account(): system = BankingSystem() account_number = system.create_account(\\"John Doe\\") account = system.get_account(account_number) assert account.owner_name == \\"John Doe\\" assert account.balance == 0.0 def test_delete_account(): system = BankingSystem() account_number = system.create_account(\\"John Doe\\") system.delete_account(account_number) with pytest.raises(ValueError): system.get_account(account_number) def test_deposit(): system = BankingSystem() account_number = system.create_account(\\"John Doe\\") account = system.get_account(account_number) new_balance = account.deposit(100) assert new_balance == 100.0 with pytest.raises(ValueError): account.deposit(-50) def test_withdraw(): system = BankingSystem() account_number = system.create_account(\\"John Doe\\") account = system.get_account(account_number) account.deposit(200) new_balance = account.withdraw(50) assert new_balance == 150.0 with pytest.raises(ValueError): account.withdraw(300) with pytest.raises(ValueError): account.withdraw(-50) def test_transfer(): system = BankingSystem() account_number1 = system.create_account(\\"John Doe\\") account_number2 = system.create_account(\\"Jane Doe\\") account1 = system.get_account(account_number1) account2 = system.get_account(account_number2) account1.deposit(300) account1.transfer(100, account2) assert account1.balance == 200.0 assert account2.balance == 100.0 with pytest.raises(ValueError): account1.transfer(400, account2) with pytest.raises(ValueError): account1.transfer(-100, account2) def test_get_statement(): system = BankingSystem() account_number = system.create_account(\\"John Doe\\") account = system.get_account(account_number) start_date = datetime.datetime.now() account.deposit(100) account.withdraw(50) end_date = datetime.datetime.now() statement = account.get_statement(start_date, end_date) assert len(statement) == 2 assert statement[0][1] == 'deposit' assert statement[1][1] == 'withdrawal'","solution":"import datetime class Account: account_counter = 1000 def __init__(self, owner_name): self.account_number = Account.account_counter self.owner_name = owner_name self.balance = 0.0 self.transactions = [] Account.account_counter += 1 def deposit(self, amount): if amount <= 0: raise ValueError(\\"Deposit amount must be positive.\\") self.balance += amount self.transactions.append((datetime.datetime.now(), 'deposit', amount)) return self.balance def withdraw(self, amount): if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive.\\") if amount > self.balance: raise ValueError(\\"Insufficient funds.\\") self.balance -= amount self.transactions.append((datetime.datetime.now(), 'withdrawal', amount)) return self.balance def transfer(self, amount, other_account): if amount <= 0: raise ValueError(\\"Transfer amount must be positive.\\") if amount > self.balance: raise ValueError(\\"Insufficient funds.\\") self.withdraw(amount) other_account.deposit(amount) self.transactions.append((datetime.datetime.now(), 'transfer', amount, other_account.account_number)) other_account.transactions.append((datetime.datetime.now(), 'transfer', amount, self.account_number)) def get_statement(self, start_date, end_date): statement = [t for t in self.transactions if start_date <= t[0] <= end_date] return statement class BankingSystem: def __init__(self): self.accounts = {} def create_account(self, owner_name): account = Account(owner_name) self.accounts[account.account_number] = account return account.account_number def delete_account(self, account_number): if account_number in self.accounts: del self.accounts[account_number] else: raise ValueError(\\"Account number does not exist.\\") def get_account(self, account_number): if account_number in self.accounts: return self.accounts[account_number] else: raise ValueError(\\"Account number does not exist.\\")"},{"question":"def matrix_rotation(matrix: list) -> list: This Python function accepts a 2D list 'matrix' representing a square matrix and returns a new matrix that is the result of rotating the given matrix by 90 degrees clockwise. The function should handle any NxN matrix. Example: >>> matrix_rotation([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix_rotation([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> matrix_rotation([[5]]) [[5]]","solution":"def matrix_rotation(matrix: list) -> list: This Python function accepts a 2D list 'matrix' representing a square matrix and returns a new matrix that is the result of rotating the given matrix by 90 degrees clockwise. The function should handle any NxN matrix. Example: >>> matrix_rotation([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix_rotation([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> matrix_rotation([[5]]) [[5]] n = len(matrix) rotated_matrix = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"def group_elements(lst: List[int], group_by_type: bool = True) -> List[int]: Groups elements based on their types (positive, negative, zero) or their parity (even, odd). :param lst: List of integers to be grouped. :param group_by_type: Boolean parameter to decide the grouping criteria. Defaults to True. :return: Grouped list of integers based on the specified criteria. If group_by_type is True: >>> group_elements([0, -3, 7, 2, -1, -3, 5, 0]) [0, 0, -3, -1, -3, 7, 2, 5] If group_by_type is False: >>> group_elements([0, -3, 7, 2, -1, -3, 5, 0], group_by_type=False) [0, 2, 0, -3, 7, -1, -3, 5] # Here are some unit tests to validate the implementation def test_group_elements_by_type(): assert group_elements([0, -3, 7, 2, -1, -3, 5, 0]) == [0, 0, -3, -1, -3, 7, 2, 5] assert group_elements([-1, 2, 3, -4, 0, 5]) == [0, -1, -4, 2, 3, 5] def test_group_elements_by_parity(): assert group_elements([0, -3, 7, 2, -1, -3, 5, 0], group_by_type=False) == [0, 2, 0, -3, 7, -1, -3, 5] assert group_elements([-1, 2, 3, -4, 0, 5], group_by_type=False) == [2, -4, 0, -1, 3, 5] def test_group_elements_empty_list(): assert group_elements([]) == [] assert group_elements([], group_by_type=False) == [] def test_group_elements_invalid_input(): try: group_elements(\\"not a list\\") except ValueError as e: assert str(e) == \\"Input should be a list of integers.\\" try: group_elements([1, 2, 3.5]) except ValueError as e: assert str(e) == \\"Input should be a list of integers.\\"","solution":"def group_elements(lst, group_by_type=True): Groups elements based on their types (positive, negative, zero) or their parity (even, odd). :param lst: List of integers to be grouped. :param group_by_type: Boolean parameter to decide the grouping criteria. Defaults to True. :return: Grouped list of integers based on the specified criteria. if not isinstance(lst, list) or not all(isinstance(i, int) for i in lst): raise ValueError(\\"Input should be a list of integers.\\") if group_by_type: zero = [i for i in lst if i == 0] negative = [i for i in lst if i < 0] positive = [i for i in lst if i > 0] return zero + negative + positive else: even = [i for i in lst if i % 2 == 0] odd = [i for i in lst if i % 2 != 0] return even + odd"},{"question":"def sum_of_squares(n): Returns the sum of the squares of all integers from 1 to n inclusive. Parameters: n (int): The upper limit of the range. Returns: int: The sum of the squares str: Error message if input is not a positive integer >>> sum_of_squares(5) 55 >>> sum_of_squares(-3) 'Input should be a positive integer.' >>> sum_of_squares('a') 'Input should be an integer.'","solution":"def sum_of_squares(n): Returns the sum of the squares of all integers from 1 to n inclusive. Parameters: n (int): The upper limit of the range. Returns: int: The sum of the squares str: Error message if input is not a positive integer if not isinstance(n, int): return \\"Input should be an integer.\\" if n < 1: return \\"Input should be a positive integer.\\" return sum(i * i for i in range(1, n + 1))"},{"question":"def find_manager(organization: dict, employee: str) -> str: Returns the manager of the given employee in the organizational structure. If the employee does not have a manager or is not found, returns \\"None\\". >>> organization = { ... 'CEO': { ... 'CTO': { ... 'Dev1': {}, ... 'Dev2': {} ... }, ... 'CFO': { ... 'Acc1': {} ... } ... } ... } >>> find_manager(organization, 'Dev1') == 'CTO' >>> find_manager(organization, 'Acc1') == 'CFO' >>> find_manager(organization, 'CEO') == None >>> find_manager(organization, 'Dev3') == None >>> organization_nested = { ... 'CEO': { ... 'CTO': { ... 'Dev1': { ... 'Intern1': {} ... }, ... 'Dev2': {} ... }, ... 'CFO': { ... 'Acc1': {} ... } ... } ... } >>> find_manager(organization_nested, 'Intern1') == 'Dev1'","solution":"def find_manager(organization, employee): Returns the manager of the given employee in the organizational structure. If the employee does not have a manager or is not found, returns \\"None\\". def helper(current_structure, current_manager): for manager, subordinates in current_structure.items(): if employee in subordinates: return manager result = helper(subordinates, manager) if result: return result return None return helper(organization, None)"},{"question":"class GradeManager: def __init__(self, grades): self.grades = grades def add_grade(self, grade): Add a grade to the list. >>> gm = GradeManager([85, 92, 76]) >>> gm.add_grade(90) >>> gm.grades [85, 92, 76, 90] pass def remove_grade(self, grade): Remove a grade from the list if it exists. >>> gm = GradeManager([85, 92, 76]) >>> gm.remove_grade(76) >>> gm.grades [85, 92] >>> gm.remove_grade(80) Traceback (most recent call last): ... ValueError: Grade 80 not found in the list. pass def sort_grades(self): Sort the list of grades in ascending order. >>> gm = GradeManager([85, 92, 76, 88]) >>> gm.sort_grades() >>> gm.grades [76, 85, 88, 92] pass def get_highest_grade(self): Get the highest grade from the list. >>> gm = GradeManager([85, 92, 76, 88]) >>> gm.get_highest_grade() 92 >>> gm_empty = GradeManager([]) >>> gm_empty.get_highest_grade() is None True pass def get_lowest_grade(self): Get the lowest grade from the list. >>> gm = GradeManager([85, 92, 76, 88]) >>> gm.get_lowest_grade() 76 >>> gm_empty = GradeManager([]) >>> gm_empty.get_lowest_grade() is None True pass def calculate_average(self): Calculate the average grade. >>> gm = GradeManager([85, 92, 76, 88]) >>> gm.calculate_average() 85.25 >>> gm_empty = GradeManager([]) >>> gm_empty.calculate_average() 0 pass def count_above_threshold(self, threshold): Count how many grades are above a user-specified threshold. >>> gm = GradeManager([85, 92, 76, 88]) >>> gm.count_above_threshold(80) 3 >>> gm.count_above_threshold(90) 1 >>> gm.count_above_threshold(95) 0 pass","solution":"class GradeManager: def __init__(self, grades): self.grades = grades def add_grade(self, grade): self.grades.append(grade) def remove_grade(self, grade): if grade in self.grades: self.grades.remove(grade) else: raise ValueError(f\\"Grade {grade} not found in the list.\\") def sort_grades(self): self.grades.sort() def get_highest_grade(self): return max(self.grades) if self.grades else None def get_lowest_grade(self): return min(self.grades) if self.grades else None def calculate_average(self): return sum(self.grades) / len(self.grades) if self.grades else 0 def count_above_threshold(self, threshold): return len([grade for grade in self.grades if grade > threshold])"},{"question":"def basic_calculator(operand1, operand2, operator): Simulates a basic calculator capable of performing addition, subtraction, multiplication, and division. Parameters: operand1 (float): The first numerical operand. operand2 (float): The second numerical operand. operator (str): The operator indicating the operation to perform. This can be '+', '-', '*', or '/'. Returns: float: The result of the operation. Raises: ValueError: If the inputs are invalid. # Check if the operands are numerical try: num1 = float(operand1) num2 = float(operand2) except ValueError: raise ValueError(\\"Operands must be numeric.\\") # Check if the operator is one of the valid operators if operator not in ['+', '-', '*', '/']: raise ValueError(\\"Invalid operator. Must be one of '+', '-', '*', or '/'.\\") # Perform the operation if operator == '+': return num1 + num2 elif operator == '-': return num1 - num2 elif operator == '*': return num1 * num2 elif operator == '/': if num2 == 0: raise ValueError(\\"Cannot divide by zero.\\") return num1 / num2 # Unit tests def test_basic_calculator_addition(): assert basic_calculator(2, 3, '+') == 5 assert basic_calculator(0, 0, '+') == 0 assert basic_calculator(-2, 2, '+') == 0 def test_basic_calculator_subtraction(): assert basic_calculator(5, 3, '-') == 2 assert basic_calculator(0, 0, '-') == 0 assert basic_calculator(-2, -2, '-') == 0 def test_basic_calculator_multiplication(): assert basic_calculator(2, 3, '*') == 6 assert basic_calculator(0, 5, '*') == 0 assert basic_calculator(-2, 3, '*') == -6 def test_basic_calculator_division(): assert basic_calculator(6, 3, '/') == 2 assert basic_calculator(-6, 3, '/') == -2 assert basic_calculator(5, 2, '/') == 2.5 def test_basic_calculator_invalid_operand(): try: basic_calculator('a', 3, '+') except ValueError as e: assert str(e) == \\"Operands must be numeric.\\" try: basic_calculator(3, 'b', '+') except ValueError as e: assert str(e) == \\"Operands must be numeric.\\" def test_basic_calculator_invalid_operator(): try: basic_calculator(3, 3, '^') except ValueError as e: assert str(e) == \\"Invalid operator. Must be one of '+', '-', '*', or '/'.\\" def test_basic_calculator_division_by_zero(): try: basic_calculator(3, 0, '/') except ValueError as e: assert str(e) == \\"Cannot divide by zero.\\"","solution":"def basic_calculator(operand1, operand2, operator): Simulates a basic calculator capable of performing addition, subtraction, multiplication, and division. Parameters: operand1 (float): The first numerical operand. operand2 (float): The second numerical operand. operator (str): The operator indicating the operation to perform. This can be '+', '-', '*', or '/'. Returns: float: The result of the operation. Raises: ValueError: If the inputs are invalid. # Check if the operands are numerical try: num1 = float(operand1) num2 = float(operand2) except ValueError: raise ValueError(\\"Operands must be numeric.\\") # Check if the operator is one of the valid operators if operator not in ['+', '-', '*', '/']: raise ValueError(\\"Invalid operator. Must be one of '+', '-', '*', or '/'.\\") # Perform the operation if operator == '+': return num1 + num2 elif operator == '-': return num1 - num2 elif operator == '*': return num1 * num2 elif operator == '/': if num2 == 0: raise ValueError(\\"Cannot divide by zero.\\") return num1 / num2"},{"question":"import pandas as pd import numpy as np from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler, OneHotEncoder from sklearn.compose import ColumnTransformer from sklearn.pipeline import Pipeline from sklearn.impute import SimpleImputer from sklearn.linear_model import LinearRegression def predict_marathon_times(dataset_path): Given a dataset containing various details of individuals participating in a marathon, predict their finishing times based on their personal information and training data. The dataset is provided in a CSV file specified by dataset_path. The function should implement proper feature engineering techniques to handle categorical data, missing values, and irrelevant features. Use a regression algorithm in scikit-learn. def test_predict_marathon_times(): dummy_dataset = create_dummy_dataset() dummy_dataset.to_csv('dummy_marathon_dataset.csv', index=False) model = predict_marathon_times('dummy_marathon_dataset.csv') assert model is not None assert hasattr(model, 'predict') assert hasattr(model, 'fit') def test_model_performance(): from sklearn.metrics import mean_squared_error, mean_absolute_error dummy_dataset = create_dummy_dataset() df = dummy_dataset.drop(columns=['Name', 'Bib', 'City']) X = df.drop(columns=['Finishing_Time']) y = df['Finishing_Time'] X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) model = predict_marathon_times('dummy_marathon_dataset.csv') y_pred = model.predict(X_test) mse = mean_squared_error(y_test, y_pred) mae = mean_absolute_error(y_test, y_pred) # Check that the prediction errors are within a reasonable range assert mse < 500 # Set a reasonable threshold for MSE based on the dataset assert mae < 20 # Set a reasonable threshold for MAE based on the dataset def create_dummy_dataset(): import pandas as pd data = { 'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eva'], 'Bib': [101, 102, 103, 104, 105], 'Age': [25, 35, 45, 28, 32], 'Gender': ['F', 'M', 'M', 'M', 'F'], 'Height_cm': [165, 175, 180, 185, 160], 'Weight_kg': [55, 75, 80, 90, 50], 'Training_Hours_Per_Week': [10, 8, 7, 9, 12], 'City': ['New York', 'Boston', 'Los Angeles', 'Chicago', 'Miami'], 'Finishing_Time': [250, 300, 340, 290, 260] # in minutes } return pd.DataFrame(data)","solution":"import pandas as pd import numpy as np from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler, OneHotEncoder from sklearn.compose import ColumnTransformer from sklearn.pipeline import Pipeline from sklearn.impute import SimpleImputer from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_squared_error from sklearn.metrics import mean_absolute_error def predict_marathon_times(dataset_path): # Load dataset df = pd.read_csv(dataset_path) # Drop irrelevant features drop_columns = ['Name', 'Bib', 'City'] df = df.drop(columns=drop_columns) # Separate features and target X = df.drop(columns=['Finishing_Time']) y = df['Finishing_Time'] # Identify categorical and numerical columns categorical_cols = X.select_dtypes(include=['object']).columns numerical_cols = X.select_dtypes(include=['number']).columns # Preprocessing for numerical data numerical_transformer = Pipeline(steps=[ ('imputer', SimpleImputer(strategy='median')), ('scaler', StandardScaler()) ]) # Preprocessing for categorical data categorical_transformer = Pipeline(steps=[ ('imputer', SimpleImputer(strategy='most_frequent')), ('onehot', OneHotEncoder(handle_unknown='ignore')) ]) # Combine preprocessing steps preprocessor = ColumnTransformer( transformers=[ ('num', numerical_transformer, numerical_cols), ('cat', categorical_transformer, categorical_cols) ]) # Create pipeline model = Pipeline(steps=[('preprocessor', preprocessor), ('regressor', LinearRegression())]) # Split data into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Train the model model.fit(X_train, y_train) # Make predictions y_pred = model.predict(X_test) # Evaluate the model mse = mean_squared_error(y_test, y_pred) mae = mean_absolute_error(y_test, y_pred) print(\\"Mean Squared Error:\\", mse) print(\\"Mean Absolute Error:\\", mae) return model"},{"question":"from typing import Tuple, Dict from sklearn.datasets import load_iris from sklearn.model_selection import GridSearchCV, train_test_split from sklearn.neighbors import KNeighborsClassifier from sklearn.metrics import classification_report def iris_knn_classifier() -> Tuple[Dict[str, Any], str]: Using the Iris dataset from scikit-learn, implement a K-Nearest Neighbors (KNN) classifier. Perform a grid search with cross-validation to find the optimal number of neighbors and distance metrics. After training the model, analyze the classification report to discuss the performance of the model for each class and the impact of different hyperparameters. Returns: best_params (dict): The best hyperparameters found by grid search. report (str): Classification report for the best model. >>> best_params, report = iris_knn_classifier() >>> 'n_neighbors' in best_params True >>> 'metric' in best_params True >>> best_params['n_neighbors'] in [3, 5, 7, 9] True >>> best_params['metric'] in ['euclidean', 'manhattan', 'chebyshev', 'minkowski'] True >>> 'setosa' in report True >>> 'versicolor' in report True >>> 'virginica' in report True >>> 'precision' in report True >>> 'recall' in report True >>> 'f1-score' in report True","solution":"from sklearn.datasets import load_iris from sklearn.model_selection import GridSearchCV, train_test_split from sklearn.neighbors import KNeighborsClassifier from sklearn.metrics import classification_report def iris_knn_classifier(): # Load the Iris dataset iris = load_iris() X, y = iris.data, iris.target # Split the dataset into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42) # Define a KNN classifier knn = KNeighborsClassifier() # Set up the parameter grid for GridSearchCV param_grid = { 'n_neighbors': [3, 5, 7, 9], 'metric': ['euclidean', 'manhattan', 'chebyshev', 'minkowski'] } # Perform grid search with cross-validation grid_search = GridSearchCV(knn, param_grid, cv=5, n_jobs=-1) grid_search.fit(X_train, y_train) # Predict on the test set y_pred = grid_search.predict(X_test) # Get the best parameters best_params = grid_search.best_params_ # Generate the classification report report = classification_report(y_test, y_pred, target_names=iris.target_names) return best_params, report # Call the function to get the results best_params, report = iris_knn_classifier() print(\\"Best Parameters:\\", best_params) print(\\"Classification Report:n\\", report)"},{"question":"from typing import List def trap_rain_water(elevations: List[int]) -> int: Calculate the total water that can be trapped after a rainfall. >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rain_water([1, 1, 1, 1]) 0 >>> trap_rain_water([]) 0","solution":"from typing import List def trap_rain_water(elevations: List[int]) -> int: n = len(elevations) if n == 0: return 0 left_max = [0] * n right_max = [0] * n left_max[0] = elevations[0] for i in range(1, n): left_max[i] = max(left_max[i-1], elevations[i]) right_max[n-1] = elevations[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], elevations[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - elevations[i] return trapped_water"},{"question":"from typing import List def square_elements(lst: List[int]) -> List[int]: Returns a list with each element squared. Parameters: lst (list): A list of integers. Returns: list: A new list with each element squared. >>> square_elements([1, 2, 3, 4]) [1, 4, 9, 16] >>> square_elements([0, 1, 2, 3]) [0, 1, 4, 9] >>> square_elements([-1, -2, -3, -4]) [1, 4, 9, 16] >>> square_elements([-1, 2, -3, 4]) [1, 4, 9, 16] >>> square_elements([]) []","solution":"def square_elements(lst): Returns a list with each element squared. Parameters: lst (list): A list of integers. Returns: list: A new list with each element squared. return [x ** 2 for x in lst]"},{"question":"def find_anagram_pairs(words, candidates): Provided a list of words and a list of candidate anagrams, this function identifies and returns all the pairs of words that are anagrams of each other in the form of tuples. Parameters: words (list of str): List of words. candidates (list of str): List of candidate anagrams. Returns: list of tuples: A list of tuples with each tuple containing a pair of words that are anagrams. Example: >>> find_anagram_pairs(['listen', 'binary', 'tea'], ['silent', 'brainy', 'eat']) [('listen', 'silent'), ('binary', 'brainy'), ('tea', 'eat')]","solution":"def find_anagram_pairs(words, candidates): Provided a list of words and a list of candidate anagrams, this function identifies and returns all the pairs of words that are anagrams of each other in the form of tuples. Parameters: words (list of str): List of words. candidates (list of str): List of candidate anagrams. Returns: list of tuples: A list of tuples with each tuple containing a pair of words that are anagrams. def sorted_word(word): return ''.join(sorted(word)) anagram_pairs = [] sorted_candidates = {sorted_word(candidate): candidate for candidate in candidates} for word in words: sorted_word_version = sorted_word(word) if sorted_word_version in sorted_candidates: anagram_pairs.append((word, sorted_candidates[sorted_word_version])) return anagram_pairs"},{"question":"from typing import List def min_difference_in_subarrays(nums: List[int], k: int) -> int: Given an array of integers nums, return the minimum difference between the maximum and minimum values in any subarray of length k. Parameters: nums (List[int]): The list of integers. k (int): The length of the subarray. Returns: int: The minimum difference between the maximum and minimum values in any subarray of length k. >>> min_difference_in_subarrays([9, 4, 1, 7], 2) 2 >>> min_difference_in_subarrays([3, 9, 4, 1, 7], 1) 0 >>> min_difference_in_subarrays([5, 5, 5, 5, 5], 3) 0 >>> min_difference_in_subarrays([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) 4 >>> min_difference_in_subarrays([10, 100, 300, 200, 1000, 20, 30], 3) 20 >>> min_difference_in_subarrays([10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], 3) 2","solution":"def min_difference_in_subarrays(nums, k): Returns the minimum difference between the maximum and minimum values in any subarray of length k. if k == 1: return 0 nums.sort() min_difference = float('inf') for i in range(len(nums) - k + 1): min_difference = min(min_difference, nums[i + k - 1] - nums[i]) return min_difference"},{"question":"from typing import List def optimal_meeting_point(points: List[int]) -> int: Computes the optimal meeting point for a given list of n points on a linear path. The optimal meeting point is the point that minimizes the sum of distances all people need to travel to reach it. Args: points (List[int]): A list of integers where each integer represents the position of a person on a number line. Returns: int: The optimal meeting point on the number line. >>> optimal_meeting_point([1, 2, 6, 8]) 6 >>> optimal_meeting_point([1, 2, 3, 4]) 2 pass def test_single_point(): assert optimal_meeting_point([3]) == 3 assert optimal_meeting_point([0]) == 0 def test_even_number_of_points(): assert optimal_meeting_point([1, 2, 3, 4]) == 2 assert optimal_meeting_point([2, 3, 4, 5]) == 3 def test_odd_number_of_points(): assert optimal_meeting_point([1, 2, 3]) == 2 assert optimal_meeting_point([2, 3, 5, 8, 10]) == 5 def test_negative_and_positive_points(): assert optimal_meeting_point([-10, -5, 0, 5, 10]) == 0 assert optimal_meeting_point([-7, -3, 1, 5, 8]) == 1 def test_all_negative_points(): assert optimal_meeting_point([-10, -8, -5, -3, -2]) == -5 assert optimal_meeting_point([-12, -9, -7, -6, -4, -2]) == -7 def test_all_positive_points(): assert optimal_meeting_point([1, 3, 6, 9, 14]) == 6 assert optimal_meeting_point([2, 4, 6, 8, 10, 12]) == 6","solution":"from typing import List def optimal_meeting_point(points: List[int]) -> int: Computes the optimal meeting point for a given list of n points on a linear path. The optimal meeting point is the point that minimizes the sum of distances all people need to travel to reach it. Args: points (List[int]): A list of integers where each integer represents the position of a person on a number line. Returns: int: The optimal meeting point on the number line. n = len(points) # The optimal meeting point is the median of the list if n % 2 == 1: return points[n // 2] else: return points[n // 2 - 1]"},{"question":"from typing import List def findLength(nums1: List[int], nums2: List[int]) -> int: Determine and return the length of the longest common subarray between nums1 and nums2. >>> findLength([1, 2, 3, 2, 1], [3, 2, 1, 4, 7]) 3 >>> findLength([0, 0, 0, 0, 0], [0, 0, 0, 0, 0]) 5 >>> findLength([1, 2, 3], [4, 5, 6]) 0 >>> findLength([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) 1 >>> findLength([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) 5 >>> findLength([1, 2, 3, 2, 1], [2, 3, 2, 1]) 4","solution":"def findLength(nums1, nums2): Returns the length of the longest common subarray of nums1 and nums2. m, n = len(nums1), len(nums2) dp = [[0] * (n + 1) for _ in range(m + 1)] max_length = 0 for i in range(m - 1, -1, -1): for j in range(n - 1, -1, -1): if nums1[i] == nums2[j]: dp[i][j] = dp[i + 1][j + 1] + 1 max_length = max(max_length, dp[i][j]) return max_length"},{"question":"from typing import List, Optional def calculate_median(numbers: List[int]) -> Optional[float]: Computes the median of a list of numbers. Returns None if the list is empty. >>> calculate_median([1, 3, 4, 2, 5]) 3 >>> calculate_median([1, 3, 4, 2]) 2.5 >>> calculate_median([]) None","solution":"def calculate_median(numbers): Returns the median of a list of numbers. If the list is empty, it returns None. if not numbers: return None numbers.sort() n = len(numbers) mid = n // 2 if n % 2 == 1: return numbers[mid] else: return (numbers[mid - 1] + numbers[mid]) / 2"},{"question":"from datetime import datetime # Employee data employees = [{'id': 1, 'name': 'John Doe'}, {'id': 2, 'name': 'Alice Smith'}] # Attendance records attendance_records = [ {'employee_id': 1, 'date': '2023-10-11', 'time': '09:00'}, {'employee_id': 2, 'date': '2023-10-11', 'time': '09:05'}, ] def mark_attendance(employee_id): Record the current date and time for the given employee ID in attendance records. >>> mark_attendance(employee_id=1) pass def view_attendance_history(employee_id): Display the attendance history of a specific employee in descending order of date. >>> view_attendance_history(employee_id=1) [{'employee_id': 1, 'date': '2023-10-11', 'time': '09:00'}] pass def edit_attendance_record(employee_id, date, time, admin=True): Update the time of a previously recorded attendance entry for the given employee ID. >>> edit_attendance_record(employee_id=1, date='2023-10-11', time='09:30') \\"Record Updated\\" >>> edit_attendance_record(employee_id=1, date='2023-10-11', time='09:30', admin=False) \\"Access Denied\\" pass def filter_attendance_by_date(start_date, end_date): Return attendance records within the given date range. >>> filter_attendance_by_date('2023-10-10', '2023-10-11') [{'employee_id': 1, 'date': '2023-10-11', 'time': '09:00'}, {'employee_id': 2, 'date': '2023-10-11', 'time': '09:05'}] pass","solution":"from datetime import datetime # Employee data employees = [{'id': 1, 'name': 'John Doe'}, {'id': 2, 'name': 'Alice Smith'}] # Attendance records attendance_records = [ {'employee_id': 1, 'date': '2023-10-11', 'time': '09:00'}, {'employee_id': 2, 'date': '2023-10-11', 'time': '09:05'}, ] def mark_attendance(employee_id): now = datetime.now() date_str = now.strftime('%Y-%m-%d') time_str = now.strftime('%H:%M') attendance_records.append({'employee_id': employee_id, 'date': date_str, 'time': time_str}) def view_attendance_history(employee_id): records = [record for record in attendance_records if record['employee_id'] == employee_id] records.sort(key=lambda x: x['date'], reverse=True) return records def edit_attendance_record(employee_id, date, time, admin=True): if not admin: return \\"Access Denied\\" for record in attendance_records: if record['employee_id'] == employee_id and record['date'] == date: record['time'] = time return \\"Record Updated\\" return \\"Record Not Found\\" def filter_attendance_by_date(start_date, end_date): start_date_dt = datetime.strptime(start_date, '%Y-%m-%d') end_date_dt = datetime.strptime(end_date, '%Y-%m-%d') filtered_records = [ record for record in attendance_records if start_date_dt <= datetime.strptime(record['date'], '%Y-%m-%d') <= end_date_dt ] return filtered_records"},{"question":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number. >>> fibonacci(0) == 0 >>> fibonacci(1) == 1 >>> fibonacci(2) == 1 >>> fibonacci(3) == 2 >>> fibonacci(4) == 3 >>> fibonacci(5) == 5 >>> fibonacci(6) == 8 >>> fibonacci(10) == 55 >>> fibonacci(20) == 6765 >>> fibonacci(30) == 832040 >>> fibonacci(50) == 12586269025 >>> fibonacci(100) == 354224848179261915075","solution":"def fibonacci(n): Returns the nth Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def rotate(matrix): Rotates a given n x n 2D matrix 90 degrees clockwise in place. Parameters: matrix (list of list of int): The 2D matrix to rotate. Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ] >>> rotate(matrix) >>> matrix [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ]","solution":"def rotate(matrix): Rotates a given n x n 2D matrix 90 degrees clockwise in place. Parameters: matrix (list of list of int): The 2D matrix to rotate. n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def first_non_repeating_character(s: str) -> str: Write a function that takes a string as input and returns the first non-repeating character in the string. If all characters repeat or the string is empty, return an appropriate message indicating so. >>> first_non_repeating_character(\\"a\\") == \\"a\\" >>> first_non_repeating_character(\\"abc\\") == \\"a\\" >>> first_non_repeating_character(\\"aabcc\\") == \\"b\\" >>> first_non_repeating_character(\\"aabbcc\\") == \\"All characters repeat\\" >>> first_non_repeating_character(\\"\\") == \\"The string is empty\\" >>> first_non_repeating_character(\\"abacabad\\") == \\"c\\" >>> first_non_repeating_character(\\"abacabaabacabd\\") == \\"d\\"","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If all characters repeat or the string is empty, returns a message indicating so. if not s: return \\"The string is empty\\" char_count = {} # Count the occurrences of each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first non-repeating character for char in s: if char_count[char] == 1: return char return \\"All characters repeat\\""},{"question":"def most_frequent_character(s: str) -> str: Returns the character that appears the most frequently in the string \`s\`. In the case of a tie, returns the first character that reached the highest frequency. >>> most_frequent_character(\\"a\\") 'a' >>> most_frequent_character(\\"banana\\") 'a' >>> most_frequent_character(\\"aardvark\\") 'a' >>> most_frequent_character(\\"zzzzzz\\") 'z' >>> most_frequent_character(\\"\\") is None >>> most_frequent_character(\\"aAaaA\\") 'a' >>> most_frequent_character(\\"aA\\") 'a' >>> most_frequent_character(\\"!@!!@\\") '!'","solution":"def most_frequent_character(s): Returns the character that appears the most frequently in the string \`s\`. In the case of a tie, returns the first character that reached the highest frequency. if not s: return None char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 max_freq = max(char_count.values()) for char in s: if char_count[char] == max_freq: return char"},{"question":"def streaming_median(stream: List[int]) -> List[float]: Calculate the running median of a stream of integers. Args: stream (List[int]): A list of integers representing the stream. Returns: List[float]: A list of running medians after each number in the stream is processed. Example: >>> streaming_median([2, 1, 5, 7, 2, 0, 5]) [2, 1.5, 2, 3.5, 2, 2, 2] >>> streaming_median([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5] >>> streaming_median([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) [10, 9.5, 9, 8.5, 8, 7.5, 7, 6.5, 6, 5.5] >>> streaming_median([1, 3, 5, 7, 9]) [1, 2, 3, 4, 5] >>> streaming_median([5, 4, 3, 2, 1]) [5, 4.5, 4, 3.5, 3] >>> streaming_median([5]) [5] >>> streaming_median([2, 2, 2, 2, 2]) [2, 2, 2, 2, 2] >>> streaming_median([]) []","solution":"import heapq def streaming_median(stream): Calculates the running median of a stream of integers. :param stream: List[int] - a list of integers representing the stream :return: List[float] - a list of running medians after each number in the stream is processed min_heap = [] # the right half max_heap = [] # the left half (inverted, i.e., as a max-heap using negatives) medians = [] for number in stream: if not max_heap or number < -max_heap[0]: heapq.heappush(max_heap, -number) else: heapq.heappush(min_heap, number) # Balance the heaps such that the size difference is not more than one if len(max_heap) > len(min_heap) + 1: heapq.heappush(min_heap, -heapq.heappop(max_heap)) elif len(min_heap) > len(max_heap): heapq.heappush(max_heap, -heapq.heappop(min_heap)) # Calculate the median if len(max_heap) == len(min_heap): median = (-max_heap[0] + min_heap[0]) / 2.0 else: median = -max_heap[0] medians.append(median) return medians"},{"question":"from typing import List, Tuple def find_peak(matrix: List[List[int]]) -> Tuple[int, int]: Given an nxm matrix filled with integers, find a peak element in the matrix. An element is considered a peak if it is not smaller than its adjacent elements. For corner elements, consider only one adjacent element. Returns the row and column indices of one peak element in the matrix. >>> matrix = [ ... [10, 20, 15], ... [21, 30, 14], ... [7, 16, 32] ... ] >>> find_peak(matrix) (1, 1) def test_find_peak_example_case(): matrix = [ [10, 20, 15], [21, 30, 14], [7, 16, 32] ] assert find_peak(matrix) == (1, 1) def test_find_peak_all_identical(): matrix = [ [10, 10, 10], [10, 10, 10], [10, 10, 10] ] assert find_peak(matrix) == (0, 0) def test_find_peak_single_element(): matrix = [ [42] ] assert find_peak(matrix) == (0, 0) def test_find_peak_single_row(): matrix = [ [1, 2, 3, 5, 4] ] assert find_peak(matrix) == (0, 3) def test_find_peak_single_column(): matrix = [ [1], [5], [3], [4] ] assert find_peak(matrix) == (1, 0) def test_find_peak_complex_case(): matrix = [ [10, 8, 10, 10], [14, 13, 12, 11], [15, 9, 11, 21], [16, 17, 19, 20] ] assert find_peak(matrix) == (3, 1) or find_peak(matrix) == (3, 2) or find_peak(matrix) == (2, 3) def test_find_peak_corner_peak(): matrix = [ [10, 20], [5, 6] ] assert find_peak(matrix) == (0, 1)","solution":"from typing import List, Tuple def find_peak(matrix: List[List[int]]) -> Tuple[int, int]: rows = len(matrix) cols = len(matrix[0]) def get_max_in_column(mid: int) -> int: max_row = 0 for row in range(rows): if matrix[row][mid] > matrix[max_row][mid]: max_row = row return max_row def find_peak_recursive(left: int, right: int) -> Tuple[int, int]: if left == right: row = get_max_in_column(left) return row, left mid = (left + right) // 2 max_row = get_max_in_column(mid) if matrix[max_row][mid] < matrix[max_row][mid + 1]: return find_peak_recursive(mid + 1, right) else: return find_peak_recursive(left, mid) return find_peak_recursive(0, cols - 1)"},{"question":"from typing import List def min_coins(amount: int, coins: List[int]) -> int: Given an amount and a list of coin denominations, determine the minimum number of coins needed to make the amount. Return -1 if it is not possible to make the amount with the given coins. >>> min_coins(11, [1, 2, 5]) 3 >>> min_coins(3, [2]) -1 >>> min_coins(0, [1, 2, 5]) 0","solution":"from typing import List def min_coins(amount: int, coins: List[int]) -> int: Given an amount and a list of coin denominations, determine the minimum number of coins needed to make the amount. Return -1 if it is not possible to make the amount with the given coins. # Create a list to store the minimum number of coins for each amount dp = [float('inf')] * (amount + 1) dp[0] = 0 # 0 coins are needed to make the amount 0 # Compute the minimum coins required for all amounts up to the given amount for i in range(1, amount + 1): for coin in coins: if i >= coin: dp[i] = min(dp[i], dp[i - coin] + 1) # If dp[amount] is still float('inf'), it means we cannot make that amount return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def total_working_days_per_week(number_of_missing_weeks: int) -> int: Returns the total number of working days Katie will miss. Parameters: number_of_missing_weeks (int): The number of weeks Katie will be absent. Returns: int: The total number of working days Katie will miss. >>> total_working_days_per_week(3) 15 >>> total_working_days_per_week(1) 5 >>> total_working_days_per_week(0) 0 >>> total_working_days_per_week(5) 25 >>> total_working_days_per_week(10) 50","solution":"def total_working_days_per_week(number_of_missing_weeks): Returns the total number of working days Katie will miss. Parameters: number_of_missing_weeks (int): The number of weeks Katie will be absent. Returns: int: The total number of working days Katie will miss. WORKING_DAYS_PER_WEEK = 5 return WORKING_DAYS_PER_WEEK * number_of_missing_weeks"},{"question":"def find_second_largest(numbers: List[int]) -> int: Write a function that takes a list of integers as input and returns the second largest number in the list. If the list contains less than two unique numbers, return None. The function should handle cases where the input list contains negative numbers and should not rely on built-in sorting methods. >>> find_second_largest([1, 2, 3, 4]) == 3 >>> find_second_largest([4, 1, 2, 3]) == 3 >>> find_second_largest([4, 4, 4, 4]) == None >>> find_second_largest([10]) == None >>> find_second_largest([4, -1, -2, -3]) == -1 # Your code here # Unit Tests def test_second_largest_normal_case(): assert find_second_largest([1, 2, 3, 4]) == 3 assert find_second_largest([4, 1, 2, 3]) == 3 assert find_second_largest([10, 20, 15, 10, 20]) == 15 def test_second_largest_with_negative_numbers(): assert find_second_largest([4, -1, -2, -3]) == -1 assert find_second_largest([-10, -20, -15, -10, -20]) == -15 def test_second_largest_with_duplicates(): assert find_second_largest([4, 4, 4, 4]) == None assert find_second_largest([10, 20, 20, 30, 30, 10]) == 20 def test_second_largest_with_too_few_elements(): assert find_second_largest([10]) == None assert find_second_largest([5, 5]) == None def test_second_largest_mixed_sign_numbers(): assert find_second_largest([-1, 3, -4, 2, -2, -5]) == 2 assert find_second_largest([0, -1, -2, -3]) == -1 def test_second_largest_edge_cases(): assert find_second_largest([]) == None assert find_second_largest([1, 2]) == 1 def test_second_largest_large_numbers(): assert find_second_largest([1000000000, 1000000001]) == 1000000000","solution":"def find_second_largest(numbers): Returns the second largest unique number in the list. If the list contains fewer than two unique numbers, returns None. if len(numbers) < 2: return None first = second = None for num in numbers: if first is None or num > first: second = first first = num elif num != first and (second is None or num > second): second = num return second"},{"question":"def min_deletions_to_make_palindrome(s: str) -> int: Given a string \`s\`, determine the minimum number of deletions required to make \`s\` a palindrome. Example usages: >>> min_deletions_to_make_palindrome(\\"abccba\\") 0 >>> min_deletions_to_make_palindrome(\\"abcdba\\") 1 >>> min_deletions_to_make_palindrome(\\"abcde\\") 4","solution":"def min_deletions_to_make_palindrome(s: str) -> int: Returns the minimum number of deletions required to make s a palindrome. n = len(s) dp = [[0] * n for _ in range(n)] # Build the table for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1] # Example usage: # s = \\"abcdba\\" # print(min_deletions_to_make_palindrome(s)) # Output: 1"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Create a function that takes an array of integers and returns a new array where each element is the product of all the original elements except the one at the same index. Do not use division in your solution. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24]","solution":"def product_except_self(nums): Returns a new array where each element is the product of all the original elements except the one at the same index. length = len(nums) result = [1] * length left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def matrix_diagonal_difference(matrix: List[List[int]]) -> int: Calculate the absolute difference between the sums of the matrix's diagonals. Parameters: matrix (list of list of int): A square matrix (NxN). Returns: int: The absolute difference between the sums of the matrix's diagonals. pass # Test Cases if __name__ == \\"__main__\\": assert matrix_diagonal_difference([ [11, 2, 4], [4, 5, 6], [10, 8, -12] ]) == 15 assert matrix_diagonal_difference([ [1, 2], [3, 4] ]) == 0 assert matrix_diagonal_difference([ [-1, -2], [-3, -4] ]) == 0 assert matrix_diagonal_difference([ [5] ]) == 0 assert matrix_diagonal_difference([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == 0 assert matrix_diagonal_difference([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) == 0","solution":"def matrix_diagonal_difference(matrix): Calculate the absolute difference between the sums of the matrix's diagonals. Parameters: matrix (list of list of int): A square matrix (NxN). Returns: int: The absolute difference between the sums of the matrix's diagonals. n = len(matrix) primary_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(n): primary_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n - 1 - i] return abs(primary_diagonal_sum - secondary_diagonal_sum)"},{"question":"def reverse_string(s: str) -> str: Write a Python function that takes a string as input and returns the string with the order of characters reversed, but without using the explicit reverse function or slicing. >>> reverse_string(\\"a\\") == \\"a\\" >>> reverse_string(\\"hello\\") == \\"olleh\\" >>> reverse_string(\\"\\") == \\"\\" >>> reverse_string(\\"a b c\\") == \\"c b a\\" >>> reverse_string(\\"madam\\") == \\"madam\\" >>> reverse_string(\\"hello, world!\\") == \\"!dlrow ,olleh\\"","solution":"def reverse_string(s: str) -> str: Returns the string with the order of characters reversed. reversed_str = '' for char in s: reversed_str = char + reversed_str return reversed_str"},{"question":"def find_max_sum_key(d): Returns the key with the maximum sum of its list elements and the sum as a tuple. Arguments: d : dict A dictionary where keys are strings and values are lists of integers. Returns: tuple A tuple containing the key with the maximum sum and the sum. Example: >>> example_dict = {\\"a\\": [1, 2, 3], \\"b\\": [4, 5], \\"c\\": [6, 7, 8, 9]} >>> find_max_sum_key(example_dict) (\\"c\\", 30) # Your code here pass","solution":"def find_max_sum_key(d): Returns the key with the maximum sum of its list elements and the sum as a tuple. Arguments: d : dict A dictionary where keys are strings and values are lists of integers. Returns: tuple A tuple containing the key with the maximum sum and the sum. max_key = None max_sum = -float('inf') for key, value in d.items(): current_sum = sum(value) if current_sum > max_sum: max_sum = current_sum max_key = key return (max_key, max_sum)"},{"question":"class VendingMachine: A class to represent a vending machine. Attributes: inventory (dict): A dictionary with item names as keys and quantities as values. prices (dict): A dictionary with item names as keys and their prices as values. balance (float): The current balance of inserted money. def __init__(self, inventory, prices): Initializes the vending machine with a given inventory and prices. Parameters: inventory (dict): A dictionary where keys are item names and values are the quantity of each item. prices (dict): A dictionary where keys are item names and values are the price of each item. def add_money(self, amount): Adds money to the vending machine balance. Parameters: amount (float): The amount of money to add. def select_item(self, item): Allows the user to select an item. Parameters: item (str): The name of the item to select. Returns: str: A message indicating the result of the selection. def get_inventory(self): Displays the remaining inventory in the vending machine. Returns: dict: The current inventory. def get_balance(self): Displays the current balance of the vending machine. Returns: float: The current balance. # Unit Tests import pytest def test_add_money(): vm = VendingMachine({'Soda': 5}, {'Soda': 1.50}) vm.add_money(5) assert vm.get_balance() == 5 def test_select_item_success(): vm = VendingMachine({'Soda': 5}, {'Soda': 1.50}) vm.add_money(2) result = vm.select_item('Soda') assert result == \\"Dispensed Soda. Change returned: 0.50\\" assert vm.get_inventory() == {'Soda': 4} assert vm.get_balance() == 0 def test_select_item_not_enough_money(): vm = VendingMachine({'Soda': 5}, {'Soda': 1.50}) vm.add_money(1) result = vm.select_item('Soda') assert result == \\"Not enough money inserted.\\" assert vm.get_inventory() == {'Soda': 5} assert vm.get_balance() == 1 def test_select_item_out_of_stock(): vm = VendingMachine({'Soda': 0}, {'Soda': 1.50}) vm.add_money(2) result = vm.select_item('Soda') assert result == \\"Item is out of stock.\\" assert vm.get_inventory() == {'Soda': 0} assert vm.get_balance() == 2 def test_select_item_not_found(): vm = VendingMachine({'Soda': 5}, {'Soda': 1.50}) vm.add_money(2) result = vm.select_item('Chips') assert result == \\"Item not found.\\" assert vm.get_inventory() == {'Soda': 5} assert vm.get_balance() == 2 def test_get_inventory(): vm = VendingMachine({'Soda': 5, 'Chips': 3}, {'Soda': 1.50, 'Chips': 1.00}) assert vm.get_inventory() == {'Soda': 5, 'Chips': 3} def test_get_balance(): vm = VendingMachine({'Soda': 5}, {'Soda': 1.50}) assert vm.get_balance() == 0 vm.add_money(3) assert vm.get_balance() == 3","solution":"class VendingMachine: def __init__(self, inventory, prices): Initializes the vending machine with a given inventory and prices. Parameters: inventory (dict): A dictionary where keys are item names and values are the quantity of each item. prices (dict): A dictionary where keys are item names and values are the price of each item. self.inventory = inventory self.prices = prices self.balance = 0 def add_money(self, amount): Adds money to the vending machine balance. Parameters: amount (float): The amount of money to add. self.balance += amount def select_item(self, item): Allows the user to select an item. Parameters: item (str): The name of the item to select. Returns: str: A message indicating the result of the selection. if item not in self.inventory: return \\"Item not found.\\" if self.inventory[item] == 0: return \\"Item is out of stock.\\" if self.balance < self.prices[item]: return \\"Not enough money inserted.\\" self.inventory[item] -= 1 self.balance -= self.prices[item] change = self.balance self.balance = 0 return f\\"Dispensed {item}. Change returned: {change:.2f}\\" def get_inventory(self): Displays the remaining inventory in the vending machine. Returns: dict: The current inventory. return self.inventory def get_balance(self): Displays the current balance of the vending machine. Returns: float: The current balance. return self.balance"},{"question":"from typing import List def find_max_length(arr: List[int]) -> int: Write a function that takes an integer array as input and returns the length of the longest contiguous subarray with an equal number of 0s and 1s. If the array does not contain any such subarray, the function should return -1. >>> find_max_length([0, 1, 0, 1]) 4 >>> find_max_length([0, 0, 1, 0, 1, 1]) 6 >>> find_max_length([0, 0, 0]) -1 >>> find_max_length([]) -1","solution":"def find_max_length(arr): if not arr: return -1 # Transform the array, considering 0 as -1 transformed = [-1 if x == 0 else 1 for x in arr] # This will store the first occurrence of each prefix sum prefix_sum_map = {} prefix_sum = 0 max_length = 0 for i in range(len(transformed)): prefix_sum += transformed[i] if prefix_sum == 0: max_length = i + 1 elif prefix_sum in prefix_sum_map: max_length = max(max_length, i - prefix_sum_map[prefix_sum]) else: prefix_sum_map[prefix_sum] = i return max_length if max_length != 0 else -1"},{"question":"from typing import List, Tuple def read_file_and_get_common_words(file_path: str) -> List[Tuple[str, int]]: Reads a file and returns the ten most common words in the file with their respective counts. Punctuation is removed and word frequency is case insensitive. Parameters: file_path (str): The path of the file to read Returns: List[Tuple[str, int]]: A list of tuples where each tuple contains a word and its frequency >>> read_file_and_get_common_words('example.txt') [('hello', 3), ('how', 2), ('you', 2), ('i', 2), ('am', 2), ('are', 1), ('fine', 1), ('about', 1), ('good', 1), ('too', 1)]","solution":"import re from collections import Counter def read_file_and_get_common_words(file_path): with open(file_path, 'r') as file: text = file.read().lower() # Remove punctuation text = re.sub(r'[^ws]', '', text) words = text.split() word_counts = Counter(words) # Get the ten most common words common_words = word_counts.most_common(10) return common_words"},{"question":"def validate_isbn(isbn): Validate if the given ISBN-10 string is valid or not, considering potential whitespaces, hyphens, and invalid characters. Returns True if valid, otherwise False. Arguments: isbn -- the ISBN-10 string to validate Example: >>> validate_isbn(\\"0-306-40615-2\\") True >>> validate_isbn(\\"0306406152\\") True >>> validate_isbn(\\"0 3 0 6 4 0-6 1 5 2\\") True >>> validate_isbn(\\"123456789X\\") True >>> validate_isbn(\\"12345 67892X\\") False >>> validate_isbn(\\"12345678\\") False >>> validate_isbn(\\"abcdefghij\\") False","solution":"def validate_isbn(isbn): Validate if the given ISBN-10 string is valid or not, considering potential whitespaces, hyphens, and invalid characters. Returns True if valid, otherwise False. Arguments: isbn -- the ISBN-10 string to validate Example: >>> validate_isbn(\\"0-306-40615-2\\") True >>> validate_isbn(\\"0306406152\\") True >>> validate_isbn(\\"0 3 0 6 4 0-6 1 5 2\\") True >>> validate_isbn(\\"123456789X\\") True >>> validate_isbn(\\"12345 67892X\\") False >>> validate_isbn(\\"12345678\\") False >>> validate_isbn(\\"abcdefghij\\") False # Remove hyphens and whitespaces cleaned_isbn = isbn.replace(\\"-\\", \\"\\").replace(\\" \\", \\"\\") # Check if cleaned ISBN length is 10 if len(cleaned_isbn) != 10: return False # Check for invalid characters if not cleaned_isbn[:-1].isdigit() or (cleaned_isbn[-1] not in '0123456789X'): return False # Calculate checksum checksum = 0 for i in range(10): if cleaned_isbn[i] == 'X': digit = 10 else: digit = int(cleaned_isbn[i]) checksum += digit * (i + 1) return checksum % 11 == 0"},{"question":"from typing import List def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float: Given two sorted arrays arr1 and arr2 of size m and n respectively, return the median of the two sorted arrays. The overall run-time complexity should be O(log(min(m,n))). >>> findMedianSortedArrays([1, 3], [2]) 2.0 >>> findMedianSortedArrays([1, 2], [3, 4]) 2.5 >>> findMedianSortedArrays([0, 0], [0, 0]) 0.0 >>> findMedianSortedArrays([], [1]) 1.0 >>> findMedianSortedArrays([2], []) 2.0","solution":"def findMedianSortedArrays(nums1, nums2): Return the median of the two sorted arrays. The overall run-time complexity should be O(log(min(m,n))). if len(nums1) > len(nums2): nums1, nums2 = nums2, nums1 x, y = len(nums1), len(nums2) low, high = 0, x while low <= high: partition_x = (low + high) // 2 partition_y = (x + y + 1) // 2 - partition_x max_left_x = float('-inf') if partition_x == 0 else nums1[partition_x - 1] min_right_x = float('inf') if partition_x == x else nums1[partition_x] max_left_y = float('-inf') if partition_y == 0 else nums2[partition_y - 1] min_right_y = float('inf') if partition_y == y else nums2[partition_y] if max_left_x <= min_right_y and max_left_y <= min_right_x: if (x + y) % 2 == 0: return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2 else: return max(max_left_x, max_left_y) elif max_left_x > min_right_y: high = partition_x - 1 else: low = partition_x + 1"},{"question":"def roman_to_integer(numeral: str) -> int: Convert a Roman numeral to its corresponding integer value. :param numeral: str, a Roman numeral string :return: int, the integer value of the Roman numeral >>> roman_to_integer(\\"III\\") == 3 >>> roman_to_integer(\\"IX\\") == 9 >>> roman_to_integer(\\"LVIII\\") == 58 >>> roman_to_integer(\\"MCMXCIV\\") == 1994","solution":"def roman_to_integer(numeral): Convert a Roman numeral to its corresponding integer value. :param numeral: str, a Roman numeral string :return: int, the integer value of the Roman numeral roman_values = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in numeral[::-1]: # Iterate from the end of the numeral string value = roman_values[char] if value >= prev_value: total += value else: total -= value prev_value = value return total"},{"question":"def vowel_count(s: str) -> str: Returns the number of vowels in the given string s. >>> vowel_count(\\"\\") == \\"Number of vowels: 0\\" >>> vowel_count(\\"bcdfg\\") == \\"Number of vowels: 0\\" >>> vowel_count(\\"aeiouAEIOU\\") == \\"Number of vowels: 10\\" >>> vowel_count(\\"hello world!\\") == \\"Number of vowels: 3\\" >>> vowel_count(\\"AEIOU\\") == \\"Number of vowels: 5\\" >>> vowel_count(\\"aeiou\\") == \\"Number of vowels: 5\\" vowels = \\"aeiouAEIOU\\" sum_vowels = 0 for char in s: if char in vowels: sum_vowels += 1 return \\"Number of vowels: \\" + str(sum_vowels)","solution":"def vowel_count(s): Returns the number of vowels in the given string s. vowels = \\"aeiouAEIOU\\" sum_vowels = 0 for char in s: if char in vowels: sum_vowels += 1 return \\"Number of vowels: \\" + str(sum_vowels)"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers in the list \`nums\` that add up to the target. Assumes there is exactly one solution. Args: nums: List of integers. target: Integer representing the target sum. Returns: A list containing two integers, the indices of the two numbers that add up to the target.","solution":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers in the list \`nums\` that add up to the target. Assumes there is exactly one solution. Args: nums: List of integers. target: Integer representing the target sum. Returns: A list containing two integers, the indices of the two numbers that add up to the target. # Dictionary to store the number and its index num_to_index = {} for index, num in enumerate(nums): # Calculate the necessary number to reach the target complement = target - num # Check if the complement exists in the dictionary if complement in num_to_index: return [num_to_index[complement], index] # If the complement doesn't exist, add the number and its index to the dictionary num_to_index[num] = index"},{"question":"def letter_frequency(s: str) -> dict: Returns a dictionary with the frequency count of each letter in the string. The function is case-insensitive and ignores non-letter characters. >>> letter_frequency(\\"Hello, World!\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> letter_frequency(\\"123abc!ABC!\\") {'a': 2, 'b': 2, 'c': 2} >>> letter_frequency(\\"\\") {} >>> letter_frequency(\\"aaaAAA\\") {'a': 6} >>> letter_frequency(\\"mIxEd CaSe\\") {'m': 1, 'i': 1, 'x': 1, 'e': 2, 'd': 1, 'c': 1, 'a': 1, 's': 1} >>> letter_frequency(\\"The quick brown fox jumps over the lazy dog\\") {'t': 2, 'h': 2, 'e': 3, 'q': 1, 'u': 2, 'i': 1, 'c': 1, 'k': 1, 'b': 1, 'r': 2, 'o': 4, 'w': 1, 'n': 1, 'f': 1, 'x': 1, 'j': 1, 'm': 1, 'p': 1, 's': 1, 'v': 1, 'l': 1, 'a': 1, 'z': 1, 'y': 1, 'd': 1, 'g': 1}","solution":"def letter_frequency(s): Returns a dictionary with the frequency count of each letter in the string. The function is case-insensitive and ignores non-letter characters. from collections import defaultdict frequency = defaultdict(int) for char in s: if char.isalpha(): char = char.lower() frequency[char] += 1 return dict(frequency)"},{"question":"class MeetingScheduler: Develop a meeting scheduling system using natural language processing that can interact with users through a chat interface. It should handle the following functionalities: - Schedule a new meeting - Update details of an existing meeting - Cancel a meeting - Send reminders to participants - Check the availability of all participants before scheduling the meeting - Handle conflicts such as double-booking - Suggest alternative time slots based on participant availability - Support integration with popular calendar services like Google Calendar and Microsoft Outlook - Handle time zone differences automatically - Provide an interface for participants to propose alternate meeting times The chatbot should manage conversations in a natural and fluid manner, with error handling for unrecognized inputs. >>> scheduler = MeetingScheduler() >>> scheduler.schedule_meeting(\\"1\\", \\"10am\\", [\\"Alice\\", \\"Bob\\"]) 'Meeting scheduled successfully.' >>> scheduler.schedule_meeting(\\"1\\", \\"11am\\", [\\"Alice\\", \\"Bob\\"]) 'Meeting ID already exists.' >>> scheduler.update_meeting(\\"1\\", \\"11am\\") 'Meeting updated successfully.' >>> scheduler.update_meeting(\\"2\\", \\"12pm\\") 'Meeting ID does not exist.' >>> scheduler.cancel_meeting(\\"1\\") 'Meeting cancelled successfully.' >>> scheduler.cancel_meeting(\\"2\\") 'Meeting ID does not exist.' >>> scheduler.send_reminder(\\"1\\") 'Reminder sent successfully.' >>> scheduler.send_reminder(\\"2\\") 'Meeting ID does not exist.' def __init__(self): # Initialize the meeting scheduler with an empty dictionary to keep track of meetings. self.meetings = {} def schedule_meeting(self, meeting_id, time_slot, participants): # Schedule a new meeting if the meeting_id is not already used. # Check if participants are available, then add the meeting to the schedule. pass def update_meeting(self, meeting_id, new_time_slot, new_participants=None): # Update the details of an existing meeting given its meeting_id. # Check if new participants are available if provided, then update the meeting details. pass def cancel_meeting(self, meeting_id): # Cancel a scheduled meeting given its meeting_id. pass def is_participant_available(self, participant, time_slot): # Dummy function to check participant availability. # In a real scenario, check from calendar services like Google Calendar, Outlook etc. pass def send_reminder(self, meeting_id): # Send a reminder to the participants of a scheduled meeting given its meeting_id. pass","solution":"class MeetingScheduler: def __init__(self): self.meetings = {} def schedule_meeting(self, meeting_id, time_slot, participants): if meeting_id in self.meetings: return \\"Meeting ID already exists.\\" for participant in participants: if not self.is_participant_available(participant, time_slot): return f\\"Participant {participant} is not available at {time_slot}.\\" self.meetings[meeting_id] = { \\"time_slot\\": time_slot, \\"participants\\": participants } return \\"Meeting scheduled successfully.\\" def update_meeting(self, meeting_id, new_time_slot, new_participants=None): if meeting_id not in self.meetings: return \\"Meeting ID does not exist.\\" meeting_details = self.meetings[meeting_id] participants = new_participants if new_participants else meeting_details[\\"participants\\"] for participant in participants: if not self.is_participant_available(participant, new_time_slot): return f\\"Participant {participant} is not available at {new_time_slot}.\\" self.meetings[meeting_id] = { \\"time_slot\\": new_time_slot, \\"participants\\": participants } return \\"Meeting updated successfully.\\" def cancel_meeting(self, meeting_id): if meeting_id in self.meetings: del self.meetings[meeting_id] return \\"Meeting cancelled successfully.\\" return \\"Meeting ID does not exist.\\" def is_participant_available(self, participant, time_slot): # Dummy function to check participant availability # In real scenario, will check from calendar services like Google Calendar, Outlook etc. return True def send_reminder(self, meeting_id): if meeting_id not in self.meetings: return \\"Meeting ID does not exist.\\" # Logic to send reminder return \\"Reminder sent successfully.\\""},{"question":"import random import matplotlib.pyplot as plt def roll_dice(num_rolls=10000): Simulate rolling two six-sided dice num_rolls times and return the frequency of each possible outcome (2-12). # Implement the function here def calculate_probability(frequencies, num_rolls): Calculate the probability of rolling a sum of 7 from the frequencies dictionary. # Implement the function here def theoretical_probability(): Calculate the theoretical probability of rolling a sum of 7. # Implement the function here def plot_results(frequencies): Plot the frequency of each dice sum from 2 to 12. x = list(frequencies.keys()) y = list(frequencies.values()) plt.bar(x, y) plt.xlabel('Dice Sum') plt.ylabel('Frequency') plt.title('Frequency of Dice Sums') plt.show() # Simulating the dice rolls frequencies = roll_dice() simulated_probability = calculate_probability(frequencies, 10000) theoretical_prob = theoretical_probability() # Plotting the results plot_results(frequencies) print(f\\"Simulated Probability of rolling a sum of 7: {simulated_probability}\\") print(f\\"Theoretical Probability of rolling a sum of 7: {theoretical_prob}\\") print(f\\"Difference: {abs(simulated_probability - theoretical_prob)}\\")","solution":"import random import matplotlib.pyplot as plt def roll_dice(num_rolls=10000): roll_results = [random.randint(1, 6) + random.randint(1, 6) for _ in range(num_rolls)] frequencies = {i: roll_results.count(i) for i in range(2, 13)} return frequencies def calculate_probability(frequencies, num_rolls): sum_seven = frequencies[7] probability_of_seven = sum_seven / num_rolls return probability_of_seven def theoretical_probability(): return 1 / 6 def plot_results(frequencies): x = list(frequencies.keys()) y = list(frequencies.values()) plt.bar(x, y) plt.xlabel('Dice Sum') plt.ylabel('Frequency') plt.title('Frequency of Dice Sums') plt.show() # Simulating the dice rolls frequencies = roll_dice() simulated_probability = calculate_probability(frequencies, 10000) theoretical_prob = theoretical_probability() # Plotting the results plot_results(frequencies) print(f\\"Simulated Probability of rolling a sum of 7: {simulated_probability}\\") print(f\\"Theoretical Probability of rolling a sum of 7: {theoretical_prob}\\") print(f\\"Difference: {abs(simulated_probability - theoretical_prob)}\\")"},{"question":"def split_even_odd_indices(lst: List[int]) -> Tuple[List[int], List[int]]: Splits the input list into two sublists: one containing elements at even indices and the other at odd indices. >>> split_even_odd_indices([]) == ([], []) >>> split_even_odd_indices([1]) == ([1], []) >>> split_even_odd_indices([1, 2]) == ([1], [2]) >>> split_even_odd_indices([1, 2, 3, 4, 5, 6]) == ([1, 3, 5], [2, 4, 6]) >>> split_even_odd_indices([0, 0, 0, 0, 0, 0]) == ([0, 0, 0], [0, 0, 0]) >>> split_even_odd_indices([1, 1, 1, 1, 1, 1]) == ([1, 1, 1], [1, 1, 1]) >>> split_even_odd_indices([1, 1, 1, 1]) == ([1, 1], [1, 1]) from typing import List, Tuple","solution":"def split_even_odd_indices(lst): Splits the input list into two sublists: one containing elements at even indices and the other at odd indices. Parameters: lst (list): The list of integers to be split. Returns: tuple: A tuple containing two sublists - elements at even indices and elements at odd indices. even_index_elements = [lst[i] for i in range(len(lst)) if i % 2 == 0] odd_index_elements = [lst[i] for i in range(len(lst)) if i % 2 == 1] return (even_index_elements, odd_index_elements)"},{"question":"def sort_even_odd(arr): Sorts the integers in ascending order, prioritizing all even numbers before any odd numbers. Even numbers retain their relative order from the original list, as do odd numbers. >>> sort_even_odd([3, 1, 4, 1, 5, 9, 2, 6]) [4, 2, 6, 3, 1, 1, 5, 9] >>> sort_even_odd([4, 2, 8, 6]) [4, 2, 8, 6] >>> sort_even_odd([3, 1, 5, 7]) [3, 1, 5, 7] >>> sort_even_odd([]) [] >>> sort_even_odd([2]) [2] >>> sort_even_odd([3]) [3] >>> sort_even_odd([1, 3, 5, 7, 9]) [1, 3, 5, 7, 9] >>> sort_even_odd([2, 4, 6, 8, 10]) [2, 4, 6, 8, 10] >>> sort_even_odd([1, 2, 2, 3, 3, 4]) [2, 2, 4, 1, 3, 3]","solution":"def sort_even_odd(arr): Sorts the integers in ascending order, prioritizing all even numbers before any odd numbers. Even numbers retain their relative order from the original list, as do odd numbers. evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] return evens + odds"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers, +, -, *, / operators, and parenthesis. Note that the integer division should truncate toward zero. >>> evaluate_expression(\\"1+2\\") 3 >>> evaluate_expression(\\"5-3\\") 2 >>> evaluate_expression(\\"4*2\\") 8 >>> evaluate_expression(\\"9/3\\") 3 >>> evaluate_expression(\\"3+(2*2-3/1)\\") 4 >>> evaluate_expression(\\"3+(6/2+1*4)-4\\") 6 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23 >>> evaluate_expression(\\"(2+(3*(2+1)))\\") 11 >>> evaluate_expression(\\"123\\") 123 >>> evaluate_expression(\\"3+5/2\\") 5","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing non-negative integers, +, -, *, / operators, and parenthesis. import re def helper(s, idx): stack = [] num = 0 sign = '+' while idx < len(s): char = s[idx] if char.isdigit(): num = num * 10 + int(char) if char == '(': num, idx = helper(s, idx + 1) if idx == len(s) - 1 or char in \\"+-*/)\\": if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack.append(stack.pop() * num) elif sign == '/': stack.append(int(stack.pop() / num)) sign = char num = 0 if char == ')': break idx += 1 return sum(stack), idx # Remove whitespace and handle the entire expression expression = re.sub(r's+', '', expression) result, _ = helper(expression, 0) return result"},{"question":"def rearrange_list(arr: List[int]) -> List[int]: Rearranges the elements of a list so that all negative numbers come before the positive numbers (including zero), preserving the original relative order. Parameters: arr (list of int): The list of integers to be rearranged. Returns: list of int: The rearranged list. >>> rearrange_list([-1, 2, -3, 4, 0, -5, 6]) [-1, -3, -5, 2, 4, 0, 6] >>> rearrange_list([-1, -2, -3, -4]) [-1, -2, -3, -4] >>> rearrange_list([1, 2, 3, 4]) [1, 2, 3, 4] >>> rearrange_list([]) [] >>> rearrange_list([0, -1, 0, -2, 0, -3]) [-1, -2, -3, 0, 0, 0] >>> rearrange_list([5]) [5] >>> rearrange_list([-5]) [-5] >>> rearrange_list([0, 0, 0, 0]) [0, 0, 0, 0]","solution":"def rearrange_list(arr): Rearranges the elements of a list so that all negative numbers come before the positive numbers, preserving the original relative order. Parameters: arr (list of int): The list of integers to be rearranged. Returns: list of int: The rearranged list. if not arr: return [] negative_numbers = [x for x in arr if x < 0] non_negative_numbers = [x for x in arr if x >= 0] return negative_numbers + non_negative_numbers"},{"question":"def is_prime(n: int) -> bool: Check if a number is a prime. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(17) == True >>> is_prime(18) == False >>> is_prime(1) == False >>> is_prime(0) == False pass def next_prime(n: int) -> int: Find the next prime greater than or equal to n. >>> next_prime(10) == 11 >>> next_prime(15) == 17 >>> next_prime(17) == 17 >>> next_prime(25) == 29 >>> next_prime(0) == 2 >>> next_prime(1) == 2 pass def replace_with_next_primes(lst: List[int]) -> List[int]: Replaces each prime number in the list with the nearest prime number that is greater than or equal to it. >>> replace_with_next_primes([10, 15, 17, 25]) == [11, 17, 17, 29] >>> replace_with_next_primes([]) == [] >>> replace_with_next_primes([2, 3, 5, 7]) == [2, 3, 5, 7] >>> replace_with_next_primes([8, 10, 12]) == [11, 11, 13] >>> replace_with_next_primes([29, 30, 31, 32]) == [29, 31, 31, 37] pass","solution":"def is_prime(n): Check if a number is a prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def next_prime(n): Find the next prime greater than or equal to n. if n <= 1: return 2 prime = n while not is_prime(prime): prime += 1 return prime def replace_with_next_primes(lst): Replaces each prime number in the list with the nearest prime number that is greater than or equal to it. return [next_prime(num) for num in lst]"},{"question":"def longest_substring_without_repeating(s: str) -> str: Write a function that takes a string as input and returns the longest substring without repeating characters. Implement an efficient solution using sliding window technique, ensuring the solution has a time complexity of O(n). >>> longest_substring_without_repeating(\\"abcabcbb\\") \\"abc\\" >>> longest_substring_without_repeating(\\"bbbbb\\") \\"b\\" >>> longest_substring_without_repeating(\\"pwwkew\\") \\"wke\\" >>> longest_substring_without_repeating(\\"\\") \\"\\" >>> longest_substring_without_repeating(\\"a\\") \\"a\\" >>> longest_substring_without_repeating(\\"abcdef\\") \\"abcdef\\" >>> longest_substring_without_repeating(\\"abcdabcabcdeabc\\") \\"abcde\\" >>> longest_substring_without_repeating(\\"aaaaaaa\\") \\"a\\" >>> longest_substring_without_repeating(\\"dvdf\\") \\"vdf\\" >>> longest_substring_without_repeating(\\"anviaj\\") \\"nviaj\\" >>> s = \\"a\\" * 1000 + \\"b\\" >>> longest_substring_without_repeating(s) \\"ab\\"","solution":"def longest_substring_without_repeating(s): Returns the longest substring without repeating characters. n = len(s) if n == 0: return \\"\\" char_index_map = {} left = 0 max_length = 0 start = 0 for right in range(n): if s[right] in char_index_map and char_index_map[s[right]] >= left: left = char_index_map[s[right]] + 1 char_index_map[s[right]] = right length = right - left + 1 if length > max_length: max_length = length start = left return s[start:start + max_length]"},{"question":"def filter_and_square_evens(nums): Returns a list of squares of the elements from the input list if and only if the squared value is even. Args: nums (list of int): List of integers. Returns: list of int: List of squares of the input elements that are even. >>> filter_and_square_evens([1, 2, 3, 4, 5]) [4, 16] >>> filter_and_square_evens([10, 15, 22, 33]) [100, 484] >>> filter_and_square_evens([]) []","solution":"def filter_and_square_evens(nums): Returns a list of squares of the elements from the input list if and only if the squared value is even. Args: nums (list of int): List of integers. Returns: list of int: List of squares of the input elements that are even. return [x * x for x in nums if (x * x) % 2 == 0]"},{"question":"def convert_to_24_hour_format(time_str: str) -> str: Converts a time string from 12-hour format to 24-hour format. Parameters: time_str (str): A string representing time in 12-hour format (e.g., \\"02:30 PM\\"). Returns: str: A string representing time in 24-hour format (e.g., \\"14:30\\"). If the input string is invalid, returns \\"Invalid time format\\". >>> convert_to_24_hour_format(\\"12:00 AM\\") == \\"00:00\\" >>> convert_to_24_hour_format(\\"01:30 AM\\") == \\"01:30\\" >>> convert_to_24_hour_format(\\"11:59 AM\\") == \\"11:59\\" >>> convert_to_24_hour_format(\\"12:00 PM\\") == \\"12:00\\" >>> convert_to_24_hour_format(\\"01:00 PM\\") == \\"13:00\\" >>> convert_to_24_hour_format(\\"11:59 PM\\") == \\"23:59\\" >>> convert_to_24_hour_format(\\"13:00 PM\\") == \\"Invalid time format\\" >>> convert_to_24_hour_format(\\"00:00 AM\\") == \\"Invalid time format\\" >>> convert_to_24_hour_format(\\"11:60 AM\\") == \\"Invalid time format\\" >>> convert_to_24_hour_format(\\"07:30 XM\\") == \\"Invalid time format\\" >>> convert_to_24_hour_format(\\"invalid string\\") == \\"Invalid time format\\" >>> convert_to_24_hour_format(\\"12:00 PM \\") == \\"12:00\\" >>> convert_to_24_hour_format(\\" 01:00 AM\\") == \\"01:00\\" >>> convert_to_24_hour_format(\\" 11:59 PM \\") == \\"23:59\\" >>> convert_to_24_hour_format(\\"10:15 pm\\") == \\"Invalid time format\\"","solution":"def convert_to_24_hour_format(time_str): Converts a time string from 12-hour format to 24-hour format. Parameters: time_str (str): A string representing time in 12-hour format (e.g., \\"02:30 PM\\"). Returns: str: A string representing time in 24-hour format (e.g., \\"14:30\\"). If the input string is invalid, returns \\"Invalid time format\\". try: # Split the time string into time and period (AM/PM) time_part, period_part = time_str.strip().split() # Split the time part into hours and minutes hours, minutes = map(int, time_part.split(\\":\\")) # Validate the time part if not (1 <= hours <= 12 and 0 <= minutes < 60): return \\"Invalid time format\\" # Validate the period part if period_part not in {\\"AM\\", \\"PM\\"}: return \\"Invalid time format\\" # Convert hours based on the period (AM/PM) if period_part == \\"PM\\" and hours != 12: hours += 12 elif period_part == \\"AM\\" and hours == 12: hours = 0 # Format hours and minutes to HH:MM return f\\"{hours:02}:{minutes:02}\\" except: return \\"Invalid time format\\""},{"question":"import torch import torch.nn as nn import torch.optim as optim from torch.utils.data import DataLoader from torchvision import datasets, transforms class Generator(nn.Module): def __init__(self, nz): super(Generator, self).__init__() self.main = nn.Sequential( nn.ConvTranspose2d(nz, 512, 4, 1, 0, bias=False), nn.BatchNorm2d(512), nn.ReLU(True), nn.ConvTranspose2d(512, 256, 4, 2, 1, bias=False), nn.BatchNorm2d(256), nn.ReLU(True), nn.ConvTranspose2d(256, 128, 4, 2, 1, bias=False), nn.BatchNorm2d(128), nn.ReLU(True), nn.ConvTranspose2d(128, 64, 4, 2, 1, bias=False), nn.BatchNorm2d(64), nn.ReLU(True), nn.ConvTranspose2d(64, 3, 4, 2, 1, bias=False), nn.Tanh() ) def forward(self, input): return self.main(input) class Discriminator(nn.Module): def __init__(self): super(Discriminator, self).__init__() self.main = nn.Sequential( nn.Conv2d(3, 64, 4, 2, 1, bias=False), nn.LeakyReLU(0.2, inplace=True), nn.Conv2d(64, 128, 4, 2, 1, bias=False), nn.BatchNorm2d(128), nn.LeakyReLU(0.2, inplace=True), nn.Conv2d(128, 256, 4, 2, 1, bias=False), nn.BatchNorm2d(256), nn.LeakyReLU(0.2, inplace=True), nn.Conv2d(256, 512, 4, 2, 1, bias=False), nn.BatchNorm2d(512), nn.LeakyReLU(0.2, inplace=True), nn.Conv2d(512, 1, 4, 1, 0, bias=False), nn.Sigmoid() ) def forward(self, input): return self.main(input).view(-1, 1).squeeze(1) def train_GAN(dataloader, G, D, optimizerG, optimizerD, criterion, nz, num_epochs, device): for epoch in range(num_epochs): for i, data in enumerate(dataloader, 0): # (1) Update D network: maximize log(D(x)) + log(1 - D(G(z))) D.zero_grad() real = data[0].to(device) b_size = real.size(0) label = torch.full((b_size,), 1, dtype=torch.float, device=device) # real label is 1 output = D(real) errD_real = criterion(output, label) errD_real.backward() noise = torch.randn(b_size, nz, 1, 1, device=device) fake = G(noise) label.fill_(0) # fake label is 0 output = D(fake.detach()) errD_fake = criterion(output, label) errD_fake.backward() optimizerD.step() # (2) Update G network: maximize log(D(G(z))) G.zero_grad() label.fill_(1) output = D(fake) errG = criterion(output, label) errG.backward() optimizerG.step() print(f'[{epoch}/{num_epochs}][{i}/{len(dataloader)}] Loss_D: {errD_real+errD_fake:.4f} Loss_G: {errG:.4f}') def main(): device = torch.device(\\"cuda\\" if torch.cuda.is_available() else \\"cpu\\") transform = transforms.Compose([ transforms.Resize(64), transforms.CenterCrop(64), transforms.ToTensor(), transforms.Normalize([0.5]*3, [0.5]*3) ]) dataset = datasets.CIFAR10(root='./data', train=True, download=True, transform=transform) dataloader = DataLoader(dataset, batch_size=128, shuffle=True, num_workers=4) nz = 100 G = Generator(nz).to(device) D = Discriminator().to(device) criterion = nn.BCELoss() optimizerD = optim.Adam(D.parameters(), lr=0.0002, betas=(0.5, 0.999)) optimizerG = optim.Adam(G.parameters(), lr=0.0002, betas=(0.5, 0.999)) num_epochs = 25 train_GAN(dataloader, G, D, optimizerG, optimizerD, criterion, nz, num_epochs, device) if __name__ == \\"__main__\\": main()","solution":"import torch import torch.nn as nn import torch.optim as optim from torch.utils.data import DataLoader from torchvision import datasets, transforms from torchvision.utils import save_image class Generator(nn.Module): def __init__(self, nz): super(Generator, self).__init__() self.main = nn.Sequential( nn.ConvTranspose2d(nz, 512, 4, 1, 0, bias=False), nn.BatchNorm2d(512), nn.ReLU(True), nn.ConvTranspose2d(512, 256, 4, 2, 1, bias=False), nn.BatchNorm2d(256), nn.ReLU(True), nn.ConvTranspose2d(256, 128, 4, 2, 1, bias=False), nn.BatchNorm2d(128), nn.ReLU(True), nn.ConvTranspose2d(128, 64, 4, 2, 1, bias=False), nn.BatchNorm2d(64), nn.ReLU(True), nn.ConvTranspose2d(64, 3, 4, 2, 1, bias=False), nn.Tanh() ) def forward(self, input): return self.main(input) class Discriminator(nn.Module): def __init__(self): super(Discriminator, self).__init__() self.main = nn.Sequential( nn.Conv2d(3, 64, 4, 2, 1, bias=False), nn.LeakyReLU(0.2, inplace=True), nn.Conv2d(64, 128, 4, 2, 1, bias=False), nn.BatchNorm2d(128), nn.LeakyReLU(0.2, inplace=True), nn.Conv2d(128, 256, 4, 2, 1, bias=False), nn.BatchNorm2d(256), nn.LeakyReLU(0.2, inplace=True), nn.Conv2d(256, 512, 4, 2, 1, bias=False), nn.BatchNorm2d(512), nn.LeakyReLU(0.2, inplace=True), nn.Conv2d(512, 1, 4, 1, 0, bias=False), nn.Sigmoid() ) def forward(self, input): return self.main(input).view(-1, 1).squeeze(1) def train_GAN(dataloader, G, D, optimizerG, optimizerD, criterion, nz, num_epochs, device): for epoch in range(num_epochs): for i, data in enumerate(dataloader, 0): # (1) Update D network: maximize log(D(x)) + log(1 - D(G(z))) D.zero_grad() real = data[0].to(device) b_size = real.size(0) label = torch.full((b_size,), 1, dtype=torch.float, device=device) # real label is 1 output = D(real) errD_real = criterion(output, label) errD_real.backward() noise = torch.randn(b_size, nz, 1, 1, device=device) fake = G(noise) label.fill_(0) # fake label is 0 output = D(fake.detach()) errD_fake = criterion(output, label) errD_fake.backward() optimizerD.step() # (2) Update G network: maximize log(D(G(z))) G.zero_grad() label.fill_(1) output = D(fake) errG = criterion(output, label) errG.backward() optimizerG.step() print(f'[{epoch}/{num_epochs}][{i}/{len(dataloader)}] Loss_D: {errD_real+errD_fake:.4f} Loss_G: {errG:.4f}') def main(): device = torch.device(\\"cuda\\" if torch.cuda.is_available() else \\"cpu\\") transform = transforms.Compose([ transforms.Resize(64), transforms.CenterCrop(64), transforms.ToTensor(), transforms.Normalize([0.5]*3, [0.5]*3) ]) dataset = datasets.CIFAR10(root='./data', train=True, download=True, transform=transform) dataloader = DataLoader(dataset, batch_size=128, shuffle=True, num_workers=4) nz = 100 G = Generator(nz).to(device) D = Discriminator().to(device) criterion = nn.BCELoss() optimizerD = optim.Adam(D.parameters(), lr=0.0002, betas=(0.5, 0.999)) optimizerG = optim.Adam(G.parameters(), lr=0.0002, betas=(0.5, 0.999)) num_epochs = 25 train_GAN(dataloader, G, D, optimizerG, optimizerD, criterion, nz, num_epochs, device) if __name__ == \\"__main__\\": main()"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5 >>> length_of_longest_substring_two_distinct(\\"a\\") 1 >>> length_of_longest_substring_two_distinct(\\"aaaa\\") 4 >>> length_of_longest_substring_two_distinct(\\"aab\\") 3 >>> length_of_longest_substring_two_distinct(\\"\\") 0 >>> length_of_longest_substring_two_distinct(\\"abaccc\\") 4","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring that contains at most two distinct characters. if len(s) == 0: return 0 max_len = 0 start = 0 char_map = {} for end in range(len(s)): char = s[end] if char in char_map: char_map[char] += 1 else: char_map[char] = 1 while len(char_map) > 2: start_char = s[start] char_map[start_char] -= 1 if char_map[start_char] == 0: del char_map[start_char] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"def median(nums): Find the median of a list of integers. The function returns the median value which is the middle value in a sorted list of integers. For even length lists, it returns the average of the two middle values. >>> median([3, 5, 1, 4, 2]) 3 >>> median([1, 2, 3, 4, 5, 6]) 3.5 >>> median([5, 3, 1]) 3 >>> median([1, 2, 2, 3, 4]) 2 >>> median([9, 2, 1, 6, 3, 8]) 4.5 >>> median([1]) 1","solution":"def median(nums): nums.sort() # Sorting the list # Check if the length of the list is odd or even if len(nums) % 2 == 1: median_value = nums[len(nums) // 2] # Middle value for odd length lists else: middle1 = nums[len(nums) // 2 - 1] # Middle left value for even length lists middle2 = nums[len(nums) // 2] # Middle right value for even length lists median_value = (middle1 + middle2) / 2.0 # Average of middle values return median_value"},{"question":"def find_max_min_diff(nums: List[int]) -> int: Computes the difference between the maximum and minimum values in the list. Args: nums (list): List of integers. Returns: int: The difference between the maximum and minimum values. Raises: ValueError: If the input list is empty. >>> find_max_min_diff([1, 2, 3, 4, 5]) == 4 >>> find_max_min_diff([-1, -5, -3, -4]) == 4 >>> find_max_min_diff([-10, 0, 10, 20]) == 30 >>> find_max_min_diff([5]) == 0 >>> find_max_min_diff([7, 7, 7, 7]) == 0 >>> find_max_min_diff([]) raises ValueError >>> find_max_min_diff([1000000, -1000000]) == 2000000","solution":"def find_max_min_diff(nums): Computes the difference between the maximum and minimum values in the list. Args: nums (list): List of integers. Returns: int: The difference between the maximum and minimum values. Raises: ValueError: If the input list is empty. if not nums: raise ValueError(\\"The input list must not be empty.\\") max_val = max(nums) min_val = min(nums) return max_val - min_val"},{"question":"from typing import List def largest_number(nums: List[int]) -> str: Takes a list of integers and returns the largest possible number formed by rearranging the list, as a string. >>> largest_number([3, 30, 34, 5, 9]) == \\"9534330\\" >>> largest_number([1, 2, 3, 4, 5, 6, 7, 8, 9]) == \\"987654321\\" >>> largest_number([0, 0, 0, 0]) == \\"0\\" >>> largest_number([10, 2]) == \\"210\\" >>> largest_number([824, 938, 1399, 5607, 6973, 5709, 9609, 4398, 8247]) == \\"9609938824824769735709560743981399\\" >>> largest_number([3, 30, 34, 5, 9, 91, 100]) == \\"991534330100\\" >>> largest_number([1, 1, 1, 1, 1]) == \\"11111\\"","solution":"from functools import cmp_to_key def comparator(a, b): t1 = a + b t2 = b + a return (t1 > t2) - (t1 < t2) # returns 1 if t1 > t2, -1 if t1 < t2, 0 otherwise def largest_number(nums): Takes a list of integers and returns the largest possible number formed by rearranging the list, as a string. # Convert all integers to strings str_nums = list(map(str, nums)) # Sort the numbers based on the comparator str_nums.sort(key=cmp_to_key(comparator), reverse=True) # Concatenate all numbers largest_num = ''.join(str_nums) # Strip leading zeros return largest_num if largest_num[0] != '0' else '0'"},{"question":"def maxCoins(grid): Calculate the maximum number of coins Mario can collect from top-left to bottom-right of the grid. >>> grid1 = [ ... [0, 3, 1, 1], ... [2, 0, 0, 4], ... [1, 5, 3, 1] ... ] >>> maxCoins(grid1) 12 >>> grid2 = [ ... [1, 2, 5], ... [3, 2, 1] ... ] >>> maxCoins(grid2) 9 >>> grid3 = [[1, 2, 3, 4]] >>> maxCoins(grid3) 10 >>> grid4 = [ ... [1], ... [2], ... [3], ... [4] ... ] >>> maxCoins(grid4) 10 >>> grid5 = [[5]] >>> maxCoins(grid5) 5 >>> grid6 = [ ... [100, 100], ... [1, 100] ... ] >>> maxCoins(grid6) 300 :param grid: List[List[int]] - a 2D grid where each cell contains a certain number of coins. :return: int - the maximum number of coins Mario can collect.","solution":"def maxCoins(grid): Calculate the maximum number of coins Mario can collect from top-left to bottom-right of the grid. :param grid: List[List[int]] - a 2D grid where each cell contains a certain number of coins. :return: int - the maximum number of coins Mario can collect. m = len(grid) n = len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"from typing import List def reorder_even_odd(nums: List[int]) -> List[int]: Reorders the list so that all even numbers are listed before all the odd numbers. Additionally, all even numbers should be sorted in ascending order, and all odd numbers should be sorted in descending order. >>> reorder_even_odd([4, 3, 1, 2, 0, 5, 9, 8]) [0, 2, 4, 8, 9, 5, 3, 1] >>> reorder_even_odd([4, 2, 0, 8]) [0, 2, 4, 8] >>> reorder_even_odd([7, 3, 5, 1]) [7, 5, 3, 1] >>> reorder_even_odd([]) [] >>> reorder_even_odd([7]) [7] >>> reorder_even_odd([2]) [2] >>> reorder_even_odd([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) [2, 4, 6, 9, 5, 5, 5, 3, 3, 1, 1]","solution":"from typing import List def reorder_even_odd(nums: List[int]) -> List[int]: Reorders the list so that all even numbers are sorted in ascending order, followed by all odd numbers sorted in descending order. evens = sorted([num for num in nums if num % 2 == 0]) odds = sorted([num for num in nums if num % 2 != 0], reverse=True) return evens + odds"},{"question":"from typing import List def doesWordExist(grid: List[List[str]], word: str) -> bool: Determine if a word exists in a 2D grid of characters. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: >>> grid = [ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ] >>> doesWordExist(grid, \\"ABCCED\\") True >>> doesWordExist(grid, \\"SEE\\") True >>> doesWordExist(grid, \\"ABCB\\") False def test_word_exist_in_grid(): grid = [ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ] word1 = \\"ABCCED\\" assert doesWordExist(grid, word1) == True word2 = \\"SEE\\" assert doesWordExist(grid, word2) == True word3 = \\"ABCB\\" assert doesWordExist(grid, word3) == False word4 = \\"ABFSAB\\" assert doesWordExist(grid, word4) == False def test_empty_grid_or_word(): empty_grid = [] word1 = \\"A\\" assert doesWordExist(empty_grid, word1) == False grid = [ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ] empty_word = \\"\\" assert doesWordExist(grid, empty_word) == False def test_single_letter_grid_and_word(): grid = [['A']] word1 = \\"A\\" assert doesWordExist(grid, word1) == True word2 = \\"B\\" assert doesWordExist(grid, word2) == False word3 = \\"AA\\" assert doesWordExist(grid, word3) == False","solution":"def doesWordExist(grid, word): if not grid or not word: return False rows, cols = len(grid), len(grid[0]) def dfs(r, c, index): if index == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != word[index]: return False temp = grid[r][c] grid[r][c] = '#' # Mark the cell as visited found = (dfs(r+1, c, index+1) or dfs(r-1, c, index+1) or dfs(r, c+1, index+1) or dfs(r, c-1, index+1)) grid[r][c] = temp # Unmark the cell return found for i in range(rows): for j in range(cols): if grid[i][j] == word[0]: if dfs(i, j, 0): return True return False"},{"question":"from typing import List, Tuple, Optional def find_pair_with_sum(numbers: List[int], target_sum: int) -> Optional[Tuple[int, int]]: Given a list of integers and a target sum, determine if any two distinct integers in the list can be summed up to reach the target sum. If such a pair exists, return the pair as a tuple; otherwise, return None. >>> find_pair_with_sum([10, 15, 3, 7], 17) (10, 7) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) None >>> find_pair_with_sum([5, 5, 5, 5], 10) (5, 5)","solution":"def find_pair_with_sum(numbers, target_sum): Finds two distinct numbers in the list that sum up to the target sum. Parameters: numbers (list): List of integers. target_sum (int): Target sum to find in the list. Returns: tuple: A tuple containing the pair of numbers that sum up to the target sum or None if no such pair exists. seen_numbers = set() for number in numbers: complement = target_sum - number if complement in seen_numbers: return (complement, number) seen_numbers.add(number) return None"},{"question":"from typing import List def first_unique_subarray_elements(lst: List[int]) -> List[int]: Implement a function that takes a list of integers and returns a new list containing only the first unique integer encountered when traversing from left to right for each subarray created by shifting one element at a time from the original list. >>> first_unique_subarray_elements([3, 4, 4, 3, 5, 6, 6]) [3, 4, 5, 6] >>> first_unique_subarray_elements([1, 2, 1, 3, 2, 4]) [1, 2, 3, 4] >>> first_unique_subarray_elements([9, 8, 7, 8, 6, 5, 5]) [9, 8, 7, 6, 5] >>> first_unique_subarray_elements([1]) [1] >>> first_unique_subarray_elements([1, 2, 2, 1, 3, 3, 4, 4, 5, 5]) [1, 2, 3, 4, 5] >>> first_unique_subarray_elements([7, 7, 7, 7, 7]) [7] >>> first_unique_subarray_elements([]) [] >>> first_unique_subarray_elements([5, 6, 7, 8]) [5, 6, 7, 8] >>> first_unique_subarray_elements([4, 4, 4, 4]) [4]","solution":"def first_unique_subarray_elements(lst): Returns a list of the first unique integer encountered in each subarray created by shifting one element at a time from the original list. encountered = set() result = [] for i in range(len(lst)): for j in range(i, len(lst)): if lst[j] not in encountered: encountered.add(lst[j]) result.append(lst[j]) break return result"},{"question":"def organize_students_by_grade(students_data: dict) -> dict: Organizes the student information by their grade level. Each student's information includes their name, age, and favorite subject. Students missing any of the three pieces of information are handled gracefully. Args: students_data (dict): The dictionary containing the student information. Returns: dict: A new dictionary where the keys are the grade levels, and the values are lists of dictionaries with student details. >>> students_data = { ... \\"students\\": [ ... {\\"name\\": \\"Alice\\", \\"age\\": 14, \\"grade\\": \\"8\\", \\"favorite_subject\\": \\"Math\\"}, ... {\\"name\\": \\"Bob\\", \\"age\\": 13, \\"grade\\": \\"7\\", \\"favorite_subject\\": \\"Science\\"}, ... {\\"name\\": \\"Charlie\\", \\"age\\": 14, \\"grade\\": \\"8\\"}, ... {\\"name\\": \\"David\\", \\"age\\": 15, \\"grade\\": \\"9\\", \\"favorite_subject\\": \\"History\\"}, ... {\\"name\\": \\"Eve\\", \\"age\\": 13, \\"grade\\": \\"7\\", \\"favorite_subject\\": \\"Art\\"} ... ] ... } >>> organize_students_by_grade(students_data) { \\"8\\": [ {\\"name\\": \\"Alice\\", \\"age\\": 14, \\"favorite_subject\\": \\"Math\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 14, \\"favorite_subject\\": None} ], \\"7\\": [ {\\"name\\": \\"Bob\\", \\"age\\": 13, \\"favorite_subject\\": \\"Science\\"}, {\\"name\\": \\"Eve\\", \\"age\\": 13, \\"favorite_subject\\": \\"Art\\"} ], \\"9\\": [ {\\"name\\": \\"David\\", \\"age\\": 15, \\"favorite_subject\\": \\"History\\"} ] } pass # Your implementation here","solution":"def organize_students_by_grade(students_data): Organizes the student information by their grade level. Args: students_data (dict): The dictionary containing the student information. Returns: dict: A new dictionary where the keys are the grade levels, and the values are lists of dictionaries with student details. organized_data = {} for student in students_data.get(\\"students\\", []): grade = student.get(\\"grade\\") if grade: if grade not in organized_data: organized_data[grade] = [] cleaned_student = { \\"name\\": student.get(\\"name\\"), \\"age\\": student.get(\\"age\\"), \\"favorite_subject\\": student.get(\\"favorite_subject\\") } organized_data[grade].append(cleaned_student) return organized_data"},{"question":"def find_median_age(ages: List[int]) -> float: Returns the median age from the list of ages. >>> find_median_age([42, 21, 34, 75, 16]) 34 >>> find_median_age([42, 21, 34, 75, 16, 59]) 38.0 >>> find_median_age([16, 21, 34, 42, 59, 75]) 38.0 >>> find_median_age([42]) 42 >>> find_median_age([21, 34]) 27.5 >>> find_median_age([42, 21, 34, 34, 16, 59, 75]) 34 >>> find_median_age([-10, -20, -30, -40, -50]) -30","solution":"def find_median_age(ages): Returns the median age from the list of ages. ages.sort() n = len(ages) if n % 2 == 1: # If odd, return the middle number return ages[n // 2] else: # If even, return the average of the two middle numbers mid1 = ages[n // 2 - 1] mid2 = ages[n // 2] return (mid1 + mid2) / 2.0"},{"question":"class Inventory: Simulate a basic text-based inventory system for a small RPG game. Each item should have a name and quantity. The inventory should support adding, removing, and viewing items. - add_item(name: str, quantity: int): Adds the specified quantity of the item to the inventory. Raises a ValueError if the quantity is negative. - remove_item(name: str, quantity: int): Removes the specified quantity of the item from the inventory. Raises a KeyError if the item does not exist. Raises a ValueError if the quantity is negative or if there is insufficient quantity to remove. - view_inventory(): Returns a dictionary representation of the current inventory. def __init__(self): self.items = {} def add_item(self, name, quantity): pass def remove_item(self, name, quantity): pass def view_inventory(self): pass import pytest def test_add_item(): inv = Inventory() inv.add_item(\\"sword\\", 2) inv.add_item(\\"shield\\", 1) assert inv.view_inventory() == {\\"sword\\": 2, \\"shield\\": 1} def test_add_to_existing_item(): inv = Inventory() inv.add_item(\\"potion\\", 5) inv.add_item(\\"potion\\", 3) assert inv.view_inventory() == {\\"potion\\": 8} def test_add_negative_quantity(): inv = Inventory() with pytest.raises(ValueError): inv.add_item(\\"boots\\", -1) def test_remove_item(): inv = Inventory() inv.add_item(\\"helmet\\", 2) inv.remove_item(\\"helmet\\", 1) assert inv.view_inventory() == {\\"helmet\\": 1} inv.remove_item(\\"helmet\\", 1) assert inv.view_inventory() == {} def test_remove_nonexistent_item(): inv = Inventory() with pytest.raises(KeyError): inv.remove_item(\\"cloak\\", 1) def test_remove_item_with_insufficient_quantity(): inv = Inventory() inv.add_item(\\"armor\\", 3) with pytest.raises(ValueError): inv.remove_item(\\"armor\\", 4) def test_remove_negative_quantity(): inv = Inventory() inv.add_item(\\"ring\\", 1) with pytest.raises(ValueError): inv.remove_item(\\"ring\\", -1) def test_view_inventory(): inv = Inventory() inv.add_item(\\"dagger\\", 1) inv.add_item(\\"rope\\", 2) assert inv.view_inventory() == {\\"dagger\\": 1, \\"rope\\": 2}","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, name, quantity): if quantity < 0: raise ValueError(\\"Cannot add negative quantity\\") if name in self.items: self.items[name] += quantity else: self.items[name] = quantity def remove_item(self, name, quantity): if name not in self.items: raise KeyError(f\\"Item {name} not found in inventory\\") if quantity < 0: raise ValueError(\\"Cannot remove negative quantity\\") if self.items[name] < quantity: raise ValueError(f\\"Not enough of {name} to remove\\") self.items[name] -= quantity if self.items[name] == 0: del self.items[name] def view_inventory(self): return self.items"},{"question":"def rearrange_string(s: str) -> str: Rearranges the given string such that all digits are moved to the end while preserving the order of both letters and digits, and non-alphanumeric characters are removed. >>> rearrange_string(\\"a1b2c3\\") 'abc123' >>> rearrange_string(\\"abc\\") 'abc' >>> rearrange_string(\\"12345\\") '12345' >>> rearrange_string(\\"a1!b@2#c3\\") 'abc123' >>> rearrange_string(\\"A1bC2dE3\\") 'AbCdE123' >>> rearrange_string(\\"!@#%^\\") '' >>> rearrange_string(\\"\\") ''","solution":"def rearrange_string(s): Rearranges the given string such that all digits are moved to the end while preserving the order of both letters and digits, and non-alphanumeric characters are removed. letters = [] digits = [] for char in s: if char.isalpha(): letters.append(char) elif char.isdigit(): digits.append(char) return ''.join(letters + digits)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression string containing '+', '*', and parentheses correctly. >>> evaluate_expression(\\"3+5*2\\") 13 >>> evaluate_expression(\\"(2+3)*(4+5)\\") 45","solution":"def evaluate_expression(expression: str) -> int: # This function evaluates a mathematical expression string containing '+', '*', and parentheses correctly. def eval_helper(tokens): stack = [] num = 0 sign = '+' while tokens: token = tokens.pop(0) if token.isdigit(): num = int(token) if token == '(': num = eval_helper(tokens) if (not token.isdigit() and token != ' ') or not tokens: if sign == '+': stack.append(num) elif sign == '*': stack[-1] *= num sign = token num = 0 if token == ')': break return sum(stack) tokens = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 tokens.append(str(num)) else: tokens.append(expression[i]) i += 1 return eval_helper(tokens)"},{"question":"from typing import List, Union def evaluate_operations(operations: List[str]) -> List[Union[int, float, str]]: Takes a list of strings representing arithmetic operations and returns a list of results. Handles addition, subtraction, multiplication, and division. Returns appropriate error messages for invalid operations. >>> evaluate_operations([\\"3 + 5\\", \\"10 - 2\\", \\"6 * 4\\", \\"8 / 2\\"]) [8, 8, 24, 4.0] >>> evaluate_operations([\\"3 / 0\\"]) [\\"Error: Division by zero\\"] >>> evaluate_operations([\\"nine + ten\\", \\"2 + \\", \\"* 3\\"]) [\\"Error: Invalid operation\\", \\"Error: Invalid operation\\", \\"Error: Invalid operation\\"] >>> evaluate_operations([\\"3 + 5\\", \\"10 / 0\\", \\"5 ** 2\\", \\"apple + orange\\"]) [8, \\"Error: Division by zero\\", 25, \\"Error: Invalid operation\\"] >>> evaluate_operations([]) [] >>> evaluate_operations([\\"7 * 3\\"]) [21] >>> evaluate_operations([\\"hello world\\"]) [\\"Error: Invalid operation\\"]","solution":"def evaluate_operations(operations): results = [] for operation in operations: try: result = eval(operation) results.append(result) except ZeroDivisionError: results.append(\\"Error: Division by zero\\") except Exception: results.append(\\"Error: Invalid operation\\") return results"},{"question":"def word_lengths(sentence: str) -> dict: Takes a string containing a sentence and returns a dictionary where the keys are the words in the sentence and the values are the lengths of those words. >>> word_lengths(\\"Hello\\") {'Hello': 5} >>> word_lengths(\\"Hello world this is a test\\") {\\"Hello\\": 5, \\"world\\": 5, \\"this\\": 4, \\"is\\": 2, \\"a\\": 1, \\"test\\": 4} >>> word_lengths(\\"\\") {} >>> word_lengths(\\"a b c d e f g\\") {\\"a\\": 1, \\"b\\": 1, \\"c\\": 1, \\"d\\": 1, \\"e\\": 1, \\"f\\": 1, \\"g\\": 1} >>> word_lengths(\\"Python is fun\\") {\\"Python\\": 6, \\"is\\": 2, \\"fun\\": 3}","solution":"def word_lengths(sentence): Takes a string containing a sentence and returns a dictionary where the keys are the words in the sentence and the values are the lengths of those words. words = sentence.split() return {word: len(word) for word in words}"},{"question":"def pivot_and_sort(arr: List[int], pivot: int) -> Tuple[List[int], List[int]]: Rearranges the elements in the list such that all elements less than or equal to the pivot come before all elements greater than the pivot. Parameters: arr (list): A list of integers. pivot (int): The pivot value. Returns: tuple: A tuple containing two lists - the first list with elements less than or equal to the pivot, and the second list with elements greater than the pivot. >>> pivot_and_sort([10, 5, 2, 7, 3, 8, 4], 5) ([5, 2, 3, 4], [10, 7, 8]) >>> pivot_and_sort([1, 4, 3, 2, 5], 3) ([1, 3, 2], [4, 5]) >>> pivot_and_sort([3, 2, 1], 5) ([3, 2, 1], []) >>> pivot_and_sort([6, 7, 8], 5) ([], [6, 7, 8]) >>> pivot_and_sort([5, 5, 5, 5], 5) ([5, 5, 5, 5], []) >>> pivot_and_sort([], 5) ([], []) >>> pivot_and_sort([3], 3) ([3], []) >>> pivot_and_sort([7], 3) ([], [7])","solution":"def pivot_and_sort(arr, pivot): Rearranges the elements in the list such that all elements less than or equal to the pivot come before all elements greater than the pivot. Parameters: arr (list): A list of integers. pivot (int): The pivot value. Returns: tuple: A tuple containing two lists - the first list with elements less than or equal to the pivot, and the second list with elements greater than the pivot. less_equal = [x for x in arr if x <= pivot] greater = [x for x in arr if x > pivot] return less_equal, greater"},{"question":"import json from collections import defaultdict def group_and_sort_products_by_category(json_data: str) -> str: Parses a JSON object representing a collection of products and returns a new JSON object where the products are grouped by category and sorted by price within each category. Each product has an additional field 'total_cost'. Args: json_data (str): A JSON string representing a list of products. Each product has a name, price, quantity, and category. Returns: str: A JSON string where products are grouped by category and sorted by price. Each product includes a total_cost field. Example usage: >>> input_json = ''' [ {\\"name\\": \\"ProductA\\", \\"price\\": 50.0, \\"quantity\\": 2, \\"category\\": \\"Electronics\\"}, {\\"name\\": \\"ProductB\\", \\"price\\": 20.0, \\"quantity\\": 1, \\"category\\": \\"Furniture\\"}, {\\"name\\": \\"ProductC\\", \\"price\\": 75.0, \\"quantity\\": 3, \\"category\\": \\"Electronics\\"} ] ''' >>> expected_output_json = ''' { \\"Electronics\\": [ {\\"name\\": \\"ProductA\\", \\"price\\": 50.0, \\"quantity\\": 2, \\"category\\": \\"Electronics\\", \\"total_cost\\": 100.0}, {\\"name\\": \\"ProductC\\", \\"price\\": 75.0, \\"quantity\\": 3, \\"category\\": \\"Electronics\\", \\"total_cost\\": 225.0} ], \\"Furniture\\": [ {\\"name\\": \\"ProductB\\", \\"price\\": 20.0, \\"quantity\\": 1, \\"category\\": \\"Furniture\\", \\"total_cost\\": 20.0} ] } ''' >>> output = group_and_sort_products_by_category(input_json) >>> assert json.loads(output) == json.loads(expected_output_json) pass # Your code here","solution":"import json from collections import defaultdict def group_and_sort_products_by_category(json_data): Parses a JSON object representing a collection of products and returns a new JSON object where the products are grouped by category and sorted by price within each category. Each product has an additional field 'total_cost'. products = json.loads(json_data) category_dict = defaultdict(list) for product in products: product['total_cost'] = product['price'] * product['quantity'] category = product['category'] category_dict[category].append(product) for category in category_dict: category_dict[category].sort(key=lambda x: x['price']) return json.dumps(category_dict, indent=4)"},{"question":"def count_characters(input_string: str) -> dict: Returns a dictionary where the keys are unique characters in the input_string and the values are the counts of each character's occurrence. Whitespace is ignored. Uppercase and lowercase letters are considered distinct. >>> count_characters(\\"Hello World\\") {'H': 1, 'e': 1, 'l': 3, 'o': 2, 'W': 1, 'r': 1, 'd': 1} >>> count_characters(\\" \\") {} >>> count_characters(\\"aAa\\") {'a': 2, 'A': 1} >>> count_characters(\\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\") {char: 1 for char in \\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\"} >>> count_characters(\\"123! @#@!321\\") {'1': 2, '2': 2, '3': 2, '!': 2, '@': 2, '#': 1}","solution":"def count_characters(input_string): Returns a dictionary where the keys are unique characters in the input_string and the values are the counts of each character's occurrence. Whitespace is ignored. Uppercase and lowercase letters are considered distinct. character_counts = {} for char in input_string: if char.isspace(): continue if char in character_counts: character_counts[char] += 1 else: character_counts[char] = 1 return character_counts"},{"question":"from typing import List, Tuple def can_complete_tasks(n: int, edges: List[List[int]]) -> Tuple[bool, List[int]]: Determines if all tasks in a directed acyclic graph can be completed, and returns a valid ordering if possible. Parameters: n (int): the number of nodes/tasks edges (list of lists of int): each inner list represents a directed edge (dependency) between two tasks Returns: tuple: (bool, list) - a tuple where the first element is a boolean indicating if all tasks can be completed, and the second element is a list representing the order of tasks if it is possible, otherwise an empty list >>> can_complete_tasks(4, [[1, 2], [1, 3], [3, 4], [4, 2]]) (True, [1, 3, 4, 2]) or (True, [1, 3, 2, 4]) >>> can_complete_tasks(3, [[1, 2], [2, 3], [3, 1]]) (False, []) pass from solution import can_complete_tasks def test_can_complete_tasks_example_1(): n = 4 edges = [[1, 2], [1, 3], [3, 4], [4, 2]] result = can_complete_tasks(n, edges) assert result[0] == True assert result[1] == [1, 3, 4, 2] or result[1] == [1, 3, 2, 4] def test_can_complete_tasks_example_2(): n = 3 edges = [[1, 2], [2, 3], [3, 1]] assert can_complete_tasks(n, edges) == (False, []) def test_no_dependencies(): n = 3 edges = [] result = can_complete_tasks(n, edges) assert result[0] == True assert sorted(result[1]) == [1, 2, 3] def test_single_dependency_chain(): n = 4 edges = [[1, 2], [2, 3], [3, 4]] result = can_complete_tasks(n, edges) assert result[0] == True assert result[1] == [1, 2, 3, 4] def test_multiple_valid_orders(): n = 5 edges = [[1, 2], [1, 3], [3, 4], [2, 5]] result = can_complete_tasks(n, edges) assert result[0] == True assert len(result[1]) == n","solution":"from collections import defaultdict, deque def can_complete_tasks(n, edges): Determines if all tasks in a directed acyclic graph can be completed, and returns a valid ordering if possible. Parameters: n (int): the number of nodes/tasks edges (list of lists of int): each inner list represents a directed edge (dependency) between two tasks Returns: tuple: (bool, list) - a tuple where the first element is a boolean indicating if all tasks can be completed, and the second element is a list representing the order of tasks if it is possible, otherwise an empty list in_degree = [0] * n adj_list = defaultdict(list) # Build the graph for u, v in edges: adj_list[u-1].append(v-1) in_degree[v-1] += 1 # Queue for nodes with no incoming edges queue = deque() for i in range(n): if in_degree[i] == 0: queue.append(i) order = [] while queue: node = queue.popleft() order.append(node + 1) for neighbor in adj_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(order) == n: return True, order else: return False, [] # Test the solution with the example n = 4 edges = [[1, 2], [1, 3], [3, 4], [4, 2]] print(can_complete_tasks(n, edges)) # Output should be (True, [1, 3, 4, 2])"},{"question":"def separate_by_type(mixed_list): Separates a list of mixed data types into three lists based on their type, and returns a dictionary with the separated data. Parameters: mixed_list (list): A list containing integers, strings, and floats. Returns: dict: A dictionary with keys 'integers', 'strings', and 'floats', and values as the corresponding lists of separated data. Example: >>> separate_by_type([1, \\"apple\\", 3.14, 2, \\"banana\\", 5.5, \\"carrot\\", 7]) {'integers': [1, 2, 7], 'strings': ['apple', 'banana', 'carrot'], 'floats': [3.14, 5.5]}","solution":"def separate_by_type(mixed_list): Separates a list of mixed data types into three lists based on their type, and returns a dictionary with the separated data. Parameters: mixed_list (list): A list containing integers, strings, and floats. Returns: dict: A dictionary with keys 'integers', 'strings', and 'floats', and values as the corresponding lists of separated data. result = {'integers': [], 'strings': [], 'floats': []} for item in mixed_list: if isinstance(item, int): result['integers'].append(item) elif isinstance(item, float): result['floats'].append(item) elif isinstance(item, str): result['strings'].append(item) return result"},{"question":"def alphabetically_rearrange(s: str) -> str: Takes a string containing multiple words and rearranges them alphabetically, ignoring case sensitivity. Returns the rearranged string with each word separated by a single space. >>> alphabetically_rearrange(\\"banana apple orange\\") \\"apple banana orange\\" >>> alphabetically_rearrange(\\"Banana apple Orange\\") \\"apple Banana Orange\\" >>> alphabetically_rearrange(\\"Apple apple aPPle\\") \\"Apple apple aPPle\\" >>> alphabetically_rearrange(\\"123 apple 456 Banana\\") \\"123 456 apple Banana\\" >>> alphabetically_rearrange(\\"apple\\") \\"apple\\" >>> alphabetically_rearrange(\\"\\") \\"\\" from solution import alphabetically_rearrange def test_alphabetically_rearrange_regular_case(): assert alphabetically_rearrange(\\"banana apple orange\\") == \\"apple banana orange\\" def test_alphabetically_rearrange_mixed_case(): assert alphabetically_rearrange(\\"Banana apple Orange\\") == \\"apple Banana Orange\\" def test_alphabetically_rearrange_same_word_different_cases(): assert alphabetically_rearrange(\\"Apple apple aPPle\\") == \\"Apple apple aPPle\\" def test_alphabetically_rearrange_numbers_and_words(): assert alphabetically_rearrange(\\"123 apple 456 Banana\\") == \\"123 456 apple Banana\\" def test_alphabetically_rearrange_single_word(): assert alphabetically_rearrange(\\"apple\\") == \\"apple\\" def test_alphabetically_rearrange_empty_string(): assert alphabetically_rearrange(\\"\\") == \\"\\" def test_alphabetically_rearrange_multiple_spaces(): # Since the input is guaranteed to have single space separation, multiple spaces should not occur. assert alphabetically_rearrange(\\"apple banana\\") == \\"apple banana\\"","solution":"def alphabetically_rearrange(s: str) -> str: Takes a string containing multiple words and rearranges them alphabetically, ignoring case sensitivity. Returns the rearranged string with each word separated by a single space. words = s.split() sorted_words = sorted(words, key=lambda x: x.lower()) return ' '.join(sorted_words)"},{"question":"def find_first_unique_character(s: str) -> str: Returns the first non-repeating character in the string s. If all characters are repeated or the string is empty, return None. >>> find_first_unique_character(\\"swiss\\") == \\"w\\" >>> find_first_unique_character(\\"racecars\\") == \\"e\\" >>> find_first_unique_character(\\"aabbcc\\") == None >>> find_first_unique_character(\\"\\") == None >>> find_first_unique_character(\\"a\\") == \\"a\\" >>> find_first_unique_character(\\"aa\\") == None >>> find_first_unique_character(\\"abcabc\\") == None >>> find_first_unique_character(\\"abacabad\\") == \\"c\\" >>> find_first_unique_character(\\"abcdefghij\\") == \\"a\\" >>> find_first_unique_character(\\"aabbccddeeffgghhii\\") == None >>> find_first_unique_character(\\"AaBbCcDdEeFf\\") == \\"A\\"","solution":"def find_first_unique_character(s): Returns the first non-repeating character in the string s. If all characters are repeated or the string is empty, return None. if not s: return None # Count frequency of each character char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character with frequency 1 for char in s: if char_count[char] == 1: return char return None"},{"question":"def find_fixed_point(arr: list) -> int: Finds a fixed point in a sorted array of unique integers using binary search. A fixed point in an array A is an index i such that A[i] is equal to i. If no such point exists, returns -1. Examples: >>> find_fixed_point([-10, -5, 0, 3, 7]) 3 >>> find_fixed_point([0, 2, 5, 8, 17]) 0 >>> find_fixed_point([-10, -5, 3, 4, 7, 9]) -1 from solution import find_fixed_point def test_fixed_point_exists(): assert find_fixed_point([-10, -5, 0, 3, 7]) == 3 assert find_fixed_point([0, 2, 5, 8, 17]) == 0 def test_no_fixed_point(): assert find_fixed_point([-10, -5, 3, 4, 7, 9]) == -1 def test_all_negative_numbers(): assert find_fixed_point([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1]) == -1 def test_all_positive_numbers_no_fixed_point(): assert find_fixed_point([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == -1 def test_single_element_fixed_point(): assert find_fixed_point([0]) == 0 def test_single_element_no_fixed_point(): assert find_fixed_point([1]) == -1","solution":"def find_fixed_point(arr: list) -> int: Finds a fixed point in the array where the value is equal to its index. If no such point exists, returns -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == mid: return mid elif arr[mid] < mid: left = mid + 1 else: right = mid - 1 return -1"},{"question":"from typing import List def rearrange_even_odd(nums: List[int]) -> List[int]: Rearrange the integers in the list so that all even numbers come before the odd numbers, while maintaining their relative order. >>> rearrange_even_odd([3, 1, 2, 4]) [2, 4, 3, 1] >>> rearrange_even_odd([1, 2, 3, 4, 5, 6]) [2, 4, 6, 1, 3, 5] >>> rearrange_even_odd([5, 7, 8, 2, 3, 1]) [8, 2, 5, 7, 3, 1] >>> rearrange_even_odd([1, 3, 5, 7]) [1, 3, 5, 7]","solution":"from typing import List def rearrange_even_odd(nums: List[int]) -> List[int]: Rearrange the integers in the list so that all even numbers come before the odd numbers, while maintaining their relative order. :param nums: List of integers to be rearranged. :return: List of integers with even numbers before odd numbers. evens = [num for num in nums if num % 2 == 0] odds = [num for num in nums if num % 2 != 0] return evens + odds"},{"question":"def pattern_search(grid, pattern): A 2D grid filled with characters is provided, and you need to verify if a specific sequential pattern exists within the grid. The pattern can be formed by tracing characters in the grid through the following movements: 1. Move up one cell. 2. Move down one cell. 3. Move left one cell. 4. Move right one cell. 5. Move diagonally in any of the four possible directions one cell. The starting point can be any cell in the grid, and you cannot revisit a cell within the same pattern sequence. Return True if the pattern is found in the grid, otherwise return False. An empty pattern should return True, and an empty grid returns False. >>> pattern_search([ ... ['a', 'b', 'c', 'd'], ... ['e', 'f', 'g', 'h'], ... ['i', 'j', 'k', 'l'], ... ['m', 'n', 'o', 'p'] ... ], \\"bfk\\") True >>> pattern_search([ ... ['a', 'b', 'c', 'd'], ... ['e', 'f', 'g', 'h'], ... ['i', 'j', 'k', 'l'], ... ['m', 'n', 'o', 'p'] ... ], \\"abcl\\") True >>> pattern_search([ ... ['a', 'b', 'c', 'd'], ... ['e', 'f', 'g', 'h'], ... ['i', 'j', 'k', 'l'], ... ['m', 'n', 'o', 'p'] ... ], \\"abcj\\") False >>> pattern_search([], \\"abc\\") False >>> pattern_search([ ... ['a', 'b', 'c', 'd'], ... ['e', 'f', 'g', 'h'], ... ['i', 'j', 'k', 'l'], ... ['m', 'n', 'o', 'p'] ... ], \\"\\") True","solution":"def pattern_search(grid, pattern): if not pattern: return True if not grid or not grid[0]: return False rows, cols = len(grid), len(grid[0]) def is_valid(x, y, visited): return 0 <= x < rows and 0 <= y < cols and (x, y) not in visited def search(x, y, pattern, visited): if not pattern: return True if not is_valid(x, y, visited) or grid[x][y] != pattern[0]: return False visited.add((x, y)) # Define direction vectors for 8 possible movements: # up, down, left, right, top-left, top-right, bottom-left, bottom-right directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] for dx, dy in directions: if search(x + dx, y + dy, pattern[1:], visited): return True visited.remove((x, y)) return False for i in range(rows): for j in range(cols): if search(i, j, pattern, set()): return True return False"},{"question":"def count_vowels_in_sentences(sentences: List[str]) -> Dict[str, int]: This function takes a list of sentences and returns a dictionary where the keys are the original sentences and the values are the number of vowels in each sentence. >>> count_vowels_in_sentences([\\"Hello World\\"]) {'Hello World': 3} >>> count_vowels_in_sentences([\\"bcdfg\\"]) {'bcdfg': 0} >>> count_vowels_in_sentences([\\"UpperCASE and lowerCASE\\"]) {'UpperCASE and lowerCASE': 9}","solution":"def count_vowels_in_sentences(sentences): This function takes a list of sentences and returns a dictionary where the keys are the original sentences and the values are the number of vowels in each sentence. vowels = set('aeiouAEIOU') def count_vowels(sentence): return sum(1 for char in sentence if char in vowels) return {sentence: count_vowels(sentence) for sentence in sentences}"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Implement a function in Python that takes two strings as input and returns a boolean indicating whether they are anagrams of each other without using any built-in sorting functionalities. The function should not be case-sensitive and should ignore any non-alphanumeric characters in the strings. >>> are_anagrams(\\"Astronomer\\", \\"Moonstarer\\") True >>> are_anagrams(\\"hello\\", \\"bye\\") False >>> are_anagrams(\\"A gentleman\\", \\"Elegant man!!!\\") True","solution":"def are_anagrams(str1, str2): Returns True if the two strings are anagrams of each other (ignoring non-alphanumeric characters and case), otherwise, returns False. def clean_string(s): cleaned = [char.lower() for char in s if char.isalnum()] return cleaned cleaned_str1 = clean_string(str1) cleaned_str2 = clean_string(str2) if len(cleaned_str1) != len(cleaned_str2): return False char_count = {} for char in cleaned_str1: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in cleaned_str2: if char in char_count: char_count[char] -= 1 if char_count[char] < 0: return False else: return False return True"},{"question":"def are_identical_trees(preorder1, preorder2): Determines if two binary trees represented by their preorder traversals are identical. The trees must have the same shape and the same node values at each corresponding position. Args: preorder1 (list): Preorder traversal of the first tree. preorder2 (list): Preorder traversal of the second tree. Returns: bool: True if the trees are structurally identical and their node values match, False otherwise. pass # Unit tests def test_identical_trees(): preorder1 = [1, 2, None, None, 3, None, None] preorder2 = [1, 2, None, None, 3, None, None] assert are_identical_trees(preorder1, preorder2) == True def test_different_trees(): preorder1 = [1, 2, None, None, 3, None, None] preorder2 = [1, 3, None, None, 2, None, None] assert are_identical_trees(preorder1, preorder2) == False def test_same_structure_different_values(): preorder1 = [1, 2, 3, None, None, None, None] preorder2 = [1, 2, 4, None, None, None, None] assert are_identical_trees(preorder1, preorder2) == False def test_different_structure(): preorder1 = [1, 2, None, None, 3, None, None] preorder2 = [1, None, 2, None, 3, None, None] assert are_identical_trees(preorder1, preorder2) == False def test_empty_trees(): preorder1 = [] preorder2 = [] assert are_identical_trees(preorder1, preorder2) == True def test_single_element_trees_same_value(): preorder1 = [1] preorder2 = [1] assert are_identical_trees(preorder1, preorder2) == True def test_single_element_trees_different_value(): preorder1 = [1] preorder2 = [2] assert are_identical_trees(preorder1, preorder2) == False def test_one_empty_one_non_empty(): preorder1 = [] preorder2 = [1, 2, None, None, 3, None, None] assert are_identical_trees(preorder1, preorder2) == False","solution":"def are_identical_trees(preorder1, preorder2): Determines if two binary trees represented by their preorder traversals are identical. The trees must have the same shape and the same node values at each corresponding position. Args: preorder1 (list): Preorder traversal of the first tree. preorder2 (list): Preorder traversal of the second tree. Returns: bool: True if the trees are structurally identical and their node values match, False otherwise. # Helper function to reconstruct tree from preorder traversal def reconstruct(preorder): if not preorder: return None if preorder[0] is None: preorder.pop(0) return None root = preorder.pop(0) node = {'val': root, 'left': None, 'right': None} node['left'] = reconstruct(preorder) node['right'] = reconstruct(preorder) return node # Helper function to compare two binary trees def compare_trees(node1, node2): if node1 is None and node2 is None: return True if node1 is None or node2 is None: return False if node1['val'] != node2['val']: return False return compare_trees(node1['left'], node2['left']) and compare_trees(node1['right'], node2['right']) tree1 = reconstruct(preorder1[:]) tree2 = reconstruct(preorder2[:]) return compare_trees(tree1, tree2)"},{"question":"def sum_of_squares_unique_values(input_dict): Takes a dictionary where keys are strings and values are lists of integers. Returns a new dictionary where each key is mapped to the sum of the squares of the unique values of its original list's elements. >>> sum_of_squares_unique_values({\\"a\\": [1, 2, 2, 4], \\"b\\": [2, 3, 3], \\"c\\": [4, 4, 4]}) == {\\"a\\": 21, \\"b\\": 13, \\"c\\": 16} >>> sum_of_squares_unique_values({}) == {} >>> sum_of_squares_unique_values({\\"a\\": [], \\"b\\": [], \\"c\\": []}) == {\\"a\\": 0, \\"b\\": 0, \\"c\\": 0} >>> sum_of_squares_unique_values({\\"a\\": [5]}) == {\\"a\\": 25} >>> sum_of_squares_unique_values({\\"a\\": [1, 1, 1, 1]}) == {\\"a\\": 1} >>> sum_of_squares_unique_values({\\"a\\": [1, 2, 2, 3], \\"b\\": [9, 9, 9], \\"c\\": [1, 3, 3, 3, 7]}) == {\\"a\\": 14, \\"b\\": 81, \\"c\\": 59} >>> sum_of_squares_unique_values({\\"a\\": [], \\"b\\": [0, 0, 0], \\"c\\": [10, 2, 3]}) == {\\"a\\": 0, \\"b\\": 0, \\"c\\": 113}","solution":"def sum_of_squares_unique_values(input_dict): Takes a dictionary where keys are strings and values are lists of integers. Returns a new dictionary where each key is mapped to the sum of the squares of the unique values of its original list's elements. result = {} for key, values in input_dict.items(): unique_values = set(values) # Get unique values sum_of_squares = sum(x**2 for x in unique_values) # Sum of squares result[key] = sum_of_squares return result"},{"question":"def is_palindrome(s: str) -> bool: Determine whether a given string is a palindrome, ignoring case and non-alphanumeric characters. Parameters: s (str): The string to be checked. Returns: bool: True if the string is a palindrome, False otherwise. >>> is_palindrome(\\"madam\\") True >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"12345\\") False","solution":"import re def is_palindrome(s): Determine whether a given string is a palindrome, ignoring case and non-alphanumeric characters. Parameters: s (str): The string to be checked. Returns: bool: True if the string is a palindrome, False otherwise. # Step 1: Normalize the string by removing non-alphanumeric characters and converting to lowercase. normalized_str = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Step 2: Check if the normalized string is the same forwards and backwards. return normalized_str == normalized_str[::-1]"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression and returns the result as a float. The expression can contain positive and negative integers, addition (+), subtraction (-), multiplication (*), and division (/). The expression may have nested parentheses. Handles division by zero by returning an error message. Example: >>> evaluate_expression(\\"3 + 5\\") == 8.0 >>> evaluate_expression(\\"10 + 2 * 6\\") == 22.0 >>> evaluate_expression(\\"(5 + 3) * 12 / 3\\") == 32.0 >>> evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\") == 100.0 >>> evaluate_expression(\\"100 / (3 - 3)\\") == \\"Error: Division by zero\\" >>> evaluate_expression(\\" 3 + 5 \\") == 8.0 >>> evaluate_expression(\\" 10 * ( 2 + 3 ) \\") == 50.0","solution":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression and returns the result as a float. The expression can contain positive and negative integers, addition (+), subtraction (-), multiplication (*), and division (/). The expression may have nested parentheses. Handles division by zero by returning an error message. def safe_eval(expr): try: return eval(expr) except ZeroDivisionError: return \\"Error: Division by zero\\" # Remove spaces from expression expression = expression.replace(\\" \\", \\"\\") # Use eval to compute the result return safe_eval(expression)"},{"question":"def longestConsecutive(nums: List[int]) -> int: Find the length of the longest consecutive elements sequence in an unsorted integer array. >>> longestConsecutive([100, 4, 200, 1, 3, 2]) 4 >>> longestConsecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) 9 >>> longestConsecutive([]) 0 >>> longestConsecutive([9]) 1 >>> longestConsecutive([1, 2, 2, 3, 4]) 4 >>> longestConsecutive([-1, -2, -3, 0, 1]) 5 >>> longestConsecutive([10, 5, 12, 3, 55, 11, 50, 4]) 3","solution":"def longestConsecutive(nums): if not nums: return 0 nums_set = set(nums) # Use a set for O(1) lookups longest_streak = 0 for num in nums_set: if num - 1 not in nums_set: # Check if it's the start of a sequence current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def word_lengths(input_string: str) -> dict: Given a string of words separated by spaces, return a dictionary where the keys are the distinct words from the string, and the values are the lengths of these words. >>> word_lengths(\\"hello world this is a test\\") {'hello': 5, 'world': 5, 'this': 4, 'is': 2, 'a': 1, 'test': 4} >>> word_lengths(\\"\\") == {} >>> word_lengths(\\"repeat repeat words words\\") == {'repeat': 6, 'words': 5} >>> word_lengths(\\"single\\") == {'single': 6} >>> word_lengths(\\"a ab abc abcd abcde\\") == {'a': 1, 'ab': 2, 'abc': 3, 'abcd': 4, 'abcde': 5} >>> word_lengths(\\"hello world\\") == {'hello': 5, 'world': 5} >>> word_lengths(\\"hello, world!\\") == {'hello,': 6, 'world!': 6}","solution":"def word_lengths(input_string): Takes a string of words separated by spaces and returns a dictionary. The keys are distinct words, and the values are the lengths of these words. words = input_string.split() word_length_dict = {word: len(word) for word in words} return word_length_dict"},{"question":"import pandas as pd def filter_csv(file_path: str, column_name: str, value) -> pd.DataFrame: Loads data from a CSV file and filters rows based on a given condition. Parameters: file_path (str): The path to the CSV file. column_name (str): The name of the column to filter on. value : The value to be used for filtering. Returns: pd.DataFrame: A DataFrame containing the filtered rows. Raises: FileNotFoundError: If the file does not exist. KeyError: If the column name does not exist in the DataFrame. >>> data = {'name': ['Alice', 'Bob', 'Charlie'], 'age': [25, 30, 30]} >>> df = pd.DataFrame(data) >>> df.to_csv('test_file.csv', index=False) >>> filter_csv('test_file.csv', 'age', 30).equals(df[df['age'] == 30]) True","solution":"import pandas as pd def filter_csv(file_path, column_name, value): Loads data from a CSV file and filters rows based on a given condition. Parameters: file_path (str): The path to the CSV file. column_name (str): The name of the column to filter on. value : The value to be used for filtering. Returns: pd.DataFrame: A DataFrame containing the filtered rows. Raises: FileNotFoundError: If the file does not exist. KeyError: If the column name does not exist in the DataFrame. try: # Load data into DataFrame df = pd.read_csv(file_path) # Check if the column name exists if column_name not in df.columns: raise KeyError(f\\"The column '{column_name}' does not exist in the DataFrame.\\") # Filter rows based on the given condition filtered_df = df[df[column_name] == value] return filtered_df except FileNotFoundError: raise FileNotFoundError(f\\"The file '{file_path}' was not found.\\") except KeyError as e: raise e"},{"question":"def fibonacci_sequence(n: int) -> List[int]: Returns a list of the first n numbers in the Fibonacci sequence. >>> fibonacci_sequence(0) [] >>> fibonacci_sequence(1) [0] >>> fibonacci_sequence(2) [0, 1] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> fibonacci_sequence(20) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181]","solution":"def fibonacci_sequence(n): Returns a list of the first n numbers in the Fibonacci sequence. if n <= 0: return [] elif n == 1: return [0] fib_sequence = [0, 1] while len(fib_sequence) < n: fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence[:n]"},{"question":"def is_prime(n): Helper function to determine if a given number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def separate_primes(nums): Takes a list of integers and returns two separate lists: one with prime numbers and one with non-prime numbers. >>> separate_primes([]) == ([], []) >>> separate_primes([2, 3, 5, 7, 11]) == ([2, 3, 5, 7, 11], []) >>> separate_primes([1, 4, 6, 8, 9, 10]) == ([], [1, 4, 6, 8, 9, 10]) >>> separate_primes([2, 4, 6, 7, 9, 13]) == ([2, 7, 13], [4, 6, 9]) primes, non_primes = [], [] for num in nums: if is_prime(num): primes.append(num) else: non_primes.append(num) return primes, non_primes","solution":"def is_prime(n): Helper function to determine if a given number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def separate_primes(nums): Takes a list of integers and returns two separate lists: one with prime numbers and one with non-prime numbers. primes = [] non_primes = [] for num in nums: if is_prime(num): primes.append(num) else: non_primes.append(num) return primes, non_primes"},{"question":"def reverse_words(text: str) -> str: Returns a string with the words in \`text\` reversed. The words are separated by single spaces. >>> reverse_words(\\"hello\\") == \\"hello\\" >>> reverse_words(\\"hello world\\") == \\"world hello\\" >>> reverse_words(\\"python is amazing\\") == \\"amazing is python\\" >>> reverse_words(\\" hello world \\") == \\"world hello\\" >>> reverse_words(\\"\\") == \\"\\" from solution import reverse_words def test_reverse_words_single_word(): assert reverse_words(\\"hello\\") == \\"hello\\" def test_reverse_words_two_words(): assert reverse_words(\\"hello world\\") == \\"world hello\\" def test_reverse_words_multiple_words(): assert reverse_words(\\"python is amazing\\") == \\"amazing is python\\" def test_reverse_words_with_extra_spaces(): # Even though input may have extra spaces, the reverse should be normalized as per split and join behavior. assert reverse_words(\\" hello world \\") == \\"world hello\\" def test_reverse_words_empty_string(): assert reverse_words(\\"\\") == \\"\\"","solution":"def reverse_words(text): Returns a string with the words in \`text\` reversed. The words are separated by single spaces. words = text.split() reversed_words = words[::-1] reversed_text = ' '.join(reversed_words) return reversed_text"},{"question":"def find_median_sorted_arrays(arr1, arr2): Function to find the median of two sorted arrays with overall run-time complexity of O(log(m+n)). :param arr1: List[int] - first sorted array :param arr2: List[int] - second sorted array :return: float - median of the merged sorted arrays Examples: >>> find_median_sorted_arrays([1, 3], [2]) 2.0 >>> find_median_sorted_arrays([1, 2], [3, 4]) 2.5 # Your code here pass def test_find_median_sorted_arrays_odd_length(): assert find_median_sorted_arrays([1, 3], [2]) == 2.0 assert find_median_sorted_arrays([1, 2], [3]) == 2.0 assert find_median_sorted_arrays([0, 0], [0]) == 0.0 def test_find_median_sorted_arrays_even_length(): assert find_median_sorted_arrays([1, 2], [3, 4]) == 2.5 assert find_median_sorted_arrays([1, 3, 5], [2, 4, 6]) == 3.5 def test_find_median_sorted_arrays_with_duplicates(): assert find_median_sorted_arrays([1, 2], [1, 2]) == 1.5 def test_find_median_sorted_arrays_with_empty(): assert find_median_sorted_arrays([], [1]) == 1.0 assert find_median_sorted_arrays([1], []) == 1.0 assert find_median_sorted_arrays([], [1, 2, 3, 4, 5, 6, 7, 8, 9]) == 5.0 def test_find_median_sorted_arrays_large_numbers(): assert find_median_sorted_arrays([1000000], [1000000]) == 1000000.0","solution":"def find_median_sorted_arrays(arr1, arr2): Function to find the median of two sorted arrays. :param arr1: List[int] - first sorted array :param arr2: List[int] - second sorted array :return: float - median of the merged sorted arrays def find_kth(arr1, arr2, k): if not arr1: return arr2[k] if not arr2: return arr1[k] idx1, idx2 = len(arr1) // 2, len(arr2) // 2 med1, med2 = arr1[idx1], arr2[idx2] # When k is bigger than the sum of a and b's median indices if idx1 + idx2 < k: # if med1 is bigger than med2, med2 can't be a kth element if med1 > med2: return find_kth(arr1, arr2[idx2 + 1:], k - idx2 - 1) else: return find_kth(arr1[idx1 + 1:], arr2, k - idx1 - 1) else: # if med1 is less than or equal to med2, med2 can't be a kth element if med1 > med2: return find_kth(arr1[:idx1], arr2, k) else: return find_kth(arr1, arr2[:idx2], k) len_total = len(arr1) + len(arr2) if len_total % 2 == 1: return find_kth(arr1, arr2, len_total // 2) else: return (find_kth(arr1, arr2, len_total // 2 - 1) + find_kth(arr1, arr2, len_total // 2)) / 2.0"},{"question":"import csv import logging from typing import Dict def calculate_average_salary_per_department(csv_file_path: str) -> Dict[str, float]: Reads a CSV file containing employee information and calculates the average salary for each department. This function handles cases where data may be missing or improperly formatted, logging any anomalies encountered. Example: >>> calculate_average_salary_per_department(\\"employees.csv\\") { \\"Engineering\\": 77500.0, \\"Marketing\\": 52500.0, \\"Sales\\": 60000.0 } Parameters: csv_file_path (str): Path to the CSV file. Returns: Dict[str, float]: A dictionary where the keys are department names and values are the average salaries. pass # Unit Tests import pytest def test_calculate_average_salary_per_department(): import tempfile csv_content = ID,Name,Department,Salary,Years of Employment 1,John Doe,Engineering,75000,5 2,Jane Smith,Marketing,55000,3 3,Bob Johnson,Engineering,80000,2 4,Alice White,Sales,60000,4 5,Chris Green,Marketing,50000,6 with tempfile.NamedTemporaryFile(delete=False, mode='w', suffix='.csv') as tmp_file: tmp_file.write(csv_content) tmp_file_path = tmp_file.name result = calculate_average_salary_per_department(tmp_file_path) assert result == { \\"Engineering\\": 77500.0, \\"Marketing\\": 52500.0, \\"Sales\\": 60000.0 } def test_calculate_average_salary_with_invalid_data(): import tempfile csv_content = ID,Name,Department,Salary,Years of Employment 1,John Doe,Engineering,75000,5 2,Jane Smith,Marketing,InvalidSalary,3 3,Bob Johnson,Engineering,80000,2 4,Alice White,Sales,60000,4 5,Chris Green,Marketing,50000,6 6,Wrong Data,,75000,3 with tempfile.NamedTemporaryFile(delete=False, mode='w', suffix='.csv') as tmp_file: tmp_file.write(csv_content) tmp_file_path = tmp_file.name result = calculate_average_salary_per_department(tmp_file_path) assert result == { \\"Engineering\\": 77500.0, \\"Marketing\\": 50000.0, \\"Sales\\": 60000.0 } def test_file_not_found(): result = calculate_average_salary_per_department(\\"non_existent_file.csv\\") assert result == {}","solution":"import csv import logging from typing import Dict def calculate_average_salary_per_department(csv_file_path: str) -> Dict[str, float]: Reads a CSV file containing employee information and calculates the average salary for each department. Parameters: csv_file_path (str): Path to the CSV file. Returns: Dict[str, float]: A dictionary where the keys are department names and values are the average salaries. department_salaries = {} department_counts = {} logging.basicConfig(level=logging.INFO) try: with open(csv_file_path, mode='r') as file: reader = csv.DictReader(file) for row in reader: try: department = row.get('Department') salary = row.get('Salary') if department and salary: salary = float(salary) if department in department_salaries: department_salaries[department] += salary department_counts[department] += 1 else: department_salaries[department] = salary department_counts[department] = 1 else: logging.warning(f\\"Incomplete row data: {row}\\") except ValueError: logging.warning(f\\"Invalid salary value: {row.get('Salary')} in row: {row}\\") except FileNotFoundError: logging.error(f\\"File not found: {csv_file_path}\\") return {} average_salaries = {department: department_salaries[department] / department_counts[department] for department in department_salaries} return average_salaries"},{"question":"def process_numbers(numbers): Returns the sum of the even numbers and the product of the odd numbers in the list. Parameters: numbers (list): A list of integers. Returns: tuple: A tuple containing the sum of the even numbers and the product of the odd numbers. >>> process_numbers([1, 2, 3, 4, 5, -6, -7, 0]) (0, 105) >>> process_numbers([2, 4, 6, 8, 10]) (30, 0) >>> process_numbers([1, 3, 5, 7]) (0, 105) >>> process_numbers([1, 2, 3, 4, -5, 6]) (12, -15) >>> process_numbers([0, 1, 2, 3, 4, 5]) (6, 15) >>> process_numbers([-1, -2, -3, 4]) (2, 3) >>> process_numbers([]) (0, 0) >>> process_numbers([2, 4, 6, 8]) (20, 0) >>> process_numbers([1, 3, 5, 7]) (0, 105)","solution":"def process_numbers(numbers): Returns the sum of the even numbers and the product of the odd numbers in the list. Parameters: numbers (list): A list of integers. Returns: tuple: A tuple containing the sum of the even numbers and the product of the odd numbers. even_sum = 0 odd_product = 1 has_odd = False for num in numbers: if num % 2 == 0: even_sum += num else: odd_product *= num has_odd = True if not has_odd: odd_product = 0 return even_sum, odd_product # Example usage: print(process_numbers([1, 2, 3, 4, 5, -6, -7, 0])) # Output: (0, 105)"},{"question":"def count_characters(s: str) -> dict: Create a dictionary with each unique character from the string as keys and the number of times each character appears in the string as values, ignoring spaces and maintaining case sensitivity. >>> count_characters(\\"Hello World\\") == {'H': 1, 'e': 1, 'l': 3, 'o': 2, 'W': 1, 'r': 1, 'd': 1} >>> count_characters(\\"A\\") == {'A': 1} >>> count_characters(\\"\\") == {} >>> count_characters(\\"a a a\\") == {'a': 3} >>> count_characters(\\"aA\\") == {'a': 1, 'A': 1} >>> count_characters(\\"123 @@@ 123\\") == {'1': 2, '2': 2, '3': 2, '@': 3}","solution":"def count_characters(s): Returns a dictionary with unique characters as keys and their frequency as values, ignoring spaces. char_count = {} for char in s: if char != ' ': if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"def shift_characters(s: str) -> str: Shift each alphabetic character in the string to the next character in the alphabet, with 'z' wrapping around to 'a' and 'Z' wrapping around to 'A'. Non-alphabetic characters remain unchanged. >>> shift_characters(\\"Zoo Keeper!\\") \\"App Lffqfs!\\" >>> shift_characters(\\"abcdxyz\\") \\"bcdeyza\\" >>> shift_characters(\\"XYZABC\\") \\"YZABCD\\" >>> shift_characters(\\"AbCdXyZ\\") \\"BcDeYzA\\" >>> shift_characters(\\"123 Hello 789\\") \\"123 Ifmmp 789\\" >>> shift_characters(\\"Hello, World!\\") \\"Ifmmp, Xpsme!\\" >>> shift_characters(\\"\\") \\"\\"","solution":"def shift_characters(s): Shift each alphabetic character to the next character in the alphabet, wrapping 'z' to 'a' and 'Z' to 'A'. Non-alphabetic characters remain unchanged. result = [] for char in s: if 'a' <= char <= 'z': result.append(chr((ord(char) - ord('a') + 1) % 26 + ord('a'))) elif 'A' <= char <= 'Z': result.append(chr((ord(char) - ord('A') + 1) % 26 + ord('A'))) else: result.append(char) return ''.join(result)"},{"question":"def reverse_words(sentence: str) -> str: Reverses the words in a sentence while preserving the original spaces between the words and at the ends of the sentence. >>> reverse_words(\\"hello world\\") 'world hello' >>> reverse_words(\\"hello world\\") 'world hello' >>> reverse_words(\\" hello world \\") ' world hello ' >>> reverse_words(\\" \\") ' ' >>> reverse_words(\\"\\") '' >>> reverse_words(\\"hello\\") 'hello'","solution":"def reverse_words(sentence): Reverses the words in the sentence while preserving the initial spaces structure. words = sentence.split(' ') reversed_words = [word for word in words[::-1]] return ' '.join(reversed_words)"},{"question":"def find_duplicates(arr: list[int]) -> list[int]: Returns a list containing the elements that appear more than once in the input array. Elements should be presented in the same order they first appear in the input array. >>> find_duplicates([1, 2, 2, 3, 4, 4, 4, 5]) == [2, 4] >>> find_duplicates([10, 20, 20, 30, 40, 50]) == [20] >>> find_duplicates([7, 8, 9, 10]) == [] from solution import find_duplicates def test_no_duplicates(): assert find_duplicates([7, 8, 9, 10]) == [] def test_all_duplicates(): assert find_duplicates([10, 20, 20, 30, 30, 30, 40, 40]) == [20, 30, 40] def test_some_duplicates(): assert find_duplicates([1, 2, 2, 3, 4, 4, 4, 5]) == [2, 4] assert find_duplicates([10, 20, 30, 30, 40, 50]) == [30] def test_mixed_sign_duplicates(): assert find_duplicates([-1, -1, 0, 0, 1, 1]) == [-1, 0, 1] def test_large_input(): assert find_duplicates(list(range(500)) + list(range(250, 500))) == list(range(250, 500)) def test_single_element(): assert find_duplicates([1]) == [] def test_empty_input(): assert find_duplicates([]) == []","solution":"def find_duplicates(arr: list[int]) -> list[int]: Returns a list containing the elements that appear more than once in the input array. Elements should be presented in the same order they first appear in the input array. element_count = {} duplicates = [] for num in arr: if num in element_count: element_count[num] += 1 else: element_count[num] = 1 for num in arr: if element_count[num] > 1: if num not in duplicates: duplicates.append(num) return duplicates"},{"question":"from typing import List, Dict def count_occurrences(nums: List[int]) -> Dict[int, int]: Returns a dictionary where the keys are unique integers from the list, and the values are the number of times each integer appears in the list. >>> count_occurrences([1, 2, 2, 3, 3, 3, 4]) {1: 1, 2: 2, 3: 3, 4: 1} >>> count_occurrences([4, 4, 4, 4]) {4: 4} >>> count_occurrences([7, 8, 9]) {7: 1, 8: 1, 9: 1} >>> count_occurrences([]) {} >>> count_occurrences([5, 5, 5, 5, 5, 5]) {5: 6} >>> count_occurrences([-1, -2, -2, -1, -1]) {-1: 3, -2: 2} >>> count_occurrences([1, -1, 2, -2, 2, -1, 0]) {1: 1, -1: 2, 2: 2, -2: 1, 0: 1}","solution":"def count_occurrences(nums): Returns a dictionary where the keys are unique integers from the list, and the values are the number of times each integer appears in the list. occurrence_dict = {} for num in nums: if num in occurrence_dict: occurrence_dict[num] += 1 else: occurrence_dict[num] = 1 return occurrence_dict"},{"question":"import operator def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression string containing integers and '+', '-', '*', '/' operators with standard precedence rules. Args: expression (str): The input mathematical expression. Returns: float: The result of the evaluated expression. >>> evaluate_expression(\\"3+5*2\\") 13.0 >>> evaluate_expression(\\"100/5+2\\") 22.0 >>> evaluate_expression(\\"5+2*3-1/2\\") 10.5","solution":"import operator def evaluate_expression(expression): Evaluates a mathematical expression string containing integers and '+', '-', '*', '/' operators with standard precedence rules. Args: expression (str): The input mathematical expression. Returns: float: The result of the evaluated expression. # Define the operator precedence ops = {'+': (1, operator.add), '-': (1, operator.sub), '*': (2, operator.mul), '/': (2, operator.truediv)} def parse_expression(expression): Parses the expression and converts it into a list of numbers and operators. num = '' tokens = [] for ch in expression: if ch in '0123456789.': num += ch else: if num: tokens.append(float(num)) num = '' tokens.append(ch) if num: tokens.append(float(num)) return tokens def shunting_yard(parsed_tokens): Transforms infix expression to postfix expression using the shunting-yard algorithm. out_queue = [] op_stack = [] for token in parsed_tokens: if isinstance(token, float): out_queue.append(token) elif token in ops: while (op_stack and op_stack[-1] in ops and ops[token][0] <= ops[op_stack[-1]][0]): out_queue.append(op_stack.pop()) op_stack.append(token) while op_stack: out_queue.append(op_stack.pop()) return out_queue def evaluate_postfix(postfix_tokens): Evaluates a postfix expression. stack = [] for token in postfix_tokens: if isinstance(token, float): stack.append(token) elif token in ops: b = stack.pop() a = stack.pop() stack.append(ops[token][1](a, b)) return stack[0] parsed_tokens = parse_expression(expression) postfix_tokens = shunting_yard(parsed_tokens) return evaluate_postfix(postfix_tokens)"},{"question":"def sum_of_squares_of_even_numbers(numbers: List[int]) -> int: Returns the sum of the squares of the even numbers in the list. If the list is empty, returns 0. Handles negative integers correctly. >>> sum_of_squares_of_even_numbers([1, 2, 3, 4, 5]) 20 >>> sum_of_squares_of_even_numbers([2, 4, 6, 8, 10]) 220 >>> sum_of_squares_of_even_numbers([-1, -2, -3, -4, -5]) 20 >>> sum_of_squares_of_even_numbers([1, 3, 5]) 0 >>> sum_of_squares_of_even_numbers([0, 1, 2, 3, 4]) 20 >>> sum_of_squares_of_even_numbers([]) 0 >>> sum_of_squares_of_even_numbers([3, 7, 11, -3, -7, -11]) 0","solution":"def sum_of_squares_of_even_numbers(numbers): Returns the sum of the squares of the even numbers in the list. If the list is empty, returns 0. return sum(x**2 for x in numbers if x % 2 == 0)"},{"question":"def count_visible_buildings(heights): Returns the count of visible buildings from the left side. A building is visible if it is taller than all the buildings before it. Parameters: heights (list): List of integers representing the heights of buildings. Returns: int: The count of visible buildings. pass def test_no_buildings(): assert count_visible_buildings([]) == 0 def test_single_building(): assert count_visible_buildings([5]) == 1 def test_all_buildings_visible(): assert count_visible_buildings([1, 2, 3, 4, 5]) == 5 def test_no_building_visible(): assert count_visible_buildings([5, 4, 3, 2, 1]) == 1 def test_some_buildings_visible(): assert count_visible_buildings([1, 3, 2, 4, 3]) == 3 assert count_visible_buildings([2, 2, 2, 3]) == 2 def test_tallest_building_visible(): assert count_visible_buildings([3, 1, 4, 1, 5, 9, 2, 6, 5]) == 4","solution":"def count_visible_buildings(heights): Returns the count of visible buildings from the left side. A building is visible if it is taller than all the buildings before it. Parameters: heights (list): List of integers representing the heights of buildings. Returns: int: The count of visible buildings. if not heights: return 0 visible_count = 1 # The first building is always visible max_height = heights[0] for height in heights[1:]: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"class ShoppingCart: A simple e-commerce shopping cart class that allows adding, removing, updating items and calculating total price with discount. Methods ------- add_item(name, price, quantity=1): Adds an item to the cart. remove_item(name): Removes an item from the cart. update_item_quantity(name, quantity): Updates the quantity of an existing item in the cart. get_total_price(): Calculates and returns the total price of items in the cart. apply_discount(discount_percentage): Applies a discount to the total price using a discount code. display_cart(): Displays the content of the cart including item details and total price. # Implementation goes here from solution import ShoppingCart def test_add_item(): cart = ShoppingCart() cart.add_item(\\"Apple\\", 1.0, 3) assert cart.get_total_price() == 3.0 cart.add_item(\\"Apple\\", 1.0, 2) assert cart.get_total_price() == 5.0 def test_remove_item(): cart = ShoppingCart() cart.add_item(\\"Apple\\", 1.0, 3) cart.remove_item(\\"Apple\\") assert cart.get_total_price() == 0.0 def test_update_item_quantity(): cart = ShoppingCart() cart.add_item(\\"Apple\\", 1.0, 3) cart.update_item_quantity(\\"Apple\\", 5) assert cart.get_total_price() == 5.0 cart.update_item_quantity(\\"Apple\\", 0) assert cart.get_total_price() == 0.0 def test_get_total_price(): cart = ShoppingCart() cart.add_item(\\"Apple\\", 1.0, 3) cart.add_item(\\"Banana\\", 0.5, 5) assert cart.get_total_price() == 5.5 def test_apply_discount(): cart = ShoppingCart() cart.add_item(\\"Apple\\", 1.0, 3) cart.add_item(\\"Banana\\", 0.5, 5) discounted_price = cart.apply_discount(10) # 10% discount assert discounted_price == 4.95 def test_display_cart(): cart = ShoppingCart() cart.add_item(\\"Apple\\", 1.0, 3) cart.add_item(\\"Banana\\", 0.5, 5) assert cart.display_cart() == \\"Apple: 1.0 x 3nBanana: 0.5 x 5nTotal price: 5.50\\"","solution":"class ShoppingCart: def __init__(self): self.cart = {} def add_item(self, name, price, quantity=1): if name in self.cart: self.cart[name]['quantity'] += quantity else: self.cart[name] = {'price': price, 'quantity': quantity} def remove_item(self, name): if name in self.cart: del self.cart[name] def update_item_quantity(self, name, quantity): if name in self.cart: self.cart[name]['quantity'] = quantity if self.cart[name]['quantity'] <= 0: del self.cart[name] def get_total_price(self): return sum(item['price'] * item['quantity'] for item in self.cart.values()) def apply_discount(self, discount_percentage): total_price = self.get_total_price() return total_price * ((100 - discount_percentage) / 100) def display_cart(self): cart_contents = [] for name, details in self.cart.items(): cart_contents.append(f\\"{name}: {details['price']} x {details['quantity']}\\") total_price = self.get_total_price() return 'n'.join(cart_contents) + f\\"nTotal price: {total_price:.2f}\\" # Example usage: # cart = ShoppingCart() # cart.add_item(\\"Apple\\", 1.0, 3) # Adds 3 apples, each costs 1.0 # cart.add_item(\\"Banana\\", 0.5, 5) # Adds 5 bananas, each costs 0.5 # print(cart.display_cart()) # cart.update_item_quantity(\\"Apple\\", 5) # Updates the quantity of apples to 5 # print(cart.display_cart()) # cart.apply_discount(10) # Applies a 10% discount to the total price"},{"question":"from typing import Dict class Book: def __init__(self, title: str, author: str, isbn: str): Implement the Book class with attributes for title, author, and ISBN. >>> book = Book(\\"Title1\\", \\"Author1\\", \\"ISBN001\\") >>> book.title 'Title1' >>> book.author 'Author1' >>> book.isbn 'ISBN001' pass class Member: def __init__(self, name: str, member_id: str): Implement the Member class with attributes for name and member ID. >>> member = Member(\\"Member1\\", \\"ID001\\") >>> member.name 'Member1' >>> member.member_id 'ID001' pass class Library: def __init__(self): Implement the Library class which handles collections of books and members and management of book lending. self.books: Dict[str, Book] = {} self.members: Dict[str, Member] = {} self.borrowed_books: Dict[str, str] = {} def add_book(self, book: Book): Adds a book to the library collection. >>> library = Library() >>> book = Book(\\"Title1\\", \\"Author1\\", \\"ISBN001\\") >>> library.add_book(book) >>> \\"ISBN001\\" in library.books True pass def register_member(self, member: Member): Registers a new member in the library. >>> library = Library() >>> member = Member(\\"Member1\\", \\"ID001\\") >>> library.register_member(member) >>> \\"ID001\\" in library.members True pass def lend_book(self, isbn: str, member_id: str): Lends a book to a member. >>> library = Library() >>> book = Book(\\"Title1\\", \\"Author1\\", \\"ISBN001\\") >>> member = Member(\\"Member1\\", \\"ID001\\") >>> library.add_book(book) >>> library.register_member(member) >>> library.lend_book(\\"ISBN001\\", \\"ID001\\") >>> \\"ISBN001\\" in library.borrowed_books True >>> library.borrowed_books[\\"ISBN001\\"] 'ID001' pass def return_book(self, isbn: str): Returns a book to the library. >>> library = Library() >>> book = Book(\\"Title1\\", \\"Author1\\", \\"ISBN001\\") >>> member = Member(\\"Member1\\", \\"ID001\\") >>> library.add_book(book) >>> library.register_member(member) >>> library.lend_book(\\"ISBN001\\", \\"ID001\\") >>> library.return_book(\\"ISBN001\\") >>> \\"ISBN001\\" not in library.borrowed_books True pass","solution":"from typing import Dict class Book: def __init__(self, title: str, author: str, isbn: str): self.title = title self.author = author self.isbn = isbn class Member: def __init__(self, name: str, member_id: str): self.name = name self.member_id = member_id class Library: def __init__(self): self.books: Dict[str, Book] = {} self.members: Dict[str, Member] = {} self.borrowed_books: Dict[str, str] = {} def add_book(self, book: Book): if book.isbn in self.books: raise ValueError(f\\"Book with ISBN {book.isbn} already exists.\\") self.books[book.isbn] = book def register_member(self, member: Member): if member.member_id in self.members: raise ValueError(f\\"Member with ID {member.member_id} already exists.\\") self.members[member.member_id] = member def lend_book(self, isbn: str, member_id: str): if isbn not in self.books: raise ValueError(f\\"Book with ISBN {isbn} does not exist.\\") if member_id not in self.members: raise ValueError(f\\"Member with ID {member_id} does not exist.\\") if isbn in self.borrowed_books: raise ValueError(f\\"Book with ISBN {isbn} is already borrowed.\\") self.borrowed_books[isbn] = member_id def return_book(self, isbn: str): if isbn not in self.borrowed_books: raise ValueError(f\\"Book with ISBN {isbn} is not borrowed.\\") del self.borrowed_books[isbn]"},{"question":"def words_by_length(words: List[str]) -> Dict[int, List[str]]: Returns a dictionary where the keys are lengths of words and the values are lists of words of that length. Ensure the function handles an empty list and words of varying lengths. >>> words_by_length([]) {} >>> words_by_length([\\"apple\\"]) {5: [\\"apple\\"]} >>> words_by_length([\\"cat\\", \\"dog\\", \\"elephant\\", \\"bat\\"]) {3: [\\"cat\\", \\"dog\\", \\"bat\\"], 8: [\\"elephant\\"]} >>> words_by_length([\\"see\\", \\"bee\\", \\"tree\\"]) {3: [\\"see\\", \\"bee\\"], 4: [\\"tree\\"]} >>> words_by_length([\\"a\\", \\"at\\", \\"bat\\", \\"hello\\", \\"world\\", \\"foo\\", \\"bar\\"]) {1: [\\"a\\"], 2: [\\"at\\"], 3: [\\"bat\\", \\"foo\\", \\"bar\\"], 5: [\\"hello\\", \\"world\\"]}","solution":"def words_by_length(words): Returns a dictionary where the keys are lengths of words and the values are lists of words of that length. Parameters: words (list): List of words. Returns: dict: Dictionary with word lengths as keys and lists of words as values. length_dict = {} for word in words: length = word.__len__() if length in length_dict: length_dict[length].append(word) else: length_dict[length] = [word] return length_dict"},{"question":"def filter_and_sort_numbers(input_list: List[Union[str, int]]) -> List[int]: Takes a list of integers and strings, removes any strings that do not represent valid integers, and returns a list of integers sorted in ascending order. >>> filter_and_sort_numbers(['5', '3', '1', 'a', '2', '4']) [1, 2, 3, 4, 5] >>> filter_and_sort_numbers(['10', '3', '1', '20']) [1, 3, 10, 20] >>> filter_and_sort_numbers(['a', 'b', 'c', '%']) [] >>> filter_and_sort_numbers([]) [] >>> filter_and_sort_numbers(['1', 2, '3', 'four', 5, '6']) [1, 2, 3, 5, 6] >>> filter_and_sort_numbers(['-5', '-3', '1', '-1', '-2', '4']) [-5, -3, -2, -1, 1, 4] >>> filter_and_sort_numbers(['2', '2', '1', '1', '3', '3']) [1, 1, 2, 2, 3, 3]","solution":"def filter_and_sort_numbers(input_list): Takes a list of integers and strings, removes any strings that do not represent valid integers, and returns a list of integers sorted in ascending order. result = [] for item in input_list: try: result.append(int(item)) except ValueError: continue return sorted(result)"},{"question":"def dailyTemperatures(temperatures): Calculates the number of days until a warmer temperature. Parameters: temperatures (List[int]): List of daily temperatures. Returns: List[int]: List of days until a warmer temperature. Examples: >>> dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> dailyTemperatures([100, 95, 90, 85, 80]) [0, 0, 0, 0, 0] >>> dailyTemperatures([60, 70, 80]) [1, 1, 0] >>> dailyTemperatures([70, 80, 70, 80, 70]) [1, 0, 1, 0, 0] >>> dailyTemperatures([75]) [0]","solution":"def dailyTemperatures(temperatures): Returns an array where each element represents the number of days until a warmer temperature. If there is no future day with a warmer temperature, return 0 for that day. n = len(temperatures) answer = [0] * n stack = [] # Indices of temperatures list for i, temp in enumerate(temperatures): while stack and temperatures[stack[-1]] < temp: prev_index = stack.pop() answer[prev_index] = i - prev_index stack.append(i) return answer"},{"question":"def evaluate_expression(expression: str) -> float: Evaluate a mathematical expression given as a string input. The expression can contain integers, the addition operator (\`+\`), the subtraction operator (\`-\`), the multiplication operator (\`*\`), and the division operator (\`/\`). The function should handle the correct operator precedence and make use of stacks to evaluate the expression. Additionally, consider and handle any potential division by zero errors gracefully by raising an appropriate exception. >>> evaluate_expression(\\"3+5*2\\") 13.0 >>> evaluate_expression(\\"10+2*6\\") 22.0 >>> evaluate_expression(\\"100*2+12\\") 212.0 >>> evaluate_expression(\\"100*(2+12)/14\\") 100.0 >>> evaluate_expression(\\"10/0\\") Raises ZeroDivisionError: division by zero pass","solution":"def evaluate_expression(expression: str) -> float: def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': if right == 0: raise ZeroDivisionError(\\"division by zero\\") values.append(left / right) def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i] == '(': operators.append(expression[i]) elif expression[i] == ')': while operators and operators[-1] != '(': apply_operator(operators, values) operators.pop() elif expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] in ('+', '-', '*', '/'): while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[-1]"},{"question":"def find_palindromes(strings: list) -> list: Write a program that takes a list of strings and returns a new list containing only the palindromic strings from the original list. A palindromic string is a string that reads the same backward as forward. >>> find_palindromes([\\"level\\", \\"test\\", \\"rotor\\", \\"hello\\", \\"mom\\"]) [\\"level\\", \\"rotor\\", \\"mom\\"] >>> find_palindromes([\\"madam\\", \\"racecar\\", \\"refer\\"]) [\\"madam\\", \\"racecar\\", \\"refer\\"] >>> find_palindromes([]) [] >>> find_palindromes([\\"test\\", \\"hello\\", \\"world\\"]) [] >>> find_palindromes([\\"a\\", \\"b\\", \\"c\\"]) [\\"a\\", \\"b\\", \\"c\\"] >>> find_palindromes([\\"a\\", \\"aa\\", \\"aaa\\", \\"abcd\\"]) [\\"a\\", \\"aa\\", \\"aaa\\"]","solution":"def find_palindromes(strings: list) -> list: Returns a new list containing only the palindromic strings from the original list. return [s for s in strings if s == s[::-1]]"},{"question":"def is_palindrome(s: str) -> bool: Determines if the given string is a valid palindrome, ignoring cases, spaces, and non-alphanumeric characters. :param s: The input string. :return: True if the string is a palindrome, False otherwise. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"race a car\\") == False >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"A\\") == True >>> is_palindrome(\\"!!!\\") == True >>> is_palindrome(\\"No 'x' in Nixon\\") == True >>> is_palindrome(\\"This is not a palindrome\\") == False >>> is_palindrome(\\"12321\\") == True >>> is_palindrome(\\"12345\\") == False","solution":"def is_palindrome(s): Determines if the given string is a valid palindrome, ignoring cases, spaces, and non-alphanumeric characters. :param s: The input string. :return: True if the string is a palindrome, False otherwise. # Filter out non-alphanumeric characters and convert to lower case cleaned_s = ''.join(char.lower() for char in s if char.isalnum()) # Compare the cleaned string with its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"def is_bracket_sequence_valid(s: str) -> bool: Determines whether a given string contains properly nested and matched brackets. The string may include the following types of brackets: (), [], {}, <>. Returns True if the string consists of matching brackets, and False otherwise. >>> is_bracket_sequence_valid(\\"([])<>{}\\") == True >>> is_bracket_sequence_valid(\\"([)]\\") == False >>> is_bracket_sequence_valid(\\"\\") == True","solution":"def is_bracket_sequence_valid(s): Determines whether a given string contains properly nested and matched brackets. Returns True if the string consists of matching brackets, and False otherwise. stack = [] bracket_pair = {')': '(', ']': '[', '}': '{', '>': '<'} for char in s: if char in bracket_pair.values(): # opening brackets stack.append(char) elif char in bracket_pair: # closing brackets if stack and stack[-1] == bracket_pair[char]: stack.pop() else: return False return len(stack) == 0"},{"question":"import random def generate_maze(n: int) -> List[List[int]]: Generates a random maze of size n x n. Paths are denoted by 0 and walls by 1. The starting point is at (0, 0) and the ending point is at (n-1, n-1). pass def is_valid_path(maze: List[List[int]]) -> bool: Checks if there is a valid path from the top-left corner to the bottom-right corner of the maze. Uses Depth-First Search (DFS). >>> maze = [ ... [0, 1, 1], ... [0, 0, 1], ... [1, 0, 0] ... ] >>> is_valid_path(maze) True >>> maze = [ ... [0, 1, 1], ... [1, 0, 1], ... [1, 0, 1] ... ] >>> is_valid_path(maze) False >>> maze = [[0]] >>> is_valid_path(maze) True >>> maze = [ ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 1, 0], ... [1, 1, 0, 0, 0], ... [1, 1, 1, 1, 0] ... ] >>> is_valid_path(maze) True pass","solution":"import random def generate_maze(n): Generates a random maze of size n x n. Paths are denoted by 0 and walls by 1. The starting point is at (0, 0) and the ending point is at (n-1, n-1). maze = [[random.choice([0, 1]) for _ in range(n)] for _ in range(n)] # Ensure the start and end points are paths maze[0][0] = 0 maze[n-1][n-1] = 0 return maze def is_valid_path(maze): Checks if there is a valid path from the top-left corner to the bottom-right corner of the maze. Uses Depth-First Search (DFS). n = len(maze) visited = [[False] * n for _ in range(n)] def dfs(x, y): if x < 0 or y < 0 or x >= n or y >= n or maze[x][y] == 1 or visited[x][y]: return False if x == n-1 and y == n-1: return True visited[x][y] = True # Explore neighbors: right, down, left, up if (dfs(x+1, y) or dfs(x, y+1) or dfs(x-1, y) or dfs(x, y-1)): return True visited[x][y] = False return False return dfs(0, 0)"},{"question":"def max_product(nums): Identify the maximum product of two distinct elements within an array of integers. >>> max_product([5, 6, -2, 3, 11]) 66 >>> max_product([3]) \\"Array must contain at least two elements.\\" try: # Your code here except Exception as e: return str(e)","solution":"def max_product(nums): try: if not nums or len(nums) < 2: raise ValueError(\\"Array must contain at least two elements.\\") # Initialize two max values and two min values max1 = max2 = float('-inf') min1 = min2 = float('inf') for num in nums: if num > max1: max2 = max1 max1 = num elif num > max2: max2 = num if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num return max(max1 * max2, min1 * min2) except Exception as e: return str(e)"},{"question":"def two_sum(nums, target): Find the indices of the two numbers such that they add up to a specific target. Args: nums (list): List of integers. target (int): The target sum. Returns: list: List containing the indices of the two numbers that add up to the target. Example: >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([5, -2, 8, -3], 2) [0, 3] >>> two_sum([-3, 4, 3, 90], 0) [0, 2] >>> two_sum([-1, -2, -3, -4, -5], -8) [2, 4]","solution":"def two_sum(nums, target): Find the indices of the two numbers such that they add up to the target. Args: nums (list): List of integers. target (int): The target sum. Returns: list: List containing the indices of the two numbers that add up to the target. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return []"},{"question":"def separate_and_sort(string: str) -> str: Separates letters and numbers in a string, sorts both, and concatenates them. >>> separate_and_sort(\\"a1b2c3\\") \\"abc123\\" >>> separate_and_sort(\\"bac\\") \\"abc\\" >>> separate_and_sort(\\"321\\") \\"123\\" >>> separate_and_sort(\\"aBcdE1\\") \\"aBcdE1\\" >>> separate_and_sort(\\"a1#b2*c3\\") \\"abc123\\" >>> separate_and_sort(\\"\\") \\"\\"","solution":"def separate_and_sort(string): Separates letters and numbers in a string, sorts both, and concatenates them. letters = sorted([ch for ch in string if ch.isalpha()], key=lambda x: x.lower()) numbers = sorted([ch for ch in string if ch.isdigit()]) return ''.join(letters) + ''.join(numbers)"},{"question":"from typing import List def find_duplicates(nums: List[int]) -> List[int]: Write a Python function \`find_duplicates\` that takes a list of integers and returns a list of duplicate integers present in the input list. The output list should contain each duplicate integer only once, regardless of how many times it appears in the input list. You must preserve the order in which duplicates first appear in the input list. >>> find_duplicates([1, 2, 3, 2, 4, 5, 1, 6, 3]) [2, 1, 3] >>> find_duplicates([5, 4, 3, 2, 1, 1, 2, 3, 4]) [1, 2, 3, 4] >>> find_duplicates([10, 20, 30, 40]) [] >>> find_duplicates([1, 1, 1, 1]) [1] >>> find_duplicates([-1, -2, -3, -2, -1, -1, 2, 2]) [-2, -1, 2] >>> find_duplicates([]) [] >>> find_duplicates([1]) [] >>> find_duplicates([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) []","solution":"def find_duplicates(nums): Returns a list of duplicate integers in the order they first appear. seen = set() duplicates = set() result = [] for num in nums: if num in seen and num not in duplicates: result.append(num) duplicates.add(num) seen.add(num) return result"},{"question":"def sort_products(products: List[Dict[str, Any]]) -> List[Dict[str, Any]]: Sort products by price in ascending order. If two products have the same price, sort them by name in alphabetical order. >>> products = [ ... {\\"name\\": \\"Pencil\\", \\"price\\": 1.5}, ... {\\"name\\": \\"Pen\\", \\"price\\": 1.5}, ... {\\"name\\": \\"Notebook\\", \\"price\\": 2.5}, ... {\\"name\\": \\"Eraser\\", \\"price\\": 0.5} ... ] >>> sort_products(products) [ {\\"name\\": \\"Eraser\\", \\"price\\": 0.5}, {\\"name\\": \\"Pen\\", \\"price\\": 1.5}, {\\"name\\": \\"Pencil\\", \\"price\\": 1.5}, {\\"name\\": \\"Notebook\\", \\"price\\": 2.5} ] from typing import List, Dict, Any def test_sort_products(): products = [ {\\"name\\": \\"Pencil\\", \\"price\\": 1.5}, {\\"name\\": \\"Pen\\", \\"price\\": 1.5}, {\\"name\\": \\"Notebook\\", \\"price\\": 2.5}, {\\"name\\": \\"Eraser\\", \\"price\\": 0.5} ] sorted_products = sort_products(products) expected = [ {\\"name\\": \\"Eraser\\", \\"price\\": 0.5}, {\\"name\\": \\"Pen\\", \\"price\\": 1.5}, {\\"name\\": \\"Pencil\\", \\"price\\": 1.5}, {\\"name\\": \\"Notebook\\", \\"price\\": 2.5} ] assert sorted_products == expected def test_sort_products_with_unique_prices(): products = [ {\\"name\\": \\"Apple\\", \\"price\\": 3.0}, {\\"name\\": \\"Banana\\", \\"price\\": 1.0}, {\\"name\\": \\"Cherry\\", \\"price\\": 2.0} ] sorted_products = sort_products(products) expected = [ {\\"name\\": \\"Banana\\", \\"price\\": 1.0}, {\\"name\\": \\"Cherry\\", \\"price\\": 2.0}, {\\"name\\": \\"Apple\\", \\"price\\": 3.0} ] assert sorted_products == expected def test_sort_products_with_same_names(): products = [ {\\"name\\": \\"Apple\\", \\"price\\": 2.0}, {\\"name\\": \\"Apple\\", \\"price\\": 1.0}, {\\"name\\": \\"Apple\\", \\"price\\": 3.0} ] sorted_products = sort_products(products) expected = [ {\\"name\\": \\"Apple\\", \\"price\\": 1.0}, {\\"name\\": \\"Apple\\", \\"price\\": 2.0}, {\\"name\\": \\"Apple\\", \\"price\\": 3.0} ] assert sorted_products == expected def test_sort_products_with_same_prices_names(): products = [ {\\"name\\": \\"Apple\\", \\"price\\": 1.0}, {\\"name\\": \\"Banana\\", \\"price\\": 1.0}, {\\"name\\": \\"Cherry\\", \\"price\\": 1.0}, {\\"name\\": \\"Date\\", \\"price\\": 2.0} ] sorted_products = sort_products(products) expected = [ {\\"name\\": \\"Apple\\", \\"price\\": 1.0}, {\\"name\\": \\"Banana\\", \\"price\\": 1.0}, {\\"name\\": \\"Cherry\\", \\"price\\": 1.0}, {\\"name\\": \\"Date\\", \\"price\\": 2.0} ] assert sorted_products == expected","solution":"def sort_products(products): Sort products by price in ascending order. If two products have the same price, sort them by name in alphabetical order. return sorted(products, key=lambda x: (x['price'], x['name']))"},{"question":"def remove_vowels(s: str) -> str: Create a function that accepts a string and returns the string with all its vowels removed. For this assignment, consider 'a', 'e', 'i', 'o', 'u' as vowels and ignore case sensitivity. >>> remove_vowels(\\"Beautiful Day\\") == \\"Btfl Dy\\" >>> remove_vowels(\\"Hello World\\") == \\"Hll Wrld\\" >>> remove_vowels(\\"AEIOUaeiou\\") == \\"\\" >>> remove_vowels(\\"Python Programming\\") == \\"Pythn Prgrmmng\\" >>> remove_vowels(\\"\\") == \\"\\" >>> remove_vowels(\\"Python 3.9\\") == \\"Pythn 3.9\\" >>> remove_vowels(\\"T3st!ng, 1, 2, 3...\\") == \\"T3st!ng, 1, 2, 3...\\" >>> remove_vowels(\\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\\") == \\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\\"","solution":"def remove_vowels(s): Removes all vowels from the input string s, ignoring case sensitivity. Parameters: - s: str, the input string Returns: - str, the string with all vowels removed vowels = 'aeiouAEIOU' return ''.join([char for char in s if char not in vowels])"},{"question":"def is_palindrome_permutation(s: str) -> bool: Check if any permutation of the given input string can form a palindrome. The function should ignore case, non-alphabetic characters, and check character frequencies. >>> is_palindrome_permutation(\\"Tact Coa\\") # True because one permutation of the string can form the palindrome \\"taco cat\\". True >>> is_palindrome_permutation(\\"Hello\\") # False because no permutation can form a palindrome. False # Example usages: print(is_palindrome_permutation(\\"Tact Coa\\")) # Output: True print(is_palindrome_permutation(\\"Hello\\")) # Output: False # Unit Tests def test_is_palindrome_permutation(): assert is_palindrome_permutation(\\"Tact Coa\\") == True assert is_palindrome_permutation(\\"Able was I ere I saw Elba\\") == True assert is_palindrome_permutation(\\"A man, a plan, a canal, Panama\\") == True assert is_palindrome_permutation(\\"Hello\\") == False assert is_palindrome_permutation(\\"abcdef\\") == False assert is_palindrome_permutation(\\"a\\") == True assert is_palindrome_permutation(\\"\\") == True assert is_palindrome_permutation(\\"No lemon, no melon!\\") == True","solution":"def is_palindrome_permutation(s: str) -> bool: # Remove non-alphabetic characters and convert to lower case cleaned_s = ''.join(char.lower() for char in s if char.isalpha()) # Count the frequency of each character char_count = {} for char in cleaned_s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # A string can form a palindrome if at most one character has an odd frequency odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 return odd_count <= 1"},{"question":"import sqlite3 from typing import List, Dict def classify_students(students: List[Dict]) -> List[Dict]: Classify students as 'Pass' or 'Fail' based on their average grade. Args: students (list): A list of dictionaries, each containing 'name', 'age', and 'grades'. Returns: list: A list of dictionaries containing 'name' and 'classification'. >>> classify_students([{'name': 'Alice', 'age': 20, 'grades': [70, 80, 90]}]) [{'name': 'Alice', 'classification': 'Pass'}] >>> classify_students([{'name': 'Bob', 'age': 22, 'grades': [50, 50, 50]}]) [{'name': 'Bob', 'classification': 'Fail'}] def save_to_database(name: str, average_grade: float, classification: str): Save student classification results to an SQLite database. Args: name (str): Student's name. average_grade (float): Calculated average grade of the student. classification (str): 'Pass' or 'Fail' classification.","solution":"import sqlite3 def classify_students(students): Classify students as 'Pass' or 'Fail' based on their average grade. Args: students (list): A list of dictionaries, each containing 'name', 'age', and 'grades'. Returns: list: A list of dictionaries containing 'name' and 'classification'. results = [] for student in students: name = student['name'] grades = student['grades'] average_grade = sum(grades) / len(grades) if grades else 0 if average_grade >= 60: classification = 'Pass' else: classification = 'Fail' results.append({'name': name, 'classification': classification}) save_to_database(name, average_grade, classification) return results def save_to_database(name, average_grade, classification): Save student classification results to an SQLite database. Args: name (str): Student's name. average_grade (float): Calculated average grade of the student. classification (str): 'Pass' or 'Fail' classification. connection = None try: connection = sqlite3.connect('students.db') cursor = connection.cursor() # Create table if not exists cursor.execute('''CREATE TABLE IF NOT EXISTS student_classification ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, average_grade REAL NOT NULL, classification TEXT NOT NULL)''') # Insert data cursor.execute('''INSERT INTO student_classification (name, average_grade, classification) VALUES (?, ?, ?)''', (name, average_grade, classification)) # Commit transaction connection.commit() except sqlite3.Error as e: print(f\\"Database error: {e}\\") finally: if connection: connection.close()"},{"question":"def are_parentheses_balanced(s: str) -> bool: Write a Python function that takes a string containing only parentheses characters '(' and ')' and determines if the parentheses are balanced. The function should return a boolean indicating whether the given string is balanced. Args: s (str): A string containing only the characters '(' and ')' Returns: bool: True if the parentheses are balanced, False otherwise >>> are_parentheses_balanced(\\"()\\") True >>> are_parentheses_balanced(\\"(())\\") True >>> are_parentheses_balanced(\\"(()(()))\\") True >>> are_parentheses_balanced(\\"(\\") False >>> are_parentheses_balanced(\\")\\") False >>> are_parentheses_balanced(\\"(()\\") False >>> are_parentheses_balanced(\\"())\\") False >>> are_parentheses_balanced(\\"(()))(()\\") False >>> are_parentheses_balanced(\\"\\") True","solution":"def are_parentheses_balanced(s): Determines if the parentheses in the given string are balanced. Args: s (str): A string containing only the characters '(' and ')' Returns: bool: True if the parentheses are balanced, False otherwise stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if len(stack) == 0: return False stack.pop() return len(stack) == 0"},{"question":"from typing import Set def unique_substrings(s: str) -> Set[str]: Create a Python function that takes a string as input and returns a set of all unique substrings that can be formed from it. A substring is defined as any sequence of consecutive characters within the string. >>> unique_substrings(\\"\\") == set() >>> unique_substrings(\\"a\\") == {\\"a\\"} >>> unique_substrings(\\"aa\\") == {\\"a\\", \\"aa\\"} >>> unique_substrings(\\"abc\\") == {\\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", \\"abc\\"} >>> unique_substrings(\\"aba\\") == {\\"a\\", \\"b\\", \\"ab\\", \\"ba\\", \\"aba\\"}","solution":"def unique_substrings(s): Returns a set of all unique substrings that can be formed from the input string. substrings = set() n = len(s) for start in range(n): for end in range(start+1, n+1): substrings.add(s[start:end]) return substrings"},{"question":"from typing import List def trapWater(heights: List[int]) -> int: Compute the maximum amount of water that can be trapped between the pillars after a rain. Args: heights (List[int]): A list of positive integers representing the heights of pillars. Returns: int: The maximum amount of water trapped. Examples: >>> trapWater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trapWater([4, 2, 0, 3, 2, 5]) 9","solution":"def trapWater(heights): Returns the maximum amount of water that can be trapped after raining. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def can_be_palindrome(s: str) -> bool: Determines whether any permutation of the characters in a given string can form a palindrome. >>> can_be_palindrome(\\"racecar\\") True >>> can_be_palindrome(\\"aabbcc\\") True >>> can_be_palindrome(\\"abc\\") False","solution":"def can_be_palindrome(s: str) -> bool: Determines whether any permutation of the characters in the given string can form a palindrome. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # A string can be permuted to form a palindrome if it has at most one character with an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def sum_of_evens(start: int, end: int) -> int: Calculate the sum of all even numbers in an inclusive numerical range between two given integers. Parameters: start (int): The starting integer of the range. end (int): The ending integer of the range. Returns: int: The sum of all even numbers in the specified range. >>> sum_of_evens(2, 10) 30 >>> sum_of_evens(4, 4) 4 >>> sum_of_evens(5, 5) 0 >>> sum_of_evens(10, 2) 0 >>> sum_of_evens(3, 5) 4 >>> sum_of_evens(1, 100) 2550","solution":"def sum_of_evens(start, end): Calculate the sum of all even numbers in an inclusive numerical range between two given integers. Parameters: start (int): The starting integer of the range. end (int): The ending integer of the range. Returns: int: The sum of all even numbers in the specified range. if start > end: return 0 if start % 2 != 0: start += 1 if end % 2 != 0: end -= 1 if start > end: return 0 number_of_evens = (end - start) // 2 + 1 return number_of_evens * (start + end) // 2"},{"question":"def find_pair_with_sum(arr: list, target: int) -> tuple: Returns the indices of the two distinct elements in the array that add up to the target integer. If no such pair exists, returns (-1, -1). >>> find_pair_with_sum([2, 7, 11, 15], 9) (0, 1) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) (-1, -1) >>> find_pair_with_sum([-1, -2, -3, -4, -5], -8) (2, 4) >>> find_pair_with_sum([0, 2, 4, 0], 0) (0, 3) >>> find_pair_with_sum([1, 1, 1, 1], 2) (0, 1) >>> find_pair_with_sum([-3, 4, 3, 90], 0) (0, 2) >>> find_pair_with_sum([3, 3], 6) (0, 1) >>> find_pair_with_sum([1, 2, 3, 4], 8) (-1, -1) >>> find_pair_with_sum([2, 5, 7, 11], 50) (-1, -1) >>> find_pair_with_sum([1, 2], 3) (0, 1) >>> find_pair_with_sum([1, 2], 2) (-1, -1) >>> find_pair_with_sum([1000000000, -1000000000], 0) (0, 1) >>> find_pair_with_sum([0, 0], 1) (-1, -1) pass","solution":"def find_pair_with_sum(arr: list, target: int) -> tuple: Returns the indices of the two distinct elements in the array that add up to the target integer. If no such pair exists, returns (-1, -1). num_to_index = {} for i, num in enumerate(arr): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return (-1, -1)"},{"question":"class CloudStorage: Simulates a simple cloud storage system capable of handling multiple users with operations for uploading, downloading, and deleting files within user-specific storage space. Methods: - register_user(username): Registers a new user. - upload_file(username, file_name, file_content): Uploads a file for a user. - download_file(username, file_name): Downloads a file for a user. - delete_file(username, file_name): Deletes a file for a user. - list_files(username): Lists all files for a user. raise ValueError for: - Attempting to register a user with a taken username. - Trying to upload/download/delete a file without an existing user. def __init__(self): Initializes the CloudStorage with necessary data structures. pass def register_user(self, username): Registers a new user if the username is not already taken. >>> cloud_storage = CloudStorage() >>> cloud_storage.register_user(\\"test_user\\") >>> cloud_storage.register_user(\\"test_user\\") # Should raise ValueError pass def upload_file(self, username, file_name, file_content): Uploads a file for a user. >>> cloud_storage = CloudStorage() >>> cloud_storage.register_user(\\"test_user\\") >>> cloud_storage.upload_file(\\"test_user\\", \\"file.txt\\", \\"content\\") >>> cloud_storage.upload_file(\\"non_existent_user\\", \\"file.txt\\", \\"content\\") # Should raise ValueError pass def download_file(self, username, file_name): Downloads a file for a user. >>> cloud_storage = CloudStorage() >>> cloud_storage.register_user(\\"test_user\\") >>> cloud_storage.upload_file(\\"test_user\\", \\"file.txt\\", \\"content\\") >>> cloud_storage.download_file(\\"test_user\\", \\"file.txt\\") == \\"content\\" >>> cloud_storage.download_file(\\"non_existent_user\\", \\"file.txt\\") # Should raise ValueError >>> cloud_storage.download_file(\\"test_user\\", \\"non_existent_file.txt\\") # Should raise ValueError pass def delete_file(self, username, file_name): Deletes a file for a user. >>> cloud_storage = CloudStorage() >>> cloud_storage.register_user(\\"test_user\\") >>> cloud_storage.upload_file(\\"test_user\\", \\"file.txt\\", \\"content\\") >>> cloud_storage.delete_file(\\"test_user\\", \\"file.txt\\") >>> cloud_storage.delete_file(\\"non_existent_user\\", \\"file.txt\\") # Should raise ValueError >>> cloud_storage.delete_file(\\"test_user\\", \\"non_existent_file.txt\\") # Should raise ValueError pass def list_files(self, username): Lists all files for a user. >>> cloud_storage = CloudStorage() >>> cloud_storage.register_user(\\"test_user\\") >>> cloud_storage.upload_file(\\"test_user\\", \\"file1.txt\\", \\"content1\\") >>> cloud_storage.upload_file(\\"test_user\\", \\"file2.txt\\", \\"content2\\") >>> sorted(cloud_storage.list_files(\\"test_user\\")) == [\\"file1.txt\\", \\"file2.txt\\"] >>> cloud_storage.list_files(\\"non_existent_user\\") # Should raise ValueError pass","solution":"class CloudStorage: def __init__(self): self.users = {} # Dictionary to store user data keyed by username def register_user(self, username): if username in self.users: raise ValueError(\\"Username already taken.\\") self.users[username] = {} # Each user has their own dictionary to store files def upload_file(self, username, file_name, file_content): if username not in self.users: raise ValueError(\\"User does not exist.\\") self.users[username][file_name] = file_content def download_file(self, username, file_name): if username not in self.users: raise ValueError(\\"User does not exist.\\") if file_name not in self.users[username]: raise ValueError(\\"File does not exist.\\") return self.users[username][file_name] def delete_file(self, username, file_name): if username not in self.users: raise ValueError(\\"User does not exist.\\") if file_name not in self.users[username]: raise ValueError(\\"File does not exist.\\") del self.users[username][file_name] def list_files(self, username): if username not in self.users: raise ValueError(\\"User does not exist.\\") return list(self.users[username].keys()) # Example Usage cloud_storage = CloudStorage() cloud_storage.register_user(\\"alice\\") cloud_storage.upload_file(\\"alice\\", \\"file1.txt\\", \\"Hello, World!\\") print(cloud_storage.download_file(\\"alice\\", \\"file1.txt\\")) # Output: \\"Hello, World!\\" cloud_storage.delete_file(\\"alice\\", \\"file1.txt\\") print(cloud_storage.list_files(\\"alice\\")) # Output: []"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Returns indices of the two numbers that add up to the target value. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([1, 2, 3, 4], 8) [] >>> two_sum([1, 1, 1, 1], 2) [0, 1] >>> two_sum([-3, 4, 3, 90], 0) [0, 2]","solution":"def two_sum(nums, target): Returns indices of the two numbers that add up to the target value. :param nums: List of integers :param target: Target sum :return: List of indices of the two numbers num_map = {} for i, num in enumerate(nums): if target - num in num_map: return [num_map[target - num], i] num_map[num] = i return []"},{"question":"from typing import List, Tuple def find_triplet(nums: List[int], target: int) -> Tuple[int, int, int]: Returns a triplet in the list of integers \`nums\` that sum up to \`target\`. If no such triplet exists, return an empty tuple. >>> find_triplet([1, 2, 3, 4, 5, 6], 10) (1, 3, 6) >>> find_triplet([1, 2, 3, 4, 5, 6], 20) ()","solution":"def find_triplet(nums, target): Returns a triplet in the list of integers \`nums\` that sum up to \`target\`. If no such triplet exists, returns an empty tuple. nums.sort() n = len(nums) for i in range(n - 2): # Avoid duplicates for the first element if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == target: return (nums[i], nums[left], nums[right]) elif total < target: left += 1 else: right -= 1 return () # Example usage: # result = find_triplet([1, 2, 3, 4, 5, 6], 10) # print(result) # Output: (1, 3, 6)"},{"question":"def min_operations_to_transform(src: str, tgt: str) -> int: Calculate the minimum number of operations required to transform src into tgt. Given two strings, src and tgt, determine the minimum number of operations (insert, delete, replace) required to transform src into tgt. Parameters: src (str): The source string. tgt (str): The target string. Returns: int: The minimum number of operations. Example: >>> min_operations_to_transform(\\"kitten\\", \\"sitting\\") 3 >>> min_operations_to_transform(\\"flaw\\", \\"lawn\\") 2","solution":"def min_operations_to_transform(src: str, tgt: str) -> int: Calculate the minimum number of operations required to transform src into tgt. Parameters: src (str): The source string. tgt (str): The target string. Returns: int: The minimum number of operations. m, n = len(src), len(tgt) # Create a DP table dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the DP table for i in range(m + 1): dp[i][0] = i # src to empty string for j in range(n + 1): dp[0][j] = j # empty string to tgt # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if src[i - 1] == tgt[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min( dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1] # Replacement ) + 1 return dp[m][n]"},{"question":"def longest_palindrome(input_string: str) -> str: Returns the longest palindrome that can be constructed by rearranging the characters of the input string. If no palindrome can be constructed, returns an empty string. >>> longest_palindrome(\\"aabbcc\\") in [\\"abccba\\", \\"bccabb\\", \\"accbba\\", \\"cabbac\\", \\"baccab\\", \\"ccbbaa\\"] True >>> longest_palindrome(\\"aaaa\\") == \\"aaaa\\" True >>> longest_palindrome(\\"aabbc\\") == \\"abcba\\" True >>> longest_palindrome(\\"abc\\") == \\"\\" True >>> longest_palindrome(\\"\\") == \\"\\" True >>> longest_palindrome(\\"aabb!!\\") in [\\"!aabb!\\", \\"ba!!ab\\", \\"ab!!ba\\"] True >>> longest_palindrome(\\"abcdef\\") == \\"\\" True","solution":"from collections import Counter def longest_palindrome(input_string): Returns the longest palindrome that can be constructed by rearranging the characters of the input string. If no palindrome can be constructed, returns an empty string. char_count = Counter(input_string) mid_char = \\"\\" halves = [] for char, count in char_count.items(): if count % 2 == 1: if mid_char: return \\"\\" # More than one character with an odd count means no palindrome can be formed mid_char = char halves.append(char * (count // 2)) left_half = ''.join(halves) return left_half + mid_char + left_half[::-1] # Constructing the palindrome"},{"question":"from typing import List def even_numbers_multiplied_by_index(lst: List[int]) -> List[int]: Write a function that takes a list of integers and returns another list containing only the even numbers, but each of them should be multiplied by their respective index in the original list. >>> even_numbers_multiplied_by_index([2, 3, 4, 5]) [0, 8] >>> even_numbers_multiplied_by_index([1, 3, 5, 7]) == [] >>> even_numbers_multiplied_by_index([2, 4, 6, 8]) == [0, 4, 12, 24] def test_even_numbers_multiplied_by_index_all_even(): assert even_numbers_multiplied_by_index([2, 4, 6, 8]) == [0, 4, 12, 24] def test_even_numbers_multiplied_by_index_mixed_numbers(): assert even_numbers_multiplied_by_index([2, 3, 4, 5]) == [0, 8] def test_even_numbers_multiplied_by_index_no_even_numbers(): assert even_numbers_multiplied_by_index([1, 3, 5, 7]) == [] def test_even_numbers_multiplied_by_index_empty_list(): assert even_numbers_multiplied_by_index([]) == [] def test_even_numbers_multiplied_by_index_single_element_even(): assert even_numbers_multiplied_by_index([2]) == [0] def test_even_numbers_multiplied_by_index_single_element_odd(): assert even_numbers_multiplied_by_index([1]) == []","solution":"def even_numbers_multiplied_by_index(lst): Returns a list containing only the even numbers from the input list, each multiplied by their respective index in the original list. return [value * index for index, value in enumerate(lst) if value % 2 == 0]"},{"question":"def largest_number(arr): Create a Python function that takes an unordered list of integers and rearranges them into the largest possible number. Returns the largest possible number that can be formed from the integers in the list. >>> largest_number([54, 546, 548, 60]) == \\"6054854654\\" >>> largest_number([5, 9, 3, 2, 1]) == \\"95321\\" >>> largest_number([60, 6, 0, 0]) == \\"66000\\" >>> largest_number([0, 0, 0]) == \\"0\\" >>> largest_number([111, 111]) == \\"111111\\" >>> largest_number([3, 30, 34, 5, 9]) == \\"9534330\\" >>> largest_number([]) == \\"\\" >>> largest_number([10]) == \\"10\\"","solution":"from functools import cmp_to_key def largest_number(arr): Returns the largest possible number that can be formed from the integers in the list. if not arr: return \\"\\" # Convert all integers to strings for comparison arr = list(map(str, arr)) # Custom comparator to sort the numbers to form the largest number def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Sort the array using the custom comparator arr.sort(key=cmp_to_key(compare)) # Concatenate sorted array into a single string result = ''.join(arr) # Handle case where there might be leading zeros (e.g., [0, 0]) return result if result[0] != '0' else '0'"},{"question":"class TimeConverter: A class to handle conversions and calculations of different time units. def hours_to_minutes(self, hours: int) -> int: Convert hours to minutes. >>> TimeConverter().hours_to_minutes(1) 60 >>> TimeConverter().hours_to_minutes(3) 180 def minutes_to_seconds(self, minutes: int) -> int: Convert minutes to seconds. >>> TimeConverter().minutes_to_seconds(1) 60 >>> TimeConverter().minutes_to_seconds(15) 900 def add_times(self, time1: str, time2: str) -> str: Add two times in the format \\"HH:MM:SS\\". >>> TimeConverter().add_times(\\"01:45:30\\", \\"02:30:45\\") \\"04:16:15\\" >>> TimeConverter().add_times(\\"23:59:59\\", \\"00:00:01\\") \\"24:00:00\\" def is_valid_time(self, time: str) -> bool: Check if a string is a valid time of the format \\"HH:MM:SS\\". >>> TimeConverter().is_valid_time(\\"23:59:59\\") True >>> TimeConverter().is_valid_time(\\"24:00:00\\") False","solution":"class TimeConverter: def hours_to_minutes(self, hours: int) -> int: return hours * 60 def minutes_to_seconds(self, minutes: int) -> int: return minutes * 60 def add_times(self, time1: str, time2: str) -> str: h1, m1, s1 = map(int, time1.split(':')) h2, m2, s2 = map(int, time2.split(':')) seconds = s1 + s2 minutes = m1 + m2 + seconds // 60 hours = h1 + h2 + minutes // 60 return f\\"{hours:02}:{minutes % 60:02}:{seconds % 60:02}\\" def is_valid_time(self, time: str) -> bool: if len(time) != 8 or time[2] != ':' or time[5] != ':': return False h, m, s = time.split(':') return h.isdigit() and m.isdigit() and s.isdigit() and 0 <= int(h) < 24 and 0 <= int(m) < 60 and 0 <= int(s) < 60"},{"question":"from typing import List def three_sum(nums: List[int]) -> List[List[int]]: Given a list of unsorted integers, identify and return all unique triplets in the list which give the sum of zero. The function should not return duplicate triplets. Args: nums (List[int]): A list of integers. Returns: List[List[int]]: A list of lists containing unique triplets that sum up to zero. Examples: >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([1, 2, 3, 4]) [] >>> three_sum([0, 0, 0, 0]) [[0, 0, 0]] >>> three_sum([-2, 0, 1, 1, 2]) [[-2, 0, 2], [-2, 1, 1]] >>> three_sum([-4, -2, -2, -2, 0, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5]) [[-4, 0, 4], [-4, 1, 3], [-4, 2, 2], [-2, -2, 4], [-2, 0, 2]]","solution":"def three_sum(nums): Returns a list of all unique triplets in the list which gives the sum of zero. nums.sort() result = [] n = len(nums) for i in range(n): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return result"},{"question":"from typing import List def is_prime(n: int) -> bool: Determine if n is a prime number. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(5) == True >>> is_prime(16) == False >>> is_prime(17) == True >>> is_prime(1) == False >>> is_prime(0) == False >>> is_prime(-3) == False def filter_primes(lst: List[int]) -> List[int]: Returns a list containing only the prime numbers from the input list. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) == [2, 3, 5, 7] >>> filter_primes([1, 4, 6, 8, 10]) == [] >>> filter_primes([2, 3, 5, 7, 11, 13, 17, 19]) == [2, 3, 5, 7, 11, 13, 17, 19] >>> filter_primes([29, 30, 35, 37]) == [29, 37] >>> filter_primes([]) == [] >>> filter_primes([1, 2**31 - 1]) == [2**31 - 1] # 2^31 - 1 (Mersenne prime) is a prime","solution":"from typing import List def is_prime(n: int) -> bool: Determine if n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(lst: List[int]) -> List[int]: Returns a list containing only the prime numbers from the input list. return [x for x in lst if is_prime(x)]"},{"question":"def get_even_index_values(int_list: list[int]) -> list[int]: Returns a new list containing the values at even index positions from the input list. >>> get_even_index_values([10, 20, 30, 40, 50, 60]) == [10, 30, 50] >>> get_even_index_values([]) == [] >>> get_even_index_values([10]) == [10] >>> get_even_index_values([10, 20]) == [10] >>> get_even_index_values(list(range(100))) == list(range(0, 100, 2)) >>> get_even_index_values([-10, -20, -30, -40, -50, -60]) == [-10, -30, -50] >>> get_even_index_values([1, -2, 3, -4, 5, -6, 7, -8]) == [1, 3, 5, 7]","solution":"def get_even_index_values(int_list): Returns a new list containing the values at even index positions from the input list. Parameters: int_list (list of int): List of integers Returns: list of int: List of integers at even index positions return int_list[0::2]"},{"question":"import pandas as pd def create_employee_df(): Create a DataFrame containing the data for a company's employees, including columns for 'Name', 'Age', 'Department', and 'Salary'. The data should include at least 10 employees. Returns: pd.DataFrame: A DataFrame containing employee data # (Provide implementation here) def calculate_average_salary_by_department(df): Calculate the average salary of employees within each department and returns a new DataFrame with the department names and their corresponding average salaries. Handle any missing salary data by filling it with the average salary of all employees before performing the calculation. Args: df (pd.DataFrame): DataFrame containing the employee data Returns: pd.DataFrame: A DataFrame containing department names and average salaries # (Provide implementation here) def test_create_employee_df(): df = create_employee_df() assert not df.empty, \\"DataFrame is empty\\" assert list(df.columns) == ['Name', 'Age', 'Department', 'Salary'], \\"Columns are not correct\\" assert len(df) == 10, \\"DataFrame does not contain 10 employees\\" def test_calculate_average_salary_by_department(): df = create_employee_df() # Adding check for missing salaries filled avg_salary = df['Salary'].mean() df['Salary'].fillna(avg_salary, inplace=True) result = calculate_average_salary_by_department(df) assert not result.empty, \\"Result DataFrame is empty\\" assert list(result.columns) == ['Department', 'AverageSalary'], \\"Columns are not correct\\" assert len(result) == 3, \\"Result DataFrame does not have correct number of departments\\" # Checking correctness of average salaries hr_avg_salary = df[df['Department'] == 'HR']['Salary'].mean() assert result[result['Department'] == 'HR']['AverageSalary'].values[0] == hr_avg_salary, \\"Incorrect average salary for HR department\\" eng_avg_salary = df[df['Department'] == 'Engineering']['Salary'].mean() assert result[result['Department'] == 'Engineering']['AverageSalary'].values[0] == eng_avg_salary, \\"Incorrect average salary for Engineering department\\" finance_avg_salary = df[df['Department'] == 'Finance']['Salary'].mean() assert result[result['Department'] == 'Finance']['AverageSalary'].values[0] == finance_avg_salary, \\"Incorrect average salary for Finance department\\"","solution":"import pandas as pd def create_employee_df(): data = { 'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eva', 'Frank', 'Grace', 'Hannah', 'Ian', 'Jack'], 'Age': [25, 30, 45, 35, 28, 40, 50, 23, 33, 41], 'Department': ['HR', 'Engineering', 'Engineering', 'HR', 'Finance', 'Engineering', 'Finance', 'HR', 'Engineering', 'Finance'], 'Salary': [50000, 60000, 80000, 45000, 52000, None, 65000, 47000, 72000, None] } return pd.DataFrame(data) def calculate_average_salary_by_department(df): average_salary = df['Salary'].mean() df['Salary'].fillna(average_salary, inplace=True) result = df.groupby('Department')['Salary'].mean().reset_index() result.rename(columns={'Salary': 'AverageSalary'}, inplace=True) return result"},{"question":"def longest_unique_substring_length(s: str) -> int: This function receives a string s and returns the length of the longest substring that does not include any repeating characters. Example scenarios: longest_unique_substring_length(\\"abcabcbb\\") == 3 # Explanation: \\"abc\\" is the longest substring without repeating characters. longest_unique_substring_length(\\"bbbbb\\") == 1 # Explanation: \\"b\\" is the longest substring without repeating characters. longest_unique_substring_length(\\"pwwkew\\") == 3 # Explanation: \\"wke\\" is the longest substring without repeating characters. Unit Test: from solution import longest_unique_substring_length def test_example_cases(): assert longest_unique_substring_length(\\"abcabcbb\\") == 3 assert longest_unique_substring_length(\\"bbbbb\\") == 1 assert longest_unique_substring_length(\\"pwwkew\\") == 3 def test_empty_string(): assert longest_unique_substring_length(\\"\\") == 0 def test_single_character_string(): assert longest_unique_substring_length(\\"a\\") == 1 def test_all_unique_characters(): assert longest_unique_substring_length(\\"abcdef\\") == 6 def test_all_identical_characters(): assert longest_unique_substring_length(\\"aaaaaa\\") == 1 def test_string_with_two_identical_characters_far_apart(): assert longest_unique_substring_length(\\"abcdefga\\") == 7 def test_long_string_with_repeats(): assert longest_unique_substring_length(\\"abcabcbbdefghijabcd\\") == 10","solution":"def longest_unique_substring_length(s): This function receives a string s and returns the length of the longest substring that does not include any repeating characters. :param s: str - input string :return: int - length of the longest non-repeating character substring char_index_map = {} longest_length = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest_length = max(longest_length, i - start + 1) return longest_length"},{"question":"def second_largest(nums: List[int]) -> int: Design an algorithm to find the second largest number in an unsorted list of integers. Your implementation should be time-efficient, aiming for a linear time complexity where possible. If the list contains less than two distinct elements, the function should return None. >>> second_largest([10, 5, 4, 3, -1]) 5 >>> second_largest([5]) None >>> second_largest([8, 8, 8, 8]) None >>> second_largest([1, 2, 3, 4, 5]) 4 >>> second_largest([5, 4, 3, 2, 1]) 4 >>> second_largest([-10, -20, -30, -40, -50]) -20 >>> second_largest([5, 1, 5, 2, 3]) 3 >>> second_largest([1000000000, 999999999, 1000000000]) 999999999 >>> second_largest([-1, 0, 1, -2, 2, 3, -3]) 2","solution":"def second_largest(nums): Returns the second largest number in the list of integers 'nums'. If there are less than two distinct elements, returns None. if len(nums) < 2: return None first, second = float('-inf'), float('-inf') for num in nums: if num > first: second = first first = num elif num > second and num != first: second = num return second if second != float('-inf') else None"},{"question":"def array_to_dict(keys, values): Returns a dictionary mapping each key to its corresponding value. :param keys: List of keys (strings). :param values: List of values. :return: A dictionary with keys mapped to corresponding values. >>> array_to_dict(['a', 'b', 'c'], [1, 2, 3]) {'a': 1, 'b': 2, 'c': 3} >>> array_to_dict([], []) {} >>> array_to_dict(['a'], [1]) {'a': 1} >>> array_to_dict(['a', 'b', 'c'], [1, 'two', 3.0]) {'a': 1, 'b': 'two', 'c': 3.0}","solution":"def array_to_dict(keys, values): Returns a dictionary mapping each key to its corresponding value. :param keys: List of keys (strings). :param values: List of values. :return: A dictionary with keys mapped to corresponding values. if len(keys) != len(values): raise ValueError(\\"Both lists must have the same length\\") return dict(zip(keys, values))"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate an arithmetic expression containing non-negative integers, parentheses, '+', '*', and '/' and return its value. Args: expression (str): A string that represents the arithmetic expression. Returns: int: The result of the evaluation of the expression. <Examples> >>> evaluate_expression(\\"2+3\\") 5 >>> evaluate_expression(\\"2*3\\") 6 >>> evaluate_expression(\\"2+3*4\\") 14 >>> evaluate_expression(\\"(2+3)*4\\") 20 >>> evaluate_expression(\\"2*(5+5*2)/3+(6/2+8)\\") 21 >>> evaluate_expression(\\" 2 * ( 5 + 5 * 2 ) / 3 + ( 6 / 2 + 8 ) \\") 21","solution":"def evaluate_expression(expression: str) -> int: Evaluate an arithmetic expression containing non-negative integers, parentheses, '+', '*', and '/' and return its value. Args: expression (str): A string that represents the arithmetic expression. Returns: int: The result of the evaluation of the expression. import re def compute(op, second, first): if op == '+': return first + second elif op == '-': return first - second elif op == '*': return first * second elif op == '/': return int(first / second) # using // would not work properly def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_ops(vals, ops): while ops and ops[-1] in {'+', '-', '*', '/'}: op = ops.pop() second = vals.pop() first = vals.pop() vals.append(compute(op, second, first)) vals = [] ops = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i] == '(': ops.append(expression[i]) elif expression[i].isdigit(): val = 0 while (i < len(expression) and expression[i].isdigit()): val = (val * 10) + int(expression[i]) i += 1 vals.append(val) i -= 1 elif expression[i] == ')': while ops and ops[-1] != '(': apply_ops(vals, ops) ops.pop() else: while (ops and precedence(ops[-1]) >= precedence(expression[i])): apply_ops(vals, ops) ops.append(expression[i]) i += 1 while ops: apply_ops(vals, ops) return vals[-1]"},{"question":"def filter_even_numbers(numbers: List[int]) -> List[int]: Develop a function that accepts a list of integers as its parameter. This function should return a new list containing only those integers that are even. Ensure your solution gracefully handles the scenario when the input list is empty, returning an empty list in such cases. >>> filter_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 4, 6, 8, 10] >>> filter_even_numbers([]) [] >>> filter_even_numbers([1, 3, 5, 7, 9]) [] >>> filter_even_numbers([2, 4, 6, 8, 10]) [2, 4, 6, 8, 10] >>> filter_even_numbers([-1, -2, -3, -4, -5, -6]) [-2, -4, -6] >>> filter_even_numbers([7]) [] >>> filter_even_numbers([4]) [4]","solution":"def filter_even_numbers(numbers): Returns a list of even numbers from the provided list. Parameters: numbers (list): A list of integers. Returns: list: A list of even integers. return [num for num in numbers if num % 2 == 0]"},{"question":"def vending_machine(): items = {'Soda': 1.50, 'Chips': 1.00, 'Candy': 0.65} inserted_money = 0.0 def display_items(): Display available items and their prices. >>> vending_machine()[\\"display_items\\"]() {'Soda': '1.50', 'Chips': '1.00', 'Candy': '0.65'} def accept_money(amount): Accept money in different denominations (1, 5, 10). >>> vm = vending_machine() >>> vm[\\"accept_money\\"](5) \\"Inserted money: 5.00\\" >>> vm[\\"accept_money\\"](3) \\"Invalid denomination. Please insert 1, 5, or 10.\\" def select_item(item): Check if enough money is inserted, dispense item, or return appropriate message. >>> vm = vending_machine() >>> vm[\\"accept_money\\"](5) \\"Inserted money: 5.00\\" >>> vm[\\"select_item\\"](\\"Chips\\") \\"Dispensing Chips. Change returned: 4.00\\" >>> vm[\\"select_item\\"](\\"Soda\\") \\"Not enough money. Soda costs 1.50. Please insert more money.\\" >>> vm[\\"select_item\\"](\\"Water\\") \\"Invalid selection. Please choose a valid item.\\"","solution":"def vending_machine(): items = {'Soda': 1.50, 'Chips': 1.00, 'Candy': 0.65} inserted_money = 0.0 def display_items(): return {item: f\\"{price:.2f}\\" for item, price in items.items()} def accept_money(amount): nonlocal inserted_money if amount in [1, 5, 10]: inserted_money += amount return f\\"Inserted money: {inserted_money:.2f}\\" else: return \\"Invalid denomination. Please insert 1, 5, or 10.\\" def select_item(item): nonlocal inserted_money if item in items: price = items[item] if inserted_money >= price: change = inserted_money - price inserted_money = 0.0 return f\\"Dispensing {item}. Change returned: {change:.2f}\\" else: return f\\"Not enough money. {item} costs {price:.2f}. Please insert more money.\\" else: return \\"Invalid selection. Please choose a valid item.\\" return { \\"display_items\\": display_items, \\"accept_money\\": accept_money, \\"select_item\\": select_item }"},{"question":"from typing import List def max_sum_subarray(arr: List[int], k: int) -> int: Returns the maximum sum of any contiguous subarray of length k. >>> max_sum_subarray([1, 2, 3, 4, 5], 2), 9 >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 3), 9 >>> max_sum_subarray([2, 3, 4, 1, 5], 2), 7 >>> max_sum_subarray([], 2), 0 >>> max_sum_subarray([1, 2, 3], 5), 0 >>> max_sum_subarray([1, 2, 3, 4, 5], 0), 0 >>> max_sum_subarray([-1, -2, -3, -4, -5], 2), -3 >>> max_sum_subarray([1, -2, 3, 4, -1], 3), 6","solution":"def max_sum_subarray(arr, k): Returns the maximum sum of any contiguous subarray of length k. if not arr or k <= 0 or k > len(arr): return 0 max_sum = current_sum = sum(arr[:k]) for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is prime. # Function implementation here def filter_primes(numbers: List[int]) -> List[int]: Returns a new list containing only the prime numbers from the original list. >>> filter_primes([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> filter_primes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([0, 1, 4, 6, 8, 10]) [] >>> filter_primes([-10, -3, -2, 2, 3, 4]) [2, 3] >>> filter_primes([]) [] >>> filter_primes([101, 103, 107, 109, 113]) [101, 103, 107, 109, 113] >>> filter_primes([2, 2, 2, 2]) [2, 2, 2, 2] # Function implementation here","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers): Returns a new list containing only the prime numbers from the original list. return [num for num in numbers if is_prime(num)]"},{"question":"def longest_distinct_substrings_lengths(strings: list) -> list: Given a list of strings, this function returns a list of integers where each integer is the length of the longest substring containing all distinct characters from the corresponding string in the input list. :param strings: List[str], a list of strings. :return: List[int], a list of lengths of the longest substrings with all distinct characters. >>> longest_distinct_substrings_lengths(['abcabcbb', 'bbbbb', 'pwwkew', '']) [3, 1, 3, 0] >>> longest_distinct_substrings_lengths(['abcdef', 'aaaaaa', 'ababcde']) [6, 1, 4]","solution":"def longest_distinct_substrings_lengths(strings): Given a list of strings, this function returns a list of integers where each integer is the length of the longest substring containing all distinct characters from the corresponding string in the input list. :param strings: List[str], a list of strings. :return: List[int], a list of lengths of the longest substrings with all distinct characters. >>> longest_distinct_substrings_lengths(['abcabcbb', 'bbbbb', 'pwwkew', '']) [3, 1, 3, 0] >>> longest_distinct_substrings_lengths(['abcdef', 'aaaaaa', 'ababcde']) [6, 1, 4] def longest_distinct_substring_length(s): Helper function to find the length of the longest substring with all distinct characters in a given string. n = len(s) if n == 0: return 0 max_length = 0 start = 0 char_index_map = {} for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length return [longest_distinct_substring_length(s) for s in strings]"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Determine if there exists a pair of integers within the given array whose sum equals the specified target value. If such a pair exists, return the indices of the two numbers. Otherwise, return an empty array. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, 2, 3, 4], 8) [] >>> two_sum([-1, -2, -3, -4, -5], -8) [2, 4] >>> two_sum([1, 2, 3, 4, 5], 6) in [[1, 3], [0, 4]] True >>> two_sum([-3, 4, 3, 90], 0) [0, 2]","solution":"def two_sum(nums, target): Returns the indices of the two numbers such that they add up to the target. Args: nums: List of integers. target: An integer target sum. Returns: A list with two indices if a pair is found, otherwise an empty list. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"from threading import Lock class Theater: def __init__(self): self.screens = {'Screen1': 50, 'Screen2': 75} self.locks = {screen: Lock() for screen in self.screens} def book_seat(self, screen, seats): Handle seat booking for a theater screen ensuring thread safety. :param screen: Identifier for the screen. :param seats: Number of seats to be booked. :return: Confirmation message if booking is successful or error message if not. if screen not in self.screens: return \\"Screen not found\\" with self.locks[screen]: if self.screens[screen] >= seats: self.screens[screen] -= seats return \\"Booking successful\\" else: return \\"Not enough seats available\\" def test_booking_successful(): theater = Theater() assert theater.book_seat('Screen1', 30) == \\"Booking successful\\" def test_booking_unsuccessful_due_to_insufficient_seats(): theater = Theater() theater.book_seat('Screen1', 45) # Book 45 seats first assert theater.book_seat('Screen1', 10) == \\"Not enough seats available\\" # Try to book 10 more def test_booking_on_different_screens(): theater = Theater() assert theater.book_seat('Screen1', 30) == \\"Booking successful\\" assert theater.book_seat('Screen2', 50) == \\"Booking successful\\" def test_booking_unsuccessful_invalid_screen(): theater = Theater() assert theater.book_seat('Screen3', 10) == \\"Screen not found\\" def test_thread_safety(): import threading theater = Theater() def book_many(): for _ in range(100): theater.book_seat('Screen1', 1) threads = [threading.Thread(target=book_many) for _ in range(100)] for thread in threads: thread.start() for thread in threads: thread.join() remaining_seats = theater.screens['Screen1'] assert remaining_seats == 0 or remaining_seats < 0 # It should be consistent without overbooking","solution":"from threading import Lock class Theater: def __init__(self): self.screens = {'Screen1': 50, 'Screen2': 75} self.locks = {screen: Lock() for screen in self.screens} def book_seat(self, screen, seats): if screen not in self.screens: return \\"Screen not found\\" with self.locks[screen]: if self.screens[screen] >= seats: self.screens[screen] -= seats return \\"Booking successful\\" else: return \\"Not enough seats available\\" theater = Theater()"},{"question":"import json from typing import List, Dict def parse_books_json(json_string: str) -> List[Dict[str, str]]: Parses a JSON string representing a list of books into a list of dictionaries. pass def categorize_books_by_decade(books: List[Dict[str, str]]) -> Dict[str, List[Dict[str, str]]]: Categorizes a list of books into a dictionary of lists based on the decade of publication. Each list is sorted by 'rating' in descending order. pass def test_parse_books_json(): json_string = ''' [ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author A\\", \\"year\\": 1985, \\"rating\\": 4.5}, {\\"title\\": \\"Book B\\", \\"author\\": \\"Author B\\", \\"year\\": 1992, \\"rating\\": 3.8} ] ''' expected_output = [ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author A\\", \\"year\\": 1985, \\"rating\\": 4.5}, {\\"title\\": \\"Book B\\", \\"author\\": \\"Author B\\", \\"year\\": 1992, \\"rating\\": 3.8} ] assert parse_books_json(json_string) == expected_output def test_categorize_books_by_decade(): books = [ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author A\\", \\"year\\": 1985, \\"rating\\": 4.5}, {\\"title\\": \\"Book B\\", \\"author\\": \\"Author B\\", \\"year\\": 1992, \\"rating\\": 3.8}, {\\"title\\": \\"Book C\\", \\"author\\": \\"Author C\\", \\"year\\": 2001, \\"rating\\": 4.0}, {\\"title\\": \\"Book D\\", \\"author\\": \\"Author D\\", \\"year\\": 1999, \\"rating\\": 4.7}, {\\"title\\": \\"Book E\\", \\"author\\": \\"Author E\\", \\"year\\": 2010, \\"rating\\": 4.2} ] expected_output = { \\"1980s\\": [ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author A\\", \\"year\\": 1985, \\"rating\\": 4.5} ], \\"1990s\\": [ {\\"title\\": \\"Book D\\", \\"author\\": \\"Author D\\", \\"year\\": 1999, \\"rating\\": 4.7}, {\\"title\\": \\"Book B\\", \\"author\\": \\"Author B\\", \\"year\\": 1992, \\"rating\\": 3.8} ], \\"2000s\\": [ {\\"title\\": \\"Book C\\", \\"author\\": \\"Author C\\", \\"year\\": 2001, \\"rating\\": 4.0} ], \\"2010s\\": [ {\\"title\\": \\"Book E\\", \\"author\\": \\"Author E\\", \\"year\\": 2010, \\"rating\\": 4.2} ] } assert categorize_books_by_decade(books) == expected_output def test_categorize_books_empty_list(): books = [] expected_output = {} assert categorize_books_by_decade(books) == expected_output def test_categorize_books_by_decade_multiple_same(): books = [ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author A\\", \\"year\\": 1985, \\"rating\\": 4.5}, {\\"title\\": \\"Book F\\", \\"author\\": \\"Author F\\", \\"year\\": 1985, \\"rating\\": 4.6} ] expected_output = { \\"1980s\\": [ {\\"title\\": \\"Book F\\", \\"author\\": \\"Author F\\", \\"year\\": 1985, \\"rating\\": 4.6}, {\\"title\\": \\"Book A\\", \\"author\\": \\"Author A\\", \\"year\\": 1985, \\"rating\\": 4.5} ] } assert categorize_books_by_decade(books) == expected_output","solution":"import json from collections import defaultdict def parse_books_json(json_string): Parses a JSON string representing a list of books into a list of dictionaries. return json.loads(json_string) def categorize_books_by_decade(books): Categorizes a list of books into a dictionary of lists based on the decade of publication. Each list is sorted by 'rating' in descending order. categorized_books = defaultdict(list) for book in books: decade = (book['year'] // 10) * 10 decade_key = f\\"{decade}s\\" categorized_books[decade_key].append(book) for decade in categorized_books: categorized_books[decade].sort(key=lambda x: x['rating'], reverse=True) return dict(categorized_books)"},{"question":"from typing import List def remove_duplicates_preserve_order(input_list: List[str]) -> List[str]: Write a function that takes a list of strings as input and removes any duplicates while preserving the original order of elements. The function should return the modified list. For example, given the list [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"pear\\"], the function should return [\\"apple\\", \\"banana\\", \\"orange\\", \\"pear\\"]. >>> remove_duplicates_preserve_order([]) [] >>> remove_duplicates_preserve_order([\\"apple\\", \\"banana\\", \\"pear\\"]) [\\"apple\\", \\"banana\\", \\"pear\\"] >>> remove_duplicates_preserve_order([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"pear\\"]) [\\"apple\\", \\"banana\\", \\"orange\\", \\"pear\\"] >>> remove_duplicates_preserve_order([\\"apple\\", \\"apple\\", \\"apple\\"]) [\\"apple\\"] >>> remove_duplicates_preserve_order([\\"Apple\\", \\"apple\\", \\"Banana\\", \\"banana\\"]) [\\"Apple\\", \\"apple\\", \\"Banana\\", \\"banana\\"] pass","solution":"def remove_duplicates_preserve_order(input_list): Removes duplicates from the list while preserving the original order of elements. seen = set() result = [] for item in input_list: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"from typing import List, Optional def transpose_matrix(matrix: List[List[int]]) -> List[List[Optional[int]]]: Returns the transpose of the given rectangular or non-rectangular matrix. If the input is not rectangular or if rows have different numbers of elements, treat the missing cells as None. Parameters: matrix (List[List[int]]): The input matrix of size m x n Returns: List[List[Optional[int]]]: The transposed matrix Examples: >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1, 2], [3, 4, 5], [6]]) [[1, 3, 6], [2, 4, None], [None, 5, None]] >>> transpose_matrix([]) [] >>> transpose_matrix([[1, 2, 3]]) [[1], [2], [3]] >>> transpose_matrix([[1], [2], [3]]) [[1, 2, 3]]","solution":"def transpose_matrix(matrix): Returns the transpose of the given rectangular or non-rectangular matrix. If the input is not rectangular or if rows have different numbers of elements, treat the missing cells as None. if not matrix: # Handle empty matrix case return [] # Find the maximum row length max_row_len = max(len(row) for row in matrix) # Initialize the transposed matrix with None transposed = [[None] * len(matrix) for _ in range(max_row_len)] for i in range(len(matrix)): for j in range(len(matrix[i])): transposed[j][i] = matrix[i][j] return transposed"},{"question":"def remove_duplicates(lst: list) -> list: Removes duplicates from the list while maintaining the original order. Args: lst (list): The list of integers from which duplicates are to be removed. Returns: list: A new list with duplicates removed. Example: >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([4, 5, 4, 4, 3, 2, 2, 1]) [4, 5, 3, 2, 1] >>> remove_duplicates([]) []","solution":"def remove_duplicates(lst): Removes duplicates from the list while maintaining the original order. Args: lst (list): The list of integers from which duplicates are to be removed. Returns: list: A new list with duplicates removed. seen = set() result = [] for item in lst: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"def generate_fibonacci(n: int) -> list: Create a function named \`generate_fibonacci(n)\` in Python which takes a single integer \`n\` as input and returns the first \`n\` numbers in the Fibonacci series as a list. Ensure that the function handles invalid input gracefully by returning an appropriate error message if \`n\` is not a positive integer. Use appropriate exception handling to manage any potential runtime errors. >>> generate_fibonacci(5) [0, 1, 1, 2, 3] >>> generate_fibonacci(-3) \\"Error: Input must be a positive integer.\\" >>> generate_fibonacci(\\"a\\") \\"Error: Input must be a positive integer.\\"","solution":"def generate_fibonacci(n): Returns the first \`n\` numbers in the Fibonacci series as a list. Handles invalid input gracefully. try: n = int(n) if n <= 0: return \\"Error: Input must be a positive integer.\\" except ValueError: return \\"Error: Input must be a positive integer.\\" fib_series = [0, 1] if n == 1: return [0] elif n == 2: return fib_series for i in range(2, n): next_value = fib_series[-1] + fib_series[-2] fib_series.append(next_value) return fib_series[:n]"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers, addition ('+') and subtraction ('-') operators, and spaces. Args: expression (str): The input mathematical expression as a string. Returns: int: The result of evaluating the input expression. >>> evaluate_expression(\\"10 + 20 - 5 + 3\\") 28 >>> evaluate_expression(\\" 10+20 - 15 + 5 \\") 20 >>> evaluate_expression(\\"1 + 2 + 3 + 4\\") 10 >>> evaluate_expression(\\"10 - 3 - 2\\") 5 >>> evaluate_expression(\\"100 + 200 - 50 + 25 - 10\\") 265 >>> evaluate_expression(\\"42\\") 42 >>> evaluate_expression(\\"5 - 10\\") -5 >>> evaluate_expression(\\"1000 + 2000 - 1500 + 250 - 100\\") 1650","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing non-negative integers, addition ('+') and subtraction ('-') operators, and spaces. Args: expression (str): The input mathematical expression as a string. Returns: int: The result of evaluating the input expression. # Remove any extraneous spaces in the expression expression = expression.replace(\\" \\", \\"\\") # Initialize variables to keep track of the total and current number total, i, n = 0, 0, len(expression) # Process each character in the expression current_number = 0 sign = 1 # 1 for '+', -1 for '-' while i < n: if expression[i].isdigit(): current_number = current_number * 10 + int(expression[i]) else: total += sign * current_number current_number = 0 if expression[i] == '+': sign = 1 elif expression[i] == '-': sign = -1 i += 1 # Add the last number to total total += sign * current_number return total"},{"question":"from typing import Dict, List, Union def sum_list_values(input_dict: Dict[str, Union[List[int], List[Union[int, str]], str]]) -> Dict[str, Union[int, str]]: Takes a dictionary where keys are strings and values are lists of integers. Returns a new dictionary where the values are the sum of the integers in the lists. If non-list values or lists with non-integer elements are encountered, returns an error message for those keys. >>> sum_list_values({'a': [1, 2, 3], 'b': [4, 5], 'c': [6]}) {'a': 6, 'b': 9, 'c': 6} >>> sum_list_values({'a': [1, 2, 3], 'b': [4, 'five'], 'c': [6]}) {'a': 6, 'b': 'Error: contains non-integer elements', 'c': 6} >>> sum_list_values({'a': [1, 2, 3], 'b': 'not a list', 'c': [6]}) {'a': 6, 'b': 'Error: contains non-list value', 'c': 6} >>> sum_list_values({}) {} >>> sum_list_values({'a': [1, 2, 3], 'b': 10, 'c': [6, 'seven']}) {'a': 6, 'b': 'Error: contains non-list value', 'c': 'Error: contains non-integer elements'}","solution":"def sum_list_values(input_dict): Takes a dictionary where keys are strings and values are lists of integers. Returns a new dictionary where the values are the sum of the integers in the lists. If non-list values or lists with non-integer elements are encountered, returns an error message for those keys. output_dict = {} for key, value in input_dict.items(): if not isinstance(value, list): output_dict[key] = 'Error: contains non-list value' continue try: output_dict[key] = sum(value) except TypeError: output_dict[key] = 'Error: contains non-integer elements' return output_dict"},{"question":"def is_sorted(lst: List[int]) -> bool: Determine if the list of integers is sorted in ascending order. Returns True if sorted, otherwise False. >>> is_sorted([1, 2, 3, 4, 5]) True >>> is_sorted([3, 2, 1]) False >>> is_sorted([7]) True >>> is_sorted([10, 10, 20]) True >>> is_sorted([7, 5, 7]) False from solution import is_sorted def test_is_sorted_ascending(): assert is_sorted([1, 2, 3, 4, 5]) == True def test_is_sorted_descending(): assert is_sorted([3, 2, 1]) == False def test_is_sorted_single_element(): assert is_sorted([7]) == True def test_is_sorted_with_duplicates(): assert is_sorted([10, 10, 20]) == True def test_is_sorted_unsorted(): assert is_sorted([7, 5, 7]) == False def test_is_sorted_empty_list(): try: is_sorted([]) except IndexError: pass # Expected as the input list will contain at least one integer def test_is_sorted_identical_elements(): assert is_sorted([1, 1, 1, 1]) == True def test_is_sorted_single_negative(): assert is_sorted([-1]) == True def test_is_sorted_with_negative_numbers(): assert is_sorted([-3, -2, -1, 0]) == True def test_is_sorted_random_order(): assert is_sorted([10, 5, 3, 8]) == False","solution":"def is_sorted(lst): Returns True if the list is sorted in ascending order, False otherwise. return all(lst[i] <= lst[i + 1] for i in range(len(lst) - 1))"},{"question":"def calculate_average_grades(students_grades): Calculate the average grade for each student. Args: students_grades (list of dict): A list of dictionaries, each representing a student's grades in different subjects. Returns: list of dict: A list of dictionaries with each student's name and their average grade. >>> students_grades = [ ... {\\"name\\": \\"Alice\\", \\"math\\": 90, \\"science\\": 80, \\"history\\": 85}, ... {\\"name\\": \\"Bob\\", \\"math\\": 75, \\"science\\": 95, \\"history\\": 78}, ... {\\"name\\": \\"Charlie\\", \\"math\\": 85, \\"science\\": 89, \\"history\\": 92} ... ] >>> calculate_average_grades(students_grades) [ {\\"name\\": \\"Alice\\", \\"average\\": 85.0}, {\\"name\\": \\"Bob\\", \\"average\\": 82.67}, {\\"name\\": \\"Charlie\\", \\"average\\": 88.67} ]","solution":"def calculate_average_grades(students_grades): Calculate the average grade for each student. Args: students_grades (list of dict): A list of dictionaries, each representing a student's grades in different subjects. Returns: list of dict: A list of dictionaries with each student's name and their average grade. result = [] for student in students_grades: name = student['name'] total_grades = 0 num_subjects = 0 for subject, grade in student.items(): if subject != 'name': total_grades += grade num_subjects += 1 average_grade = round(total_grades / num_subjects, 2) result.append({'name': name, 'average': average_grade}) return result"},{"question":"import numpy as np from sklearn.datasets import load_iris from sklearn.preprocessing import StandardScaler from typing import Tuple def preprocess_iris_data() -> np.ndarray: Preprocess the Iris dataset. The function loads the iris dataset, scales the features and returns the data. # Your code here def initialize_centroids(X: np.ndarray, k: int) -> np.ndarray: Initialize k centroids randomly from the dataset X. Args: X (np.ndarray): The input dataset. k (int): The number of clusters. Returns: np.ndarray: Initialized centroids. # Your code here def assign_clusters(X: np.ndarray, centroids: np.ndarray) -> np.ndarray: Assign data points to the nearest centroid to form clusters. Args: X (np.ndarray): The input dataset. centroids (np.ndarray): The current centroids. Returns: np.ndarray: The cluster assignments for each data point. # Your code here def update_centroids(X: np.ndarray, clusters: np.ndarray, k: int) -> np.ndarray: Update centroid positions based on the assigned clusters. Args: X (np.ndarray): The input dataset. clusters (np.ndarray): The current cluster assignments. k (int): The number of clusters. Returns: np.ndarray: Updated centroids. # Your code here def kmeans(X: np.ndarray, k: int, max_iters: int = 100) -> Tuple[np.ndarray, np.ndarray]: Perform k-means clustering. Args: X (np.ndarray): The input dataset. k (int): The number of clusters. max_iters (int): The maximum number of iterations (default 100). Returns: Tuple[np.ndarray, np.ndarray]: The final centroids and the cluster assignments. # Your code here def compute_silhouette_score(X: np.ndarray, labels: np.ndarray) -> float: Compute the silhouette score for the clustering. Args: X (np.ndarray): The input dataset. labels (np.ndarray): The cluster assignments. Returns: float: The silhouette score. # Your code here # Example Usage and Testing def test_initialize_centroids(): X = np.array([[1, 2], [3, 4], [5, 6], [7, 8]]) centroids = initialize_centroids(X, 2) assert centroids.shape == (2, 2) assert len(np.unique(centroids, axis=0)) == 2 def test_assign_clusters(): X = np.array([[1, 2], [3, 4], [5, 6], [7, 8]]) centroids = np.array([[1, 2], [7, 8]]) clusters = assign_clusters(X, centroids) assert clusters.tolist() == [0, 0, 1, 1] def test_update_centroids(): X = np.array([[1, 2], [3, 4], [5, 6], [7, 8]]) clusters = np.array([0, 0, 1, 1]) new_centroids = update_centroids(X, clusters, 2) assert np.array_equal(new_centroids, np.array([[2, 3], [6, 7]])) def test_kmeans_run(): X = preprocess_iris_data() k = 3 centroids, clusters = kmeans(X, k) assert len(np.unique(clusters)) == k assert centroids.shape == (k, X.shape[1]) def test_silhouette_score(): X = preprocess_iris_data() k = 3 _, clusters = kmeans(X, k) silhouette_kmeans = compute_silhouette_score(X, clusters) assert 0 <= silhouette_kmeans <= 1 def test_comparison_with_sklearn(): X = preprocess_iris_data() k = 3 _, clusters = kmeans(X, k) silhouette_kmeans = compute_silhouette_score(X, clusters) sklearn_kmeans = KMeans(n_clusters=k, random_state=42) sklearn_kmeans.fit(X) sklearn_clusters = sklearn_kmeans.labels_ silhouette_sklearn = compute_silhouette_score(X, sklearn_clusters) assert -1 <= silhouette_kmeans <= 1 assert -1 <= silhouette_sklearn <= 1","solution":"import numpy as np from sklearn.datasets import load_iris from sklearn.preprocessing import StandardScaler from sklearn.metrics import silhouette_score def initialize_centroids(X, k): np.random.seed(42) random_indices = np.random.permutation(np.arange(len(X))) centroids = X[random_indices[:k]] return centroids def assign_clusters(X, centroids): distances = np.sqrt(((X - centroids[:, np.newaxis])**2).sum(axis=2)) return np.argmin(distances, axis=0) def update_centroids(X, clusters, k): new_centroids = np.array([X[clusters == i].mean(axis=0) for i in range(k)]) return new_centroids def kmeans(X, k, max_iters=100): centroids = initialize_centroids(X, k) for _ in range(max_iters): clusters = assign_clusters(X, centroids) new_centroids = update_centroids(X, clusters, k) if np.all(new_centroids == centroids): break centroids = new_centroids return centroids, clusters def preprocess_iris_data(): iris = load_iris() X = iris.data X = StandardScaler().fit_transform(X) return X def compute_silhouette_score(X, labels): return silhouette_score(X, labels) X = preprocess_iris_data() k = 3 centroids, clusters = kmeans(X, k) silhouette_kmeans = compute_silhouette_score(X, clusters) # Comparing with Scikit-learn's implementation from sklearn.cluster import KMeans sklearn_kmeans = KMeans(n_clusters=k, random_state=42) sklearn_kmeans.fit(X) sklearn_clusters = sklearn_kmeans.labels_ silhouette_sklearn = compute_silhouette_score(X, sklearn_clusters) silhouette_kmeans, silhouette_sklearn # Returning the silhouette scores for comparison"},{"question":"class Book: def __init__(self, book_id, title, author, publication_year, genre, quantity): self.book_id = book_id self.title = title self.author = author self.publication_year = publication_year self.genre = genre self.quantity = quantity class Library: def __init__(self): self.books = {} def add_book(self, book_id, title, author, publication_year, genre, quantity): Adds a new book to the library. Args: book_id (str): The unique identifier for the book. title (str): The title of the book. author (str): The author of the book. publication_year (int): The publication year of the book. genre (str): The genre of the book. quantity (int): The number of copies available. Raises: ValueError: If the book ID already exists in the library. pass def display_books(self): Displays all books in the library. Returns: List[Tuple[str, str, int]]: A list of tuples containing the title, author, and quantity of each book. pass def borrow_book(self, book_id): Allows a user to borrow a book. Args: book_id (str): The unique identifier for the book to be borrowed. Raises: ValueError: If the book ID is not found in the library or if the book is not available. pass def return_book(self, book_id): Allows a user to return a borrowed book. Args: book_id (str): The unique identifier for the book to be returned. Raises: ValueError: If the book ID is not found in the library. pass def search_books(self, keyword): Searches for books by title, author, or genre. Args: keyword (str): The keyword to search for. Returns: List[Tuple[str, str, int, str, int]]: A list of tuples containing the title, author, publication year, genre, and quantity of each matching book. pass def delete_book(self, book_id): Deletes a book from the library. Args: book_id (str): The unique identifier for the book to be deleted. Raises: ValueError: If the book ID is not found in the library. pass import pytest from solution import Book, Library def test_add_book(): library = Library() library.add_book(\\"1\\", \\"Book Title 1\\", \\"Author 1\\", 2021, \\"Genre 1\\", 3) assert len(library.books) == 1 with pytest.raises(ValueError): library.add_book(\\"1\\", \\"Book Title 2\\", \\"Author 2\\", 2022, \\"Genre 2\\", 2) def test_display_books(): library = Library() library.add_book(\\"1\\", \\"Book Title 1\\", \\"Author 1\\", 2021, \\"Genre 1\\", 3) library.add_book(\\"2\\", \\"Book Title 2\\", \\"Author 2\\", 2022, \\"Genre 2\\", 2) assert library.display_books() == [(\\"Book Title 1\\", \\"Author 1\\", 3), (\\"Book Title 2\\", \\"Author 2\\", 2)] def test_borrow_book(): library = Library() library.add_book(\\"1\\", \\"Book Title 1\\", \\"Author 1\\", 2021, \\"Genre 1\\", 3) library.borrow_book(\\"1\\") assert library.books[\\"1\\"].quantity == 2 with pytest.raises(ValueError): library.borrow_book(\\"2\\") library.books[\\"1\\"].quantity = 0 with pytest.raises(ValueError): library.borrow_book(\\"1\\") def test_return_book(): library = Library() library.add_book(\\"1\\", \\"Book Title 1\\", \\"Author 1\\", 2021, \\"Genre 1\\", 3) library.return_book(\\"1\\") assert library.books[\\"1\\"].quantity == 4 with pytest.raises(ValueError): library.return_book(\\"2\\") def test_search_books(): library = Library() library.add_book(\\"1\\", \\"Book Title 1\\", \\"Author 1\\", 2021, \\"Genre 1\\", 3) library.add_book(\\"2\\", \\"Book Title 2\\", \\"Author 2\\", 2022, \\"Genre 2\\", 2) assert library.search_books(\\"Book Title 1\\") == [(\\"Book Title 1\\", \\"Author 1\\", 2021, \\"Genre 1\\", 3)] assert library.search_books(\\"Author 2\\") == [(\\"Book Title 2\\", \\"Author 2\\", 2022, \\"Genre 2\\", 2)] assert library.search_books(\\"Genre 1\\") == [(\\"Book Title 1\\", \\"Author 1\\", 2021, \\"Genre 1\\", 3)] def test_delete_book(): library = Library() library.add_book(\\"1\\", \\"Book Title 1\\", \\"Author 1\\", 2021, \\"Genre 1\\", 3) library.delete_book(\\"1\\") assert len(library.books) == 0 with pytest.raises(ValueError): library.delete_book(\\"2\\")","solution":"class Book: def __init__(self, book_id, title, author, publication_year, genre, quantity): self.book_id = book_id self.title = title self.author = author self.publication_year = publication_year self.genre = genre self.quantity = quantity class Library: def __init__(self): self.books = {} def add_book(self, book_id, title, author, publication_year, genre, quantity): if book_id in self.books: raise ValueError(\\"Book ID already exists.\\") self.books[book_id] = Book(book_id, title, author, publication_year, genre, quantity) def display_books(self): return [(book.title, book.author, book.quantity) for book in self.books.values()] def borrow_book(self, book_id): if book_id not in self.books: raise ValueError(\\"Book ID not found.\\") if self.books[book_id].quantity <= 0: raise ValueError(\\"Book not available.\\") self.books[book_id].quantity -= 1 def return_book(self, book_id): if book_id not in self.books: raise ValueError(\\"Book ID not found.\\") self.books[book_id].quantity += 1 def search_books(self, keyword): keyword = keyword.lower() return [ (book.title, book.author, book.publication_year, book.genre, book.quantity) for book in self.books.values() if keyword in book.title.lower() or keyword in book.author.lower() or keyword in book.genre.lower() ] def delete_book(self, book_id): if book_id not in self.books: raise ValueError(\\"Book ID not found.\\") del self.books[book_id]"},{"question":"def findAnagrams(words: List[str], target: str) -> List[str]: In the Solution class, finalize the findAnagrams function that accepts a string list 'words' and a specific string 'target'. The function should return a list of words from the 'words' list that are anagrams of the 'target' string. An anagram of a word is another word that contains the same characters, only the order of characters can be different. For instance: >>> findAnagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"abc\\", \\"def\\"], \\"listen\\") [\\"listen\\", \\"silent\\", \\"enlist\\"] >>> findAnagrams([\\"race\\", \\"care\\", \\"acer\\", \\"hello\\", \\"world\\"], \\"care\\") [\\"race\\", \\"care\\", \\"acer\\"] >>> findAnagrams([\\"abcd\\", \\"dcba\\", \\"bcad\\", \\"dabc\\", \\"abdc\\"], \\"abcd\\") [\\"abcd\\", \\"dcba\\", \\"bcad\\", \\"dabc\\", \\"abdc\\"]","solution":"def findAnagrams(words, target): Returns a list of words from 'words' that are anagrams of the 'target' string. target_sorted = sorted(target) return [word for word in words if sorted(word) == target_sorted]"},{"question":"def filter_strings_with_substring(strings_list: List[str], target_substring: str) -> List[str]: Implement a function that takes a list of strings and a target substring, and returns a list of strings from the original list that contain the target substring, ignoring case. >>> filter_strings_with_substring([], 'test') [] >>> filter_strings_with_substring(['test', 'example'], '') ['test', 'example'] >>> filter_strings_with_substring(['test', 'example'], 'none') [] >>> filter_strings_with_substring(['apple', 'banana', 'cherry'], 'apple') ['apple'] >>> filter_strings_with_substring(['Apple', 'Banana', 'Cherry'], 'apple') ['Apple'] >>> filter_strings_with_substring(['applepie', 'bananasplit', 'cheesecake'], 'pie') ['applepie'] >>> filter_strings_with_substring(['applepie', 'applejuice', 'banana'], 'apple') ['applepie', 'applejuice'] pass","solution":"def filter_strings_with_substring(strings_list, target_substring): Returns a list of strings from the original list that contain the target substring, ignoring case. :param strings_list: List of strings :param target_substring: Substring to search for :return: List of strings containing the target substring target_substring_lower = target_substring.lower() return [s for s in strings_list if target_substring_lower in s.lower()]"},{"question":"from typing import List def longest_consecutive(nums: List[int]) -> int: Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([0, -1, -2, -3, 1, 2, 3, 4, -4]) 9 >>> longest_consecutive([]) 0 >>> longest_consecutive([1]) 1 >>> longest_consecutive([10, 30, 20]) 1 >>> longest_consecutive(list(range(-50, 51))) 101","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence. if not nums: return 0 num_set = set(nums) longest = 0 for num in num_set: # Only check for the beginning of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest = max(longest, current_streak) return longest"},{"question":"def insert_in_sorted_array(arr: List[int], num: int) -> List[int]: Inserts a given integer into its correct position in a sorted array, maintaining the sorted order. >>> insert_in_sorted_array([], 3) [3] >>> insert_in_sorted_array([1, 2, 4, 5], 0) [0, 1, 2, 4, 5] >>> insert_in_sorted_array([1, 2, 3, 4], 5) [1, 2, 3, 4, 5] >>> insert_in_sorted_array([1, 3, 4, 5], 2) [1, 2, 3, 4, 5] >>> insert_in_sorted_array([1, 2, 3, 4], 3) [1, 2, 3, 3, 4] >>> insert_in_sorted_array([-5, -3, -1], -2) [-5, -3, -2, -1] >>> insert_in_sorted_array([-5, -2, 0, 3], -4) [-5, -4, -2, 0, 3]","solution":"def insert_in_sorted_array(arr, num): Inserts a given integer into its correct position in a sorted array, maintaining the sorted order. for i in range(len(arr)): if num <= arr[i]: return arr[:i] + [num] + arr[i:] return arr + [num]"},{"question":"def reverse_list(input_list): Implement a function that takes a list of integers input_list and returns a new list with the elements in reverse order. The function should not use any built-in reverse functions or methods. For example: reverse_list([1, 2, 3, 4, 5]) => [5, 4, 3, 2, 1] reverse_list([10, 20, 30, 40]) => [40, 30, 20, 10] reverse_list([7, 11, 3]) => [3, 11, 7] reverse_list([]) => [] # Test cases def test_reverse_list_standard_cases(): assert reverse_list([1, 2, 3, 4, 5]) == [5, 4, 3, 2, 1] assert reverse_list([10, 20, 30, 40]) == [40, 30, 20, 10] assert reverse_list([7, 11, 3]) == [3, 11, 7] def test_reverse_list_empty_case(): assert reverse_list([]) == [] def test_reverse_list_single_element_case(): assert reverse_list([1]) == [1] def test_reverse_list_identical_elements(): assert reverse_list([1, 1, 1, 1]) == [1, 1, 1, 1] def test_reverse_list_mixed_elements(): assert reverse_list([1, -2, 3, -4, 5]) == [5, -4, 3, -2, 1]","solution":"def reverse_list(input_list): Takes a list of integers input_list and returns a new list with the elements in reverse order. The function does not use any built-in reverse functions or methods. reversed_list = [] for i in range(len(input_list) - 1, -1, -1): reversed_list.append(input_list[i]) return reversed_list"},{"question":"def min_path_cost(grid): Determine the minimum cost to reach the bottom-right corner of the grid. Parameters: grid (List[List[int]]): The grid as a list of lists of integers representing costs. Returns: int : The minimum cost to reach the bottom-right corner from the top-left corner. >>> min_path_cost([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> min_path_cost([ ... [2, 3, 1], ... [2, 1, 1], ... [3, 2, 1] ... ]) == 7 >>> min_path_cost([ ... [1, 2], ... [1, 1] ... ]) == 3 >>> min_path_cost([ ... [1, 2, 3] ... ]) == 6 >>> min_path_cost([ ... [1], ... [2], ... [3] ... ]) == 6 >>> min_path_cost([ ... [5, 9, 6], ... [11, 5, 2], ... [3, 7, 4] ... ]) == 25 >>> min_path_cost([]) == 0 >>> min_path_cost([[0]]) == 0","solution":"def min_path_cost(grid): Determine the minimum cost to reach the bottom-right corner of the grid. Parameters: grid (List[List[int]]): The grid as a list of lists of integers representing costs. Returns: int : The minimum cost to reach the bottom-right corner from the top-left corner. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"import openai from time import sleep openai.api_key = 'your_openai_api_key_here' def summarize_texts(texts: list) -> list: Summarizes a list of texts using the OpenAI GPT-3 API. Parameters: texts (list): A list of strings to be summarized. Returns: list: A list of summarized texts. pass # Test case def fake_openai_completion_create(engine, prompt, max_tokens): class Response: class Choice: def __init__(self, text): self.text = text def __init__(self, text): self.choices = [self.Choice(text)] responses = { \\"Summarize the following text:nnThe quick brown fox jumps over the lazy dog.\\": \\"The quick fox jumps over a lazy dog.\\", \\"Summarize the following text:nnIn the beginning, the universe was created.\\": \\"The universe was created in the beginning.\\" } text = prompt.split(\\"nn\\")[1] return Response(responses.get(prompt, \\"Summary not available.\\")) openai.Completion.create = fake_openai_completion_create def test_summarize_texts(): texts = [ \\"The quick brown fox jumps over the lazy dog.\\", \\"In the beginning, the universe was created.\\" ] expected_summaries = [ \\"The quick fox jumps over a lazy dog.\\", \\"The universe was created in the beginning.\\" ] assert summarize_texts(texts) == expected_summaries","solution":"import openai from time import sleep openai.api_key = 'your_openai_api_key_here' def summarize_texts(texts): Summarizes a list of texts using the OpenAI GPT-3 API. Parameters: texts (list): A list of strings to be summarized. Returns: list: A list of summarized texts. summaries = [] for text in texts: while True: # Handle API rate limiting try: response = openai.Completion.create( engine=\\"text-davinci-003\\", prompt=f\\"Summarize the following text:nn{text}\\", max_tokens=50 ) summaries.append(response.choices[0].text.strip()) break except openai.error.RateLimitError: sleep(1) # Wait for a second before retrying except Exception as e: summaries.append(f\\"Error: {str(e)}\\") break return summaries"},{"question":"def differences_from_min(lst: List[int]) -> List[int]: Create a Python function that accepts a list of integers and returns a new list where each element is the difference between the smallest element and the current element in the original list. The function should handle edge cases, such as when the list is empty or contains non-integer values, by raising an appropriate exception. Additionally, the function should ensure no negative differences are included in the resultant list. Args: lst (List[int]): list of integers Returns: List[int]: a list where each element is the difference between the smallest element and the current element in the original list. >>> differences_from_min([1, 2, 3, 4]) [0, 1, 2, 3] >>> differences_from_min([0, 5, 10]) [0, 5, 10] >>> differences_from_min([10]) [0] >>> differences_from_min([-5, -1, 0]) [0, 4, 5] >>> differences_from_min([-10, -5, 0, 5, 10]) [0, 5, 10, 15, 20] import pytest def test_differences_from_min_positive_numbers(): assert differences_from_min([1, 2, 3, 4]) == [0, 1, 2, 3] def test_differences_from_min_with_zero(): assert differences_from_min([0, 5, 10]) == [0, 5, 10] def test_differences_from_min_single_element(): assert differences_from_min([10]) == [0] def test_differences_from_min_negative_numbers(): assert differences_from_min([-5, -1, 0]) == [0, 4, 5] def test_differences_from_min_mixed_sign_numbers(): assert differences_from_min([-10, -5, 0, 5, 10]) == [0, 5, 10, 15, 20] def test_differences_from_min_empty_list(): with pytest.raises(ValueError, match=\\"The list should not be empty.\\"): differences_from_min([]) def test_differences_from_min_non_integer_values(): with pytest.raises(ValueError, match=\\"The list should contain only integers.\\"): differences_from_min([1, 2, 'a', 3]) def test_differences_from_min_mixed_integers(): assert differences_from_min([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [2, 0, 3, 0, 4, 8, 1, 5, 4, 2, 4]","solution":"def differences_from_min(lst): Returns a new list where each element is the difference between the smallest element in the list and the current element in the original list. Raises an exception for empty lists or lists with non-integer values. if not lst: raise ValueError(\\"The list should not be empty.\\") if not all(isinstance(x, int) for x in lst): raise ValueError(\\"The list should contain only integers.\\") min_value = min(lst) return [max(0, x - min_value) for x in lst]"},{"question":"from typing import List from collections import Counter def is_permutation_of_palindrome(s: str) -> bool: Checks if the given string is a permutation of a palindrome. A string is a permutation of a palindrome if the frequency of each character in the string can form a palindrome. For that to be true, at most one character can have an odd frequency (for odd-length palindromes), and all characters must have even frequency for even-length palindromes. Args: s (str): The input string to check. Returns: bool: True if the string is a permutation of a palindrome, False otherwise. pass # Write logic here # Unit tests def test_is_permutation_of_palindrome_true_cases(): assert is_permutation_of_palindrome(\\"racecar\\") == True assert is_permutation_of_palindrome(\\"taco cat\\") == True assert is_permutation_of_palindrome(\\"atco cta\\") == True assert is_permutation_of_palindrome(\\"civic\\") == True assert is_permutation_of_palindrome(\\"ivicc\\") == True def test_is_permutation_of_palindrome_false_cases(): assert is_permutation_of_palindrome(\\"hello\\") == False assert is_permutation_of_palindrome(\\"world\\") == False assert is_permutation_of_palindrome(\\"nonpalindrome\\") == False def test_is_permutation_of_palindrome_special_cases(): assert is_permutation_of_palindrome(\\"\\") == True # Empty string assert is_permutation_of_palindrome(\\"a\\") == True # Single character assert is_permutation_of_palindrome(\\"Aa\\") == True # Case insensitivity assert is_permutation_of_palindrome(\\"aaabbb\\") == False # Even length, but odd counts assert is_permutation_of_palindrome(\\"aaabb\\") == True # Odd length, one odd count","solution":"def is_permutation_of_palindrome(s): Checks if the given string is a permutation of a palindrome. A string is a permutation of a palindrome if the frequency of each character in the string can form a palindrome. For that to be true, at most one character can have an odd frequency (for odd-length palindromes), and all characters must have even frequency for even-length palindromes. Args: s (str): The input string to check. Returns: bool: True if the string is a permutation of a palindrome, False otherwise. from collections import Counter # Remove whitespace and convert to lowercase for uniformity. s = s.replace(\\" \\", \\"\\").lower() # Count the frequency of each character. char_count = Counter(s) # Check the number of characters that have an odd count. odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if there is at most one character with an odd count. return odd_count <= 1"},{"question":"def find_pairs(nums: list, target: int) -> list: Given a list of integers, identifies all the unique pairs of numbers whose sum equals a given target value. Each pair should be sorted in ascending order, and the list should not contain duplicate pairs. Args: nums (list): List of integers. target (int): The target sum. Returns: list: List of tuples, each containing a pair of integers that sum up to the target value. Examples: >>> find_pairs([], 5) [] >>> find_pairs([1], 5) [] >>> find_pairs([1, 2, 3], 7) [] >>> find_pairs([1, 2, 3], 4) [(1, 3)] >>> find_pairs([1, 2, 3, 2], 4) [(1, 3), (2, 2)] >>> find_pairs([1, 2, 3, 2, 4, 2, -1, 5], 4) [(1, 3), (2, 2), (-1, 5)]","solution":"def find_pairs(nums: list, target: int) -> list: Identifies all unique pairs of numbers in the list that sum up to the target value. Args: nums (list): List of integers. target (int): The target sum. Returns: list: List of tuples, each containing a pair of integers that sum up to the target value. pairs = set() seen = set() for num in nums: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return list(pairs)"},{"question":"import heapq from typing import List def k_largest_elements(nums: List[int], k: int) -> List[int]: Write a function that takes a list of integers and an integer \`k\`, and returns the \`k\` largest elements in the list in descending order. Your solution should account for the potential that the list could be very large. Analyze the time complexity of your function and explain how well it handles large datasets. Optimize your function to ensure it can process lists with up to one million elements efficiently and provide a justification for your optimization choices. >>> k_largest_elements([3, 1, 5, 2, 4, 6], 3) [6, 5, 4] >>> k_largest_elements([10, 20, 30, 40, 50, 60], 4) [60, 50, 40, 30] >>> k_largest_elements([-10, -20, -30, -40, -50, -60], 2) [-10, -20] >>> k_largest_elements([100, -50, 2000, -300, 45], 3) [2000, 100, 45] >>> k_largest_elements([2, 8, 6], 5) [8, 6, 2] >>> k_largest_elements([], 3) [] >>> k_largest_elements([3, 1, 5, 2, 4, 6], 0) []","solution":"import heapq def k_largest_elements(nums, k): Returns the k largest elements in the list \`nums\` in descending order. if k <= 0: return [] # Use a heap to find the k largest elements efficiently largest_elements = heapq.nlargest(k, nums) return sorted(largest_elements, reverse=True)"},{"question":"from typing import List def is_prime(n: int) -> bool: Returns True if n is a prime number, else False. pass def filter_primes(numbers: List[int]) -> List[int]: Returns a new list containing only the prime numbers from the input list. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) [2, 3, 5, 7, 11] >>> filter_primes([4, 6, 8, 9, 10]) [] >>> filter_primes([-1, 0, 1, 2]) [2] >>> filter_primes([]) [] pass","solution":"def is_prime(n): Returns True if n is a prime number, else False. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers): Returns a new list containing only the prime numbers from the input list. return [num for num in numbers if is_prime(num)]"},{"question":"def reverse_strings(input_list: list) -> list: Function to reverse each string in the input list while maintaining the order of the strings. Non-string elements in the list are ignored. Args: input_list (list): List of elements which may include strings and non-strings. Returns: list: List of reversed strings. >>> reverse_strings([\\"apple\\", \\"banana\\", \\"cherry\\"]) ['elppa', 'ananab', 'yrrehc'] >>> reverse_strings([\\"123\\", \\"hello\\", 123, \\"world\\"]) ['321', 'olleh', 'dlrow'] >>> reverse_strings([1, 2, 3]) [] >>> reverse_strings([]) [] >>> reverse_strings([\\"\\", \\"\\", \\"\\"]) [\\"\\", \\"\\", \\"\\"] >>> reverse_strings([\\"abc\\", 123, True, \\"xyz\\"]) [\\"cba\\", \\"zyx\\"]","solution":"def reverse_strings(input_list): Function to reverse each string in the input list while maintaining the order of the strings. Non-string elements in the list are ignored. Args: input_list (list): List of elements which may include strings and non-strings. Returns: list: List of reversed strings. return [s[::-1] for s in input_list if isinstance(s, str)]"},{"question":"def moving_average(nums, window_size): Calculate the moving average of the integers in the list over the defined window size. Args: nums (list of int): List of integers. window_size (int): Size of the sliding window. Returns: list of float: List containing the moving averages, rounded to two decimal places. Examples: >>> moving_average([1, 2, 3, 4, 5], 3) [2.0, 3.0, 4.0] >>> moving_average([10, 20, 30, 40, 50, 60], 2) [15.0, 25.0, 35.0, 45.0, 55.0] >>> moving_average([1, 1, 1, 1], 5) [] >>> moving_average([3, 5, 7, 9], 1) [3.0, 5.0, 7.0, 9.0]","solution":"def moving_average(nums, window_size): Calculate the moving average of the integers in the list over the defined window size. Args: nums (list of int): List of integers. window_size (int): Size of the sliding window. Returns: list of float: List containing the moving averages, rounded to two decimal places. if len(nums) < window_size: return [] averages = [] for i in range(len(nums) - window_size + 1): window = nums[i:i + window_size] average = round(sum(window) / window_size, 2) averages.append(average) return averages"},{"question":"def remove_divisibles(lst: List[int], X: int) -> List[int]: Write a Python function that takes a list of integers and an integer \`X\`. Your function should return a new list that contains all the elements of the original list except those that are divisible by \`X\`. Ensure that your function handles cases where the list is empty or contains no elements divisible by \`X\` gracefully. >>> remove_divisibles([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) [1, 3, 5, 7, 9] >>> remove_divisibles([1, 3, 5, 7, 9], 2) [1, 3, 5, 7, 9] >>> remove_divisibles([2, 4, 6, 8, 10], 2) [] >>> remove_divisibles([], 2) [] >>> remove_divisibles([1, 2, 3], 10) [1, 2, 3] >>> remove_divisibles([-1, -2, -3, -4], 2) [-1, -3] >>> try: ... remove_divisibles([1, 2, 3, 4], 0) ... except ZeroDivisionError: ... assert True ... else: ... assert False >>> remove_divisibles([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], -2) [1, 3, 5, 7, 9] pass","solution":"def remove_divisibles(lst, X): Returns a list of elements from \`lst\` that are not divisible by \`X\`. :param lst: List of integers :param X: Integer divisor :return: A list of integers not divisible by \`X\` return [item for item in lst if item % X != 0]"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Determine if two strings are anagrams. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"listen\\", \\"silents\\") False >>> are_anagrams(\\"\\", \\"\\") True >>> are_anagrams(\\"aabbcc\\", \\"abcabc\\") True >>> are_anagrams(\\"aabbc\\", \\"aabcc\\") False >>> are_anagrams(\\"same\\", \\"same\\") True >>> are_anagrams(\\"abcd\\", \\"xyz\\") False","solution":"def are_anagrams(str1, str2): Determine if two strings are anagrams. Args: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if the strings are anagrams, False otherwise. # Check if the lengths of the strings are the same if len(str1) != len(str2): return False # Count the frequency of each character in both strings from collections import Counter return Counter(str1) == Counter(str2)"},{"question":"def word_exists(grid, word): Determine if a word exists in a 2D grid of characters. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. >>> word_exists([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], \\"ABCCED\\") True >>> word_exists([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], \\"SEE\\") True >>> word_exists([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], \\"ABCB\\") False","solution":"def word_exists(grid, word): def dfs(x, y, word_index): if word_index == len(word): return True if not (0 <= x < len(grid) and 0 <= y < len(grid[0])): return False if grid[x][y] != word[word_index]: return False tmp, grid[x][y] = grid[x][y], \\"#\\" # Mark cell as used found = (dfs(x + 1, y, word_index + 1) or dfs(x - 1, y, word_index + 1) or dfs(x, y + 1, word_index + 1) or dfs(x, y - 1, word_index + 1)) grid[x][y] = tmp # Unmark cell return found for i in range(len(grid)): for j in range(len(grid[0])): if dfs(i, j, 0): return True return False"},{"question":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: Find the length of the longest contiguous increasing subsequence in the given list of integers. Constraints: 1 <= len(arr) <= 10^5, -10^9 <= arr[i] <= 10^9 >>> longest_increasing_subsequence([1, 2, 2, 3, 4, 1]) 3 >>> longest_increasing_subsequence([5, 1, 2, 3, 4]) 4 >>> longest_increasing_subsequence([1, 3, 5, 7, 8, 2, 4, 6, 9]) 5 >>> longest_increasing_subsequence([-1, -2, -3, -4, -5]) 1 >>> longest_increasing_subsequence([10]) 1","solution":"def longest_increasing_subsequence(arr): Find the length of the longest contiguous increasing subsequence in the given list of integers. Constraints: 1 <= len(arr) <= 10^5, -10^9 <= arr[i] <= 10^9 if not arr: return 0 max_len = 1 current_len = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 max_len = max(max_len, current_len) return max_len"},{"question":"from typing import List def max_consecutive_revenue(revenues: List[int], n: int) -> int: Returns the maximum total revenue from any consecutive \`n\` days. If \`n\` is greater than the length of the revenues list, raises ValueError. :param revenues: List of integers, each representing the revenue made each day of a year (365 entries) :param n: Integer, the number of consecutive days to consider for maximum total revenue :return: Integer, the maximum total revenue from any consecutive \`n\` days import pytest def test_max_consecutive_revenue_basic(): revenues = [10] * 365 assert max_consecutive_revenue(revenues, 1) == 10 assert max_consecutive_revenue(revenues, 2) == 20 assert max_consecutive_revenue(revenues, 365) == 3650 def test_max_consecutive_revenue_mixed(): revenues = [i for i in range(365)] assert max_consecutive_revenue(revenues, 1) == 364 assert max_consecutive_revenue(revenues, 2) == 727 assert max_consecutive_revenue(revenues, 365) == sum(range(365)) def test_max_consecutive_revenue_negative(): revenues = [-1] * 365 assert max_consecutive_revenue(revenues, 1) == -1 assert max_consecutive_revenue(revenues, 2) == -2 assert max_consecutive_revenue(revenues, 365) == -365 def test_max_consecutive_revenue_mixed_sign(): revenues = [-100, 100] * 182 + [0] assert max_consecutive_revenue(revenues, 1) == 100 assert max_consecutive_revenue(revenues, 2) == 100 assert max_consecutive_revenue(revenues, 4) == 100 assert max_consecutive_revenue(revenues, 365) == 0 def test_max_consecutive_revenue_exceptions(): revenues = [10] * 365 with pytest.raises(ValueError): max_consecutive_revenue(revenues, 366) with pytest.raises(ValueError): max_consecutive_revenue(revenues, 0) with pytest.raises(ValueError): max_consecutive_revenue(revenues, -1) with pytest.raises(ValueError): max_consecutive_revenue([10] * 364, 1)","solution":"def max_consecutive_revenue(revenues, n): Returns the maximum total revenue from any consecutive \`n\` days. If \`n\` is greater than the length of the revenues list, raises ValueError. :param revenues: List of integers, each representing the revenue made each day of a year (365 entries) :param n: Integer, the number of consecutive days to consider for maximum total revenue :return: Integer, the maximum total revenue from any consecutive \`n\` days if len(revenues) != 365: raise ValueError(\\"The input list must have exactly 365 entries.\\") if n > 365: raise ValueError(\\"The number of consecutive days \`n\` cannot be greater than 365.\\") if n <= 0: raise ValueError(\\"The number of consecutive days \`n\` must be a positive integer.\\") max_revenue = sum(revenues[:n]) current_revenue = max_revenue for i in range(n, 365): current_revenue = current_revenue - revenues[i-n] + revenues[i] if current_revenue > max_revenue: max_revenue = current_revenue return max_revenue"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted linked lists l1 and l2 and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: l1 = [1,2,4] l2 = [1,3,4] Output: [1,1,2,3,4,4] Constraints: * The number of nodes in both lists is in the range [0, 50]. * -100 <= Node.val <= 100 * Both l1 and l2 are sorted in non-decreasing order. # Implementation here def list_to_linked_list(elements): Utility to convert a list to a linked list. dummy = ListNode() current = dummy for element in elements: current.next = new_node = ListNode(element) current = new_node return dummy.next def linked_list_to_list(node): Utility to convert a linked list to a list. elements = [] while node: elements.append(node.val) node = node.next return elements def test_merge_both_empty_lists(): assert linked_list_to_list(mergeTwoLists(None, None)) == [] def test_merge_first_empty_list(): l2 = list_to_linked_list([1, 3, 4]) assert linked_list_to_list(mergeTwoLists(None, l2)) == [1, 3, 4] def test_merge_second_empty_list(): l1 = list_to_linked_list([1, 2, 4]) assert linked_list_to_list(mergeTwoLists(l1, None)) == [1, 2, 4] def test_merge_non_empty_lists(): l1 = list_to_linked_list([1, 2, 4]) l2 = list_to_linked_list([1, 3, 4]) assert linked_list_to_list(mergeTwoLists(l1, l2)) == [1, 1, 2, 3, 4, 4] def test_merge_with_negative_values(): l1 = list_to_linked_list([-10, -5, 0, 5]) l2 = list_to_linked_list([-6, 1, 4]) assert linked_list_to_list(mergeTwoLists(l1, l2)) == [-10, -6, -5, 0, 1, 4, 5]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1, l2): Merge two sorted linked lists l1 and l2 and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists. dummy = ListNode() # Create a dummy node to form the new sorted linked list tail = dummy while l1 and l2: if l1.val <= l2.val: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next # Append the rest of the remaining list if one is exhausted tail.next = l1 if l1 else l2 return dummy.next"},{"question":"def is_unique_string(s: str) -> bool: Determines if a string has all unique characters. >>> is_unique_string(\\"hello\\") == False >>> is_unique_string(\\"world\\") == True >>> is_unique_string(\\"\\") == True >>> is_unique_string(\\"abcdefg\\") == True >>> is_unique_string(\\"aabbcc\\") == False def are_strings_unique(str_list: List[str]) -> List[bool]: Determines if each string in a list has all unique characters. >>> are_strings_unique([\\"hello\\", \\"world\\", \\"python\\", \\"\\"]) == [False, True, True, True] >>> are_strings_unique([\\"\\", \\"aa\\", \\"ab\\", \\"abc\\", \\"aabbcc\\"]) == [True, False, True, True, False] >>> are_strings_unique([\\"qwerty\\", \\"asdfgh\\", \\"zxcvbnm\\", \\"qqqq\\"]) == [True, True, True, False] >>> are_strings_unique([\\"alfa\\", \\"beta\\", \\"gamma\\", \\"delta\\"]) == [False, True, False, True]","solution":"def is_unique_string(s): Determines if a string has all unique characters. Args: s (str): The string to check. Returns: bool: True if all characters in the string are unique, False otherwise. char_set = set() for char in s: if char in char_set: return False char_set.add(char) return True def are_strings_unique(str_list): Determines if each string in a list has all unique characters. Args: str_list (list): List of strings to check. Returns: list: List of booleans indicating if each string has all unique characters. return [is_unique_string(s) for s in str_list]"},{"question":"def square_non_negatives(nums: list) -> list: Return a list of squared integers, removing negatives and duplicate values first. Args: nums: list of integers Returns: List of squared integers Examples: >>> square_non_negatives([1, -2, 3, -4, 5]) [1, 9, 25] >>> square_non_negatives([2, 2, -3, 3]) [4, 9] >>> square_non_negatives([-1, -2, -3]) [] >>> square_non_negatives([1, 2, 3]) [1, 4, 9] >>> square_non_negatives([]) [] >>> square_non_negatives([0, -1, 1]) [0, 1] >>> square_non_negatives([0, 0, 0]) [0]","solution":"def square_non_negatives(nums: list) -> list: Return a list of squared integers, removing negatives and duplicate values first. Args: nums: list of integers Returns: List of squared integers # Remove negative numbers and duplicates positive_unique_nums = set(num for num in nums if num >= 0) # Square the filtered numbers squared_nums = [num ** 2 for num in positive_unique_nums] return squared_nums"},{"question":"import random def simulate_robot() -> int: Simulate the robot's movement on an 8x8 grid. The robot starts at (1, 1) and collects energy units in a specified area. Returns the number of steps taken for the robot to collect 10 energy units and then reach the teleporter at (8, 8). pass def expected_steps(num_simulations: int = 10000) -> float: Calculate the expected number of steps for the robot to collect 10 energy units and reach the teleporter. Args: num_simulations (int): Number of simulations to run. Returns: float: The expected number of steps rounded to 6 decimal places. >>> expected_steps(1000) > 0 pass # Example unit tests def test_simulate_robot(): result = simulate_robot() assert result > 0 def test_expected_steps(): result = expected_steps(1000) assert result > 0 # As there should be always a positive step count.","solution":"import random def simulate_robot(): grid_size = 8 start = (1, 1) teleporter = (8, 8) energy_area = {(i, j) for i in range(3, 7) for j in range(3, 7)} position = start energy_units = 0 steps = 0 while energy_units < 10 or position != teleporter: # Random move x, y = position move = random.choice([(0, 1), (0, -1), (1, 0), (-1, 0)]) # right, left, down, up new_position = (x + move[0], y + move[1]) # Ensure the new position is within bounds if 1 <= new_position[0] <= grid_size and 1 <= new_position[1] <= grid_size: position = new_position steps += 1 # Check for energy area if position in energy_area: energy_units += 1 # Check for teleporter if energy_units >= 10 and position == teleporter: break # Teleport back to start if position == teleporter: position = start return steps def expected_steps(num_simulations=10000): # Perform simulation multiple times and calculate average steps total_steps = sum(simulate_robot() for _ in range(num_simulations)) return round(total_steps / num_simulations, 6)"},{"question":"def longest_increasing_subsequence(nums): Find the length of the longest increasing subsequence in a list of integers. The subsequence elements must appear in the same order as in the original list. Examples: >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([10]) 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9]) 9 >>> longest_increasing_subsequence([9, 8, 7, 6, 5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) 3 >>> longest_increasing_subsequence([2, 2, 2, 2, 2, 2, 2]) 1 >>> longest_increasing_subsequence([-1, 3, 4, 5, 2, 2, 2, 2]) 4","solution":"def longest_increasing_subsequence(nums): Finds the length of the longest increasing subsequence in a list of integers. :param nums: List of integers :return: Length of the longest increasing subsequence if not nums: return 0 dp = [1] * len(nums) # Initialize dp array to store the length of LIS ending at each index for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"import math from typing import List def is_perfect_square(x: int) -> bool: Check if x is a perfect square. >>> is_perfect_square(4) True >>> is_perfect_square(5) False s = int(math.sqrt(x)) return s * s == x def a(k: int) -> int: Returns the k-th term of the sequence a(n). >>> a(1) 1 >>> a(2) 3 >>> a(3) 6 >>> a(4) 10 >>> a(5) 15 >>> a(6) 21 >>> a(7) 28 >>> a(8) 36 >>> a(10) 55 >>> a(20) 210","solution":"import math def is_perfect_square(x): Check if x is a perfect square. s = int(math.sqrt(x)) return s * s == x def a(k): Returns the k-th term of the sequence a(n). if k == 1: return 1 sequence = [1] while len(sequence) < k: previous = sequence[-1] next_value = previous + 1 while not is_perfect_square(previous + next_value): next_value += 1 sequence.append(next_value) return sequence[-1]"},{"question":"class BankingSystem: A class to simulate a basic banking system. Provides methods to create user accounts, deposit money, withdraw money, check the balance, and display transaction history. >>> bank = BankingSystem() >>> bank.create_account('123456', 'Alice', 1000) >>> bank.deposit('123456', 500) >>> bank.withdraw('123456', 200) >>> balance = bank.check_balance('123456') >>> history = bank.get_transaction_history('123456') >>> print('Balance:', balance) 1300 >>> print('Transaction History:', history) ['Deposit: 500', 'Withdrawal: 200'] def __init__(self): self.accounts = {} def create_account(self, account_number, user_name, initial_balance): pass def deposit(self, account_number, amount): pass def withdraw(self, account_number, amount): pass def check_balance(self, account_number): pass def get_transaction_history(self, account_number): pass","solution":"class BankingSystem: def __init__(self): self.accounts = {} def create_account(self, account_number, user_name, initial_balance): if account_number in self.accounts: raise ValueError(\\"Account number already exists.\\") if initial_balance < 0: raise ValueError(\\"Initial balance cannot be negative.\\") self.accounts[account_number] = { \\"user_name\\": user_name, \\"balance\\": initial_balance, \\"transactions\\": [] } def deposit(self, account_number, amount): if amount <= 0: raise ValueError(\\"Deposit amount must be positive.\\") if account_number not in self.accounts: raise ValueError(\\"Account does not exist.\\") self.accounts[account_number][\\"balance\\"] += amount self.accounts[account_number][\\"transactions\\"].append(f\\"Deposit: {amount}\\") def withdraw(self, account_number, amount): if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive.\\") if account_number not in self.accounts: raise ValueError(\\"Account does not exist.\\") if self.accounts[account_number][\\"balance\\"] < amount: raise ValueError(\\"Insufficient funds.\\") self.accounts[account_number][\\"balance\\"] -= amount self.accounts[account_number][\\"transactions\\"].append(f\\"Withdrawal: {amount}\\") def check_balance(self, account_number): if account_number not in self.accounts: raise ValueError(\\"Account does not exist.\\") return self.accounts[account_number][\\"balance\\"] def get_transaction_history(self, account_number): if account_number not in self.accounts: raise ValueError(\\"Account does not exist.\\") return self.accounts[account_number][\\"transactions\\"]"},{"question":"def extract_unique_words(sentence: str) -> List[str]: Identify and extract all the unique words from a given sentence and return a list of words sorted in alphabetical order. All words should be converted to lowercase and punctuation marks are considered as part of the words. >>> extract_unique_words(\\"Hello world! Hello Python.\\") ['hello', 'python.', 'world!'] >>> extract_unique_words(\\"Hello, Hello... World? World!\\") ['hello,', 'hello...', 'world!', 'world?'] >>> extract_unique_words(\\"apple banana apple\\") ['apple', 'banana'] >>> extract_unique_words(\\"Apple apple Banana banana\\") ['apple', 'banana'] >>> extract_unique_words(\\"\\") [] >>> extract_unique_words(\\"Only\\") ['only'] >>> extract_unique_words(\\"word1, word2. word3;word4:word5\\") ['word1,', 'word2.', 'word3;word4:word5']","solution":"def extract_unique_words(sentence): This function receives a sentence, extracts all unique words and returns them in alphabetical order. All words are converted to lowercase. # Split the sentence into words based on spaces words = sentence.split() # Convert all words to lowercase lower_words = [word.lower() for word in words] # Get unique words using set unique_words = set(lower_words) # Sort the unique words alphabetically sorted_unique_words = sorted(unique_words) return sorted_unique_words"},{"question":"def restore_ip_addresses(s: str) -> List[str]: Given a string containing only digits, find all possible valid IP addresses that can be formed by inserting dots into the string. An IP address consists of four numbers separated by dots, and each number ranges between 0 and 255. Note that numbers should not have leading zeros except for zero itself. Return all valid IP addresses in any order. >>> restore_ip_addresses(\\"25525511135\\") [\\"255.255.11.135\\", \\"255.255.111.35\\"] >>> restore_ip_addresses(\\"0000\\") [\\"0.0.0.0\\"] >>> restore_ip_addresses(\\"1111\\") [\\"1.1.1.1\\"] import pytest from solution import restore_ip_addresses def test_restore_ip_addresses_example1(): assert sorted(restore_ip_addresses(\\"25525511135\\")) == sorted([\\"255.255.11.135\\", \\"255.255.111.35\\"]) def test_restore_ip_addresses_example2(): assert restore_ip_addresses(\\"0000\\") == [\\"0.0.0.0\\"] def test_restore_ip_addresses_example3(): assert restore_ip_addresses(\\"1111\\") == [\\"1.1.1.1\\"] def test_restore_ip_addresses_example4(): assert sorted(restore_ip_addresses(\\"101023\\")) == sorted([\\"1.0.10.23\\", \\"1.0.102.3\\", \\"10.1.0.23\\", \\"10.10.2.3\\", \\"101.0.2.3\\"]) def test_restore_ip_addresses_no_valid(): assert restore_ip_addresses(\\"999999999999999\\") == []","solution":"def restore_ip_addresses(s): Returns a list of all possible valid IP addresses that can be formed by inserting dots into the string s. def is_valid(segment): # A segment is valid if it is between 0 and 255, and has no leading zeros unless it is \\"0\\" return len(segment) == 1 or (segment[0] != '0' and int(segment) <= 255) def backtrack(start=0, path=[]): if len(path) == 4: # If 4 segments are formed and we've used all the string, then it's a valid address if start == len(s): valid_ips.append('.'.join(path)) return # Choose segments of length 1 to 3 for length in range(1, 4): if start + length <= len(s): segment = s[start:start+length] if is_valid(segment): backtrack(start+length, path + [segment]) valid_ips = [] backtrack() return valid_ips"},{"question":"def longestConsecutiveSubsequence(numbers): Write a function that computes the longest sub-sequence of consecutive integers in an unsorted list of integers. The function should return both the length of the longest consecutive sub-sequence and the sub-sequence itself, sorted in ascending order. It should handle edge cases such as an empty list or a list with all identical elements correctly. >>> longestConsecutiveSubsequence([100, 4, 200, 1, 3, 2]) (4, [1, 2, 3, 4]) >>> longestConsecutiveSubsequence([2, 2, 3, 1, 1, 4, 4]) (4, [1, 2, 3, 4]) >>> longestConsecutiveSubsequence([1, 1, 1, 1]) (1, [1]) >>> longestConsecutiveSubsequence([3, 7, 2, 5, 8, 9, 1, 4]) (5, [1, 2, 3, 4, 5]) >>> longestConsecutiveSubsequence([]) (0, []) >>> longestConsecutiveSubsequence([7]) (1, [7]) >>> longestConsecutiveSubsequence([-1, -2, -3, 0, 1, 2]) (6, [-3, -2, -1, 0, 1, 2])","solution":"def longestConsecutiveSubsequence(numbers): if not numbers: return (0, []) numbers_set = set(numbers) longest_seq = [] for number in numbers_set: if number - 1 not in numbers_set: # Start of a new sequence current_seq = [] current_number = number while current_number in numbers_set: current_seq.append(current_number) current_number += 1 if len(current_seq) > len(longest_seq): longest_seq = current_seq return (len(longest_seq), sorted(longest_seq))"},{"question":"def count_unique_substrings(s: str) -> int: Returns the number of unique substrings in the given string. The function is case-sensitive and efficient enough to handle strings up to length 1000. >>> count_unique_substrings(\\"abcabc\\") 15 >>> count_unique_substrings(\\"ababa\\") 9 from solution import count_unique_substrings def test_count_unique_substrings_abcabc(): assert count_unique_substrings(\\"abcabc\\") == 15 def test_count_unique_substrings_ababa(): assert count_unique_substrings(\\"ababa\\") == 9 def test_count_unique_substrings_single_character(): assert count_unique_substrings(\\"a\\") == 1 def test_count_unique_substrings_empty_string(): assert count_unique_substrings(\\"\\") == 0 def test_count_unique_substrings_repeated_character(): assert count_unique_substrings(\\"aaa\\") == 3 def test_count_unique_substrings_mixed_case(): assert count_unique_substrings(\\"AaAa\\") == 7","solution":"def count_unique_substrings(s: str) -> int: Returns the number of unique substrings in the given string. unique_substrings = set() n = len(s) for i in range(n): for j in range(i + 1, n + 1): unique_substrings.add(s[i:j]) return len(unique_substrings)"},{"question":"from typing import List def maxProfit(prices: List[int]) -> int: This function takes a list of stock prices and returns the maximum profit that can be achieved by buying and selling one stock. If no profit can be achieved, it returns 0. Args: prices (List[int]): A list of integers representing stock prices. Returns: int: The maximum profit that can be achieved. Examples: >>> maxProfit([7, 1, 5, 3, 6, 4]) 5 >>> maxProfit([7, 6, 4, 3, 1]) 0 # Your code here def test_maxProfit_example(): assert maxProfit([7, 1, 5, 3, 6, 4]) == 5 def test_maxProfit_no_profit(): assert maxProfit([7, 6, 4, 3, 1]) == 0 def test_maxProfit_single_element(): assert maxProfit([1]) == 0 def test_maxProfit_empty_list(): assert maxProfit([]) == 0 def test_maxProfit_two_elements(): assert maxProfit([1, 5]) == 4 assert maxProfit([5, 1]) == 0 def test_maxProfit_price_fluctuates(): assert maxProfit([3, 8, 2, 5, 7, 1, 9]) == 8 assert maxProfit([1, 8, 2, 7, 3, 9]) == 8 def test_maxProfit_all_same_prices(): assert maxProfit([5, 5, 5, 5, 5]) == 0 def test_maxProfit_large_input(): prices = list(range(10000, 0, -1)) assert maxProfit(prices) == 0 prices = list(range(10000)) assert maxProfit(prices) == 9999","solution":"from typing import List def maxProfit(prices: List[int]) -> int: This function takes a list of stock prices and returns the maximum profit that can be achieved by buying and selling one stock. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: # Update the minimum price encountered so far if price < min_price: min_price = price # Calculate the current potential profit profit = price - min_price # Update the maximum profit encountered so far if profit > max_profit: max_profit = profit return max_profit"},{"question":"from typing import List def extract_primes(numbers: List[int]) -> List[int]: Given a list of integers, returns a new list containing only the prime numbers. Optimizations include trial division by numbers up to the square root of the target number, skipping even numbers and multiples of 3 beyond the initial checks. >>> extract_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> extract_primes([11, 13, 17, 19, 23]) [11, 13, 17, 19, 23] >>> extract_primes([4, 6, 8, 10, 12]) [] >>> extract_primes([-10, -3, 0, 1, 2, 3]) [2, 3] >>> extract_primes([29, 31, 37, 41, 43, 47, 49, 51, 53]) [29, 31, 37, 41, 43, 47, 53] pass def is_prime(n: int) -> bool: Returns True if n is a prime number, False otherwise. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(18) False >>> is_prime(19) True pass","solution":"def is_prime(n): Returns True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def extract_primes(numbers): Given a list of integers, returns a new list containing only the prime numbers. Optimizations include trial division by numbers up to the square root of the target number, skipping even numbers and multiples of 3 beyond the initial checks. return [num for num in numbers if is_prime(num)]"},{"question":"def navigate_robot(movements: list) -> tuple: Simulates a simple version of a navigation system for a robot on a 2D grid. Parameters: movements (list of str): List of movements (e.g., [\\"up\\", \\"down\\", \\"left\\", \\"right\\"]). Returns: tuple: Final coordinates of the robot (x, y). >>> navigate_robot([]) (0, 0) >>> navigate_robot([\\"up\\", \\"up\\", \\"up\\"]) (0, 3) >>> navigate_robot([\\"down\\", \\"down\\"]) (0, -2) >>> navigate_robot([\\"left\\", \\"left\\"]) (-2, 0) >>> navigate_robot([\\"right\\", \\"right\\", \\"right\\"]) (3, 0) >>> navigate_robot([\\"up\\", \\"up\\", \\"left\\", \\"down\\", \\"right\\", \\"right\\"]) (1, 1) >>> navigate_robot([\\"up\\", \\"down\\", \\"somewhere\\", \\"left\\", \\"right\\", \\"unknown\\"]) (0, 0)","solution":"def navigate_robot(movements): Simulates a simple version of a navigation system for a robot on a 2D grid. Parameters: movements (list of str): List of movements (e.g., [\\"up\\", \\"down\\", \\"left\\", \\"right\\"]). Returns: tuple: Final coordinates of the robot (x, y). x, y = 0, 0 # Start at the origin (0, 0) for move in movements: if move == \\"up\\": y += 1 elif move == \\"down\\": y -= 1 elif move == \\"left\\": x -= 1 elif move == \\"right\\": x += 1 # Invalid moves are ignored return (x, y)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: Determine if a given binary tree is balanced. A balanced binary tree is defined as a tree where the depth of all the leaf nodes or nodes with a single child differ by at most one. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> is_balanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> is_balanced(root) False >>> is_balanced(None) True >>> root = TreeNode(1) >>> is_balanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> is_balanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.left.left = TreeNode(5) >>> is_balanced(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) curr_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 curr_height = 1 + max(left_height, right_height) return curr_height, curr_balanced _, balanced = check_balance(root) return balanced"},{"question":"def fibonacci(n): Returns the nth Fibonacci number. Parameters: n (int): The position in the Fibonacci sequence Returns: int: The nth Fibonacci number Raises: ValueError: If the input is not a non-negative integer Example: >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(10) 55","solution":"def fibonacci(n): Returns the nth Fibonacci number. Parameters: n (int): The position in the Fibonacci sequence Returns: int: The nth Fibonacci number Raises: ValueError: If the input is not a non-negative integer if not isinstance(n, int): raise ValueError(\\"Input must be an integer\\") if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def compress_string(s: str) -> str: Compresses the string using counts of repeated characters. If the compressed string is not smaller than the original string, return the original string. >>> compress_string(\\"aabcccccaaa\\") 'a2b1c5a3' >>> compress_string(\\"abcdef\\") 'abcdef' pass # Example usage: # print(compress_string(\\"aabcccccaaa\\")) # Output: 'a2b1c5a3' # print(compress_string(\\"abcdef\\")) # Output: 'abcdef'","solution":"def compress_string(s): Compresses the string using counts of repeated characters. If the compressed string is not smaller than the original string, return the original string. if not s: return s compressed = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: compressed.append(current_char + str(count)) current_char = char count = 1 compressed.append(current_char + str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def explain_immutability(): Explains the significance of immutability in functional programming. Immutability refers to the state of an object that cannot be modified after it is created. In functional programming, immutability is a core principle that promotes safer and more predictable code. Here's why immutability is significant: 1. **Predictability**: When data is immutable, functions that use and produce it are much more predictable since values cannot be altered unexpectedly. 2. **Concurrency**: Immutability makes it easier to write concurrent and parallel programs since there is no need to worry about shared mutable state and the associated race conditions. 3. **Debugging and Testing**: Programs with immutable data are easier to debug and test, because data does not change state unpredictably, which simplifies understanding of the program flow and logic. # Examples - **Haskell**: In Haskell, immutability is strictly enforced. All data by default cannot be modified after creation. For example, lists and other data structures in Haskell are immutable. - **Clojure**: In Clojure, data structures like lists, vectors, sets, and maps are immutable by default. # Pros and Cons of Immutability Pros: - **Safety**: Immutable data eliminates accidental modification, leading to fewer bugs. - **Simplicity**: It simplifies the reasoning about the state of data at any point in time. - **Branching and History**: Supports safe branching and snapshotting of data, useful for undo functionality. Cons: - **Performance**: Frequent creation of new immutable structures can lead to performance overhead. - **Memory Usage**: May require more memory as old versions of structures are retained. # Strategies for Leveraging Immutability - **Persistent Data Structures**: Use data structures that are designed to be efficient in an immutable context. Many functional languages provide these out-of-the-box. - **Referential Transparency**: Write functions that produce outputs solely dependent on their inputs, without side effects. - **Functional Patterns**: Embrace functional programming patterns, like map, reduce, and filter, for processing collections without mutating them. By effectively leveraging immutability, developers can create software that is both robust and maintainable, minimizing bugs related to state changes.","solution":"def explain_immutability(): Explains the significance of immutability in functional programming. Immutability refers to the state of an object that cannot be modified after it is created. In functional programming, immutability is a core principle that promotes safer and more predictable code. Here's why immutability is significant: 1. **Predictability**: When data is immutable, functions that use and produce it are much more predictable since values cannot be altered unexpectedly. 2. **Concurrency**: Immutability makes it easier to write concurrent and parallel programs since there is no need to worry about shared mutable state and the associated race conditions. 3. **Debugging and Testing**: Programs with immutable data are easier to debug and test, because data does not change state unpredictably, which simplifies understanding of the program flow and logic. # Examples - **Haskell**: In Haskell, immutability is strictly enforced. All data by default cannot be modified after creation. For example, lists and other data structures in Haskell are immutable. - **Clojure**: In Clojure, data structures like lists, vectors, sets, and maps are immutable by default. # Pros and Cons of Immutability Pros: - **Safety**: Immutable data eliminates accidental modification, leading to fewer bugs. - **Simplicity**: It simplifies the reasoning about the state of data at any point in time. - **Branching and History**: Supports safe branching and snapshotting of data, useful for undo functionality. Cons: - **Performance**: Frequent creation of new immutable structures can lead to performance overhead. - **Memory Usage**: May require more memory as old versions of structures are retained. # Strategies for Leveraging Immutability - **Persistent Data Structures**: Use data structures that are designed to be efficient in an immutable context. Many functional languages provide these out-of-the-box. - **Referential Transparency**: Write functions that produce outputs solely dependent on their inputs, without side effects. - **Functional Patterns**: Embrace functional programming patterns, like map, reduce, and filter, for processing collections without mutating them. By effectively leveraging immutability, developers can create software that is both robust and maintainable, minimizing bugs related to state changes. return { \\"significance\\": [ \\"Predictability\\", \\"Concurrency\\", \\"Debugging and Testing\\" ], \\"examples\\": { \\"Haskell\\": \\"Lists and other data structures are immutable by default.\\", \\"Clojure\\": \\"Lists, vectors, sets, and maps are immutable by default.\\" }, \\"pros\\": [ \\"Safety\\", \\"Simplicity\\", \\"Branching and History\\" ], \\"cons\\": [ \\"Performance\\", \\"Memory Usage\\" ], \\"strategies\\": [ \\"Persistent Data Structures\\", \\"Referential Transparency\\", \\"Functional Patterns\\" ] }"},{"question":"import datetime class Task: def __init__(self, title: str, description: str, due_date: datetime.datetime, priority: int): self.title = title self.description = description self.due_date = due_date self.is_complete = False self.priority = priority def mark_complete(self): Mark the task as complete. self.is_complete = True class User: def __init__(self, username: str, password: str, is_admin: bool): self.username = username self.password = password self.is_admin = is_admin self.tasks = [] def create_task(self, title: str, description: str, due_date: datetime.datetime, priority: int) -> Task: Create a new task for the user. task = Task(title, description, due_date, priority) self.tasks.append(task) return task def edit_task(self, task_id: int, title: str = None, description: str = None, due_date: datetime.datetime = None, priority: int = None) -> Task: Edit an existing task of the user. task = self.tasks[task_id] if title: task.title = title if description: task.description = description if due_date: task.due_date = due_date if priority is not None: task.priority = priority return task def delete_task(self, task_id: int): Delete an existing task of the user. self.tasks.pop(task_id) def mark_task_complete(self, task_id: int) -> bool: Mark an existing task of the user as complete. task = self.tasks[task_id] task.mark_complete() return task.is_complete # Unit Test def test_create_task(): user = User(username=\\"testuser\\", password=\\"password123\\", is_admin=False) due_date = datetime.datetime(2023, 11, 1) task = user.create_task(title=\\"Test Task\\", description=\\"Task description\\", due_date=due_date, priority=1) assert task.title == \\"Test Task\\" assert task.description == \\"Task description\\" assert task.due_date == due_date assert not task.is_complete assert task.priority == 1 def test_edit_task(): user = User(username=\\"testuser\\", password=\\"password123\\", is_admin=False) due_date = datetime.datetime(2023, 11, 1) task = user.create_task(title=\\"Test Task\\", description=\\"Task description\\", due_date=due_date, priority=1) updated_due_date = datetime.datetime(2023, 12, 1) edited_task = user.edit_task(task_id=0, title=\\"Updated Task\\", description=\\"Updated description\\", due_date=updated_due_date, priority=2) assert edited_task.title == \\"Updated Task\\" assert edited_task.description == \\"Updated description\\" assert edited_task.due_date == updated_due_date assert edited_task.priority == 2 def test_delete_task(): user = User(username=\\"testuser\\", password=\\"password123\\", is_admin=False) due_date = datetime.datetime(2023, 11, 1) task1 = user.create_task(title=\\"Test Task 1\\", description=\\"Task 1 description\\", due_date=due_date, priority=1) task2 = user.create_task(title=\\"Test Task 2\\", description=\\"Task 2 description\\", due_date=due_date, priority=1) user.delete_task(task_id=0) assert len(user.tasks) == 1 assert user.tasks[0].title == \\"Test Task 2\\" def test_mark_task_complete(): user = User(username=\\"testuser\\", password=\\"password123\\", is_admin=False) due_date = datetime.datetime(2023, 11, 1) task = user.create_task(title=\\"Test Task\\", description=\\"Task description\\", due_date=due_date, priority=1) is_complete = user.mark_task_complete(task_id=0) assert is_complete assert task.is_complete # Running unit tests test_create_task() test_edit_task() test_delete_task() test_mark_task_complete()","solution":"import datetime class Task: def __init__(self, title, description, due_date, priority): self.title = title self.description = description self.due_date = due_date self.is_complete = False self.priority = priority def mark_complete(self): self.is_complete = True class User: def __init__(self, username, password, is_admin): self.username = username self.password = password self.is_admin = is_admin self.tasks = [] def create_task(self, title, description, due_date, priority): task = Task(title, description, due_date, priority) self.tasks.append(task) return task def edit_task(self, task_id, title=None, description=None, due_date=None, priority=None): task = self.tasks[task_id] if title: task.title = title if description: task.description = description if due_date: task.due_date = due_date if priority is not None: task.priority = priority return task def delete_task(self, task_id): self.tasks.pop(task_id) def mark_task_complete(self, task_id): task = self.tasks[task_id] task.mark_complete() return task.is_complete"},{"question":"from datetime import datetime, timedelta from typing import List, Tuple, Dict def filter_and_sum_transactions(transactions: List[Tuple[str, str, float]], current_date: str) -> Dict[str, float]: Filters out transactions that occurred only in the past month and then calculates the total transaction amount for each user. Args: transactions (list of tuples): List of transactions where each transaction is a tuple (user_id, date, amount). current_date (str): The current date in 'YYYY-MM-DD' format. Returns: dict: A dictionary where the keys are the user IDs and the values are their respective total transaction amounts for the past month. pass # Implement the function here # Unit tests def test_filter_and_sum_transactions_empty(): assert filter_and_sum_transactions([], '2023-10-17') == {} def test_filter_and_sum_transactions_no_transactions_in_last_month(): transactions = [ ('user1', '2023-08-15', 100), ('user2', '2023-07-20', 200) ] assert filter_and_sum_transactions(transactions, '2023-10-17') == {} def test_filter_and_sum_transactions_single_user(): transactions = [ ('user1', '2023-10-01', 100), ('user1', '2023-10-05', 150), ('user1', '2023-09-18', 50), ] assert filter_and_sum_transactions(transactions, '2023-10-17') == {'user1': 300} def test_filter_and_sum_transactions_multiple_users(): transactions = [ ('user1', '2023-09-20', 100), ('user2', '2023-10-01', 200), ('user1', '2023-10-10', 150), ('user3', '2023-09-25', 50), ('user2', '2023-09-15', 50), ] assert filter_and_sum_transactions(transactions, '2023-10-17') == { 'user1': 250, 'user2': 200, 'user3': 50 } def test_filter_and_sum_transactions_edge_case(): transactions = [ ('user1', '2023-09-17', 100), # Exactly one month ago, should be included ('user2', '2023-10-01', 200), ('user3', '2023-09-16', 50) # Just over one month ago, should not be included ] assert filter_and_sum_transactions(transactions, '2023-10-17') == {'user1': 100, 'user2': 200}","solution":"from datetime import datetime, timedelta def filter_and_sum_transactions(transactions, current_date): Filters out transactions that occurred only in the past month and then calculates the total transaction amount for each user. Args: transactions (list of tuples): List of transactions where each transaction is a tuple (user_id, date, amount). current_date (str): The current date in 'YYYY-MM-DD' format. Returns: dict: A dictionary where the keys are the user IDs and the values are their respective total transaction amounts for the past month. current_date = datetime.strptime(current_date, '%Y-%m-%d') one_month_ago = current_date - timedelta(days=30) user_totals = {} for user_id, date, amount in transactions: transaction_date = datetime.strptime(date, '%Y-%m-%d') if one_month_ago <= transaction_date <= current_date: if user_id in user_totals: user_totals[user_id] += amount else: user_totals[user_id] = amount return user_totals"},{"question":"def edit_distance(str1, str2): Computes the edit distance between two strings using dynamic programming. The edit distance is the minimum number of single-character edits (insertions, deletions, or substitutions) required to transform one string into the other. Args: str1 (str): The first string. str2 (str): The second string. Returns: int: The edit distance between the two strings. Raises: ValueError: If either of the inputs is not a string. >>> edit_distance(\\"kitten\\", \\"kitten\\") 0 >>> edit_distance(\\"kitten\\", \\"sitten\\") 1 >>> edit_distance(\\"kitten\\", \\"kittn\\") 1 >>> edit_distance(\\"kitten\\", \\"kittan\\") 1 >>> edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> edit_distance(\\"\\", \\"\\") 0 >>> edit_distance(\\"\\", \\"abc\\") 3 >>> edit_distance(\\"abc\\", \\"\\") 3 >>> edit_distance(\\"a\\", \\"a\\") 0 >>> edit_distance(\\"a\\", \\"b\\") 1 >>> edit_distance(\\"abc\\", \\"xyz\\") 3 >>> edit_distance(123, \\"abc\\") Traceback (most recent call last): ... ValueError: Both inputs must be strings >>> edit_distance(\\"abc\\", 123) Traceback (most recent call last): ... ValueError: Both inputs must be strings >>> edit_distance(123, 123) Traceback (most recent call last): ... ValueError: Both inputs must be strings # Your implementation here pass","solution":"def edit_distance(str1, str2): Computes the edit distance between two strings using dynamic programming. if not isinstance(str1, str) or not isinstance(str2, str): raise ValueError(\\"Both inputs must be strings\\") m, n = len(str1), len(str2) # Create a matrix to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the matrix for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill dp array using the distance formula for i in range(1, m + 1): for j in range(1, n + 1): if str1[i-1] == str2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i-1][j], # Deletion dp[i][j-1], # Insertion dp[i-1][j-1]) # Substitution return dp[m][n]"},{"question":"import pandas as pd def preprocess_customer_data(input_csv: str, output_csv: str): Preprocess a CSV dataset containing customer information. The preprocessing tasks include: 1. Reading the CSV dataset into a Pandas DataFrame. 2. Handling missing or null values in the 'Age' and 'PurchaseAmount' columns by filling them with the mean value of their respective columns. 3. Converting the 'JoinDate' column to datetime format and creating a new column 'DaysSinceJoining' that calculates the number of days each customer has been with the company. 4. Creating a new column 'CustomerCategory' that categorizes customers based on 'PurchaseAmount'. - \\"Low\\" for PurchaseAmount < 100, - \\"Medium\\" for 100 <= PurchaseAmount < 500, - \\"High\\" for PurchaseAmount >= 500. 5. Outputting the processed DataFrame and saving it to a new CSV file named 'processed_customers.csv'. :param input_csv: The path to the input CSV file :param output_csv: The path to the output CSV file >>> preprocess_customer_data(\\"customers.csv\\", \\"processed_customers.csv\\")","solution":"import pandas as pd def preprocess_customer_data(input_csv, output_csv): # Step 1: Read the CSV dataset into a Pandas DataFrame. df = pd.read_csv(input_csv) # Step 2: Handle any missing or null values in the 'Age' and 'PurchaseAmount' columns. df['Age'].fillna(df['Age'].mean(), inplace=True) df['PurchaseAmount'].fillna(df['PurchaseAmount'].mean(), inplace=True) # Step 3: Convert the 'JoinDate' column to datetime format. df['JoinDate'] = pd.to_datetime(df['JoinDate']) # Create a new column 'DaysSinceJoining' - number of days each customer has been with the company. df['DaysSinceJoining'] = (pd.Timestamp('now') - df['JoinDate']).dt.days # Step 4: Create a new column 'CustomerCategory' that categorizes customers based on 'PurchaseAmount'. df['CustomerCategory'] = pd.cut( df['PurchaseAmount'], bins=[-float('inf'), 100, 500, float('inf')], labels=['Low', 'Medium', 'High'] ) # Output the processed DataFrame and save it to a new CSV file named 'processed_customers.csv'. df.to_csv(output_csv, index=False) return df"},{"question":"def single_number(nums): Given a list of integers where every element appears twice except for one, write a function to find that single one. Your solution should have a linear runtime complexity and make use of constant space. >>> single_number([1]) 1 >>> single_number([2, 2, 1]) 1 >>> single_number([4, 1, 2, 1, 2]) 4 >>> single_number([1, 2, 3, 2, 3, 1, 4]) 4 >>> single_number([5, 10, 14, 10, 5]) 14 >>> single_number([-1, -2, -2]) -1 >>> single_number([4, -1, 2, 1, 2, 1, 4]) -1","solution":"def single_number(nums): Given a list of integers where every element appears twice except for one, finds that single one. Uses XOR operation to achieve linear runtime complexity and constant space. result = 0 for num in nums: result ^= num return result"},{"question":"def traffic_light_controller(green_duration, yellow_duration, red_duration, iterations): Simulates a basic traffic light controller system that cycles through Green, Yellow, and Red states. Parameters: green_duration (int): Duration for Green light in seconds. yellow_duration (int): Duration for Yellow light in seconds. red_duration (int): Duration for Red light in seconds. iterations (int): Number of cycles to run the traffic light. pass def defective_traffic_light_controller(green_duration, yellow_duration, red_duration, iterations): A defective implementation of traffic light controller where the sleep is not properly applied. pass def test_traffic_light_controller(capsys): traffic_light_controller(1, 1, 1, 1) captured = capsys.readouterr() output = captured.out.strip().split('n') expected_output = [ 'State: Green, Duration: 1', 'State: Yellow, Duration: 1', 'State: Red, Duration: 1', ] assert output == expected_output def test_defective_traffic_light_controller(capsys): defective_traffic_light_controller(1, 1, 1, 1) captured = capsys.readouterr() output = captured.out.strip().split('n') expected_output = [ 'State: Green, Duration: 1', 'State: Yellow, Duration: 1', 'State: Red, Duration: 1', ] assert output == expected_output def test_multiple_iterations(capsys): traffic_light_controller(1, 1, 1, 2) captured = capsys.readouterr() output = captured.out.strip().split('n') expected_output = [ 'State: Green, Duration: 1', 'State: Yellow, Duration: 1', 'State: Red, Duration: 1', 'State: Green, Duration: 1', 'State: Yellow, Duration: 1', 'State: Red, Duration: 1', ] assert output == expected_output","solution":"import time def traffic_light_controller(green_duration, yellow_duration, red_duration, iterations): Simulates a basic traffic light controller system that cycles through Green, Yellow, and Red states. Parameters: green_duration (int): Duration for Green light in seconds. yellow_duration (int): Duration for Yellow light in seconds. red_duration (int): Duration for Red light in seconds. iterations (int): Number of cycles to run the traffic light. states = [ ('Green', green_duration), ('Yellow', yellow_duration), ('Red', red_duration), ] for i in range(iterations): for state, duration in states: print(f'State: {state}, Duration: {duration}') time.sleep(duration) # Defective implementation: The durations for each state are not respected properly. # The 'sleep' calls were omitted, leading to incorrect timing of state changes. def defective_traffic_light_controller(green_duration, yellow_duration, red_duration, iterations): A defective implementation of traffic light controller where the sleep is not properly applied. states = [ ('Green', green_duration), ('Yellow', yellow_duration), ('Red', red_duration), ] for i in range(iterations): for state, duration in states: print(f'State: {state}, Duration: {duration}') # missing time.sleep(duration) here results in no delay between state changes # Explanation of the flaw in the defective implementation: In the defective implementation, the call to time.sleep(duration) is missing. This function call is necessary to ensure that each state lasts for the specified duration. Without the call to time.sleep(duration), the state transitions will happen immediately one after another without any delay, which does not simulate the traffic light correctly."},{"question":"from typing import List def swapDiagonals(matrix: List[List[int]]) -> List[List[int]]: Write a function that swaps the main diagonal with the anti-diagonal in a given square matrix. >>> swapDiagonals([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [3, 2, 1], [4, 5, 6], [9, 8, 7] ] >>> swapDiagonals([ ... [10, 11, 12, 13], ... [14, 15, 16, 17], ... [18, 19, 20, 21], ... [22, 23, 24, 25] ... ]) [ [13, 11, 12, 10], [14, 16, 15, 17], [18, 20, 19, 21], [25, 23, 24, 22] ]","solution":"def swapDiagonals(matrix): This function swaps the main diagonal with the anti-diagonal in a given square matrix. n = len(matrix) for i in range(n): main_diagonal_element = matrix[i][i] anti_diagonal_element = matrix[i][n - i - 1] # Swapping the elements matrix[i][i] = anti_diagonal_element matrix[i][n - i - 1] = main_diagonal_element return matrix"},{"question":"def shift_list(lst: List[int], shift: int) -> List[int]: Shift elements of the list to the left by a specified number of positions. The elements shifted out should be re-introduced at the end in the same order. Supports negative shift values for right shifts. >>> shift_list([1, 2, 3, 4, 5], 2) [3, 4, 5, 1, 2] >>> shift_list([10, 20, 30, 40, 50], -1) [50, 10, 20, 30, 40] pass from typing import List def test_shift_list_single_shift(): assert shift_list([1, 2, 3, 4, 5], 1) == [2, 3, 4, 5, 1] def test_shift_list_multiple_shifts(): assert shift_list([1, 2, 3, 4, 5], 2) == [3, 4, 5, 1, 2] def test_shift_list_no_shift(): assert shift_list([10, 20, 30, 40, 50], 0) == [10, 20, 30, 40, 50] def test_shift_list_negative_shift(): assert shift_list([10, 20, 30, 40, 50], -1) == [50, 10, 20, 30, 40] def test_shift_list_shift_equals_length(): assert shift_list([1, 2, 3, 4], 4) == [1, 2, 3, 4] def test_shift_list_shift_greater_than_length(): assert shift_list([1, 2, 3, 4], 6) == [3, 4, 1, 2] def test_shift_list_empty_list(): assert shift_list([], 3) == [] def test_shift_list_negative_shift_greater_than_length(): assert shift_list([10, 20, 30, 40, 50], -6) == [50, 10, 20, 30, 40]","solution":"def shift_list(lst, shift): Shift elements of the list to the left by a specified number of positions. The elements shifted out should be re-introduced at the end in the same order. Supports negative shift values for right shifts. if not lst: return [] shift = shift % len(lst) # Handle shifts greater than len(lst) return lst[shift:] + lst[:shift]"},{"question":"def filter_and_sort_users(users): Filters out users under 18 years old, sorts the remaining users by age in ascending order, and returns a new array of objects containing only the \\"id\\" and \\"name\\" of each user. :param users: List of user objects, each containing \\"id\\", \\"name\\", and \\"age\\" :return: List of filtered and sorted user objects containing only \\"id\\" and \\"name\\" from solution import filter_and_sort_users def test_filter_and_sort_users_with_mixed_ages(): users = [ {'id': 1, 'name': 'Alice', 'age': 17}, {'id': 2, 'name': 'Bob', 'age': 20}, {'id': 3, 'name': 'Charlie', 'age': 19}, {'id': 4, 'name': 'David', 'age': 18} ] expected = [ {'id': 4, 'name': 'David'}, {'id': 3, 'name': 'Charlie'}, {'id': 2, 'name': 'Bob'} ] assert filter_and_sort_users(users) == expected def test_filter_and_sort_users_all_underage(): users = [ {'id': 1, 'name': 'Alice', 'age': 17}, {'id': 2, 'name': 'Bob', 'age': 16}, ] expected = [] assert filter_and_sort_users(users) == expected def test_filter_and_sort_users_all_of_age(): users = [ {'id': 1, 'name': 'Alice', 'age': 18}, {'id': 2, 'name': 'Bob', 'age': 20}, {'id': 3, 'name': 'Charlie', 'age': 19}, ] expected = [ {'id': 1, 'name': 'Alice'}, {'id': 3, 'name': 'Charlie'}, {'id': 2, 'name': 'Bob'} ] assert filter_and_sort_users(users) == expected def test_filter_and_sort_empty_users(): users = [] expected = [] assert filter_and_sort_users(users) == expected def test_filter_and_sort_users_with_same_age(): users = [ {'id': 1, 'name': 'Alice', 'age': 18}, {'id': 2, 'name': 'Bob', 'age': 18}, {'id': 3, 'name': 'Charlie', 'age': 18} ] expected = [ {'id': 1, 'name': 'Alice'}, {'id': 2, 'name': 'Bob'}, {'id': 3, 'name': 'Charlie'} ] assert filter_and_sort_users(users) == expected","solution":"def filter_and_sort_users(users): Filters out users under 18 years old, sorts the remaining users by age in ascending order, and returns a new array of objects containing only the \\"id\\" and \\"name\\" of each user. :param users: List of user objects, each containing \\"id\\", \\"name\\", and \\"age\\" :return: List of filtered and sorted user objects containing only \\"id\\" and \\"name\\" # Filter out users under 18 filtered_users = list(filter(lambda user: user['age'] >= 18, users)) # Sort the remaining users by age in ascending order sorted_users = sorted(filtered_users, key=lambda user: user['age']) # Create a new array of objects with only \\"id\\" and \\"name\\" result = [{'id': user['id'], 'name': user['name']} for user in sorted_users] return result"},{"question":"def most_populated_city_category(cities: List[int]) -> str: Determines the category of the most populated city in the list. Parameters: cities (list): A list of integers representing the population of each city. Returns: str: The category of the most populated city: 'Small', 'Medium', 'Large', or 'No cities' if the list is empty. >>> most_populated_city_category([]) 'No cities' >>> most_populated_city_category([100, 1200, 320, 4500]) 'Small' >>> most_populated_city_category([5000, 15000, 20000]) 'Medium' >>> most_populated_city_category([22000, 34000, 56000]) 'Large' >>> most_populated_city_category([1000, 34000, 5600, 45000, 320]) 'Large' >>> most_populated_city_category([1000, 25000]) 'Large'","solution":"def most_populated_city_category(cities): Determines the category of the most populated city in the list. Parameters: cities (list): A list of integers representing the population of each city. Returns: str: The category of the most populated city: 'Small', 'Medium', 'Large', or 'No cities' if the list is empty. if not cities: return 'No cities' max_population = max(cities) if max_population < 5000: return 'Small' elif 5000 <= max_population <= 20000: return 'Medium' else: return 'Large'"},{"question":"def max_length_subarray(arr: List[int], k: int) -> int: Determines the maximum length of a contiguous subarray that sums exactly to k. If there is no such subarray, the function returns 0. :param arr: List[int] - array of integers :param k: int - target sum :return: int - maximum length of contiguous subarray that sums to k >>> max_length_subarray([1, -1, 5, -2, 3], 3) 4 >>> max_length_subarray([-2, -1, 2, 1], 1) 2 >>> max_length_subarray([1, 2, 3], 7) 0 >>> max_length_subarray([-1, -2, -3, -4], -6) 3 >>> max_length_subarray([1, 2, 1, 2, 1, 2], 3) 2 >>> max_length_subarray([], 3) 0 >>> max_length_subarray([3], 3) 1 >>> max_length_subarray([1], 3) 0","solution":"def max_length_subarray(arr, k): Determines the maximum length of a contiguous subarray that sums exactly to k. If there is no such subarray, the function returns 0. :param arr: List[int] - array of integers :param k: int - target sum :return: int - maximum length of contiguous subarray that sums to k # Dictionary to store the first occurrence of sum sum_map = {} current_sum = 0 max_len = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum == k: max_len = i + 1 if current_sum - k in sum_map: max_len = max(max_len, i - sum_map[current_sum - k]) if current_sum not in sum_map: sum_map[current_sum] = i return max_len"},{"question":"def calculate_votes(total_votes: int): Calculate the number of votes each candidate received based on the given conditions. The total number of votes is 2500: - Alice received 15% more votes than Bob. - Charlie received 10% more votes than Alice. Returns a tuple with the votes for Bob, Alice, and Charlie respectively. pass def test_calculate_votes(): bob_votes, alice_votes, charlie_votes = calculate_votes(2500) # Verify the sum of votes is 2500 assert bob_votes + alice_votes + charlie_votes == 2500 # Verify the individual conditions assert round(alice_votes) == round(bob_votes * 1.15) assert round(charlie_votes) == round(alice_votes * 1.10) def test_calculate_votes_with_partial_sum(): total_votes = 2500 bob_votes, alice_votes, charlie_votes = calculate_votes(total_votes) # Checking individual conditions and sums assert round(alice_votes) == round(bob_votes * 1.15) assert round(charlie_votes) == round(alice_votes * 1.10) assert (bob_votes + alice_votes + charlie_votes) == total_votes","solution":"def calculate_votes(total_votes): Calculate the number of votes each candidate received based on the given conditions. The total number of votes is 2500: - Alice received 15% more votes than Bob. - Charlie received 10% more votes than Alice. Returns a tuple with the votes for Bob, Alice, and Charlie respectively. # Let the number of votes for Bob be B # Then Alice's votes A = 1.15 * B (15% more than Bob) # And Charlie's votes C = 1.10 * A (10% more than Alice) # Total votes equation: B + A + C = 2500 # Substitute A = 1.15 * B and C = 1.10 * (1.15 * B) into the equation: # B + 1.15 * B + 1.10 * (1.15 * B) = 2500 B = total_votes / (1 + 1.15 + (1.10 * 1.15)) A = 1.15 * B C = 1.10 * A return round(B), round(A), round(C)"},{"question":"def reverse_string(s: str) -> str: Returns a new string with characters of the original string reversed. Parameters: s (str): The string to be reversed. Returns: str: Reversed string. Examples: >>> reverse_string('') '' >>> reverse_string('a') 'a' >>> reverse_string('hello') 'olleh' >>> reverse_string('hello world') 'dlrow olleh' >>> reverse_string('!@# %^ &*()') ')(*& ^% #@!' >>> reverse_string('abc123') '321cba' >>> reverse_string('123456') '654321'","solution":"def reverse_string(s): Returns a new string with characters of the original string reversed. Parameters: s (str): The string to be reversed. Returns: str: Reversed string. return s[::-1]"},{"question":"from typing import List def distribute_tasks(tasks: List[int]) -> int: Distribute tasks between two workers to minimize the maximum workload. >>> distribute_tasks([10, 7, 5, 8]) 15 >>> distribute_tasks([10]) 10 >>> distribute_tasks([5, 5, 5, 5]) 10 >>> distribute_tasks([1, 1, 1, 1000]) 1000 >>> distribute_tasks([1, 2, 3, 4, 5, 6, 7]) 14 >>> distribute_tasks([1000]*1000) 500000 pass","solution":"def distribute_tasks(tasks): def can_distribute(max_time): worker_1 = 0 worker_2 = 0 for task in sorted(tasks, reverse=True): if worker_1 <= worker_2: worker_1 += task if worker_1 > max_time: return False else: worker_2 += task if worker_2 > max_time: return False return True low, high = max(tasks), sum(tasks) result = high while low <= high: mid = (low + high) // 2 if can_distribute(mid): result = mid high = mid - 1 else: low = mid + 1 return result"},{"question":"def is_palindromic_number(n: int) -> bool: Check if a given number is palindromic. >>> is_palindromic_number(121) True >>> is_palindromic_number(123) False >>> is_palindromic_number(-121) False >>> is_palindromic_number(1) True >>> is_palindromic_number(0) True","solution":"def is_palindromic_number(n): Checks if a given number is palindromic. Args: n (int): The number to check. Returns: bool: True if the number is palindromic, False otherwise. # Convert number to string num_str = str(n) # Check if reversed string is the same as the original return num_str == num_str[::-1]"},{"question":"import os from typing import Dict, Tuple def read_and_count_words(file_path: str, keyword: str) -> Tuple[Dict[str, int], int, bool]: Read the file at file_path, count occurrences of each word, and check for keyword. Args: file_path (str): Path to the file. keyword (str): Keyword to search for within the file. Returns: Tuple containing: - Dictionary with word counts. - Count of occurrences of the keyword. - Boolean indicating if the keyword was found. Raises: FileNotFoundError: If the file does not exist. PermissionError: If there are permission issues accessing the file. Exception: For any other exceptions. word_count = {} keyword_count = 0 keyword_found = False try: with open(file_path, 'r') as file: content = file.read() words = content.split() for word in words: word_count[word] = word_count.get(word, 0) + 1 keyword_count = word_count.get(keyword, 0) keyword_found = keyword in word_count except FileNotFoundError: print(f\\"File {file_path} not found.\\") except PermissionError: print(f\\"Permission denied for file {file_path}.\\") except Exception as e: print(f\\"An error occurred: {e}\\") return word_count, keyword_count, keyword_found def process_files(file_paths: list, keyword: str) -> list: Process a list of file paths to count word occurrences and check for a keyword. Args: file_paths (list): List of file paths. keyword (str): Keyword to search for within the files. Returns: List of dictionaries with results for each file. results = [] for file_path in file_paths: word_count, keyword_count, keyword_found = read_and_count_words(file_path, keyword) if word_count: results.append({ \\"file_path\\": file_path, \\"word_count\\": word_count, \\"keyword_count\\": keyword_count, \\"keyword_found\\": keyword_found }) else: results.append({ \\"file_path\\": file_path, \\"error\\": \\"Could not process file.\\" }) return results","solution":"def read_and_count_words(file_path, keyword): try: with open(file_path, 'r') as f: content = f.read() word_list = content.split() word_count = {} for word in word_list: word_count[word] = word_count.get(word, 0) + 1 keyword_count = word_count.get(keyword, 0) keyword_found = keyword in word_count return word_count, keyword_count, keyword_found except FileNotFoundError: print(f\\"File {file_path} not found.\\") except PermissionError: print(f\\"Permission denied for file {file_path}.\\") except Exception as e: print(f\\"An error occurred: {e}\\") return {}, 0, False def process_files(file_paths, keyword): results = [] for file_path in file_paths: word_count, keyword_count, keyword_found = read_and_count_words(file_path, keyword) if word_count: results.append({ \\"file_path\\": file_path, \\"word_count\\": word_count, \\"keyword_count\\": keyword_count, \\"keyword_found\\": keyword_found }) else: results.append({ \\"file_path\\": file_path, \\"error\\": \\"Could not process file.\\" }) return results"},{"question":"import pytest def can_form_palindrome(s) -> bool: Determines whether a provided string can be rearranged to form a palindrome. Considers only alphanumeric characters and ignores cases. :param s: input string. :return: True if the string can be rearranged to form a palindrome, False otherwise. >>> can_form_palindrome(\\"abba\\") == True >>> can_form_palindrome(\\"racecar\\") == True >>> can_form_palindrome(\\"abcd\\") == False def test_can_form_palindrome_even_length_palindrome(): assert can_form_palindrome(\\"abba\\") == True def test_can_form_palindrome_odd_length_palindrome(): assert can_form_palindrome(\\"racecar\\") == True def test_can_form_palindrome_non_palindrome_even_length(): assert can_form_palindrome(\\"abcd\\") == False def test_can_form_palindrome_non_palindrome_odd_length(): assert can_form_palindrome(\\"abcde\\") == False def test_can_form_palindrome_mixed_case(): assert can_form_palindrome(\\"Aba\\") == True def test_can_form_palindrome_with_numbers(): assert can_form_palindrome(\\"a1b1a\\") == True def test_can_form_palindrome_with_special_characters(): assert can_form_palindrome(\\"taco cat!!\\") == True def test_can_form_palindrome_empty_string(): assert can_form_palindrome(\\"\\") == True def test_can_form_palindrome_single_character(): assert can_form_palindrome(\\"Z\\") == True def test_can_form_palindrome_non_string_input(): with pytest.raises(ValueError): can_form_palindrome(12345)","solution":"def can_form_palindrome(s): Determines whether a provided string can be rearranged to form a palindrome. Considers only alphanumeric characters and ignores cases. :param s: input string. :return: True if the string can be rearranged to form a palindrome, False otherwise. if not isinstance(s, str): raise ValueError(\\"Input should be a string\\") s = ''.join(char.lower() for char in s if char.isalnum()) char_count = {} for char in s: char_count[char] = char_count.get(char, 0) + 1 odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def isValid(s: str) -> bool: Determines if the given string is a valid parentheses sequence. Args: s (str): The input string consisting of '(', ')', '{', '}', '[' and ']'. Returns: bool: True if the string is a valid parentheses sequence, else False. Examples: >>> isValid(\\"()\\") True >>> isValid(\\"()[]{}\\") True >>> isValid(\\"(]\\") False >>> isValid(\\"([)]\\") False >>> isValid(\\"{[]}\\") True","solution":"def isValid(s: str) -> bool: Determines if the given string is a valid parentheses sequence. stack = [] matching_parentheses = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_parentheses: top_element = stack.pop() if stack else '#' if matching_parentheses[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def reverse_words(sentence: str) -> str: Write a Python function to reverse the words in a given sentence while preserving the order of the words. You are not allowed to use Pythons built-in reverse() method. >>> reverse_words(\\"Hello world from space\\") == \\"olleH dlrow morf ecaps\\" >>> reverse_words(\\"Coding challenges are fun\\") == \\"gnidoC segnellahc era nuf\\" >>> reverse_words(\\"Hello, world!\\") == \\",olleH !dlrow\\" >>> reverse_words(\\"Multiple spaces\\") == \\"elpitluM secaps\\" >>> reverse_words(\\"\\") == \\"\\" :param sentence: A string representing the input sentence. :return: A string with each word reversed while maintaining word order.","solution":"def reverse_words(sentence): Reverses each word in a given sentence while preserving the order of the words. :param sentence: A string representing the input sentence. :return: A string with each word reversed while maintaining word order. words = sentence.split() reversed_words = [''.join(reversed(word)) for word in words] return ' '.join(reversed_words)"},{"question":"class PriorityQueue: def __init__(self): self.heap = [] def insert(self, item, priority): self.heap.append((priority, item)) self._sift_up(len(self.heap) - 1) def _sift_up(self, index): Implement the sift-up operation def extract_max(self): if len(self.heap) > 1: self._swap(0, len(self.heap) - 1) max_item = self.heap.pop() self._sift_down(0) elif self.heap: max_item = self.heap.pop() else: raise IndexError(\\"extract_max(): empty queue\\") return max_item[1] def _sift_down(self, index): Implement the sift-down operation def peek_max(self): if not self.heap: raise IndexError(\\"peek_max(): empty queue\\") return self.heap[0][1] def _swap(self, i, j): self.heap[i], self.heap[j] = self.heap[j], self.heap[i] # Example usage and tests: pq = PriorityQueue() pq.insert('task1', 2) pq.insert('task2', 5) pq.insert('task3', 1) print(pq.peek_max()) # Output: 'task2' print(pq.extract_max()) # Output: 'task2' print(pq.extract_max()) # Output: 'task1' print(pq.extract_max()) # Output: 'task3'","solution":"class PriorityQueue: def __init__(self): self.heap = [] def insert(self, item, priority): self.heap.append((priority, item)) self._sift_up(len(self.heap) - 1) def _sift_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index][0] > self.heap[parent_index][0]: self._swap(index, parent_index) self._sift_up(parent_index) def extract_max(self): if len(self.heap) > 1: self._swap(0, len(self.heap) - 1) max_item = self.heap.pop() self._sift_down(0) elif self.heap: max_item = self.heap.pop() else: raise IndexError(\\"extract_max(): empty queue\\") return max_item[1] def _sift_down(self, index): left_child = 2 * index + 1 right_child = 2 * index + 2 largest = index if left_child < len(self.heap) and self.heap[left_child][0] > self.heap[largest][0]: largest = left_child if right_child < len(self.heap) and self.heap[right_child][0] > self.heap[largest][0]: largest = right_child if largest != index: self._swap(index, largest) self._sift_down(largest) def peek_max(self): if not self.heap: raise IndexError(\\"peek_max(): empty queue\\") return self.heap[0][1] def _swap(self, i, j): self.heap[i], self.heap[j] = self.heap[j], self.heap[i] # Example usage: pq = PriorityQueue() pq.insert('task1', 2) pq.insert('task2', 5) pq.insert('task3', 1) print(pq.peek_max()) # Output: 'task2' print(pq.extract_max()) # Output: 'task2' print(pq.extract_max()) # Output: 'task1' print(pq.extract_max()) # Output: 'task3'"},{"question":"def string_lengths(lst: List[str]) -> Dict[str, int]: Returns a dictionary where keys are the strings from the list and values are the lengths of those strings. >>> string_lengths([\\"apple\\", \\"banana\\", \\"cherry\\"]) {'apple': 5, 'banana': 6, 'cherry': 6} >>> string_lengths([\\"one\\", \\"two\\", \\"three\\"]) {'one': 3, 'two': 3, 'three': 5} >>> string_lengths([]) {} >>> string_lengths([\\"a\\", \\"ab\\", \\"abc\\"]) {'a': 1, 'ab': 2, 'abc': 3} >>> string_lengths([\\"\\", \\"a\\", \\"abcd\\"]) {'': 0, 'a': 1, 'abcd': 4}","solution":"def string_lengths(lst): Returns a dictionary where keys are the strings from the list and values are the lengths of those strings. return { s: len(s) for s in lst }"},{"question":"def sort_by_second_element(lst: List[Tuple[int, Union[int, float]]]) -> List[Tuple[int, Union[int, float]]]: Sorts a list of two-element tuples by the second element of each tuple in ascending order. Raises TypeError if the second element is not numeric. :param lst: List of two-element tuples :return: Sorted list of tuples by the second element in ascending order >>> sort_by_second_element([(1, 3), (2, 1), (3, 2)]) [(2, 1), (3, 2), (1, 3)] >>> sort_by_second_element([(1, 'a'), (2, 3)]) Traceback (most recent call last): ... TypeError: Non-numeric second element found: a","solution":"def sort_by_second_element(lst): Sorts a list of two-element tuples by the second element of each tuple in ascending order. Raises TypeError if the second element is not numeric. :param lst: List of two-element tuples :return: Sorted list of tuples by the second element in ascending order # Check that all second elements are numeric, otherwise raise a TypeError for _, second in lst: if not isinstance(second, (int, float)): raise TypeError(f\\"Non-numeric second element found: {second}\\") # Sort the list by the second element of each tuple return sorted(lst, key=lambda x: x[1])"},{"question":"import numpy as np def generate_matrix(m: int, n: int) -> np.ndarray: Generates an m x n matrix where each element is the sum of its row and column indices. Parameters: m (int): Number of rows n (int): Number of columns Returns: np.ndarray: Generated matrix Examples: >>> generate_matrix(3, 4) array([[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]) >>> generate_matrix(2, 2) array([[0, 1], [1, 2]])","solution":"import numpy as np def generate_matrix(m, n): Generates an m x n matrix where each element is the sum of its row and column indices. Parameters: m (int): Number of rows n (int): Number of columns Returns: np.ndarray: Generated matrix matrix = np.zeros((m, n), dtype=int) for i in range(m): for j in range(n): matrix[i, j] = i + j return matrix"},{"question":"def validate_numbers(lst): Ensure each item in the list is either int or float. Raises: ValueError: If any item is not a number. pass def flatten_list(lst): Flatten a nested list into a single list of numbers. Returns: list: A flattened list of numbers. pass def calculate_average(lst): Calculate the average of a list of numbers, handling nested lists. Returns: float: The average value of the list elements. pass # Example usages: # print(calculate_average([1, 2, 3])) # Should output: 2.0 # print(calculate_average([1, [2, 3], 4])) # Should output: 2.5 # try: # print(calculate_average([1, [2, 'a'], 4])) # except ValueError as e: # print(e) # Should output: Invalid item a: All elements must be int or float","solution":"def validate_numbers(lst): Ensure each item in the list is either int or float. Raises: ValueError: If any item is not a number. for item in lst: if isinstance(item, list): validate_numbers(item) # Recursive check for nested lists elif not isinstance(item, (int, float)): raise ValueError(f\\"Invalid item {item}: All elements must be int or float\\") def flatten_list(lst): Flatten a nested list into a single list of numbers. Returns: list: A flattened list of numbers. flat_list = [] for item in lst: if isinstance(item, list): flat_list.extend(flatten_list(item)) # Extend with the flattened sublist else: flat_list.append(item) return flat_list def calculate_average(lst): Calculate the average of a list of numbers, handling nested lists. Returns: float: The average value of the list elements. validate_numbers(lst) flat_list = flatten_list(lst) return sum(flat_list) / len(flat_list) if flat_list else 0"},{"question":"from typing import List def rearrange_string(s: str) -> str: Rearrange characters in the string such that no two adjacent characters are the same. If no such arrangement is possible, return an empty string. Args: s (str): The input string containing only lowercase English letters. Returns: str: The rearranged string or an empty string if no valid arrangement exists. >>> rearrange_string(\\"aab\\") in [\\"aba\\"] True >>> rearrange_string(\\"aabb\\") in [\\"abab\\", \\"baba\\"] True >>> rearrange_string(\\"aaab\\") '' >>> rearrange_string(\\"aaa\\") '' >>> rearrange_string(\\"a\\") 'a' >>> rearrange_string(\\"\\") '' def test_rearrange_string_possible(): assert rearrange_string(\\"aab\\") in [\\"aba\\"] assert rearrange_string(\\"aabb\\") in [\\"abab\\", \\"baba\\"] def test_rearrange_string_impossible(): assert rearrange_string(\\"aaab\\") == \\"\\" assert rearrange_string(\\"aaa\\") == \\"\\" def test_rearrange_string_single_char(): assert rearrange_string(\\"a\\") == \\"a\\" def test_rearrange_string_empty_string(): assert rearrange_string(\\"\\") == \\"\\" def test_rearrange_string_long_repetition(): result = rearrange_string(\\"aaabbbccc\\") # Check that no two adjacent characters are the same if result: for i in range(len(result) - 1): assert result[i] != result[i + 1] def test_rearrange_string_all_unique(): result = rearrange_string(\\"abcdefg\\") assert set(result) == set(\\"abcdefg\\") for i in range(len(result) - 1): assert result[i] != result[i + 1]","solution":"from heapq import heappush, heappop from collections import Counter def rearrange_string(s): # Count frequencies of characters char_count = Counter(s) # Use a max heap to store the characters by frequency max_heap = [] for char, count in char_count.items(): heappush(max_heap, (-count, char)) # Variables to store the previous character and its count prev_char = None prev_count = 0 result = [] while max_heap: count, char = heappop(max_heap) result.append(char) # If previous character still has a count, push it back to the heap if prev_char and prev_count < 0: heappush(max_heap, (prev_count, prev_char)) # Update the previous character and count prev_char = char prev_count = count + 1 # Since we used one instance of this character # Check if the resulting string has the correct length if len(result) != len(s): return \\"\\" return \\"\\".join(result)"},{"question":"def letter_frequency(s: str) -> dict: Returns a dictionary where the keys are the unique letters in the string (ignoring case) and the values are the frequency of each letter. The dictionary does not include spaces or punctuation marks as keys. >>> letter_frequency(\\"Hello, World!\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> letter_frequency(\\"AaBbCc\\") {'a': 2, 'b': 2, 'c': 2} >>> letter_frequency(\\"\\") {} from solution import letter_frequency def test_letter_frequency_simple(): assert letter_frequency(\\"Hello\\") == {'h': 1, 'e': 1, 'l': 2, 'o': 1} def test_letter_frequency_with_spaces_and_punctuation(): assert letter_frequency(\\"Hello, World!\\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} def test_letter_frequency_case_insensitivity(): assert letter_frequency(\\"AaBbCc\\") == {'a': 2, 'b': 2, 'c': 2} def test_letter_frequency_all_spaces_and_punctuations(): assert letter_frequency(\\" ,.!\\") == {} def test_letter_frequency_mixed_characters(): assert letter_frequency(\\"AbC, aBC! zYx\\") == {'a': 2, 'b': 2, 'c': 2, 'z': 1, 'y': 1, 'x': 1} def test_letter_frequency_empty_string(): assert letter_frequency(\\"\\") == {}","solution":"def letter_frequency(s: str) -> dict: Returns a dictionary where the keys are the unique letters in the string (ignoring case) and the values are the frequency of each letter. The dictionary does not include spaces or punctuation marks as keys. frequency = {} for char in s: # Manually handle case insensitivity if 'A' <= char <= 'Z': char = chr(ord(char) + 32) if 'a' <= char <= 'z': if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"def find_first_non_repeating_char(string): Find the first non-repeating character in a string. >>> find_first_non_repeating_char(\\"aabcc\\") == \\"b\\" >>> find_first_non_repeating_char(\\"aabbcc\\") == None >>> find_first_non_repeating_char(\\"abc\\") == \\"a\\" >>> find_first_non_repeating_char(\\"\\") == None pass def find_missing_number(arr): Find the missing number in a list of integers from 1 to n. >>> find_missing_number([1, 2, 3, 5]) == 4 >>> find_missing_number([1, 3, 4, 5]) == 2 >>> find_missing_number([2, 3, 4, 5]) == 1 >>> find_missing_number([]) == 1 pass def reverse_words(sen): Reverse words in a given sentence. >>> reverse_words(\\"Hello World\\") == \\"World Hello\\" >>> reverse_words(\\"Python is fun\\") == \\"fun is Python\\" >>> reverse_words(\\"a b c\\") == \\"c b a\\" >>> reverse_words(\\"\\") == \\"\\" pass def merge_sorted_arrays(arr1, arr2): Merge two sorted arrays into one sorted array. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 2, 3], []) == [1, 2, 3] >>> merge_sorted_arrays([], [4, 5, 6]) == [4, 5, 6] >>> merge_sorted_arrays([], []) == [] pass","solution":"def find_first_non_repeating_char(string): Find the first non-repeating character in a string. char_count = {} for char in string: char_count[char] = char_count.get(char, 0) + 1 for char in string: if char_count[char] == 1: return char return None def find_missing_number(arr): Find the missing number in a list of integers from 1 to n. n = len(arr) + 1 total = n * (n + 1) // 2 arr_sum = sum(arr) return total - arr_sum def reverse_words(sen): Reverse words in a given sentence. return \\" \\".join(reversed(sen.split())) def merge_sorted_arrays(arr1, arr2): Merge two sorted arrays into one sorted array. sorted_array, i, j = [], 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: sorted_array.append(arr1[i]) i += 1 else: sorted_array.append(arr2[j]) j += 1 sorted_array.extend(arr1[i:]) sorted_array.extend(arr2[j:]) return sorted_array"},{"question":"def sequence_value(n: int) -> int: Given a position 'n', calculate the number based on its position, the position immediately before it, and the position immediately after it. >>> sequence_value(1) == 1 >>> sequence_value(2) == 6 >>> sequence_value(3) == 24 >>> sequence_value(4) == 60 >>> sequence_value(5) == 120 >>> sequence_value(6) == 210 def get_6th_number() -> int: Calculate the 6th number in the sequence. >>> get_6th_number() == 210","solution":"def sequence_value(n): if n == 1: return 1 return n * (n-1) * (n+1) def get_6th_number(): return sequence_value(6)"},{"question":"def find_first_non_consecutive(nums: List[int]) -> int: Write a function that takes a list of integers and returns the first integer that is not consecutive. If the entire list is consecutive, return None. >>> find_first_non_consecutive([1, 2, 4, 5]) 4 >>> find_first_non_consecutive([10, 11, 12, 13, 14, 15]) None >>> find_first_non_consecutive([1, 2, 3, 4]) None >>> find_first_non_consecutive([3, 4, 5, 7, 8, 9]) 7","solution":"def find_first_non_consecutive(nums): Returns the first integer in the list that is not consecutive. If all integers are consecutive, returns None. if len(nums) < 2: return None for i in range(1, len(nums)): if nums[i] != nums[i-1] + 1: return nums[i] return None"},{"question":"from datetime import datetime from typing import List, Tuple def top_n_spenders(transactions: List[Tuple[int, int, int, str]], start_date: str, end_date: str, N: int) -> List[int]: Identifies the top 'N' users who have spent the most money over a specified period of time. Parameters: transactions (list of tuples): A list where each transaction is represented as a tuple (user_id, item_id, amount, timestamp). start_date (str): Start date of the period in 'YYYY-MM-DD' format. end_date (str): End date of the period in 'YYYY-MM-DD' format. N (int): The number of top spenders to return. Returns: list: A list of user_ids corresponding to the top 'N' spenders. >>> transactions = [ ... (1, 10, 100, '2021-05-01'), ... (2, 20, 300, '2021-05-02'), ... (1, 30, 400, '2021-05-03'), ... (3, 40, 200, '2021-05-04'), ... (2, 50, 100, '2021-05-05') ... ] >>> start_date = '2021-05-01' >>> end_date = '2021-05-04' >>> N = 2 >>> top_n_spenders(transactions, start_date, end_date, N) [1, 2]","solution":"from datetime import datetime def top_n_spenders(transactions, start_date, end_date, N): Identifies the top 'N' users who have spent the most money over a specified period of time. Parameters: transactions (list of tuples): A list where each transaction is represented as a tuple (user_id, item_id, amount, timestamp). start_date (str): Start date of the period in 'YYYY-MM-DD' format. end_date (str): End date of the period in 'YYYY-MM-DD' format. N (int): The number of top spenders to return. Returns: list: A list of user_ids corresponding to the top 'N' spenders. start_dt = datetime.strptime(start_date, '%Y-%m-%d') end_dt = datetime.strptime(end_date, '%Y-%m-%d') user_spending = {} for user_id, item_id, amount, timestamp in transactions: txn_date = datetime.strptime(timestamp, '%Y-%m-%d') if start_dt <= txn_date <= end_dt: if user_id in user_spending: user_spending[user_id] += amount else: user_spending[user_id] = amount top_spenders = sorted(user_spending, key=user_spending.get, reverse=True)[:N] return top_spenders"},{"question":"def average_grades(students_grades: dict) -> dict: Calculate the average grade for each student, rounding to the nearest integer. Invalid grades are skipped. If all grades are invalid or there are no grades, the average is None. >>> average_grades({\\"Alice\\": [88, 92, 77]}) {\\"Alice\\": 86} >>> average_grades({\\"Bob\\": [92, 95, 99, 105]}) {\\"Bob\\": 95} >>> average_grades({\\"Charlie\\": [80, 70, \\"91\\"]}) {\\"Charlie\\": 75} >>> average_grades({\\"Diana\\": []}) {\\"Diana\\": None} >>> example_dict = { ... \\"Alice\\": [88, 92, 77], ... \\"Bob\\": [92, 95, 99, 105], ... \\"Charlie\\": [80, 70, \\"91\\"], ... \\"Diana\\": [] ... } >>> expected_output = { ... \\"Alice\\": 86, ... \\"Bob\\": 95, ... \\"Charlie\\": 75, ... \\"Diana\\": None ... } >>> average_grades(example_dict) expected_output","solution":"def average_grades(students_grades): Calculate the average grade for each student, rounding to the nearest integer. Invalid grades are skipped. If all grades are invalid or there are no grades, the average is None. avg_grades = {} for student, grades in students_grades.items(): valid_grades = [g for g in grades if isinstance(g, (int, float)) and 0 <= g <= 100] if not valid_grades: avg_grades[student] = None else: avg_grades[student] = round(sum(valid_grades) / len(valid_grades)) return avg_grades"},{"question":"def count_frequency(numbers): Takes a list of integers and returns a dictionary with unique integers as keys and their frequencies as values. Returns an error message for empty lists or lists with non-integer values. Examples: >>> count_frequency([1, 2, 2, 3, 4, 4, 4, 5]) {1: 1, 2: 2, 3: 1, 4: 3, 5: 1} >>> count_frequency([10]) {10: 1} >>> count_frequency([]) \\"List is empty.\\" >>> count_frequency([1, 2, 'a', 3]) \\"List contains non-integer values.\\" >>> count_frequency([1.5, 2, 3]) \\"List contains non-integer values.\\" >>> count_frequency(\\"123\\") \\"Input should be a list of integers.\\" >>> count_frequency(123) \\"Input should be a list of integers.\\" >>> count_frequency([1,2,3,4,5]) {1: 1, 2: 1, 3: 1, 4: 1, 5: 1} >>> count_frequency([1,1,2,2,3,4,4,5,5,5]) {1: 2, 2: 2, 3: 1, 4: 2, 5: 3}","solution":"def count_frequency(numbers): Takes a list of integers and returns a dictionary with unique integers as keys and their frequencies as values. Returns an error message for empty lists or lists with non-integer values. if not isinstance(numbers, list): return \\"Input should be a list of integers.\\" if len(numbers) == 0: return \\"List is empty.\\" frequency_dict = {} for number in numbers: if not isinstance(number, int): return \\"List contains non-integer values.\\" if number in frequency_dict: frequency_dict[number] += 1 else: frequency_dict[number] = 1 return frequency_dict"},{"question":"import sys import pandas as pd def generate_summary_report(csv_file, column_name): Generate a summary report from a CSV file. The summary report includes: 1. The total number of rows. 2. The average of a specified numeric column. 3. The maximum value in the specified numeric column. 4. The minimum value in the specified numeric column. Args: csv_file (str): The path to the CSV file. column_name (str): The name of the column for which to generate the report. Example: >>> csv_data = '''id,value ... 1,10 ... 2,20 ... 3,30 ... 4,40 ... 5,50''' >>> with open('data.csv', 'w') as f: ... f.write(csv_data) >>> generate_summary_report('data.csv', 'value') Summary Report for column 'value': Total number of rows: 5 Average value: 30.00 Maximum value: 50 Minimum value: 10 # Your implementation here if __name__ == '__main__': if len(sys.argv) != 3: print(\\"Usage: python summary_report.py <csv_file> <column_name>\\") else: csv_file = sys.argv[1] column_name = sys.argv[2] generate_summary_report(csv_file, column_name)","solution":"import sys import pandas as pd def generate_summary_report(csv_file, column_name): # Read the CSV file into a pandas DataFrame df = pd.read_csv(csv_file) # Calculate required values for the report total_rows = df.shape[0] average_value = df[column_name].mean() maximum_value = df[column_name].max() minimum_value = df[column_name].min() # Print summary report print(f\\"Summary Report for column '{column_name}':\\") print(f\\"Total number of rows: {total_rows}\\") print(f\\"Average value: {average_value:.2f}\\") print(f\\"Maximum value: {maximum_value}\\") print(f\\"Minimum value: {minimum_value}\\") if __name__ == '__main__': # Check if the correct number of arguments has been provided if len(sys.argv) != 3: print(\\"Usage: python summary_report.py <csv_file> <column_name>\\") else: csv_file = sys.argv[1] column_name = sys.argv[2] generate_summary_report(csv_file, column_name)"},{"question":"def is_balanced(expression: str) -> bool: Checks if all the parentheses in the given string are balanced. The parentheses include both round brackets () and square brackets []. Parameters: expression (str): The input string containing the mathematical expression. Returns: bool: True if the parentheses are balanced, False otherwise. >>> is_balanced(\\"(a[0]+b[2c[6]])  {24 + [14  5]}\\") True >>> is_balanced(\\"f(e(d))}{}\\") False >>> is_balanced(\\"((a[{b}]))\\") True >>> is_balanced(\\"a[{b(c)d}e}\\") False >>> is_balanced(\\"\\") True >>> is_balanced(\\"[([])]\\") True >>> is_balanced(\\"(((\\") False >>> is_balanced(\\"[[[]\\") False >>> is_balanced(\\")(\\") False","solution":"def is_balanced(expression): Checks if all the parentheses in the given string are balanced. The parentheses include both round brackets () and square brackets []. Parameters: expression (str): The input string containing the mathematical expression. Returns: bool: True if the parentheses are balanced, False otherwise. stack = [] matching_bracket = {')': '(', ']': '[', '}': '{'} for char in expression: if char in \\"([{\\": stack.append(char) elif char in \\")]}\\": if not stack or stack[-1] != matching_bracket[char]: return False stack.pop() return not stack"},{"question":"def best_student(scores: dict) -> str: Return the name of the student with the highest average score. Parameters: scores (dict): A dictionary where keys are student names and values are lists of their scores in different subjects. Returns: str: Name of the student with the highest average score. >>> best_student({\\"Alice\\": [90, 80, 85]}) 'Alice' >>> best_student({ \\"Alice\\": [90, 80, 85], \\"Bob\\": [70, 75, 80], \\"Charlie\\": [85, 90, 95] }) 'Charlie' >>> best_student({ \\"Alice\\": [100, 100, 100], \\"Bob\\": [100, 100, 100] }) in [\\"Alice\\", \\"Bob\\"] >>> best_student({ \\"Alice\\": [90, 80], \\"Bob\\": [70, 85, 80], \\"Charlie\\": [85, 90, 90] }) 'Charlie' >>> best_student({ \\"Alice\\": [-10, -20, -30], \\"Bob\\": [-1, -2, -3], \\"Charlie\\": [-5, -10, -15] }) 'Bob'","solution":"def best_student(scores: dict) -> str: Return the name of the student with the highest average score. Parameters: scores (dict): A dictionary where keys are student names and values are lists of their scores in different subjects. Returns: str: Name of the student with the highest average score. highest_avg = float('-inf') best_student_name = \\"\\" for student, grades in scores.items(): average = sum(grades) / len(grades) if average > highest_avg: highest_avg = average best_student_name = student return best_student_name"},{"question":"from typing import List, Tuple def longest_increasing_subsequence(arr: List[int]) -> Tuple[List[int], int]: Finds the longest increasing subsequence in a list of integers. Returns the subsequence and its length as a tuple. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) ([2, 3, 7, 18], 4) >>> longest_increasing_subsequence([]) ([], 0) def process_multiple_requests(requests: List[List[int]]) -> List[Tuple[List[int], int]]: Processes multiple requests for finding the longest increasing subsequence. Returns a list of tuples, each containing the longest increasing subsequence and its length. >>> process_multiple_requests([[10, 9, 2, 5, 3, 7, 101, 18], [0, 8, 4, 12, 2]]) [([2, 3, 7, 18], 4), ([0, 4, 12], 3)] from solution import longest_increasing_subsequence, process_multiple_requests def test_single_request(): arr = [10, 9, 2, 5, 3, 7, 101, 18] expected_subsequence = [2, 3, 7, 18] expected_length = 4 subsequence, length = longest_increasing_subsequence(arr) assert subsequence == expected_subsequence assert length == expected_length def test_empty_request(): arr = [] expected_subsequence = [] expected_length = 0 subsequence, length = longest_increasing_subsequence(arr) assert subsequence == expected_subsequence assert length == expected_length def test_multiple_requests(): requests = [[10, 9, 2, 5, 3, 7, 101, 18], [0, 8, 4, 12, 2]] expected_results = [ ([2, 3, 7, 18], 4), ([0, 4, 12], 3) ] results = process_multiple_requests(requests) for result, expected in zip(results, expected_results): assert result == expected def test_request_with_negative_integers(): arr = [-1, 3, -2, 4, -3, 5] expected_subsequence = [-1, 3, 4, 5] expected_length = 4 subsequence, length = longest_increasing_subsequence(arr) assert subsequence == expected_subsequence assert length == expected_length def test_request_with_single_element(): arr = [7] expected_subsequence = [7] expected_length = 1 subsequence, length = longest_increasing_subsequence(arr) assert subsequence == expected_subsequence assert length == expected_length def test_request_with_all_equal_elements(): arr = [5, 5, 5, 5] expected_subsequence = [5] expected_length = 1 subsequence, length = longest_increasing_subsequence(arr) assert subsequence == expected_subsequence assert length == expected_length","solution":"def longest_increasing_subsequence(arr): Finds the longest increasing subsequence in a list of integers. Returns the subsequence and its length as a tuple. from bisect import bisect_left if not arr: return [], 0 n = len(arr) # Will store the indices of the smallest end elements of LIS of various lengths tails = [] indices = [] # Initialize the prev array to reconstruct path prev = [-1] * n for i in range(n): pos = bisect_left([arr[j] for j in tails], arr[i]) if pos < len(tails): tails[pos] = i else: tails.append(i) if pos > 0: prev[i] = tails[pos-1] else: prev[i] = -1 # Reconstruct the longest increasing subsequence lis_length = len(tails) lis = [] k = tails[-1] while k >= 0: lis.append(arr[k]) k = prev[k] lis.reverse() return lis, lis_length def process_multiple_requests(requests): Processes multiple requests for finding the longest increasing subsequence. Returns a list of tuples, each containing the longest increasing subsequence and its length. return [longest_increasing_subsequence(request) for request in requests]"},{"question":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring that contains no repeated characters. >>> longest_unique_substring(\\"\\") 0 >>> longest_unique_substring(\\"a\\") 1 >>> longest_unique_substring(\\"aaaa\\") 1 >>> longest_unique_substring(\\"abcdef\\") 6 >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\"aabcdef\\") 6 >>> longest_unique_substring(\\"a\\"*1000 + \\"b\\"*1000 + \\"c\\"*1000) 2","solution":"def longest_unique_substring(s): Returns the length of the longest substring that contains no repeated characters. n = len(s) if n == 0: return 0 char_index_map = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def longest_subsequence_with_diff_2(arr: List[int]) -> List[int]: Returns the longest subsequence where the difference between consecutive numbers is either 2 or -2. >>> longest_subsequence_with_diff_2([1, 3, 5, 7, 9, 2, 4, 6, 8]) [1, 3, 5, 7, 9] >>> longest_subsequence_with_diff_2([1, 3, 5, 6, 8, 10]) [1, 3, 5] >>> longest_subsequence_with_diff_2([2]) [2] >>> longest_subsequence_with_diff_2([1, 4, 7, 10]) [1] >>> longest_subsequence_with_diff_2([1, 3, 5, 7]) [1, 3, 5, 7] >>> longest_subsequence_with_diff_2([1, 3, 5, 1, 3, 5, 1, 3, 5]) [1, 3, 5] >>> longest_subsequence_with_diff_2([]) [] # Write your code here","solution":"def longest_subsequence_with_diff_2(arr): Returns the longest subsequence where the difference between consecutive numbers is either 2 or -2. Parameters: arr (list): A list of integers. Returns: list: The longest subsequence following the rule. if not arr: return [] max_length_subseq = [] current_subseq = [arr[0]] for i in range(1, len(arr)): if arr[i] - arr[i-1] == 2 or arr[i] - arr[i-1] == -2: current_subseq.append(arr[i]) else: if len(current_subseq) > len(max_length_subseq): max_length_subseq = current_subseq current_subseq = [arr[i]] if len(current_subseq) > len(max_length_subseq): max_length_subseq = current_subseq return max_length_subseq"},{"question":"def string_lengths(strings: list) -> dict: Takes a list of strings and returns a dictionary with the strings as keys and their lengths as values. Ignores any strings that contain numbers and skips non-string items. >>> string_lengths(['apple', 'banana', 'cherry']) {'apple': 5, 'banana': 6, 'cherry': 6} >>> string_lengths(['apple1', 'banana', 'cherry2']) {'banana': 6} >>> string_lengths(['apple', 123, 'cherry']) {'apple': 5, 'cherry': 6} >>> string_lengths([]) {} >>> string_lengths(['', 'test', '123']) {'': 0, 'test': 4} >>> string_lengths(['hello', 'world2', 42, True, 'python']) {'hello': 5, 'python': 6}","solution":"def string_lengths(strings): Takes a list of strings and returns a dictionary with the strings as keys and their lengths as values. Ignores any strings that contain numbers and skips non-string items. length_dict = {} for s in strings: if isinstance(s, str) and not any(char.isdigit() for char in s): length_dict[s] = len(s) return length_dict"},{"question":"def countPaths(m: int, n: int, obstacles: List[Tuple[int, int]]) -> int: Given an m x n matrix filled with non-negative integers, find the number of distinct paths from the top-left corner to the bottom-right corner. You can only move either down or right at any point in time. However, some cells in the matrix are marked as obstacle cells, and you cannot move through those cells. Args: m (int): The number of rows in the matrix. n (int): The number of columns in the matrix. obstacles (List[Tuple[int, int]]): List of coordinates for obstacle cells. Returns: int: The number of distinct paths from the top-left to the bottom-right corner avoiding obstacles. Examples: >>> countPaths(3, 3, [(1, 1)]) 2 >>> countPaths(3, 3, []) 6 from typing import List, Tuple def test_no_obstacles(): assert countPaths(3, 3, []) == 6 def test_single_obstacle(): assert countPaths(3, 3, [(1, 1)]) == 2 def test_blocked_path(): assert countPaths(3, 3, [(0, 1), (1, 1), (1, 0)]) == 0 def test_start_is_obstacle(): assert countPaths(3, 3, [(0, 0)]) == 0 def test_end_is_obstacle(): assert countPaths(3, 3, [(2, 2)]) == 0 def test_large_grid_no_obstacles(): assert countPaths(5, 5, []) == 70","solution":"def countPaths(m, n, obstacles): Returns the number of distinct paths from the top-left corner to the bottom-right corner, avoiding the cells that are marked as obstacles. # Create a 2D dp array to store the count of paths dp = [[0 for _ in range(n)] for _ in range(m)] # Mark obstacle cells in the dp array for obstacle in obstacles: dp[obstacle[0]][obstacle[1]] = -1 # Initialize the starting point; if start is an obstacle, return 0 if dp[0][0] == -1: return 0 dp[0][0] = 1 # Fill the dp array for i in range(m): for j in range(n): if dp[i][j] == -1: continue if i > 0 and dp[i-1][j] != -1: dp[i][j] += dp[i-1][j] if j > 0 and dp[i][j-1] != -1: dp[i][j] += dp[i][j-1] # Return the value on the bottom-right corner; if it's an obstacle, return 0 return dp[m-1][n-1] if dp[m-1][n-1] != -1 else 0"},{"question":"from datetime import datetime def price_analyzer(start_date, end_date, price_data): Analyzes the prices of products over time. Args: - start_date (str): the start date in 'YYYY-MM-DD' format. - end_date (str): the end date in 'YYYY-MM-DD' format. - price_data (list of tuples): a list of tuples where each tuple contains a date, product_name, and price. Returns: - dict: a dictionary with product names as keys and another dictionary with 'highest_price' and 'average_price' as values. >>> price_analyzer('2023-01-01', '2023-01-03', [('2023-01-01', 'ProductA', 100), ('2023-01-02', 'ProductA', 200), ('2023-01-03', 'ProductA', 150)]) {'ProductA': {'highest_price': 200, 'average_price': 150.0}} >>> price_analyzer('2023-01-01', '2023-01-03', [('2023-01-01', 'ProductA', 100), ('2023-01-02', 'ProductA', 200), ('2023-01-03', 'ProductA', 150), ('2023-01-01', 'ProductB', 300), ('2023-01-02', 'ProductB', 400)]) {'ProductA': {'highest_price': 200, 'average_price': 150.0}, 'ProductB': {'highest_price': 400, 'average_price': 350.0}} # Your implementation here pass","solution":"from datetime import datetime def price_analyzer(start_date, end_date, price_data): Analyzes the prices of products over time. Args: - start_date (str): the start date in 'YYYY-MM-DD' format. - end_date (str): the end date in 'YYYY-MM-DD' format. - price_data (list of tuples): a list of tuples where each tuple contains a date, product_name, and price. Returns: - dict: a dictionary with product names as keys and another dictionary with 'highest_price' and 'average_price' as values. start_date = datetime.strptime(start_date, '%Y-%m-%d') end_date = datetime.strptime(end_date, '%Y-%m-%d') product_prices = {} for date_str, product_name, price in price_data: date = datetime.strptime(date_str, '%Y-%m-%d') if start_date <= date <= end_date: if product_name not in product_prices: product_prices[product_name] = [] product_prices[product_name].append(price) result = {} for product_name, prices in product_prices.items(): highest_price = max(prices) average_price = sum(prices) / len(prices) result[product_name] = { 'highest_price': highest_price, 'average_price': average_price } return result"},{"question":"def calculate(expression: str) -> int: Simulates a basic calculator that evaluates the given mathematical expression string considering the order of operations (PEMDAS). >>> calculate(\\"2+3\\") == 5 >>> calculate(\\"5-2\\") == 3 >>> calculate(\\"4*5\\") == 20 >>> calculate(\\"9/3\\") == 3 >>> calculate(\\"2+3*4\\") == 14 >>> calculate(\\"2*3+4\\") == 10 >>> calculate(\\"2+3*4-5\\") == 9 >>> calculate(\\"10/2-3\\") == 2 >>> calculate(\\"0+5\\") == 5 >>> calculate(\\"5-0\\") == 5 >>> calculate(\\"0*4\\") == 0 >>> calculate(\\"9/1\\") == 9 >>> calculate(\\"1000000+1000000\\") == 2000000 >>> calculate(\\"1000000*2\\") == 2000000 >>> calculate(\\"1000000+1000000*2\\") == 3000000 >>> calculate(\\"1000000*2-500000\\") == 1500000","solution":"def calculate(expression): Simulates a basic calculator that evaluates the given mathematical expression string considering the order of operations (PEMDAS). import re import operator from math import isclose # Tokenize input string tokens = re.findall(r'd+|[+-*/]', expression) def apply_operator(operators, values): operator_token = operators.pop() right_value = values.pop() left_value = values.pop() if operator_token == '+': values.append(operator.add(left_value, right_value)) elif operator_token == '-': values.append(operator.sub(left_value, right_value)) elif operator_token == '*': values.append(operator.mul(left_value, right_value)) elif operator_token == '/': # Use integer division values.append(operator.floordiv(left_value, right_value)) # Define operator precedence precedence = {'+': 1, '-': 1, '*': 2, '/': 2} operators = [] values = [] for token in tokens: if token.isdigit(): values.append(int(token)) else: while (operators and precedence[operators[-1]] >= precedence[token]): apply_operator(operators, values) operators.append(token) while operators: apply_operator(operators, values) return values[0]"},{"question":"from typing import List def k_most_frequent(nums: List[int], k: int) -> List[int]: Returns the k most frequent elements in the array. If there are multiple candidates for the kth position, choose the smallest number among them. :param nums: List[int] - List of integers :param k: int - Number of most frequent elements to return :return: List[int] - List of k most frequent elements","solution":"from collections import Counter import heapq def k_most_frequent(nums, k): Returns the k most frequent elements in the array. If there are multiple candidates for the kth position, choose the smallest number among them. :param nums: List[int] - List of integers :param k: int - Number of most frequent elements to return :return: List[int] - List of k most frequent elements if not nums: return [] # Generate a frequency dictionary freq = Counter(nums) # Create a max heap with negative frequency to use heapq as a max heap max_heap = [(-count, num) for num, count in freq.items()] heapq.heapify(max_heap) # Extract the k most frequent elements result = [] for _ in range(k): result.append(heapq.heappop(max_heap)[1]) return sorted(result)"},{"question":"def group_students_by_grade(students): Groups students by their grades. Args: students (list): A list of dictionaries where each dictionary contains student information with keys 'name', 'grade', and 'age'. Returns: dict: A dictionary where the keys are grades and the values are lists of dictionaries with student information. from solution import group_students_by_grade def test_group_students_by_grade_single_entries(): students = [ {'name': 'Alice', 'grade': 'A', 'age': 17}, {'name': 'Bob', 'grade': 'B', 'age': 18}, {'name': 'David', 'grade': 'C', 'age': 17} ] expected_output = { 'A': [{'name': 'Alice', 'grade': 'A', 'age': 17}], 'B': [{'name': 'Bob', 'grade': 'B', 'age': 18}], 'C': [{'name': 'David', 'grade': 'C', 'age': 17}] } assert group_students_by_grade(students) == expected_output def test_group_students_by_grade_multiple_entries(): students = [ {'name': 'Alice', 'grade': 'A', 'age': 17}, {'name': 'Bob', 'grade': 'B', 'age': 18}, {'name': 'Charlie', 'grade': 'A', 'age': 16}, {'name': 'David', 'grade': 'C', 'age': 17}, {'name': 'Eve', 'grade': 'B', 'age': 17} ] expected_output = { 'A': [ {'name': 'Alice', 'grade': 'A', 'age': 17}, {'name': 'Charlie', 'grade': 'A', 'age': 16} ], 'B': [ {'name': 'Bob', 'grade': 'B', 'age': 18}, {'name': 'Eve', 'grade': 'B', 'age': 17} ], 'C': [{'name': 'David', 'grade': 'C', 'age': 17}] } assert group_students_by_grade(students) == expected_output def test_group_students_by_grade_empty_list(): students = [] assert group_students_by_grade(students) == {} def test_group_students_by_grade_same_grade(): students = [ {'name': 'Alice', 'grade': 'A', 'age': 17}, {'name': 'Bob', 'grade': 'A', 'age': 18}, {'name': 'Charlie', 'grade': 'A', 'age': 16}, ] expected_output = { 'A': [ {'name': 'Alice', 'grade': 'A', 'age': 17}, {'name': 'Bob', 'grade': 'A', 'age': 18}, {'name': 'Charlie', 'grade': 'A', 'age': 16} ] } assert group_students_by_grade(students) == expected_output","solution":"def group_students_by_grade(students): Groups students by their grades. Args: students (list): A list of dictionaries where each dictionary contains student information with keys 'name', 'grade', and 'age'. Returns: dict: A dictionary where the keys are grades and the values are lists of dictionaries with student information. grouped_students = {} for student in students: grade = student['grade'] if grade not in grouped_students: grouped_students[grade] = [] grouped_students[grade].append(student) return grouped_students"},{"question":"import csv import statistics from typing import Dict, Any def process_student_scores(csv_file_path: str) -> Dict[str, Any]: Process student scores from a CSV file and generate a summary report. Args: csv_file_path (str): The file path of the CSV containing student data. Returns: Dict[str, Any]: A dictionary containing summary reports per grade and overall statistics. The dataset consists of a series of student records, each with the following fields: student_id, student_name, test_score, and grade. The task is to: 1. Calculate the average test score per grade. 2. Determine the highest and lowest test scores in the entire dataset. 3. Create and display a summary report containing the average, highest, and lowest scores per grade. 4. Handle any potential errors, such as missing data or invalid test scores, ensuring the program can process the dataset without terminating abruptly. Example Usage: >>> result = process_student_scores(\\"path_to_csv_file.csv\\") >>> summary_report = result['summary_report'] >>> overall_highest_score = result['overall_highest_score'] >>> overall_lowest_score = result['overall_lowest_score'] # Implement the function here # Unit Tests def test_process_student_scores(): csv_content = student_id,student_name,test_score,grade 1,John Doe,85,A 2,Jane Smith,90,B 3,Bob Johnson,76,A 4,Lucy Brown,88,B 5,Tom Hanks,65,C # Create a temporary CSV file to read from csv_file_path = \\"/tmp/test_student_scores.csv\\" with open(csv_file_path, 'w') as f: f.write(csv_content) result = process_student_scores(csv_file_path) summary_report = result['summary_report'] overall_highest_score = result['overall_highest_score'] overall_lowest_score = result['overall_lowest_score'] assert summary_report['A']['average_score'] == 80.5 assert summary_report['A']['highest_score'] == 85 assert summary_report['A']['lowest_score'] == 76 assert summary_report['B']['average_score'] == 89 assert summary_report['B']['highest_score'] == 90 assert summary_report['B']['lowest_score'] == 88 assert summary_report['C']['average_score'] == 65 assert summary_report['C']['highest_score'] == 65 assert summary_report['C']['lowest_score'] == 65 assert overall_highest_score == 90 assert overall_lowest_score == 65 def test_missing_columns(): csv_content = student_id,student_name,grade 1,John Doe,A csv_file_path = \\"/tmp/test_student_scores_missing.csv\\" with open(csv_file_path, 'w') as f: f.write(csv_content) # Expecting error print but no crash result = process_student_scores(csv_file_path) # Because no valid scores are present, results should reflect that assert result['summary_report'] == {} assert result['overall_highest_score'] == 0 assert result['overall_lowest_score'] == 0 def test_invalid_scores(): csv_content = student_id,student_name,test_score,grade 1,John Doe,85,A 2,Jane Smith,invalid_score,B csv_file_path = \\"/tmp/test_student_scores_invalid.csv\\" with open(csv_file_path, 'w') as f: f.write(csv_content) result = process_student_scores(csv_file_path) summary_report = result['summary_report'] overall_highest_score = result['overall_highest_score'] overall_lowest_score = result['overall_lowest_score'] assert summary_report['A']['average_score'] == 85 assert summary_report['A']['highest_score'] == 85 assert summary_report['A']['lowest_score'] == 85 # Since one score is invalid, it should not be considered assert 'B' not in summary_report assert overall_highest_score == 85 assert overall_lowest_score == 85","solution":"import csv import statistics def process_student_scores(csv_file_path): student_data = [] # Read CSV and collect data with open(csv_file_path, newline='') as csv_file: reader = csv.DictReader(csv_file) for row in reader: try: student_id = row['student_id'] student_name = row['student_name'] test_score = float(row['test_score']) grade = row['grade'] student_data.append({ 'student_id': student_id, 'student_name': student_name, 'test_score': test_score, 'grade': grade }) except KeyError as e: print(f\\"Missing column in CSV: {e}\\") except ValueError: print(f\\"Invalid test score: {row.get('test_score')}\\") # Processing data grade_data = {} all_scores = [] for student in student_data: grade = student['grade'] test_score = student['test_score'] all_scores.append(test_score) if grade not in grade_data: grade_data[grade] = [] grade_data[grade].append(test_score) summary_report = {} for grade, scores in grade_data.items(): avg_score = round(statistics.mean(scores), 2) if scores else 0 max_score = max(scores) if scores else 0 min_score = min(scores) if scores else 0 summary_report[grade] = { 'average_score': avg_score, 'highest_score': max_score, 'lowest_score': min_score } overall_max_score = max(all_scores) if all_scores else 0 overall_min_score = min(all_scores) if all_scores else 0 return { 'summary_report': summary_report, 'overall_highest_score': overall_max_score, 'overall_lowest_score': overall_min_score }"},{"question":"import re class PhoneNumberFormatter: def validate_number(self, phone: str): Validate if the input string is in the format 'NXX-NXX-XXXX' where N is any digit from 2 to 9 and X is any digit from 0 to 9. Args: phone (str): The phone number as a string. Returns: str: \\"Valid number\\" if the number matches the format, otherwise \\"Invalid number\\". >>> validate_number('234-567-8901') 'Valid number' >>> validate_number('123-456-7890') 'Invalid number' >>> validate_number('111-222-3333') 'Invalid number' def reformat_number(self, phone: str): Reformat a valid phone number by replacing dashes with spaces. If the phone number is invalid, return an appropriate message. Args: phone (str): The valid phone number as a string. Returns: str: The reformatted phone number with spaces instead of dashes if valid, otherwise \\"Invalid number\\". >>> reformat_number('234-567-8901') '234 567 8901' >>> reformat_number('123-456-7890') 'Invalid number' >>> reformat_number('111-222-3333') 'Invalid number'","solution":"import re class PhoneNumberFormatter: def validate_number(self, phone: str): Validate if the input string is in the format 'NXX-NXX-XXXX' where N is any digit from 2 to 9 and X is any digit from 0 to 9. Args: phone (str): The phone number as a string. Returns: str: \\"Valid number\\" if the number matches the format, otherwise \\"Invalid number\\". pattern = re.compile(r'^[2-9][0-9]{2}-[2-9][0-9]{2}-[0-9]{4}') if pattern.match(phone): return \\"Valid number\\" return \\"Invalid number\\" def reformat_number(self, phone: str): Reformat a valid phone number by replacing dashes with spaces. If the phone number is invalid, return an appropriate message. Args: phone (str): The valid phone number as a string. Returns: str: The reformatted phone number with spaces instead of dashes if valid, otherwise \\"Invalid number\\". if self.validate_number(phone) == \\"Valid number\\": return phone.replace('-', ' ') return \\"Invalid number\\""},{"question":"def merge_sorted_arrays(arr1, arr2): Merge two sorted arrays into one sorted array. Args: arr1 (list): The first sorted array. arr2 (list): The second sorted array. Returns: list: A sorted array containing all elements from both input arrays. Examples: >>> merge_sorted_arrays([1, 3, 5, 7], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_arrays([1, 1, 1], [1, 1, 1]) [1, 1, 1, 1, 1, 1]","solution":"def merge_sorted_arrays(arr1, arr2): Merge two sorted arrays into one sorted array. Args: arr1 (list): The first sorted array. arr2 (list): The second sorted array. Returns: list: A sorted array containing all elements from both input arrays. merged_array = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def binary_search(arr, target): Perform a binary search on a sorted array to find the target value. Parameters: arr (list of int): A list of sorted integers. target (int): The target value to search for. Returns: int: The index of the target value if found, otherwise -1. >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) 2 >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6) 5 >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) 9 >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 11) -1 >>> binary_search([], 5) -1 >>> binary_search([5], 5) 0 >>> binary_search([5], 0) -1 >>> binary_search([1, 3, 5, 7, 9], 7) 3 >>> binary_search([1, 3, 5, 7, 9], 2) -1","solution":"def binary_search(arr, target): Perform a binary search on a sorted array to find the target value. Parameters: arr (list of int): A list of sorted integers. target (int): The target value to search for. Returns: int: The index of the target value if found, otherwise -1. left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"import pandas as pd import matplotlib.pyplot as plt def analyze_titanic_dataset(path): Download the titanic dataset from https://web.stanford.edu/class/archive/cs/cs109/cs109.1166/stuff/titanic.csv. Using pandas and matplotlib, analyze and visualize the distribution of the passengers' ages, the survival rate grouped by gender, and the ticket class. Ensure that your visualizations clearly distinguish different categories and make the insights easy to interpret.","solution":"import pandas as pd import matplotlib.pyplot as plt def analyze_titanic_dataset(path): # Load the Titanic dataset df = pd.read_csv(path) # Plot the distribution of passenger ages plt.figure(figsize=(10, 5)) df['Age'].hist(bins=30, edgecolor='black') plt.title('Distribution of Passengers' Ages') plt.xlabel('Age') plt.ylabel('Number of Passengers') plt.grid(False) plt.show() # Plot the survival rate grouped by gender survival_rate_by_gender = df.groupby('Sex')['Survived'].mean() survival_rate_by_gender.plot(kind='bar', color=['blue', 'pink'], edgecolor='black') plt.title('Survival Rate by Gender') plt.xlabel('Gender') plt.ylabel('Survival Rate') plt.grid(False) plt.show() # Plot the survival rate grouped by ticket class survival_rate_by_class = df.groupby('Pclass')['Survived'].mean() survival_rate_by_class.plot(kind='bar', color=['purple', 'green', 'orange'], edgecolor='black') plt.title('Survival Rate by Ticket Class') plt.xlabel('Ticket Class') plt.ylabel('Survival Rate') plt.grid(False) plt.show()"},{"question":"def longest_consecutive_subsequence(arr): Returns the longest consecutive subsequence in the given array. >>> longest_consecutive_subsequence([]) == [] >>> longest_consecutive_subsequence([7]) == [7] >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) == [1, 2, 3, 4] >>> longest_consecutive_subsequence([10, 5, 12, 3, 55, 6, 7, 8, 9, 1, 2]) == [5, 6, 7, 8, 9, 10] >>> longest_consecutive_subsequence([1, 9, 3, 10, 2, 20, 2, 5, 8]) == [1, 2, 3] >>> longest_consecutive_subsequence([-1, 0, 1, -2, -3, -4]) == [-4, -3, -2, -1, 0, 1]","solution":"def longest_consecutive_subsequence(arr): Returns the longest consecutive subsequence in the given array. if not arr: return [] num_set = set(arr) longest_streak = [] for num in arr: if num - 1 not in num_set: current_num = num current_streak = [current_num] while current_num + 1 in num_set: current_num += 1 current_streak.append(current_num) if len(current_streak) > len(longest_streak): longest_streak = current_streak return longest_streak"},{"question":"def word_frequencies(sentences: List[str]) -> Dict[str, int]: Takes a list of strings representing sentences and returns a dictionary where keys are unique words (case-insensitive) and values are the frequency of word appearances across all sentences. Also prints the word with the highest frequency along with its count. If there is a tie, any one of the words with the highest frequency is printed. >>> word_frequencies([\\"Hello world\\"]) {'hello': 1, 'world': 1} The word with the highest frequency is: 'hello' with count: 1 >>> word_frequencies([\\"Hello world\\", \\"Hello again, world!\\"]) {'hello': 2, 'world': 2, 'again': 1} The word with the highest frequency is: 'hello' with count: 2 >>> word_frequencies([\\"Apple banana apple\\", \\"BANANA\\"]) {'apple': 2, 'banana': 2} The word with the highest frequency is: 'apple' with count: 2 >>> word_frequencies([\\"cat bat cat\\", \\"bat bat cat\\"]) {'cat': 3, 'bat': 3} The word with the highest frequency is: 'cat' with count: 3","solution":"def word_frequencies(sentences): Returns a dictionary with word frequencies from the input list of sentences. Also prints the word with the highest frequency and its count. word_count = {} for sentence in sentences: words = sentence.lower().split() for word in words: if word.endswith(\\".\\") or word.endswith(\\",\\") or word.endswith(\\"!\\"): word = word[:-1] word_count[word] = word_count.get(word, 0) + 1 max_word = max(word_count, key=word_count.get) print(f\\"The word with the highest frequency is: '{max_word}' with count: {word_count[max_word]}\\") return word_count"},{"question":"def find_most_frequent(nums: List[int]) -> int: Returns the most frequent number in the list. If there is a tie, the smallest number among them is returned. pass from solution import find_most_frequent def test_single_element(): assert find_most_frequent([1]) == 1 def test_all_unique_elements(): assert find_most_frequent([1, 2, 3, 4, 5]) == 1 def test_multiple_frequent_elements(): assert find_most_frequent([1, 2, 2, 3, 3, 4]) == 2 assert find_most_frequent([4, 4, 5, 5, 6, 6]) == 4 def test_one_number_repeats(): assert find_most_frequent([1, 3, 1, 3, 2, 1]) == 1 def test_large_list(): assert find_most_frequent([1] * 1000000 + [2] * 999999) == 1 def test_empty_list(): assert find_most_frequent([]) is None def test_tie_with_smaller_number_first(): assert find_most_frequent([1, 2, 3, 1, 2, 3, 4]) == 1 def test_negative_numbers(): assert find_most_frequent([-1, -2, -2, -3, -1]) == -2 def test_mixed_sign_numbers(): assert find_most_frequent([-1, 1, -1, 1, 2]) == -1","solution":"def find_most_frequent(nums): Returns the most frequent number in the list. If there is a tie, the smallest number among them is returned. from collections import Counter if not nums: return None # Count the frequency of each number num_counts = Counter(nums) # Find the maximum frequency max_count = max(num_counts.values()) # Collect all numbers with the maximum frequency most_frequent_numbers = [num for num, count in num_counts.items() if count == max_count] # Return the smallest number among the most frequent numbers return min(most_frequent_numbers)"},{"question":"def normalize_and_filter_products(product_names, product_prices, threshold): Normalize the prices to a common base where the price of the cheapest product is scaled to 1. Remove any product whose normalized price exceeds the given threshold. :param product_names: List of product names :param product_prices: List of corresponding prices :param threshold: Price threshold for normalized prices :return: A tuple of filtered product names and their corresponding normalized prices >>> normalize_and_filter_products([\\"laptop\\", \\"phone\\", \\"tablet\\", \\"monitor\\"], [1000, 500, 300, 700], 2.5) ([\\"phone\\", \\"tablet\\", \\"monitor\\"], [1.67, 1.0, 2.33]) >>> normalize_and_filter_products([], [], 2.5) ([], []) >>> normalize_and_filter_products([\\"laptop\\"], [1000], 2.5) ([\\"laptop\\"], [1.0]) >>> normalize_and_filter_products([\\"a\\", \\"b\\", \\"c\\"], [1, 2, 3], 1) ([\\"a\\"], [1.0]) >>> normalize_and_filter_products([\\"a\\", \\"b\\", \\"c\\"], [10, 20, 30], 0.5) ([], [])","solution":"def normalize_and_filter_products(product_names, product_prices, threshold): Normalize the prices to a common base where the price of the cheapest product is scaled to 1. Remove any product whose normalized price exceeds the given threshold. :param product_names: List of product names :param product_prices: List of corresponding prices :param threshold: Price threshold for normalized prices :return: A tuple of filtered product names and their corresponding normalized prices if not product_names or not product_prices or len(product_names) != len(product_prices): return [], [] min_price = min(product_prices) normalized_prices = [price / min_price for price in product_prices] filtered_product_names = [] filtered_normalized_prices = [] for name, price in zip(product_names, normalized_prices): if price <= threshold: filtered_product_names.append(name) filtered_normalized_prices.append(price) return filtered_product_names, filtered_normalized_prices"},{"question":"from typing import List def can_partition(nums: List[int]) -> bool: Determines if there is a way to partition nums into two parts such that the products of the integers in both parts are equal. >>> can_partition([1, 2, 3, 6]) # True >>> can_partition([1, 5, 11, 5]) # False >>> can_partition([2, 3, 8, 8]) # True >>> can_partition([1, 1, 1, 1]) # False >>> can_partition([1, 2, 3, 4, 9, 27]) # True >>> can_partition([1, 1, 1, 1, 1, 1]) # False >>> can_partition([2, 3, 5, 6, 10, 15, 18, 30]) # True >>> can_partition([1]) # False >>> can_partition([10]) # False >>> can_partition([2, 2]) # True >>> can_partition([3, 5]) # False","solution":"def can_partition(nums): Determines if there is a way to partition nums into two parts such that the products of the integers in both parts are equal. from functools import lru_cache from math import prod total_prod = prod(nums) # If total product is not even, we cannot split into two equal products if total_prod % 2 != 0: return False target = total_prod // 2 n = len(nums) # Use memoization to avoid repeated calculation @lru_cache(None) def dfs(index, curr_prod): if curr_prod == target: return True if index == n or curr_prod > target: return False # Include nums[index] in our set or exclude nums[index] return dfs(index+1, curr_prod * nums[index]) or dfs(index+1, curr_prod) return dfs(0, 1)"},{"question":"class ToDoList: A class to manage tasks in a to-do list. Each task is represented as a dictionary with 'title', 'description', and 'completed' keys. def __init__(self): self.tasks = [] def add_task(self, title: str, description: str): Add a new task to the to-do list. pass def complete_task(self, title: str): Mark the task with the given title as completed. pass def get_tasks(self, completed: bool = None): Retrieve all the tasks in the list. If \`completed\` is True, return only completed tasks. If \`completed\` is False, return only not completed tasks. If \`completed\` is None, return all tasks. pass # Example usage: to_do_list = ToDoList() to_do_list.add_task('Buy groceries', 'Milk, Eggs, Bread') to_do_list.add_task('Call the bank', 'Inquiry about charges') print(to_do_list.get_tasks()) # List all tasks to_do_list.complete_task('Buy groceries') print(to_do_list.get_tasks(completed=True)) # List only completed tasks print(to_do_list.get_tasks(completed=False)) # List only not completed tasks","solution":"class ToDoList: def __init__(self): self.tasks = [] def add_task(self, title, description): task = {'title': title, 'description': description, 'completed': False} self.tasks.append(task) def complete_task(self, title): for task in self.tasks: if task['title'] == title: task['completed'] = True return raise ValueError(f\\"Task with title '{title}' not found\\") def get_tasks(self, completed=None): if completed is None: return self.tasks else: return [task for task in self.tasks if task['completed'] == completed]"},{"question":"def maxProfit(prices: List[int]) -> int: Calculates the maximum possible profit from a single transaction. :param prices: List[int] - list of stock prices :return: int - maximum profit Examples: >>> maxProfit([7, 1, 5, 3, 6, 4]) 5 >>> maxProfit([7, 6, 4, 3, 1]) 0","solution":"def maxProfit(prices): Calculates the maximum possible profit from a single transaction. :param prices: List[int] - list of stock prices :return: int - maximum profit if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def find_primes_in_range(start: int, end: int) -> List[int]: Identify all prime numbers within a given range, inclusive of the start and end points. >>> find_primes_in_range(10, 20) [11, 13, 17, 19] >>> find_primes_in_range(50, 100) [53, 59, 61, 67, 71, 73, 79, 83, 89, 97] >>> find_primes_in_range(29, 29) [29] >>> find_primes_in_range(8, 10) [] >>> find_primes_in_range(17, 23) [17, 19, 23] >>> find_primes_in_range(-10, 10) [2, 3, 5, 7] >>> find_primes_in_range(1000, 1010) [1009]","solution":"def is_prime(n): Helper function to determine if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def find_primes_in_range(start, end): Find all prime numbers in the given range [start, end]. return [num for num in range(start, end + 1) if is_prime(num)]"},{"question":"def canBePalindrome(s: str) -> bool: Determine if it is possible to delete exactly one character from the string to make it a palindrome. >>> canBePalindrome(\\"abca\\") True >>> canBePalindrome(\\"racecarb\\") True >>> canBePalindrome(\\"aba\\") False >>> canBePalindrome(\\"abba\\") False >>> canBePalindrome(\\"abcba\\") False >>> canBePalindrome(\\"abccba\\") False >>> canBePalindrome(\\"abcdef\\") False >>> canBePalindrome(\\"abcddcba\\") False >>> canBePalindrome(\\"aa\\") False >>> canBePalindrome(\\"a\\") False >>> canBePalindrome(\\"ab\\") True >>> canBePalindrome(\\"madam\\") False >>> canBePalindrome(\\"noon\\") False","solution":"def canBePalindrome(s): Determines if it is possible to delete exactly one character from the string to make it a palindrome. def is_palindrome_range(text, left, right): while left < right: if text[left] != text[right]: return False left += 1 right -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Check by skipping the left character or the right character return is_palindrome_range(s, left + 1, right) or is_palindrome_range(s, left, right - 1) left += 1 right -= 1 return False"},{"question":"def process_list(input_list): Takes a list of integers and strings, and returns a new list where each integer is doubled and each string is capitalized. Any other data types in the list are ignored. Args: - input_list: List containing integers and strings, possibly mixed with other types. Returns: - List: New list with doubled integers and capitalized strings. >>> process_list([1, 'hello', 3, 'world']) [2, 'HELLO', 6, 'WORLD'] >>> process_list([2, 'abc', 4.5, 'xyz', None, 6, '123']) [4, 'ABC', 'XYZ', 12, '123'] >>> process_list([]) [] >>> process_list(['example', 'text']) ['EXAMPLE', 'TEXT'] >>> process_list([1, 2, 3]) [2, 4, 6]","solution":"def process_list(input_list): Takes a list of integers and strings, and returns a new list where each integer is doubled and each string is capitalized. Any other data types in the list are ignored. Args: - input_list: List containing integers and strings, possibly mixed with other types. Returns: - List: New list with doubled integers and capitalized strings. result_list = [] for item in input_list: if isinstance(item, int): result_list.append(item * 2) elif isinstance(item, str): result_list.append(item.upper()) return result_list"},{"question":"def find_unique_pairs(numbers: List[Union[int, float]], target: Union[int, float]) -> List[Tuple[Union[int, float], Union[int, float]]]: Finds unique pairs of numbers in a given list that add up to the target sum. Pairs are returned in ascending order based on the first element of each pair. >>> find_unique_pairs([2, -1, 3, 6, 4, -3, 0, 5, -5], 5) [(-1, 6), (0, 5), (2, 3)] >>> find_unique_pairs([1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> find_unique_pairs([-10, -20, -30, -40, -50], -30) [(-20, -10)] >>> find_unique_pairs([1.5, 2.5, 3.5, 4.5], 6.0) [(1.5, 4.5), (2.5, 3.5)]","solution":"def find_unique_pairs(numbers, target): Finds unique pairs of numbers that add up to the target sum. Pairs are returned in ascending order based on the first element of each pair. numbers.sort() pairs = set() num_dict = {} for num in numbers: complement = target - num if complement in num_dict: pairs.add((min(num, complement), max(num, complement))) num_dict[num] = True return sorted(list(pairs))"},{"question":"from typing import List def smallest_k_substring(s: str, k: int) -> str: Given a string s and an integer k, return the lexicographically smallest substring of length k. :param s: The input string consisting of only lowercase alphabets :param k: The length of the substring to find :return: The lexicographically smallest substring of length k >>> smallest_k_substring('azcbob', 3) 'azc' >>> smallest_k_substring('leetcode', 2) 'co'","solution":"def smallest_k_substring(s: str, k: int) -> str: Given a string s and an integer k, return the lexicographically smallest substring of length k. :param s: The input string consisting of only lowercase alphabets :param k: The length of the substring to find :return: The lexicographically smallest substring of length k if not s or k <= 0 or k > len(s): return \\"\\" smallest_substring = s[:k] for i in range(1, len(s) - k + 1): current_substring = s[i:i+k] if current_substring < smallest_substring: smallest_substring = current_substring return smallest_substring"},{"question":"from typing import List class LRUCache: def __init__(self, capacity: int): Initialize the LRU cache with the given capacity. def get(self, key: int) -> int: Return the value of the key if the key exists, otherwise return -1. def set(self, key: int, value: int) -> None: Insert the value with key into the cache or update the value if key already exists. If the cache is at capacity, it should remove the least recently used item first. # Example Usage: cache = LRUCache(2) cache.set(1, 1) print(cache.get(1)) # returns 1 cache.set(2, 2) print(cache.get(1)) # returns 1 (1 is still the most recently used) cache.set(3, 3) # evicts key 2 print(cache.get(2)) # returns -1 (not found) cache.set(4, 4) # evicts key 1 print(cache.get(1)) # returns -1 (not found) print(cache.get(3)) # returns 3 print(cache.get(4)) # returns 4","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 # Move the key to the end to mark it as recently used self.cache.move_to_end(key) return self.cache[key] def set(self, key: int, value: int) -> None: if key in self.cache: # Update the value and mark it as recently used self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: # Pop the first item (the least recently used) self.cache.popitem(last=False)"},{"question":"from typing import Dict def count_characters(s: str) -> Dict[str, int]: Takes a string as input and returns a dictionary where the keys are the characters from the string, and the values are the number of times each character appears. The function is case-sensitive and accounts for special characters and spaces. >>> count_characters(\\"hello\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> count_characters(\\"\\") {} >>> count_characters(\\"aAa\\") {'a': 2, 'A': 1} >>> count_characters(\\"!@#!!\\") {'!': 3, '@': 1, '#': 1} >>> count_characters(\\"a b a\\") {'a': 2, ' ': 2, 'b': 1}","solution":"def count_characters(s): Returns a dictionary where the keys are the characters from the string, and the values are the number of times each character appears. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"def manage_inventory(inventory, current_day): Returns a list of items that will expire within the next two days given the current day. Parameters: inventory (list of dict): A list of dictionaries, each representing an item. current_day (int): The current day. Returns: list of dict: A list of items that need to be dealt with within the next two days. >>> inventory = [ >>> {\\"name\\": \\"Milk\\", \\"quantity\\": 10, \\"shelf_life\\": 3}, >>> {\\"name\\": \\"Bread\\", \\"quantity\\": 20, \\"shelf_life\\": 1}, >>> {\\"name\\": \\"Eggs\\", \\"quantity\\": 30, \\"shelf_life\\": 7}, >>> {\\"name\\": \\"Cheese\\", \\"quantity\\": 5, \\"shelf_life\\": 2} >>> ] >>> current_day = 5 >>> manage_inventory(inventory, current_day) [{'name': 'Bread', 'quantity': 20, 'shelf_life': 1}, {'name': 'Cheese', 'quantity': 5, 'shelf_life': 2}] # Your code here pass from solution import manage_inventory def test_manage_inventory_basic(): inventory = [ {\\"name\\": \\"Milk\\", \\"quantity\\": 10, \\"shelf_life\\": 3}, {\\"name\\": \\"Bread\\", \\"quantity\\": 20, \\"shelf_life\\": 1}, {\\"name\\": \\"Eggs\\", \\"quantity\\": 30, \\"shelf_life\\": 7}, {\\"name\\": \\"Cheese\\", \\"quantity\\": 5, \\"shelf_life\\": 2} ] current_day = 5 expected_output = [ {\\"name\\": \\"Bread\\", \\"quantity\\": 20, \\"shelf_life\\": 1}, {\\"name\\": \\"Cheese\\", \\"quantity\\": 5, \\"shelf_life\\": 2} ] assert manage_inventory(inventory, current_day) == expected_output def test_manage_inventory_empty(): inventory = [] current_day = 10 expected_output = [] assert manage_inventory(inventory, current_day) == expected_output def test_manage_inventory_no_items_to_deal_with(): inventory = [ {\\"name\\": \\"Milk\\", \\"quantity\\": 10, \\"shelf_life\\": 10}, {\\"name\\": \\"Eggs\\", \\"quantity\\": 30, \\"shelf_life\\": 7} ] current_day = 1 expected_output = [] assert manage_inventory(inventory, current_day) == expected_output def test_manage_inventory_all_items_to_deal_with(): inventory = [ {\\"name\\": \\"Milk\\", \\"quantity\\": 10, \\"shelf_life\\": 1}, {\\"name\\": \\"Bread\\", \\"quantity\\": 20, \\"shelf_life\\": 1}, {\\"name\\": \\"Eggs\\", \\"quantity\\": 30, \\"shelf_life\\": 2}, {\\"name\\": \\"Cheese\\", \\"quantity\\": 5, \\"shelf_life\\": 1} ] current_day = 6 expected_output = [ {\\"name\\": \\"Milk\\", \\"quantity\\": 10, \\"shelf_life\\": 1}, {\\"name\\": \\"Bread\\", \\"quantity\\": 20, \\"shelf_life\\": 1}, {\\"name\\": \\"Eggs\\", \\"quantity\\": 30, \\"shelf_life\\": 2}, {\\"name\\": \\"Cheese\\", \\"quantity\\": 5, \\"shelf_life\\": 1} ] assert manage_inventory(inventory, current_day) == expected_output def test_manage_inventory_one_item_to_deal_with(): inventory = [ {\\"name\\": \\"Milk\\", \\"quantity\\": 10, \\"shelf_life\\": 5}, {\\"name\\": \\"Bread\\", \\"quantity\\": 20, \\"shelf_life\\": 1}, {\\"name\\": \\"Eggs\\", \\"quantity\\": 30, \\"shelf_life\\": 7}, {\\"name\\": \\"Cheese\\", \\"quantity\\": 5, \\"shelf_life\\": 10} ] current_day = 8 expected_output = [ {\\"name\\": \\"Bread\\", \\"quantity\\": 20, \\"shelf_life\\": 1} ] assert manage_inventory(inventory, current_day) == expected_output","solution":"def manage_inventory(inventory, current_day): Returns a list of items that will expire within the next two days given the current day. Parameters: inventory (list of dict): A list of dictionaries, each representing an item. current_day (int): The current day. Returns: list of dict: A list of items that need to be dealt with within the next two days. items_to_deal_with = [] for item in inventory: expiration_day = current_day + item['shelf_life'] if expiration_day <= current_day + 2: items_to_deal_with.append(item) return items_to_deal_with"},{"question":"def add(a, b): Returns the sum of a and b. >>> add(2, 3) 5 >>> add(0, 5) 5 >>> add(5, 0) 5 >>> add(-1, -1) -2 >>> add(-1, 3) 2","solution":"def add(a, b): Returns the sum of a and b. return a + b"},{"question":"from typing import Dict, List def calculate_average_grades(students_grades: Dict[str, List[int]]) -> Dict[str, float]: Returns a dictionary with students' names and their average grades. Parameters: students_grades (dict): Dictionary where keys are student names and values are lists of their grades. Returns: dict: Dictionary with student names as keys and average grades as values. Examples: >>> calculate_average_grades({ >>> \\"Alice\\": [90, 80, 70], >>> \\"Bob\\": [100, 95, 90], >>> \\"Charlie\\": [80, 85, 90] >>> }) {'Alice': 80.0, 'Bob': 95.0, 'Charlie': 85.0} >>> calculate_average_grades({\\"Alice\\": [90, 100]}) {'Alice': 95.0} >>> calculate_average_grades({\\"Alice\\": [80]}) {'Alice': 80.0} pass","solution":"def calculate_average_grades(students_grades): Returns a dictionary with students' names and their average grades. Parameters: students_grades (dict): Dictionary where keys are student names and values are lists of their grades Returns: dict: Dictionary with student names as keys and average grades as values return {student: sum(grades) / len(grades) for student, grades in students_grades.items()}"},{"question":"def inverted_half_pyramid(n: int) -> list: Generates an inverted half-pyramid pattern of stars. Parameters: n (int): The number of stars in the top row. Returns: list of str: A list where each string represents a row of the pyramid. >>> inverted_half_pyramid(5) ['*****', '****', '***', '**', '*'] >>> inverted_half_pyramid(3) ['***', '**', '*'] >>> inverted_half_pyramid(1) ['*'] >>> inverted_half_pyramid(0) [] >>> inverted_half_pyramid(10) ['**********', '*********', '********', '*******', '******', '*****', '****', '***', '**', '*']","solution":"def inverted_half_pyramid(n): Generates an inverted half-pyramid pattern of stars. Parameters: n (int): The number of stars in the top row. Returns: list of str: A list where each string represents a row of the pyramid. pyramid = [] for i in range(n, 0, -1): pyramid.append('*' * i) return pyramid"},{"question":"def remove_adjacent_duplicates(lst: List[int]) -> List[int]: Takes a list of integers and returns a new list with duplicated adjacent elements removed. >>> remove_adjacent_duplicates([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_adjacent_duplicates([1, 1, 1, 1]) [1] >>> remove_adjacent_duplicates([]) [] >>> remove_adjacent_duplicates([42]) [42] >>> remove_adjacent_duplicates([-1, -1, 0, 0, 1, 1]) [-1, 0, 1] >>> remove_adjacent_duplicates([1, 2, 2, 1, 3, 3, 1]) [1, 2, 1, 3, 1]","solution":"def remove_adjacent_duplicates(lst): Takes a list of integers and returns a new list with duplicated adjacent elements removed. if not lst: return [] result = [lst[0]] for i in range(1, len(lst)): if lst[i] != lst[i-1]: result.append(lst[i]) return result"},{"question":"def most_frequent_char(s: str) -> str: Given a string of lowercase letters, determine the most frequently occurring character. If there are multiple characters with the same highest frequency, return the one that appears earliest in the alphabet. Args: s (str): A string of lowercase letters Returns: str: The most frequently occurring character in the string >>> most_frequent_char(\\"examplestring\\") 'e' >>> most_frequent_char(\\"testingcode\\") 't'","solution":"def most_frequent_char(s: str) -> str: Given a string of lowercase letters, determine the most frequently occurring character. If there are multiple characters with the same highest frequency, return the one that appears earliest in the alphabet. Args: s (str): A string of lowercase letters Returns: str: The most frequently occurring character in the string from collections import Counter # Count the frequency of each character freq_count = Counter(s) # Find the character with most frequency with earliest in alphabetic order most_frequent = None highest_frequency = 0 for char in sorted(freq_count.keys()): if freq_count[char] > highest_frequency: highest_frequency = freq_count[char] most_frequent = char return most_frequent"},{"question":"from typing import List def find_triplet(arr: List[int]) -> bool: Determines whether there exists a triplet (a, b, c) in the array such that a^3 + b^3 = c^3. >>> find_triplet([1, 2, 3, 4, 5, 6]) False >>> find_triplet([3, -3, 0, 7]) True >>> find_triplet([-1, 2, -2, 1, 0]) True >>> find_triplet([7]) False >>> find_triplet([2, 3]) False >>> find_triplet([-1000, 1000, 0]) True >>> find_triplet([-4, -5, -6, -7]) False >>> find_triplet([1, -1, 8, -8, 2, -2, 0]) True","solution":"from typing import List def find_triplet(arr: List[int]) -> bool: Determines whether there exists a triplet (a, b, c) in the array such that a^3 + b^3 = c^3. cubes = {x**3 for x in arr} for i in range(len(arr)): for j in range(len(arr)): if i != j: # Check if a^3 + b^3 is in the cubes set if arr[i]**3 + arr[j]**3 in cubes: return True return False"},{"question":"from typing import List def longest_ap_length(arr: List[int]) -> int: Develop a Python function that takes a list of integers and returns the length of the longest contiguous subsequence where the numbers form an arithmetic progression. An arithmetic progression is defined as a sequence of numbers with a constant difference between consecutive terms. Handle the input efficiently, considering edge cases such as an empty list or a list with no possible arithmetic progression of length greater than one. >>> longest_ap_length([]) 0 >>> longest_ap_length([7]) 1 >>> longest_ap_length([3, 5]) 2 >>> longest_ap_length([3, 3]) 2 >>> longest_ap_length([1, 2, 4]) 2 >>> longest_ap_length([1, 3, 5, 7, 9]) 5 >>> longest_ap_length([1, 2, 2, 2, 2, 3, 4, 5]) 4 >>> longest_ap_length([1, 2, 4, 6, 8, 10, 7, 1, 3, 5]) 5 >>> longest_ap_length([-1, 1, 3, 5, 7, 9, -5, -3, -1]) 6 >>> longest_ap_length([1, 3, 1, 3, 1, 3, 1]) 2","solution":"def longest_ap_length(arr): Returns the length of the longest contiguous subsequence where the numbers form an arithmetic progression. if not arr: return 0 if len(arr) == 1: return 1 max_len = 1 curr_len = 1 common_diff = None for i in range(1, len(arr)): if common_diff is None: common_diff = arr[i] - arr[i-1] curr_len += 1 elif arr[i] - arr[i-1] == common_diff: curr_len += 1 else: max_len = max(max_len, curr_len) common_diff = arr[i] - arr[i-1] curr_len = 2 max_len = max(max_len, curr_len) return max_len"},{"question":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters. >>> longest_unique_substring(\\"abcabcbb\\") \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") \\"wke\\"","solution":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters. # Initialize variables to keep track of the longest substring start = 0 max_length = 0 max_substr = \\"\\" seen_chars = {} for end, char in enumerate(s): # If the character is already in the dictionary and its index is # within the current window, move the start to the right of this character's last index if char in seen_chars and seen_chars[char] >= start: start = seen_chars[char] + 1 # Update last index of current character seen_chars[char] = end # Update max substring if the current window is larger if end - start + 1 > max_length: max_length = end - start + 1 max_substr = s[start:end + 1] return max_substr"},{"question":"import string def read_file(file_path: str) -> str: Read a text file and return its content as a string. >>> read_file(\\"sample.txt\\") # File should contain \\"Hello world\\" 'Hello world' with open(file_path, \\"r\\") as file: return file.read() def clean_text(text: str) -> str: Remove punctuation from the text and convert it to lowercase. >>> clean_text(\\"Hello, World! This is a test.\\") 'hello world this is a test' translator = str.maketrans(\\"\\", \\"\\", string.punctuation) return text.translate(translator).lower() def count_words(text: str) -> dict: Count the frequency of each word in the text, ignoring common stopwords. >>> count_words(\\"hello hello world and the world is big\\") {'hello': 2, 'world': 2, 'big': 1} stopwords = {\\"and\\", \\"the\\", \\"is\\", \\"in\\", \\"at\\"} word_counts = {} for word in text.split(): if word not in stopwords: if word not in word_counts: word_counts[word] = 1 else: word_counts[word] += 1 return word_counts def print_top_words(word_counts: dict, top_n: int = 10) -> None: Print the top N most frequent words along with their counts. >>> word_counts = {'hello': 2, 'world': 2, 'big': 1, 'test': 5} >>> print_top_words(word_counts) test: 5 hello: 2 world: 2 big: 1 sorted_words = sorted(word_counts.items(), key=lambda item: item[1], reverse=True) for word, count in sorted_words[:top_n]: print(f\\"{word}: {count}\\") if __name__ == \\"__main__\\": file_path = \\"sample.txt\\" text = read_file(file_path) cleaned_text = clean_text(text) word_counts = count_words(cleaned_text) print_top_words(word_counts)","solution":"import string def read_file(file_path): try: with open(file_path, \\"r\\") as file: return file.read() except FileNotFoundError as e: print(f\\"Error: {e}\\") return \\"\\" def clean_text(text): translator = str.maketrans(\\"\\", \\"\\", string.punctuation) return text.translate(translator).lower() def count_words(text): stopwords = {\\"and\\", \\"the\\", \\"is\\", \\"in\\", \\"at\\"} word_counts = {} for word in text.split(): if word not in stopwords: if word not in word_counts: word_counts[word] = 1 else: word_counts[word] += 1 return word_counts def print_top_words(word_counts, top_n=10): sorted_words = sorted(word_counts.items(), key=lambda item: item[1], reverse=True) for word, count in sorted_words[:top_n]: print(f\\"{word}: {count}\\") file_path = \\"sample.txt\\" text = read_file(file_path) cleaned_text = clean_text(text) word_counts = count_words(cleaned_text) print_top_words(word_counts)"},{"question":"def three_sum(nums: List[int], target: int) -> bool: Write a program that takes a list of integers and a target sum as inputs. Your task is to determine if there are any three distinct elements in the list that add up to the target sum. If such elements exist, return True; otherwise, return False. >>> three_sum([1, 4, 45, 6, 10, 8], 22) True >>> three_sum([1, 4, 45, 6, 10, 8], 21) False >>> three_sum([-1, 0, 1, 2, -1, -4], 0) True >>> three_sum([], 10) False >>> three_sum([1, 2], 3) False >>> three_sum([1, 1, 1, 1], 3) True >>> three_sum([2, 2, 2, 2], 8) False >>> three_sum([100, 200, 300, -500, 400, 700], 400) True >>> three_sum([100, 200, 300, 400, 500], 1500) False","solution":"def three_sum(nums, target): Returns True if there are three distinct elements in 'nums' that add up to 'target', otherwise returns False. nums.sort() n = len(nums) for i in range(n - 2): # To prevent duplication if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"def process_numbers(numbers: list) -> dict: Processes a list of integers and returns a dictionary with keys: - \\"even_squares\\": a list of squares of all even numbers. - \\"odd_cubes\\": a list of cubes of all odd numbers. The function should traverse the input list only once and should ensure the result lists are in the same order as the corresponding numbers appeared in the input list. Parameters: numbers (list): List of integers to process. Returns: dict: A dictionary with \\"even_squares\\" and \\"odd_cubes\\" lists. >>> process_numbers([1, 2, 3, 4, 5]) {'even_squares': [4, 16], 'odd_cubes': [1, 27, 125]} >>> process_numbers([]) {'even_squares': [], 'odd_cubes': []}","solution":"def process_numbers(numbers): Processes a list of integers and returns a dictionary with keys: - \\"even_squares\\": a list of squares of all even numbers. - \\"odd_cubes\\": a list of cubes of all odd numbers. Parameters: numbers (list): List of integers to process. Returns: dict: A dictionary with \\"even_squares\\" and \\"odd_cubes\\" lists. result = { \\"even_squares\\": [], \\"odd_cubes\\": [] } for num in numbers: if num % 2 == 0: result[\\"even_squares\\"].append(num**2) else: result[\\"odd_cubes\\"].append(num**3) return result"},{"question":"def replace_with_difference_from_average(numbers): Replaces each number in the list with the difference between that number and the average of the entire list. >>> replace_with_difference_from_average([]) == [] >>> replace_with_difference_from_average([5]) == [0] >>> replace_with_difference_from_average([1, 2, 3, 4, 5]) == [-2, -1, 0, 1, 2] >>> replace_with_difference_from_average([-1, -2, -3, -4, -5]) == [2, 1, 0, -1, -2] >>> replace_with_difference_from_average([-2, -1, 0, 1, 2]) == [-2, -1, 0, 1, 2] >>> replace_with_difference_from_average([2, 2, 2, 2]) == [0, 0, 0, 0]","solution":"def replace_with_difference_from_average(numbers): Replaces each number in the list with the difference between that number and the average of the entire list. if not numbers: return [] avg = sum(numbers) / len(numbers) return [x - avg for x in numbers]"},{"question":"def has_two_sum(nums: list, target: int) -> bool: Returns True if there are two distinct numbers in the list that add up to the target integer. Args: nums (list): A list of integers. target (int): The target integer. Returns: bool: True if two distinct numbers sum up to target, False otherwise. Raises: ValueError: If nums contains non-integer values. >>> has_two_sum([1, 2, 3, 4, 5], 9) == True >>> has_two_sum([-1, -2, -3, -4, -5], -8) == True >>> has_two_sum([0, 1, 2, 3, 4], 3) == True >>> has_two_sum([1, 2, 3, 4], 0) == False >>> has_two_sum([-1, 2, -3, 4], 1) == True >>> has_two_sum([-1, 2, -3, 4], 10) == False >>> has_two_sum([5, 3, 3, 3], 6) == True >>> has_two_sum([3, 3, 3], 6) == True >>> has_two_sum([1, 2, 3], 6) == False >>> has_two_sum([], 1) == False >>> has_two_sum([1], 1) == False >>> has_two_sum([1, \\"two\\", 3], 4) ValueError: All elements in the list must be integers.","solution":"def has_two_sum(nums, target): Returns True if there are two distinct numbers in the list that add up to the target integer. Args: nums (list): A list of integers. target (int): The target integer. Returns: bool: True if two distinct numbers sum up to target, False otherwise. Raises: ValueError: If nums contains non-integer values. if not all(isinstance(num, int) for num in nums): raise ValueError(\\"All elements in the list must be integers.\\") seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"def find_primes(n: int) -> list: Returns a list of all prime numbers less than n. >>> find_primes(10) == [2, 3, 5, 7] >>> find_primes(30) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> find_primes(2) == [] >>> find_primes(11) == [2, 3, 5, 7] from solution import find_primes def test_find_primes_ten(): assert find_primes(10) == [2, 3, 5, 7] def test_find_primes_thirty(): assert find_primes(30) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] def test_find_primes_less_than_two(): assert find_primes(2) == [] assert find_primes(1) == [] assert find_primes(0) == [] def test_find_primes_prime_limit(): assert find_primes(11) == [2, 3, 5, 7] def test_find_primes_large(): primes_up_to_50 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] assert find_primes(50) == primes_up_to_50","solution":"def find_primes(n): Returns a list of all prime numbers less than n. if n <= 2: return [] sieve = [True] * n sieve[0] = sieve[1] = False for start in range(2, int(n**0.5) + 1): if sieve[start]: for i in range(start*start, n, start): sieve[i] = False return [num for num in range(n) if sieve[num]] # Example usage: find_primes(10) returns [2, 3, 5, 7]"},{"question":"def largest_rectangle_area(histogram: List[int]) -> int: Find the largest rectangular area possible in a given histogram. :param histogram: List[int] - a list of non-negative integers representing the histogram heights :return: int - the area of the largest rectangle >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 >>> largest_rectangle_area([1, 1, 1, 1, 1]) == 5 >>> largest_rectangle_area([2, 4, 2, 1, 10, 6, 10]) == 18 >>> largest_rectangle_area([6]) == 6 >>> largest_rectangle_area([1, 2, 3, 4, 5]) == 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) == 9 >>> largest_rectangle_area([]) == 0 >>> largest_rectangle_area([5, 5, 5, 5]) == 20","solution":"def largest_rectangle_area(histogram): Finds the largest rectangular area possible in a given histogram. :param histogram: List[int] - a list of non-negative integers representing the histogram heights :return: int - the area of the largest rectangle # Add a zero height bar at the end to ensure all bars get processed histogram.append(0) stack = [] max_area = 0 for i in range(len(histogram)): while stack and histogram[stack[-1]] > histogram[i]: height = histogram[stack.pop()] # Width is calculated as the difference between the current index and index of the last item in stack minus 1 width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) # Remove the zero height bar inserted at the beginning histogram.pop() return max_area"},{"question":"def transform_list(lst: List[int]) -> List[int]: Returns a new list where each element is squared and then added by 2. Raises ValueError if list contains non-integer elements. >>> transform_list([1, 2, 3, 4]) [3, 6, 11, 18] >>> transform_list([]) [] >>> transform_list([1, 'a', 3]) ValueError: List must contain only integers. # Your code here import pytest def test_transform_list_with_positive_numbers(): assert transform_list([1, 2, 3, 4]) == [3, 6, 11, 18] def test_transform_list_with_negative_numbers(): assert transform_list([-1, -2, -3, -4]) == [3, 6, 11, 18] def test_transform_list_with_mixed_numbers(): assert transform_list([0, -1, 1]) == [2, 3, 3] def test_transform_list_with_empty_list(): assert transform_list([]) == [] def test_transform_list_with_non_integer_elements(): with pytest.raises(ValueError, match=\\"List must contain only integers.\\"): transform_list([1, 'a', 3]) def test_transform_list_with_all_zeroes(): assert transform_list([0, 0, 0]) == [2, 2, 2]","solution":"def transform_list(lst): Returns a new list where each element is squared and then added by 2. Raises ValueError if list contains non-integer elements. if not all(isinstance(x, int) for x in lst): raise ValueError(\\"List must contain only integers.\\") return [(x * x) + 2 for x in lst]"},{"question":"class BookCatalog: A simple book catalog system. - Each book will have a unique ID, title, author, and publication year. - Up to 1000 books can be stored in the catalog. Example Usage: >>> catalog = BookCatalog() >>> catalog.add_book(1, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) >>> catalog.retrieve_book(1) 'Book details: ID=1, Title=To Kill a Mockingbird, Author=Harper Lee, Year=1960' >>> catalog.delete_book(1) >>> catalog.retrieve_book(1) 'Book not found' def __init__(self): self.books = {} def add_book(self, book_id, title, author, year): Add a book to the catalog. - book_id: Unique identifier for the book. - title: The title of the book. - author: The author of the book. - year: The publication year of the book. pass # Implementation goes here. def retrieve_book(self, book_id): Retrieve the details of a book given its ID. - book_id: Unique identifier for the book to be retrieved. - Returns: Formatted string containing book details, or \\"Book not found\\" if the book does not exist. pass # Implementation goes here. def delete_book(self, book_id): Delete a book from the catalog by its ID. - book_id: Unique identifier for the book to be deleted. pass # Implementation goes here. # Example tests def test_add_and_retrieve_book(): catalog = BookCatalog() catalog.add_book(1, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) retrieved_book = catalog.retrieve_book(1) assert retrieved_book == \\"Book details: ID=1, Title=To Kill a Mockingbird, Author=Harper Lee, Year=1960\\" def test_delete_book(): catalog = BookCatalog() catalog.add_book(1, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) catalog.delete_book(1) assert catalog.retrieve_book(1) == \\"Book not found\\" def test_catalog_limit(): catalog = BookCatalog() for i in range(1000): catalog.add_book(i, f\\"Title {i}\\", \\"Author Name\\", 2000 + i % 100) assert len(catalog.books) == 1000 # Attempt to add another book, beyond the limit catalog.add_book(1001, \\"Extra Book\\", \\"Extra Author\\", 2023) assert len(catalog.books) == 1000 # Should still be 1000, the book wasn't added def test_retrieve_nonexistent_book(): catalog = BookCatalog() assert catalog.retrieve_book(999) == \\"Book not found\\"","solution":"class BookCatalog: def __init__(self): self.books = {} def add_book(self, book_id, title, author, year): if len(self.books) < 1000: self.books[book_id] = {\\"title\\": title, \\"author\\": author, \\"year\\": year} def retrieve_book(self, book_id): if book_id in self.books: book = self.books[book_id] return f\\"Book details: ID={book_id}, Title={book['title']}, Author={book['author']}, Year={book['year']}\\" return \\"Book not found\\" def delete_book(self, book_id): if book_id in self.books: del self.books[book_id]"},{"question":"def merge_intervals(intervals): Merges overlapping time intervals from a list of tuples where each tuple contains two strings representing a start time and an end time in \\"HH:MM\\" format. Parameters: intervals (list of tuples): A list of tuples where each tuple contains two strings representing a start time and an end time in \\"HH:MM\\" format. Returns: list of tuples: A list of merged non-overlapping intervals in \\"HH:MM\\" format. >>> merge_intervals([(\\"09:00\\", \\"11:00\\"), (\\"11:00\\", \\"12:00\\"), (\\"10:30\\", \\"13:00\\"), (\\"15:00\\", \\"16:30\\")]) [(\\"09:00\\", \\"13:00\\"), (\\"15:00\\", \\"16:30\\")] >>> merge_intervals([(\\"09:00\\", \\"10:00\\"), (\\"11:00\\", \\"12:00\\"), (\\"13:00\\", \\"14:00\\")]) [(\\"09:00\\", \\"10:00\\"), (\\"11:00\\", \\"12:00\\"), (\\"13:00\\", \\"14:00\\")]","solution":"def merge_intervals(intervals): Merges overlapping time intervals. Parameters: intervals (list of tuples): A list of tuples where each tuple contains two strings representing a start time and an end time in \\"HH:MM\\" format. Returns: list of tuples: A list of merged non-overlapping intervals in \\"HH:MM\\" format. # Convert intervals to minutes since start of day intervals_minutes = [ (int(start.split(\\":\\")[0]) * 60 + int(start.split(\\":\\")[1]), int(end.split(\\":\\")[0]) * 60 + int(end.split(\\":\\")[1])) for start, end in intervals ] # Sort intervals by the start time intervals_minutes.sort() merged_intervals = [] for start, end in intervals_minutes: if not merged_intervals or merged_intervals[-1][1] < start: merged_intervals.append((start, end)) else: merged_intervals[-1] = (merged_intervals[-1][0], max(merged_intervals[-1][1], end)) # Convert back to \\"HH:MM\\" format merged_intervals_formatted = [ (f\\"{start // 60:02}:{start % 60:02}\\", f\\"{end // 60:02}:{end % 60:02}\\") for start, end in merged_intervals ] return merged_intervals_formatted"},{"question":"def reverse_binary_list(lst): Takes a list of integers and returns a new list where each integer is represented as a string of its binary equivalent in reverse order. Raises a ValueError if a negative integer is found. Example: >>> reverse_binary_list([2, 3, 4]) -> ['01', '11', '001'] >>> reverse_binary_list([0, 7, 8]) -> ['0', '111', '0001'] >>> reverse_binary_list([-1, 5, -8]) -> ValueError :param lst: List of integers :return: List of reversed binary string equivalents","solution":"def reverse_binary_list(lst): Takes a list of integers and returns a new list where each integer is represented as a string of its binary equivalent in reverse order. Raises a ValueError if a negative integer is found. Example: reverse_binary_list([2, 3, 4]) should return ['01', '11', '001'] reverse_binary_list([0, 7, 8]) should return ['0', '111', '0001'] reverse_binary_list([-1, 5, -8]) should raise a ValueError :param lst: List of integers :return: List of reversed binary string equivalents result = [] for num in lst: if num < 0: raise ValueError(f\\"Negative number found: {num}\\") binary_str = bin(num)[2:] # Convert number to binary, strip '0b' reversed_binary_str = binary_str[::-1] # Reverse the binary string result.append(reversed_binary_str) return result"},{"question":"def isogram(s: str) -> bool: Determines whether a given string \`s\` is an isogram. An isogram is a word or phrase without a repeating letter, however spaces and hyphens are allowed to appear multiple times. Letter comparison should be case-insensitive. >>> isogram(\\"lumberjack\\") True >>> isogram(\\"background\\") True >>> isogram(\\"downstream\\") True >>> isogram(\\"six-year-old\\") True >>> isogram(\\"Alphabet\\") False","solution":"def isogram(s): Determines whether a given string s is an isogram. An isogram is a word or phrase without a repeating letter (case insensitive), however spaces and hyphens are allowed to appear multiple times. s = s.replace(\\" \\", \\"\\").replace(\\"-\\", \\"\\").lower() return len(s) == len(set(s))"},{"question":"def two_number_sum(array, target_sum): Write a function that takes in a non-empty array of distinct integers and an integer representing a target sum. If any two numbers in the input array sum up to the target sum, the function should return them in an array, in any order. If no two numbers sum up to the target sum, the function should return an empty array. Example: >>> two_number_sum([3, 5, -4, 8, 11, 1, -1, 6], 10) [11, -1] >>> two_number_sum([1, 2, 3, 4, 5], 10) [] # Unit tests def test_general_case(): array = [3, 5, -4, 8, 11, 1, -1, 6] target_sum = 10 result = two_number_sum(array, target_sum) assert sorted(result) == sorted([11, -1]) def test_no_pair(): array = [1, 2, 3, 4, 5] target_sum = 10 result = two_number_sum(array, target_sum) assert result == [] def test_with_negative_numbers(): array = [-3, -1, 1, 2, 9] target_sum = 1 result = two_number_sum(array, target_sum) assert sorted(result) == sorted([-1, 2]) def test_pair_with_zero_in_array(): array = [0, 2, 3, 7, 11] target_sum = 10 result = two_number_sum(array, target_sum) assert sorted(result) == sorted([3, 7]) def test_array_with_only_two_numbers(): array = [-7, 17] target_sum = 10 result = two_number_sum(array, target_sum) assert sorted(result) == sorted([-7, 17])","solution":"def two_number_sum(array, target_sum): Returns two numbers from the array that sum up to the target sum, if such a pair exists. Otherwise, returns an empty array. num_map = {} for num in array: potential_match = target_sum - num if potential_match in num_map: return [num, potential_match] else: num_map[num] = True return []"},{"question":"import re from typing import List def is_palindrome(s: str) -> bool: Determines if a given string is a palindrome, ignoring spaces, punctuation, and capitalization. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") == True >>> is_palindrome(\\"No lemon, no melon\\") == True >>> is_palindrome(\\"Hello World\\") == False >>> is_palindrome(\\"Was it a car or a cat I saw\\") == True >>> is_palindrome(\\"Not a palindrome\\") == False def count_vowels(s: str) -> int: Counts the number of vowels in a given string. >>> count_vowels(\\"Example String\\") == 4 >>> count_vowels(\\"aeiou\\") == 5 >>> count_vowels(\\"AEIOU\\") == 5 >>> count_vowels(\\"Python Programming\\") == 4 >>> count_vowels(\\"bcdfg\\") == 0","solution":"import re def is_palindrome(s): Determines if a given string is a palindrome, ignoring spaces, punctuation, and capitalization. # Remove non-alphanumeric characters and convert to lower case filtered_s = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the string is equal to its reverse return filtered_s == filtered_s[::-1] def count_vowels(s): Counts the number of vowels in a given string. vowels = \\"aeiouAEIOU\\" count = 0 for char in s: if char in vowels: count += 1 return count"},{"question":"from typing import List, Tuple, Dict def allocate_meeting_rooms(meetings: List[Tuple[int, int, int]]) -> Tuple[Dict[int, int], int]: Allocates meeting rooms for given set of meetings to maximize resource utilization by minimizing the number of meeting rooms used. The meeting is a list of tuples where each tuple contains (meeting_id, start_time, end_time). Returns a dictionary with meeting IDs as keys and allocated room number as values. Also returns the total number of rooms used. >>> allocate_meeting_rooms([]) ({}, 0) >>> allocate_meeting_rooms([(1, 10, 20)]) ({1: 1}, 1) >>> allocate_meeting_rooms([(1, 10, 20), (2, 21, 30), (3, 31, 40)]) ({1: 1, 2: 1, 3: 1}, 1) >>> allocate_meeting_rooms([(1, 10, 20), (2, 15, 25), (3, 20, 30)]) ({1: 1, 2: 2, 3: 1}, 2) >>> allocate_meeting_rooms([(1, 1, 10), (2, 2, 7), (3, 3, 19), (4, 8, 12), (5, 18, 30)]) ({1: 1, 2: 2, 3: 3, 4: 2, 5: 1}, 3) >>> allocate_meeting_rooms([(1, 10, 5)]) Traceback (most recent call last): ... ValueError: Invalid meeting times: start_time (10) should be less than end_time (5).","solution":"import heapq def allocate_meeting_rooms(meetings): Allocates meeting rooms for given set of meetings to maximize resource utilization by minimizing the number of meeting rooms used. The meeting is a list of tuples where each tuple contains (meeting_id, start_time, end_time). Returns a dictionary with meeting IDs as keys and allocated room number as values. Also returns the total number of rooms used. if not meetings: return {}, 0 # Sort meetings by start time meetings.sort(key=lambda x: x[1]) # Priority queue for keeping track of end times of meetings in each room heap = [] # Dictionary to maintain meeting ID and allocated room allocated_rooms = {} for meeting in meetings: meeting_id, start_time, end_time = meeting # Input validation if start_time >= end_time: raise ValueError(f\\"Invalid meeting times: start_time ({start_time}) should be less than end_time ({end_time}).\\") # Check if any room is free if heap and heap[0][0] <= start_time: # Reuse the room end_time_prev, room_number = heapq.heappop(heap) else: # Allocate a new room room_number = len(heap) + 1 # Allocate the room to the current meeting allocated_rooms[meeting_id] = room_number # Add the end time of the current meeting to the heap heapq.heappush(heap, (end_time, room_number)) return allocated_rooms, len(heap)"},{"question":"def longest_common_prefix(strings): Returns the longest common prefix string among an array of strings. If there is no common prefix, return an empty string. >>> longest_common_prefix([\\"intersperse\\", \\"internet\\", \\"interval\\", \\"intersect\\"]) 'inter' >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) 'fl' >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' >>> longest_common_prefix([]) '' >>> longest_common_prefix([\\"single\\"]) 'single' >>> longest_common_prefix([\\"test\\", \\"test\\", \\"test\\"]) 'test' >>> longest_common_prefix([\\"Test\\", \\"test\\", \\"testing\\"]) '' >>> longest_common_prefix([\\"\\", \\"empty\\", \\"entries\\"]) '' >>> longest_common_prefix([\\"abcde\\", \\"abfgh\\", \\"abxyz\\"]) 'ab' >>> longest_common_prefix([\\"@prefix\\", \\"@presume\\", \\"@pressed\\"]) '@pre'","solution":"def longest_common_prefix(strings): Returns the longest common prefix string among an array of strings. If there is no common prefix, return an empty string. if not strings: return \\"\\" # Sort the strings to get the least and most lexicographically strings.sort() # Take the first and the last string after sorting first = strings[0] last = strings[-1] # Compare characters of the first and last string common_prefix = [] for i in range(min(len(first), len(last))): if first[i] == last[i]: common_prefix.append(first[i]) else: break return ''.join(common_prefix)"},{"question":"def list_intersection(lst1, lst2): Finds the intersection of two given lists without duplicates. Parameters: lst1 (list): The first list. lst2 (list): The second list. Returns: list: A list containing the unique elements that are present in both lists. >>> list_intersection([1, 2, 3, 4, 5], [3, 4, 5, 6, 7]) [3, 4, 5] >>> list_intersection([1, 2, 3], [4, 5, 6]) [] >>> list_intersection([1, 2, 3], [1, 2, 3]) [1, 2, 3] >>> list_intersection([1, 2, 2, 3, 4], [2, 2, 4, 6]) [2, 4] >>> list_intersection([], [2, 4, 6]) [] >>> list_intersection([1, 2, 3], []) [] >>> list_intersection([], []) [] >>> list_intersection([1, 2, 3], [4, 5, 6]) [] >>> list_intersection([1], [1]) [1] >>> list_intersection([1], [2]) []","solution":"def list_intersection(lst1, lst2): Finds the intersection of two given lists without duplicates. Parameters: lst1 (list): The first list. lst2 (list): The second list. Returns: list: A list containing the unique elements that are present in both lists. return list(set(lst1).intersection(set(lst2)))"},{"question":"import pandas as pd def merge_customers_orders(df_customers, df_orders): Merges two DataFrames df_customers and df_orders on 'customerId' so that all customers, including those who have not placed any orders, are included in the result. Parameters: df_customers (pd.DataFrame): DataFrame containing customer information. df_orders (pd.DataFrame): DataFrame containing order information. Returns: pd.DataFrame: The merged DataFrame. # Write code here to merge the DataFrames # Example DataFrames for verification (can be used as test cases) df_customers = pd.DataFrame({ 'customerId': [1, 2, 3], 'name': ['Alice', 'Bob', 'Charlie'], 'age': [25, 30, 35] }) df_orders = pd.DataFrame({ 'orderId': [101, 102, 103], 'customerId': [1, 2, 2], 'product': ['Book', 'Laptop', 'Pen'], 'orderDate': ['2021-01-01', '2021-01-02', '2021-01-03'] }) def test_merge_customers_orders(): expected_result = pd.DataFrame({ 'customerId': [1, 2, 2, 3], 'name': ['Alice', 'Bob', 'Bob', 'Charlie'], 'age': [25, 30, 30, 35], 'orderId': [101, 102, 103, None], 'product': ['Book', 'Laptop', 'Pen', None], 'orderDate': ['2021-01-01', '2021-01-02', '2021-01-03', None] }) result = merge_customers_orders(df_customers, df_orders) pd.testing.assert_frame_equal(result, expected_result, check_dtype=False) test_merge_customers_orders()","solution":"import pandas as pd def merge_customers_orders(df_customers, df_orders): Merges two DataFrames df_customers and df_orders on 'customerId' so that all customers, including those who have not placed any orders, are included in the result. Parameters: df_customers (pd.DataFrame): DataFrame containing customer information. df_orders (pd.DataFrame): DataFrame containing order information. Returns: pd.DataFrame: The merged DataFrame. df_merged = pd.merge(df_customers, df_orders, on='customerId', how='left') return df_merged # Example DataFrames for verification df_customers = pd.DataFrame({ 'customerId': [1, 2, 3], 'name': ['Alice', 'Bob', 'Charlie'], 'age': [25, 30, 35] }) df_orders = pd.DataFrame({ 'orderId': [101, 102, 103], 'customerId': [1, 2, 2], 'product': ['Book', 'Laptop', 'Pen'], 'orderDate': ['2021-01-01', '2021-01-02', '2021-01-03'] }) df_merged = merge_customers_orders(df_customers, df_orders) print(df_merged)"},{"question":"class DistributedFileSystem: def __init__(self, nodes): Initializes the distributed file system with given nodes. Parameters: nodes (List[Node]): The list of nodes that make up the distributed file system. def add_file(self, file_path, data): Adds a file to the distributed file system. Parameters: file_path (str): The path of the file. data (str): The data to be stored in the file. Returns: bool: True if the file is added successfully, False otherwise. def get_file(self, file_path): Retrieves a file from the distributed file system. Parameters: file_path (str): The path of the file to retrieve. Returns: str: The data of the file. class Node: def __init__(self, name): Initializes a node with a given name. Parameters: name (str): The name of the node. def store_file(self, file_path, data): Stores a file on the node. Parameters: file_path (str): The path of the file to store. data (str): The data to store in the file. def get_file(self, file_path): Retrieves a file from the node. Parameters: file_path (str): The path of the file to retrieve. Returns: str: The data of the file. # Unit tests def test_add_and_get_file(): node1 = Node(\\"Node1\\") node2 = Node(\\"Node2\\") dfs = DistributedFileSystem([node1, node2]) # Add a file assert dfs.add_file(\\"/path/to/file1\\", \\"data1\\") == True assert dfs.add_file(\\"/path/to/file2\\", \\"data2\\") == True # Retrieve the file assert dfs.get_file(\\"/path/to/file1\\") == \\"data1\\" assert dfs.get_file(\\"/path/to/file2\\") == \\"data2\\" def test_load_balancing(): node1 = Node(\\"Node1\\") node2 = Node(\\"Node2\\") dfs = DistributedFileSystem([node1, node2]) # Add multiple files dfs.add_file(\\"/path/to/file1\\", \\"data1\\") dfs.add_file(\\"/path/to/file2\\", \\"data2\\") # Ensure that files are distributed across nodes assert \\"/path/to/file1\\" in node1.files or \\"/path/to/file1\\" in node2.files assert \\"/path/to/file2\\" in node1.files or \\"/path/to/file2\\" in node2.files def test_file_not_found(): node1 = Node(\\"Node1\\") node2 = Node(\\"Node2\\") dfs = DistributedFileSystem([node1, node2]) try: dfs.get_file(\\"/path/to/non_existent_file\\") except FileNotFoundError: assert True else: assert False","solution":"class DistributedFileSystem: def __init__(self, nodes): self.nodes = nodes # List of nodes in the distributed system self.file_allocation_table = {} # Mapping of file paths to node locations def add_file(self, file_path, data): Adds a file to the distributed file system. Parameters: file_path (str): The path of the file. data (str): The data to be stored in the file. Returns: bool: True if the file is added successfully, False otherwise. # Select node based on load balancing strategy (e.g., round robin) node = self._select_node() # Simulate storing file in node node.store_file(file_path, data) # Update file allocation table self.file_allocation_table[file_path] = node return True def get_file(self, file_path): Retrieves a file from the distributed file system. Parameters: file_path (str): The path of the file to retrieve. Returns: str: The data of the file. node = self.file_allocation_table.get(file_path) if node: return node.get_file(file_path) else: raise FileNotFoundError(\\"File not found in file allocation table\\") def _select_node(self): Selects a node based on load balancing strategy. Returns: Node: The selected node. # Example: Simple round robin implementation selected_node = self.nodes.pop(0) self.nodes.append(selected_node) return selected_node class Node: def __init__(self, name): self.name = name self.files = {} # Local storage of files def store_file(self, file_path, data): Stores a file on the node. Parameters: file_path (str): The path of the file to store. data (str): The data to store in the file. self.files[file_path] = data def get_file(self, file_path): Retrieves a file from the node. Parameters: file_path (str): The path of the file to retrieve. Returns: str: The data of the file. return self.files[file_path]"},{"question":"class FileSystem: A class to simulate a simple file system. Methods: - mkdir(path: str) -> None: Creates a new directory at the given path. - addPath(path: str, value: int) -> None: Adds a new path at the given location with some integer value. def test_mkdir_simple(): fs = FileSystem() fs.mkdir(\\"/a/b/c\\") assert \\"a\\" in fs.fs assert \\"b\\" in fs.fs[\\"a\\"] assert \\"c\\" in fs.fs[\\"a\\"][\\"b\\"] def test_addPath_simple(): fs = FileSystem() fs.mkdir(\\"/a/b/c\\") fs.addPath(\\"/a/b/c/d\\", 10) assert fs.fs[\\"a\\"][\\"b\\"][\\"c\\"][\\"d\\"] == 10 def test_addPath_creates_intermediate_dirs(): fs = FileSystem() fs.addPath(\\"/a/b/c/d\\", 10) assert fs.fs[\\"a\\"][\\"b\\"][\\"c\\"][\\"d\\"] == 10 def test_mkdir_nested(): fs = FileSystem() fs.mkdir(\\"/x/y\\") fs.mkdir(\\"/x/y/z\\") assert \\"x\\" in fs.fs assert \\"y\\" in fs.fs[\\"x\\"] assert \\"z\\" in fs.fs[\\"x\\"][\\"y\\"] def test_addPath_overwrite(): fs = FileSystem() fs.addPath(\\"/a/b/c\\", 5) fs.addPath(\\"/a/b/c\\", 10) assert fs.fs[\\"a\\"][\\"b\\"][\\"c\\"] == 10","solution":"class FileSystem: def __init__(self): self.fs = {} def mkdir(self, path: str) -> None: components = path.split('/') current = self.fs for component in components: if component: # skip empty components caused by leading '/' if component not in current: current[component] = {} current = current[component] def addPath(self, path: str, value: int) -> None: components = path.split('/') current = self.fs for component in components[:-1]: if component: # skip empty components caused by leading '/' if component not in current: current[component] = {} current = current[component] last_component = components[-1] if last_component: current[last_component] = value"},{"question":"def max_contiguous_subarray_sum(arr: List[int]) -> int: Returns the maximum sum of any contiguous subarray within the list, using Kadane's Algorithm. Examples: >>> max_contiguous_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_contiguous_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_contiguous_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_contiguous_subarray_sum([5]) 5 >>> max_contiguous_subarray_sum([-5]) -5 >>> max_contiguous_subarray_sum([]) 0 >>> max_contiguous_subarray_sum([1, 2, -1, 2, -1, 2, 1]) 6","solution":"def max_contiguous_subarray_sum(arr): Returns the maximum sum of any contiguous subarray within the list. if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def bubble_sort(arr: List[int]) -> List[int]: Write a Python function that takes a list of integers as an input and returns a list of the integers sorted in ascending order without using any built-in sort functions. The function should implement the bubble sort algorithm to achieve the sorting. >>> bubble_sort([]) == [] >>> bubble_sort([1]) == [1] >>> bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> bubble_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] >>> bubble_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] >>> bubble_sort([4, 2, 2, 8, 3, 3, 1]) == [1, 2, 2, 3, 3, 4, 8]","solution":"def bubble_sort(arr): Returns a new list of integers sorted in ascending order using the bubble sort algorithm. n = len(arr) sorted_arr = arr.copy() for i in range(n): for j in range(0, n-i-1): if sorted_arr[j] > sorted_arr[j+1]: sorted_arr[j], sorted_arr[j+1] = sorted_arr[j+1], sorted_arr[j] return sorted_arr"},{"question":"def count_numbers(lst): Returns a dictionary with the count of positive, negative, and zero numbers in the list. Args: lst (list): A list of integers. Returns: dict: A dictionary with keys 'positive', 'negative', and 'zero' and their respective counts. >>> count_numbers([1, -1, 2, 0, -3, 5, 0, -8]) {'positive': 3, 'negative': 3, 'zero': 2} >>> count_numbers([1, 2, 3, 4, 5]) {'positive': 5, 'negative': 0, 'zero': 0} >>> count_numbers([-1, -2, -3, -4, -5]) {'positive': 0, 'negative': 5, 'zero': 0} >>> count_numbers([0, 0, 0]) {'positive': 0, 'negative': 0, 'zero': 3} >>> count_numbers([]) {'positive': 0, 'negative': 0, 'zero': 0}","solution":"def count_numbers(lst): Returns a dictionary with the count of positive, negative, and zero numbers in the list. Args: lst (list): A list of integers. Returns: dict: A dictionary with keys 'positive', 'negative', and 'zero' and their respective counts. counters = {'positive': 0, 'negative': 0, 'zero': 0} for number in lst: if number > 0: counters['positive'] += 1 elif number < 0: counters['negative'] += 1 else: counters['zero'] += 1 return counters"},{"question":"class ParkingSystem: def __init__(self, big: int, medium: int, small: int): Initialize the ParkingSystem with a given number of slots for each type of vehicle. pass def addCar(self, carType: int) -> bool: Tries to park a car of a given carType: 1 = big, 2 = medium, 3 = small. Returns True if the car can be parked, otherwise returns False. pass # Unit tests def test_parking_system(): parking_system = ParkingSystem(1, 1, 0) # Initial parking should be successful assert parking_system.addCar(1) == True # one big slot available assert parking_system.addCar(2) == True # one medium slot available # No small slots available assert parking_system.addCar(3) == False # no small slots available # No more big slots available assert parking_system.addCar(1) == False # big slot already taken # Testing after more parking attempts parking_system = ParkingSystem(2, 2, 1) assert parking_system.addCar(1) == True # first big slot taken assert parking_system.addCar(1) == True # second big slot taken assert parking_system.addCar(1) == False # no more big slots available assert parking_system.addCar(2) == True # first medium slot taken assert parking_system.addCar(2) == True # second medium slot taken assert parking_system.addCar(2) == False # no more medium slots available assert parking_system.addCar(3) == True # small slot taken assert parking_system.addCar(3) == False # no more small slots available def test_edge_cases(): parking_system = ParkingSystem(0, 0, 0) assert parking_system.addCar(1) == False # no big slots available assert parking_system.addCar(2) == False # no medium slots available assert parking_system.addCar(3) == False # no small slots available parking_system = ParkingSystem(1000, 1000, 1000) for _ in range(1000): assert parking_system.addCar(1) == True assert parking_system.addCar(2) == True assert parking_system.addCar(3) == True assert parking_system.addCar(1) == False # all big slots taken assert parking_system.addCar(2) == False # all medium slots taken assert parking_system.addCar(3) == False # all small slots taken","solution":"class ParkingSystem: def __init__(self, big: int, medium: int, small: int): Initialize the ParkingSystem with a given number of slots for each type of vehicle. self.spots = {1: big, 2: medium, 3: small} def addCar(self, carType: int) -> bool: Tries to park a car of a given carType: 1 = big, 2 = medium, 3 = small. Returns True if the car can be parked, otherwise returns False. if self.spots[carType] > 0: self.spots[carType] -= 1 return True else: return False"},{"question":"def min_total_time(people: List[List[int]]) -> int: Returns the minimum total time required for all people to reach a meeting point. >>> min_total_time([[1,0],[2,2]]) == 3 >>> min_total_time([[0,0],[2,2]]) == 4 >>> min_total_time([[0,0]]) == 0 >>> min_total_time([[0,0],[1,0],[2,0]]) == 2 >>> min_total_time([[0,0],[0,1],[0,2]]) == 2 >>> min_total_time([[0,2],[1,0],[2,1]]) == 4","solution":"def min_total_time(people): Returns the minimum total time required for all people to reach a meeting point. rows = sorted([p[0] for p in people]) cols = sorted([p[1] for p in people]) median_row = rows[len(rows) // 2] median_col = cols[len(cols) // 2] total_time = 0 for r, c in people: total_time += abs(r - median_row) + abs(c - median_col) return total_time"},{"question":"def top_three_max(nums: List[int]) -> List[int]: Returns the top three maximum numbers from the list in descending order. If the list contains fewer than three elements, return all elements in descending order. >>> top_three_max([3, 1, 2]) == [3, 2, 1] >>> top_three_max([5, 3, 9, 1, 4]) == [9, 5, 4] >>> top_three_max([7]) == [7] >>> top_three_max([8, 2]) == [8, 2] >>> top_three_max([]) == [] >>> top_three_max([3, 3, 3]) == [3, 3, 3] >>> top_three_max([1, 1, 0, 0]) == [1, 1, 0] >>> top_three_max([10, 20, 10, 20, 30]) == [30, 20, 20] >>> top_three_max([100000, 10000, 1000, 100, 10]) == [100000, 10000, 1000]","solution":"def top_three_max(nums): Returns the top three maximum numbers from the list in descending order. If the list contains fewer than three elements, return all elements in descending order. if len(nums) == 0: return [] # Initialize top three variables first, second, third = float('-inf'), float('-inf'), float('-inf') for num in nums: if num > first: third = second second = first first = num elif num > second: third = second second = num elif num > third: third = num # Prepare the result list result = [num for num in [first, second, third] if num != float('-inf')] return result"},{"question":"def process_names(names): Processes a list of names and returns a dictionary where the keys are the unique first letters of the names and the values are lists of names starting with that letter, sorted in alphabetical order. Args: names (list): A list of strings where each string is a name. Returns: dict: A dictionary with the first letters as keys and lists of names as values, or str: an error message in case of invalid input. >>> process_names([\\"John\\", \\"Jack\\", \\"Albert\\", \\"Andrew\\", \\"Jim\\"]) {'J': ['Jack', 'Jim', 'John'], 'A': ['Albert', 'Andrew']} >>> process_names([]) 'No valid names provided.' >>> process_names(\\"John\\") 'Input must be a list.' >>> process_names(123) 'Input must be a list.' >>> process_names([\\"John\\", 123, None, \\"Albert\\"]) {'J': ['John'], 'A': ['Albert']} >>> process_names([\\"apple\\", \\"Banana\\", None, 123, \\"apricot\\"]) {'A': ['apple', 'apricot'], 'B': ['Banana']}","solution":"def process_names(names): Processes a list of names and returns a dictionary where the keys are the unique first letters of the names and the values are lists of names starting with that letter, sorted in alphabetical order. Args: names (list): A list of strings where each string is a name. Returns: dict: A dictionary with the first letters as keys and lists of names as values, or str: an error message in case of invalid input. if not isinstance(names, list): return \\"Input must be a list.\\" # Filter out non-string elements from the list. valid_names = [name for name in names if isinstance(name, str)] if not valid_names: return \\"No valid names provided.\\" name_dict = {} for name in valid_names: if name: first_letter = name[0].upper() if first_letter not in name_dict: name_dict[first_letter] = [] name_dict[first_letter].append(name) # Sort the names starting with each letter. for key in name_dict: name_dict[key].sort() return name_dict"},{"question":"from typing import List from collections import Counter def frequency_sort(lst: List[int]) -> List[int]: Sorts a list of integers based on the frequency of each integer in descending order. If multiple integers have the same frequency, those integers are sorted in ascending order. >>> frequency_sort([4, 3, 1, 6, 4, 7, 1, 4, 7]) [4, 4, 4, 1, 1, 7, 7, 3, 6] >>> frequency_sort([9, 9, 8, 7, 8, 9, 8]) [8, 8, 8, 9, 9, 9, 7] pass","solution":"from collections import Counter def frequency_sort(lst): Sorts a list of integers based on the frequency of each integer in descending order. If multiple integers have the same frequency, those integers are sorted in ascending order. count = Counter(lst) # Sort primarily by frequency (descending), secondarily by value (ascending) sorted_lst = sorted(lst, key=lambda x: (-count[x], x)) return sorted_lst"},{"question":"import math from typing import List, Optional def is_prime(n: int) -> bool: Helper function to check if a given number n is prime. if n <= 1: return False if n == 2: return True for i in range(2, math.isqrt(n) + 1): if n % i == 0: return False return True def filter_primes(lst: List[int]) -> List[int]: Returns a list of prime numbers from the given list lst. >>> filter_primes([10, 15, 3, 7, 11, 2, 20, 13, 5]) [3, 7, 11, 2, 13, 5] >>> filter_primes([1, 4, 6, 8, 9, 10]) [] >>> filter_primes([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] pass def highest_prime(lst: List[int]) -> Optional[int]: Returns the highest prime number in the given list lst. >>> highest_prime([10, 15, 3, 7, 11, 2, 20, 13, 5]) 13 >>> highest_prime([1, 4, 6, 8, 9, 10]) None >>> highest_prime([2, 3, 5, 7, 11]) 11 pass def sum_of_primes(lst: List[int]) -> int: Returns the sum of all prime numbers in the given list lst. >>> sum_of_primes([10, 15, 3, 7, 11, 2, 20, 13, 5]) 41 >>> sum_of_primes([1, 4, 6, 8, 9, 10]) 0 >>> sum_of_primes([2, 3, 5, 7, 11]) 28 pass","solution":"import math def is_prime(n): Helper function to check if a given number n is prime. if n <= 1: return False if n == 2: return True for i in range(2, math.isqrt(n) + 1): if n % i == 0: return False return True def filter_primes(lst): Returns a list of prime numbers from the given list lst. return [x for x in lst if is_prime(x)] def highest_prime(lst): Returns the highest prime number in the given list lst. primes = filter_primes(lst) return max(primes) if primes else None def sum_of_primes(lst): Returns the sum of all prime numbers in the given list lst. return sum(filter_primes(lst)) # Demonstration with a sample list of integers sample_list = [10, 15, 3, 7, 11, 2, 20, 13, 5] filtered_primes = filter_primes(sample_list) highest_prime_in_list = highest_prime(sample_list) sum_primes_in_list = sum_of_primes(sample_list)"},{"question":"from typing import List def longest_palindrome_substring(s: str) -> str: Returns the longest palindrome substring in a given string. >>> longest_palindrome_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] >>> longest_palindrome_substring(\\"a\\") == \\"a\\" >>> longest_palindrome_substring(\\"bb\\") == \\"bb\\" >>> longest_palindrome_substring(\\"ab\\") == \\"a\\" >>> longest_palindrome_substring(\\"racecar\\") == \\"racecar\\" >>> longest_palindrome_substring(\\"aabcdcb\\") == \\"bcdcb\\" >>> longest_palindrome_substring(\\"bananas\\") == \\"anana\\" >>> longest_palindrome_substring(\\"aA\\") == \\"a\\" >>> longest_palindrome_substring(\\"Aa\\") == \\"A\\" >>> longest_palindrome_substring(\\"aAaa\\") == \\"aAa\\" >>> longest_palindrome_substring(\\"abc\\") == \\"a\\" >>> longest_palindrome_substring(\\"\\") == \\"\\" >>> longest_palindrome_substring(\\"aaaa\\") == \\"aaaa\\" >>> longest_palindrome_substring(\\"bbbbbb\\") == \\"bbbbbb\\"","solution":"def longest_palindrome_substring(s): Returns the longest palindrome substring in a given string. n = len(s) if n == 0: return \\"\\" dp = [[False] * n for _ in range(n)] start = 0 max_length = 1 for i in range(n): dp[i][i] = True for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if dp[i + 1][j - 1] and s[i] == s[j]: dp[i][j] = True start = i max_length = length return s[start:start + max_length]"},{"question":"def char_count(s: str) -> Dict[str, int]: Returns a dictionary where keys are characters from the string (case-insensitive), and values are the count of their occurrences in the string. >>> char_count('a') {'a': 1} >>> char_count('abc') {'a': 1, 'b': 1, 'c': 1} >>> char_count('aaabb') {'a': 3, 'b': 2} >>> char_count('AaBb') {'a': 2, 'b': 2} >>> char_count('') {} >>> char_count('@#') {'@': 1, '#': 1, '': 1} >>> char_count('AaB1b2') {'a': 2, 'b': 2, '1': 1, '2': 1} >>> char_count('a a b b') {'a': 2, ' ': 3, 'b': 2} # Implementation here if __name__ == \\"__main__\\": input_string = input(\\"Enter a string: \\") print(char_count(input_string))","solution":"def char_count(s): Returns a dictionary where keys are characters from the string (case-insensitive), and values are the count of their occurrences in the string. s = s.lower() count_dict = {} for char in s: if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 return count_dict if __name__ == \\"__main__\\": input_string = input(\\"Enter a string: \\") print(char_count(input_string))"},{"question":"from typing import List, Optional def find_majority_element(arr: List[int]) -> Optional[int]: Returns the majority element if it exists, or None otherwise. A majority element is the element that appears more than n/2 times in the list. >>> find_majority_element([3,3,4,2,4,4,2,4,4]) == 4 >>> find_majority_element([3,3,4,2,4,4,2,4]) == None >>> find_majority_element([1]) == 1 >>> find_majority_element([5, 5, 5, 5, 5]) == 5 >>> find_majority_element([7, 7, 7, 1, 2, 3, 7, 7, 7, 7]) == 7 >>> find_majority_element([1, 2, 3, 4, 5, 5, 5, 5, 5]) == 5 >>> find_majority_element([]) == None","solution":"from typing import List, Optional def find_majority_element(arr: List[int]) -> Optional[int]: Returns the majority element if it exists, or None otherwise. A majority element is the element that appears more than n/2 times in the list. candidate = None count = 0 # Boyer-Moore Voting Algorithm to find potential majority element for num in arr: if count == 0: candidate = num if num == candidate: count += 1 else: count -= 1 # Verify if candidate is actually the majority if arr.count(candidate) > len(arr) // 2: return candidate return None"},{"question":"def rotate_matrix90(matrix): Rotate an NxN matrix 90 degrees clockwise in place. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix90(matrix) >>> matrix ... [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ]","solution":"def rotate_matrix90(matrix): Rotates an NxN matrix 90 degrees clockwise in place. n = len(matrix) for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): offset = i - first # Save the top top = matrix[first][i] # left -> top matrix[first][i] = matrix[last-offset][first] # bottom -> left matrix[last-offset][first] = matrix[last][last-offset] # right -> bottom matrix[last][last-offset] = matrix[i][last] # top -> right matrix[i][last] = top"},{"question":"def evaluate_expression(expression): Evaluates a mathematical expression containing non-negative integers and operators (+, -, *, /) and respects the order of operations (PEMDAS). This function does not use the built-in \`eval\` function or similar built-in functions. pass def test_simple_addition(): assert evaluate_expression(\\"2 + 3\\") == 5 def test_addition_and_subtraction(): assert evaluate_expression(\\"5 - 3 + 2\\") == 4 def test_multiplication_and_division(): assert evaluate_expression(\\"4 * 3 / 2\\") == 6 # 12 / 2 def test_combined_operations(): assert evaluate_expression(\\"2 + 3 * 4\\") == 14 # 2 + 12 def test_parentheses(): assert evaluate_expression(\\"(2 + 3) * 4\\") == 20 def test_nested_parentheses(): assert evaluate_expression(\\"(2 + (3 * 4)) - 5\\") == 9 # (2 + 12) - 5 def test_division_rounding_down(): assert evaluate_expression(\\"8 / 3\\") == 2 # 2.666... should round down to 2 def test_expression_with_spaces(): assert evaluate_expression(\\" 8 + 2 * 5 / ( 1 + 1 ) \\") == 13 # 8 + 10 / 2 = 8 + 5 = 13 def test_large_numbers(): assert evaluate_expression(\\"12345 + 67890 * 2\\") == 148125 def test_no_operators(): assert evaluate_expression(\\"42\\") == 42","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing non-negative integers and operators (+, -, *, /) and respects the order of operations (PEMDAS). This function does not use the built-in \`eval\` function or similar built-in functions. def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(left // right) # Use integer division def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 # since there's an additional i += 1 in the loop elif expression[i] == '(': operators.append(expression[i]) elif expression[i] == ')': while len(operators) != 0 and operators[-1] != '(': apply_operator(operators, values) operators.pop() else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while len(operators) != 0: apply_operator(operators, values) return values[-1]"},{"question":"from typing import List, Tuple def is_prime(n: int) -> bool: Helper function to check if a number is prime. # Implementation of is_prime function pass def prime_numbers_and_count(nums: List[int]) -> Tuple[List[int], int]: Returns a list containing only the prime numbers from the original input list, and the count of these prime numbers. >>> prime_numbers_and_count([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) ([2, 3, 5, 7], 4) >>> prime_numbers_and_count([11, 13, 17, 19, 23]) ([11, 13, 17, 19, 23], 5) >>> prime_numbers_and_count([0, 1, 4, 6, 8, 10, 12]) ([], 0) >>> prime_numbers_and_count([31, 37, 41, 43, 47]) ([31, 37, 41, 43, 47], 5) >>> prime_numbers_and_count([15, 25, 35, 45, 55]) ([], 0) >>> prime_numbers_and_count([-3, -2, 0, 1, 2, 3, 5]) ([2, 3, 5], 3) # Implementation of the function to get prime numbers and their count pass","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_numbers_and_count(nums): Returns a list containing only the prime numbers from the original input list, and the count of these prime numbers. prime_list = [num for num in nums if is_prime(num)] count_of_primes = len(prime_list) return prime_list, count_of_primes"},{"question":"from typing import List def longest_contiguous_subarray(arrays: List[List[int]]) -> List[int]: Returns the length of the longest subarray with a contiguous set of elements for each input array. :param arrays: List of lists of integers :return: List of integers representing the length of longest contiguous subarray for each array # Unit tests def test_empty_array(): assert longest_contiguous_subarray([[]]) == [0] def test_single_element_array(): assert longest_contiguous_subarray([[1]]) == [1] def test_no_contiguous_elements(): assert longest_contiguous_subarray([[1, 3, 5, 7]]) == [1] def test_all_elements_contiguous(): assert longest_contiguous_subarray([[1, 2, 3, 4, 5]]) == [5] def test_mixed_elements_with_gaps(): assert longest_contiguous_subarray([[1, 3, 2, 5, 4, 8, 10]]) == [5] def test_multiple_arrays(): assert longest_contiguous_subarray([[1, 3, 2, 5, 4], [], [1, 5, 3, 4, 2, 8, 10], [2, 1, 3], [10], [4, 2, 1, 3, 7]]) == [5, 0, 5, 3, 1, 4] def test_none_contiguous_values(): assert longest_contiguous_subarray([[10, 50, 100]]) == [1]","solution":"def longest_contiguous_subarray(arrays): Returns the length of the longest subarray with a contiguous set of elements for each input array. def find_longest(arr): if not arr: return 0 arr = sorted(arr) max_len = 1 current_len = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1] + 1: current_len += 1 elif arr[i] != arr[i - 1]: max_len = max(max_len, current_len) current_len = 1 return max(max_len, current_len) return [find_longest(arr) for arr in arrays]"},{"question":"def find_longest_word(words: List[str]) -> str: Returns the longest word from the list of words. If multiple words have the same maximum length, the first one is returned. If the input list is empty, an empty string is returned. Example: >>> find_longest_word([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) # \\"banana\\" >>> find_longest_word([]) # \\"\\" >>> find_longest_word([\\"one\\", \\"two\\", \\"six\\", \\"ten\\"]) # \\"one\\" >>> find_longest_word([\\"apple\\", \\"banana\\", \\"pear\\", \\"cherry\\"]) # \\"banana\\" >>> find_longest_word([\\"apple\\"]) # \\"apple\\" >>> find_longest_word([\\"a\\", \\"abc\\", \\"ab\\"]) # \\"abc\\" >>> find_longest_word([\\"aaa\\", \\"bbb\\", \\"cccc\\", \\"dddd\\"]) # \\"cccc\\"","solution":"def find_longest_word(words): Returns the longest word from the list of words. If multiple words have the same maximum length, the first one is returned. If the input list is empty, an empty string is returned. if not words: return \\"\\" longest_word = words[0] for word in words[1:]: if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"from typing import List def find_missing_number(nums: List[int]) -> int: Create a function named \`find_missing_number\` that takes a list of integers containing \`n-1\` distinct elements ranging from 1 to \`n\` (inclusive) with one number missing, and returns the missing number. >>> find_missing_number([1, 2, 4, 5, 6]) == 3 >>> find_missing_number([3, 7, 1, 2, 8, 4, 5, 6]) == 9 >>> find_missing_number([1, 2, 3, 5]) == 4 >>> find_missing_number([2, 3, 4, 5]) == 1 >>> find_missing_number([2]) == 1 >>> find_missing_number([2, 3]) == 1","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Finds the missing number from the list of integers ranging from 1 to n. n = len(nums) + 1 total_sum = n * (n + 1) // 2 actual_sum = sum(nums) return total_sum - actual_sum"},{"question":"from typing import List, Tuple def city_block_distance(buildings: List[Tuple[int, int]]) -> Tuple[int, int]: Calculates the Manhattan distance between two points in a grid and returns the building with the minimum Manhattan distance to all other buildings. If there are multiple such points, return the one with the smallest coordinates (i.e., lowest x, then lowest y). >>> city_block_distance([(1, 2)]) (1, 2) >>> city_block_distance([(1, 2), (3, 4), (5, 6)]) (3, 4) >>> city_block_distance([(1, 1), (2, 2), (3, 3)]) (2, 2) >>> city_block_distance([(2, 1), (2, 3), (2, 2)]) (2, 2) >>> city_block_distance([(1, 2), (3, 2), (2, 2)]) (2, 2) >>> city_block_distance([(i, i) for i in range(1, 1001)]) (500, 500) >>> city_block_distance([(0, 0), (1000000, 1000000), (500000, 500000)]) (500000, 500000) pass","solution":"def city_block_distance(buildings): Return the building with the minimum Manhattan distance to all other buildings. If there are multiple such points, return the one with lowest x, then lowest y. # Calculating the median for both x and y coordinates x_coords = sorted(x for x, y in buildings) y_coords = sorted(y for x, y in buildings) # Median will give us the optimal coordinate minimizing Manhattan distance median_x = x_coords[(len(x_coords) - 1) // 2] median_y = y_coords[(len(y_coords) - 1) // 2] return (median_x, median_y)"},{"question":"def rotate_matrix(matrix): Rotates the given N x N matrix 90 degrees clockwise. >>> rotate_matrix([]) == [] >>> rotate_matrix([[1]]) == [[1]] >>> rotate_matrix([[1, 2], [3, 4]]) == [[3, 1], [4, 2]] >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) == [ ... [13, 9, 5, 1], ... [14, 10, 6, 2], ... [15, 11, 7, 3], ... [16, 12, 8, 4] ... ]","solution":"def rotate_matrix(matrix): Rotates the given N x N matrix 90 degrees clockwise. if not matrix or not any(matrix): return matrix N = len(matrix) result = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): result[j][N - 1 - i] = matrix[i][j] return result"},{"question":"def reverse_words(s: str) -> str: Reverses the characters in each word of the string s while preserving whitespace and initial word order. >>> reverse_words(\\"Let's take LeetCode contest\\") \\"s'teL ekat edoCteeL tsetnoc\\" >>> reverse_words(\\"God Ding\\") \\"doG gniD\\"","solution":"def reverse_words(s): Reverses the characters in each word of the string s while preserving whitespace and initial word order. Parameters: s (str): The input string. Returns: str: The string with each word's characters reversed. return ' '.join(word[::-1] for word in s.split())"},{"question":"import numpy as np import matplotlib.pyplot as plt import random def run_simulation(n: int, p: float, q: float, t: int) -> None: Simulate the spread of an infection in a grid-like city using the SIR model. Parameters: n (int): The size of the grid (n x n). p (float): The probability of infecting a neighboring cell. q (float): The probability of an infected cell recovering. t (int): The number of simulation steps. The function will plot the number of Susceptible, Infected, and Recovered cells over time. pass # Sample test cases if __name__ == \\"__main__\\": n = 20 # Grid size p = 0.3 # Infection probability q = 0.1 # Recovery probability t = 100 # Number of steps run_simulation(n, p, q, t)","solution":"import numpy as np import matplotlib.pyplot as plt import random def run_simulation(n: int, p: float, q: float, t: int) -> None: # Define states SUSCEPTIBLE, INFECTED, RECOVERED = 0, 1, 2 # Initialize the grid grid = np.zeros((n, n), dtype=int) # Randomly infect one cell initial_infected = (random.randint(0, n-1), random.randint(0, n-1)) grid[initial_infected] = INFECTED # Arrays to store the counts of S, I, R at each time step susceptible_counts = [] infected_counts = [] recovered_counts = [] for step in range(t): new_grid = grid.copy() for i in range(n): for j in range(n): if grid[i, j] == INFECTED: if random.random() < q: new_grid[i, j] = RECOVERED else: # Try to infect neighbors for di, dj in [(-1,0), (1,0), (0,-1), (0,1)]: ni, nj = i + di, j + dj if 0 <= ni < n and 0 <= nj < n and grid[ni, nj] == SUSCEPTIBLE: if random.random() < p: new_grid[ni, nj] = INFECTED grid = new_grid # Store counts of each state unique, counts = np.unique(grid, return_counts=True) count_dict = dict(zip(unique, counts)) susceptible_counts.append(count_dict.get(SUSCEPTIBLE, 0)) infected_counts.append(count_dict.get(INFECTED, 0)) recovered_counts.append(count_dict.get(RECOVERED, 0)) # Plotting the results plt.figure(figsize=(10, 6)) plt.plot(susceptible_counts, label='Susceptible') plt.plot(infected_counts, label='Infected') plt.plot(recovered_counts, label='Recovered') plt.xlabel('Time steps') plt.ylabel('Count of cells') plt.title('SIR Model Simulation') plt.legend() plt.grid(True) plt.show()"},{"question":"def count_vowels(input_string: str) -> dict: Returns a dictionary with the count of each vowel (a, e, i, o, u) present in the input string. >>> count_vowels(\\"hello world\\") {'a': 0, 'e': 1, 'i': 0, 'o': 2, 'u': 0} >>> count_vowels(\\"aeiou\\") {'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1} >>> count_vowels(\\"bcdfghjklmnpqrstvwxyz\\") {'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0} >>> count_vowels(\\"HeLLo WoRLd\\") {'a': 0, 'e': 1, 'i': 0, 'o': 2, 'u': 0} >>> count_vowels(\\"\\") {'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0} >>> count_vowels(\\"aaeeiioouu\\") {'a': 2, 'e': 2, 'i': 2, 'o': 2, 'u': 2} # Implementation goes here","solution":"def count_vowels(input_string): Returns a dictionary with the count of each vowel (a, e, i, o, u) present in the input string. vowels = 'aeiou' vowel_count = {vowel: 0 for vowel in vowels} for char in input_string.lower(): if char in vowel_count: vowel_count[char] += 1 return vowel_count"},{"question":"def group_and_sort_contiguous_integers(lst: List[int], reverse: bool = False) -> List[List[int]]: Groups a list of integers into contiguous sublists where the difference between adjacent numbers is 1, and returns these sublists sorted in ascending or descending order. Parameters: lst (list): A list of integers. reverse (bool): If True, sort the sublists and the list of sublists in descending order. Returns: list: List of sorted contiguous sublists. >>> group_and_sort_contiguous_integers([1, 2, 4, 5, 6, 8, 9, 10, 12]) [[1, 2], [4, 5, 6], [8, 9, 10], [12]] >>> group_and_sort_contiguous_integers([5, 1, 10, 2, 4, 9, 8, 6, 12], reverse=True) [[12], [10, 9, 8], [6, 5, 4], [2, 1]] Unit Test: from solution import group_and_sort_contiguous_integers def test_group_and_sort_contiguous_integers(): assert group_and_sort_contiguous_integers([1, 2, 4, 5, 6, 8, 9, 10, 12]) == [[1, 2], [4, 5, 6], [8, 9, 10], [12]] assert group_and_sort_contiguous_integers([5, 1, 10, 2, 4, 9, 8, 6, 12], reverse=True) == [[12], [10, 9, 8], [6, 5, 4], [2, 1]] assert group_and_sort_contiguous_integers([]) == [] assert group_and_sort_contiguous_integers([3, 3, 3, 3, 3]) == [[3], [3], [3], [3], [3]] assert group_and_sort_contiguous_integers([10, 9, 8, 7, 1, 2, 4, 5, -1, -2, -3]) == [[-3, -2, -1], [1, 2], [4, 5], [7, 8, 9, 10]] assert group_and_sort_contiguous_integers([1]) == [[1]] assert group_and_sort_contiguous_integers([1, 3, 5, 7], reverse=True) == [[7], [5], [3], [1]] # Run the tests def run_tests(): test_group_and_sort_contiguous_integers() print(\\"All tests passed!\\") run_tests()","solution":"def group_and_sort_contiguous_integers(lst, reverse=False): Groups a list of integers into contiguous sublists where the difference between adjacent numbers is 1, and returns these sublists sorted in ascending or descending order. Parameters: lst (list): A list of integers. reverse (bool): If True, sort the sublists and the list of sublists in descending order. Returns: list: List of sorted contiguous sublists. if not lst: return [] # Sort the input list lst.sort() result = [] current_sublist = [lst[0]] for i in range(1, len(lst)): if lst[i] == lst[i - 1] + 1: current_sublist.append(lst[i]) else: result.append(current_sublist) current_sublist = [lst[i]] result.append(current_sublist) # Sort the sublists and the list of sublists result = sorted(result, key=lambda sublist: sublist[0], reverse=reverse) for sublist in result: sublist.sort(reverse=reverse) return result"},{"question":"def filter_people_by_age(people: List[Dict[str, Any]], age_threshold: int) -> List[Dict[str, int]]: Filters a list of dictionaries to only include people older than a given age. Args: people (list): A list of dictionaries with 'name', 'age', and 'city' keys. age_threshold (int): The age threshold to filter people. Returns: list: A new list of dictionaries containing only 'name' and 'age' of people older than the given age. >>> people = [ ... {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, ... {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"Los Angeles\\"}, ... {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Chicago\\"} ... ] >>> age_threshold = 28 >>> filter_people_by_age(people, age_threshold) [{'name': 'Alice', 'age': 30}, {'name': 'Charlie', 'age': 35}] pass from typing import List, Dict, Any def test_filter_people_by_age_all_above_threshold(): people = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"Los Angeles\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Chicago\\"} ] age_threshold = 20 expected = [ {\\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"name\\": \\"Bob\\", \\"age\\": 25}, {\\"name\\": \\"Charlie\\", \\"age\\": 35} ] assert filter_people_by_age(people, age_threshold) == expected def test_filter_people_by_age_some_above_threshold(): people = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"Los Angeles\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Chicago\\"} ] age_threshold = 28 expected = [ {\\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"name\\": \\"Charlie\\", \\"age\\": 35} ] assert filter_people_by_age(people, age_threshold) == expected def test_filter_people_by_age_none_above_threshold(): people = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"Los Angeles\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Chicago\\"} ] age_threshold = 40 expected = [] assert filter_people_by_age(people, age_threshold) == expected def test_filter_people_by_age_empty_list(): people = [] age_threshold = 25 expected = [] assert filter_people_by_age(people, age_threshold) == expected def test_filter_people_by_age_exact_threshold(): people = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"Los Angeles\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Chicago\\"} ] age_threshold = 30 expected = [ {\\"name\\": \\"Charlie\\", \\"age\\": 35} ] assert filter_people_by_age(people, age_threshold) == expected","solution":"def filter_people_by_age(people, age_threshold): Filters a list of dictionaries to only include people older than a given age. Args: people (list): A list of dictionaries with 'name', 'age', and 'city' keys. age_threshold (int): The age threshold to filter people. Returns: list: A new list of dictionaries containing only 'name' and 'age' of people older than the given age. return [{\\"name\\": person[\\"name\\"], \\"age\\": person[\\"age\\"]} for person in people if person[\\"age\\"] > age_threshold]"},{"question":"def max_subarray(nums: List[int]) -> List[int]: Returns the longest contiguous subarray with the largest possible sum. The function should account for edge cases, such as when the input list is empty. >>> max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == [4, -1, 2, 1] >>> max_subarray([1, 2, 3, 4]) == [1, 2, 3, 4] >>> max_subarray([-4, -3, -2, -1]) == [-1] >>> max_subarray([5]) == [5] >>> max_subarray([]) == [] >>> max_subarray([1, -2, 3, 4, -1, 2, 1, -5, 4, -1, 6]) == [3, 4, -1, 2, 1, -5, 4, -1, 6] >>> max_subarray([1, 2, 3, -2, 5, -1, 6, -3]) == [1, 2, 3, -2, 5, -1, 6]","solution":"def max_subarray(nums): Returns the longest contiguous subarray with the largest sum. Uses Kadane's Algorithm to find the maximum sum contiguous subarray. if not nums: return [] current_sum = max_sum = nums[0] start = end = s = 0 for i in range(1, len(nums)): if nums[i] > current_sum + nums[i]: current_sum = nums[i] s = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start = s end = i return nums[start:end + 1]"},{"question":"import pandas as pd from sklearn.datasets import fetch_20newsgroups from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.naive_bayes import MultinomialNB from sklearn.pipeline import make_pipeline from sklearn.model_selection import train_test_split from sklearn import metrics def classify_document(doc: str) -> int: Classifies a given document based on the trained model. # Pretrained model should be used for classification pass def get_category_name(index: int) -> str: Gets the category name corresponding to the index. pass # Fetching the dataset categories = ['rec.sport.baseball', 'sci.med', 'rec.motorcycles'] # Simplified for this task data = fetch_20newsgroups(subset='train', categories=categories) # Splitting data into training and testing sets X_train, X_test, y_train, y_test = train_test_split(data.data, data.target, test_size=0.3, random_state=42) # Building the model pipeline model = make_pipeline(TfidfVectorizer(), MultinomialNB()) # Training the model model.fit(X_train, y_train) # Making predictions predicted = model.predict(X_test) # Model performance accuracy = metrics.accuracy_score(y_test, predicted) conf_matrix = metrics.confusion_matrix(y_test, predicted) # Displaying the model performance print(f\\"Accuracy: {accuracy}\\") print(f\\"Confusion Matrix:n{conf_matrix}\\") # Example usage: new_document = \\"The new cancer treatment showed promising results in the recent clinical trials.\\" predicted_category = classify_document(new_document) print(f\\"The document is classified as: {get_category_name(predicted_category)}\\")","solution":"import pandas as pd from sklearn.datasets import fetch_20newsgroups from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.naive_bayes import MultinomialNB from sklearn.pipeline import make_pipeline from sklearn.model_selection import train_test_split from sklearn import metrics # Fetching the dataset categories = ['rec.sport.baseball', 'sci.med', 'rec.motorcycles'] # Simplified for this task data = fetch_20newsgroups(subset='train', categories=categories) # Splitting data into training and testing sets X_train, X_test, y_train, y_test = train_test_split(data.data, data.target, test_size=0.3, random_state=42) # Building the model pipeline model = make_pipeline(TfidfVectorizer(), MultinomialNB()) # Training the model model.fit(X_train, y_train) # Making predictions predicted = model.predict(X_test) # Model performance accuracy = metrics.accuracy_score(y_test, predicted) conf_matrix = metrics.confusion_matrix(y_test, predicted) def classify_document(doc): Classifies a given document based on the trained model. return model.predict([doc])[0] def get_category_name(index): Gets the category name corresponding to the index. return data.target_names[index] # Displaying the model performance print(f\\"Accuracy: {accuracy}\\") print(f\\"Confusion Matrix:n{conf_matrix}\\") # Example usage: new_document = \\"The new cancer treatment showed promising results in the recent clinical trials.\\" predicted_category = classify_document(new_document) print(f\\"The document is classified as: {get_category_name(predicted_category)}\\")"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Perform an inorder traversal of the BST and collect values in a list. pass def sorted_list_to_bst(nums): Convert a sorted list to a balanced BST. pass def balance_bst(root): Balance a given BST. pass def print_inorder(root): Print the inorder traversal of the BST. pass def merge_two_bsts(root1, root2): Merge two BSTs into one balanced BST. pass Unit Test: from solution import TreeNode, balance_bst, print_inorder, merge_two_bsts def test_inorder_traversal(): root = TreeNode(3) root.left = TreeNode(1) root.right = TreeNode(4) root.left.right = TreeNode(2) assert inorder_traversal(root) == [1, 2, 3, 4] def test_sorted_list_to_bst(): nums = [1, 2, 3, 4, 5, 6, 7] bst_root = sorted_list_to_bst(nums) assert inorder_traversal(bst_root) == nums def test_balance_bst(): root = TreeNode(10) root.left = TreeNode(5) root.left.left = TreeNode(1) balanced_root = balance_bst(root) assert inorder_traversal(balanced_root) == [1, 5, 10] def test_merge_two_bsts(): root1 = TreeNode(3) root1.left = TreeNode(1) root1.right = TreeNode(4) root2 = TreeNode(5) root2.left = TreeNode(2) root2.right = TreeNode(6) merged_root = merge_two_bsts(root1, root2) assert inorder_traversal(merged_root) == [1, 2, 3, 4, 5, 6] def test_print_inorder(capfd): root = TreeNode(2) root.left = TreeNode(1) root.right = TreeNode(3) print_inorder(root) out, _ = capfd.readouterr() assert out == \\"1 2 3n\\"","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Perform an inorder traversal of the BST and collect values in a list. if root is None: return [] return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) def sorted_list_to_bst(nums): Convert a sorted list to a balanced BST. if not nums: return None mid = len(nums) // 2 node = TreeNode(nums[mid]) node.left = sorted_list_to_bst(nums[:mid]) node.right = sorted_list_to_bst(nums[mid+1:]) return node def balance_bst(root): Balance a given BST. elements = inorder_traversal(root) return sorted_list_to_bst(elements) def print_inorder(root): Print the inorder traversal of the BST. elements = inorder_traversal(root) print(\\" \\".join(map(str, elements))) def merge_two_bsts(root1, root2): Merge two BSTs into one balanced BST. elements1 = inorder_traversal(root1) elements2 = inorder_traversal(root2) merged_elements = sorted(elements1 + elements2) return sorted_list_to_bst(merged_elements)"},{"question":"def segregate_data_types(input_list): Segregates integers, strings, and floats from the input_list into separate lists. Returns a dictionary with keys 'integers', 'strings', and 'floats'. >>> segregate_data_types([1, 'hello', 3.5, 4, 'world', 2.718]) {'integers': [1, 4], 'strings': ['hello', 'world'], 'floats': [3.5, 2.718]} >>> segregate_data_types([]) {'integers': [], 'strings': [], 'floats': []} >>> segregate_data_types([1, 2, 3]) {'integers': [1, 2, 3], 'strings': [], 'floats': []} >>> segregate_data_types(['a', 'b', 'c']) {'integers': [], 'strings': ['a', 'b', 'c'], 'floats': []} >>> segregate_data_types([1.1, 2.2, 3.3]) {'integers': [], 'strings': [], 'floats': [1.1, 2.2, 3.3]} >>> segregate_data_types([1, 'a', 2.2, 'b', 3]) {'integers': [1, 3], 'strings': ['a', 'b'], 'floats': [2.2]} >>> segregate_data_types([1, 'string', 3.14, {'key': 'value'}]) Traceback (most recent call last): ... ValueError: Unsupported data type: <class 'dict'> pass","solution":"def segregate_data_types(input_list): Segregates integers, strings, and floats from the input_list into separate lists. Returns a dictionary with keys 'integers', 'strings', and 'floats'. result = { 'integers': [], 'strings': [], 'floats': [] } for item in input_list: if isinstance(item, int): result['integers'].append(item) elif isinstance(item, float): result['floats'].append(item) elif isinstance(item, str): result['strings'].append(item) else: raise ValueError(f\\"Unsupported data type: {type(item)}\\") return result"},{"question":"def reverse_words_order(s: str) -> str: Reverses the order of words in the input string while preserving the order of characters within the words. Parameters: s (str): Input string Returns: str: The string with the order of words reversed Examples: >>> reverse_words_order(\\"hello\\") 'hello' >>> reverse_words_order(\\"hello world\\") 'world hello' >>> reverse_words_order(\\"The quick brown fox\\") 'fox brown quick The' >>> reverse_words_order(\\"\\") '' >>> reverse_words_order(\\" hello world \\") 'world hello' >>> reverse_words_order(\\"hello, world!\\") 'world! hello,' >>> original = \\"The quick brown fox\\" >>> reverse_words_order(reverse_words_order(original)) == original True","solution":"def reverse_words_order(s): Reverses the order of words in the input string while preserving the order of characters within the words. Parameters: s (str): Input string Returns: str: The string with the order of words reversed words = s.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"from typing import List, Union def sum_of_digits(n: int) -> int: Returns the sum of the digits of an integer n. >>> sum_of_digits(21) 3 >>> sum_of_digits(123) 6 pass def create_sum_list(int_list: List[int]) -> List[int]: Given a list of integers, returns a new list where each integer is replaced by the sum of its digits. >>> create_sum_list([7, 21, 123]) [7, 3, 6] >>> create_sum_list([1, 2, 3]) [1, 2, 3] pass def create_digit_sum_dict(int_list: List[int]) -> dict: Given a list of integers, returns a dictionary where each key is the original integer from the list and the value is the corresponding sum of its digits. >>> create_digit_sum_dict([7, 21, 123]) {7: 7, 21: 3, 123: 6} >>> create_digit_sum_dict([4, 5, 6]) {4: 4, 5: 5, 6: 6} pass def highest_digit_sum_in_list(int_list: List[Union[int, str]]) -> Union[List[int], str]: Returns the integer(s) from the original list that has the highest sum of its digits. In case of a tie, returns all such integers. Includes error handling for an empty list and non-integer elements. >>> highest_digit_sum_in_list([7, 21, 123]) [7] >>> highest_digit_sum_in_list([4, 5, 6]) [6] >>> highest_digit_sum_in_list([18, 81]) [18, 81] >>> highest_digit_sum_in_list([]) \\"Error: Empty list\\" >>> highest_digit_sum_in_list([4, 5, 'six']) \\"Error: List contains non-integer elements\\" pass original_list = [7, 2, 9, 21, 4, 6, 1, 3]","solution":"def sum_of_digits(n): Returns the sum of the digits of an integer n. return sum(int(digit) for digit in str(n)) def create_sum_list(int_list): Given a list of integers, returns a new list where each integer is replaced by the sum of its digits. return [sum_of_digits(x) for x in int_list] def create_digit_sum_dict(int_list): Given a list of integers, returns a dictionary where each key is the original integer from the list and the value is the corresponding sum of its digits. return {x: sum_of_digits(x) for x in int_list} def highest_digit_sum_in_list(int_list): Returns the integer(s) from the original list that has the highest sum of its digits. In case of a tie, returns all such integers. Includes error handling for an empty list and non-integer elements. if not int_list: return \\"Error: Empty list\\" if any(not isinstance(x, int) for x in int_list): return \\"Error: List contains non-integer elements\\" digit_sum_dict = create_digit_sum_dict(int_list) max_sum = max(digit_sum_dict.values()) return [key for key, value in digit_sum_dict.items() if value == max_sum] original_list = [7, 2, 9, 21, 4, 6, 1, 3]"},{"question":"class Polynomial: A class to represent a polynomial in one variable. Attributes: coefficients (list): Coefficients of the polynomial, where the index represents the power of the variable. Methods: __add__(self, other): Adds two polynomials. __sub__(self, other): Subtracts one polynomial from another. __mul__(self, other): Multiplies two polynomials. evaluate(self, x): Evaluates the polynomial at a given value of x. __str__(self): Returns a string representation of the polynomial. def __init__(self, coefficients): self.coefficients = coefficients def __add__(self, other): Your code for addition here def __sub__(self, other): Your code for subtraction here def __mul__(self, other): Your code for multiplication here def evaluate(self, x): Your code for evaluation here def __str__(self): Your code for string representation here # Demonstration if __name__ == \\"__main__\\": p1 = Polynomial([1, 2, 3]) p2 = Polynomial([0, -1, 4]) p3 = p1 + p2 p4 = p1 - p2 p5 = p1 * p2 val_p1 = p1.evaluate(2) val_p2 = p2.evaluate(2) print(f\\"p1: {p1}\\") print(f\\"p2: {p2}\\") print(f\\"p1 + p2: {p3}\\") print(f\\"p1 - p2: {p4}\\") print(f\\"p1 * p2: {p5}\\") print(f\\"p1 evaluated at x=2: {val_p1}\\") print(f\\"p2 evaluated at x=2: {val_p2}\\")","solution":"class Polynomial: def __init__(self, coefficients): self.coefficients = coefficients def __add__(self, other): max_len = max(len(self.coefficients), len(other.coefficients)) result = [0] * max_len for i in range(max_len): if i < len(self.coefficients): result[i] += self.coefficients[i] if i < len(other.coefficients): result[i] += other.coefficients[i] return Polynomial(result) def __sub__(self, other): max_len = max(len(self.coefficients), len(other.coefficients)) result = [0] * max_len for i in range(max_len): if i < len(self.coefficients): result[i] += self.coefficients[i] if i < len(other.coefficients): result[i] -= other.coefficients[i] return Polynomial(result) def __mul__(self, other): result = [0] * (len(self.coefficients) + len(other.coefficients) - 1) for i in range(len(self.coefficients)): for j in range(len(other.coefficients)): result[i + j] += self.coefficients[i] * other.coefficients[j] return Polynomial(result) def evaluate(self, x): result = 0 power = 1 for coefficient in self.coefficients: result += coefficient * power power *= x return result def __str__(self): terms = [] for power, coefficient in enumerate(self.coefficients): if coefficient != 0: if power == 0: terms.append(f\\"{coefficient}\\") elif power == 1: terms.append(f\\"{coefficient}x\\") else: terms.append(f\\"{coefficient}x^{power}\\") return \\" + \\".join(terms) # Demonstration p1 = Polynomial([1, 2, 3]) p2 = Polynomial([0, -1, 4]) p3 = p1 + p2 p4 = p1 - p2 p5 = p1 * p2 val_p1 = p1.evaluate(2) val_p2 = p2.evaluate(2) print(f\\"p1: {p1}\\") print(f\\"p2: {p2}\\") print(f\\"p1 + p2: {p3}\\") print(f\\"p1 - p2: {p4}\\") print(f\\"p1 * p2: {p5}\\") print(f\\"p1 evaluated at x=2: {val_p1}\\") print(f\\"p2 evaluated at x=2: {val_p2}\\")"},{"question":"from typing import List def merge_and_sort_odd_numbers(list1: List[int], list2: List[int]) -> List[int]: This function takes two lists of integers, list1 and list2, as input and returns a single list consisting of all the odd numbers from both lists, sorted in ascending order. If there are no odd numbers in both lists, the function should return an empty list. >>> merge_and_sort_odd_numbers([10, 3, 5], [6, 7, 1]) [1, 3, 5, 7] >>> merge_and_sort_odd_numbers([4, 2, 8], [12, 14]) [] >>> merge_and_sort_odd_numbers([9, 13, 15], [3, 19, 11]) [3, 9, 11, 13, 15, 19] def test_merge_and_sort_odd_numbers_example_cases(): assert merge_and_sort_odd_numbers([10, 3, 5], [6, 7, 1]) == [1, 3, 5, 7] assert merge_and_sort_odd_numbers([4, 2, 8], [12, 14]) == [] assert merge_and_sort_odd_numbers([9, 13, 15], [3, 19, 11]) == [3, 9, 11, 13, 15, 19] def test_merge_and_sort_odd_numbers_empty_lists(): assert merge_and_sort_odd_numbers([], []) == [] assert merge_and_sort_odd_numbers([1, 3, 5], []) == [1, 3, 5] assert merge_and_sort_odd_numbers([], [2, 4, 6, 7]) == [7] def test_merge_and_sort_odd_numbers_no_odds(): assert merge_and_sort_odd_numbers([2, 4, 6, 8], [10, 12, 14]) == [] def test_merge_and_sort_odd_numbers_same_list(): assert merge_and_sort_odd_numbers([3, 3, 3], [3, 3, 3]) == [3, 3, 3, 3, 3, 3] def test_merge_and_sort_odd_numbers_mixed(): assert merge_and_sort_odd_numbers([-1, -3, -4, 0], [1, 2, 3, 4]) == [-3, -1, 1, 3]","solution":"def merge_and_sort_odd_numbers(list1, list2): This function takes two lists of integers, list1 and list2, as input and returns a single list consisting of all the odd numbers from both lists, sorted in ascending order. If there are no odd numbers in both lists, the function should return an empty list. # Combine the two lists combined_list = list1 + list2 # Filter out the odd numbers odd_numbers = [num for num in combined_list if num % 2 != 0] # Sort the odd numbers in ascending order odd_numbers.sort() return odd_numbers"},{"question":"class InventoryItem: Represents an item in the warehouse inventory. def __init__(self, item_id, name, quantity, price): self.item_id = item_id self.name = name self.quantity = quantity self.price = price class WarehouseInventory: Class to manage the warehouse inventory. def __init__(self): self.inventory = [] def add_item(self, item_id, name, quantity, price): Add a new item to the inventory. Ensure that 'item_id' is unique and handle the case where an item with the same 'item_id' already exists. def remove_item(self, item_id): Remove an item from the inventory based on 'item_id'. Handle the case where the 'item_id' does not exist. def update_item(self, item_id, quantity, price): Update the quantity and price of an existing item based on 'item_id'. Handle the case where the 'item_id' does not exist. def search_item(self, **kwargs): Search for an item based on 'item_id' or 'name'. Return all matching items.","solution":"class InventoryItem: def __init__(self, item_id, name, quantity, price): self.item_id = item_id self.name = name self.quantity = quantity self.price = price class WarehouseInventory: def __init__(self): self.inventory = [] def add_item(self, item_id, name, quantity, price): for item in self.inventory: if item.item_id == item_id: return \\"Error: Item with this ID already exists.\\" new_item = InventoryItem(item_id, name, quantity, price) self.inventory.append(new_item) return \\"Item added successfully.\\" def remove_item(self, item_id): for item in self.inventory: if item.item_id == item_id: self.inventory.remove(item) return \\"Item removed successfully.\\" return \\"Error: Item ID does not exist.\\" def update_item(self, item_id, quantity, price): for item in self.inventory: if item.item_id == item_id: item.quantity = quantity item.price = price return \\"Item updated successfully.\\" return \\"Error: Item ID does not exist.\\" def search_item(self, **kwargs): search_results = [] for item in self.inventory: for key, value in kwargs.items(): if hasattr(item, key) and getattr(item, key) == value: search_results.append(item) return search_results"},{"question":"def longest_palindromic_subarray(arr): Find the longest contiguous subarray within the given list that forms a number palindrome. >>> longest_palindromic_subarray([1, 2, 3, 2, 1, 4, 5, 4, 6]) == [1, 2, 3, 2, 1] >>> longest_palindromic_subarray([7, 3, 9, 3, 7, 4, 3, 6, 3]) == [7, 3, 9, 3, 7] >>> longest_palindromic_subarray([5]) == [5] >>> longest_palindromic_subarray([1, 2, 3, 4]) == [1] >>> longest_palindromic_subarray([1, 2, 3, 2, 1]) == [1, 2, 3, 2, 1] >>> longest_palindromic_subarray([1, 2, 2, 1, 3, 4, 4, 3]) == [1, 2, 2, 1] >>> longest_palindromic_subarray([9, 1, 2, 3, 2, 1, 8]) == [1, 2, 3, 2, 1] >>> longest_palindromic_subarray([5, 6, 7, 8, 8, 7, 6, 1, 2, 3]) == [6, 7, 8, 8, 7, 6] >>> longest_palindromic_subarray([10**9, 10**6, 10**9]) == [10**9, 10**6, 10**9] >>> input_list = list(range(1, 1000)) + list(range(999, 0, -1)) >>> expected_output = list(range(1, 1000)) + list(range(999, 0, -1)) >>> longest_palindromic_subarray(input_list) == expected_output # Your code here","solution":"def longest_palindromic_subarray(arr): def is_palindrome(subarray): return subarray == subarray[::-1] n = len(arr) if n == 1: return arr max_length = 1 start = 0 for i in range(n): for j in range(i, n): subarray = arr[i:j+1] if is_palindrome(subarray) and len(subarray) > max_length: start = i max_length = len(subarray) return arr[start:start + max_length]"},{"question":"from typing import List, Dict, Union def weather_summary(data: List[Dict[str, Union[str, float, int]]]) -> Dict[str, Union[float, str]]: Process a list of JSON objects representing weather data for the past week. Each JSON object includes 'date', 'temperature', 'humidity', and 'wind_speed'. Returns a summary of the weather data, including: - average temperature over the week (rounded to two decimal places), - the date with the highest humidity, - total wind speed over the week. Parameters: data (List[Dict[str, Union[str, float, int]]]): The list of JSON objects. Returns: Dict[str, Union[float, str]]: A dictionary containing the summary of the weather data. Example: >>> data = [ ... {\\"date\\": \\"2023-01-01\\", \\"temperature\\": 10.5, \\"humidity\\": 80, \\"wind_speed\\": 5.5}, ... {\\"date\\": \\"2023-01-02\\", \\"temperature\\": 12.3, \\"humidity\\": 78, \\"wind_speed\\": 6.1}, ... {\\"date\\": \\"2023-01-03\\", \\"temperature\\": 8.8, \\"humidity\\": 82, \\"wind_speed\\": 4.0}, ... {\\"date\\": \\"2023-01-04\\", \\"temperature\\": 7.5, \\"humidity\\": 85, \\"wind_speed\\": 3.8}, ... {\\"date\\": \\"2023-01-05\\", \\"temperature\\": 9.0, \\"humidity\\": 80, \\"wind_speed\\": 4.5}, ... {\\"date\\": \\"2023-01-06\\", \\"temperature\\": 11.2, \\"humidity\\": 79, \\"wind_speed\\": 5.2}, ... {\\"date\\": \\"2023-01-07\\", \\"temperature\\": 10.0, \\"humidity\\": 81, \\"wind_speed\\": 5.0} ... ] >>> weather_summary(data) { 'average_temperature': 9.90, 'highest_humidity_day': '2023-01-04', 'total_wind_speed': 34.1 }","solution":"from typing import List, Dict, Union def weather_summary(data: List[Dict[str, Union[str, float, int]]]) -> Dict[str, Union[float, str]]: total_temperature = 0.0 total_wind_speed = 0.0 highest_humidity = -1 highest_humidity_day = \\"\\" for entry in data: # Sum temperatures total_temperature += entry[\\"temperature\\"] # Sum wind speeds total_wind_speed += entry[\\"wind_speed\\"] # Check for highest humidity if entry[\\"humidity\\"] > highest_humidity: highest_humidity = entry[\\"humidity\\"] highest_humidity_day = entry[\\"date\\"] # Calculate average temperature average_temperature = round(total_temperature / len(data), 2) return { 'average_temperature': average_temperature, 'highest_humidity_day': highest_humidity_day, 'total_wind_speed': round(total_wind_speed, 1) }"},{"question":"influencer.py class Influencer: def __init__(self, name: str, platform: str, followers: int, engagement_rate: float, category: str): self.name = name self.platform = platform self.followers = followers self.engagement_rate = engagement_rate self.category = category def get_data(self) -> dict: Returns a dictionary containing the influencer's data. pass compare.py class Compare: def __init__(self, influencers: list): self.influencers = influencers def compare_influencers(self) -> dict: Compares multiple influencers based on their metrics. Returns a dictionary with influencer names as keys and their metrics as values. >>> influencer1 = Influencer(\\"Alice\\", \\"Instagram\\", 10000, 5.4, \\"Fashion\\") >>> influencer2 = Influencer(\\"Bob\\", \\"YouTube\\", 20000, 4.9, \\"Tech\\") >>> compare = Compare([influencer1, influencer2]) >>> compare.compare_influencers() { \\"Alice\\": { \\"platform\\": \\"Instagram\\", \\"followers\\": 10000, \\"engagement_rate\\": 5.4, \\"category\\": \\"Fashion\\" }, \\"Bob\\": { \\"platform\\": \\"YouTube\\", \\"followers\\": 20000, \\"engagement_rate\\": 4.9, \\"category\\": \\"Tech\\" } } pass","solution":"influencer.py class Influencer: def __init__(self, name: str, platform: str, followers: int, engagement_rate: float, category: str): self.name = name self.platform = platform self.followers = followers self.engagement_rate = engagement_rate self.category = category def get_data(self) -> dict: return { \\"name\\": self.name, \\"platform\\": self.platform, \\"followers\\": self.followers, \\"engagement_rate\\": self.engagement_rate, \\"category\\": self.category } compare.py class Compare: def __init__(self, influencers: list): self.influencers = influencers def compare_influencers(self) -> dict: comparison_result = {} for influencer in self.influencers: data = influencer.get_data() name = data.pop('name') comparison_result[name] = data return comparison_result"},{"question":"def count_frequencies(numbers: List[int]) -> Tuple[Dict[int, int], int]: Given a list of integers, returns a dictionary with keys as unique integers and values as the count of each integer. Also returns the integer that appears the most frequently (smallest one in case of a tie). Parameters: numbers (list): List of integers Returns: tuple: A dictionary with frequencies and the most frequently appearing integer >>> count_frequencies([1]) ({1: 1}, 1) >>> count_frequencies([1, 2, 3, 4]) ({1: 1, 2: 1, 3: 1, 4: 1}, 1) >>> count_frequencies([1, 2, 2, 3, 3, 3, 4]) ({1: 1, 2: 2, 3: 3, 4: 1}, 3) >>> count_frequencies([1, 1, 2, 2, 3, 3]) ({1: 2, 2: 2, 3: 2}, 1) >>> count_frequencies([-1, -1, -2, -2, -3, -3]) ({-1: 2, -2: 2, -3: 2}, -3) >>> large_input = [i for i in range(1000)] + [0]*1000 >>> expected_dict = {i: 1 for i in range(1000)} >>> expected_dict[0] = 1001 >>> count_frequencies(large_input) == (expected_dict, 0) True pass","solution":"def count_frequencies(numbers): Given a list of integers, returns a dictionary with keys as unique integers and values as the count of each integer. Also returns the integer that appears the most frequently (smallest one in case of a tie). Parameters: numbers (list): List of integers Returns: tuple: A dictionary with frequencies and the most frequently appearing integer from collections import defaultdict frequency_dict = defaultdict(int) for num in numbers: frequency_dict[num] += 1 most_frequent_num = min(frequency_dict, key=lambda x: (-frequency_dict[x], x)) return dict(frequency_dict), most_frequent_num"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Checks if two strings are anagrams of each other. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"hello\\", \\"billion\\") False >>> are_anagrams(\\"anagram\\", \\"nagaram\\") True >>> are_anagrams(\\"rat\\", \\"car\\") False","solution":"def are_anagrams(str1: str, str2: str) -> bool: Checks if two strings are anagrams of each other. :param str1: First string. :param str2: Second string. :return: True if str1 and str2 are anagrams, False otherwise. # If the lengths of the two strings are not equal, they cannot be anagrams. if len(str1) != len(str2): return False # Create frequency dictionaries for both strings. freq1 = {} freq2 = {} # Count the frequency of each character in both strings. for char in str1: freq1[char] = freq1.get(char, 0) + 1 for char in str2: freq2[char] = freq2.get(char, 0) + 1 # Compare the frequency dictionaries. return freq1 == freq2"},{"question":"def palindromic_substrings(s: str) -> List[str]: Identifies all unique palindromic substrings in the given string s. :param s: Input string to search for palindromic substrings. :return: A list of unique palindromic substrings. >>> palindromic_substrings(\\"\\") [] >>> palindromic_substrings(\\"a\\") [\\"a\\"] >>> palindromic_substrings(\\"abc\\") in [[\\"a\\", \\"b\\", \\"c\\"], [\\"a\\", \\"c\\", \\"b\\"], [\\"b\\", \\"a\\", \\"c\\"], [\\"b\\", \\"c\\", \\"a\\"], [\\"c\\", \\"a\\", \\"b\\"], [\\"c\\", \\"b\\", \\"a\\"]] True >>> sorted(palindromic_substrings(\\"aaa\\")) sorted([\\"a\\", \\"aa\\", \\"aaa\\"]) >>> sorted(palindromic_substrings(\\"ababa\\")) sorted([\\"a\\", \\"b\\", \\"aba\\", \\"bab\\", \\"ababa\\"]) >>> result = palindromic_substrings(\\"racecar\\") >>> expected = [\\"r\\", \\"a\\", \\"c\\", \\"e\\", \\"cec\\", \\"aceca\\", \\"racecar\\"] >>> sorted(result) == sorted(expected) True","solution":"def palindromic_substrings(s): Identifies all unique palindromic substrings in the given string s. :param s: Input string to search for palindromic substrings. :return: A list of unique palindromic substrings. def expand_around_center(s, left, right, seen): while left >= 0 and right < len(s) and s[left] == s[right]: palindromic = s[left:right+1] if palindromic not in seen: seen.add(palindromic) left -= 1 right += 1 seen = set() for i in range(len(s)): # Odd length palindromes expand_around_center(s, i, i, seen) # Even length palindromes expand_around_center(s, i, i + 1, seen) return list(seen)"},{"question":"class InsufficientDistinctElements(Exception): pass def second_largest(numbers: List[int]) -> int: Design a function that takes a list of integers and returns the second largest number in the list. If the list contains fewer than two distinct elements, raises an InsufficientDistinctElements exception. >>> second_largest([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == 6 >>> second_largest([10, 5, 5, 3, 3, 2, 2, 1]) == 5 >>> second_largest([10, 7]) == 7 >>> second_largest([5, 5, 5, 5]) raises InsufficientDistinctElements >>> second_largest([]) raises InsufficientDistinctElements >>> second_largest([42]) raises InsufficientDistinctElements","solution":"class InsufficientDistinctElements(Exception): pass def second_largest(numbers): Returns the second largest number in a list. If the list contains fewer than two distinct elements, raises an InsufficientDistinctElements exception. if not numbers or len(numbers) < 2: raise InsufficientDistinctElements(\\"The list must contain at least two distinct elements.\\") unique_numbers = list(set(numbers)) if len(unique_numbers) < 2: raise InsufficientDistinctElements(\\"The list must contain at least two distinct elements.\\") unique_numbers.sort(reverse=True) return unique_numbers[1]"},{"question":"def divide_numbers(x, y): Divide two numbers, handling division by zero and type errors. >>> divide_numbers(10, 2) 5 >>> divide_numbers(10, 0) \\"Cannot divide by zero\\" >>> divide_numbers(10, 'a') \\"Both arguments must be numbers\\" >>> divide_numbers('a', 2) \\"Both arguments must be numbers\\" >>> divide_numbers(10, 5) 2","solution":"def divide_numbers(x, y): try: result = x / y except ZeroDivisionError: return \\"Cannot divide by zero\\" except TypeError: return \\"Both arguments must be numbers\\" return result"},{"question":"def product_except_self(nums): Returns a list where each element at index i is the product of all the numbers in the original list except the number at index i. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([0, 0, 0, 0]) [0, 0, 0, 0] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([42]) [1] >>> product_except_self([3, 5]) [5, 3] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> product_except_self([-1, 0, -3, 4]) [0, 12, 0, 0]","solution":"def product_except_self(nums): Returns a list where each element at index i is the product of all the numbers in the original list except the number at index i. length = len(nums) # Initialize our two lists with 1s for product accumulation left_products = [1] * length right_products = [1] * length # Compute the products of all elements to the left of each element for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] # Compute the products of all elements to the right of each element for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # The result is the product of corresponding left and right products result = [left_products[i] * right_products[i] for i in range(length)] return result"},{"question":"import re from collections import Counter def are_anagrams(s1: str, s2: str) -> bool: Determine if a given string is an anagram of another string. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, using all the original letters exactly once. The function is case-insensitive and ignores spaces and punctuation. >>> are_anagrams(\\"Astronomer\\", \\"Moon starer\\") True >>> are_anagrams(\\"Hello\\", \\"Ollhe\\") True >>> are_anagrams(\\"Apple\\", \\"Pineapple\\") False","solution":"import re from collections import Counter def are_anagrams(s1, s2): Returns True if s1 and s2 are anagrams, otherwise False. The function is case-insensitive and ignores spaces and punctuation. s1_cleaned = re.sub(r'[^a-zA-Z0-9]', '', s1).lower() s2_cleaned = re.sub(r'[^a-zA-Z0-9]', '', s2).lower() return Counter(s1_cleaned) == Counter(s2_cleaned)"},{"question":"class Zoo: def __init__(self): self.animals = {} def add_animals(self, type_of_animal: str, count: int) -> None: Increases the number of type_of_animal in the zoo by count. If the type_of_animal does not already exist in the zoo, it should be added. >>> zoo = Zoo() >>> zoo.add_animals(\\"Lion\\", 5) >>> zoo.add_animals(\\"Lion\\", 2) >>> zoo.count_animals(\\"Lion\\") 7 pass def count_animals(self, type_of_animal: str) -> int: Returns the total number of type_of_animal currently in the zoo. If the type_of_animal does not exist in the zoo, it should return 0. >>> zoo = Zoo() >>> zoo.add_animals(\\"Tiger\\", 3) >>> zoo.count_animals(\\"Tiger\\") 3 >>> zoo.count_animals(\\"Lion\\") 0 pass import pytest from solution import Zoo def test_add_and_count_animals(): zoo = Zoo() zoo.add_animals(\\"Lion\\", 5) assert zoo.count_animals(\\"Lion\\") == 5 zoo.add_animals(\\"Tiger\\", 3) assert zoo.count_animals(\\"Tiger\\") == 3 zoo.add_animals(\\"Lion\\", 2) assert zoo.count_animals(\\"Lion\\") == 7 assert zoo.count_animals(\\"Bear\\") == 0 def test_add_zero_animals(): zoo = Zoo() zoo.add_animals(\\"Elephant\\", 0) assert zoo.count_animals(\\"Elephant\\") == 0 def test_large_number_of_animals(): zoo = Zoo() zoo.add_animals(\\"Giraffe\\", 10**6) assert zoo.count_animals(\\"Giraffe\\") == 10**6 def test_multiple_animal_types(): zoo = Zoo() zoo.add_animals(\\"Monkey\\", 10) zoo.add_animals(\\"Zebra\\", 20) zoo.add_animals(\\"Monkey\\", 5) assert zoo.count_animals(\\"Monkey\\") == 15 assert zoo.count_animals(\\"Zebra\\") == 20 assert zoo.count_animals(\\"Lion\\") == 0","solution":"class Zoo: def __init__(self): self.animals = {} def add_animals(self, type_of_animal: str, count: int) -> None: Increases the number of type_of_animal in the zoo by count. If the type_of_animal does not already exist in the zoo, it should be added. if type_of_animal in self.animals: self.animals[type_of_animal] += count else: self.animals[type_of_animal] = count def count_animals(self, type_of_animal: str) -> int: Returns the total number of type_of_animal currently in the zoo. If the type_of_animal does not exist in the zoo, it should return 0. return self.animals.get(type_of_animal, 0)"},{"question":"from typing import List def is_prime(num: int) -> bool: Helper function to check if a number is prime. pass def filter_primes(lst: List[int]) -> List[int]: Returns a list containing only the prime numbers from the input list. >>> filter_primes([4, 7, 12, 17, 23]) [7, 17, 23] >>> filter_primes([4, 6, 8, 10]) [] pass from solution import filter_primes def test_filter_primes_all_prime(): assert filter_primes([2, 3, 5, 7, 11]) == [2, 3, 5, 7, 11] def test_filter_primes_mixed(): assert filter_primes([4, 7, 12, 17, 23]) == [7, 17, 23] def test_filter_primes_no_prime(): assert filter_primes([4, 6, 8, 10]) == [] def test_filter_primes_with_negatives(): assert filter_primes([-1, -2, 2, 3, 4]) == [2, 3] def test_filter_primes_empty_list(): assert filter_primes([]) == [] def test_filter_primes_with_large_numbers(): assert filter_primes([29, 49, 97, 143, 199]) == [29, 97, 199]","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def filter_primes(lst): Returns a list containing only the prime numbers from the input list. return [x for x in lst if is_prime(x)]"},{"question":"def sum_of_squares(n: int) -> int: Computes the sum of the squares of all integers from 1 to n. Args: n (int): A non-negative integer Returns: int: The sum of the squares of all integers from 1 to n >>> sum_of_squares(0) 0 >>> sum_of_squares(1) 1 >>> sum_of_squares(5) 55 >>> sum_of_squares(10) 385 >>> sum_of_squares(100) 338350","solution":"def sum_of_squares(n): Returns the sum of the squares of all integers from 1 to n. return sum(i * i for i in range(1, n + 1))"},{"question":"def character_count(s: str) -> dict: Create a function that takes a string as input and returns a dictionary with the count of each character. The function is case-sensitive and includes punctuation marks and spaces in the character count. >>> character_count(\\"Hello, World!\\") {'H': 1, 'e': 1, 'l': 3, 'o': 2, ',': 1, ' ': 1, 'W': 1, 'r': 1, 'd': 1, '!': 1} >>> character_count(\\"\\") {} >>> character_count(\\"a\\") {'a': 1} >>> character_count(\\"AaBbCc\\") {'A': 1, 'a': 1, 'B': 1, 'b': 1, 'C': 1, 'c': 1}","solution":"def character_count(s): Returns a dictionary with the count of each character in the string s. The count is case-sensitive and includes punctuation marks and spaces. count_dict = {} for char in s: if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 return count_dict"},{"question":"def repetition_free_string(s: str) -> str: Transforms the input string into a repetition-free string by removing the fewest number of characters. If there are multiple solutions, it returns the lexicographically smallest one. Examples: >>> repetition_free_string(\\"aaaa\\") == \\"a\\" >>> repetition_free_string(\\"ababab\\") == \\"ababab\\" >>> repetition_free_string(\\"aabbcc\\") == \\"abc\\" >>> repetition_free_string(\\"aabac\\") == \\"abac\\" >>> repetition_free_string(\\"abc\\") == \\"abc\\" >>> repetition_free_string(\\"\\") == \\"\\" >>> repetition_free_string(\\"z\\") == \\"z\\" >>> repetition_free_string(\\"abbaaacddc\\") == \\"abacdc\\" >>> repetition_free_string(\\"abcdabcdab\\") == \\"abcdabcdab\\"","solution":"def repetition_free_string(s): Transforms the input string into a repetition-free string by removing the fewest number of characters. If there are multiple solutions, it returns the lexicographically smallest one. if not s: return \\"\\" result = [s[0]] # Start with the first character for char in s[1:]: if char != result[-1]: result.append(char) return \\"\\".join(result)"},{"question":"def reverse_string(s: str) -> str: Reverses the given string without using built-in reversal methods. Parameters: s (str): The string to be reversed. Returns: str: The reversed string. Examples: >>> reverse_string(\\"hello\\") 'olleh' >>> reverse_string(\\"\\") '' >>> reverse_string(\\"a\\") 'a' >>> reverse_string(\\"racecar\\") 'racecar' >>> reverse_string(\\"12345\\") '54321' >>> reverse_string(\\"!@#%^\\") '^%#@!' >>> reverse_string(\\"AbC123\\") '321CbA' reversed_str = '' for char in s: reversed_str = char + reversed_str return reversed_str","solution":"def reverse_string(s: str) -> str: Reverses the given string without using built-in reversal methods. Parameters: s (str): The string to be reversed. Returns: str: The reversed string. reversed_str = '' for char in s: reversed_str = char + reversed_str return reversed_str"},{"question":"def letter_case_permutation(s: str) -> List[str]: Write a function \`letter_case_permutation\` that takes in a string \`s\` and returns a list of all possible strings we can obtain by capitalizing or non-capitalizing each letter in the string \`s\`. The order of the output does not matter. >>> letter_case_permutation(\\"a1b2\\") [\\"a1b2\\", \\"A1b2\\", \\"a1B2\\", \\"A1B2\\"] >>> letter_case_permutation(\\"AB\\") [\\"ab\\", \\"Ab\\", \\"aB\\", \\"AB\\"]","solution":"def letter_case_permutation(s): Returns all possible strings by capitalizing or non-capitalizing each letter in the string \`s\`. def backtrack(sub=\\"\\", i=0): if i == len(s): permutations.append(sub) return if s[i].isalpha(): backtrack(sub + s[i].lower(), i + 1) backtrack(sub + s[i].upper(), i + 1) else: backtrack(sub + s[i], i + 1) permutations = [] backtrack() return permutations"},{"question":"def filter_and_sort_positive(numbers: List[int]) -> List[int]: Returns a list of positive numbers from the input list sorted in descending order. :param numbers: A list of integers. :return: A list containing only the positive integers sorted in descending order. >>> filter_and_sort_positive([3, -1, 0, 5, 9, -2]) [9, 5, 3] >>> filter_and_sort_positive([1, 2, 3, 4, 5]) [5, 4, 3, 2, 1] >>> filter_and_sort_positive([-3, -1, 0, -5, -9, 0]) [] >>> filter_and_sort_positive([]) [] >>> filter_and_sort_positive([3, 1, 1, 3, 2, 5, 5]) [5, 5, 3, 3, 2, 1, 1]","solution":"def filter_and_sort_positive(numbers): Returns a list of positive numbers from the input list sorted in descending order. :param numbers: A list of integers. :return: A list containing only the positive integers sorted in descending order. # Filter out non-positive integers positive_numbers = [num for num in numbers if num > 0] # Sort the positive numbers in descending order positive_numbers.sort(reverse=True) return positive_numbers # Example usage: # input_list = [3, -1, 0, 5, 9, -2] # output_list = filter_and_sort_positive(input_list) # print(output_list) # Output should be [9, 5, 3]"},{"question":"def longest_palindrome_substring(s: str) -> str: Returns the longest palindromic substring in the given string. If there are multiple substrings of the same maximum length, return the first one. >>> longest_palindrome_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] >>> longest_palindrome_substring(\\"cbbd\\") == \\"bb\\" >>> longest_palindrome_substring(\\"\\") == \\"\\" >>> longest_palindrome_substring(\\"a\\") == \\"a\\" >>> longest_palindrome_substring(\\"abcdefg\\") in [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\", \\"g\\"] >>> longest_palindrome_substring(\\"racecar\\") == \\"racecar\\" >>> longest_palindrome_substring(\\"abccba\\") == \\"abccba\\" >>> longest_palindrome_substring(\\"abacdfgdcaba\\") == \\"aba\\"","solution":"def longest_palindrome_substring(s: str) -> str: Returns the longest palindromic substring in the given string. If there are multiple substrings of the same maximum length, return the first one. n = len(s) if n == 0: return \\"\\" # Initialize the start and end pointers for the largest palindrome start, end = 0, 0 def expand_around_center(left: int, right: int) -> (int, int): while left >= 0 and right < n and s[left] == s[right]: left -= 1 right += 1 return left + 1, right - 1 for i in range(n): # Check for odd length palindromes (single character center) left1, right1 = expand_around_center(i, i) # Check for even length palindromes (two character center) left2, right2 = expand_around_center(i, i + 1) if right1 - left1 > end - start: start, end = left1, right1 if right2 - left2 > end - start: start, end = left2, right2 return s[start:end + 1]"},{"question":"def count_total_requests(log_entries): Calculate and return the total number of requests in the log entries. >>> count_total_requests([{'ip': '192.168.1.1', 'processing_time': 234, 'url': '/index', 'status': 200}, {'ip': '192.168.1.2', 'processing_time': 123, 'url': '/home', 'status': 200}]) 2 pass def get_top_10_ip_addresses(log_entries): Identify and return the top 10 IP addresses by request count from log entries. >>> get_top_10_ip_addresses([{'ip': '192.168.1.1', 'processing_time': 234, 'url': '/index', 'status': 200}, {'ip': '192.168.1.1', 'processing_time': 123, 'url': '/home', 'status': 200}, {'ip': '192.168.1.2', 'processing_time': 123, 'url': '/contact', 'status': 404}]) [('192.168.1.1', 2), ('192.168.1.2', 1)] pass def calculate_average_request_time(log_entries): Calculate and return the average request processing time from log entries. >>> calculate_average_request_time([{'ip': '192.168.1.1', 'processing_time': 200, 'url': '/index', 'status': 200}, {'ip': '192.168.1.2', 'processing_time': 100, 'url': '/home', 'status': 200}]) 150 pass def get_most_frequently_accessed_urls(log_entries): Determine and return the most frequently accessed URLs from log entries. >>> get_most_frequently_accessed_urls([{'ip': '192.168.1.1', 'processing_time': 200, 'url': '/index', 'status': 200}, {'ip': '192.168.1.2', 'processing_time': 100, 'url': '/home', 'status': 200}, {'ip': '192.168.1.1', 'processing_time': 150, 'url': '/index', 'status': 200}, {'ip': '192.168.1.3', 'processing_time': 120, 'url': '/about', 'status': 200}]) [('/index', 2), ('/home', 1), ('/about', 1)] pass def summarize_http_status_codes(log_entries): Summarize and return the HTTP status codes from log entries. >>> summarize_http_status_codes([{'ip': '192.168.1.1', 'processing_time': 200, 'url': '/index', 'status': 200}, {'ip': '192.168.1.2', 'processing_time': 100, 'url': '/home', 'status': 404}, {'ip': '192.168.1.3', 'processing_time': 150, 'url': '/about', 'status': 500}, {'ip': '192.168.1.4', 'processing_time': 50, 'url': '/contact', 'status': 200}]) {200: 2, 404: 1, 500: 1} pass","solution":"def count_total_requests(log_entries): Return the total number of requests in the log entries. return len(log_entries) def get_top_10_ip_addresses(log_entries): Return the top 10 IP addresses by request count. from collections import Counter ip_addresses = [entry['ip'] for entry in log_entries] most_common_ips = Counter(ip_addresses).most_common(10) return most_common_ips def calculate_average_request_time(log_entries): Return the average request processing time from log entries. total_time = sum(entry['processing_time'] for entry in log_entries) average_time = total_time / len(log_entries) return average_time def get_most_frequently_accessed_urls(log_entries): Return the most frequently accessed URLs from log entries. from collections import Counter urls = [entry['url'] for entry in log_entries] most_common_urls = Counter(urls).most_common() return most_common_urls def summarize_http_status_codes(log_entries): Return a summary of HTTP status codes from log entries. from collections import Counter status_codes = [entry['status'] for entry in log_entries] status_code_summary = Counter(status_codes).most_common() return dict(status_code_summary)"},{"question":"def flatten_dict(d, parent_key='', sep='.'): Flattens a nested dictionary into a single dictionary with concatenated keys. Args: d (dict): The dictionary to be flattened. parent_key (str): The base key string used to store the concatenated key. sep (str): The separator to use between key segments. Returns: dict: The flattened dictionary. pass # Example usages: # flatten_dict({ # 'a': 1, # 'b': { # 'c': 2, # 'd': { # 'e': 3, # 'f': 4 # } # } # }) should return { # 'a': 1, # 'b.c': 2, # 'b.d.e': 3, # 'b.d.f': 4 # } def test_flatten_dict_single_level(): d = {'a': 1, 'b': 2, 'c': 3} expected = {'a': 1, 'b': 2, 'c': 3} assert flatten_dict(d) == expected def test_flatten_dict_two_levels(): d = {'a': 1, 'b': {'c': 2, 'd': 3}} expected = {'a': 1, 'b.c': 2, 'b.d': 3} assert flatten_dict(d) == expected def test_flatten_dict_multiple_levels(): d = {'a': 1, 'b': {'c': 2, 'd': {'e': 3, 'f': 4}}} expected = {'a': 1, 'b.c': 2, 'b.d.e': 3, 'b.d.f': 4} assert flatten_dict(d) == expected def test_flatten_dict_empty(): d = {} expected = {} assert flatten_dict(d) == expected def test_flatten_dict_with_empty_nested_dict(): d = {'a': 1, 'b': {}, 'c': 3} expected = {'a': 1, 'c': 3} assert flatten_dict(d) == expected","solution":"def flatten_dict(d, parent_key='', sep='.'): Flattens a nested dictionary into a single dictionary with concatenated keys. Args: d (dict): The dictionary to be flattened. parent_key (str): The base key string used to store the concatenated key. sep (str): The separator to use between key segments. Returns: dict: The flattened dictionary. items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def students_above_average(students): Returns a list of student names who scored above the average. :param students: List of tuples where each tuple consists of a student's name and score :type students: list :return: List of names of students who scored above the average score :rtype: list >>> students_above_average([]) [] >>> students_above_average([(\\"John\\", 88), (\\"Jane\\", 92), (\\"Dave\\", 75)]) [\\"John\\", \\"Jane\\"] >>> students_above_average([(\\"John\\", 60), (\\"Jane\\", 60), (\\"Dave\\", 60)]) [] >>> students_above_average([(\\"John\\", 80), (\\"Jane\\", 90), (\\"Dave\\", 70), (\\"Mike\\", 50)]) [\\"John\\", \\"Jane\\"] >>> students_above_average([(\\"John\\", 88)]) [] >>> students_above_average([(\\"John\\", 50), (\\"Jane\\", 100)]) [\\"Jane\\"] >>> students_above_average([(\\"John\\", 0), (\\"Jane\\", 0)]) []","solution":"def students_above_average(students): Returns a list of student names who scored above the average. :param students: List of tuples where each tuple consists of a student's name and score :type students: list :return: List of names of students who scored above the average score :rtype: list if not students: return [] total_score = sum(score for name, score in students) average_score = total_score / len(students) above_average_students = [name for name, score in students if score > average_score] return above_average_students"},{"question":"def longest_consecutive_sequence(arr: list) -> int: Returns the length of the longest sequence of consecutive elements. >>> longest_consecutive_sequence([102, 4, 100, 1, 101, 3, 2]) 4 >>> longest_consecutive_sequence([0, -1]) 2 >>> longest_consecutive_sequence([5]) 1 >>> longest_consecutive_sequence([1, 2, 2, 2, 3, 4, 4, 5]) 5 >>> longest_consecutive_sequence([10, 20, 30, 40]) 1 >>> longest_consecutive_sequence(list(range(-50, 51))) 101 >>> longest_consecutive_sequence([-1, -2, -3, -5, -4]) 5 >>> longest_consecutive_sequence([5, 2, 99, 100, 3, -1, 1, 4, 101, 102]) 5","solution":"def longest_consecutive_sequence(arr: list) -> int: Returns the length of the longest sequence of consecutive elements. nums_set = set(arr) longest_length = 0 for num in nums_set: if num - 1 not in nums_set: # num is the start of a new sequence current_num = num current_length = 1 while current_num + 1 in nums_set: current_num += 1 current_length += 1 longest_length = max(longest_length, current_length) return longest_length"},{"question":"import json from collections import defaultdict def generate_report(log_file_path): Reads a log file containing JSON event records and produces a summary report. :param log_file_path: Path to the log file. :return: Dictionary containing the summary report. pass import os import json import pytest @pytest.fixture def create_log_file(tmp_path): log_data = [ {\\"timestamp\\": \\"2023-10-17T16:20:00Z\\", \\"event_type\\": \\"LOGIN\\", \\"user_id\\": \\"user1\\"}, {\\"timestamp\\": \\"2023-10-17T16:25:00Z\\", \\"event_type\\": \\"LOGOUT\\", \\"user_id\\": \\"user1\\"}, {\\"timestamp\\": \\"2023-10-17T16:30:00Z\\", \\"event_type\\": \\"LOGIN\\", \\"user_id\\": \\"user2\\"}, {\\"timestamp\\": \\"2023-10-17T16:35:00Z\\", \\"event_type\\": \\"ERROR\\", \\"user_id\\": \\"user2\\"}, {\\"timestamp\\": \\"2023-10-17T16:40:00Z\\", \\"event_type\\": \\"LOGIN\\", \\"user_id\\": \\"user3\\"} ] log_file = tmp_path / \\"log.json\\" with log_file.open('w') as f: json.dump(log_data, f) return log_file def test_generate_report(create_log_file): log_file = create_log_file report = generate_report(log_file) expected_report = { \\"total_events\\": 5, \\"unique_users\\": 3, \\"event_counts\\": { \\"LOGIN\\": 3, \\"LOGOUT\\": 1, \\"ERROR\\": 1 } } assert report == expected_report @pytest.fixture def create_empty_log_file(tmp_path): log_data = [] log_file = tmp_path / \\"log.json\\" with log_file.open('w') as f: json.dump(log_data, f) return log_file def test_generate_report_empty_logs(create_empty_log_file): log_file = create_empty_log_file report = generate_report(log_file) expected_report = { \\"total_events\\": 0, \\"unique_users\\": 0, \\"event_counts\\": {} } assert report == expected_report","solution":"import json from collections import defaultdict def generate_report(log_file_path): Reads a log file containing JSON event records and produces a summary report. :param log_file_path: Path to the log file. :return: Dictionary containing the summary report. with open(log_file_path, 'r') as file: events = json.load(file) total_events = len(events) unique_users = set() event_counts = defaultdict(int) for event in events: unique_users.add(event['user_id']) event_counts[event['event_type']] += 1 report = { \\"total_events\\": total_events, \\"unique_users\\": len(unique_users), \\"event_counts\\": dict(event_counts) } return report"},{"question":"def process_names(input_file, output_file): Reads names from an input file, removes blank lines or lines with only whitespace, sorts the names alphabetically, and writes them to an output file. :param input_file: Path to the input file containing names. :param output_file: Path to the output file where sorted names will be written. pass import os def test_process_names(tmpdir): # Create a temporary input file with the name to sort input_file = tmpdir.join(\\"input_names.txt\\") output_file = tmpdir.join(\\"output_names.txt\\") # Write the test data to the input file input_data = Emma Oliver Ava Sophia James input_file.write(input_data) # Call the function to process the input file process_names(str(input_file), str(output_file)) # Read back the output file with open(output_file, 'r') as f: result = f.read().strip() # Define the expected output expected_output = Ava Emma James Oliver Sophia # Assert the output matches the expected output assert result == expected_output def test_process_names_with_all_blank_lines(tmpdir): input_file = tmpdir.join(\\"input_blank_names.txt\\") output_file = tmpdir.join(\\"output_blank_names.txt\\") # Test with all blank lines in input input_data = input_file.write(input_data) process_names(str(input_file), str(output_file)) # Read back the output file with open(output_file, 'r') as f: result = f.read().strip() # Define the expected output (should be empty) expected_output = \\"\\" # Assert the output is empty assert result == expected_output def test_process_names_with_no_blank_lines(tmpdir): input_file = tmpdir.join(\\"input_no_blank_names.txt\\") output_file = tmpdir.join(\\"output_no_blank_names.txt\\") # Test with no blank lines in input input_data = Jake Anna Chris input_file.write(input_data) process_names(str(input_file), str(output_file)) # Read back the output file with open(output_file, 'r') as f: result = f.read().strip() # Define the expected output expected_output = Anna Chris Jake # Assert the output matches the expected output assert result == expected_output","solution":"def process_names(input_file, output_file): Reads names from an input file, removes blank lines or lines with only whitespace, sorts the names alphabetically, and writes them to an output file. :param input_file: Path to the input file containing names. :param output_file: Path to the output file where sorted names will be written. with open(input_file, 'r') as infile: # Read all lines, stripping whitespace and filtering out empty lines names = [line.strip() for line in infile if line.strip()] # Sort the names alphabetically names.sort() # Write the sorted names to the output file, each on a new line with open(output_file, 'w') as outfile: for name in names: outfile.write(name + 'n')"},{"question":"def numDecodings(s: str) -> int: You are given an encoded string containing only digits. Your task is to decode it and determine the total number of possible decodings. Each digit or group of digits can be mapped to a letter using the following mapping: 'A' -> 1 'B' -> 2 ... 'Z' -> 26 The decoding must be valid according to the mapping rules above. If the input string contains leading zeros or sequences that cannot map to any valid letter, the function should return \`0\`. Examples: >>> numDecodings(\\"12\\") 2 >>> numDecodings(\\"226\\") 3 >>> numDecodings(\\"0\\") 0 >>> numDecodings(\\"10\\") 1","solution":"def numDecodings(s: str) -> int: if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): if s[i-1] != '0': dp[i] += dp[i-1] if '10' <= s[i-2:i] <= '26': dp[i] += dp[i-2] return dp[n]"},{"question":"class BankAccount: A simple bank account class to simulate deposit, withdraw, and balance checking Attributes: balance (int/float): The current balance in the account. Methods: deposit(amount): Adds the specified amount to the account balance. withdraw(amount): Subtracts the specified amount from the account balance if sufficient funds exist. get_balance(): Returns the current account balance. >>> account = BankAccount() >>> account.get_balance() 0 >>> account_with_balance = BankAccount(100) >>> account_with_balance.get_balance() 100 >>> account.deposit(50) >>> account.get_balance() 50 >>> account.deposit(25) >>> account.get_balance() 75 >>> account.withdraw(30) >>> account.get_balance() 70 >>> account.withdraw(70) >>> account.get_balance() 0 def __init__(self, initial_balance=0): # Initialize the account with an initial balance. pass def deposit(self, amount): # Deposit a positive amount to the account balance. pass def withdraw(self, amount): # Withdraw a positive amount from the account balance if sufficient funds exist. pass def get_balance(self): # Return the current account balance. pass","solution":"class BankAccount: def __init__(self, initial_balance=0): self.balance = initial_balance def deposit(self, amount): if amount <= 0: raise ValueError(\\"Deposit amount must be positive.\\") self.balance += amount def withdraw(self, amount): if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive.\\") if amount > self.balance: raise ValueError(\\"Insufficient funds.\\") self.balance -= amount def get_balance(self): return self.balance"},{"question":"def minesweeper(board_size, bombs): Simulates a Minesweeper board. Parameters: board_size (tuple): A tuple representing the size of the board (rows, cols). bombs (list): A list of tuples where each tuple contains coordinates of a bomb. Returns: list: A 2D list representing the Minesweeper board. >>> minesweeper((3, 3), [(0, 0), (1, 1)]) [[-1, 2, 1], [2, -1, 1], [1, 1, 1]]","solution":"def minesweeper(board_size, bombs): Simulates a Minesweeper board. Parameters: board_size (tuple): A tuple representing the size of the board (rows, cols). bombs (list): A list of tuples where each tuple contains coordinates of a bomb. Returns: list: A 2D list representing the Minesweeper board. rows, cols = board_size board = [[0] * cols for _ in range(rows)] for bomb in bombs: r, c = bomb board[r][c] = -1 for i in range(r-1, r+2): for j in range(c-1, c+2): if 0 <= i < rows and 0 <= j < cols and board[i][j] != -1: board[i][j] += 1 return board"},{"question":"def highest_score(courses): Takes a dictionary of courses and their respective scores and returns a dictionary with each course name and the highest score in that course. If a course has no scores, it returns None for that course. Parameters: courses (dict): A dictionary where the keys are course names and the values are lists of student scores. Returns: dict: A dictionary with each course name and its corresponding highest score. If a course has no scores, it returns None for that course. Example: >>> courses = { ... \\"Math\\": [85, 90, 78], ... \\"Science\\": [88, 92], ... \\"Literature\\": [], ... \\"Art\\": [95, 100, 92] ... } >>> highest_score(courses) {'Math': 90, 'Science': 92, 'Literature': None, 'Art': 100} def test_highest_score(): courses = { \\"Math\\": [85, 90, 78], \\"Science\\": [88, 92], \\"Literature\\": [], \\"Art\\": [95, 100, 92] } expected = { \\"Math\\": 90, \\"Science\\": 92, \\"Literature\\": None, \\"Art\\": 100 } assert highest_score(courses) == expected def test_empty_courses(): courses = {} expected = {} assert highest_score(courses) == expected def test_all_empty_subjects(): courses = { \\"History\\": [], \\"Physics\\": [], \\"Chemistry\\": [] } expected = { \\"History\\": None, \\"Physics\\": None, \\"Chemistry\\": None } assert highest_score(courses) == expected def test_single_course(): courses = { \\"Biology\\": [78, 85, 89] } expected = { \\"Biology\\": 89 } assert highest_score(courses) == expected def test_mixed_courses_empty_and_non_empty(): courses = { \\"Math\\": [84, 72, 90], \\"Biology\\": [90], \\"History\\": [] } expected = { \\"Math\\": 90, \\"Biology\\": 90, \\"History\\": None } assert highest_score(courses) == expected","solution":"def highest_score(courses): Takes a dictionary of courses and their respective scores and returns a dictionary with each course name and the highest score in that course. If a course has no scores, it returns None for that course. result = {} for course, scores in courses.items(): if scores: result[course] = max(scores) else: result[course] = None return result"},{"question":"def compress_string(s: str) -> str: Compresses the given string by replacing consecutive repeated characters with the character followed by the count of repetitions. If the compressed string is not shorter than the original string, return the original string. >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compress_string(\\"abc\\") \\"abc\\" >>> compress_string(\\"aaaa\\") \\"a4\\" >>> compress_string(\\"\\") \\"\\" >>> compress_string(\\"aabbcc\\") \\"aabbcc\\"","solution":"def compress_string(s): Compresses the given string by replacing consecutive repeated characters with the character followed by the count of repetitions. If the compressed string is not shorter than the original string, return the original string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(s[i-1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) # Don't forget to add the last group compressed_str = ''.join(compressed) return compressed_str if len(compressed_str) < len(s) else s"},{"question":"def find_majority_element(nums): Identifies the majority element in the list using Boyer-Moore Voting Algorithm. If no majority element exists, returns None. >>> find_majority_element([1, 2, 3, 1, 1]) 1 >>> find_majority_element([1, 2, 3, 4, 5]) None >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> find_majority_element([]) None >>> find_majority_element([1]) 1 >>> find_majority_element([5, 5, 5, 5, 5]) 5 >>> find_majority_element([2] * 5000 + [1] * 4999) 2","solution":"def find_majority_element(nums): Identifies the majority element in the list using Boyer-Moore Voting Algorithm. If no majority element exists, returns None. if not nums: return None # Phase 1: Finding a candidate majority element candidate, count = None, 0 for num in nums: if count == 0: candidate = num count += 1 if num == candidate else -1 # Phase 2: Validating the candidate count = 0 for num in nums: if num == candidate: count += 1 if count > len(nums) // 2: return candidate return None"},{"question":"def square_elements(input_list): Returns a list of squared values of the integers in the input list. If the input is not a list or contains non-integer elements, returns an error message. >>> square_elements([1, 2, 3, 4]) [1, 4, 9, 16] >>> square_elements([0, -1, -2]) [0, 1, 4] >>> square_elements([1, 'two', 3]) \\"Error: List contains non-integer elements\\" >>> square_elements(\\"not a list\\") \\"Error: Input is not a list\\" >>> square_elements([]) []","solution":"def square_elements(input_list): Returns a list of squared values of the integers in the input list. If the input is not a list or contains non-integer elements, returns an error message. if not isinstance(input_list, list): return \\"Error: Input is not a list\\" squared_list = [] for element in input_list: if not isinstance(element, int): return \\"Error: List contains non-integer elements\\" squared_list.append(element ** 2) return squared_list"},{"question":"from typing import List from urllib.parse import urlparse def extract_domains(urls: List[str]) -> List[str]: Extracts domain names from a list of URLs, ignoring 'www.' part. Args: urls (list): List of URLs in format 'http://www.example.com' or 'https://www.example.com'. Returns: list: List of domain names without 'www.'. Examples: >>> extract_domains([\\"http://www.example.com\\", \\"http://www.test.com\\"]) ['example.com', 'test.com'] >>> extract_domains([\\"https://www.example.com\\", \\"https://www.test.com\\"]) ['example.com', 'test.com'] >>> extract_domains([\\"http://www.example.com\\", \\"https://www.test.com\\", \\"http://example.org\\"]) ['example.com', 'test.com', 'example.org'] >>> extract_domains([\\"http://example.com\\", \\"https://test.com\\"]) ['example.com', 'test.com'] >>> extract_domains([]) []","solution":"from urllib.parse import urlparse def extract_domains(urls): Extracts domain names from a list of URLs, ignoring 'www.' part. Args: urls (list): List of URLs in format 'http://www.example.com' or 'https://www.example.com'. Returns: list: List of domain names without 'www.'. domains = [] for url in urls: parsed_url = urlparse(url) domain = parsed_url.netloc if domain.startswith('www.'): domain = domain[4:] domains.append(domain) return domains"},{"question":"from typing import List def move_to_end(arr: List[int], N: int) -> List[int]: Moves all instances of N to the end of the list while preserving the order of other elements. >>> move_to_end([4, 1, 2, 3, 4, 5, 4], 4) [1, 2, 3, 5, 4, 4, 4] >>> move_to_end([1, 2, 3, 4, 5], 6) [1, 2, 3, 4, 5] >>> move_to_end([], 3) [] >>> move_to_end([2, 2, 2, 2], 2) [2, 2, 2, 2] >>> move_to_end([1, 3, 5, 7], 2) [1, 3, 5, 7] >>> move_to_end([5, 1, 5, 2, 5], 5) [1, 2, 5, 5, 5]","solution":"def move_to_end(arr, N): Moves all instances of N to the end of the list while preserving the order of other elements. # Initialize two lists, one for elements to keep and another for elements to move to the end kept_elements = [] moved_elements = [] # Iterate through the array and distribute elements to the appropriate list for num in arr: if num == N: moved_elements.append(num) else: kept_elements.append(num) # Concatenate the lists, with kept elements first followed by the moved elements return kept_elements + moved_elements"},{"question":"def max_packages_load(truck_dims, packages): This function should return the maximum number of packages that can fit into the truck without exceeding its dimensions. Args: truck_dims (tuple): A tuple of three integers (truck_width, truck_height, truck_depth) representing the dimensions of the truck. packages (list): A list of tuples, each containing three integers (width, height, depth) representing the dimensions of a package. Returns: int: The maximum number of packages that can be loaded into the truck. Example: >>> max_packages_load((10, 10, 10), [(1, 1, 1), (2, 2, 2), (5, 5, 5), (8, 8, 8)]) 4 >>> max_packages_load((5, 5, 5), [(3, 3, 2), (4, 4, 4), (1, 1, 1)]) 2 >>> max_packages_load((8, 8, 8), [(9, 9, 9), (1, 7, 7), (6, 6, 6), (5, 5, 5)]) 2","solution":"def max_packages_load(truck_dims, packages): This function should return the maximum number of packages that can fit into the truck without exceeding its dimensions. Args: truck_dims (tuple): A tuple of three integers (truck_width, truck_height, truck_depth) representing the dimensions of the truck. packages (list): A list of tuples, each containing three integers (width, height, depth) representing the dimensions of a package. Returns: int: The maximum number of packages that can be loaded into the truck. truck_width, truck_height, truck_depth = truck_dims count = 0 for package in packages: width, height, depth = package if width <= truck_width and height <= truck_height and depth <= truck_depth: count += 1 return count"},{"question":"def maximize_min_diff(arr: List[int]) -> List[int]: Given an array of unique integers, this function returns a new array that maximizes the minimum difference between any consecutive elements in the array. >>> maximize_min_diff([1, 5, 10, 15]) [1, 15, 5, 10] >>> maximize_min_diff([9, 1, 19, 6]) [1, 19, 6, 9] >>> maximize_min_diff([8, 5, 12, 11, 3]) [3, 12, 5, 11, 8]","solution":"def maximize_min_diff(arr): Given an array of unique integers, the function returns a new array that maximizes the minimum difference between any consecutive elements in the array. arr.sort() low = 0 high = len(arr) - 1 result = [] while low < high: result.append(arr[low]) low += 1 if low < high: result.append(arr[high]) high -= 1 if low == high: result.append(arr[low]) return result"},{"question":"from typing import List, Optional def most_frequent_integer(numbers: List[int]) -> Optional[int]: Determines the most frequent integer in a list. If there are multiple integers with the same frequency, returns the smallest one. :param numbers: List of integers :return: The most frequent integer, or the smallest one if tie in frequency >>> most_frequent_integer([4, 1, 2, 2, 3, 4, 4, 1]) 4 >>> most_frequent_integer([4, 4, 1, 1, 2, 2]) 1 >>> most_frequent_integer([7]) 7 >>> most_frequent_integer([]) None >>> most_frequent_integer([7, 8, 9, 10]) 7 >>> most_frequent_integer([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) 4 >>> most_frequent_integer([-1, -2, -2, -3, -3, -3, -4, -4, -4, -4]) -4 pass","solution":"def most_frequent_integer(numbers): Determines the most frequent integer in a list. If there are multiple integers with the same frequency, returns the smallest one. :param numbers: List of integers :return: The most frequent integer, or the smallest one if tie in frequency from collections import Counter if not numbers: return None freq = Counter(numbers) max_freq = max(freq.values()) most_frequent = [num for num, count in freq.items() if count == max_freq] return min(most_frequent)"},{"question":"def find_largest_number(lst): Returns the largest number in a given list. If the list is empty, returns None. >>> find_largest_number([1, 2, 3, 4, 5]) == 5 >>> find_largest_number([-1, -2, -3, -4, -5]) == -1 >>> find_largest_number([3, -1, 9, 2, 7]) == 9 >>> find_largest_number([42]) == 42 >>> find_largest_number([]) == None >>> find_largest_number([4, 4, 4, 4]) == 4 # Your code here","solution":"def find_largest_number(lst): Returns the largest number in a given list. If the list is empty, returns None. if not lst: return None largest = lst[0] for num in lst: if num > largest: largest = num return largest"},{"question":"import pandas as pd def generate_sales_summary(file_path: str) -> dict: Reads a CSV file containing sales data and generates a summary report. The report includes total sales, average sales per month, and the top 3 highest selling products. Parameters: file_path (str): Path to the CSV file containing the sales data Returns: dict: A dictionary containing the summary report with keys 'total_sales', 'average_sales_per_month', and 'top_3_products' Example: >>> data = { 'month': ['Jan', 'Jan', 'Feb', 'Feb', 'Mar', 'Mar'], 'product': ['A', 'B', 'A', 'C', 'B', 'C'], 'sales': [100, 200, 150, 300, 250, 350] } >>> df = pd.DataFrame(data) >>> df.to_csv('test_sales_data.csv', index=False) >>> report = generate_sales_summary('test_sales_data.csv') >>> report['total_sales'] 1350 >>> pytest.approx(report['average_sales_per_month'], 0.1) 450.0 >>> set(report['top_3_products']) {'C', 'B', 'A'}","solution":"import pandas as pd def generate_sales_summary(file_path): Reads a CSV file containing sales data and generates a summary report. The report includes total sales, average sales per month, and the top 3 highest selling products. Parameters: file_path (str): Path to the CSV file containing the sales data Returns: dict: A dictionary containing the summary report with keys 'total_sales', 'average_sales_per_month', and 'top_3_products' # Read the CSV file sales_data = pd.read_csv(file_path) # Handle missing values by filling with 0s sales_data.fillna(0, inplace=True) # Calculate total sales total_sales = sales_data['sales'].sum() # Calculate average sales per month # Assuming the data contains a 'month' column to group by average_sales_per_month = sales_data.groupby('month')['sales'].sum().mean() # Find the top 3 highest selling products top_3_products = sales_data.groupby('product')['sales'].sum().nlargest(3).index.tolist() # Create the summary report summary_report = { 'total_sales': total_sales, 'average_sales_per_month': average_sales_per_month, 'top_3_products': top_3_products } return summary_report"},{"question":"def group_by_root_directory(file_paths: List[str]) -> Dict[str, List[str]]: Groups file paths by their root directories. Parameters: file_paths (list of str): The list of file paths. Returns: dict: A dictionary where keys are root directories and values are lists of file paths. >>> group_by_root_directory([ ... \\"root1/file1.txt\\", ... \\"root2/file2.txt\\", ... \\"root1/folder1/file3.txt\\", ... \\"root3/file4.txt\\", ... \\"root2/folder2/file5.txt\\", ... \\"root1/folder1/folder2/file6.txt\\" ... ]) == { ... \\"root1\\": [ ... \\"root1/file1.txt\\", ... \\"root1/folder1/file3.txt\\", ... \\"root1/folder1/folder2/file6.txt\\" ... ], ... \\"root2\\": [ ... \\"root2/file2.txt\\", ... \\"root2/folder2/file5.txt\\" ... ], ... \\"root3\\": [ ... \\"root3/file4.txt\\" ... ] ... } >>> group_by_root_directory([]) == {} >>> group_by_root_directory([\\"root1/file1.txt\\"]) == {\\"root1\\": [\\"root1/file1.txt\\"]} >>> group_by_root_directory([\\"root1/file1.txt\\", \\"root1/file2.txt\\"]) == {\\"root1\\": [\\"root1/file1.txt\\", \\"root1/file2.txt\\"]} >>> group_by_root_directory([\\"file1.txt\\"]) == {\\"file1.txt\\": [\\"file1.txt\\"]} >>> group_by_root_directory([\\"root1\\", \\"root2/file1.txt\\"]) == { ... \\"root1\\": [\\"root1\\"], ... \\"root2\\": [\\"root2/file1.txt\\"] ... } grouped_paths = {} for path in file_paths: root_dir = path.split('/')[0] if root_dir not in grouped_paths: grouped_paths[root_dir] = [] grouped_paths[root_dir].append(path) return grouped_paths","solution":"def group_by_root_directory(file_paths): Groups file paths by their root directories. Parameters: file_paths (list of str): The list of file paths. Returns: dict: A dictionary where keys are root directories and values are lists of file paths. grouped_paths = {} for path in file_paths: root_dir = path.split('/')[0] if root_dir not in grouped_paths: grouped_paths[root_dir] = [] grouped_paths[root_dir].append(path) return grouped_paths"},{"question":"available_subject_time_slots = { 'Math': ['Monday 9AM', 'Wednesday 10AM'], 'Science': ['Monday 10AM', 'Thursday 11AM'], 'Literature': ['Tuesday 9AM', 'Friday 10AM'], 'History': ['Wednesday 9AM', 'Friday 11AM'] } def generate_schedule(students): Generate a schedule for each student based on their preferred subjects and available time slots. Args: students (list): A list of dictionaries where each dictionary represents a student with their name, preferred subjects, and available time slots. Returns: tuple: Two dictionaries, one for the generated schedules and one for the alerts for unassigned subjects. pass def validate_schedules(schedules): Validate that the generated schedules do not have overlapping time slots for each student and that all assigned time slots are valid within the available subject time slots. Args: schedules (dict): A dictionary containing the generated schedules for each student. Returns: bool: True if all schedules are valid, False otherwise. pass def view_schedule(name, schedules, alerts): Provide a clear and structured view of a student's schedule. Args: name (str): The student's name. schedules (dict): A dictionary containing the generated schedules for each student. alerts (dict): A dictionary containing the alerts for unassigned subjects for each student. Returns: str: A formatted string displaying the student's schedule and any scheduling conflicts or unassigned preferences. pass # Unit Tests import pytest def test_generate_schedule(): students = [ {'name': 'Alice', 'preferences': ['Math', 'Science', 'Literature'], 'available_slots': ['Monday 9AM', 'Monday 10AM', 'Tuesday 9AM']}, {'name': 'Bob', 'preferences': ['Math', 'History'], 'available_slots': ['Monday 9AM', 'Friday 11AM']}, {'name': 'Charlie', 'preferences': ['Science', 'Literature', 'History'], 'available_slots': ['Thursday 11AM', 'Tuesday 9AM', 'Friday 11AM']} ] schedules, alerts = generate_schedule(students) assert schedules['Alice'] == {'Math': 'Monday 9AM', 'Science': 'Monday 10AM', 'Literature': 'Tuesday 9AM'} assert alerts['Alice'] == [] assert schedules['Bob'] == {'Math': 'Monday 9AM', 'History': 'Friday 11AM'} assert alerts['Bob'] == [] assert schedules['Charlie'] == {'Science': 'Thursday 11AM', 'Literature': 'Tuesday 9AM', 'History': 'Friday 11AM'} assert alerts['Charlie'] == [] def test_generate_schedule_with_conflicts(): students = [ {'name': 'David', 'preferences': ['Math', 'Science'], 'available_slots': ['Monday 9AM', 'Monday 10AM']}, {'name': 'Eve', 'preferences': ['Math', 'Science'], 'available_slots': ['Monday 10AM']}, {'name': 'Frank', 'preferences': ['History', 'Literature'], 'available_slots': ['Friday 10AM', 'Friday 11AM']} ] schedules, alerts = generate_schedule(students) assert schedules['David'] == {'Math': 'Monday 9AM', 'Science': 'Monday 10AM'} assert alerts['David'] == [] assert schedules['Eve'] == {'Science': 'Monday 10AM'} assert alerts['Eve'] == ['Math'] assert schedules['Frank'] == {'Literature': 'Friday 10AM', 'History': 'Friday 11AM'} assert alerts['Frank'] == [] def test_validate_schedules(): schedules = { 'Alice': {'Math': 'Monday 9AM', 'Science': 'Monday 10AM', 'Literature': 'Tuesday 9AM'}, 'Bob': {'Math': 'Monday 9AM', 'History': 'Friday 11AM'}, 'Charlie': {'Science': 'Thursday 11AM', 'Literature': 'Tuesday 9AM', 'History': 'Friday 11AM'} } assert validate_schedules(schedules) == True def test_view_schedule(): students = [ {'name': 'Alice', 'preferences': ['Math', 'Science', 'Literature'], 'available_slots': ['Monday 9AM', 'Monday 10AM', 'Tuesday 9AM']}, {'name': 'Bob', 'preferences': ['Math', 'History'], 'available_slots': ['Monday 9AM', 'Friday 11AM']}, {'name': 'Charlie', 'preferences': ['Science', 'Literature', 'History'], 'available_slots': ['Thursday 11AM', 'Tuesday 9AM', 'Friday 11AM']} ] schedules, alerts = generate_schedule(students) expected_output = \\"Schedule for Alice:nMath: Monday 9AMnScience: Monday 10AMnLiterature: Tuesday 9AMn\\" assert view_schedule('Alice', schedules, alerts) == expected_output expected_output = \\"Schedule for Bob:nMath: Monday 9AMnHistory: Friday 11AMn\\" assert view_schedule('Bob', schedules, alerts) == expected_output expected_output = \\"Schedule for Charlie:nScience: Thursday 11AMnLiterature: Tuesday 9AMnHistory: Friday 11AMn\\" assert view_schedule('Charlie', schedules, alerts) == expected_output expected_output = \\"Schedule not found for student: Zach\\" assert view_schedule('Zach', schedules, alerts) == expected_output","solution":"available_subject_time_slots = { 'Math': ['Monday 9AM', 'Wednesday 10AM'], 'Science': ['Monday 10AM', 'Thursday 11AM'], 'Literature': ['Tuesday 9AM', 'Friday 10AM'], 'History': ['Wednesday 9AM', 'Friday 11AM'] } def generate_schedule(students): schedules = {} alerts = {} for student in students: name = student['name'] preferences = student['preferences'] available_slots = student['available_slots'] student_schedule = {} student_alerts = [] for subject in preferences: assigned = False for slot in available_subject_time_slots[subject]: if slot in available_slots and slot not in student_schedule.values(): student_schedule[subject] = slot assigned = True break if not assigned: student_alerts.append(subject) schedules[name] = student_schedule alerts[name] = student_alerts return schedules, alerts def validate_schedules(schedules): for student, schedule in schedules.items(): assigned_slots = list(schedule.values()) if len(assigned_slots) != len(set(assigned_slots)): return False for subject, slot in schedule.items(): if slot not in available_subject_time_slots[subject]: return False return True def view_schedule(name, schedules, alerts): if name not in schedules: return f\\"Schedule not found for student: {name}\\" schedule = schedules[name] student_alerts = alerts[name] result = f\\"Schedule for {name}:n\\" for subject, slot in schedule.items(): result += f\\"{subject}: {slot}n\\" if student_alerts: result += \\"Could not schedule: \\" + \\", \\".join(student_alerts) + \\"n\\" return result"},{"question":"def compact_consecutive_duplicates(numbers: List[int]) -> List[int]: Compacts a list by removing all consecutive duplicate integers. Args: numbers (list): A list of integers. Returns: list: A list of integers with consecutive duplicates removed. from solution import compact_consecutive_duplicates def test_compact_consecutive_duplicates_no_duplicates(): assert compact_consecutive_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_compact_consecutive_duplicates_with_duplicates(): assert compact_consecutive_duplicates([1, 1, 2, 3, 3, 4, 4, 4, 5]) == [1, 2, 3, 4, 5] def test_compact_consecutive_duplicates_all_duplicates(): assert compact_consecutive_duplicates([1, 1, 1, 1, 1]) == [1] def test_compact_consecutive_duplicates_mixed(): assert compact_consecutive_duplicates([1, 2, 2, 3, 3, 3, 4, 1, 1]) == [1, 2, 3, 4, 1] def test_compact_consecutive_duplicates_empty_list(): assert compact_consecutive_duplicates([]) == [] def test_compact_consecutive_duplicates_single_element(): assert compact_consecutive_duplicates([1]) == [1] def test_compact_consecutive_duplicates_two_different_elements(): assert compact_consecutive_duplicates([1, 2]) == [1, 2] def test_compact_consecutive_duplicates_two_same_elements(): assert compact_consecutive_duplicates([1, 1]) == [1]","solution":"def compact_consecutive_duplicates(numbers): Compacts a list by removing all consecutive duplicate integers. Args: numbers (list): A list of integers. Returns: list: A list of integers with consecutive duplicates removed. if not numbers: return [] return [numbers[i] for i in range(len(numbers)) if i == 0 or numbers[i] != numbers[i - 1]]"},{"question":"def is_path(grid: List[List[int]]) -> bool: Determines if there is a path from the top-left to the bottom-right corner in the grid. >>> is_path([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) True >>> is_path([[0, 1], [1, 0]]) False >>> is_path([[0, 0, 1], [1, 0, 0], [0, 0, 0]]) True >>> is_path([[0]]) True >>> is_path([[1]]) False :param grid: List[List[int]] - 2D list representing the grid with 0s and 1s. :return: bool - Whether such a path exists.","solution":"def is_path(grid): Determines if there is a path from the top-left to the bottom-right corner in the grid. :param grid: List[List[int]] - 2D list representing the grid with 0s and 1s. :return: bool - Whether such a path exists. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return False m, n = len(grid), len(grid[0]) queue = [(0, 0)] directions = [(0, 1), (1, 0)] while queue: x, y = queue.pop(0) if (x, y) == (m - 1, n - 1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0: queue.append((nx, ny)) grid[nx][ny] = 1 # Mark as visited return False"},{"question":"def remove_duplicates(input_list: list) -> list: Removes duplicate integers from the input list while maintaining the order of elements. Args: input_list (list of int): The list of integers from which to remove duplicates. Returns: list of int: A new list with duplicates removed and the order maintained. >>> remove_duplicates([4, 5, 6, 5, 4, 7, 8]) [4, 5, 6, 7, 8] >>> remove_duplicates([]) [] >>> remove_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([1, 1, 1, 1, 1]) [1] >>> remove_duplicates([1, 2, 3, 2, 2, 4, 5, 3, 6]) [1, 2, 3, 4, 5, 6]","solution":"def remove_duplicates(input_list): Removes duplicate integers from the input list while maintaining the order of elements. Args: input_list (list of int): The list of integers from which to remove duplicates. Returns: list of int: A new list with duplicates removed and the order maintained. seen = set() output_list = [] for num in input_list: if num not in seen: seen.add(num) output_list.append(num) return output_list"},{"question":"def longest_word_length(s: str) -> int: Returns the length of the longest word in the string s. Parameters: s (str): A string of words separated by spaces Returns: int: The length of the longest word in the string >>> longest_word_length(\\"hello world some words are longer\\") 6 >>> longest_word_length(\\"cat bat rat hat mat\\") 3 >>> longest_word_length(\\"\\") 0 >>> longest_word_length(\\"a ab abc abcd abcde abcdef\\") 6","solution":"def longest_word_length(s): Returns the length of the longest word in the string s. Parameters: s (str): A string of words separated by spaces Returns: int: The length of the longest word in the string words = s.split() if not words: return 0 longest = max(words, key=len) return len(longest)"},{"question":"def compute_result(numbers: List[int]) -> int: Compute the product of all numbers greater than 5 in a list. >>> compute_result([6, 7, 8]) 336 >>> compute_result([2, 4, 6, 8, 10]) 480 >>> compute_result([1, 2, 5]) 1 >>> compute_result([]) 1 >>> compute_result([10]) 10 >>> compute_result([3]) 1","solution":"def compute_result(numbers): result = 1 for num in numbers: if num > 5: result *= num return result"},{"question":"def find_books_by_keywords(book_titles: List[str], keywords: List[str]) -> Union[List[str], str]: Returns a list of books that contain any of the given keywords in their titles. The search is case-insensitive. If no titles match the keywords, a message indicating that no matches were found is returned. The function handles cases where the input lists are empty. >>> find_books_by_keywords([\\"To Kill a Mockingbird\\", \\"Pride and Prejudice\\", \\"The Great Gatsby\\", \\"The Catcher in the Rye\\"], [\\"pride\\", \\"great\\", \\"moby\\"]) [\\"Pride and Prejudice\\", \\"The Great Gatsby\\"] >>> find_books_by_keywords([\\"To Kill a Mockingbird\\", \\"Pride and Prejudice\\", \\"The Great Gatsby\\", \\"The Catcher in the Rye\\"], [\\"moby\\"]) \\"No matches found\\" >>> find_books_by_keywords([], [\\"pride\\", \\"great\\", \\"moby\\"]) \\"No matches found\\" >>> find_books_by_keywords([\\"To Kill a Mockingbird\\", \\"Pride and Prejudice\\", \\"The Great Gatsby\\", \\"The Catcher in the Rye\\"], []) \\"No matches found\\" >>> find_books_by_keywords([\\"To Kill a Mockingbird\\", \\"Pride and Prejudice\\", \\"The Great Gatsby\\", \\"The Catcher in the Rye\\"], [\\"PRIDE\\", \\"GREAT\\", \\"MOBY\\"]) [\\"Pride and Prejudice\\", \\"The Great Gatsby\\"] >>> find_books_by_keywords([\\"To Kill a Mockingbird\\", \\"Pride and Prejudice\\", \\"The Great Gatsby\\", \\"The Catcher in the Rye\\"], [\\"to\\", \\"pride\\", \\"great\\", \\"catcher\\"]) [\\"To Kill a Mockingbird\\", \\"Pride and Prejudice\\", \\"The Great Gatsby\\", \\"The Catcher in the Rye\\"] pass","solution":"def find_books_by_keywords(book_titles, keywords): Returns a list of books that contain any of the given keywords in their titles. Parameters: - book_titles: List of book titles (list of strings) - keywords: List of keywords to search for in the titles (list of strings) Returns: - List of book titles that contain any of the keywords (case-insensitive). Returns \\"No matches found\\" if no titles match the keywords. if not book_titles or not keywords: return \\"No matches found\\" # Convert keywords to lowercase for case-insensitive matching. keywords = [keyword.lower() for keyword in keywords] matched_books = [title for title in book_titles if any(keyword in title.lower() for keyword in keywords)] if not matched_books: return \\"No matches found\\" return matched_books"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers that add up to the target integer. Parameters: nums (list of int): A list of integers. target (int): The target integer. Returns: list of int: A list containing two indices. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1]","solution":"def two_sum(nums, target): Returns the indices of the two numbers that add up to the target integer. Parameters: nums (list of int): A list of integers. target (int): The target integer. Returns: list of int: A list containing two indices. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i"},{"question":"def cumulative_sum(numbers): Takes a list of integers and returns a list where each element is the sum of itself and all previous elements in the input list. Parameters: numbers (list of int): The input list of integers. Returns: list of int: The cumulative sum list. >>> cumulative_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> cumulative_sum([5]) [5] >>> cumulative_sum([0, 0, 0, 0]) [0, 0, 0, 0] >>> cumulative_sum([-1, -2, -3, -4]) [-1, -3, -6, -10] >>> cumulative_sum([1, -1, 2, -2]) [1, 0, 2, 0] >>> cumulative_sum([]) []","solution":"def cumulative_sum(numbers): Takes a list of integers and returns a list where each element is the sum of itself and all previous elements in the input list. Parameters: numbers (list of int): The input list of integers. Returns: list of int: The cumulative sum list. if not numbers: return [] result = [numbers[0]] for i in range(1, len(numbers)): result.append(result[-1] + numbers[i]) return result"},{"question":"def find_anagrams(word: str, candidates: list) -> list: Identifies all distinct anagrams of the given word within the nested candidate list. Only includes nested structures in the result and skips non-string elements. >>> word = \\"listen\\" >>> candidates = [\\"enlists\\", \\"google\\", \\"inlets\\", \\"banana\\", [\\"Silent\\", \\"LISTEN\\"], \\"tinsel\\", [None, \\"Listen\\"]] >>> find_anagrams(word, candidates) [\\"inlets\\", [\\"silent\\", \\"listen\\"], \\"tinsel\\", [\\"listen\\"]] >>> word = \\"apple\\" >>> candidates = [\\"banana\\", \\"orange\\", [\\"fruit\\", None]] >>> find_anagrams(word, candidates) [] >>> word = \\"act\\" >>> candidates = [\\"Cat\\", \\"tac\\", \\"dog\\", [\\"Tac\\", \\"dog\\"], [None, \\"CAT\\"]] >>> find_anagrams(word, candidates) [\\"cat\\", \\"tac\\", [\\"tac\\"], [\\"cat\\"]] >>> word = \\"clint eastwood\\" >>> candidates = [\\"old west action\\", 123, [None, \\"Old West Action\\", \\"eastwood clint\\"]] >>> find_anagrams(word, candidates) [\\"oldwestaction\\", [\\"oldwestaction\\", \\"eastwoodclint\\"]] >>> word = \\"empty\\" >>> candidates = [] >>> find_anagrams(word, candidates) [] >>> word = \\"\\" >>> candidates = [\\"a\\", \\"list\\", [\\"of\\", \\"anagrams\\"]] >>> find_anagrams(word, candidates) [] pass","solution":"import re def sanitize_string(s): Removes all non-alphabetic characters from the string and converts it to lowercase return re.sub(r'[^a-z]', '', s.lower()) def is_anagram(word1, word2): Checks if word1 and word2 are anagrams, ignoring case and non-alphabetic characters. return sorted(sanitize_string(word1)) == sorted(sanitize_string(word2)) def find_anagrams(word, candidates): Identifies all distinct anagrams of the given word within the nested candidate list. Only includes nested structures in the result and skips non-string elements. result = [] def check_anagrams(word, candidate_list): Inner recursive function to handle nested structures and gather anagrams sub_result = [] seen = set() for item in candidate_list: if isinstance(item, list): nested_result = check_anagrams(word, item) if nested_result: sub_result.append(nested_result) elif isinstance(item, str): sanitized_item = sanitize_string(item) if item not in seen and is_anagram(word, item): sub_result.append(sanitized_item) seen.add(item) return sub_result # Initiating the check process anagrams = check_anagrams(word, candidates) return anagrams # Example Usage word = \\"listen\\" candidates = [\\"enlists\\", \\"google\\", \\"inlets\\", \\"banana\\", [\\"Silent\\", \\"LISTEN\\"], \\"tinsel\\", [None, \\"Listen\\"]] print(find_anagrams(word, candidates))"},{"question":"def group_people_by_city(people: list) -> dict: Groups people by their city. Parameters: people (list of dict): A list of dictionaries where each dictionary contains 'name', 'age', and 'city'. Returns: dict: A dictionary with city names as keys and lists of the names of people in those cities as values. Example: >>> group_people_by_city([{'name': 'Alice', 'age': 30, 'city': 'New York'}, {'name': 'Bob', 'age': 25, 'city': 'San Francisco'}, {'name': 'Charlie', 'age': 35, 'city': 'New York'}]) {'New York': ['Alice', 'Charlie'], 'San Francisco': ['Bob']} >>> group_people_by_city([{'name': 'Alice', 'age': 30}, {'name': 'Bob', 'age': 25, 'city': 'San Francisco'}, {'name': 'Charlie', 'age': 35, 'city': 'New York'}]) {'Unknown': ['Alice'], 'San Francisco': ['Bob'], 'New York': ['Charlie']} >>> group_people_by_city([{'name': 'Alice', 'age': 30}, {'name': 'Bob', 'age': 25}, {'name': 'Charlie', 'age': 35}]) {'Unknown': ['Alice', 'Bob', 'Charlie']} >>> group_people_by_city([]) {} pass import pytest def test_group_people_by_city_all_present(): people = [ {'name': 'Alice', 'age': 30, 'city': 'New York'}, {'name': 'Bob', 'age': 25, 'city': 'San Francisco'}, {'name': 'Charlie', 'age': 35, 'city': 'New York'}, ] expected = { 'New York': ['Alice', 'Charlie'], 'San Francisco': ['Bob'] } assert group_people_by_city(people) == expected def test_group_people_by_city_missing_city(): people = [ {'name': 'Alice', 'age': 30}, {'name': 'Bob', 'age': 25, 'city': 'San Francisco'}, {'name': 'Charlie', 'age': 35, 'city': 'New York'}, ] expected = { 'Unknown': ['Alice'], 'San Francisco': ['Bob'], 'New York': ['Charlie'] } assert group_people_by_city(people) == expected def test_group_people_by_city_all_unknown(): people = [ {'name': 'Alice', 'age': 30}, {'name': 'Bob', 'age': 25}, {'name': 'Charlie', 'age': 35}, ] expected = { 'Unknown': ['Alice', 'Bob', 'Charlie'] } assert group_people_by_city(people) == expected def test_group_people_by_city_no_people(): people = [] expected = {} assert group_people_by_city(people) == expected def test_invalid_input_not_list(): with pytest.raises(TypeError): group_people_by_city(\\"not a list\\") def test_invalid_input_element_not_dict(): with pytest.raises(TypeError): group_people_by_city([{'name': 'Alice', 'age': 30}, \\"not a dict\\"]) def test_invalid_input_missing_name(): with pytest.raises(ValueError): group_people_by_city([{'age': 30, 'city': 'New York'}]) def test_invalid_input_missing_age(): with pytest.raises(ValueError): group_people_by_city([{'name': 'Alice', 'city': 'New York'}]) def test_invalid_input_name_not_string(): with pytest.raises(ValueError): group_people_by_city([{'name': 123, 'age': 30, 'city': 'New York'}]) def test_invalid_input_age_not_number(): with pytest.raises(ValueError): group_people_by_city([{'name': 'Alice', 'age': 'thirty', 'city': 'New York'}])","solution":"def group_people_by_city(people): Groups people by their city. Parameters: people (list of dict): A list of dictionaries where each dictionary contains 'name', 'age', and 'city'. Returns: dict: A dictionary with city names as keys and lists of the names of people in those cities as values. if not isinstance(people, list): raise TypeError(\\"Input should be a list of dictionaries.\\") result = {} for person in people: if not isinstance(person, dict): raise TypeError(\\"All elements in the list should be dictionaries.\\") if 'name' not in person or 'age' not in person or not isinstance(person['name'], str) or not isinstance(person['age'], (int, float)): raise ValueError(\\"Each dictionary must contain 'name' as a string and 'age' as a number.\\") city = person.get('city', 'Unknown') if city not in result: result[city] = [] result[city].append(person['name']) return result"},{"question":"def cumulative_product(lst, start=None, end=None): Returns a list where each element is the cumulative product of the elements up to that index in the original list. Optionally calculates the cumulative product only within a specified range. Parameters: lst (list): List of integers start (int): Optional, start index for the range to be considered end (int): Optional, end index for the range to be considered Returns: list: List with cumulative product >>> cumulative_product([1, 2, 3, 4]) [1, 2, 6, 24] >>> cumulative_product([1, 2, 3, 4], 1, 3) [1, 2, 6, 4] >>> cumulative_product([1, -2, -3, 4]) [1, -2, 6, 24] >>> cumulative_product([1, 1, 1, 1]) [1, 1, 1, 1] >>> cumulative_product([1, 0, 3, 4]) [1, 0, 0, 0] >>> cumulative_product([5]) [5] >>> cumulative_product([]) []","solution":"def cumulative_product(lst, start=None, end=None): Returns a list where each element is the cumulative product of the elements up to that index in the original list. Optionally calculates the cumulative product only within a specified range. Parameters: lst (list): List of integers start (int): Optional, start index for the range to be considered end (int): Optional, end index for the range to be considered Returns: list: List with cumulative product # Validate input list if not isinstance(lst, list): raise ValueError(\\"Input must be a list\\") for item in lst: if not isinstance(item, int): raise ValueError(\\"All elements in the list must be integers\\") # Set default range if not provided if start is None: start = 0 if end is None: end = len(lst) # Validate range if start < 0 or end > len(lst) or start > end: raise ValueError(\\"Invalid range specified\\") # Calculate cumulative product result = lst.copy() product = 1 for i in range(start, end): product *= lst[i] result[i] = product return result"},{"question":"import json def pretty_json(json_str: str) -> str: Takes a JSON string and returns a prettified version of the JSON with proper indentation. Parameters: json_str (str): A string representing JSON data. Returns: str: Prettified JSON string. try: # Parse the JSON string to a Python dictionary json_obj = json.loads(json_str) # Convert the Python dictionary back to a JSON string with proper indentation except json.JSONDecodeError: return \\"Invalid JSON string\\" def test_pretty_json_simple_object(): input_json = '{\\"name\\":\\"John\\",\\"age\\":30}' expected_output = '''{ \\"name\\": \\"John\\", \\"age\\": 30 }''' assert pretty_json(input_json) == expected_output def test_pretty_json_nested_object(): input_json = '{\\"person\\":{\\"name\\":\\"John\\",\\"age\\":30}}' expected_output = '''{ \\"person\\": { \\"name\\": \\"John\\", \\"age\\": 30 } }''' assert pretty_json(input_json) == expected_output def test_pretty_json_array(): input_json = '{\\"children\\":[\\"Anna\\",\\"Ella\\"]}' expected_output = '''{ \\"children\\": [ \\"Anna\\", \\"Ella\\" ] }''' assert pretty_json(input_json) == expected_output def test_pretty_json_mixed_elements(): input_json = '{\\"name\\":\\"John\\",\\"age\\":30,\\"city\\":\\"New York\\",\\"hasLicense\\":true,\\"children\\":[\\"Anna\\",\\"Ella\\"]}' expected_output = '''{ \\"name\\": \\"John\\", \\"age\\": 30, \\"city\\": \\"New York\\", \\"hasLicense\\": true, \\"children\\": [ \\"Anna\\", \\"Ella\\" ] }''' assert pretty_json(input_json) == expected_output def test_pretty_json_invalid_string(): input_json = 'invalid JSON' assert pretty_json(input_json) == \\"Invalid JSON string\\"","solution":"import json def pretty_json(json_str): Takes a JSON string and returns a prettified version of the JSON with proper indentation. Parameters: json_str (str): A string representing JSON data. Returns: str: Prettified JSON string. try: # Parse the JSON string to a Python dictionary json_obj = json.loads(json_str) # Convert the Python dictionary back to a JSON string with proper indentation pretty_str = json.dumps(json_obj, indent=2) return pretty_str except json.JSONDecodeError: return \\"Invalid JSON string\\""},{"question":"def factorial(n): Returns the factorial of a non-negative integer n using an iterative approach. >>> factorial(0) == 1 >>> factorial(1) == 1 >>> factorial(4) == 24 >>> factorial(10) == 3628800 >>> try: ... factorial(-1) ... except ValueError as e: ... assert str(e) == \\"Factorial is not defined for negative integers\\" # To Do: Implement the iterative approach here pass","solution":"def factorial(n): Returns the factorial of a non-negative integer n using an iterative approach. if n < 0: raise ValueError(\\"Factorial is not defined for negative integers\\") result = 1 for i in range(2, n + 1): result *= i return result"},{"question":"from typing import List def next_greater_elements(arr: List[int]) -> List[int]: Write a function that takes an unsorted list of integers and returns a list containing the next greater element for each element in the input list. The next greater element for a number \`x\` is the first greater number to its right in the list. If such a number does not exist, output -1 for that number. >>> next_greater_elements([4, 5, 2, 25]) [5, 25, 25, -1] >>> next_greater_elements([13, 7, 6, 12]) [-1, 12, 12, -1] pass def test_next_greater_elements_1(): assert next_greater_elements([4, 5, 2, 25]) == [5, 25, 25, -1] def test_next_greater_elements_2(): assert next_greater_elements([13, 7, 6, 12]) == [-1, 12, 12, -1] def test_next_greater_elements_single_element(): assert next_greater_elements([7]) == [-1] def test_next_greater_elements_all_same(): assert next_greater_elements([5, 5, 5, 5]) == [-1, -1, -1, -1] def test_next_greater_elements_increasing_order(): assert next_greater_elements([1, 2, 3, 4]) == [2, 3, 4, -1] def test_next_greater_elements_decreasing_order(): assert next_greater_elements([4, 3, 2, 1]) == [-1, -1, -1, -1] def test_next_greater_elements_mixed(): assert next_greater_elements([2, 1, 2, 4, 3]) == [4, 2, 4, -1, -1]","solution":"from typing import List def next_greater_elements(arr: List[int]) -> List[int]: Returns a list of the next greater elements for each element in the input list. result = [-1] * len(arr) stack = [] for i in range(len(arr)): while stack and arr[stack[-1]] < arr[i]: index = stack.pop() result[index] = arr[i] stack.append(i) return result"},{"question":"def factorial(n): Computes the factorial of a non-negative integer n using recursion. Args: n (int): A non-negative integer whose factorial is to be computed. Returns: int: The factorial of n. Example: >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(5) 120 >>> factorial(4) 24 >>> factorial(3) 6 >>> factorial(2) 2 >>> factorial(10) 3628800 # Your implementation goes here","solution":"def factorial(n): Computes the factorial of a non-negative integer n. Args: n (int): A non-negative integer whose factorial is to be computed. Returns: int: The factorial of n. # Base case: factorial of 0 is 1 if n == 0: return 1 # Recursive case: n! = n * (n-1)! else: return n * factorial(n - 1)"},{"question":"def minimum_jumps(arr): Determines the minimum number of jumps needed to reach the end of the array. Parameters: arr (list): List of non-negative integers representing the maximum number of steps that can be jumped forward from that position. Returns: int: The minimum number of jumps to reach the end, or -1 if it's not possible. >>> minimum_jumps([2, 3, 1, 1, 4]) 2 >>> minimum_jumps([3, 2, 1, 0, 4]) -1 >>> minimum_jumps([1, 1, 1, 1, 1]) 4 >>> minimum_jumps([10, 1, 1, 1, 1]) 1 >>> minimum_jumps([0]) 0 >>> minimum_jumps([1] * 1000) 999 >>> minimum_jumps([2] * 500) 250 >>> minimum_jumps([0, 2, 3]) -1","solution":"def minimum_jumps(arr): Determines the minimum number of jumps needed to reach the end of the array. Parameters: arr (list): List of non-negative integers representing the maximum number of steps that can be jumped forward from that position. Returns: int: The minimum number of jumps to reach the end, or -1 if it's not possible. if len(arr) == 1: return 0 jumps = 0 farthest = 0 end = 0 for i in range(len(arr) - 1): farthest = max(farthest, i + arr[i]) if i == end: jumps += 1 end = farthest if end >= len(arr) - 1: return jumps return -1"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression represented as a string. The expression can contain integers, basic operations (+, -, *, /), and parentheses. It also handles spaces around the operators, numbers, and parentheses. >>> evaluate_expression(\\" ( 2 + 3 ) * 4 - 5 / ( 1 + 1 ) \\") 17 >>> evaluate_expression(\\"4 * (3 - 2)\\") 4","solution":"def evaluate_expression(expression): Evaluates a mathematical expression represented as a string. The expression can contain integers, basic operations (+, -, *, /), and parentheses. It also handles spaces around the operators, numbers, and parentheses. def parse_expression(expr): import re tokens = re.findall(r'd+|[-+*/()]', expr.replace(' ', '')) def next_token(): return tokens.pop(0) if tokens else None def parse_term(): token = next_token() if token == '(': result = parse_expression() assert next_token() == ')' return result return int(token) def parse_factor(): result = parse_term() while tokens and tokens[0] in '*/': op = next_token() if op == '*': result *= parse_term() elif op == '/': result /= parse_term() return result def parse_expression(): result = parse_factor() while tokens and tokens[0] in '+-': op = next_token() if op == '+': result += parse_factor() elif op == '-': result -= parse_factor() return result return parse_expression() return parse_expression(expression)"},{"question":"import datetime class ATM: def __init__(self): Initializes the ATM with a starting balance of zero and an empty transaction history. self.balance = 0.0 self.transaction_history = [] def check_balance(self) -> float: Returns the current balance. >>> atm = ATM() >>> atm.check_balance() 0.0 pass def deposit_money(self, amount: float) -> float: Deposits the specified amount into the ATM and records the transaction. >>> atm = ATM() >>> atm.deposit_money(100.0) 100.0 pass def withdraw_money(self, amount: float) -> float: Withdraws the specified amount from the ATM if sufficient funds are available and records the transaction. >>> atm = ATM() >>> atm.deposit_money(100.0) >>> atm.withdraw_money(50.0) 50.0 pass def view_transaction_history(self) -> list: Returns the transaction history. >>> atm = ATM() >>> atm.deposit_money(100.0) >>> atm.withdraw_money(50.0) >>> len(atm.view_transaction_history()) 2 pass","solution":"import datetime class ATM: def __init__(self): self.balance = 0.0 self.transaction_history = [] def check_balance(self): Returns the current balance. return self.balance def deposit_money(self, amount): Deposits the specified amount into the ATM and records the transaction. if amount <= 0: raise ValueError(\\"Deposit amount must be greater than zero\\") self.balance += amount self.transaction_history.append({ 'timestamp': datetime.datetime.now(), 'transaction_type': 'Deposit', 'amount': amount }) return self.balance def withdraw_money(self, amount): Withdraws the specified amount from the ATM if sufficient funds are available and records the transaction. if amount <= 0: raise ValueError(\\"Withdrawal amount must be greater than zero\\") if amount > self.balance: raise ValueError(\\"Insufficient funds\\") self.balance -= amount self.transaction_history.append({ 'timestamp': datetime.datetime.now(), 'transaction_type': 'Withdrawal', 'amount': amount }) return self.balance def view_transaction_history(self): Returns the transaction history. return self.transaction_history # Command-line interface is excluded as it is not testable via unit tests"},{"question":"def is_prime(n: int) -> bool: Determines if a given number n is prime. Args: - n (int): The number to check for primality. Returns: - bool: True if n is prime, False otherwise. pass def prime_dict(numbers: list) -> dict: Returns a dictionary with unique integers from the input list as keys, and their primality (True/False) as values. Filters out non-integer elements. Args: - numbers (list): List of integers. Returns: - dict: Dictionary with integer keys and boolean values indicating primality. pass # Unit Tests def test_prime_dict_with_mixed_elements(): numbers = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 'a', 15] expected_output = { 2: True, 3: True, 4: False, 5: True, 6: False, 7: True, 8: False, 9: False, 10: False, 11: True, 12: False, 15: False } assert prime_dict(numbers) == expected_output def test_prime_dict_with_all_primes(): numbers = [2, 3, 5, 7, 11, 13, 17, 19] expected_output = {number: True for number in numbers} assert prime_dict(numbers) == expected_output def test_prime_dict_with_non_integers(): numbers = [2, 'three', 4, 5.5, 7, None, {}, 11] expected_output = { 2: True, 4: False, 7: True, 11: True } assert prime_dict(numbers) == expected_output def test_prime_dict_with_negative_and_zero(): numbers = [-1, 0, 1, 2, 3, 4, 5] expected_output = { -1: False, 0: False, 1: False, 2: True, 3: True, 4: False, 5: True } assert prime_dict(numbers) == expected_output def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(17) == True assert is_prime(18) == False assert is_prime(1) == False assert is_prime(0) == False assert is_prime(-3) == False","solution":"def is_prime(n): Determines if a given number n is prime. Args: - n (int): The number to check for primality. Returns: - bool: True if n is prime, False otherwise. if n <= 1: return False if n == 2: return True # 2 is the only even prime number if n % 2 == 0: return False # No other even number can be prime for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def prime_dict(numbers): Returns a dictionary with unique integers from the input list as keys, and their primality (True/False) as values. Filters out non-integer elements. Args: - numbers (list): List of integers. Returns: - dict: Dictionary with integer keys and boolean values indicating primality. result = {} for number in numbers: if isinstance(number, int): result[number] = is_prime(number) return result"},{"question":"def can_partition_k_subsets(nums, k): Determine if an array can be partitioned into k non-overlapping subarrays with equal sums. Args: nums (List[int]): The list of integers. k (int): Number of subarrays. Returns: bool: True if the array can be partitioned into k subarrays with equal sums, False otherwise. Example: >>> can_partition_k_subsets([4, 3, 2, 3, 5, 2, 1], 4) True >>> can_partition_k_subsets([1, 2, 3, 4], 3) False def test_can_partition_k_subsets(): assert can_partition_k_subsets([4, 3, 2, 3, 5, 2, 1], 4) == True assert can_partition_k_subsets([1, 2, 3, 4], 3) == False assert can_partition_k_subsets([2, 2, 2, 2, 3, 3, 3, 3], 4) == True assert can_partition_k_subsets([1], 1) == True assert can_partition_k_subsets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], 8) == True assert can_partition_k_subsets([1, 1, 1, 1], 2) == True assert can_partition_k_subsets([1, 1, 1, 1, 2, 2, 2, 2], 4) == True assert can_partition_k_subsets([2, 2, 2, 2], 3) == False assert can_partition_k_subsets([10] * 16, 16) == True assert can_partition_k_subsets([10] * 16, 1) == True assert can_partition_k_subsets([10, 15, 15, 5, 5], 2) == True","solution":"def can_partition_k_subsets(nums, k): Determine if an array can be partitioned into k non-overlapping subarrays with equal sums. Args: nums (List[int]): The list of integers. k (int): Number of subarrays. Returns: bool: True if the array can be partitioned into k subarrays with equal sums, False otherwise. total_sum = sum(nums) if total_sum % k != 0: return False target = total_sum // k nums.sort(reverse=True) used = [False] * len(nums) def backtrack(start_index, current_sum, k): if k == 1: return True if current_sum == target: return backtrack(0, 0, k - 1) for i in range(start_index, len(nums)): if not used[i] and current_sum + nums[i] <= target: used[i] = True if backtrack(i + 1, current_sum + nums[i], k): return True used[i] = False return False return backtrack(0, 0, k)"},{"question":"import re from typing import List def extract_unique_words(strings: List[str]) -> List[str]: Takes a list of strings and returns a list of unique words found in the strings, ignoring case and excluding punctuation. :param strings: List of strings :return: List of unique words Examples: >>> set(extract_unique_words([\\"Hello, world!\\", \\"Hello again, world.\\"])) {'hello', 'world', 'again'} >>> set(extract_unique_words([\\"Hello, WORLD!\\", \\"hello AGAIN, World.\\"])) {'hello', 'world', 'again'} pass def test_extract_unique_words_basic(): assert set(extract_unique_words([\\"Hello, world!\\", \\"Hello again, world.\\"])) == {\\"hello\\", \\"world\\", \\"again\\"} def test_extract_unique_words_mixed_case(): assert set(extract_unique_words([\\"Hello, WORLD!\\", \\"hello AGAIN, World.\\"])) == {\\"hello\\", \\"world\\", \\"again\\"} def test_extract_unique_words_with_punctuation(): assert set(extract_unique_words([\\"A quick brown-fox jumps over the lazy dog!\\", \\"Lazy, dog.\\"])) == { \\"a\\", \\"quick\\", \\"brown\\", \\"fox\\", \\"jumps\\", \\"over\\", \\"the\\", \\"lazy\\", \\"dog\\"} def test_extract_unique_words_no_repeats(): assert set(extract_unique_words([\\"One sentence.\\", \\"Another sentence.\\", \\"Yet another sentence.\\"])) == { \\"one\\", \\"sentence\\", \\"another\\", \\"yet\\"} def test_extract_unique_words_empty_string(): assert extract_unique_words([\\"\\"]) == [] def test_extract_unique_words_empty_list(): assert extract_unique_words([]) == [] def test_extract_unique_words_non_list_input(): try: extract_unique_words(\\"This is a string\\") except ValueError as e: assert str(e) == \\"Input must be a list of strings.\\" def test_extract_unique_words_non_string_element_in_list(): try: extract_unique_words([\\"This is fine\\", 123]) except ValueError as e: assert str(e) == \\"All elements in the list must be strings.\\"","solution":"import re def extract_unique_words(strings): Takes a list of strings and returns a list of unique words found in the strings, ignoring case and excluding punctuation. :param strings: List of strings :return: List of unique words if not isinstance(strings, list): raise ValueError(\\"Input must be a list of strings.\\") if not all(isinstance(s, str) for s in strings): raise ValueError(\\"All elements in the list must be strings.\\") unique_words_set = set() for s in strings: words = re.findall(r'bw+b', s.lower()) unique_words_set.update(words) return list(unique_words_set)"},{"question":"class BankAccount: A class to mimic basic banking operations. Attributes: account_number (str): The account number of the bank account. holder_name (str): The name of the account holder. balance (float): The balance of the bank account. Methods: deposit(amount): Adds the specified amount to the balance. withdraw(amount): Deducts the specified amount from the balance if sufficient balance is available. getBalance(): Returns the current balance. def __init__(self, account_number, holder_name, balance): self.account_number = account_number self.holder_name = holder_name self.balance = balance def deposit(self, amount): Adds the specified \`amount\` to the \`balance\`. pass def withdraw(self, amount): Deducts the specified \`amount\` from the \`balance\` if sufficient balance is available. pass def getBalance(self): Returns the current \`balance\`. pass","solution":"class BankAccount: def __init__(self, account_number, holder_name, balance): self.account_number = account_number self.holder_name = holder_name self.balance = balance def deposit(self, amount): self.balance += amount def withdraw(self, amount): if self.balance < amount: print(\\"Insufficient funds\\") else: self.balance -= amount def getBalance(self): return self.balance"},{"question":"def group_anagrams(words): Groups all anagrams together from the given list of words. Args: words (list): List of lowercase alphabet words. Returns: List[List[str]]: List of lists where each inner list contains anagrams. >>> group_anagrams([\\"bat\\", \\"tab\\", \\"cat\\", \\"act\\", \\"rat\\", \\"tar\\", \\"car\\"]) == [ [\\"bat\\", \\"tab\\"], [\\"cat\\", \\"act\\"], [\\"rat\\", \\"tar\\"], [\\"car\\"] ]","solution":"def group_anagrams(words): Groups all anagrams together from the given list of words. Args: words (list): List of lowercase alphabet words. Returns: List[List[str]]: List of lists where each inner list contains anagrams. anagrams = {} for word in words: sorted_word = ''.join(sorted(word)) if sorted_word in anagrams: anagrams[sorted_word].append(word) else: anagrams[sorted_word] = [word] return list(anagrams.values())"},{"question":"from typing import List, Tuple def calculate_subtree_strength(N: int, A: List[int], edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: Calculate the strength of the subtrees rooted at the queried nodes. :param N: An integer representing the number of nodes in the tree. :param A: A list of integers representing the strengths associated with each node. :param edges: A list of tuples where each tuple represents an edge between two nodes. :param queries: A list of integers representing the nodes for which to calculate subtree strengths. :return: A list of integers where each integer is the strength of the subtree rooted at the corresponding queried node. Example: >>> N = 5 >>> A = [1, 2, 3, 4, 5] >>> edges = [(1, 2), (1, 3), (2, 4), (3, 5)] >>> queries = [1, 2, 3] >>> calculate_subtree_strength(N, A, edges, queries) [15, 6, 8]","solution":"from typing import List, Tuple, Dict def calculate_subtree_strength(N: int, A: List[int], edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: from collections import defaultdict, deque # Build the tree using adjacency list tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Strength map to store the strength of sub-trees strength_map = {} # Perform DFS to calculate the subtree strengths def dfs(node, parent): total_strength = A[node - 1] for child in tree[node]: if child != parent: total_strength += dfs(child, node) strength_map[node] = total_strength return total_strength # Start DFS from the root node (1) dfs(1, -1) # Answer the queries result = [strength_map[x] for x in queries] return result"},{"question":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Complete the merge_sort function to implement the Merge Sort algorithm. Given an unsorted list of integers, the function should return the sorted list in ascending order using the Merge Sort algorithm. >>> merge_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] >>> merge_sort([-1, 6, 3, -5, 9, 0, 2]) [-5, -1, 0, 2, 3, 6, 9] >>> merge_sort([4, 5, 4, 3, 2, 7, 4]) [2, 3, 4, 4, 4, 5, 7] >>> merge_sort([-3, -1, -7, -2]) [-7, -3, -2, -1] >>> merge_sort([1]) [1] >>> merge_sort([]) [] >>> merge_sort([1, 2, 3, 4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sort([6, 5, 4, 3, 2, 1]) [1, 2, 3, 4, 5, 6]","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] i, j = 0, 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 # Append remaining elements sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate the arithmetic expression consisting of addition and subtraction without using the eval() function. >>> evaluate_expression(\\"3 + 5 - 2\\") 6 >>> evaluate_expression(\\"10 - 3 + 8\\") 15 >>> evaluate_expression(\\"7 + 8 - 4 + 2 - 5\\") 8 # Your code here pass","solution":"def evaluate_expression(expression: str) -> int: Evaluate the arithmetic expression consisting of addition and subtraction without using the eval() function. tokens = expression.split() total = 0 current_sign = 1 # 1 for positive, -1 for negative for token in tokens: if token == '+': current_sign = 1 elif token == '-': current_sign = -1 else: # token is a number total += current_sign * int(token) return total"},{"question":"from typing import List def numIslands(grid: List[List[str]]) -> int: Given a 2D grid of size m x n representing an island map, count the number of distinct islands. An island is surrounded by water and is formed by connecting adjacent '1's horizontally or vertically. Assume all four edges of the grid are surrounded by water. Examples: >>> numIslands([ [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"1\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"] ]) 1 >>> numIslands([ [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ]) 3 Test cases: >>> numIslands([ [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"1\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"] ]) 1 >>> numIslands([ [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ]) 3 >>> numIslands([ [\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\"] ]) 0 >>> numIslands([ [\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\"] ]) 1 >>> numIslands([ [\\"0\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\"] ]) 1 >>> numIslands([]) 0","solution":"def numIslands(grid): if not grid: return 0 def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0': return grid[i][j] = '0' dfs(grid, i+1, j) dfs(grid, i-1, j) dfs(grid, i, j+1) dfs(grid, i, j-1) count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': count += 1 dfs(grid, i, j) return count"},{"question":"import re from collections import Counter def word_count(sentence: str) -> dict: Takes a string input and returns a dictionary with each unique word as key and the number of times it appears as value. Disregards case sensitivity and punctuation. >>> word_count(\\"Hello, hello! How are you?\\") {'hello': 2, 'how': 1, 'are': 1, 'you': 1} >>> word_count(\\"Test 123, test !@# TEST\\") {'test': 3, '123': 1} >>> word_count(\\"\\") {} >>> word_count(\\"Mixed-case, Mixed-CASE.\\") {'mixedcase': 2} pass","solution":"import re from collections import Counter def word_count(sentence): Takes a string input and returns a dictionary with each unique word as key and the number of times it appears as value. Disregards case sensitivity and punctuation. # Normalize the sentence to lower case and remove punctuation sentence = re.sub(r'[^ws]', '', sentence.lower()) words = sentence.split() return dict(Counter(words))"},{"question":"import numpy as np import matplotlib.pyplot as plt from typing import List, Tuple def normalize_ratios(ratios: List[float]) -> List[float]: Normalize a list of ratios so that they sum to 1. def blend_colors(primary_colors: List[Tuple[int, int, int]], blending_ratios: List[List[float]]) -> List[Tuple[int, int, int]]: Blend the primary colors based on the blending ratios. >>> blend_colors([(255, 0, 0), (0, 255, 0), (0, 0, 255)], [[1/3, 1/3, 1/3], [1, 0, 0], [0, 1, 0], [0, 0, 1]]) [(85, 85, 85), (255, 0, 0), (0, 255, 0), (0, 0, 255)] >>> blend_colors([(255, 0, 0), (0, 300, 0)], [[0.5, 0.5]]) ValueError: Invalid color value >>> blend_colors([(255, 0, 0), (0, 255, 0)], [[1, -0.5]]) ValueError: Invalid blending ratio >>> blend_colors([], [[0.5, 0.5]]) ValueError: Empty input >>> blend_colors([(255, 0, 0), (0, 255, 0)], [[0.5]]) ValueError: Mismatch in number of primary colors and ratios def visualize_colors(colors: List[Tuple[int, int, int]], title: str = \\"Color Palette\\"): Visualize the list of RGB colors using matplotlib.","solution":"import numpy as np import matplotlib.pyplot as plt def normalize_ratios(ratios): Normalize a list of ratios so that they sum to 1. total = sum(ratios) if total == 0 or any(r < 0 for r in ratios): raise ValueError(\\"Invalid blending ratio\\") return [r / total for r in ratios] def blend_colors(primary_colors, blending_ratios): Blend the primary colors based on the blending ratios. if not primary_colors or not blending_ratios: raise ValueError(\\"Empty input\\") num_colors = len(primary_colors) for color in primary_colors: if any(c < 0 or c > 255 for c in color): raise ValueError(\\"Invalid color value\\") blended_colors = [] for ratios in blending_ratios: ratios = normalize_ratios(ratios) if len(ratios) != num_colors: raise ValueError(\\"Mismatch in number of primary colors and ratios\\") r = sum(ratios[i] * primary_colors[i][0] for i in range(num_colors)) g = sum(ratios[i] * primary_colors[i][1] for i in range(num_colors)) b = sum(ratios[i] * primary_colors[i][2] for i in range(num_colors)) blended_colors.append((round(r), round(g), round(b))) return blended_colors def visualize_colors(colors, title=\\"Color Palette\\"): Visualize the list of RGB colors using matplotlib. num_colors = len(colors) plt.figure(figsize=(num_colors, 1)) plt.imshow([colors], aspect='auto') plt.title(title) plt.axis('off') plt.show()"},{"question":"def is_palindrome(s): Check if a given string is a valid palindrome, ignoring spaces, punctuation, and case sensitivity. >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") == True >>> is_palindrome(\\"No 'x' in Nixon\\") == True >>> is_palindrome(\\"This is not a palindrome\\") == False >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"Madam\\") == True >>> is_palindrome(\\"RaCeCaR\\") == True >>> is_palindrome(12345) == \\"Input is not a string\\" >>> is_palindrome([1, 2, 3, 2, 1]) == \\"Input is not a string\\" >>> is_palindrome(\\"!!!\\") == True >>> is_palindrome(\\" . , \\") == True","solution":"import string def is_palindrome(s): Check if a given string is a valid palindrome, ignoring spaces, punctuation, and case sensitivity. Args: s (str): The string to check. Returns: bool: True if the input string is a palindrome, False otherwise. if not isinstance(s, str): return \\"Input is not a string\\" # Remove spaces, punctuation and convert to lower case s = ''.join(char.lower() for char in s if char.isalnum()) # Check if the string is equal to its reverse return s == s[::-1]"},{"question":"from collections import deque def bfs(graph, start_vertex): Performs BFS traversal on a graph represented as an adjacency list. :param graph: Dictionary representing the adjacency list of the graph :param start_vertex: The starting vertex for the BFS traversal :return: List of vertices in the order they are visited during BFS BFS Overview: - BFS starts at the given starting vertex and explores all its neighboring vertices at the present depth level before moving on to vertices at the next depth level. - Utilize a queue to keep track of vertices to visit and a set to mark visited vertices to avoid visiting the same vertex multiple times. Edge Cases: - If the graph is empty, return an empty list. - If the starting vertex is not in the graph, return an empty list. Example: >>> bfs({'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}, 'A') ['A', 'B', 'C', 'D', 'E', 'F'] >>> bfs({'A': []}, 'A') ['A'] >>> bfs({}, 'A') [] >>> bfs({'A': ['B'], 'B': ['A'], 'C': ['D'], 'D': ['C']}, 'A') ['A', 'B'] >>> bfs({'A': ['B'], 'B': ['A'], 'C': ['D'], 'D': ['C']}, 'E') []","solution":"from collections import deque def bfs(graph, start_vertex): Performs BFS traversal on a graph represented as an adjacency list. :param graph: Dictionary representing the adjacency list of the graph :param start_vertex: The starting vertex for the BFS traversal :return: List of vertices in the order they are visited during BFS if start_vertex not in graph: return [] visited = set() queue = deque([start_vertex]) bfs_order = [] while queue: vertex = queue.popleft() if vertex not in visited: visited.add(vertex) bfs_order.append(vertex) # Enqueue all adjacent vertices that haven't been visited queue.extend([neighbor for neighbor in graph[vertex] if neighbor not in visited]) return bfs_order"},{"question":"def longest_strictly_increasing_subsequence(lst): Finds the length of the longest subsequence where the difference between consecutive integers is strictly increasing. >>> longest_strictly_increasing_subsequence([1, 2, 3, 6, 7, 8, 3, 2]) 6 >>> longest_strictly_increasing_subsequence([]) 0 >>> longest_strictly_increasing_subsequence([5]) 1 >>> longest_strictly_increasing_subsequence([1, 2, 3, 4, 5, 6, 7, 8]) 8 >>> longest_strictly_increasing_subsequence([8, 7, 6, 5, 4, 3, 2, 1]) 1 >>> longest_strictly_increasing_subsequence([5, 1, 2, 3, 1, 2, 3, 4, 0, 1, 2, 3]) 4 >>> longest_strictly_increasing_subsequence([1, 3, 2, 4, 3, 5, 2, 6]) 2","solution":"def longest_strictly_increasing_subsequence(lst): Finds the length of the longest subsequence where the difference between consecutive integers is strictly increasing. if not lst: return 0 # Initialize variables max_length = 1 current_length = 1 for i in range(1, len(lst)): if lst[i] > lst[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"from typing import List, Dict from collections import Counter from datetime import datetime import pandas as pd from sklearn.feature_extraction.text import CountVectorizer, TfidfTransformer from sklearn.decomposition import LatentDirichletAllocation def preprocess_text(text: str) -> str: Preprocess the input text by removing special characters, links, and converting to lowercase. Args: text (str): The input text to preprocess. Returns: str: The processed text. >>> preprocess_text(\\"Check this out! http://example.com\\") 'check this out' >>> preprocess_text(\\"Amazing! #test @user\\") 'amazing test user' >>> preprocess_text(\\"123 abc def#ghi\\") 'abc defghi' pass def extract_hashtags(text: str) -> List[str]: Extract hashtags from the text and return them as a list of strings. Args: text (str): The input text containing hashtags. Returns: List[str]: List of extracted hashtag strings. >>> extract_hashtags(\\"Loving the #sunset #beautiful #love\\") ['sunset', 'beautiful', 'love'] >>> extract_hashtags(\\"No hashtags here!\\") [] >>> extract_hashtags(\\"#start #middle #end\\") ['start', 'middle', 'end'] pass def analyze_trends(data: List[Dict[str, datetime]]) -> Dict[str, int]: Analyze trends from the social media data. Args: data (list of dicts): List where each dict contains 'text' (str) and 'timestamp' (datetime). Returns: dict: Dictionary of trending topics with their associated scores. pass","solution":"import re from collections import Counter from datetime import datetime import pandas as pd from sklearn.feature_extraction.text import CountVectorizer, TfidfTransformer from sklearn.decomposition import LatentDirichletAllocation def preprocess_text(text): Preprocess the input text by removing special characters, links, and converting to lowercase. text = re.sub(r\\"httpS+\\", \\"\\", text) text = re.sub(r\\"[^a-zA-Zs]\\", \\"\\", text) text = text.lower().strip() return text def extract_hashtags(text): Extract hashtags from the text. return re.findall(r\\"#(w+)\\", text) def analyze_trends(data): Analyze trends from the social media data. Args: data (list of dicts): List where each dict contains 'text' (str) and 'timestamp' (datetime). Returns: dict: Dictionary of trending topics with their associated scores. # Preprocess texts and extract hashtags texts = [preprocess_text(item['text']) for item in data] hashtags = [extract_hashtags(item['text']) for item in data] timestamps = [item['timestamp'] for item in data] # Flatten the list of hashtags all_hashtags = [hashtag for sublist in hashtags for hashtag in sublist] # Calculate frequency of hashtags hashtag_counter = Counter(all_hashtags) # Use CountVectorizer to transform texts into frequency matrix vectorizer = CountVectorizer(stop_words='english') dtm = vectorizer.fit_transform(texts) # Use TF-IDF to transform the frequency matrix tfidf_transformer = TfidfTransformer() dtm_tfidf = tfidf_transformer.fit_transform(dtm) # Use Latent Dirichlet Allocation to find topics lda = LatentDirichletAllocation(n_components=5, random_state=42) lda.fit(dtm_tfidf) # Get trending topics feature_names = vectorizer.get_feature_names_out() trending_topics = {} for topic_idx, topic in enumerate(lda.components_): trend_score = sum([hashtag_counter[feature_names[i]] for i in topic.argsort()[:-11:-1] if feature_names[i] in hashtag_counter]) trending_topics[f\\"Topic {topic_idx}\\"] = trend_score return trending_topics"},{"question":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of a contiguous subarray using Kadane's algorithm. Parameters: nums (List[int]): A list of integers. Returns: int: The maximum sum of a contiguous subarray. Kadane's algorithm works by iterating through the array while keeping track of the maximum sum of the subarray ending at the current position in a variable (\`current_max\`). It also maintains the global maximum sum seen so far (\`global_max\`). For each element in the array, you update \`current_max\` to be the maximum of the current element and \`current_max + current element\`. If \`current_max\` exceeds \`global_max\`, you update \`global_max\`. Time Complexity: O(n), where n is the number of elements in the array. Examples: >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_subarray_sum([1,2,3,4,5]) 15 >>> max_subarray_sum([-1,-2,-3,-4,-5]) -1 >>> max_subarray_sum([3,-1,4,-1,2,-6,5,3]) 9 >>> max_subarray_sum([5,4,-1,7,8]) 23","solution":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of a contiguous subarray using Kadane's algorithm. Parameters: nums (List[int]): A list of integers. Returns: int: The maximum sum of a contiguous subarray. if not nums: return 0 current_max = global_max = nums[0] for num in nums[1:]: current_max = max(num, current_max + num) if current_max > global_max: global_max = current_max return global_max"},{"question":"import csv from collections import defaultdict def compute_average_salary(csv_file_path): Reads a CSV file and computes the average salary of employees in each department. :param csv_file_path: Path to the CSV file containing employee records. :return: A dictionary where the keys are department names and the values are average salaries.","solution":"import csv from collections import defaultdict def compute_average_salary(csv_file_path): Reads a CSV file and computes the average salary of employees in each department. :param csv_file_path: Path to the CSV file containing employee records. :return: A dictionary where the keys are department names and the values are average salaries. department_salaries = defaultdict(list) try: with open(csv_file_path, mode='r') as file: csv_reader = csv.DictReader(file) for row in csv_reader: department = row[\\"department\\"] salary = float(row[\\"salary\\"]) department_salaries[department].append(salary) except FileNotFoundError: print(f\\"Error: File not found - {csv_file_path}\\") return {} except Exception as e: print(f\\"An error occurred: {e}\\") return {} average_salaries = {} for department, salaries in department_salaries.items(): average_salaries[department] = sum(salaries) / len(salaries) return average_salaries"},{"question":"from typing import List def length_of_LIS(nums: List[int]) -> int: Returns the length of the longest increasing subsequence (LIS) in the given list of integers. >>> length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_LIS([0, 1, 0, 3, 2, 3]) 4 >>> length_of_LIS([7, 7, 7, 7, 7]) 1","solution":"from typing import List def length_of_LIS(nums: List[int]) -> int: Returns the length of the longest increasing subsequence (LIS) in the given list of integers. if not nums: return 0 # Initialize the dp array, where dp[i] will be the length of the LIS ending at index i dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence will be the maximum value in dp return max(dp)"},{"question":"def is_point_in_sphere(x, y, z, r): Determines if a point (x, y, z) lies within or on a sphere centered at the origin with radius r. Args: x (float): x-coordinate of the point y (float): y-coordinate of the point z (float): z-coordinate of the point r (float): Radius of the sphere Returns: bool: True if the point is inside or on the sphere, False otherwise. Raises: TypeError: If any of the coordinates or the radius are not numeric. ValueError: If the radius is not positive.","solution":"def is_point_in_sphere(x, y, z, r): Determines if a point (x, y, z) lies within or on a sphere centered at the origin with radius r. Args: x (float): x-coordinate of the point y (float): y-coordinate of the point z (float): z-coordinate of the point r (float): Radius of the sphere Returns: bool: True if the point is inside or on the sphere, False otherwise. Raises: TypeError: If any of the coordinates or the radius are not numeric. ValueError: If the radius is not positive. if not all(isinstance(i, (int, float)) for i in (x, y, z, r)): raise TypeError(\\"All coordinates and the radius must be numeric values.\\") if r <= 0: raise ValueError(\\"The radius must be a positive value.\\") return (x**2 + y**2 + z**2) <= r**2"},{"question":"def flatten_with_depth(nested_list, N): Flattens a nested list of integers up to the specified depth. Args: nested_list (list): The nested list to be flattened. N (int): The depth to which the list should be flattened. Returns: list: A flattened list up to the depth N. >>> flatten_with_depth([1, [2, [3, [4]], 5], [6, 7]], 1) [1, 2, [3, [4]], 5, 6, 7] >>> flatten_with_depth([1, [2, [3, [4]], 5], [6, 7]], 2) [1, 2, 3, [4], 5, 6, 7] >>> flatten_with_depth([1, [2, [3, [4]], 5], [6, 7]], 3) [1, 2, 3, 4, 5, 6, 7] >>> flatten_with_depth([1, [2, [3, [4]], 5], [6, 7]], 5) [1, 2, 3, 4, 5, 6, 7] >>> flatten_with_depth([1, [2, [3, [4]], 5], [6, 7]], 0) [1, [2, [3, [4]], 5], [6, 7]] >>> flatten_with_depth([], 2) [] >>> flatten_with_depth([[1]], 1) [1] >>> flatten_with_depth([[1]], 0) [[1]]","solution":"def flatten_with_depth(nested_list, N): Flattens a nested list up to depth N. Args: nested_list (list): The nested list to be flattened. N (int): The depth to which the list should be flattened. Returns: list: A flattened list up to the depth N. def flatten(lst, depth): result = [] if depth > 0: for item in lst: if isinstance(item, list): result.extend(flatten(item, depth - 1)) else: result.append(item) else: result.extend(lst) return result return flatten(nested_list, N)"},{"question":"import re def extract_and_classify_ips(s: str) -> dict: Extracts valid IPv4 addresses from the input string and classifies them into private and public IP addresses. Args: s (str): Input string containing potential IP addresses. Returns: dict: A dictionary with keys \\"private\\" and \\"public\\", containing lists of respective classified IP addresses. >>> extract_and_classify_ips(\\"The IP address 192.168.1.1 is a private one, and 8.8.8.8 is public.\\") {'private': ['192.168.1.1'], 'public': ['8.8.8.8']} >>> extract_and_classify_ips(\\"Connection details: 10.0.0.1, 172.16.0.1, and 192.168.0.1.\\") {'private': ['10.0.0.1', '172.16.0.1', '192.168.0.1'], 'public': []} >>> extract_and_classify_ips(\\"Public servers: 8.8.4.4, 1.1.1.1, and 203.0.113.5.\\") {'private': [], 'public': ['8.8.4.4', '1.1.1.1', '203.0.113.5']} >>> extract_and_classify_ips(\\"Mixed IPs: 192.168.0.1, 8.8.8.8, 10.0.0.1, 8.8.4.4, and 172.31.0.1.\\") {'private': ['192.168.0.1', '10.0.0.1', '172.31.0.1'], 'public': ['8.8.8.8', '8.8.4.4']} >>> extract_and_classify_ips(\\"There are no IP addresses here.\\") {'private': [], 'public': []} >>> extract_and_classify_ips(\\"Invalid IPs with leading zeros: 192.168.001.001, 256.100.100.100.\\") {'private': [], 'public': []}","solution":"import re def extract_and_classify_ips(s): Extracts valid IPv4 addresses from the input string and classifies them into private and public IP addresses. Args: s (str): Input string containing potential IP addresses. Returns: dict: A dictionary with keys \\"private\\" and \\"public\\", containing lists of respective classified IP addresses. ip_pattern = re.compile(r'b(25[0-5]|2[0-4]d|1d{2}|d{1,2}).(25[0-5]|2[0-4]d|1d{2}|d{1,2}).(25[0-5]|2[0-4]d|1d{2}|d{1,2}).(25[0-5]|2[0-4]d|1d{2}|d{1,2})b') all_matches = ip_pattern.findall(s) ips = ['.'.join(match) for match in all_matches] private_ips = [] public_ips = [] for ip in ips: octets = list(map(int, ip.split('.'))) if (octets[0] == 10 or (octets[0] == 172 and 16 <= octets[1] <= 31) or (octets[0] == 192 and octets[1] == 168)): private_ips.append(ip) else: public_ips.append(ip) return {'private': private_ips, 'public': public_ips}"},{"question":"def max_hourglass_sum(matrix: List[List[int]]) -> int: Finds the maximum hourglass sum in a given 2D list (matrix). An hourglass sum is defined as the sum of matrix elements that form an hourglass shape. Parameters: matrix (list of list of int): 2D list representing the input matrix. Returns: int: The maximum hourglass sum found in the matrix. If the matrix has less than 3 rows or columns, returns 0. >>> max_hourglass_sum([ [1, 2, 3, 0, 0], [0, 0, 0, 0, 0], [1, 1, 1, 0, 0], [0, 0, 2, 4, 4], [0, 0, 0, 2, 0], ]) == 10 >>> max_hourglass_sum([ [-1, -1, 0, -9, -2, -2], [-2, -1, -6, -8, -2, -5], [-1, -1, -1, -2, -3, -4], [-1, -9, -2, -4, -4, -5], [-7, -3, -3, -2, -9, -9], [-1, -3, -1, -2, -4, -5], ]) == -6 >>> max_hourglass_sum([ [1, 1, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0], [0, 0, 2, 4, 4, 0], [0, 0, 0, 2, 0, 0], [0, 0, 1, 2, 4, 0], ]) == 19 >>> max_hourglass_sum([ [1, 2], [3, 4] ]) == 0 >>> max_hourglass_sum([ [1, 1, 1], [1, 1, 1], [1, 1, 1], ]) == 7","solution":"def max_hourglass_sum(matrix): Finds the maximum hourglass sum in a given 2D list (matrix). An hourglass sum is defined as the sum of matrix elements that form an hourglass shape. Parameters: matrix (list of list of int): 2D list representing the input matrix. Returns: int: The maximum hourglass sum found in the matrix. If the matrix has less than 3 rows or columns, returns 0. rows = len(matrix) cols = len(matrix[0]) if rows > 0 else 0 if rows < 3 or cols < 3: return 0 max_sum = float('-inf') for i in range(rows - 2): for j in range(cols - 2): hourglass_sum = (matrix[i][j] + matrix[i][j+1] + matrix[i][j+2] + matrix[i+1][j+1] + + matrix[i+2][j] + matrix[i+2][j+1] + matrix[i+2][j+2]) if hourglass_sum > max_sum: max_sum = hourglass_sum return max_sum"},{"question":"def two_sum(nums, target): Finds two indices i, j such that nums[i] + nums[j] == target. :param nums: List[int] - List of integers. :param target: int - Target sum. :return: (int, int) or None - Tuple of indices or None if no valid pair is found.","solution":"def two_sum(nums, target): Finds two indices i, j such that nums[i] + nums[j] == target. :param nums: List[int] - List of integers. :param target: int - Target sum. :return: (int, int) or None - Tuple of indices or None if no valid pair is found. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return None"},{"question":"from typing import List def max_subarray_sum(nums: List[int], k: int) -> int: Given a list of \`n\` integers and an integer \`k\`, returns the maximum sum of any subarray of length \`k\`. If the array length is less than \`k\`, return 0. >>> max_subarray_sum([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) 39 >>> max_subarray_sum([2, 3], 3) 0 >>> max_subarray_sum([2, 1, 5, 1, 3, 2], 3) 9","solution":"from typing import List def max_subarray_sum(nums: List[int], k: int) -> int: if len(nums) < k: return 0 # Calculate the sum of the first window of \`k\` elements max_sum = current_sum = sum(nums[:k]) # Slide the window from the start to the end of the list for i in range(k, len(nums)): current_sum = current_sum - nums[i - k] + nums[i] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def sorted_squares(nums: List[int]) -> List[int]: Takes a list of integers as input and returns a list of integers that are the squares of the elements from the original list but sorted in non-decreasing order. Args: nums (list): List of integers. Returns: list: Sorted list of squared integers. >>> sorted_squares([-4, -2, 0, 3, 5]) [0, 4, 9, 16, 25] >>> sorted_squares([1, 2, 3]) [1, 4, 9] >>> sorted_squares([-3, -2, -1]) [1, 4, 9] >>> sorted_squares([-1, 0, 1]) [0, 1, 1] >>> sorted_squares([]) [] >>> sorted_squares([2]) [4] >>> sorted_squares([-3]) [9]","solution":"def sorted_squares(nums): Returns a list of the squares of the elements from the original list, sorted in non-decreasing order. Args: nums (list): List of integers. Returns: list: Sorted list of squared integers. return sorted(x ** 2 for x in nums)"},{"question":"def longest_increasing_subsequence(nums): Returns the longest increasing subsequence in the list of integers nums. >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == [10, 22, 33, 50, 60, 80] >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) == [5] >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> longest_increasing_subsequence([]) == [] >>> longest_increasing_subsequence([2, 2, 2, 2, 2]) == [2]","solution":"def longest_increasing_subsequence(nums): Returns the longest increasing subsequence in the list of integers nums. if not nums: return [] n = len(nums) lengths = [1] * n previous_indices = [-1] * n # Compute lengths of longest increasing subsequences ending at each index for i in range(1, n): for j in range(i): if nums[i] > nums[j] and lengths[i] < lengths[j] + 1: lengths[i] = lengths[j] + 1 previous_indices[i] = j # Find the index of the maximum length of increasing subsequence max_length_index = lengths.index(max(lengths)) # Reconstruct the longest increasing subsequence lis = [] while max_length_index != -1: lis.append(nums[max_length_index]) max_length_index = previous_indices[max_length_index] return lis[::-1]"},{"question":"def max_difference(arr: List[int]) -> int: Create a function that accepts a list of integers and returns the maximum difference between any two elements such that the larger element appears after the smaller element in the list. Examples: >>> max_difference([2, 3, 10, 6, 4, 8, 1]) == 8 >>> max_difference([7, 9, 5, 6, 3, 2]) == 2 >>> max_difference([]) == 0 >>> max_difference([1]) == 0 >>> max_difference([5, 5, 5, 5]) == 0 >>> max_difference([10, 9, 8, 7]) == 0 >>> max_difference([1, 2, 3, 4, 5]) == 4 >>> max_difference([5, 1, 3, 4, 2]) == 3 >>> max_difference([1, 2, 6, 4, 5]) == 5 >>> max_difference([10, 3, 6, 1, 9, 8, 10]) == 9 >>> max_difference([1000, 10000, 100, 1000000, 50]) == 999900","solution":"def max_difference(arr): Returns the maximum difference between any two elements such that the larger element appears after the smaller element in the list. if not arr or len(arr) < 2: return 0 # No meaningful difference can be found in these cases min_value = arr[0] max_diff = 0 for i in range(1, len(arr)): current_value = arr[i] if current_value - min_value > max_diff: max_diff = current_value - min_value if current_value < min_value: min_value = current_value return max_diff # Example usage print(max_difference([2, 3, 10, 6, 4, 8, 1])) # Output: 8 (10 - 2) print(max_difference([7, 9, 5, 6, 3, 2])) # Output: 2 (9 - 7)"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring('aaaaaaa') == 1 >>> length_of_longest_substring('abcdef') == 6 >>> length_of_longest_substring('abcabcbb') == 3 >>> length_of_longest_substring('pwwkew') == 3 >>> length_of_longest_substring('') == 0 >>> length_of_longest_substring('1234567890') == 10 def longest_substrings(s: str) -> List[str]: Returns all distinct substrings of maximum length without repeating characters. >>> longest_substrings('aaaaaaa') == ['a'] >>> longest_substrings('abcdef') == ['abcdef'] >>> set(longest_substrings('abcabcbb')) == {'abc', 'bca', 'cab'} >>> set(longest_substrings('pwwkew')) == {'wke', 'kew'} >>> longest_substrings('') == [] >>> longest_substrings('1234567890') == ['1234567890']","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) max_length = 0 start = 0 char_index_map = {} for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length def longest_substrings(s): Returns all distinct substrings of maximum length without repeating characters. n = len(s) max_length = length_of_longest_substring(s) substrings = set() start = 0 char_index_map = {} for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end if end - start + 1 == max_length: substrings.add(s[start:end+1]) return list(substrings)"},{"question":"def max_distinct_chars_in_substring(s: str, k: int) -> int: Find the maximum number of distinct characters in any substring of the given string of the specified length. >>> max_distinct_chars_in_substring(\\"abcabcbb\\", 3) 3 >>> max_distinct_chars_in_substring(\\"aaaa\\", 2) 1 >>> max_distinct_chars_in_substring(\\"abcd\\", 4) 4 >>> max_distinct_chars_in_substring(\\"aabbcc\\", 3) 2 from solution import max_distinct_chars_in_substring def test_example_1(): assert max_distinct_chars_in_substring(\\"abcabcbb\\", 3) == 3 def test_example_2(): assert max_distinct_chars_in_substring(\\"aaaa\\", 2) == 1 def test_example_3(): assert max_distinct_chars_in_substring(\\"abcd\\", 4) == 4 def test_example_4(): assert max_distinct_chars_in_substring(\\"aabbcc\\", 3) == 2 def test_single_character_string(): assert max_distinct_chars_in_substring(\\"a\\", 1) == 1 def test_repetitive_characters(): assert max_distinct_chars_in_substring(\\"abababababa\\", 3) == 2 def test_all_unique_characters(): assert max_distinct_chars_in_substring(\\"abcdefghijklmnopqrstuvwxyz\\", 5) == 5 def test_k_equals_length_of_string(): assert max_distinct_chars_in_substring(\\"abcdefghij\\", 10) == 10","solution":"def max_distinct_chars_in_substring(s: str, k: int) -> int: from collections import defaultdict max_distinct = 0 char_count = defaultdict(int) distinct_chars = 0 for i in range(len(s)): char_count[s[i]] += 1 if char_count[s[i]] == 1: # new distinct character added distinct_chars += 1 if i >= k: char_count[s[i - k]] -= 1 if char_count[s[i - k]] == 0: # distinct character removed distinct_chars -= 1 if i >= k - 1: max_distinct = max(max_distinct, distinct_chars) return max_distinct"},{"question":"def merge_dictionaries(dict1: dict, dict2: dict) -> dict: Merge two dictionaries, adding values of any overlapping keys. >>> merge_dictionaries({'a': 2, 'b': 3, 'c': 1}, {'a': 1, 'b': 2, 'd': 4}) {'a': 3, 'b': 5, 'c': 1, 'd': 4} >>> merge_dictionaries({}, {'a': 1, 'b': 2}) {'a': 1, 'b': 2} >>> merge_dictionaries({'a': 1, 'b': 2}, {}) {'a': 1, 'b': 2} >>> merge_dictionaries({}, {}) {}","solution":"def merge_dictionaries(dict1, dict2): Merges two dictionaries. If both dictionaries contain the same key, their values are added together. merged_dict = dict1.copy() # Start with a copy of dict1 for key, value in dict2.items(): if key in merged_dict: merged_dict[key] += value else: merged_dict[key] = value return merged_dict"},{"question":"def reverse_string(s: str) -> str: Returns a new string with the characters in reverse order. >>> reverse_string(\\"hello\\") \\"olleh\\" >>> reverse_string(\\"\\") \\"\\" >>> reverse_string(\\"a\\") \\"a\\" >>> reverse_string(\\"abc\\") \\"cba\\" >>> reverse_string(\\"Madam\\") \\"madaM\\" pass def is_palindrome(s: str) -> bool: Checks if the input string is a palindrome, ignoring case and non-alphanumeric characters. >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") True pass","solution":"def reverse_string(s): Returns a new string with the characters in reverse order. reversed_str = \\"\\" for char in s: reversed_str = char + reversed_str return reversed_str def is_palindrome(s): Checks if the input string is a palindrome, ignoring case and non-alphanumeric characters. alnum_str = ''.join(char.lower() for char in s if char.isalnum()) reversed_alnum_str = reverse_string(alnum_str) return alnum_str == reversed_alnum_str"},{"question":"def count_unique_characters(s: str) -> int: Returns the number of unique characters in the input string, ignoring spaces and punctuation marks, and considering case-insensitivity. >>> count_unique_characters(\\"abcABC\\") 3 >>> count_unique_characters(\\"Hello, World!\\") 7 >>> count_unique_characters(\\"\\") 0 >>> count_unique_characters(\\"Aa\\") 1 >>> count_unique_characters(\\"a1b2c3\\") 6 >>> count_unique_characters(\\" \\") 0 >>> count_unique_characters(\\"!@#%^&*()\\") 0 >>> count_unique_characters(\\"AaBbCc 123 !!\\") 6","solution":"def count_unique_characters(s): Returns the number of unique characters in the input string, ignoring spaces and punctuation marks, and considering case-insensitivity. # Convert string to lowercase and filter out non-alphanumeric characters filtered_chars = {char.lower() for char in s if char.isalnum()} return len(filtered_chars)"},{"question":"import math from typing import List def is_prime(n: int) -> bool: Returns True if n is a prime number, else False. >>> is_prime(2) True >>> is_prime(4) False pass def filter_primes(nums: List[int]) -> List[int]: Returns a list containing only the prime numbers from the input list. >>> filter_primes([10, 15, 3, 7, 2, 20, 11]) [3, 7, 2, 11] >>> filter_primes([1, 4, 6, 8, 10, 12]) [] pass","solution":"import math def is_prime(n): Returns True if n is a prime number, else False. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(nums): Returns a list containing only the prime numbers from the input list. return [num for num in nums if is_prime(num)]"},{"question":"def reverse_words(input_string: str) -> str: Reverses the words in the given string and returns the new string. Handles multiple spaces between words. >>> reverse_words(\\"Hello there how are you\\") 'you are how there Hello' >>> reverse_words(\\"Hello there how are you \\") 'you are how there Hello' >>> reverse_words(\\" Hello there how are you\\") 'you are how there Hello' >>> reverse_words(\\"Hello there how are you \\") 'you are how there Hello' >>> reverse_words(\\"\\") ''","solution":"def reverse_words(input_string): Reverses the words in the given string and returns the new string. Handles multiple spaces between words. # Split the input string into words based on spaces words = input_string.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words with a single space between them return ' '.join(reversed_words)"},{"question":"import os import logging def merge_sorted_files(file1, file2, output_file): Reads from two files containing sorted lists of numbers and merges them into a single sorted list. The merged list is saved to a third file. Handles file not found errors and logs all steps in the process to a local log file. Skips invalid numeric data, logging these occurrences.","solution":"import os import logging logging.basicConfig(filename='merge_logs.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s') def merge_sorted_files(file1, file2, output_file): def read_file(file): numbers = [] try: with open(file, 'r') as f: for line in f: try: numbers.append(int(line.strip())) except ValueError as e: logging.error(f\\"Value error in file {file}: {e}\\") except FileNotFoundError: logging.error(f\\"File not found: {file}\\") return numbers list1 = read_file(file1) list2 = read_file(file2) logging.info(f\\"Read {len(list1)} numbers from {file1}\\") logging.info(f\\"Read {len(list2)} numbers from {file2}\\") merged_list = [] i = j = 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append remaining elements merged_list.extend(list1[i:]) merged_list.extend(list2[j:]) with open(output_file, 'w') as f: for number in merged_list: f.write(f\\"{number}n\\") logging.info(f\\"Merged list of {len(merged_list)} numbers written to {output_file}\\")"},{"question":"class Hub: def __init__(self, identifier): Initialize a Hub with an identifier and an empty list of neighbors. Parameters: identifier (str): The unique identifier for the hub. self.identifier = identifier self.neighbors = [] def add_neighbor(self, neighbor): Add a neighboring hub to this hub's list of neighbors. Parameters: neighbor (Hub): The neighboring hub to be added. self.neighbors.append(neighbor) class Package: def __init__(self, tracking_id, sender_address, recipient_address, route): Initialize a Package with a tracking ID, sender's address, recipient's address, and route. Parameters: tracking_id (str): The unique tracking ID of the package. sender_address (str): The address of the sender. recipient_address (str): The address of the recipient. route (List[str]): A list of hub identifiers that the package must pass through. self.tracking_id = tracking_id self.sender_address = sender_address self.recipient_address = recipient_address self.route = route self.current_hub = route[0] if route else None def move_to_next_hub(self): Move the package to the next hub in its route if possible. if self.current_hub and self.route: next_hub_index = self.route.index(self.current_hub) + 1 if next_hub_index < len(self.route): self.current_hub = self.route[next_hub_index] def has_reached_destination(self): Check if the package has reached its final destination. Returns: bool: True if the package is at the last hub in its route, otherwise False. return self.current_hub == self.route[-1] def initialize_hubs(hub_ids, connections): Initialize hubs and their connections based on hub identifiers and connections. Parameters: hub_ids (List[str]): List of hub identifiers. connections (List[Tuple[str, str]]): List of tuples representing connections (routes) between hubs. Returns: dict: Dictionary of initialized hubs with their connections set. hubs = {hid: Hub(hid) for hid in hub_ids} for h1, h2 in connections: hubs[h1].add_neighbor(hubs[h2]) hubs[h2].add_neighbor(hubs[h1]) return hubs def add_package(packages, package): Add a package to the delivery system. Parameters: packages (List[Package]): List of packages in the system. package (Package): The package to be added to the system. packages.append(package) def move_packages(packages): Move all packages in the system to their next hub in their respective routes. Parameters: packages (List[Package]): List of packages to be moved. for package in packages: package.move_to_next_hub() def simulate_delivery(packages): Simulate the delivery of multiple packages, moving them through their routes until all reach their destinations. Parameters: packages (List[Package]): List of packages to be delivered. while not all(package.has_reached_destination() for package in packages): move_packages(packages)","solution":"class Hub: def __init__(self, identifier): self.identifier = identifier self.neighbors = [] def add_neighbor(self, neighbor): self.neighbors.append(neighbor) class Package: def __init__(self, tracking_id, sender_address, recipient_address, route): self.tracking_id = tracking_id self.sender_address = sender_address self.recipient_address = recipient_address self.route = route self.current_hub = route[0] if route else None def move_to_next_hub(self): if self.current_hub and self.route: next_hub_index = self.route.index(self.current_hub) + 1 if next_hub_index < len(self.route): self.current_hub = self.route[next_hub_index] def has_reached_destination(self): return self.current_hub == self.route[-1] def initialize_hubs(hub_ids, connections): hubs = {hid: Hub(hid) for hid in hub_ids} for h1, h2 in connections: hubs[h1].add_neighbor(hubs[h2]) hubs[h2].add_neighbor(hubs[h1]) return hubs def add_package(packages, package): packages.append(package) def move_packages(packages): for package in packages: package.move_to_next_hub() def simulate_delivery(packages): while not all(package.has_reached_destination() for package in packages): move_packages(packages)"},{"question":"def calculate_new_garden_length(small_length: float, small_width: float, new_width: float) -> float: Returns the length of the new garden maintaining the same proportions as the smaller garden. small_length: length of the smaller, existing garden small_width: width of the smaller, existing garden new_width: width of the new garden Examples: >>> calculate_new_garden_length(5, 3, 12) 20.0 >>> calculate_new_garden_length(10, 2, 20) 100.0 >>> calculate_new_garden_length(7, 4, 16) 28.0","solution":"def calculate_new_garden_length(small_length, small_width, new_width): Returns the length of the new garden maintaining the same proportions as the smaller garden. small_length: length of the smaller, existing garden small_width: width of the smaller, existing garden new_width: width of the new garden proportion = small_length / small_width new_length = proportion * new_width return new_length"},{"question":"def max_sum_subarray(nums: list): Return the contiguous subarray with the maximum sum. If multiple subarrays have the same maximum sum, return the one with the shortest length. >>> max_sum_subarray([1, -3, 2, 1, -1]) [2, 1] >>> max_sum_subarray([-2, -3, 4, -1, -2, 1, 5, -3]) [4, -1, -2, 1, 5] >>> max_sum_subarray([5, -1, 2, -1, 3]) [5, -1, 2, -1, 3] >>> max_sum_subarray([1, 2, 3, -1, 2, -1, 2, -1, 7]) [1, 2, 3, -1, 2, -1, 2, -1, 7]","solution":"def max_sum_subarray(nums: list): Return the contiguous subarray with the maximum sum. If multiple subarrays have the same maximum sum, return the one with the shortest length. if not nums: return [] max_sum = curr_sum = nums[0] start = end = temp_start = 0 for i in range(1, len(nums)): if curr_sum < 0: curr_sum = nums[i] temp_start = i else: curr_sum += nums[i] if (curr_sum > max_sum) or (curr_sum == max_sum and i - temp_start < end - start): max_sum = curr_sum start = temp_start end = i return nums[start:end + 1]"},{"question":"def count_pairs_with_sum(nums: List[int], k: int) -> int: Write a function that takes a list of integers and an integer k as arguments. The function should return the number of pairs of integers in the list that add up to k. Ensure that the function does not count pairs more than once, and each pair should consist of distinct indices. >>> count_pairs_with_sum([1, 2, 3, 4], 10) 0 >>> count_pairs_with_sum([1, 2, 3, 4], 5) 2 >>> count_pairs_with_sum([1, 1, 1, 1], 2) 6 >>> count_pairs_with_sum([1, 2, 3, 4, 5], 9) 1 >>> count_pairs_with_sum([-1, -2, -3, -4, -5], -8) 1 >>> count_pairs_with_sum([1, -2, 3, 0, 2, -3], 0) 2","solution":"def count_pairs_with_sum(nums, k): Returns the number of pairs of integers in the list that add up to k. Parameters: nums (list): List of integers. k (int): Target sum. Returns: int: Number of pairs that add up to k. seen = {} count = 0 for num in nums: complement = k - num if complement in seen: count += seen[complement] if num in seen: seen[num] += 1 else: seen[num] = 1 return count"},{"question":"def convert_product_prices(product_list): Takes a list of tuples, with each tuple containing a product name and its price as strings. Returns a dictionary with product names as keys and prices as floats. Skips products with invalid prices. >>> convert_product_prices([('apple', '0.5'), ('orange', '0.75')]) {'apple': 0.5, 'orange': 0.75} >>> convert_product_prices([('apple', '0.5'), ('banana', 'abc')]) {'apple': 0.5} >>> convert_product_prices([('apple', '0.5'), ('banana', 'abc'), ('orange', '0.75')]) {'apple': 0.5, 'orange': 0.75} >>> convert_product_prices([]) {} >>> convert_product_prices([('banana', 'abc'), ('grape', 'xyz')]) {} >>> convert_product_prices([('freebie', '0.0'), ('cheap', '0.5')]) {'freebie': 0.0, 'cheap': 0.5} >>> convert_product_prices([('discount', '-1.0'), ('deal', '1.0')]) {'discount': -1.0, 'deal': 1.0}","solution":"def convert_product_prices(product_list): Takes a list of tuples, with each tuple containing a product name and its price as strings. Returns a dictionary with product names as keys and prices as floats. Skips products with invalid prices. product_dict = {} for product, price in product_list: try: product_dict[product] = float(price) except ValueError: # Skip products with prices that can't be converted to float continue return product_dict"},{"question":"from typing import List, Tuple, Dict, Any def process_transactions(transactions: List[Tuple[int, str, float, str]], start_date: str, end_date: str, threshold: float) -> Dict[str, Any]: Processes the transaction records to: 1. Calculate the total transaction amount for each customer. 2. Identify the customer with the highest total transaction amount. 3. Count the number of unique customers who made transactions within a specified date range. 4. List all transaction IDs for transactions that exceed a given threshold amount. Args: transactions (List[Tuple[int, str, float, str]]): A list of tuples, each containing a transaction ID, customer ID, transaction amount, and date. start_date (str): The start date of the specified date range (inclusive). end_date (str): The end date of the specified date range (inclusive). threshold (float): The threshold amount to identify high-value transactions. Returns: Dict[str, Any]: A dictionary containing the results of processing transactions: - \\"total_per_customer\\": A dictionary with customer IDs as keys and total transaction amounts as values. - \\"high_total_customer\\": A tuple containing the customer ID with the highest total transaction amount and the total amount. - \\"unique_customers_count\\": The number of unique customers who made transactions within the specified date range. - \\"transaction_ids_above_threshold\\": A list of transaction IDs for transactions that exceed the given threshold amount. >>> transactions = [(1, 'C1', 100.50, '2023-01-10'), (2, 'C2', 200.75, '2023-01-15'), (3, 'C1', 150.25, '2023-02-10'), (4, 'C3', 300.12, '2023-01-20'), (5, 'C2', 50.00, '2023-01-25'), (6, 'C3', 365.00, '2023-03-01')] >>> start_date = '2023-01-01' >>> end_date = '2023-01-31' >>> threshold = 100.00 >>> process_transactions(transactions, start_date, end_date, threshold) { \\"total_per_customer\\": {'C1': 250.75, 'C2': 250.75, 'C3': 665.12}, \\"high_total_customer\\": ('C3', 665.12), \\"unique_customers_count\\": 3, \\"transaction_ids_above_threshold\\": [1, 2, 3, 4, 6] }","solution":"from collections import defaultdict from datetime import datetime def process_transactions(transactions, start_date, end_date, threshold): Processes the transaction records to: 1. Calculate the total transaction amount for each customer. 2. Identify the customer with the highest total transaction amount. 3. Count the number of unique customers who made transactions within a specified date range. 4. List all transaction IDs for transactions that exceed a given threshold amount. total_per_customer = defaultdict(float) high_total_customer = None high_total_amount = 0 unique_customers = set() transaction_ids_above_threshold = [] start_date = datetime.strptime(start_date, \\"%Y-%m-%d\\") end_date = datetime.strptime(end_date, \\"%Y-%m-%d\\") for trans_id, cust_id, amount, date in transactions: date_obj = datetime.strptime(date, \\"%Y-%m-%d\\") # Total transaction amount per customer total_per_customer[cust_id] += amount if total_per_customer[cust_id] > high_total_amount: high_total_amount = total_per_customer[cust_id] high_total_customer = cust_id # Unique customers within date range if start_date <= date_obj <= end_date: unique_customers.add(cust_id) # Transaction IDs above threshold if amount > threshold: transaction_ids_above_threshold.append(trans_id) result = { \\"total_per_customer\\": total_per_customer, \\"high_total_customer\\": (high_total_customer, high_total_amount), \\"unique_customers_count\\": len(unique_customers), \\"transaction_ids_above_threshold\\": transaction_ids_above_threshold } return result"},{"question":"from typing import List, Dict, Tuple import matplotlib.pyplot as plt def calculate_averages_and_plot(students_scores: List[Dict[str, any]]) -> Tuple[Dict[str, float], Dict[str, float]]: Calculate the average score of each student and the class average for each subject. Also, plot a bar chart for each student's average score. :param students_scores: List of dictionaries containing students' scores in various subjects :return: A tuple containing: - A dictionary with student names as keys and their average score as values. - A dictionary with class average score for each subject. >>> students_scores = [ ... {\\"name\\": \\"Alice\\", \\"Mathematics\\": 85, \\"Physics\\": 78, \\"Chemistry\\": 88, \\"Biology\\": 92, \\"English\\": 80}, ... {\\"name\\": \\"Bob\\", \\"Mathematics\\": 75, \\"Physics\\": 85, \\"Chemistry\\": 89, \\"Biology\\": 90, \\"English\\": 78}, ... {\\"name\\": \\"Charlie\\", \\"Mathematics\\": 95, \\"Physics\\": 92, \\"Chemistry\\": 94, \\"Biology\\": 85, \\"English\\": 88}, ... {\\"name\\": \\"David\\", \\"Mathematics\\": 65, \\"Physics\\": 70, \\"Chemistry\\": 75, \\"Biology\\": 80, \\"English\\": 72}, ... {\\"name\\": \\"Eva\\", \\"Mathematics\\": 88, \\"Physics\\": 82, \\"Chemistry\\": 84, \\"Biology\\": 89, \\"English\\": 86} ... ] >>> student_averages, class_averages = calculate_averages_and_plot(students_scores) >>> student_averages {\\"Alice\\": 84.6, \\"Bob\\": 83.4, \\"Charlie\\": 90.8, \\"David\\": 72.4, \\"Eva\\": 85.8} >>> class_averages {\\"Mathematics\\": 81.6, \\"Physics\\": 81.4, \\"Chemistry\\": 86.0, \\"Biology\\": 87.2, \\"English\\": 80.8}","solution":"import matplotlib.pyplot as plt def calculate_averages_and_plot(students_scores): Calculate the average score of each student and the class average for each subject. Also, plot a bar chart for each student's average score. student_averages = {} subject_totals = { \\"Mathematics\\": 0, \\"Physics\\": 0, \\"Chemistry\\": 0, \\"Biology\\": 0, \\"English\\": 0 } num_students = len(students_scores) for student in students_scores: name = student[\\"name\\"] avg_score = sum( student[subject] for subject in subject_totals ) / len(subject_totals) student_averages[name] = avg_score for subject in subject_totals: subject_totals[subject] += student[subject] class_averages = { subject: total / num_students for subject, total in subject_totals.items() } # Plotting plt.figure(figsize=(10, 6)) plt.bar(student_averages.keys(), student_averages.values()) plt.xlabel('Students') plt.ylabel('Average Score') plt.title('Average Scores of Students') plt.xticks(rotation=45) plt.show() return student_averages, class_averages"},{"question":"from typing import List def fibonacci_sequence(n: int) -> List[int]: Returns the first n terms of the Fibonacci sequence. >>> fibonacci_sequence(0) [] >>> fibonacci_sequence(1) [0] >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] def fibonacci_nth(n: int) -> int: Returns the nth term of the Fibonacci sequence directly. >>> fibonacci_nth(0) 0 >>> fibonacci_nth(1) 1 >>> fibonacci_nth(5) 5 >>> fibonacci_nth(10) 55","solution":"def fibonacci_sequence(n): Returns the first n terms of the Fibonacci sequence. if n == 0: return [] if n == 1: return [0] sequence = [0, 1] for _ in range(2, n): sequence.append(sequence[-1] + sequence[-2]) return sequence def fibonacci_nth(n): Returns the nth term of the Fibonacci sequence directly. if n == 0: return 0 if n == 1: return 1 a, b = 0, 1 for _ in range(2, n+1): a, b = b, a + b return b"},{"question":"def second_largest(numbers: List[int]) -> Optional[int]: Returns the second largest number in the list. If there are fewer than two distinct numbers, it returns None. >>> second_largest([11, 27, 43, 27, 36, 50, 36, 50]) 43 >>> second_largest([10]) None >>> second_largest([10, 10, 10]) None >>> second_largest([-1, -2, -3, -4, -5]) -2 >>> second_largest([]) None >>> second_largest([3, 4]) 3 >>> second_largest([1, 2, 2, 3, 3, 3]) 2","solution":"def second_largest(numbers): Returns the second largest number in the list. If there are fewer than two distinct numbers, it returns None. if len(numbers) < 2: return None first = second = float('-inf') for num in numbers: if num > first: first, second = num, first elif first > num > second: second = num return second if second != float('-inf') else None"},{"question":"def rearrange_string(s: str) -> str: Implement a function that rearranges the string s such that no two adjacent characters are the same. If it is not possible to rearrange the string, return an empty string. >>> rearrange_string(\\"aab\\") in [\\"aba\\"] >>> rearrange_string(\\"aaab\\") == \\"\\" >>> rearrange_string(\\"aaabbc\\") in [\\"ababac\\", \\"abacba\\", \\"abacab\\", \\"bacaba\\", \\"bcabac\\", \\"acabab\\", \\"acbacb\\"] >>> rearrange_string(\\"aaabbcc\\") in [\\"abacabc\\", \\"abacbac\\", \\"abacabca\\", \\"bacabca\\", \\"bcaabac\\", \\"acbacab\\", \\"acababc\\", \\"acabcbca\\"] >>> rearrange_string(\\"abcd\\") == \\"abcd\\" >>> rearrange_string(\\"a\\") == \\"a\\" >>> rearrange_string(\\"aa\\") == \\"\\" >>> rearrange_string(\\"a\\" * 250 + \\"b\\" * 250) == \\"ab\\" * 250","solution":"from collections import Counter import heapq def rearrange_string(s: str) -> str: Rearranges the string s such that no two adjacent characters are the same. Returns an empty string if rearrangement is not possible. count = Counter(s) max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) result = [] prev_count, prev_char = 0, '' while max_heap: cur_count, cur_char = heapq.heappop(max_heap) result.append(cur_char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count = cur_count + 1 prev_char = cur_char result_str = ''.join(result) if len(result_str) != len(s): return \\"\\" return result_str"},{"question":"def generate_parentheses(n: int) -> List[str]: Generates all valid parenthetical expressions with n pairs of parentheses in lexicographical order. >>> generate_parentheses(3) ['((()))', '(()())', '(())()', '()(())', '()()()'] >>> generate_parentheses(0) [] >>> generate_parentheses(1) [\\"()\\"] >>> generate_parentheses(2) [\\"(())\\", \\"()()\\"] >>> generate_parentheses(4) [\\"(((())))\\", \\"((()()))\\", \\"((())())\\", \\"((()))()\\", \\"(()(()))\\", \\"(()()())\\", \\"(()())()\\", \\"(())(())\\", \\"(())()()\\", \\"()((()))\\", \\"()(()())\\", \\"()(())()\\", \\"()()(())\\", \\"()()()()\\"]","solution":"def generate_parentheses(n): Generates all valid parenthetical expressions with n pairs of parentheses in lexicographical order. if n == 0: return [] result = [] def backtrack(s='', left=0, right=0): if len(s) == 2*n: result.append(s) return if left < n: backtrack(s+'(', left+1, right) if right < left: backtrack(s+')', left, right+1) backtrack() return result"},{"question":"def find_longest_word(s: str) -> Tuple[str, int]: Returns the longest word in the given string s along with its length. >>> find_longest_word(\\"The quick brown fox jumped over the lazy dog\\") == (\\"jumped\\", 6) >>> find_longest_word(\\"supercalifragilisticexpialidocious\\") == (\\"supercalifragilisticexpialidocious\\", 34) >>> find_longest_word(\\"a bb ccc ddd\\") == (\\"ccc\\", 3) >>> find_longest_word(\\"cat bat rat mat\\") == (\\"cat\\", 3) >>> find_longest_word(\\"\\") == (\\"\\", 0)","solution":"def find_longest_word(s): Returns the longest word in the given string s along with its length. Parameters: s (str): The input string containing words separated by spaces. Returns: tuple: A tuple containing the longest word and its length. words = s.split() longest_word = \\"\\" max_length = 0 for word in words: if len(word) > max_length: longest_word = word max_length = len(word) return longest_word, max_length"},{"question":"def smallest_lexicographical_permutation(words: List[str]) -> List[str]: Formulate a robust function that traverses an unordered list of words to identify and extract the smallest lexicographical permutation of the input. Ensure the permutation retains unique elements only, thereby eliminating any repetitive entities to preserve data singularity. >>> smallest_lexicographical_permutation(['beta', 'alpha', 'beta', 'delta', 'gamma', 'alpha']) ['alpha', 'beta', 'delta', 'gamma'] >>> smallest_lexicographical_permutation(['gamma', 'delta', 'beta', 'alpha']) ['alpha', 'beta', 'delta', 'gamma'] >>> smallest_lexicographical_permutation(['alpha', 'alpha', 'alpha', 'alpha']) ['alpha'] >>> smallest_lexicographical_permutation([]) [] >>> smallest_lexicographical_permutation(['alpha']) ['alpha']","solution":"def smallest_lexicographical_permutation(words): Returns the smallest lexicographical permutation of the unique words. # Remove duplicates by converting to a set unique_words = set(words) # Sort the unique words lexicographically sorted_unique_words = sorted(unique_words) return sorted_unique_words"},{"question":"import re from typing import List def is_valid_phone_number(phone_number: str) -> bool: Checks if the provided phone number is in a valid US format. >>> is_valid_phone_number(\\"(123) 456-7890\\") True >>> is_valid_phone_number(\\"123-456-7890\\") True >>> is_valid_phone_number(\\"123 456 7890\\") False def test_valid_phone_numbers_with_parentheses(): assert is_valid_phone_number(\\"(123) 456-7890\\") == True def test_valid_phone_numbers_with_dashes(): assert is_valid_phone_number(\\"123-456-7890\\") == True def test_invalid_phone_numbers_missing_digits(): assert is_valid_phone_number(\\"(123) 456-789\\") == False assert is_valid_phone_number(\\"123-45-7890\\") == False def test_invalid_phone_numbers_incorrect_format(): assert is_valid_phone_number(\\"123 456 7890\\") == False assert is_valid_phone_number(\\"123.456.7890\\") == False def test_edge_cases(): assert is_valid_phone_number(\\"(123 456-7890\\") == False assert is_valid_phone_number(\\"123) 456-7890\\") == False assert is_valid_phone_number(\\" (123) 456-7890\\") == False assert is_valid_phone_number(\\"(123) 456-7890 \\") == False","solution":"import re def is_valid_phone_number(phone_number): Checks if the provided phone number is in a valid US format. pattern = re.compile(r'^(d{3}) d{3}-d{4}|^d{3}-d{3}-d{4}') return bool(pattern.match(phone_number))"},{"question":"import pandas as pd import matplotlib.pyplot as plt from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_squared_error, r2_score import numpy as np def analyze_sales_data(file_path): Load the sales dataset, perform data cleansing, create visualizations, and perform linear regression analysis to model the relationship between sales and discounts. Args: file_path (str): The path to the sales dataset file. Returns: dict: A dictionary containing the coefficient, intercept, mean squared error, and R-squared value of the linear regression model. Example: >>> report = analyze_sales_data('sales_data.csv') >>> 'Coefficient' in report True >>> 'Mean Squared Error' in report True import pandas as pd import pytest from solution import analyze_sales_data def create_sales_test_data(): data = { 'Date': ['2023-01-01', '2023-01-15', '2023-02-01', '2023-02-15', '2023-03-01'], 'Sales': [100, 150, 200, 250, 300], 'Product_Category': ['A', 'B', 'A', 'B', 'A'], 'Discount': [5, 10, 15, 20, 25] } df = pd.DataFrame(data) return df def test_analyze_sales_data(monkeypatch): test_data = create_sales_test_data() monkeypatch.setattr(pd, 'read_csv', lambda _: test_data) report = analyze_sales_data('dummy_path') assert 'Coefficient' in report assert 'Intercept' in report assert 'Mean Squared Error' in report assert 'R-squared' in report","solution":"import pandas as pd import matplotlib.pyplot as plt from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_squared_error, r2_score import numpy as np def analyze_sales_data(file_path): # Load dataset data = pd.read_csv(file_path) # Perform data cleansing data.drop_duplicates(inplace=True) data.dropna(inplace=True) # Parse dates data['Date'] = pd.to_datetime(data['Date']) data['Month'] = data['Date'].dt.to_period('M') # Monthly Sales Trend Line Plot monthly_sales = data.groupby('Month')['Sales'].sum() plt.figure(figsize=(12, 6)) monthly_sales.plot(kind='line') plt.title('Monthly Sales Trend') plt.ylabel('Total Sales') plt.xlabel('Month') plt.grid(True) plt.savefig('monthly_sales_trend.png') plt.show() # Bar Plot of Total Sales by Product Category category_sales = data.groupby('Product_Category')['Sales'].sum() plt.figure(figsize=(12, 6)) category_sales.plot(kind='bar') plt.title('Total Sales by Product Category') plt.ylabel('Total Sales') plt.xlabel('Product Category') plt.savefig('category_sales.png') plt.show() # Scatter Plot of Sales vs Discounts plt.figure(figsize=(12, 6)) plt.scatter(data['Discount'], data['Sales']) plt.title('Sales vs Discount Scatter Plot') plt.xlabel('Discount') plt.ylabel('Sales') plt.savefig('sales_vs_discount.png') plt.show() # Linear Regression Analysis X = data[['Discount']].values y = data['Sales'].values reg = LinearRegression() reg.fit(X, y) y_pred = reg.predict(X) mse = mean_squared_error(y, y_pred) r2 = r2_score(y, y_pred) report = { 'Coefficient': reg.coef_[0], 'Intercept': reg.intercept_, 'Mean Squared Error': mse, 'R-squared': r2 } with open('regression_report.txt', 'w') as f: for key, value in report.items(): f.write(f\\"{key}: {value}n\\") return report"},{"question":"import csv from collections import defaultdict from typing import Dict def extract_action_counts(json_response: dict) -> Dict[str, int]: Process the JSON response to extract the total count of each action type. Args: json_response (dict): JSON response from the API. Returns: Dict[str, int]: A dictionary with action types as keys and their counts as values. >>> json_response = { ... \\"userId\\": \\"12345\\", ... \\"actions\\": [ ... { ... \\"category\\": \\"file\\", ... \\"actions\\": [ ... { ... \\"type\\": \\"upload\\", ... \\"count\\": 5 ... }, ... { ... \\"type\\": \\"delete\\", ... \\"count\\": 2 ... } ... ] ... }, ... { ... \\"category\\": \\"email\\", ... \\"actions\\": [ ... { ... \\"type\\": \\"send\\", ... \\"count\\": 10 ... }, ... { ... \\"type\\": \\"receive\\", ... \\"count\\": 15 ... } ... ] ... } ... ] ... } >>> extract_action_counts(json_response) {'upload': 5, 'delete': 2, 'send': 10, 'receive': 15} action_counts = defaultdict(int) # Your code here to process json_response and fill in action_counts return action_counts def save_to_csv(action_counts: Dict[str, int], output_file: str): Save the action counts to a CSV file. Args: action_counts (Dict[str, int]): Dictionary containing action types and their counts. output_file (str): Path to the CSV file to be created. >>> action_counts = { ... 'upload': 5, ... 'delete': 2, ... 'send': 10, ... 'receive': 15 ... } >>> output_file = 'action_counts.csv' >>> save_to_csv(action_counts, output_file) # Check the contents of 'action_counts.csv' file # Your code here to save action_counts to output_file in CSV format import os import csv def test_extract_action_counts(): json_response = { \\"userId\\": \\"12345\\", \\"actions\\": [ { \\"category\\": \\"file\\", \\"actions\\": [ { \\"type\\": \\"upload\\", \\"count\\": 5 }, { \\"type\\": \\"delete\\", \\"count\\": 2 } ] }, { \\"category\\": \\"email\\", \\"actions\\": [ { \\"type\\": \\"send\\", \\"count\\": 10 }, { \\"type\\": \\"receive\\", \\"count\\": 15 } ] } ] } expected_counts = { 'upload': 5, 'delete': 2, 'send': 10, 'receive': 15 } assert extract_action_counts(json_response) == expected_counts def test_save_to_csv(tmp_path): action_counts = { 'upload': 5, 'delete': 2, 'send': 10, 'receive': 15 } output_file = os.path.join(tmp_path, 'action_counts.csv') save_to_csv(action_counts, output_file) with open(output_file, newline='') as file: reader = csv.DictReader(file) result = {row['type']: int(row['count']) for row in reader} assert result == action_counts","solution":"import csv import json from collections import defaultdict def extract_action_counts(json_response): Process the JSON response to extract the total count of each action type. Args: json_response (dict): JSON response from the API Returns: dict: A dictionary with action types as keys and their counts as values action_counts = defaultdict(int) for category in json_response.get(\\"actions\\", []): for action in category.get(\\"actions\\", []): action_type = action.get(\\"type\\") count = action.get(\\"count\\", 0) action_counts[action_type] += count return action_counts def save_to_csv(action_counts, output_file): Save the action counts to a CSV file. Args: action_counts (dict): Dictionary containing action types and their counts output_file (str): Path to the CSV file to be created with open(output_file, 'w', newline='') as file: writer = csv.writer(file) writer.writerow(['type', 'count']) for action_type, count in action_counts.items(): writer.writerow([action_type, count]) # Example JSON response json_response = { \\"userId\\": \\"12345\\", \\"actions\\": [ { \\"category\\": \\"file\\", \\"actions\\": [ { \\"type\\": \\"upload\\", \\"count\\": 5 }, { \\"type\\": \\"delete\\", \\"count\\": 2 } ] }, { \\"category\\": \\"email\\", \\"actions\\": [ { \\"type\\": \\"send\\", \\"count\\": 10 }, { \\"type\\": \\"receive\\", \\"count\\": 15 } ] } ] } action_counts = extract_action_counts(json_response) save_to_csv(action_counts, 'action_counts.csv')"},{"question":"def is_prime(n: int) -> bool: Helper function to check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(-3) False >>> is_prime(17) True pass def filter_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the input list. >>> filter_primes([11, 14, 17, 19, 21]) [11, 17, 19] >>> filter_primes([4, 6, 8, 10, 12]) [] >>> filter_primes([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> filter_primes([]) [] >>> filter_primes([0, 1, -3, 4]) [] >>> filter_primes([29, 31, 38, 40]) [29, 31] pass","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False max_divisor = int(n**0.5) + 1 for i in range(3, max_divisor, 2): if n % i == 0: return False return True def filter_primes(numbers): Returns a list of prime numbers from the input list. return [num for num in numbers if is_prime(num)]"},{"question":"from typing import List def find_median(numbers: List[int]) -> float: Returns the median value of a list of integers. >>> find_median([2, 5, 1, 7, 3]) == 3 >>> find_median([10, 20, 30]) == 20 >>> find_median([1, 6, 2, 4]) == 3.0","solution":"from typing import List def find_median(numbers: List[int]) -> float: Returns the median value of a list of integers. numbers.sort() n = len(numbers) if n % 2 == 1: # If odd, return the middle element return numbers[n//2] else: # If even, return the average of the two middle elements middle1 = numbers[n//2 - 1] middle2 = numbers[n//2] return (middle1 + middle2) / 2"},{"question":"class FileSystem: File System In-Memory Simulation Methods: - mkDir(path: str) -> None: Creates a directory at the specified path. - createFile(path: str, content: str) -> None: Creates a file at the specified path with the given content. - readFile(path: str) -> str: Reads the content of the file at the specified path. - writeToFile(path: str, content: str) -> None: Writes the specified content to the file at the given path. Example: >>> fs = FileSystem() >>> fs.mkDir(\\"/a\\") >>> fs.createFile(\\"/a/file\\", \\"content\\") >>> fs.readFile(\\"/a/file\\") 'content' >>> fs.writeToFile(\\"/a/file\\", \\"_more\\") >>> fs.readFile(\\"/a/file\\") 'content_more' def __init__(self): self.fs_tree = {\\"/\\": {}} def mkDir(self, path: str) -> None: pass def createFile(self, path: str, content: str) -> None: pass def readFile(self, path: str) -> str: pass def writeToFile(self, path: str, content: str) -> None: pass # Unit Tests def test_mkDir_create_directory(): fs = FileSystem() fs.mkDir(\\"/a\\") assert fs.fs_tree[\\"/\\"].get(\\"a\\") == {} def test_mkDir_idempotent(): fs = FileSystem() fs.mkDir(\\"/a\\") fs.mkDir(\\"/a\\") assert fs.fs_tree[\\"/\\"].get(\\"a\\") == {} def test_createFile(): fs = FileSystem() fs.createFile(\\"/file\\", \\"content\\") assert fs.readFile(\\"/file\\") == \\"content\\" def test_createFile_overwrite(): fs = FileSystem() fs.createFile(\\"/file\\", \\"content1\\") fs.createFile(\\"/file\\", \\"content2\\") assert fs.readFile(\\"/file\\") == \\"content2\\" def test_readFile_non_existent(): fs = FileSystem() assert fs.readFile(\\"/non_existent\\") == \\"\\" def test_writeToFile(): fs = FileSystem() fs.createFile(\\"/file\\", \\"content\\") fs.writeToFile(\\"/file\\", \\"_more\\") assert fs.readFile(\\"/file\\") == \\"content_more\\" def test_writeToFile_non_existent(): fs = FileSystem() fs.writeToFile(\\"/non_existent\\", \\"content\\") assert fs.readFile(\\"/non_existent\\") == \\"\\" def test_directory_as_file_conflict(): fs = FileSystem() fs.mkDir(\\"/dir\\") fs.createFile(\\"/dir/file\\", \\"content\\") assert fs.readFile(\\"/dir/file\\") == \\"content\\" fs.createFile(\\"/dir\\", \\"newcontent\\") assert fs.readFile(\\"/dir\\") == \\"\\"","solution":"class FileSystem: def __init__(self): self.fs_tree = {'/': {}} def _traverse(self, path): Helper method to traverse the path and return the parent directory and the final component of the path. components = path.strip('/').split('/') curr = self.fs_tree['/'] for comp in components[:-1]: if comp in curr and isinstance(curr[comp], dict): curr = curr[comp] else: return None, None return curr, components[-1] def mkDir(self, path: str) -> None: parent, new_dir = self._traverse(path) if parent is not None and new_dir not in parent: parent[new_dir] = {} def createFile(self, path: str, content: str) -> None: parent, new_file = self._traverse(path) if parent is not None and (new_file not in parent or isinstance(parent[new_file], str)): parent[new_file] = content def readFile(self, path: str) -> str: parent, file_name = self._traverse(path) if parent is not None and file_name in parent and isinstance(parent[file_name], str): return parent[file_name] return \\"\\" def writeToFile(self, path: str, content: str) -> None: parent, file_name = self._traverse(path) if parent is not None and file_name in parent and isinstance(parent[file_name], str): parent[file_name] += content"},{"question":"def is_perfect_number(n: int) -> bool: Determines if a given positive integer is a perfect number. Parameters: n (int): A positive integer. Returns: bool: True if n is a perfect number, False otherwise. >>> is_perfect_number(6) == True >>> is_perfect_number(28) == True >>> is_perfect_number(496) == True >>> is_perfect_number(8128) == True >>> is_perfect_number(1) == False >>> is_perfect_number(10) == False >>> is_perfect_number(27) == False >>> is_perfect_number(10000) == False >>> is_perfect_number(33550336) == True # large known perfect number","solution":"def is_perfect_number(n): Determines if a given positive integer is a perfect number. Parameters: n (int): A positive integer. Returns: bool: True if n is a perfect number, False otherwise. # Initial check for n to be greater than 1 as 1 doesn't have proper divisors if n <= 1: return False # Calculate sum of proper divisors sum_divisors = 1 # 1 is a proper divisor for any n > 1 for i in range(2, int(n**0.5) + 1): if n % i == 0: sum_divisors += i if i != n // i: # Add the complement divisor if it's different sum_divisors += n // i return sum_divisors == n"},{"question":"def count_characters(s: str) -> dict: Returns a dictionary with the count of each character in the string s. Parameters: s (str): A string to count characters from. Returns: dict: A dictionary with characters as keys and their counts as values. Ignore case sensitivity and consider only alphanumeric characters. >>> count_characters(\\"aabbcc\\") == {'a': 2, 'b': 2, 'c': 2} >>> count_characters(\\"AaBbCc\\") == {'a': 2, 'b': 2, 'c': 2} >>> count_characters(\\"a1b2c3\\") == {'a': 1, '1': 1, 'b': 1, '2': 1, 'c': 1, '3': 1} >>> count_characters(\\"a!b@c#\\") == {'a': 1, 'b': 1, 'c': 1} >>> count_characters(\\"\\") == {} >>> count_characters(\\"!@#%\\") == {}","solution":"def count_characters(s): Returns a dictionary with the count of each character in the string s. Parameters: s (str): a string to count characters from. Returns: dict: a dictionary with characters as keys and their counts as values. s = s.lower() counts = {} for char in s: if char.isalnum(): if char in counts: counts[char] += 1 else: counts[char] = 1 return counts"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.key = key def balance_bst(root): This function takes an unbalanced BST and returns a balanced BST which maintains the properties of a binary search tree. The algorithm runs in O(n) time complexity where n is the number of nodes in the tree. >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.left.left = TreeNode(2) >>> root.left.left.left = TreeNode(1) >>> balanced_root = balance_bst(root) >>> bst_to_list(balanced_root) == [1, 2, 5, 10] True pass def store_inorder(node, inorder_list): Helper function to store the inorder traversal of a tree. pass def sorted_array_to_bst(start, end, inorder_list): Helper function to convert a sorted array to a balanced BST. pass def bst_to_list(root): Helper function to convert BST to a sorted list which can be used in tests for comparison. result = [] def inorder(node): if not node: return inorder(node.left) result.append(node.key) inorder(node.right) inorder(root) return result","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.key = key def store_inorder(node, inorder_list): Helper function to store the inorder traversal of a tree. if node is None: return # Store nodes in the left subtree store_inorder(node.left, inorder_list) # Store the root node inorder_list.append(node.key) # Store nodes in the right subtree store_inorder(node.right, inorder_list) def sorted_array_to_bst(start, end, inorder_list): Helper function to convert a sorted array to a balanced BST. if start > end: return None # Get the middle element and make it root mid = (start + end) // 2 node = TreeNode(inorder_list[mid]) # Recursively construct the left subtree and make it left child of root node.left = sorted_array_to_bst(start, mid-1, inorder_list) # Recursively construct the right subtree and make it right child of root node.right = sorted_array_to_bst(mid+1, end, inorder_list) return node def balance_bst(root): This function takes an unbalanced BST and returns a balanced BST. inorder_list = [] store_inorder(root, inorder_list) # Store the inorder traversal of the BST # Convert the sorted inorder traversal list to a balanced BST balanced_root = sorted_array_to_bst(0, len(inorder_list)-1, inorder_list) return balanced_root"},{"question":"def is_valid_parentheses(s: str) -> bool: Determines if the string of parentheses is valid. A string is considered valid if: 1. All open parenthesis '(' have a corresponding closing parenthesis ')'. 2. Open parenthesis '(' must be closed in the correct order. Example Inputs and Outputs: >>> is_valid_parentheses(\\"(())\\") == True >>> is_valid_parentheses(\\"(()))\\") == False >>> is_valid_parentheses(\\"()()\\") == True >>> is_valid_parentheses(\\"((())\\") == False","solution":"def is_valid_parentheses(s: str) -> bool: Determines if the string of parentheses is valid. A string is considered valid if: 1. All open parenthesis '(' have a corresponding closing parenthesis ')'. 2. Open parenthesis '(' must be closed in the correct order. open_count = 0 for char in s: if char == '(': open_count += 1 elif char == ')': if open_count == 0: return False open_count -= 1 return open_count == 0"},{"question":"def count_trailing_zeroes(n: int) -> int: Returns the number of trailing zeroes in the factorial of n. >>> count_trailing_zeroes(3) 0 >>> count_trailing_zeroes(5) 1 >>> count_trailing_zeroes(100) 24 pass import pytest def test_trailing_zeroes_small_numbers(): assert count_trailing_zeroes(3) == 0 assert count_trailing_zeroes(5) == 1 assert count_trailing_zeroes(10) == 2 def test_trailing_zeroes_large_numbers(): assert count_trailing_zeroes(100) == 24 assert count_trailing_zeroes(1000) == 249 assert count_trailing_zeroes(10000) == 2499 def test_trailing_zeroes_edge_case(): assert count_trailing_zeroes(1) == 0 assert count_trailing_zeroes(4) == 0 def test_trailing_zeroes_multiples_of_25(): assert count_trailing_zeroes(25) == 6 assert count_trailing_zeroes(30) == 7 def test_trailing_zeroes_multiples_of_125(): assert count_trailing_zeroes(125) == 31 assert count_trailing_zeroes(250) == 62 if __name__ == \\"__main__\\": pytest.main()","solution":"def count_trailing_zeroes(n: int) -> int: Returns the number of trailing zeroes in the factorial of n. count = 0 while n >= 5: n //= 5 count += n return count"},{"question":"class MyCircularQueue: Circular Queue implementation without using built-in queue data structure. MyCircularQueue(k) Initializes the object with the size of the queue to be k. boolean enQueue(int value) Inserts an element into the circular queue. Return true if the operation is successful. boolean deQueue() Deletes an element from the circular queue. Return true if the operation is successful. int Front() Gets the front item from the queue. If the queue is empty, return -1. int Rear() Gets the last item from the queue. If the queue is empty, return -1. boolean isEmpty() Checks whether the circular queue is empty or not. boolean isFull() Checks whether the circular queue is full or not. >>> circularQueue = MyCircularQueue(3) >>> circularQueue.enQueue(1) True >>> circularQueue.enQueue(2) True >>> circularQueue.enQueue(3) True >>> circularQueue.enQueue(4) False >>> circularQueue.Rear() 3 >>> circularQueue.isFull() True >>> circularQueue.deQueue() True >>> circularQueue.enQueue(4) True >>> circularQueue.Rear() 4 >>> circularQueue.Front() 2 >>> circularQueue.deQueue() True >>> circularQueue.deQueue() True >>> circularQueue.deQueue() True >>> circularQueue.deQueue() False >>> circularQueue.Front() -1 >>> circularQueue.Rear() -1 >>> circularQueue.isEmpty() True def __init__(self, k: int): pass def enQueue(self, value: int) -> bool: pass def deQueue(self) -> bool: pass def Front(self) -> int: pass def Rear(self) -> int: pass def isEmpty(self) -> bool: pass def isFull(self) -> bool: pass def test_circular_queue_operations(): circularQueue = MyCircularQueue(3) assert circularQueue.enQueue(1) == True assert circularQueue.enQueue(2) == True assert circularQueue.enQueue(3) == True assert circularQueue.enQueue(4) == False assert circularQueue.Rear() == 3 assert circularQueue.isFull() == True assert circularQueue.deQueue() == True assert circularQueue.enQueue(4) == True assert circularQueue.Rear() == 4 assert circularQueue.Front() == 2 assert circularQueue.deQueue() == True assert circularQueue.deQueue() == True assert circularQueue.deQueue() == True assert circularQueue.deQueue() == False assert circularQueue.Front() == -1 assert circularQueue.Rear() == -1 assert circularQueue.isEmpty() == True def test_circular_queue_initialization(): circularQueue = MyCircularQueue(1) assert circularQueue.isEmpty() == True assert circularQueue.isFull() == False def test_circular_queue_edge_cases(): circularQueue = MyCircularQueue(2) assert circularQueue.enQueue(1) == True assert circularQueue.enQueue(2) == True assert circularQueue.enQueue(3) == False assert circularQueue.isFull() == True assert circularQueue.deQueue() == True assert circularQueue.enQueue(4) == True assert circularQueue.Front() == 2 assert circularQueue.Rear() == 4","solution":"class MyCircularQueue: def __init__(self, k: int): Initializes the object with the size of the queue to be k. self.queue = [0] * k self.head_index = 0 self.count = 0 self.capacity = k def enQueue(self, value: int) -> bool: Inserts an element into the circular queue. Return true if the operation is successful. if self.isFull(): return False self.queue[(self.head_index + self.count) % self.capacity] = value self.count += 1 return True def deQueue(self) -> bool: Deletes an element from the circular queue. Return true if the operation is successful. if self.isEmpty(): return False self.head_index = (self.head_index + 1) % self.capacity self.count -= 1 return True def Front(self) -> int: Gets the front item from the queue. If the queue is empty, return -1. if self.isEmpty(): return -1 return self.queue[self.head_index] def Rear(self) -> int: Gets the last item from the queue. If the queue is empty, return -1. if self.isEmpty(): return -1 return self.queue[(self.head_index + self.count - 1) % self.capacity] def isEmpty(self) -> bool: Checks whether the circular queue is empty or not. return self.count == 0 def isFull(self) -> bool: Checks whether the circular queue is full or not. return self.count == self.capacity"},{"question":"def find_anagram_indices(s: str, p: str) -> List[int]: Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order. Args: s : str : input string p : str : string whose anagrams are to be found in s Returns: List[int] : start indices of each anagram of p in s Examples: >>> find_anagram_indices(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> find_anagram_indices(\\"abab\\", \\"ab\\") [0, 1, 2] >>> find_anagram_indices(\\"aaaaaa\\", \\"a\\") [0, 1, 2, 3, 4, 5] >>> find_anagram_indices(\\"abcdefg\\", \\"gfedcba\\") [0] >>> find_anagram_indices(\\"xyz\\", \\"abc\\") []","solution":"def find_anagram_indices(s, p): from collections import Counter # Resultant list result = [] p_len = len(p) s_len = len(s) p_counter = Counter(p) window_counter = Counter(s[:p_len-1]) for i in range(p_len-1, s_len): window_counter[s[i]] += 1 # include a new char in the window if window_counter == p_counter: # This step is O(1) since there are at most 26 English letters result.append(i-p_len+1) # Remove oldest char in the window window_counter[s[i-p_len+1]] -= 1 # Remove the count of character completely if it's zero if window_counter[s[i-p_len+1]] == 0: del window_counter[s[i-p_len+1]] return result"},{"question":"def count_common_items(list1: str, list2: str, list3: str, list4: str) -> dict: Write a function that takes in four strings representing shopping lists from four different stores. Each string contains a list of items, separated by a comma. The function should return a dictionary where the keys are the items and the values are the number of stores that have that item on their list. Example: >>> list1 = \\"apples, bananas, carrots, dates\\" >>> list2 = \\"bananas, dates, eggs, figs\\" >>> list3 = \\"grapes, apples, bananas, eggs\\" >>> list4 = \\"carrots, dates, figs, apples\\" >>> count_common_items(list1, list2, list3, list4) { 'apples': 3, 'bananas': 3, 'carrots': 2, 'dates': 3, 'eggs': 2, 'figs': 2, 'grapes': 1 } from solution import count_common_items def test_common_items_example(): list1 = \\"apples, bananas, carrots, dates\\" list2 = \\"bananas, dates, eggs, figs\\" list3 = \\"grapes, apples, bananas, eggs\\" list4 = \\"carrots, dates, figs, apples\\" expected_output = { 'apples': 3, 'bananas': 3, 'carrots': 2, 'dates': 3, 'eggs': 2, 'figs': 2, 'grapes': 1 } assert count_common_items(list1, list2, list3, list4) == expected_output def test_no_common_items(): list1 = \\"a, b, c\\" list2 = \\"d, e, f\\" list3 = \\"g, h, i\\" list4 = \\"j, k, l\\" expected_output = { 'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1, 'h': 1, 'i': 1, 'j': 1, 'k': 1, 'l': 1 } assert count_common_items(list1, list2, list3, list4) == expected_output def test_all_same_items(): list1 = \\"a, b, c\\" list2 = \\"a, b, c\\" list3 = \\"a, b, c\\" list4 = \\"a, b, c\\" expected_output = { 'a': 4, 'b': 4, 'c': 4 } assert count_common_items(list1, list2, list3, list4) == expected_output def test_partial_overlap(): list1 = \\"a, b\\" list2 = \\"b, c\\" list3 = \\"c, d\\" list4 = \\"d, e\\" expected_output = { 'a': 1, 'b': 2, 'c': 2, 'd': 2, 'e': 1 } assert count_common_items(list1, list2, list3, list4) == expected_output","solution":"def count_common_items(list1: str, list2: str, list3: str, list4: str) -> dict: Count how many lists each item appears in. from collections import defaultdict # Split each list and convert them to sets for easy comparison set1 = set(list1.split(', ')) set2 = set(list2.split(', ')) set3 = set(list3.split(', ')) set4 = set(list4.split(', ')) # Use a defaultdict to count the appearances in lists item_counts = defaultdict(int) # Count appearances in each set for item in set1: item_counts[item] += 1 for item in set2: item_counts[item] += 1 for item in set3: item_counts[item] += 1 for item in set4: item_counts[item] += 1 return dict(item_counts)"},{"question":"def reverse_words_in_sentences(sentences: List[str]) -> List[str]: This function takes a list of sentences and returns a new list where each sentence has its words reversed. Punctuation remains attached to the words they follow, and the original capitalization is preserved. >>> reverse_words_in_sentences([\\"Hello, world!\\"]) == [\\"world! Hello,\\"] >>> reverse_words_in_sentences([\\"Python is fun.\\"]) == [\\"fun. is Python\\"] >>> reverse_words_in_sentences([\\"Coding challenges are great.\\"]) == [\\"great. are challenges Coding\\"] >>> reverse_words_in_sentences([\\"\\"]) == [\\"\\"] >>> reverse_words_in_sentences([\\"Hello\\"]) == [\\"Hello\\"]","solution":"def reverse_words_in_sentences(sentences): This function takes a list of sentences and returns a new list where each sentence has its words reversed. Punctuation remains attached to the words they follow, and original capitalization is preserved. reversed_sentences = [] for sentence in sentences: words = sentence.split() reversed_sentence = ' '.join(reversed(words)) reversed_sentences.append(reversed_sentence) return reversed_sentences"},{"question":"def max_consecutive_sum(nums: List[int], k: int) -> int: Returns the maximum sum of k consecutive elements in the list nums. If k is larger than the list length or any other edge case, return 0. >>> max_consecutive_sum([1, 2, 3, 4, 5], 2) == 9 >>> max_consecutive_sum([5, 4, 3, 2, 1], 3) == 12 >>> max_consecutive_sum([1, 2, 3, 4], 4) == 10 >>> max_consecutive_sum([1, 2, 3], 1) == 3 >>> max_consecutive_sum([1, 2, 3], 4) == 0 >>> max_consecutive_sum([], 1) == 0 >>> max_consecutive_sum([1, 2, 3], 0) == 0 >>> max_consecutive_sum([1, 2, 3], -1) == 0 >>> max_consecutive_sum([5], 1) == 5 >>> max_consecutive_sum([-1, -2, -3, -4, -5], 3) == -6 >>> max_consecutive_sum([-5, -4, -3, -2, -1], 2) == -3 >>> max_consecutive_sum([1, -2, 3, -4, 5], 2) == 1 >>> max_consecutive_sum([1, -2, 3, -4, 5], 3) == 4","solution":"def max_consecutive_sum(nums, k): Returns the maximum sum of k consecutive elements in the list nums. If k is larger than the list length or any other edge case, return 0. if k > len(nums) or k <= 0: return 0 max_sum = current_sum = sum(nums[:k]) for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def calculate_powers(numbers: List[int]) -> List[Tuple[int, int, int]]: Takes a list of integers and returns a list of tuples. Each tuple contains the original integer, its square, and its cube. >>> calculate_powers([1, 2, 3]) [(1, 1, 1), (2, 4, 8), (3, 9, 27)] >>> calculate_powers([-1, -2, -3]) [(-1, 1, -1), (-2, 4, -8), (-3, 9, -27)] >>> calculate_powers([-1, 0, 1]) [(-1, 1, -1), (0, 0, 0), (1, 1, 1)] >>> calculate_powers([0]) [(0, 0, 0)] >>> calculate_powers([4]) [(4, 16, 64)] >>> calculate_powers([-4]) [(-4, 16, -64)] pass","solution":"def calculate_powers(numbers): Takes a list of integers and returns a list of tuples. Each tuple contains the original integer, its square, and its cube. return [(n, n**2, n**3) for n in numbers]"},{"question":"from typing import List, Dict, Any def calculate_average_grades(data: List[Dict[str, Any]]) -> Dict[str, float]: Calculate the average grade for each student. :param data: List of dictionaries containing students' names and their grades. :return: Dictionary with each student's name as a key and their average grade as the value. >>> data = [ ... {\\"name\\": \\"Alice\\", \\"grades\\": {\\"math\\": 85, \\"science\\": 92, \\"literature\\": 78}}, ... {\\"name\\": \\"Bob\\", \\"grades\\": {\\"math\\": 79, \\"science\\": 85}}, ... {\\"name\\": \\"Charlie\\", \\"grades\\": {\\"literature\\": 91, \\"math\\": 83, \\"science\\": 87}} ... ] >>> calculate_average_grades(data) {'Alice': 85.0, 'Bob': 82.0, 'Charlie': 87.0} >>> data = [] >>> calculate_average_grades(data) {} >>> data = [ ... {\\"name\\": \\"David\\", \\"grades\\": {}} ... ] >>> calculate_average_grades(data) {'David': 0.0} >>> data = [ ... {\\"name\\": \\"Eve\\", \\"grades\\": {\\"math\\": 90}}, ... {\\"name\\": \\"Frank\\", \\"grades\\": {\\"science\\": 78, \\"math\\": 88}}, ... {\\"name\\": \\"Grace\\", \\"grades\\": {}} ... ] >>> calculate_average_grades(data) {'Eve': 90.0, 'Frank': 83.0, 'Grace': 0.0}","solution":"from typing import List, Dict, Any def calculate_average_grades(data: List[Dict[str, Any]]) -> Dict[str, float]: Calculate the average grade for each student. :param data: List of dictionaries containing students' names and their grades. :return: Dictionary with each student's name as a key and their average grade as the value. average_grades = {} for student in data: name, grades = student['name'], student['grades'] if grades: average = sum(grades.values()) / len(grades) average_grades[name] = average else: average_grades[name] = 0.0 return average_grades"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Determine the contiguous subarray (containing at least one number) which has the largest sum and return that sum. Args: nums (List[int]): An array of integers. Returns: int: The largest sum of the contiguous subarray. Examples: >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23","solution":"def max_subarray_sum(nums): Find the contiguous subarray within an array (containing at least one number) which has the largest sum. :param nums: List of integers :return: The largest sum of the contiguous subarray max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def evaluate_expression(expression: str) -> float: Parses a string representation of a mathematical expression and evaluates its value. The expression may include integers, addition (+), subtraction (-), multiplication (*), and division (/). The function should handle parentheses to dictate the order of operations. Return the evaluated result as a float. Args: expression (str): The mathematical expression to evaluate. Returns: float: The result of evaluating the expression. Raises: ValueError: If the expression is invalid. Examples: >>> evaluate_expression(\\"2 + 3\\") 5.0 >>> evaluate_expression(\\"5 - 2\\") 3.0 >>> evaluate_expression(\\"3 * 4\\") 12.0 >>> evaluate_expression(\\"10 / 2\\") 5.0 >>> evaluate_expression(\\"3 + 5 * 2\\") 13.0 >>> evaluate_expression(\\"3 + 5 * (2 - 8) / 2\\") -12.0 >>> evaluate_expression(\\"(1 + (2 * (2 + 3)))\\") 11.0 >>> evaluate_expression(\\" 2 + 3 \\") 5.0 >>> evaluate_expression(\\"invalid\\") Traceback (most recent call last): ... ValueError: Invalid expression: ... >>> evaluate_expression(\\"5 + (3 * 2\\") Traceback (most recent call last): ... ValueError: Invalid expression: Mismatched parentheses in expression","solution":"def evaluate_expression(expression): def parse_expression(expr): stack = [] num = 0 prev_op = '+' operands = [] i = 0 while i < len(expr): char = expr[i] if char.isdigit() or char == '.': num_str = [] while i < len(expr) and (expr[i].isdigit() or expr[i] == '.'): num_str.append(expr[i]) i += 1 num_str = ''.join(num_str) operands.append(float(num_str)) i -= 1 # Adjust for the extra increment in the inner loop elif char in '+-*/': evaluate_stack(stack, prev_op, operands.pop()) prev_op = char operands.clear() elif char == '(': end = find_closing_bracket(expr, i) inner_expr = expr[i + 1:end] operands.append(parse_expression(inner_expr)) i = end i += 1 if operands: evaluate_stack(stack, prev_op, operands.pop()) return sum(stack) def evaluate_stack(stack, op, num): if op == '+': stack.append(num) elif op == '-': stack.append(-num) elif op == '*': stack[-1] *= num elif op == '/': stack[-1] /= num def find_closing_bracket(expr, start): stack = [] for i in range(start, len(expr)): if expr[i] == '(': stack.append('(') elif expr[i] == ')': stack.pop() if not stack: return i raise ValueError(\\"Mismatched parentheses in expression\\") try: return float(parse_expression(expression)) except Exception as e: raise ValueError(f\\"Invalid expression: {e}\\") # Example usage: try: result = evaluate_expression(\\"3 + 5 * (2 - 8) / 2\\") print(result) # Output: 2.0 except ValueError as e: print(e)"},{"question":"def balanced_brackets(s: str) -> bool: Checks if a string containing brackets is balanced. A string is considered balanced if the brackets are correctly nested and every opening bracket has a corresponding closing bracket of the same type. :param s: A string containing brackets ({, }, (, ), [, ]). :return: A boolean indicating if the string is balanced. >>> balanced_brackets(\\"(){}[]\\") True >>> balanced_brackets(\\"([{}])\\") True >>> balanced_brackets(\\"(}\\") False >>> balanced_brackets(\\"[(])\\") False >>> balanced_brackets(\\"[({})](]\\") False # Your code here pass def test_balanced_brackets(): assert balanced_brackets(\\"(){}[]\\") == True assert balanced_brackets(\\"([{}])\\") == True assert balanced_brackets(\\"(}\\") == False assert balanced_brackets(\\"[(])\\") == False assert balanced_brackets(\\"[({})](]\\") == False assert balanced_brackets(\\"\\") == True assert balanced_brackets(\\"()\\") == True assert balanced_brackets(\\"(\\") == False assert balanced_brackets(\\")\\") == False assert balanced_brackets(\\"([])\\") == True assert balanced_brackets(\\"([)]\\") == False assert balanced_brackets(\\"{[(\\") == False assert balanced_brackets(\\"(()\\") == False assert balanced_brackets(\\"[{]\\") == False assert balanced_brackets(\\"(a+b)*(c-d)\\") == True assert balanced_brackets(\\"{[abc](xyz)}\\") == True assert balanced_brackets(\\"(a+b*[x-y])\\") == True assert balanced_brackets(\\"{a+(b*c)]\\") == False assert balanced_brackets(\\"[a*(b-c)]})\\") == False print(\\"All tests passed!\\")","solution":"def balanced_brackets(s): Checks if a string containing brackets is balanced. :param s: A string containing brackets. :return: A boolean indicating if the string is balanced. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False else: continue # Ignore non-bracket characters, although they should not appear return stack == []"},{"question":"def maxDifference(arr): This function takes a list of integers and returns the maximum difference between two elements such that the larger element comes after the smaller element. Parameters: arr (list): List of integers Returns: int: The maximum difference if found, otherwise 0. >>> maxDifference([2, 3, 10, 2, 4, 8, 1]) 8 >>> maxDifference([7, 9, 5, 6, 3, 2]) 2 >>> maxDifference([5, 4, 3, 2, 1]) 0 >>> maxDifference([1, 2, 3, 4, 5]) 4","solution":"def maxDifference(arr): This function takes a list of integers and returns the maximum difference between two elements such that the larger element comes after the smaller element. Parameters: arr (list): List of integers Returns: int: The maximum difference if found, otherwise 0. if len(arr) < 2: return 0 min_element = arr[0] max_diff = 0 for number in arr[1:]: if number - min_element > max_diff: max_diff = number - min_element if number < min_element: min_element = number return max_diff"},{"question":"def two_sum(nums: List[int], target: int) -> Tuple[Optional[int], Optional[int]]: Returns a tuple of two distinct elements from the list that add up to the target, or None if no such pair exists. Args: nums (list of int): The list of integers. target (int): The target sum. Returns: tuple: A tuple containing two integers that add up to the target. >>> two_sum([2, 7, 11, 15], 9) == (2, 7) >>> two_sum([1, 2, 3, 4], 8) == None >>> two_sum([1, 3, 2, 4, 6, 7], 9) == (3, 6) from solution import two_sum def test_two_sum_pair_exists(): assert two_sum([2, 7, 11, 15], 9) == (2, 7) def test_two_sum_no_pair_exists(): assert two_sum([1, 2, 3, 4], 8) == None def test_two_sum_multiple_pairs(): assert two_sum([1, 3, 2, 4, 6, 7], 9) == (3, 6) # Since there is guaranteed to be one solution, we test one possible correct answer. def test_two_sum_same_elements(): assert two_sum([3, 3, 4, 7], 6) == (3, 3) def test_two_sum_large_numbers(): assert two_sum([1000000, 500000, 1005000], 1500000) == (1000000, 500000)","solution":"def two_sum(nums, target): Returns a tuple of two distinct elements from the list that add up to the target, or None if no such pair exists. Args: nums (list of int): The list of integers. target (int): The target sum. Returns: tuple: A tuple containing two integers that add up to the target. num_dict = {} for num in nums: complement = target - num if complement in num_dict: return (complement, num) num_dict[num] = True return None"},{"question":"import math def check_perfect_square(n: int) -> tuple: Design a Python function that achieves two objectives: first, it verifies if a number is a perfect square; second, it confirms if the integer square root of that number itself forms a perfect square. The function should return a tuple, with the first element being the boolean result confirming if the number is a perfect square, and the second being the boolean result verifying if the integer square root is also a perfect square. Args: n (int): The number to be checked. Must be a non-negative integer. Returns: tuple: A tuple where the first element indicates if n is a perfect square, and the second element indicates if the integer square root of n is a perfect square. Example: >>> check_perfect_square(16) (True, True) >>> check_perfect_square(14) (False, False)","solution":"import math def check_perfect_square(n): Checks if a number is a perfect square and its integer square root is also a perfect square. Args: n (int): The number to be checked. Must be a non-negative integer. Returns: tuple: A tuple where the first element indicates if n is a perfect square, and the second element indicates if the integer square root of n is a perfect square. if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") # Check if n is a perfect square sqrt_n = int(math.isqrt(n)) is_perfect_square = sqrt_n * sqrt_n == n # Check if the integer square root of n is a perfect square if is_perfect_square: sqrt_sqrt_n = int(math.isqrt(sqrt_n)) is_sqrt_perfect_square = sqrt_sqrt_n * sqrt_sqrt_n == sqrt_n else: is_sqrt_perfect_square = False return (is_perfect_square, is_sqrt_perfect_square)"},{"question":"def sum_dict_values(input_dict: dict) -> dict: Takes a dictionary where keys are strings and values are lists of integers, and returns a new dictionary where each key's value is replaced by the sum of the integers in the list. >>> sum_dict_values({'a': [1, 2, 3], 'b': [4, 5, 6], 'c': [7, 8, 9]}) == {'a': 6, 'b': 15, 'c': 24} >>> sum_dict_values({'a': [], 'b': [], 'c': []}) == {'a': 0, 'b': 0, 'c': 0} >>> sum_dict_values({'a': [5], 'b': [10], 'c': [15]}) == {'a': 5, 'b': 10, 'c': 15} >>> sum_dict_values({'a': [1, -1, 2], 'b': [4, -2, 6], 'c': [7, 0, 2]}) == {'a': 2, 'b': 8, 'c': 9} >>> sum_dict_values({}) == {} >>> sum_dict_values({'a': [1000000, 2000000, 3000000], 'b': [4000000, 5000000, 6000000]}) == {'a': 6000000, 'b': 15000000}","solution":"def sum_dict_values(input_dict): Takes a dictionary where keys are strings and values are lists of integers, and returns a new dictionary where each key's value is replaced by the sum of the integers in the list. :param input_dict: Dictionary with lists of integers as values :return: Dictionary with summed integer values return {key: sum(values) for key, values in input_dict.items()}"},{"question":"from typing import List, Tuple def factorial(n: int) -> int: Returns the factorial of the given integer n. >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(5) 120 def list_factorials(numbers: List[int]) -> List[Tuple[int, int]]: Takes a list of integers and returns a list of tuples. Each tuple contains an integer from the input list and its factorial. >>> list_factorials([]) [] >>> list_factorials([5]) [(5, 120)] >>> list_factorials([1, 2, 3]) [(1, 1), (2, 2), (3, 6)] >>> list_factorials([0, 1, 2]) [(0, 1), (1, 1), (2, 2)]","solution":"from typing import List, Tuple def factorial(n: int) -> int: Returns the factorial of the given integer n. if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result def list_factorials(numbers: List[int]) -> List[Tuple[int, int]]: Takes a list of integers and returns a list of tuples. Each tuple contains an integer from the input list and its factorial. return [(number, factorial(number)) for number in numbers]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rangeSum(root: TreeNode, L: int, R: int) -> int: Computes the sum of all nodes' values that fall between L and R (inclusive). :param root: TreeNode, the root of the binary tree :param L: int, lower bound of the range (inclusive) :param R: int, upper bound of the range (inclusive) :return: int, the sum of values of all nodes within the range [L, R] pass import pytest def test_single_node_within_range(): root = TreeNode(10) assert rangeSum(root, 5, 15) == 10 def test_single_node_outside_range(): root = TreeNode(10) assert rangeSum(root, 15, 20) == 0 def test_multiple_nodes_within_range(): root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(3) root.left.right = TreeNode(7) root.right.right = TreeNode(18) assert rangeSum(root, 7, 15) == 32 def test_all_nodes_within_range(): root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(3) root.left.right = TreeNode(7) root.right.left = TreeNode(13) root.right.right = TreeNode(18) assert rangeSum(root, 1, 20) == 71 def test_no_nodes_within_range(): root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(3) root.left.right = TreeNode(7) root.right.right = TreeNode(18) assert rangeSum(root, 20, 30) == 0 def test_multiple_nodes_within_range_and_empty_subtree(): root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(3) root.left.right = TreeNode(7) root.right.left = TreeNode(13) root.right.right = TreeNode(18) assert rangeSum(root, 6, 15) == 45","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rangeSum(root, L, R): Computes the sum of all nodes' values that fall between L and R (inclusive). :param root: TreeNode, the root of the binary tree :param L: int, lower bound of the range (inclusive) :param R: int, upper bound of the range (inclusive) :return: int, the sum of values of all nodes within the range [L, R] if not root: return 0 sum = 0 if L <= root.val <= R: sum += root.val if root.val > L: sum += rangeSum(root.left, L, R) if root.val < R: sum += rangeSum(root.right, L, R) return sum"},{"question":"from typing import List, Tuple def student_with_highest_average(records: List[Tuple[str, List[int]]]) -> str: Returns the name of the student with the highest average score. If multiple students have the highest average, returns the name that comes first alphabetically. :param records: List of tuples, each containing a student name and a list of their scores in various subjects :return: Name of the student with the highest average score >>> student_with_highest_average([('Alice', [80, 90, 85]), ('Bob', [70, 85, 90]), ('Charlie', [95, 100, 90])]) 'Charlie' >>> student_with_highest_average([('Alice', [90, 90, 90]), ('Bob', [80, 95, 85]), ('Charlie', [85, 100, 75])]) 'Alice' >>> student_with_highest_average([('Charlie', [90, 95, 85]), ('Alice', [92, 88, 90]), ('Bob', [95, 90, 85])]) 'Alice' pass","solution":"def student_with_highest_average(records): Returns the name of the student with the highest average score. If multiple students have the highest average, returns the name that comes first alphabetically. :param records: List of tuples, each containing a student name and a list of their scores in various subjects :return: Name of the student with the highest average score def average(scores): return sum(scores) / len(scores) highest_average = -1 top_student = \\"\\" for name, scores in records: avg = average(scores) if avg > highest_average or (avg == highest_average and name < top_student): highest_average = avg top_student = name return top_student"},{"question":"def divisible_and_reversed(lst: List[int], n: int) -> List[int]: Write a Python function that takes a list of integers and an integer \`n\`. The function should return a new list containing all the elements of the original list that are divisible by \`n\`, but with the order of elements reversed. >>> divisible_and_reversed([12, 4, 9, 10, 28, 45, 30], 3) [30, 45, 9, 12] >>> divisible_and_reversed([1, 2, 4, 5], 3) [] >>> divisible_and_reversed([3, 6, 9, 12], 3) [12, 9, 6, 3] >>> divisible_and_reversed([0, 3, 6, 9], 3) [9, 6, 3, 0] >>> divisible_and_reversed([-12, -9, 0, 9, 12], 3) [12, 9, 0, -9, -12]","solution":"def divisible_and_reversed(lst, n): Returns a list of elements from lst that are divisible by n, in reversed order. Parameters: lst (list): A list of integers. n (int): The integer to check divisibility against. Returns: list: A list of integers divisible by n, in reversed order. # Filtering elements divisible by n divisible_elements = [x for x in lst if x % n == 0] # Reversing the order return divisible_elements[::-1]"},{"question":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list without using built-in sorting functions. >>> merge_sorted_lists([], []) == [] True >>> merge_sorted_lists([], [1, 2, 3]) == [1, 2, 3] True >>> merge_sorted_lists([1, 2, 3], []) == [1, 2, 3] True >>> merge_sorted_lists([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6] True >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] True >>> merge_sorted_lists([1, 2, 2, 3], [2, 2, 4]) == [1, 2, 2, 2, 2, 3, 4] True >>> list1 = [-10, -3, 0, 2, 9] >>> list2 = [-5, -2, 1, 3, 4, 10] >>> merge_sorted_lists(list1, list2) == [-10, -5, -3, -2, 0, 1, 2, 3, 4, 9, 10] True","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list. :param list1: First sorted list :param list2: Second sorted list :return: Merged sorted list merged_list = [] i, j = 0, 0 # Traverse both lists, comparing elements and appending the smaller one while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # If there are any remaining elements in list1 or list2, add them to the merged list while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def atm_transaction(initial_balance, withdrawal_amount, deposit_amount): Simulates an ATM transaction. Parameters: initial_balance (float): the initial balance in the account withdrawal_amount (float): the amount to withdraw from the account deposit_amount (float): the amount to deposit into the account Returns: float: the final balance after the transactions >>> atm_transaction(500, 100, 200) 600.0 >>> atm_transaction(500, 600, 100) \\"Insufficient funds for the withdrawal.\\" >>> atm_transaction(500, -100, 200) \\"Amounts must be non-negative.\\" >>> atm_transaction(500, \\"100\\", 200) \\"All amounts must be numbers.\\" from solution import atm_transaction def test_atm_transaction_valid(): assert atm_transaction(500, 100, 200) == 600.0 def test_atm_transaction_insufficient_funds(): assert atm_transaction(500, 600, 100) == \\"Insufficient funds for the withdrawal.\\" def test_atm_transaction_negative_amounts(): assert atm_transaction(500, -100, 200) == \\"Amounts must be non-negative.\\" assert atm_transaction(500, 100, -200) == \\"Amounts must be non-negative.\\" assert atm_transaction(-500, 100, 200) == \\"Amounts must be non-negative.\\" def test_atm_transaction_invalid_types(): assert atm_transaction(500, \\"100\\", 200) == \\"All amounts must be numbers.\\" assert atm_transaction(\\"500\\", 100, 200) == \\"All amounts must be numbers.\\" assert atm_transaction(500, 100, \\"200\\") == \\"All amounts must be numbers.\\" assert atm_transaction(\\"500\\", \\"100\\", \\"200\\") == \\"All amounts must be numbers.\\" def test_atm_transaction_exact_withdrawal(): assert atm_transaction(500, 500, 0) == 0.0","solution":"def atm_transaction(initial_balance, withdrawal_amount, deposit_amount): Simulates an ATM transaction. Parameters: initial_balance (float): the initial balance in the account withdrawal_amount (float): the amount to withdraw from the account deposit_amount (float): the amount to deposit into the account Returns: float: the final balance after the transactions try: # Validate input types if not (isinstance(initial_balance, (int, float)) and isinstance(withdrawal_amount, (int, float)) and isinstance(deposit_amount, (int, float))): raise ValueError(\\"All amounts must be numbers.\\") # Validate that amounts are non-negative if withdrawal_amount < 0 or deposit_amount < 0 or initial_balance < 0: raise ValueError(\\"Amounts must be non-negative.\\") # Validate that the withdrawal does not exceed the current balance if withdrawal_amount > initial_balance: raise ValueError(\\"Insufficient funds for the withdrawal.\\") # Update the balance final_balance = initial_balance - withdrawal_amount + deposit_amount return final_balance except ValueError as e: return str(e)"},{"question":"def square_elements(input_list): Returns a list containing the squares of the elements in the input_list. >>> square_elements([1, 2, 3, 4]) == [1, 4, 9, 16] >>> square_elements([-1, -2, -3, -4]) == [1, 4, 9, 16] >>> square_elements([-1, 0, 2, -3]) == [1, 0, 4, 9] >>> square_elements([0]) == [0] >>> square_elements([]) == []","solution":"def square_elements(input_list): Returns a list containing the squares of the elements in the input_list. return [element ** 2 for element in input_list]"},{"question":"class Book: def __init__(self, title: str, author: str, genre: str, price: float, stock_quantity: int): Initialize a book with title, author, genre, price, and stock quantity. pass class Bookstore: def __init__(self): Initialize the bookstore with an empty inventory. pass def add_book(self, book: Book): Add a book to the bookstore inventory. pass def search_books(self, title: str = None, author: str = None, genre: str = None): Search for books in the inventory by title, author, or genre. >>> bookstore = Bookstore() >>> book1 = Book(\\"1984\\", \\"George Orwell\\", \\"Dystopian\\", 15.99, 10) >>> book2 = Book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"Fiction\\", 12.99, 5) >>> bookstore.add_book(book1) >>> bookstore.add_book(book2) >>> search_results = bookstore.search_books(title=\\"1984\\") >>> len(search_results) 1 >>> search_results[0].title '1984' pass def purchase_book(self, title: str): Purchase a book from the inventory, reducing its stock quantity. >>> bookstore = Bookstore() >>> book1 = Book(\\"1984\\", \\"George Orwell\\", \\"Dystopian\\", 15.99, 10) >>> bookstore.add_book(book1) >>> purchased_book = bookstore.purchase_book(\\"1984\\") >>> purchased_book.title '1984' >>> purchased_book.stock_quantity 9 pass","solution":"class Book: def __init__(self, title, author, genre, price, stock_quantity): self.title = title self.author = author self.genre = genre self.price = price self.stock_quantity = stock_quantity class Bookstore: def __init__(self): self.inventory = [] def add_book(self, book): self.inventory.append(book) def search_books(self, title=None, author=None, genre=None): results = [] for book in self.inventory: if (title and title.lower() in book.title.lower()) or (author and author.lower() in book.author.lower()) or (genre and genre.lower() in book.genre.lower()): results.append(book) return results def purchase_book(self, title): for book in self.inventory: if book.title.lower() == title.lower() and book.stock_quantity > 0: book.stock_quantity -= 1 return book return None"},{"question":"def spiral_matrix(m: int, n: int) -> List[List[int]]: Generates an m by n matrix filled with elements from 1 to m*n in spiral order. >>> spiral_matrix(3, 3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> spiral_matrix(4, 1) [[1], [2], [3], [4]]","solution":"def spiral_matrix(m, n): Generates an m x n matrix filled with elements from 1 to m*n in spiral order. matrix = [[0] * n for _ in range(m)] num = 1 left, right, top, bottom = 0, n-1, 0, m-1 while left <= right and top <= bottom: for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 if top <= bottom: for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"def odd_occurrences(arr): Implement a function that takes an array of integers as input and returns a new array containing only the elements that appear an odd number of times in the input array. The returned array should be sorted in ascending order. Args: arr (list): List of integers. Returns: list: List of integers that appear an odd number of times, sorted in ascending order. Examples: >>> odd_occurrences([]) [] >>> odd_occurrences([1]) [1] >>> odd_occurrences([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) [1, 3]","solution":"def odd_occurrences(arr): Returns a new array containing only the elements that appear an odd number of times in the input array. The returned array is sorted in ascending order. from collections import Counter counts = Counter(arr) odd_elements = [elem for elem, count in counts.items() if count % 2 != 0] return sorted(odd_elements)"},{"question":"from typing import Dict import re from collections import defaultdict def count_words(s: str) -> Dict[str, int]: Takes a single string input of space-separated words and returns a dictionary where the keys are the words and the values are the counts of each word's occurrence. Punctuation and capitalization are ignored when counting occurrences. >>> count_words(\\"Hello world! Hello, programming world.\\") {'hello': 2, 'world': 2, 'programming': 1} >>> count_words(\\"Test.\\") {'test': 1} >>> count_words(\\"Test, test, test!\\") {'test': 3} >>> count_words(\\"Caps LOCK CaSe.\\") {'caps': 1, 'lock': 1, 'case': 1} >>> count_words(\\"\\") {} >>> count_words(\\"one two three four five\\") {'one': 1, 'two': 1, 'three': 1, 'four': 1, 'five': 1} >>> count_words(\\"The quick brown fox jumped over the lazy dog, and the quick blue hare.\\") { 'the': 3, 'quick': 2, 'brown': 1, 'fox': 1, 'jumped': 1, 'over': 1, 'lazy': 1, 'dog': 1, 'and': 1, 'blue': 1, 'hare': 1 }","solution":"import re from collections import defaultdict def count_words(s): Takes a single string input of space-separated words and returns a dictionary where the keys are the words and the values are the counts of each word's occurrence. Punctuation and capitalization are ignored when counting occurrences. # Convert string to lowercase s = s.lower() # Remove punctuation using regex s = re.sub(r'[^ws]', '', s) # Split the string into words words = s.split() word_count = defaultdict(int) for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"from typing import List def is_prime(n: int) -> bool: Check if a number is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(18) False pass def filter_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the input list. >>> filter_primes([2, 3, 5, 7, 11, 13]) [2, 3, 5, 7, 11, 13] >>> filter_primes([4, 6, 8, 9, 10, 11, 13, 17, 20]) [11, 13, 17] >>> filter_primes([4, 6, 8, 9, 10, 12]) [] >>> filter_primes([1, 0, -1, -3, -7, 17, 19]) [17, 19] >>> filter_primes([]) [] pass","solution":"def is_prime(n): Check if a number is a prime number. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers): Returns a list of prime numbers from the input list. return [num for num in numbers if is_prime(num)]"},{"question":"def sieve_of_eratosthenes(max_num: int) -> List[int]: Return a list of prime numbers up to max_num using the Sieve of Eratosthenes algorithm. def filter_primes(numbers: List[int]) -> List[int]: Filter and return prime numbers from a list of integers. >>> filter_primes([]) == [] >>> filter_primes([4, 6, 8, 10, 12]) == [] >>> filter_primes([2, 3, 5, 7, 11]) == [2, 3, 5, 7, 11] >>> filter_primes([2, 4, 6, 7, 9, 11, 12, 13]) == [2, 7, 11, 13] >>> filter_primes([1, 2, 3, 5, 10, 11]) == [2, 3, 5, 11] >>> filter_primes(list(range(1, 20))) == [2, 3, 5, 7, 11, 13, 17, 19] >>> filter_primes([2, 2, 3, 3, 4, 5, 5, 6]) == [2, 2, 3, 3, 5, 5]","solution":"def sieve_of_eratosthenes(max_num): Return a list of prime numbers up to max_num using the Sieve of Eratosthenes algorithm. sieve = [True] * (max_num + 1) sieve[0] = sieve[1] = False for start in range(2, int(max_num**0.5) + 1): if sieve[start]: for multiple in range(start*start, max_num + 1, start): sieve[multiple] = False return [num for num, is_prime in enumerate(sieve) if is_prime] def filter_primes(numbers): Filter and return prime numbers from a list of integers. if not numbers: return [] max_num = max(numbers) primes = sieve_of_eratosthenes(max_num) prime_set = set(primes) return [num for num in numbers if num in prime_set]"},{"question":"from typing import List def is_prime(n: int) -> bool: Check whether a given positive integer is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(5) True >>> is_prime(7) True >>> is_prime(11) True >>> is_prime(1) False >>> is_prime(4) False >>> is_prime(6) False >>> is_prime(8) False >>> is_prime(9) False >>> is_prime(10) False >>> is_prime(29) True >>> is_prime(31) True >>> is_prime(37) True >>> is_prime(25) False >>> is_prime(35) False >>> is_prime(49) False","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if (n % i == 0) or (n % (i + 2) == 0): return False i += 6 return True"},{"question":"def square_list(input_list): Takes a list of integers as input and returns a new list containing the square of each integer. >>> square_list([1, 2, 3, 4]) [1, 4, 9, 16] >>> square_list([-1, -2, -3, -4]) [1, 4, 9, 16] >>> square_list([-1, 0, 1, 2]) [1, 0, 1, 4] >>> square_list([5]) [25] >>> square_list([]) []","solution":"def square_list(input_list): Takes a list of integers and returns a new list containing the square of each integer. return [x ** 2 for x in input_list]"},{"question":"from datetime import datetime from typing import Tuple def days_between_dates(date1: str, date2: str) -> int: Calculates the absolute number of days between two dates. Args: date1 (str): The first date in \\"YYYY-MM-DD\\" format. date2 (str): The second date in \\"YYYY-MM-DD\\" format. Returns: int: The absolute number of days between the two dates. >>> days_between_dates(\\"2023-10-01\\", \\"2023-10-01\\") 0 >>> days_between_dates(\\"2023-10-01\\", \\"2023-10-02\\") 1 >>> days_between_dates(\\"2023-10-29\\", \\"2023-11-02\\") 4 >>> days_between_dates(\\"2023-12-31\\", \\"2024-01-01\\") 1 >>> days_between_dates(\\"2020-01-01\\", \\"2023-10-10\\") 1378 >>> days_between_dates(\\"2023-03-15\\", \\"2023-08-20\\") 158","solution":"from datetime import datetime def days_between_dates(date1, date2): Calculates the absolute number of days between two dates. Args: date1 (str): The first date in \\"YYYY-MM-DD\\" format. date2 (str): The second date in \\"YYYY-MM-DD\\" format. Returns: int: The absolute number of days between the two dates. date_format = \\"%Y-%m-%d\\" d1 = datetime.strptime(date1, date_format) d2 = datetime.strptime(date2, date_format) delta = abs((d2 - d1).days) return delta"},{"question":"def find_second_largest(arr): Returns the second largest value in the list or None if not applicable. >>> find_second_largest([3, 1, 4, 1, 5, 9, 2, 6]) 6 >>> find_second_largest([3, 3, 3]) None >>> find_second_largest([10]) None >>> find_second_largest([12, 35, 1, 10, 34, 1]) 34 >>> find_second_largest([]) None >>> find_second_largest([4, 4, 4, 4, 4, 4, 4, 4, 4, 4]) None","solution":"def find_second_largest(arr): Returns the second largest value in the list or None if not applicable. if len(arr) < 2: return None first, second = float('-inf'), float('-inf') for num in arr: if num > first: second = first first = num elif first > num > second: second = num return second if second != float('-inf') else None"},{"question":"def average_rainfall(rainfall: List[int]) -> float: Returns the average rainfall, ignoring any days with no rainfall (represented by a value of 0). The result is rounded to two decimal places. >>> average_rainfall([23, 0, 12, 0, 8, 15, 27, 0, 7, 0]) == 15.33 >>> average_rainfall([0, 0, 0, 0]) == 0.0 >>> average_rainfall([10, 20, 30]) == 20.0 >>> average_rainfall([]) == 0.0 >>> average_rainfall([0, 0, 25, 0]) == 25.0","solution":"def average_rainfall(rainfall): Returns the average rainfall, ignoring any days with no rainfall (represented by a value of 0). The result is rounded to two decimal places. # Filter out the days with no rainfall rainfall = [r for r in rainfall if r != 0] if not rainfall: return 0.0 # Calculate the average avg_rainfall = sum(rainfall) / len(rainfall) # Return the average rounded to two decimal places return round(avg_rainfall, 2)"},{"question":"def validate_sudoku(board): Accept a 9x9 2D array representing a Sudoku board. Validate whether the board satisfies all constraints of a correctly solved Sudoku. A valid Sudoku board (partially filled) ensures: 1. Each row contains the digits 1-9 without repetition. 2. Each column contains the digits 1-9 without repetition. 3. Each of the nine 3x3 sub-boxes contains the digits 1-9 without repetition. The board can contain the integer 0 to represent an empty cell. Return True if the board is valid according to the rules above, False otherwise. Example: board = [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] >>> validate_sudoku(board) True board = [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 8] # Last number in the last row should be 9 for the board to be valid ] >>> validate_sudoku(board) False","solution":"def validate_sudoku(board): Accept a 9x9 2D array representing a Sudoku board. Validate whether the board satisfies all constraints of a correctly solved Sudoku. A valid Sudoku board (partially filled) ensures: 1. Each row contains the digits 1-9 without repetition. 2. Each column contains the digits 1-9 without repetition. 3. Each of the nine 3x3 sub-boxes contains the digits 1-9 without repetition. The board can contain the integer 0 to represent an empty cell. Return True if the board is valid according to the rules above, False otherwise. def is_valid_unit(unit): unit = [num for num in unit if num != 0] return len(unit) == len(set(unit)) def is_valid_row(board): for row in board: if not is_valid_unit(row): return False return True def is_valid_column(board): for col in range(9): column = [board[row][col] for row in range(9)] if not is_valid_unit(column): return False return True def is_valid_subgrid(board): for row in range(0, 9, 3): for col in range(0, 9, 3): subgrid = [board[r][c] for r in range(row, row+3) for c in range(col, col+3)] if not is_valid_unit(subgrid): return False return True return is_valid_row(board) and is_valid_column(board) and is_valid_subgrid(board)"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"aaaaa\\") 1 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"abc abc\\") 4 >>> length_of_longest_substring(\\"123abc123\\") 6","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"from typing import List def kth_smallest_element(array: List[int], k: int) -> int: Returns the k-th smallest element in the array. Parameters: array (List[int]): The list of integers. k (int): The 1-based index of the k-th smallest element to be found. Returns: int: The k-th smallest element in the array. Examples: >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 3) 7 >>> kth_smallest_element([5, 3, 1, 6, 4, 2], 5) 5","solution":"from typing import List def kth_smallest_element(array: List[int], k: int) -> int: Returns the k-th smallest element in the array. Parameters: array (List[int]): The list of integers. k (int): The 1-based index of the k-th smallest element to be found. Returns: int: The k-th smallest element in the array. # Sort the array sorted_array = sorted(array) # Return the k-th smallest element based on 1-based index return sorted_array[k - 1]"},{"question":"def word_length_starting_with_vowel(words: List[str]) -> int: Identify the first word in the list that begins with a vowel and return its length. >>> word_length_starting_with_vowel([\\"zebra\\", \\"apple\\", \\"computer\\", \\"orange\\"]) == 5 >>> word_length_starting_with_vowel([\\"zebra\\", \\"computer\\", \\"orange\\"]) == 6 >>> word_length_starting_with_vowel([\\"zebra\\", \\"apple\\", \\"octopus\\", \\"orange\\"]) == 5 >>> word_length_starting_with_vowel([\\"zebra\\", \\"apple\\", \\"computer\\"]) == 5 >>> word_length_starting_with_vowel([\\"zebra\\", \\"computer\\", \\"laptop\\"]) == None >>> word_length_starting_with_vowel([]) == None","solution":"def word_length_starting_with_vowel(words): Returns the length of the first word in the list that starts with a vowel. vowels = 'AEIOUaeiou' for word in words: if word[0] in vowels: return len(word) return None"},{"question":"from typing import List, Tuple, Union def calculate_average_scores(students: List[Tuple[str, int, int, int]]) -> Union[List[str], str]: Write a function that takes a list of tuples where each tuple contains a student's name and their corresponding scores in three different subjects. The function should calculate the average score for each student and return a sorted list of student names based on their average scores in descending order. In case of a tie, sort the names alphabetically. If the function receives an empty list or any tuple that does not contain exactly four elements (name and three scores), it should return \\"Invalid input\\". >>> calculate_average_scores([ ... ('John', 88, 77, 93), ... ('Alice', 85, 90, 92), ... ('Bob', 78, 81, 79), ... ('Jane', 92, 85, 88), ... ('Emma', 88, 84, 90) ... ]) ['Alice', 'Jane', 'Emma', 'John', 'Bob'] >>> calculate_average_scores([]) 'Invalid input' >>> calculate_average_scores([ ... ('John', 88, 77, 93), ... ('Alice', 85, 90), ... ('Bob', 78, 81, 79), ... ]) 'Invalid input' >>> calculate_average_scores([ ... ('John', 88, 77, 93), ... ('Jane', 92, 85, 88), ... ('Jake', 92, 85, 88) ... ]) ['Jake', 'Jane', 'John'] >>> calculate_average_scores([ ... ('John', 80, 80, 80), ... ('Jane', 80, 80, 80), ... ('Jake', 80, 80, 80) ... ]) ['Jake', 'Jane', 'John']","solution":"def calculate_average_scores(students): if not students: return \\"Invalid input\\" # Check for invalid tuples for student in students: if len(student) != 4: return \\"Invalid input\\" # Calculate averages and map to names averages = [(student[0], (student[1] + student[2] + student[3]) / 3) for student in students] # Sort by average score descending, then by name ascending sorted_students = sorted(averages, key=lambda x: (-x[1], x[0])) # Extract names sorted_names = [student[0] for student in sorted_students] return sorted_names"},{"question":"def char_frequency(s): Returns the frequency of each character in the string s. The function ignores case sensitivity and spaces. :param s: input string :type s: str :return: dictionary with character frequencies :rtype: dict :raises TypeError: if input is not a string pass","solution":"def char_frequency(s): Returns the frequency of each character in the string s. The function ignores case sensitivity and spaces. :param s: input string :type s: str :return: dictionary with character frequencies :rtype: dict :raises TypeError: if input is not a string if not isinstance(s, str): raise TypeError('Input must be a string') s = s.replace(' ', '').lower() freq = {} for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 return freq"},{"question":"def is_palindrome(s: str) -> bool: Determines if a given string is a palindrome, ignoring spaces, punctuation, and capitalization. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"Madam\\") == True >>> is_palindrome(\\"MadamInEdenImAdam\\") == True >>> is_palindrome(\\"No 'x' in Nixon\\") == True >>> is_palindrome(\\"This is not a palindrome\\") == False >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"12321\\") == True >>> is_palindrome(\\"12345\\") == False","solution":"import re def is_palindrome(s): Determines if a given string is a palindrome, ignoring spaces, punctuation, and capitalization. cleaned_string = re.sub(r'[^A-Za-z0-9]', '', s).lower() return cleaned_string == cleaned_string[::-1]"},{"question":"def remove_occurrences(lst: List[int], n: int) -> List[int]: Write a function that takes a list of integers and an integer 'n', and returns the list with all occurrences of 'n' removed. If 'n' is not present in the list, return the original list. >>> remove_occurrences([1, 3, 4, 5], 2) == [1, 3, 4, 5] >>> remove_occurrences([1, 2, 3, 4, 2, 2, 5], 2) == [1, 3, 4, 5] >>> remove_occurrences([2, 2, 2, 2], 2) == [] >>> remove_occurrences([], 2) == [] >>> remove_occurrences([1, 2, 3, 4, 5], 2) == [1, 3, 4, 5] >>> remove_occurrences([1, 3, 4, 5], 6) == [1, 3, 4, 5]","solution":"def remove_occurrences(lst, n): Removes all occurrences of n from the list lst. If n is not present, returns the original list. Parameters: lst (list of int): The list of integers. n (int): The integer to be removed. Returns: list of int: The list with all occurrences of n removed. return [x for x in lst if x != n]"},{"question":"from typing import List def sort_list(nums: List[int]) -> List[int]: Takes an unordered list of integer elements and returns the list in ascending order, while retaining any occurrences of duplicate elements. >>> sort_list([34, 7, 23, 32, 5, 62, 7, 3]) [3, 5, 7, 7, 23, 32, 34, 62] >>> sort_list([1, 3, 2, 3, 1, 2, 1]) [1, 1, 1, 2, 2, 3, 3] >>> sort_list([4, 4, 4, 4, 4]) [4, 4, 4, 4, 4] >>> sort_list([]) [] >>> sort_list([99]) [99] >>> sort_list([0, -10, 5, -3, 2, -1]) [-10, -3, -1, 0, 2, 5]","solution":"def sort_list(nums): Returns the input list sorted in ascending order. return sorted(nums)"},{"question":"class Library: def __init__(self): self.books = [] self.borrowed_books = [] def add_book(self, title, author): Method to add a book to the library pass def borrow_book(self, title): Method to borrow a book from the library Returns a message indicating whether the borrowing was successful or not. pass def return_book(self, title): Method to return a borrowed book to the library Returns a message indicating whether the return was successful or not. pass # Example usage library = Library() library.add_book(\\"1984\\", \\"George Orwell\\") library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\") print(library.borrow_book(\\"1984\\")) # You have successfully borrowed '1984' print(library.borrow_book(\\"1984\\")) # '1984' is already borrowed or not available in the library print(library.return_book(\\"1984\\")) # You have successfully returned '1984' print(library.return_book(\\"1984\\")) # '1984' was not borrowed print(library.books) # [{\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\"}, {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\"}] print(library.borrowed_books) # []","solution":"class Library: def __init__(self): self.books = [] self.borrowed_books = [] def add_book(self, title, author): self.books.append({\\"title\\": title, \\"author\\": author}) def borrow_book(self, title): for book in self.books: if book['title'] == title: self.borrowed_books.append(book) self.books.remove(book) return f\\"You have successfully borrowed '{title}'\\" return f\\"'{title}' is already borrowed or not available in the library\\" def return_book(self, title): for book in self.borrowed_books: if book['title'] == title: self.books.append(book) self.borrowed_books.remove(book) return f\\"You have successfully returned '{title}'\\" return f\\"'{title}' was not borrowed\\" # Example usage library = Library() library.add_book(\\"1984\\", \\"George Orwell\\") library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\") print(library.borrow_book(\\"1984\\")) # You have successfully borrowed '1984' print(library.borrow_book(\\"1984\\")) # '1984' is already borrowed or not available in the library print(library.return_book(\\"1984\\")) # You have successfully returned '1984' print(library.return_book(\\"1984\\")) # '1984' was not borrowed print(library.books) # [{\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\"}, {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\"}] print(library.borrowed_books) # []"},{"question":"def flatten_dict(d, parent_key='', sep='.'): Flatten a nested dictionary. Concatenates keys in nested dictionaries with a specified separator. Args: d (dict): The dictionary to flatten. parent_key (str): The base key string to be concatenated (used in recursion). sep (str): The separator to use between concatenated keys. Returns: dict: A new dictionary with flattened keys. Examples: >>> flatten_dict({'a': 1, 'b': {'c': 2, 'd': {'e': 3}}}) {'a': 1, 'b.c': 2, 'b.d.e': 3} >>> flatten_dict({'a': 1, 'b': 2}) {'a': 1, 'b': 2} >>> flatten_dict({}) {} >>> flatten_dict({'a': {'b': {'c': {'d': 1}}}}) {'a.b.c.d': 1}","solution":"def flatten_dict(d, parent_key='', sep='.'): Flatten a nested dictionary. Parameters: d (dict): The dictionary to flatten. parent_key (str): The base key string (used in recursion). sep (str): The separator to use between concatenated keys. Returns: dict: A new flattened dictionary. flat_dict = {} for k, v in d.items(): new_key = parent_key + sep + k if parent_key else k if isinstance(v, dict): flat_dict.update(flatten_dict(v, new_key, sep=sep)) else: flat_dict[new_key] = v return flat_dict"},{"question":"def temperature_translator(temp, scale): Converts the temperature from Celsius to Fahrenheit or vice versa. Parameters: - temp (int or float): The temperature value to be converted. - scale (str): The scale to convert to ('C' for Celsius, 'F' for Fahrenheit). Returns: - float: The converted temperature. - str: 'Invalid scale' if an invalid scale is provided. Examples: >>> temperature_translator(0, 'C') 32.0 >>> temperature_translator(32, 'F') 0.0 >>> temperature_translator(100, 'C') 212.0 >>> temperature_translator(212, 'F') 100.0 >>> temperature_translator(75, 'G') 'Invalid scale'","solution":"def temperature_translator(temp, scale): Converts the temperature from Celsius to Fahrenheit or vice versa. Parameters: - temp (int or float): The temperature value to be converted. - scale (str): The scale to convert to ('C' for Celsius, 'F' for Fahrenheit). Returns: - float: The converted temperature. - str: 'Invalid scale' if an invalid scale is provided. if scale == 'C': return (temp * 9/5) + 32 elif scale == 'F': return (temp - 32) * 5/9 else: return 'Invalid scale'"},{"question":"def frequency_sort(s: str) -> str: Function to sort characters of the string 's' by frequency in decreasing order. Characters with the same frequency are sorted in ascending alphabetical order. >>> frequency_sort(\\"banana\\") # \\"aaannb\\" >>> frequency_sort(\\"cccaaa\\") # \\"aaaccc\\" >>> frequency_sort(\\"abcd\\") # \\"abcd\\" >>> frequency_sort(\\"eeeeee\\") # \\"eeeeee\\"","solution":"from collections import Counter def frequency_sort(s: str) -> str: Function to sort characters of the string 's' by frequency in decreasing order. Characters with the same frequency are sorted in ascending alphabetical order. # Count the frequency of each character char_count = Counter(s) # Sort the characters first by frequency (descending) then by character (ascending) sorted_chars = sorted(char_count.items(), key=lambda x: (-x[1], x[0])) # Build the result string result = ''.join([char * count for char, count in sorted_chars]) return result"},{"question":"def transpose(matrix): Returns the transpose of the given matrix. Args: matrix (list of list of ints): A 2D list representing the matrix. Returns: list of list of ints: The transposed matrix. Examples: >>> transpose([ ... [1, 2], ... [3, 4] ... ]) [[1, 3], [2, 4]] >>> transpose([ ... [1, 2, 3], ... [4, 5, 6] ... ]) [[1, 4], [2, 5], [3, 6]] >>> transpose([ ... [1, 2, 3] ... ]) [[1], [2], [3]] >>> transpose([ ... [1], ... [2], ... [3] ... ]) [[1, 2, 3]] >>> transpose([]) [] >>> transpose([ ... [1] ... ]) [[1]]","solution":"def transpose(matrix): Returns the transpose of the given matrix. Args: matrix (list of list of ints): A 2D list representing the matrix. Returns: list of list of ints: The transposed matrix. # Check if the matrix is empty if not matrix: return [] # Transpose the matrix transposed_matrix = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))] return transposed_matrix # Sample input input_matrix = [ [1, 2, 3], [4, 5, 6] ] # Sample output # [ # [1, 4], # [2, 5], # [3, 6] # ] print(transpose(input_matrix))"},{"question":"def compress_array(arr): Compresses the array in-place such that consecutive elements are replaced with the element followed by the count of its consecutive repetitions. If the compressed array is not shorter, retains the original array. pass # Example Test Cases from solution import compress_array def test_single_element_array(): arr = [1] compress_array(arr) assert arr == [1] def test_no_compression_needed(): arr = [1, 2, 3, 4] compress_array(arr) assert arr == [1, 2, 3, 4] def test_basic_compression(): arr = [1, 1, 2, 3, 3, 3, 4] compress_array(arr) assert arr == [1, 2, 2, 3, 3, 4] def test_full_compression(): arr = [1, 1, 1, 1, 1] compress_array(arr) assert arr == [1, 5] def test_complex_case(): arr = [1, 1, 2, 3, 3, 3, 4, 4, 5, 5, 5, 5] compress_array(arr) assert arr == [1, 2, 2, 3, 3, 4, 2, 5, 4] def test_mixed_compression(): arr = [1, 1, 2, 2, 2, 3, 3, 4, 4, 4, 4] compress_array(arr) assert arr == [1, 2, 2, 3, 3, 2, 4, 4]","solution":"def compress_array(arr): Compresses the array in-place such that consecutive elements are replaced with the element followed by the count of its consecutive repetitions. If the compressed array is not shorter, retains the original array. n = len(arr) if n == 1: return i = 0 index = 0 while i < n: current_element = arr[i] count = 1 while i + 1 < n and arr[i + 1] == current_element: count += 1 i += 1 arr[index] = current_element index += 1 if count > 1: count_str = str(count) for char in count_str: arr[index] = int(char) index += 1 i += 1 # truncate the array if compressed version is shorter if index < n: del arr[index:]"},{"question":"def power(base: float, exponent: int) -> float: Calculates the result of raising a number to a specific power without using the built-in power function or operator. Handles both positive and negative powers, as well as zero. Args: base (float): The base number. exponent (int): The exponent (power) to raise the base. Returns: float: The result of raising base to the power of exponent. >>> abs(power(2.0, 3) - 8.0) < 1e-9 True >>> abs(power(2.0, -2) - 0.25) < 1e-9 True >>> power(2.0, 0) == 1.0 True","solution":"def power(base, exponent): Calculates base raised to the power of exponent without using built-in pow function or operator. Handles both positive and negative exponents, as well as zero. Args: base (float): The base number. exponent (int): The exponent (power) to raise the base. Returns: float: The result of raising base to the power of exponent. if exponent == 0: return 1.0 is_negative = exponent < 0 exponent = abs(exponent) result = 1.0 for _ in range(exponent): result *= base if is_negative: return 1 / result return result"},{"question":"def sublist_sum_exists(arr, target_sum): Determines whether there exists a contiguous sublist within a given array of integers that sums up to a specified target sum. :param arr: List of integers :param target_sum: Integer target sum :return: True if such a sublist exists, False otherwise Examples: >>> sublist_sum_exists([1, 2, 3, 7, 5], 12) True >>> sublist_sum_exists([1, 2, 3, 4, 5], 9) True >>> sublist_sum_exists([1, 2, 3, 4, 5], 20) False >>> sublist_sum_exists([-1, 2, 4, -2, 3], 3) True # Your code here","solution":"def sublist_sum_exists(arr, target_sum): Determines whether there exists a contiguous sublist within a given array of integers that sums up to a specified target sum. :param arr: List of integers :param target_sum: Integer target sum :return: True if such a sublist exists, False otherwise current_sum = 0 start = 0 sum_dict = {0: -1} for i, num in enumerate(arr): current_sum += num if (current_sum - target_sum) in sum_dict: return True if current_sum not in sum_dict: sum_dict[current_sum] = i return False"},{"question":"def palindromic_substrings(s: str) -> List[str]: Returns a list of all possible palindromic substrings in the input string. >>> palindromic_substrings(\\"abba\\") [\\"a\\", \\"b\\", \\"b\\", \\"a\\", \\"bb\\", \\"abba\\"] >>> palindromic_substrings(\\"racecar\\") [\\"r\\", \\"a\\", \\"c\\", \\"e\\", \\"c\\", \\"a\\", \\"r\\", \\"cec\\", \\"aceca\\", \\"racecar\\"] >>> palindromic_substrings(\\"a\\") [\\"a\\"] >>> palindromic_substrings(\\"ab\\") [\\"a\\", \\"b\\"] >>> palindromic_substrings(\\"abc\\") [\\"a\\", \\"b\\", \\"c\\"] >>> palindromic_substrings(\\"madam\\") [\\"m\\", \\"a\\", \\"d\\", \\"a\\", \\"m\\", \\"ada\\", \\"madam\\"] >>> palindromic_substrings(\\"\\") []","solution":"def palindromic_substrings(s): Returns a list of all possible palindromic substrings in the input string s. def is_palindrome(substr): return substr == substr[::-1] n = len(s) palindromes = [] for i in range(n): for j in range(i, n): substr = s[i:j+1] if is_palindrome(substr): palindromes.append(substr) return palindromes"},{"question":"def longest_substring_k_distinct(s: str, k: int) -> int: Implement a Python function that takes a string \`s\` and an integer \`k\`, and returns the length of the longest substring that contains at most \`k\` distinct characters. >>> longest_substring_k_distinct(\\"eceba\\", 2) 3 >>> longest_substring_k_distinct(\\"aa\\", 1) 2 from solution import longest_substring_k_distinct def test_longest_substring_k_distinct_example_1(): assert longest_substring_k_distinct(\\"eceba\\", 2) == 3 def test_longest_substring_k_distinct_example_2(): assert longest_substring_k_distinct(\\"aa\\", 1) == 2 def test_longest_substring_k_distinct_k_zero(): assert longest_substring_k_distinct(\\"eceba\\", 0) == 0 def test_longest_substring_k_distinct_k_greater_than_distinct_chars(): assert longest_substring_k_distinct(\\"eceba\\", 5) == 5 def test_longest_substring_k_distinct_k_equals_one(): assert longest_substring_k_distinct(\\"abaccc\\", 1) == 3 def test_longest_substring_k_distinct_empty_string(): assert longest_substring_k_distinct(\\"\\", 3) == 0 def test_longest_substring_k_distinct_zeros(): assert longest_substring_k_distinct(\\"\\", 0) == 0","solution":"def longest_substring_k_distinct(s, k): if k == 0: return 0 n = len(s) if n == 0: return 0 if k >= n: return n left = 0 right = 0 max_len = 0 char_count = {} while right < n: char = s[right] if char in char_count: char_count[char] += 1 else: char_count[char] = 1 while len(char_count) > k: left_char = s[left] if char_count[left_char] == 1: del char_count[left_char] else: char_count[left_char] -= 1 left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"def is_balanced(s: str) -> bool: Determines if the given string contains balanced parentheses. :param s: Input string :return: True if the string has balanced parentheses, otherwise False >>> is_balanced(\\"abc(def)ghi\\") == True >>> is_balanced(\\"a(b)c)d(\\") == False >>> is_balanced(\\"(a+b)*(c+d)\\") == True >>> is_balanced(\\")(\\") == False","solution":"def is_balanced(s): Determines if the given string contains balanced parentheses. :param s: Input string :return: True if balanced, otherwise False stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if stack and stack[-1] == '(': stack.pop() else: return False return not stack"},{"question":"def remove_vowels(input_string: str) -> str: Returns a new string with all vowels removed from the input string. Vowels are defined as 'a', 'e', 'i', 'o', 'u' and their uppercase counterparts. >>> remove_vowels(\\"Hello, World!\\") == \\"Hll, Wrld!\\" >>> remove_vowels(\\"aeiouAEIOU\\") == \\"\\" >>> remove_vowels(\\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\\") == \\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\\" >>> remove_vowels(\\"Programming is fun!\\") == \\"Prgrmmng s fn!\\" >>> remove_vowels(\\"\\") == \\"\\" >>> long_string = \\"a\\" * 1000000 + \\"b\\" * 1000000 >>> remove_vowels(long_string) == \\"b\\" * 1000000","solution":"def remove_vowels(input_string): Returns a new string with all vowels removed from the input string. Vowels are defined as 'a', 'e', 'i', 'o', 'u' and their uppercase counterparts. vowels = \\"aeiouAEIOU\\" return ''.join(char for char in input_string if char not in vowels)"},{"question":"from typing import List def longest_sublist_with_two_distinct(nums: List[int]) -> int: Write a function that takes a list of integers as input and processes it to find and return the length of the longest contiguous sub-list that contains exactly two distinct integers. >>> longest_sublist_with_two_distinct([1, 2, 1, 2, 3]) 4 >>> longest_sublist_with_two_distinct([1, 2, 3, 4]) 2 >>> longest_sublist_with_two_distinct([1, 1, 1, 1]) 4 # Example Usage print(longest_sublist_with_two_distinct([1, 2, 1, 2, 3])) # Output: 4 (sub-list: [1, 2, 1, 2]) print(longest_sublist_with_two_distinct([1, 2, 3, 4])) # Output: 2 (sub-list: [1, 2] or [2, 3] or [3, 4]) print(longest_sublist_with_two_distinct([1, 1, 1, 1])) # Output: 4 (sub-list: [1, 1, 1, 1])","solution":"def longest_sublist_with_two_distinct(nums): if not nums: return 0 n = len(nums) left = 0 right = 0 max_length = 0 count = {} while right < n: count[nums[right]] = count.get(nums[right], 0) + 1 while len(count) > 2: count[nums[left]] -= 1 if count[nums[left]] == 0: del count[nums[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def is_leap_year(year: int) -> bool: Checks if a given year is a leap year. A leap year is exactly divisible by 4 except for century years (years ending in 00). The century year is a leap year only if it is perfectly divisible by 400. >>> is_leap_year(2020) True >>> is_leap_year(2019) False >>> is_leap_year(1900) False >>> is_leap_year(2000) True","solution":"def is_leap_year(year): Checks if a given year is a leap year. A leap year is: - Exactly divisible by 4 - Except for century years (years ending in 00), which must be divisible by 400 if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): return True return False"},{"question":"from typing import List def sum_of_integers(list_of_strings: List[str]) -> List[int]: Takes a list of strings where each string is a representation of a list of integers. Returns a new list where each element is the sum of the integers from the corresponding input string. >>> sum_of_integers([\\"[1, 2, 3]\\", \\"[4, 5, 6]\\", \\"[7, 8, 9]\\"]) [6, 15, 24] >>> sum_of_integers([\\"[]\\", \\"[]\\", \\"[]\\"]) [0, 0, 0] >>> sum_of_integers([\\"[1]\\", \\"[2]\\", \\"[3]\\"]) [1, 2, 3] >>> sum_of_integers([\\"[1, -1, 2]\\", \\"[3, 0, -3]\\", \\"[4, 5, -9]\\"]) [2, 0, 0] >>> sum_of_integers([\\"[1000, 2000, 3000]\\", \\"[4000, 5000, 6000]\\"]) [6000, 15000]","solution":"import ast def sum_of_integers(list_of_strings): Takes a list of strings where each string is a representation of a list of integers. Returns a new list where each element is the sum of the integers from the corresponding input string. result = [] for string in list_of_strings: # Parse the string to transform it into a list of integers int_list = ast.literal_eval(string) # Calculate the sum of the integers in the list total = sum(int_list) # Append the sum to the result list result.append(total) return result"},{"question":"def compress_counts(lst: List[int]) -> Dict[int, int]: Takes a list of integers and returns a dictionary where the keys are the integers from the list and the values are the number of times each integer appears in compressed form. Consecutive appearances are counted as one. >>> compress_counts([1, 2, 2, 1, 1, 3, 3, 3]) # {1: 2, 2: 1, 3: 1} >>> compress_counts([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) # {1: 1, 2: 1, 3: 1, 4: 1} pass","solution":"def compress_counts(lst): Takes a list of integers and returns a dictionary where the keys are the integers from the list and the values are the number of times each integer appears in compressed form. Consecutive appearances are counted as one. if not lst: return {} compressed_dict = {} current = lst[0] compressed_dict[current] = 1 for i in range(1, len(lst)): if lst[i] != current: current = lst[i] if current in compressed_dict: compressed_dict[current] += 1 else: compressed_dict[current] = 1 return compressed_dict"},{"question":"import matplotlib.pyplot as plt def create_fruit_bar_chart(fruit_quantities): Creates a bar chart for given fruit quantities and saves it as 'fruit_quantities.png'. Parameters: fruit_quantities (dict): A dictionary with fruit names as keys and their quantities as values. Example: >>> fruit_quantities = {'Apple': 50, 'Banana': 75, 'Cherry': 45, 'Date': 30, 'Grape': 90} >>> create_fruit_bar_chart(fruit_quantities)","solution":"import matplotlib.pyplot as plt def create_fruit_bar_chart(fruit_quantities): Creates a bar chart for given fruit quantities and saves it as 'fruit_quantities.png'. Parameters: fruit_quantities (dict): A dictionary with fruit names as keys and their quantities as values. fruits = list(fruit_quantities.keys()) quantities = list(fruit_quantities.values()) colors = plt.cm.get_cmap('tab10', len(fruits)) plt.figure(figsize=(10, 6)) plt.bar(fruits, quantities, color=colors(range(len(fruits)))) plt.xlabel('Fruits') plt.ylabel('Quantities') plt.title('Fruit Quantities') plt.savefig('fruit_quantities.png') plt.close()"},{"question":"from typing import List def is_prime(n: int) -> bool: Helper function to determine if a number is prime. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(0) False pass def filter_primes(numbers: List[int]) -> List[int]: Returns a new list consisting of only the prime numbers from the original list. >>> filter_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([]) [] >>> filter_primes([1, 4, 6, 8, 9, 10]) [] >>> filter_primes([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> filter_primes([-2, -3, -5, -7]) [] pass","solution":"def is_prime(n): Helper function to determine if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers): Returns a new list consisting of only the prime numbers from the original list. return [num for num in numbers if is_prime(num)]"},{"question":"import re from typing import List def count_unique_words(s: str) -> int: Returns the number of unique words in the given string s. Words are case insensitive and only alphanumeric characters are considered. >>> count_unique_words(\\"Hello world\\") == 2 >>> count_unique_words(\\"Hello hello HELLO\\") == 1 >>> count_unique_words(\\"Hello, world!\\") == 2 >>> count_unique_words(\\"The quick brown fox jumps over the lazy dog.\\") == 8 >>> count_unique_words(\\"\\") == 0","solution":"import re def count_unique_words(s): Returns the number of unique words in the given string s. Words are case insensitive and only alphanumeric characters are considered. # Convert the string to lowercase s = s.lower() # Use regex to find all words which consist of alphanumeric characters words = re.findall(r'bw+b', s) # Use a set to find the unique words unique_words = set(words) return len(unique_words)"},{"question":"def shift_string_right(s: str) -> str: Returns a new string where each character is shifted to the right by one position in the alphabet. Non-alphabetic characters are not altered. >>> shift_string_right('hello') == 'ifmmp' >>> shift_string_right('xyz') == 'yza' >>> shift_string_right('Hello') == 'Ifmmp' >>> shift_string_right('abc') == 'bcd' >>> shift_string_right('hello123') == 'ifmmp123' >>> shift_string_right('!@#') == '!@#' >>> shift_string_right('HeLLo') == 'IfMMp' >>> shift_string_right('') == ''","solution":"def shift_string_right(s): Returns a new string where each character is shifted to the right by one position in the alphabet. Non-alphabetic characters are not altered. if not isinstance(s, str): raise ValueError(\\"Input must be a string\\") result = [] for char in s: if 'a' <= char <= 'z': shifted_char = chr((ord(char) - ord('a') + 1) % 26 + ord('a')) result.append(shifted_char) elif 'A' <= char <= 'Z': shifted_char = chr((ord(char) - ord('A') + 1) % 26 + ord('A')) result.append(shifted_char) else: result.append(char) return ''.join(result)"},{"question":"def char_count(s: str) -> dict: Returns a dictionary with the count of each character in the string. The function is case insensitive. Args: s (str): The input string. Returns: dict: A dictionary with the count of each character (case insensitive). >>> char_count(\\"aabbcc\\") {'a': 2, 'b': 2, 'c': 2} >>> char_count(\\"AaBbCc\\") {'a': 2, 'b': 2, 'c': 2} >>> char_count(\\"abc abc\\") {'a': 2, 'b': 2, 'c': 2, ' ': 1} >>> char_count(\\"a!@#A!@#b!@#B!@#\\") {'a': 2, '!': 4, '@': 4, '#': 4, 'b': 2} >>> char_count(\\"Python Programming!\\") {'p': 2, 'y': 1, 't': 1, 'h': 1, 'o': 2, 'n': 2, ' ': 1, 'r': 2, 'g': 2, 'a': 1, 'm': 2, 'i': 1, '!': 1} # Your implementation here def test_char_count_basic(): result = char_count(\\"aabbcc\\") assert result == {'a': 2, 'b': 2, 'c': 2} def test_char_count_case_insensitive(): result = char_count(\\"AaBbCc\\") assert result == {'a': 2, 'b': 2, 'c': 2} def test_char_count_with_spaces(): result = char_count(\\"abc abc\\") assert result == {'a': 2, 'b': 2, 'c': 2, ' ': 1} def test_char_count_with_special_characters(): result = char_count(\\"a!@#A!@#b!@#B!@#\\") assert result == {'a': 2, '!': 4, '@': 4, '#': 4, 'b': 2} def test_char_count_mixed(): result = char_count(\\"Python Programming!\\") assert result == {'p': 2, 'y': 1, 't': 1, 'h': 1, 'o': 2, 'n': 2, ' ': 1, 'r': 2, 'g': 2, 'a': 1, 'm': 2, 'i': 1, '!': 1}","solution":"def char_count(s): Returns a dictionary with the count of each character in the string. The function is case insensitive. count_dict = {} s = s.lower() for char in s: if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 return count_dict # Explanation of the time complexity and space complexity: # Time Complexity: O(n), where n is the length of the input string. # We iterate over the string once, and each dictionary operation generally takes O(1) time. # Space Complexity: O(k), where k is the number of unique characters in the string. # We store each unique character in the dictionary with its corresponding count."},{"question":"def all_elements_even_frequency(arr: list) -> bool: Return True if every element in the list arr occurs an even number of times, otherwise return False. >>> all_elements_even_frequency([2, 4, 2, 4]) True >>> all_elements_even_frequency([3, 3, 4, 4, 4]) False >>> all_elements_even_frequency([1, 1, 2, 2, 3, 3]) True >>> all_elements_even_frequency([]) True >>> all_elements_even_frequency([9]) False >>> all_elements_even_frequency([1] * 10**6 + [2] * 10**6) True >>> all_elements_even_frequency([1] * 10**6 + [2] * (10**6 + 1)) False","solution":"from collections import Counter def all_elements_even_frequency(arr: list) -> bool: Return True if every element in the list arr occurs an even number of times, otherwise return False. element_counts = Counter(arr) for count in element_counts.values(): if count % 2 != 0: return False return True"},{"question":"def differences_from_average(numbers: List[int]) -> List[float]: Returns a list where each element is the difference between the corresponding elements of the input list and the average of the input list. Args: numbers (list of int): A list of integers Returns: list of float: A new list where each element is the difference from the average. >>> differences_from_average([10, 12, 14, 16, 18]) [-4.0, -2.0, 0.0, 2.0, 4.0] >>> differences_from_average([]) [] >>> differences_from_average([5]) [0.0] >>> differences_from_average([7, 7, 7, 7]) [0.0, 0.0, 0.0, 0.0] >>> differences_from_average([-10, -20, -30]) [10.0, 0.0, -10.0] >>> differences_from_average([1, -1, 1, -1]) [1.0, -1.0, 1.0, -1.0]","solution":"def differences_from_average(numbers): Returns a list where each element is the difference between the corresponding elements of the input list and the average of the input list. Args: numbers (list of int): A list of integers Returns: list of float: A new list where each element is the difference from the average. if not numbers: return [] average = sum(numbers) / len(numbers) return [round(num - average, 1) for num in numbers]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(rootA: TreeNode, rootB: TreeNode) -> bool: Determine if one binary tree B is a subtree of another binary tree A. >>> rootA = TreeNode(3) >>> rootA.left = TreeNode(4) >>> rootA.right = TreeNode(5) >>> rootA.left.left = TreeNode(1) >>> rootA.left.right = TreeNode(2) >>> rootB = TreeNode(4) >>> rootB.left = TreeNode(1) >>> rootB.right = TreeNode(2) >>> is_subtree(rootA, rootB) True >>> rootA.left.right.left = TreeNode(0) # Adding extra node to make it different >>> is_subtree(rootA, rootB) False >>> rootA = TreeNode(1) >>> rootA.left = TreeNode(2) >>> rootA.right = TreeNode(3) >>> is_subtree(rootA, rootA) True >>> rootA = TreeNode(1) >>> rootB = TreeNode(1) >>> is_subtree(rootA, rootB) True >>> rootA = TreeNode(1) >>> is_subtree(rootA, None) True >>> rootB = TreeNode(1) >>> is_subtree(None, rootB) False >>> is_subtree(None, None) True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_same_tree(s, t): if not s and not t: return True if not s or not t: return False if s.val != t.val: return False return is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right) def is_subtree(rootA, rootB): if not rootB: return True if not rootA: return False if is_same_tree(rootA, rootB): return True return is_subtree(rootA.left, rootB) or is_subtree(rootA.right, rootB)"},{"question":"def merge_dictionaries(d1, d2): Merges two dictionaries d1 and d2. If a key exists in both dictionaries, the function will combine their values into a list. >>> merge_dictionaries({'a': 1, 'b': 'two'}, {'c': 3, 'd': 'four'}) {'a': 1, 'b': 'two', 'c': 3, 'd': 'four'} >>> merge_dictionaries({'a': 1, 'b': 'two', 'c': [3, 4]}, {'b': 2, 'c': 'three', 'd': [5, 6]}) {'a': 1, 'b': ['two', 2], 'c': [3, 4, 'three'], 'd': [5, 6]} >>> merge_dictionaries({'a': [1, 2], 'b': [3, 'four']}, {'a': 3, 'b': ['five', 6]}) {'a': [1, 2, 3], 'b': [3, 'four', 'five', 6]} >>> merge_dictionaries({}, {'a': 1}) {'a': 1} >>> merge_dictionaries({'a': 1, 'b': 'two'}, {}) {'a': 1, 'b': 'two'} # implementation here","solution":"def merge_dictionaries(d1, d2): Merges two dictionaries d1 and d2. If a key exists in both dictionaries, the function will combine their values into a list. result = {} for key in d1: if key in d2: val_d1 = d1[key] if isinstance(d1[key], list) else [d1[key]] val_d2 = d2[key] if isinstance(d2[key], list) else [d2[key]] result[key] = val_d1 + val_d2 else: result[key] = d1[key] for key in d2: if key not in result: result[key] = d2[key] return result"},{"question":"from typing import List def unique_characters(s: str) -> List[str]: Returns a list of unique characters in the string \`s\`, sorted in the order of their first occurrence. >>> unique_characters(\\"programming\\") == ['p', 'r', 'o', 'g', 'a', 'm', 'i', 'n'] >>> unique_characters(\\"\\") == [] >>> unique_characters(\\"a\\") == ['a'] >>> unique_characters(\\"abcdef\\") == ['a', 'b', 'c', 'd', 'e', 'f'] >>> unique_characters(\\"aabbcc\\") == ['a', 'b', 'c'] >>> unique_characters(\\"AabbCC\\") == ['A', 'a', 'b', 'C']","solution":"def unique_characters(s): Returns a list of unique characters in the string \`s\`, sorted in the order of their first occurrence. seen = set() unique_chars = [] for char in s: if char not in seen: unique_chars.append(char) seen.add(char) return unique_chars"},{"question":"def search_matrix(matrix: List[List[int]], target: int) -> Tuple[int, int]: Searches for the target value in the given matrix. Each row in the matrix is sorted in ascending order. Returns the position (row_index, col_index) if found, otherwise returns (-1, -1). >>> matrix = [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ] >>> search_matrix(matrix, 5) (1, 1) >>> search_matrix(matrix, 20) (-1, -1) from typing import List, Tuple def search_matrix(matrix: List[List[int]], target: int) -> Tuple[int, int]: # Your implementation goes here pass def test_found_in_matrix(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 5 assert search_matrix(matrix, target) == (1, 1) def test_not_found_in_matrix(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 20 assert search_matrix(matrix, target) == (-1, -1) def test_empty_matrix(): matrix = [] target = 5 assert search_matrix(matrix, target) == (-1, -1) def test_empty_row_matrix(): matrix = [[]] target = 5 assert search_matrix(matrix, target) == (-1, -1) def test_single_element_matrix_found(): matrix = [[7]] target = 7 assert search_matrix(matrix, target) == (0, 0) def test_single_element_matrix_not_found(): matrix = [[7]] target = 5 assert search_matrix(matrix, target) == (-1, -1) def test_target_at_start(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 1 assert search_matrix(matrix, target) == (0, 0) def test_target_at_end(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 30 assert search_matrix(matrix, target) == (4, 4)","solution":"def search_matrix(matrix, target): Searches for the target value in the given matrix. Each row in the matrix is sorted in ascending order. Returns the position (row_index, col_index) if found, otherwise returns (-1, -1). :param matrix: List of List of integers :param target: Integer value to be searched :return: Tuple (row_index, col_index) or (-1, -1) if not matrix or not matrix[0]: return (-1, -1) rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 # Start from the top-right corner while row < rows and col >= 0: if matrix[row][col] == target: return (row, col) elif matrix[row][col] > target: col -= 1 # Move left else: row += 1 # Move down return (-1, -1) # Target not found"},{"question":"def cumulative_sum(numbers: List[int]) -> List[int]: Takes a list of integers and returns a new list with each integer increased by the sum of all elements preceding it in the original list (cumulative sum). If the list is empty, the output should be an empty list. >>> cumulative_sum([1, 2, 3]) [1, 3, 6] >>> cumulative_sum([2, 4, 6]) [2, 6, 12] >>> cumulative_sum([]) [] >>> cumulative_sum([5]) [5] >>> cumulative_sum([-1, -2, -3]) [-1, -3, -6] >>> cumulative_sum([1, -2, 3, -4]) [1, -1, 2, -2]","solution":"def cumulative_sum(numbers): Takes a list of integers and returns a new list with each integer increased by the sum of all elements preceding it in the original list. result = [] current_sum = 0 for number in numbers: current_sum += number result.append(current_sum) return result"},{"question":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring that contains only unique characters. >>> longest_unique_substring(\\"\\") 0 >>> longest_unique_substring(\\"aaaaa\\") 1 >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\"dvdf\\") 3 >>> longest_unique_substring(\\"anviaj\\") 5 >>> longest_unique_substring(\\"aaabbcdeab\\") 5 >>> longest_unique_substring(\\" \\") 1 >>> longest_unique_substring(\\"aab\\") 2 >>> longest_unique_substring(\\"abcdefg\\") 7 >>> longest_unique_substring(\\"a\\" * 1000) 1 >>> longest_unique_substring(\\"abcdeabcdeabcdef\\") 6","solution":"def longest_unique_substring(s): Returns the length of the longest substring that contains only unique characters. if not s: return 0 max_length = 0 start = 0 seen = {} for end in range(len(s)): char = s[end] if char in seen: start = max(start, seen[char] + 1) seen[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List def sieve_of_eratosthenes(max_num: int) -> List[bool]: Returns a list of boolean values where True indicates that the index is a prime number. Uses the Sieve of Eratosthenes algorithm. sieve = [True] * (max_num + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(max_num**0.5) + 1): if sieve[start]: for multiple in range(start*start, max_num + 1, start): sieve[multiple] = False return sieve def filter_primes(numbers: List[int]) -> List[int]: Returns a list containing only the prime numbers from the given list. >>> filter_primes([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> filter_primes([4, 6, 8, 9, 10]) [] >>> filter_primes([2, 3, 5, 7, 8, 10, 13, 15]) [2, 3, 5, 7, 13] >>> filter_primes([10]) [] >>> filter_primes([7]) [7] >>> filter_primes([]) [] >>> filter_primes([29, 33, 37, 42, 45]) [29, 37]","solution":"from typing import List def sieve_of_eratosthenes(max_num: int) -> List[bool]: Returns a list of boolean values where True indicates that the index is a prime number. Uses the Sieve of Eratosthenes algorithm. sieve = [True] * (max_num + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(max_num**0.5) + 1): if sieve[start]: for multiple in range(start*start, max_num + 1, start): sieve[multiple] = False return sieve def filter_primes(numbers: List[int]) -> List[int]: Returns a list containing only the prime numbers from the given list. if not numbers: return [] max_num = max(numbers) sieve = sieve_of_eratosthenes(max_num) return [num for num in numbers if sieve[num]]"},{"question":"def find_pairs(nums: list, target: int) -> list: Find all unique pairs of integers from the list that add up to the target sum. Parameters: nums (list): List of integers target (int): Target sum Returns: list: List of tuples where each tuple contains a unique pair of integers that add up to the target sum >>> find_pairs([1, 2, 3, 4, 5], 5) [(2, 3), (1, 4)] >>> find_pairs([1, 2, 3, 2, 4, 5, 4], 6) [(2, 4), (1, 5)] >>> find_pairs([1, 2, 3], 10) [] >>> find_pairs([-1, 1, -2, 2, -3, 3], 0) [(-1, 1), (-2, 2), (-3, 3)] >>> find_pairs([1, 1, 1, 1, 1, 1], 2) [(1, 1)]","solution":"def find_pairs(nums, target): Find all unique pairs of integers from the list that add up to the target sum. Parameters: nums (list): List of integers target (int): Target sum Returns: list: List of tuples where each tuple contains a unique pair of integers that add up to the target sum seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return list(pairs)"},{"question":"def num_decodings(s): Your task is to write a function that accepts a string containing the encoded message and returns the total number of ways to decode it. For example: >>> num_decodings(\\"12\\") == 2 # \\"AB\\" (1 2), \\"L\\" (12) >>> num_decodings(\\"226\\") == 3 # \\"BZ\\" (2 26), \\"VF\\" (22 6), \\"BBF\\" (2 2 6) >>> num_decodings(\\"0\\") == 0 # no valid decoding >>> num_decodings(\\"10\\") == 1 # \\"J\\" (10) from solution import num_decodings def test_single_digit(): assert num_decodings(\\"1\\") == 1 assert num_decodings(\\"7\\") == 1 assert num_decodings(\\"0\\") == 0 def test_two_digits(): assert num_decodings(\\"12\\") == 2 # \\"AB\\", \\"L\\" assert num_decodings(\\"26\\") == 2 # \\"BF\\", \\"Z\\" assert num_decodings(\\"10\\") == 1 # \\"J\\" assert num_decodings(\\"01\\") == 0 # Invalid def test_multiple_digits(): assert num_decodings(\\"226\\") == 3 # \\"BZ\\" (2 26), \\"VF\\" (22 6), \\"BBF\\" (2 2 6) assert num_decodings(\\"11106\\") == 2 # \\"AAJF\\" (1 1 10 6), \\"KJF\\" (11 10 6) assert num_decodings(\\"110\\") == 1 # \\"J\\" (11 0 is invalid) assert num_decodings(\\"100\\") == 0 # Invalid def test_edge_cases(): assert num_decodings(\\"\\") == 0 # Empty string assert num_decodings(\\"30\\") == 0 # Invalid def test_large_input(): assert num_decodings(\\"1111111111\\") == 89 # Sequence of valid encodings","solution":"def num_decodings(s): Calculates the total number of ways to decode the given encoded message. :param s: A string representing the encoded message. :return: An integer representing the number of ways to decode the message. if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 # Base case: an empty string has one way to be decoded (doing nothing) dp[1] = 1 # Base case: a single non-zero character has one way to be decoded for i in range(2, n + 1): if s[i - 1] != '0': dp[i] += dp[i - 1] if '10' <= s[i - 2:i] <= '26': dp[i] += dp[i - 2] return dp[n]"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved by buying and selling the stock once. If no profit is possible, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 # Test cases def test_max_profit_example(): assert max_profit([7, 1, 5, 3, 6, 4]) == 5 assert max_profit([7, 6, 4, 3, 1]) == 0 def test_max_profit_single_day(): assert max_profit([5]) == 0 def test_max_profit_constant_prices(): assert max_profit([3, 3, 3, 3]) == 0 def test_max_profit_descending_prices(): assert max_profit([9, 7, 5, 3, 1]) == 0 def test_max_profit_all_same_prices(): assert max_profit([2, 2, 2, 2, 2, 2]) == 0 def test_max_profit_intermittent(): assert max_profit([7, 1, 5, 3, 6, 4, 8, 3]) == 7 def test_max_profit_large_values(): assert max_profit([1, 1000]) == 999 def test_max_profit_empty(): assert max_profit([]) == 0","solution":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved by buying and selling the stock once. If no profit is possible, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit # Time Complexity: O(n) # Space Complexity: O(1)"},{"question":"from datetime import datetime def day_of_week(date_str: str) -> str: Returns the day of the week for the given date in \\"YYYY-MM-DD\\" format. The function validates the input string for correct format and valid dates, accounting for leap years and providing appropriate error handling and messages for invalid inputs. >>> day_of_week(\\"2023-10-26\\") == \\"Thursday\\" >>> day_of_week(\\"2000-01-01\\") == \\"Saturday\\" >>> day_of_week(\\"2021-12-25\\") == \\"Saturday\\" >>> day_of_week(\\"2020-02-29\\") == \\"Saturday\\" >>> day_of_week(\\"2016-02-29\\") == \\"Monday\\" >>> with pytest.raises(ValueError, match=\\"Input date must be in the format YYYY-MM-DD and be a valid date.\\"): day_of_week(\\"20231026\\") >>> with pytest.raises(ValueError, match=\\"Input date must be in the format YYYY-MM-DD and be a valid date.\\"): day_of_week(\\"26-10-2023\\") >>> with pytest.raises(ValueError, match=\\"Input date must be in the format YYYY-MM-DD and be a valid date.\\"): day_of_week(\\"2021-02-30\\") >>> with pytest.raises(ValueError, match=\\"Input date must be in the format YYYY-MM-DD and be a valid date.\\"): day_of_week(\\"2023-13-01\\")","solution":"from datetime import datetime def day_of_week(date_str): Returns the day of the week for the given date in \\"YYYY-MM-DD\\" format. Parameters: date_str (str): The date string in \\"YYYY-MM-DD\\" format. Returns: str: The day of the week corresponding to the date. Raises: ValueError: If the input string is not in the correct format or if the date is invalid. try: date = datetime.strptime(date_str, \\"%Y-%m-%d\\") except ValueError as e: raise ValueError(\\"Input date must be in the format YYYY-MM-DD and be a valid date.\\") from e return date.strftime(\\"%A\\")"},{"question":"def replace_vowels(input_str: str) -> str: Replace all vowels (a, e, i, o, u) in the input string with '*' and maintain the case of the original string. >>> replace_vowels(\\"Hello World\\") \\"H*ll* W*rld\\" >>> replace_vowels(\\"Python Programming\\") \\"Pyth*n Pr*gr*mm*ng\\"","solution":"def replace_vowels(input_str): Replaces all vowels in the input string with '*' and maintains case of the original string. vowels = 'aeiouAEIOU' return ''.join(['*' if char in vowels else char for char in input_str])"},{"question":"class MinStack: Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time. You should implement the following methods: - push(x): Pushes element x onto the stack. - pop(): Removes the element on the top of the stack. - top(): Gets the top element. - getMin(): Retrieves the minimum element in the stack. Example: >>> minStack = MinStack() >>> minStack.push(-2) >>> minStack.push(0) >>> minStack.push(-3) >>> minStack.getMin() # Returns -3 -3 >>> minStack.pop() >>> minStack.top() # Returns 0 0 >>> minStack.getMin() # Returns -2 -2 def __init__(self): pass def push(self, x: int) -> None: pass def pop(self) -> None: pass def top(self) -> int: pass def getMin(self) -> int: pass def test_min_stack_operations(): minStack = MinStack() minStack.push(-2) minStack.push(0) minStack.push(-3) # Test getMin after pushes assert minStack.getMin() == -3 # getMin() should return -3 # Test pop and top operations minStack.pop() assert minStack.top() == 0 # top() should return 0 assert minStack.getMin() == -2 # getMin() should return -2 after popping -3 minStack.pop() assert minStack.top() == -2 # top() should return -2 assert minStack.getMin() == -2 # getMin() should still return -2 minStack.pop() assert minStack.top() == None # top() should return None as stack is empty assert minStack.getMin() == None # getMin() should return None as stack is empty def test_min_stack_with_empty(): minStack = MinStack() # Test getMin and top with empty stack assert minStack.getMin() == None # getMin() should return None assert minStack.top() == None # top() should return None minStack.push(1) assert minStack.getMin() == 1 # getMin() should return 1 assert minStack.top() == 1 # top() should return 1 minStack.pop() # Assert the stack is empty again assert minStack.top() == None # top() should return None assert minStack.getMin() == None # getMin() should return None","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: if self.stack: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] return None # Or raise an exception def getMin(self) -> int: if self.min_stack: return self.min_stack[-1] return None # Or raise an exception"},{"question":"from typing import List, Union def palindromic_primes(n: Union[int, List[int]], count=False) -> Union[List[int], List[List[int]], int, List[Union[List[int], str]]]: Generates a list of palindromic primes less than a given number \`n\`. A palindromic prime is a prime number that remains the same when its digits are reversed. If \`n\` is a list, each element is processed individually, and the results are returned as a list of lists. If \`count\` is True, the function returns the total count of palindromic primes. Input validation ensures \`n\` is a positive integer greater than 2. If \`n\` does not meet this criterion, a descriptive error is raised. Example: >>> palindromic_primes(10) [2, 3, 5, 7] >>> palindromic_primes(10, count=True) 4 >>> palindromic_primes([10, 20]) [[2, 3, 5, 7], [2, 3, 5, 7, 11]] >>> palindromic_primes([10, 2, -1]) [[2, 3, 5, 7], 'Invalid input: 2 is not a positive integer greater than 2.', 'Invalid input: -1 is not a positive integer greater than 2.']","solution":"def is_prime(num): if num < 2: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def is_palindrome(num): return str(num) == str(num)[::-1] def palindromic_primes(n, count=False): if isinstance(n, int): if n <= 2: raise ValueError('Input must be a positive integer greater than 2.') results = [i for i in range(2, n) if is_prime(i) and is_palindrome(i)] return len(results) if count else results elif isinstance(n, list): result_list = [] for num in n: if isinstance(num, int) and num > 2: result_list.append([i for i in range(2, num) if is_prime(i) and is_palindrome(i)]) else: result_list.append(f\\"Invalid input: {num} is not a positive integer greater than 2.\\") return result_list else: raise ValueError('Input must be a positive integer greater than 2 or a list of such integers.')"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression involving addition, subtraction, multiplication, and division. The function correctly handles operator precedence and parentheses. The function does not use the \`eval\` function. Parameters: expression (str): The string representing the expression to evaluate. Returns: float: The result of the evaluated expression. import re def test_simple_addition(): assert evaluate_expression(\\"3 + 2\\") == 5.0 def test_simple_subtraction(): assert evaluate_expression(\\"5 - 2\\") == 3.0 def test_simple_multiplication(): assert evaluate_expression(\\"4 * 2\\") == 8.0 def test_simple_division(): assert evaluate_expression(\\"8 / 2\\") == 4.0 def test_combined_operations(): assert evaluate_expression(\\"3 + 5 * 2\\") == 13.0 assert evaluate_expression(\\"3 + 5 * 2 / 4\\") == 5.5 def test_expression_with_parentheses(): assert evaluate_expression(\\"(3 + 5) * 2\\") == 16.0 def test_expression_with_nested_parentheses(): assert evaluate_expression(\\"3 + (5 * (2 + 3))\\") == 28.0 def test_expression_with_multiple_parentheses(): assert evaluate_expression(\\"(3 + 5) * (2 + 3)\\") == 40.0 def test_divide_by_zero(): import pytest with pytest.raises(ValueError, match=\\"Division by zero\\"): evaluate_expression(\\"2 / 0\\")","solution":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression involving addition, subtraction, multiplication, and division. Parameters: expression (str): The string representing the expression to evaluate. Returns: float: The result of the evaluated expression. import re def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_operation(operators, values): right = values.pop() left = values.pop() operator = operators.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': if right == 0: raise ValueError(\\"Division by zero\\") values.append(left / right) def is_operator(c): return c in \\"+-*/\\" tokens = re.findall(\\"[+-*/()]|d+.d+|d+\\", expression.replace(\\" \\", \\"\\")) values = [] operators = [] for token in tokens: if re.match(\\"d+.d+|d+\\", token): values.append(float(token)) elif token == '(': operators.append(token) elif token == ')': while operators and operators[-1] != '(': apply_operation(operators, values) operators.pop() # Pop the '(' elif is_operator(token): while (operators and precedence(operators[-1]) >= precedence(token)): apply_operation(operators, values) operators.append(token) while operators: apply_operation(operators, values) return values[0]"},{"question":"from typing import List def filter_squares(int_list: List[int], threshold: int) -> List[int]: Returns a list containing only the integers that are perfect squares and greater than the given threshold. :param int_list: List of integers to filter. :param threshold: Integer threshold value that the perfect squares must be greater than. :return: List of integers that are perfect squares greater than the threshold. >>> filter_squares([1, 4, 9, 14, 16, 20, 25, 30], 10) [16, 25] >>> filter_squares([1, 2, 3, 4, 5, 6], 10) [] >>> filter_squares([3, 5, 7, 16, 20, 25, 26], 15) [16, 25] >>> filter_squares([], 10) [] >>> filter_squares([2, 3, 5, 7, 8], 10) [] >>> filter_squares([1, 4, 9, 14, 16, 20, 25, 30], -5) [1, 4, 9, 16, 25] >>> filter_squares([1, 4, 9, 14, 16, 20, 25, 30], 0) [1, 4, 9, 16, 25]","solution":"import math def filter_squares(int_list, threshold): Returns a list containing only the integers that are perfect squares and greater than the given threshold. :param int_list: List of integers to filter. :param threshold: Integer threshold value that the perfect squares must be greater than. :return: List of integers that are perfect squares greater than the threshold. result = [] for number in int_list: if number > threshold and math.isqrt(number) ** 2 == number: result.append(number) return result"},{"question":"import csv from collections import defaultdict from typing import Dict def parse_sales_data(filename: str) -> Dict[str, Dict[str, int]]: Reads the CSV file and returns the total sales per product in each region. Args: filename (str): The path to the CSV file containing the sales data. Returns: Dict[str, Dict[str, int]]: A dictionary where keys are product names and values are dictionaries with region names as keys and total sales amounts as values. Example: >>> parse_sales_data(\\"sales_data.csv\\") { \\"ProductA\\": { \\"North\\": 300, \\"West\\": 250 }, \\"ProductB\\": { \\"South\\": 150, \\"East\\": 100 } } pass def test_parse_sales_data(tmp_path): data = Date,Product,Region,Sales 2023-01-01,ProductA,North,100 2023-01-01,ProductB,South,150 2023-01-02,ProductA,North,200 2023-01-02,ProductB,East,100 2023-01-02,ProductA,West,250 file_path = tmp_path / \\"sales_data.csv\\" file_path.write_text(data) expected_output = { \\"ProductA\\": { \\"North\\": 300, \\"West\\": 250 }, \\"ProductB\\": { \\"South\\": 150, \\"East\\": 100 } } result = parse_sales_data(file_path) assert result == expected_output def test_parse_sales_data_single_entry(tmp_path): data = Date,Product,Region,Sales 2023-01-01,ProductA,North,100 file_path = tmp_path / \\"sales_data.csv\\" file_path.write_text(data) expected_output = { \\"ProductA\\": { \\"North\\": 100 } } result = parse_sales_data(file_path) assert result == expected_output def test_parse_sales_data_empty_file(tmp_path): data = Date,Product,Region,Sales file_path = tmp_path / \\"sales_data.csv\\" file_path.write_text(data) expected_output = {} result = parse_sales_data(file_path) assert result == expected_output def test_parse_sales_data_multiple_products_and_regions(tmp_path): data = Date,Product,Region,Sales 2023-01-01,ProductA,North,100 2023-01-01,ProductB,South,150 2023-01-02,ProductA,West,200 2023-01-02,ProductB,East,100 2023-01-03,ProductC,North,250 2023-01-03,ProductC,South,300 file_path = tmp_path / \\"sales_data.csv\\" file_path.write_text(data) expected_output = { \\"ProductA\\": { \\"North\\": 100, \\"West\\": 200 }, \\"ProductB\\": { \\"South\\": 150, \\"East\\": 100 }, \\"ProductC\\": { \\"North\\": 250, \\"South\\": 300 } } result = parse_sales_data(file_path) assert result == expected_output","solution":"import csv from collections import defaultdict from typing import Dict def parse_sales_data(filename: str) -> Dict[str, Dict[str, int]]: sales_data = defaultdict(lambda: defaultdict(int)) with open(filename, newline='') as csvfile: reader = csv.DictReader(csvfile) for row in reader: product = row['Product'] region = row['Region'] sales = int(row['Sales']) sales_data[product][region] += sales return dict(sales_data)"},{"question":"def group_anagrams(words: List[str]) -> Dict[str, List[str]]: Given a list of strings, group the list into anagrams and return a dictionary. Args: words (List[str]): The list of words to group. Returns: Dict[str, List[str]]: A dictionary where keys are sorted strings of anagrams, and values are lists of words that are anagrams. Examples: >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) {'aet': ['eat', 'tea', 'ate'], 'ant': ['tan', 'nat'], 'abt': ['bat']} >>> group_anagrams([]) {} >>> group_anagrams([\\"apple\\", \\"banana\\", \\"carrot\\"]) {'aelpp': ['apple'], 'aaabnn': ['banana'], 'acorrt': ['carrot']} >>> group_anagrams([\\"test\\", \\"test\\", \\"test\\"]) {'estt': ['test', 'test', 'test']} >>> group_anagrams([\\"Listen\\", \\"Silent\\", \\"enlist\\"]) {'Leinst': ['Listen'], 'Seilnt': ['Silent'], 'eilnst': ['enlist']}","solution":"from collections import defaultdict def group_anagrams(words): Groups a list of words into anagrams. Args: words (list of str): The list of words to group. Returns: dict: A dictionary where keys are sorted strings of anagrams, and values are lists of words that are anagrams. anagram_groups = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagram_groups[sorted_word].append(word) return dict(anagram_groups)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing only non-negative integers, '+', '-', '*', and '/' (with truncating towards zero). The expression respects the order of operations (PEMDAS/BODMAS rules). >>> evaluate_expression(\\"1 + 2\\") 3 >>> evaluate_expression(\\"5 - 3\\") 2 >>> evaluate_expression(\\"4 * 2\\") 8 >>> evaluate_expression(\\"8 / 2\\") 4 >>> evaluate_expression(\\"2 + 3 * 4\\") 14 >>> evaluate_expression(\\"(2 + 3) * 4\\") 20 >>> evaluate_expression(\\"8 / 3\\") 2 >>> evaluate_expression(\\"10 + 2 * 6\\") 22 >>> evaluate_expression(\\"100 * 2 + 12\\") 212 >>> evaluate_expression(\\"100 * (2 + 12)\\") 1400 >>> evaluate_expression(\\"100 * (2 + 12) / 14\\") 100 >>> evaluate_expression(\\" 100 * ( 2 + 12) / 14 \\") 100 >>> evaluate_expression(\\"0 + 0\\") 0 >>> evaluate_expression(\\"0 * 100 + 2\\") 2 >>> evaluate_expression(\\"123456789 * 9\\") 1111111101","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing only non-negative integers, '+', '-', '*', and '/' (with truncating towards zero). The expression respects the order of operations (PEMDAS/BODMAS rules). import re # Handling white spaces expression = expression.replace(\\" \\", \\"\\") def helper(tokens): stack = [] num = 0 sign = \\"+\\" while len(tokens) > 0: token = tokens.pop(0) if token.isdigit(): num = int(token) if token == '(': num = helper(tokens) if token in '+-*/)' or not tokens: if sign == \\"+\\": stack.append(num) elif sign == \\"-\\": stack.append(-num) elif sign == \\"*\\": stack.append(stack.pop() * num) elif sign == \\"/\\": stack.append(int(stack.pop() / num)) sign = token num = 0 if token == ')': break return sum(stack) # Tokenize the string by digits and operators tokens = re.findall(r\\"[d]+|[-+*/()]\\", expression) return helper(tokens)"},{"question":"def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Returns a list of unique pairs from the given list that add up to the target sum. Each pair is a tuple (smaller number, larger number). >>> find_pairs([10, 15, 3, 7, 3], 10) [(3, 7)] >>> find_pairs([1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> find_pairs([], 10) [] >>> find_pairs([5], 5) [] >>> find_pairs([1, 2, 3, 9], 15) [] >>> find_pairs([1, 1, 2, 2, 3, 3, 4, 4], 5) [(1, 4), (2, 3)] from solution import find_pairs def test_find_pairs_target_sum(): result = find_pairs([10, 15, 3, 7, 3], 10) assert (3, 7) in result assert len(result) == 1 def test_find_pairs_distinct_pairs(): result = find_pairs([1, 2, 3, 4, 5], 5) assert (1, 4) in result assert (2, 3) in result assert len(result) == 2 def test_find_pairs_empty_list(): result = find_pairs([], 10) assert result == [] def test_find_pairs_single_element_list(): result = find_pairs([5], 5) assert result == [] def test_find_pairs_no_pairs(): result = find_pairs([1, 2, 3, 9], 15) assert result == [] def test_find_pairs_repeated_elements(): result = find_pairs([1, 1, 2, 2, 3, 3, 4, 4], 5) assert (1, 4) in result assert (2, 3) in result assert len(result) == 2","solution":"def find_pairs(nums, target): Returns a list of unique pairs from the given list that add up to the target sum. Each pair is a tuple (smaller number, larger number). Parameters: nums (list of int): list of integers. target (int): target sum. Returns: list of tuples: list of tuples where each tuple contains two numbers that add up to the target sum. pairs = set() seen = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return list(pairs)"},{"question":"def unique_sorted_elements(lst: List[int]) -> List[int]: Returns a new list containing only the unique elements from the original list, but in sorted order. >>> unique_sorted_elements([3, 1, 2, 3, 4, 1, 2]) [1, 2, 3, 4] >>> unique_sorted_elements([5, 1, 3, 2, 4]) [1, 2, 3, 4, 5] >>> unique_sorted_elements([]) [] >>> unique_sorted_elements([1, 1, 1, 1]) [1] >>> unique_sorted_elements([-1, -2, 3, 2, 1]) [-2, -1, 1, 2, 3]","solution":"def unique_sorted_elements(lst): Returns a new list containing only the unique elements from the original list, but in sorted order. return sorted(set(lst))"},{"question":"def partition_even_odd(lst): Rearranges the list in place such that all even numbers appear before all odd numbers. The relative order of the even and odd numbers should remain unchanged. >>> lst = [3, 1, 2, 4] >>> partition_even_odd(lst) >>> lst [2, 4, 3, 1] >>> lst = [3, 1, 2, 4, 7, 6, 9, 8] >>> partition_even_odd(lst) >>> lst [2, 4, 6, 8, 3, 1, 7, 9] >>> lst = [2, 4, 6, 8] >>> partition_even_odd(lst) >>> lst [2, 4, 6, 8] >>> lst = [1, 3, 5, 7] >>> partition_even_odd(lst) >>> lst [1, 3, 5, 7] >>> lst = [] >>> partition_even_odd(lst) >>> lst [] >>> lst = [1] >>> partition_even_odd(lst) >>> lst [1] >>> lst = [2] >>> partition_even_odd(lst) >>> lst [2] >>> lst = [3, -1, -2, -4, 7, -6, 9, -8] >>> partition_even_odd(lst) >>> lst [-2, -4, -6, -8, 3, -1, 7, 9] >>> lst = [0, 1, 0, 1] >>> partition_even_odd(lst) >>> lst [0, 0, 1, 1]","solution":"def partition_even_odd(lst): Rearranges the list in place such that all even numbers appear before all odd numbers. The relative order of the even and odd numbers should remain unchanged. i, j = 0, 0 while j < len(lst): if lst[j] % 2 == 0: lst.insert(i, lst.pop(j)) i += 1 j += 1"},{"question":"def isPalindrome(s: str) -> bool: Checks if the given string is a valid palindrome, considering only alphanumeric characters and ignoring cases. >>> isPalindrome(\\"A man, a plan, a canal: Panama\\") == True >>> isPalindrome(\\"race a car\\") == False >>> isPalindrome(\\" \\") == True >>> isPalindrome(\\"Able was I ere I saw Elba\\") == True >>> isPalindrome(\\"No lemon, no melon\\") == True >>> isPalindrome(\\"Hello, World!\\") == False >>> isPalindrome(\\"12321\\") == True >>> isPalindrome(\\"12345\\") == False >>> isPalindrome(\\"\\") == True >>> isPalindrome(\\"a\\") == True >>> isPalindrome(\\"A\\") == True","solution":"def isPalindrome(s: str) -> bool: Checks if the given string is a valid palindrome, considering only alphanumeric characters and ignoring cases. # Filter out non-alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered characters form a palindrome return filtered_chars == filtered_chars[::-1]"},{"question":"def unique_consecutive_substrings(strings: List[str]) -> List[str]: Returns all possible unique substrings formed by any two (or more) consecutive strings in the list. >>> unique_consecutive_substrings([\\"a\\", \\"b\\"]) [\\"ab\\"] >>> unique_consecutive_substrings([\\"a\\", \\"b\\", \\"c\\"]) [\\"ab\\", \\"abc\\", \\"bc\\"] >>> unique_consecutive_substrings([\\"a\\", \\"b\\", \\"a\\"]) [\\"ab\\", \\"aba\\", \\"ba\\"] >>> unique_consecutive_substrings([\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) [\\"ab\\", \\"abc\\", \\"abcd\\", \\"bc\\", \\"bcd\\", \\"cd\\"] >>> unique_consecutive_substrings([\\"a\\", \\"a\\"]) [\\"aa\\"] >>> unique_consecutive_substrings([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"]) [\\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\", \\"bc\\", \\"bcd\\", \\"bcde\\", \\"cd\\", \\"cde\\", \\"de\\"]","solution":"def unique_consecutive_substrings(strings): Returns all possible unique substrings formed by any two (or more) consecutive strings in the list. :param strings: List of strings :return: List of unique substrings substrings = set() result = [] for i in range(len(strings) - 1): for j in range(i + 1, len(strings)): substring = ''.join(strings[i:j + 1]) if substring not in substrings: substrings.add(substring) result.append(substring) return result"},{"question":"def remove_duplicates(input_list: List[int]) -> List[int]: Returns a list with all duplicate numbers removed while maintaining the original order of first occurrences. >>> remove_duplicates([4, 5, 6, 4, 7, 6, 8]) [4, 5, 6, 7, 8] >>> remove_duplicates([1, 2, 3, 2, 1, 4]) [1, 2, 3, 4] >>> remove_duplicates([]) [] >>> remove_duplicates([1, 1, 1, 1]) [1] >>> remove_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([1, 2, 1, 3, 2, 4, 3, 5]) [1, 2, 3, 4, 5]","solution":"def remove_duplicates(input_list): Returns a list with all duplicate numbers removed while maintaining the original order of first occurrences. seen = set() result = [] for num in input_list: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"def string_frequency(s: str) -> dict: Returns a dictionary with the frequency of each alphabetic character in the string. The function ignores non-alphabetic characters and is case-insensitive. The output is sorted in alphabetical order of characters. >>> string_frequency(\\"Hello, World!\\") {'d': 1, 'e': 1, 'h': 1, 'l': 3, 'o': 2, 'r': 1, 'w': 1} >>> string_frequency(\\"\\") {} >>> string_frequency(\\"123!@#\\") {} >>> string_frequency(\\"AaBbCc\\") {'a': 2, 'b': 2, 'c': 2} >>> string_frequency(\\"Hello123, World 456!\\") {'d': 1, 'e': 1, 'h': 1, 'l': 3, 'o': 2, 'r': 1, 'w': 1} >>> test_string = \\"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\\" >>> expected_result = {chr(c): 2 for c in range(ord('a'), ord('z') + 1)} >>> string_frequency(test_string) expected_result","solution":"def string_frequency(s): Returns a dictionary with the frequency of each alphabetic character in the string. The function ignores non-alphabetic characters and is case-insensitive. The output is sorted in alphabetical order of characters. from collections import Counter # Convert to lower case and filter alphabetic characters cleaned_string = ''.join(filter(str.isalpha, s.lower())) # Count frequencies of characters frequency = Counter(cleaned_string) # Return the dictionary sorted by keys (characters) return dict(sorted(frequency.items()))"},{"question":"def most_frequent_character(s: str) -> str: Design a function that determines the most frequent character in a given string. If there is a tie for the most frequent character, return the character that comes first alphabetically. >>> most_frequent_character(\\"apple\\") == 'p' >>> most_frequent_character(\\"banana\\") == 'a' >>> most_frequent_character(\\"mango\\") == 'a' >>> most_frequent_character(\\"\\") == None >>> most_frequent_character(\\"test\\") == 't' >>> most_frequent_character(\\"aaaa\\") == 'a'","solution":"def most_frequent_character(s): Returns the most frequent character in the string. If there is a tie, returns the character that comes first alphabetically. from collections import Counter if not s: return None frequency = Counter(s) most_frequent = min(frequency, key=lambda x: (-frequency[x], x)) return most_frequent"},{"question":"import datetime class Inventory: def __init__(self, id: int, name: str, quantity: int, location: str): Initialize an Inventory item with id, name, quantity, and location. :param id: Inventory item ID :param name: Inventory item name :param quantity: Quantity of inventory item :param location: Location of the inventory item >>> inventory = Inventory(1, 'Tomatoes', 100, 'Warehouse 1') >>> inventory.id 1 >>> inventory.name 'Tomatoes' >>> inventory.quantity 100 >>> inventory.location 'Warehouse 1' pass class Order: def __init__(self, id: int, product: str, quantity: int, customer: str, date: datetime.datetime): Initialize an Order with id, product, quantity, customer, and date. :param id: Order ID :param product: Ordered product name :param quantity: Quantity ordered :param customer: Customer who placed the order :param date: Order date >>> order = Order(1, 'Tomatoes', 50, 'John Doe', datetime.datetime(2023, 10, 10)) >>> order.id 1 >>> order.product 'Tomatoes' >>> order.quantity 50 >>> order.customer 'John Doe' >>> order.date datetime.datetime(2023, 10, 10) pass class Report: def __init__(self, id: int, title: str, content: str, generated_on: datetime.datetime): Initialize a Report with id, title, content, and generated_on date. :param id: Report ID :param title: Title of the report :param content: Content of the report :param generated_on: Report generation date >>> report = Report(1, 'Monthly Sales', 'Content of the report', datetime.datetime(2023, 10, 1)) >>> report.id 1 >>> report.title 'Monthly Sales' >>> report.content 'Content of the report' >>> report.generated_on datetime.datetime(2023, 10, 1) pass class Customer: def __init__(self, id: int, name: str, contact: str, address: str): Initialize a Customer with id, name, contact, and address. :param id: Customer ID :param name: Customer name :param contact: Customer contact information :param address: Customer address >>> customer = Customer(1, 'John Doe', '123456789', '123 Main St') >>> customer.id 1 >>> customer.name 'John Doe' >>> customer.contact '123456789' >>> customer.address '123 Main St' pass class Supplier: def __init__(self, id: int, name: str, contact: str, address: str): Initialize a Supplier with id, name, contact, and address. :param id: Supplier ID :param name: Supplier name :param contact: Supplier contact information :param address: Supplier address >>> supplier = Supplier(1, 'Jane Smith', '987654321', '456 Elm St') >>> supplier.id 1 >>> supplier.name 'Jane Smith' >>> supplier.contact '987654321' >>> supplier.address '456 Elm St' pass","solution":"import datetime # Models representing data structures class Inventory: def __init__(self, id: int, name: str, quantity: int, location: str): self.id = id self.name = name self.quantity = quantity self.location = location class Order: def __init__(self, id: int, product: str, quantity: int, customer: str, date: datetime.datetime): self.id = id self.product = product self.quantity = quantity self.customer = customer self.date = date class Report: def __init__(self, id: int, title: str, content: str, generated_on: datetime.datetime): self.id = id self.title = title self.content = content self.generated_on = generated_on class Customer: def __init__(self, id: int, name: str, contact: str, address: str): self.id = id self.name = name self.contact = contact self.address = address class Supplier: def __init__(self, id: int, name: str, contact: str, address: str): self.id = id self.name = name self.contact = contact self.address = address"},{"question":"def truncate_strings(strings: list, n: int) -> list: Truncate each string in the list to 'n' characters. Strings shorter than or equal to 'n' characters remain unchanged. Parameters: strings (list): A list of strings to be truncated. n (int): The maximum length for each string. Returns: list: A new list with truncated strings. # Unit Tests def test_truncate_strings_all_shorter(): assert truncate_strings(['one', 'two', 'three'], 5) == ['one', 'two', 'three'] assert truncate_strings(['abcd', 'xy'], 4) == ['abcd', 'xy'] def test_truncate_strings_all_longer(): assert truncate_strings(['one', 'two', 'three'], 2) == ['on', 'tw', 'th'] assert truncate_strings(['abcdef', 'xyz'], 3) == ['abc', 'xyz'] def test_truncate_strings_mixed_lengths(): assert truncate_strings(['one', 'two', 'three', 'four'], 3) == ['one', 'two', 'thr', 'fou'] assert truncate_strings(['abc', 'xy', 'vwxyz'], 4) == ['abc', 'xy', 'vwxy'] def test_truncate_strings_n_is_zero(): assert truncate_strings(['one', 'two', 'three'], 0) == ['', '', ''] assert truncate_strings(['abc'], 0) == [''] def test_truncate_strings_empty_list(): assert truncate_strings([], 3) == [] def test_truncate_strings_empty_strings(): assert truncate_strings(['', '', ''], 3) == ['', '', ''] assert truncate_strings(['', '', ''], 0) == ['', '', '']","solution":"def truncate_strings(strings, n): Truncate each string in the list to 'n' characters. Strings shorter than or equal to 'n' characters remain unchanged. Parameters: strings (list): A list of strings to be truncated. n (int): The maximum length for each string. Returns: list: A new list with truncated strings. return [s[:n] if len(s) > n else s for s in strings]"},{"question":"import re def is_camel_case(s: str) -> bool: Determines if a string follows the camel case naming convention. Camel case requires the first letter to be lowercase, and subsequent words should start with an uppercase letter, with no spaces or special characters. >>> is_camel_case(\\"thisIsCamelCase\\") == True >>> is_camel_case(\\"ThisIsNotCamelCase\\") == False >>> is_camel_case(\\"notCamel\\") == True >>> is_camel_case(\\"notCamel123\\") == False >>> is_camel_case(\\"not_camel\\") == False def test_camel_case_valid(): assert is_camel_case(\\"thisIsCamelCase\\") == True assert is_camel_case(\\"thisIsATest\\") == True assert is_camel_case(\\"suchAWellFormedCamel\\") == True assert is_camel_case(\\"aSmallCamelCase\\") == True def test_camel_case_invalid(): assert is_camel_case(\\"ThisIsNotCamelCase\\") == False assert is_camel_case(\\"notCamel123\\") == False assert is_camel_case(\\"not_camel\\") == False assert is_camel_case(\\"camelCase!\\") == False assert is_camel_case(\\"CamelCase\\") == False def test_camel_case_edge_cases(): assert is_camel_case(\\"\\") == False # no content assert is_camel_case(\\"a\\") == True # single lower case letter assert is_camel_case(\\"A\\") == False # single upper case letter assert is_camel_case(\\"Aa\\") == False # starts with upper case assert is_camel_case(\\"aAa\\") == True # valid camel case with single words","solution":"import re def is_camel_case(s): Returns True if the string follows camel case convention, False otherwise. # Check if the string matches the camel case pattern. return bool(re.match(r'^[a-z]+(?:[A-Z][a-z]*)*', s))"},{"question":"def product_except_self(nums): Returns a list of products of all integers in the input list except for the integer at each index. :param nums: List of integers. :return: List of integers where each integer is the product of all integers in the input list except the one at the current index. >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([4, 3, 2, 1]) == [6, 8, 12, 24] >>> product_except_self([2, 2, 2, 2]) == [8, 8, 8, 8] >>> product_except_self([0, 1, 2, 3]) == [6, 0, 0, 0] >>> product_except_self([1, 0, 2, 0]) == [0, 0, 0, 0] >>> product_except_self([]) == [] >>> product_except_self([10]) == [1] # Test invalid inputs >>> product_except_self('not a list') == \\"Input must be a list\\" >>> product_except_self([1, 2, 'three']) == \\"All elements of the list must be integers\\"","solution":"def product_except_self(nums): Returns a list of products of all integers in the input list except for the integer at each index. :param nums: List of integers. :return: List of integers where each integer is the product of all integers in the input list except the one at the current index. if not isinstance(nums, list): return \\"Input must be a list\\" if not all(isinstance(x, int) for x in nums): return \\"All elements of the list must be integers\\" n = len(nums) if n == 0: return [] if n == 1: return [1] # Initialize the result array with 1 result = [1] * n # Calculate products of elements on the left side except self left_product = 1 for i in range(n): result[i] *= left_product left_product *= nums[i] # Calculate products of elements on the right side except self right_product = 1 for i in range(n-1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def fibonacci_sequence(n): Generates the first \`n\` numbers of the Fibonacci sequence. :param n: Non-negative integer representing the number of Fibonacci numbers to generate. :return: List containing the first \`n\` numbers of the Fibonacci sequence. :raises ValueError: If the input is not a non-negative integer. # Your code here # Test cases print(fibonacci_sequence(10)) # Expected output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] print(fibonacci_sequence(0)) # Expected output: [] print(fibonacci_sequence(1)) # Expected output: [0] print(fibonacci_sequence(2)) # Expected output: [0, 1] print(fibonacci_sequence(5)) # Expected output: [0, 1, 1, 2, 3] try: fibonacci_sequence(-1) except ValueError as e: print(e) # Expected output: \\"Input must be a non-negative integer\\" try: fibonacci_sequence(2.5) except ValueError as e: print(e) # Expected output: \\"Input must be a non-negative integer\\" try: fibonacci_sequence(\\"string\\") except ValueError as e: print(e) # Expected output: \\"Input must be a non-negative integer\\" try: fibonacci_sequence(None) except ValueError as e: print(e) # Expected output: \\"Input must be a non-negative integer\\"","solution":"def fibonacci_sequence(n): Generates the first \`n\` numbers of the Fibonacci sequence. :param n: Non-negative integer representing the number of Fibonacci numbers to generate. :return: List containing the first \`n\` numbers of the Fibonacci sequence. :raises ValueError: If the input is not a non-negative integer. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer\\") sequence = [] a, b = 0, 1 for _ in range(n): sequence.append(a) a, b = b, a + b return sequence"},{"question":"import keyword def is_valid_identifier(identifier: str) -> bool: Returns True if 'identifier' is a valid identifier, False otherwise. >>> is_valid_identifier('variable1') True >>> is_valid_identifier('_var') True >>> is_valid_identifier('2invalid') False >>> is_valid_identifier('for') False >>> is_valid_identifier('whileTrue') True","solution":"import keyword def is_valid_identifier(identifier): Returns True if 'identifier' is a valid identifier, False otherwise. if not identifier: return False if identifier in keyword.kwlist: return False if not (identifier[0].isalpha() or identifier[0] == '_'): return False for char in identifier[1:]: if not (char.isalnum() or char == '_'): return False return True"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a given mathematical expression string. Supports addition, subtraction, multiplication, and division operations. Handles whitespace around operators and operands. >>> evaluate_expression(\\"3 + 5\\") == 8 >>> evaluate_expression(\\"10 - 2\\") == 8 >>> evaluate_expression(\\"4 * 7\\") == 28 >>> evaluate_expression(\\"16 / 4\\") == 4.0 >>> evaluate_expression(\\" 9 + 3 \\") == 12 >>> evaluate_expression(\\" 2 * ( 3 + 5 ) / 2 \\") == 8.0 >>> evaluate_expression(\\"10 / 0\\") == None >>> evaluate_expression(\\"5 + \\") == None","solution":"def evaluate_expression(expression): Evaluates a given mathematical expression string. Supports addition, subtraction, multiplication, and division operations. Handles whitespace around operators and operands. # Remove any leading/trailing whitespace expression = expression.strip() # Use Python's eval function to evaluate the expression try: result = eval(expression) except (SyntaxError, ZeroDivisionError): return None return result"},{"question":"def get_top_student(students: List[Dict[str, Union[str, int]]]) -> str: Returns the name of the student with the highest score. If there are multiple students with the highest score, return the one whose name comes first alphabetically. >>> students = [ {\\"name\\": \\"John\\", \\"score\\": 85}, {\\"name\\": \\"Jane\\", \\"score\\": 92}, {\\"name\\": \\"Alice\\", \\"score\\": 92}, {\\"name\\": \\"Bob\\", \\"score\\": 78} ] get_top_student(students) \\"Alice\\" >>> students = [ {\\"name\\": \\"John\\", \\"score\\": 85} ] get_top_student(students) \\"John\\"","solution":"def get_top_student(students): Returns the name of the student with the highest score. If there are multiple students with the highest score, return the one whose name comes first alphabetically. if not students: return None top_student = None top_score = float('-inf') for student in students: name = student['name'] score = student['score'] if score > top_score or (score == top_score and name < top_student): top_student = name top_score = score return top_student"},{"question":"from typing import List def is_prime(n: int) -> bool: Determines if a given number n is prime. pass def filter_primes(numbers: List[int]) -> List[int]: Filters the list of numbers and returns a new list containing only the prime numbers. >>> filter_primes([1, 4, 6, 8, 10]) [] >>> filter_primes([2, 3, 5, 7]) [2, 3, 5, 7] >>> filter_primes([10, 11, 12, 13, 14, 15]) [11, 13] >>> filter_primes([]) [] >>> filter_primes([-1, -2, -3, 17, 19]) [17, 19] pass","solution":"def is_prime(n): Determines if a given number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(numbers): Filters the list of numbers and returns a new list containing only the prime numbers. return [num for num in numbers if is_prime(num)]"},{"question":"def sorted_squares(lst: List[int]) -> List[int]: Returns a new list with the squares of the original integers sorted in ascending order. >>> sorted_squares([4, -3, 2, 1]) [1, 4, 9, 16] >>> sorted_squares([-1, 0, 2, 3]) [0, 1, 4, 9]","solution":"def sorted_squares(lst): Returns a new list with the squares of the original integers sorted in ascending order. Parameters: lst (list of integers): The input list of integers. Returns: list of integers: A new list with the squares of the original integers sorted in ascending order. squared_lst = [x**2 for x in lst] squared_lst.sort() return sorted(squared_lst)"},{"question":"def spiral_order(matrix: List[List[int]]) -> List[int]: Returns the elements of a 2D matrix in spiral order. >>> spiral_order([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiral_order([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12] ... ]) [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] >>> spiral_order([ ... [1, 2, 3, 4, 5] ... ]) [1, 2, 3, 4, 5] >>> spiral_order([ ... [1], ... [2], ... [3], ... [4], ... [5] ... ]) [1, 2, 3, 4, 5] >>> spiral_order([]) [] >>> spiral_order([ ... [1, 2], ... [3, 4] ... ]) [1, 2, 4, 3] >>> spiral_order([ ... [1, 2], ... [3, 4], ... [5, 6] ... ]) [1, 2, 4, 6, 5, 3]","solution":"def spiral_order(matrix): Returns the elements of a 2D matrix in spiral order. if not matrix or not matrix[0]: return [] result = [] top, bottom = 0, len(matrix) - 1 left, right = 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 # Traverse from top to bottom for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: # Traverse from bottom to top for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"from typing import List, Tuple def best_buy_sell_days(prices: List[int]) -> Tuple[int, int]: Find the best day to buy and the best day to sell to maximize profit. Returns a tuple with the indices of the buy day and the sell day. If there is no profit to be made, returns (0, 0). >>> best_buy_sell_days([7, 1, 5, 3, 6, 4]) (1, 4) >>> best_buy_sell_days([7, 6, 4, 3, 1]) (0, 0) >>> best_buy_sell_days([1, 2, 3, 4, 5]) (0, 4) >>> best_buy_sell_days([2, 4, 1, 7, 5, 3]) (2, 3) >>> best_buy_sell_days([3, 3, 3, 3, 3]) (0, 0) >>> best_buy_sell_days([1, 1, 1, 0, 2, 2, 2, 2, 2]) (3, 4) >>> best_buy_sell_days([9]) (0, 0) >>> best_buy_sell_days([]) (0, 0) >>> best_buy_sell_days([8, 7, 6, 4, 1, 10]) (4, 5) >>> best_buy_sell_days([5, 5, 1, 3, 5, 8, 1, 6]) (2, 5)","solution":"from typing import List, Tuple def best_buy_sell_days(prices: List[int]) -> Tuple[int, int]: Find the best day to buy and the best day to sell to maximize profit. Returns a tuple with the indices of the buy day and the sell day. If there is no profit to be made, returns (0, 0). if not prices: return (0, 0) min_price = float('inf') max_profit = 0 buy_day = 0 sell_day = 0 for i, price in enumerate(prices): if price < min_price: min_price = price potential_buy_day = i profit = price - min_price if profit > max_profit: max_profit = profit buy_day = potential_buy_day sell_day = i if max_profit == 0: return (0, 0) return (buy_day, sell_day)"},{"question":"def sort_words(sentence: str) -> str: Takes a string containing multiple words and returns a new string where the words are sorted alphabetically. Args: sentence (str): The input string containing only lower-case letters and spaces. Returns: str: A new string with the words sorted alphabetically. >>> sort_words(\\"the quick brown fox jumps over the lazy dog\\") 'brown dog fox jumps lazy over quick the the' >>> sort_words(\\"hello\\") 'hello' >>> sort_words(\\"hello world\\") 'hello world' >>> sort_words(\\"apple apricot banana\\") 'apple apricot banana' >>> sort_words(\\"apple banana cherry date\\") 'apple banana cherry date' >>> sort_words(\\"\\") ''","solution":"def sort_words(sentence): Takes a string containing multiple words and returns a new string where the words are sorted alphabetically. Args: sentence (str): The input string containing only lower-case letters and spaces. Returns: str: A new string with the words sorted alphabetically. words = sentence.split() sorted_words = sorted(words) return ' '.join(sorted_words)"},{"question":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler, OneHotEncoder from sklearn.compose import ColumnTransformer from sklearn.pipeline import Pipeline from sklearn.impute import SimpleImputer from sklearn.ensemble import RandomForestClassifier def preprocess_and_train_model(data): Establish a data pipeline using the Pandas and Scikit-learn libraries to preprocess the Titanic dataset. The preprocessing steps should include handling missing values, encoding categorical variables, and standardizing numerical features. Use a RandomForestClassifier to predict the survival of passengers based on these preprocessed features. >>> import pandas as pd >>> data = pd.DataFrame({ ... 'Pclass': [1, 3, 2, 3, 1], ... 'Sex': ['male', 'female', 'female', 'male', 'female'], ... 'Age': [22, 38, 26, 35, 27], ... 'SibSp': [1, 1, 0, 0, 0], ... 'Parch': [0, 0, 0, 0, 0], ... 'Fare': [7.25, 71.2833, 7.925, 8.0500, 13.00], ... 'Embarked': ['S', 'C', 'C', 'S', 'S'], ... 'Survived': [0, 1, 1, 0, 1] ... }) >>> model, predictions, y_val = preprocess_and_train_model(data)","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler, OneHotEncoder from sklearn.compose import ColumnTransformer from sklearn.pipeline import Pipeline from sklearn.impute import SimpleImputer from sklearn.ensemble import RandomForestClassifier def preprocess_and_train_model(data): # Split data into features and target X = data.drop(columns=['Survived']) y = data['Survived'] # Define columns numerical_features = ['Age', 'Fare'] categorical_features = ['Pclass', 'Sex', 'Embarked'] # Preprocessing for numerical data numerical_transformer = Pipeline(steps=[ ('imputer', SimpleImputer(strategy='median')), ('scaler', StandardScaler()) ]) # Preprocessing for categorical data categorical_transformer = Pipeline(steps=[ ('imputer', SimpleImputer(strategy='most_frequent')), ('onehot', OneHotEncoder(handle_unknown='ignore')) ]) # Bundle preprocessing for numerical and categorical data preprocessor = ColumnTransformer( transformers=[ ('num', numerical_transformer, numerical_features), ('cat', categorical_transformer, categorical_features) ]) # Create pipeline with preprocessor and model model = Pipeline(steps=[ ('preprocessor', preprocessor), ('classifier', RandomForestClassifier(n_estimators=100, random_state=0)) ]) # Split data into training and validation sets X_train, X_val, y_train, y_val = train_test_split(X, y, train_size=0.8, test_size=0.2, random_state=0) # Fit the model model.fit(X_train, y_train) # Get predictions predictions = model.predict(X_val) return model, predictions, y_val"},{"question":"def merge_dicts(dict_list: List[Dict]) -> Dict: Merges a list of dictionaries into a single dictionary. For any common keys that appear in multiple dictionaries, their values are summed. Handles nested dictionaries by summing common keys at every level of nesting. :param dict_list: List of dictionaries to be merged :return: A single merged dictionary pass # Example usage and test cases def test_merge_dicts_simple(): result = merge_dicts([{'a': 1}, {'a': 2, 'b': 3}]) assert result == {'a': 3, 'b': 3} def test_merge_dicts_complex(): result = merge_dicts([{'a': 1}, {'a': 2, 'b': {'c': 4}}, {'a': 5, 'b': {'c': 6, 'd': 7}}]) assert result == {'a': 8, 'b': {'c': 10, 'd': 7}} def test_merge_dicts_nested(): result = merge_dicts([{'a': {'b': 1}}, {'a': {'b': 2, 'c': 3}}, {'a': {'b': 3, 'c': 4, 'd': 5}}]) assert result == {'a': {'b': 6, 'c': 7, 'd': 5}} def test_merge_dicts_disjoint(): result = merge_dicts([{'a': 1}, {'b': 2}, {'c': {'d': 3}}]) assert result == {'a': 1, 'b': 2, 'c': {'d': 3}} def test_merge_dicts_empty(): result = merge_dicts([{}, {'a': 1}, {}]) assert result == {'a': 1} def test_merge_dicts_mix(): result = merge_dicts([{'a': 1, 'b': {'x': 1}}, {'a': 2, 'b': {'y': 2}}, {'b': {'x': 3}, 'c': 4}]) assert result == {'a': 3, 'b': {'x': 4, 'y': 2}, 'c': 4}","solution":"def merge_dicts(dict_list): Merges a list of dictionaries into a single dictionary. For any common keys that appear in multiple dictionaries, their values are summed. Handles nested dictionaries by summing common keys at every level of nesting. :param dict_list: List of dictionaries to be merged :return: A single merged dictionary def merge_two_dicts(d1, d2): for key in d2: if key in d1: if isinstance(d1[key], dict) and isinstance(d2[key], dict): d1[key] = merge_two_dicts(d1[key], d2[key]) else: d1[key] += d2[key] else: d1[key] = d2[key] return d1 merged_dict = {} for dictionary in dict_list: merged_dict = merge_two_dicts(merged_dict, dictionary) return merged_dict"},{"question":"def is_happy_string(s: str) -> bool: Determine if a given string is a happy string. A string is considered happy if every letter in it appears at least twice consecutively. Parameters: - s: the input string containing only lowercase English letters. Returns: - True if the string is happy, otherwise False. Examples: >>> is_happy_string(\\"hhaappyy\\") True >>> is_happy_string(\\"hello\\") False >>> is_happy_string(\\"hahppy\\") False >>> is_happy_string(\\"aabbcc\\") True >>> is_happy_string(\\"abc\\") False def test_happy_string(): assert is_happy_string(\\"hhaappyy\\") == True def test_not_happy_string_hello(): assert is_happy_string(\\"hello\\") == False def test_not_happy_string_hahppy(): assert is_happy_string(\\"hahppy\\") == False def test_happy_string_aabbcc(): assert is_happy_string(\\"aabbcc\\") == True def test_not_happy_string_abc(): assert is_happy_string(\\"abc\\") == False def test_empty_string(): assert is_happy_string(\\"\\") == False def test_single_character_string(): assert is_happy_string(\\"a\\") == False def test_happy_string_edge_case(): assert is_happy_string(\\"aabbccddeeffgghh\\") == True def test_not_happy_string_with_single_appearance(): assert is_happy_string(\\"aabbc\\") == False","solution":"def is_happy_string(s: str) -> bool: Determine if a given string is a happy string. A string is considered happy if every letter appears at least twice consecutively. Parameters: - s: the input string containing only lowercase English letters. Returns: - True if the string is happy, otherwise False. n = len(s) if n < 2: # A string of length less than 2 cannot be happy return False i = 0 while i < n: char_count = 1 while i + 1 < n and s[i] == s[i + 1]: char_count += 1 i += 1 if char_count < 2: return False i += 1 return True"},{"question":"from typing import List def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(1) [] >>> sieve_of_eratosthenes(2) [2] >>> sieve_of_eratosthenes(0) [] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> sieve_of_eratosthenes(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] >>> sieve_of_eratosthenes(-5) []","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start * start, n + 1, start): sieve[multiple] = False return [num for num in range(n + 1) if sieve[num]]"},{"question":"def is_palindrome(s: str) -> bool: Check if a given string is a valid palindrome considering only alphanumeric characters and ignoring cases. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"race a car\\") == False >>> is_palindrome(\\"No 'x' in Nixon\\") == True","solution":"def is_palindrome(s: str) -> bool: Check if the given string is a valid palindrome considering only alphanumeric characters and ignoring cases. # Filter only alphanumeric characters and convert to lower case. filtered_chars = ''.join(char.lower() for char in s if char.isalnum()) # Check if the filtered string is equal to its reverse. return filtered_chars == filtered_chars[::-1]"},{"question":"def max_product_of_pairs(int_list: List[int]) -> int: Determine the maximum product of any pair of integers in a given list of integers. Parameters: int_list (List[int]): A list of integers. Returns: int: The maximum product of any pair of integers. Raises: ValueError: If the list contains fewer than two integers. >>> max_product_of_pairs([1, 2, 3, 4, 5]) == 20 >>> max_product_of_pairs([-10, -20, 1, 2]) == 200 >>> max_product_of_pairs([-10, -20, 0, 2, 3]) == 200 >>> max_product_of_pairs([1, 2]) == 2 >>> max_product_of_pairs([-1, -2, -3, -4]) == 12 >>> max_product_of_pairs([999, 500, 2, 8, -300, 0, 1]) == 499500","solution":"def max_product_of_pairs(int_list): Returns the maximum product of any pair of integers in the given list of integers. Parameters: int_list (list): A list of integers. Returns: int: The maximum product of any pair of integers. Raises: ValueError: If the list contains fewer than two integers. if len(int_list) < 2: raise ValueError(\\"List must contain at least two integers\\") int_list.sort() # Maximum product is either from the two largest numbers or the two most negative numbers. return max(int_list[0] * int_list[1], int_list[-1] * int_list[-2])"},{"question":"def smallest_string_after_reversals(s: str) -> str: Return the lexicographically smallest string that can be obtained by performing any number of substring reversals on the input string. >>> smallest_string_after_reversals(\\"dcba\\") \\"abcd\\" >>> smallest_string_after_reversals(\\"bca\\") \\"abc\\" >>> smallest_string_after_reversals(\\"cba\\") \\"abc\\" >>> smallest_string_after_reversals(\\"zxy\\") \\"xyz\\"","solution":"def smallest_string_after_reversals(s): Returns the lexicographically smallest string that can be obtained by performing any number of substring reversals on the input string. return ''.join(sorted(s))"},{"question":"from typing import List def longest_consecutive_sequence(nums: List[int]) -> List[int]: Finds the longest sequence of consecutive integers in the list. If there are multiple sequences of the same length, it returns the one that starts with the smallest number. >>> longest_consecutive_sequence([3, 9, 1, 10, 4, 20, 2, 8, 11, 12]) [1, 2, 3, 4] >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) [1, 2, 3, 4] >>> longest_consecutive_sequence([-1, 0, 1, 2, -2, -3]) [-3, -2, -1, 0, 1, 2]","solution":"def longest_consecutive_sequence(nums): Finds the longest sequence of consecutive integers in the list. If there are multiple sequences of the same length, it returns the one that starts with the smallest number. if not nums: return [] nums = sorted(set(nums)) # Remove duplicates and sort the list longest_seq = [] current_seq = [] for num in nums: if not current_seq or num == current_seq[-1] + 1: current_seq.append(num) else: if len(current_seq) > len(longest_seq): longest_seq = current_seq current_seq = [num] if len(current_seq) > len(longest_seq): longest_seq = current_seq return longest_seq"},{"question":"def remove_char_and_count(input_str: str, char_to_remove: str) -> (str, int): Implement a function in Python that takes a string composed of uppercase English letters and removes all instances of a specified character. Your function should also return the number of characters removed. >>> remove_char_and_count(\\"HELLO\\", \\"L\\") == (\\"HEO\\", 2) >>> remove_char_and_count(\\"TESTCASE\\", \\"E\\") == (\\"TSTCAS\\", 2) >>> remove_char_and_count(\\"NOCHANGE\\", \\"Z\\") == (\\"NOCHANGE\\", 0) from solution import remove_char_and_count def test_remove_char_and_count(): assert remove_char_and_count(\\"HELLO\\", \\"L\\") == (\\"HEO\\", 2) assert remove_char_and_count(\\"TESTCASE\\", \\"E\\") == (\\"TSTCAS\\", 2) assert remove_char_and_count(\\"NOCHANGE\\", \\"Z\\") == (\\"NOCHANGE\\", 0) assert remove_char_and_count(\\"A\\", \\"A\\") == (\\"\\", 1) assert remove_char_and_count(\\"AAA\\", \\"A\\") == (\\"\\", 3) assert remove_char_and_count(\\"HELLO\\", \\"H\\") == (\\"ELLO\\", 1) assert remove_char_and_count(\\"HELLOHELLO\\", \\"H\\") == (\\"ELLOELLO\\", 2) assert remove_char_and_count(\\"SOMETIMES\\", \\"S\\") == (\\"OMETIME\\", 2) assert remove_char_and_count(\\"ABRACADABRA\\", \\"A\\") == (\\"BRCDBR\\", 5) assert remove_char_and_count(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\", \\"M\\") == (\\"ABCDEFGHIJKLNOPQRSTUVWXYZ\\", 1)","solution":"def remove_char_and_count(input_str: str, char_to_remove: str) -> (str, int): Removes all instances of 'char_to_remove' from 'input_str' and returns the modified string along with the count of characters removed. count_removed = input_str.count(char_to_remove) modified_str = input_str.replace(char_to_remove, \\"\\") return modified_str, count_removed"},{"question":"from typing import List def find_modes(lst: List[int]) -> List[int]: Finds the mode(s) in a list of integers. >>> find_modes([15, 21, 15, 18, 21, 24, 21, 24, 18, 30]) [21] >>> find_modes([1, 2, 3, 1, 2, 3, 4]) [1, 2, 3] >>> find_modes([]) [] >>> find_modes([10, 20, 30, 40, 50]) [10, 20, 30, 40, 50] >>> find_modes([42]) [42] >>> find_modes([7, 7, 7, 7]) [7]","solution":"from collections import Counter def find_modes(lst): Finds the mode(s) in a list of integers. if not lst: # Empty list edge case return [] counter = Counter(lst) max_frequency = max(counter.values()) modes = [key for key, value in counter.items() if value == max_frequency] return modes # Example usage for the provided list of integers example_list = [15, 21, 15, 18, 21, 24, 21, 24, 18, 30] modes_example = find_modes(example_list)"},{"question":"def reverse_words(sentence: str) -> str: Takes a string as input and returns the string with the order of words reversed. Handles multiple spaces between words and leading/trailing spaces. >>> reverse_words(\\"the sky is blue\\") \\"blue is sky the\\" >>> reverse_words(\\" the sky is blue \\") \\"blue is sky the\\" >>> reverse_words(\\"hello\\") \\"hello\\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\" hello world \\") \\"world hello\\"","solution":"def reverse_words(sentence: str) -> str: Takes a string as input and returns the string with the order of words reversed. Handles multiple spaces between words and leading/trailing spaces. words = sentence.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def mergeSortedLists(arr1, arr2): Merges two sorted arrays into a single sorted array. >>> mergeSortedLists([], []) == [] >>> mergeSortedLists([], [1, 2, 3]) == [1, 2, 3] >>> mergeSortedLists([1, 2, 3], []) == [1, 2, 3] >>> mergeSortedLists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] >>> mergeSortedLists([1, 2, 3], [2, 3, 4]) == [1, 2, 2, 3, 3, 4] >>> mergeSortedLists([1], [2, 3, 4]) == [1, 2, 3, 4] >>> mergeSortedLists([1, 2, 3], [4]) == [1, 2, 3, 4] >>> mergeSortedLists([1000000000], [1000000001]) == [1000000000, 1000000001] >>> mergeSortedLists([1, 3, 5, 7, 9], [2, 4, 6]) == [1, 2, 3, 4, 5, 6, 7, 9] import pytest from solution import mergeSortedLists def test_empty_arrays(): assert mergeSortedLists([], []) == [] def test_single_empty_array(): assert mergeSortedLists([], [1, 2, 3]) == [1, 2, 3] assert mergeSortedLists([1, 2, 3], []) == [1, 2, 3] def test_no_duplicates(): assert mergeSortedLists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] def test_with_duplicates(): assert mergeSortedLists([1, 2, 3], [2, 3, 4]) == [1, 2, 2, 3, 3, 4] def test_different_sizes(): assert mergeSortedLists([1], [2, 3, 4]) == [1, 2, 3, 4] assert mergeSortedLists([1, 2, 3], [4]) == [1, 2, 3, 4] def test_large_numbers(): assert mergeSortedLists([1000000000], [1000000001]) == [1000000000, 1000000001] def test_reversed_sorted_arrays(): assert mergeSortedLists([1, 3, 5, 7, 9], [2, 4, 6]) == [1, 2, 3, 4, 5, 6, 7, 9]","solution":"def mergeSortedLists(arr1, arr2): Merges two sorted arrays into a single sorted array. Args: arr1 (list): First sorted array. arr2 (list): Second sorted array. Returns: list: Merged sorted array. result = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: result.append(arr1[i]) i += 1 else: result.append(arr2[j]) j += 1 while i < len(arr1): result.append(arr1[i]) i += 1 while j < len(arr2): result.append(arr2[j]) j += 1 return result"},{"question":"def longest_word(s: str) -> str: Returns the longest word in the input string. If there are multiple words of the same length, return the one that appears first. >>> longest_word(\\"Write a program that finds the longest word\\") == \\"program\\" >>> longest_word(\\"the quick brown fox jumps over the lazy dog\\") == \\"quick\\" >>> longest_word(\\"antidisestablishmentarianism\\") == \\"antidisestablishmentarianism\\" >>> longest_word(\\"\\") == \\"\\" >>> longest_word(\\"Hello, world! This is a test.\\") == \\"Hello,\\" >>> longest_word(\\"There are 2 apples and 3 bananas\\") == \\"bananas\\"","solution":"def longest_word(s): Returns the longest word in the input string. If there are multiple words of the same length, return the one that appears first. :param s: input string :return: longest word in the input string words = s.split() longest = \\"\\" for word in words: if len(word) > len(longest): longest = word return longest"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers such that they add up to target. Args: nums (list): List of integers. target (int): Target sum. Returns: list: List of two indices. >>> two_sum([2,7,11,15], 9) [0, 1] >>> two_sum([3,2,4], 6) [1, 2] >>> two_sum([-3, 4, 3, 90], 0) [0, 2] >>> two_sum([0, 4, 3, 0], 0) [0, 3] >>> two_sum([100000000, 1000000000, -999999900, 999999900], 0) [2, 3] >>> two_sum([1, 2, 3, 4, 5], 9) [3, 4] from solution import two_sum def test_example_1(): assert two_sum([2,7,11,15], 9) == [0, 1] def test_example_2(): assert two_sum([3,2,4], 6) == [1, 2] def test_negative_numbers(): assert two_sum([-3, 4, 3, 90], 0) == [0, 2] def test_zero_elements(): assert two_sum([0, 4, 3, 0], 0) == [0, 3] def test_large_numbers(): assert two_sum([100000000, 1000000000, -999999900, 999999900], 0) == [2, 3] def test_single_possible_pair(): assert two_sum([1, 2, 3, 4, 5], 9) == [3, 4]","solution":"def two_sum(nums, target): Returns the indices of the two numbers such that they add up to target. Args: nums (list): List of integers. target (int): Target sum. Returns: list: List of two indices. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i"},{"question":"from typing import List def is_prime(n: int) -> bool: Returns True if n is a prime number, False otherwise. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(5) == True >>> is_prime(1) == False >>> is_prime(29) == True >>> is_prime(30) == False # logic to determine if n is a prime number def sum_of_primes(arr: List[int]) -> int: Returns the sum of all elements in the given list that are prime numbers. >>> sum_of_primes([3, 5, 8, 13, 20, 23, 28]) == 44 >>> sum_of_primes([1, 2, 3, 4, 5, 6, 7]) == 17 >>> sum_of_primes([10, 15, 18, 20, 25]) == 0 >>> sum_of_primes([2, 3, 5, 7, 11, 13]) == 41 >>> sum_of_primes([]) == 0 >>> sum_of_primes([17, 19, 23]) == 59 # logic to calculate the sum of prime numbers in the array","solution":"def is_prime(n): Returns True if n is a prime number, False otherwise. if n < 2: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def sum_of_primes(arr): Returns the sum of all elements in the given list that are prime numbers. return sum(x for x in arr if is_prime(x))"},{"question":"def longest_unique_substring(s: str) -> str: Returns the longest substring with unique characters from the input string. If there are multiple longest substrings, the first one encountered is returned. >>> longest_unique_substring(\\"abcdabc\\") 'abcd' >>> longest_unique_substring(\\"abcabcbb\\") 'abc' >>> longest_unique_substring(\\"pwwkew\\") 'wke' >>> longest_unique_substring(\\"abcdef\\") 'abcdef' >>> longest_unique_substring(\\"aaaaaa\\") 'a' >>> longest_unique_substring(\\"aAbBcCdD\\") 'aAbBcCdD' >>> longest_unique_substring(\\"\\") '' >>> longest_unique_substring(\\"dvdf\\") 'vdf'","solution":"def longest_unique_substring(s): Returns the longest substring with unique characters from the input string. If there are multiple longest substrings, the first one encountered is returned. char_index_map = {} start = 0 max_length = 0 max_substring_start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i current_length = i - start + 1 if current_length > max_length: max_length = current_length max_substring_start = start return s[max_substring_start:max_substring_start + max_length]"},{"question":"def print_staircase(n): Prints a right-aligned staircase pattern of \`n\` steps using the \`#\` character. Each step should have increasing number of \`#\` characters starting from 1 to n. Example: >>> print_staircase(6) # # # >>> print_staircase(2) #","solution":"def print_staircase(n): Prints a right-aligned staircase pattern of \`n\` steps using the \`#\` character. Each step should have increasing number of \`#\` characters starting from 1 to n. if not isinstance(n, int) or n <= 0: raise ValueError(\\"Input must be a positive integer greater than zero.\\") for i in range(1, n + 1): print(' ' * (n - i) + '#' * i)"},{"question":"from typing import List from collections import Counter def is_anagram(str1: str, str2: str) -> bool: Write a function \`is_anagram\` that takes two strings as input and returns \`True\` if one string is an anagram of the other, and \`False\` otherwise. An anagram is a word formed by rearranging the letters of another, typically using all the original letters exactly once. Note that the function should be case-insensitive and ignore spaces. >>> is_anagram(\\"listen\\", \\"silent\\") True >>> is_anagram(\\"triangle\\", \\"integral\\") True >>> is_anagram(\\"apple\\", \\"pale\\") False >>> is_anagram(\\"A gentleman\\", \\"Elegant man\\") True","solution":"def is_anagram(str1, str2): Returns True if str1 is an anagram of str2, False otherwise. from collections import Counter # Preprocess the strings: remove spaces and convert to lowercase str1 = str1.replace(\\" \\", \\"\\").lower() str2 = str2.replace(\\" \\", \\"\\").lower() # Use Counter to count character frequencies and compare return Counter(str1) == Counter(str2)"},{"question":"class Student: def __init__(self, name, age, grades=None): Initialize a new student with the given name, age, and optional grades list. def add_grade(self, grade): Adds a new grade to the student's grade list. def average_grade(self): Calculates and returns the average grade. def max_grade(self): Finds and returns the maximum grade. def min_grade(self): Finds and returns the minimum grade. def __str__(self): Returns a formatted string representing the student's information. def compare_students(student1, student2): Compares two student objects based on their average grade. Returns: -1 if student1 has a lower average, 0 if equals, and 1 if higher. def merge_students(student1, student2): Returns a new student object that merges the grades of two students, keeping the name and age from the first student. # Example Unit Tests if __name__ == \\"__main__\\": def test_add_grade(): student = Student(name=\\"John\\", age=20) student.add_grade(85) assert student.grades == [85] def test_average_grade(): student = Student(name=\\"John\\", age=20, grades=[80, 90, 85]) assert student.average_grade() == 85 student_empty = Student(name=\\"Jane\\", age=21) assert student_empty.average_grade() == 0 def test_max_grade(): student = Student(name=\\"John\\", age=20, grades=[80, 90, 85]) assert student.max_grade() == 90 student_empty = Student(name=\\"Jane\\", age=21) assert student_empty.max_grade() is None def test_min_grade(): student = Student(name=\\"John\\", age=20, grades=[80, 90, 85]) assert student.min_grade() == 80 student_empty = Student(name=\\"Jane\\", age=21) assert student_empty.min_grade() is None def test_str_representation(): student = Student(name=\\"John\\", age=20, grades=[80, 90, 85]) assert str(student) == \\"Student(name=John, age=20, grades=[80, 90, 85])\\" def test_compare_students(): student1 = Student(name=\\"John\\", age=20, grades=[80, 90, 85]) student2 = Student(name=\\"Jane\\", age=21, grades=[70, 85, 90]) assert compare_students(student1, student2) == 1 student3 = Student(name=\\"Alice\\", age=22, grades=[70, 85, 90]) assert compare_students(student2, student3) == 0 student4 = Student(name=\\"Bob\\", age=23, grades=[60, 70, 80]) assert compare_students(student4, student2) == -1 def test_merge_students(): student1 = Student(name=\\"John\\", age=20, grades=[80, 90, 85]) student2 = Student(name=\\"Jane\\", age=21, grades=[70, 85, 90]) merged_student = merge_students(student1, student2) assert merged_student.name == \\"John\\" assert merged_student.age == 20 assert merged_student.grades == [80, 90, 85, 70, 85, 90] test_add_grade() test_average_grade() test_max_grade() test_min_grade() test_str_representation() test_compare_students() test_merge_students()","solution":"class Student: def __init__(self, name, age, grades=None): self.name = name self.age = age self.grades = grades if grades is not None else [] def add_grade(self, grade): Adds a new grade to the student's grade list. self.grades.append(grade) def average_grade(self): Calculates and returns the average grade. if not self.grades: return 0 return sum(self.grades) / len(self.grades) def max_grade(self): Finds and returns the maximum grade. if not self.grades: return None return max(self.grades) def min_grade(self): Finds and returns the minimum grade. if not self.grades: return None return min(self.grades) def __str__(self): Returns a formatted string representing the student's information. return f\\"Student(name={self.name}, age={self.age}, grades={self.grades})\\" def compare_students(student1, student2): Compares two student objects based on their average grade. Returns: -1 if student1 has a lower average, 0 if equals, and 1 if higher. avg1 = student1.average_grade() avg2 = student2.average_grade() if avg1 < avg2: return -1 elif avg1 == avg2: return 0 else: return 1 def merge_students(student1, student2): Returns a new student object that merges the grades of two students, keeping the name and age from the first student. merged_grades = student1.grades + student2.grades return Student(name=student1.name, age=student1.age, grades=merged_grades)"},{"question":"def reverse_strings(strings: List[str]) -> List[str]: Takes a list of strings and returns a new list where each string is reversed, but the relative order of the strings is preserved. >>> reverse_strings([\\"hello\\"]) [\\"olleh\\"] >>> reverse_strings([\\"hello\\", \\"world\\"]) [\\"olleh\\", \\"dlrow\\"] >>> reverse_strings([\\"\\"]) [\\"\\"] >>> reverse_strings([\\"abc\\", \\"def\\", \\"ghi\\"]) [\\"cba\\", \\"fed\\", \\"ihg\\"] >>> reverse_strings([\\"123\\", \\"abc\\", \\"!@#\\"]) [\\"321\\", \\"cba\\", \\"#@!\\"]","solution":"def reverse_strings(strings): Takes a list of strings and returns a new list where each string is reversed, but the relative order of the strings is preserved. :param strings: List of strings :return: List of reversed strings return [s[::-1] for s in strings]"},{"question":"def reverse_bracketed_words(input_string: str) -> str: Replaces each word within the square brackets with the reversed version of that word, maintaining the rest of the string as is. >>> reverse_bracketed_words(\\"This is a [simple] test.\\") \\"This is a [elpmis] test.\\" >>> reverse_bracketed_words(\\"Nested [example [brackets]] are [fun].\\") \\"Nested [example [stekcarb]] are [nuf].\\" >>> reverse_bracketed_words(\\"Hello [world] and [Python] lovers.\\") \\"Hello [dlrow] and [nohtyP] lovers.\\" >>> reverse_bracketed_words(\\"This has no brackets.\\") \\"This has no brackets.\\" >>> reverse_bracketed_words(\\"This has [[]] empty brackets.\\") \\"This has [[]] empty brackets.\\" >>> reverse_bracketed_words(\\"[a][b][c]\\") \\"[a][b][c]\\" >>> reverse_bracketed_words(\\"This is [test1][test2].\\") \\"This is [1tset][2tset].\\"","solution":"def reverse_bracketed_words(input_string: str) -> str: def reverse_word_in_brackets(s): stack, res, word = [], \\"\\", \\"\\" for char in s: if char == '[': if word: stack.append(word) stack.append('[') word = \\"\\" elif char == ']': if word: stack.append(word[::-1]) word = \\"\\" temp = [] while stack and stack[-1] != '[': temp.append(stack.pop()) stack.pop() # pop '[' stack.append('[' + ''.join(temp[::-1]) + ']') else: word += char return ''.join(stack) + word return reverse_word_in_brackets(input_string)"},{"question":"def count_distinct_substrings(s: str) -> int: Returns the number of distinct substrings that can be formed using the characters of s. >>> count_distinct_substrings(\\"abc\\") == 6 >>> count_distinct_substrings(\\"aaa\\") == 3","solution":"def count_distinct_substrings(s: str) -> int: Returns the number of distinct substrings that can be formed using the characters of s. n = len(s) substrings = set() for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"class Account: A class to represent a bank account. Args: account_number (str): The unique account number. initial_balance (int): The initial balance. Methods: deposit(amount): Deposits the specified amount into the account. withdraw(amount): Withdraws the specified amount from the account. check_balance(): Returns the current balance of the account. def __init__(self, account_number, initial_balance=0): pass def deposit(self, amount): pass def withdraw(self, amount): pass def check_balance(self): pass class Bank: A class to represent a bank. Methods: create_account(account_number, initial_balance): Creates a new account with the specified account number. get_account(account_number): Returns the account object associated with the specified account number. def __init__(self): pass def create_account(self, account_number, initial_balance=0): pass def get_account(self, account_number): pass","solution":"class Account: def __init__(self, account_number, initial_balance=0): self.account_number = account_number self.balance = initial_balance def deposit(self, amount): if amount <= 0: raise ValueError(\\"Deposit amount must be positive\\") self.balance += amount def withdraw(self, amount): if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive\\") if amount > self.balance: raise ValueError(\\"Insufficient funds\\") self.balance -= amount def check_balance(self): return self.balance class Bank: def __init__(self): self.accounts = {} def create_account(self, account_number, initial_balance=0): if account_number in self.accounts: raise ValueError(\\"Account number already exists\\") self.accounts[account_number] = Account(account_number, initial_balance) def get_account(self, account_number): if account_number not in self.accounts: raise ValueError(\\"Invalid account number\\") return self.accounts[account_number]"},{"question":"from typing import List def product_except_self(arr: List[int], k: int) -> List[int]: Write a Python function that takes a list of integers and an integer k, and returns a new list where each element is the product of every other element in the original list except the one at that position. Avoid using the division operator and ensure the algorithm runs in O(n) time complexity. >>> product_except_self([1, 2, 3, 4], 2) [24, 12, 8, 6] >>> product_except_self([7], 3) [1] >>> product_except_self([1, 1, 1, 1], 0) [1, 1, 1, 1] >>> product_except_self([5, 10], 1) [10, 5] >>> product_except_self([-1, 2, -3, 4], 0) [-24, 12, -8, 6] >>> product_except_self([10000, -10000, 10000, -10000], 4) [1000000000000, -1000000000000, 1000000000000, -1000000000000]","solution":"from typing import List def product_except_self(arr: List[int], k: int) -> List[int]: n = len(arr) # Initialize the output array with 1's for multiplication output = [1] * n # Generate prefix products prefix_product = 1 for i in range(n): output[i] = prefix_product prefix_product *= arr[i] # Generate postfix products and update the output array postfix_product = 1 for i in range(n-1, -1, -1): output[i] *= postfix_product postfix_product *= arr[i] return output"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression string with +, -, *, / operators and integers, following the standard order of operations (PEMDAS/BODMAS). >>> evaluate_expression(\\"2 + 3\\") 5.0 >>> evaluate_expression(\\"5 - 3\\") 2.0 >>> evaluate_expression(\\"(2 + 3) * 4\\") 20.0 >>> evaluate_expression(\\"10 / (2 * (2 + 3))\\") 1.0 pass","solution":"def evaluate_expression(expression): Evaluates a mathematical expression string with +, -, *, / operators and integers, following the standard order of operations (PEMDAS/BODMAS). import re import operator # Define the supported operators and their precedence ops = { '+': (1, operator.add), '-': (1, operator.sub), '*': (2, operator.mul), '/': (2, operator.truediv) } def parse(expression): Parses the input string into numbers and operators based on precedence tokens = re.findall(r'd+|[+/*()-]', expression.replace(' ', '')) output = [] stack = [] for token in tokens: if token.isdigit(): output.append(int(token)) elif token in ops: while stack and stack[-1] in ops and ops[token][0] <= ops[stack[-1]][0]: output.append(stack.pop()) stack.append(token) elif token == '(': stack.append(token) elif token == ')': while stack and stack[-1] != '(': output.append(stack.pop()) stack.pop() while stack: output.append(stack.pop()) return output def compute(rpn): Computes the result from the reverse Polish notation list stack = [] for token in rpn: if type(token) == int: stack.append(token) else: b = stack.pop() a = stack.pop() stack.append(ops[token][1](a, b)) return stack[0] # Validate and clean the input expression if not re.match(r'^[ds+/*()-]+', expression): raise ValueError(\\"Invalid characters in the expression.\\") # Convert infix expression to Reverse Polish Notation (RPN) rpn = parse(expression) # Compute the result from the RPN result = compute(rpn) return result"},{"question":"from typing import List, Union, Dict def flatten_and_count_nested_list(nested_list: List[Union[int, List]]) -> Dict[int, int]: Given a nested list of integers, return a dictionary where keys are the integers and values are the counts of their occurrences in the list, regardless of their levels in the nested structure. >>> flatten_and_count_nested_list([1, 2, 2, 3, 3, 3]) == {1: 1, 2: 2, 3: 3} >>> flatten_and_count_nested_list([1, [2, 2], [3, [3, [3]]]]) == {1: 1, 2: 2, 3: 3} >>> flatten_and_count_nested_list([]) == {} >>> flatten_and_count_nested_list([[]]) == {} >>> flatten_and_count_nested_list([1, 'a', [2], ['b', [3]]]) == {1: 1, 2: 1, 3: 1}","solution":"def flatten_and_count_nested_list(nested_list): Given a nested list of integers, return a dictionary where keys are the integers and values are the counts of their occurrences in the list, regardless of their levels in the nested structure. from collections import defaultdict def flatten(lst): for item in lst: if isinstance(item, list): yield from flatten(item) else: yield item count_dict = defaultdict(int) for number in flatten(nested_list): if isinstance(number, int): count_dict[number] += 1 return dict(count_dict)"},{"question":"class Library: def __init__(self): self.books = {} def add_book(self, title, author, year, copies=1): Adds a new book to the library or increases the number of copies if the book already exists. pass def borrow_book(self, title): Borrows a book from the library, if available. Raises an error if the book is not available. pass def return_book(self, title): Returns a book to the library. Raises an error if the book to return does not exist in the library. pass def list_books(self): Lists all available books in the library. pass import pytest def test_add_book(): lib = Library() lib.add_book(\\"Book A\\", \\"Author A\\", 2000, 2) assert lib.books[\\"Book A\\"]['author'] == \\"Author A\\" assert lib.books[\\"Book A\\"]['year'] == 2000 assert lib.books[\\"Book A\\"]['copies'] == 2 def test_borrow_book_success(): lib = Library() lib.add_book(\\"Book B\\", \\"Author B\\", 2001, 1) lib.borrow_book(\\"Book B\\") assert lib.books[\\"Book B\\"]['copies'] == 0 def test_borrow_book_fail(): lib = Library() lib.add_book(\\"Book C\\", \\"Author C\\", 2002, 0) with pytest.raises(ValueError, match=\\"Book not available or out of stock.\\"): lib.borrow_book(\\"Book C\\") def test_return_book_success(): lib = Library() lib.add_book(\\"Book D\\", \\"Author D\\", 2003, 1) lib.borrow_book(\\"Book D\\") lib.return_book(\\"Book D\\") assert lib.books[\\"Book D\\"]['copies'] == 1 def test_return_book_fail(): lib = Library() with pytest.raises(ValueError, match=\\"Book does not exist in the library.\\"): lib.return_book(\\"Book E\\") def test_list_books(): lib = Library() lib.add_book(\\"Book F\\", \\"Author F\\", 2004, 2) lib.add_book(\\"Book G\\", \\"Author G\\", 2005, 0) available_books = lib.list_books() assert \\"Book F\\" in available_books assert \\"Book G\\" not in available_books def test_add_existing_book(): lib = Library() lib.add_book(\\"Book H\\", \\"Author H\\", 2006, 1) lib.add_book(\\"Book H\\", \\"Author H\\", 2006, 2) assert lib.books[\\"Book H\\"]['copies'] == 3","solution":"class Library: def __init__(self): self.books = {} def add_book(self, title, author, year, copies=1): Adds a new book to the library or increases the number of copies if the book already exists. if title in self.books: self.books[title]['copies'] += copies else: self.books[title] = {'author': author, 'year': year, 'copies': copies} def borrow_book(self, title): Borrows a book from the library, if available. Raises an error if the book is not available. if title in self.books and self.books[title]['copies'] > 0: self.books[title]['copies'] -= 1 else: raise ValueError(\\"Book not available or out of stock.\\") def return_book(self, title): Returns a book to the library. Raises an error if the book to return does not exist in the library. if title in self.books: self.books[title]['copies'] += 1 else: raise ValueError(\\"Book does not exist in the library.\\") def list_books(self): Lists all available books in the library. return {title: book for title, book in self.books.items() if book['copies'] > 0}"},{"question":"class Stack: Implement a basic stack data structure using Python's list methods. Methods: def push(self, value): # Add an element to the top of the stack def pop(self): # Remove and return the top element from the stack def peek(self): # Return the top element without removing it def is_empty(self): # Check if the stack is empty def __init__(self): self.stack = [] def push(self, value): self.stack.append(value) def pop(self): if len(self.stack) == 0: return None return self.stack.pop() def peek(self): if len(self.stack) == 0: return None return self.stack[-1] def is_empty(self): return len(self.stack) == 0 def test_stack(): # Tests for push method stack = Stack() stack.push(1) assert stack.stack == [1] stack.push(2) assert stack.stack == [1, 2] # Tests for pop method stack = Stack() stack.push(1) stack.push(2) assert stack.pop() == 2 assert stack.pop() == 1 assert stack.pop() == None # Tests for peek method stack = Stack() assert stack.peek() == None stack.push(1) assert stack.peek() == 1 stack.push(2) assert stack.peek() == 2 stack.pop() assert stack.peek() == 1 # Tests for is_empty method stack = Stack() assert stack.is_empty() == True stack.push(1) assert stack.is_empty() == False stack.pop() assert stack.is_empty() == True","solution":"class Stack: def __init__(self): self.stack = [] def push(self, value): self.stack.append(value) def pop(self): if len(self.stack) == 0: return None return self.stack.pop() def peek(self): if len(self.stack) == 0: return None return self.stack[-1] def is_empty(self): return len(self.stack) == 0"},{"question":"def reverse_even_numbers(arr: List[int]) -> List[int]: Returns a new array containing only the even numbers from the original array, but in reverse order. The input array is not mutated. >>> reverse_even_numbers([1, 2, 3, 4, 5, 6]) [6, 4, 2] >>> reverse_even_numbers([1, 3, 5, 7]) [] >>> reverse_even_numbers([2, 4, 6, 8]) [8, 6, 4, 2] >>> reverse_even_numbers([]) [] >>> reverse_even_numbers([2]) [2]","solution":"def reverse_even_numbers(arr): Returns a new array containing only the even numbers from the original array, but in reverse order. The input array is not mutated. :param arr: List of integers :return: List of even integers in reverse order # Filter out even numbers and reverse the order even_numbers = [num for num in arr if num % 2 == 0] return even_numbers[::-1]"},{"question":"def categorize_and_sort_entities(entity_collection): Groups entities by their main category and sorts each group by their detailed attributes (first by habitat/type, then by diet/fuel) in ascending order. Additionally, validates the presence of all required attributes and handles any inconsistencies, producing a detailed error message identifying the specific entity and the nature of the inconsistency if an anomaly is detected. :param entity_collection: List of entities with their details :return: Dict of categorized and sorted entities Examples: >>> entities = [ { 'name': \\"Alice\\", 'category': \\"animal\\", 'details': { 'habitat': \\"forest\\", 'diet': \\"herbivore\\" } }, { 'name': \\"Bob\\", 'category': \\"vehicle\\", 'details': { 'fuel': \\"electric\\", 'type': \\"sedan\\" } }, { 'name': \\"Charlie\\", 'category': \\"animal\\", 'details': { 'habitat': \\"desert\\", 'diet': \\"carnivore\\" } } ] >>> categorize_and_sort_entities(entities) { 'animal': [ { 'name': \\"Charlie\\", 'category': \\"animal\\", 'details': { 'habitat': \\"desert\\", 'diet': \\"carnivore\\" } }, { 'name': \\"Alice\\", 'category': \\"animal\\", 'details': { 'habitat': \\"forest\\", 'diet': \\"herbivore\\" } } ], 'vehicle': [ { 'name': \\"Bob\\", 'category': \\"vehicle\\", 'details': { 'fuel': \\"electric\\", 'type': \\"sedan\\" } } ] }","solution":"def categorize_and_sort_entities(entity_collection): Groups entities by their main category and sorts each group by their detailed attributes (first by habitat/type, then by diet/fuel) in ascending order. :param entity_collection: List of entities with their details :return: Dict of categorized and sorted entities from collections import defaultdict categorized_entities = defaultdict(list) required_details = { 'animal': ['habitat', 'diet'], 'vehicle': ['fuel', 'type'] } # Validate and categorize entities for entity in entity_collection: category = entity.get('category', None) details = entity.get('details', None) if category not in required_details: raise ValueError(f\\"Unknown category {category} for entity {entity['name']}\\") if not details: raise ValueError(f\\"Missing details for entity {entity['name']}\\") for attribute in required_details[category]: if attribute not in details: raise ValueError(f\\"Missing attribute '{attribute}' in details of entity {entity['name']}\\") categorized_entities[category].append(entity) # Sorting entities in each category sorted_entities = {} for category, ents in categorized_entities.items(): attr1, attr2 = required_details[category] sorted_entities[category] = sorted(ents, key=lambda x: (x['details'][attr1], x['details'][attr2])) return sorted_entities"},{"question":"def maximum_product_of_three(nums: List[int]) -> int: Returns the maximum product of any three distinct numbers in the array nums. >>> maximum_product_of_three([1, 2, 3]) == 6 >>> maximum_product_of_three([1, 2, 3, 4]) == 24 >>> maximum_product_of_three([-1, -2, -3, -4]) == -6 >>> maximum_product_of_three([-1, -2, 1, 2, 3]) == 6","solution":"def maximum_product_of_three(nums): Returns the maximum product of any three distinct numbers in the array nums. nums.sort() # The maximum product can be either by: # - Multiplying the three largest positive numbers # - Multiplying the two smallest (most negative) numbers and the largest positive number return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def max_contiguous_subarray_sum(nums): Returns the largest sum of a contiguous subarray within the given list of integers. The function implements Kadane's Algorithm and runs in O(n) time complexity. >>> max_contiguous_subarray_sum([1, 2, 3, 4]) == 10 >>> max_contiguous_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_contiguous_subarray_sum([-1, -2, -3, -4]) == -1 >>> max_contiguous_subarray_sum([]) == 0 >>> max_contiguous_subarray_sum([5]) == 5 >>> max_contiguous_subarray_sum([-5]) == -5","solution":"def max_contiguous_subarray_sum(nums): Returns the largest sum of a contiguous subarray within the given list of integers. The function implements Kadane's Algorithm and runs in O(n) time complexity. :param nums: A list of integers :return: The largest sum of a contiguous subarray if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def maxSubArraySum(arr: List[int], k: int) -> int: Computes the maximum sum of a subarray with at least length k. If no valid subarray exists, returns 0. >>> maxSubArraySum([1, 2, 3, -2, 5, -1, 6, 10], 3) 24 >>> maxSubArraySum([1, 2, 3], 4) 0","solution":"def maxSubArraySum(arr, k): Computes the maximum sum of a subarray with at least length k. If no valid subarray exists, returns 0. n = len(arr) if n < k: return 0 # Step 1: Compute the sum of the first \`k\` elements current_sum = sum(arr[:k]) max_sum = current_sum # Step 2: Create prefix sums prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + arr[i] # Step 3: Use a sliding window to compute sums of subarrays with at least \`k\` length for i in range(k, n): current_sum += arr[i] max_sum = max(max_sum, current_sum) for j in range(i - k + 1): max_sum = max(max_sum, current_sum - (prefix_sum[j + 1])) return max_sum"},{"question":"def find_missing_number(lst) -> int: Finds the missing number in a list of integers from 1 to n with one missing number. Args: lst: List of integers in the range 1 to n with one integer missing. Returns: The missing integer. >>> find_missing_number([2, 3, 1, 5]) 4 >>> find_missing_number([1, 2, 4, 5, 6]) 3 pass # Unit Tests def test_find_missing_number_case_1(): assert find_missing_number([2, 3, 1, 5]) == 4 def test_find_missing_number_case_2(): assert find_missing_number([1, 2, 4, 5, 6]) == 3 def test_find_missing_number_single_element(): assert find_missing_number([2]) == 1 def test_find_missing_number_missing_last(): assert find_missing_number([1, 2, 3, 4]) == 5 def test_find_missing_number_missing_first(): assert find_missing_number([2, 3, 4, 5]) == 1","solution":"def find_missing_number(lst): Finds the missing number in a list of integers from 1 to n with one missing number. :param lst: List of integers in the range 1 to n with one integer missing. :return: The missing integer. n = len(lst) + 1 expected_sum = n * (n + 1) / 2 actual_sum = sum(lst) return int(expected_sum - actual_sum)"},{"question":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeRegressor from sklearn.metrics import mean_squared_error def train_decision_tree_regression(data: pd.DataFrame) -> float: Trains a Decision Tree Regression model to predict daily temperature based on humidity, wind speed, and precipitation. Args: data (pd.DataFrame): DataFrame containing the dataset with columns 'temperature', 'humidity', 'wind_speed', and 'precipitation'. Returns: float: Mean Squared Error of the model on the test dataset. # Your code here","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeRegressor from sklearn.metrics import mean_squared_error def train_decision_tree_regression(data): Trains a Decision Tree Regression model to predict daily temperature based on humidity, wind speed, and precipitation. Args: data (pd.DataFrame): DataFrame containing the dataset with columns 'temperature', 'humidity', 'wind_speed', and 'precipitation'. Returns: float: Mean Squared Error of the model on the test dataset. # Split the dataset into features (X) and target (y) X = data[['humidity', 'wind_speed', 'precipitation']] y = data['temperature'] # Split the data into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Initialize the Decision Tree Regressor regressor = DecisionTreeRegressor(random_state=42) # Train the model regressor.fit(X_train, y_train) # Predict the temperature on the test set y_pred = regressor.predict(X_test) # Calculate the Mean Squared Error mse = mean_squared_error(y_test, y_pred) return mse"},{"question":"import csv def calculate_average_from_csv(file_path: str, column_name: str) -> float: Reads data from a CSV file, processes it to find the average value of a specified column. Args: file_path (str): The path to the CSV file. column_name (str): The name of the column to find the average of. Returns: float: The average value of the specified column. Raises: FileNotFoundError: If the specified file does not exist. KeyError: If the specified column does not exist in the CSV. ValueError: If the data in the specified column is non-numeric.","solution":"import csv def calculate_average_from_csv(file_path, column_name): Reads data from a CSV file, processes it to find the average value of a specified column. Args: file_path (str): The path to the CSV file. column_name (str): The name of the column to find the average of. Returns: float: The average value of the specified column. Raises: FileNotFoundError: If the specified file does not exist. KeyError: If the specified column does not exist in the CSV. ValueError: If the data in the specified column is non-numeric. try: with open(file_path, mode='r') as csvfile: reader = csv.DictReader(csvfile) values = [] for row in reader: try: value = float(row[column_name]) values.append(value) except ValueError: raise ValueError(f\\"Non-numeric data found in column: {column_name}\\") if not values: return 0.0 average = sum(values) / len(values) return average except FileNotFoundError: raise FileNotFoundError(f\\"The file at path {file_path} does not exist.\\") except KeyError: raise KeyError(f\\"The column {column_name} does not exist in the CSV file.\\") # Example usage: # avg = calculate_average_from_csv('sample.csv', 'age') # print(avg)"},{"question":"def get_highest_value_dicts(input_list, key): Returns a list of dictionaries with the highest value for the given key. :param input_list: List of dictionaries :param key: Key to look for the highest value :return: List of dictionaries with the highest value for the given key >>> input_list = [{\\"name\\": \\"Alice\\", \\"score\\": 85}, {\\"name\\": \\"Bob\\", \\"score\\": 92}, {\\"name\\": \\"Charlie\\", \\"score\\": 92}, {\\"name\\": \\"David\\", \\"score\\": 78}] >>> get_highest_value_dicts(input_list, \\"score\\") [{'name': 'Bob', 'score': 92}, {'name': 'Charlie', 'score': 92}] from solution import get_highest_value_dicts def test_single_highest_value(): input_list = [ {\\"name\\": \\"Alice\\", \\"score\\": 85}, {\\"name\\": \\"Bob\\", \\"score\\": 92}, {\\"name\\": \\"Charlie\\", \\"score\\": 78}, {\\"name\\": \\"David\\", \\"score\\": 90} ] assert get_highest_value_dicts(input_list, \\"score\\") == [{\\"name\\": \\"Bob\\", \\"score\\": 92}] def test_multiple_highest_values(): input_list = [ {\\"name\\": \\"Alice\\", \\"score\\": 85}, {\\"name\\": \\"Bob\\", \\"score\\": 92}, {\\"name\\": \\"Charlie\\", \\"score\\": 92}, {\\"name\\": \\"David\\", \\"score\\": 78} ] assert get_highest_value_dicts(input_list, \\"score\\") == [{\\"name\\": \\"Bob\\", \\"score\\": 92}, {\\"name\\": \\"Charlie\\", \\"score\\": 92}] def test_key_not_present(): input_list = [ {\\"name\\": \\"Alice\\", \\"score\\": 85}, {\\"name\\": \\"Bob\\", \\"score\\": 92} ] assert get_highest_value_dicts(input_list, \\"age\\") == [] def test_empty_list(): input_list = [] assert get_highest_value_dicts(input_list, \\"score\\") == [] def test_identical_values(): input_list = [ {\\"name\\": \\"Alice\\", \\"score\\": 92}, {\\"name\\": \\"Bob\\", \\"score\\": 92}, {\\"name\\": \\"Charlie\\", \\"score\\": 92} ] assert get_highest_value_dicts(input_list, \\"score\\") == input_list def test_non_numeric_values(): input_list = [ {\\"name\\": \\"Alice\\", \\"rating\\": \\"A\\"}, {\\"name\\": \\"Bob\\", \\"rating\\": \\"B\\"}, {\\"name\\": \\"Charlie\\", \\"rating\\": \\"B\\"}, {\\"name\\": \\"David\\", \\"rating\\": \\"C\\"} ] assert get_highest_value_dicts(input_list, \\"rating\\") == [{\\"name\\": \\"David\\", \\"rating\\": \\"C\\"}]","solution":"def get_highest_value_dicts(input_list, key): Returns a list of dictionaries with the highest value for the given key. :param input_list: List of dictionaries :param key: Key to look for the highest value :return: List of dictionaries with the highest value for the given key if not input_list or key not in input_list[0]: return [] # Find the highest value for the given key highest_value = max(d[key] for d in input_list if key in d) # Filter and return the dictionaries with the highest value return [d for d in input_list if d.get(key) == highest_value]"},{"question":"import re from typing import List, Dict def word_frequency(words: List[str]) -> Dict[str, int]: Write a function that takes a list of strings as input and returns a dictionary where the keys are the words present in the list, and the values are the number of times each word appears in the list, in a case-insensitive manner. Punctuation should be ignored. >>> word_frequency([\\"Hello, world!\\", \\"HELLO!\\", \\"Python's the best.\\", \\"world of Python.\\"]) {'hello': 2, 'world': 2, 'pythons': 1, 'the': 1, 'best': 1, 'of': 1, 'python': 1} >>> word_frequency([]) {} >>> word_frequency([\\"test\\"]) {'test': 1} >>> word_frequency([\\"!!!\\", \\"test!\\", \\"!test\\", \\"!\\"]) {'test': 2} >>> word_frequency([\\"Case\\", \\"CASE\\", \\"case closed\\"]) {'case': 3, 'closed': 1} >>> word_frequency([\\"Python3's\\", \\"Python3\\", \\"@Python\\", \\"#Python\\"]) {'python3s': 1, 'python3': 1, 'python': 2}","solution":"import re from typing import List, Dict def word_frequency(words: List[str]) -> Dict[str, int]: Returns a dictionary where the keys are the words present in the list, and the values are the number of times each word appears in the list, in a case-insensitive manner. Punctuation is ignored. frequency = {} for sentence in words: # Remove punctuation using regex and convert to lowercase cleaned_sentence = re.sub(r\\"[^ws]\\", \\"\\", sentence.lower()) # Split the sentence into words word_list = cleaned_sentence.split() for word in word_list: if word in frequency: frequency[word] += 1 else: frequency[word] = 1 return frequency"},{"question":"from typing import Dict, Optional def calculate_median_age(ages_dict: Dict[str, int]) -> Optional[float]: Returns the median age from a dictionary mapping names to ages. Parameters: ages_dict (dict): A dictionary where keys are names (str) and values are ages (int). Returns: float: Median age. >>> calculate_median_age({'Alice': 24, 'Bob': 30, 'Charlie': 18}) 24 >>> calculate_median_age({'Alice': 24, 'Bob': 30, 'Charlie': 18, 'David': 22}) 23.0 >>> calculate_median_age({'Alice': 24}) 24 >>> calculate_median_age({'Alice': 24, 'Bob': 30}) 27.0 >>> calculate_median_age({}) is None >>> calculate_median_age({'Alice': 24, 'Bob': 24, 'Charlie': 24}) 24","solution":"def calculate_median_age(ages_dict): Returns the median age from a dictionary mapping names to ages. Parameters: ages_dict (dict): A dictionary where keys are names (str) and values are ages (int). Returns: float: Median age. if not ages_dict: return None ages = sorted(ages_dict.values()) n = len(ages) mid = n // 2 if n % 2 == 0: return (ages[mid - 1] + ages[mid]) / 2.0 else: return ages[mid]"},{"question":"def maxBalancedLength(s: str) -> int: Returns the maximum length of a substring that consists of balanced parentheses. >>> maxBalancedLength(\\"(()))(\\") == 4 >>> maxBalancedLength(\\"((()))\\") == 6 >>> maxBalancedLength(\\"()\\") == 2 >>> maxBalancedLength(\\"\\") == 0 >>> maxBalancedLength(\\")(\\") == 0 >>> maxBalancedLength(\\"()(())))\\") == 6 >>> maxBalancedLength(\\"((())\\") == 4 >>> maxBalancedLength(\\"(())()\\") == 6 >>> maxBalancedLength(\\"((((((\\") == 0 >>> maxBalancedLength(\\")))))\\") == 0 >>> maxBalancedLength(\\"()()()()\\") == 8 >>> maxBalancedLength(\\"()\\") == 2","solution":"def maxBalancedLength(s): Returns the maximum length of a substring that consists of balanced parentheses. max_len = 0 stack = [-1] # Initialize stack with -1 to handle edge case of balanced substring at the start for i in range(len(s)): if s[i] == '(': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_len = max(max_len, i - stack[-1]) return max_len"},{"question":"def is_prime(n: int) -> bool: Determine if a given positive integer n is a prime number without using built-in functions related to prime checking or mathematical libraries. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(5) True >>> is_prime(11) True >>> is_prime(13) True >>> is_prime(1) False","solution":"def is_prime(n): Determine if a given positive integer n is a prime number. :param n: Positive integer to check for primality. :return: True if n is a prime number, False otherwise. if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True"},{"question":"from typing import List, Dict def analyze_list(lst: List[int]) -> Dict[str, float]: Process a list of integers and return a dictionary with the following statistics: - 'sum': the total sum of the elements in the list - 'mean': the average value of the elements in the list - 'median': the median value of the elements in the list - 'mode': the most frequently occurring element in the list Examples: >>> analyze_list([1, 2, 2, 3, 4]) {'sum': 12, 'mean': 2.4, 'median': 2, 'mode': 2} >>> analyze_list([]) {'sum': 0, 'mean': None, 'median': None, 'mode': None} # TODO: Implement this function # Unit Tests def test_analyze_list_normal_case(): result = analyze_list([1, 2, 2, 3, 4]) expected = {'sum': 12, 'mean': 2.4, 'median': 2, 'mode': 2} assert result == expected def test_analyze_list_empty_list(): result = analyze_list([]) expected = {'sum': 0, 'mean': None, 'median': None, 'mode': None} assert result == expected def test_analyze_list_single_element(): result = analyze_list([5]) expected = {'sum': 5, 'mean': 5, 'median': 5, 'mode': 5} assert result == expected def test_analyze_list_no_mode(): result = analyze_list([1, 2, 3, 4, 5]) expected = {'sum': 15, 'mean': 3, 'median': 3, 'mode': 1} # In case of no mode, return the first element assert result == expected def test_analyze_list_multiple_modes(): result = analyze_list([1, 1, 2, 2, 3]) expected = {'sum': 9, 'mean': 1.8, 'median': 2, 'mode': 1} # In case of multiple modes, return the first mode assert result == expected def test_analyze_list_large_numbers(): result = analyze_list([1000000, 2000000, 3000000, 4000000, 5000000]) expected = {'sum': 15000000, 'mean': 3000000, 'median': 3000000, 'mode': 1000000} assert result == expected","solution":"from collections import Counter import statistics def analyze_list(lst): Returns a dictionary with the sum, mean, median, and mode of the list of integers. if not lst: return {'sum': 0, 'mean': None, 'median': None, 'mode': None} data_sum = sum(lst) data_mean = statistics.mean(lst) data_median = statistics.median(lst) data_counter = Counter(lst) max_count = max(data_counter.values()) mode_candidates = [k for k, v in data_counter.items() if v == max_count] data_mode = mode_candidates[0] if max_count > 1 else lst[0] return { 'sum': data_sum, 'mean': data_mean, 'median': data_median, 'mode': data_mode }"},{"question":"def are_permutations(s1: str, s2: str) -> bool: Returns True if one string is a permutation of the other, otherwise False. >>> are_permutations(\\"abc\\", \\"bca\\") == True >>> are_permutations(\\"abc\\", \\"abcd\\") == False >>> are_permutations(\\"abc \\", \\" bca\\") == True >>> are_permutations(\\"hello\\", \\"oellh\\") == True >>> are_permutations(\\"abcd\\", \\"dcba \\") == True >>> are_permutations(\\"hello\\", \\"world\\") == False from solution import are_permutations def test_permutations(): assert are_permutations(\\"abc\\", \\"bca\\") == True assert are_permutations(\\"abc\\", \\"abcd\\") == False assert are_permutations(\\"abc \\", \\" bca\\") == True assert are_permutations(\\"hello\\", \\"oellh\\") == True assert are_permutations(\\"abcd\\", \\"dcba \\") == True assert are_permutations(\\"hello\\", \\"world\\") == False def test_different_lengths(): assert are_permutations(\\"a\\", \\"aa\\") == False assert are_permutations(\\"abc\\", \\"abcd\\") == False def test_empty_strings(): assert are_permutations(\\"\\", \\"\\") == True assert are_permutations(\\" \\", \\"\\") == True assert are_permutations(\\"\\", \\"a\\") == False def test_expression_order(): assert are_permutations(\\"aabbcc\\", \\"bbaacc\\") == True assert are_permutations(\\"aabbcc\\", \\"aabbc\\") == False assert are_permutations(\\"aa bb cc\\", \\"ccbbaa\\") == True def test_case_insensitivity(): assert are_permutations(\\"abc\\", \\"Abc\\") == True assert are_permutations(\\"ABC\\", \\"abc\\") == True assert are_permutations(\\"AaAa\\", \\"aaaa\\") == True","solution":"def are_permutations(s1, s2): Returns True if one string is a permutation of the other, otherwise False. # Remove spaces and consider only lowercase letters s1 = s1.replace(\\" \\", \\"\\").lower() s2 = s2.replace(\\" \\", \\"\\").lower() # Check if sorted versions of the strings are the same return sorted(s1) == sorted(s2)"},{"question":"def k_largest_elements(arr, k): Takes an array of integers and an integer \`k\` as input and returns the \`k\` largest elements from the array in descending order. If \`k\` is greater than the number of elements in the array, returns the entire array sorted in descending order. >>> k_largest_elements([3, 5, 1, 4, 2], 3) [5, 4, 3] >>> k_largest_elements([1, 2], 5) [2, 1]","solution":"def k_largest_elements(arr, k): Returns the k largest elements from the array \`arr\` in descending order. If \`k\` is greater than the number of elements in the array, returns the entire array sorted in descending order. if k >= len(arr): return sorted(arr, reverse=True) return sorted(arr, reverse=True)[:k]"},{"question":"def sum_of_prime_factors(numbers): Write a function that takes a list of integers and returns a list of tuples, where each tuple contains an integer from the input list and the sum of its distinct prime factors. >>> sum_of_prime_factors([12, 15, 18]) [(12, 5), (15, 8), (18, 5)] >>> sum_of_prime_factors([10]) [(10, 7)] >>> sum_of_prime_factors([2, 3, 4, 5, 6]) [(2, 2), (3, 3), (4, 2), (5, 5), (6, 5)] >>> sum_of_prime_factors([30, 45, 60]) [(30, 10), (45, 8), (60, 10)] >>> sum_of_prime_factors([]) [] >>> sum_of_prime_factors([7]) [(7, 7)]","solution":"def sum_of_prime_factors(numbers): def prime_factors(n): i = 2 factors = set() while i * i <= n: if n % i: i += 1 else: n //= i factors.add(i) if n > 1: factors.add(n) return factors result = [] for number in numbers: factors = prime_factors(number) factors_sum = sum(factors) result.append((number, factors_sum)) return result"},{"question":"def longest_consecutive_sequence(nums): Returns the length of the longest sequence of consecutive integers in an unsorted list of integers. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2, 2, -1, 0]) 6 >>> longest_consecutive_sequence([1, 9, 3, 10, 4, 20, 2]) 4 >>> longest_consecutive_sequence([0, -1, -2, -3, -4, -5, 50]) 6 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([1, 1, 1, 1]) 1 pass def unique_preserve_order(nums): Returns a new list with the unique numbers from the original list, preserving the order they appeared in. >>> unique_preserve_order([100, 4, 200, 1, 3, 2, 2, -1, 0]) [100, 4, 200, 1, 3, 2, -1, 0] >>> unique_preserve_order([1, 9, 3, 10, 4, 20, 2, 9, 10]) [1, 9, 3, 10, 4, 20, 2] >>> unique_preserve_order([1, 1, 1, 1, 1]) [1] >>> unique_preserve_order([]) [] >>> unique_preserve_order([7, 10, 7, 3, 4, 3, 2, 10, 7]) [7, 10, 3, 4, 2] pass","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest sequence of consecutive integers in an unsorted list of integers. if not nums: return 0 nums = set(nums) longest_streak = 0 for num in nums: if num - 1 not in nums: current_num = num current_streak = 1 while current_num + 1 in nums: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak def unique_preserve_order(nums): Returns a new list with the unique numbers from the original list, preserving the order they appeared in. seen = set() result = [] for num in nums: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"def evaluate_expression(expression: str, variables: dict) -> float: Evaluates an algebraic expression with variables, constants, and basic operators (+, -, *, /), correctly handling the order of operations and parentheses. Args: expression: The algebraic expression as a string. variables: A dictionary where keys are variable names and values are their corresponding numerical values. Returns: float: The result of the evaluated expression. pass # Unit tests def test_simple_addition(): expression = \\"a + b\\" variables = {'a': 2, 'b': 3} assert evaluate_expression(expression, variables) == 5 def test_mixed_operations(): expression = \\"a + b * c\\" variables = {'a': 2, 'b': 3, 'c': 4} assert evaluate_expression(expression, variables) == 14 # 2 + 3*4 = 2 + 12 def test_parentheses(): expression = \\"(a + b) * c\\" variables = {'a': 2, 'b': 3, 'c': 4} assert evaluate_expression(expression, variables) == 20 # (2 + 3) * 4 = 5 * 4 def test_division(): expression = \\"a / b\\" variables = {'a': 10, 'b': 2} assert evaluate_expression(expression, variables) == 5 def test_combined_operations(): expression = \\"a + b - c * d / e\\" variables = {'a': 10, 'b': 5, 'c': 4, 'd': 3, 'e': 2} assert evaluate_expression(expression, variables) == 9 # 10 + 5 - 4*3/2 = 10 + 5 - 6 = 9 def test_single_variable(): expression = \\"a\\" variables = {'a': 10} assert evaluate_expression(expression, variables) == 10","solution":"import re def evaluate_expression(expression, variables): Evaluates an algebraic expression with variables, constants, and basic operators (+, -, *, /). Args: expression (str): The algebraic expression as a string. variables (dict): A dictionary where keys are variable names and values are their corresponding numerical values. Returns: float: The result of the evaluated expression. # Replace variables in the expression with their values from the dictionary for var, value in variables.items(): # Use regex to ensure we replace only whole words expression = re.sub(r'b' + re.escape(var) + r'b', str(value), expression) # Evaluate the expression using Python's eval result = eval(expression) return result"},{"question":"def classify_sequence(sequence: list) -> str: Returns a string representing the type of sequence: \\"Arithmetic\\", \\"Geometric\\", or \\"None\\". >>> classify_sequence([3, 6, 9, 12]) \\"Arithmetic\\" >>> classify_sequence([2, 6, 18, 54]) \\"Geometric\\" >>> classify_sequence([1, 2, 4, 8, 16]) \\"Geometric\\" >>> classify_sequence([1, 2, 4, 8, 15]) \\"None\\" >>> classify_sequence([]) \\"None\\" >>> classify_sequence([5]) \\"None\\" >>> classify_sequence([5, 5]) \\"Arithmetic\\"","solution":"def classify_sequence(sequence: list) -> str: Returns the type of sequence: \\"Arithmetic\\", \\"Geometric\\", or \\"None\\". if len(sequence) < 2: return \\"None\\" is_arithmetic = True is_geometric = True arithmetic_diff = sequence[1] - sequence[0] geometric_ratio = sequence[1] / sequence[0] if sequence[0] != 0 else None for i in range(1, len(sequence) - 1): if sequence[i + 1] - sequence[i] != arithmetic_diff: is_arithmetic = False if sequence[i] == 0 or sequence[i + 1] / sequence[i] != geometric_ratio: is_geometric = False if is_arithmetic: return \\"Arithmetic\\" elif is_geometric: return \\"Geometric\\" else: return \\"None\\""},{"question":"def find_missing_positive(nums: list) -> int: Finds the smallest positive integer missing from the list. The function should have a time complexity of O(n) and use O(1) additional space (excluding the input list). >>> find_missing_positive([3, 4, -1, 1]) == 2 >>> find_missing_positive([1, 2, 0]) == 3 >>> find_missing_positive([7, 8, 9, 11, 12]) == 1","solution":"def find_missing_positive(nums: list) -> int: Finds the smallest positive integer missing from the list. The function modifies the input list to achieve O(1) extra space complexity. n = len(nums) # Step 1: Replace non-positive numbers and out of range numbers with a number larger than the length of the array for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Step 2: Mark positions corresponding to values in the array for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # Step 3: The first positive index + 1 is the smallest missing positive integer for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"def calculate_factorial(n): Returns the factorial of a non-negative integer n using recursion. Provide a correct implementation. >>> calculate_factorial(0) == 1 >>> calculate_factorial(1) == 1 >>> calculate_factorial(5) == 120 >>> calculate_factorial(3) == 6 >>> calculate_factorial(10) == 3628800 # Implementation should go here Test cases: import pytest from solution import calculate_factorial def test_factorial_of_zero(): assert calculate_factorial(0) == 1 def test_factorial_of_one(): assert calculate_factorial(1) == 1 def test_factorial_of_positive_number(): assert calculate_factorial(5) == 120 assert calculate_factorial(3) == 6 def test_factorial_large_number(): assert calculate_factorial(10) == 3628800 def test_factorial_raises_error_for_negative_input(): with pytest.raises(ValueError): calculate_factorial(-1)","solution":"def calculate_factorial(n): Returns the factorial of a non-negative integer n using recursion. if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return 1 else: return n * calculate_factorial(n - 1)"},{"question":"def double_characters(input_string: str) -> str: Returns a new string where each character in the original string is doubled. >>> double_characters('') == '' >>> double_characters('a') == 'aa' >>> double_characters('b') == 'bb' >>> double_characters('hello') == 'hheelllloo' >>> double_characters('hello world') == 'hheelllloo wwoorrlldd' >>> double_characters('a!b@c#') == 'aa!!bb@@cc' >>> double_characters('12345') == '1122334455' >>> double_characters('a1!b') == 'aa11!!bb'","solution":"def double_characters(input_string): Returns a new string where each character in the input string is doubled. return ''.join([char * 2 for char in input_string])"},{"question":"def max_subarray_sum(arr: List[int]) -> Tuple[int, int, int]: Finds the maximum sum of a contiguous subarray within the list. Returns the maximum sum along with the start and end indices of the subarray. >>> max_subarray_sum([5]) (5, 0, 0) >>> max_subarray_sum([-5]) (-5, 0, 0) >>> max_subarray_sum([1, 2, 3, 4, 5]) (15, 0, 4) >>> max_subarray_sum([-1, -2, -3, -4, -5]) (-1, 0, 0) >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) (6, 3, 6) >>> max_subarray_sum([1, 2, 3, -6, 1, 2, 3]) (6, 0, 2) >>> max_subarray_sum([]) (0, -1, -1)","solution":"def max_subarray_sum(arr): Finds the maximum sum of a contiguous subarray within the list. Parameters: arr (list): A list of integers. Returns: tuple: A tuple containing the maximum sum, starting index, and ending index of the subarray. if not arr: return (0, -1, -1) max_sum = arr[0] current_sum = arr[0] start = 0 end = 0 temp_start = 0 for i in range(1, len(arr)): if current_sum < 0: current_sum = arr[i] temp_start = i else: current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return (max_sum, start, end)"},{"question":"from typing import List def find_palindromic_substrings(s: str) -> List[str]: Given a string s, return a list of all palindromic substrings in s. Parameters: s (str): The input string. Returns: list: A list of palindromic substrings found in s. def get_palindromic_substrings_in_list(strings: List[str]) -> List[List[str]]: Given a list of strings, return a list where each element is a list of all palindromic substrings found in the corresponding input string. Parameters: strings (list): A list of input strings. Returns: list: A list of lists, where each list contains the palindromic substrings of the corresponding string. # Test cases def test_find_palindromic_substrings(): assert find_palindromic_substrings(\\"abba\\") == [\\"abba\\", \\"bb\\"] assert find_palindromic_substrings(\\"racecar\\") == [\\"racecar\\", \\"aceca\\", \\"cec\\"] assert find_palindromic_substrings(\\"abc\\") == [] assert find_palindromic_substrings(\\"a\\") == [] assert find_palindromic_substrings(\\"madam\\") == [\\"madam\\", \\"ada\\"] assert find_palindromic_substrings(\\"\\") == [] def test_get_palindromic_substrings_in_list(): assert get_palindromic_substrings_in_list([\\"abba\\", \\"racecar\\", \\"abc\\", \\"a\\", \\"madam\\"]) == [ [\\"abba\\", \\"bb\\"], [\\"racecar\\", \\"aceca\\", \\"cec\\"], [], [], [\\"madam\\", \\"ada\\"] ] assert get_palindromic_substrings_in_list([]) == [] assert get_palindromic_substrings_in_list([\\"\\"]) == [[]] assert get_palindromic_substrings_in_list([\\"noon\\", \\"level\\", \\"\\"]) == [ [\\"noon\\", \\"oo\\"], [\\"level\\", \\"eve\\"], [] ]","solution":"def find_palindromic_substrings(s): Given a string s, return a list of all palindromic substrings in s. Parameters: s (str): The input string. Returns: list: A list of palindromic substrings found in s. def is_palindrome(sub): return sub == sub[::-1] palindromes = [] n = len(s) # Check each substring (n^2 complexity) for start in range(n): for end in range(start + 2, n + 1): # +2 ensures we only consider substrings of length 2 or more substring = s[start:end] if is_palindrome(substring): palindromes.append(substring) return palindromes def get_palindromic_substrings_in_list(strings): Given a list of strings, return a list where each element is a list of all palindromic substrings found in the corresponding input string. Parameters: strings (list): A list of input strings. Returns: list: A list of lists, where each list contains the palindromic substrings of the corresponding string. result = [] for s in strings: result.append(find_palindromic_substrings(s)) return result"},{"question":"def is_well_formed(expression: str) -> bool: Returns True if the input string is a well-formed mathematical expression using parentheses, brackets, and curly braces; otherwise, returns False. >>> is_well_formed(\\"{[()]}\\") True >>> is_well_formed(\\"{[(])}\\") False >>> is_well_formed(\\"\\") True >>> is_well_formed(\\"{a[b(c)d]e}\\") True >>> is_well_formed(\\"{a+b*(c-d]}\\") False","solution":"def is_well_formed(expression): Returns True if the input string is a well-formed mathematical expression using parentheses, brackets, and curly braces; otherwise, returns False. stack = [] matching_pairs = {')': '(', ']': '[', '}': '{'} for char in expression: if char in matching_pairs.values(): stack.append(char) elif char in matching_pairs.keys(): if stack == [] or matching_pairs[char] != stack.pop(): return False else: # Ignore non-bracket characters continue return stack == []"},{"question":"from typing import List def all_permutations(lst: List[int]) -> List[List[int]]: Write a Python function that takes a list of integers and returns a list of all possible permutations of those integers. >>> all_permutations([]) == [[]] >>> all_permutations([1]) == [[1]] >>> all_permutations([1, 2]) == [[1, 2], [2, 1]] >>> all_permutations([1, 2, 3]) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> all_permutations([1, 2, 3, 4]) == [[1, 2, 3, 4], [1, 2, 4, 3], [1, 3, 2, 4], [1, 3, 4, 2], [1, 4, 2, 3], [1, 4, 3, 2], [2, 1, 3, 4], [2, 1, 4, 3], [2, 3, 1, 4], [2, 3, 4, 1], [2, 4, 1, 3], [2, 4, 3, 1], [3, 1, 2, 4], [3, 1, 4, 2], [3, 2, 1, 4], [3, 2, 4, 1], [3, 4, 1, 2], [3, 4, 2, 1], [4, 1, 2, 3], [4, 1, 3, 2], [4, 2, 1, 3], [4, 2, 3, 1], [4, 3, 1, 2], [4, 3, 2, 1]]","solution":"from itertools import permutations def all_permutations(lst): Returns all possible permutations of a list of integers. :param lst: List of integers :return: List of all possible permutations return [list(p) for p in permutations(lst)]"},{"question":"from typing import List def four_sum(nums: List[int], target: int) -> List[List[int]]: Finds all unique quadruples in the list that sum up to the target. Args: nums (List[int]): A list of integers. target (int): The target sum for the quadruples. Returns: List[List[int]]: A list of unique quadruples (a, b, c, d) such that a + b + c + d = target. >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([1, 2, 3, 4], 100) [] >>> four_sum([1, 0, -1, 0, -2, 2, 2], 2) [[-2, 0, 2, 2], [-1, 0, 1, 2]] >>> four_sum([-3, -2, -1, 0, 0, 1, 2, 3], 0) [[-3, -2, 2, 3], [-3, -1, 1, 3], [-3, 0, 0, 3], [-3, 0, 1, 2], [-2, -1, 0, 3], [-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([1000000000, 1000000000, 1000000000, 1000000000], 4000000000) [[1000000000, 1000000000, 1000000000, 1000000000]]","solution":"from typing import List def four_sum(nums: List[int], target: int) -> List[List[int]]: Finds all unique quadruples in the list that sum up to the target. nums.sort() quadruples = set() n = len(nums) for i in range(n - 3): for j in range(i + 1, n - 2): left = j + 1 right = n - 1 while left < right: current_sum = nums[i] + nums[j] + nums[left] + nums[right] if current_sum == target: quadruples.add((nums[i], nums[j], nums[left], nums[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 # Sort and convert to list of lists result = [list(q) for q in sorted(quadruples)] return result"},{"question":"def recommend_movies(movies, users): Recommends a list of movies for each user based on their preferred genres. >>> movies = [ ... [\\"Inception\\", \\"Action\\", \\"Sci-Fi\\", \\"Thriller\\"], ... [\\"The Godfather\\", \\"Crime\\", \\"Drama\\"], ... [\\"Toy Story\\", \\"Animation\\", \\"Comedy\\", \\"Family\\"] ... ] >>> users = [ ... [\\"Alice\\", \\"Action\\", \\"Comedy\\"], ... [\\"Bob\\", \\"Crime\\", \\"Drama\\"] ... ] >>> recommend_movies(movies, users) {'Alice': ['Inception', 'Toy Story'], 'Bob': ['The Godfather']}","solution":"def recommend_movies(movies, users): recommendations = {} # Build user preferences dictionary for easier access user_preferences = {} for user in users: user_preferences[user[0]] = set(user[1:]) # Iterate over each user and check which movies match their preferences for user, genres in user_preferences.items(): recommendations[user] = [] for movie in movies: movie_title = movie[0] movie_genres = set(movie[1:]) if not genres.isdisjoint(movie_genres): recommendations[user].append(movie_title) return recommendations"},{"question":"def count_integers(int_list): Returns a dictionary with the count of each unique integer in the input list. The dictionary keys are sorted in ascending order. >>> count_integers([4, 6, 2, 6, 7, 4, 2, 2]) == {2: 3, 4: 2, 6: 2, 7: 1} >>> count_integers([]) == {} >>> count_integers([5]) == {5: 1} >>> count_integers([1, 2, 3, 4, 5]) == {1: 1, 2: 1, 3: 1, 4: 1, 5: 1} >>> count_integers([1, 2, 2, 3, 4, 4, 4, 5]) == {1: 1, 2: 2, 3: 1, 4: 3, 5: 1} >>> count_integers([-1, -2, -1, 0, 2, 0, 1, 2]) == {-2: 1, -1: 2, 0: 2, 1: 1, 2: 2} ...","solution":"def count_integers(int_list): Returns a dictionary with the count of each unique integer in the input list. The dictionary keys are sorted in ascending order. count_dict = {} for num in int_list: if num in count_dict: count_dict[num] += 1 else: count_dict[num] = 1 return dict(sorted(count_dict.items()))"},{"question":"def trim_strings(string_list: List[str]) -> List[str]: Devise a function that accepts a list of strings and returns a new list compiled by removing all leading and trailing whitespace from each string in the original list. The function should handle edge cases such as null input, empty strings, and strings that contain only whitespace. Additionally, the function should preserve the order of the original list and be able to manage inputs containing Unicode and special characters. >>> trim_strings([\\" hello \\", \\" world\\", \\"test \\"]) [\\"hello\\", \\"world\\", \\"test\\"] >>> trim_strings([\\"  \\", \\" \\", \\" \\"]) [\\"\\", \\"\\", \\"\\"] >>> trim_strings([\\"\\", \\" \\", \\"test\\"]) [\\"\\", \\"\\", \\"test\\"] >>> trim_strings(None) [] >>> trim_strings([\\" abc123\\", \\"123 \\", \\" abc 123 \\"]) [\\"abc123\\", \\"123\\", \\"abc 123\\"] >>> trim_strings([\\" \\"]) [\\"\\"] >>> trim_strings([\\"a\\"]) [\\"a\\"] >>> trim_strings([\\" a \\"]) [\\"a\\"] pass","solution":"def trim_strings(string_list): Removes leading and trailing whitespace from each string in the input list. Parameters: string_list (list): A list of strings to be trimmed. Returns: list: A new list with trimmed strings. if string_list is None: return [] return [s.strip() for s in string_list]"},{"question":"def extract_engineers(employees): Extract and return the names of employees from the 'Engineering' department aged 30 and above, sorted by descending salary, and alphabetically by name in case of salary ties. >>> extract_engineers([ ... {'name': 'Alice', 'age': 34, 'department': 'Engineering', 'salary': 70000}, ... {'name': 'Bob', 'age': 28, 'department': 'Marketing', 'salary': 60000}, ... {'name': 'Charlie', 'age': 32, 'department': 'Engineering', 'salary': 150000}, ... {'name': 'Dana', 'age': 29, 'department': 'Engineering', 'salary': 90000}, ... {'name': 'Eve', 'age': 40, 'department': 'HR', 'salary': 120000} ... ]) == ['Charlie', 'Alice'] >>> extract_engineers([]) == [] >>> extract_engineers([ ... {'name': 'Alice', 'age': 28, 'department': 'Engineering', 'salary': 70000}, ... {'name': 'Bob', 'age': 28, 'department': 'Marketing', 'salary': 60000}, ... {'name': 'Dana', 'age': 29, 'department': 'Engineering', 'salary': 90000}, ... {'name': 'Eve', 'age': 40, 'department': 'HR', 'salary': 120000} ... ]) == [] >>> extract_engineers([ ... {'name': 'Alice', 'age': 34, 'department': 'Engineering', 'salary': 70000}, ... {'name': 'Charlie', 'age': 32, 'department': 'Engineering', 'salary': 150000}, ... {'name': 'Eve', 'age': 40, 'department': 'HR', 'salary': 120000}, ... {'name': 'Bob', 'age': 28, 'department': 'Marketing', 'salary': 60000}, ... {'name': 'Dana', 'age': 30, 'department': 'Engineering', 'salary': 80000} ... ]) == ['Charlie', 'Dana', 'Alice']","solution":"def extract_engineers(employees): Extract and return the names of employees from the 'Engineering' department aged 30 and above, sorted by descending salary, and alphabetically by name in case of salary ties. eligible_employees = [ employee for employee in employees if employee['department'] == 'Engineering' and employee['age'] >= 30 ] sorted_employees = sorted(eligible_employees, key=lambda x: (-x['salary'], x['name'])) return [employee['name'] for employee in sorted_employees]"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression consisting of non-negative integers, addition (+), and multiplication (*) operations, respecting the order of operations. >>> evaluate_expression(\\"2+3\\") == 5 >>> evaluate_expression(\\"2*3\\") == 6 >>> evaluate_expression(\\"2+3*5+8\\") == 25 >>> evaluate_expression(\\"2*3+4*5\\") == 26 >>> evaluate_expression(\\"2*3+4\\") == 10 >>> evaluate_expression(\\"2*3*4\\") == 24 >>> evaluate_expression(\\"1+2+3+4\\") == 10 >>> evaluate_expression(\\"42\\") == 42","solution":"def evaluate_expression(expression): Evaluates a mathematical expression consisting of non-negative integers, addition (+), and multiplication (*) operations, respecting the order of operations. def evaluate(tokens): Helper function to evaluate tokens with correct precedence. # Process multiplication first result = [] i = 0 while i < len(tokens): if tokens[i] == '*': last_num = result.pop() next_num = tokens[i + 1] result.append(last_num * next_num) i += 1 else: result.append(tokens[i]) i += 1 # Process addition total = 0 for token in result: if token != '+': total += token return total # Tokenization import re tokens = re.findall(r'd+|[+*]', expression) tokens = [int(token) if token.isdigit() else token for token in tokens] return evaluate(tokens)"},{"question":"class LibraryInventory: A class to manage a library inventory system. def __init__(self): Initialize an empty inventory list. self.inventory = [] def add_book(self, title: str, author: str, genre: str, year: int, available: bool=True): Adds a new book to the inventory. :param title: Title of the book :param author: Author of the book :param genre: Genre of the book :param year: Year of publication :param available: Availability status of the book (default is True) pass def search_books(self, title: str=None, author: str=None, genre: str=None): Searches for books based on title, author, and genre. Partial matches are supported. :param title: Title of the book to search for (optional) :param author: Author of the book to search for (optional) :param genre: Genre of the book to search for (optional) :return: List of books matching the search criteria pass def loan_book(self, title: str): Loans out a book by title. Updates the inventory to mark the book as not available. :param title: Title of the book to loan out :return: Message indicating the loan status pass def return_book(self, title: str): Returns a book by title. Updates the inventory to mark the book as available. :param title: Title of the book to return :return: Message indicating the return status pass def display_inventory(self): Displays all books currently in the inventory. :return: List of all books in the inventory pass","solution":"class LibraryInventory: def __init__(self): self.inventory = [] def add_book(self, title, author, genre, year, available=True): Adds a new book to the inventory. book = { \\"title\\": title, \\"author\\": author, \\"genre\\": genre, \\"year\\": year, \\"available\\": available } self.inventory.append(book) def search_books(self, title=None, author=None, genre=None): Searches for books based on title, author, and genre. Partial matches are supported. results = [] for book in self.inventory: if (title and title.lower() in book[\\"title\\"].lower()) or (author and author.lower() in book[\\"author\\"].lower()) or (genre and genre.lower() in book[\\"genre\\"].lower()): results.append(book) return results def loan_book(self, title): Loans out a book by title. Updates the inventory to mark the book as not available. for book in self.inventory: if book[\\"title\\"].lower() == title.lower() and book[\\"available\\"]: book[\\"available\\"] = False return f\\"The book '{title}' has been loaned out.\\" return f\\"The book '{title}' is not available.\\" def return_book(self, title): Returns a book by title. Updates the inventory to mark the book as available. for book in self.inventory: if book[\\"title\\"].lower() == title.lower() and not book[\\"available\\"]: book[\\"available\\"] = True return f\\"The book '{title}' has been returned.\\" return f\\"The book '{title}' was not loaned out.\\" def display_inventory(self): Displays all books currently in the inventory. return self.inventory"},{"question":"def merge_and_sort(list1, list2): Merges two sorted lists into a single sorted list while maintaining the order specified: - Numeric elements first (integers and floats) in ascending order. - String elements last in their original order. - Nested lists intermediate, ordered by the sum of their elements and maintaining relative order. >>> merge_and_sort([1, -2.5, [3, 1], \\"banana\\", [2, 3]], [4, 6, \\"apple\\", [1, 1]]) [-2.5, 1, 4, 6, \\"banana\\", \\"apple\\", [1, 1], [3, 1], [2, 3]] >>> merge_and_sort([1, 3, 5, \\"apple\\"], [2, 4, 6, \\"banana\\"]) [1, 2, 3, 4, 5, 6, \\"apple\\", \\"banana\\"]","solution":"def merge_and_sort(list1, list2): Merges two sorted lists into a single sorted list while maintaining the order specified: - Numeric elements first (integers and floats) in ascending order. - String elements next in their original order. - Nested lists last, ordered by the sum of their elements and maintaining relative order. merged_list = list1 + list2 # Separate numeric elements, string elements, and nested lists numbers = [] strings = [] nested_lists = [] for element in merged_list: if isinstance(element, (int, float)): numbers.append(element) elif isinstance(element, str): strings.append(element) elif isinstance(element, list): nested_lists.append(element) # Sort numeric elements numbers.sort() # Sort nested lists by the sum of their elements nested_lists.sort(key=lambda x: sum(x)) # Combine all sorted parts sorted_merged_list = numbers + strings + nested_lists return sorted_merged_list"},{"question":"def to_be_ordered(available: list[str], restocking: list[str]) -> list[str]: Returns a list of items from the restocking list that are not in the available list, sorted in alphabetical order. Parameters: available (list of str): List of items currently available in the store. restocking (list of str): List of items that need to be restocked. Returns: list of str: Sorted list of items to be ordered. >>> to_be_ordered([\\"apple\\", \\"banana\\", \\"orange\\", \\"peach\\"], [\\"banana\\", \\"kiwi\\", \\"apple\\", \\"mango\\", \\"peach\\", \\"grape\\"]) [\\"grape\\", \\"kiwi\\", \\"mango\\"] >>> to_be_ordered([], [\\"kiwi\\", \\"banana\\", \\"mango\\"]) [\\"banana\\", \\"kiwi\\", \\"mango\\"] >>> to_be_ordered([\\"apple\\", \\"banana\\"], [\\"apple\\", \\"banana\\"]) [] >>> to_be_ordered([\\"apple\\", \\"banana\\", \\"peach\\"], [\\"banana\\", \\"kiwi\\", \\"apple\\", \\"mango\\", \\"peach\\", \\"grape\\"]) [\\"grape\\", \\"kiwi\\", \\"mango\\"] >>> to_be_ordered([\\"apple\\", \\"banana\\", \\"orange\\", \\"peach\\"], [\\"banana\\", \\"kiwi\\", \\"apple\\", \\"mango\\", \\"peach\\", \\"grape\\"]) [\\"grape\\", \\"kiwi\\", \\"mango\\"]","solution":"def to_be_ordered(available, restocking): Returns a list of items from the restocking list that are not in the available list, sorted in alphabetical order. Parameters: available (list of str): List of items currently available in the store. restocking (list of str): List of items that need to be restocked. Returns: list of str: Sorted list of items to be ordered. # Using a set for available items for faster lookup available_set = set(available) # List comprehension to filter items not available in the store to_order = [item for item in restocking if item not in available_set] # Returning the sorted list of items to be ordered return sorted(to_order)"},{"question":"class Account: A class to represent a bank account. account_number_counter = 1000 accounts = {} def __init__(self, account_holder_name): self.account_holder_name = account_holder_name self.balance = 0.0 self.account_number = Account.account_number_counter Account.account_number_counter += 1 Account.accounts[self.account_number] = self def deposit(self, amount): Deposit a valid positive amount into the account. Returns True if the amount is valid and deposited, else returns False. pass def withdraw(self, amount): Withdraw a valid positive amount from the account if sufficient balance exists. Returns True if the amount is valid and withdrawn, else returns False. pass def check_balance(self): Returns the current balance of the account. pass def _is_valid_amount(self, amount): Check if the provided amount is a valid positive number. pass @classmethod def get_account(cls, account_number): Returns the account with the specified account number, or None if not found. pass # Unit test def test_account_creation(): acc = Account(\\"John Doe\\") assert acc.account_holder_name == \\"John Doe\\" assert acc.balance == 0.0 assert acc.account_number == 1000 def test_account_number_increment(): acc1 = Account(\\"John Doe\\") acc2 = Account(\\"Jane Doe\\") assert acc2.account_number == acc1.account_number + 1 def test_deposit_positive_amount(): acc = Account(\\"John Doe\\") initial_balance = acc.balance result = acc.deposit(100) assert result == True assert acc.balance == initial_balance + 100 def test_deposit_invalid_amount(): acc = Account(\\"John Doe\\") result1 = acc.deposit(-100) result2 = acc.deposit(\\"abc\\") assert result1 == False assert result2 == False assert acc.balance == 0.0 def test_withdraw_valid_amount(): acc = Account(\\"John Doe\\") acc.deposit(200) result = acc.withdraw(100) assert result == True assert acc.balance == 100 def test_withdraw_invalid_amount(): acc = Account(\\"John Doe\\") acc.deposit(100) result1 = acc.withdraw(-50) result2 = acc.withdraw(\\"abc\\") result3 = acc.withdraw(200) # more than the balance assert result1 == False assert result2 == False assert result3 == False assert acc.balance == 100 def test_check_balance(): acc = Account(\\"John Doe\\") acc.deposit(150) assert acc.check_balance() == 150 def test_get_account(): acc1 = Account(\\"John Doe\\") found_acc = Account.get_account(acc1.account_number) assert found_acc == acc1 assert Account.get_account(-1) == None","solution":"import re class Account: A class to represent a bank account. account_number_counter = 1000 accounts = {} def __init__(self, account_holder_name): self.account_holder_name = account_holder_name self.balance = 0.0 self.account_number = Account.account_number_counter Account.account_number_counter += 1 Account.accounts[self.account_number] = self def deposit(self, amount): if self._is_valid_amount(amount): self.balance += amount return True return False def withdraw(self, amount): if self._is_valid_amount(amount) and amount <= self.balance: self.balance -= amount return True return False def check_balance(self): return self.balance def _is_valid_amount(self, amount): return isinstance(amount, (int, float)) and amount > 0 @classmethod def get_account(cls, account_number): return cls.accounts.get(account_number, None)"},{"question":"def calculate_expression(expression: str) -> int: Write a Python function that receives a string representing a mathematical expression containing only non-negative integers, addition (+) and multiplication (*) operators, and computes its result correctly respecting the mathematical precedence of the operators. The input string may have spaces which the function should ignore. You are not allowed to use the \`eval\` function or any other built-in function that directly evaluates the expression. >>> calculate_expression(\\"3+5*2\\") 13 >>> calculate_expression(\\" 10 + 2 * 6 \\") 22 >>> calculate_expression(\\"100 * 2 + 12\\") 212 >>> calculate_expression(\\"100 * ( 2 + 12 )\\") 1400 >>> calculate_expression(\\"100 * ( 2 + 12 ) / 14\\") 100 pass","solution":"import re def calculate_expression(expression: str) -> int: def apply_op(operands, operators): right = operands.pop() left = operands.pop() op = operators.pop() if op == '+': operands.append(left + right) elif op == '*': operands.append(left * right) expression = re.sub(r\\"s+\\", \\"\\", expression) operands = [] operators = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 operands.append(num) i -= 1 elif expression[i] in '+*': while (operators and operators[-1] == '*' and expression[i] == '+'): apply_op(operands, operators) operators.append(expression[i]) i += 1 while operators: apply_op(operands, operators) return operands[0] # Example assertions assert calculate_expression(\\"3+5*2\\") == 13 assert calculate_expression(\\" 10 + 2 * 6 \\") == 22 assert calculate_expression(\\"100 * 2 + 12\\") == 212"},{"question":"def char_count(s: str) -> dict: Write a Python function that takes a string as input and returns a dictionary where each key is a character in the string, and the corresponding value is the number of times that character appears in the string. Case sensitivity is preserved, and special characters are counted as well. Args: s (str): The input string. Returns: dict: A dictionary with characters as keys and their counts as values. Time Complexity: O(n), where n is the length of the string. Example: >>> char_count(\\"aabbcc\\") {'a': 2, 'b': 2, 'c': 2} >>> char_count(\\"aA\\") {'a': 1, 'A': 1} >>> char_count(\\"@@!!\\") {'@': 2, '!': 2, '#': 2} >>> char_count(\\"123321\\") {'1': 2, '2': 2, '3': 2} >>> char_count(\\"\\") {} >>> char_count(\\"aA1!aA1!\\") {'a': 2, 'A': 2, '1': 2, '!': 2} >>> char_count(\\"aaaaa\\") {'a': 5}","solution":"def char_count(s): Returns a dictionary where each key is a character in the string \`s\`, and the corresponding value is the number of times that character appears in the string. Case sensitivity is preserved, and special characters are counted as well. Args: s (str): The input string. Returns: dict: A dictionary with characters as keys and their counts as values. result = {} for char in s: if char in result: result[char] += 1 else: result[char] = 1 return result # The time complexity of this function is O(n), where n is the length of the string. # This is because we iterate through the string once, and operations on the dictionary (insertion and update) # are average O(1) operations."},{"question":"def fizzbuzz(n: int) -> List[str]: Simulates the FizzBuzz game and returns a list of strings. For multiples of 3, it outputs \\"Fizz\\" instead of the number. For multiples of 5, it outputs \\"Buzz\\" instead of the number. For numbers which are multiples of both 3 and 5, it outputs \\"FizzBuzz\\". # Write your solution here from solution import fizzbuzz def test_fizzbuzz_15(): assert fizzbuzz(15) == [\\"1\\", \\"2\\", \\"Fizz\\", \\"4\\", \\"Buzz\\", \\"Fizz\\", \\"7\\", \\"8\\", \\"Fizz\\", \\"Buzz\\", \\"11\\", \\"Fizz\\", \\"13\\", \\"14\\", \\"FizzBuzz\\"] def test_fizzbuzz_1(): assert fizzbuzz(1) == [\\"1\\"] def test_fizzbuzz_3(): assert fizzbuzz(3) == [\\"1\\", \\"2\\", \\"Fizz\\"] def test_fizzbuzz_5(): assert fizzbuzz(5) == [\\"1\\", \\"2\\", \\"Fizz\\", \\"4\\", \\"Buzz\\"] def test_fizzbuzz_0(): assert fizzbuzz(0) == [] def test_fizzbuzz_negative(): assert fizzbuzz(-5) == []","solution":"def fizzbuzz(n): Returns a list of strings representing the numbers from 1 to n. For multiples of 3, it outputs \\"Fizz\\" instead of the number. For multiples of 5, it outputs \\"Buzz\\" instead of the number. For numbers which are multiples of both 3 and 5, it outputs \\"FizzBuzz\\". result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return result"},{"question":"from datetime import datetime from typing import List, Tuple def days_between_dates(date_pairs: List[Tuple[str, str]]) -> List[int]: Write a Python function that takes a list of tuples, where each tuple contains two strings representing dates in \\"YYYY-MM-DD\\" format. The function should return a list of integers representing the number of days between the two dates for each tuple. Ensure that the function can handle special cases where the dates are the same and where the dates fall in different months or years. >>> days_between_dates([(\\"2023-03-25\\", \\"2023-04-01\\"), (\\"2022-01-10\\", \\"2022-01-10\\"), (\\"2021-12-25\\", \\"2022-01-01\\")]) [7, 0, 7] >>> days_between_dates([(\\"2020-01-01\\", \\"2020-12-31\\"), (\\"2023-06-15\\", \\"2023-06-14\\")]) [365, 1] >>> days_between_dates([(\\"2023-05-20\\", \\"2023-05-20\\")]) [0] >>> days_between_dates([(\\"2019-02-28\\", \\"2020-02-29\\")]) [366] >>> days_between_dates([(\\"2021-07-01\\", \\"2021-08-01\\")]) [31] >>> days_between_dates([(\\"2024-02-28\\", \\"2024-03-01\\")]) [2] >>> days_between_dates([(\\"2022-05-01\\", \\"2021-05-01\\")]) [365]","solution":"from datetime import datetime def days_between_dates(date_pairs): Given a list of tuples containing two dates in \\"YYYY-MM-DD\\" format, returns a list of integers representing the number of days between each pair of dates. result = [] for date1, date2 in date_pairs: date_format = \\"%Y-%m-%d\\" d1 = datetime.strptime(date1, date_format) d2 = datetime.strptime(date2, date_format) delta = abs((d2 - d1).days) result.append(delta) return result"},{"question":"import pandas as pd from difflib import get_close_matches # Sample movie dataset MOVIES = [ {\\"title\\": \\"Inception\\", \\"genre\\": \\"Sci-Fi\\", \\"director\\": \\"Christopher Nolan\\", \\"year\\": 2010, \\"rating\\": 8.8}, {\\"title\\": \\"The Godfather\\", \\"genre\\": \\"Crime\\", \\"director\\": \\"Francis Ford Coppola\\", \\"year\\": 1972, \\"rating\\": 9.2}, {\\"title\\": \\"Pulp Fiction\\", \\"genre\\": \\"Crime\\", \\"director\\": \\"Quentin Tarantino\\", \\"year\\": 1994, \\"rating\\": 8.9}, {\\"title\\": \\"The Dark Knight\\", \\"genre\\": \\"Action\\", \\"director\\": \\"Christopher Nolan\\", \\"year\\": 2008, \\"rating\\": 9.0}, {\\"title\\": \\"Forrest Gump\\", \\"genre\\": \\"Drama\\", \\"director\\": \\"Robert Zemeckis\\", \\"year\\": 1994, \\"rating\\": 8.8}, {\\"title\\": \\"The Matrix\\", \\"genre\\": \\"Sci-Fi\\", \\"director\\": \\"The Wachowskis\\", \\"year\\": 1999, \\"rating\\": 8.7}, {\\"title\\": \\"The Shawshank Redemption\\", \\"genre\\": \\"Drama\\", \\"director\\": \\"Frank Darabont\\", \\"year\\": 1994, \\"rating\\": 9.3}, # Additional movies... ] def load_movie_data(): Load the mock movie dataset into a DataFrame. >>> df = load_movie_data() >>> not df.empty True pass def get_user_genres(): Mock function to simulate user input for favorite genres. >>> genres = get_user_genres() >>> isinstance(genres, list) True >>> len(genres) > 0 True pass def recommend_movies(movies_df, user_genres): Recommend movies to the user based on their input genres. Parameters: movies_df: The movie dataset. user_genres: List of user's favorite genres. Returns: DataFrame: Filtered DataFrame of recommended movies. >>> df = load_movie_data() >>> genres = get_user_genres() >>> recommended = recommend_movies(df, genres) >>> not recommended.empty True pass def recommend_movies_with_related_genres(movies_df, user_genres): Recommend movies to the user based on their input genres, including suggesting closely related genres if user's preferred genres are not found. Parameters: movies_df: The movie dataset. user_genres: List of user's favorite genres. Returns: DataFrame: Filtered DataFrame of recommended movies. >>> df = load_movie_data() >>> recommended = recommend_movies_with_related_genres(df, [\\"Sci-Fi\\", \\"Action\\"]) >>> not recommended.empty True pass def analyze_recommendation_system(recommended_movies): Perform analysis on the recommendation system, such as hypothetical feedback. Parameters: recommended_movies: The DataFrame of recommended movies. Returns: dict: Analysis results. >>> df = load_movie_data() >>> genres = get_user_genres() >>> recommended = recommend_movies(df, genres) >>> analysis = analyze_recommendation_system(recommended) >>> isinstance(analysis, dict) True >>> 'average_rating' in analysis True pass","solution":"import pandas as pd from difflib import get_close_matches # Sample movie dataset MOVIES = [ {\\"title\\": \\"Inception\\", \\"genre\\": \\"Sci-Fi\\", \\"director\\": \\"Christopher Nolan\\", \\"year\\": 2010, \\"rating\\": 8.8}, {\\"title\\": \\"The Godfather\\", \\"genre\\": \\"Crime\\", \\"director\\": \\"Francis Ford Coppola\\", \\"year\\": 1972, \\"rating\\": 9.2}, {\\"title\\": \\"Pulp Fiction\\", \\"genre\\": \\"Crime\\", \\"director\\": \\"Quentin Tarantino\\", \\"year\\": 1994, \\"rating\\": 8.9}, {\\"title\\": \\"The Dark Knight\\", \\"genre\\": \\"Action\\", \\"director\\": \\"Christopher Nolan\\", \\"year\\": 2008, \\"rating\\": 9.0}, {\\"title\\": \\"Forrest Gump\\", \\"genre\\": \\"Drama\\", \\"director\\": \\"Robert Zemeckis\\", \\"year\\": 1994, \\"rating\\": 8.8}, {\\"title\\": \\"The Matrix\\", \\"genre\\": \\"Sci-Fi\\", \\"director\\": \\"The Wachowskis\\", \\"year\\": 1999, \\"rating\\": 8.7}, {\\"title\\": \\"The Shawshank Redemption\\", \\"genre\\": \\"Drama\\", \\"director\\": \\"Frank Darabont\\", \\"year\\": 1994, \\"rating\\": 9.3}, # Additional movies... ] # Load and preprocess the movie dataset def load_movie_data(): Load the mock movie dataset into a DataFrame. return pd.DataFrame(MOVIES) # Allow the user to input their favorite genres def get_user_genres(): Mock function to simulate user input for favorite genres. In a real system, this would retrieve data from the user. return [\\"Sci-Fi\\", \\"Action\\"] # Recommend a list of movies based on the user's input def recommend_movies(movies_df, user_genres): Recommend movies to the user based on their input genres. Parameters: movies_df (DataFrame): The movie dataset. user_genres (list): List of user's favorite genres. Returns: DataFrame: Filtered DataFrame of recommended movies. return movies_df[movies_df['genre'].isin(user_genres)] # Optimize the recommendation system to handle cases where the user's preferred genres are not explicitly listed def recommend_movies_with_related_genres(movies_df, user_genres): Recommend movies to the user based on their input genres, including suggesting closely related genres if user's preferred genres are not found. Parameters: movies_df (DataFrame): The movie dataset. user_genres (list): List of user's favorite genres. Returns: DataFrame: Filtered DataFrame of recommended movies. available_genres = movies_df['genre'].unique().tolist() related_genres = set(user_genres) for genre in user_genres: close_matches = get_close_matches(genre, available_genres, n=2, cutoff=0.6) related_genres.update(close_matches) return movies_df[movies_df['genre'].isin(related_genres)] # Provide analysis of how the recommendation system performs def analyze_recommendation_system(recommended_movies): Perform analysis on the recommendation system, such as hypothetical feedback. Parameters: recommended_movies (DataFrame): The DataFrame of recommended movies. Returns: dict: Analysis results. avg_rating = recommended_movies['rating'].mean() genre_distribution = recommended_movies['genre'].value_counts().to_dict() analysis = { \\"average_rating\\": avg_rating, \\"genre_distribution\\": genre_distribution, \\"total_recommendations\\": len(recommended_movies) } return analysis"},{"question":"def sum_of_unique_multiples(lst, n): Returns the sum of all unique multiples of n found within the list lst. >>> sum_of_unique_multiples([1, 3, 6, 9, 12, 3, 6], 3) 30 >>> sum_of_unique_multiples([5, 10, 15, 20, 25, 30], 5) 105 >>> sum_of_unique_multiples([1, 2, 4, 7], 3) 0 >>> sum_of_unique_multiples([], 3) 0 >>> sum_of_unique_multiples([0, 0, 0], 0) 0 >>> sum_of_unique_multiples([1, -3, 6, -9, 12, 3], 3) 9","solution":"def sum_of_unique_multiples(lst, n): Returns the sum of all unique multiples of n found within the list lst. if n == 0: return 0 multiples = set(x for x in lst if x % n == 0) return sum(multiples)"},{"question":"def reverse_words(s: str) -> str: Given a string of words separated by spaces, reverses each word in the string while maintaining the original order of words. The function should use list comprehension. >>> reverse_words(\\"hello\\") \\"olleh\\" >>> reverse_words(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_words(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_words(\\" hello world \\") \\"olleh dlrow\\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\"madam racecar\\") \\"madam racecar\\"","solution":"def reverse_words(s): Reverses each word in the string while maintaining the original order of words. return ' '.join([word[::-1] for word in s.split()])"},{"question":"from typing import Dict def flatten_dictionary(d: Dict[str, any]) -> Dict[str, any]: Flatten a dictionary with nested dictionaries into a single-level dictionary with dot-separated keys. >>> flatten_dictionary({ ... \\"key1\\": \\"value1\\", ... \\"key2\\": { ... \\"key3\\": { ... \\"key4\\": \\"value2\\" ... } ... }, ... \\"key5\\": { ... \\"key6\\": \\"value3\\" ... } ... }) {\\"key1\\": \\"value1\\", \\"key2.key3.key4\\": \\"value2\\", \\"key5.key6\\": \\"value3\\"} >>> flatten_dictionary({}) {} pass def test_flatten_simple(): input_dict = { \\"key1\\": \\"value1\\", \\"key2\\": { \\"key3\\": { \\"key4\\": \\"value2\\" } }, \\"key5\\": { \\"key6\\": \\"value3\\" } } expected_output = { \\"key1\\": \\"value1\\", \\"key2.key3.key4\\": \\"value2\\", \\"key5.key6\\": \\"value3\\" } assert flatten_dictionary(input_dict) == expected_output def test_flatten_empty(): input_dict = {} expected_output = {} assert flatten_dictionary(input_dict) == expected_output def test_flatten_no_nested(): input_dict = { \\"key1\\": \\"value1\\", \\"key2\\": \\"value2\\" } expected_output = { \\"key1\\": \\"value1\\", \\"key2\\": \\"value2\\" } assert flatten_dictionary(input_dict) == expected_output def test_flatten_single_nested(): input_dict = { \\"key1\\": { \\"key2\\": \\"value1\\" } } expected_output = { \\"key1.key2\\": \\"value1\\" } assert flatten_dictionary(input_dict) == expected_output def test_flatten_multiple_nested(): input_dict = { \\"key1\\": { \\"key2\\": { \\"key3\\": { \\"key4\\": \\"value1\\" } }, \\"key5\\": \\"value2\\" }, \\"key6\\": \\"value3\\" } expected_output = { \\"key1.key2.key3.key4\\": \\"value1\\", \\"key1.key5\\": \\"value2\\", \\"key6\\": \\"value3\\" } assert flatten_dictionary(input_dict) == expected_output","solution":"def flatten_dictionary(d): def _flatten(current_key, value, result): if isinstance(value, dict): for k, v in value.items(): new_key = f\\"{current_key}.{k}\\" if current_key else k _flatten(new_key, v, result) else: result[current_key] = value result = {} for key, val in d.items(): _flatten(key, val, result) return result"},{"question":"import pandas as pd import numpy as np import argparse from sklearn.preprocessing import MinMaxScaler def process_csv(input_file, column, output_file): Process a CSV file to: 1. Calculate the mean and median of a specified numerical column. 2. Fill in the missing values in this column with the calculated mean. 3. Normalize the column values to a range between 0 and 1. 4. Save the modified DataFrame to a new CSV file. Args: input_file (str): Path to the input CSV file. column (str): The column name to process. output_file (str): Path to save the modified CSV file. Returns: tuple: Mean and median of the processed column. >>> mean, median = process_csv('test_input.csv', 'A', 'test_output.csv') >>> (mean, median) (3.0, 3) # Placeholder for function implementation def main(): parser = argparse.ArgumentParser(description=\\"Process a CSV file\\") parser.add_argument('input_file', type=str, help='Path to input CSV file') parser.add_argument('column', type=str, help='Column name to process') parser.add_argument('output_file', type=str, help='Path to output CSV file') args = parser.parse_args() process_csv(args.input_file, args.column, args.output_file) if __name__ == \\"__main__\\": main() def test_process_csv(): df = pd.DataFrame({ 'A': [1, 2, np.nan, 4, 5], 'B': [5, np.nan, 7, 8, 10] }) input_path = 'test_input.csv' output_path = 'test_output.csv' column_to_process = 'A' df.to_csv(input_path, index=False) mean, median = process_csv(input_path, column_to_process, output_path) result_df = pd.read_csv(output_path) expected_mean = df['A'].mean() expected_median = df['A'].median() assert mean == expected_mean assert median == expected_median assert not result_df['A'].isna().any() assert result_df['A'].min() == 0 assert result_df['A'].max() == 1 os.remove(input_path) os.remove(output_path) def test_process_csv_column_not_found(): input_path = 'test_input.csv' column_to_process = 'C' output_path = 'test_output.csv' df = pd.DataFrame({ 'A': [1, 2, np.nan, 4, 5], 'B': [5, np.nan, 7, 8, 10] }) df.to_csv(input_path, index=False) try: process_csv(input_path, column_to_process, output_path) except Exception as e: assert str(e) == \\"The column 'C' does not exist in the DataFrame.\\" os.remove(input_path) def test_process_csv_input_file_not_found(): input_path = 'non_existent.csv' column_to_process = 'A' output_path = 'test_output.csv' try: process_csv(input_path, column_to_process, output_path) except Exception as e: assert \\"Error reading the input file\\" in str(e)","solution":"import pandas as pd import numpy as np import argparse from sklearn.preprocessing import MinMaxScaler def process_csv(input_file, column, output_file): # Read CSV file try: df = pd.read_csv(input_file) except Exception as e: raise Exception(f\\"Error reading the input file: {e}\\") # Check if the specified column exists if column not in df.columns: raise Exception(f\\"The column '{column}' does not exist in the DataFrame.\\") # Calculate mean and median of the column mean = df[column].mean() median = df[column].median() # Fill missing values in the column with the mean df[column].fillna(mean, inplace=True) # Normalize the column values to a range between 0 and 1 scaler = MinMaxScaler() df[[column]] = scaler.fit_transform(df[[column]]) # Save the modified DataFrame to a new CSV file try: df.to_csv(output_file, index=False) except Exception as e: raise Exception(f\\"Error writing the output file: {e}\\") return mean, median"},{"question":"--- Implementation approach We will implement an e-commerce platform with functionalities to register or log in with email, create and edit profiles, browse products, add products to a cart, manage the cart, and proceed to checkout. Python package name \\"ecommerce_platform\\" File list [ \\"main.py\\", \\"user.py\\", \\"product.py\\", \\"cart.py\\", \\"checkout.py\\", \\"order_history.py\\" ] Data structures and interface definitions mermaid classDiagram class User{ +str email +str password +str full_name +str address +~register(email: str, password: str) : None +~login(email: str, password: str) : bool +~edit_profile(full_name: str, address: str) : None } class Product{ +int id +str name +str description +float price +~view_product_details() : str } class Cart{ +int user_id +List{Product} items +~add_to_cart(product: Product) : None +~remove_from_cart(product_id: int) : None +~view_cart() : List[Product] } class Checkout{ +int user_id +Cart cart +str payment_method +~proceed_to_checkout() : bool } class OrderHistory{ +int user_id +List{Order} orders +~view_order_history() : List[Order] } User \\"1\\" -- \\"1\\" Cart: has Cart \\"1\\" -- \\"1\\" Checkout: proceeds User \\"1\\" -- \\"1\\" OrderHistory: owns Order \\"1\\" -- \\"1\\" Product: contains Program call flow mermaid sequenceDiagram participant U as User participant S as System U->>S: register(email, password) S->>U: confirmation message U->>S: login(email, password) S->>U: authentication token U->>S: edit_profile(full_name, address) U->>S: browse_product() S->>U: list of products U->>S: view_product_details(product_id) S->>U: product details U->>S: add_to_cart(product_id) U->>S: view_cart() S->>U: cart contents U->>S: proceed_to_checkout(payment_method) S->>U: order confirmation U->>S: view_order_history() S->>U: list of past orders Anything UNCLEAR The requirement is clear to me. --- import pytest from solution import User, Product, Cart, Checkout, OrderHistory def test_user_registration(): user = User(\\"email@example.com\\", \\"password123\\") user.register(\\"email@example.com\\", \\"password123\\") assert user.email == \\"email@example.com\\" assert user.password == \\"password123\\" def test_user_login(): user = User(\\"email@example.com\\", \\"password123\\") assert user.login(\\"email@example.com\\", \\"password123\\") == True assert user.login(\\"wrongemail@example.com\\", \\"password123\\") == False assert user.login(\\"email@example.com\\", \\"wrongpassword\\") == False def test_user_profile_edit(): user = User(\\"email@example.com\\", \\"password123\\") user.edit_profile(\\"John Doe\\", \\"123 Main St\\") assert user.full_name == \\"John Doe\\" assert user.address == \\"123 Main St\\" def test_view_product_details(): product = Product(1, \\"Laptop\\", \\"A high performance laptop\\", 999.99) assert product.view_product_details() == \\"ID: 1, Name: Laptop, Description: A high performance laptop, Price: 999.99\\" def test_cart_operations(): cart = Cart(1) product1 = Product(1, \\"Laptop\\", \\"A high performance laptop\\", 999.99) product2 = Product(2, \\"Mouse\\", \\"A wireless mouse\\", 49.99) cart.add_to_cart(product1) cart.add_to_cart(product2) assert len(cart.view_cart()) == 2 cart.remove_from_cart(2) assert len(cart.view_cart()) == 1 assert cart.view_cart()[0].id == 1 def test_checkout_process(): cart = Cart(1) product = Product(1, \\"Laptop\\", \\"A high performance laptop\\", 999.99) cart.add_to_cart(product) checkout = Checkout(1, cart, \\"Credit Card\\") assert checkout.proceed_to_checkout() == True def test_view_order_history(): order_history = OrderHistory(1) assert order_history.view_order_history() == [] class User: def __init__(self, email, password): self.email = email self.password = password self.full_name = \\"\\" self.address = \\"\\" def register(self, email, password): self.email = email self.password = password def login(self, email, password): return self.email == email and self.password == password def edit_profile(self, full_name, address): self.full_name = full_name self.address = address class Product: def __init__(self, id, name, description, price): self.id = id self.name = name self.description = description self.price = price def view_product_details(self): return f\\"ID: {self.id}, Name: {self.name}, Description: {self.description}, Price: {self.price}\\" class Cart: def __init__(self, user_id): self.user_id = user_id self.items = [] def add_to_cart(self, product): self.items.append(product) def remove_from_cart(self, product_id): self.items = [item for item in self.items if item.id != product_id] def view_cart(self): return self.items class Checkout: def __init__(self, user_id, cart, payment_method): self.user_id = user_id self.cart = cart self.payment_method = payment_method def proceed_to_checkout(self): # Mimic successful checkout process return True class OrderHistory: def __init__(self, user_id): self.user_id = user_id self.orders = [] def view_order_history(self): return self.orders","solution":"class User: def __init__(self, email, password): self.email = email self.password = password self.full_name = \\"\\" self.address = \\"\\" def register(self, email, password): self.email = email self.password = password def login(self, email, password): return self.email == email and self.password == password def edit_profile(self, full_name, address): self.full_name = full_name self.address = address class Product: def __init__(self, id, name, description, price): self.id = id self.name = name self.description = description self.price = price def view_product_details(self): return f\\"ID: {self.id}, Name: {self.name}, Description: {self.description}, Price: {self.price}\\" class Cart: def __init__(self, user_id): self.user_id = user_id self.items = [] def add_to_cart(self, product): self.items.append(product) def remove_from_cart(self, product_id): self.items = [item for item in self.items if item.id != product_id] def view_cart(self): return self.items class Checkout: def __init__(self, user_id, cart, payment_method): self.user_id = user_id self.cart = cart self.payment_method = payment_method def proceed_to_checkout(self): # Mimic successful checkout process return True class OrderHistory: def __init__(self, user_id): self.user_id = user_id self.orders = [] def view_order_history(self): return self.orders"},{"question":"def valid_math_expression(s: str) -> bool: Determines if a given string is a valid mathematical expression. A valid mathematical expression includes numbers, operators (+, -, *, /), and parentheses, and must be properly formatted. >>> valid_math_expression(\\"3+5*2-(4/2)\\") True >>> valid_math_expression(\\"10 / (2 + 3)\\") True >>> valid_math_expression(\\"2.5 * 4.0 - 3.2\\") True >>> valid_math_expression(\\"\\") False >>> valid_math_expression(\\"3++5\\") False >>> valid_math_expression(\\"3+*5\\") False >>> valid_math_expression(\\"3.14.5 + 2\\") False >>> valid_math_expression(\\"1 + 2)\\") False >>> valid_math_expression(\\"(1 + 2\\") False >>> valid_math_expression(\\"00 + 1\\") False >>> valid_math_expression(\\"2..5 + 2\\") False >>> valid_math_expression(\\"3a + 2\\") False >>> valid_math_expression(\\"0\\") True >>> valid_math_expression(\\"3+(5*2)-(4/2)\\") True >>> valid_math_expression(\\"5/(10-5)\\") True >>> valid_math_expression(\\"*3+5\\") False >>> valid_math_expression(\\"3+5/\\") False >>> valid_math_expression(\\"3*-5\\") False >>> valid_math_expression(\\"(3+5\\") False >>> valid_math_expression(\\"(3+5)*\\") False","solution":"import re def valid_math_expression(s): Determines if a given string is a valid mathematical expression. A valid mathematical expression includes numbers, operators (+, -, *, /), and parentheses, and must be properly formatted. # Check for invalid characters if re.search(r'[^0-9+-*/(). ]', s): return False # Check for empty string or invalid start/end characters if not s or s[0] in '*/)' or s[-1] in '+*/-(': return False # Check for leading zeros in numbers if re.search(r'b0[0-9]', s): return False # Check for operators without numbers around them if re.search(r'[+-*/]{2,}', s) or re.search(r'[+-*/][+-*/]', s): return False # Check for misplaced periods if re.search(r'.[^0-9]', s) or re.search(r'[0-9].[0-9]*.', s): return False # Check for balanced parentheses stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() if stack: return False return True"},{"question":"import numpy as np import random def initialize_population(pop_size, chromosome_length): Initialize the population with random chromosomes. Each chromosome is binary encoded. pass def decode_chromosome(chromosome): Decode the binary chromosome to a float value in the range [0, 1]. pass def fitness_function(x): The fitness function to be maximized: f(x) = x * sin(10 * pi * x) + 1. pass def evaluate_population(population): Evaluate the entire population and return their fitness scores. pass def select_parents(population, fitness): Select parents using roulette wheel selection. pass def crossover(parent1, parent2): Perform single point crossover between two parents. pass def mutate(chromosome, mutation_rate): Perform mutation on a chromosome with the given mutation rate. pass def genetic_algorithm(pop_size=100, chromosome_length=10, generations=50, mutation_rate=0.01): Genetic Algorithm to maximize the function f(x) = x * sin(10 * pi * x) + 1. pass","solution":"import numpy as np import random def initialize_population(pop_size, chromosome_length): Initialize the population with random chromosomes. Each chromosome is binary encoded. return np.random.randint(2, size=(pop_size, chromosome_length)) def decode_chromosome(chromosome): Decode the binary chromosome to a float value in the range [0, 1]. binary_string = ''.join(map(str, chromosome)) return int(binary_string, 2) / (2**len(chromosome) - 1) def fitness_function(x): The fitness function to be maximized: f(x) = x * sin(10 * pi * x) + 1. return x * np.sin(10 * np.pi * x) + 1 def evaluate_population(population): Evaluate the entire population and return their fitness scores. return np.array([fitness_function(decode_chromosome(individual)) for individual in population]) def select_parents(population, fitness): Select parents using roulette wheel selection. total_fitness = np.sum(fitness) selection_probs = fitness / total_fitness return population[np.random.choice(len(population), size=len(population), p=selection_probs)] def crossover(parent1, parent2): Perform single point crossover between two parents. point = random.randint(1, len(parent1) - 1) child1 = np.concatenate((parent1[:point], parent2[point:])) child2 = np.concatenate((parent2[:point], parent1[point:])) return child1, child2 def mutate(chromosome, mutation_rate): Perform mutation on a chromosome with the given mutation rate. for i in range(len(chromosome)): if random.random() < mutation_rate: chromosome[i] = 1 - chromosome[i] # Flip the bit return chromosome def genetic_algorithm(pop_size=100, chromosome_length=10, generations=50, mutation_rate=0.01): Genetic Algorithm to maximize the function f(x) = x * sin(10 * pi * x) + 1. population = initialize_population(pop_size, chromosome_length) for generation in range(generations): fitness = evaluate_population(population) population = select_parents(population, fitness) # Crossover next_population = [] for i in range(0, pop_size, 2): parent1, parent2 = population[i], population[i+1] child1, child2 = crossover(parent1, parent2) next_population.extend([child1, child2]) # Mutation population = np.array([mutate(individual, mutation_rate) for individual in next_population]) # Find and return best solution fitness = evaluate_population(population) best_index = np.argmax(fitness) best_chromosome = population[best_index] best_solution = decode_chromosome(best_chromosome) best_fitness = fitness[best_index] return best_solution, best_fitness"},{"question":"import statistics from collections import Counter from typing import List, Union, Dict def list_statistics(lst: List[int]) -> Union[str, Dict[str, Union[int, float, List[int]]]]: Write a function that takes a list of integers as input and returns a dictionary with statistics about the list. The dictionary should contain the following keys and values: 1. \\"mean\\": the average of the integers in the list. 2. \\"median\\": the median value of the integers in the list. 3. \\"mode\\": the mode of the integers in the list. If there are multiple modes, return a list of all modes, sorted in ascending order. 4. \\"variance\\": the variance of the integers in the list. 5. \\"standard_deviation\\": the standard deviation of the integers in the list. Ensure the function handles edge cases appropriately. >>> list_statistics([]) \\"Error: The list is empty\\" >>> list_statistics([10]) {'mean': 10, 'median': 10, 'mode': [10], 'variance': 0, 'standard_deviation': 0} >>> list_statistics([5, 5, 5, 5, 5]) {'mean': 5, 'median': 5, 'mode': [5], 'variance': 0, 'standard_deviation': 0} >>> list_statistics([1, 2, 3, 4, 4, 5, 5, 6, 7]) {'mean': 4.11, 'median': 4, 'mode': [4, 5], 'variance': 4.33, 'standard_deviation': 2.08} >>> list_statistics([1, 2, 3, 4, 5]) {'mean': 3, 'median': 3, 'mode': [1, 2, 3, 4, 5], 'variance': 2.5, 'standard_deviation': 1.58}","solution":"import statistics import math from collections import Counter def list_statistics(lst): if not lst: return \\"Error: The list is empty\\" stats = {} stats['mean'] = statistics.mean(lst) stats['median'] = statistics.median(lst) counts = Counter(lst) max_count = max(counts.values()) mode_list = [k for k, v in counts.items() if v == max_count] stats['mode'] = sorted(mode_list) stats['variance'] = statistics.variance(lst) if len(lst) > 1 else 0 stats['standard_deviation'] = statistics.stdev(lst) if len(lst) > 1 else 0 return stats"},{"question":"import numpy as np import pandas as pd from sklearn.metrics.pairwise import cosine_similarity class RestaurantRecommender: def __init__(self, ratings): self.ratings = ratings self.user_similarity = None self.restaurants_mean_ratings = None def fit(self): Fit the recommendation model based on the ratings data. pass # Implement model fitting logic here def recommend(self, user_id, top_n=3): Recommend top N restaurants for the given user based on similar user preferences. Args: user_id (int): ID of the user for whom to recommend restaurants. top_n (int): Number of top recommendations to return, default is 3. Returns: list: List of recommended restaurant IDs. Raises: ValueError: If the model has not been fit yet. KeyError: If the user_id is not found in the user similarity matrix. pass # Implement recommendation logic here # Unit Tests def get_test_data(): return [ {'user_id': 1, 'restaurant_id': 101, 'rating': 5}, {'user_id': 1, 'restaurant_id': 102, 'rating': 3}, {'user_id': 2, 'restaurant_id': 101, 'rating': 4}, {'user_id': 2, 'restaurant_id': 103, 'rating': 2}, {'user_id': 3, 'restaurant_id': 101, 'rating': 3}, {'user_id': 3, 'restaurant_id': 104, 'rating': 5}, {'user_id': 4, 'restaurant_id': 102, 'rating': 4}, {'user_id': 4, 'restaurant_id': 103, 'rating': 4}, {'user_id': 5, 'restaurant_id': 104, 'rating': 3}, {'user_id': 5, 'restaurant_id': 105, 'rating': 5} ] def test_recommendations(): ratings = get_test_data() recommender = RestaurantRecommender(ratings) recommender.fit() recommended_restaurants = recommender.recommend(user_id=1, top_n=3) assert isinstance(recommended_restaurants, list) assert len(recommended_restaurants) == 3 for restaurant_id in recommended_restaurants: assert isinstance(restaurant_id, int) def test_invalid_user(): ratings = get_test_data() recommender = RestaurantRecommender(ratings) recommender.fit() with pytest.raises(KeyError): recommender.recommend(user_id=999, top_n=3) def test_unfit_model(): ratings = get_test_data() recommender = RestaurantRecommender(ratings) with pytest.raises(ValueError): recommender.recommend(user_id=1, top_n=3)","solution":"import numpy as np import pandas as pd from sklearn.metrics.pairwise import cosine_similarity from sklearn.impute import SimpleImputer class RestaurantRecommender: def __init__(self, ratings): self.ratings = ratings self.user_similarity = None self.restaurants_mean_ratings = None def fit(self): ratings_df = pd.DataFrame(self.ratings) pivot_table = ratings_df.pivot(index='user_id', columns='restaurant_id', values='rating').fillna(0) self.user_similarity = cosine_similarity(pivot_table) self.user_similarity_df = pd.DataFrame(self.user_similarity, index=pivot_table.index, columns=pivot_table.index) self.restaurants_mean_ratings = pivot_table.mean(axis=0) def recommend(self, user_id, top_n=3): if self.user_similarity is None: raise ValueError(\\"Model has not been fit yet.\\") similar_users = self.user_similarity_df[user_id].sort_values(ascending=False) similar_users = similar_users[similar_users.index != user_id] similar_ratings = pd.DataFrame(self.ratings) similar_ratings = similar_ratings[similar_ratings['user_id'].isin(similar_users.index)] avg_rating = similar_ratings.groupby('restaurant_id')['rating'].mean() recommendations = avg_rating.sort_values(ascending=False).head(top_n) return recommendations.index.tolist() # Example usage: # ratings = [ # {'user_id': 1, 'restaurant_id': 101, 'rating': 5}, # {'user_id': 1, 'restaurant_id': 102, 'rating': 3}, # {'user_id': 2, 'restaurant_id': 101, 'rating': 4}, # {'user_id': 2, 'restaurant_id': 103, 'rating': 2}, # {'user_id': 3, 'restaurant_id': 101, 'rating': 3}, # {'user_id': 3, 'restaurant_id': 104, 'rating': 5}, # # more ratings... # ] # recommender = RestaurantRecommender(ratings) # recommender.fit() # print(recommender.recommend(user_id=1))"},{"question":"import pandas as pd import numpy as np import matplotlib.pyplot as plt from scipy.stats import zscore from typing import Dict def read_data(filepath: str) -> pd.DataFrame: Reads data from a CSV file. Parameters: filepath (str): Path to the CSV file. Returns: pd.DataFrame: DataFrame containing the data. pass def clean_data(df: pd.DataFrame) -> pd.DataFrame: Cleans the data by handling missing values and normalizing fields. Parameters: df (pd.DataFrame): Raw data DataFrame. Returns: pd.DataFrame: Cleaned data DataFrame. pass def analyze_data(df: pd.DataFrame) -> Dict: Performs advanced analytics on the data. Parameters: df (pd.DataFrame): Cleaned and normalized data DataFrame. Returns: dict: A dictionary with correlation matrix and outliers indices. pass def visualize_data(df: pd.DataFrame, analysis_results: Dict) -> None: Visualizes data trends using plots. Parameters: df (pd.DataFrame): Cleaned and normalized data DataFrame. analysis_results (dict): Analysis results containing correlation matrix and outliers. Returns: None pass def main(filepath: str) -> None: The main function to run the data processing pipeline. Parameters: filepath (str): Path to the CSV file. Returns: None pass if __name__ == \\"__main__\\": # Example usage # main('path/to/large_dataset.csv') pass","solution":"import pandas as pd import numpy as np import matplotlib.pyplot as plt from scipy.stats import zscore def read_data(filepath): Reads data from a CSV file. Parameters: filepath (str): Path to the CSV file. Returns: pd.DataFrame: DataFrame containing the data. return pd.read_csv(filepath) def clean_data(df): Cleans the data by handling missing values and normalizing fields. Parameters: df (pd.DataFrame): Raw data DataFrame. Returns: pd.DataFrame: Cleaned data DataFrame. # Handle missing values: drop rows with any missing value df_cleaned = df.dropna() # Normalize data: assuming all columns are numeric df_normalized = df_cleaned.apply(zscore) return df_normalized def analyze_data(df): Performs advanced analytics on the data. Parameters: df (pd.DataFrame): Cleaned and normalized data DataFrame. Returns: dict: A dictionary with correlation matrix and outliers indices. analysis_results = {} # Calculate correlation matrix correlation_matrix = df.corr() analysis_results['correlation_matrix'] = correlation_matrix # Detect outliers using Z-score z_scores = np.abs(df.apply(zscore)) outliers = (z_scores > 3) # Z-score threshold for outlier detection analysis_results['outliers'] = np.where(outliers) return analysis_results def visualize_data(df, analysis_results): Visualizes data trends using plots. Parameters: df (pd.DataFrame): Cleaned and normalized data DataFrame. analysis_results (dict): Analysis results containing correlation matrix and outliers. Returns: None # Plot correlation matrix as heatmap plt.figure(figsize=(10, 8)) plt.imshow(analysis_results['correlation_matrix'], cmap='hot', interpolation='nearest') plt.colorbar() plt.title(\\"Correlation Matrix Heatmap\\") plt.show() # Visualize outliers for outlier in zip(*analysis_results['outliers']): plt.figure() plt.plot(df.iloc[outlier[0]]) plt.title(f\\"Outlier at index {outlier[0]}, Column {df.columns[outlier[1]]}\\") plt.show() def main(filepath): The main function to run the data processing pipeline. Parameters: filepath (str): Path to the CSV file. Returns: None df = read_data(filepath) df_cleaned = clean_data(df) analysis_results = analyze_data(df_cleaned) visualize_data(df_cleaned, analysis_results) # Example usage # main('path/to/large_dataset.csv')"},{"question":"def merge_sorted_arrays(arr1, arr2): Merges two sorted lists into a single sorted list in O(n) time. Args: arr1 (list of int): The first sorted list. arr2 (list of int): The second sorted list. Returns: list of int: A single merged and sorted list. Example: >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1], [2]) [1, 2] >>> merge_sorted_arrays([], []) []","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted lists into a single sorted list in O(n) time. Args: arr1 (list of int): The first sorted list. arr2 (list of int): The second sorted list. Returns: list of int: A single merged and sorted list. merged_array = [] i, j = 0, 0 n1, n2 = len(arr1), len(arr2) while i < n1 and j < n2: if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Append any remaining elements of arr1 while i < n1: merged_array.append(arr1[i]) i += 1 # Append any remaining elements of arr2 while j < n2: merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def highest_average_student(students): Finds the student with the highest average score. If multiple students have the same average, returns the name that comes first alphabetically. >>> highest_average_student([{'name': 'Alice', 'scores': [100, 100, 100]}]) 'Alice' >>> highest_average_student([ { 'name': 'Alice', 'scores': [90, 80, 85] }, { 'name': 'Bob', 'scores': [85, 85, 86] }, { 'name': 'Charlie', 'scores': [90, 95, 87] } ]) 'Charlie' >>> highest_average_student([ { 'name': 'Alice', 'scores': [80, 90] }, { 'name': 'Bob', 'scores': [70, 100] } ]) 'Alice' >>> highest_average_student([]) None >>> highest_average_student([ { 'name': 'Alice', 'scores': [0, 0, 0] }, { 'name': 'Bob', 'scores': [0, 0, 0] } ]) 'Alice'","solution":"def highest_average_student(students): Finds the student with the highest average score. If multiple students have the same average, returns the name that comes first alphabetically. if not students: return None highest_avg = float('-inf') best_student = None for student in students: avg_score = sum(student['scores']) / len(student['scores']) if avg_score > highest_avg or (avg_score == highest_avg and student['name'] < best_student): highest_avg = avg_score best_student = student['name'] return best_student"},{"question":"def first_non_repeating_character(string: str) -> str: Returns the first non-repeating character in the given string. If all characters are repeating, returns None. >>> first_non_repeating_character(\\"\\") is None >>> first_non_repeating_character(\\"aabbcc\\") is None >>> first_non_repeating_character(\\"a\\") == 'a' >>> first_non_repeating_character(\\"abacabad\\") == 'c' >>> first_non_repeating_character(\\"aabbccddeef\\") == 'f' >>> first_non_repeating_character(\\"fabcdea\\") == 'f' >>> first_non_repeating_character(\\"aabbccd\\") == 'd' # Write your code here","solution":"def first_non_repeating_character(string): Returns the first non-repeating character in the given string. If all characters are repeating, returns None. from collections import Counter # Count the occurrences of each character in the string char_count = Counter(string) # Find the first character that has a count of 1 for char in string: if char_count[char] == 1: return char # If no non-repeating character is found, return None return None"},{"question":"def max_increasing_streak(scores: List[int]) -> int: Create a function in Python that accepts a list of integers representing the scores of games played by a player. The function should return the maximum streak of consecutively increasing scores. >>> max_increasing_streak([10, 20, 30, 15, 25, 35]) 3 >>> max_increasing_streak([10, 9, 8, 7, 6]) 1 >>> max_increasing_streak([1, 2, 3, 4, 5, 6]) 6 >>> max_increasing_streak([]) 0 >>> max_increasing_streak([42]) 1 >>> max_increasing_streak([1, 2, 1, 2, 1, 2]) 2 >>> max_increasing_streak(list(range(100000))) 100000","solution":"def max_increasing_streak(scores): This function accepts a list of integers representing scores of games played by a player. It returns the maximum streak of consecutively increasing scores. :param scores: List[int] - a list of integers (scores) :return: int - the length of the longest streak of increasing scores if not scores: return 0 max_streak = 1 current_streak = 1 for i in range(1, len(scores)): if scores[i] > scores[i - 1]: current_streak += 1 else: max_streak = max(max_streak, current_streak) current_streak = 1 max_streak = max(max_streak, current_streak) return max_streak"},{"question":"def canSegment(s: str, dict: set) -> bool: Determines if the string s can be segmented into a space-separated sequence of one or more dictionary words. Args: s (str): The input string to segment. dict (set): A set containing all dictionary words. Returns: bool: True if the string can be segmented, otherwise False. >>> canSegment(\\"leetcode\\", {\\"leet\\", \\"code\\"}) True >>> canSegment(\\"applepenapple\\", {\\"apple\\", \\"pen\\"}) True >>> canSegment(\\"catsandog\\", {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"}) False >>> canSegment(\\"apple\\", {\\"apple\\"}) True >>> canSegment(\\"apple\\", {\\"pen\\"}) False >>> canSegment(\\"banana\\", {\\"apple\\", \\"orange\\", \\"grape\\"}) False >>> canSegment(\\"applepie\\", {\\"apple\\", \\"pie\\", \\"applepie\\"}) True >>> canSegment(\\"aaaaaaa\\", {\\"a\\", \\"aa\\", \\"aaa\\"}) True","solution":"def canSegment(s, dict): Determines if the string s can be segmented into a space-separated sequence of one or more dictionary words. Args: s: str - The input string to segment. dict: set of str - A set containing all dictionary words. Returns: bool - True if the string can be segmented, otherwise False. n = len(s) dp = [False] * (n + 1) dp[0] = True # Base case: empty string is always segmentable for i in range(1, n + 1): for j in range(i): if dp[j] and s[j:i] in dict: dp[i] = True break return dp[-1]"},{"question":"from typing import List def longest_substring_without_repeating_characters(s: str) -> int: Finds the length of the longest substring without repeating characters. Args: s (str): The input string containing only lowercase letters. Returns: int: The length of the longest substring without repeating characters. pass def test_longest_substring_without_repeating_characters(): assert longest_substring_without_repeating_characters('') == 0 assert longest_substring_without_repeating_characters('aaaa') == 1 assert longest_substring_without_repeating_characters('abcde') == 5 assert longest_substring_without_repeating_characters('abcabcbb') == 3 assert longest_substring_without_repeating_characters('pwwkew') == 3 assert longest_substring_without_repeating_characters(' ') == 1 assert longest_substring_without_repeating_characters('dvdf') == 3 assert longest_substring_without_repeating_characters('aab') == 2 assert longest_substring_without_repeating_characters('abcdefg') == 7 assert longest_substring_without_repeating_characters(\\"anviaj\\") == 5","solution":"def longest_substring_without_repeating_characters(s): Finds the length of the longest substring without repeating characters. Args: s (str): The input string containing only lowercase letters. Returns: int: The length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 char_index_map = {} longest = 0 start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end longest = max(longest, end - start + 1) return longest"},{"question":"import csv def compute_average(file_path, column_name): Compute the average value of a specified column in a CSV file. The function should skip rows with missing or malformed data in the specified column. Handle exceptions and potential errors while reading the file and parsing data, ensuring the calculated average is accurate after handling these cases. >>> compute_average(\\"data.csv\\", \\"age\\") :param file_path: Path to the CSV file :param column_name: Name of the column to compute the average for :return: The average value of the column, or None if there was an error reading the file try: with open(file_path, mode='r', newline='') as csvfile: reader = csv.DictReader(csvfile) total = 0 count = 0 for row in reader: try: # Skip malformed or missing data value = float(row[column_name]) total += value count += 1 except (ValueError, KeyError): continue if count == 0: return 0 # Handle case where no valid data was found return total / count except (FileNotFoundError, IOError) as e: print(f\\"Error reading file: {e}\\") return None # Example usage: file_path = \\"<ENTER FILE PATH HERE>\\" column_name = \\"<ENTER COLUMN NAME HERE>\\" average = compute_average(file_path, column_name) if average is not None: print(f\\"The average value of column '{column_name}' is {average}\\") else: print(f\\"Could not compute the average due to file error\\")","solution":"import csv def compute_average(file_path, column_name): try: with open(file_path, mode='r', newline='') as csvfile: reader = csv.DictReader(csvfile) total = 0 count = 0 for row in reader: try: # Skip malformed or missing data value = float(row[column_name]) total += value count += 1 except (ValueError, KeyError): continue if count == 0: return 0 # Handle case where no valid data was found return total / count except (FileNotFoundError, IOError) as e: print(f\\"Error reading file: {e}\\") return None file_path = \\"<ENTER FILE PATH HERE>\\" column_name = \\"<ENTER COLUMN NAME HERE>\\" average = compute_average(file_path, column_name) if average is not None: print(f\\"The average value of column '{column_name}' is {average}\\") else: print(f\\"Could not compute the average due to file error\\")"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if a string can be rearranged to form a palindrome. Ignore spaces and treat uppercase and lowercase letters as equal. Args: s (str): The input string. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. Examples: >>> can_form_palindrome('Tact Coa') True >>> can_form_palindrome('hello') False >>> can_form_palindrome('civic') True >>> can_form_palindrome('abcdef') False def test_can_form_palindrome(): assert can_form_palindrome('a') == True assert can_form_palindrome('civic') == True assert can_form_palindrome('hello') == False assert can_form_palindrome('Aba') == True assert can_form_palindrome('Tact Coa') == True assert can_form_palindrome('abcdef') == False assert can_form_palindrome('aabbcc') == True assert can_form_palindrome('aabbc') == True","solution":"def can_form_palindrome(s): Determines if a string can be rearranged to form a palindrome. Ignore spaces and treat uppercase and lowercase letters as equal. Args: s (str): The input string. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. # Create a dictionary to count occurrences of each character char_count = {} for char in s: if char == ' ': continue char = char.lower() if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Count the number of characters with an odd number of occurrences odd_count = 0 for count in char_count.values(): if count % 2 == 1: odd_count += 1 if odd_count > 1: return False return True"},{"question":"def process_order(items: List[Dict[str, Union[str, float, int]]]) -> Dict[str, Union[float, List[Dict[str, Union[str, float, int]]]]]: Processes an order for an online store. Parameters: items (list of dict): A list of dictionaries where each dictionary represents an item with 'name', 'price', and 'quantity' keys. Returns: dict: A summary of the order, including initial total price, any discounts applied, and the final total price. from typing import List, Dict, Union def test_single_item_no_discount(): items = [{'name': 'item1', 'price': 10.0, 'quantity': 2}] result = process_order(items) assert result['initial_total_price'] == 20.0 assert result['discounts'] == 0.0 assert result['final_total_price'] == 20.0 assert len(result['items']) == 1 assert result['items'][0]['free_items'] == 0 def test_multiple_items_no_discount(): items = [{'name': 'item1', 'price': 15.0, 'quantity': 1}, {'name': 'item2', 'price': 20.0, 'quantity': 2}] result = process_order(items) assert result['initial_total_price'] == 55.0 assert result['discounts'] == 0.0 assert result['final_total_price'] == 55.0 assert len(result['items']) == 2 def test_threshold_discount(): items = [{'name': 'item1', 'price': 50.0, 'quantity': 3}] result = process_order(items) assert result['initial_total_price'] == 150.0 assert result['discounts'] == 15.0 assert result['final_total_price'] == 135.0 assert len(result['items']) == 1 def test_buy_3_get_1_free(): items = [{'name': 'item1', 'price': 10.0, 'quantity': 4}] result = process_order(items) assert result['initial_total_price'] == 30.0 assert result['discounts'] == 0.0 assert result['final_total_price'] == 30.0 assert len(result['items']) == 1 assert result['items'][0]['free_items'] == 1 def test_combined_discounts(): items = [{'name': 'item1', 'price': 30.0, 'quantity': 8}] # should charge for 6, get 2 free result = process_order(items) assert result['initial_total_price'] == 180.0 # should apply 10% discount assert result['discounts'] == 18.0 assert result['final_total_price'] == 162.0 assert len(result['items']) == 1 assert result['items'][0]['free_items'] == 2 import pytest pytest.main()","solution":"def process_order(items): Processes an order for an online store. Parameters: items (list of dict): A list of dictionaries where each dictionary represents an item with 'name', 'price', and 'quantity' keys. Returns: dict: A summary of the order, including initial total price, any discounts applied, and the final total price. threshold_for_discount = 100.00 order_summary = { 'items': [], 'initial_total_price': 0.0, 'discounts': 0.0, 'final_total_price': 0.0 } for item in items: name = item['name'] price = item['price'] quantity = item['quantity'] # Apply \\"buy 3, get 1 free\\" offer free_items = quantity // 4 paid_quantity = quantity - free_items cost = paid_quantity * price order_summary['items'].append({ 'name': name, 'price_per_item': price, 'quantity': quantity, 'free_items': free_items, 'total_cost': cost }) order_summary['initial_total_price'] += cost # Apply 10% discount if threshold is exceeded if order_summary['initial_total_price'] > threshold_for_discount: discount = 0.10 * order_summary['initial_total_price'] order_summary['discounts'] += discount order_summary['final_total_price'] = order_summary['initial_total_price'] - order_summary['discounts'] return order_summary"},{"question":"def rotate_matrix_90_clockwise(matrix): Rotates the given NxN matrix 90 degrees clockwise in-place. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix_90_clockwise(matrix) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ] >>> rotate_matrix_90_clockwise(matrix) [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ]","solution":"def rotate_matrix_90_clockwise(matrix): Rotates the given N x N matrix 90 degrees clockwise in-place. N = len(matrix) for layer in range(N // 2): first = layer last = N - 1 - layer for i in range(first, last): offset = i - first top = matrix[first][i] # save top # left -> top matrix[first][i] = matrix[last - offset][first] # bottom -> left matrix[last - offset][first] = matrix[last][last - offset] # right -> bottom matrix[last][last - offset] = matrix[i][last] # top -> right matrix[i][last] = top # right <- saved top return matrix"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Given an array of integers \`nums\` and an integer \`target\`, return the indices of the two numbers such that they add up to the target. Args: nums (List[int]): List of integers. target (int): The target integer. Returns: List[int]: Indices of the two numbers that add up to \`target\`. pass # Example usage: # >>> two_sum([2, 7, 11, 15], 9) # [0, 1] # >>> two_sum([3, 2, 4], 6) # [1, 2] # >>> two_sum([3, 3], 6) # [0, 1] # Unit Tests def test_two_sum(): assert two_sum([2, 7, 11, 15], 9) == [0, 1] assert two_sum([3, 2, 4], 6) == [1, 2] assert two_sum([3, 3], 6) == [0, 1] assert two_sum([1, 2, 3, 4, 5], 9) == [3, 4] assert two_sum([0, 4, 3, 0], 0) == [0, 3] assert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4] def test_with_large_input(): nums = list(range(1, 10001)) assert two_sum(nums, 19999) == [9998, 9999] # The last two numbers in the range. def test_edge_cases(): assert two_sum([5, 1, -7, 3, 7], 0) == [2, 4] assert two_sum([-5, 5, 10], 0) == [0, 1]","solution":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Given an array of integers \`nums\` and an integer \`target\`, return the indices of the two numbers such that they add up to the target. Args: nums (List[int]): List of integers. target (int): The target integer. Returns: List[int]: Indices of the two numbers that add up to \`target\`. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index"},{"question":"def retrieve_shared_keys(dict1, dict2): Returns a new dictionary containing key-value pairs where the keys are common to both input dictionaries. The values in the new dictionary are tuples with the first element being from dict1 and the second from dict2. >>> retrieve_shared_keys({'a': 1, 'b': 2, 'c': 3}, {'b': 3, 'c': 4, 'd': 5}) {\\"b\\": (2, 3), \\"c\\": (3, 4)} >>> retrieve_shared_keys({'e': 5, 'f': 6}, {'g': 7, 'h': 8}) {} >>> retrieve_shared_keys({}, {}) {} >>> retrieve_shared_keys({'a': 1, 'b': 2}, {}) {} >>> retrieve_shared_keys({'a': 1, 'b': 2, 'c': 3}, {'a': 1, 'b': 2, 'c': 3}) {\\"a\\": (1, 1), \\"b\\": (2, 2), \\"c\\": (3, 3)} >>> retrieve_shared_keys({'a': 1, 'b': 2, 'c': 3, 'e': 5}, {'b': 3, 'c': 4, 'd': 5}) {\\"b\\": (2, 3), \\"c\\": (3, 4)}","solution":"def retrieve_shared_keys(dict1, dict2): Returns a new dictionary containing key-value pairs where the keys are common to both input dictionaries. The values in the new dictionary are tuples with the first element being from dict1 and the second from dict2. result = {} for key in dict1: if key in dict2: result[key] = (dict1[key], dict2[key]) return result"},{"question":"def first_non_repeating_character(s: str) -> str: Write a function that takes a string as input and returns the first non-repeating character in it. If all characters are repeating or the string is empty, return an underscore. The function should be case-sensitive. >>> first_non_repeating_character(\\"swiss\\") 'w' >>> first_non_repeating_character(\\"aabbcc\\") '_' >>> first_non_repeating_character(\\"\\") '_' >>> first_non_repeating_character(\\"abcdabc\\") 'd' >>> first_non_repeating_character(\\"ab c ab\\") 'c' >>> first_non_repeating_character(\\"aA\\") 'a' >>> first_non_repeating_character(\\"x\\") 'x' >>> first_non_repeating_character(\\"a@&a\\") '@' >>> first_non_repeating_character(\\"racecar\\") 'e'","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If all characters are repeating or the string is empty, returns an underscore. The function is case-sensitive. char_count = {} # Count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first non-repeating character for char in s: if char_count[char] == 1: return char return '_'"},{"question":"from typing import List def count_clusters(L: List[int]) -> int: Count the number of clusters in the list L. A cluster is defined as a contiguous subarray where all elements are identical. Parameters: L (list): A list of integers. Returns: int: The number of clusters in the list. >>> count_clusters([]) 0 >>> count_clusters([5]) 1 >>> count_clusters([1, 1, 1, 1, 1]) 1 >>> count_clusters([1, 2, 3, 4, 5]) 5 >>> count_clusters([1, 2, 2, 2, 3, 3, 4]) 4 >>> count_clusters([1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5]) 5 >>> count_clusters([1] * 50000 + [2] * 50000) 2","solution":"def count_clusters(L): Count the number of clusters in the list L. A cluster is defined as a contiguous subarray where all elements are identical. Parameters: L (list): A list of integers. Returns: int: The number of clusters in the list. if not L: return 0 clusters = 1 for i in range(1, len(L)): if L[i] != L[i - 1]: clusters += 1 return clusters"},{"question":"def infix_to_postfix(expression: str) -> str: Convert a given string containing a mathematical expression in infix notation into postfix notation (Reverse Polish Notation). The input string will consist of single-digit numbers and operators \`+\`, \`-\`, \`*\`, and \`/\`. The function should return the postfix expression as a string. >>> infix_to_postfix(\\"3+4\\") == \\"34+\\" >>> infix_to_postfix(\\"3+4*2\\") == \\"342*+\\" >>> infix_to_postfix(\\"3+4-2\\") == \\"34+2-\\" >>> infix_to_postfix(\\"3+4*2-1\\") == \\"342*+1-\\" >>> infix_to_postfix(\\"6/2+3\\") == \\"62/3+\\" >>> infix_to_postfix(\\"3*4/2\\") == \\"34*2/\\" >>> infix_to_postfix(\\"3+4*2/1-5\\") == \\"342*1/+5-\\" >>> infix_to_postfix(\\"2+3*4-5/6\\") == \\"234*+56/-\\" >>> infix_to_postfix(\\"4*3-2+1\\") == \\"43*2-1+\\"","solution":"def infix_to_postfix(expression: str) -> str: precedence = {'+': 1, '-': 1, '*': 2, '/': 2} output = [] stack = [] for char in expression: if char.isdigit(): output.append(char) elif char in precedence: while stack and precedence.get(stack[-1], 0) >= precedence[char]: output.append(stack.pop()) stack.append(char) while stack: output.append(stack.pop()) return ''.join(output)"},{"question":"def find_item_location(inventory: dict, barcode: str): Given an inventory dictionary and a barcode, find the row and slot where the item with the barcode is located. :param inventory: Dictionary with row identifiers as keys and dictionaries as values. Inner dictionaries have slot identifiers as keys and barcodes as values. :param barcode: String representing the barcode of the item to find. :return: Tuple (row_identifier, slot_identifier) if the item is found, otherwise \\"Item not found\\". >>> inventory = { ... 'row1': {1: 'abc123', 2: 'def456', 3: 'ghi789'}, ... 'row2': {1: 'xyz123', 2: 'uvw456', 3: 'rst789'} ... } >>> find_item_location(inventory, 'uvw456') ('row2', 2) >>> find_item_location(inventory, 'nop012') \\"Item not found\\"","solution":"def find_item_location(inventory, barcode): Given an inventory dictionary and a barcode, find the row and slot where the item with the barcode is located. :param inventory: Dictionary with row identifiers as keys and dictionaries as values. Inner dictionaries have slot identifiers as keys and barcodes as values. :param barcode: String representing the barcode of the item to find. :return: Tuple (row_identifier, slot_identifier) if the item is found, otherwise \\"Item not found\\". for row_identifier, slots in inventory.items(): for slot_identifier, item_barcode in slots.items(): if item_barcode == barcode: return (row_identifier, slot_identifier) return \\"Item not found\\""},{"question":"def square_numbers(nums): Refactor this function to use the 'map' function instead of a 'for' loop. This function returns a list of the squares of the numbers in the input list. >>> square_numbers([1, 2, 3, 4]) [1, 4, 9, 16] >>> square_numbers([]) [] >>> square_numbers([-1, -2, -3]) [1, 4, 9] >>> square_numbers([-3, 0, 2, 5]) [9, 0, 4, 25]","solution":"def square_numbers(nums): Returns a list of the squares of the numbers in the input list. return list(map(lambda num: num ** 2, nums))"},{"question":"def find_unique_element(arr: List[int]) -> int: Given an array of integers, where every element appears twice except for one, which appears exactly once. This function finds that single, unique element. Ensure the solution with linear runtime complexity and constant space complexity. >>> find_unique_element([2, 2, 1]) 1 >>> find_unique_element([4, 1, 2, 1, 2]) 4","solution":"def find_unique_element(arr): Finds the single unique element in the array where every element appears twice except for one. unique_element = 0 for num in arr: unique_element ^= num # XOR operation return unique_element"},{"question":"def count_occurrences(lst: List[int]) -> Dict[int, int]: Takes a list of integers and returns a dictionary where the keys are the integers, and the values are the number of times each integer appears in the list. >>> count_occurrences([]) == {} >>> count_occurrences([5]) == {5: 1} >>> count_occurrences([1, 2, 2, 3, 3, 3]) == {1: 1, 2: 2, 3: 3} >>> count_occurrences([4, 4, 4, 4, 4]) == {4: 5} >>> count_occurrences([10, 10, 20, 30, 10, 20]) == {10: 3, 20: 2, 30: 1}","solution":"def count_occurrences(lst): Takes a list of integers and returns a dictionary where the keys are the integers, and the values are the number of times each integer appears in the list. occurrences = {} for num in lst: if num in occurrences: occurrences[num] += 1 else: occurrences[num] = 1 return occurrences"},{"question":"def find_common_elements(list1: list, list2: list) -> list: Returns a list of the common elements between list1 and list2 in ascending order without duplicates. Raises TypeError if inputs are not lists of integers. >>> find_common_elements([4, 5, 7, 1, 4, 3], [0, 3, 4, 6, 7, 3]) [3, 4, 7] >>> find_common_elements([10, 12, 14], [1, 2, 3]) [] >>> find_common_elements([4, 5, \\"a\\", 1], [0, 3, 4, 6, 7]) TypeError: Both inputs must be lists of integers. # Your code here","solution":"def find_common_elements(list1: list, list2: list) -> list: Returns a list of the common elements between list1 and list2 in ascending order without duplicates. Raises TypeError if inputs are not lists of integers. if not all(isinstance(i, int) for i in list1) or not all(isinstance(i, int) for i in list2): raise TypeError(\\"Both inputs must be lists of integers.\\") common_elements = set(list1).intersection(set(list2)) return sorted(common_elements)"},{"question":"def generate_permutations(s: str) -> list: Generate all unique permutations of a given string. :param s: The input string. :return: A list of unique permutations. >>> sorted(generate_permutations(\\"AAB\\")) ['AAB', 'ABA', 'BAA'] >>> generate_permutations(\\"A\\") ['A'] >>> generate_permutations(\\"\\") [\\"\\"] >>> generate_permutations(\\"AAA\\") ['AAA'] >>> sorted(generate_permutations(\\"ABC\\")) ['ABC', 'ACB', 'BAC', 'BCA', 'CAB', 'CBA']","solution":"def generate_permutations(s: str) -> list: Generate all unique permutations of a given string. :param s: The input string. :return: A list of unique permutations. def permute(path, counter): if len(path) == len(s): result.append(\\"\\".join(path)) return for char in counter: if counter[char] > 0: path.append(char) counter[char] -= 1 permute(path, counter) path.pop() counter[char] += 1 result = [] counter = {char: s.count(char) for char in set(s)} permute([], counter) return result"},{"question":"def next_greater_element(arr: List[int]) -> List[int]: Write a Python function that takes an integer array as input and returns an array containing the next greater element for each element in the input array. If there is no greater element, put -1 for that index. >>> next_greater_element([4, 5, 2, 10]) [5, 10, 10, -1] >>> next_greater_element([1, 2, 3, 4]) [2, 3, 4, -1]","solution":"def next_greater_element(arr): result = [-1] * len(arr) stack = [] for i in range(len(arr)): while stack and arr[stack[-1]] < arr[i]: result[stack.pop()] = arr[i] stack.append(i) return result"},{"question":"def sum_dict_values(input_dict): Accepts a dictionary where keys are strings and values are lists of integers, and returns a new dictionary where each key is mapped to the sum of its corresponding list of integers. :param input_dict: Dictionary (str -> list of int) :return: Dictionary (str -> int) pass # Test cases for the function def test_sum_dict_values(): # Example test case assert sum_dict_values({'a': [1, 2, 3], 'b': [4, 5], 'c': [6]}) == {'a': 6, 'b': 9, 'c': 6} # Test case with empty lists assert sum_dict_values({'a': [], 'b': [0], 'c': []}) == {'a': 0, 'b': 0, 'c': 0} # Test case with positive and negative numbers assert sum_dict_values({'a': [1, -2, 3], 'b': [4, -5], 'c': [-6]}) == {'a': 2, 'b': -1, 'c': -6} # Test case with all zeros assert sum_dict_values({'a': [0, 0, 0], 'b': [0, 0], 'c': [0]}) == {'a': 0, 'b': 0, 'c': 0} # Test case with single element lists assert sum_dict_values({'a': [10], 'b': [20], 'c': [30]}) == {'a': 10, 'b': 20, 'c': 30} def test_sum_dict_values_empty_dict(): # Test case with empty input dictionary assert sum_dict_values({}) == {}","solution":"def sum_dict_values(input_dict): Accepts a dictionary where keys are strings and values are lists of integers, and returns a new dictionary where each key is mapped to the sum of its corresponding list of integers. :param input_dict: Dictionary (str -> list of int) :return: Dictionary (str -> int) return {key: sum(value) for key, value in input_dict.items()}"},{"question":"def find_target_indices(arr, target): Returns a list of indices where the target string appears in the input array of strings. If the target string is not found, returns [-1]. Handles invalid inputs by returning [-1]. >>> find_target_indices([\\"apple\\", \\"banana\\", \\"apple\\", \\"cherry\\"], \\"apple\\") [0, 2] >>> find_target_indices([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"orange\\") [-1] >>> find_target_indices([\\"apple\\", 123, \\"banana\\"], \\"apple\\") [-1] >>> find_target_indices([\\"apple\\", \\"banana\\"], 123) [-1] >>> find_target_indices([], \\"apple\\") [-1] >>> find_target_indices([\\"\\", \\"banana\\", \\"\\"], \\"\\") [0, 2]","solution":"def find_target_indices(arr, target): Returns a list of indices where the target string appears in the input array of strings. If the target string is not found, returns [-1]. Handles invalid inputs by returning [-1]. if not isinstance(target, str) or not all(isinstance(item, str) for item in arr): return [-1] indices = [i for i, val in enumerate(arr) if val == target] return indices if indices else [-1]"},{"question":"def sort_dict_by_values(d): Sort the given dictionary by its values in descending order. Raises a ValueError if the input is not a dictionary or if its values are not all integers. Parameters: d (dict): The input dictionary Returns: dict: A new dictionary sorted by values in descending order >>> sort_dict_by_values({'a': 2, 'b': 3, 'c': 1}) {'b': 3, 'a': 2, 'c': 1} >>> sort_dict_by_values({'a': 0, 'b': -1, 'c': 1}) {'c': 1, 'a': 0, 'b': -1} >>> sort_dict_by_values({'a': 3, 'b': 1, 'c': 3}) {'a': 3, 'c': 3, 'b': 1} >>> sort_dict_by_values({}) {} >>> sort_dict_by_values({'a': 1}) {'a': 1} >>> sort_dict_by_values([('a', 2), ('b', 3)]) Traceback (most recent call last): ... ValueError: Input must be a dictionary >>> sort_dict_by_values({'a': 2, 'b': 'three', 'c': 1}) Traceback (most recent call last): ... ValueError: All values in the dictionary must be integers","solution":"def sort_dict_by_values(d): Sort the given dictionary by its values in descending order. Raises a ValueError if the input is not a dictionary or if its values are not all integers. Parameters: d (dict): The input dictionary Returns: dict: A new dictionary sorted by values in descending order if not isinstance(d, dict): raise ValueError(\\"Input must be a dictionary\\") for value in d.values(): if not isinstance(value, int): raise ValueError(\\"All values in the dictionary must be integers\\") return dict(sorted(d.items(), key=lambda item: item[1], reverse=True))"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression provided as a string and returns the result. This function handles the operators '+', '-', '*', and '/' and ignores any whitespace. Parameters: expression (str): The mathematical expression to evaluate. Returns: float: The result of the evaluated expression. Examples: >>> evaluate_expression(\\"3 + 4\\") 7.0 >>> evaluate_expression(\\" 3 + 4 \\") 7.0 >>> evaluate_expression(\\"3 + 5 / 2 - 1\\") 5.5 >>> evaluate_expression(\\"3 * 2\\") 6.0 >>> evaluate_expression(\\" 3 * 2 \\") 6.0 >>> evaluate_expression(\\"8 / 2\\") 4.0 >>> evaluate_expression(\\"3 + 5 * 2 - 8 / 4\\") 9.0 >>> evaluate_expression(\\"1 + 2 - 3 * 4 / 2\\") -3.0 >>> evaluate_expression(\\"-5 + 3\\") -2.0 >>> evaluate_expression(\\"(3 + 5) * 2\\") 16.0","solution":"def evaluate_expression(expression): Evaluates a mathematical expression provided as a string and returns the result. This function handles the operators '+', '-', '*', and '/' and ignores any whitespace. Parameters: expression (str): The mathematical expression to evaluate. Returns: float: The result of the evaluated expression. try: return eval(expression) except Exception as e: raise ValueError(f\\"Invalid expression: {expression}. Error: {e}\\")"},{"question":"def longest_distinct_substring(s: str) -> str: Returns the longest substring with all distinct characters. >>> longest_distinct_substring(\\"abcdef\\") == \\"abcdef\\" >>> longest_distinct_substring(\\"abcabcbb\\") == \\"abc\\" >>> longest_distinct_substring(\\"bbbbb\\") == \\"b\\" >>> longest_distinct_substring(\\"pwwkew\\") == \\"wke\\" >>> longest_distinct_substring(\\"abcbdaacb\\") == \\"cbda\\" >>> longest_distinct_substring(\\"\\") == \\"\\" >>> longest_distinct_substring(\\"a\\") == \\"a\\" >>> input_string = \\"abcdefghijklmnopqrstuvwxyz\\" * 1000 >>> longest_distinct_substring(input_string) == \\"abcdefghijklmnopqrstuvwxyz\\"","solution":"def longest_distinct_substring(s): Returns the longest substring with all distinct characters. char_index_map = {} longest = 0 start = 0 longest_substr = \\"\\" for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end if end - start + 1 > longest: longest = end - start + 1 longest_substr = s[start:end+1] return longest_substr"},{"question":"def matrix_multiplication(A, B): Returns the result of matrix multiplication of A and B. Parameters: A (list of list of int/float): The first matrix (m x n) B (list of list of int/float): The second matrix (n x p) Returns: list of list of int/float: The resulting matrix (m x p) Raises: ValueError: If the matrices cannot be multiplied due to incompatible dimensions Examples: >>> matrix_multiplication([[1, 2], [3, 4]], [[5, 6], [7, 8]]) [[19, 22], [43, 50]] >>> matrix_multiplication([[2]], [[3]]) [[6]] >>> try: ... matrix_multiplication([[1, 2]], [[1, 2]]) ... except ValueError as e: ... print(str(e)) \\"Matrices have incompatible dimensions for multiplication\\" >>> try: ... matrix_multiplication([], [[1]]) ... except ValueError as e: ... print(str(e)) \\"Matrices cannot be empty\\" >>> matrix_multiplication([[1, 2, 3]], [[4], [5], [6]]) [[32]]","solution":"def matrix_multiplication(A, B): Returns the result of matrix multiplication of A and B. Parameters: A (list of list of int/float): The first matrix (m x n) B (list of list of int/float): The second matrix (n x p) Returns: list of list of int/float: The resulting matrix (m x p) Raises: ValueError: If the matrices cannot be multiplied due to incompatible dimensions if not A or not B or not A[0] or not B[0]: raise ValueError(\\"Matrices cannot be empty\\") m = len(A) n = len(A[0]) if len(B) != n: raise ValueError(\\"Matrices have incompatible dimensions for multiplication\\") p = len(B[0]) # Initialize the result matrix with zeros C = [[0 for _ in range(p)] for _ in range(m)] for i in range(m): for j in range(p): for k in range(n): C[i][j] += A[i][k] * B[k][j] return C"},{"question":"def sort_dict_values_desc(input_dict): Takes a dictionary with string keys and list of integers as values, and returns a new dictionary with the same keys, where each integer list is sorted in descending order if the list contains 3 or more integers. pass # Test Cases def test_sort_lists_with_more_than_3_elements(): input_data = {'a': [5, 2, 9, 1], 'b': [8, 6, 7, 3]} expected_output = {'a': [9, 5, 2, 1], 'b': [8, 7, 6, 3]} assert sort_dict_values_desc(input_data) == expected_output def test_leave_short_lists_unchanged(): input_data = {'a': [2], 'b': [5, 1], 'c': [9, 3, 7]} expected_output = {'a': [2], 'b': [5, 1], 'c': [9, 7, 3]} assert sort_dict_values_desc(input_data) == expected_output def test_mixed_length_lists(): input_data = {'a': [5, 2, 9, 1], 'b': [3], 'c': [8, 6, 4, 2]} expected_output = {'a': [9, 5, 2, 1], 'b': [3], 'c': [8, 6, 4, 2]} assert sort_dict_values_desc(input_data) == expected_output def test_empty_dictionary(): input_data = {} expected_output = {} assert sort_dict_values_desc(input_data) == expected_output def test_all_short_lists(): input_data = {'a': [1], 'b': [2]} expected_output = {'a': [1], 'b': [2]} assert sort_dict_values_desc(input_data) == expected_output def test_lists_with_exactly_3_elements(): input_data = {'a': [5, 2, 9], 'b': [3, 8, 1]} expected_output = {'a': [9, 5, 2], 'b': [8, 3, 1]} assert sort_dict_values_desc(input_data) == expected_output","solution":"def sort_dict_values_desc(input_dict): Takes a dictionary with string keys and list of integers as values, and returns a new dictionary with the same keys, where each integer list is sorted in descending order if the list contains 3 or more integers. output_dict = {} for key, value in input_dict.items(): if len(value) >= 3: output_dict[key] = sorted(value, reverse=True) else: output_dict[key] = value return output_dict"},{"question":"def squared_elements(numbers: List[int]) -> List[int]: Write a Python function \`squared_elements\` that accepts a list of integers and returns a new list containing the squares of each element from the input list. The function should not use any built-in functions or list comprehensions for squaring the elements. Instead, it should use a loop to iterate through the list and manually compute the square of each element. Additionally, ensure the function handles the case where the input list is empty, returning an empty list in such cases. >>> squared_elements([1, 2, 3, 4]) [1, 4, 9, 16] >>> squared_elements([-1, -2, -3, -4]) [1, 4, 9, 16] >>> squared_elements([-1, 0, 1, 2]) [1, 0, 1, 4] >>> squared_elements([]) [] >>> squared_elements([10]) [100] # Your code here","solution":"def squared_elements(numbers): Returns a new list containing the squares of each element from the input list. Args: numbers (list): A list of integers. Returns: list: A list containing the squares of the input integers. squared_numbers = [] for number in numbers: squared_numbers.append(number * number) return squared_numbers"},{"question":"[Completion Task in Python] def remove_k_characters(s: str, k: int) -> str: Returns the lexicographically smallest string after removing k characters from the input string s. >>> remove_k_characters(\\"acdb\\", 1) \\"acb\\" >>> remove_k_characters(\\"abcde\\", 2) \\"abc\\" >>> remove_k_characters(\\"aaaa\\", 2) \\"aa\\" >>> remove_k_characters(\\"abcd\\", 4) \\"\\" >>> remove_k_characters(\\"abcd\\", 0) \\"abcd\\" >>> remove_k_characters(\\"dcba\\", 3) \\"a\\" >>> remove_k_characters(\\"dbcafe\\", 4) \\"ae\\" >>> remove_k_characters(\\"bbbbb\\", 3) \\"bb\\" >>> remove_k_characters(\\"cba\\" * 1000, 2000) \\"a\\" * 1000","solution":"def remove_k_characters(s, k): Returns the lexicographically smallest string after removing k characters from the input string s. stack = [] for char in s: while k > 0 and stack and stack[-1] > char: stack.pop() k -= 1 stack.append(char) # If k is still greater than 0, remove from the end return ''.join(stack[:len(stack) - k])"},{"question":"def get_values_by_key(dict_list, key): Returns a list of values associated with the given key from each dictionary in the input list. If a dictionary does not contain the given key, it will be skipped. >>> get_values_by_key([ {\\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"name\\": \\"Bob\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 25} ], \\"age\\") [30, 25] >>> get_values_by_key([ {\\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"name\\": \\"Bob\\", \\"age\\": 40} ], \\"name\\") [\\"Alice\\", \\"Bob\\"] >>> get_values_by_key([], \\"age\\") [] >>> get_values_by_key([ {\\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"name\\": \\"Charlie\\", \\"age\\": 25} ], \\"salary\\") [] >>> get_values_by_key([ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 25, \\"city\\": \\"San Francisco\\"} ], \\"city\\") [\\"New York\\", \\"San Francisco\\"]","solution":"def get_values_by_key(dict_list, key): Returns a list of values associated with the given key from each dictionary in the input list. If a dictionary does not contain the given key, it will be skipped. :param dict_list: List of dictionaries :param key: Key to look for :return: List of values associated with the given key return [d[key] for d in dict_list if key in d]"},{"question":"def rearrange_negatives_before_positives(arr): Rearranges elements in the array such that all negative numbers appear before the positive numbers. The relative order of negative numbers and positive numbers is maintained. This function does not use extra space and works in O(n) time complexity. :param arr: List of integers :return: The array rearranged with negatives before positives, in-place >>> rearrange_negatives_before_positives([-1, -2, -3]) == [-1, -2, -3] >>> rearrange_negatives_before_positives([1, 2, 3]) == [1, 2, 3] >>> rearrange_negatives_before_positives([1, -2, -3, 4]) == [-2, -3, 1, 4] >>> rearrange_negatives_before_positives([-1, 2, -3, 4]) == [-1, -3, 2, 4] >>> rearrange_negatives_before_positives([-1, 1, -2, 2, -3, 3]) == [-1, -2, -3, 1, 2, 3] >>> rearrange_negatives_before_positives([-1, 0, 1, -2, 2]) == [-1, -2, 0, 1, 2] >>> rearrange_negatives_before_positives([4, -1, -3, 2, -1, 2]) == [-1, -3, -1, 4, 2, 2]","solution":"def rearrange_negatives_before_positives(arr): Rearranges elements in the array such that all negative numbers appear before the positive numbers. The relative order of negative numbers and positive numbers is maintained. This function does not use extra space and works in O(n) time complexity. :param arr: List of integers :return: The array rearranged with negatives before positives, in-place n = len(arr) j = 0 # This will indicate the position where the next negative number should go for i in range(n): if arr[i] < 0: arr.insert(j, arr.pop(i)) j += 1 return arr"},{"question":"def longest_string_length(lst: list) -> int: Write a function that accepts a list of strings and returns the length of the longest string in the list. Ignores non-string elements. If the list is empty, returns 0. >>> longest_string_length([\\"apple\\", 123, \\"banana\\", None, \\"carrot\\", 456.789]) 6 >>> longest_string_length([\\"apple\\", \\"banana\\", \\"peach\\"]) 6 >>> longest_string_length([]) 0 >>> longest_string_length([1, 2, 3, 4.5, None, {}]) 0 >>> longest_string_length([\\"onlyone\\"]) 7","solution":"def longest_string_length(lst): Returns the length of the longest string in the list. Ignores non-string elements. if not lst: return 0 max_length = 0 for item in lst: if isinstance(item, str): max_length = max(max_length, len(item)) return max_length"},{"question":"import requests def fetch_weather(city_name): Fetches the current weather data for a given city and returns a formatted string with the temperature, humidity, and weather condition. Handles HTTP and connection errors gracefully, including invalid city names. Args: city_name (str): Name of the city to fetch the weather for. Returns: str: Formatted weather information or an error message. Example: >>> print(fetch_weather(\\"London\\")) Weather in London: Temperature: 25C Humidity: 60% Condition: Clear sky >>> print(fetch_weather(\\"InvalidCity\\")) Error: city not found from unit_test import fetch_weather import requests import pytest from unittest.mock import patch def test_fetch_weather_valid_city(): test_data = { \\"weather\\": [{\\"description\\": \\"clear sky\\"}], \\"main\\": {\\"temp\\": 25, \\"humidity\\": 60}, \\"cod\\": 200 } with patch('requests.get') as mock_get: mock_get.return_value.status_code = 200 mock_get.return_value.json.return_value = test_data result = fetch_weather(\\"London\\") assert \\"Weather in London:\\" in result assert \\"Temperature: 25C\\" in result assert \\"Humidity: 60%\\" in result assert \\"Condition: Clear sky\\" in result def test_fetch_weather_invalid_city(): test_data = { \\"cod\\": \\"404\\", \\"message\\": \\"city not found\\" } with patch('requests.get') as mock_get: mock_get.return_value.status_code = 404 mock_get.return_value.json.return_value = test_data result = fetch_weather(\\"InvalidCity\\") assert \\"Error: city not found\\" in result def test_fetch_weather_connection_error(): with patch('requests.get', side_effect=requests.exceptions.ConnectionError): result = fetch_weather(\\"London\\") assert \\"Error: Unable to fetch weather data.\\" in result","solution":"import requests def fetch_weather(city_name): Fetches the current weather data for a given city and returns a formatted string with the temperature, humidity, and weather condition. api_key = 'your_api_key_here' # replace with your actual API key base_url = f\\"http://api.openweathermap.org/data/2.5/weather?q={city_name}&appid={api_key}&units=metric\\" try: response = requests.get(base_url) response.raise_for_status() except requests.exceptions.RequestException as e: return f\\"Error: Unable to fetch weather data. {e}\\" data = response.json() if data.get(\\"cod\\") != 200: return f\\"Error: {data.get('message', 'Invalid city name')}\\" weather_desc = data[\\"weather\\"][0][\\"description\\"] temperature = data[\\"main\\"][\\"temp\\"] humidity = data[\\"main\\"][\\"humidity\\"] formatted_data = (f\\"Weather in {city_name.capitalize()}:n\\" f\\"Temperature: {temperature}Cn\\" f\\"Humidity: {humidity}%n\\" f\\"Condition: {weather_desc.capitalize()}\\") return formatted_data"},{"question":"def min_deletions_to_make_strings_same(str1: str, str2: str) -> int: Return the minimum number of deletions required to make two strings the same. >>> min_deletions_to_make_strings_same(\\"sea\\", \\"eat\\") == 2 >>> min_deletions_to_make_strings_same(\\"abc\\", \\"ac\\") == 1 >>> min_deletions_to_make_strings_same(\\"leetcode\\", \\"etco\\") == 4 >>> min_deletions_to_make_strings_same(\\"abcd\\", \\"abcd\\") == 0 >>> min_deletions_to_make_strings_same(\\"abc\\", \\"def\\") == 6 >>> min_deletions_to_make_strings_same(\\"abc\\", \\"\\") == 3 >>> min_deletions_to_make_strings_same(\\"\\", \\"def\\") == 3 >>> min_deletions_to_make_strings_same(\\"abcfgh\\", \\"abdfgh\\") == 2","solution":"def min_deletions_to_make_strings_same(str1, str2): Return the minimum number of deletions required to make two strings the same. # Find the length of the longest common subsequence def longest_common_subsequence(str1, str2): m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] lcs_length = longest_common_subsequence(str1, str2) # Minimum deletions to make the strings the same return (len(str1) - lcs_length) + (len(str2) - lcs_length)"},{"question":"def pairwise_sum_even_indices(list1, list2): Returns a new list containing pairwise sums of elements from list1 and list2 but only at even indices. If the two lists are of different lengths, truncate the longer list to the length of the shorter one. >>> pairwise_sum_even_indices([1, 2, 3, 4], [5, 6, 7, 8]) [6, 10] >>> pairwise_sum_even_indices([1, 2, 3, 4, 5], [5, 6, 7]) [6, 10] >>> pairwise_sum_even_indices([2], [3]) [5] >>> pairwise_sum_even_indices([], []) [] >>> pairwise_sum_even_indices([1, 2], [3, 4, 5, 6]) [4] >>> pairwise_sum_even_indices([1, 3, 5], [2, 4, 6]) [3, 11]","solution":"def pairwise_sum_even_indices(list1, list2): Returns a new list containing pairwise sums of elements from list1 and list2 but only at even indices. If the two lists are of different lengths, truncate the longer list to the length of the shorter one. min_length = min(len(list1), len(list2)) truncated_list1 = list1[:min_length] truncated_list2 = list2[:min_length] result = [] for i in range(0, min_length, 2): result.append(truncated_list1[i] + truncated_list2[i]) return result"},{"question":"def divisor_pairs(n: int) -> List[Tuple[int, int]]: Given an integer \`n\`, returns a list of tuples where each tuple contains two positive integers \`(a, b)\` such that \`a * b = n\` and \`a <= b\`. The list should be of tuples sorted in ascending order by the first element of each tuple. >>> divisor_pairs(16) [(1, 16), (2, 8), (4, 4)] >>> divisor_pairs(13) [(1, 13)] >>> divisor_pairs(1) [(1, 1)] >>> divisor_pairs(25) [(1, 25), (5, 5)] >>> divisor_pairs(100) [(1, 100), (2, 50), (4, 25), (5, 20), (10, 10)] >>> divisor_pairs(60) [(1, 60), (2, 30), (3, 20), (4, 15), (5, 12), (6, 10)]","solution":"def divisor_pairs(n): Returns a list of tuples where each tuple contains two positive integers \`(a, b)\` such that \`a * b = n\` and \`a <= b\`. result = [] for a in range(1, int(n**0.5) + 1): if n % a == 0: b = n // a if a <= b: result.append((a, b)) return result"},{"question":"def manipulate_list(lst: List[int]) -> List[int]: Manipulates a list of integers by sorting, removing duplicates, and reversing. Parameters: lst (list of int): The list of integers to manipulate. Returns: list of int: The manipulated list. >>> manipulate_list([]) == [] >>> manipulate_list([1]) == [1] >>> manipulate_list([1, 2, 3]) == [3, 2, 1] >>> manipulate_list([4, 6, 2, 4, 3, 3, 1]) == [6, 4, 3, 2, 1] >>> manipulate_list([5, 5, 5, 5, 5]) == [5] >>> manipulate_list([10, -1, 2, 10, -1, 3, -2]) == [10, 3, 2, -1, -2]","solution":"def manipulate_list(lst): Manipulates a list of integers by sorting, removing duplicates, and reversing. Parameters: lst (list of int): The list of integers to manipulate. Returns: list of int: The manipulated list. # Step 1: Sort the list in ascending order sorted_lst = sorted(lst) # Step 2: Remove all duplicate elements from the list unique_lst = list(dict.fromkeys(sorted_lst)) # Step 3: Reverse the sorted list reversed_lst = unique_lst[::-1] return reversed_lst # Example usage: # sample_list = [4, 6, 2, 4, 3, 3, 1] # print(manipulate_list(sample_list)) # Output should be [6, 4, 3, 2, 1]"},{"question":"import typing from typing import List def manage_queue(operations: List[str], capacity: int) -> List[int]: Manages a limited capacity queue system based on the given operations. Parameters: operations (list): A list of operations to be performed on the queue. capacity (int): The maximum capacity of the queue. Returns: list: The state of the queue after all operations have been performed. >>> manage_queue([\\"ENQUEUE 1\\", \\"LIST\\"], 3) == [1] >>> manage_queue([\\"ENQUEUE 1\\", \\"ENQUEUE 2\\", \\"ENQUEUE 3\\", \\"LIST\\"], 3) == [1, 2, 3] >>> manage_queue([\\"ENQUEUE 1\\", \\"ENQUEUE 2\\", \\"DEQUEUE\\", \\"LIST\\"], 3) == [2] >>> manage_queue([\\"ENQUEUE 1\\", \\"ENQUEUE 2\\", \\"ENQUEUE 3\\", \\"ENQUEUE 4\\", \\"LIST\\"], 3) == [1, 2, 3] >>> manage_queue([\\"ENQUEUE 1\\", \\"ENQUEUE 2\\", \\"ENQUEUE 3\\", \\"DEQUEUE\\", \\"ENQUEUE 4\\", \\"LIST\\"], 3) == [2, 3, 4] >>> manage_queue([\\"DEQUEUE\\", \\"LIST\\"], 3) == [] >>> manage_queue([], 3) == [] >>> manage_queue([\\"ENQUEUE 1\\", \\"ENQUEUE 2\\", \\"DEQUEUE\\", \\"ENQUEUE 3\\", \\"DEQUEUE\\", \\"ENQUEUE 4\\", \\"LIST\\"], 3) == [3, 4]","solution":"def manage_queue(operations, capacity): Manages a limited capacity queue system based on the given operations. Parameters: operations (list): A list of operations to be performed on the queue. capacity (int): The maximum capacity of the queue. Returns: list: The state of the queue after all operations have been performed. queue = [] for operation in operations: if operation.startswith(\\"ENQUEUE\\"): _, x = operation.split() if len(queue) < capacity: queue.append(int(x)) elif operation == \\"DEQUEUE\\": if queue: queue.pop(0) elif operation == \\"LIST\\": return queue return queue"},{"question":"def three_sum(nums: List[int]) -> List[List[int]]: Given a list of integers, returns a list of unique triplets that sum up to zero. Each triplet is sorted in ascending order, and the returned list does not contain duplicate triplets. Args: nums (List[int]): A list of integers. Returns: List[List[int]]: A list of unique triplets that sum up to zero. >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([1, 2, 3, 4, 5]) [] >>> three_sum([0, -1, 1]) [[-1, 0, 1]] >>> three_sum([-1, 0, 1, 2, -1, -4, -2, 2, 2]) [[-4, 2, 2], [-2, 0, 2], [-1, -1, 2], [-1, 0, 1]] >>> three_sum([1, 2, -2, -1]) [] >>> three_sum([0, 0, 0, 0]) [[0, 0, 0]]","solution":"def three_sum(nums): Given a list of integers, returns a list of unique triplets that sum up to zero. Parameters: nums (list): List of integers. Returns: list: List of unique triplets that sum up to zero. nums.sort() result = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, len(nums) - 1 while left < right: s = nums[i] + nums[left] + nums[right] if s == 0: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif s < 0: left += 1 else: right -= 1 return result"},{"question":"def sum_of_squares(N: int) -> int: Returns the sum of squares of the first N natural numbers. >>> sum_of_squares(1) 1 >>> sum_of_squares(4) 30 >>> sum_of_squares(0) 0 >>> sum_of_squares(-5) 0","solution":"def sum_of_squares(N): Returns the sum of squares of the first N natural numbers. return sum(i ** 2 for i in range(1, N + 1))"},{"question":"class Elevator: A class to simulate a basic elevator control system in a multi-story building. >>> elevator = Elevator(max_capacity=5, total_floors=10) >>> elevator.add_request(5) >>> elevator.move() >>> elevator.current_floor 5 >>> elevator = Elevator(max_capacity=5, total_floors=10) >>> elevator.add_passenger(3) >>> elevator.add_passenger(2) >>> elevator.passengers 5 >>> elevator.remove_passenger(1) >>> elevator.passengers 4 >>> elevator = Elevator(max_capacity=5, total_floors=10) >>> elevator.add_request(11) >>> elevator.add_request(0) >>> elevator.requests []","solution":"class Elevator: def __init__(self, max_capacity, total_floors): self.current_floor = 1 self.requests = [] self.max_capacity = max_capacity self.passengers = 0 self.total_floors = total_floors self.emergency_stopped = False def add_request(self, floor): if not self.emergency_stopped and 1 <= floor <= self.total_floors: self.requests.append(floor) self.requests.sort() def move(self): if not self.requests or self.emergency_stopped: return destination = self.requests.pop(0) self.current_floor = destination def add_passenger(self, count=1): if self.passengers + count <= self.max_capacity: self.passengers += count def remove_passenger(self, count=1): if self.passengers >= count: self.passengers -= count def emergency_stop(self): self.emergency_stopped = True def reset_emergency_stop(self): self.emergency_stopped = False"},{"question":"def find_possible_words(words: List[str], target: str) -> List[str]: Develop a function that takes two inputs: a list of words and a string representing a target word. The function should return a list of all words from the original list that can be created by removing one letter from the target word. The returned list should be sorted in ascending order. >>> find_possible_words([\\"cat\\", \\"hat\\", \\"bat\\", \\"at\\", \\"catat\\"], \\"that\\") == [\\"hat\\"] >>> find_possible_words([], \\"that\\") == [] >>> find_possible_words([\\"a\\"], \\"a\\") == [] >>> find_possible_words([\\"cat\\", \\"bat\\", \\"rat\\"], \\"dog\\") == [] >>> find_possible_words([\\"cat\\", \\"hat\\", \\"bat\\"], \\"that\\") == [\\"hat\\"] >>> find_possible_words([\\"cat\\", \\"hat\\", \\"bat\\", \\"tht\\"], \\"that\\") == [\\"hat\\", \\"tht\\"] >>> find_possible_words([\\"cat\\", \\"hat\\", \\"hat\\"], \\"that\\") == [\\"hat\\"] >>> find_possible_words([\\"\\"], \\"a\\") == [] >>> find_possible_words([\\"at\\", \\"tt\\"], \\"ttt\\") == [\\"tt\\"]","solution":"def find_possible_words(words, target): Returns a list of words that can be formed by removing one letter from the target word. if len(target) <= 1 or not words: return [] possible_words = set() for i in range(len(target)): # Generate the word formed when the ith letter is removed new_word = target[:i] + target[i+1:] if new_word in words: possible_words.add(new_word) return sorted(possible_words)"},{"question":"def largestRectangleArea(heights): Calculate the largest rectangular area in a histogram represented by the list of heights. :param heights: List of non-negative integers representing the height of the histogram's bars :return: The largest rectangular area >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([2, 4]) 4 >>> largestRectangleArea([6, 2, 5, 4, 5, 1, 6]) 12","solution":"def largestRectangleArea(heights): Calculate the largest rectangular area in a histogram represented by the list of heights. :param heights: List of non-negative integers representing the height of the histogram's bars :return: The largest rectangular area stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def char_frequency(s: str) -> dict: Calculates the frequency of each character in the given string, ignoring case. Returns a dictionary with characters as keys and their respective counts as values. Args: s (str): Input string whose character frequencies are to be calculated. Returns: dict: A dictionary with characters as keys and their frequencies as values. Examples: >>> char_frequency('Hello World') {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> char_frequency('') {} >>> char_frequency('aaaa') {'a': 4} >>> char_frequency('AaBbCc') {'a': 2, 'b': 2, 'c': 2} >>> char_frequency('Hello, World!') {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1, ',': 1, '!': 1} >>> char_frequency(' ') {}","solution":"def char_frequency(s): Returns a dictionary with the frequency of each character in the string s. The function ignores the case of the characters. Parameters: s (str): The input string whose characters' frequencies are to be calculated. Returns: dict: A dictionary where keys are characters and values are their frequencies. s = s.lower() frequency = {} for char in s: if char != \\" \\": # Ignore spaces if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"from typing import List def is_prime(n: int) -> bool: Determines if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(11) True >>> is_prime(1) False >>> is_prime(75) False def sum_excluding_primes(lst: List[int]) -> int: Returns the sum of the elements in lst excluding any integers that are prime numbers. >>> sum_excluding_primes([4, 6, 8, 10]) 28 >>> sum_excluding_primes([2, 3, 5, 7]) 0 >>> sum_excluding_primes([2, 4, 5, 7, 10, 12]) 26 >>> sum_excluding_primes([]) 0 >>> sum_excluding_primes([4]) 4 >>> sum_excluding_primes([3]) 0","solution":"def is_prime(n): Determines if a number is prime. if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def sum_excluding_primes(lst): Returns the sum of the elements in lst excluding any integers that are prime numbers. return sum(x for x in lst if not is_prime(x))"},{"question":"def longest_subarray_with_threshold(nums: List[int], threshold: int) -> int: Given an array of integers, find the length of the longest subarray in which the absolute difference between any two elements is no greater than the specified threshold. >>> longest_subarray_with_threshold([1], 1) 1 >>> longest_subarray_with_threshold([3, 3, 3, 3], 0) 4 >>> longest_subarray_with_threshold([1, 2, 3, 4, 5], 0) 1 >>> longest_subarray_with_threshold([1, 2, 3, 4, 5], 100) 5 >>> longest_subarray_with_threshold([1, 2, 3, 6, 7, 8], 2) 3 >>> longest_subarray_with_threshold([10, 1, 2, 7, 8, 3], 15) 6 >>> longest_subarray_with_threshold([1, 100, 1, 100, 1], 50) 1","solution":"def longest_subarray_with_threshold(nums, threshold): from collections import deque max_deque, min_deque = deque(), deque() left = 0 longest = 0 for right, num in enumerate(nums): while max_deque and nums[max_deque[-1]] <= num: max_deque.pop() max_deque.append(right) while min_deque and nums[min_deque[-1]] >= num: min_deque.pop() min_deque.append(right) while nums[max_deque[0]] - nums[min_deque[0]] > threshold: left += 1 if max_deque[0] < left: max_deque.popleft() if min_deque[0] < left: min_deque.popleft() longest = max(longest, right - left + 1) return longest"},{"question":"def minimum_difference(nums: List[int]) -> int: Given a list of non-negative integers nums, partition the array into two subsets such that the sum of the elements in both subsets is minimized. Return the minimum possible absolute difference between the sums of the two subsets. >>> minimum_difference([1, 2, 3, 9]) 3 >>> minimum_difference([1, 2, 7, 1, 5]) 0 >>> minimum_difference([2]) 2 >>> minimum_difference([4, 4]) 0 >>> minimum_difference([7, 1]) 6 >>> minimum_difference([100, 99, 98, 100]) 1 >>> minimum_difference([1, 6, 11, 5]) 1","solution":"def minimum_difference(nums): Compute the minimum possible absolute difference between the sums of two subsets. total_sum = sum(nums) n = len(nums) target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] for i in range(target, -1, -1): if dp[i]: return abs(total_sum - 2 * i)"},{"question":"def length_of_longest_substring(s: str) -> int: Write a function that takes a string as input and returns the length of the longest substring without repeating characters. Parameters: s (str): Input string consisting of lowercase letters (a-z). Returns: int: Length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\"a\\") == 1 >>> length_of_longest_substring(\\"au\\") == 2 >>> length_of_longest_substring(\\"dvdf\\") == 3 >>> length_of_longest_substring(\\"aa\\") == 1 >>> length_of_longest_substring(\\"aaaaa\\") == 1 >>> length_of_longest_substring(\\"abcdabcde\\") == 5 >>> length_of_longest_substring(\\"abcdefghijkabcdefghijk\\") == 11 >>> length_of_longest_substring(\\"abacdef\\") == 6 >>> length_of_longest_substring(\\"abcbde\\") == 4","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. Parameters: s (str): Input string consisting of lowercase letters (a-z). Returns: int: Length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 char_map = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_map and char_map[s[end]] >= start: start = char_map[s[end]] + 1 char_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Calculate the maximum profit that can be made by buying and selling the stock exactly once. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"from typing import List def max_profit(prices: List[int]) -> int: if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def separate_and_sort(input_string: str) -> tuple: Separates words and numbers from an input string and returns them sorted. :param input_string: str, a string containing a mix of words and numbers separated by spaces. :return: tuple, (list of words in alphabetical order, list of numbers in numerical order). Examples: >>> separate_and_sort(\\"apple 25 banana 10 22 cherry 15 5\\") (['apple', 'banana', 'cherry'], [5, 10, 15, 22, 25]) >>> separate_and_sort(\\"apple banana cherry\\") (['apple', 'banana', 'cherry'], []) >>> separate_and_sort(\\"25 10 22 15 5\\") ([], [5, 10, 15, 22, 25]) >>> separate_and_sort(\\"\\") ([], []) >>> separate_and_sort(\\"room101 apple2 banana3\\") (['apple2', 'banana3', 'room101'], []) >>> separate_and_sort(\\"1a 1b 2a 3b\\") (['1a', '1b', '2a', '3b'], [])","solution":"def separate_and_sort(input_string): Separates words and numbers from an input string and returns them sorted. :param input_string: str, a string containing a mix of words and numbers separated by spaces. :return: tuple, (list of words in alphabetical order, list of numbers in numerical order). words = [] numbers = [] elements = input_string.split() for element in elements: if element.isdigit(): numbers.append(int(element)) else: words.append(element) words.sort() numbers.sort() return (words, numbers)"},{"question":"def find_prime_factors(n: int) -> list: Returns a list of prime factors of the given integer \`n\` greater than 1, in ascending order. >>> find_prime_factors(18) [2, 3, 3] >>> find_prime_factors(29) [29] >>> find_prime_factors(60) [2, 2, 3, 5]","solution":"def find_prime_factors(n): Returns the list of prime factors of the given integer n. def is_prime(x): if x <= 1: return False for i in range(2, int(x**0.5) + 1): if x % i == 0: return False return True prime_factors = [] # Check for number of 2s in n while n % 2 == 0: prime_factors.append(2) n = n // 2 # Check for odd factors from 3 onwards for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: prime_factors.append(i) n = n // i # This condition is to check if n is a prime number greater than 2 if n > 2: prime_factors.append(n) return prime_factors"},{"question":"def is_valid_schedule(tasks: List[Tuple[int, int]]) -> bool: Determines if a given list of task intervals can all be scheduled without overlap. Parameters: tasks (list of tuples): List of tuples, where each tuple contains two integers representing the start and end times of a task. Returns: bool: True if no tasks overlap, or False otherwise. # Placeholder for the solution pass Example test cases if __name__ == \\"__main__\\": assert is_valid_schedule([]) == True assert is_valid_schedule([(1, 2), (3, 5), (6, 8)]) == True assert is_valid_schedule([(1, 3), (2, 5), (4, 6)]) == False assert is_valid_schedule([(1, 2), (2, 3), (3, 4)]) == True assert is_valid_schedule([(1, 2)]) == True assert is_valid_schedule([(3, 5), (1, 2), (6, 8)]) == True assert is_valid_schedule([(4, 6), (1, 3), (2, 5)]) == False","solution":"def is_valid_schedule(tasks): Determines if a given list of task intervals can all be scheduled without overlap. Parameters: tasks (list of tuples): List of tuples, where each tuple contains two integers representing the start and end times of a task. Returns: bool: True if no tasks overlap, or False otherwise. # Sort tasks based on the start time tasks.sort(key=lambda x: x[0]) for i in range(1, len(tasks)): # If the start time of the current task is less than the end time of the previous task, we have an overlap if tasks[i][0] < tasks[i-1][1]: return False return True"},{"question":"def flatten_and_sort(lst): Write a program to flatten a deeply nested list of integers. Given a list that can contain more lists as elements that themselves can contain integers or more lists and so on, your program should return a flat list of all the integers in non-decreasing order. Example: >>> flatten_and_sort([1, [4, [6, 5], 2], [3, [7]]]) [1, 2, 3, 4, 5, 6, 7] def test_flatten_and_sort(): assert flatten_and_sort([5, 2, 9]) == [2, 5, 9] assert flatten_and_sort([1, [4, [6, 5], 2], [3, [7]]]) == [1, 2, 3, 4, 5, 6, 7] assert flatten_and_sort([]) == [] assert flatten_and_sort([[[[1, 2]]], [3, [[4, 5], 6]], 7]) == [1, 2, 3, 4, 5, 6, 7] assert flatten_and_sort([10, [10, [10, 10], 10], [10, [10]]]) == [10, 10, 10, 10, 10, 10, 10] assert flatten_and_sort([[[5]]]) == [5]","solution":"def flatten_and_sort(lst): def flatten(nested_lst): for item in nested_lst: if isinstance(item, list): yield from flatten(item) else: yield item flat_list = list(flatten(lst)) return sorted(flat_list) # Example usage print(flatten_and_sort([1, [4, [6, 5], 2], [3, [7]]])) # Output: [1, 2, 3, 4, 5, 6, 7]"},{"question":"class BankAccount: A class to simulate a basic bank account with operations for deposit, withdrawal, and transfer, including error handling for invalid operations. >>> account = BankAccount(100) >>> account.get_balance() 100 >>> account.deposit(50) >>> account.get_balance() 150 >>> account.withdraw(50) >>> account.get_balance() 100 >>> account2 = BankAccount(50) >>> account.transfer(50, account2) >>> account.get_balance() 50 >>> account2.get_balance() 100 >>> account.create_account(-100) Traceback (most recent call last): ... ValueError: Initial balance cannot be negative >>> account.deposit(-50) Traceback (most recent call last): ... ValueError: Deposit amount must be positive >>> account.withdraw(200) Traceback (most recent call last): ... ValueError: Insufficient funds def __init__(self, initial_balance=0): pass def deposit(self, amount): pass def withdraw(self, amount): pass def transfer(self, amount, other_account): pass def get_balance(self): pass","solution":"class BankAccount: def __init__(self, initial_balance=0): if initial_balance < 0: raise ValueError(\\"Initial balance cannot be negative.\\") self.balance = initial_balance def deposit(self, amount): if amount <= 0: raise ValueError(\\"Deposit amount must be positive.\\") self.balance += amount def withdraw(self, amount): if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive.\\") if amount > self.balance: raise ValueError(\\"Insufficient funds.\\") self.balance -= amount def transfer(self, amount, other_account): if amount <= 0: raise ValueError(\\"Transfer amount must be positive.\\") if amount > self.balance: raise ValueError(\\"Insufficient funds.\\") self.balance -= amount other_account.deposit(amount) def get_balance(self): return self.balance"},{"question":"def multiples_of_n(nums: List[int], n: int) -> List[int]: Returns a list of integers that are multiples of n from the input list nums. Args: nums (list): List of integers. n (int): The multiple to check for. Returns: list: A list of integers that are multiples of n. >>> multiples_of_n([12, -24, 35, 70, 50, 91], 5) [35, 70, 50] >>> multiples_of_n([12, -24, 35, 70, 50, 91], 1) [12, -24, 35, 70, 50, 91] >>> multiples_of_n([-12, -24, 35, -70, 50, -91], -5) [35, -70, 50] >>> multiples_of_n([10, 20, 30, 40], 10) [10, 20, 30, 40] >>> multiples_of_n([10, 20, 30, 40], 20) [20, 40] >>> multiples_of_n([], 5) [] pass","solution":"def multiples_of_n(nums, n): Returns a list of integers that are multiples of n from the input list nums. Args: nums (list): List of integers. n (int): The multiple to check for. Returns: list: A list of integers that are multiples of n. if not isinstance(n, int) or n == 0: return [] if not all(isinstance(x, int) for x in nums): raise ValueError(\\"All elements in the input list must be integers.\\") return [x for x in nums if x % n == 0]"},{"question":"from typing import List def sum_with_neighbors(nums: List[int]) -> List[int]: Given a list of integers, returns a new list where each element is the sum of that element and its neighbors in the original list. For elements at the beginning or end of the list, treat missing neighbors as zero. :param nums: List of integers :return: List of integers >>> sum_with_neighbors([1, 2, 3, 4, 5]) [3, 6, 9, 12, 9] >>> sum_with_neighbors([7]) [7] >>> sum_with_neighbors([]) [] >>> sum_with_neighbors([1, 2]) [3, 3] >>> sum_with_neighbors([-1, -2, -3, -4, -5]) [-3, -6, -9, -12, -9] >>> sum_with_neighbors([1, -2, 3, -4, 5]) [-1, 2, -3, 4, 1]","solution":"def sum_with_neighbors(nums): Given a list of integers, returns a new list where each element is the sum of that element and its neighbors in the original list. For elements at the beginning or end of the list, treat missing neighbors as zero. :param nums: List of integers :return: List of integers if not nums: return [] result = [] n = len(nums) for i in range(n): left = nums[i - 1] if i - 1 >= 0 else 0 right = nums[i + 1] if i + 1 < n else 0 current_sum = left + nums[i] + right result.append(current_sum) return result"},{"question":"import math from typing import List def factorial(n: int) -> int: Compute the factorial of n. >>> factorial(0) == 1 >>> factorial(1) == 1 >>> factorial(5) == 120 >>> factorial(10) == 3628800 >>> factorial(-5) Traceback (most recent call last): ... ValueError: Factorial is not defined for negative numbers. def binomial_coefficient(i: int, j: int) -> int: Compute binomial coefficient C(i, j) which is given by (i+j)! / (i! * j!) >>> binomial_coefficient(0, 0) == 1 >>> binomial_coefficient(2, 1) == 3 >>> binomial_coefficient(3, 2) == 10 >>> binomial_coefficient(4, 3) == 35 def generate_matrix(m: int, n: int) -> List[List[int]]: Generate an m x n matrix populated with binomial coefficients. >>> generate_matrix(0, 0) == [] >>> generate_matrix(1, 1) == [[1]] >>> generate_matrix(2, 2) == [[1, 1], [1, 2]] >>> generate_matrix(3, 3) == [[1, 1, 1], [1, 2, 3], [1, 3, 6]] >>> generate_matrix(3, 4) == [[1, 1, 1, 1], [1, 2, 3, 4], [1, 3, 6, 10]] >>> generate_matrix(-1, 2) Traceback (most recent call last): ... ValueError: The number of rows and columns should be non-negative.","solution":"import math def factorial(n): Compute the factorial of n. if n < 0: raise ValueError(\\"Factorial is not defined for negative numbers.\\") if n == 0: return 1 return math.factorial(n) def binomial_coefficient(i, j): Compute binomial coefficient C(i, j) which is given by (i+j)! / (i! * j!) return factorial(i+j) // (factorial(i) * factorial(j)) def generate_matrix(m, n): Generate an m x n matrix populated with binomial coefficients. if m < 0 or n < 0: raise ValueError(\\"The number of rows and columns should be non-negative.\\") matrix = [] for i in range(m): row = [] for j in range(n): row.append(binomial_coefficient(i, j)) matrix.append(row) return matrix"},{"question":"def character_frequency(s: str) -> dict: Create a function that takes a string and returns a dictionary containing the frequency of each character in the string. >>> character_frequency(\\"hello\\") == {\\"h\\": 1, \\"e\\": 1, \\"l\\": 2, \\"o\\": 1} >>> character_frequency(\\"hello world\\") == {\\"h\\": 1, \\"e\\": 1, \\"l\\": 3, \\"o\\": 2, \\" \\": 1, \\"w\\": 1, \\"r\\": 1, \\"d\\": 1} >>> character_frequency(\\"\\") == {} >>> character_frequency(\\"aaa\\") == {\\"a\\": 3} >>> character_frequency(\\"Aa\\") == {\\"A\\": 1, \\"a\\": 1}","solution":"def character_frequency(s): Returns a dictionary containing the frequency of each character in the string s. frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"def get_recommended_framework() -> str: Returns the recommended framework/library for building interactive charts that can be integrated into a Django web application. pass def get_integration_approach() -> str: Returns the recommended approach to integrate interactive charts into Django web application. pass # Example Usage: # >>> get_recommended_framework() # 'Plotly and Django Plotly Dash' # >>> get_integration_approach() # '<instructions on how to integrate Plotly with Django>' from solution import get_recommended_framework, get_integration_approach def test_get_recommended_framework(): assert get_recommended_framework() == \\"Plotly and Django Plotly Dash\\" def test_get_integration_approach(): approach = get_integration_approach() assert \\"pip install plotly django-plotly-dash\\" in approach assert \\"plotly_dash\\" in approach assert \\"DjangoDash\\" in approach assert \\"html.Div\\" in approach assert \\"{% load plotly_dash %}\\" in approach assert \\"{% plotly_app name=\\"SimpleExample\\" %}\\" in approach assert \\"urlpatterns\\" in approach","solution":"def get_recommended_framework(): Returns the recommended framework/library for building interactive charts that can be integrated into a Django web application. return \\"Plotly and Django Plotly Dash\\" def get_integration_approach(): Returns the recommended approach to integrate interactive charts into Django web application. return ''' 1. Install Plotly and Django Plotly Dash: pip install plotly django-plotly-dash 2. Add plotly_dash to the list of INSTALLED_APPS in your Django settings. 3. Create a Dash app within your Django app: - In your Django app, create a new directory named embedded_dash - Inside embedded_dash, create an __init__.py file 4. Define your Dash app in the __init__.py file: from dash import Dash import dash_core_components as dcc import dash_html_components as html import plotly.express as px from django_plotly_dash import DjangoDash app = DjangoDash('SimpleExample') # replaces dash.Dash app.layout = html.Div([ dcc.Graph( id='example-graph', figure=px.bar(x=['A', 'B', 'C'], y=[1, 3, 2], title=\\"Sample Chart\\") ) ]) 5. Create a Django template for your dashboard and embed Dash app: - Create a new HTML file (e.g., dashboard.html) and include the Dash app: {% load plotly_dash %} <!DOCTYPE html> <html lang=\\"en\\"> <head> <meta charset=\\"UTF-8\\"> <title>Dashboard</title> </head> <body> {% plotly_app name=\\"SimpleExample\\" %} </body> </html> 6. Configure your Django URLs to include Dash: from django.urls import path from django_plotly_dash.views import add_to_session urlpatterns = [ path('your-dashboard-url/', add_to_session, name='add_to_session'), ] 7. Run your Django server and navigate to the URL for your dashboard to see the interactive charts. '''"},{"question":"def is_valid_palindrome(s: str): Determines if a given string is a valid palindrome, considering only alphanumeric characters and ignoring cases. Additionally, the function should be capable of reconstructing the given string in such a way that it becomes a valid palindrome by adding the minimum number of characters necessary at any position within the string. Parameters: s (str): The input string to check and reconstruct. Returns: tuple: A tuple containing a boolean indicating if the string is a valid palindrome and the reconstructed string. >>> is_valid_palindrome(\\"A man, a plan, a canal, Panama!\\") (True, \\"amanaplanacanalpanama\\") >>> is_valid_palindrome(\\"Hello, World!\\") (False, \\"helloworld\\") >>> is_valid_palindrome(\\"\\") (True, \\"\\") >>> is_valid_palindrome(\\"12321\\") (True, \\"12321\\") >>> is_valid_palindrome(\\"@@\\") (True, \\"\\") >>> is_valid_palindrome(12345) (False, \\"Invalid input: Not a string\\")","solution":"def is_valid_palindrome(s): Determines if a given string is a valid palindrome, considering only alphanumeric characters and ignoring case. if not isinstance(s, str): return (False, \\"Invalid input: Not a string\\") # Filter only alphanumeric characters and convert to lower case filtered_chars = [char.lower() for char in s if char.isalnum()] reconstructed_string = ''.join(filtered_chars) # Check if the filtered string is a palindrome is_palindrome = reconstructed_string == reconstructed_string[::-1] return (is_palindrome, reconstructed_string)"},{"question":"from collections import deque from typing import List, Dict def shortest_path(graph: Dict[str, List[str]], start: str, end: str) -> List[str]: Returns the shortest path between start and end nodes in an unweighted graph. >>> graph = { ... 'A': ['B', 'C', 'D'], ... 'B': ['A', 'E', 'F'], ... 'C': ['A', 'G'], ... 'D': ['A', 'H'], ... 'E': ['B'], ... 'F': ['B'], ... 'G': ['C'], ... 'H': ['D'] ... } >>> shortest_path(graph, 'A', 'G') == ['A', 'C', 'G'] >>> shortest_path(graph, 'B', 'H') == ['B', 'A', 'D', 'H'] >>> shortest_path(graph, 'A', 'A') == ['A'] >>> shorte_path(graph, 'A', 'D') == None >>> shortest_path(graph, 'C', 'E') == None >>> shortest_path(graph, 'A', 'F') == ['A', 'C', 'F'] >>> shortest_path(graph, 'B', 'C') == ['B', 'A', 'C']","solution":"from collections import deque def shortest_path(graph, start, end): Returns the shortest path between start and end nodes in an unweighted graph. if start == end: return [start] queue = deque([(start, [start])]) visited = set() while queue: node, path = queue.popleft() if node in visited: continue visited.add(node) for neighbor in graph.get(node, []): if neighbor == end: return path + [neighbor] else: queue.append((neighbor, path + [neighbor])) return None # return None if there is no path"},{"question":"def unique_elements(lst: List[int]) -> List[int]: Returns a new list containing only the unique elements from the input list, preserving the order of their first appearance. >>> unique_elements([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> unique_elements([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> unique_elements([1, 1, 1, 1, 1]) [1] >>> unique_elements([]) [] >>> unique_elements([5, 5, 5, 2, 2, 3, 3]) [5, 2, 3] >>> unique_elements([-1, -2, -2, -3, -1, 0, 1, 0]) [-1, -2, -3, 0, 1]","solution":"def unique_elements(lst): Returns a new list containing only the unique elements from the input list, preserving the order of their first appearance. Args: lst (list): A list of integers. Returns: list: A list of unique integers. seen = set() unique_lst = [] for elem in lst: if elem not in seen: seen.add(elem) unique_lst.append(elem) return unique_lst"},{"question":"def can_form_palindrome(s: str) -> bool: Returns True if the given string can be rearranged to form a palindrome. Ignores spaces, punctuation, and is case-insensitive. >>> can_form_palindrome(\\"A man, a plan, a canal, Panama\\") == True >>> can_form_palindrome(\\"No lemon, no melon\\") == True >>> can_form_palindrome(\\"Hello, World!\\") == False >>> can_form_palindrome(\\"\\") == True >>> can_form_palindrome(\\"a\\") == True >>> can_form_palindrome(\\"abba\\") == True >>> can_form_palindrome(\\"racecar\\") == True >>> can_form_palindrome(\\"Tact Coa\\") == True","solution":"from collections import Counter import re def can_form_palindrome(s): Returns True if the given string can be rearranged to form a palindrome. Ignores spaces, punctuation, and is case-insensitive. cleaned_s = re.sub(r'[^a-zA-Z]', '', s).lower() char_count = Counter(cleaned_s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"from typing import List def find_pair(nums: List[int], target: int) -> bool: Determines if any two distinct numbers in the list add up to the target value. Parameters: nums (List[int]): List of integers. target (int): Target integer value. Returns: bool: True if any two distinct numbers add up to the target, False otherwise. pass # Example Usage: # print(find_pair([10, 15, 3, 7], 17)) # Expected Output: True # Unit Tests: def test_find_pair_exists(): assert find_pair([10, 15, 3, 7], 17) == True def test_find_pair_no_match(): assert find_pair([10, 15, 3, 7], 20) == False def test_find_pair_multiple_pairs(): assert find_pair([10, 15, 3, 7, 5, 2], 12) == True def test_find_pair_negative_numbers(): assert find_pair([-2, -3, 7, 5], 2) == True def test_find_pair_empty_list(): assert find_pair([], 5) == False def test_find_pair_single_element(): assert find_pair([5], 5) == False def test_find_pair_with_zero(): assert find_pair([0, 1, 2, 3], 3) == True def test_find_pair_large_numbers(): assert find_pair([1000000000, 1000000001], 2000000001) == True","solution":"def find_pair(nums, target): Determines if any two distinct numbers in the list add up to the target value. Parameters: nums (list): List of integers. target (int): Target integer value. Returns: bool: True if any two distinct numbers add up to the target, False otherwise. nums_seen = set() for num in nums: complement = target - num if complement in nums_seen: return True nums_seen.add(num) return False"},{"question":"from datetime import datetime, timedelta class Book: def __init__(self, title, author, isbn): self.title = title self.author = author self.isbn = isbn self.is_checked_out = False self.due_date = None self.checked_out_by = None class Member: def __init__(self, member_id, name): self.member_id = member_id self.name = name self.checked_out_books = [] class Library: Simulate a book lending system with the following operations: Add a new book, remove a book, search for books by title/author, check out a book, return a book, add/remove members, list overdue books. def __init__(self): self.books = {} self.members = {} def add_book(self, title, author, isbn): Add a new book to the collection. def remove_book(self, isbn): Remove a book from the collection using its ISBN number. def search_books(self, keyword): Search for books by title or author. def add_member(self, member_id, name): Add a new library member. def remove_member(self, member_id): Remove a library member. def check_out_book(self, isbn, member_id, due_days=14): Check out a book to a library member. def return_book(self, isbn, member_id): Return a book that was previously checked out. def list_overdue_books(self): List all overdue books. # Unit tests def test_add_and_remove_book(): library = Library() library.add_book(\\"Test Book\\", \\"Test Author\\", \\"12345\\") assert \\"12345\\" in library.books library.remove_book(\\"12345\\") assert \\"12345\\" not in library.books def test_search_books(): library = Library() library.add_book(\\"Test Book\\", \\"Test Author\\", \\"12345\\") result = library.search_books(\\"Test Book\\") assert len(result) == 1 assert result[0].title == \\"Test Book\\" def test_add_and_remove_member(): library = Library() library.add_member(\\"001\\", \\"John Doe\\") assert \\"001\\" in library.members library.remove_member(\\"001\\") assert \\"001\\" not in library.members def test_check_out_and_return_book(): library = Library() library.add_book(\\"Test Book\\", \\"Test Author\\", \\"12345\\") library.add_member(\\"001\\", \\"John Doe\\") library.check_out_book(\\"12345\\", \\"001\\") assert library.books[\\"12345\\"].is_checked_out assert library.books[\\"12345\\"].checked_out_by == \\"001\\" assert library.members[\\"001\\"].checked_out_books library.return_book(\\"12345\\", \\"001\\") assert not library.books[\\"12345\\"].is_checked_out assert library.books[\\"12345\\"].checked_out_by is None assert not library.members[\\"001\\"].checked_out_books def test_list_overdue_books(): library = Library() library.add_book(\\"Old Book\\", \\"Old Author\\", \\"12345\\") library.add_member(\\"001\\", \\"John Doe\\") library.check_out_book(\\"12345\\", \\"001\\", due_days=-1) # due in the past overdue_books = library.list_overdue_books() assert len(overdue_books) == 1 assert overdue_books[0].title == \\"Old Book\\"","solution":"from datetime import datetime, timedelta class Book: def __init__(self, title, author, isbn): self.title = title self.author = author self.isbn = isbn self.is_checked_out = False self.due_date = None self.checked_out_by = None class Member: def __init__(self, member_id, name): self.member_id = member_id self.name = name self.checked_out_books = [] class Library: def __init__(self): self.books = {} self.members = {} def add_book(self, title, author, isbn): if isbn not in self.books: self.books[isbn] = Book(title, author, isbn) def remove_book(self, isbn): if isbn in self.books and not self.books[isbn].is_checked_out: del self.books[isbn] def search_books(self, keyword): results = [] for book in self.books.values(): if keyword.lower() in book.title.lower() or keyword.lower() in book.author.lower(): results.append(book) return results def add_member(self, member_id, name): if member_id not in self.members: self.members[member_id] = Member(member_id, name) def remove_member(self, member_id): if member_id in self.members and not self.members[member_id].checked_out_books: del self.members[member_id] def check_out_book(self, isbn, member_id, due_days=14): if isbn in self.books and not self.books[isbn].is_checked_out and member_id in self.members: book = self.books[isbn] member = self.members[member_id] book.is_checked_out = True book.due_date = datetime.now() + timedelta(days=due_days) book.checked_out_by = member_id member.checked_out_books.append(book) def return_book(self, isbn, member_id): if isbn in self.books and self.books[isbn].is_checked_out and self.books[isbn].checked_out_by == member_id: book = self.books[isbn] member = self.members[member_id] book.is_checked_out = False book.due_date = None book.checked_out_by = None member.checked_out_books.remove(book) def list_overdue_books(self): overdue_books = [] for book in self.books.values(): if book.is_checked_out and book.due_date and book.due_date < datetime.now(): overdue_books.append(book) return overdue_books"},{"question":"def is_anagram_of_palindrome(s: str) -> bool: Checks if the input string is an anagram of a palindrome. An anagram of a palindrome has at most one character with an odd count. Args: s (str): The input string. Returns: bool: True if the input string is an anagram of a palindrome, False otherwise. >>> is_anagram_of_palindrome(\\"civic\\") True >>> is_anagram_of_palindrome(\\"hello\\") False >>> is_anagram_of_palindrome(\\"Able was I ere I saw Elba\\") True >>> is_anagram_of_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_anagram_of_palindrome(\\"a\\") True >>> is_anagram_of_palindrome(\\"ab\\") False >>> is_anagram_of_palindrome(\\"racecar\\") True >>> is_anagram_of_palindrome(\\"arceace\\") True >>> is_anagram_of_palindrome(\\"\\") True >>> is_anagram_of_palindrome(\\"12321\\") True >>> is_anagram_of_palindrome(\\"1a2b2a1\\") True # Your code here","solution":"def is_anagram_of_palindrome(s): Checks if the input string is an anagram of a palindrome. An anagram of a palindrome has at most one character with an odd count. Args: s (str): The input string. Returns: bool: True if the input string is an anagram of a palindrome, False otherwise. from collections import Counter import re # Clean the string: remove non-alphanumeric characters and lower the case. cleaned_s = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Count each character's frequency. char_count = Counter(cleaned_s) # Count how many characters have an odd frequency. odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For a string to be an anagram of a palindrome, # there must be at most one character with an odd frequency. return odd_count <= 1"},{"question":"def parse_query(user_input: str) -> str: Parses the user input and returns an appropriate response based on predefined rules. >>> parse_query(\\"Hello\\") \\"Hello! How can I assist you today?\\" >>> parse_query(\\"When do you close?\\") \\"Our operating hours are from 9 AM to 5 PM, Monday to Friday.\\" >>> parse_query(\\"Is this item available?\\") \\"We offer a wide range of products. Can you please specify which product you are looking for?\\" >>> parse_query(\\"What is the meaning of life?\\") \\"I'm sorry, I didn't understand that. Can you please provide more details?\\" # Implementation here def chatbot_interface(): A simple interface function to interact with the chatbot. # Implementation here","solution":"import re def parse_query(user_input): Parses the user input and returns an appropriate response based on predefined rules. user_input = user_input.lower().strip() # Define predefined rules and responses greetings = [\\"hello\\", \\"hi\\", \\"hey\\", \\"good morning\\", \\"good afternoon\\", \\"good evening\\"] operating_hours_keywords = [\\"hours\\", \\"open\\", \\"close\\", \\"time\\", \\"when\\"] product_info_keywords = [\\"product\\", \\"stock\\", \\"available\\", \\"sell\\", \\"item\\"] # Check for greetings for greeting in greetings: if re.search(r'b' + greeting + r'b', user_input): return \\"Hello! How can I assist you today?\\" # Check for operating hours questions if any(keyword in user_input for keyword in operating_hours_keywords): return \\"Our operating hours are from 9 AM to 5 PM, Monday to Friday.\\" # Check for product information requests if any(keyword in user_input for keyword in product_info_keywords): return \\"We offer a wide range of products. Can you please specify which product you are looking for?\\" # Fallback response return \\"I'm sorry, I didn't understand that. Can you please provide more details?\\" def chatbot_interface(): A simple interface function to interact with the chatbot. print(\\"Welcome to our chatbot! Type 'exit' to end the conversation.\\") while True: user_input = input(\\"You: \\") if user_input.lower() == \\"exit\\": print(\\"Goodbye!\\") break response = parse_query(user_input) print(\\"Chatbot: \\" + response)"},{"question":"def filter_chat_history(chat_history: list, user_id: str) -> list: Filters the chat history to return all messages where the user_id is either the sender or the recipient, sorted by timestamp in ascending order. Args: - chat_history (list): A list of dictionaries containing chat messages. - user_id (str): The user ID to filter messages for. Returns: - list: A list of dictionaries with the filtered chat messages sorted by timestamp. >>> chat_history = [ ... {\\"sender\\": \\"user1\\", \\"recipient\\": \\"user2\\", \\"timestamp\\": \\"2023-05-01T14:48:00Z\\", \\"message\\": \\"Hello!\\"}, ... {\\"sender\\": \\"user2\\", \\"recipient\\": \\"user1\\", \\"timestamp\\": \\"2023-05-01T14:49:00Z\\", \\"message\\": \\"Hi! How are you?\\"}, ... {\\"sender\\": \\"user1\\", \\"recipient\\": \\"user2\\", \\"timestamp\\": \\"2023-05-01T14:50:00Z\\", \\"message\\": \\"I'm good, thanks!\\"}, ... {\\"sender\\": \\"user3\\", \\"recipient\\": \\"user1\\", \\"timestamp\\": \\"2023-05-02T12:00:00Z\\", \\"message\\": \\"Hey user1!\\"}, ... {\\"sender\\": \\"user1\\", \\"recipient\\": \\"user3\\", \\"timestamp\\": \\"2023-05-02T12:01:00Z\\", \\"message\\": \\"Hey user3!\\"} ... ] >>> filter_chat_history(chat_history, \\"user1\\") [ {\\"sender\\": \\"user1\\", \\"recipient\\": \\"user2\\", \\"timestamp\\": \\"2023-05-01T14:48:00Z\\", \\"message\\": \\"Hello!\\"}, {\\"sender\\": \\"user2\\", \\"recipient\\": \\"user1\\", \\"timestamp\\": \\"2023-05-01T14:49:00Z\\", \\"message\\": \\"Hi! How are you?\\"}, {\\"sender\\": \\"user1\\", \\"recipient\\": \\"user2\\", \\"timestamp\\": \\"2023-05-01T14:50:00Z\\", \\"message\\": \\"I'm good, thanks!\\"}, {\\"sender\\": \\"user3\\", \\"recipient\\": \\"user1\\", \\"timestamp\\": \\"2023-05-02T12:00:00Z\\", \\"message\\": \\"Hey user1!\\"}, {\\"sender\\": \\"user1\\", \\"recipient\\": \\"user3\\", \\"timestamp\\": \\"2023-05-02T12:01:00Z\\", \\"message\\": \\"Hey user3!\\"} ]","solution":"def filter_chat_history(chat_history: list, user_id: str) -> list: Filters the chat history to return all messages where the user_id is either the sender or the recipient. Args: - chat_history (list): A list of dictionaries containing chat messages. - user_id (str): The user ID to filter messages for. Returns: - list: A list of dictionaries with the filtered chat messages sorted by timestamp. # Filtering the messages where user_id is either sender or recipient filtered_messages = [message for message in chat_history if message['sender'] == user_id or message['recipient'] == user_id] # Sorting the messages by timestamp filtered_messages.sort(key=lambda x: x['timestamp']) return filtered_messages"},{"question":"def sort_by_frequency(arr: list) -> list: Sorts the list based on frequency of elements in descending order. If frequencies match, sorts by element values in ascending order. >>> sort_by_frequency([5, 3, 9, 5, 5, 3, 3]) [5, 5, 5, 3, 3, 3, 9] >>> sort_by_frequency([8, 8, 7, 7, 7, 6, 6, 6, 5]) [6, 6, 6, 7, 7, 7, 8, 8, 5]","solution":"def sort_by_frequency(arr: list) -> list: Sorts the list based on frequency of elements in descending order. If frequencies match, sorts by element values in ascending order. >>> sort_by_frequency([5, 3, 9, 5, 5, 3, 3]) [5, 5, 5, 3, 3, 3, 9] >>> sort_by_frequency([8, 8, 7, 7, 7, 6, 6, 6, 5]) [6, 6, 6, 7, 7, 7, 8, 8, 5] # Use a dictionary to count frequencies freq_dict = {} for num in arr: if num in freq_dict: freq_dict[num] += 1 else: freq_dict[num] = 1 # Sort the items first by frequency, then by value sorted_list = sorted(arr, key=lambda x: (-freq_dict[x], x)) return sorted_list # Test cases to verify print(sort_by_frequency([5, 3, 9, 5, 5, 3, 3])) # [5, 5, 5, 3, 3, 3, 9] print(sort_by_frequency([8, 8, 7, 7, 7, 6, 6, 6, 5])) # [6, 6, 6, 7, 7, 7, 8, 8, 5]"},{"question":"class ParkingSlot: def __init__(self, slot_number, size): self.slot_number = slot_number self.size = size self.is_occupied = False self.vehicle = None class ParkingLot: def __init__(self, slots): Initialize the parking lot with a given number of parking slots. self.slots = {i['slot_number']: ParkingSlot(i['slot_number'], i['size']) for i in slots} def park(self, vehicle): Park a vehicle in the nearest available slot. :param vehicle: Vehicle object to be parked. :return: Slot number or \\"Parking lot is full\\" if there is no available slot. def exit_vehicle(self, slot_number): Exit a parked vehicle. :param slot_number: Slot number from where the vehicle needs to be removed. :return: True if vehicle exits successfully, False otherwise. def check_availability(self): Check the availability of slots. :return: List of available slot numbers. def find_vehicle(self, vehicle_id): Find the slot number where a specific vehicle is parked. :param vehicle_id: ID of the vehicle to be searched. :return: Slot number or \\"Vehicle not found\\" if the vehicle is not found. class Vehicle: def __init__(self, vehicle_id, size): Initialize a vehicle with its ID and size. :param vehicle_id: Unique identification for the vehicle. :param size: Size of the vehicle. self.vehicle_id = vehicle_id self.size = size Example Usage: slots = [ {'slot_number': 1, 'size': 1}, {'slot_number': 2, 'size': 2}, {'slot_number': 3, 'size': 3}, ] parking_lot = ParkingLot(slots) vehicle1 = Vehicle('ABC123', 1) vehicle2 = Vehicle('DEF456', 2) vehicle3 = Vehicle('GHI789', 3) # Park vehicles print(parking_lot.park(vehicle1)) # Output: 1 print(parking_lot.park(vehicle2)) # Output: 2 print(parking_lot.park(vehicle3)) # Output: 3 # Check the availability of slots print(parking_lot.check_availability()) # Output: [] # Find the slot number where a specific vehicle is parked print(parking_lot.find_vehicle('ABC123')) # Output: 1 # Exit a parked vehicle print(parking_lot.exit_vehicle(1)) # Output: True print(parking_lot.check_availability()) # Output: [1]","solution":"class ParkingSlot: def __init__(self, slot_number, size): self.slot_number = slot_number self.size = size self.is_occupied = False self.vehicle = None class ParkingLot: def __init__(self, slots): self.slots = {i['slot_number']: ParkingSlot(i['slot_number'], i['size']) for i in slots} def park(self, vehicle): for slot_number, slot in self.slots.items(): if not slot.is_occupied and slot.size >= vehicle.size: slot.vehicle = vehicle slot.is_occupied = True return slot_number return \\"Parking lot is full\\" def exit_vehicle(self, slot_number): if self.slots[slot_number].is_occupied: self.slots[slot_number].vehicle = None self.slots[slot_number].is_occupied = False return True return False def check_availability(self): return [slot_number for slot_number, slot in self.slots.items() if not slot.is_occupied] def find_vehicle(self, vehicle_id): for slot_number, slot in self.slots.items(): if slot.is_occupied and slot.vehicle.vehicle_id == vehicle_id: return slot_number return \\"Vehicle not found\\" class Vehicle: def __init__(self, vehicle_id, size): self.vehicle_id = vehicle_id self.size = size"},{"question":"def calculate_frequency(s: str) -> dict: Design a function \`calculate_frequency\` that takes a string \`s\` as input and returns a dictionary where each key is a unique character from the string and its value is the frequency of that character in the string. The function should ignore spaces and be case-insensitive (i.e., 'A' and 'a' should be treated as the same character). >>> calculate_frequency(\\"Hello World\\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> calculate_frequency(\\"\\") == {} >>> calculate_frequency(\\" \\") == {} >>> calculate_frequency(\\"AaAaAa\\") == {'a': 6} >>> calculate_frequency(\\"abcd ABCD aBcD AbCd\\") == {'a': 4, 'b': 4, 'c': 4, 'd': 4} >>> calculate_frequency(\\"1234!@#\\") == {} >>> calculate_frequency(\\"Hello World! 123\\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1}","solution":"def calculate_frequency(s): Returns a dictionary where each key is a unique character from the string s (ignoring spaces and case), and its value is the frequency of that character. frequency_dict = {} for char in s.lower(): if char.isalpha(): if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict"},{"question":"def count_duplicates(string_list): This function takes a list of strings and returns a dictionary with counts of strings that appear more than once in the list. Parameters: string_list (list): A list of strings. Returns: dict: A dictionary with strings as keys and their appearance counts as values, including only strings that appear more than once. # Your implementation here # Example usage input_list = [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"] result = count_duplicates(input_list) print(result) # Output should be: {'apple': 3, 'banana': 2} # Unit Tests def test_count_duplicates(): assert count_duplicates([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) == {\\"apple\\": 3, \\"banana\\": 2} assert count_duplicates([\\"cat\\", \\"dog\\", \\"mouse\\", \\"dog\\", \\"cat\\", \\"cat\\"]) == {\\"cat\\": 3, \\"dog\\": 2} assert count_duplicates([\\"one\\", \\"two\\", \\"three\\"]) == {} assert count_duplicates([]) == {} assert count_duplicates([\\"same\\", \\"same\\", \\"same\\", \\"same\\"]) == {\\"same\\": 4} def test_count_duplicates_varied_cases(): assert count_duplicates([\\"Apple\\", \\"Banana\\", \\"apple\\", \\"banana\\", \\"APPLE\\", \\"banana\\"]) == {\\"banana\\": 2} def test_count_duplicates_no_duplicates(): assert count_duplicates([\\"unique\\", \\"distinct\\", \\"single\\", \\"oneof\\"]) == {} def test_count_duplicates_with_special_characters(): assert count_duplicates([\\"a!\\", \\"a\\", \\"a!\\", \\"a#\\", \\"a\\"]) == {\\"a!\\": 2, \\"a\\": 2}","solution":"def count_duplicates(string_list): This function takes a list of strings and returns a dictionary with counts of strings that appear more than once in the list. Parameters: string_list (list): A list of strings. Returns: dict: A dictionary with strings as keys and their appearance counts as values, including only strings that appear more than once. from collections import Counter # Count occurrences of each string counts = Counter(string_list) # Filter out strings that appear only once duplicates = {string: count for string, count in counts.items() if count > 1} return duplicates"},{"question":"def char_frequency(s: str) -> dict: Accepts a string containing only lowercase alphabetical characters and returns a dictionary with the characters from the string as keys and their respective frequencies as values. >>> char_frequency(\\"abracadabra\\") {'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1} >>> char_frequency(\\"hello\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> char_frequency(\\"\\") {} from solution import char_frequency def test_char_frequency_single_character(): assert char_frequency(\\"a\\") == {'a': 1} def test_char_frequency_multiple_characters(): assert char_frequency(\\"abracadabra\\") == {'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1} def test_char_frequency_different_characters(): assert char_frequency(\\"hello\\") == {'h': 1, 'e': 1, 'l': 2, 'o': 1} def test_char_frequency_repeating_characters(): assert char_frequency(\\"aaaaaa\\") == {'a': 6} def test_char_frequency_empty_string(): assert char_frequency(\\"\\") == {}","solution":"def char_frequency(s): Returns a dictionary with the frequency of each character in the string s. frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"def clean_sort(lst: list) -> list: Write a Python function that takes a list of integers and returns the list sorted in ascending order. However, if the list contains any negative numbers, the function should remove those negative numbers before sorting the list. >>> clean_sort([3, -1, 5, -6, 0, 9, 1, -3]) [0, 1, 3, 5, 9] >>> clean_sort([3, 5, 0, 9, 1]) [0, 1, 3, 5, 9] >>> clean_sort([]) [] >>> clean_sort([-3, -1, -6, -9]) [] >>> clean_sort([4, -2, -3, 2, 5, -10, 8]) [2, 4, 5, 8]","solution":"def clean_sort(lst: list) -> list: Returns a sorted list in ascending order with all negative numbers removed. # Filter out negative numbers non_negative_lst = [x for x in lst if x >= 0] # Sort the remaining elements non_negative_lst.sort() return non_negative_lst"},{"question":"from typing import List def find_single_number(nums: List[int]) -> int: Returns the number that appears only once in the array, nums. All other numbers appear exactly twice. Args: nums (list): The list of integers where exactly one element appears once, and all others appear twice. Returns: int: The single number that appears only once. pass def test_single_appearance_1(): assert find_single_number([4, 2, 2, 6, 4, 6, 3]) == 3 def test_single_appearance_2(): assert find_single_number([1, 5, 1, 7, 8, 5, 8]) == 7 def test_single_appearance_3(): assert find_single_number([10, 20, 30, 20, 10]) == 30 def test_single_appearance_4(): assert find_single_number([99, 1, 99, 2, 2]) == 1 def test_single_appearance_5(): assert find_single_number([17]) == 17 def test_single_appearance_6(): assert find_single_number([4,1,2,1,2]) == 4","solution":"def find_single_number(nums): Returns the number that appears only once in the array nums. All other numbers appear exactly twice. Args: nums (list): The list of integers where exactly one element appears once, and all others appear twice. Returns: int: The single number that appears only once. result = 0 for num in nums: result ^= num return result"},{"question":"def find_abc_substring(s: str) -> int: Returns the first index of the substring \\"abc\\" in the input string s if it exists. The search is case-insensitive and ignores any surrounding whitespace. If \\"abc\\" does not exist in the string, returns -1. >>> find_abc_substring(\\"testing for abc substring\\") == 12 >>> find_abc_substring(\\"no relevant substring\\") == -1 >>> find_abc_substring(\\"AbCdEfG\\") == 0 >>> find_abc_substring(\\" a b c d e \\") == 3 >>> find_abc_substring(\\"xA bC y\\") == 1 >>> find_abc_substring(\\"abc abc\\") == 0 >>> find_abc_substring(\\"abcdefabc\\") == 0 >>> find_abc_substring(\\"firstabc secAbCd abc\\") == 5","solution":"def find_abc_substring(s): Returns the first index of the substring \\"abc\\" in the input string s if exists. The search is case-insensitive and ignores any surrounding whitespace. If \\"abc\\" does not exist in the string, returns -1. # Convert the string to lower case to make the search case-insensitive s = s.lower() # Find the stripped version of \\"abc\\" presence stripped_s = ''.join(s.split()) index = stripped_s.find(\\"abc\\") if index == -1: return -1 # Calculate the actual index in the original string actual_index = 0 count = 0 for i, char in enumerate(s): if char.strip(): count += 1 if count == index + 1: actual_index = i break return actual_index"},{"question":"from typing import List def longestSubsequence(arr: List[int]) -> int: Analyze the provided array of integers and determine the length of the longest subsequence where each element is either the same as or differs by 1 from the previous element. >>> longestSubsequence([1, 2, 3, 4, 3, 2, 1, 2, 3, 4]) 10 >>> longestSubsequence([1, 1, 1, 1, 1]) 5 >>> longestSubsequence([1, 2, 3, 4]) 4 >>> longestSubsequence([1, 2, 2, 1, 2, 3]) 6 >>> longestSubsequence([1, 2, 4, 1, 2, 3, 5, 1]) 3 >>> longestSubsequence([]) 0 >>> longestSubsequence([42]) 1 >>> longestSubsequence([-1, -2, -1, 0, 1]) 5 pass","solution":"def longestSubsequence(arr): if not arr: return 0 max_len = 1 current_len = 1 for i in range(1, len(arr)): if abs(arr[i] - arr[i-1]) <= 1: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 max_len = max(max_len, current_len) return max_len"},{"question":"def shift_string(s: str, n: int) -> str: This function takes a string \`s\` and an integer \`n\` and returns a new string where the first \`n\` characters of the original string are shifted to the end of the string. If \`n\` is greater than the length of the string or negative, it returns the original string. >>> shift_string(\\"python\\", 2) 'thonpy' >>> shift_string(\\"coding\\", 10) 'coding' >>> shift_string(\\"example\\", -3) 'example' >>> shift_string(\\"example\\", 0) 'example' >>> shift_string(\\"example\\", len(\\"example\\")) 'example' >>> shift_string(\\"\\", 3) ''","solution":"def shift_string(s, n): This function takes a string \`s\` and an integer \`n\` and returns a new string where the first \`n\` characters of the original string are shifted to the end of the string. If \`n\` is greater than the length of the string or negative, it returns the original string. # Validate input types if not isinstance(s, str) or not isinstance(n, int): raise TypeError(\\"Input must be a string and an integer.\\") # If n is outside the valid range, return the original string if n < 0 or n > len(s): return s return s[n:] + s[:n]"},{"question":"def combination_sum(nums: List[int], target: int) -> List[List[int]]: Given an integer array \`nums\` and an integer \`target\`, return all unique combinations of \`nums\` where the chosen numbers sum to \`target\`. The same number may be chosen multiple times in the combination. >>> combination_sum([2, 3, 6, 7], 7) == [[2, 2, 3], [7]] >>> combination_sum([2, 3, 5], 8) == [[2, 2, 2, 2], [2, 3, 3], [3, 5]] >>> combination_sum([2], 1) == [] >>> combination_sum([1], 1) == [[1]] >>> combination_sum([1], 2) == [[1, 1]] >>> combination_sum([2, 4, 6, 8], 8) == [[2, 2, 2, 2], [2, 2, 4], [2, 6], [4, 4], [8]]","solution":"def combination_sum(nums, target): def backtrack(remaining, start, path, result): if remaining < 0: return if remaining == 0: result.append(path[:]) return for i in range(start, len(nums)): path.append(nums[i]) backtrack(remaining - nums[i], i, path, result) path.pop() # backtrack result = [] nums.sort() # optional: helps to improve efficiency backtrack(target, 0, [], result) return result"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: Merges two sorted linked lists into a single sorted linked list. Args: l1 (ListNode): The head of the first sorted linked list. l2 (ListNode): The head of the second sorted linked list. Returns: ListNode: The head of the merged sorted linked list. # Your code here! Unit Test: def linked_list_from_list(values): if not values: return None head = ListNode(values[0]) current = head for val in values[1:]: current.next = ListNode(val) current = current.next return head def list_from_linked_list(head): values = [] current = head while current: values.append(current.val) current = current.next return values def test_merge_two_sorted_lists(): l1 = linked_list_from_list([1, 2, 4]) l2 = linked_list_from_list([1, 3, 4]) merged_head = merge_two_sorted_lists(l1, l2) assert list_from_linked_list(merged_head) == [1, 1, 2, 3, 4, 4] def test_merge_with_empty_list(): l1 = linked_list_from_list([]) l2 = linked_list_from_list([1, 2, 3]) merged_head = merge_two_sorted_lists(l1, l2) assert list_from_linked_list(merged_head) == [1, 2, 3] l1 = linked_list_from_list([1, 2, 3]) l2 = linked_list_from_list([]) merged_head = merge_two_sorted_lists(l1, l2) assert list_from_linked_list(merged_head) == [1, 2, 3] def test_merge_two_empty_lists(): l1 = linked_list_from_list([]) l2 = linked_list_from_list([]) merged_head = merge_two_sorted_lists(l1, l2) assert list_from_linked_list(merged_head) == [] def test_merge_single_element_lists(): l1 = linked_list_from_list([1]) l2 = linked_list_from_list([2]) merged_head = merge_two_sorted_lists(l1, l2) assert list_from_linked_list(merged_head) == [1, 2] l1 = linked_list_from_list([2]) l2 = linked_list_from_list([1]) merged_head = merge_two_sorted_lists(l1, l2) assert list_from_linked_list(merged_head) == [1, 2]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: Merges two sorted linked lists into a single sorted linked list. Args: l1 (ListNode): The head of the first sorted linked list. l2 (ListNode): The head of the second sorted linked list. Returns: ListNode: The head of the merged sorted linked list. dummy = ListNode(0) current = dummy while l1 and l2: if l1.val <= l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 elif l2: current.next = l2 return dummy.next"},{"question":"from typing import List def longest_zero_sum_subarray(arr: List[int]) -> List[int]: Returns the longest contiguous subarray which has a sum equal to 0. If multiple such subarrays exist with the same maximum length, returns the first one. >>> longest_zero_sum_subarray([]) == [] >>> longest_zero_sum_subarray([1, 2, 3]) == [] >>> longest_zero_sum_subarray([1, -1, 2, -2, 3, -3]) == [1, -1, 2, -2, 3, -3] >>> longest_zero_sum_subarray([1, 2, -3, 3]) == [1, 2, -3] >>> longest_zero_sum_subarray([1, 2, -2, 3, -2, 2]) == [2, -2] >>> longest_zero_sum_subarray([0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0]","solution":"def longest_zero_sum_subarray(arr): Returns the longest contiguous subarray which has a sum equal to 0. If multiple such subarrays exist with the same maximum length, returns the first one. # Dictionary to store the first occurrence of prefix sums prefix_sum_map = {} max_len = 0 prefix_sum = 0 start_index = -1 for i, num in enumerate(arr): prefix_sum += num # When subarray starts from index 0 if prefix_sum == 0: max_len = i + 1 start_index = 0 # If prefix_sum is seen before, then there exists at least one subarray ending # at index i with 0 sum if prefix_sum in prefix_sum_map: length = i - prefix_sum_map[prefix_sum] if length > max_len: max_len = length start_index = prefix_sum_map[prefix_sum] + 1 else: prefix_sum_map[prefix_sum] = i # If max_len is 0, it means no subarray has sum=0 if max_len == 0: return [] else: return arr[start_index:start_index + max_len]"},{"question":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: Calculate the area of the largest rectangle that can be formed within the bounds of the histogram. Args: heights (List[int]): List of integers representing the heights of blocks in the histogram. Returns: int: The area of the largest rectangle. Examples: >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([5]) 5 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 pass def test_example_case(): assert largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 def test_single_element(): assert largest_rectangle_area([5]) == 5 assert largest_rectangle_area([100]) == 100 def test_all_same_height(): assert largest_rectangle_area([2, 2, 2, 2]) == 8 assert largest_rectangle_area([5, 5, 5, 5, 5]) == 25 def test_increasing_heights(): assert largest_rectangle_area([1, 2, 3, 4, 5]) == 9 def test_decreasing_heights(): assert largest_rectangle_area([5, 4, 3, 2, 1]) == 9 def test_mixed_heights(): assert largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) == 12 def test_single_large_block(): assert largest_rectangle_area([10, 10, 10, 1]) == 30 def test_alternating_heights(): assert largest_rectangle_area([5, 1, 5, 1, 5, 1, 5]) == 7","solution":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: stack = [] # stack to store the indices of the histogram bars max_area = 0 # variable to store the maximum area index = 0 # index to traverse through the histogram bars while index < len(heights): # if the stack is empty or the current bar is taller than the bar at stack top if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # pop the top element from the stack top_of_stack = stack.pop() # calculate the area with heights[top_of_stack] as the smallest (or minimum height) bar area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index) # update max_area, if needed max_area = max(max_area, area) # now pop the remaining bars from the stack and calculate area with each popped bar as the smallest bar while stack: top_of_stack = stack.pop() area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) return max_area"},{"question":"def is_prime(n: int) -> bool: Checks if a number is prime. # Implement this helper function to check if a number is prime. def extract_prime_numbers(lst: List[int]) -> List[int]: Create a function that takes an unsorted list of integers and returns a new list containing only the prime numbers from the original list. Each prime number in the returned list should be in the same order as they appeared in the input list. >>> extract_prime_numbers([10, 2, 3, 4, 5, 6, 11, 13, 17, 19, 22, 23, 29]) [2, 3, 5, 11, 13, 17, 19, 23, 29] >>> extract_prime_numbers([4, 6, 8, 10, 12, 14, 15, 16, 20]) [] >>> extract_prime_numbers([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31] >>> extract_prime_numbers([-10, -3, 0, 2, 3, 4, 5]) [2, 3, 5] >>> extract_prime_numbers([]) [] >>> extract_prime_numbers([11]) [11] >>> extract_prime_numbers([9]) []","solution":"def is_prime(n): Checks if n is a prime number. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def extract_prime_numbers(lst): Returns a list of prime numbers from the input list. return [x for x in lst if is_prime(x)]"},{"question":"import numpy as np import matplotlib.pyplot as plt from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split, cross_val_score from sklearn.neighbors import KNeighborsClassifier from sklearn.metrics import accuracy_score from sklearn.preprocessing import StandardScaler def load_and_prepare_data(): Load the Iris dataset and prepare the feature matrix and target vector. >>> X, y = load_and_prepare_data() >>> X.shape (150, 4) >>> y.shape (150,) def find_best_k(X, y): Perform hyperparameter tuning to find the optimal number of neighbors (k) using cross-validation. >>> X, y = load_and_prepare_data() >>> best_k, cv_scores = find_best_k(X, y) >>> isinstance(best_k, int) True >>> best_k > 0 True >>> len(cv_scores) 30 def knn_classification(X, y, k): Implement a K-Nearest Neighbors classifier and evaluate its performance using cross-validation. >>> X, y = load_and_prepare_data() >>> best_k, _ = find_best_k(X, y) >>> knn, accuracy = knn_classification(X, y, best_k) >>> 0 <= accuracy <= 1 True def plot_cross_validation_scores(k_values, cv_scores): Provide visualizations to show the classification boundaries. >>> k_values = list(range(1, 31)) >>> cv_scores = [0.9, 0.92, 0.91, 0.93, 0.94] # Dummy values for example >>> plot_cross_validation_scores(k_values, cv_scores)","solution":"import numpy as np import matplotlib.pyplot as plt from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split, cross_val_score from sklearn.neighbors import KNeighborsClassifier from sklearn.metrics import accuracy_score from sklearn.preprocessing import StandardScaler def load_and_prepare_data(): iris = load_iris() X = iris.data y = iris.target # Standardize features by removing the mean and scaling to unit variance scaler = StandardScaler() X = scaler.fit_transform(X) return X, y def find_best_k(X, y): k_values = range(1, 31) cv_scores = [] for k in k_values: knn = KNeighborsClassifier(n_neighbors=k) scores = cross_val_score(knn, X, y, cv=10, scoring='accuracy') cv_scores.append(scores.mean()) best_k = k_values[np.argmax(cv_scores)] return best_k, cv_scores def knn_classification(X, y, k): X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42) knn = KNeighborsClassifier(n_neighbors=k) knn.fit(X_train, y_train) y_pred = knn.predict(X_test) accuracy = accuracy_score(y_test, y_pred) return knn, accuracy def plot_cross_validation_scores(k_values, cv_scores): plt.figure(figsize=(10, 6)) plt.plot(k_values, cv_scores, marker='o') plt.xlabel('Number of Neighbors K') plt.ylabel('Cross-Validated Accuracy') plt.title('KNN Cross-Validated Accuracy for different K values') plt.grid(True) plt.show() X, y = load_and_prepare_data() best_k, cv_scores = find_best_k(X, y) print(f\\"Best value for k: {best_k}\\") knn, accuracy = knn_classification(X, y, best_k) print(f\\"Accuracy with best k ({best_k}): {accuracy*100:.2f}%\\") plot_cross_validation_scores(list(range(1, 31)), cv_scores)"},{"question":"def atm_simulation(commands: List[str]) -> Tuple[List[Union[str, int]], int]: Simulates a basic ATM based on the input commands and returns the resulting balance or appropriate messages. :param commands: List of command strings for the ATM operations. :return: The resulting balance or appropriate messages after executing all commands. Example: >>> atm_simulation([\\"DEPOSIT 100\\"]) == ([\\"Deposited 100\\"], 100) >>> atm_simulation([\\"DEPOSIT 100\\", \\"WITHDRAW 50\\"]) == ([\\"Deposited 100\\", \\"Withdrew 50\\"], 50) >>> atm_simulation([\\"WITHDRAW 50\\"]) == ([\\"Insufficient funds\\"], 0) >>> atm_simulation([\\"DEPOSIT 100\\", \\"BALANCE\\"]) == ([\\"Deposited 100\\", 100], 100) >>> atm_simulation([\\"INVALID 123\\"]) == ([\\"Invalid command\\"], 0) >>> atm_simulation([\\"DEPOSIT -100\\", \\"WITHDRAW -50\\"]) == ([\\"Invalid deposit amount\\", \\"Invalid withdrawal amount\\"], 0) >>> atm_simulation([\\"DEPOSIT abcd\\", \\"WITHDRAW a100\\", \\"BALANCE\\", \\"DEPOSIT 50\\", \\"WITHDRAW 20A\\"]) == ( ... [\\"Invalid deposit amount\\", \\"Invalid withdrawal amount\\", 0, \\"Deposited 50\\", \\"Invalid withdrawal amount\\"], 50) >>> atm_simulation([\\"\\"]) == ([\\"Invalid command\\"], 0) >>> atm_simulation([\\" \\"]) == ([\\"Invalid command\\"], 0)","solution":"def atm_simulation(commands): Simulates a basic ATM based on the input commands and returns the resulting balance or appropriate messages. :param commands: List of command strings for the ATM operations. :return: The resulting balance or appropriate messages after executing all commands. balance = 0 results = [] for command in commands: parts = command.split() if len(parts) == 0: results.append(\\"Invalid command\\") continue action = parts[0].upper() if action == \\"DEPOSIT\\": if len(parts) != 2 or not parts[1].isdigit() or int(parts[1]) <= 0: results.append(\\"Invalid deposit amount\\") else: amount = int(parts[1]) balance += amount results.append(f\\"Deposited {amount}\\") elif action == \\"WITHDRAW\\": if len(parts) != 2 or not parts[1].isdigit() or int(parts[1]) <= 0: results.append(\\"Invalid withdrawal amount\\") else: amount = int(parts[1]) if amount > balance: results.append(\\"Insufficient funds\\") else: balance -= amount results.append(f\\"Withdrew {amount}\\") elif action == \\"BALANCE\\": results.append(balance) else: results.append(\\"Invalid command\\") return results, balance"},{"question":"def most_frequent_ratings(ratings: list) -> dict: Identify the most frequent rating provided by each user. Args: ratings (list): A list of tuples containing user ID and their rating. Returns: dict: A dictionary where the keys are user IDs and the values are the most frequent ratings. Example: >>> most_frequent_ratings([(1, 4), (2, 3), (1, 3), (2, 3), (2, 4), (1, 5)]) {1: 3, 2: 3} from solution import most_frequent_ratings def test_multiple_users(): ratings = [(1, 4), (2, 3), (1, 3), (2, 3), (2, 4), (1, 5)] assert most_frequent_ratings(ratings) == {1: 3, 2: 3} def test_single_user_single_rating(): ratings = [(1, 4)] assert most_frequent_ratings(ratings) == {1: 4} def test_single_user_multiple_ratings(): ratings = [(1, 5), (1, 5), (1, 6)] assert most_frequent_ratings(ratings) == {1: 5} def test_tie_in_frequent_ratings(): ratings = [(1, 5), (1, 5), (1, 4), (1, 4)] assert most_frequent_ratings(ratings) == {1: 4} def test_multiple_users_different_patterns(): ratings = [(1, 5), (1, 5), (1, 6), (2, 5), (2, 6), (3, 7)] assert most_frequent_ratings(ratings) == {1: 5, 2: 5, 3: 7} def test_all_ratings_unique(): ratings = [(1, 4), (2, 5), (3, 6)] assert most_frequent_ratings(ratings) == {1: 4, 2: 5, 3: 6}","solution":"from collections import defaultdict, Counter def most_frequent_ratings(ratings): Identify the most frequent rating provided by each user. Args: ratings (list): A list of tuples containing user ID and their rating. Returns: dict: A dictionary where the keys are user IDs and the values are the most frequent ratings. user_ratings = defaultdict(list) # Populate the dictionary with user ratings for user_id, rating in ratings: user_ratings[user_id].append(rating) most_freq_ratings = {} # Find the most frequent rating for each user for user_id, ratings in user_ratings.items(): rating_counts = Counter(ratings) max_freq = max(rating_counts.values()) most_freq_rating = min([rating for rating, freq in rating_counts.items() if freq == max_freq]) most_freq_ratings[user_id] = most_freq_rating return most_freq_ratings"},{"question":"def sum_of_two_largest_unique_numbers(arr): Returns the sum of the two largest unique numbers in the array. If the array does not contain at least two unique numbers, returns 0. >>> sum_of_two_largest_unique_numbers([1, 2, 3, 4, 5]) 9 >>> sum_of_two_largest_unique_numbers([10, 10, 10, 10, 10]) 0 >>> sum_of_two_largest_unique_numbers([1, 1, 2, 3]) 5 >>> sum_of_two_largest_unique_numbers([1, 2, 2, 3, 3]) 5 >>> sum_of_two_largest_unique_numbers([1]) 0 >>> sum_of_two_largest_unique_numbers([]) 0 >>> sum_of_two_largest_unique_numbers([2, 2, 3, 3, 3, 3]) 5 >>> sum_of_two_largest_unique_numbers([-10, -10, -20, -30]) -30 >>> sum_of_two_largest_unique_numbers([-1, -2, -3, 5, 6]) 11","solution":"def sum_of_two_largest_unique_numbers(arr): Returns the sum of the two largest unique numbers in the array. If the array does not contain at least two unique numbers, returns 0. unique_numbers = list(set(arr)) if len(unique_numbers) < 2: return 0 unique_numbers.sort(reverse=True) return unique_numbers[0] + unique_numbers[1]"},{"question":"from typing import List, Tuple, Union def sort_books(books: List[List[Union[str, int]]]) -> List[Tuple[str, str]]: Sorts and returns a list of tuples with the author's name followed by the title of the book sorted by author's name in ascending order, by publication year in descending order, and by title in ascending order. :param books: List of books where each book is represented by a list of [title, author, year] :return: Sorted list of tuples [(author, title)] Test Cases: >>> sort_books([ ... [\\"Book A\\", \\"Author B\\", 2000], ... [\\"Book B\\", \\"Author A\\", 2001], ... [\\"Book C\\", \\"Author C\\", 2002] ... ]) == [(\\"Author A\\", \\"Book B\\"), (\\"Author B\\", \\"Book A\\"), (\\"Author C\\", \\"Book C\\")] >>> sort_books([ ... [\\"Book A\\", \\"Author A\\", 2000], ... [\\"Book B\\", \\"Author A\\", 2001], ... [\\"Book C\\", \\"Author A\\", 1999] ... ]) == [(\\"Author A\\", \\"Book B\\"), (\\"Author A\\", \\"Book A\\"), (\\"Author A\\", \\"Book C\\")] >>> sort_books([ ... [\\"Book B\\", \\"Author A\\", 2000], ... [\\"Book A\\", \\"Author A\\", 2000], ... [\\"Book C\\", \\"Author A\\", 2000] ... ]) == [(\\"Author A\\", \\"Book A\\"), (\\"Author A\\", \\"Book B\\"), (\\"Author A\\", \\"Book C\\")] >>> sort_books([ ... [\\"Book D\\", \\"Author B\\", 1990], ... [\\"Book A\\", \\"Author A\\", 2005], ... [\\"Book B\\", \\"Author A\\", 2001], ... [\\"Book C\\", \\"Author B\\", 1995] ... ]) == [(\\"Author A\\", \\"Book A\\"), (\\"Author A\\", \\"Book B\\"), (\\"Author B\\", \\"Book C\\"), (\\"Author B\\", \\"Book D\\")] >>> sort_books([]) == []","solution":"from typing import List, Tuple, Union def sort_books(books: List[List[Union[str, int]]]) -> List[Tuple[str, str]]: Sorts and returns a list of tuples with the author's name followed by the title of the book sorted by author's name in ascending order, by publication year in descending order, and by title in ascending order. :param books: List of books where each book is represented by a list of [title, author, year] :return: Sorted list of tuples [(author, title)] # Convert list of lists into list of tuples for the specified order books_tuples = [(book[1], book[0], book[2]) for book in books] # Sort based on author (asc), year (desc), and title (asc) sorted_books = sorted(books_tuples, key=lambda x: (x[0], -x[2], x[1])) # Extract only the required format (author, title) result = [(book[0], book[1]) for book in sorted_books] return result"},{"question":"def longest_palindrome_substring(s: str) -> str: Finds the longest palindromic substring in the input string s. >>> longest_palindrome_substring(\\"\\") == \\"\\" >>> longest_palindrome_substring(\\"a\\") == \\"a\\" >>> longest_palindrome_substring(\\"abcde\\") == \\"a\\" >>> longest_palindrome_substring(\\"cbbd\\") == \\"bb\\" >>> longest_palindrome_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] >>> longest_palindrome_substring(\\"racecar\\") == \\"racecar\\" >>> longest_palindrome_substring(\\"abaxyzzyxf\\") == \\"xyzzyx\\" >>> longest_palindrome_substring(\\"bananas\\") == \\"anana\\" # Your code here","solution":"def longest_palindrome_substring(s): Finds the longest palindromic substring in the input string s. if not s: return \\"\\" n = len(s) start = 0 max_length = 1 table = [[False for x in range(n)] for y in range(n)] for i in range(n): table[i][i] = True for i in range(n-1): if s[i] == s[i+1]: table[i][i+1] = True start = i max_length = 2 for k in range(3, n+1): for i in range(n-k+1): j = i + k - 1 if table[i+1][j-1] and s[i] == s[j]: table[i][j] = True start = i max_length = k return s[start:start + max_length]"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns a list where each element is the product of all the numbers in the input list except the one at the current index. Args: nums (list): a list of integers Returns: list: a list of products >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 1, 2, 3]) [6, 0, 0, 0] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_except_self([7, 9, 3, 4]) [108, 84, 252, 189] >>> product_except_self([]) []","solution":"def product_except_self(nums): Returns a list where each element is the product of all the numbers in the input list except the one at the current index. Args: nums (list): a list of integers Returns: list: a list of products length = len(nums) if length == 0: return [] left_products = [1] * length right_products = [1] * length output = [1] * length # Compute products from the left side for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] # Compute products from the right side for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Combine the products for i in range(length): output[i] = left_products[i] * right_products[i] return output"},{"question":"def rearrange_array(arr): Rearranges the elements of the array such that all negative numbers appear before all positive numbers, while preserving their relative order. Args: arr (list): The array of integers to be rearranged. Example: >>> arr = [1, -2, 3, 4, -5, -6, 7, 8] >>> rearrange_array(arr) >>> print(arr) [-2, -5, -6, 1, 3, 4, 7, 8] # Your code here pass def test_mixed_numbers(): arr = [1, -2, 3, 4, -5, -6, 7, 8] rearrange_array(arr) assert arr == [-2, -5, -6, 1, 3, 4, 7, 8] def test_all_negative_numbers(): arr = [-1, -2, -3, -4] rearrange_array(arr) assert arr == [-1, -2, -3, -4] def test_all_positive_numbers(): arr = [1, 2, 3, 4] rearrange_array(arr) assert arr == [1, 2, 3, 4] def test_empty_array(): arr = [] rearrange_array(arr) assert arr == [] def test_single_negative(): arr = [-1] rearrange_array(arr) assert arr == [-1] def test_single_positive(): arr = [1] rearrange_array(arr) assert arr == [1] def test_no_change_required(): arr = [-3, -2, 1, 2] rearrange_array(arr) assert arr == [-3, -2, 1, 2] def test_already_sorted(): arr = [-5, -3, 1, 4] rearrange_array(arr) assert arr == [-5, -3, 1, 4]","solution":"def rearrange_array(arr): This function rearranges the elements of the array such that all negative numbers appear before all positive numbers, while preserving their relative order. # Initialize pointers for the next position of negative and positive elements. neg_pointer = 0 # Traverse the array and check elements. for i in range(len(arr)): if arr[i] < 0: if i != neg_pointer: arr.insert(neg_pointer, arr.pop(i)) neg_pointer += 1 return arr"},{"question":"from typing import List def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Given a list of intervals representing lines on a 2D plane, merge all overlapping intervals and return the resulting list of non-overlapping intervals. >>> merge_intervals([[1, 3], [2, 4], [5, 7]]) == [[1, 4], [5, 7]] >>> merge_intervals([[1, 5], [6, 9]]) == [[1, 5], [6, 9]] def add_interval(intervals: List[List[int]], new_interval: List[int]) -> List[List[int]]: Adds a new interval to the list and merges if there are overlapping intervals. >>> add_interval([[1, 5], [6, 9]], [2, 6]) == [[1, 9]] >>> add_interval([[1, 4], [5, 8], [9, 12]], [4, 5]) == [[1, 8], [9, 12]] def remove_interval(intervals: List[List[int]], remove_interval: List[int]) -> List[List[int]]: Removes an interval from the list and merges the rest if necessary. >>> remove_interval([[1, 4], [5, 8], [9, 12]], [5, 8]) == [[1, 4], [9, 12]] >>> remove_interval([[1, 3], [3, 6], [7, 9]], [3, 6]) == [[1, 3], [7, 9]]","solution":"def merge_intervals(intervals): Merges the overlapping intervals. if not intervals: return [] intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last_merged = merged[-1] if current[0] <= last_merged[1]: last_merged[1] = max(last_merged[1], current[1]) else: merged.append(current) return merged def add_interval(intervals, new_interval): Adds a new interval and merges if there are overlapping intervals. intervals.append(new_interval) return merge_intervals(intervals) def remove_interval(intervals, remove_interval): Removes an interval and then merges the rest if necessary. new_intervals = [interval for interval in intervals if interval != remove_interval] return merge_intervals(new_intervals)"},{"question":"def three_sum(nums: List[int], k: int) -> bool: Determines whether there are three distinct elements within the list that sum up to k. Args: nums (list of int): List of integers. k (int): Target sum. Returns: bool: True if there are three distinct elements that sum up to k, otherwise False. >>> three_sum([12, 3, 4, 1, 6, 9], 24) True >>> three_sum([1, 2, 3], 7) False >>> three_sum([], 5) False >>> three_sum([-1, 2, 1, -4, 5], 0) True >>> three_sum([1, 2, 4, 5, 10], 11) True >>> three_sum([1, 2], 3) False","solution":"def three_sum(nums, k): Determines whether there are three distinct elements within the list that sum up to k. Args: nums (list of int): List of integers. k (int): Target sum. Returns: bool: True if there are three distinct elements that sum up to k, otherwise False. nums.sort() n = len(nums) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == k: return True elif current_sum < k: left += 1 else: right -= 1 return False"},{"question":"def sort_students_by_GPA(students): Takes a list of dictionaries containing information about students and returns a new list sorted by GPA in ascending order. If two students have the same GPA, sorts them by their name in alphabetical order. :param students: List[Dict[str, Any]]: a list of dictionaries containing student information :return: List[Dict[str, Any]]: sorted list of dictionaries >>> sort_students_by_GPA([{\\"name\\": \\"Alice\\", \\"age\\": 23, \\"GPA\\": 3.5}]) [{\\"name\\": \\"Alice\\", \\"age\\": 23, \\"GPA\\": 3.5}] >>> students = [ ... {\\"name\\": \\"Bob\\", \\"age\\": 21, \\"GPA\\": 3.7}, ... {\\"name\\": \\"David\\", \\"age\\": 24, \\"GPA\\": 3.9}, ... {\\"name\\": \\"Alice\\", \\"age\\": 23, \\"GPA\\": 3.5} ... ] >>> sort_students_by_GPA(students) [ {\\"name\\": \\"Alice\\", \\"age\\": 23, \\"GPA\\": 3.5}, {\\"name\\": \\"Bob\\", \\"age\\": 21, \\"GPA\\": 3.7}, {\\"name\\": \\"David\\", \\"age\\": 24, \\"GPA\\": 3.9} ] >>> students = [ ... {\\"name\\": \\"Alice\\", \\"age\\": 23, \\"GPA\\": 3.5}, ... {\\"name\\": \\"Chris\\", \\"age\\": 22, \\"GPA\\": 3.5}, ... {\\"name\\": \\"Bob\\", \\"age\\": 21, \\"GPA\\": 3.7}, ... {\\"name\\": \\"David\\", \\"age\\": 24, \\"GPA\\": 3.9} ... ] >>> sort_students_by_GPA(students) [ {\\"name\\": \\"Alice\\", \\"age\\": 23, \\"GPA\\": 3.5}, {\\"name\\": \\"Chris\\", \\"age\\": 22, \\"GPA\\": 3.5}, {\\"name\\": \\"Bob\\", \\"age\\": 21, \\"GPA\\": 3.7}, {\\"name\\": \\"David\\", \\"age\\": 24, \\"GPA\\": 3.9} ] >>> students = [ ... {\\"name\\": \\"Alice\\", \\"age\\": 23, \\"GPA\\": 3.5}, ... {\\"name\\": \\"Bob\\", \\"age\\": 21, \\"GPA\\": 3.5}, ... {\\"name\\": \\"Chris\\", \\"age\\": 22, \\"GPA\\": 3.5}, ... {\\"name\\": \\"David\\", \\"age\\": 24, \\"GPA\\": 3.5} ... ] >>> sort_students_by_GPA(students) [ {\\"name\\": \\"Alice\\", \\"age\\": 23, \\"GPA\\": 3.5}, {\\"name\\": \\"Bob\\", \\"age\\": 21, \\"GPA\\": 3.5}, {\\"name\\": \\"Chris\\", \\"age\\": 22, \\"GPA\\": 3.5}, {\\"name\\": \\"David\\", \\"age\\": 24, \\"GPA\\": 3.5} ] >>> sort_students_by_GPA([]) []","solution":"def sort_students_by_GPA(students): Takes a list of dictionaries containing information about students and returns a new list sorted by GPA in ascending order. If two students have the same GPA, sorts them by their name in alphabetical order. :param students: List[Dict[str, Any]]: a list of dictionaries containing student information :return: List[Dict[str, Any]]: sorted list of dictionaries return sorted(students, key=lambda s: (s[\\"GPA\\"], s[\\"name\\"]))"},{"question":"def cumulative_sum(nums: List[int]) -> List[int]: Returns a new list where each element is the sum of itself and all previous elements from the original list. >>> cumulative_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> cumulative_sum([4, -1, 2, 0, -3]) [4, 3, 5, 5, 2]","solution":"def cumulative_sum(nums): Returns a new list where each element is the sum of itself and all previous elements from the original list. result = [] current_sum = 0 for num in nums: current_sum += num result.append(current_sum) return result"},{"question":"def longest_consecutive_sequence(nums: List[int]) -> int: Determines the longest sequence of consecutive integers in an array. >>> longest_consecutive_sequence([]) == 0 >>> longest_consecutive_sequence([1]) == 1 >>> longest_consecutive_sequence([100, 200, 300]) == 1 >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) == 4 >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2, 5, 6]) == 6 >>> longest_consecutive_sequence([1, 2, 2, 3]) == 3 >>> longest_consecutive_sequence([-1, -2, -3, 0]) == 4","solution":"def longest_consecutive_sequence(nums): Determines the longest sequence of consecutive integers in an array. Args: nums: List[int] - A list of integers Returns: int - The length of the longest consecutive sequence if not nums: return 0 num_set = set(nums) longest_sequence = 0 for num in nums: # If this number is the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_sequence = max(longest_sequence, current_streak) return longest_sequence"},{"question":"class BankQueue: def __init__(self): self.queue = [] def join_queue(self, name): Add a customer to the queue with the given name. >>> queue.join_queue(\\"Alice\\") def serve_customer(self): Serve the next customer in the queue. >>> queue.serve_customer() 'Alice' >>> queue.serve_customer() 'No customers in the queue to serve' def current_queue(self): Return the list of all customers currently in the queue. >>> queue.current_queue() ['Alice', 'Bob']","solution":"class BankQueue: def __init__(self): self.queue = [] def join_queue(self, name): self.queue.append(name) def serve_customer(self): if self.queue: return self.queue.pop(0) else: return \\"No customers in the queue to serve\\" def current_queue(self): return self.queue # Example usage: # queue = BankQueue() # queue.join_queue(\\"Alice\\") # queue.join_queue(\\"Bob\\") # print(queue.current_queue()) # Expected output: [\\"Alice\\", \\"Bob\\"] # print(queue.serve_customer()) # Expected output: \\"Alice\\" # print(queue.current_queue()) # Expected output: [\\"Bob\\"] # print(queue.serve_customer()) # Expected output: \\"Bob\\" # print(queue.serve_customer()) # Expected output: \\"No customers in the queue to serve\\" # print(queue.current_queue()) # Expected output: []"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): Insert a node with the given key into the BST. pass def in_order_traversal(self): Perform an in-order traversal of the BST and return the elements in ascending order. >>> bst = construct_bst_from_array([5, 3, 8, 1, 4, 7, 10]) >>> bst.in_order_traversal() [1, 3, 4, 5, 7, 8, 10] >>> bst = construct_bst_from_array([]) >>> bst.in_order_traversal() [] pass def search(self, key): Search for a node with the given key in the BST. >>> bst = construct_bst_from_array([5, 3, 8, 1, 4, 7, 10]) >>> bst.search(8) True >>> bst.search(1) True >>> bst.search(6) False >>> bst.search(11) False pass def construct_bst_from_array(arr): Construct a BST from an array of integers and return the BST. >>> bst = construct_bst_from_array([5, 3, 8, 1, 4, 7, 10]) >>> bst.in_order_traversal() [1, 3, 4, 5, 7, 8, 10] pass","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = TreeNode(key) else: self._insert(root.left, key) else: if root.right is None: root.right = TreeNode(key) else: self._insert(root.right, key) def in_order_traversal(self): res = [] self._in_order_traversal(self.root, res) return res def _in_order_traversal(self, root, res): if root: self._in_order_traversal(root.left, res) res.append(root.val) self._in_order_traversal(root.right, res) def search(self, key): return self._search(self.root, key) def _search(self, root, key): if root is None or root.val == key: return root is not None if key < root.val: return self._search(root.left, key) return self._search(root.right, key) def construct_bst_from_array(arr): bst = BinarySearchTree() for num in arr: bst.insert(num) return bst"},{"question":"def longest_common_prefix(strs): Returns the longest common prefix string among an array of strings. If there is no common prefix, returns an empty string. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) \\"\\" >>> longest_common_prefix([]) \\"\\" >>> longest_common_prefix([\\"single\\"]) \\"single\\" >>> longest_common_prefix([\\"test\\", \\"test\\", \\"test\\"]) \\"test\\" >>> longest_common_prefix([\\"a\\", \\"a\\", \\"a\\"]) \\"a\\" >>> longest_common_prefix([\\"a\\", \\"b\\", \\"c\\"]) \\"\\" >>> longest_common_prefix([\\"interview\\", \\"intermediate\\", \\"internet\\", \\"interval\\"]) \\"inter\\" >>> longest_common_prefix([\\"prefix\\", \\"prefixes\\", \\"prefixing\\", \\"prefix\\"]) \\"prefix\\"","solution":"def longest_common_prefix(strs): Returns the longest common prefix string amongst an array of strings. If there is no common prefix, returns an empty string. if not strs: return \\"\\" # The shortest string will limit the length of the common prefix shortest_str = min(strs, key=len) for i, char in enumerate(shortest_str): for other in strs: if other[i] != char: return shortest_str[:i] return shortest_str"},{"question":"def flatten_nested_lists(nested_lists: list) -> list: Flatten a list of nested lists into a single list. >>> flatten_nested_lists([1, [2, [3, 4], 5], [6, [7, 8]]]) == [1, 2, 3, 4, 5, 6, 7, 8] >>> flatten_nested_lists([[1, 2, [3]], [4, 5], 6]) == [1, 2, 3, 4, 5, 6]","solution":"def flatten_nested_lists(nested_lists): Flatten a list of nested lists into a single list. :param nested_lists: List that may contain integers and/or other lists of integers. :return: A flattened single list containing all the integers from the nested_lists in the same order. flat_list = [] for item in nested_lists: if isinstance(item, list): flat_list.extend(flatten_nested_lists(item)) else: flat_list.append(item) return flat_list"},{"question":"class TaskManager: A class to manage a task list for a project. The task list supports the following operations: adding a task, marking a task as complete, and removing a task. Each task has a unique identifier, description, and a status indicating whether it is complete or not. def __init__(self): self.tasks = {} def add_task(self, identifier: int, description: str): Adds a new task with the given identifier and description. If a task with the same identifier already exists, raises a ValueError. :param identifier: Unique identifier for the task :param description: Description of the task pass def mark_task_complete(self, identifier: int): Marks the task with the given identifier as complete. If the task does not exist, raises a ValueError. :param identifier: Unique identifier for the task pass def remove_task(self, identifier: int): Removes the task with the given identifier. If the task does not exist, raises a ValueError. :param identifier: Unique identifier for the task pass def list_tasks(self): Returns a list of all tasks with their identifier, description, and status. :return: List of dictionaries representing the tasks pass # Test cases import pytest def test_add_task(): tm = TaskManager() tm.add_task(1, \\"Task 1\\") assert tm.list_tasks() == [{'identifier': 1, 'description': \\"Task 1\\", 'complete': False}] def test_add_task_with_existing_identifier(): tm = TaskManager() tm.add_task(1, \\"Task 1\\") with pytest.raises(ValueError, match=\\"Task with this identifier already exists.\\"): tm.add_task(1, \\"Task 1\\") def test_mark_task_complete(): tm = TaskManager() tm.add_task(1, \\"Task 1\\") tm.mark_task_complete(1) assert tm.list_tasks() == [{'identifier': 1, 'description': \\"Task 1\\", 'complete': True}] def test_mark_task_complete_non_existent(): tm = TaskManager() with pytest.raises(ValueError, match=\\"Task with this identifier does not exist.\\"): tm.mark_task_complete(1) def test_remove_task(): tm = TaskManager() tm.add_task(1, \\"Task 1\\") tm.remove_task(1) assert tm.list_tasks() == [] def test_remove_task_non_existent(): tm = TaskManager() with pytest.raises(ValueError, match=\\"Task with this identifier does not exist.\\"): tm.remove_task(1) def test_list_tasks(): tm = TaskManager() tm.add_task(1, \\"Task 1\\") tm.add_task(2, \\"Task 2\\") tm.mark_task_complete(1) assert tm.list_tasks() == [ {'identifier': 1, 'description': \\"Task 1\\", 'complete': True}, {'identifier': 2, 'description': \\"Task 2\\", 'complete': False} ]","solution":"class TaskManager: def __init__(self): self.tasks = {} # Using a dictionary to store tasks with their unique identifiers def add_task(self, identifier, description): if identifier in self.tasks: raise ValueError(\\"Task with this identifier already exists.\\") self.tasks[identifier] = {'description': description, 'complete': False} def mark_task_complete(self, identifier): if identifier not in self.tasks: raise ValueError(\\"Task with this identifier does not exist.\\") self.tasks[identifier]['complete'] = True def remove_task(self, identifier): if identifier not in self.tasks: raise ValueError(\\"Task with this identifier does not exist.\\") del self.tasks[identifier] def list_tasks(self): return [{'identifier': id, **details} for id, details in self.tasks.items()]"},{"question":"def fibonacci_sequence(n: int) -> List[int]: Returns a list of the first n Fibonacci numbers. >>> fibonacci_sequence(0) [] >>> fibonacci_sequence(1) [0] >>> fibonacci_sequence(2) [0, 1] >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci_sequence(n): Returns a list of the first n Fibonacci numbers. if n <= 0: return [] elif n == 1: return [0] sequence = [0, 1] while len(sequence) < n: next_value = sequence[-1] + sequence[-2] sequence.append(next_value) return sequence"},{"question":"def strings_to_length_dict(strings: List[str]) -> Dict[str, int]: Returns a dictionary where each key is a string from the input list and the value is the length of that string. Only strings containing alphabetic characters are included. >>> strings_to_length_dict([]) == {} >>> strings_to_length_dict([\\"apple\\", \\"banana\\", \\"carrot\\"]) == {\\"apple\\": 5, \\"banana\\": 6, \\"carrot\\": 6} >>> strings_to_length_dict([\\"apple1\\", \\"banana!\\", \\"carrot\\"]) == {\\"carrot\\": 6} >>> strings_to_length_dict([\\"apple\\", \\"123\\", \\"Banana\\", \\"!\\", \\"\\"]) == {\\"apple\\": 5, \\"Banana\\": 6} >>> strings_to_length_dict([\\"pear\\"]) == {\\"pear\\": 4}","solution":"def strings_to_length_dict(strings): Returns a dictionary where each key is a string from the input list and the value is the length of that string. Only strings containing alphabetic characters are included. return {s: len(s) for s in strings if s.isalpha()}"},{"question":"class Singleton: Singleton class ensuring only one instance is created with an access count. Example: >>> singleton1 = Singleton.get_instance() >>> singleton2 = Singleton.get_instance() >>> singleton1 is singleton2 True >>> singleton1.increment_access_count() >>> singleton2.increment_access_count() >>> singleton1.get_access_count() 2 >>> singleton2.get_access_count() 2 _instance = None _access_count = 0 def __init__(self): if Singleton._instance is not None: raise Exception(\\"This class is a singleton!\\") @classmethod def get_instance(cls): pass def increment_access_count(self): pass def get_access_count(self): pass","solution":"class Singleton: _instance = None _access_count = 0 def __init__(self): if Singleton._instance is not None: raise Exception(\\"This class is a singleton!\\") else: Singleton._instance = self @classmethod def get_instance(cls): if cls._instance is None: cls._instance = Singleton() cls._access_count += 1 return cls._instance def increment_access_count(self): Singleton._access_count += 1 def get_access_count(self): return Singleton._access_count"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring which contains at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring which contains at most two distinct characters. if not s: return 0 left = 0 max_length = 0 char_count = {} for right in range(len(s)): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def find_peak(nums: List[int]) -> int: Write a function that receives a list of integers and returns the index of the first peak element. A peak element is an element that is greater than its neighbors. If the input list is empty or no peak exists, return -1. A peak at the first or last position is acceptable. >>> find_peak([1, 3, 2, 5, 4]) 1 >>> find_peak([1, 2, 3, 2, 3, 0]) [2, 4] >>> find_peak([]) -1 >>> find_peak([1, 1, 1, 1]) -1","solution":"def find_peak(nums): Returns the index of the first peak element in the list. A peak element is an element that is greater than its neighbors. If the list is empty or no peak exists, returns -1. if not nums: return -1 n = len(nums) for i in range(n): if (i == 0 or nums[i] > nums[i - 1]) and (i == n - 1 or nums[i] > nums[i + 1]): return i return -1"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def merge_sorted_lists(l1, l2): Merge two sorted linked lists into one sorted linked list in place. >>> l1 = ListNode(1) ... l1.next = ListNode(3) ... l1.next.next = ListNode(5) ... l2 = ListNode(2) ... l2.next = ListNode(4) ... l2.next.next = ListNode(6) ... merged = merge_sorted_lists(l1, l2) ... while merged: ... print(merged.val, end=\\" \\") ... merged = merged.next 1 2 3 4 5 6 >>> l1 = ListNode(1) ... l1.next = ListNode(3) ... l1.next.next = ListNode(5) ... merged = merge_sorted_lists(l1, None) ... while merged: ... print(merged.val, end=\\" \\") 1 3 5 >>> merged = merge_sorted_lists(None, None) >>> print(merged is None) True","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def merge_sorted_lists(l1, l2): Merge two sorted linked lists into one sorted linked list in place. # Dummy node to hang the result on dummy = ListNode(0) tail = dummy # Traverse both lists and compare each node while l1 and l2: if l1.val <= l2.val: tail.next, l1 = l1, l1.next else: tail.next, l2 = l2, l2.next tail = tail.next # At this point, at least one of l1 or l2 is None tail.next = l1 if l1 is not None else l2 return dummy.next"},{"question":"class ProjectManagementTool: Develop a web-based project management tool that allows teams to create, assign, and track tasks in real-time. The application should support user authentication and role-based access to ensure that only authorized users can make changes. Implement a notification system that alerts users of any updates or changes to tasks they are involved with. Additionally, the tool should provide a dashboard displaying key metrics such as task progress, upcoming deadlines, and team performance statistics. Consider handling concurrency issues and data integrity to maintain the app's reliability. The system should also be designed with a scalable architecture to accommodate growing user data and functionality needs. >>> pm_tool = ProjectManagementTool() >>> pm_tool.create_task(1, \\"Design Homepage\\") True >>> pm_tool.create_task(2, \\"Develop Backend\\") True >>> pm_tool.assign_task(1, \\"Alice\\") >>> pm_tool.get_notifications() [\\"Task 1 assigned to Alice\\"] def __init__(self): self.tasks = {} # A dictionary to store tasks with their assigned users self.notifications = [] # A list to keep track of notifications def create_task(self, task_id, task_name): # code here def assign_task(self, task_id, user): # code here def get_notifications(self): # code here","solution":"class ProjectManagementTool: def __init__(self): self.tasks = {} # A dictionary to store tasks with their assigned users self.notifications = [] # A list to keep track of notifications def create_task(self, task_id, task_name): if task_id not in self.tasks: self.tasks[task_id] = {\\"name\\": task_name, \\"assigned_user\\": None} return True return False def assign_task(self, task_id, user): if task_id in self.tasks: self.tasks[task_id]['assigned_user'] = user self.notifications.append(f\\"Task {task_id} assigned to {user}\\") return True return False def get_notifications(self): return self.notifications"},{"question":"def filter_dict_by_keys(input_dict, keys): Returns a dictionary containing only the key-value pairs corresponding to the keys from the input list that exist in the original dictionary. If the first argument is not a dictionary, raises a ValueError. >>> filter_dict_by_keys({'a': 1, 'b': 2, 'c': 3}, ['a', 'c']) {'a': 1, 'c': 3} >>> filter_dict_by_keys({'a': 1, 'b': 2, 'c': 3}, ['x', 'y']) {} >>> filter_dict_by_keys({'a': 1, 'b': 2, 'c': 3}, ['a', 'x', 'c']) {'a': 1, 'c': 3} >>> filter_dict_by_keys({}, ['a', 'b']) {} >>> filter_dict_by_keys({'a': 1, 'b': 2, 'c': 3}, []) {} >>> filter_dict_by_keys(123, ['a', 'b']) Traceback (most recent call last): ... ValueError: First argument must be a dictionary","solution":"def filter_dict_by_keys(input_dict, keys): Returns a dictionary containing only the key-value pairs corresponding to the keys from the input list that exist in the original dictionary. If the first argument is not a dictionary, raises a ValueError. if not isinstance(input_dict, dict): raise ValueError(\\"First argument must be a dictionary\\") return {key: input_dict[key] for key in keys if key in input_dict}"},{"question":"def min_path_sum(grid: List[List[int]]) -> int: Returns the minimum sum obtained by following a path from the top-left corner to the bottom-right corner of the grid, moving only down or right at any point in time. >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21 >>> min_path_sum([[1, 2, 3]]) 6 >>> min_path_sum([[1], [2], [3]]) 6 >>> min_path_sum([[0]]) 0 >>> min_path_sum([[1, 3, 1, 2], [1, 5, 1, 3], [4, 2, 1, 1], [2, 1, 1, 1]]) 9","solution":"def min_path_sum(grid): Returns the minimum sum obtained by following a path from the top-left corner to the bottom-right corner of the grid, moving only down or right at any point in time. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first column of dp table for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the first row of dp table for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill in the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"from typing import List def sort_even_before_odd(arr: List[int]) -> List[int]: Sort the array such that all the even numbers appear before all the odd numbers, while maintaining the original relative order of both even and odd numbers. >>> sort_even_before_odd([3, 8, 5, 12, 9, 1]) [8, 12, 3, 5, 9, 1] def test_example_case(): assert sort_even_before_odd([3, 8, 5, 12, 9, 1]) == [8, 12, 3, 5, 9, 1] def test_all_evens(): assert sort_even_before_odd([2, 4, 6, 8]) == [2, 4, 6, 8] def test_all_odds(): assert sort_even_before_odd([1, 3, 5, 7]) == [1, 3, 5, 7] def test_mixture(): assert sort_even_before_odd([7, 5, 4, 2, 3, 8]) == [4, 2, 8, 7, 5, 3] def test_empty(): assert sort_even_before_odd([]) == [] def test_single_even(): assert sort_even_before_odd([2]) == [2] def test_single_odd(): assert sort_even_before_odd([3]) == [3] def test_already_sorted_even_odd(): assert sort_even_before_odd([2, 4, 6, 3, 5, 9]) == [2, 4, 6, 3, 5, 9]","solution":"from typing import List def sort_even_before_odd(arr: List[int]) -> List[int]: Sort the array such that all the even numbers appear before all the odd numbers, while maintaining the original relative order of both even and odd numbers. even_part = [x for x in arr if x % 2 == 0] odd_part = [x for x in arr if x % 2 != 0] return even_part + odd_part # Example usage # sorted_array = sort_even_before_odd([3, 8, 5, 12, 9, 1]) # print(sorted_array) # Output: [8, 12, 3, 5, 9, 1]"},{"question":"from typing import List def max_water_trapped(elevations: List[int]) -> int: Implement a function that takes a list of integers representing elevations and returns the maximum amount of water that can be trapped after raining. >>> max_water_trapped([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> max_water_trapped([1, 2, 3, 4, 5]) == 0 >>> max_water_trapped([5, 4, 3, 2, 1]) == 0 >>> max_water_trapped([1]) == 0 >>> max_water_trapped([1, 2]) == 0 >>> max_water_trapped([3, 0, 3]) == 3 >>> max_water_trapped([4, 2, 0, 3, 2, 5]) == 9","solution":"from typing import List def max_water_trapped(elevations: List[int]) -> int: Calculates the maximum amount of water that can be trapped between the elevations. :param elevations: List of integers representing the elevations. :return: The maximum amount of water that can be trapped. if not elevations or len(elevations) < 3: return 0 left, right = 0, len(elevations) - 1 max_left, max_right = elevations[left], elevations[right] water_trapped = 0 while left < right: if elevations[left] < elevations[right]: left += 1 max_left = max(max_left, elevations[left]) water_trapped += max(0, max_left - elevations[left]) else: right -= 1 max_right = max(max_right, elevations[right]) water_trapped += max(0, max_right - elevations[right]) return water_trapped"},{"question":"def cumulative_sum(input_list: List[int]) -> List[int]: Returns a new list where each element is the cumulative sum of the elements up to that index. >>> cumulative_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> cumulative_sum([5]) [5] >>> cumulative_sum([5, 10]) [5, 15] >>> cumulative_sum([5, 10, 15, 20]) [5, 15, 30, 50] >>> cumulative_sum([0, 1, 2, 3]) [0, 1, 3, 6] >>> cumulative_sum([-1, -2, -3, -4]) [-1, -3, -6, -10] >>> cumulative_sum([5, -2, 3, -1]) [5, 3, 6, 5]","solution":"def cumulative_sum(input_list): Returns a new list where each element is the cumulative sum of the elements up to that index. cumulative_list = [] current_sum = 0 for num in input_list: current_sum += num cumulative_list.append(current_sum) return cumulative_list"}]`),E={name:"App",components:{PoemCard:F},data(){return{searchQuery:"",visibleCount:4,poemsData:C,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},S={class:"search-container"},I={class:"card-container"},D={key:0,class:"empty-state"},N=["disabled"],P={key:0},z={key:1};function B(n,e,l,m,i,a){const f=h("PoemCard");return s(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"prompts chat")])],-1)),t("div",S,[e[3]||(e[3]=t("span",{class:"search-icon"},"",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(s(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")},"  ")):u("",!0)]),t("div",I,[(s(!0),r(y,null,v(a.displayedPoems,(o,p)=>(s(),w(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),r("div",D,' No results found for "'+d(i.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(s(),r("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(s(),r("span",z,"Loading...")):(s(),r("span",P,"See more"))],8,N)):u("",!0)])}const j=_(E,[["render",B],["__scopeId","data-v-d214174c"]]),U=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"grok/20.md","filePath":"grok/20.md"}'),M={name:"grok/20.md"},G=Object.assign(M,{setup(n){return(e,l)=>(s(),r("div",null,[x(j)]))}});export{U as __pageData,G as default};
