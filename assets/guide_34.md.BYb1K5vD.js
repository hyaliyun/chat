import{_ as c,o as s,c as r,a as t,m,t as d,C as h,M as g,U as b,f as l,F as y,p as x,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function R(i,e,u,_,n,a){return s(),r("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),m(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),m(d(u.poem.solution),1)])])])}const A=c(q,[["render",R],["__scopeId","data-v-79486936"]]),E=JSON.parse(`[{"question":"def smallest_rectangle(L: int, M: int, positions: List[Tuple[int, int]]) -> Tuple[int, int]: Given the side length L of the garden and M positions of rare flowering plants, returns the dimensions of the smallest rectangle that can enclose all the rare plants after any number of row transitions. Parameters: L (int): the side length of the garden. M (int): the number of rare flowering plants. positions (list of tuples): the positions of the rare flowering plants. Returns: tuple: the dimensions of the smallest rectangle (height, width). >>> smallest_rectangle(5, 3, [(1, 2), (3, 3), (4, 1)]) (4, 3) >>> smallest_rectangle(6, 4, [(2, 2), (2, 4), (5, 1), (6, 5)]) (5, 5) >>> smallest_rectangle(4, 1, [(1, 1)]) (1, 1) >>> smallest_rectangle(5, 3, [(1, 2), (3, 2), (5, 2)]) (5, 1) >>> smallest_rectangle(5, 3, [(1, 1), (1, 2), (1, 5)]) (1, 5) >>> smallest_rectangle(5, 3, [(2, 2), (2, 3), (2, 4)]) (1, 3) # Initialize the min and max bounds for rows and columns # Your solution goes here","solution":"def smallest_rectangle(L, M, positions): Given the side length L of the garden and M positions of rare flowering plants, returns the dimensions of the smallest rectangle that can enclose all the rare plants after any number of row transitions. Parameters: L (int): the side length of the garden. M (int): the number of rare flowering plants. positions (list of tuples): the positions of the rare flowering plants. Returns: tuple: the dimensions of the smallest rectangle (height, width). # Initialize the min and max bounds for rows and columns min_x = L max_x = 0 min_y = L max_y = 0 # Traverse through all positions to find the min and max bounds for x, y in positions: if x < min_x: min_x = x if x > max_x: max_x = x if y < min_y: min_y = y if y > max_y: max_y = y # Rectangle dimensions height = max_x - min_x + 1 width = max_y - min_y + 1 return height, width"},{"question":"from typing import List def is_pack_cheaper(item_prices: List[int], pack_price: int) -> bool: Determines if buying a pack of 5 items at a discounted price is cheaper than buying the five cheapest items individually. Parameters: item_prices (List[int]): A list of individual item prices. pack_price (int): The discounted price for a pack of 5 items. Returns: bool: True if the pack price is cheaper, False otherwise. >>> is_pack_cheaper([2, 3, 1, 5, 4, 6, 7, 8], 10) True >>> is_pack_cheaper([2, 3, 1, 5, 4, 6, 7, 8], 15) False >>> is_pack_cheaper([2, 3, 1, 5, 4, 6, 7, 8], 16) False >>> is_pack_cheaper([1, 2, 3, 4, 5], 14) True >>> is_pack_cheaper([100, 200, 3, 4, 5, 2, 1, 300], 10) True","solution":"from typing import List def is_pack_cheaper(item_prices: List[int], pack_price: int) -> bool: Determines if buying a pack of 5 items at a discounted price is cheaper than buying the five cheapest items individually. Parameters: item_prices (List[int]): A list of individual item prices. pack_price (int): The discounted price for a pack of 5 items. Returns: bool: True if the pack price is cheaper, False otherwise. # Sort the list of item prices to find the five cheapest items item_prices.sort() # Sum the five cheapest items sum_of_cheapest_five = sum(item_prices[:5]) # Compare the sum with the pack price return pack_price < sum_of_cheapest_five"},{"question":"def can_split_into_patterns(t: int, cases: list) -> list: Given a list of integers, check if it is possible to split the list into exactly k non-empty continuous subsequences such that each subsequence is a pattern of consecutive numbers that increase by 1. -----Input----- The input consists of multiple test cases. The first line contains a single integer t (1 le t le 50) — the number of test cases. The first line of each test case description contains two integers n and k (1 le n le 100, 1 le k le n) — the length of the list and the number of patterns required. The second line of each test case description contains n space-separated integers a_1, a_2, ldots, a_n (1 le a_i le 1000) — the list of integers. -----Output----- For each test case, return \\"YES\\" (without quotes) if it is possible to split the list into exactly k patterns, and \\"NO\\" (without quotes) otherwise. >>> can_split_into_patterns(4, [ ... ((6, 2), [1, 2, 3, 5, 6, 7]), ... ((5, 1), [3, 4, 5, 6, 7]), ... ((7, 3), [10, 11, 12, 1, 2, 3, 8]), ... ((4, 4), [4, 5, 6, 7]) ... ]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] >>> can_split_into_patterns(3, [ ... ((1, 1), [1]), ... ((2, 2), [1, 3]), ... ((3, 1), [5, 6, 7]) ... ]) [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_split_into_patterns(t, cases): results = [] for i in range(t): n, k = cases[i][0] nums = cases[i][1] # Step 1: Find the lengths of all continuous increasing subsequences lengths = [] current_length = 1 for j in range(1, n): if nums[j] == nums[j - 1] + 1: current_length += 1 else: lengths.append(current_length) current_length = 1 lengths.append(current_length) # Step 2: Check if we can use the found lengths to get exactly k patterns if len(lengths) < k: results.append(\\"NO\\") else: if len(lengths) == k: results.append(\\"YES\\") else: remaining_splits_needed = k - len(lengths) # Check if we have enough larger subsequences to be split further splittable_count = sum(l - 1 for l in lengths if l > 1) if splittable_count >= remaining_splits_needed: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from itertools import permutations from typing import List, Tuple def generate_permutations(A: List[str], r: int) -> List[Tuple[str, ...]]: Generates all r-length permutations of the list A. Parameters: A (list): List of characters. r (int): Length of the permutations. Returns: list: List of r-length permutations. >>> generate_permutations(['A', 'B', 'C'], 2) [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')] >>> generate_permutations(['1', '2', '3'], 3) [('1', '2', '3'), ('1', '3', '2'), ('2', '1', '3'), ('2', '3', '1'), ('3', '1', '2'), ('3', '2', '1')] >>> generate_permutations(['a', 'b'], 2) [('a', 'b'), ('b', 'a')] >>> generate_permutations(['x'], 1) [('x',)] >>> generate_permutations(['A', 'B', 'C', 'D'], 3) [(('A', 'B', 'C'), ('A', 'B', 'D'), ('A', 'C', 'B'), ('A', 'C', 'D'), ('A', 'D', 'B'), ('A', 'D', 'C'), ('B', 'A', 'C'), ('B', 'A', 'D'), ('B', 'C', 'A'), ('B', 'C', 'D'), ('B', 'D', 'A'), ('B', 'D', 'C'), ('C', 'A', 'B'), ('C', 'A', 'D'), ('C', 'B', 'A'), ('C', 'B', 'D'), ('C', 'D', 'A'), ('C', 'D', 'B'), ('D', 'A', 'B'), ('D', 'A', 'C'), ('D', 'B', 'A'), ('D', 'B', 'C'), ('D', 'C', 'A'), ('D', 'C', 'B')] ]","solution":"from itertools import permutations def generate_permutations(A, r): Generates all r-length permutations of the list A. Parameters: A (list): List of characters. r (int): Length of the permutations. Returns: list: List of r-length permutations. return list(permutations(A, r))"},{"question":"def minimize_maximum_vertical_distance(test_cases): Computes the smallest possible maximum vertical distance a drone has to cover for each test case. Parameters: test_cases (list): List of test cases, where each test case is a list of tuples representing points (x, y). Returns: list: List of minimum maximum vertical distances for each test case pass def parse_input(input_string): Parses the input string and returns structured data for processing. Parameters: input_string (str): Multi-line string input as described in the problem. Returns: list: List of test cases, where each test case is a list of tuples representing points (x, y). pass def main(input_string): Main function to handle input and call the necessary functions to get the output. Parameters: input_string (str): Multi-line string input as described in the problem. Returns: str: Output string with the results for each test case. pass input_string = '''2 4 0 0 2 1 3 -1 5 3 3 1 1 -1 3 2 -2''' if __name__ == \\"__main__\\": print(main(input_string)) # Unit Tests def test_minimize_maximum_vertical_distance(): test_cases = [ [(0, 0), (2, 1), (3, -1), (5, 3)], [(1, 1), (-1, 3), (2, -2)] ] result = minimize_maximum_vertical_distance(test_cases) assert result == ['4.00', '5.00'] def test_parse_input(): input_string = '''2 4 0 0 2 1 3 -1 5 3 3 1 1 -1 3 2 -2''' test_cases = parse_input(input_string) expected = [ [(0, 0), (2, 1), (3, -1), (5, 3)], [(1, 1), (-1, 3), (2, -2)] ] assert test_cases == expected def test_main(): input_string = '''2 4 0 0 2 1 3 -1 5 3 3 1 1 -1 3 2 -2''' result = main(input_string) expected = '4.00n5.00' assert result == expected def test_custom_case(): input_string = '''1 5 -5 -5 -5 5 5 -5 5 5 0 0''' assert main(input_string) == '10.00'","solution":"def minimize_maximum_vertical_distance(test_cases): Computes the smallest possible maximum vertical distance a drone has to cover for each test case. Parameters: test_cases (list): List of test cases, where each test case is a list of tuples representing points (x, y). Returns: list: List of minimum maximum vertical distances for each test case results = [] for points in test_cases: y_coords = [y for (x, y) in points] min_y = min(y_coords) max_y = max(y_coords) min_max_vertical_distance = max_y - min_y results.append(f\\"{min_max_vertical_distance:.2f}\\") return results def parse_input(input_string): Parses the input string and returns structured data for processing. Parameters: input_string (str): Multi-line string input as described in the problem. Returns: list: List of test cases, where each test case is a list of tuples representing points (x, y). lines = input_string.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): n = int(lines[index]) points = [] for i in range(index + 1, index + 1 + n): x, y = map(int, lines[i].split()) points.append((x, y)) index += n + 1 test_cases.append(points) return test_cases def main(input_string): test_cases = parse_input(input_string) results = minimize_maximum_vertical_distance(test_cases) return 'n'.join(results) input_string = '''2 4 0 0 2 1 3 -1 5 3 3 1 1 -1 3 2 -2''' print(main(input_string)) # Expected output: '4.00n5.00'"},{"question":"def min_palindromic_substrings(s: str) -> int: Find the minimum number of palindromic substrings a given input string can be divided into. >>> min_palindromic_substrings('racecar') == 1 >>> min_palindromic_substrings('aabbd') == 3 >>> min_palindromic_substrings('abc') == 3 >>> min_palindromic_substrings('madamimadam') == 1 pass def process_input(input_data: str) -> list: Process the input data for multiple test cases and return the results for each case. >>> process_input(\\"racecarnaabbdnabcnmadamimadamn.\\") == [1, 3, 3, 1] >>> process_input(\\"noonnlevelnrevivernkayakn.\\") == [1, 1, 1, 1] pass","solution":"def min_palindromic_substrings(s): n = len(s) # is_palindrome[i][j] will be True if the substring s[i:j+1] is a palindrome is_palindrome = [[False] * n for _ in range(n)] # Every string with one character is a palindrome for i in range(n): is_palindrome[i][i] = True # Check two character palindromes for i in range(n-1): if s[i] == s[i+1]: is_palindrome[i][i+1] = True # Check palindromes longer than two characters for length in range(3, n+1): for i in range(n-length+1): j = i + length - 1 if s[i] == s[j] and is_palindrome[i+1][j-1]: is_palindrome[i][j] = True # dp[i] will be the minimum number of palindromic substrings of s[0:i+1] dp = [float('inf')] * n for i in range(n): if is_palindrome[0][i]: dp[i] = 1 else: for j in range(i): if is_palindrome[j+1][i]: dp[i] = min(dp[i], dp[j] + 1) return dp[-1] def process_input(input_data): results = [] for line in input_data.strip().split('n'): if line == '.': break results.append(min_palindromic_substrings(line)) return results # Example inputs example_input = racecar aabbd abc madamimadam . # Process the example inputs example_output = process_input(example_input) for result in example_output: print(result)"},{"question":"from typing import List, Tuple def minimum_moves(n: int, m: int, grid: List[str], start: Tuple[int, int], target: Tuple[int, int]) -> int: Determine the minimum number of moves required to reach the target position from the start position, or return -1 if it's not possible. Parameters: n (int): Number of rows of the grid m (int): Number of columns of the grid grid (List[str]): The grid map start (Tuple[int, int]): Starting position (sr, sc) target (Tuple[int, int]): Target position (tr, tc) Returns: int: Minimum number of moves to reach the target, or -1 if impossible Examples: >>> minimum_moves(5, 5, [\\".....\\", \\".#.\\", \\".#.#.\\", \\".#.\\", \\".....\\"], (0, 0), (4, 4)) 8 >>> minimum_moves(3, 4, [\\"....\\", \\"..\\", \\"....\\"], (0, 0), (1, 2)) -1 pass def test_case_1(): n = 5 m = 5 grid = [ \\".....\\", \\".#.\\", \\".#.#.\\", \\".#.\\", \\".....\\" ] start = (0, 0) target = (4, 4) assert minimum_moves(n, m, grid, start, target) == 8 def test_case_2(): n = 3 m = 4 grid = [ \\"....\\", \\"..\\", \\"....\\" ] start = (0, 0) target = (1, 2) assert minimum_moves(n, m, grid, start, target) == -1 def test_case_3(): n = 3 m = 3 grid = [ \\"...\\", \\"...\\", \\"...\\" ] start = (0, 0) target = (2, 2) assert minimum_moves(n, m, grid, start, target) == 4 def test_case_4(): n = 2 m = 2 grid = [ \\"\\", \\"\\" ] start = (0, 0) target = (1, 1) assert minimum_moves(n, m, grid, start, target) == -1 def test_case_5(): n = 4 m = 4 grid = [ \\"....\\", \\"....\\", \\"....\\", \\"....\\" ] start = (0, 0) target = (3, 3) assert minimum_moves(n, m, grid, start, target) == 6","solution":"from collections import deque def minimum_moves(n, m, grid, start, target): sr, sc = start tr, tc = target if grid[sr][sc] == '#' or grid[tr][tc] == '#': return -1 # start or target is an obstacle directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * m for _ in range(n)] queue = deque([(sr, sc, 0)]) while queue: r, c, steps = queue.popleft() if (r, c) == (tr, tc): return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and not visited[nr][nc] and grid[nr][nc] == '.': visited[nr][nc] = True queue.append((nr, nc, steps + 1)) return -1"},{"question":"def minInsertions(s: str) -> int: Given a string consisting of lowercase English letters, find the minimum number of insertions needed to make the string a palindrome. >>> minInsertions(\\"abc\\") 2 >>> minInsertions(\\"aab\\") 1 >>> minInsertions(\\"aa\\") 0 >>> minInsertions(\\"racecar\\") 0","solution":"def minInsertions(s): def lcs(X, Y): m = len(X) n = len(Y) L = [[0] * (n + 1) for i in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: L[i][j] = 0 elif X[i - 1] == Y[j - 1]: L[i][j] = L[i - 1][j - 1] + 1 else: L[i][j] = max(L[i - 1][j], L[i][j - 1]) return L[m][n] rev_s = s[::-1] lcs_length = lcs(s, rev_s) return len(s) - lcs_length"},{"question":"from typing import List, Tuple def find_min_moves(grid: List[str], start: Tuple[int, int], treasure: Tuple[int, int]) -> int: Find the minimum number of moves required for the player to reach the treasure, avoiding obstacles. If the treasure is unreachable, return -1. >>> grid = [ ... \\"......\\", ... \\"..#.\\", ... \\"....#.\\", ... \\".#....\\", ... \\"..P.T.\\" ... ] >>> find_min_moves(grid, (4, 2), (4, 4)) 2 >>> grid = [ ... \\"\\", ... \\"#P.#\\", ... \\"#..#\\", ... \\"T#\\" ... ] >>> find_min_moves(grid, (1, 1), (3, 3)) -1","solution":"from collections import deque from typing import List, Tuple def find_min_moves(grid: List[str], start: Tuple[int, int], treasure: Tuple[int, int]) -> int: n = len(grid) m = len(grid[0]) x_start, y_start = start x_treasure, y_treasure = treasure if grid[x_start][y_start] == '#' or grid[x_treasure][y_treasure] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(x_start, y_start, 0)]) visited = set((x_start, y_start)) while queue: x, y, dist = queue.popleft() if (x, y) == treasure: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] != '#': queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"def maximalRectangle(grid): Given a 2D binary grid, find the area of the largest rectangle containing only '1's. >>> maximalRectangle([ ... [\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"0\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"0\\",\\"0\\",\\"1\\",\\"0\\"] ... ]) 6 >>> maximalRectangle([ ... [\\"0\\",\\"1\\"], ... [\\"1\\",\\"0\\"] ... ]) 1","solution":"def maximalRectangle(grid): if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) max_area = 0 height = [0] * (cols + 1) for row in range(rows): for col in range(cols): if grid[row][col] == '1': height[col] += 1 else: height[col] = 0 stack = [] for col in range(cols + 1): while stack and height[col] < height[stack[-1]]: h = height[stack.pop()] w = col if not stack else col - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(col) return max_area"},{"question":"from typing import List def most_valuable_planet(planets: List[List[int]], fruit_values: List[int]) -> int: Determine the most valuable planet based on fruit production and values. Args: planets (List[List[int]]): A list of planets, each with a list of integers representing the quantity of fruit produced each day. fruit_values (List[int]): A list of integers representing the value of each type of fruit for a specific day. Returns: int: The index of the most valuable planet for the given day. If there are multiple planets with the same highest value, return the smallest index. Examples: >>> most_valuable_planet([[3, 2, 1], [1, 1, 10], [4, 0, 0]], [2, 3, 8]) 1 >>> most_valuable_planet([[0, 0, 0], [0, 0, 0]], [0, 0, 0]) 0 >>> most_valuable_planet([[5, 7, 2]], [2, 3, 4]) 0 >>> most_valuable_planet([[2, 2], [1, 3]], [1, 1]) 0 >>> most_valuable_planet([[1, -2], [2, -1]], [3, 4]) 1 >>> most_valuable_planet([[1, 2], [3, 4]], [-1, -2]) 0","solution":"from typing import List def most_valuable_planet(planets: List[List[int]], fruit_values: List[int]) -> int: max_value = float('-inf') best_planet_index = -1 for i, planet in enumerate(planets): planet_value = sum(quantity * value for quantity, value in zip(planet, fruit_values)) if planet_value > max_value: max_value = planet_value best_planet_index = i return best_planet_index"},{"question":"def max_area_of_island(grid): Returns the maximum area of an island in the given m x n grid. >>> max_area_of_island([['1', '1', '0', '0', '0'], ... ['1', '1', '0', '0', '0'], ... ['0', '0', '1', '0', '0'], ... ['0', '0', '0', '1', '1']]) 4 >>> max_area_of_island([['1', '1', '0'], ... ['0', '0', '0'], ... ['1', '1', '0']]) 2 >>> max_area_of_island([['0', '0', '0'], ... ['0', '0', '0'], ... ['0', '0', '0']]) 0 >>> max_area_of_island([['1', '0', '0', '1'], ... ['0', '1', '0', '0'], ... ['1', '0', '1', '1'], ... ['0', '0', '1', '0']]) 3 >>> max_area_of_island([['1']]) 1 >>> max_area_of_island([['1', '0', '1', '0'], ... ['0', '1', '0', '1'], ... ['1', '0', '1', '0']]) 1","solution":"def max_area_of_island(grid): Returns the maximum area of an island in the given m x n grid. if not grid: return 0 m, n = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == '0': return 0 grid[x][y] = '0' # mark as visited area = 1 area += dfs(x - 1, y) area += dfs(x + 1, y) area += dfs(x, y - 1) area += dfs(x, y + 1) return area max_area = 0 for i in range(m): for j in range(n): if grid[i][j] == '1': max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a fully parenthesized mathematical expression containing integers, addition, and multiplication operations. >>> evaluate_expression(\\"3+(2*2)\\") 7 >>> evaluate_expression(\\"(1+1)*(3+2)\\") 10 >>> evaluate_expression(\\"(3+((2+1)*(2*2)))\\") 15","solution":"def evaluate_expression(expression): Evaluates a fully parenthesized mathematical expression containing integers, addition and multiplication operations. def compute(tokens): stack = [] for token in tokens: if token == '+': stack.append(stack.pop() + stack.pop()) elif token == '*': stack.append(stack.pop() * stack.pop()) else: stack.append(int(token)) return stack[0] def tokenize(expr): tokens, num, i = [], \\"\\", 0 while i < len(expr): if expr[i].isdigit(): num += expr[i] else: if num: tokens.append(num) num = \\"\\" if expr[i] in \\"+*()\\": tokens.append(expr[i]) i += 1 if num: tokens.append(num) return tokens def to_postfix(tokens): output = [] ops = [] for token in tokens: if token.isdigit(): output.append(token) elif token in \\"+*\\": while ops and ops[-1] != '(': output.append(ops.pop()) ops.append(token) elif token == '(': ops.append(token) elif token == ')': while ops and ops[-1] != '(': output.append(ops.pop()) ops.pop() while ops: output.append(ops.pop()) return output tokens = tokenize(expression) postfix_tokens = to_postfix(tokens) return compute(postfix_tokens)"},{"question":"def max_subtree_weight(n: int, weights: List[int], edges: List[Tuple[int, int]]) -> int: Find the maximum weight of any subtree for a given tree structure. Args: n (int): The number of nodes in the tree. weights (List[int]): The weights associated with each node. edges (List[Tuple[int, int]]): The edges that define the tree structure. Returns: int: The maximum weight of any subtree. Example: >>> max_subtree_weight(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (2, 5)]) 15 >>> max_subtree_weight(3, [100, 200, 300], [(1, 2), (1, 3)]) 600 >>> max_subtree_weight(4, [4, 1, 3, 2], [(1, 2), (2, 3), (2, 4)]) 10","solution":"def max_subtree_weight(n, weights, edges): from collections import defaultdict # Build the adjacency list and initialize weight list tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) max_weight = 0 subtree_weights = [0] * (n + 1) # to store subtree weights visited = [False] * (n + 1) def dfs(node): nonlocal max_weight visited[node] = True subtree_weight = weights[node - 1] # node numbers are 1-based in input, weights is 0-based for neighbor in tree[node]: if not visited[neighbor]: subtree_weight += dfs(neighbor) subtree_weights[node] = subtree_weight max_weight = max(max_weight, subtree_weight) return subtree_weight dfs(1) return max_weight"},{"question":"def unique_paths(grid): Calculate the number of unique paths from top-left corner to bottom-right corner in a grid. Obstacles are represented by 1, and walkable cells are represented by 0. Args: grid (List[List[int]]): A 2D list representing the grid. Returns: int: Number of unique paths, or 0 if no path exists. >>> unique_paths([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths([[0, 1], [1, 0]]) 0 # Your code here def process_input_output(data): Process the input data and return the corresponding output results. Args: data (List[str]): A list of strings representing input data. Returns: List[int]: A list of integers representing the number of unique paths for each test case. >>> data = [ ... \\"2\\", ... \\"3 3\\", ... \\"0 0 0\\", ... \\"0 1 0\\", ... \\"0 0 0\\", ... \\"2 2\\", ... \\"0 1\\", ... \\"1 0\\" ... ] >>> process_input_output(data) [2, 0] # Your code here def forest_paths(data): Entry function to get input data, process it, and return the expected output Args: data (List[str]): A list of strings representing input data. Returns: List[int]: A list of integers representing the number of unique paths for each test case. return process_input_output(data)","solution":"def unique_paths(grid): n = len(grid) m = len(grid[0]) if grid[0][0] == 1 or grid[n-1][m-1] == 1: return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1] def process_input_output(data): results = [] t = int(data[0]) idx = 1 for _ in range(t): n, m = map(int, data[idx].split()) grid = [] for i in range(n): grid.append(list(map(int, data[idx + 1 + i].split()))) results.append(unique_paths(grid)) idx += n + 1 return results def forest_paths(data): Entry function to get input data, process it and return the expected output return process_input_output(data)"},{"question":"def find_min_books(m: int, books: List[Tuple[str, List[str]]], n: int, required_themes: List[str]) -> Union[int, str]: Determine the minimum number of books needed to cover all the requested themes. Args: m : int : number of books books : List[Tuple[str, List[str]]] : list of books with their titles and associated themes n : int : number of required themes required_themes : List[str] : list of required themes Returns: int : minimum number of books needed to cover all the themes str : \\"impossible\\" if it is not achievable Example: >>> find_min_books(4, [(\\"Book1\\", [\\"Adventure\\", \\"Mystery\\"]), (\\"Book2\\", [\\"Romance\\"]), (\\"Book3\\", [\\"Adventure\\", \\"ScienceFiction\\", \\"Fantasy\\"]), (\\"Book4\\", [\\"Mystery\\", \\"Romance\\"])], 3, [\\"Adventure\\", \\"Mystery\\", \\"Romance\\"]) 2 >>> find_min_books(3, [(\\"BookA\\", [\\"Horror\\"]), (\\"BookB\\", [\\"Adventure\\"]), (\\"BookC\\", [\\"Mystery\\"])], 2, [\\"Adventure\\", \\"Fantasy\\"]) \\"impossible\\" pass def test_find_min_books(): # Test case 1 m = 4 books = [ (\\"Book1\\", [\\"Adventure\\", \\"Mystery\\"]), (\\"Book2\\", [\\"Romance\\"]), (\\"Book3\\", [\\"Adventure\\", \\"ScienceFiction\\", \\"Fantasy\\"]), (\\"Book4\\", [\\"Mystery\\", \\"Romance\\"]) ] n = 3 required_themes = [\\"Adventure\\", \\"Mystery\\", \\"Romance\\"] assert find_min_books(m, books, n, required_themes) == 2 # Test case 2 m = 3 books = [ (\\"BookA\\", [\\"Horror\\"]), (\\"BookB\\", [\\"Adventure\\"]), (\\"BookC\\", [\\"Mystery\\"]), ] n = 2 required_themes = [\\"Adventure\\", \\"Fantasy\\"] assert find_min_books(m, books, n, required_themes) == \\"impossible\\" # Test case 3 (Edge case: No books) m = 0 books = [] n = 2 required_themes = [\\"Adventure\\", \\"Fantasy\\"] assert find_min_books(m, books, n, required_themes) == \\"impossible\\" # Test case 4 (Single book covers all themes) m = 1 books = [ (\\"Book1\\", [\\"Adventure\\", \\"Mystery\\", \\"Romance\\"]), ] n = 3 required_themes = [\\"Adventure\\", \\"Mystery\\", \\"Romance\\"] assert find_min_books(m, books, n, required_themes) == 1 # Test case 5 (Multiple books covering themes) m = 3 books = [ (\\"Book1\\", [\\"Adventure\\"]), (\\"Book2\\", [\\"Mystery\\"]), (\\"Book3\\", [\\"Romance\\"]), ] n = 3 required_themes = [\\"Adventure\\", \\"Mystery\\", \\"Romance\\"] assert find_min_books(m, books, n, required_themes) == 3 test_find_min_books()","solution":"from itertools import combinations def find_min_books(m, books, n, required_themes): # Edge case where no books are provided if m == 0: return \\"impossible\\" # Helper to check if a combination covers all required themes def covers_all_themes(combo): themes_covered = set() for idx in combo: themes_covered.update(books[idx][1]) return all(theme in themes_covered for theme in required_themes) for r in range(1, m + 1): # Try combinations from 1 to m books for combo in combinations(range(m), r): if covers_all_themes(combo): return r # Return the number of books in the smallest valid combination return \\"impossible\\" # If no valid combination is found def process_input(): results = [] while True: # Read number of books m = int(input()) if m == 0: break # Read books with their titles and themes books = [] for _ in range(m): parts = input().split() title = parts[0] num_themes = int(parts[1]) themes = parts[2:] books.append((title, themes)) # Read number of required themes n = int(input()) required_themes = [] for _ in range(n): required_themes.append(input()) # Find and store the result for the current dataset result = find_min_books(m, books, n, required_themes) results.append(result) return results"},{"question":"def restoreString(s: str, indices: List[int]) -> str: Reconstructs the string based on the given indices. Parameters: - s (str): The input string - indices (List[int]): The indices at which characters from 's' should be placed Returns: - str: The reordered string >>> restoreString(\\"abc\\", [2, 1, 0]) 'cba' >>> restoreString(\\"aiohn\\", [3, 1, 4, 2, 0]) 'nihao' >>> restoreString(\\"aaiougrt\\", [4, 0, 2, 6, 7, 3, 1, 5]) 'arigatou'","solution":"def restoreString(s, indices): Reconstructs the string based on the given indices. Parameters: - s (str): The input string - indices (List[int]): The indices at which characters from 's' should be placed Returns: - str: The reordered string result = [''] * len(s) for i, index in enumerate(indices): result[index] = s[i] return ''.join(result)"},{"question":"def findTriplets(arr: List[int], target: int) -> bool: Returns True if there exists a triplet in the array which sums up to the target sum. Args: arr (List[int]): list of integers target (int): target sum for a triplet Returns: bool: True if a triplet exists that sums to the target, otherwise False Examples: >>> findTriplets([12, 3, 4, 1, 6, 9], 24) True >>> findTriplets([1, 2, 3, 4, 5], 10) True >>> findTriplets([1, 2, 3, 4, 5], 20) False","solution":"def findTriplets(arr, target): Returns True if there exists a triplet in the array which sums up to the target sum. n = len(arr) arr.sort() for i in range(n-2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def calculate_consistency_score(purchase_history): Calculate the consistency score for a customer's shopping behavior. Args: purchase_history (List[int]): A list of item categories purchased by the customer. Returns: int: The consistency score based on the frequency distribution of item categories. Examples: >>> calculate_consistency_score([1, 1, 2, 2, 3]) 2 >>> calculate_consistency_score([4, 4, 4, 5, 5, 6]) 1 pass def process_test_cases(test_cases): Process multiple test cases to calculate consistency scores. Args: test_cases (List[Tuple[int, List[int]]]): A list of test cases, where each test case is a tuple containing the number of items purchased and the list of purchased item categories. Returns: List[int]: A list of consistency scores for each test case. Examples: >>> process_test_cases([(5, [1, 1, 2, 2, 3]), (6, [4, 4, 4, 5, 5, 6])]) [2, 1] pass # Test cases from solution import calculate_consistency_score, process_test_cases def test_calculate_consistency_score(): assert calculate_consistency_score([1, 1, 2, 2, 3]) == 2 assert calculate_consistency_score([4, 4, 4, 5, 5, 6]) == 1 assert calculate_consistency_score([1, 1, 2, 3, 3, 3]) == 1 assert calculate_consistency_score([]) == 0 assert calculate_consistency_score([1, 1, 1, 1, 1, 1]) == 1 def test_process_test_cases(): assert process_test_cases([(5, [1, 1, 2, 2, 3]), (6, [4, 4, 4, 5, 5, 6])]) == [2, 1] assert process_test_cases([(3, [1, 1, 1]), (4, [2, 2, 3, 3])]) == [1, 2] def test_edge_cases(): assert calculate_consistency_score([10]*100000) == 1 assert calculate_consistency_score([i for i in range(1, 101)] * 1000) == 100","solution":"def calculate_consistency_score(purchase_history): from collections import Counter n = len(purchase_history) if n == 0: return 0 frequencies = list(Counter(purchase_history).values()) mean_frequency = sum(frequencies) / len(frequencies) consistency_score = sum(1 for freq in frequencies if freq == round(mean_frequency)) return consistency_score def process_test_cases(test_cases): results = [] for test_case in test_cases: n = test_case[0] purchase_history = test_case[1] results.append(calculate_consistency_score(purchase_history)) return results # Reading input def main(): import sys input = sys.stdin.read data = input().split() index = 0 tc = int(data[index]) index += 1 test_cases = [] for _ in range(tc): n = int(data[index]) index += 1 purchase_history = list(map(int, data[index:index + n])) index += n test_cases.append((n, purchase_history)) results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"def max_page_difference(T, test_cases): Alice is obsessed with analyzing her book collection. She has a collection of N books where each book has a certain number of pages P_i. Alice likes diverse reading experiences and is interested in finding collections of books with the most variation in page count. Specifically, she wants to find M contiguous books such that the difference between the maximum and minimum page counts among the selected books is maximized. Input: The first line of the input contains an integer T denoting the number of test cases. The first line of every test-case contains two space-separated integers N and M. The second line of every test case contains N space-separated integers P_i denoting the number of pages in the i-th book. Output: For each test case, print the maximum difference between the maximum and minimum page counts among the chosen M contiguous books. Constraints: 1 ≤ N ≤ 100 1 ≤ M ≤ N 1 ≤ P_i ≤ 10^9 >>> T = 1 >>> test_cases = [{'N': 5, 'M': 3, 'pages': [150, 80, 200, 300, 50]}] >>> max_page_difference(T, test_cases) == [250] >>> T = 2 >>> test_cases = [ ... {'N': 5, 'M': 3, 'pages': [150, 80, 200, 300, 50]}, ... {'N': 6, 'M': 2, 'pages': [100, 200, 150, 300, 50, 400]} ... ] >>> max_page_difference(T, test_cases) == [250, 350] >>> T = 1 >>> test_cases = [{'N': 3, 'M': 3, 'pages': [10, 20, 30]}] >>> max_page_difference(T, test_cases) == [20] >>> T = 1 >>> test_cases = [{'N': 4, 'M': 2, 'pages': [5, 5, 5, 5]}] >>> max_page_difference(T, test_cases) == [0] >>> T = 1 >>> test_cases = [{'N': 5, 'M': 3, 'pages': [1000000000, 999999999, 1000000000, 5, 10]}] >>> max_page_difference(T, test_cases) == [999999995]","solution":"def max_page_difference(T, test_cases): results = [] for case in test_cases: N, M, pages = case['N'], case['M'], case['pages'] max_diff = 0 for i in range(N - M + 1): current_window = pages[i:i + M] current_diff = max(current_window) - min(current_window) max_diff = max(max_diff, current_diff) results.append(max_diff) return results"},{"question":"def has_pair_with_difference(nums: List[int], target: int) -> str: Determines if there are two distinct indices in the array such that the absolute difference between the elements at these indices is equal to the given target. Args: nums (List[int]): List of integers. target (int): Target difference. Returns: str: \\"YES\\" if such pair exists, otherwise \\"NO\\". >>> has_pair_with_difference([1, 5, 2, 4, 6], 3) \\"YES\\" >>> has_pair_with_difference([1, 2, 3, 4], 10) \\"NO\\" pass from solution import has_pair_with_difference def test_pair_exists(): assert has_pair_with_difference([1, 5, 2, 4, 6], 3) == \\"YES\\" def test_pair_does_not_exist(): assert has_pair_with_difference([1, 2, 3, 4], 10) == \\"NO\\" def test_empty_array(): assert has_pair_with_difference([], 5) == \\"NO\\" def test_single_element(): assert has_pair_with_difference([5], 0) == \\"NO\\" def test_same_elements(): assert has_pair_with_difference([2, 2, 2, 2], 0) == \\"YES\\" def test_large_difference(): assert has_pair_with_difference([5, 1000000000], 999999995) == \\"YES\\" def test_no_pair_with_large_target(): assert has_pair_with_difference([5, 5, 5, 5], 100) == \\"NO\\"","solution":"def has_pair_with_difference(nums, target): Determines if there are two distinct indices in the array such that the absolute difference between the elements at these indices is equal to the given target. num_set = set() for num in nums: if (num + target) in num_set or (num - target) in num_set: return \\"YES\\" num_set.add(num) return \\"NO\\" # Example usage if __name__ == \\"__main__\\": n, target = map(int, input().split()) nums = list(map(int, input().split())) print(has_pair_with_difference(nums, target))"},{"question":"def largest_number_by_adjacent_swaps(S: str) -> str: Returns the largest number possible by only swapping adjacent digits. >>> largest_number_by_adjacent_swaps(\\"34912\\") \\"94321\\" >>> largest_number_by_adjacent_swaps(\\"8\\") \\"8\\" >>> largest_number_by_adjacent_swaps(\\"1111\\") \\"1111\\" >>> largest_number_by_adjacent_swaps(\\"12345\\") \\"54321\\" >>> largest_number_by_adjacent_swaps(\\"98765\\") \\"98765\\" >>> largest_number_by_adjacent_swaps(\\"1029384756\\") \\"9876543210\\" >>> largest_number_by_adjacent_swaps(\\"112233\\") \\"332211\\"","solution":"def largest_number_by_adjacent_swaps(S): Returns the largest number possible by only swapping adjacent digits. digits = list(S) n = len(digits) for i in range(n): for j in range(n - 1): if digits[j] < digits[j + 1]: digits[j], digits[j + 1] = digits[j + 1], digits[j] return ''.join(digits)"},{"question":"def find_book_with_most_pages(n, books): Returns the ISBN of the book with the highest number of pages. If multiple books have the same highest number of pages, returns the one with the smallest ISBN. :param n: int, number of books :param books: list of tuples (ISBN, pages) :return: str, ISBN of the book with the highest number of pages >>> find_book_with_most_pages(4, [(\\"1234567890\\", 200), (\\"0987654321\\", 300), (\\"1111111111\\", 300), (\\"2222222222\\", 150)]) '0987654321' >>> find_book_with_most_pages(3, [(\\"1111111111\\", 450), (\\"2222222222\\", 450), (\\"3333333333\\", 450)]) '1111111111' >>> find_book_with_most_pages(1, [(\\"1111111111\\", 100)]) '1111111111' >>> find_book_with_most_pages(4, [(\\"1234567890\\", 200), (\\"0987654321\\", 350), (\\"1111111111\\", 100), (\\"2222222222\\", 250)]) '0987654321' >>> find_book_with_most_pages(4, [(\\"1234567890\\", 9999), (\\"0987654321\\", 10000), (\\"1111111111\\", 9998), (\\"0000000001\\", 10000)]) '0000000001'","solution":"def find_book_with_most_pages(n, books): Returns the ISBN of the book with the highest number of pages. If multiple books have the same highest number of pages, returns the one with the smallest ISBN. :param n: int, number of books :param books: list of tuples (ISBN, pages) :return: str, ISBN of the book with the highest number of pages max_pages = -1 best_isbn = \\"\\" for isbn, pages in books: if pages > max_pages or (pages == max_pages and isbn < best_isbn): max_pages = pages best_isbn = isbn return best_isbn"},{"question":"def find_first_peak_element(test_cases: List[List[int]]) -> List[Union[Tuple[int, int], int]]: Find the position and value of the first peak element for each test case. >>> find_first_peak_element([[1, 3, 20, 4, 1, 0], [10, 20, 15, 2, 23], [5, 10, 5]]) [(3, 20), (2, 20), (2, 10)] >>> find_first_peak_element([[1, 1, 1]]) [-1]","solution":"def find_first_peak_element(test_cases): results = [] for A in test_cases: N = len(A) if N == 1: results.append((1, A[0])) else: for i in range(N): if (i == 0 and A[i] > A[i+1]) or (i == N-1 and A[i] > A[i-1]) or (A[i] > A[i-1] and A[i] > A[i+1]): results.append((i+1, A[i])) break else: results.append(-1) return results"},{"question":"def first_non_repeating_character(s: str) -> int: Returns the index of the first non-repeating character in the string s. If there is no such character, returns -1. >>> first_non_repeating_character(\\"leetcode\\") == 0 >>> first_non_repeating_character(\\"loveleetcode\\") == 2 >>> first_non_repeating_character(\\"aabbcc\\") == -1","solution":"def first_non_repeating_character(s): Returns the index of the first non-repeating character in the string s. If there is no such character, returns -1. # Create a dictionary to store the count of each character count = {} # Fill the dictionary with the frequency of each character for char in s: count[char] = count.get(char, 0) + 1 # Find the first character with frequency 1 for index, char in enumerate(s): if count[char] == 1: return index # If there is no non-repeating character, return -1 return -1"},{"question":"from typing import List, Tuple def kruskal_mst(n: int, edges: List[Tuple[int, int, int]]) -> int: Calculate the minimum cost of constructing roads such that each pair of towns has one unique minimum cost path. Args: n (int): The number of towns. edges (List[Tuple[int, int, int]]): The list of edges where each edge is a tuple (u, v, w) representing a road between town u and town v with a travel cost of w. Returns: int: The minimum construction cost or -1 if it is impossible to achieve this configuration. Examples: >>> kruskal_mst(4, [(1, 2, 2), (1, 3, 5), (2, 3, 7), (2, 4, 8), (3, 4, 3)]) 10 >>> kruskal_mst(4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 3, 2)]) 3 pass def min_unique_path_costs(test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[int]: Process multiple test cases to calculate the minimum construction costs for each. Args: test_cases (List[Tuple[int, int, List[Tuple[int, int, int]]]]): List of test cases where each test case is a tuple containing number of towns (n), number of roads (m), and a list of edges. Returns: List[int]: List of minimum construction costs for each test case or -1 if it is impossible. Examples: >>> min_unique_path_costs([(4, 5, [(1, 2, 2), (1, 3, 5), (2, 3, 7), (2, 4, 8), (3, 4, 3)]), (4, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 3, 2)])]) [10, 3] pass def test_kruskal_mst(): test_cases = [ (4, 5, [(1, 2, 2), (1, 3, 5), (2, 3, 7), (2, 4, 8), (3, 4, 3)]), (4, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 3, 2)]), (3, 3, [(1, 2, 4), (2, 3, 4), (1, 3, 2)]), (4, 5, [(1, 2, 3), (1, 3, 4), (1, 4, 5), (2, 3, 6), (3, 4, 7)]), (4, 0, []) ] expected_results = [ 10, 3, 6, 12, -1 ] results = min_unique_path_costs(test_cases) for result, expected in zip(results, expected_results): assert result == expected def test_kruskal_mst_impossible(): test_cases = [ (5, 2, [(1, 2, 4), (2, 3, 5)]) ] expected_results = [ -1 ] results = min_unique_path_costs(test_cases) for result, expected in zip(results, expected_results): assert result == expected def test_kruskal_mst_edge_case(): test_cases = [ (2, 1, [(1, 2, 1)]), (2, 1, [(1, 2, 1000)]), (3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 2)]), ] expected_results = [ 1, 1000, 2, ] results = min_unique_path_costs(test_cases) for result, expected in zip(results, expected_results): assert result == expected","solution":"def kruskal_mst(n, edges): def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 parent = list(range(n)) rank = [0] * n edges.sort(key=lambda x: x[2]) mst_cost = 0 edge_count = 0 for u, v, w in edges: uroot = find(parent, u) vroot = find(parent, v) if uroot != vroot: mst_cost += w edge_count += 1 union(parent, rank, uroot, vroot) if edge_count == n - 1: break if edge_count != n - 1: return -1 return mst_cost def min_unique_path_costs(test_cases): results = [] for n, m, edges in test_cases: if n == 0 and m == 0: break adjusted_edges = [(u-1, v-1, w) for u, v, w in edges] result = kruskal_mst(n, adjusted_edges) results.append(result) return results"},{"question":"def can_form_palindrome(s: str) -> bool: Determines whether any permutation of the string s can form a palindrome. :param s: The input string consisting of lowercase English letters. :return: True if any permutation of the string can form a palindrome, otherwise False. >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"hello\\") False","solution":"def can_form_palindrome(s: str) -> bool: Determines whether any permutation of the string s can form a palindrome. :param s: The input string consisting of lowercase English letters. :return: True if any permutation of the string can form a palindrome, otherwise False. from collections import Counter char_count = Counter(s) # Count how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"def manage_tasks(commands): Task Management System. Args: commands (List[List]): List of commands to manage tasks with the given structure: - [\\"add\\", task_name, deadline, priority] - [\\"update\\", task_name, [new_deadline], [new_priority]] - [\\"list_deadline\\"] - [\\"list_priority\\"] Returns: List of tasks according to 'list' commands in the order they appear. Example: >>> commands = [ ... [\\"add\\", \\"task1\\", \\"2023-12-01\\", \\"high\\"], ... [\\"add\\", \\"task2\\", \\"2023-11-01\\", \\"urgent\\"], ... [\\"update\\", \\"task1\\", None, \\"urgent\\"], ... [\\"list_priority\\"], ... [\\"add\\", \\"task3\\", \\"2023-10-01\\", \\"medium\\"], ... [\\"list_deadline\\"] ... ] >>> manage_tasks(commands) [[{\\"name\\": \\"task2\\", \\"deadline\\": \\"2023-11-01\\", \\"priority\\": \\"urgent\\"}, {\\"name\\": \\"task1\\", \\"deadline\\": \\"2023-12-01\\", \\"priority\\": \\"urgent\\"}], [{\\"name\\": \\"task3\\", \\"deadline\\": \\"2023-10-01\\", \\"priority\\": \\"medium\\"}, {\\"name\\": \\"task2\\", \\"deadline\\": \\"2023-11-01\\", \\"priority\\": \\"urgent\\"}, {\\"name\\": \\"task1\\", \\"deadline\\": \\"2023-12-01\\", \\"priority\\": \\"urgent\\"}]] def test_manage_tasks_add_and_list_priority(): commands = [ [\\"add\\", \\"task1\\", \\"2023-12-01\\", \\"high\\"], [\\"add\\", \\"task2\\", \\"2023-11-01\\", \\"urgent\\"], [\\"list_priority\\"] ] expected_output = [ [{\\"name\\": \\"task2\\", \\"deadline\\": \\"2023-11-01\\", \\"priority\\": \\"urgent\\"}, {\\"name\\": \\"task1\\", \\"deadline\\": \\"2023-12-01\\", \\"priority\\": \\"high\\"}] ] assert manage_tasks(commands) == expected_output def test_manage_tasks_update_and_list_deadline(): commands = [ [\\"add\\", \\"task1\\", \\"2023-12-01\\", \\"high\\"], [\\"add\\", \\"task2\\", \\"2023-11-01\\", \\"urgent\\"], [\\"update\\", \\"task1\\", \\"2023-10-01\\", None], [\\"list_deadline\\"] ] expected_output = [ [{\\"name\\": \\"task1\\", \\"deadline\\": \\"2023-10-01\\", \\"priority\\": \\"high\\"}, {\\"name\\": \\"task2\\", \\"deadline\\": \\"2023-11-01\\", \\"priority\\": \\"urgent\\"}] ] assert manage_tasks(commands) == expected_output def test_manage_tasks_list_commands_order(): commands = [ [\\"add\\", \\"task1\\", \\"2023-12-01\\", \\"high\\"], [\\"list_deadline\\"], [\\"add\\", \\"task2\\", \\"2023-11-01\\", \\"urgent\\"], [\\"list_priority\\"], ] expected_output = [ [{\\"name\\": \\"task1\\", \\"deadline\\": \\"2023-12-01\\", \\"priority\\": \\"high\\"}], [{\\"name\\": \\"task2\\", \\"deadline\\": \\"2023-11-01\\", \\"priority\\": \\"urgent\\"}, {\\"name\\": \\"task1\\", \\"deadline\\": \\"2023-12-01\\", \\"priority\\": \\"high\\"}] ] assert manage_tasks(commands) == expected_output def test_manage_tasks_update_priority(): commands = [ [\\"add\\", \\"task1\\", \\"2023-12-01\\", \\"high\\"], [\\"update\\", \\"task1\\", None, \\"urgent\\"], [\\"list_priority\\"] ] expected_output = [ [{\\"name\\": \\"task1\\", \\"deadline\\": \\"2023-12-01\\", \\"priority\\": \\"urgent\\"}] ] assert manage_tasks(commands) == expected_output def test_manage_tasks_update_deadline_and_priority(): commands = [ [\\"add\\", \\"task1\\", \\"2023-12-01\\", \\"high\\"], [\\"update\\", \\"task1\\", \\"2023-11-01\\", \\"urgent\\"], [\\"list_deadline\\"], [\\"list_priority\\"] ] expected_output = [ [{\\"name\\": \\"task1\\", \\"deadline\\": \\"2023-11-01\\", \\"priority\\": \\"urgent\\"}], [{\\"name\\": \\"task1\\", \\"deadline\\": \\"2023-11-01\\", \\"priority\\": \\"urgent\\"}] ] assert manage_tasks(commands) == expected_output","solution":"def manage_tasks(commands): tasks = [] output = [] priority_order = {\\"urgent\\": 1, \\"high\\": 2, \\"medium\\": 3, \\"low\\": 4} def sort_by_deadline(task): return task[\\"deadline\\"] def sort_by_priority(task): return priority_order[task[\\"priority\\"]] for command in commands: if command[0] == \\"add\\": _, task_name, deadline, priority = command tasks.append({\\"name\\": task_name, \\"deadline\\": deadline, \\"priority\\": priority}) elif command[0] == \\"update\\": _, task_name, new_deadline, new_priority = command for task in tasks: if task[\\"name\\"] == task_name: if new_deadline is not None: task[\\"deadline\\"] = new_deadline if new_priority is not None: task[\\"priority\\"] = new_priority break elif command[0] == \\"list_deadline\\": sorted_tasks = sorted(tasks, key=sort_by_deadline) output.append(sorted_tasks) elif command[0] == \\"list_priority\\": sorted_tasks = sorted(tasks, key=sort_by_priority) output.append(sorted_tasks) return output"},{"question":"from typing import List, Tuple def max_sum_and_min_cost(tc_count: int, cases: List[Tuple[int, List[int]]]) -> List[str]: Compute the maximum possible sum and the minimum total cost of rarity values after an optimal sequence of exchanges. >>> max_sum_and_min_cost(3, [(3, [1, 2, 3]), (4, [5, 7, 2, 8]), (2, [10, 20])]) [\\"6 0\\", \\"22 0\\", \\"30 0\\"] >>> max_sum_and_min_cost(1, [(3, [4, 5, 6])]) [\\"15 0\\"] >>> max_sum_and_min_cost(1, [(4, [5, 5, 5, 5])]) [\\"20 0\\"] >>> max_sum_and_min_cost(1, [(1, [100])]) [\\"100 0\\"]","solution":"def max_sum_and_min_cost(tc_count, cases): results = [] for case in cases: N = case[0] rarities = case[1] max_sum = sum(rarities) min_cost = 0 # No exchanges needed results.append(f\\"{max_sum} {min_cost}\\") return results"},{"question":"def longest_consecutive_subsequence(nums: List[int]) -> int: Returns the length of the longest consecutive subsequence in the array. :param nums: List of integers :returns: Length of the longest consecutive subsequence >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2, 101]) 4 >>> longest_consecutive_subsequence([]) 0 >>> longest_consecutive_subsequence([10, 5, 15, 20]) 1 >>> longest_consecutive_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_consecutive_subsequence([1, 2, 2, 3, 4, 4]) 4 >>> longest_consecutive_subsequence([-2, -1, 0, 1, 2]) 5 >>> longest_consecutive_subsequence([1, 9, 3, 10, 4, 20, 2]) 4 >>> longest_consecutive_subsequence(range(10000)) 10000 >>> longest_consecutive_subsequence([42]) 1","solution":"def longest_consecutive_subsequence(nums): Returns the length of the longest consecutive subsequence in the array. :param nums: List of integers :returns: Length of the longest consecutive subsequence if not nums: return 0 nums = set(nums) longest_streak = 0 for num in nums: if num - 1 not in nums: current_num = num current_streak = 1 while current_num + 1 in nums: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from typing import List def is_prime(num: int) -> bool: Helper function to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def nearest_prime(n: int) -> int: Returns the nearest prime number to n. If there are two prime numbers equally close to n, returns the smaller one. >>> nearest_prime(10) 11 >>> nearest_prime(14) 13 >>> nearest_prime(30) 29 def __test(): assert nearest_prime(10) == 11 assert nearest_prime(14) == 13 assert nearest_prime(30) == 29 assert nearest_prime(34) == 31 assert nearest_prime(1) == 2 assert nearest_prime(2) == 2 assert nearest_prime(3) == 3 assert nearest_prime(100) == 101 assert nearest_prime(101) == 101 assert nearest_prime(20) == 19 assert nearest_prime(50) == 47 assert nearest_prime(99) == 97 __test()","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def nearest_prime(n): Returns the nearest prime number to n. If there are two prime numbers equally close to n, returns the smaller one. if is_prime(n): return n distance = 1 while True: if is_prime(n - distance): return n - distance if is_prime(n + distance): return n + distance distance += 1"},{"question":"def findLongestConsecutiveSubsequence(arr): Returns the length of the longest consecutive subsequence in the array. >>> findLongestConsecutiveSubsequence([100, 4, 200, 1, 3, 2]) 4 >>> findLongestConsecutiveSubsequence([10, 12, 11, 7, 6, 5, 8]) 4 >>> findLongestConsecutiveSubsequence([1, 9, 3, 10, 4, 20, 2]) 4","solution":"def findLongestConsecutiveSubsequence(arr): Returns the length of the longest consecutive subsequence in the array. if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in num_set: # Only check if the current num is the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def reverse_to_minimize(arr): Given an array of integers, this function finds the lexicographically smallest sequence by reversing any possible subarray. >>> reverse_to_minimize([4, 3, 1, 2]) [1, 3, 4, 2] >>> reverse_to_minimize([1, 2, 3, 5, 4]) [1, 2, 3, 4, 5] def process_test_cases(t, test_cases): Process multiple test cases to find the lexicographically smallest sequence for each. >>> process_test_cases(2, [(4, [4, 3, 1, 2]), (5, [1, 2, 3, 5, 4])]) [\\"1 3 4 2\\", \\"1 2 3 4 5\\"]","solution":"def reverse_to_minimize(arr): Given an array of integers, this function finds the lexicographically smallest sequence by reversing any possible subarray. n = len(arr) min_seq = arr.copy() for start in range(n): for end in range(start, n): temp = arr[:start] + arr[start:end+1][::-1] + arr[end+1:] if temp < min_seq: min_seq = temp return min_seq def process_test_cases(t, test_cases): results = [] for i in range(t): n, spells = test_cases[i] minimized_sequence = reverse_to_minimize(spells) results.append(' '.join(map(str, minimized_sequence))) return results"},{"question":"def min_days_for_all_bloom(n: int, flower_states: List[int]) -> int: Returns the minimum number of days required to make all flowers bloom at least once. :param n: An integer representing the number of flowers. :param flower_states: A list of integers representing the initial state of the flowers (1 for blooming, 0 for not blooming). :return: An integer representing the minimum number of days required to make all flowers bloom. >>> min_days_for_all_bloom(5, [1, 0, 0, 1, 0]) 3 >>> min_days_for_all_bloom(3, [0, 0, 0]) 3 >>> min_days_for_all_bloom(4, [1, 1, 1, 1]) 0","solution":"def min_days_for_all_bloom(n, flower_states): Returns the minimum number of days required to make all flowers bloom at least once. # Count the number of flowers that are not blooming (i.e., 0s in the array). non_blooming_count = flower_states.count(0) return non_blooming_count"},{"question":"def min_add_to_make_valid(s: str) -> int: Determines the minimum number of brackets needed to make the sequence valid. >>> min_add_to_make_valid(\\"(()))\\") 1 >>> min_add_to_make_valid(\\"((())\\") 1 >>> min_add_to_make_valid(\\")()())\\") 2","solution":"def min_add_to_make_valid(s): Returns the minimum number of brackets to add to make the sequence valid. open_brackets = 0 close_brackets = 0 for char in s: if char == '(': open_brackets += 1 elif char == ')': if open_brackets > 0: open_brackets -= 1 else: close_brackets += 1 return open_brackets + close_brackets"},{"question":"def sum_of_elements(num_cases: int, cases: List[List[int]]) -> List[int]: Given a number of arrays and each array's elements, returns a list of sums of each array. >>> sum_of_elements(1, [[1, 2, 3, 4, 5]]) == [15] >>> sum_of_elements(2, [[1, 2, 3, 4, 5], [10, 20, 30]]) == [15, 60] >>> sum_of_elements(2, [[], []]) == [0, 0] >>> sum_of_elements(3, [[1], [2], [3]]) == [1, 2, 3] >>> sum_of_elements(2, [[1, -1, 2, -2, 3, -3], [10, 0, -10]]) == [0, 0]","solution":"def sum_of_elements(num_cases, cases): Given a number of arrays and each array's elements, returns a list of sums of each array. :param num_cases: int, number of arrays to sum :param cases: list of lists, each containing an array to sum :return: list of int, sum of elements for each array result = [] for case in cases: result.append(sum(case)) return result"},{"question":"def perfectly_balanced(arr: List[int]) -> str: Check if the array can be rearranged to be perfectly balanced. >>> perfectly_balanced([2, 1, 4, 3]) \\"YES\\" >>> perfectly_balanced([1, 3, 2, 4, 5]) \\"NO\\" >>> perfectly_balanced([1, 3, 5, 2, 4, 6]) \\"YES\\" from typing import List","solution":"def perfectly_balanced(arr): Function to check if the array can be rearranged to be perfectly balanced. even_count = len([x for x in arr if x % 2 == 0]) odd_count = len(arr) - even_count return \\"YES\\" if even_count == odd_count else \\"NO\\""},{"question":"def check_modified_palindromes(t: int, strings: List[str]) -> List[str]: For each string, determine if it can be a modified palindrome. >>> check_modified_palindromes(3, ['abca', 'racecar', 'hello']) ['YES', 'YES', 'NO'] >>> check_modified_palindromes(1, ['a']) ['YES'] >>> check_modified_palindromes(2, ['aa', 'ab']) ['YES', 'YES'] >>> check_modified_palindromes(5, ['abca', 'aabbcc', 'a', 'ab', 'abcdabcd']) ['YES', 'NO', 'YES', 'YES', 'NO'] >>> check_modified_palindromes(3, ['z' * 100000, 'a' * 199999 + 'b', 'd' * 50000 + 'e' + 'd' * 50000]) ['YES', 'YES', 'YES']","solution":"def is_palindrome(s): return s == s[::-1] def is_modified_palindrome(s): left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: s_without_left = s[:left] + s[left + 1:] s_without_right = s[:right] + s[right + 1:] return is_palindrome(s_without_left) or is_palindrome(s_without_right) left += 1 right -= 1 return True def check_modified_palindromes(t, strings): results = [] for s in strings: if is_modified_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage: # t = 3 # strings = ['abca', 'racecar', 'hello'] # print(check_modified_palindromes(t, strings)) # Output: ['YES', 'YES', 'NO']"},{"question":"def smallest_string_after_modification(s: str) -> str: Returns the lexicographically smallest string obtainable after at most one character modification. Args: s (str): A string of lowercase English alphabets. Returns: str: The lexicographically smallest string after at most one character modification. Examples: >>> smallest_string_after_modification(\\"abc\\") 'aac' >>> smallest_string_after_modification(\\"dcba\\") 'acba' >>> smallest_string_after_modification(\\"zz\\") 'az'","solution":"def smallest_string_after_modification(s): Returns the lexicographically smallest string obtainable after at most one character modification. n = len(s) if n == 1: return 'a' min_string = s for i in range(n): for char in \\"abcdefghijklmnopqrstuvwxyz\\": if char != s[i]: # Create a new string with one character modification new_string = s[:i] + char + s[i + 1:] if new_string < min_string: min_string = new_string # Since we look for the smallest lexicographical character, we can break early. break return min_string def process_test_cases(test_cases): Processes multiple test cases. results = [] for n, s in test_cases: results.append(smallest_string_after_modification(s)) return results"},{"question":"from collections import Counter from typing import List, Tuple def findLHS(nums: List[int]) -> int: Function to find the length of the longest harmonious subsequence in an array of integers. A harmonious subsequence is one where the difference between the maximum and minimum element is exactly 1. Args: nums (List[int]): List of integers Returns: int: Length of the longest harmonious subsequence Examples: >>> findLHS([1, 3, 2, 2, 5, 2]) 4 >>> findLHS([1, 2, 3, 4, 5]) 2 >>> findLHS([1, 1, 1, 1]) 0 pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Function to process multiple test cases and find the length of the longest harmonious subsequence for each test case. Args: test_cases (List[Tuple[int, List[int]]]): List of tuples, where each tuple represents a test case. The first element of the tuple is the number of elements in the array, and the second element is the array of integers. Returns: List[int]: List of results for each test case Examples: >>> process_test_cases([(6, [1, 3, 2, 2, 5, 2]), (5, [1, 2, 3, 4, 5]), (4, [1, 1, 1, 1])]) [4, 2, 0] pass import pytest def test_findLHS(): assert findLHS([1, 3, 2, 2, 5, 2]) == 4 assert findLHS([1, 2, 3, 4, 5]) == 2 assert findLHS([1, 1, 1, 1]) == 0 assert findLHS([1, 2, 2, 1]) == 4 assert findLHS([1, 2, 3, 4, 5, 6, 7, 8, 8, 8]) == 4 assert findLHS([]) == 0 def test_process_test_cases(): test_cases = [ (6, [1, 3, 2, 2, 5, 2]), (5, [1, 2, 3, 4, 5]), (4, [1, 1, 1, 1]) ] assert process_test_cases(test_cases) == [4, 2, 0] test_cases = [ (1, [2]), (3, [2, 2, 3]), (3, [1, 2, 3]) ] assert process_test_cases(test_cases) == [0, 3, 2] test_cases = [ (7, [1, 1, 1, 2, 2, 2, 3]), (3, [1, 1, 3]), (5, [10, 11, 13, 15, 16]) ] assert process_test_cases(test_cases) == [6, 0, 2] pytest.main()","solution":"from collections import Counter def findLHS(nums): Function to find the length of the longest harmonious subsequence in an array of integers. count = Counter(nums) max_length = 0 for num in count: if num + 1 in count: max_length = max(max_length, count[num] + count[num + 1]) return max_length def process_test_cases(test_cases): result = [] for t in test_cases: n, array = t result.append(findLHS(array)) return result"},{"question":"def calculate_trapped_water(n: int, heights: List[int]) -> int: Calculate the total units of water trapped after raining given the heights of buildings. >>> calculate_trapped_water(6, [0, 1, 0, 2, 1, 0]) 1 >>> calculate_trapped_water(4, [3, 0, 2, 0]) 2 pass def trapped_water(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the units of water trapped for multiple test cases. >>> trapped_water([(6, [0, 1, 0, 2, 1, 0]), (4, [3, 0, 2, 0]), (5, [0, 0, 0, 0, 0])]) [1, 2, 0] pass # Test Cases import pytest def test_calculate_trapped_water_basic(): assert calculate_trapped_water(6, [0, 1, 0, 2, 1, 0]) == 1 assert calculate_trapped_water(4, [3, 0, 2, 0]) == 2 def test_calculate_trapped_water_no_trap(): assert calculate_trapped_water(5, [0, 1, 2, 3, 4]) == 0 assert calculate_trapped_water(5, [4, 3, 2, 1, 0]) == 0 def test_calculate_trapped_water_single_building(): assert calculate_trapped_water(1, [4]) == 0 def test_calculate_trapped_water_all_equal_height(): assert calculate_trapped_water(4, [2, 2, 2, 2]) == 0 def test_trapped_water(): assert trapped_water([(6, [0, 1, 0, 2, 1, 0]), (4, [3, 0, 2, 0]), (5, [0, 0, 0, 0, 0])]) == [1, 2, 0] if __name__ == \\"__main__\\": pytest.main()","solution":"def calculate_trapped_water(n, heights): if n == 0: return 0 left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) for i in range(n): water_trapped += max(min(left_max[i], right_max[i]) - heights[i], 0) return water_trapped def trapped_water(test_cases): results = [] for n, heights in test_cases: results.append(calculate_trapped_water(n, heights)) return results"},{"question":"def is_special_pattern_possible(grid, R, C): Determine if it is possible to transform the grid into a special pattern. A special pattern is a configuration where no two adjacent cells (horizontally or vertically) have the same value (i.e., it forms a checkerboard pattern). pass def solve_grids(grids): Solve all grids to determine if they can be transformed into the special pattern for each grid. pass def parse_input(input_str): Parse the input string into a list of test cases, each test case represented as (R, C, grid_data). pass def main(input_str): Main function to process the input and return results for each test case. For each test case, determine if the grid can be transformed into the special pattern and return the result as either \\"YES\\" or \\"NO\\". pass # Unit tests def test_is_special_pattern_possible(): assert is_special_pattern_possible([[0, 1], [1, 0]], 2, 2) == True assert is_special_pattern_possible([[1, 1], [1, 0], [0, 1]], 3, 2) == False assert is_special_pattern_possible([[1, 0, 1], [0, 1, 0]], 2, 3) == True def test_solve_grids(): grids = [ (2, 2, [[0, 1], [1, 0]]), (3, 2, [[1, 1], [1, 0], [0, 1]]), (2, 3, [[1, 0, 1], [0, 1, 0]]) ] assert solve_grids(grids) == [\\"YES\\", \\"NO\\", \\"YES\\"] def test_parse_input(): input_str = \\"3n2 2n0 1n1 0n3 2n1 1n1 0n0 1n2 3n1 0 1n0 1 0n\\" expected_output = [ (2, 2, [[0, 1], [1, 0]]), (3, 2, [[1, 1], [1, 0], [0, 1]]), (2, 3, [[1, 0, 1], [0, 1, 0]]) ] assert parse_input(input_str) == expected_output def test_main(): input_str = \\"3n2 2n0 1n1 0n3 2n1 1n1 0n0 1n2 3n1 0 1n0 1 0n\\" expected_output = \\"YESnNOnYES\\" assert main(input_str) == expected_output","solution":"def is_special_pattern_possible(grid, R, C): Determine if the grid can be transformed into the special pattern. A special pattern is a checkerboard pattern where no two adjacent cells have the same value. pattern1 = [[(r+c) % 2 for c in range(C)] for r in range(R)] pattern2 = [[(r+c+1) % 2 for c in range(C)] for r in range(R)] can_transform_to_pattern1 = True can_transform_to_pattern2 = True for r in range(R): for c in range(C): if grid[r][c] != pattern1[r][c]: can_transform_to_pattern1 = False if grid[r][c] != pattern2[r][c]: can_transform_to_pattern2 = False return can_transform_to_pattern1 or can_transform_to_pattern2 def solve_grids(grids): results = [] for grid in grids: R, C, grid_data = grid if is_special_pattern_possible(grid_data, R, C): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") t = int(lines[0]) index = 1 grids = [] for _ in range(t): R, C = map(int, lines[index].split()) index += 1 grid_data = [] for _ in range(R): grid_data.append(list(map(int, lines[index].split()))) index += 1 grids.append((R, C, grid_data)) return grids def main(input_str): grids = parse_input(input_str) results = solve_grids(grids) return \\"n\\".join(results) # Example usage: # input_str = \\"3n2 2n0 1n1 0n3 2n1 1n1 0n0 1n2 3n1 0 1n0 1 0n\\" # print(main(input_str))"},{"question":"def merge_intervals(intervals): Merges overlapping intervals and returns a list of the merged intervals, sorted by the start of the interval. Args: intervals (list of tuple): A list of intervals to be merged, each interval represented by a tuple (start, end). Returns: list of tuple: A list of merged intervals sorted by the start of the interval. Examples: >>> merge_intervals([(1, 3), (2, 6), (8, 10), (15, 18)]) [(1, 6), (8, 10), (15, 18)] >>> merge_intervals([(1, 4), (4, 5)]) [(1, 5)]","solution":"def merge_intervals(intervals): Merges overlapping intervals and returns a list of the merged intervals, sorted by the start of the interval. if not intervals: return [] # First, we sort the intervals by their starting point intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: merged_intervals[-1] = (last_merged[0], max(last_merged[1], current[1])) else: merged_intervals.append(current) return merged_intervals"},{"question":"def can_partition(nums: List[int]) -> bool: Determine whether it is possible to partition the list into two subarrays with equal sum. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False >>> can_partition([7, 7, 7, 7]) True","solution":"def can_partition(nums): Determine whether it is possible to partition the list into two subarrays with equal sum. :param nums: List of integers :return: True if such a partitioning is possible, False otherwise total_sum = sum(nums) # If the total sum is odd, we cannot split the list into two equal parts if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Initialize a DP array of size (target + 1) with False values dp = [False] * (target + 1) dp[0] = True # Iterate over the numbers and update the DP array for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"from typing import List import re def can_form_word(words: List[str], chars: str) -> str: Determines if the string of characters can be rearranged to form at least one of the words in the list. - If the words list is empty, return \\"empty list\\". - If the characters string is empty, return \\"empty string\\". - Words comparison is case-insensitive. - Ignore non-alphabetic characters in the characters string. >>> can_form_word([\\"world\\", \\"hello\\", \\"Python\\"], \\"dlorw\\") in [\\"world\\"] >>> can_form_word([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"pplea\\") in [\\"apple\\"] >>> can_form_word([\\"cat\\", \\"dog\\", \\"bird\\"], \\"gdo\\") in [\\"dog\\"] >>> can_form_word([], \\"anystring\\") == \\"empty list\\" >>> can_form_word([\\"anything\\"], \\"\\") == \\"empty string\\" >>> can_form_word([\\"python\\"], \\"3@p^yt#h*on!\\") in [\\"python\\"] >>> can_form_word([\\"try\\", \\"it\\"], \\"notr\\") == \\"no match\\" pass","solution":"from typing import List import re def can_form_word(words: List[str], chars: str) -> str: Determines if the string of characters can be rearranged to form at least one of the words in the list. if not words: return \\"empty list\\" if not chars: return \\"empty string\\" # Clean and normalize chars chars = re.sub('[^a-zA-Z]', '', chars).lower() # Check each word in the list for word in words: if sorted(word.lower()) == sorted(chars): return word return \\"no match\\""},{"question":"def cumulativeSum(A): Returns an array B such that B[i] is the sum of elements from A[0] to A[i]. Parameters: A (List[int]): List of integers. Returns: List[int]: Cumulative sum array. Example: >>> cumulativeSum([1, 2, 3, 4]) [1, 3, 6, 10] >>> cumulativeSum([5, -1, 3]) [5, 4, 7]","solution":"def cumulativeSum(A): Returns an array B such that B[i] is the sum of elements from A[0] to A[i]. B = [] current_sum = 0 for num in A: current_sum += num B.append(current_sum) return B"},{"question":"def count_unique_substrings(s: str, k: int) -> int: This function returns the count of unique substrings of length \`k\` in the given string \`s\`. >>> count_unique_substrings(\\"abcabc\\", 1) == 3 >>> count_unique_substrings(\\"abcabc\\", 2) == 3 >>> count_unique_substrings(\\"abcd\\", 2) == 3 >>> count_unique_substrings(\\"abcd\\", 3) == 2 pass def process_queries(t: int, test_cases: List[Tuple[str, int, List[int]]]) -> List[int]: This function processes multiple test cases and returns the results for each query. >>> process_queries(2, [(\\"abcabc\\", 2, [1, 3]), (\\"abcd\\", 2, [2, 3])]) == [3, 3, 3, 2] pass","solution":"def count_unique_substrings(s, k): This function returns the count of unique substrings of length \`k\` in the given string \`s\`. if k > len(s): return 0 unique_substrings = set() for i in range(len(s) - k + 1): unique_substrings.add(s[i:i+k]) return len(unique_substrings) def process_queries(t, test_cases): This function processes multiple test cases and returns the results for each query. results = [] for s, m, queries in test_cases: for k in queries: results.append(count_unique_substrings(s, k)) return results"},{"question":"def has_pair_with_sum(arr, T): Determines if there are two distinct elements in the array whose sum equals T. :param arr: List of integers. :param T: Target sum value. :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\". >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) == \\"YES\\" >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) == \\"NO\\" >>> has_pair_with_sum([1], 2) == \\"NO\\" >>> has_pair_with_sum([1, 2, 3, 4, 5, 6, 7, 8, 9], 17) == \\"YES\\" >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) == \\"YES\\" >>> has_pair_with_sum([-1, 2, 3, -4, 5], 1) == \\"YES\\" >>> has_pair_with_sum([1, 2, 4, 8], 15) == \\"NO\\" >>> has_pair_with_sum([1, -1, 2, -2, 3, -3], 0) == \\"YES\\"","solution":"def has_pair_with_sum(arr, T): Determines if there are two distinct elements in the array whose sum equals T. :param arr: List of integers. :param T: Target sum value. :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\". seen = set() for num in arr: if T - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def generate_spiral(n): Generate a n x n grid numbered in spiral order. Args: n (int): Size of the grid. Returns: List[List[int]]: The n x n grid numbered in spiral order. def find_position(n, num): Find the position (row, col) of a given number in the spiral grid. Args: n (int): Size of the grid. num (int): Number whose position to be found. Returns: Tuple[int, int]: The (row, col) position of the number in the grid. def can_rook_move(n, i, j): Determine if a rook can move from position i to position j in a n x n grid. Args: n (int): Size of the grid. i (int): Starting position. j (int): Target position. Returns: bool: True if the rook can move from i to j, otherwise False. def rook_moves(n, test_cases): Determine if a rook can move between pairs of positions in a n x n grid. Args: n (int): Size of the grid. test_cases (List[Tuple[int, int]]): List of pairs of positions to test. Returns: List[str]: List of results, \\"YES\\" if a rook can move between the positions, otherwise \\"NO\\". >>> n = 5 >>> test_cases = [(1, 13), (7, 9), (17, 21)] >>> rook_moves(n, test_cases) ['YES', 'YES', 'NO']","solution":"def generate_spiral(n): spiral = [[0] * n for _ in range(n)] left, right = 0, n - 1 top, bottom = 0, n - 1 num = 1 while left <= right and top <= bottom: for i in range(left, right + 1): spiral[top][i] = num num += 1 top += 1 for i in range(top, bottom + 1): spiral[i][right] = num num += 1 right -= 1 for i in range(right, left - 1, -1): spiral[bottom][i] = num num += 1 bottom -= 1 for i in range(bottom, top - 1, -1): spiral[i][left] = num num += 1 left += 1 return spiral def find_position(n, num): spiral = generate_spiral(n) for row in range(n): for col in range(n): if spiral[row][col] == num: return (row, col) return (-1, -1) def can_rook_move(n, i, j): row_i, col_i = find_position(n, i) row_j, col_j = find_position(n, j) return row_i == row_j or col_i == col_j def rook_moves(n, test_cases): results = [] for i, j in test_cases: if can_rook_move(n, i, j): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def minimal_highway_cost(n: int, m: int, highways: List[Tuple[int, int, int]]) -> int: Calculate the minimal total cost to construct the highways so that all stations are connected. >>> minimal_highway_cost(4, 5, [(1, 2, 5), (1, 3, 3), (4, 1, 6), (2, 4, 7), (3, 4, 4)]) 12 >>> minimal_highway_cost(4, 3, [(1, 2, 1), (2, 3, 2)]) -1 pass import pytest def test_minimal_highway_cost_example(): n = 4 m = 5 highways = [ (1, 2, 5), (1, 3, 3), (4, 1, 6), (2, 4, 7), (3, 4, 4) ] assert minimal_highway_cost(n, m, highways) == 12 def test_minimal_highway_cost_simple_chain(): n = 3 m = 3 highways = [ (1, 2, 1), (2, 3, 2), (1, 3, 3) ] assert minimal_highway_cost(n, m, highways) == 3 def test_minimal_highway_cost_disconnected(): n = 4 m = 3 highways = [ (1, 2, 1), (2, 3, 2) ] assert minimal_highway_cost(n, m, highways) == -1 def test_minimal_highway_cost_min_highways(): n = 2 m = 1 highways = [ (1, 2, 10) ] assert minimal_highway_cost(n, m, highways) == 10 def test_minimal_highway_cost_large_weights(): n = 4 m = 5 highways = [ (1, 2, 10000), (2, 3, 9999), (3, 4, 9998), (1, 3, 5000), (2, 4, 1) ] assert minimal_highway_cost(n, m, highways) == 14999","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal_mst(n, edges): edges.sort(key=lambda x: x[2]) parent = [] rank = [] for node in range(n + 1): parent.append(node) rank.append(0) mst_cost = 0 mst_edges = 0 for edge in edges: u, v, w = edge uroot = find(parent, u) vroot = find(parent, v) if uroot != vroot: mst_cost += w mst_edges += 1 union(parent, rank, uroot, vroot) if mst_edges == n - 1: break if mst_edges != n - 1: return -1 else: return mst_cost def minimal_highway_cost(n, m, highways): return kruskal_mst(n, highways)"},{"question":"def count_faces(T: int, reviews: List[str]) -> List[Tuple[int, int]]: Count the number of happy and sad faces in given customer reviews. Args: T (int): The number of customer reviews. reviews (List[str]): A list of strings representing customer reviews. Returns: List[Tuple[int, int]]: A list of tuples where each tuple contains two integers representing the number of happy faces and the number of sad faces in the review. >>> count_faces(3, [\\"I am happy :)\\", \\"This is terrible :(\\", \\"Life is good :) :) but sometimes :( happens\\"]) [(1, 0), (0, 1), (2, 1)] >>> count_faces(1, [\\"No faces here\\"]) [(0, 0)]","solution":"def count_faces(T, reviews): results = [] for review in reviews: happy_count = review.count(\\":)\\") sad_count = review.count(\\":(\\") results.append((happy_count, sad_count)) return results"},{"question":"def total_calories(meals): Calculate the total calories consumed in a day based on meal logs. Parameters: meals (list): A list of tuples where each tuple contains a string (meal name) and an integer (calorie value). Returns: int: The total calorie intake for the day. Examples: >>> total_calories([(\\"breakfast\\", 300), (\\"lunch\\", 500), (\\"snack\\", 150), (\\"dinner\\", 600)]) 1550 >>> total_calories([(\\"brunch\\", 700)]) 700 >>> total_calories([(\\"breakfast\\", 450), (\\"lunch\\", 600), (\\"dinner\\", 800)]) 1850","solution":"def total_calories(meals): Calculate the total calories consumed in a day based on meal logs. Parameters: meals (list): A list of tuples where each tuple contains a string (meal name) and an integer (calorie value). Returns: int: The total calorie intake for the day. return sum(calorie for meal, calorie in meals)"},{"question":"def classify_feedback(feedbacks: List[str]) -> List[str]: Automatically classify each feedback as either positive, negative, mixed or neutral based on specific keywords. The classification is based on the presence of certain positive and negative keywords in the feedback entry: Positive keywords: ['good', 'great', 'satisfactory', 'excellent', 'positive', 'fantastic'] Negative keywords: ['bad', 'poor', 'terrible', 'negative', 'horrible', 'awful'] Classification rules: - \\"Positive\\" if any positive keyword is present - \\"Negative\\" if any negative keyword is present - \\"Mixed\\" if both positive and negative keywords are present - \\"Neutral\\" if none of the keywords are present >>> classify_feedback([\\"The product is absolutely fantastic and works great\\", \\"Poor performance for the price I paid\\", \\"Quite satisfactory but could be better\\", \\"No comments on the horrible experience\\"]) ['Positive', 'Negative', 'Positive', 'Negative']","solution":"def classify_feedback(feedbacks): positive_keywords = ['good', 'great', 'satisfactory', 'excellent', 'positive', 'fantastic'] negative_keywords = ['bad', 'poor', 'terrible', 'negative', 'horrible', 'awful'] classifications = [] for feedback in feedbacks: feedback_lower = feedback.lower() positive_found = any(keyword in feedback_lower for keyword in positive_keywords) negative_found = any(keyword in feedback_lower for keyword in negative_keywords) if positive_found and negative_found: classification = \\"Mixed\\" elif positive_found: classification = \\"Positive\\" elif negative_found: classification = \\"Negative\\" else: classification = \\"Neutral\\" classifications.append(classification) return classifications # Example Usage # N = 4 # feedbacks = [ # \\"The product is absolutely fantastic and works great\\", # \\"Poor performance for the price I paid\\", # \\"Quite satisfactory but could be better\\", # \\"No comments on the horrible experience\\" # ] # print(classify_feedback(feedbacks)) -> ['Positive', 'Negative', 'Positive', 'Negative']"},{"question":"from typing import List def unique_sorted_strings(n: int, string_list: List[str]) -> List[str]: Return a list of unique strings sorted alphabetically. >>> unique_sorted_strings(6, [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"grape\\"]) ['apple', 'banana', 'grape', 'orange'] >>> unique_sorted_strings(5, [\\"cat\\", \\"dog\\", \\"elephant\\", \\"ant\\", \\"cat\\"]) ['ant', 'cat', 'dog', 'elephant']","solution":"def unique_sorted_strings(n, string_list): Returns a list of unique strings sorted alphabetically unique_strings = set(string_list) sorted_strings = sorted(list(unique_strings)) return sorted_strings"},{"question":"def find_min_range_subsequence(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, int]]: Find a subsequence of the given sequence such that the difference between its maximum and minimum element is minimized. Args: - t: The number of test cases. - test_cases: A list of tuples, each containing an integer n (length of the sequence) and a list of n non-negative integers. Returns: - A list of tuples. Each tuple contains two integers: the length of the subsequence and the minimum difference between the maximum and minimum element in that subsequence. Example: >>> find_min_range_subsequence(3, [ (5, [4, 2, 1, 10, 5]), (3, [2, 2, 2]), (6, [1, 5, 3, 8, 2, 9]) ]) [(5, 1), (3, 0), (6, 1)] from typing import List, Tuple # Test cases def test_single_element(): assert find_min_range_subsequence(1, [(1, [7])]) == [(1, 0)] def test_all_elements_same(): assert find_min_range_subsequence(1, [(3, [2, 2, 2])]) == [(3, 0)] def test_example_cases(): assert find_min_range_subsequence(3, [ (5, [4, 2, 1, 10, 5]), (3, [2, 2, 2]), (6, [1, 5, 3, 8, 2, 9]) ]) == [(5, 1), (3, 0), (6, 1)] def test_large_input(): assert find_min_range_subsequence(1, [(5, [10000, 9999, 9998, 9997, 9996])]) == [(5, 1)] def test_unsorted_elements(): assert find_min_range_subsequence(1, [(6, [6, 3, 9, 1, 4, 7])]) == [(6, 1)] def test_two_elements(): assert find_min_range_subsequence(1, [(2, [5, 8])]) == [(2, 3)]","solution":"def find_min_range_subsequence(t, test_cases): results = [] for i in range(t): n, a = test_cases[i] if n == 1: results.append((1, 0)) continue sorted_a = sorted(a) min_diff = float('inf') for j in range(1, n): min_diff = min(min_diff, sorted_a[j] - sorted_a[j - 1]) results.append((n, min_diff)) return results"},{"question":"def find_words_in_matrix(M, N, matrix, K, dictionary): Given a matrix of characters, find all words in the matrix that are present in a given dictionary. A word can be formed by a sequence of adjacent characters in 8 possible directions (up, down, left, right, diagonals). The same letter cell in the matrix may not be used more than once within the same word. Args: M (int): Number of rows in the matrix. N (int): Number of columns in the matrix. matrix (List[List[str]]): The matrix of characters. K (int): Number of words in the dictionary. dictionary (List[str]): List of words to be found in the matrix. Returns: List[str]: List of words found in the matrix. If no words are found, returns [\\"No words found\\"]. >>> find_words_in_matrix(4, 4, [['A', 'B', 'C', 'D'], ['E', 'F', 'G', 'H'], ['I', 'J', 'K', 'L'], ['M', 'N', 'O', 'P']], 5, ['ABEF', 'GK', 'CDE', 'MNO', 'NJKL']) ['ABEF', 'GK', 'MNO', 'NJKL'] >>> find_words_in_matrix(3, 4, [['A', 'B', 'C', 'D'], ['E', 'F', 'G', 'H'], ['I', 'J', 'K', 'L']], 3, ['HELLO', 'WORLD', 'DOG']) ['No words found']","solution":"def find_words_in_matrix(M, N, matrix, K, dictionary): def is_valid(x, y, visited): return 0 <= x < M and 0 <= y < N and not visited[x][y] def dfs(x, y, word, index, visited): if index == len(word): return True if not is_valid(x, y, visited) or matrix[x][y] != word[index]: return False visited[x][y] = True for dx, dy in directions: if dfs(x + dx, y + dy, word, index + 1, visited): return True visited[x][y] = False return False directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (1, 1), (-1, 1), (1, -1)] found_words = [] for word in dictionary: found = False visited = [[False for _ in range(N)] for _ in range(M)] for i in range(M): for j in range(N): if dfs(i, j, word, 0, visited): found_words.append(word) found = True break if found: break return found_words if found_words else [\\"No words found\\"] # Input reading and function call if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() M, N = int(data[0]), int(data[1]) matrix = [] idx = 2 for _ in range(M): matrix.append(data[idx: idx + N]) idx += N K = int(data[idx]) dictionary = data[idx + 1: idx + 1 + K] found_words = find_words_in_matrix(M, N, matrix, K, dictionary) for word in found_words: print(word)"},{"question":"def create_grain_stock(n: int, initial_stocks: List[Tuple[str, int]], q: int, operations: List[List[str]]) -> List[int]: Track, update, and query grain stock details. Args: n (int): The number of different grain types to register initially. initial_stocks (List[Tuple[str, int]]): List of tuples containing grain types and their initial stock quantities. q (int): The number of operations to be performed. operations (List[List[str]]): List of operations to update or query stock details. Returns: List[int]: Results of the query operations. >>> create_grain_stock(5, [(\\"wheat\\", 100), (\\"rice\\", 200), (\\"maze\\", 150), (\\"barley\\", 80), (\\"oats\\", 60)], 6, [[\\"Update\\", \\"wheat\\", 50], [\\"Query\\", \\"rice\\"], [\\"Update\\", \\"barley\\", -30], [\\"Query\\", \\"barley\\"], [\\"Update\\", \\"oats\\", 20], [\\"Query\\", \\"oats\\"]]) [200, 50, 80] >>> create_grain_stock(1, [(\\"corn\\", 1000)], 2, [[\\"Update\\", \\"corn\\", \\"0\\"], [\\"Query\\", \\"corn\\"]]) [1000] >>> create_grain_stock(2, [(\\"rye\\", 500), (\\"soybean\\", 400)], 4, [[\\"Update\\", \\"rye\\", -200], [\\"Query\\", \\"rye\\"], [\\"Update\\", \\"soybean\\", -100], [\\"Query\\", \\"soybean\\"]]) [300, 300] >>> create_grain_stock(2, [(\\"buckwheat\\", 700), (\\"millet\\", 800)], 2, [[\\"Query\\", \\"buckwheat\\"], [\\"Query\\", \\"millet\\"]]) [700, 800]","solution":"def create_grain_stock(n, initial_stocks, q, operations): grain_stock = {} for grain, stock in initial_stocks: grain_stock[grain] = stock results = [] for operation in operations: if operation[0] == \\"Update\\": grain = operation[1] quantity = int(operation[2]) grain_stock[grain] += quantity elif operation[0] == \\"Query\\": grain = operation[1] results.append(grain_stock[grain]) return results"},{"question":"def schedule_interviews(availability, duration, numSlots): Generate a list of available interview slots based on the interviewer's availability, the duration of each interview, and the number of consecutive slots required. >>> schedule_interviews([(9,12), (13,17)], 1, 2) [(9, 10), (10, 11), (13, 14), (14, 15), (15, 16)] >>> schedule_interviews([(9,11)], 1, 2) \\"Not enough slots\\" >>> schedule_interviews([(8,10), (11,15)], 2, 1) [(8, 10), (11, 13), (13, 15)]","solution":"def schedule_interviews(availability, duration, numSlots): Returns a list of available interview slots based on the interviewer's availability, the duration of each interview, and the number of consecutive slots required. available_slots = [] required_interval = duration * numSlots for start, end in availability: current_time = start while current_time + required_interval <= end: consecutive_slots = [(current_time + duration * i, current_time + duration * (i + 1)) for i in range(numSlots)] available_slots.append(consecutive_slots[0]) current_time += duration if len(available_slots) < numSlots: return \\"Not enough slots\\" return available_slots"},{"question":"def find_intersection(arr1, arr2): Returns the intersection of arr1 and arr2 in the order of first appearance in arr1. >>> find_intersection([1, 2, 3], [2, 3, 4]) [2, 3] >>> find_intersection([1, 2, 3], [4, 5, 6]) [] def process_test_cases(test_cases): Processes multiple test cases and returns the list of results. >>> process_test_cases([([1, 2, 3], [2, 3, 4]), ([1, 2, 3, 4], [2, 3, 4, 5, 6])]) [[2, 3], [2, 3, 4]]","solution":"def find_intersection(arr1, arr2): Returns the intersection of arr1 and arr2 in the order of first appearance in arr1. set_arr2 = set(arr2) result = [x for x in arr1 if x in set_arr2] return result def process_test_cases(test_cases): Processes multiple test cases and returns the list of results. results = [] for arr1, arr2 in test_cases: intersection = find_intersection(arr1, arr2) results.append(intersection) return results"},{"question":"def count_unique_follow_pairs(T, test_cases): Determine the number of unique follower-following pairs. T: An integer representing the number of test cases. test_cases: A list of tuples, where each tuple contains an integer N and a list of N follow operations. Returns a list of integers, each representing the number of unique follower-following pairs for each test case. >>> count_unique_follow_pairs(2, [ (3, [(1, 2), (1, 2), (2, 3)]), (4, [(5, 6), (5, 6), (5, 6), (6, 5)]) ]) [2, 2] >>> count_unique_follow_pairs(1, [ (1, [(1, 1)]) ]) [1] >>> count_unique_follow_pairs(1, [ (0, []) ]) [0] >>> count_unique_follow_pairs(1, [ (10, [(1, 2)] * 10) ]) [1] >>> count_unique_follow_pairs(1, [ (5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) ]) [5]","solution":"def count_unique_follow_pairs(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] follows = test_cases[i][1] unique_pairs = set(follows) results.append(len(unique_pairs)) return results"},{"question":"from collections import OrderedDict def char_frequency(text: str) -> OrderedDict: Determine the frequency of each character in a string and return an ordered dictionary with characters as keys and their frequencies as values. The order should be based on the first appearance of each character. Args: text (str): The input string consisting of lowercase alphabetical characters. Returns: OrderedDict: An ordered dictionary with the frequencies of each character. Examples: >>> char_frequency(\\"aabccdeff\\") OrderedDict([('a', 2), ('b', 1), ('c', 2), ('d', 1), ('e', 1), ('f', 2)]) >>> char_frequency(\\"aaaaaa\\") OrderedDict([('a', 6)]) >>> char_frequency(\\"abcdef\\") OrderedDict([('a', 1), ('b', 1), ('c', 1), ('d', 1), ('e', 1), ('f', 1)]) >>> char_frequency(\\"abacabad\\") OrderedDict([('a', 4), ('b', 2), ('c', 1), ('d', 1)]) >>> char_frequency(\\"\\") OrderedDict()","solution":"from collections import OrderedDict def char_frequency(text: str) -> OrderedDict: Returns an ordered dictionary with the frequency of each character in the string. The order is based on the first appearance of each character. frequency_dict = OrderedDict() for char in text: if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict"},{"question":"def sort_string(s: str) -> str: Sorts the letters in alphabetical order and the integers in numerical order while preserving their relative positions. Parameters: s (str): The input string consisting of lowercase letters and integers. Returns: str: The resulting string where letters and integers remain separated and sorted. Example: >>> sort_string(\\"a3c1b2\\") \\"abc123\\" >>> sort_string(\\"4d3c2b1a\\") \\"abcd1234\\"","solution":"def sort_string(s): Sorts the letters in alphabetical order and the integers in numerical order while preserving their relative positions. Parameters: s (str): The input string consisting of lowercase letters and integers. Returns: str: The resulting string where letters and integers remain separated and sorted. letters = sorted([ch for ch in s if ch.isalpha()]) digits = sorted([ch for ch in s if ch.isdigit()]) sorted_str = ''.join(letters + digits) return sorted_str"},{"question":"from typing import List, Tuple def shortest_path_with_limited_changes(n: int, m: int, s: int, e: int, k: int, edges: List[Tuple[int, int, int]]) -> int: Find the shortest path from node s to node e in a weighted undirected graph with limitations on direction changes. Args: n (int): Number of nodes. m (int): Number of edges. s (int): Start node. e (int): End node. k (int): Number of allowed direction changes. edges (List[Tuple[int, int, int]]): List of edges represented as tuples (u, v, w) with u and v being nodes and w being the weight of the edge. Returns: int: The shortest path length. If no valid path exists, return -1. Examples: >>> shortest_path_with_limited_changes(5, 7, 1, 5, 2, [(1, 2, 4), (1, 3, 2), (2, 3, 1), (2, 4, 5), (3, 4, 8), (4, 5, 3), (2, 5, 7)]) 10 >>> shortest_path_with_limited_changes(5, 7, 1, 5, 0, [(1, 2, 4), (1, 3, 2), (2, 3, 1), (2, 4, 5), (3, 4, 8), (4, 5, 3), (2, 5, 7)]) -1 >>> shortest_path_with_limited_changes(3, 3, 1, 3, 1, [(1, 2, 3), (2, 3, 4), (1, 3, 10)]) 7 >>> shortest_path_with_limited_changes(4, 4, 1, 4, 2, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 5)]) 3 >>> shortest_path_with_limited_changes(4, 4, 1, 4, 1, [(1, 2, 1), (2, 4, 2), (1, 3, 1), (3, 4, 2)]) 3","solution":"import heapq def shortest_path_with_limited_changes(n, m, s, e, k, edges): # Create adjacency list graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Define a priority queue for Dijkstra's algorithm pq = [(0, s, -1, 0)] # (cost, current node, previous node, direction changes) dist = [[[float('inf')] * (k + 1) for _ in range(n + 1)] for _ in range(n + 1)] dist[s][s][0] = 0 while pq: cost, current, prev, changes = heapq.heappop(pq) if cost > dist[current][prev][changes]: continue if current == e: return cost for neighbor, weight in graph[current]: new_cost = cost + weight new_changes = changes if prev != -1 and prev != neighbor: if changes < k: new_changes += 1 else: continue if new_cost < dist[neighbor][current][new_changes]: dist[neighbor][current][new_changes] = new_cost heapq.heappush(pq, (new_cost, neighbor, current, new_changes)) min_cost = min(dist[e][i][changes] for i in range(n + 1) for changes in range(k + 1)) return min_cost if min_cost != float('inf') else -1"},{"question":"from typing import List def longest_word(grid: List[List[str]]) -> str: Find the longest word that can be formed from a grid of alphabetic characters by moving to adjacent cells. >>> longest_word([ ... ['a', 'b', 'c'], ... ['d', 'e', 'f'], ... ['g', 'h', 'i'] ... ]) \\"abcdefi\\" pass def test_longest_in_small_grid(): grid = [ ['a', 'b'], ['c', 'd'] ] result = longest_word(grid) assert result in ['abcd', 'abdc', 'acbd', 'acdb', 'adbc', 'adcb', 'bacd', 'badc', 'bcad', 'bcda', 'bdac', 'bdca', 'cabd', 'cadb', 'cbad', 'cbda', 'cdab', 'cdba', 'dabc', 'dacb', 'dbac', 'dbca', 'dcab', 'dcba'] def test_longest_in_larger_grid(): grid = [ ['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i'] ] result = longest_word(grid) found = len(result) == len('abcdefghi') # Longest word must be 9 characters long assert found def test_non_square_grid(): grid = [ ['a', 'b', 'c'], ['d', 'e', 'f'] ] result = longest_word(grid) found = len(result) == len('abcdef') # Longest word must be 6 characters long assert found def test_single_letter_grid(): grid = [['a']] result = longest_word(grid) assert result == 'a' def test_same_letter_grid(): grid = [ ['a', 'a'], ['a', 'a'] ] result = longest_word(grid) assert result == 'aaaa'","solution":"from typing import List def longest_word(grid: List[List[str]]) -> str: rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] # 8 possible directions longest = \\"\\" def dfs(x: int, y: int, visited: List[List[bool]], current_word: str) -> str: nonlocal longest current_word += grid[x][y] if len(current_word) > len(longest): longest = current_word visited[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny]: dfs(nx, ny, visited, current_word) visited[x][y] = False for i in range(rows): for j in range(cols): visited = [[False] * cols for _ in range(rows)] dfs(i, j, visited, \\"\\") return longest"},{"question":"from typing import List, Tuple def sortStudents(arr: List[Tuple[str, int]], N: int) -> List[Tuple[str, int]]: Sorts the student records based on the grade in descending order. If two students have the same grade, they are sorted alphabetically by their name. >>> sortStudents([(\\"Alice\\", 85), (\\"Bob\\", 90), (\\"Charlie\\", 85)], 3) [(\\"Bob\\", 90), (\\"Alice\\", 85), (\\"Charlie\\", 85)] >>> sortStudents([(\\"Dave\\", 75), (\\"Eve\\", 85)], 2) [(\\"Eve\\", 85), (\\"Dave\\", 75)]","solution":"from typing import List, Tuple def sortStudents(arr: List[Tuple[str, int]], N: int) -> List[Tuple[str, int]]: Sorts the student records based on the grade in descending order. If two students have the same grade, they are sorted alphabetically by their name. # Sort the array with priority to the grade in descending order and then by name in ascending order. arr.sort(key=lambda x: (-x[1], x[0])) return arr"},{"question":"def can_partition(nums: List[int]) -> str: Determine if it is possible to partition the array into two subsets with equal sum. >>> can_partition([1, 5, 11, 5]) \\"YES\\" >>> can_partition([1, 2, 3, 5]) \\"NO\\"","solution":"def can_partition(nums): total_sum = sum(nums) # If the total sum is odd, we can't partition it into two equal subsets if total_sum % 2 != 0: return \\"NO\\" subset_sum = total_sum // 2 n = len(nums) # Initialize a dp array where dp[i] will be True if a subset sum of i can be formed dp = [False] * (subset_sum + 1) dp[0] = True for num in nums: for j in range(subset_sum, num - 1, -1): dp[j] = dp[j] or dp[j - num] return \\"YES\\" if dp[subset_sum] else \\"NO\\""},{"question":"def findMaximum(arr, n): Finds the maximum element in an array which is first increasing, then decreasing. Parameters: arr (list): List of integers. n (int): Length of the list. Returns: int: The maximum element in the array. Example: >>> findMaximum([1, 3, 8, 12, 4, 2], 6) 12 >>> findMaximum([10, 20, 30, 40, 50], 5) 50 # Your implementation here def test_findMaximum(): assert findMaximum([1, 3, 8, 12, 4, 2], 6) == 12 assert findMaximum([10, 20, 30, 40, 50], 5) == 50 assert findMaximum([1, 2, 3, 4, 5, 4, 3, 2, 1], 9) == 5 assert findMaximum([1], 1) == 1 # Single element case assert findMaximum([10, 20, 30, 40, 10], 5) == 40 assert findMaximum([1, 2, 3, 4, 3, 2, 1], 7) == 4 assert findMaximum([10, 9, 8, 7, 6], 5) == 10 # Decreasing only case from start if __name__ == \\"__main__\\": test_findMaximum() print(\\"All tests passed.\\")","solution":"def findMaximum(arr, n): Finds the maximum element in an array which is first increasing, then decreasing. Parameters: arr (list): List of integers. n (int): Length of the list. Returns: int: The maximum element in the array. low, high = 0, n - 1 while low <= high: mid = (low + high) // 2 if (mid == 0 or arr[mid] > arr[mid - 1]) and (mid == n - 1 or arr[mid] > arr[mid + 1]): return arr[mid] elif mid > 0 and arr[mid - 1] > arr[mid]: high = mid - 1 else: low = mid + 1 return -1 # This case should never be reached if the input is valid"},{"question":"def min_moves_to_rearrange_books(n: int, sections: List[int]) -> int: Determine the minimum number of moves required to rearrange the bookshelf such that all books of the same color are in contiguous sections. Input: n (int): the number of sections on the bookshelf. sections (List[int]): the color code of each section on the bookshelf. Output: int: the minimum number of moves required. Examples: >>> min_moves_to_rearrange_books(5, [1, 2, 1, 2, 1]) 4 >>> min_moves_to_rearrange_books(6, [1, 1, 2, 3, 2, 1]) 4 >>> min_moves_to_rearrange_books(5, [1, 1, 1, 1, 1]) 0 >>> min_moves_to_rearrange_books(4, [1, 2, 3, 4]) 3 >>> min_moves_to_rearrange_books(6, [1, 1, 2, 2, 1, 1]) 2","solution":"def min_moves_to_rearrange_books(n, sections): if n <= 1: return 0 moves = 0 for i in range(1, n): if sections[i] != sections[i-1]: moves += 1 return moves"},{"question":"def max_profit(n: int, transactions: List[int]) -> int: Calculate the maximum profit that can be achieved by making at most one transaction (buy one and sell one) in the given period. Args: n (int): The length of transaction array. transactions (List[int]): The list of transaction values recorded each day. Returns: int: The maximum profit that can be achieved, or 0 if no profit can be made. Examples: >>> max_profit(6, [7, 1, 5, 3, 6, 4]) 5 >>> max_profit(5, [7, 6, 4, 3, 1]) 0 from solution import max_profit def test_example_1(): assert max_profit(6, [7, 1, 5, 3, 6, 4]) == 5 def test_example_2(): assert max_profit(5, [7, 6, 4, 3, 1]) == 0 def test_single_element(): assert max_profit(1, [10]) == 0 def test_all_increasing(): assert max_profit(5, [1, 2, 3, 4, 5]) == 4 def test_all_decreasing(): assert max_profit(5, [5, 4, 3, 2, 1]) == 0 def test_alternating_increase_decrease(): assert max_profit(6, [3, 3, 5, 0, 0, 3]) == 3 def test_big_case(): big_case = list(range(200000, 0, -1)) assert max_profit(200000, big_case) == 0 def test_no_profit_but_fluctuating(): assert max_profit(5, [2, 2, 2, 2, 2]) == 0","solution":"def max_profit(n, transactions): if n == 0: return 0 min_price = float('inf') max_profit = 0 for price in transactions: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) transactions = list(map(int, data[1:])) print(max_profit(n, transactions))"},{"question":"def is_balanced(s: str) -> bool: Determines if a string containing only the characters 'a' and 'b' is balanced. A string is considered \\"balanced\\" if the number of occurrences of 'a' is equal to the number of occurrences of 'b'. :param s: str - Input string containing only 'a' and 'b'. :return: bool - True if the string is balanced, False otherwise. Examples: >>> is_balanced(\\"ab\\") True >>> is_balanced(\\"aabb\\") True >>> is_balanced(\\"aab\\") False","solution":"def is_balanced(s): Checks if the string s is balanced, meaning the number of occurrences of 'a' is equal to the number of occurrences of 'b'. :param s: str - Input string containing only 'a' and 'b'. :return: bool - True if the string is balanced, False otherwise. return s.count('a') == s.count('b')"},{"question":"from typing import List def max_subgrid_sum(grid: List[List[int]]) -> int: Calculate the maximum sum of any subgrid in a given 2D grid. pass def max_subarray_sum(arr: List[int]) -> int: Calculate the maximum sum of any subarray using the Kadane's algorithm. pass def process_test_cases(test_cases: List[List[List[int]]]) -> List[int]: Process multiple test cases and return the results. pass def parse_input(input_data: str) -> List[List[List[int]]]: Parse input data into a list of test cases. pass def main(input_data: str): Main function for running the processing of test cases. test_cases = parse_input(input_data) results = process_test_cases(test_cases) for result in results: print(result) import pytest def test_max_subgrid_sum(): grid = [ [1, 2], [-1, -3] ] assert max_subgrid_sum(grid) == 3 grid = [ [1, -2, 3], [4, 5, -6], [-7, 8, 9] ] assert max_subgrid_sum(grid) == 17 def test_max_subarray_sum(): arr = [1, 2, -1, -3] assert max_subarray_sum(arr) == 3 arr = [4, -5, 9, -11, 3, 6] assert max_subarray_sum(arr) == 9 def test_parse_input(): input_data = 2 2 2 1 2 -1 -3 3 3 1 -2 3 4 5 -6 -7 8 9 expected_output = [ [ [1, 2], [-1, -3] ], [ [1, -2, 3], [4, 5, -6], [-7, 8, 9] ] ] assert parse_input(input_data) == expected_output def test_process_test_cases(): test_cases = [ [ [1, 2], [-1, -3] ], [ [1, -2, 3], [4, 5, -6], [-7, 8, 9] ] ] assert process_test_cases(test_cases) == [3, 17] def test_main(capsys): input_data = 2 2 2 1 2 -1 -3 3 3 1 -2 3 4 5 -6 -7 8 9 main(input_data) captured = capsys.readouterr() assert captured.out.strip() == \\"3n17\\"","solution":"def max_subgrid_sum(grid): This function calculates the maximum sum of any subgrid in a given 2D grid. N = len(grid) M = len(grid[0]) max_sum = float('-inf') for left in range(M): temp = [0] * N for right in range(left, M): for i in range(N): temp[i] += grid[i][right] current_sum = max_subarray_sum(temp) max_sum = max(max_sum, current_sum) return max_sum def max_subarray_sum(arr): Helper function to calculate the maximum sum of any subarray using the Kadane's algorithm. max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far def process_test_cases(test_cases): Function to process multiple test cases and output the results. results = [] for grid in test_cases: results.append(max_subgrid_sum(grid)) return results def parse_input(input_data): Function to parse input data into a list of test cases. lines = input_data.strip().split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N, M = map(int, lines[index].split()) index += 1 grid = [] for _ in range(N): grid.append(list(map(int, lines[index].split()))) index += 1 test_cases.append(grid) return test_cases # Example usage def main(input_data): test_cases = parse_input(input_data) results = process_test_cases(test_cases) for result in results: print(result) input_data = 2 2 2 1 2 -1 -3 3 3 1 -2 3 4 5 -6 -7 8 9 main(input_data)"},{"question":"def maxProduct(nums: List[int]) -> int: Returns the maximum product of a contiguous subarray. >>> maxProduct([2, 3, 4]) 24 >>> maxProduct([2, 3, -2, 4]) 6 >>> maxProduct([-2, 3, -4]) 24 >>> maxProduct([-2, 0, -1]) 0 >>> maxProduct([0, 2]) 2 >>> maxProduct([2]) 2 >>> maxProduct([-2]) -2 >>> maxProduct([-2, -3, -4]) 12 >>> maxProduct([2, -5, -2, -4, 3]) 24 >>> maxProduct([-1, -3, -10, 0, 60]) 60 >>> maxProduct([6, -3, -10, 0, 2]) 180","solution":"def maxProduct(nums): Returns the maximum product of a contiguous subarray. if not nums: return 0 # Initialize the maximum and minimum products as the first element max_prod = min_prod = result = nums[0] # Iterate through the array from the second element for num in nums[1:]: if num < 0: max_prod, min_prod = min_prod, max_prod max_prod = max(num, max_prod * num) min_prod = min(num, min_prod * num) result = max(result, max_prod) return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root): Flattens a binary tree to a linked list in-place. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(4) >>> root.right.right = TreeNode(6) >>> flatten(root) >>> tree_to_list(root) == [1, 2, 3, 4, 5, 6] True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root): Flattens a binary tree to a linked list in-place. if not root: return # Flatten the left and right subtree flatten(root.left) flatten(root.right) # Store the left and right nodes left = root.left right = root.right # Turn the left subtree into the right subtree root.left = None root.right = left # Find the end of the new right subtree p = root while p.right: p = p.right # Attach the original right subtree p.right = right"},{"question":"def is_subset_sum(arr, n, sum_val): Helper function to check if there is a subset of the array with a sum equal to 'sum_val'. pass def find_subsets(T, test_cases): Determine if there exists a subset of the collection whose sum is equal to the target value S. Args: T (int): Number of test cases. test_cases (list): A list of tuples where each tuple contains a pair ((N, S), arr) with: - N (int): Number of integers in the collection. - S (int): Target sum value. - arr (list): Collection of integers. Returns: list: A list of strings, \\"Possible\\" or \\"Impossible\\" for each test case. >>> find_subsets(3, [((5, 9), [1, 2, 3, 4, 5]), ((4, 0), [3, -1, -2, 1]), ((3, -5), [-2, -3, 7])]) [\\"Possible\\", \\"Possible\\", \\"Impossible\\"] pass # Add your test cases below to verify the solution T = 3 test_cases = [ ((5, 9), [1, 2, 3, 4, 5]), ((4, 0), [3, -1, -2, 1]), ((3, -5), [-2, -3, 7]) ] print(find_subsets(T, test_cases)) # Output should be: [\\"Possible\\", \\"Possible\\", \\"Impossible\\"]","solution":"def is_subset_sum(arr, n, sum_val): if sum_val == 0: return True if n == 0: return False if arr[n-1] > sum_val: return is_subset_sum(arr, n-1, sum_val) include = is_subset_sum(arr, n-1, sum_val - arr[n-1]) exclude = is_subset_sum(arr, n-1, sum_val) return include or exclude def find_subsets(T, test_cases): results = [] for i in range(T): N, S = test_cases[i][0] arr = test_cases[i][1] if is_subset_sum(arr, N, S): results.append(\\"Possible\\") else: results.append(\\"Impossible\\") return results # For your example input T = 3 test_cases = [ ((5, 9), [1, 2, 3, 4, 5]), ((4, 0), [3, -1, -2, 1]), ((3, -5), [-2, -3, 7]) ] result = find_subsets(T, test_cases) for res in result: print(res)"},{"question":"def min_window(s: str, t: str) -> str: Find the minimum window substring in S which will contain all the characters in T. >>> min_window(\\"ADOBECODEBANC\\", \\"ABC\\") == \\"BANC\\" >>> min_window(\\"a\\", \\"a\\") == \\"a\\" >>> min_window(\\"a\\", \\"aa\\") == \\"\\"","solution":"def min_window(s: str, t: str) -> str: from collections import Counter, defaultdict if not t or not s: return \\"\\" # Dictionary keeping track of how many letters of t we need to find in s dict_t = Counter(t) # Number of unique characters in t, which need to be present in the window required = len(dict_t) # Left and right pointers l, r = 0, 0 # Formed is when the window contains all characters in the required frequency formed = 0 # Dictionary to keep track of all the unique characters in the current window window_counts = defaultdict(int) # [window length, left, right] ans = float('inf'), None, None while r < len(s): # Add one character from the right to the window character = s[r] window_counts[character] += 1 # If the number of current characters matches the desired count in t, increment the formed count if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 # Try and contract the window from the left till the point it ceases to be 'desirable' while l <= r and formed == required: character = s[l] # Save the smallest window until now if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) # The character at the position pointed by the \`left\` pointer is no longer a part of the window. window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 # Move the left pointer ahead l += 1 # Keep expanding the window once we are done contracting r += 1 return \\"\\" if ans[0] == float('inf') else s[ans[1]:ans[2] + 1]"},{"question":"def roman_to_int(roman: str) -> int: Converts a Roman numeral to an integer. >>> roman_to_int(\\"III\\") 3 >>> roman_to_int(\\"IX\\") 9 >>> roman_to_int(\\"LVIII\\") 58 >>> roman_to_int(\\"MCMXCIV\\") 1994 pass","solution":"def roman_to_int(roman: str) -> int: Converts a Roman numeral to an integer. roman_values = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(roman): current_value = roman_values[char] if current_value < prev_value: total -= current_value else: total += current_value prev_value = current_value return total"},{"question":"def TopM(observations, M): Returns the A-ids of the M most frequently observed species. Parameters: observations (list of int): List of A-id observations. M (int): Number of top most frequent A-ids to return. Returns: list of int: List of A-ids of the most frequently observed species. pass from solution import TopM def test_example_1(): assert set(TopM([5, 3, 5, 2, 6, 3, 3], 2)) == {3, 5} def test_example_2(): assert set(TopM([4, 4, 1, 2, 2, 2, 4, 3, 3], 3)) == {4, 2, 3} def test_single_occurrence(): assert set(TopM([1, 2, 3, 4, 5], 3)) == {1, 2, 3} def test_all_same_frequency(): assert set(TopM([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 2)) == {3, 4} def test_large_input(): observations = [1] * 100000 + [2] * 50000 + [3] * 25000 assert TopM(observations, 1) == [1] assert set(TopM(observations, 2)) == {1, 2} assert set(TopM(observations, 3)) == {1, 2, 3} def test_tie_with_lower_aid_priority(): assert TopM([1, 1, 2, 2, 3, 3, 4, 4], 2) == [1, 2]","solution":"import heapq from collections import Counter def TopM(observations, M): Returns the A-ids of the M most frequently observed species. Parameters: observations (list of int): List of A-id observations. M (int): Number of top most frequent A-ids to return. Returns: list of int: List of A-ids of the most frequently observed species. # Count the frequency of each A-id counter = Counter(observations) # Use a max-heap to keep track of M most frequent A-ids max_heap = [(-freq, a_id) for a_id, freq in counter.items()] heapq.heapify(max_heap) # Extract top M elements from the max-heap result = [] for _ in range(M): result.append(heapq.heappop(max_heap)[1]) return result"},{"question":"from typing import List, Tuple, Union def unique_prefix_sum_sequence(n: int) -> Union[str, Tuple[str, List[int]]]: Determines if it is possible to create a sequence of length n where each prefix sum is unique. Returns the sequence if possible, otherwise returns \\"NO\\". :param n: Length of the sequence to be generated :return: \\"YES\\" followed by the sequence if possible, otherwise \\"NO\\" >>> unique_prefix_sum_sequence(3) ('YES', [1, 2, 4]) >>> unique_prefix_sum_sequence(4) ('YES', [1, 2, 4, 8]) >>> unique_prefix_sum_sequence(100000) ('YES', [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, ...]) >>> unique_prefix_sum_sequence(0) 'NO' >>> unique_prefix_sum_sequence(-5) 'NO'","solution":"def unique_prefix_sum_sequence(n): Determines if it is possible to create a sequence of length n where each prefix sum is unique. Returns the sequence if possible, otherwise prints \\"NO\\". # For any positive integer n, this problem can be solved by using the sequence of powers of 2 # because each prefix sum will be unique (sum of all previous + the next power of 2). if n < 1: return \\"NO\\" sequence = [2**i for i in range(n)] return \\"YES\\", sequence"},{"question":"def getSum(a: int, b: int) -> int: Return the sum of two integers without using + and - operators. >>> getSum(2, 3) == 5 >>> getSum(10, 7) == 17 >>> getSum(-1, 1) == 0 >>> getSum(-5, -3) == -8 >>> getSum(7, -2) == 5 >>> getSum(0, 5) == 5 >>> getSum(7, 0) == 7 >>> getSum(1000000000, 1000000000) == 2000000000 >>> getSum(-(10**9), 10**9) == 0 >>> getSum(-1000000000, -1000000000) == -2000000000","solution":"def getSum(a, b): Return the sum of two integers without using + and - operators. # 32 bits integer max MAX = 0x7FFFFFFF # Mask to get 32 bits MASK = 0xFFFFFFFF while b != 0: # (a & b) gives all the carry bits, << 1 shifts them to the left carry = (a & b) << 1 # (a ^ b) does the adding without carry a = (a ^ b) & MASK b = carry & MASK # If the result is negative, return the two's complement of a return a if a <= MAX else ~(a ^ MASK)"},{"question":"def filter_scores(scores, high_threshold, low_threshold): Return a tuple containing two lists: - The first list contains scores greater than high_threshold. - The second list contains scores less than low_threshold. >>> filter_scores([90, 85, 70, 65, 50], 75, 60) ([90, 85], [50]) >>> filter_scores([88, 76, 54, 45, 95], 80, 50) ([88, 95], [45]) >>> filter_scores([50, 60, 70, 80, 90], 65, 55) ([70, 80, 90], [50])","solution":"def filter_scores(scores, high_threshold, low_threshold): Returns two lists: - The first list contains scores greater than high_threshold. - The second list contains scores less than low_threshold. above_high = [score for score in scores if score > high_threshold] below_low = [score for score in scores if score < low_threshold] return (above_high, below_low)"},{"question":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def minimum_spanning_tree(N, M, edges): Prune the forest such that all trees remain connected with minimum total difficulty of traversal. Args: N : int : number of nodes (trees) M : int : number of edges (paths) edges : List[Tuple[int, int, int]] : list of edges represented by tuples (u, v, w) where u and v are nodes connected by this edge, and w is the weight of this edge. Returns: int : total weight of the Minimum Spanning Tree (MST) Example: >>> minimum_spanning_tree(4, 5, [(1, 2, 1), (2, 3, 4), (3, 4, 5), (4, 1, 6), (1, 3, 3)]) 9 >>> minimum_spanning_tree(2, 1, [(1, 2, 10)]) 10 >>> minimum_spanning_tree(3, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) 3 >>> minimum_spanning_tree(4, 6, [ (1, 2, 10000), (2, 3, 10000), (3, 4, 10000), (4, 1, 10000), (1, 3, 9999), (2, 4, 9999) ]) 29998 def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) edges = [] index = 2 for _ in range(M): u = int(data[index]) v = int(data[index + 1]) w = int(data[index + 2]) edges.append((u, v, w)) index += 3 result = minimum_spanning_tree(N, M, edges) print(result) if __name__ == \\"__main__\\": main()","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def minimum_spanning_tree(N, M, edges): edges.sort(key=lambda x: x[2]) # Sort edges by weights parent = list(range(N)) rank = [0] * N mst_weight = 0 num_edges_in_mst = 0 for u, v, w in edges: u -= 1 v -= 1 root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: union(parent, rank, root_u, root_v) mst_weight += w num_edges_in_mst += 1 if num_edges_in_mst == N - 1: break return mst_weight def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) edges = [] index = 2 for _ in range(M): u = int(data[index]) v = int(data[index + 1]) w = int(data[index + 2]) edges.append((u, v, w)) index += 3 result = minimum_spanning_tree(N, M, edges) print(result) if __name__ == \\"__main__\\": main()"},{"question":"def calculate_total(cart: List[str], prices: Dict[str, float]) -> float: Calculates the total cost of a customer's cart based on provided prices. Args: cart (list of str): List of product names that the customer wants to buy. prices (dict): Dictionary with product names as keys and their corresponding prices as values. Returns: float: The total cost of products in the cart. >>> calculate_total([\\"apple\\", \\"banana\\", \\"milk\\"], {\\"apple\\": 1.0, \\"banana\\": 0.5, \\"milk\\": 1.5}) 3.0 >>> calculate_total([\\"apple\\", \\"chocolate\\"], {\\"apple\\": 1.0, \\"banana\\": 0.5, \\"milk\\": 1.5}) 1.0 >>> calculate_total([\\"bread\\", \\"butter\\"], {\\"bread\\": 2.0, \\"butter\\": 3.0, \\"milk\\": 1.5}) 5.0 >>> calculate_total([\\"orange\\"], {\\"apple\\": 1.0, \\"banana\\": 0.5, \\"milk\\": 1.5}) 0.0 >>> calculate_total([], {\\"apple\\": 1.0, \\"banana\\": 0.5, \\"milk\\": 1.5}) 0.0 >>> calculate_total([\\"apple\\", \\"banana\\"], {}) 0.0 >>> calculate_total([\\"apple\\", \\"banana\\", \\"banana\\"], {\\"apple\\": 1.0, \\"banana\\": 0.5}) 2.0 >>> calculate_total([\\"banana\\", \\"banana\\", \\"banana\\"], {\\"banana\\": 0.5}) 1.5","solution":"def calculate_total(cart, prices): Calculates the total cost of a customer's cart based on provided prices. Args: cart (list of str): List of product names that the customer wants to buy. prices (dict): Dictionary with product names as keys and their corresponding prices as values. Returns: float: The total cost of products in the cart. total_cost = 0.0 for product in cart: if product in prices: total_cost += prices[product] return total_cost"},{"question":"def find_project_with_most_unique_employees(n: int, logs: List[str]) -> Optional[int]: You are given a list of employee logs, where each log contains an integer Employee ID, an integer Project ID, and a string that represents the date of logging in \`YYYY-MM-DD\` format. Your task is to find the Project ID that has the largest number of unique employees working on it. If there are multiple such projects, return the one with the smallest Project ID. :param n: An integer representing the number of logs. :param logs: A list of strings where each string contains space-separated values: Employee ID, Project ID, and date. :return: The Project ID with the largest number of unique employees, or the smallest Project ID if there is a tie. Example usage: >>> find_project_with_most_unique_employees(7, [ ... \\"101 1 2022-01-01\\", \\"102 2 2022-01-02\\", \\"103 1 2022-01-03\\", \\"102 1 2022-01-04\\", ... \\"104 3 2022-01-05\\", \\"101 2 2022-01-06\\", \\"105 3 2022-01-07\\"]) 1 >>> find_project_with_most_unique_employees(3, [\\"101 1 2022-01-01\\", \\"102 1 2022-01-02\\", \\"103 1 2022-01-03\\"]) 1 from typing import List, Optional from solution import find_project_with_most_unique_employees def test_example_case(): n = 7 logs = [ \\"101 1 2022-01-01\\", \\"102 2 2022-01-02\\", \\"103 1 2022-01-03\\", \\"102 1 2022-01-04\\", \\"104 3 2022-01-05\\", \\"101 2 2022-01-06\\", \\"105 3 2022-01-07\\" ] assert find_project_with_most_unique_employees(n, logs) == 1 def test_single_project_multiple_employees(): n = 3 logs = [ \\"101 1 2022-01-01\\", \\"102 1 2022-01-02\\", \\"103 1 2022-01-03\\" ] assert find_project_with_most_unique_employees(n, logs) == 1 def test_tie_between_projects(): n = 6 logs = [ \\"101 1 2022-01-01\\", \\"102 2 2022-01-02\\", \\"103 1 2022-01-03\\", \\"104 2 2022-01-04\\", \\"105 3 2022-01-05\\", \\"106 3 2022-01-06\\" ] assert find_project_with_most_unique_employees(n, logs) == 1 def test_no_employees(): n = 0 logs = [] assert find_project_with_most_unique_employees(n, logs) == None def test_multiple_employees_same_project_same_day(): n = 4 logs = [ \\"101 2 2022-01-01\\", \\"102 2 2022-01-01\\", \\"103 2 2022-01-01\\", \\"104 2 2022-01-01\\" ] assert find_project_with_most_unique_employees(n, logs) == 2","solution":"def find_project_with_most_unique_employees(n, logs): project_employee_map = {} for log in logs: employee_id, project_id, _ = log.split() employee_id = int(employee_id) project_id = int(project_id) if project_id not in project_employee_map: project_employee_map[project_id] = set() project_employee_map[project_id].add(employee_id) max_unique_employees = 0 project_with_max_unique_employees = None for project_id, employees in project_employee_map.items(): if len(employees) > max_unique_employees or ( len(employees) == max_unique_employees and (project_with_max_unique_employees is None or project_id < project_with_max_unique_employees)): max_unique_employees = len(employees) project_with_max_unique_employees = project_id return project_with_max_unique_employees # Example usage: # n = 7 # logs = [ # \\"101 1 2022-01-01\\", # \\"102 2 2022-01-02\\", # \\"103 1 2022-01-03\\", # \\"102 1 2022-01-04\\", # \\"104 3 2022-01-05\\", # \\"101 2 2022-01-06\\", # \\"105 3 2022-01-07\\" # ] # print(find_project_with_most_unique_employees(n, logs)) # Output: 1"},{"question":"def is_special_string(s: str) -> str: Check if a given string is special. A string is considered special if it only consists of the alphabetic characters 'a', 'e', 'i', 'o', 'u', 'b', 'c', 'd', and 'f'. >>> is_special_string(\\"abc\\") \\"YES\\" >>> is_special_string(\\"aeiouxyz\\") \\"NO\\" >>> is_special_string(\\"bdf\\") \\"YES\\" def process_test_cases(T: int, strings: List[str]) -> List[str]: Process multiple test cases to check if the given strings are special or not. >>> process_test_cases(3, [\\"abc\\", \\"aeiouxyz\\", \\"bdf\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases(2, [\\"a\\", \\"z\\"]) [\\"YES\\", \\"NO\\"]","solution":"def is_special_string(s): Check if a given string is special. A string is considered special if it only consists of the alphabetic characters 'a', 'e', 'i', 'o', 'u', 'b', 'c', 'd', and 'f'. special_chars = set('aeioubcdf') for char in s: if char not in special_chars: return \\"NO\\" return \\"YES\\" def process_test_cases(T, strings): results = [] for string in strings: results.append(is_special_string(string)) return results"},{"question":"def max_rounds(N, candies): Calculate the maximum number of rounds Jack can distribute candies. Parameters: N (int): Number of jars. candies (list): List containing number of candies in each jar. Returns: int: Maximum number of rounds Jack can distribute candies. pass # Unit Tests def test_max_rounds(): assert max_rounds(5, [2, 3, 1, 4, 0]) == 10 assert max_rounds(3, [0, 0, 0]) == 0 assert max_rounds(4, [1, 1, 1, 1]) == 4 assert max_rounds(1, [5]) == 5 assert max_rounds(3, [5, 0, 2]) == 7 assert max_rounds(2, [1000000, 1000000]) == 2000000 assert max_rounds(4, [0, 0, 0, 0]) == 0 assert max_rounds(6, [1, 2, 3, 4, 5, 6]) == 21 assert max_rounds(1, [0]) == 0 assert max_rounds(1, [1000000]) == 1000000 if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"def max_rounds(N, candies): Calculate the maximum number of rounds Jack can distribute candies. Parameters: N (int): Number of jars. candies (list): List containing number of candies in each jar. Returns: int: Maximum number of rounds Jack can distribute candies. return sum(candies)"},{"question":"from typing import List from collections import Counter def can_form_palindrome(s: str) -> bool: Determines if a string can be rearranged to form a palindrome. :param s: string containing only lowercase alphabetic characters :return: True if the string can be rearranged to form a palindrome, False otherwise >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabb\\") True","solution":"from collections import Counter def can_form_palindrome(s): Determines if a string can be rearranged to form a palindrome. :param s: string containing only lowercase alphabetic characters :return: True if the string can be rearranged to form a palindrome, False otherwise char_count = Counter(s) odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 if odd_count > 1: return False return True"},{"question":"def calculate_work_hours(entries): Calculate the total work hours for each employee. Each entry is a log consisting of an employee ID, an action (either \\"entry\\" or \\"exit\\"), and the time in \\"HH:MM\\" format. The function returns a list of strings, where each string contains the employee ID and their total work hours in \\"HH:MM\\" format. >>> calculate_work_hours([\\"emp01 entry 09:00\\", \\"emp01 exit 17:00\\"]) [\\"emp01 08:00\\"] >>> calculate_work_hours([\\"john entry 08:15\\", \\"john exit 12:30\\", \\"john entry 13:15\\", \\"john exit 17:45\\", \\"mary entry 09:00\\", \\"mary exit 17:00\\"]) [\\"john 08:45\\", \\"mary 08:00\\"]","solution":"def calculate_work_hours(entries): from datetime import datetime, timedelta logs = {} first_appearance = [] for entry in entries: emp_id, action, time_str = entry.split() time = datetime.strptime(time_str, \\"%H:%M\\") if emp_id not in logs: logs[emp_id] = {\\"entry\\": [], \\"exit\\": [], \\"total\\": timedelta()} first_appearance.append(emp_id) logs[emp_id][action].append(time) results = {} for emp_id in logs: total_duration = timedelta() for entry_time, exit_time in zip(logs[emp_id][\\"entry\\"], logs[emp_id][\\"exit\\"]): total_duration += (exit_time - entry_time) results[emp_id] = total_duration output = [] for emp_id in first_appearance: total_seconds = int(results[emp_id].total_seconds()) hours, remainder = divmod(total_seconds, 3600) minutes = remainder // 60 output.append(f\\"{emp_id} {hours:02}:{minutes:02}\\") return output"},{"question":"def find_permuted_pairs(n: int, m: int, matrix: List[List[int]]) -> Tuple[int, List[Tuple[int, int]]]: Given a matrix filled with integers, find all pairs of rows that are permutations of each other. Args: n : int : number of rows in the matrix m : int : number of columns in the matrix matrix : List[List[int]] : the matrix of integers Returns: Tuple[int, List[Tuple[int, int]]] : a tuple where the first element is the number of pairs of rows that are permutations of each other, and the second element is the list of pairs of row indices. Example: >>> find_permuted_pairs(4, 4, [[1, 2, 3, 4], [4, 3, 2, 1], [1, 2, 4, 3], [5, 6, 7, 8]]) (3, [(1, 2), (1, 3), (2, 3)]) >>> find_permuted_pairs(3, 3, [[1, 2, 3], [3, 2, 1], [1, 2, 2]]) (1, [(1, 2)]) >>> find_permuted_pairs(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) (0, []) pass","solution":"def find_permuted_pairs(n, m, matrix): row_permutations = {} for i in range(n): sorted_row = tuple(sorted(matrix[i])) if sorted_row in row_permutations: row_permutations[sorted_row].append(i + 1) else: row_permutations[sorted_row] = [i + 1] pairs = [] for rows in row_permutations.values(): if len(rows) > 1: for i in range(len(rows)): for j in range(i + 1, len(rows)): pairs.append((rows[i], rows[j])) return len(pairs), pairs # Example usage: # n, m = 4, 4 # matrix = [ # [1, 2, 3, 4], # [4, 3, 2, 1], # [1, 2, 4, 3], # [5, 6, 7, 8] # ] # k, pairs = find_permuted_pairs(n, m, matrix) # print(k) # for pair in pairs: # print(pair[0], pair[1])"},{"question":"def nested_lists_sum(lst): Returns the cumulative sum of all integers within the nested lists. >>> nested_lists_sum([1, [2, [3, 4], [5, [6, 7]]], 8, [9]]) == 45 >>> nested_lists_sum([10, [20, 30], [[40, 50], 60], 70]) == 280 >>> nested_lists_sum([[1, 2], [3, 4], [5, [6, 7, [8, 9, [10]]]]]) == 55 >>> nested_lists_sum([[[[[1]]], 2], 3]) == 6 >>> nested_lists_sum([[], 1, [[], [2]], 3]) == 6","solution":"def nested_lists_sum(lst): Returns the cumulative sum of all integers within the nested lists. total = 0 for element in lst: if isinstance(element, list): total += nested_lists_sum(element) else: total += element return total"},{"question":"class MinHeap: def __init__(self): Initialize the MinHeap with an empty list. self.heap = [] def insert(self, x): Insert the element x into the Min-Heap. Args: x (int): The element to insert. Expected Time Complexity: O(log N) pass def extractMin(self): Remove and return the smallest element from the Min-Heap. Returns: int: The smallest element from the Min-Heap. Expected Time Complexity: O(log N) pass def decreaseKey(self, i, x): Decrease the value of the element at index i to x, maintaining the heap property. Args: i (int): The index of the element to decrease. x (int): The new value of the element. It is guaranteed that x will be smaller than or equal to the current value of the element. Expected Time Complexity: O(log N) pass def delete(self, i): Remove the element at index i from the Min-Heap. Args: i (int): The index of the element to delete. Expected Time Complexity: O(log N) pass def _heapify_up(self, i): Helper function to maintain heap property while inserting a new element. pass def _heapify_down(self, i): Helper function to maintain heap property while extracting the minimum element. pass import pytest def test_insert_and_extractMin(): min_heap = MinHeap() min_heap.insert(3) min_heap.insert(2) min_heap.insert(1) assert min_heap.extractMin() == 1 assert min_heap.extractMin() == 2 assert min_heap.extractMin() == 3 def test_decreaseKey(): min_heap = MinHeap() min_heap.insert(9) min_heap.insert(5) min_heap.insert(6) min_heap.insert(2) min_heap.insert(3) min_heap.decreaseKey(2, 1) # change 6 to 1 assert min_heap.extractMin() == 1 def test_delete(): min_heap = MinHeap() min_heap.insert(4) min_heap.insert(5) min_heap.insert(6) min_heap.insert(7) min_heap.insert(8) min_heap.delete(2) # remove element at index 2 (6) assert min_heap.extractMin() == 4 assert min_heap.extractMin() == 5 assert min_heap.extractMin() == 7 assert min_heap.extractMin() == 8 def test_mixed_operations(): min_heap = MinHeap() min_heap.insert(15) min_heap.insert(5) min_heap.insert(6) min_heap.insert(2) min_heap.insert(3) min_heap.decreaseKey(4, 1) # change 3 to 1 assert min_heap.extractMin() == 1 min_heap.delete(1) # remove element at index 1 (5) assert min_heap.extractMin() == 2 assert min_heap.extractMin() == 6 assert min_heap.extractMin() == 15 if __name__ == \\"__main__\\": pytest.main()","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, x): self.heap.append(x) self._heapify_up(len(self.heap) - 1) def extractMin(self): if len(self.heap) == 0: return None if len(self.heap) == 1: return self.heap.pop() root = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return root def decreaseKey(self, i, x): self.heap[i] = x self._heapify_up(i) def delete(self, i): self.decreaseKey(i, float('-inf')) self.extractMin() def _heapify_up(self, i): parent = (i - 1) // 2 if i > 0 and self.heap[i] < self.heap[parent]: self.heap[i], self.heap[parent] = self.heap[parent], self.heap[i] self._heapify_up(parent) def _heapify_down(self, i): smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < len(self.heap) and self.heap[left] < self.heap[smallest]: smallest = left if right < len(self.heap) and self.heap[right] < self.heap[smallest]: smallest = right if smallest != i: self.heap[i], self.heap[smallest] = self.heap[smallest], self.heap[i] self._heapify_down(smallest)"},{"question":"import math from typing import List, Tuple def calculate_distance(tower1: Tuple[int, int], tower2: Tuple[int, int]) -> float: Function to calculate the Euclidean distance between two towers. >>> calculate_distance((0, 0), (0, 2)) 2.0 >>> calculate_distance((0, 0), (3, 4)) 5.0 >>> calculate_distance((2, 2), (5, 6)) 5.0 def min_max_distance(tower_coords: List[Tuple[int, int]]) -> float: Function to find the minimum value of the maximum distance required for every pair of towers to be able to communicate directly or indirectly. >>> min_max_distance([(0, 0), (0, 2), (2, 0), (2, 2)]) 2.0 >>> min_max_distance([(0, 0), (3, 4), (6, 0)]) 5.0","solution":"import math def calculate_distance(tower1, tower2): Function to calculate the Euclidean distance between two towers. return math.sqrt((tower1[0] - tower2[0]) ** 2 + (tower1[1] - tower2[1]) ** 2) def min_max_distance(tower_coords): Function to find the minimum value of the maximum distance required for every pair of towers to be able to communicate directly or indirectly. n = len(tower_coords) distances = [[calculate_distance(tower_coords[i], tower_coords[j]) for j in range(n)] for i in range(n)] # Prim's algorithm to find the Maximum Spanning Tree distance max_distance = 0 selected = [False] * n min_edge = [float('inf')] * n min_edge[0] = 0 for _ in range(n): u = -1 for i in range(n): if not selected[i] and (u == -1 or min_edge[i] < min_edge[u]): u = i if min_edge[u] == float('inf'): return float('inf') selected[u] = True max_distance = max(max_distance, min_edge[u]) for v in range(n): if distances[u][v] < min_edge[v] and not selected[v]: min_edge[v] = distances[u][v] return max_distance def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) tower_coords = [] index = 1 for _ in range(n): x = int(data[index]) y = int(data[index+1]) tower_coords.append((x, y)) index += 2 result = min_max_distance(tower_coords) print(int(result))"},{"question":"def count_visible_steps(buildings): Returns the number of visible 'steps' in the city's skyline. Parameters: buildings (list of ints): Heights of buildings in the city Returns: int: Number of visible steps >>> count_visible_steps([3, 1, 4, 1, 5, 9]) 4 >>> count_visible_steps([1, 2, 3, 4, 5, 6, 7, 8, 9]) 9 >>> count_visible_steps([9, 8, 7, 6, 5, 4, 3, 2, 1]) 1 >>> count_visible_steps([1, 1, 2, 2, 3, 1, 4, 0, 5]) 5 >>> count_visible_steps([5]) 1 >>> count_visible_steps([]) 0 >>> count_visible_steps([3, 3, 3, 3]) 1","solution":"def count_visible_steps(buildings): Returns the number of visible 'steps' in the city's skyline. Parameters: buildings (list of ints): Heights of buildings in the city Returns: int: Number of visible steps if not buildings: return 0 count = 0 max_height = 0 for height in buildings: if height > max_height: count += 1 max_height = height return count"},{"question":"def find_min_index(nums): Function to find the index of the minimum element in a rotated sorted array. >>> find_min_index([4, 5, 1, 2, 3]) 2 >>> find_min_index([3, 4, 5, 6, 7, 1, 2]) 5 >>> find_min_index([2, 3, 1]) 2 pass def process_test_cases(T, test_cases): Function to process multiple test cases and return the results. >>> T = 3 >>> test_cases = [ ... (5, [4, 5, 1, 2, 3]), ... (7, [3, 4, 5, 6, 7, 1, 2]), ... (3, [2, 3, 1]) ... ] >>> process_test_cases(T, test_cases) [2, 5, 2] pass","solution":"def find_min_index(nums): Function to find the index of the minimum element in a rotated sorted array. left, right = 0, len(nums) - 1 # Handle edge cases where the array is not rotated. if nums[left] < nums[right]: return left while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: left = mid + 1 else: right = mid return left def process_test_cases(T, test_cases): results = [] for i in range(T): N, array = test_cases[i] results.append(find_min_index(array)) return results"},{"question":"def decode_string(encoded_str: str) -> str: Decode the given encoded string where encoding is defined using the rule: The string is composed of substrings of the form \`k[encoded_string]\`, where the \`encoded_string\` inside the square brackets is repeated exactly \`k\` times. You may assume that \`k\` is a positive integer and that the input string is always valid. >>> decode_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" >>> decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" >>> decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\"","solution":"def decode_string(encoded_str: str) -> str: stack = [] current_num = 0 current_str = '' for char in encoded_str: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == '[': stack.append((current_str, current_num)) current_str = '' current_num = 0 elif char == ']': last_str, num = stack.pop() current_str = last_str + current_str * num else: current_str += char return current_str"},{"question":"def generate_permutations(nums): Generate all permutations of the given list of unique integers. >>> generate_permutations([1]) [[1]] >>> generate_permutations([1, 2]) [[1, 2], [2, 1]] >>> generate_permutations([1, 2, 3]) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> generate_permutations([1, 2, 3, 4]) [[1, 2, 3, 4], [1, 2, 4, 3], [1, 3, 2, 4], [1, 3, 4, 2], [1, 4, 2, 3], [1, 4, 3, 2], [2, 1, 3, 4], [2, 1, 4, 3], [2, 3, 1, 4], [2, 3, 4, 1], [2, 4, 1, 3], [2, 4, 3, 1], [3, 1, 2, 4], [3, 1, 4, 2], [3, 2, 1, 4], [3, 2, 4, 1], [3, 4, 1, 2], [3, 4, 2, 1], [4, 1, 2, 3], [4, 1, 3, 2], [4, 2, 1, 3], [4, 2, 3, 1], [4, 3, 1, 2], [4, 3, 2, 1]] >>> len(generate_permutations([1, 2, 3, 4, 5, 6])) 720 Args: nums (List[int]): A list of unique integers. Returns: List[List[int]]: A list containing all permutations of nums.","solution":"def generate_permutations(nums): Generate all permutations of the given list of unique integers. Args: nums (List[int]): A list of unique integers. Returns: List[List[int]]: A list containing all permutations of nums. def backtrack(start): # If the entire list is processed: if start == len(nums): result.append(nums[:]) for i in range(start, len(nums)): # Swap nums[start] with nums[i] nums[start], nums[i] = nums[i], nums[start] # Recursively generate permutations for the next part of the list: backtrack(start + 1) # Swap back to restore the original list state nums[start], nums[i] = nums[i], nums[start] result = [] backtrack(0) return result"},{"question":"def fill_snake_matrix(n, m, identifiers): Fills an n by m matrix in a snake-like pattern using the provided identifiers. Parameters: n (int): The number of rows. m (int): The number of columns. identifiers (list): A list of unique integers to fill the matrix. Returns: list: A 2D list representing the matrix filled in the snake-like pattern. pass # Unit Test: def test_fill_snake_matrix_example(): n, m = 3, 4 identifiers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] expected_output = [ [1, 2, 3, 4], [8, 7, 6, 5], [9, 10, 11, 12] ] assert fill_snake_matrix(n, m, identifiers) == expected_output def test_fill_snake_matrix_single_row(): n, m = 1, 4 identifiers = [1, 2, 3, 4] expected_output = [ [1, 2, 3, 4] ] assert fill_snake_matrix(n, m, identifiers) == expected_output def test_fill_snake_matrix_single_column(): n, m = 4, 1 identifiers = [1, 2, 3, 4] expected_output = [ [1], [2], [3], [4] ] assert fill_snake_matrix(n, m, identifiers) == expected_output def test_fill_snake_matrix_even_rows(): n, m = 2, 3 identifiers = [1, 2, 3, 4, 5, 6] expected_output = [ [1, 2, 3], [6, 5, 4] ] assert fill_snake_matrix(n, m, identifiers) == expected_output def test_fill_snake_matrix_large(): n, m = 3, 3 identifiers = [i for i in range(1, 10)] expected_output = [ [1, 2, 3], [6, 5, 4], [7, 8, 9] ] assert fill_snake_matrix(n, m, identifiers) == expected_output","solution":"def fill_snake_matrix(n, m, identifiers): Fills an n by m matrix in a snake-like pattern using the provided identifiers. Parameters: n (int): The number of rows. m (int): The number of columns. identifiers (list): A list of unique integers to fill the matrix. Returns: list: A 2D list representing the matrix filled in the snake-like pattern. matrix = [] idx = 0 for i in range(n): row = [] for j in range(m): row.append(identifiers[idx]) idx += 1 if i % 2 == 1: row.reverse() matrix.append(row) return matrix"},{"question":"from typing import List def find_min_absolute_difference(n: int, array: List[int]) -> int: This function takes the number of elements in the array and the array itself, and returns the minimum absolute difference between the sum of two non-empty partitions of the array. >>> find_min_absolute_difference(4, [3, 1, 4, 2]) 0 >>> find_min_absolute_difference(5, [1, 2, 3, 4, 5]) 1 >>> find_min_absolute_difference(2, [1, 1]) 0 >>> find_min_absolute_difference(3, [1, 1, 1000]) 998 >>> find_min_absolute_difference(6, [5, 5, 5, 5, 5, 5]) 0 >>> find_min_absolute_difference(8, [10, 20, 15, 25, 30, 10, 50, 10]) 0","solution":"def min_diff_partition(arr): This function takes a list of integers and returns the minimum absolute difference between the sum of two non-empty partitions of the array. total_sum = sum(arr) n = len(arr) # To find the subset with sum closest to total_sum / 2 dp = [0] * (total_sum // 2 + 1) for num in arr: for j in range(total_sum // 2, num - 1, -1): dp[j] = max(dp[j], dp[j - num] + num) sum1 = dp[-1] sum2 = total_sum - sum1 return abs(sum1 - sum2) def find_min_absolute_difference(n, array): return min_diff_partition(array)"},{"question":"def maximum_span_of_control(n: int, relations: List[Tuple[int, int]]) -> int: Determine the maximum span of control in the company. An employee's span of control is defined as the number of employees they supervise, directly or indirectly. Args: n : int : the number of employees. relations: List[Tuple[int, int]] : a list of tuples where each tuple consists of two integers representing a direct parent-child relationship (a, b), where employee b is a direct child of employee a. Returns: int : the maximum span of control among all employees. Example: >>> maximum_span_of_control(6, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) 5 >>> maximum_span_of_control(1, []) 0 >>> maximum_span_of_control(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 4 from solution import maximum_span_of_control def test_max_span_single_employee(): assert maximum_span_of_control(1, []) == 0 def test_max_span_linear_hierarchy(): assert maximum_span_of_control(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 4 def test_max_span_balanced_tree(): assert maximum_span_of_control(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) == 6 def test_max_span_unbalanced_tree(): assert maximum_span_of_control(5, [(1, 2), (1, 3), (2, 4), (4, 5)]) == 4 def test_max_span_complex_tree(): assert maximum_span_of_control(10, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7), (7, 8), (7, 9), (9, 10)]) == 9","solution":"def maximum_span_of_control(n, relations): from collections import defaultdict, deque # Build the graph tree = defaultdict(list) for parent, child in relations: tree[parent].append(child) # Function for DFS traversal to count the span of control def dfs(node): # Span is initially zero for each node span = 0 stack = [node] visited = set() while stack: current = stack.pop() if current not in visited: visited.add(current) span += 1 # Count this node stack.extend(tree[current]) return span - 1 # Subtract 1 to not count the CEO himself # Start DFS from the root (CEO) max_span = 0 for employee in range(1, n + 1): max_span = max(max_span, dfs(employee)) return max_span # Example usage: # print(maximum_span_of_control(6, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)])) # Output: 5"},{"question":"def recommend_courses(courses: List[Tuple[str, List[str]]], mastered_topics: Set[str]) -> List[str]: Given a list of courses with their respective prerequisites and a list of topics a student has mastered, returns a list of courses that the student is eligible to take. Parameters: courses (list): A list of tuples where each tuple contains a course name and a list of its prerequisite topics. mastered_topics (set): A set of topics the student has mastered. Returns: list: A list of course names that the student is eligible to take. pass # Testing the recommend_courses function def test_recommend_single_course_no_prereqs(): courses = [(\\"Course1\\", [])] mastered_topics = set() assert recommend_courses(courses, mastered_topics) == [\\"Course1\\"] def test_recommend_courses_with_single_prerequisite(): courses = [(\\"Course1\\", [\\"TopicA\\"]), (\\"Course2\\", [\\"TopicB\\"])] mastered_topics = {\\"TopicA\\"} assert recommend_courses(courses, mastered_topics) == [\\"Course1\\"] def test_recommend_courses_with_multiple_prerequisites(): courses = [(\\"Course1\\", [\\"TopicA\\", \\"TopicB\\"]), (\\"Course2\\", [\\"TopicB\\", \\"TopicC\\"])] mastered_topics = {\\"TopicA\\", \\"TopicB\\", \\"TopicC\\"} assert recommend_courses(courses, mastered_topics) == [\\"Course1\\", \\"Course2\\"] def test_recommend_courses_some_unmatched_prerequisites(): courses = [(\\"Course1\\", [\\"TopicA\\", \\"TopicB\\"]), (\\"Course2\\", [\\"TopicB\\", \\"TopicC\\"]), (\\"Course3\\", [\\"TopicD\\"])] mastered_topics = {\\"TopicA\\", \\"TopicB\\"} assert recommend_courses(courses, mastered_topics) == [\\"Course1\\"] def test_recommend_courses_empty_result(): courses = [(\\"Course1\\", [\\"TopicA\\", \\"TopicB\\"]), (\\"Course2\\", [\\"TopicB\\", \\"TopicC\\"])] mastered_topics = {\\"TopicD\\"} assert recommend_courses(courses, mastered_topics) == [] def test_recommend_courses_with_no_mastered_topics(): courses = [(\\"Course1\\", [\\"TopicA\\", \\"TopicB\\"]), (\\"Course2\\", [\\"TopicB\\", \\"TopicC\\"])] mastered_topics = set() assert recommend_courses(courses, mastered_topics) == []","solution":"def recommend_courses(courses, mastered_topics): Given a list of courses with their respective prerequisites and a list of topics a student has mastered, returns a list of courses that the student is eligible to take. Parameters: courses (list): A list of tuples where each tuple contains a course name and a list of its prerequisite topics. mastered_topics (set): A set of topics the student has mastered. Returns: list: A list of course names that the student is eligible to take. eligible_courses = [] for course, prerequisites in courses: if all(prereq in mastered_topics for prereq in prerequisites): eligible_courses.append(course) return eligible_courses if __name__ == \\"__main__\\": n = int(input().strip()) courses = [] for _ in range(n): course_info = input().strip().split() course_name = course_info[0] prerequisites = course_info[1:] courses.append((course_name, prerequisites)) m = int(input().strip()) mastered_topics = set(input().strip().split()) eligible_courses = recommend_courses(courses, mastered_topics) for course in eligible_courses: print(course)"},{"question":"def is_perfect_number(n: int) -> bool: Determines whether a given positive integer is a perfect number. A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself. :param n: int - The number to check for being a perfect number. :return: bool - True if n is a perfect number, False otherwise. Example: >>> is_perfect_number(28) True >>> is_perfect_number(10) False def test_is_perfect_number_6(): assert is_perfect_number(6) == True def test_is_perfect_number_28(): assert is_perfect_number(28) == True def test_is_perfect_number_496(): assert is_perfect_number(496) == True def test_is_perfect_number_non_perfect_small(): assert is_perfect_number(10) == False def test_is_perfect_number_non_perfect_large(): assert is_perfect_number(100) == False def test_is_perfect_number_min_value(): assert is_perfect_number(1) == False def test_is_perfect_number_prime(): assert is_perfect_number(7) == False def test_is_perfect_number_2(): assert is_perfect_number(2) == False def test_is_perfect_number_8128(): assert is_perfect_number(8128) == True","solution":"def is_perfect_number(n: int) -> bool: Determines whether a given positive integer is a perfect number. A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself. :param n: int - The number to check for being a perfect number. :return: bool - True if n is a perfect number, False otherwise. if n < 2: return False sum_of_divisors = 1 for i in range(2, int(n**0.5) + 1): if n % i == 0: sum_of_divisors += i if i != n // i: sum_of_divisors += n // i return sum_of_divisors == n"},{"question":"def marathon_completion_percentage(N, L, D): Calculate the total percentage of the marathon the runner has completed. :param N: int - Total number of laps to be completed :param L: int - Distance of each lap in meters :param D: int - Actual distance run by the runner in meters :return: float - Percentage of completed marathon rounded to two decimal places >>> marathon_completion_percentage(10, 400, 4000) 100.00 >>> marathon_completion_percentage(10, 400, 3500) 87.50 >>> marathon_completion_percentage(10, 400, 0) 0.00 >>> marathon_completion_percentage(5, 200, 500) 50.00 >>> marathon_completion_percentage(7, 300, 1250) 59.52 >>> marathon_completion_percentage(10000, 1000, 10000000) 100.00 >>> marathon_completion_percentage(1, 1, 0) 0.00","solution":"def marathon_completion_percentage(N, L, D): Calculate the total percentage of the marathon the runner has completed. :param N: int - Total number of laps to be completed :param L: int - Distance of each lap in meters :param D: int - Actual distance run by the runner in meters :return: float - Percentage of completed marathon rounded to two decimal places total_distance = N * L percentage = (D / total_distance) * 100 return round(percentage, 2)"},{"question":"def product_of_all_except_self(arr): Returns a new array where each element is the product of all other elements except for the current one. :param arr: List[int] - input array of integers :return: List[int] - an array where each element is the product of all other elements in the input array >>> product_of_all_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_of_all_except_self([2, 3]) [3, 2] >>> product_of_all_except_self([5]) [1] >>> product_of_all_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_of_all_except_self([3, 3, 3]) [9, 9, 9] >>> product_of_all_except_self([]) []","solution":"def product_of_all_except_self(arr): Returns a new array where each element is the product of all other elements except for the current one. :param arr: List[int] - input array of integers :return: List[int] - an array where each element is the product of all other elements in the input array n = len(arr) if n == 0: return [] # Initialize the output array with ones output = [1] * n # Initialize cumulative product from the left left_product = 1 for i in range(n): output[i] = left_product left_product *= arr[i] # Initialize cumulative product from the right right_product = 1 for i in reversed(range(n)): output[i] *= right_product right_product *= arr[i] return output"},{"question":"def count_ways(n: int, m: int, coins: List[int]) -> int: Returns the number of distinct ways to make up the target amount n using the given denominations. Args: n: int - Target amount to be made up. m: int - Number of different coin denominations. coins: List[int] - List of coin denominations. Returns: int - Number of distinct ways to make up the target amount. Examples: >>> count_ways(10, 2, [1, 2]) 6 >>> count_ways(3, 3, [2, 5, 3]) 1","solution":"def count_ways(n, m, coins): Returns the number of distinct ways to make up the target amount n using the given denominations. # Initialize a list to store the number of ways to make change for each amount dp = [0] * (n + 1) # There is one way to make change for 0 amount (i.e., use no coins) dp[0] = 1 # Iterate through each coin and update the dp array for coin in coins: for x in range(coin, n + 1): dp[x] += dp[x - coin] return dp[n] # Example usage: # n, m = 10, 2 # coins = [1, 2] # print(count_ways(n, m, coins)) # Output: 6"},{"question":"from typing import List def min_teams(N: int, T: int, skills: List[int]) -> int: Returns the minimum number of teams required such that each team's combined skill level does not exceed T. Args: N : int : Number of employees T : int : Target skill level for each team skills : list : List of integers denoting skill levels of employees Returns: int : Minimum number of teams required >>> min_teams(6, 10, [2, 3, 7, 1, 8, 4]) 3 >>> min_teams(5, 5, [1, 1, 1, 1, 1]) 1 >>> min_teams(1, 10, [10]) 1 >>> min_teams(5, 10, [10, 10, 10, 10, 10]) 5 >>> min_teams(5, 100, [20, 30, 40, 50, 60]) 3","solution":"from collections import deque def min_teams(N, T, skills): Returns the minimum number of teams required such that each team's combined skill level does not exceed T. Args: N : int : Number of employees T : int : Target skill level for each team skills : list : List of integers denoting skill levels of employees Returns: int : Minimum number of teams required # Sort the skills in descending order skills.sort(reverse=True) teams = 0 skills = deque(skills) while skills: teams += 1 current_team_skill = skills.popleft() # Try to add the least skillful member available without exceeding T while skills and current_team_skill + skills[-1] <= T: current_team_skill += skills.pop() return teams"},{"question":"from typing import List def can_partition(nums: List[int]) -> bool: Determine if it is possible to partition the list into two subsets such that the sum of the elements in both subsets is the same. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False # Unit Tests def test_can_partition_true(): assert can_partition([1, 5, 11, 5]) == True def test_can_partition_false(): assert can_partition([1, 2, 3, 5]) == False def test_can_partition_small_positive(): assert can_partition([1, 1]) == True def test_can_partition_all_same_false(): assert can_partition([1, 1, 1]) == False def test_can_partition_all_same_true(): assert can_partition([3, 3, 3, 3]) == True def test_can_partition_large_input_false(): nums = [1000] * 99 + [999] assert can_partition(nums) == False def test_can_partition_large_input_true(): nums = [1] * 100 assert can_partition(nums) == True","solution":"from typing import List def can_partition(nums: List[int]) -> bool: total = sum(nums) # If the total sum is odd, it can't be partitioned into two equal subsets if total % 2 != 0: return False target = total // 2 n = len(nums) # Create a DP array where dp[i] means that a subset sum of 'i' is possible dp = [False] * (target + 1) dp[0] = True # There is always a subset with sum 0 (empty subset) for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"def two_sum(nums, target): Returns a tuple of two distinct indices (i, j) such that nums[i] + nums[j] == target. If no such indices exist, returns None. >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([1, 2, 3, 4], 10) None >>> result = two_sum([3, 2, 4, 3], 6) >>> result == (0, 3) or result == (1, 2) True >>> two_sum([-1, -2, -3, -4, -5], -8) (2, 4) >>> two_sum([0, 4, 3, 0], 0) (0, 3) >>> two_sum([], 0) None","solution":"def two_sum(nums, target): Returns a tuple of two distinct indices (i, j) such that nums[i] + nums[j] == target. If no such indices exist, returns None. hash_map = {} # To store value to index mapping. for i, num in enumerate(nums): complement = target - num if complement in hash_map: return (hash_map[complement], i) hash_map[num] = i return None"},{"question":"def check_pair_sum(array, target): This function returns 1 if there exists a pair of elements in the sorted array that sum up to the target value, otherwise returns 0. >>> check_pair_sum([1, 2, 3, 4, 6], 5) 1 >>> check_pair_sum([1, 2, 3, 9], 8) 0 >>> check_pair_sum([], 3) 0 >>> check_pair_sum([10], 10) 0 >>> check_pair_sum([1, 2, 3, 7, 9], 20) 0 >>> check_pair_sum([1, 2, 3, 4, 5, 6], 7) 1 >>> check_pair_sum([-4, -2, 0, 1, 3], -1) 1 >>> check_pair_sum([-10, -6, -3, 1, 2, 7, 9], 3) 1 >>> check_pair_sum([-100000, -50000, 0, 50000, 100000], 0) 1","solution":"def check_pair_sum(array, target): This function returns 1 if there exists a pair of elements in the sorted array that sum up to the target value, otherwise returns 0. left = 0 right = len(array) - 1 while left < right: current_sum = array[left] + array[right] if current_sum == target: return 1 elif current_sum < target: left += 1 else: right -= 1 return 0"},{"question":"def min_energy_to_exit(N, M, E, maze): Calculate the minimum energy required for Alice to reach the exit point in the maze. Args: N (int): Number of rows in the maze. M (int): Number of columns in the maze. E (int): Initial energy Alice has. maze (List[str]): The maze grid with 'S', 'E', '.', and '#'. Returns: int: Minimum energy required to reach the exit, or -1 if not possible with the given energy. Example: >>> min_energy_to_exit(4, 4, 10, [\\"S..#\\", \\".#.#\\", \\".#.E\\", \\"....\\"]) 5 >>> min_energy_to_exit(3, 3, 2, [\\"S#.\\", \\".#E\\", \\"#\\"]) -1 def solve(maze_input): Solve the maze problem described by the given input. Args: maze_input (List[str]): List of strings describing the maze input, with the first string containing N, M, and E, followed by the rows of the maze grid. Example: >>> solve([\\"4 4 10\\", \\"S..#\\", \\".#.#\\", \\".#.E\\", \\"....\\"]) 5 >>> solve([\\"3 3 2\\", \\"S#.\\", \\".#E\\", \\"#\\"]) -1 def test_case_1(): maze_input = [ \\"4 4 10\\", \\"S..#\\", \\".#.#\\", \\".#.E\\", \\"....\\" ] solve(maze_input) def test_case_2(): maze_input = [ \\"3 3 2\\", \\"S#.\\", \\".#E\\", \\"#\\" ] solve(maze_input) def test_case_3(): maze_input = [ \\"5 5 20\\", \\"S....\\", \\"..#\\", \\"...\\", \\".....\\", \\"....E\\" ] solve(maze_input) def test_case_4(): maze_input = [ \\"2 2 1\\", \\"S#\\", \\"#E\\" ] solve(maze_input) def test_case_5(): maze_input = [ \\"3 3 5\\", \\"S#E\\", \\"#\\", \\"E\\" ] solve(maze_input) # Run the test cases test_case_1() # Expected Output: 5 test_case_2() # Expected Output: -1 test_case_3() # Expected Output: 8 test_case_4() # Expected Output: -1 test_case_5() # Expected Output: -1","solution":"from collections import deque def min_energy_to_exit(N, M, E, maze): def is_within_bounds(x, y): return 0 <= x < N and 0 <= y < M # Locate the start (S) and end (E) points start = end = None for i in range(N): for j in range(M): if maze[i][j] == 'S': start = (i, j) elif maze[i][j] == 'E': end = (i, j) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right # BFS initialization queue = deque([(start[0], start[1], 0)]) # (row, col, current_energy) visited = set() visited.add((start[0], start[1])) while queue: x, y, current_energy = queue.popleft() # If we reach the end point if (x, y) == end: return current_energy # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if is_within_bounds(nx, ny) and (nx, ny) not in visited and maze[nx][ny] != '#': queue.append((nx, ny, current_energy + 1)) visited.add((nx, ny)) # If the exit is not reachable return -1 def solve(maze_input): N, M, E = map(int, maze_input[0].split()) maze = maze_input[1:] min_energy_required = min_energy_to_exit(N, M, E, maze) if min_energy_required == -1 or min_energy_required > E: print(-1) else: print(min_energy_required)"},{"question":"from typing import List def min_stores(matrix: List[List[int]], requirements: List[int]) -> int: Given a 2D matrix representing the availability of items in various stores, and a requirement list specifying the quantity of each type of item needed, find the minimum number of stores that must be visited to fulfill the requirement list. If the task cannot be accomplished, return -1. >>> min_stores([[2, 0, 1], [1, 3, 1], [0, 3, 4]], [1, 4, 2]) 2 >>> min_stores([[2, 1, 1], [0, 0, 2], [3, 1, 1]], [3, 1, 1]) 1 >>> min_stores([[0, 1], [1, 0]], [1, 1]) 2 >>> min_stores([[1, 0], [1, 0]], [4, 1]) -1 def test_example_0(): matrix = [ [2, 0, 1], [1, 3, 1], [0, 3, 4] ] requirements = [1, 4, 2] assert min_stores(matrix, requirements) == 2 def test_example_1(): matrix = [ [2, 1, 1], [0, 0, 2], [3, 1, 1] ] requirements = [3, 1, 1] assert min_stores(matrix, requirements) == 1 def test_example_2(): matrix = [ [0, 1], [1, 0] ] requirements = [1, 1] assert min_stores(matrix, requirements) == 2 def test_example_3(): matrix = [ [1, 0], [1, 0] ] requirements = [4, 1] assert min_stores(matrix, requirements) == -1 def test_large_matrix(): matrix = [ [2, 0, 0], [0, 2, 0], [0, 0, 2], [1, 1, 1] ] requirements = [2, 2, 2] assert min_stores(matrix, requirements) == 3 def test_exact_requirements(): matrix = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] requirements = [2, 2, 2] assert min_stores(matrix, requirements) == 2 def test_single_store(): matrix = [ [3, 3, 3] ] requirements = [2, 2, 2] assert min_stores(matrix, requirements) == 1 def test_unreachable_requirements(): matrix = [ [1, 2, 3], [1, 2, 3], [1, 2, 3] ] requirements = [10, 10, 10] assert min_stores(matrix, requirements) == -1","solution":"from itertools import combinations def can_fulfill_requirements(matrix, requirements, selected_stores): item_count = [0] * len(requirements) for store in selected_stores: for j in range(len(requirements)): item_count[j] += matrix[store][j] for i in range(len(requirements)): if item_count[i] < requirements[i]: return False return True def min_stores(matrix, requirements): n = len(matrix) min_store_count = float('inf') for r in range(1, n + 1): for selected_stores in combinations(range(n), r): if can_fulfill_requirements(matrix, requirements, selected_stores): min_store_count = min(min_store_count, r) break return min_store_count if min_store_count != float('inf') else -1"},{"question":"def longest_consecutive_sequence(nums): Given a list of integers, returns the length of the longest consecutive elements sequence. Args: nums: List[int] - list of integers to check for longest consecutive sequence Returns: int - length of the longest consecutive elements sequence Examples: >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2, 5]) 5 >>> longest_consecutive_sequence([10, 100, 1000]) 1 >>> longest_consecutive_sequence([-1, -2, -3, -4]) 4 from solution import longest_consecutive_sequence def test_example_case(): assert longest_consecutive_sequence([100, 4, 200, 1, 3, 2, 5]) == 5 def test_empty_list(): assert longest_consecutive_sequence([]) == 0 def test_no_consecutive_sequence(): assert longest_consecutive_sequence([10, 100, 1000]) == 1 def test_all_negative(): assert longest_consecutive_sequence([-1, -2, -3, -4]) == 4 def test_mixed_numbers(): assert longest_consecutive_sequence([10, 1, 3, -2, 4, -1, 2, 0, 5, -3]) == 9 def test_single_element(): assert longest_consecutive_sequence([42]) == 1 def test_large_spread(): assert longest_consecutive_sequence([0, -1, -2, -3, -4, -5, -10**5, 10**5]) == 6","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive elements sequence. if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums: if num - 1 not in nums_set: # Only check for the start of a sequence current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from typing import List, Tuple def smallest_sum(arr: List[int]) -> int: Determine the smallest possible sum of the array when only one element remains. Args: arr (List[int]): The initial array of positive integers. Returns: int: The smallest possible sum of the array. Examples: >>> smallest_sum([4, 1, 3]) 8 >>> smallest_sum([1, 2, 3, 4]) 10 def solve_smallest_sum(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases to determine the smallest possible sums. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of test cases with the size of the array and the array itself. Returns: List[int]: List of the smallest sums for each test case. Examples: >>> solve_smallest_sum(2, [(3, [4, 1, 3]), (4, [1, 2, 3, 4])]) [8, 10] >>> solve_smallest_sum(1, [(3, [1, 1, 1])]) [3]","solution":"def smallest_sum(arr): if not arr: return 0 # Sorting the initial array gives us the minimum possible sum arr.sort() while len(arr) > 1: # Combine the first two elements (smallest two elements) new_val = arr.pop(0) + arr.pop(0) # Append the sum back into the list arr.append(new_val) # Maintain sorted order arr.sort() return arr[0] def solve_smallest_sum(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] arr = test_cases[i][1] results.append(smallest_sum(arr)) return results"},{"question":"def minPathSum(grid): Returns the minimum path sum from top-left to bottom-right of the grid. Params: grid (List[List[int]]): 2D list containing non-negative integers representing the number of boxes in each cell. Returns: int: Minimum path sum. def test_minPathSum_example1(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert minPathSum(grid) == 7 def test_minPathSum_example2(): grid = [ [1, 2, 3], [4, 5, 6] ] assert minPathSum(grid) == 12 def test_minPathSum_single_element(): assert minPathSum([[0]]) == 0 assert minPathSum([[1]]) == 1 def test_minPathSum_single_row(): grid = [ [1, 2, 3] ] assert minPathSum(grid) == 6 def test_minPathSum_single_column(): grid = [ [1], [2], [3] ] assert minPathSum(grid) == 6 def test_minPathSum_zeros(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert minPathSum(grid) == 0 def test_minPathSum_large_values(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert minPathSum(grid) == 21","solution":"def minPathSum(grid): Returns the minimum path sum from top-left to bottom-right of the grid. Params: grid (List[List[int]]): 2D list containing non-negative integers representing the number of boxes in each cell. Returns: int: Minimum path sum. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Initialize the first row for col in range(1, cols): grid[0][col] += grid[0][col - 1] # Initialize the first column for row in range(1, rows): grid[row][0] += grid[row - 1][0] # Fill in the rest of the grid for row in range(1, rows): for col in range(1, cols): grid[row][col] += min(grid[row - 1][col], grid[row][col - 1]) return grid[rows - 1][cols - 1]"},{"question":"def findPairs(amounts, M, T): Identify all unique pairs of friends who can be helped together if the sum of their required amounts exactly matches a given target amount T. amounts: List[int] - The list of amounts required by each friend. M: int - The number of friends. T: int - The target sum for the wealthy donor's support. Return: List[Tuple[int, int]] - List of unique pairs where each tuple consists of two integers representing the amount each of the two friends required. >>> findPairs([40, 60, 10, 90, 50], 5, 100) [(10, 90), (40, 60)] >>> findPairs([5, 45, 20, 25, 30], 5, 50) [(5, 45), (20, 30)] >>> findPairs([10, 20, 30, 40], 4, 100) [] >>> findPairs([0, 0, 0, 0], 4, 0) [(0, 0)] >>> findPairs([40, 60, 60, 60, 40, 50], 6, 100) [(40, 60)]","solution":"def findPairs(amounts, M, T): Returns a list of tuples where each tuple consists of two integers representing the amounts that sum up to the target T. # List to store the result pairs result = [] # Sorting the amounts array amounts.sort() # Two pointers approach left = 0 right = M - 1 while left < right: current_sum = amounts[left] + amounts[right] if current_sum == T: result.append((amounts[left], amounts[right])) left += 1 right -= 1 elif current_sum < T: left += 1 else: right -= 1 return result"},{"question":"def river_crossing(): This function returns the sequence of steps to safely get the farmer, wolf, goat, and cabbage across the river. It represents each step as a tuple, with the item taken and the resulting state on both sides of the river. >>> river_crossing() [ (\\"goat\\", [\\"farmer\\", \\"wolf\\", \\"cabbage\\"], [\\"goat\\"]), (\\"farmer\\", [\\"wolf\\", \\"cabbage\\"], [\\"farmer\\", \\"goat\\"]), (\\"wolf\\", [\\"farmer\\", \\"cabbage\\"], [\\"wolf\\", \\"goat\\"]), (\\"goat\\", [\\"cabbage\\"], [\\"farmer\\", \\"wolf\\"], [\\"goat\\"]), (\\"cabbage\\", [\\"farmer\\", \\"goat\\"], [\\"cabbage\\", \\"wolf\\"]), (\\"farmer\\", [\\"goat\\"], [\\"farmer\\", \\"wolf\\", \\"cabbage\\"]), (\\"goat\\", [], [\\"farmer\\", \\"wolf\\", \\"cabbage\\", \\"goat\\"]), ]","solution":"def river_crossing(): This function returns the sequence of steps to safely get the farmer, wolf, goat, and cabbage across the river. It represents each step as a tuple, with the item taken and the resulting state on both sides of the river. steps = [ (\\"goat\\", [\\"farmer\\", \\"wolf\\", \\"cabbage\\"], [\\"goat\\"]), # Farmer takes goat to the right bank (\\"farmer\\", [\\"wolf\\", \\"cabbage\\"], [\\"farmer\\", \\"goat\\"]), # Farmer returns alone to the left bank (\\"wolf\\", [\\"farmer\\", \\"cabbage\\"], [\\"wolf\\", \\"goat\\"]), # Farmer takes wolf to the right bank (\\"goat\\", [\\"cabbage\\"], [\\"farmer\\", \\"wolf\\"], [\\"goat\\"]), # Farmer returns with goat to the left bank (\\"cabbage\\", [\\"farmer\\", \\"goat\\"], [\\"cabbage\\", \\"wolf\\"]), # Farmer takes cabbage to the right bank (\\"farmer\\", [\\"goat\\"], [\\"farmer\\", \\"wolf\\", \\"cabbage\\"]), # Farmer returns alone to the left bank (\\"goat\\", [], [\\"farmer\\", \\"wolf\\", \\"cabbage\\", \\"goat\\"]), # Farmer takes goat to the right bank ] return steps"},{"question":"def sumOfSubmatrix(matrix, r1, c1, r2, c2): Returns the sum of all elements in the submatrix defined by the top-left corner (r1, c1) and the bottom-right corner (r2, c2). >>> sumOfSubmatrix( ... [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], 0, 0, 1, 1) 12 >>> sumOfSubmatrix( ... [ ... [1, 2], ... [3, 4] ... ], 1, 0, 1, 1) 7 >>> sumOfSubmatrix( ... [ ... [1, 2], ... [3, 4] ... ], 0, 1, 0, 1) 2 >>> sumOfSubmatrix( ... [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], 0, 0, 2, 2) 45 >>> sumOfSubmatrix( ... [ ... [-1000000000, 1000000000], ... [1000000000, -1000000000] ... ], 0, 0, 1, 1) 0 pass # implement the computation of submatrix sum","solution":"def sumOfSubmatrix(matrix, r1, c1, r2, c2): Returns the sum of all elements in the submatrix defined by the top-left corner (r1, c1) and the bottom-right corner (r2, c2). total_sum = 0 for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): total_sum += matrix[i][j] return total_sum"},{"question":"def calculate_trapped_water(elevations): Calculate the amount of trapped water given the elevations of the terrain. >>> calculate_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> calculate_trapped_water([3, 0, 0, 2, 0, 4]) 10 >>> calculate_trapped_water([0, 0, 0, 0]) 0 >>> calculate_trapped_water([3, 2, 1, 2, 3]) 4 pass def trapped_water_for_all_cases(T, test_cases): Calculate the total amount of trapped water for multiple test cases. >>> T = 2 >>> test_cases = [ ... [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1], ... [3, 0, 0, 2, 0, 4] ... ] >>> trapped_water_for_all_cases(T, test_cases) [6, 10] pass","solution":"def calculate_trapped_water(elevations): if not elevations: return 0 n = len(elevations) left_max = [0] * n right_max = [0] * n left_max[0] = elevations[0] for i in range(1, n): left_max[i] = max(left_max[i-1], elevations[i]) right_max[n-1] = elevations[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], elevations[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - elevations[i] return trapped_water def trapped_water_for_all_cases(T, test_cases): results = [] for elevations in test_cases: results.append(calculate_trapped_water(elevations)) return results"},{"question":"def min_operations_to_k_different_characters(k: int, s: str) -> int: Determines the minimum number of operations required to make the string \`s\` contain at least \`K\` different characters. >>> min_operations_to_k_different_characters(5, 'abcde') == 0 >>> min_operations_to_k_different_characters(2, 'aaaa') == 1 >>> min_operations_to_k_different_characters(3, 'ab') == 1 >>> min_operations_to_k_different_characters(5, 'aabbcc') == 2 pass def process_input(test_cases: list) -> list: Processes multiple test cases for the min_operations_to_k_different_characters function. >>> process_input([(5, 'abcde'), (2, 'aaaa'), (3, 'ab')]) == [0, 1, 1] >>> process_input([(1, 'z'), (4, 'a'), (26, 'abcdefghijklmnopqrstuvwxyz')]) == [0, 3, 0] pass","solution":"def min_operations_to_k_different_characters(k, s): Determines the minimum number of operations required to make the string \`s\` contain at least \`K\` different characters. unique_chars = set(s) num_unique_chars = len(unique_chars) # If the number of unique characters is already greater than or equal to K if num_unique_chars >= k: return 0 # Otherwise, we need to add more different characters return k - num_unique_chars def process_input(test_cases): results = [] for k, s in test_cases: results.append(min_operations_to_k_different_characters(k, s)) return results"},{"question":"def count_palindromic_substrings(s: str) -> int: Given a string containing only lowercase alphabets, return the count of substrings that are palindromes. A palindrome is a word that reads the same forwards and backwards. Single character substrings are considered palindromes. >>> count_palindromic_substrings(\\"abba\\") 6 >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aaa\\") 6 from typing import List def test_single_characters(): assert count_palindromic_substrings(\\"a\\") == 1 assert count_palindromic_substrings(\\"abc\\") == 3 def test_palindromes(): assert count_palindromic_substrings(\\"abba\\") == 6 # \\"a\\", \\"b\\", \\"b\\", \\"a\\", \\"bb\\", \\"abba\\" assert count_palindromic_substrings(\\"aa\\") == 3 # \\"a\\", \\"a\\", \\"aa\\" def test_no_palindromic_combinations(): assert count_palindromic_substrings(\\"abcd\\") == 4 # \\"a\\", \\"b\\", \\"c\\", \\"d\\" def test_complete_palindrome(): assert count_palindromic_substrings(\\"aaaa\\") == 10 # \\"a\\", \\"a\\", \\"a\\", \\"a\\", \\"aa\\", \\"aa\\", \\"aa\\", \\"aaa\\", \\"aaa\\", \\"aaaa\\" def test_mixed_cases(): assert count_palindromic_substrings(\\"abcba\\") == 7 # \\"a\\", \\"b\\", \\"c\\", \\"b\\", \\"a\\", \\"bcb\\", \\"abcba\\" assert count_palindromic_substrings(\\"racecar\\") == 10 # \\"r\\", \\"a\\", \\"c\\", \\"e\\", \\"c\\", \\"a\\", \\"r\\", \\"cec\\", \\"aceca\\", \\"racecar\\"","solution":"def count_palindromic_substrings(s): Returns the count of palindromic substrings in the input string. :param s: Input string containing only lowercase alphabets :return: Number of palindromic substrings n = len(s) count = 0 for center in range(2 * n - 1): left = center // 2 right = left + center % 2 while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 return count"},{"question":"def checkSubarraySum(arr: List[int], k: int) -> bool: Determines if there exists any contiguous subarray of length at least 2 such that the sum of the elements in the subarray is divisible by k. Args: arr: List[int] - list of integers k: int - target integer Returns: bool - True if such a subarray exists, False otherwise >>> checkSubarraySum([23, 2, 4, 6, 7], 6) True >>> checkSubarraySum([1, 2, 3], 5) True >>> checkSubarraySum([1, 2, 3], 7) False >>> checkSubarraySum([5, 0, 0], 5) True >>> checkSubarraySum([5], 5) False >>> checkSubarraySum([5, 10, 15], 5) True >>> checkSubarraySum([-1, 2, 3], 5) True >>> checkSubarraySum([10**9, 2, -10**9, 10**9], 10**9 + 7) True pass","solution":"def checkSubarraySum(arr, k): Determines if there exists any contiguous subarray of length at least 2 such that the sum of the elements in the subarray is divisible by k. Args: arr: List[int] - list of integers k: int - target integer Returns: bool - True if such a subarray exists, False otherwise # Dictionary to store the running sum mod k and its earliest index sum_mod = {0: -1} # Initialize with 0 mod k at index -1 to handle edge cases running_sum = 0 # Iterate over the array to compute the running sum mod k for i, num in enumerate(arr): running_sum += num mod_value = running_sum % k if mod_value in sum_mod: if i - sum_mod[mod_value] > 1: return True else: sum_mod[mod_value] = i return False"},{"question":"def valid_palindrome_with_one_removal(S: str) -> bool: Returns True if it is possible to form a palindrome by removing at most one character from the string S. Returns False otherwise. >>> valid_palindrome_with_one_removal(\\"abca\\") True >>> valid_palindrome_with_one_removal(\\"racecar\\") True >>> valid_palindrome_with_one_removal(\\"abcdef\\") False def can_be_palindrome(T: int, test_cases: List[str]) -> List[str]: Given an integer T and a list of T strings, determines if each string can be a palindrome by removing at most one character. Returns a list of \\"Yes\\" or \\"No\\" for each string accordingly. >>> can_be_palindrome(3, [\\"abca\\", \\"racecar\\", \\"abcdef\\"]) [\\"Yes\\", \\"Yes\\", \\"No\\"] >>> can_be_palindrome(2, [\\"abcba\\", \\"abcecba\\"]) [\\"Yes\\", \\"Yes\\"] >>> can_be_palindrome(2, [\\"abccxaa\\", \\"abcdca\\"]) [\\"No\\", \\"Yes\\"]","solution":"def valid_palindrome_with_one_removal(S): Returns True if it is possible to form a palindrome by removing at most one character from the string S. Returns False otherwise. def is_palindrome(s, start, end): Helper function to check if the substring s[start:end+1] is a palindrome. while start < end: if s[start] != s[end]: return False start += 1 end -= 1 return True start, end = 0, len(S) - 1 while start < end: if S[start] != S[end]: # Check two subcases: removing either the start or the end character return is_palindrome(S, start+1, end) or is_palindrome(S, start, end-1) start += 1 end -= 1 return True def can_be_palindrome(T, test_cases): results = [] for S in test_cases: if valid_palindrome_with_one_removal(S): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"from typing import List def maximum_extractions(s: str, target_words: List[str]) -> int: Given a string consisting of lowercase English letters and a list of target words, return the maximum number of times all the target words can be simultaneously extracted from the given string while maintaining their order. Args: s (str): The original string. target_words (List[str]): A list of target words. Returns: int: The maximum number of times all target words can be simultaneously extracted. >>> maximum_extractions(\\"abacabacaba\\", [\\"ab\\", \\"ca\\", \\"ac\\"]) 2 >>> maximum_extractions(\\"abcdef\\", [\\"gh\\", \\"ij\\", \\"kl\\"]) 0 >>> maximum_extractions(\\"aaaaa\\", [\\"a\\"]) 5 >>> maximum_extractions(\\"abcdefghijkl\\", [\\"abc\\", \\"def\\", \\"ghi\\", \\"jkl\\"]) 1 >>> maximum_extractions(\\"abcdefabcdefabcdef\\", [\\"abc\\", \\"def\\"]) 3 >>> maximum_extractions(\\"ababab\\", [\\"ab\\", \\"ab\\"]) 3","solution":"from collections import Counter def can_extract(s, target_words): Checks if all target words can be extracted simultaneously from string s and returns how many times this extraction is possible. s_counter = Counter(s) target_counters = [Counter(word) for word in target_words] min_extractions = float('inf') for target in target_counters: min_extractions_for_target = float('inf') for char in target: if char in s_counter: min_extractions_for_target = min(min_extractions_for_target, s_counter[char] // target[char]) else: return 0 min_extractions = min(min_extractions, min_extractions_for_target) return min_extractions def maximum_extractions(s, target_words): Returns the maximum number of times all target words can simultaneously be extracted from the given string while maintaining their order. return can_extract(s, target_words)"},{"question":"def findHighestPeak(N: int, M: int, matrix: List[List[int]]) -> Tuple[int, int]: Returns the coordinates (row, column) of the highest peak in the terrain matrix. If there are multiple highest peaks, it returns the coordinates of the first one encountered. >>> findHighestPeak(3, 3, [[1, 2, 3], [6, 5, 4], [7, 8, 9]]) (2, 2) >>> findHighestPeak(2, 2, [[1, 4], [3, 2]]) (0, 1) from typing import List, Tuple def test_single_peak(): matrix = [[1, 2, 3], [6, 5, 4], [7, 8, 9]] assert findHighestPeak(3, 3, matrix) == (2, 2) def test_multiple_peaks(): matrix = [[1, 4], [3, 2]] assert findHighestPeak(2, 2, matrix) == (0, 1) def test_same_height_different_position(): matrix = [[7, 4], [3, 7]] assert findHighestPeak(2, 2, matrix) == (0, 0) def test_large_numbers(): matrix = [[1, 10000], [9999, 10000]] assert findHighestPeak(2, 2, matrix) == (0, 1) def test_edge_case_minimum_matrix(): matrix = [[1]] assert findHighestPeak(1, 1, matrix) == (0, 0) def test_negative_values(): matrix = [[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]] assert findHighestPeak(3, 3, matrix) == (0, 0)","solution":"def findHighestPeak(N, M, matrix): Returns the coordinates (row, column) of the highest peak in the terrain matrix. If there are multiple highest peaks, it returns the coordinates of the first one encountered. max_height = -1 max_position = (0, 0) for i in range(N): for j in range(M): if matrix[i][j] > max_height: max_height = matrix[i][j] max_position = (i, j) return max_position"},{"question":"def classify_emails(n, subject_lines): Classifies each email subject line as \\"urgent\\" or \\"not urgent\\" based on the presence of substrings \\"project\\", \\"deadline\\", and \\"important\\". Parameters: n (int): Number of email subject lines. subject_lines (List[str]): List of email subject lines. Returns: List[str]: List of classifications, either \\"urgent\\" or \\"not urgent\\" for each subject line. >>> classify_emails(4, [\\"Project deadline is approaching\\", \\"This is an important project update\\", \\"Deadline extension for important project\\", \\"Team meeting about the project\\"]) ['not urgent', 'not urgent', 'urgent', 'not urgent'] >>> classify_emails(4, [\\"important project deadline meeting\\", \\"deadline for important project today\\", \\"project update, it's important and has a deadline\\", \\"just another email\\"]) ['urgent', 'urgent', 'urgent', 'not urgent']","solution":"def classify_emails(n, subject_lines): Classifies each email subject line as \\"urgent\\" or \\"not urgent\\" based on the presence of substrings \\"project\\", \\"deadline\\", and \\"important\\". Parameters: n (int): Number of email subject lines. subject_lines (List[str]): List of email subject lines. Returns: List[str]: List of classifications, either \\"urgent\\" or \\"not urgent\\" for each subject line. keywords = [\\"project\\", \\"deadline\\", \\"important\\"] results = [] for line in subject_lines: if all(keyword in line.lower() for keyword in keywords): results.append(\\"urgent\\") else: results.append(\\"not urgent\\") return results"},{"question":"from typing import List def spiral_traversal(mat: List[List[int]]) -> List[int]: Given a matrix mat of size n x m, return the spiral order traversal of the matrix. The spiral order traversal of a matrix involves starting at the top-left corner and moving right, then down, then left, then up, and repeating these steps until all elements are visited. Args: mat: A list of lists of integers representing the matrix. Returns: A list of integers representing the elements of the matrix in spiral order. Examples: >>> spiral_traversal([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiral_traversal([ ... [1, 2, 3, 4] ... ]) [1, 2, 3, 4] >>> spiral_traversal([ ... [1], ... [2], ... [3], ... [4] ... ]) [1, 2, 3, 4] >>> spiral_traversal([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12] ... ]) [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] >>> spiral_traversal([]) [] >>> spiral_traversal([ ... [1] ... ]) [1]","solution":"from typing import List def spiral_traversal(mat: List[List[int]]) -> List[int]: if not mat: return [] result = [] top, bottom, left, right = 0, len(mat), 0, len(mat[0]) while top < bottom and left < right: for i in range(left, right): result.append(mat[top][i]) top += 1 for i in range(top, bottom): result.append(mat[i][right - 1]) right -= 1 if top < bottom: for i in range(right - 1, left - 1, -1): result.append(mat[bottom - 1][i]) bottom -= 1 if left < right: for i in range(bottom - 1, top - 1, -1): result.append(mat[i][left]) left += 1 return result"},{"question":"from typing import List, Tuple def sort_inventory(inventory: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts the inventory items in alphabetical order based on product names. Args: inventory (list): A list of tuples, each containing a product name and quantity. Returns: list: A list of tuples sorted by product names in alphabetical order. >>> sort_inventory([(\\"Banana\\", 50), (\\"apple\\", 30), (\\"Orange\\", 40), (\\"grape\\", 60), (\\"Peach\\", 20)]) [(\\"apple\\", 30), (\\"Banana\\", 50), (\\"grape\\", 60), (\\"Orange\\", 40), (\\"Peach\\", 20)] >>> sort_inventory([(\\"apple\\", 30)]) [(\\"apple\\", 30)] >>> sort_inventory([(\\"apple\\", 30), (\\"Banana\\", 50), (\\"grape\\", 60), (\\"Orange\\", 40), (\\"Peach\\", 20)]) [(\\"apple\\", 30), (\\"Banana\\", 50), (\\"grape\\", 60), (\\"Orange\\", 40), (\\"Peach\\", 20)] >>> sort_inventory([(\\"banana\\", 50), (\\"Apple\\", 30), (\\"orange\\", 40), (\\"Grape\\", 60), (\\"peach\\", 20)]) [(\\"Apple\\", 30), (\\"banana\\", 50), (\\"Grape\\", 60), (\\"orange\\", 40), (\\"peach\\", 20)] >>> sort_inventory([]) []","solution":"def sort_inventory(inventory): Sorts the inventory items in alphabetical order based on product names. Args: inventory (list): A list of tuples, each containing a product name and quantity. Returns: list: A list of tuples sorted by product names in alphabetical order. return sorted(inventory, key=lambda item: item[0].lower())"},{"question":"def longestPalindromicSubstring(N: int, S: str) -> str: Given a string S of length N, find the longest palindromic substring in S using dynamic programming. >>> longestPalindromicSubstring(5, \\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longestPalindromicSubstring(12, \\"cbbdadaedfse\\") == \\"ada\\" True >>> longestPalindromicSubstring(3, \\"abc\\") in [\\"a\\", \\"b\\", \\"c\\"] True","solution":"def longestPalindromicSubstring(N, S): if N == 0: return \\"\\" dp = [[0] * N for _ in range(N)] start = 0 max_length = 1 # Initialize substrings of length 1 as palindromes for i in range(N): dp[i][i] = 1 # Check for substrings of length 2 for i in range(N-1): if S[i] == S[i+1]: dp[i][i+1] = 1 start = i max_length = 2 # Check for substrings of length greater than 2 for length in range(3, N+1): for i in range(N-length+1): j = i+length-1 if S[i] == S[j] and dp[i+1][j-1] == 1: dp[i][j] = 1 start = i max_length = length return S[start:start+max_length]"},{"question":"def can_deliver_all_orders(d, o, weight_limits, order_weights): Determine if all orders can be delivered using the available drones and under their respective weight limits. >>> can_deliver_all_orders(2, 3, [100, 200], [50, 75, 130]) \\"possible\\" >>> can_deliver_all_orders(1, 3, [100], [50, 60, 80]) \\"impossible\\" from solution import can_deliver_all_orders def test_example_1(): d = 2 o = 3 weight_limits = [100, 200] order_weights = [50, 75, 130] assert can_deliver_all_orders(d, o, weight_limits, order_weights) == \\"possible\\" def test_example_2(): d = 1 o = 3 weight_limits = [100] order_weights = [50, 60, 80] assert can_deliver_all_orders(d, o, weight_limits, order_weights) == \\"impossible\\" def test_larger_orders_than_drone_capacity(): d = 2 o = 3 weight_limits = [100, 200] order_weights = [300, 75, 50] assert can_deliver_all_orders(d, o, weight_limits, order_weights) == \\"impossible\\" def test_single_small_order(): d = 1 o = 1 weight_limits = [100] order_weights = [50] assert can_deliver_all_orders(d, o, weight_limits, order_weights) == \\"possible\\" def test_order_weight_equal_to_drone_capacity(): d = 2 o = 2 weight_limits = [100, 200] order_weights = [100, 200] assert can_deliver_all_orders(d, o, weight_limits, order_weights) == \\"possible\\" def test_insufficient_drones(): d = 1 o = 2 weight_limits = [100] order_weights = [50, 60] assert can_deliver_all_orders(d, o, weight_limits, order_weights) == \\"impossible\\"","solution":"def can_deliver_all_orders(d, o, weight_limits, order_weights): weight_limits.sort(reverse=True) order_weights.sort(reverse=True) for weight in order_weights: for i in range(d): if weight_limits[i] >= weight: weight_limits[i] -= weight break else: return \\"impossible\\" return \\"possible\\""},{"question":"def can_be_non_decreasing_flowers(n: int, heights: List[int]) -> str: Determine if the flower heights can be made non-decreasing by removing at most one flower. >>> can_be_non_decreasing_flowers(5, [1, 3, 2, 4, 5]) \\"yes\\" >>> can_be_non_decreasing_flowers(4, [4, 2, 3, 1]) \\"no\\"","solution":"def can_be_non_decreasing_flowers(n, heights): Determine if the flower heights can be made non-decreasing by removing at most one flower. def is_non_decreasing(arr): for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True if is_non_decreasing(heights): return \\"yes\\" for i in range(n): if is_non_decreasing(heights[:i] + heights[i+1:]): return \\"yes\\" return \\"no\\""},{"question":"class Warehouse: def __init__(self): self.inventory = {} def add(self, itemID, quantity): if itemID in self.inventory: self.inventory[itemID] += quantity else: self.inventory[itemID] = quantity def get(self, itemID): return self.inventory.get(itemID, 0) def remove(self, itemID, quantity): if itemID in self.inventory: self.inventory[itemID] = max(self.inventory[itemID] - quantity, 0) if self.inventory[itemID] == 0: del self.inventory[itemID] def list_items(self, L, R): sorted_items = sorted((item for item in self.inventory.keys() if L <= item <= R)) return [(item, self.inventory[item]) for item in sorted_items] def process_queries(queries): Process a sequence of queries for the warehouse management system. Args: queries (List[str]): List of queries in the format described. Returns: List: Result of the queries. Example: >>> process_queries([ ... \\"0 item1 10\\", ... \\"0 item2 20\\", ... \\"1 item1\\", ... \\"2 item1 5\\", ... \\"1 item1\\", ... \\"3 item1 item3\\", ... \\"3 itema itemz\\" ... ]) [10, 5, 'item1 5', 'item2 20'] pass from solution import process_queries def test_warehouse_operations(): queries = [ \\"0 item1 10\\", \\"0 item2 20\\", \\"1 item1\\", \\"2 item1 5\\", \\"1 item1\\", \\"3 item1 item3\\", \\"3 itema itemz\\" ] result = process_queries(queries) assert result == [10, 5, \\"item1 5\\", \\"item2 20\\"] def test_add_and_get(): queries = [ \\"0 itemA 100\\", \\"0 itemB 200\\", \\"1 itemA\\", \\"1 itemB\\", \\"0 itemB 50\\", \\"1 itemB\\" ] result = process_queries(queries) assert result == [100, 200, 250] def test_remove_items(): queries = [ \\"0 itemX 500\\", \\"2 itemX 300\\", \\"1 itemX\\", \\"2 itemX 300\\", \\"1 itemX\\" ] result = process_queries(queries) assert result == [200, 0] def test_list_items(): queries = [ \\"0 itemM 10\\", \\"0 itemN 20\\", \\"0 itemO 30\\", \\"3 itemL itemO\\", \\"3 itemM itemP\\" ] result = process_queries(queries) assert result == [\\"itemM 10\\", \\"itemN 20\\", \\"itemO 30\\", \\"itemM 10\\", \\"itemN 20\\", \\"itemO 30\\"] def test_edge_cases(): queries = [ \\"1 nonexistentItem\\", \\"2 nonexistentItem 10\\", \\"3 a z\\" ] result = process_queries(queries) assert result == [0]","solution":"class Warehouse: def __init__(self): self.inventory = {} def add(self, itemID, quantity): if itemID in self.inventory: self.inventory[itemID] += quantity else: self.inventory[itemID] = quantity def get(self, itemID): return self.inventory.get(itemID, 0) def remove(self, itemID, quantity): if itemID in self.inventory: self.inventory[itemID] = max(self.inventory[itemID] - quantity, 0) if self.inventory[itemID] == 0: del self.inventory[itemID] def list_items(self, L, R): sorted_items = sorted((item for item in self.inventory.keys() if L <= item <= R)) return [(item, self.inventory[item]) for item in sorted_items] def process_queries(queries): warehouse = Warehouse() output = [] for query in queries: parts = query.split() if parts[0] == '0': # add operation _, itemID, quantity = parts quantity = int(quantity) warehouse.add(itemID, quantity) elif parts[0] == '1': # get operation _, itemID = parts output.append(warehouse.get(itemID)) elif parts[0] == '2': # remove operation _, itemID, quantity = parts quantity = int(quantity) warehouse.remove(itemID, quantity) elif parts[0] == '3': # list operation _, L, R = parts items = warehouse.list_items(L, R) if items: for item, qty in items: output.append(f\\"{item} {qty}\\") return output"},{"question":"def maxScore(arr: List[int], n: int) -> int: Find the maximum score a player can achieve by starting from at most one checkpoint and continuing to the end. Parameters: arr (list[int]): A list of integers with the scores at each checkpoint. n (int): The number of checkpoints. Returns: int: The maximum score a player can achieve. >>> maxScore([-3, 2, 5, -1, 4], 5) == 10 >>> maxScore([1, -2, -3, 4, -1, 2, 1], 7) == 6 >>> maxScore([-5, -2, -3], 3) == -2 >>> maxScore([1, 2, 3, 4, 5], 5) == 15 >>> maxScore([-1, -2, -3, -4, -5], 5) == -1 >>> maxScore([3, -1, 2, -1, 4], 5) == 7 >>> maxScore([5], 1) == 5 >>> maxScore([0, -1, 0, -2, 0], 5) == 0","solution":"def maxScore(arr, n): Find the maximum score a player can achieve by starting from at most one checkpoint and continuing to the end. Parameters: arr (list[int]): A list of integers with the scores at each checkpoint. n (int): The number of checkpoints. Returns: int: The maximum score a player can achieve. # Initialize variables max_score = float('-inf') # This will store the maximum score found current_score = 0 # This will store the score from the current starting point # Traverse the array to find the maximum score for i in range(n): # Add the current element to the current score current_score += arr[i] # Update max_score if the current score is greater if current_score > max_score: max_score = current_score # If current score drops below 0, restart from the next index if current_score < 0: current_score = 0 return max_score"},{"question":"def longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> longest_substring(\\"abcabcbb\\") 3 >>> longest_substring(\\"bbbbb\\") 1 >>> longest_substring(\\"pwwkew\\") 3","solution":"def longest_substring(s): Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map: left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def min_cost_to_distribute_candies(t: int, test_cases: List[Tuple[int, int, int, List[int]]]) -> List[int]: Calculate the minimum cost required to distribute candies among children as per the conditions. Each child must have at least K candies. The cost per additional candy is C. Args: t: Number of test cases. test_cases: A list of tuples. Each tuple consists of N (number of children), K (minimum candies each child should have), C (cost per candy), and a list of integers representing the initial number of candies each child has. Returns: A list of integers representing the minimum cost required for each test case. >>> min_cost_to_distribute_candies(1, [(3, 5, 2, [2, 3, 6])]) [10] >>> min_cost_to_distribute_candies(1, [(3, 5, 2, [5, 6, 7])]) [0] >>> min_cost_to_distribute_candies(1, [(3, 5, 2, [0, 0, 0])]) [30] >>> min_cost_to_distribute_candies(2, [(3, 4, 1, [3, 3, 5]), (2, 3, 3, [2, 4])]) [2, 3]","solution":"def min_cost_to_distribute_candies(t, test_cases): results = [] for case in test_cases: N, K, C, a = case cost = 0 for candies in a: if candies < K: cost += (K - candies) * C results.append(cost) return results"},{"question":"def largest_square_subgrid(T, test_cases): Find the size of the largest square sub-grid consisting entirely of '1's. >>> largest_square_subgrid(1, [ ... (4, 5, [ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 1, 1, 1] ... ]) ]) == [3] >>> largest_square_subgrid(2, [ ... (3, 3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]), ... (4, 4, [ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0] ... ]) ]) == [3, 2] >>> largest_square_subgrid(1, [ ... (5, 6, [ ... [0, 1, 0, 1, 0, 1], ... [1, 0, 1, 0, 1, 0], ... [0, 1, 0, 1, 0, 1], ... [1, 0, 1, 0, 1, 0], ... [0, 1, 0, 1, 0, 1] ... ]) ]) == [1] >>> largest_square_subgrid(1, [ ... (1, 1, [ ... [1] ... ]) ]) == [1] >>> largest_square_subgrid(1, [ ... (1, 1, [ ... [0] ... ]) ]) == [0] >>> largest_square_subgrid(1, [ ... (3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) ]) == [0] >>> largest_square_subgrid(1, [ ... (3, 3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) ]) == [3]","solution":"def largest_square_subgrid(T, test_cases): def max_square_size(grid, N, M): dp = [[0]*M for _ in range(N)] max_size = 0 for i in range(N): for j in range(M): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_size = max(max_size, dp[i][j]) return max_size results = [] for case in test_cases: N, M, grid = case results.append(max_square_size(grid, N, M)) return results"},{"question":"def markdown_to_html(markdown: str) -> str: Convert Markdown text to HTML. This function transforms Markdown text into HTML, handling the following elements: 1. Headers (from level 1 to 3) 2. Paragraphs 3. Unordered lists 4. Ordered lists 5. Inline code Parameters: markdown (str): The Markdown text to be converted. Returns: str: The corresponding HTML. Example: >>> markdown_input = \\"# Header 1n Header 2n# Header 3nnThis is a paragraph with \`inline code\`.nn- Item 1n- Item 2n- Item 3nn1. First itemn2. Second itemnnAnother paragraph.\\" >>> markdown_to_html(markdown_input) '<h1>Header 1</h1>n<h2>Header 2</h2>n<h3>Header 3</h3>nn<p>This is a paragraph with <code>inline code</code>.</p>nn<ul>n<li>Item 1</li>n<li>Item 2</li>n<li>Item 3</li>n</ul>nn<ol>n<li>First item</li>n<li>Second item</li>n</ol>nn<p>Another paragraph.</p>' pass # Unit tests def test_headers(): markdown = \\"# Header 1n Header 2n# Header 3\\" html = \\"<h1>Header 1</h1>n<h2>Header 2</h2>n<h3>Header 3</h3>\\" assert markdown_to_html(markdown) == html def test_paragraphs(): markdown = \\"This is a paragraph.\\" html = \\"<p>This is a paragraph.</p>\\" assert markdown_to_html(markdown) == html def test_unordered_list(): markdown = \\"- Item 1n- Item 2n- Item 3\\" html = \\"<ul>n<li>Item 1</li>n<li>Item 2</li>n<li>Item 3</li>n</ul>\\" assert markdown_to_html(markdown) == html def test_ordered_list(): markdown = \\"1. First itemn2. Second item\\" html = \\"<ol>n<li>First item</li>n<li>Second item</li>n</ol>\\" assert markdown_to_html(markdown) == html def test_inline_code(): markdown = \\"This is a \`inline code\` example.\\" html = \\"<p>This is a <code>inline code</code> example.</p>\\" assert markdown_to_html(markdown) == html def test_complex_example(): markdown = # Header 1 Header 2 # Header 3 This is a paragraph with \`inline code\`. - Item 1 - Item 2 - Item 3 1. First item 2. Second item Another paragraph. html = <h1>Header 1</h1> <h2>Header 2</h2> <h3>Header 3</h3> <p>This is a paragraph with <code>inline code</code>.</p> <ul> <li>Item 1</li> <li>Item 2</li> <li>Item 3</li> </ul> <ol> <li>First item</li> <li>Second item</li> </ol> <p>Another paragraph.</p> assert markdown_to_html(markdown) == html def test_empty_input(): markdown = \\"\\" html = \\"\\" assert markdown_to_html(markdown) == html","solution":"import re def markdown_to_html(markdown): html_lines = [] in_ul = False in_ol = False def close_lists(): nonlocal in_ul, in_ol if in_ul: html_lines.append(\\"</ul>\\") in_ul = False if in_ol: html_lines.append(\\"</ol>\\") in_ol = False for line in markdown.splitlines(): if line.startswith('# '): close_lists() html_lines.append(f\\"<h1>{line[2:]}</h1>\\") elif line.startswith(' '): close_lists() html_lines.append(f\\"<h2>{line[3:]}</h2>\\") elif line.startswith('# '): close_lists() html_lines.append(f\\"<h3>{line[4:]}</h3>\\") elif line.startswith('- '): if not in_ul: close_lists() html_lines.append(\\"<ul>\\") in_ul = True html_lines.append(f\\"<li>{line[2:]}</li>\\") elif re.match(r'^d+. ', line): if not in_ol: close_lists() html_lines.append(\\"<ol>\\") in_ol = True html_lines.append(f\\"<li>{line[line.index('. ')+2:]}</li>\\") elif line.strip() == \\"\\": close_lists() if html_lines and not html_lines[-1].startswith('</p'): html_lines.append(\\"\\") else: close_lists() if not (html_lines and html_lines[-1] and html_lines[-1].startswith(\\"<p>\\")): html_lines.append(\\"<p>\\") else: html_lines[-1] = html_lines[-1][:-4] + \\" \\" line_with_code = re.sub(r'\`([^\`]*)\`', r'<code>1</code>', line) html_lines[-1] += line_with_code + \\"</p>\\" close_lists() return \\"n\\".join(html_lines) # Example usage markdown_input = # Header 1 Header 2 # Header 3 This is a paragraph with \`inline code\`. - Item 1 - Item 2 - Item 3 1. First item 2. Second item Another paragraph. html_output = markdown_to_html(markdown_input) print(html_output)"},{"question":"def maximize_score(test_cases): Given a list of test cases where each test case contains a list of integers, calculates the maximum score Alice can achieve using the specified operations. :param test_cases: List of test cases, each containing an integer N and a list of N integers :return: List of integers where each integer is the maximum score Alice can achieve for that test case >>> maximize_score([(3, [1, 2, 3]), (4, [4, 5, 6, 7])]) [3, 10] >>> maximize_score([(1, [5])]) [5] >>> maximize_score([(2, [7, 3])]) [3] >>> maximize_score([(4, [4, 4, 4, 4])]) [8] pass def parse_input(input_str): Parses the input string to extract test cases :param input_str: Raw input string :return: List of test cases >>> parse_input(\\"2n3n1 2 3n4n4 5 6 7n\\") [(3, [1, 2, 3]), (4, [4, 5, 6, 7])] pass def format_output(results): Formats the results into a string format for output :param results: List of results to format :return: Formatted string output >>> format_output([3, 10]) \\"3n10\\" pass","solution":"def maximize_score(test_cases): Given a list of test cases where each test case contains a list of integers, calculates the maximum score Alice can achieve using the specified operations. :param test_cases: List of test cases, each containing an integer N and a list of N integers :return: List of integers where each integer is the maximum score Alice can achieve for that test case results = [] for N, integers in test_cases: integers.sort() score = 0 # Take pairs from the back of the sorted list which is more optimal to maximize the score for i in range(N - 1, 0, -2): score += integers[i - 1] if N % 2 == 1: score += integers[0] results.append(score) return results def parse_input(input_str): Parses the input string to extract test cases :param input_str: Raw input string :return: List of test cases lines = input_str.split(\\"n\\") T = int(lines[0]) test_cases = [] current_line = 1 for _ in range(T): N = int(lines[current_line]) integers = list(map(int, lines[current_line + 1].split())) test_cases.append((N, integers)) current_line += 2 return test_cases def format_output(results): Formats the results into a string format for output :param results: List of results to format :return: Formatted string output return \\"n\\".join(map(str, results))"},{"question":"def organize_books(n: int, book_heights: List[int], m: int, shelf_capacities: List[int]) -> int: Sarah is an avid reader and loves collecting books. She has recently purchased several books and wants to organize them on her shelves. This function determines the maximum number of books that can be placed on the shelves following the given constraints. >>> organize_books(5, [4, 5, 3, 2, 8], 2, [3, 2]) 5 >>> organize_books(5, [4, 5, 3, 2, 8], 1, [4]) 4 >>> organize_books(5, [4, 5, 3, 2, 8], 2, [2, 1]) 3 >>> organize_books(6, [1, 2, 3, 4, 5, 6], 3, [1, 2, 2]) 5 >>> organize_books(0, [], 2, [3, 2]) 0 >>> organize_books(5, [4, 5, 3, 2, 8], 0, []) 0 >>> organize_books(5, [4, 5, 3, 2, 8], 2, [0, 0]) 0 >>> organize_books(5, [4, 5, 3, 2, 1], 3, [3, 2, 3]) 5","solution":"def maximize_books_on_shelves(book_heights, shelf_capacities): Returns the maximum number of books that can be placed on the shelves. book_heights.sort() shelf_capacities.sort(reverse=True) total_books = 0 i = 0 for capacity in shelf_capacities: placed_books = 0 while placed_books < capacity and i < len(book_heights): placed_books += 1 i += 1 total_books += placed_books return total_books # Wrapper function to parse the input format def organize_books(n, book_heights, m, shelf_capacities): return maximize_books_on_shelves(book_heights, shelf_capacities)"},{"question":"def minCoins(coins, target): Determine the minimum number of coins needed to make the target amount. You can use each coin from coins an unlimited number of times. If it is not possible to make the target amount using any combination of the given coins, return -1. >>> minCoins([1, 2, 5], 11) 3 >>> minCoins([2], 3) -1 >>> minCoins([1], 0) 0 >>> minCoins([1], 1) 1 >>> minCoins([1], 2) 2","solution":"def minCoins(coins, target): Returns the minimum number of coins needed to make the target amount using the given coins. If it is not possible to make the target amount using any combination of the given coins, returns -1. # Initialize DP array with an impossible high value (target+1) for all amounts dp = [target + 1] * (target + 1) dp[0] = 0 # Base case: 0 coins needed to make amount 0 for amount in range(1, target + 1): for coin in coins: if coin <= amount: dp[amount] = min(dp[amount], dp[amount - coin] + 1) return dp[target] if dp[target] != target + 1 else -1"},{"question":"def find_minimum_difference(N, arr): Splits the given array into two non-empty parts such that the absolute difference between the sum of elements in these two parts is minimized. Params: - N (int): size of the array - arr (List[int]): elements of the array Returns: int: the minimum possible absolute difference between the sums of the two parts >>> find_minimum_difference(5, [1, 2, 3, 4, 5]) 1 >>> find_minimum_difference(4, [8, 15, 7, 3]) 3 def process_test_cases(T, test_cases): Processes multiple test cases and returns the results for each. Params: - T (int): number of test cases - test_cases (List[Tuple[int, List[int]]]): list of test cases where each test case is a tuple containing the size of the array and the array elements. Returns: List[int]: results for each test case >>> T = 2 >>> test_cases = [ ... (5, [1, 2, 3, 4, 5]), ... (4, [8, 15, 7, 3]) ... ] >>> process_test_cases(T, test_cases) [1, 3] from solution import find_minimum_difference, process_test_cases def test_single_case(): assert find_minimum_difference(5, [1, 2, 3, 4, 5]) == 1 assert find_minimum_difference(4, [8, 15, 7, 3]) == 3 def test_varied_cases(): assert find_minimum_difference(3, [1, 3, 5]) == 1 assert find_minimum_difference(6, [1, 2, 3, 4, 5, 6]) == 1 assert find_minimum_difference(2, [10, 15]) == 5 def test_process_test_cases(): T = 2 test_cases = [ (5, [1, 2, 3, 4, 5]), (4, [8, 15, 7, 3]) ] assert process_test_cases(T, test_cases) == [1, 3] T = 1 test_cases = [ (5, [3, 1, 4, 2, 2]) ] assert process_test_cases(T, test_cases) == [0] def test_minimal_case(): assert find_minimum_difference(2, [1, 2]) == 1 def test_maximal_case(): assert find_minimum_difference(100, [1]*100) == 0","solution":"def find_minimum_difference(N, arr): Splits the given array into two non-empty parts such that the absolute difference between the sum of elements in these two parts is minimized. total_sum = sum(arr) half_sum = total_sum // 2 dp = [False] * (half_sum + 1) dp[0] = True for num in arr: for s in range(half_sum, num - 1, -1): if dp[s - num]: dp[s] = True for s in range(half_sum, -1, -1): if dp[s]: return abs(total_sum - 2 * s) def process_test_cases(T, test_cases): results = [] for i in range(T): N, arr = test_cases[i] results.append(find_minimum_difference(N, arr)) return results # Sample Test Case Input T = 2 test_cases = [ (5, [1, 2, 3, 4, 5]), (4, [8, 15, 7, 3]) ] # Process sample test cases results = process_test_cases(T, test_cases) for result in results: print(result)"},{"question":"def min_operations_to_palindrome(s: str) -> int: Determines the minimum number of operations required to transform the string into a valid palindrome. :param s: A string consisting of lowercase English letters. :return: The minimum number of operations required. >>> min_operations_to_palindrome(\\"abc\\") 1 >>> min_operations_to_palindrome(\\"aabb\\") 2 >>> min_operations_to_palindrome(\\"racecar\\") 0 >>> min_operations_to_palindrome(\\"\\") 0 >>> min_operations_to_palindrome(\\"a\\") 0 >>> min_operations_to_palindrome(\\"aa\\") 0 >>> min_operations_to_palindrome(\\"ab\\") 1 >>> min_operations_to_palindrome(\\"a\\" * 50000 + \\"b\\" * 50000) 50000","solution":"def min_operations_to_palindrome(s): Determines the minimum number of operations required to transform the string into a valid palindrome. :param s: A string consisting of lowercase English letters. :return: The minimum number of operations required. operations = 0 left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: operations += 1 left += 1 right -= 1 return operations"},{"question":"def count_islands(grid): Returns the number of islands in the given grid. :param grid: List of strings representing the grid where 'L' is land and 'W' is water. :return: Integer, the number of islands. pass from solution import count_islands def test_no_islands(): grid = [ \\"WWWW\\", \\"WWWW\\", \\"WWWW\\" ] assert count_islands(grid) == 0 def test_one_island(): grid = [ \\"LLLL\\", \\"LLLL\\", \\"LLLL\\" ] assert count_islands(grid) == 1 def test_multiple_islands(): grid = [ \\"LWLWL\\", \\"LWWLL\\", \\"LWWLL\\", \\"LWLWL\\" ] assert count_islands(grid) == 4 def test_diagonal_land(): grid = [ \\"LWW\\", \\"WLW\\", \\"WWL\\" ] assert count_islands(grid) == 3 def test_mixed_grid(): grid = [ \\"LWLLW\\", \\"LWLLW\\", \\"LWWLW\\" ] assert count_islands(grid) == 2","solution":"def count_islands(grid): Returns the number of islands in the given grid. :param grid: List of strings representing the grid where 'L' is land and 'W' is water. :return: Integer, the number of islands. if not grid: return 0 n = len(grid) m = len(grid[0]) visited = [[False] * m for _ in range(n)] def dfs(x, y): stack = [(x, y)] while stack: cx, cy = stack.pop() if 0 <= cx < n and 0 <= cy < m and not visited[cx][cy] and grid[cx][cy] == 'L': visited[cx][cy] = True # Push adjacent cells onto stack stack.append((cx-1, cy)) # Up stack.append((cx+1, cy)) # Down stack.append((cx, cy-1)) # Left stack.append((cx, cy+1)) # Right island_count = 0 for i in range(n): for j in range(m): if grid[i][j] == 'L' and not visited[i][j]: dfs(i, j) island_count += 1 return island_count"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Returns a new array where each element at index i is the product of all the numbers in the original array except for the one at i. >>> product_except_self([1, 2, 3, 4, 5]) == [120, 60, 40, 30, 24] >>> product_except_self([3, 2, 1]) == [2, 3, 6]","solution":"def product_except_self(nums): Returns a new array where each element at index i is the product of all the numbers in the original array except for the one at i. n = len(nums) if n == 0: return [] # Initialize output array with 1s result = [1] * n # Compute the prefixes products prefix = 1 for i in range(n): result[i] = prefix prefix *= nums[i] # Compute the postfixes products and multiply with corresponding prefix products postfix = 1 for i in range(n-1, -1, -1): result[i] *= postfix postfix *= nums[i] return result"},{"question":"from typing import List, Tuple def max_activities_performable(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determines the maximum number of consecutive activities the robot can perform without exceeding the initial battery capacity for each test case. Parameters: T (int): Number of test cases test_cases (list): List of tuples where each tuple contains: - N (int): Number of activities - B (int): Initial battery capacity - activity_durations (list): List of energy consumptions for activities Returns: list: List of integers representing the maximum number of consecutive activities for each test case >>> max_activities_performable(2, [(5, 100, [20, 30, 50, 10, 40]), (3, 60, [10, 20, 30])]) [3, 3] >>> max_activities_performable(1, [(4, 100, [10, 20, 30, 40])]) [4] >>> max_activities_performable(1, [(4, 50, [60, 70, 80, 90])]) [0] >>> max_activities_performable(1, [(4, 20, [20, 30, 40, 50])]) [1] >>> max_activities_performable(1, [(5, 75, [15, 15, 15, 15, 15])]) [5] >>> max_activities_performable(1, [(1000, 500, [1]*1000)]) [500] >>> max_activities_performable(1, [(10, 10000, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1])]) [10] >>> max_activities_performable(1, [(3, 30, [10, 10, 10])]) [3] >>> max_activities_performable(1, [(3, 5, [10, 15, 20])]) [0]","solution":"def max_activities_performable(T, test_cases): Determines the maximum number of consecutive activities the robot can perform without exceeding the initial battery capacity for each test case. Parameters: T (int): Number of test cases test_cases (list): List of tuples where each tuple contains: - N (int): Number of activities - B (int): Initial battery capacity - activity_durations (list): List of energy consumptions for activities Returns: list: List of integers representing the maximum number of consecutive activities for each test case results = [] for case in test_cases: N, B, activity_durations = case max_consecutive = 0 current_sum = 0 left = 0 for right in range(N): current_sum += activity_durations[right] while current_sum > B: current_sum -= activity_durations[left] left += 1 max_consecutive = max(max_consecutive, right - left + 1) results.append(max_consecutive) return results"},{"question":"def minPathCost(grid: List[List[int]]) -> int: Returns the minimum cost to move from the top-left to the bottom-right of the grid. >>> minPathCost([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> minPathCost([ ... [1, 2, 3], ... [4, 5, 6] ... ]) == 12 >>> minPathCost([ ... [1, 2], ... [4, 6], ... [7, 8] ... ]) == 17","solution":"def minPathCost(grid): Returns the minimum cost to move from the top-left to the bottom-right of the grid. m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[m - 1][n - 1]"},{"question":"def twoSumExists(array, target): Given an array of integers and a target value, determine whether there exist two distinct indices i and j in the array such that the sum of elements at these indices is equal to the target. >>> twoSumExists([2, 7, 11, 15], 9) == True >>> twoSumExists([1, 2, 3, 4], 8) == False","solution":"def twoSumExists(array, target): Given an array of integers and a target value, determine whether there exist two distinct indices i and j in the array such that the sum of elements at these indices is equal to the target. Parameters: array (List[int]): List of integers. target (int): Target sum value. Returns: bool: True if such a pair exists, otherwise False. seen = set() for num in array: if target - num in seen: return True seen.add(num) return False"},{"question":"def max_non_overlapping_intervals(test_cases): For each test case, find the maximum number of non-overlapping intervals. Args: test_cases: List of tuples, where each tuple contains: an integer N (number of applicants) and a list of tuples of integers (start, end) for each applicant's time slot. Returns: List of integers representing the maximum number of non-overlapping time slots for each test case. pass def process_input(data): Convert the input string into a structured format. Args: data: String containing input data Returns: List of test cases structured as described in the function max_non_overlapping_intervals pass def process_output(results): Convert the list of results into the required output format. Args: results: List of integers representing the maximum number of non-overlapping time slots for each test case Returns: String representation of results pass def run_interview_scheduling(data): Main function to run the interview scheduling algorithm. Args: data: String containing input data Returns: String representation of the solution pass if __name__ == \\"__main__\\": input_data = input().strip() print(run_interview_scheduling(input_data)) # Unit tests def test_max_non_overlapping_intervals(): data = \\"2n3n1 3n2 4n3 5n4n1 2n2 3n3 4n4 5\\" expected_output = \\"2n4\\" assert run_interview_scheduling(data) == expected_output def test_single_interval(): data = \\"1n1n0 5\\" expected_output = \\"1\\" assert run_interview_scheduling(data) == expected_output def test_no_overlap(): data = \\"1n3n1 2n3 4n5 6\\" expected_output = \\"3\\" assert run_interview_scheduling(data) == expected_output def test_all_overlap(): data = \\"1n3n1 4n2 5n3 6\\" expected_output = \\"1\\" assert run_interview_scheduling(data) == expected_output def test_large_data(): data = \\"1n100n\\" + \\"n\\".join(f\\"{i} {i+1}\\" for i in range(100)) expected_output = \\"100\\" assert run_interview_scheduling(data) == expected_output","solution":"def max_non_overlapping_intervals(test_cases): For each test case, find the maximum number of non-overlapping intervals. Args: test_cases: List of tuples, where each tuple contains: an integer N (number of applicants) and a list of tuples of integers (start, end) for each applicant's time slot. Returns: List of integers representing the maximum number of non-overlapping time slots for each test case. results = [] for N, intervals in test_cases: intervals.sort(key=lambda x: x[1]) # sort intervals by their end time count = 0 end = -1 for start, finish in intervals: if start >= end: count += 1 end = finish results.append(count) return results # Function to convert input data into a structured format def process_input(data): lines = data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) intervals = [] for i in range(N): start, end = map(int, lines[index + 1 + i].split()) intervals.append((start, end)) test_cases.append((N, intervals)) index += N + 1 return test_cases # Function to convert output data from a list to the required format def process_output(results): return 'n'.join(map(str, results)) # Main function to run the algorithm def run_interview_scheduling(data): test_cases = process_input(data) results = max_non_overlapping_intervals(test_cases) return process_output(results)"},{"question":"def shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: A company is developing a mapping application and wants to ensure that its users can find the shortest routes between various landmarks. To do this, they need to implement an efficient algorithm for finding the shortest path in a weighted graph. The application must handle multiple queries for pathfinding in a large, connected graph. Args: n: int - Number of nodes in the graph. m: int - Number of edges in the graph. edges: List[Tuple[int, int, int]] - List of edges where each edge consists of three integers u, v and w representing an edge between nodes u and v with weight w. Edges are bidirectional. queries: List[Tuple[int, int]] - List of queries where each query contains two integers a and b representing the source node and the destination node of the query. Returns: List[int] - List containing the length of the shortest path between the source and the destination for each query. If there is no path, the output is -1. Example: >>> shortest_path(4, 5, [(1, 2, 1), (2, 3, 2), (1, 3, 4), (3, 4, 1), (2, 4, 5)], [(1, 4), (4, 1), (2, 3)]) == [4, 4, 2] >>> shortest_path(4, 2, [(1, 2, 1), (3, 4, 1)], [(1, 3), (2, 4), (1, 4)]) == [-1, -1, -1] >>> shortest_path(3, 2, [(1, 2, 1), (2, 3, 2)], [(1, 1), (2, 2), (3, 3)]) == [0, 0, 0] >>> shortest_path(6, 5, [(1, 2, 1), (1, 3, 2), (2, 3, 1), (4, 5, 1), (5, 6, 1)], [(1, 4), (2, 5), (3, 6), (3, 2)]) == [-1, -1, -1, 1]","solution":"import heapq from collections import defaultdict, deque def dijkstra(graph, start, n): distances = {node: float('inf') for node in range(1, n+1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def shortest_path(n, m, edges, queries): graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) results = [] for a, b in queries: if a == b: results.append(0) else: distances = dijkstra(graph, a, n) result = distances[b] if distances[b] != float('inf') else -1 results.append(result) return results"},{"question":"def shortest_palindrome_length(s: str) -> int: Given a string containing only characters 'a', 'b', and 'c', determine the length of the shortest palindrome that can be formed by appending characters to the end of the given string. Args: s (str): A string containing only 'a', 'b', and 'c'. Returns: int: The length of the shortest palindrome that can be formed. Examples: >>> shortest_palindrome_length(\\"abca\\") 7 >>> shortest_palindrome_length(\\"abab\\") 5 >>> shortest_palindrome_length(\\"abc\\") 5","solution":"def shortest_palindrome_length(s: str) -> int: Returns the length of the shortest palindrome that can be formed by appending characters to the end of the given string. def is_palindrome(string): return string == string[::-1] n = len(s) for i in range(n): if is_palindrome(s[i:]): return n + i return 2 * n - 1 # This line is technically unreachable due to the loop guarantee."},{"question":"import heapq from typing import List, Tuple def minConferenceRoomsRequired(T: int, test_cases: List[List[Tuple[int, int]]]) -> List[int]: Determine the minimum number of conference rooms required to schedule all sessions without any conflicts. Args: T (int): The number of test cases. test_cases (List[List[Tuple[int, int]]]): A list of test cases, each containing a list of tuples where each tuple represents the start and end times of a session. Returns: List[int]: A list containing the minimum number of conference rooms required for each test case. Examples: >>> minConferenceRoomsRequired(1, [[(30, 75), (0, 50), (60, 150)]]) [2] >>> minConferenceRoomsRequired(2, [[(1, 5), (6, 10), (11, 15)], [(9, 17), (18, 22)]]) [1, 1] results = [] # Complete the function to find the minimum number of conference rooms required for each test case return results def test_minConferenceRoomsRequired(): assert minConferenceRoomsRequired(1, [[(30, 75), (0, 50), (60, 150)]]) == [2] assert minConferenceRoomsRequired(2, [[(1, 5), (6, 10), (11, 15)], [(9, 17), (18, 22)]]) == [1, 1] assert minConferenceRoomsRequired(1, [[(1, 10), (2, 9), (3, 8), (4, 7), (5, 6)]]) == [5] assert minConferenceRoomsRequired(1, [[(5, 10), (10, 15), (7, 8), (8, 9)]]) == [2] assert minConferenceRoomsRequired(1, [[]]) == [0] assert minConferenceRoomsRequired(3, [[(30, 75), (0, 50), (60, 150)], [(10, 20), (21, 30)], [(1, 10), (2, 9), (3, 8), (4, 7)]]) == [2, 1, 4]","solution":"import heapq def minConferenceRoomsRequired(T, test_cases): results = [] for i in range(T): sessions = test_cases[i] if not sessions: results.append(0) continue # Sort the sessions by start time sessions.sort(key = lambda x: x[0]) # Initialize a min-heap to track end times of sessions in ongoing conference rooms min_heap = [] # Add the first session end time to the heap heapq.heappush(min_heap, sessions[0][1]) for j in range(1, len(sessions)): # If the session starting now can reuse the room if sessions[j][0] >= min_heap[0]: heapq.heappop(min_heap) # Add the current session's end time to the heap heapq.heappush(min_heap, sessions[j][1]) # The size of the heap gives us the number of conference rooms required results.append(len(min_heap)) return results"},{"question":"def sort_employees(employees): Sorts a list of employees by age, and by name alphabetically if ages are the same. Args: employees (list of tuple): List of tuples where each tuple contains a name (str) and an age (int). Returns: list of tuple: Sorted list of employees. pass def format_employee_list(employees): Formats the sorted list of employees to display only names. Args: employees (list of tuple): Sorted list of tuples where each tuple contains a name (str) and an age (int). Returns: list of str: List of employee names. pass from solution import sort_employees, format_employee_list def test_sort_employees(): employees = [(\\"Alice\\", 30), (\\"Bob\\", 25), (\\"Eve\\", 25), (\\"Charlie\\", 30)] sorted_employees = sort_employees(employees) assert sorted_employees == [(\\"Bob\\", 25), (\\"Eve\\", 25), (\\"Alice\\", 30), (\\"Charlie\\", 30)] def test_sort_employees_with_same_name(): employees = [(\\"Alice\\", 30), (\\"Alice\\", 25), (\\"Bob\\", 25), (\\"Eve\\", 25), (\\"Charlie\\", 30)] sorted_employees = sort_employees(employees) assert sorted_employees == [(\\"Alice\\", 25), (\\"Bob\\", 25), (\\"Eve\\", 25), (\\"Alice\\", 30), (\\"Charlie\\", 30)] def test_sort_employees_with_same_age(): employees = [(\\"Alice\\", 30), (\\"Charlie\\", 30), (\\"Bob\\", 30)] sorted_employees = sort_employees(employees) assert sorted_employees == [(\\"Alice\\", 30), (\\"Bob\\", 30), (\\"Charlie\\", 30)] def test_format_employee_list(): employees = [(\\"Bob\\", 25), (\\"Eve\\", 25), (\\"Alice\\", 30), (\\"Charlie\\", 30)] employee_names = format_employee_list(employees) assert employee_names == [\\"Bob\\", \\"Eve\\", \\"Alice\\", \\"Charlie\\"] def test_end_to_end(): employees = [(\\"Alice\\", 30), (\\"Bob\\", 25), (\\"Eve\\", 25), (\\"Charlie\\", 30)] sorted_employees = sort_employees(employees) employee_names = format_employee_list(sorted_employees) assert employee_names == [\\"Bob\\", \\"Eve\\", \\"Alice\\", \\"Charlie\\"]","solution":"def sort_employees(employees): Sorts a list of employees by age, and by name alphabetically if ages are the same. Args: employees (list of tuple): List of tuples where each tuple contains a name (str) and an age (int). Returns: list of tuple: Sorted list of employees. return sorted(employees, key=lambda employee: (employee[1], employee[0])) def format_employee_list(employees): Formats the sorted list of employees to display only names. Args: employees (list of tuple): Sorted list of tuples where each tuple contains a name (str) and an age (int). Returns: list of str: List of employee names. return [employee[0] for employee in employees]"},{"question":"def findSingleElement(A, N): Returns the element that appears only once in the array A. Args: A: List[int] - List of integers where every element except one appears twice. N: int - Number of elements in the list A Returns: int - The unique element that appears only once. >>> findSingleElement([1, 2, 3, 2, 1], 5) 3 >>> findSingleElement([4, 5, 6, 5, 4, 6, 7], 7) 7 >>> findSingleElement([8, 9, 8], 3) 9 >>> findSingleElement([10, 20, 20, 30, 30], 5) 10 >>> findSingleElement([1, 1], 2) 0","solution":"def findSingleElement(A, N): Returns the element that appears only once in the array A. Args: A: List[int] - List of integers where every element except one appears twice. N: int - Number of elements in the list A Returns: int - The unique element that appears only once. # XOR all the elements in the array result = 0 for elem in A: result ^= elem return result"},{"question":"def canRemoveAll(n: int, S: str) -> str: Determines if it is possible to turn the entire binary string into a string of length zero by flipping and removing substrings of consecutive '1's. Args: n (int): The length of the string S. S (str): A binary string of length n. Returns: str: \\"YES\\" if it is possible to remove all characters, otherwise \\"NO\\". >>> canRemoveAll(6, \\"111000\\") \\"YES\\" >>> canRemoveAll(4, \\"1100\\") \\"YES\\" >>> canRemoveAll(3, \\"101\\") \\"NO\\"","solution":"def canRemoveAll(n, S): Determines if it is possible to turn the entire binary string into a string of length zero by flipping and removing substrings of consecutive '1's. Args: n (int): The length of the string S. S (str): A binary string of length n. Returns: str: \\"YES\\" if it is possible to remove all characters, otherwise \\"NO\\". # Check if there is any substring of '101' for i in range(1, n - 1): if S[i - 1] == '1' and S[i] == '0' and S[i + 1] == '1': return \\"NO\\" return \\"YES\\""},{"question":"def catalan_number(n: int) -> int: Compute the n-th Catalan number. >>> catalan_number(0) 1 >>> catalan_number(1) 1 >>> catalan_number(2) 2 >>> catalan_number(3) 5 >>> catalan_number(10) 16796","solution":"def catalan_number(n): Compute the n-th Catalan number using dynamic programming. if n == 0 or n == 1: return 1 catalan = [0] * (n + 1) catalan[0] = 1 catalan[1] = 1 for i in range(2, n + 1): for j in range(i): catalan[i] += catalan[j] * catalan[i - j - 1] return catalan[n]"},{"question":"from typing import List def trapped_water(heights: List[int]) -> int: Calculate the amount of water that would be trapped after raining. Args: heights (List[int]): A list of integers representing the heights of buildings. Returns: int: The total units of water trapped. Examples: >>> trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trapped_water([4, 2, 0, 3, 2, 5]) 9 >>> trapped_water([1, 2, 3, 4, 5]) 0 >>> trapped_water([5, 4, 3, 2, 1]) 0 >>> trapped_water([2, 0, 2]) 2","solution":"from typing import List def trapped_water(heights: List[int]) -> int: Calculate the amount of water that would be trapped after raining. Args: heights (List[int]): A list of integers representing the heights of buildings. Returns: int: The total units of water trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def unique_k_substrings(s: str, k: int) -> int: Calculates the number of unique substrings of length \`k\` in the given string \`s\`. Example: >>> unique_k_substrings(\\"abacab\\", 3) 4 >>> unique_k_substrings(\\"aaaa\\", 2) 1","solution":"def unique_k_substrings(s: str, k: int) -> int: Calculates the number of unique substrings of length \`k\` in the given string \`s\`. if k > len(s): return 0 substrings = set() for i in range(len(s) - k + 1): substrings.add(s[i:i + k]) return len(substrings)"},{"question":"from typing import List def temperature_trend(n: int, today_temp: int, predictions: List[int]) -> List[str]: Determines the trend in temperature predictions for the next n days. Parameters: n (int): Number of days for which predictions are made. today_temp (int): Today's temperature. predictions (List[int]): List of temperature predictions for the next n days. Returns: List[str]: List of strings indicating the trend for each day compared to the previous day. pass def test_temperature_trend_rise(): assert temperature_trend(5, 20, [22, 23, 24, 25, 26]) == [\\"Rise\\", \\"Rise\\", \\"Rise\\", \\"Rise\\", \\"Rise\\"] def test_temperature_trend_fall(): assert temperature_trend(5, 20, [18, 17, 16, 15, 14]) == [\\"Fall\\", \\"Fall\\", \\"Fall\\", \\"Fall\\", \\"Fall\\"] def test_temperature_trend_same(): assert temperature_trend(5, 20, [20, 20, 20, 20, 20]) == [\\"Same\\", \\"Same\\", \\"Same\\", \\"Same\\", \\"Same\\"] def test_temperature_trend_varied(): assert temperature_trend(5, 20, [18, 21, 20, 20, 22]) == [\\"Fall\\", \\"Rise\\", \\"Fall\\", \\"Same\\", \\"Rise\\"] def test_temperature_trend_mixed(): assert temperature_trend(3, 15, [15, 15, 16]) == [\\"Same\\", \\"Same\\", \\"Rise\\"] def test_temperature_trend_single_rise(): assert temperature_trend(1, 10, [20]) == [\\"Rise\\"] def test_temperature_trend_single_fall(): assert temperature_trend(1, 20, [10]) == [\\"Fall\\"] def test_temperature_trend_single_same(): assert temperature_trend(1, 15, [15]) == [\\"Same\\"]","solution":"def temperature_trend(n, today_temp, predictions): Determines the trend in temperature predictions for the next n days. Parameters: n (int): Number of days for which predictions are made. today_temp (int): Today's temperature. predictions (list): List of temperature predictions for the next n days. Returns: list: List of strings indicating the trend for each day compared to the previous day. trends = [] previous_temp = today_temp for temp in predictions: if temp > previous_temp: trends.append(\\"Rise\\") elif temp < previous_temp: trends.append(\\"Fall\\") else: trends.append(\\"Same\\") # Update the previous_temp for the next iteration previous_temp = temp return trends"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert_level_order(arr, root, i, n): Inserts nodes into the binary search tree in level order. Args: arr: List[int], the level order traversal of the BST. root: TreeNode, the root of the BST. i: int, the current index in the level order traversal list. n: int, the total number of nodes in the BST. Returns: TreeNode, the root of the BST. pass def in_order_traversal(root, arr): Performs in-order traversal of the binary search tree. Args: root: TreeNode, the root of the BST. arr: List[int], list to store the in-order traversal. Returns: List[int], the in-order traversal of the BST. pass def median_of_bst(nodes): Finds the median of a list of numbers from a balanced BST. Args: nodes: List[int], the in-order traversal of the BST nodes. Returns: float, the median value of the BST nodes. pass def process_cases(cases): Processes multiple test cases to find the median of BSTs. Args: cases: List[Tuple[int, List[int]]], list of test cases. Returns: List[float], the median values for each test case. pass def solve(inputs): Solves the problem based on the input format. Args: inputs: List[int], formatted input containing the number of test cases, number of nodes, and the level order traversal of each BST. Outputs the median value for each BST. pass # Example of using the function example_input = [2, 7, 4, 2, 6, 1, 3, 5, 7, 4, 4, 2, 6, 1] solve(example_input)","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert_level_order(arr, root, i, n): if i < n: temp = TreeNode(arr[i]) root = temp root.left = insert_level_order(arr, root.left, 2 * i + 1, n) root.right = insert_level_order(arr, root.right, 2 * i + 2, n) return root def in_order_traversal(root, arr): if root: in_order_traversal(root.left, arr) arr.append(root.val) in_order_traversal(root.right, arr) return arr def median_of_bst(nodes): bst = insert_level_order(nodes, None, 0, len(nodes)) in_order = in_order_traversal(bst, []) n = len(in_order) if n % 2 == 1: return float(in_order[n // 2]) else: return (in_order[n // 2 - 1] + in_order[n // 2]) / 2 def process_cases(cases): results = [] for case in cases: n, nodes = case results.append(median_of_bst(nodes)) return results def solve(inputs): index = 0 T = inputs[index] index += 1 cases = [] for _ in range(T): N = inputs[index] index += 1 nodes = [] for _ in range(N): nodes.append(inputs[index]) index += 1 cases.append((N, nodes)) results = process_cases(cases) for result in results: print(f\\"{result:.1f}\\") # Example of using the function example_input = [2, 7, 4, 2, 6, 1, 3, 5, 7, 4, 4, 2, 6, 1] solve(example_input)"},{"question":"def klara_wins(N: int) -> str: Determine if Klara has a winning strategy for a given number of stones N. >>> klara_wins(1) 'Klara' >>> klara_wins(2) 'John' >>> klara_wins(3) 'Klara' >>> klara_wins(10) 'Klara' def solve(arr: List[int]) -> List[str]: Determine the winner for each test case in arr, where each element in arr represents the initial number of stones. >>> solve([1, 2, 3, 10]) ['Klara', 'John', 'Klara', 'Klara'] >>> solve([0, 4]) ['John', 'Klara'] >>> solve([1000000]) ['Klara']","solution":"def klara_wins(N): Determine if Klara has a winning strategy for a given number of stones N. # dp[i] will be True if for pile with i stones Klara has a winning strategy dp = [False] * (N + 1) # Base cases if N >= 1: dp[1] = True if N >= 2: dp[2] = False if N >= 3: dp[3] = True if N >= 4: dp[4] = True for i in range(5, N+1): dp[i] = not dp[i-1] or not dp[i-3] or not dp[i-4] return \\"Klara\\" if dp[N] else \\"John\\" def solve(arr): results = [] for N in arr: results.append(klara_wins(N)) return results"},{"question":"from typing import List def can_be_increasing(nums: List[int]) -> bool: You are given a sequence of integers and you need to determine if it is possible to transform it into a monotonic increasing sequence by removing at most one element from it. A sequence is considered monotonic increasing if for every element S[i], S[i] <= S[i + 1]. >>> can_be_increasing([1, 2, 10, 5, 7]) True >>> can_be_increasing([2, 3, 1, 2]) False >>> can_be_increasing([1, 2, 3, 4]) True >>> can_be_increasing([5, 1, 2, 3, 4]) True >>> can_be_increasing([1, 2, 3, 4, 0]) True >>> can_be_increasing([1, 1, 1, 1]) False >>> can_be_increasing([42]) True","solution":"from typing import List def can_be_increasing(nums: List[int]) -> bool: def is_increasing(sequence): return all(sequence[i] < sequence[i+1] for i in range(len(sequence) - 1)) for i in range(len(nums)): if is_increasing(nums[:i] + nums[i+1:]): return True return False"},{"question":"def SolveIndexQueries(arr, queries): Given an array of integers arr and several queries, each query contains a value X. For each query, finds the index of the first occurrence of the number X in the array. If the number X does not exist in the array, returns -1. Example: >>> SolveIndexQueries([4, 2, 1, 5, 2, 3, 1], [2, 5, 7]) [1, 3, -1] >>> SolveIndexQueries([4, 2, 1, 5, 2, 3, 1], [6, 7, 8]) [-1, -1, -1] >>> SolveIndexQueries([4], [4, 5]) [0, -1] from solution import SolveIndexQueries def test_solve_index_queries_all_present(): arr = [4, 2, 1, 5, 2, 3, 1] queries = [2, 5, 1] expected = [1, 3, 2] assert SolveIndexQueries(arr, queries) == expected def test_solve_index_queries_not_present(): arr = [4, 2, 1, 5, 2, 3, 1] queries = [6, 7, 8] expected = [-1, -1, -1] assert SolveIndexQueries(arr, queries) == expected def test_solve_index_queries_mixed(): arr = [4, 2, 1, 5, 2, 3, 1] queries = [2, 5, 7] expected = [1, 3, -1] assert SolveIndexQueries(arr, queries) == expected def test_solve_index_queries_single_element(): arr = [4] queries = [4, 5] expected = [0, -1] assert SolveIndexQueries(arr, queries) == expected def test_solve_index_queries_empty_array(): arr = [] queries = [1, 2, 3] expected = [-1, -1, -1] assert SolveIndexQueries(arr, queries) == expected def test_solve_index_queries_empty_queries(): arr = [4, 2, 1, 5, 2, 3, 1] queries = [] expected = [] assert SolveIndexQueries(arr, queries) == expected","solution":"def SolveIndexQueries(arr, queries): Returns a list containing the index of the first occurrence of each query value in arr. If the query value does not exist in arr, returns -1 for that query. result = [] for q in queries: try: index = arr.index(q) except ValueError: index = -1 result.append(index) return result"},{"question":"def trailing_zeros_in_factorial(n: int) -> int: Returns the number of trailing zeros in the factorial of n. >>> trailing_zeros_in_factorial(5) == 1 >>> trailing_zeros_in_factorial(10) == 2 >>> trailing_zeros_in_factorial(25) == 6 >>> trailing_zeros_in_factorial(50) == 12","solution":"def trailing_zeros_in_factorial(n): Returns the number of trailing zeros in the factorial of n. count = 0 power_of_5 = 5 while n >= power_of_5: count += n // power_of_5 power_of_5 *= 5 return count"},{"question":"def can_form_palindrome(s: str) -> str: Determine if any rotation of the string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"aab\\") 'YES' >>> can_form_palindrome(\\"carerac\\") 'YES' >>> can_form_palindrome(\\"a\\") 'YES' >>> can_form_palindrome(\\"abc\\") 'NO' >>> can_form_palindrome(\\"ab\\") 'NO' >>> can_form_palindrome(\\"\\") 'YES' >>> can_form_palindrome(\\"racecar\\") 'YES' >>> can_form_palindrome(\\"aaaaa\\") 'YES' >>> can_form_palindrome(\\"xyzzyx\\") 'YES'","solution":"def can_form_palindrome(s): # Helper function to determine if a string can be rearranged to form a palindrome def can_rearrange_to_palindrome(string): from collections import Counter count = Counter(string) odd_count = sum(1 for c in count if count[c] % 2 != 0) return odd_count <= 1 if can_rearrange_to_palindrome(s): return \\"YES\\" else: return \\"NO\\""},{"question":"def game_of_life(grid): Returns the state of the grid after one iteration according to the rules of the cellular automaton. >>> game_of_life([[0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0]]) [[0, 0, 0], [1, 0, 1], [0, 1, 1], [0, 1, 0]] >>> game_of_life([[1, 1], [1, 0]]) [[1, 1], [1, 1]]","solution":"def game_of_life(grid): Returns the state of the grid after one iteration according to the rules of the cellular automaton. def count_live_neighbors(x, y): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] count = 0 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1: count += 1 return count m, n = len(grid), len(grid[0]) next_state = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): live_neighbors = count_live_neighbors(i, j) if grid[i][j] == 1: if live_neighbors < 2 or live_neighbors > 3: next_state[i][j] = 0 else: next_state[i][j] = 1 else: if live_neighbors == 3: next_state[i][j] = 1 else: next_state[i][j] = 0 return next_state"},{"question":"from typing import List def process_student_records(test_cases: List[List[str]]) -> List[List[str]]: Processes a list of student records and returns the names of students who passed all subjects, sorted in descending order of their total scores. In case of a tie in total scores, the names are listed in alphabetical order. Parameters: test_cases (List[List[str]]): List of test cases, where each test case is a list of student records. Returns: List[List[str]]: List of result lists. Each result list contains names of students who passed, sorted as specified. pass def test_case_1(): test_cases = [ [ \\"John 78 67 90\\", \\"Alice 45 50 49\\", \\"Bob 34 80 90\\" ], [ \\"Rachel 55 89 76\\", \\"Monica 90 92 85\\", \\"Phoebe 28 64 72\\", \\"Chandler 30 29 101\\" ] ] expected = [ [\\"John\\", \\"Alice\\"], [\\"Monica\\", \\"Rachel\\"] ] assert process_student_records(test_cases) == expected def test_case_2_with_equal_total_scores(): test_cases = [ [ \\"John 60 60 60\\", \\"Alice 60 60 60\\", \\"Bob 35 35 35\\" ] ] expected = [[\\"Alice\\", \\"John\\", \\"Bob\\"]] assert process_student_records(test_cases) == expected def test_case_3_all_students_fail(): test_cases = [ [ \\"John 30 60 60\\", \\"Alice 60 34 60\\", \\"Bob 35 35 30\\" ] ] expected = [[]] assert process_student_records(test_cases) == expected def test_case_4_empty_input(): test_cases = [ [] ] expected = [[]] assert process_student_records(test_cases) == expected def test_case_5_mix_of_pass_and_fail(): test_cases = [ [ \\"Harry 90 90 90\\", \\"Ron 85 85 85\\", \\"Hermione 100 100 100\\", \\"Neville 30 40 35\\", \\"Luna 35 35 35\\" ] ] expected = [[\\"Hermione\\", \\"Harry\\", \\"Ron\\", \\"Luna\\"]] assert process_student_records(test_cases) == expected","solution":"def process_student_records(test_cases): results = [] for students in test_cases: passed_students = [] for student in students: name, math, physics, chem = student.split() math, physics, chem = int(math), int(physics), int(chem) if math >= 35 and physics >= 35 and chem >= 35: total_score = math + physics + chem passed_students.append((name, total_score)) # Sorting the list first by total_score in descending order, then by name in alphabetical order passed_students.sort(key=lambda x: (-x[1], x[0])) # Collect the names of the passed students results.append([name for name, _ in passed_students]) return results"},{"question":"def aggregate_by_key(data: List[Dict[str, Any]], key: str) -> Dict[str, int]: Aggregates values in a list of dictionaries based on the specified key. Args: data (list of dict): The list of dictionaries to process. key (str): The key to aggregate values by. Returns: dict: A dictionary where each key is a unique category from the input list and the value is the sum of values associated with that category. >>> data = [ ... {\\"category\\": \\"A\\", \\"value\\": 10}, ... {\\"category\\": \\"B\\", \\"value\\": 20}, ... {\\"category\\": \\"A\\", \\"value\\": 5}, ... {\\"category\\": \\"C\\", \\"value\\": 7}, ... {\\"category\\": \\"B\\", \\"value\\": 3}, ... ] >>> aggregate_by_key(data, 'category') {'A': 15, 'B': 23, 'C': 7}","solution":"def aggregate_by_key(data, key): Aggregates values in a list of dictionaries based on the specified key. Args: data (list of dict): The list of dictionaries to process. key (str): The key to aggregate values by. Returns: dict: A dictionary where each key is a unique category from the input list and the value is the sum of values associated with that category. aggregated_result = {} for item in data: category = item[key] value = item['value'] if category in aggregated_result: aggregated_result[category] += value else: aggregated_result[category] = value return aggregated_result"},{"question":"def allocate_resources(events): Simulates a resource allocation system. :param events: List of tuples, where each tuple contains an event type (\\"CHECKOUT\\"/\\"RETURN\\"), a user ID, and a resource ID. :return: Dictionary where keys are user IDs and values are sets of resource IDs currently checked out by that user. Example: >>> allocate_resources([(\\"CHECKOUT\\", \\"user1\\", \\"res1\\"), (\\"CHECKOUT\\", \\"user2\\", \\"res2\\"), (\\"RETURN\\", \\"user1\\", \\"res1\\"), (\\"RETURN\\", \\"user2\\", \\"res3\\"), (\\"CHECKOUT\\", \\"user2\\", \\"res1\\")]) {\\"user2\\": {\\"res2\\", \\"res1\\"}} pass from solution import allocate_resources def test_allocate_resources_empty(): assert allocate_resources([]) == {} def test_allocate_resources_simple_checkout(): events = [(\\"CHECKOUT\\", \\"user1\\", \\"res1\\")] assert allocate_resources(events) == {\\"user1\\": {\\"res1\\"}} def test_allocate_resources_checkout_return_checkout(): events = [(\\"CHECKOUT\\", \\"user1\\", \\"res1\\"), (\\"RETURN\\", \\"user1\\", \\"res1\\"), (\\"CHECKOUT\\", \\"user2\\", \\"res1\\")] assert allocate_resources(events) == {\\"user2\\": {\\"res1\\"}} def test_allocate_resources_invalid_return(): events = [(\\"RETURN\\", \\"user1\\", \\"res1\\")] assert allocate_resources(events) == {} def test_allocate_resources_invalid_checkout(): events = [(\\"CHECKOUT\\", \\"user1\\", \\"res1\\"), (\\"CHECKOUT\\", \\"user2\\", \\"res1\\")] assert allocate_resources(events) == {\\"user1\\": {\\"res1\\"}} def test_allocate_resources_mixed_events(): events = [ (\\"CHECKOUT\\", \\"user1\\", \\"res1\\"), (\\"CHECKOUT\\", \\"user2\\", \\"res2\\"), (\\"RETURN\\", \\"user1\\", \\"res1\\"), (\\"RETURN\\", \\"user2\\", \\"res3\\"), (\\"CHECKOUT\\", \\"user2\\", \\"res1\\") ] assert allocate_resources(events) == {\\"user2\\": {\\"res2\\", \\"res1\\"}} def test_allocate_resources_complex_scenario(): events = [ (\\"CHECKOUT\\", \\"user1\\", \\"res1\\"), (\\"CHECKOUT\\", \\"user2\\", \\"res2\\"), (\\"CHECKOUT\\", \\"user3\\", \\"res3\\"), (\\"RETURN\\", \\"user1\\", \\"res1\\"), (\\"CHECKOUT\\", \\"user1\\", \\"res2\\"), (\\"RETURN\\", \\"user2\\", \\"res2\\"), (\\"CHECKOUT\\", \\"user1\\", \\"res2\\"), (\\"RETURN\\", \\"user3\\", \\"res3\\") ] assert allocate_resources(events) == {\\"user1\\": {\\"res2\\"}}","solution":"def allocate_resources(events): Simulates a resource allocation system. :param events: List of tuples, where each tuple contains an event type (\\"CHECKOUT\\"/\\"RETURN\\"), a user ID, and a resource ID. :return: Dictionary where keys are user IDs and values are sets of resource IDs currently checked out by that user. user_resources = {} resource_owner = {} for event in events: event_type, user_id, resource_id = event if event_type == \\"CHECKOUT\\": # Check if resource is already checked out if resource_id not in resource_owner: if user_id not in user_resources: user_resources[user_id] = set() user_resources[user_id].add(resource_id) resource_owner[resource_id] = user_id elif event_type == \\"RETURN\\": # Check if the user has this resource checked out if user_id in user_resources and resource_id in user_resources[user_id]: user_resources[user_id].remove(resource_id) del resource_owner[resource_id] if not user_resources[user_id]: # Clean up user entry if no resources left del user_resources[user_id] return user_resources"},{"question":"def filter_greater_than(numbers, threshold): Returns a new array containing only the numbers from the original array that are greater than the threshold. Args: numbers (List[int]): An array of integers. threshold (int): An integer threshold. Returns: List[int]: A new array containing numbers greater than the threshold. Examples: >>> filter_greater_than([1, 5, 8, 3, 7], 4) [5, 8, 7] >>> filter_greater_than([2, 3, 1], 5) []","solution":"def filter_greater_than(numbers, threshold): Returns a new array containing only the numbers from the original array that are greater than the threshold. return [num for num in numbers if num > threshold]"},{"question":"def shortest_subsequence(words: List[str], target: str) -> List[str]: Find the shortest contiguous subsequence of words such that the concatenated string of this subsequence contains the target string as a subsequence. >>> shortest_subsequence([\\"abc\\", \\"de\\", \\"fg\\", \\"hij\\", \\"kl\\"], \\"fgh\\") == [\\"fg\\", \\"hij\\"] >>> shortest_subsequence([\\"abc\\", \\"def\\", \\"gh\\", \\"ijk\\"], \\"ghijk\\") == [\\"gh\\", \\"ijk\\"] >>> shortest_subsequence([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"], \\"ace\\") == [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"] >>> shortest_subsequence([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"], \\"f\\") == [] pass","solution":"from typing import List def shortest_subsequence(words: List[str], target: str) -> List[str]: n = len(words) min_length = float('inf') result = [] # Helper function to check if target is a subsequence of combined def is_subsequence(combined, target): it = iter(combined) return all(char in it for char in target) # Iterate over all possible subsequences for i in range(n): combined = \\"\\" for j in range(i, n): combined += words[j] if is_subsequence(combined, target): if j - i + 1 < min_length: min_length = j - i + 1 result = words[i:j+1] break return result"},{"question":"def findSmallestMissingPositive(arr): Returns the smallest missing positive integer from the list. >>> findSmallestMissingPositive([-2, 3, 7, 1, 2, 8]) 4 >>> findSmallestMissingPositive([1, 2, 3, 4, 5]) 6 >>> findSmallestMissingPositive([-1, -2, -3]) 1 >>> findSmallestMissingPositive([1, 2, 0]) 3 >>> findSmallestMissingPositive([3, 4, -1, 1]) 2 >>> findSmallestMissingPositive([1, 2, 2, 1, 3, 4]) 5 pass","solution":"def findSmallestMissingPositive(arr): Returns the smallest missing positive integer from the list. n = len(arr) # Mark elements that are out of the range of the length of the list for i in range(n): if arr[i] <= 0 or arr[i] > n: arr[i] = n + 1 # Use the index as a hash key and mark the presence of an integer for i in range(n): num = abs(arr[i]) if num <= n: arr[num - 1] = -abs(arr[num - 1]) # Find the first index that has a positive value for i in range(n): if arr[i] > 0: return i + 1 # If all indices have negative values return n + 1"},{"question":"from typing import List, Tuple def max_recipes(recipes: List[Tuple[str, List[Tuple[str, int]]]], ingredients: List[Tuple[str, int]]) -> int: Determine the maximum number of complete recipes that can be prepared with the available ingredients. >>> recipes = [('pasta', [('tomato', 2), ('cheese', 1)]), ('burger', [('bread', 1), ('patty', 2)]), ('salad', [('lettuce', 1), ('tomato', 1), ('dressing', 1)])] >>> ingredients = [('bread', 1), ('patty', 2), ('tomato', 3), ('cheese', 1), ('lettuce', 1), ('dressing', 1)] >>> max_recipes(recipes, ingredients) 2 def parse_input(input_str: str) -> Tuple[List[Tuple[str, List[Tuple[str, int]]]], List[Tuple[str, int]]]: Parse the input string to extract recipes and ingredients. >>> input_str = '''3 pasta 2 tomato 2 cheese 1 burger 2 bread 1 patty 2 salad 3 lettuce 1 tomato 1 dressing 1 5 bread 1 patty 2 tomato 3 cheese 1 lettuce 1 dressing 1''' >>> recipes, ingredients = parse_input(input_str) >>> expected_recipes = [('pasta', [('tomato', 2), ('cheese', 1)]), ('burger', [('bread', 1), ('patty', 2)]), ('salad', [('lettuce', 1), ('tomato', 1), ('dressing', 1)])] >>> expected_ingredients = [('bread', 1), ('patty', 2), ('tomato', 3), ('cheese', 1), ('lettuce', 1), ('dressing', 1)] >>> recipes == expected_recipes True >>> ingredients == expected_ingredients True if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def max_recipes(recipes, ingredients): from collections import defaultdict available = defaultdict(int) for ingredient, qty in ingredients: available[ingredient] += qty max_possible = 0 while True: can_prepare_any = False for recipe, req_ingredients in recipes: can_prepare = True for ingredient, qty in req_ingredients: if available[ingredient] < qty: can_prepare = False break if can_prepare: for ingredient, qty in req_ingredients: available[ingredient] -= qty can_prepare_any = True max_possible += 1 break if not can_prepare_any: break return max_possible def parse_input(input_str): lines = input_str.splitlines() R = int(lines[0]) recipes = [] index = 1 for _ in range(R): parts = lines[index].split() recipe_name = parts[0] num_ingredients = int(parts[1]) req_ingredients = [] for i in range(num_ingredients): ingredient_name = parts[2 + 2 * i] ingredient_qty = int(parts[3 + 2 * i]) req_ingredients.append((ingredient_name, ingredient_qty)) recipes.append((recipe_name, req_ingredients)) index += 1 I = int(lines[index]) ingredients = [] for i in range(I): parts = lines[index + 1 + i].split() ingredient_name = parts[0] ingredient_qty = int(parts[1]) ingredients.append((ingredient_name, ingredient_qty)) return recipes, ingredients"},{"question":"def final_string_length(binary_string: str) -> int: Return the length of the final string after performing the operations of removing adjacent differing characters ('0' and '1') any number of times. >>> final_string_length(\\"1100\\") 0 >>> final_string_length(\\"00110\\") 1 >>> final_string_length(\\"101010\\") 0","solution":"def final_string_length(binary_string): Return the length of the final string after performing the operations of removing adjacent differing characters ('0' and '1') any number of times. stack = [] for char in binary_string: if stack and stack[-1] != char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"def maximum_cells_covered(T, test_cases): Given the number of test cases, and for each test case, the number of columns in a 2xN grid, return the maximum number of cells the snake can cover starting from any cell in the given grids. Args: T: int : The number of test cases test_cases: list : A list containing the number of columns for each test case Returns: list : A list containing the maximum number of cells covered for each test case Examples: >>> maximum_cells_covered(2, [3, 5]) [6, 10] >>> maximum_cells_covered(1, [1]) [2]","solution":"def maximum_cells_covered(T, test_cases): This function returns the maximum number of cells the snake can cover in a 2xN grid for each test case. results = [] for N in test_cases: results.append(2 * N) # Each grid has 2 rows, so maximum cells covered will be 2*N return results"},{"question":"def optimize_distribution_centers(n: int, k: int, grid: List[List[int]]) -> List[Tuple[int, int]]: Determine the optimal placement of k distribution centers on a grid to minimize the maximum Manhattan distance from any cell to the nearest distribution center. Args: n (int): The size of the grid (n x n). k (int): Number of distribution centers to be placed. grid (List[List[int]]): The grid where 0 represents a road and 1 represents a building. Returns: List[Tuple[int, int]]: The list of k pairs of integers where each pair (i, j) represents the row and column index of a road cell where a distribution center will be placed. Example: >>> optimize_distribution_centers(5, 3, [ ... [0, 1, 0, 0, 1], ... [0, 0, 1, 1, 0], ... [1, 0, 0, 0, 1], ... [1, 1, 0, 0, 0], ... [0, 1, 0, 0, 0] ... ]) [(1, 1), (3, 2), (5, 3)] >>> optimize_distribution_centers(4, 2, [ ... [0, 0, 1, 0], ... [0, 1, 0, 0], ... [1, 0, 1, 0], ... [0, 0, 0, 0] ... ]) [(1, 1), (4, 4)]","solution":"import heapq def optimize_distribution_centers(n, k, grid): def possible_positions(): positions = [] for i in range(n): for j in range(n): if grid[i][j] == 0: positions.append((i, j)) return positions def max_manhattan_distance(centers): max_dist = 0 for i in range(n): for j in range(n): min_dist = float('inf') for ci, cj in centers: min_dist = min(min_dist, abs(i - ci) + abs(j - cj)) max_dist = max(max_dist, min_dist) return max_dist positions = possible_positions() best_centers = [] best_max_distance = float('inf') heapq.heapify(positions) def search(centers): nonlocal best_centers, best_max_distance if len(centers) == k: max_dist = max_manhattan_distance(centers) if max_dist < best_max_distance: best_max_distance = max_dist best_centers = centers[:] return for pos_index in range(len(positions)): center = positions[pos_index] remaining_positions = positions[pos_index+1:] search(centers + [center]) positions[pos_index] = center # backtrack search([]) return best_centers"},{"question":"def minimum_trips(N: int, M: int, P: List[int]) -> int: Calculate the minimum number of trips required to pick up all passengers from bus stops. Args: N : int : number of bus stops M : int : maximum number of passengers the bus can carry at a time P : List[int] : list of passengers at each bus stop Returns: int : minimum number of trips needed Examples: >>> minimum_trips(5, 4, [1, 2, 3, 4, 5]) 4 >>> minimum_trips(3, 3, [3, 3, 3]) 3 >>> minimum_trips(6, 10, [10, 0, 10, 3, 2, 1]) 3","solution":"def minimum_trips(N, M, P): trips = 0 current_bus_capacity = 0 for passengers in P: if current_bus_capacity + passengers <= M: current_bus_capacity += passengers else: trips += 1 current_bus_capacity = passengers if current_bus_capacity > 0: trips += 1 return trips # Sample Input and Output testing if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) P = list(map(int, data[2:])) print(minimum_trips(N, M, P))"},{"question":"def min_coins_to_make_amount(denominations, amount): Returns the minimum number of coins required to make up the given amount using the specified denominations, or -1 if it's not possible to make the amount. >>> min_coins_to_make_amount([1, 2, 5], 11) 3 >>> min_coins_to_make_amount([2, 4, 6], 7) -1 >>> min_coins_to_make_amount([1], 10) 10 >>> min_coins_to_make_amount([1, 3, 4], 6) 2 >>> min_coins_to_make_amount([], 5) -1 >>> min_coins_to_make_amount([1, 2, 5], 0) 0 >>> min_coins_to_make_amount([1, 2, 5], 100) 20 >>> min_coins_to_make_amount([2, 5], 3) -1","solution":"def min_coins_to_make_amount(denominations, amount): Returns the minimum number of coins required to make up the given amount using the specified denominations, or -1 if it's not possible to make the amount. # Initialize a large number for comparison, assumed to be larger than any possible number of coins MAX = float('inf') # Initialize dp array where dp[i] stands for minimum number of coins to make amount i dp = [MAX] * (amount + 1) # Base case: To make amount 0, we need 0 coins dp[0] = 0 for coin in denominations: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) # If dp[amount] is still MAX, it means it's not possible to form the amount return dp[amount] if dp[amount] != MAX else -1"},{"question":"def filter_even_numbers(lst): Filter even numbers from a list and return them. >>> filter_even_numbers([1, 2, 3, 4, 5, 6]) [2, 4, 6] >>> filter_even_numbers([]) [] >>> filter_even_numbers([1, 3, 5, 7, 9]) [] >>> filter_even_numbers([2, 4, 6, 8, 10]) [2, 4, 6, 8, 10] >>> filter_even_numbers([10, 15, 20, 25, 30, 35]) [10, 20, 30] >>> filter_even_numbers([-2, -1, 0, 1, 2]) [-2, 0, 2]","solution":"def filter_even_numbers(lst): even_numbers = [] for number in lst: if number % 2 == 0: even_numbers.append(number) return even_numbers # Example usage numbers = [1, 2, 3, 4, 5, 6] print(filter_even_numbers(numbers)) # Expected output: [2, 4, 6]"},{"question":"def unique_numbers_in_sequences(n: int, sequences: List[str]) -> str: Identify and extract all unique numbers from the sequences preserving the order of their first occurrence. >>> unique_numbers_in_sequences(3, [\\"1 2 2 3 4\\", \\"3 5 6 3 7\\", \\"8 9 5 1\\"]) \\"1 2 3 4 5 6 7 8 9\\" >>> unique_numbers_in_sequences(3, [\\"1 1 1\\", \\"1 1 1\\", \\"1 1 1\\"]) \\"1\\"","solution":"def unique_numbers_in_sequences(n, sequences): seen = set() result = [] for seq in sequences: for number in seq.split(): if number not in seen: seen.add(number) result.append(number) return \\" \\".join(result)"},{"question":"def nextPrime(N: int) -> int: Takes a positive integer N and returns the smallest prime number greater than N. Examples: >>> nextPrime(10) 11 >>> nextPrime(14) 17 >>> nextPrime(20) 23","solution":"def is_prime(num): Checks if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def nextPrime(N): Returns the smallest prime number greater than N. candidate = N + 1 while not is_prime(candidate): candidate += 1 return candidate"},{"question":"def can_attend_meetings(meetings): Returns whether a person can attend all meetings without any overlap. Parameters: meetings (list of list of int): A list of [start, end] meeting times. Returns: bool: True if the person can attend all meetings, False otherwise. Examples: >>> can_attend_meetings([[1, 3], [5, 6], [2, 4]]) False >>> can_attend_meetings([[7, 10], [2, 4]]) True >>> can_attend_meetings([[1, 5]]) True >>> can_attend_meetings([]) True >>> can_attend_meetings([[1, 2], [2, 3], [3, 4]]) True >>> can_attend_meetings([[1, 3], [1, 3]]) False >>> can_attend_meetings([[1, 5], [2, 3], [4, 6]]) False","solution":"def can_attend_meetings(meetings): Returns whether a person can attend all meetings without any overlap. Parameters: meetings (list of list of int): A list of [start, end] meeting times. Returns: bool: True if the person can attend all meetings, False otherwise. if not meetings: return True # Sort meetings by their start time meetings.sort(key=lambda x: x[0]) # Check for any overlap for i in range(1, len(meetings)): if meetings[i][0] < meetings[i-1][1]: return False return True"},{"question":"def minimum_total_distance(alice, bob, charlie): Returns the minimum total walking distance for Alice, Bob, and Charlie to meet at one point. >>> minimum_total_distance(1, 4, 6) 5 >>> minimum_total_distance(5, 5, 5) 0 >>> minimum_total_distance(1, 4, 7) 6 >>> minimum_total_distance(10, 50, 100) 90 >>> minimum_total_distance(10, 5, 1) 9 >>> minimum_total_distance(1, 2, 3) 2 >>> minimum_total_distance(100000, 100000, 100000) 0","solution":"def minimum_total_distance(alice, bob, charlie): Returns the minimum total walking distance for Alice, Bob, and Charlie to meet at one point. # Sort their initial positions positions = sorted([alice, bob, charlie]) # The most optimal meeting point is the middle position when sorted optimal_meeting_point = positions[1] # The total walking distance is the sum of the distances each friend needs to walk total_distance = abs(alice - optimal_meeting_point) + abs(bob - optimal_meeting_point) + abs(charlie - optimal_meeting_point) return total_distance"},{"question":"def geometric_series_sum(a: int, r: int, n: int) -> int: Calculate the sum of the first n terms of a geometric series with given first term a, common ratio r. >>> geometric_series_sum(3, 2, 4) 45 >>> geometric_series_sum(5, 1, 3) 15","solution":"def geometric_series_sum(a, r, n): Calculate the sum of the first n terms of a geometric series with given first term a, common ratio r. if r == 1: return a * n else: return a * (1 - r**n) // (1 - r) # Example Usage # print(geometric_series_sum(3, 2, 4)) # Output: 45 # print(geometric_series_sum(5, 1, 3)) # Output: 15"},{"question":"from typing import List def find_permutations(arr: List[int]) -> List[List[int]]: Given an array of distinct integers \`arr\`, this function finds all possible permutations of the array and returns them in any order. Examples: >>> find_permutations([1, 2, 3]) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> find_permutations([0, 1]) [[0, 1], [1, 0]] >>> find_permutations([1]) [[1]]","solution":"from itertools import permutations def find_permutations(arr): Finds all possible permutations of the given array. return [list(p) for p in permutations(arr)]"},{"question":"def find_partitions(n: int, sequence: List[int]) -> Union[int, List[List[int]]]: Finds the required partition of the sequence into groups of four where required conditions are met or returns -1 if such partition doesn't exist. >>> find_partitions(8, [1, 2, 4, 8, 1, 2, 4, 8]) [[1, 2, 4, 8], [1, 2, 4, 8]] >>> find_partitions(4, [1, 2, 1, 4]) -1","solution":"def find_partitions(n, sequence): from collections import Counter count = Counter(sequence) groups = [] while count[1] and count[2] and count[4] and count[8]: group = [] for num in [1, 2, 4, 8]: if count[num] > 0: group.append(num) count[num] -= 1 else: return -1 groups.append(group) if len(groups) * 4 == n: return groups else: return -1 def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) sequence = list(map(int, data[1:])) result = find_partitions(n, sequence) if result == -1: print(result) else: for group in result: print(' '.join(map(str, group)))"},{"question":"def apply_discount(price: float, is_special_customer: bool) -> float: Calculate the new price after applying the relevant discount(s) based on the price and whether the customer is special or not. Args: price (float): The original price of the product. is_special_customer (bool): Indicates if the customer is special. Returns: float: The new price after discounts. Examples: >>> apply_discount(600, False) 480.0 >>> apply_discount(250, True) 213.75 >>> apply_discount(150, True) 135.375","solution":"def apply_discount(price, is_special_customer): Calculate the new price after applying the relevant discount(s) based on the price and whether the customer is special or not. Args: price (float): The original price of the product. is_special_customer (bool): Indicates if the customer is special. Returns: float: The new price after discounts. if price > 500: price *= 0.80 elif 200 <= price <= 500: price *= 0.90 else: price *= 0.95 if is_special_customer: price *= 0.95 return price"},{"question":"from typing import List def can_form_palindrome(n: int, strings: List[str]) -> List[str]: Determine if each string can be rearranged into a palindrome. >>> can_form_palindrome(4, [\\"abba\\", \\"abc\\", \\"aabbcc\\", \\"abcd\\"]) ['Yes', 'No', 'Yes', 'No'] >>> can_form_palindrome(3, [\\"civic\\", \\"ivicc\\", \\"civil\\"]) ['Yes', 'Yes', 'No'] >>> can_form_palindrome(1, [\\"aabbccdd\\"]) ['Yes'] # Your code here def process_input_output(inputs: List[str]) -> List[str]: Process input and output for the palindrome test cases. >>> process_input_output([\\"4\\", \\"abba\\", \\"abc\\", \\"aabbcc\\", \\"abcd\\"]) ['Yes', 'No', 'Yes', 'No'] # Your code here","solution":"def can_form_palindrome(n, strings): from collections import Counter results = [] for s in strings: char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) if odd_count <= 1: results.append(\\"Yes\\") else: results.append(\\"No\\") return results def process_input_output(inputs): n = int(inputs[0]) strings = inputs[1:] return can_form_palindrome(n, strings)"},{"question":"def minimum_processing_time(n: int, times: List[int]) -> int: Returns the minimum time required to process a product through all the stations. >>> minimum_processing_time(5, [3, 1, 4, 1, 5]) 14 >>> minimum_processing_time(3, [10, 20, 30]) 60 >>> minimum_processing_time(1, [1000]) 1000 >>> minimum_processing_time(5, [1, 1, 1, 1, 1]) 5 >>> minimum_processing_time(4, [5, 10, 5, 10]) 30 >>> minimum_processing_time(1000, [1] * 1000) 1000 >>> minimum_processing_time(1000, [1000] * 1000) 1000000 pass","solution":"def minimum_processing_time(n, times): Returns the minimum time required to process a product through all the stations. Parameters: n (int): Number of stations. times (list of int): Processing times for each station. Returns: int: The total processing time. return sum(times)"},{"question":"def min_packets(T: int, test_cases: List[Tuple[int, List[int], int]]) -> List[int]: Determine the minimum number of packets required to obtain at least the required amount of the ingredient for each test case. Parameters: T (int): Number of test cases test_cases (list): List of tuples, each containing the number of packets, a list of quantities in each packet, and the required amount Returns: list: List of minimum number of packets required for each test case or -1 if not possible >>> T = 2 >>> test_cases = [ ... (3, [800, 400, 300], 1000), ... (4, [500, 800, 700, 200], 2000) ... ] >>> min_packets(T, test_cases) [2, 3] >>> T = 1 >>> test_cases = [ ... (3, [100, 100, 100], 500) ... ] >>> min_packets(T, test_cases) [-1] >>> T = 1 >>> test_cases = [ ... (4, [500, 400, 100, 500], 1000) ... ] >>> min_packets(T, test_cases) [2] from typing import List, Tuple # Unit Tests def test_min_packets_example_cases(): T = 2 test_cases = [ (3, [800, 400, 300], 1000), (4, [500, 800, 700, 200], 2000) ] assert min_packets(T, test_cases) == [2, 3] def test_min_packets_insufficient_packets(): T = 1 test_cases = [ (3, [100, 100, 100], 500) ] assert min_packets(T, test_cases) == [-1] def test_min_packets_exact_match(): T = 1 test_cases = [ (4, [500, 400, 100, 500], 1000) ] assert min_packets(T, test_cases) == [2] def test_min_packets_large_numbers(): T = 1 test_cases = [ (5, [2000, 1500, 1000, 500, 250], 2750) ] assert min_packets(T, test_cases) == [2] def test_min_packets_single_packet(): T = 1 test_cases = [ (1, [1000], 1000) ] assert min_packets(T, test_cases) == [1] def test_multiple_cases(): T = 3 test_cases = [ (2, [999, 1], 1000), (3, [400, 700, 800], 1500), (4, [200, 300, 400, 500], 1200) ] assert min_packets(T, test_cases) == [2, 2, 3]","solution":"def min_packets(T, test_cases): Determine the minimum number of packets required to obtain at least the required amount of the ingredient for each test case. Parameters: T (int): Number of test cases test_cases (list): List of tuples, each containing (P, quantities, R) Returns: list: List of minimum number of packets required for each test case or -1 if not possible results = [] for case in test_cases: P, quantities, R = case quantities.sort(reverse=True) # Sort packets in descending order to use larger packets first total = 0 count = 0 for quantity in quantities: total += quantity count += 1 if total >= R: results.append(count) break if total < R: results.append(-1) return results # Example input T = 2 test_cases = [ (3, [800, 400, 300], 1000), (4, [500, 800, 700, 200], 2000) ] # Call function with example input and print the results print(min_packets(T, test_cases))"},{"question":"from typing import List def next_permutation(s: str) -> str: Returns the lexicographically smallest permutation greater than s, or \\"no answer\\" if no such permutation exists. >>> next_permutation(\\"ab\\") 'ba' >>> next_permutation(\\"bb\\") 'no answer' pass def process_test_cases(test_cases: List[str]) -> List[str]: Processes a list of test cases and returns the lexicographically smallest permutations greater than each string, or \\"no answer\\" if no such permutation exists. >>> process_test_cases([\\"ab\\", \\"bb\\", \\"abc\\", \\"xyz\\", \\"a\\", \\"ba\\"]) ['ba', 'no answer', 'acb', 'xzy', 'no answer', 'no answer'] pass def test_next_permutation(): # Test with sample inputs assert next_permutation(\\"ab\\") == \\"ba\\" assert next_permutation(\\"bb\\") == \\"no answer\\" # Test with a permutation in the middle assert next_permutation(\\"acb\\") == \\"bac\\" # Test with the last permutation assert next_permutation(\\"cba\\") == \\"no answer\\" # Test with a multi-character string assert next_permutation(\\"abcd\\") == \\"abdc\\" assert next_permutation(\\"xyza\\") == \\"xzay\\" assert next_permutation(\\"zxy\\") == \\"zyx\\" # Test with a string that is already the smallest lexicographical permutation assert next_permutation(\\"aaa\\") == \\"no answer\\" assert next_permutation(\\"abcde\\") == \\"abced\\" # Test boundary cases assert next_permutation(\\"a\\") == \\"no answer\\" assert next_permutation(\\"ba\\") == \\"no answer\\" def test_process_test_cases(): # Define test cases test_cases = [\\"ab\\", \\"bb\\", \\"abc\\", \\"xyz\\", \\"a\\", \\"ba\\"] # Define expected results expected_results = [\\"ba\\", \\"no answer\\", \\"acb\\", \\"xzy\\", \\"no answer\\", \\"no answer\\"] # Call the function results = process_test_cases(test_cases) # Check if results match expected results assert results == expected_results def test_process_test_cases_empty(): # Define test cases with no strings test_cases = [] # Define expected results expected_results = [] # Call the function results = process_test_cases(test_cases) # Check if results match expected results assert results == expected_results","solution":"def next_permutation(s): Returns the lexicographically smallest permutation greater than s, or \\"no answer\\" if no such permutation exists. s = list(s) n = len(s) # Step 1: Find the largest index k such that s[k] < s[k + 1] k = -1 for i in range(n - 1): if s[i] < s[i + 1]: k = i # If there is no such index k, then this is the last permutation if k == -1: return \\"no answer\\" # Step 2: Find the largest index l such that s[k] < s[l] l = -1 for i in range(k + 1, n): if s[k] < s[i]: l = i # Step 3: Swap the values of s[k] and s[l] s[k], s[l] = s[l], s[k] # Step 4: Reverse the sequence from s[k + 1] to the end s = s[:k + 1] + s[k + 1:][::-1] # Convert the list back to a string return ''.join(s) def process_test_cases(test_cases): results = [] for s in test_cases: results.append(next_permutation(s)) return results"},{"question":"def max_sublist_sum(arr): Returns the maximum sum of any non-empty sublist where the sublist contains consecutive elements. >>> max_sublist_sum([1, 2, -3, 4, 5]) 9 >>> max_sublist_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_sublist_sum([-1, -2, -3]) -1 >>> max_sublist_sum([10]) 10 >>> max_sublist_sum([-10]) -10 >>> max_sublist_sum([3, -1, 4, -1, 2, 1, -5, 4]) 8 >>> max_sublist_sum([0, 0, 0, 0, 0]) 0 >>> max_sublist_sum([i for i in range(-1000, 1000)]) 499500 >>> max_sublist_sum([-10000, -10000, -9999, -10001, -9998]) -9998","solution":"def max_sublist_sum(arr): Returns the maximum sum of any non-empty sublist where the sublist contains consecutive elements. if not arr: return 0 current_max = arr[0] global_max = arr[0] for i in range(1, len(arr)): current_max = max(arr[i], current_max + arr[i]) global_max = max(global_max, current_max) return global_max"},{"question":"def categorize_scrolls(test_cases): Categorize scrolls by their civilizations and print the number of scrolls for each civilization. Args: test_cases (List[List[Tuple[int, str]]]): A list of test cases, where each test case is a list of tuples containing the serial number (int) and civilization (str) of the scroll. Returns: List[str]: A list of strings where each string contains the civilization name followed by the number of scrolls belonging to that civilization, sorted in alphabetical order of civilization names. Example: >>> test_cases = [ [(101, 'Mesopotamia'), (102, 'Egypt'), (103, 'Egypt')], [(201, 'Greece'), (202, 'Mesopotamia'), (203, 'Greece'), (204, 'Egypt')] ] >>> categorize_scrolls(test_cases) ['Egypt 2', 'Mesopotamia 1', 'Egypt 1', 'Greece 2', 'Mesopotamia 1'] pass def parse_input(input_string): Parse the input string into a list of test cases. Args: input_string (str): The input string containing multiple test cases, each test case starting with an integer N followed by N lines of serial number and civilization string. Returns: List[List[Tuple[int, str]]]: A list of test cases, where each test case is a list of tuples containing the serial number (int) and civilization (str). Example: >>> input_string = \\"3n101 Mesopotamian102 Egyptn103 Egyptn4n201 Greecen202 Mesopotamian203 Greecen204 Egyptn0\\" >>> parse_input(input_string) [ [(101, 'Mesopotamia'), (102, 'Egypt'), (103, 'Egypt')], [(201, 'Greece'), (202, 'Mesopotamia'), (203, 'Greece'), (204, 'Egypt')] ] pass from solution import categorize_scrolls, parse_input def test_single_case(): input_data = \\"3n101 Mesopotamian102 Egyptn103 Egyptn0\\" test_cases = parse_input(input_data) result = categorize_scrolls(test_cases) assert result == [\\"Egypt 2\\", \\"Mesopotamia 1\\"] def test_multiple_cases(): input_data = \\"3n101 Mesopotamian102 Egyptn103 Egyptn4n201 Greecen202 Mesopotamian203 Greecen204 Egyptn0\\" test_cases = parse_input(input_data) result = categorize_scrolls(test_cases) assert result == [\\"Egypt 2\\", \\"Mesopotamia 1\\", \\"Egypt 1\\", \\"Greece 2\\", \\"Mesopotamia 1\\"] def test_empty_case(): input_data = \\"0\\" test_cases = parse_input(input_data) result = categorize_scrolls(test_cases) assert result == [] def test_all_different(): input_data = \\"4n101 Romen102 Greecen103 Egyptn104 Mesopotamian0\\" test_cases = parse_input(input_data) result = categorize_scrolls(test_cases) assert result == [\\"Egypt 1\\", \\"Greece 1\\", \\"Mesopotamia 1\\", \\"Rome 1\\"] def test_large_case(): input_data = \\"5n101 Romen102 Romen103 Egyptn104 Egyptn105 Egyptn0\\" test_cases = parse_input(input_data) result = categorize_scrolls(test_cases) assert result == [\\"Egypt 3\\", \\"Rome 2\\"]","solution":"def categorize_scrolls(test_cases): result = [] for t in test_cases: scroll_count = {} for serial, civilization in t: if civilization in scroll_count: scroll_count[civilization] += 1 else: scroll_count[civilization] = 1 for civilization in sorted(scroll_count): result.append(f\\"{civilization} {scroll_count[civilization]}\\") return result def parse_input(input_string): lines = input_string.strip().split('n') test_cases = [] idx = 0 while idx < len(lines): n = int(lines[idx]) if n == 0: break idx += 1 test_case = [] for _ in range(n): serial, civilization = lines[idx].split(maxsplit=1) test_case.append((int(serial), civilization)) idx += 1 test_cases.append(test_case) return test_cases"},{"question":"def sort_book_titles(t: int, titles: List[str]) -> List[str]: Sort book titles ignoring leading articles (\\"a\\", \\"an\\", \\"the\\"). Parameters: t (int): The number of book titles. titles (list of str): List of book titles. Returns: list of str: Alphabetically sorted list of book titles ignoring leading articles. >>> sort_book_titles(4, [\\"The Great Gatsby\\", \\"A Tale of Two Cities\\", \\"The Catcher in the Rye\\", \\"Moby Dick\\"]) [\\"The Catcher in the Rye\\", \\"The Great Gatsby\\", \\"Moby Dick\\", \\"A Tale of Two Cities\\"] >>> sort_book_titles(3, [\\"Gone with the Wind\\", \\"Pride and Prejudice\\", \\"Brave New World\\"]) [\\"Brave New World\\", \\"Gone with the Wind\\", \\"Pride and Prejudice\\"] >>> sort_book_titles(5, [\\"An Apple a Day\\", \\"Rise of the Planet of the Apes\\", \\"A Study in Scarlet\\", \\"The Brothers Karamazov\\", \\"One Hundred Years of Solitude\\"]) [\\"An Apple a Day\\", \\"The Brothers Karamazov\\", \\"One Hundred Years of Solitude\\", \\"Rise of the Planet of the Apes\\", \\"A Study in Scarlet\\"] >>> sort_book_titles(5, [\\"The\\", \\"A\\", \\"An\\", \\"B\\", \\"C\\"]) [\\"A\\", \\"An\\", \\"B\\", \\"C\\", \\"The\\"]","solution":"def sort_book_titles(t, titles): Sort book titles ignoring leading articles (\\"a\\", \\"an\\", \\"the\\"). Parameters: t (int): The number of book titles. titles (list of str): List of book titles. Returns: list of str: Alphabetically sorted list of book titles ignoring leading articles. def article_strip(title): articles = [\\"a \\", \\"an \\", \\"the \\"] title_lower = title.lower() for article in articles: if title_lower.startswith(article): return (title_lower[len(article):], title) return (title_lower, title) sorted_titles = sorted(titles, key=article_strip) return sorted_titles"},{"question":"def max_sum_after_one_operation(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns the maximum possible value of the sum obtained after performing the described operation for each test case. Each test case contains: - n: the number of elements in the array. - array: the array of positive integers. :param t: int, number of test cases. :param test_cases: list of tuples, each tuple contains (n, array) for each test case. :return: list of int, the maximum possible sums for each test case. >>> max_sum_after_one_operation(2, [(3, [1, 2, 3]), (4, [10, 20, 30, 40])]) [5, 70] >>> max_sum_after_one_operation(1, [(3, [5, 5, 5])]) [10] >>> max_sum_after_one_operation(1, [(4, [1000000, 999999, 1, 2])]) [1999999] def parse_input(input_str: str) -> Tuple[int, List[Tuple[int, List[int]]]]: Parses the input string and returns number of test cases and a list of test cases. Each test case contains: - n: the number of elements in the array. - array: the array of positive integers. :param input_str: str, the input string. :return: tuple, containing: - int, number of test cases, - list of tuples, each tuple contains (n, array) for each test case. >>> parse_input(\\"2n3n1 2 3n4n10 20 30 40\\") (2, [(3, [1, 2, 3]), (4, [10, 20, 30, 40])])","solution":"def max_sum_after_one_operation(t, test_cases): Returns the maximum possible value of the sum obtained after performing the described operation for each test case. :param t: int, number of test cases :param test_cases: list of tuples, each tuple contains (n, array) for each test case :return: list of int, maximum possible sums for each test case results = [] for n, arr in test_cases: # The maximum sum after one operation is obtained by taking the two largest numbers' sum. arr.sort() max_sum = arr[-1] + arr[-2] results.append(max_sum) return results # Helper function to parse input if needed def parse_input(input_str): lines = input_str.strip().split('n') t = int(lines[0]) test_cases = [] line_index = 1 for _ in range(t): n = int(lines[line_index]) array = list(map(int, lines[line_index + 1].split())) test_cases.append((n, array)) line_index += 2 return t, test_cases"},{"question":"from typing import List def min_teams(N: int, K: int, skill_levels: List[int]) -> int: Alice is organizing a coding competition. She wants to ensure that the participants are assigned unique teams and that no team has more than one participant who belongs to the same skill level. >>> min_teams(6, 3, [1, 2, 3, 1, 2, 3]) 2 >>> min_teams(8, 5, [1, 1, 2, 2, 3, 3, 4, 5]) 4 >>> min_teams(4, 1, [1, 1, 1, 1]) 4 >>> min_teams(5, 5, [1, 2, 3, 4, 5]) 1 >>> min_teams(100, 10, [i % 10 + 1 for i in range(100)]) 10 >>> min_teams(1, 1, [1]) 1 >>> min_teams(10, 3, [3, 3, 2, 2, 1, 1, 3, 2, 1, 3]) 4","solution":"def min_teams(N, K, skill_levels): from collections import Counter # Count the number of participants for each skill level skill_count = Counter(skill_levels) # The minimum number of teams required is the maximum count of any skill level max_count = max(skill_count.values()) return max_count if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) K = int(data[1]) skill_levels = list(map(int, data[2:])) print(min_teams(N, K, skill_levels))"},{"question":"def find_max_length(nums: List[int]) -> int: Returns the length of the longest contiguous subarray with equal number of 0s and 1s. >>> find_max_length([0, 1, 0, 1, 0, 1, 1]) 6 >>> find_max_length([0, 0, 1, 1, 0]) 4","solution":"def find_max_length(nums): Returns the length of the longest contiguous subarray with equal number of 0s and 1s. count_map = {0: -1} max_length = 0 count = 0 for i, num in enumerate(nums): count += 1 if num == 1 else -1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"def min_operations_to_transform_array(T, test_cases): Determine the minimum number of operations required to transform the array such that each integer in the array is twice as large as the preceding integer. Returns -1 if it is not possible. # Your code here def parse_input(input_string): Parse the input string and return the number of test cases and a list of test case details. # Your code here # Example Usage: input_string = 2 3 4 8 16 4 1 2 8 16 T, test_cases = parse_input(input_string) results = min_operations_to_transform_array(T, test_cases) for result in results: print(result)","solution":"def min_operations_to_transform_array(T, test_cases): def can_transform(arr): operations = 0 for i in range(1, len(arr)): if arr[i] != 2 * arr[i-1]: if arr[i] % 2 == 0 and (arr[i] // 2 >= arr[i-1] or arr[i] * 2 <= arr[i-1]): cur = arr[i] while cur != 2 * arr[i-1]: if cur < 2 * arr[i-1]: cur *= 2 else: cur //= 2 operations += 1 arr[i] = cur else: return -1 return operations results = [] for test_case in test_cases: N = test_case[0] arr = test_case[1] result = can_transform(arr) results.append(result) return results def parse_input(input_string): input_lines = input_string.strip().split(\\"n\\") T = int(input_lines[0]) test_cases = [] idx = 1 for _ in range(T): N = int(input_lines[idx]) arr = list(map(int, input_lines[idx + 1].split())) test_cases.append((N, arr)) idx += 2 return T, test_cases # Example Usage: input_string = 2 3 4 8 16 4 1 2 8 16 T, test_cases = parse_input(input_string) results = min_operations_to_transform_array(T, test_cases) for result in results: print(result)"},{"question":"from typing import List, Tuple class Tree: def __init__(self, n, values, edges): self.n = n self.values = values[:] self.adj = [[] for _ in range(n + 1)] for u, v in edges: self.adj[u].append(v) self.adj[v].append(u) self.subtree_sum = [0] * (n + 1) self.subtree_max_sum = [0] * (n + 1) self.dfs(1, -1) def dfs(self, node, parent): self.subtree_sum[node] = self.values[node - 1] max_single_child = 0 second_max_single_child = 0 for neighbor in self.adj[node]: if neighbor == parent: continue self.dfs(neighbor, node) child_sum = self.subtree_sum[neighbor] max_single_child = max(max_single_child, child_sum) self.subtree_sum[node] += max_single_child self.subtree_max_sum[node] = max(self.subtree_sum[node], max_single_child + second_max_single_child + self.values[node - 1]) def update_value(self, u, v): Update the value of the u-th node to v self.values[u - 1] = v self.dfs(1, -1) def find_max_path_sum(self): Find the maximum path sum between any two nodes in the tree return max(self.subtree_max_sum) def solve(n: int, q: int, values: List[int], edges: List[Tuple[int, int]], queries: List[Tuple[int, ...]]) -> List[int]: You are given a tree with N nodes. Each node has a value, such that the value of the i-th node is A[i]. There are Q queries and each query can be of two types: - Type 1: Change the value of a node to a given number. - Type 2: Find the maximum path sum between any two nodes in the tree. Args: n (int): Number of nodes in the tree q (int): Number of queries values (List[int]): Values of the nodes edges (List[Tuple[int, int]]): Edges of the tree queries (List[Tuple[int, ...]]): List of tuples representing the queries Returns: List[int]: The response to each query of type 2 >>> solve(5, 3, [1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)], [(2,), (1, 3, 10), (2,)]) [15, 22] >>> solve(1, 1, [5], [], [(2,)]) [5] tree = Tree(n, values, edges) result = [] for query in queries: if query[0] == 1: u, v = query[1], query[2] tree.update_value(u, v) elif query[0] == 2: result.append(tree.find_max_path_sum()) return result","solution":"class Tree: def __init__(self, n, values, edges): self.n = n self.values = values[:] self.adj = [[] for _ in range(n + 1)] for u, v in edges: self.adj[u].append(v) self.adj[v].append(u) self.subtree_sum = [0] * (n + 1) self.subtree_max_sum = [0] * (n + 1) self.dfs(1, -1) def dfs(self, node, parent): self.subtree_sum[node] = self.values[node - 1] max_single_child = 0 second_max_single_child = 0 for neighbor in self.adj[node]: if neighbor == parent: continue self.dfs(neighbor, node) child_sum = self.subtree_sum[neighbor] max_single_child = max(max_single_child, child_sum) self.subtree_sum[node] += max_single_child self.subtree_max_sum[node] = max(self.subtree_sum[node], max_single_child + second_max_single_child + self.values[node - 1]) def update_value(self, u, v): self.values[u - 1] = v self.dfs(1, -1) def find_max_path_sum(self): return max(self.subtree_max_sum) def solve(n, q, values, edges, queries): tree = Tree(n, values, edges) result = [] for query in queries: if query[0] == 1: u, v = query[1], query[2] tree.update_value(u, v) elif query[0] == 2: result.append(tree.find_max_path_sum()) return result"},{"question":"def capitalize_words(input_string: str) -> str: Returns the input string with the first letter of each word capitalized. >>> capitalize_words(\\"the quick brown fox\\") \\"The Quick Brown Fox\\" >>> capitalize_words(\\"the QUICK bRoWn fOx\\") \\"The QUICK BRoWn FOx\\" >>> capitalize_words(\\"hello\\") \\"Hello\\" >>> capitalize_words(\\"\\") \\"\\" >>> capitalize_words(\\"The Quick Brown Fox\\") \\"The Quick Brown Fox\\" >>> capitalize_words(\\"hello, world!\\") \\"Hello, World!\\" >>> capitalize_words(\\" hellotworld \\") \\"Hello World\\"","solution":"def capitalize_words(input_string): Returns the input string with the first letter of each word capitalized. words = input_string.split() capitalized_words = [word[0].upper() + word[1:] for word in words] return ' '.join(capitalized_words)"},{"question":"import math def maximum_distance_to_fountain(R: int) -> float: Returns the maximum distance from any point on the boundary of the semi-circle to the optimal position of the fountain located inside the semi-circle. >>> abs(maximum_distance_to_fountain(1) - 1.414213) <= 1e-6 True >>> abs(maximum_distance_to_fountain(10) - 14.142136) <= 1e-6 True >>> abs(maximum_distance_to_fountain(1000000) - 1414213.562373) <= 1e-6 True >>> abs(maximum_distance_to_fountain(1) - 1.414213) <= 1e-6 True","solution":"import math def maximum_distance_to_fountain(R): Returns the maximum distance from any point on the boundary of the semi-circle to the optimal position of the fountain located inside the semi-circle. # For a semi-circle park of radius R, the optimal position of the fountain is at the origin (0, 0) # The maximum distance from the boundary to the origin will be the distance from either # any point on the arc to the origin or from the straight line to the origin. # The distance from the arc to the origin is R. # The distance from any point on the straight line (from -R to R) on x-axis to the origin is R * sqrt(2) # Hence the maximum distance is R * sqrt(2) max_distance = R * math.sqrt(2) return max_distance"},{"question":"def bamboo_to_decimal(bamboo_number: str) -> int: Converts a Bamboo Decimal System number into a regular decimal number. >>> bamboo_to_decimal(\\"A|B\\") == 12 >>> bamboo_to_decimal(\\"C|A|A\\") == 311 >>> bamboo_to_decimal(\\"B|B|C|A\\") == 2231 pass def bamboo_decimal_converter(test_cases: List[str]) -> List[int]: Converts multiple Bamboo Decimal System numbers to regular decimal numbers. >>> bamboo_decimal_converter([\\"A|B\\", \\"C|A|A\\", \\"B|B|C|A\\"]) == [12, 311, 2231] >>> bamboo_decimal_converter([\\"A\\", \\"B\\", \\"C\\", \\"A|A\\"]) == [1, 2, 3, 11] pass","solution":"def bamboo_to_decimal(bamboo_number): Converts a Bamboo Decimal System number into a regular decimal number. Parameters: bamboo_number (str): Bamboo number with digits separated by '|' Returns: int: decimal number equivalent # Mapping of Bamboo digits to decimal digits bamboo_map = {'A': '1', 'B': '2', 'C': '3'} # Split the bamboo_number by '|' bamboo_digits = bamboo_number.split('|') # Convert each digit using the mapping and join to form a decimal number decimal_number = ''.join(bamboo_map[digit] for digit in bamboo_digits) return int(decimal_number) def bamboo_decimal_converter(test_cases): Converts multiple Bamboo Decimal System numbers to regular decimal numbers. Parameters: test_cases (list): List of Bamboo numbers (each a string) Returns: list: List of integers representing the decimal conversion of each Bamboo number return [bamboo_to_decimal(bamboo_number) for bamboo_number in test_cases]"},{"question":"def generate_diamond(n: int) -> List[str]: Create a function to generate a series of strings representing a diamond shape, centered in a square grid. The size of the diamond is determined by an odd integer \`n\`, which is the length of one side of the grid. The sides of the grid should be \`n\` characters long. The diamond is made up of \`'*'\` characters centered in the grid. The diamond should start with one \`'*'\` character at the center of the grid, then expand outwards by placing additional \`'*'\` characters until reaching the width of \`n\` characters at the widest point (the middle row). Then, it should symmetrically reduce the number of \`'*'\` characters until reaching one \`'*'\` character again. Empty spaces should be filled with the whitespace character \`' '\`. >>> generate_diamond(1) ['*'] >>> generate_diamond(3) [' * ', '***', ' * '] >>> generate_diamond(5) [' * ', ' *** ', '*****', ' *** ', ' * '] >>> generate_diamond(7) [' * ', ' *** ', ' ***** ', '*******', ' ***** ', ' *** ', ' * '] >>> generate_diamond(9) [' * ', ' *** ', ' ***** ', ' ******* ', '*********', ' ******* ', ' ***** ', ' *** ', ' * '] pass","solution":"def generate_diamond(n: int): diamond = [] for i in range(n): if i <= n // 2: stars = '*' * (2 * i + 1) else: stars = '*' * (2 * (n - i - 1) + 1) row = stars.center(n) diamond.append(row) return diamond"},{"question":"def minimum_operations_to_equalize_water(n, water_levels): Given n plants and their current water levels, this function returns the minimum number of operations needed to make all the plants' water levels equal. :param n: int - Number of plants :param water_levels: List[int] - List of initial water levels for each plant :return: int - Minimum number of operations needed to equalize water levels >>> minimum_operations_to_equalize_water(4, [2, 3, 1, 5]) 5 >>> minimum_operations_to_equalize_water(3, [4, 4, 4]) 0 >>> minimum_operations_to_equalize_water(3, [100000, 100000, 100000]) 0 >>> minimum_operations_to_equalize_water(1, [5]) 0 >>> minimum_operations_to_equalize_water(3, [1, 2, 3]) 2 >>> minimum_operations_to_equalize_water(3, [3, 2, 1]) 2","solution":"def minimum_operations_to_equalize_water(n, water_levels): Given n plants and their current water levels, this function returns the minimum number of operations needed to make all the plants' water levels equal. :param n: int - Number of plants :param water_levels: List[int] - List of initial water levels for each plant :return: int - Minimum number of operations needed to equalize water levels median_level = sorted(water_levels)[n // 2] return sum(abs(level - median_level) for level in water_levels)"},{"question":"def is_beautiful(arr): Returns \\"Yes\\" if the sequence of mountain heights is beautiful, otherwise \\"No\\". A sequence is beautiful if it strictly increases and then strictly decreases with exactly one peak. >>> is_beautiful([1, 2, 3, 1, 0]) \\"Yes\\" >>> is_beautiful([1, 2, 4, 3, 2, 1]) \\"Yes\\" >>> is_beautiful([1, 3, 2]) \\"Yes\\" >>> is_beautiful([1, 3, 3, 2, 1]) \\"No\\" def mountain_sequence_testcases(testcases): Processes multiple testcases and returns the results for each. >>> mountain_sequence_testcases([ ... (5, [1, 2, 3, 1, 0]), ... (6, [1, 2, 4, 3, 2, 1]), ... (3, [1, 3, 2]), ... (5, [1, 3, 3, 2, 1]) ...]) [\\"Yes\\", \\"Yes\\", \\"Yes\\", \\"No\\"]","solution":"def is_beautiful(arr): Returns \\"Yes\\" if the sequence of mountains heights is beautiful, otherwise \\"No\\". A sequence is beautiful if it strictly increases and then strictly decreases with exactly one peak. n = len(arr) if n < 3: return \\"No\\" peak_found = False for i in range(1, n): if arr[i] == arr[i - 1]: return \\"No\\" elif arr[i] > arr[i - 1]: if peak_found: return \\"No\\" elif arr[i] < arr[i - 1]: if i == 1: # Peak can't be the first element return \\"No\\" peak_found = True return \\"Yes\\" if peak_found else \\"No\\" def mountain_sequence_testcases(testcases): Processes multiple testcases and returns the results for each. results = [] for n, heights in testcases: results.append(is_beautiful(heights)) return results"},{"question":"from typing import List from math import gcd from functools import reduce def min_operations_to_make_equal(arr: List[int]) -> int: Returns the minimum number of operations required to make all elements of the array equal. An operation consists of choosing any pair of adjacent elements and replacing both of them with gcd(x, y). >>> min_operations_to_make_equal([12, 15, 18]) 2 >>> min_operations_to_make_equal([5, 5, 5, 5]) 0","solution":"from math import gcd from functools import reduce def min_operations_to_make_equal(arr): Returns the minimum number of operations required to make all elements of the array equal. An operation consists of choosing any pair of adjacent elements and replacing both of them with gcd(x, y). def array_gcd(array): return reduce(gcd, array) n = len(arr) if n == 1: return 0 overall_gcd = array_gcd(arr) # Check if array is already uniform if all(x == overall_gcd for x in arr): return 0 return n - 1"},{"question":"def find_winner(M: int, student_problems: List[Tuple[int, List[int]]]) -> int: Determines the student who solved the maximum number of unique problems. Args: - M (int): Number of students. - student_problems (list): List of tuples, where each tuple consists of a student's ID and a list of problems solved by the student. Returns: - int: The ID of the student who solved the maximum number of unique problems. >>> find_winner(3, [(101, [1, 2, 3, 1, 4]), (102, [2, 3, 4]), (103, [1, 2, 1, 2])]) 101 >>> find_winner(2, [(101, [1, 2, 3]), (102, [3, 4, 5])]) 101 # Test function def test_find_winner(): assert find_winner(3, [(101, [1, 2, 3, 1, 4]), (102, [2, 3, 4]), (103, [1, 2, 1, 2])]) == 101 assert find_winner(2, [(101, [1, 2, 3]), (102, [3, 4, 5])]) == 101 assert find_winner(2, [(101, [1, 2, 3, 4]), (102, [1, 2, 3, 4])]) == 101 assert find_winner(3, [(101, [1, 2]), (102, [1]), (103, [1, 2, 3, 4])]) == 103 assert find_winner(1, [(101, [1, 2, 2, 3, 4, 4])]) == 101 test_find_winner()","solution":"def find_winner(M, student_problems): Determines the student who solved the maximum number of unique problems. Args: - M (int): Number of students. - student_problems (list): List of tuples, where each tuple consists of a student's ID and a list of problems solved by the student. Returns: - int: The ID of the student who solved the maximum number of unique problems. max_unique = 0 winner_id = None for student_id, problems in student_problems: unique_problems = len(set(problems)) if (unique_problems > max_unique) or (unique_problems == max_unique and student_id < winner_id): max_unique = unique_problems winner_id = student_id return winner_id"},{"question":"class LRUCache: A class representing a Least Recently Used (LRU) Cache. Args: - capacity (int): The maximum capacity of the cache. Methods: - get(self, key: int) -> int: Returns the value of the key if it exists, otherwise returns -1. - put(self, key: int, value: int) -> None: Updates the key value if exists, otherwise adds the key-value to the cache and evicts the least recently used item if needed. >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) 1 >>> cache.put(3, 3) >>> cache.get(2) -1 >>> cache.put(4, 4) >>> cache.get(1) -1 >>> cache.get(3) 3 >>> cache.get(4) 4 def process_commands(capacity, commands): Process a sequence of commands for LRU Cache. Args: - capacity (int): The maximum capacity of the cache. - commands (List[str]): A list of commands to process. Returns: - result (List[int]): Results of \`get\` commands. Unit Test: >>> commands = [ ... \\"put 1 1\\", ... \\"put 2 2\\", ... \\"get 1\\", ... \\"put 3 3\\", ... \\"get 2\\", ... \\"put 4 4\\", ... \\"get 1\\", ... \\"get 3\\", ... \\"get 4\\" ... ] >>> process_commands(2, commands) [1, -1, -1, 3, 4] >>> commands = [ ... \\"put 1 1\\", ... \\"put 2 2\\", ... \\"put 3 3\\", ... \\"put 4 4\\", ... \\"get 1\\", ... \\"get 3\\", ... \\"get 4\\" ... ] >>> process_commands(2, commands) [-1, 3, 4] >>> commands = [ ... \\"put 1 1\\", ... \\"put 2 2\\", ... \\"put 1 10\\", ... \\"get 1\\", ... \\"get 2\\" ... ] >>> process_commands(2, commands) [10, 2] >>> commands = [ ... \\"put 1 1\\", ... \\"put 2 2\\", ... \\"get 1\\", ... \\"get 2\\" ... ] >>> process_commands(1, commands) [-1, 2]","solution":"class LRUCache: def __init__(self, capacity: int): self.cache = {} self.capacity = capacity self.order = [] def get(self, key: int) -> int: if key in self.cache: # Refresh the key as it is recently used self.order.remove(key) self.order.append(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: if key in self.cache: # Update existing key and mark it as recently used self.cache[key] = value self.order.remove(key) self.order.append(key) else: if len(self.cache) >= self.capacity: # Evict the least recently used item lru_key = self.order.pop(0) del self.cache[lru_key] # Add new key-value pair self.cache[key] = value self.order.append(key) def process_commands(capacity, commands): result = [] cache = LRUCache(capacity) for command in commands: cmd = command.split() if cmd[0] == 'get': result.append(cache.get(int(cmd[1]))) elif cmd[0] == 'put': cache.put(int(cmd[1]), int(cmd[2])) return result"},{"question":"from typing import List def running_sum(input_list: List[int]) -> List[int]: Takes a list of integers and returns a list containing the running sum. Examples: >>> running_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> running_sum([10, 20, 30, 40]) [10, 30, 60, 100] >>> running_sum([5]) [5] >>> running_sum([]) [] >>> running_sum([0, 0, 0, 0]) [0, 0, 0, 0] >>> running_sum([1, -2, 3, -4]) [1, -1, 2, -2] >>> running_sum([-1, -2, -3, -4]) [-1, -3, -6, -10] >>> running_sum([10**6, 10**6, 10**6]) [10**6, 2*10**6, 3*10**6]","solution":"from typing import List def running_sum(input_list: List[int]) -> List[int]: Takes a list of integers and returns a list containing the running sum. if not input_list: return [] running_total = 0 running_sums = [] for num in input_list: running_total += num running_sums.append(running_total) return running_sums"},{"question":"from typing import List def rearrange_list(arr: List[int]) -> List[int]: Rearranges the integers in the list such that no two adjacent integers are the same. If not possible, returns an empty list. >>> rearrange_list([1, 1, 2]) [1, 2, 1] >>> rearrange_list([1, 1, 1, 2]) [] >>> rearrange_list([4, 5, 5, 4]) [5, 4, 5, 4] >>> rearrange_list([1]) [1] >>> rearrange_list([1, 2, 1, 2]) [1, 2, 1, 2]","solution":"from collections import Counter from heapq import heappush, heappop def rearrange_list(arr): Rearranges the integers in the list such that no two adjacent integers are the same. If not possible, returns an empty list. if not arr: return [] counter = Counter(arr) max_heap = [] for num, freq in counter.items(): heappush(max_heap, (-freq, num)) prev_freq, prev_num = 0, None result = [] while max_heap: freq, num = heappop(max_heap) result.append(num) if prev_freq < 0: heappush(max_heap, (prev_freq, prev_num)) prev_freq, prev_num = freq + 1, num if len(result) != len(arr): return [] return result"},{"question":"def find_subarray_with_avg(nums, k, target): Determines if there exists a subarray of length k in nums such that the average of that subarray equals target. Returns the starting index if such subarray exists, otherwise returns -1. >>> find_subarray_with_avg([1, 2, 3, 4, 5, 6], 3, 4) 2 >>> find_subarray_with_avg([1, 1, 1, 1, 1, 1], 3, 2) -1 >>> find_subarray_with_avg([3, 3, 3, 3, 3, 3], 2, 3) 0 >>> find_subarray_with_avg([1, 2, 3, 4, 5, 6], 2, 5.5) 4 >>> find_subarray_with_avg([3, 3, 3, 3], 4, 3) 0","solution":"def find_subarray_with_avg(nums, k, target): Determines if there exists a subarray of length k in nums such that the average of that subarray equals target. Returns the starting index if such subarray exists, otherwise returns -1. n = len(nums) target_sum = target * k current_sum = sum(nums[:k]) if current_sum == target_sum: return 0 for i in range(1, n - k + 1): current_sum = current_sum - nums[i - 1] + nums[i + k - 1] if current_sum == target_sum: return i return -1"},{"question":"def max_subarray_sum(nums): Finds the continuous subarray with the maximum sum and returns that value. Parameters: nums (List[int]): The list of integers representing the number of vehicles passing through a certain checkpoint over a series of hours. Returns: int: The maximum sum of a continuous subarray. Example: >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23","solution":"def max_subarray_sum(nums): Finds the continuous subarray with the maximum sum and returns that value. Parameters: nums (List[int]): The list of integers representing the number of vehicles passing through a certain checkpoint over a series of hours. Returns: int: The maximum sum of a continuous subarray. max_sum = nums[0] current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def next_state(initial_state: str) -> str: Returns the next state of Lavaland given the initial state according to the Volcanoverse mechanism. 'V' remains 'V', and 'L' turns into 'V' if it is adjacent to at least one 'V'. >>> next_state('VVLVLLLV') 'VVVVVVVV' >>> next_state('LLLL') 'LLLL' >>> next_state('LVLV') 'VVVV'","solution":"def next_state(initial_state: str) -> str: Returns the next state of Lavaland given the initial state according to the Volcanoverse mechanism. 'V' remains 'V', and 'L' turns into 'V' if it is adjacent to at least one 'V'. n = len(initial_state) next_state = list(initial_state) for i in range(n): if initial_state[i] == 'L': if (i > 0 and initial_state[i - 1] == 'V') or (i < n - 1 and initial_state[i + 1] == 'V'): next_state[i] = 'V' return ''.join(next_state)"},{"question":"def longest_string(strings: List[str]) -> str: Returns the longest string from the array of strings. If there are multiple strings of the same maximum length, return the first one that appears. If the array is empty, return an empty string. >>> longest_string([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) == \\"banana\\" >>> longest_string([]) == \\"\\"","solution":"def longest_string(strings): Returns the longest string from the array of strings. If there are multiple strings of the same maximum length, return the first one that appears. If the array is empty, return an empty string. if not strings: return \\"\\" return max(strings, key=len)"},{"question":"def unique_paths(grid: List[List[int]]) -> int: Find the number of unique paths from the top-left corner to the bottom-right corner of the grid, avoiding obstacles. Parameters: grid (List[List[int]]): A 2D grid where 0 represents an empty cell and 1 represents an obstacle. Returns: int: The number of unique paths from the top-left to the bottom-right of the grid. Examples: >>> unique_paths([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths([[0, 1], [0, 0]]) 1 pass import pytest def test_example_cases(): assert unique_paths([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 2 assert unique_paths([[0, 1], [0, 0]]) == 1 def test_no_obstacles(): assert unique_paths([[0, 0], [0, 0]]) == 2 assert unique_paths([[0, 0, 0], [0, 0, 0]]) == 3 def test_all_obstacles(): assert unique_paths([[1, 1], [1, 1]]) == 0 assert unique_paths([[0, 1], [1, 1]]) == 0 def test_single_path(): assert unique_paths([[0, 0, 1], [0, 1, 0], [0, 0, 0]]) == 1 def test_large_grid(): large_grid = [[0]*1000 for _ in range(1000)] assert unique_paths(large_grid) > 0 # There should be at least one path # Run the tests if __name__ == '__main__': pytest.main()","solution":"def unique_paths(grid): n = len(grid) m = len(grid[0]) if grid[0][0] == 1 or grid[n-1][m-1] == 1: return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 0: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1]"},{"question":"def total_price(items: List[Dict[str, Any]], promotions: Dict[str, int]) -> int: Calculate the total price for the list of items after applying the discounts to each item. Round the total price to the nearest whole cent. - If an item does not have any promotional discount, its discount should be considered \`0\`. - If the list of items is empty, return \`0\`. :param items: List of dictionaries with \\"name\\" and \\"price\\" in cents :param promotions: Dictionary with item names as keys and discount percentages as values :return: Total price after applying discounts >>> total_price([{\\"name\\": \\"apple\\", \\"price\\": 100}, {\\"name\\": \\"banana\\", \\"price\\": 150}], {\\"apple\\": 10, \\"banana\\": 20}) == 210 >>> total_price([], {}) == 0 >>> total_price([{\\"name\\": \\"apple\\", \\"price\\": 100}, {\\"name\\": \\"banana\\", \\"price\\": 150}], {}) == 250 from typing import List, Dict, Any def test_no_items(): assert total_price([], {}) == 0 def test_no_promotions(): items = [ {\\"name\\": \\"apple\\", \\"price\\": 100}, {\\"name\\": \\"banana\\", \\"price\\": 150} ] assert total_price(items, {}) == 250 def test_full_promotions(): items = [ {\\"name\\": \\"apple\\", \\"price\\": 100}, {\\"name\\": \\"banana\\", \\"price\\": 150}, {\\"name\\": \\"cherry\\", \\"price\\": 200} ] promotions = { \\"apple\\": 10, \\"banana\\": 20, \\"cherry\\": 15 } assert total_price(items, promotions) == 380 def test_partial_promotions(): items = [ {\\"name\\": \\"apple\\", \\"price\\": 100}, {\\"name\\": \\"banana\\", \\"price\\": 150}, {\\"name\\": \\"cherry\\", \\"price\\": 200} ] promotions = { \\"apple\\": 10, \\"banana\\": 20 } assert total_price(items, promotions) == 410 # 90 + 120 + 200 def test_mixed_case_items(): items = [ {\\"name\\": \\"Apple\\", \\"price\\": 100}, {\\"name\\": \\"Banana\\", \\"price\\": 150}, {\\"name\\": \\"CHERRY\\", \\"price\\": 200} ] promotions = { \\"apple\\": 10, \\"banana\\": 20, \\"cherry\\": 15 } # Here, the case does not match any discount because promotions has lower case keys assert total_price(items, promotions) == 450 def test_edge_case_large_numbers(): items = [ {\\"name\\": \\"diamond\\", \\"price\\": 1000000}, {\\"name\\": \\"gold\\", \\"price\\": 500000} ] promotions = { \\"diamond\\": 50, \\"gold\\": 75 } assert total_price(items, promotions) == 625000 # 500000 + 125000","solution":"def total_price(items, promotions): Calculate the total price of the items after applying the discounts. Each discount is given as a percentage. If there is no discount, it is assumed to be 0. :param items: List of dictionaries with \\"name\\" and \\"price\\" :param promotions: Dictionary with item names as keys and discount percentages as values :return: Total price after applying discounts, rounded to the nearest whole cent total = 0 for item in items: item_name = item[\\"name\\"] item_price = item[\\"price\\"] discount = promotions.get(item_name, 0) / 100 discounted_price = item_price * (1 - discount) total += discounted_price return round(total)"},{"question":"def file_merge_operation(input_str: str) -> str: Implement a File Merge Operation. First line contains T - Number of test cases. Each test case contains two positive integers N and M followed by a list of N integers and a list of M integers. Output a single sorted list for each test case. 1 ≤ T ≤ 200 1 ≤ N, M ≤ 100 -1000 ≤ integer values in the list ≤ 1000 >>> file_merge_operation(\\"2n3 3n12 11 5n6 2 14n4 4n-1 0 1 0n3 -4 2 5\\") \\"2 5 6 11 12 14n-4 -1 0 0 1 2 3 5\\" >>> file_merge_operation(\\"1n3 3n-12 -11 -5n-6 -2 -14\\") \\"-14 -12 -11 -6 -5 -2\\" >>> file_merge_operation(\\"1n3 3n12 -11 5n-6 2 14\\") \\"-11 -6 2 5 12 14\\" >>> file_merge_operation(\\"1n3 3n1 2 3n3 2 1\\") \\"1 1 2 2 3 3\\"","solution":"def merge_and_sort_arrays(test_cases): results = [] for case in test_cases: N, M, list1, list2 = case merged_list = list1 + list2 merged_list.sort() results.append(merged_list) return results def parse_input(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): N, M = map(int, input_lines[index].strip().split()) list1 = list(map(int, input_lines[index + 1].strip().split())) list2 = list(map(int, input_lines[index + 2].strip().split())) test_cases.append((N, M, list1, list2)) index += 3 return test_cases def format_output(results): return 'n'.join(' '.join(map(str, result)) for result in results) def file_merge_operation(input_str): test_cases = parse_input(input_str) results = merge_and_sort_arrays(test_cases) return format_output(results)"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with unique characters in the given string. >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"aab\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with unique characters in the given string. char_set = set() l = 0 result = 0 for r in range(len(s)): while s[r] in char_set: char_set.remove(s[l]) l += 1 char_set.add(s[r]) result = max(result, r - l + 1) return result"},{"question":"def are_rectangles_overlapping(x_bl_A, y_bl_A, x_tr_A, y_tr_A, x_bl_B, y_bl_B, x_tr_B, y_tr_B): Determines if two rectangles A and B overlap. Each rectangle is represented by its bottom-left (x_bl, y_bl) and top-right (x_tr, y_tr) coordinates. Returns 1 if the rectangles overlap, otherwise returns 0. >>> are_rectangles_overlapping(0, 0, 2, 2, 1, 1, 3, 3) 1 >>> are_rectangles_overlapping(0, 0, 1, 1, 2, 2, 3, 3) 0 pass def check_overlap(datasets): For each dataset of rectangle coordinates, determines if the two rectangles overlap by calling the are_rectangles_overlapping function. Returns a list of 1s or 0s for each dataset. >>> datasets = [ ... (0.0, 0.0, 2.0, 2.0, 1.0, 1.0, 3.0, 3.0), ... (0.0, 0.0, 1.0, 1.0, 2.0, 2.0, 3.0, 3.0), ... (1.0, 1.0, 4.0, 4.0, 3.0, 3.0, 5.0, 5.0), ... (0.0, 0.0, 2.0, 2.0, -1.0, -1.0, 1.5, 1.5) ... ] >>> check_overlap(datasets) [1, 0, 1, 1] pass","solution":"def are_rectangles_overlapping(x_bl_A, y_bl_A, x_tr_A, y_tr_A, x_bl_B, y_bl_B, x_tr_B, y_tr_B): Determines if two rectangles A and B overlap. Each rectangle is represented by its bottom-left (x_bl, y_bl) and top-right (x_tr, y_tr) coordinates. Returns 1 if the rectangles overlap, otherwise returns 0. # If one rectangle is to the left of the other if x_tr_A < x_bl_B or x_tr_B < x_bl_A: return 0 # If one rectangle is above the other if y_tr_A < y_bl_B or y_tr_B < y_bl_A: return 0 return 1 def check_overlap(datasets): results = [] for data in datasets: results.append(are_rectangles_overlapping(*data)) return results"},{"question":"def longest_consecutive_sequence(arr): Returns the length of the longest sequence of consecutive integers in the list arr. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([1, 9, 3, 10, 4, 20, 2]) 4 >>> longest_consecutive_sequence([1, 2, 2, 3]) 3 >>> longest_consecutive_sequence([5, 6, 100, 400, 401, 402]) 3 >>> longest_consecutive_sequence([1]) 1 >>> longest_consecutive_sequence([-1, -2, -3, -4]) 4 >>> longest_consecutive_sequence([1000000000, -1000000000, 0]) 1 >>> longest_consecutive_sequence([1, 2, 0, -1, -2]) 5 >>> longest_consecutive_sequence([-5, -4, -3, -2, -1]) 5 >>> longest_consecutive_sequence([1, 1, 1, 1]) 1 >>> longest_consecutive_sequence([1, 2, 2, 3, 3, 4]) 4","solution":"def longest_consecutive_sequence(arr): Returns the length of the longest sequence of consecutive integers in the list arr. if not arr: return 0 num_set = set(arr) longest_length = 0 for num in arr: if num - 1 not in num_set: current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 longest_length = max(longest_length, current_length) return longest_length"},{"question":"def roman_to_integer(roman: str) -> int: Convert a Roman numeral to an integer. Returns -1 if the input is not a valid Roman numeral. >>> roman_to_integer('III') 3 >>> roman_to_integer('IV') 4 >>> roman_to_integer('IX') 9 >>> roman_to_integer('LVIII') 58 >>> roman_to_integer('MCMXCIV') 1994 >>> roman_to_integer('MMMCMXCIX') 3999 >>> roman_to_integer('IIII') -1 >>> roman_to_integer('VV') -1 >>> roman_to_integer('ABCD') -1 >>> roman_to_integer('MMMMM') -1","solution":"def roman_to_integer(roman): Convert a Roman numeral to an integer. Returns -1 if the input is not a valid Roman numeral. roman_values = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } valid_roman_characters = set(roman_values.keys()) invalid_conditions = [ lambda r: any(char not in valid_roman_characters for char in r), lambda r: r.count('I') > 3 or r.count('X') > 3 or r.count('C') > 3, lambda r: r.count('V') > 1 or r.count('L') > 1 or r.count('D') > 1, ] if any(condition(roman) for condition in invalid_conditions): return -1 integer_value = 0 prev_value = 0 for char in reversed(roman): value = roman_values[char] if value < prev_value: integer_value -= value else: integer_value += value prev_value = value return integer_value if 0 < integer_value <= 3999 else -1"},{"question":"def simplify_text(dictionary_entries, text_words): Simplifies the given text using the dictionary of synonyms. Parameters: dictionary_entries (list of tuples): List of (original_word, synonym) pairs. text_words (list of str): List of words in the text to be simplified. Returns: str: Simplified text as a single line. pass # Example usage: # Input: # 5 # difficult hard # easy simple # complicated complex # smart clever # fast quick # 10 # this is a difficult test with some complicated and smart questions to answer fast # # Output: # this is a hard test with some complex and clever questions to answer quick","solution":"def simplify_text(dictionary_entries, text_words): Simplifies the given text using the dictionary of synonyms. Parameters: dictionary_entries (list of tuples): List of (original_word, synonym) pairs. text_words (list of str): List of words in the text to be simplified. Returns: str: Simplified text as a single line. dictionary = dict(dictionary_entries) simplified_text = [] for word in text_words: if word in dictionary: simplified_text.append(dictionary[word]) else: simplified_text.append(word) return ' '.join(simplified_text)"},{"question":"import math def sum_of_factorial_digits(n: int) -> int: Computes the sum of the digits of the factorial of n. n (int): The non-negative integer to compute the factorial of. Returns: int: The sum of the digits of n!. Example: >>> sum_of_factorial_digits(5) 3 >>> sum_of_factorial_digits(10) 27","solution":"import math def sum_of_factorial_digits(n): Computes the sum of the digits of the factorial of n. Parameters: n (int): The non-negative integer to compute the factorial of. Returns: int: The sum of the digits of n!. factorial_result = math.factorial(n) sum_digits = sum(int(digit) for digit in str(factorial_result)) return sum_digits"},{"question":"def is_valid_palindrome(s: str) -> str: Given a string s, determine if it is a valid palindrome while ignoring non-alphanumeric characters and considering only uppercase and lowercase letters. >>> is_valid_palindrome(\\"A man, a plan, a canal: Panama\\") 'YES' >>> is_valid_palindrome(\\"race a car\\") 'NO'","solution":"def is_valid_palindrome(s): Determines if a string is a valid palindrome by ignoring non-alphanumeric characters and considering only uppercase and lowercase letters. # Filter out non-alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered characters form a palindrome return 'YES' if filtered_chars == filtered_chars[::-1] else 'NO'"},{"question":"def makePerfect(s: str) -> int: Returns the minimum number of operations required to make the string perfect. A string is perfect if all characters are the same. >>> makePerfect(\\"abc\\") 2 >>> makePerfect(\\"aaaa\\") 0","solution":"def makePerfect(s: str) -> int: Returns the minimum number of operations required to make the string perfect. A string is perfect if all characters are the same. # Count the occurrences of 'a', 'b', and 'c' count_a = s.count('a') count_b = s.count('b') count_c = s.count('c') # Find the maximum count among the three characters max_count = max(count_a, count_b, count_c) # The minimum operations required will be the total length of the string # minus the frequency of the most common character return len(s) - max_count"},{"question":"def num_distinct_islands(grid: List[List[str]]) -> int: Finds the number of distinct islands in a grid. >>> num_distinct_islands([ ... ['1', '1', '0', '0'], ... ['1', '0', '0', '1'], ... ['0', '0', '1', '0'], ... ['0', '1', '1', '0'] ... ]) == 3 >>> num_distinct_islands([ ... ['1', '1', '0', '0'], ... ['1', '0', '0', '0'], ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'] ... ]) == 1 >>> num_distinct_islands([ ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'] ... ]) == 0 >>> num_distinct_islands([ ... ['1', '1', '1', '1'], ... ['1', '0', '0', '1'], ... ['1', '1', '1', '1'], ... ['0', '1', '1', '0'] ... ]) == 1","solution":"def num_distinct_islands(grid): Finds the number of distinct islands in a grid. :param grid: List of lists representing the grid :return: Integer, number of distinct islands def dfs(x, y, visited, island_shape, origin): if (x, y) in visited: return visited.add((x, y)) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == '1': island_shape.append((nx - origin[0], ny - origin[1])) dfs(nx, ny, visited, island_shape, origin) def process_grid(): visited = set() islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if (i, j) not in visited and grid[i][j] == '1': island_shape = [] dfs(i, j, visited, island_shape, (i, j)) islands.add(tuple(island_shape)) return len(islands) return process_grid()"},{"question":"def count_ways_to_climb_stairs(N: int) -> int: Returns the number of distinct ways to climb N stairs when you can take 1, 2, or 3 steps at a time. The result is given modulo 10^9 + 7. >>> count_ways_to_climb_stairs(4) 7 >>> count_ways_to_climb_stairs(1) 1 >>> count_ways_to_climb_stairs(2) 2 >>> count_ways_to_climb_stairs(3) 4","solution":"def count_ways_to_climb_stairs(N): Returns the number of distinct ways to climb N stairs when you can take 1, 2, or 3 steps at a time. The result is given modulo 10^9 + 7. MOD = 10**9 + 7 if N == 0: return 0 if N == 1: return 1 if N == 2: return 2 if N == 3: return 4 dp = [0] * (N + 1) dp[0] = 1 dp[1] = 1 dp[2] = 2 dp[3] = 4 for i in range(4, N + 1): dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % MOD return dp[N]"},{"question":"def rearrange_string(s: str) -> str: Rearranges the string such that no two adjacent characters are the same. If not possible, returns an empty string. >>> rearrange_string('aab') 'aba' >>> rearrange_string('aaab') ''","solution":"from heapq import heappop, heappush from collections import Counter def rearrange_string(s): Rearranges the string such that no two adjacent characters are the same. If not possible, returns an empty string. # Count the frequency of each character count = Counter(s) # Form a max-heap based on character frequency max_heap = [] for char, freq in count.items(): heappush(max_heap, (-freq, char)) prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heappop(max_heap) # Add the previous character back if it's frequency is non-zero if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) # Append the current character to the result result.append(char) # Update the previous character and decrease it's frequency prev_freq, prev_char = freq + 1, char rearranged_string = ''.join(result) # If the rearranged string length is the same as the original string if len(rearranged_string) == len(s): return rearranged_string else: return \\"\\""},{"question":"def climb_stairs(n: int) -> int: Returns the number of unique ways to climb a staircase with \`n\` steps. You can either take 1 step, 2 steps, or 3 steps at a time. >>> climb_stairs(4) 7 >>> climb_stairs(3) 4","solution":"def climb_stairs(n): Returns the number of unique ways to climb a staircase with \`n\` steps. You can either take 1 step, 2 steps, or 3 steps at a time. # Base cases if n == 0: return 1 elif n == 1: return 1 elif n == 2: return 2 # Initialize ways to climb 0, 1, and 2 steps dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 dp[2] = 2 # Use dynamic programming to fill dp array for i in range(3, n + 1): dp[i] = dp[i-1] + dp[i-2] + dp[i-3] return dp[n]"},{"question":"from typing import List, Tuple def maxTeamMembers(matches: List[Tuple[int, int]]) -> int: Calculate the maximum number of team members required to ensure that no matches are interrupted. >>> maxTeamMembers([(1, 4), (2, 5), (6, 8), (6, 7)]) 2 >>> maxTeamMembers([(1, 3), (2, 4), (3, 5)]) 2","solution":"def maxTeamMembers(matches): Calculate the maximum number of team members required to ensure that no matches are interrupted. :param matches: List of tuples where each tuple consists of (start_time, end_time) :return: Integer representing the maximum number of team members required events = [] # Create events for all start and end times for start, end in matches: events.append((start, 'start')) events.append((end, 'end')) # Sort the events first by time, and then by type where 'end' comes before 'start' events.sort(key=lambda x: (x[0], x[1] == 'start')) max_members = 0 current_members = 0 # Process all events for event in events: if event[1] == 'start': current_members += 1 if current_members > max_members: max_members = current_members else: current_members -= 1 return max_members"},{"question":"def count_aesthetically_pleasing_recipes(n: int, m: int) -> int: Count the number of aesthetically pleasing recipes of length m that can be formed using n different ingredients, modulo 10^9+7. >>> count_aesthetically_pleasing_recipes(3, 2) 6 >>> count_aesthetically_pleasing_recipes(4, 3) 24","solution":"MOD = 1000000007 def factorial(n): if n == 0 or n == 1: return 1 return n * factorial(n - 1) def count_aesthetically_pleasing_recipes(n, m): if m == 1: return n elif m > n: return 0 else: return (n * (factorial(n - 1) // factorial(n - m))) % MOD"},{"question":"def count_distinct_substrings(S: str, K: int) -> int: Returns the number of distinct non-empty substrings of length K in the given string S. If K is greater than the length of the string, returns -1. >>> count_distinct_substrings(\\"abcabc\\", 3) 3 >>> count_distinct_substrings(\\"aaaa\\", 2) 1 >>> count_distinct_substrings(\\"abac\\", 5) -1 >>> count_distinct_substrings(\\"abcde\\", 1) 5 >>> count_distinct_substrings(\\"\\", 1) -1 >>> count_distinct_substrings(\\"a\\", 1) 1 >>> count_distinct_substrings(\\"a\\", 2) -1 >>> count_distinct_substrings(\\"abab\\", 2) 2 >>> count_distinct_substrings(\\"abcab\\", 3) 3","solution":"def count_distinct_substrings(S, K): Returns the number of distinct non-empty substrings of length K in the given string S. If K is greater than the length of the string, returns -1. if K > len(S): return -1 substrings = set() for i in range(len(S) - K + 1): substrings.add(S[i:i + K]) return len(substrings)"},{"question":"def can_form_palindrome(n: int, s: str) -> str: Determines if the string s of length n can be rearranged to form a palindrome. >>> can_form_palindrome(4, \\"abba\\") == \\"YES\\" >>> can_form_palindrome(6, \\"aabbcc\\") == \\"YES\\" >>> can_form_palindrome(4, \\"abcd\\") == \\"NO\\" >>> can_form_palindrome(2, \\"aa\\") == \\"YES\\" >>> can_form_palindrome(2, \\"ab\\") == \\"NO\\" >>> can_form_palindrome(6, \\"aaabbb\\") == \\"NO\\" # Implement the function here def process_test_cases(test_cases: List[Tuple[int, str]]) -> List[str]: Processes multiple test cases and returns the results as a list. >>> test_cases = [(4, \\"abba\\"), (6, \\"aabbcc\\"), (4, \\"abcd\\")] >>> process_test_cases(test_cases) == [\\"YES\\", \\"YES\\", \\"NO\\"] # Implement the function here","solution":"def can_form_palindrome(n, s): Determines if the string s of length n can be rearranged to form a palindrome. from collections import Counter count = Counter(s) for value in count.values(): if value % 2 != 0: return \\"NO\\" return \\"YES\\" def process_test_cases(test_cases): Processes multiple test cases and returns the results as a list. results = [] for n, s in test_cases: results.append(can_form_palindrome(n, s)) return results"},{"question":"def find_max_subarray(nums: List[int]) -> int: Returns the sum of the largest contiguous subarray. Uses Kadane's Algorithm with a time complexity of O(n). Args: nums: List of integers that contains both positive and negative numbers. Returns: An integer representing the sum of the largest contiguous subarray. Examples: >>> find_max_subarray([1, -2, 3, 5, -3, 2]) 8 >>> find_max_subarray([-4, -3, -2, -1]) -1 >>> find_max_subarray([8, -19, 5, -4, 20]) 21 from solution import find_max_subarray def test_find_max_subarray_positive_and_negative(): assert find_max_subarray([1, -2, 3, 5, -3, 2]) == 8 def test_find_max_subarray_all_negative(): assert find_max_subarray([-4, -3, -2, -1]) == -1 def test_find_max_subarray_mixed(): assert find_max_subarray([8, -19, 5, -4, 20]) == 21 def test_find_max_subarray_single_element(): assert find_max_subarray([5]) == 5 assert find_max_subarray([-5]) == -5 def test_find_max_subarray_all_positive(): assert find_max_subarray([1, 2, 3, 4, 5]) == 15 def test_find_max_subarray_with_zeroes(): assert find_max_subarray([0, -1, 2, -3, 4, -5, 0]) == 4","solution":"def find_max_subarray(nums): Returns the sum of the largest contiguous subarray. Uses Kadane's Algorithm with a time complexity of O(n). max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def max_batches(c: int, s: int, a: int, b: int) -> int: Determines the maximum number of complete batches of cookies Maria can bake with the available resources. Parameters: c (int): the number of cups of flour available. s (int): the number of cups of sugar available. a (int): the number of cups of flour required per batch. b (int): the number of cups of sugar required per batch. Returns: int: the maximum number of complete batches of cookies. Examples: >>> max_batches(10, 21, 2, 3) 5 >>> max_batches(15, 8, 4, 5) 1 >>> max_batches(7, 14, 3, 7) 2","solution":"def max_batches(c, s, a, b): Determines the maximum number of complete batches of cookies Maria can bake with the available resources. Parameters: c (int): the number of cups of flour available. s (int): the number of cups of sugar available. a (int): the number of cups of flour required per batch. b (int): the number of cups of sugar required per batch. Returns: int: the maximum number of complete batches of cookies. max_batches_flour = c // a max_batches_sugar = s // b return min(max_batches_flour, max_batches_sugar)"},{"question":"def count_positive_numbers(matrix): Given a matrix of integers, return the count of positive numbers in the matrix. Positive numbers are those greater than zero. >>> count_positive_numbers([[-1, 2, 3], [4, 5, -6], [7, -8, 9]]) == 6 >>> count_positive_numbers([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 9 >>> count_positive_numbers([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) == 0 >>> count_positive_numbers([[0, -1, 1], [2, 0, -2], [3, 0, 0]]) == 3 >>> count_positive_numbers([[10]]) == 1 >>> count_positive_numbers([[1] * 100] * 100) == 10000","solution":"def count_positive_numbers(matrix): Returns the count of positive numbers in the matrix. count = 0 for row in matrix: for number in row: if number > 0: count += 1 return count"},{"question":"def generate_encoded_clues(xs): Generate an encoded list of clues based on input values. Args: xs (List[int]): A list of integers representing the input values. Returns: List[str]: A list of encoded clues. >>> generate_encoded_clues([2]) [\\"1 12\\"] >>> generate_encoded_clues([3]) [\\"1 12 123\\"] >>> generate_encoded_clues([4]) [\\"1 12 123 1234\\"] def main(input_list): Process a list of input values to generate encoded list of clues for each test case. Args: input_list (List[int]): A list containing the number of test cases followed by the test cases. Returns: List[str]: A list of encoded clues for each test case. from solution import main def test_example(): input_data = [3, 2, 3, 4] expected_output = [ \\"1 12\\", \\"1 12 123\\", \\"1 12 123 1234\\" ] assert main(input_data) == expected_output def test_single_case(): input_data = [1, 1] expected_output = [\\"1\\"] assert main(input_data) == expected_output def test_maximum_case(): input_data = [1, 50] # Generating expected output for 50 expected_output = [\\" \\".join(\\"\\".join(str(j) for j in range(1, i+1)) for i in range(1, 51))] assert main(input_data) == expected_output def test_multiple_cases(): input_data = [2, 5, 6] expected_output = [ \\"1 12 123 1234 12345\\", \\"1 12 123 1234 12345 123456\\" ] assert main(input_data) == expected_output","solution":"def generate_encoded_clues(xs): result = [] for x in xs: encoded_clues = [] for i in range(1, x+1): clue = ''.join(str(j) for j in range(1, i+1)) encoded_clues.append(clue) result.append(' '.join(encoded_clues)) return result def main(input_list): N = input_list[0] test_cases = input_list[1:N+1] return generate_encoded_clues(test_cases)"},{"question":"def are_all_substrings_unique(S: str) -> str: Determine if all the possible substrings of a given string are unique. Args: S (str): Input string Returns: str: \\"Unique\\" if all substrings are unique, \\"Not Unique\\" otherwise. Examples: >>> are_all_substrings_unique(\\"abcd\\") \\"Unique\\" >>> are_all_substrings_unique(\\"aa\\") \\"Not Unique\\"","solution":"def are_all_substrings_unique(S): substrings = set() length = len(S) for i in range(length): for j in range(i + 1, length + 1): substring = S[i:j] if substring in substrings: return \\"Not Unique\\" substrings.add(substring) return \\"Unique\\""},{"question":"from typing import List def can_form_palindrome(s: str) -> bool: Determine if it is possible to rearrange the characters of the string to form a palindrome. >>> can_form_palindrome(\\"abba\\") True >>> can_form_palindrome(\\"aabbcc\\") True >>> can_form_palindrome(\\"abc\\") False def process_test_cases(test_cases: List[str]) -> List[str]: Process multiple test cases and determine if each string can form a palindrome. >>> process_test_cases([\\"abba\\", \\"aabbcc\\", \\"abc\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_test_cases([\\"a\\", \\"aa\\", \\"aaa\\", \\"aab\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] >>> process_test_cases([\\"aabb\\", \\"abcabc\\", \\"aabbccddee\\", \\"xxyyzz\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_form_palindrome(s): Determine if it is possible to rearrange the characters of the string to form a palindrome. from collections import Counter count = Counter(s) odd_count = sum(1 for freq in count.values() if freq % 2 != 0) return odd_count <= 1 def process_test_cases(test_cases): Process multiple test cases and determine if each string can form a palindrome. results = [] for test in test_cases: if can_form_palindrome(test): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def longest_common_substring(s: str, k: str) -> int: Returns the length of the longest common substring between s and k. >>> longest_common_substring(\\"abcdef\\", \\"zcdemf\\") 3 >>> longest_common_substring(\\"hello\\", \\"yellow\\") 4","solution":"def longest_common_substring(s, k): Returns the length of the longest common substring between s and k. m, n = len(s), len(k) # Create a table to store lengths of longest common suffixes of substrings. # LCSuff[i][j] will be the length of the longest common suffix of s[0...i-1] and k[0...j-1]. LCSuff = [[0] * (n + 1) for _ in range(m + 1)] # To store the length of the longest common substring. result = 0 # Building the LCSuff table. for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == k[j - 1]: LCSuff[i][j] = LCSuff[i - 1][j - 1] + 1 result = max(result, LCSuff[i][j]) else: LCSuff[i][j] = 0 return result"},{"question":"def nth_largest_unique(nums: List[int], n: int) -> Optional[int]: Write a function that receives a list of integers and an integer value \`n\` as parameters. Your job is to return the nth largest unique integer in the list. If \`n\` is greater than the number of unique integers in the list, return \`None\`. Examples: >>> nth_largest_unique([4, 1, 2, 3, 4, 5], 3) == 3 >>> nth_largest_unique([4, 4, 4, 4, 4, 4], 2) == None >>> nth_largest_unique([10, 20, 30, 40, 50], 1) == 50 >>> nth_largest_unique([10, 20, 30, 40, 50], 6) == None","solution":"def nth_largest_unique(nums, n): Returns the nth largest unique integer in the list. If n is greater than the number of unique integers, return None. unique_nums = list(set(nums)) unique_nums.sort(reverse=True) if n > len(unique_nums): return None return unique_nums[n-1]"},{"question":"def are_parentheses_balanced(expression: str) -> bool: Returns True if the parentheses in the expression are balanced, False otherwise. >>> are_parentheses_balanced(\\"3 + (4 * (5 - 2))\\") True >>> are_parentheses_balanced(\\"3 + (4 * (5 - 2)\\") False >>> are_parentheses_balanced(\\"3 + 4) * (5 - 2)\\") False >>> are_parentheses_balanced(\\"3 + 4 * 5 - 2\\") True >>> are_parentheses_balanced(\\"\\") True >>> are_parentheses_balanced(\\"()()\\") True >>> are_parentheses_balanced(\\"(()\\") False >>> are_parentheses_balanced(\\"())\\") False pass","solution":"def are_parentheses_balanced(expression): Returns True if the parentheses in the expression are balanced, False otherwise. stack = [] for char in expression: if char == '(': stack.append('(') elif char == ')': if not stack: return False stack.pop() return not stack"},{"question":"def canReachExit(h: int, w: int, grid: List[List[int]]) -> str: Check if there is a path from top-left to bottom-right in a grid with obstacles. >>> canReachExit(3, 3, [ [0, 1, 0], [0, 0, 1], [1, 0, 0] ]) \\"YES\\" >>> canReachExit(3, 3, [ [0, 1, 0], [1, 0, 1], [1, 1, 0] ]) \\"NO\\"","solution":"def canReachExit(h, w, grid): Check if there is a path from top-left to bottom-right in a grid with obstacles. :param h: Number of rows in the grid. :param w: Number of columns in the grid. :param grid: 2D list representing the grid, where 0 is an empty cell and 1 is an obstacle. :return: \\"YES\\" if there is a path from (0, 0) to (h-1, w-1), \\"NO\\" otherwise. if grid[0][0] == 1 or grid[h-1][w-1] == 1: return \\"NO\\" from collections import deque # Directions for moving in the grid (right, left, down, up) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Queue for BFS queue = deque([(0, 0)]) # Visited set to keep track of visited cells visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (h-1, w-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < h and 0 <= ny < w and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\""},{"question":"def max_complexity(m: int, b: List[int]) -> int: Returns the maximum possible complexity for the given maze path. Parameters: m (int): Length of the maze path. b (list): List of integers representing the maze path. Returns: int: Maximum possible complexity of the maze path. >>> max_complexity(5, [1, 3, 5, 7, 2]) 12 >>> max_complexity(4, [8, 1, 4, 6]) 14","solution":"def max_complexity(m, b): Returns the maximum possible complexity for the given maze path. Parameters: m (int): Length of the maze path. b (list): List of integers representing the maze path. Returns: int: Maximum possible complexity of the maze path. max_b = max(b) min_b = min(b) return (max_b - min_b) * 2 # Example usage: # m = 5 # b = [1, 3, 5, 7, 2] # print(max_complexity(m, b)) # Expected output: 12 # m = 4 # b = [8, 1, 4, 6] # print(max_complexity(m, b)) # Expected output: 14"},{"question":"def unique_track_playlists(tracks, target_duration): Implement a function called \`unique_track_playlists\` that takes two arguments: 1. A list of integers, \`tracks\`, where each integer represents the duration (in seconds) of a track. 2. A target integer \`target_duration\` representing the total duration (in seconds) of the playlist. The function should return the number of unique ways to select tracks from the list that exactly sum up to the \`target_duration\`. Each track can only be used once in a playlist, and order does not matter. >>> unique_track_playlists([2, 3, 5, 8, 13], 10) 2 >>> unique_track_playlists([1, 2, 3, 4, 5], 5) 3 >>> unique_track_playlists([1, 2, 3], 10) 0 >>> unique_track_playlists([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 55) 1 >>> unique_track_playlists([], 5) 0","solution":"from functools import lru_cache def unique_track_playlists(tracks, target_duration): Returns the number of unique ways to select tracks from the list such that their sum equals target_duration. @lru_cache(None) def count_ways(remaining_duration, index): if remaining_duration == 0: return 1 if remaining_duration < 0 or index >= len(tracks): return 0 # Option 1: Include the current track include = count_ways(remaining_duration - tracks[index], index + 1) # Option 2: Exclude the current track exclude = count_ways(remaining_duration, index + 1) return include + exclude return count_ways(target_duration, 0)"},{"question":"def longest_balanced_subarray_length(arr): Finds the length of the longest balanced contiguous subarray. Parameters: arr (list of int): The array to check Returns: int: The length of the longest balanced contiguous subarray >>> longest_balanced_subarray_length([2, 2, 3, 2, 3]) 5 >>> longest_balanced_subarray_length([1, 2, 4, 2]) 2 def process_test_cases(T, test_cases): Processes multiple test cases and returns results for each. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains (n, arr) where n is the number of elements in the array and arr is the array itself. Returns: list: List of results for each test case >>> process_test_cases(2, [(5, [2, 2, 3, 2, 3]), (4, [1, 2, 4, 2])]) [5, 2]","solution":"def longest_balanced_subarray_length(arr): Finds the length of the longest balanced contiguous subarray. Parameters: arr (list of int): The array to check Returns: int: The length of the longest balanced contiguous subarray max_length = 0 n = len(arr) start = 0 while start < n: min_val, max_val = arr[start], arr[start] end = start while end < n and max_val - min_val <= 1: min_val = min(min_val, arr[end]) max_val = max(max_val, arr[end]) if max_val - min_val <= 1: max_length = max(max_length, end - start + 1) end += 1 start += 1 return max_length def process_test_cases(T, test_cases): results = [] for i in range(T): n, arr = test_cases[i] results.append(longest_balanced_subarray_length(arr)) return results # Reading input and calling the function def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): n = int(data[index]) arr = list(map(int, data[index + 1: index + 1 + n])) test_cases.append((n, arr)) index += n + 1 results = process_test_cases(T, test_cases) for result in results: print(result)"},{"question":"def can_transform_to_ABC(s: str) -> str: Determines if the given string can be transformed into \\"ABC\\" by swapping at most one pair of characters. Args: s (str): Input string consisting of exactly 'A', 'B', and 'C'. Returns: str: \\"YES\\" if the string can be transformed into \\"ABC\\" by swapping at most one pair of characters, otherwise \\"NO\\". pass def test_can_transform_to_ABC_ABC(): assert can_transform_to_ABC(\\"ABC\\") == \\"YES\\" def test_can_transform_to_ABC_BAC(): assert can_transform_to_ABC(\\"BAC\\") == \\"YES\\" def test_can_transform_to_ABC_ACB(): assert can_transform_to_ABC(\\"ACB\\") == \\"YES\\" def test_can_transform_to_ABC_CAB(): assert can_transform_to_ABC(\\"CAB\\") == \\"YES\\" def test_can_transform_to_ABC_BCA(): assert can_transform_to_ABC(\\"BCA\\") == \\"NO\\" def test_can_transform_to_ABC_CBA(): assert can_transform_to_ABC(\\"CBA\\") == \\"NO\\"","solution":"def can_transform_to_ABC(s): Determines if the given string can be transformed into \\"ABC\\" by swapping at most one pair of characters. Args: s (str): Input string consisting of exactly 'A', 'B', and 'C'. Returns: str: \\"YES\\" if the string can be transformed into \\"ABC\\" by swapping at most one pair of characters, otherwise \\"NO\\". if s == \\"ABC\\": return \\"YES\\" if s == \\"BAC\\": return \\"YES\\" if s == \\"ACB\\": return \\"YES\\" if s == \\"CAB\\": return \\"YES\\" if s == \\"BCA\\": return \\"NO\\" if s == \\"CBA\\": return \\"NO\\""},{"question":"def productExceptSelf(arr): Given an array of integers, find the product of all elements in the array except the element at the current index without using division. The function should return a list of such products. >>> productExceptSelf([1, 2, 3, 4]) [24, 12, 8, 6] >>> productExceptSelf([5, 1, 4, 2]) [8, 40, 10, 20]","solution":"def productExceptSelf(arr): n = len(arr) if n == 0: return [] left_products = [1] * n right_products = [1] * n output = [1] * n for i in range(1, n): left_products[i] = left_products[i - 1] * arr[i - 1] for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * arr[i + 1] for i in range(n): output[i] = left_products[i] * right_products[i] return output"},{"question":"def max_even_length_subsequence_sum(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the maximum sum of any even-length subsequence of a given sequence. Parameters: t (int): Number of test cases test_cases (List[Tuple[int, List[int]]]): List of tuples where the first element is the length of the sequence and the second element is the sequence itself Returns: List[int]: List of results for each test case >>> max_even_length_subsequence_sum(2, [(4, [1, 2, 3, 4]), (5, [3, 3, 1, 7, 5])]) [10, 18] >>> max_even_length_subsequence_sum(1, [(2, [1, 2])]) [3] >>> max_even_length_subsequence_sum(1, [(4, [0, 0, 0, 0])]) [0]","solution":"def max_even_length_subsequence_sum(t, test_cases): results = [] for i in range(t): n, a = test_cases[i] a.sort(reverse=True) results.append(sum(a[:n - (n % 2)])) return results def main(): import sys input = sys.stdin.read data = input().split() t = int(data[0]) index = 1 test_cases = [] for _ in range(t): n = int(data[index]) a = list(map(int, data[index+1:index+1+n])) test_cases.append((n, a)) index += n + 1 results = max_even_length_subsequence_sum(t, test_cases) for result in results: print(result)"},{"question":"def minJumps(arr: List[int]) -> int: Determine the minimum number of jumps required to reach the last index of the array. If it is not possible to reach the last index, return -1. >>> minJumps([2, 3, 1, 1, 4]) # Output: 2 >>> minJumps([2, 3, 0, 1, 4]) # Output: 2 >>> minJumps([1, 1, 1, 1, 1]) # Output: 4 >>> minJumps([1, 0, 2, 3, 1]) # Output: -1","solution":"def minJumps(arr): if len(arr) <= 1: return 0 if arr[0] == 0: return -1 n = len(arr) jumps = 1 maxReach = arr[0] steps = arr[0] for i in range(1, n): if i == n-1: return jumps maxReach = max(maxReach, i + arr[i]) steps -= 1 if steps == 0: jumps += 1 if i >= maxReach: return -1 steps = maxReach - i return -1"},{"question":"def twoSum(n, arr, target): Returns the indices of the two numbers that add up to the target. :param n: int, the size of the array :param arr: list of int, the input array :param target: int, the target sum :return: list of int, the indices of the two numbers >>> twoSum(4, [2, 7, 11, 15], 9) [0, 1] >>> twoSum(3, [3, 2, 4], 6) [1, 2]","solution":"def twoSum(n, arr, target): Returns the indices of the two numbers that add up to the target. :param n: int, the size of the array :param arr: list of int, the input array :param target: int, the target sum :return: list of int, the indices of the two numbers num_to_index = {} for i in range(n): complement = target - arr[i] if complement in num_to_index: return [num_to_index[complement], i] num_to_index[arr[i]] = i return [] # Example usage: # n = 4 # arr = [2, 7, 11, 15] # target = 9 # print(twoSum(n, arr, target)) # Output: [0, 1]"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def handle_queries(n: int, labels: List[int], edges: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]: Handle the given queries on a directed graph with n nodes and n edges forming exactly one cycle. Parameters: n (int): The number of nodes in the graph. labels (List[int]): The labels of the nodes. edges (List[Tuple[int, int]]): The edges of the graph. queries (List[Tuple[int, int, int]]): The list of queries where each query is a tuple: - If t = 1, the tuple contains (1, u, v) meaning swap labels of node u and node v. - If t = 2, the tuple contains (2, u, v) meaning find the maximum label along the shortest path from u to v. Returns: List[int]: The results of each type 2 query. >>> handle_queries(6, [1, 2, 3, 4, 5, 6], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)], [(2, 1, 4), (1, 4, 6), (2, 1, 4)]) [4, 6] >>> handle_queries(4, [4, 3, 2, 1], [(1, 2), (2, 3), (3, 4), (4, 1)], [(1, 1, 2), (1, 3, 4), (2, 1, 4)]) [3] pass # Function implementation goes here def test_handle_queries(): n = 6 labels = [1, 2, 3, 4, 5, 6] edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)] queries = [(2, 1, 4), (1, 4, 6), (2, 1, 4)] assert handle_queries(n, labels, edges, queries) == [4, 6] def test_handle_queries_all_swaps(): n = 4 labels = [4, 3, 2, 1] edges = [(1, 2), (2, 3), (3, 4), (4, 1)] queries = [(1, 1, 2), (1, 3, 4), (2, 1, 4)] assert handle_queries(n, labels, edges, queries) == [3] def test_handle_queries_only_max_label(): n = 5 labels = [1, 2, 3, 4, 5] edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)] queries = [(2, 2, 5), (2, 4, 1)] assert handle_queries(n, labels, edges, queries) == [5, 5] def test_handle_queries_with_swaps(): n = 3 labels = [3, 1, 2] edges = [(1, 2), (2, 3), (3, 1)] queries = [(2, 1, 3), (1, 1, 2), (2, 1, 3)] assert handle_queries(n, labels, edges, queries) == [3, 2]","solution":"def handle_queries(n, labels, edges, queries): from collections import defaultdict, deque graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def swap_labels(u, v): labels[u-1], labels[v-1] = labels[v-1], labels[u-1] def bfs_max_label(u, v): visited = set() queue = deque([(u, labels[u-1])]) visited.add(u) max_label = labels[u-1] while queue: node, current_max = queue.popleft() if node == v: return current_max for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, max(current_max, labels[neighbor-1]))) return -1 # should not reach here if u and v are valid result = [] for query in queries: t, u, v = query if t == 1: swap_labels(u, v) elif t == 2: result.append(bfs_max_label(u, v)) return result"},{"question":"def rearrange_array(arr): Rearrange array such that: - for every i (1 ≤ i ≤ n), arr[i] > arr[i-1] if i is odd - for every i (1 ≤ i ≤ n), arr[i] < arr[i-1] if i is even >>> rearrange_array([1, 3, 2, 4, 5]) [1, 3, 2, 5, 4] >>> rearrange_array([9, 7, 5]) [5, 9, 7] pass def process_test_cases(test_cases): Process multiple test cases for the rearrange_array function. >>> test_cases = [(5, [1, 3, 2, 4, 5]), (3, [9, 7, 5])] >>> process_test_cases(test_cases) [[1, 3, 2, 5, 4], [5, 9, 7]] pass","solution":"def rearrange_array(arr): Rearrange array such that: - for every i (1 ≤ i ≤ n), arr[i] > arr[i-1] if i is odd - for every i (1 ≤ i ≤ n), arr[i] < arr[i-1] if i is even arr.sort() for i in range(1, len(arr), 2): if i + 1 < len(arr): arr[i], arr[i + 1] = arr[i + 1], arr[i] return arr def process_test_cases(test_cases): results = [] for n, arr in test_cases: results.append(rearrange_array(arr)) return results"},{"question":"def is_path(maze): Determines if there's a path from 'S' (start) to 'E' (end) in the given maze. :param maze: List[List[str]] - 2D array representing the maze :return: bool - True if there's a path, False otherwise >>> maze = [ ... ['S', '.', '#', '#', '.'], ... ['.', '.', '#', '#', '.'], ... ['#', '.', '.', '.', '.'], ... ['#', '#', '.', '#', '.'], ... ['.', '.', '.', '#', 'E'] ... ] >>> is_path(maze) True >>> maze = [ ... ['S', '.', '#', '#', '.'], ... ['#', '#', '#', '#', '.'], ... ['#', '.', '.', '.', '.'], ... ['#', '#', '.', '#', '.'], ... ['.', '.', '.', '#', 'E'] ... ] >>> is_path(maze) False >>> maze = [ ... ['.', '.', '#', '#', '.'], ... ['.', '.', '#', '#', '.'], ... ['#', '.', '.', '.', '.'], ... ['#', '#', '.', '#', '.'], ... ['.', '.', '.', '#', 'E'] ... ] >>> is_path(maze) False >>> maze = [ ... ['S', '.', '#', '#', '.'], ... ['.', '.', '#', '#', '.'], ... ['#', '.', '.', '.', '.'], ... ['#', '#', '.', '#', '.'], ... ['.', '.', '.', '#', '.'] ... ] >>> is_path(maze) False >>> maze = [ ... ['S', 'E'] ... ] >>> is_path(maze) True >>> maze = [ ... ['S', '#', '#', '#', '.'], ... ['#', '#', '#', '#', '.'], ... ['#', '.', '.', '.', '.'], ... ['#', '#', '.', '#', '.'], ... ['.', '.', '.', '#', 'E'] ... ] >>> is_path(maze) False >>> maze = [ ... ['S', '.', '#', '#', '.'], ... ['.', '.', '#', '#', '.'], ... ['#', '.', '.', '.', '.'], ... ['#', '#', '.', '#', '#'], ... ['.', '.', '.', '#', 'E'] ... ] >>> is_path(maze) False","solution":"def is_path(maze): Determines if there's a path from 'S' (start) to 'E' (end) in the given maze. :param maze: List[List[str]] - 2D array representing the maze :return: bool - True if there's a path, False otherwise # Find start 'S' and end 'E' positions start, end = None, None for i in range(len(maze)): for j in range(len(maze[0])): if maze[i][j] == 'S': start = (i, j) elif maze[i][j] == 'E': end = (i, j) if not start or not end: return False # Breadth-First Search (BFS) from collections import deque queue = deque([start]) visited = set() visited.add(start) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right while queue: current = queue.popleft() if current == end: return True for direction in directions: next_pos = (current[0] + direction[0], current[1] + direction[1]) if (0 <= next_pos[0] < len(maze) and 0 <= next_pos[1] < len(maze[0]) and maze[next_pos[0]][next_pos[1]] in {'.', 'E'} and next_pos not in visited): queue.append(next_pos) visited.add(next_pos) return False"},{"question":"from typing import List def min_moves_to_reach_destination(N: int, M: int, grid: List[str]) -> int: Find the minimum number of moves required for the robot to reach the destination in a grid-based warehouse. If it is impossible for the robot to reach the destination, return -1. >>> grid1 = [ ... 'S....', ... '...', ... '..#..', ... '....#', ... '....D' ... ] >>> min_moves_to_reach_destination(5, 5, grid1) 8 >>> grid2 = [ ... 'S..', ... '#', ... '..D' ... ] >>> min_moves_to_reach_destination(3, 3, grid2) -1","solution":"from collections import deque def min_moves_to_reach_destination(N, M, grid): # Locate the start and destination positions start = None destination = None for i in range(N): for j in range(M): if grid[i][j] == 'S': start = (i, j) elif grid[i][j] == 'D': destination = (i, j) if not start or not destination: return -1 # BFS to find the shortest path queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set() visited.add(start) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: x, y, dist = queue.popleft() if (x, y) == destination: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and grid[nx][ny] != '#': visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def unique_subarray_sum(n: int, q: int, array: List[int], operations: List[Tuple[int, int]]) -> List[int]: Calculate the sum of elements in the subarray from index l to index r (1-based) if all elements in the subarray are distinct. If any element is repeated within the subarray, return -1 for that operation. >>> unique_subarray_sum(6, 3, [1, 2, 3, 3, 2, 1], [(1, 3), (4, 6), (2, 5)]) [6, 6, -1] >>> unique_subarray_sum(5, 2, [5, 4, 3, 2, 1], [(1, 5), (2, 3)]) [15, 7]","solution":"def unique_subarray_sum(n, q, array, operations): def is_unique(subarray): return len(subarray) == len(set(subarray)) results = [] for l, r in operations: subarray = array[l-1:r] if is_unique(subarray): results.append(sum(subarray)) else: results.append(-1) return results"},{"question":"def exploreTunnels(tunnel_map): Explore all tunnels using DFS starting from the first key in the dictionary. Parameters: tunnel_map (dict): A dictionary representing the tunnel system, where each key is a point in the tunnel, and the value is a list of directly connected points. Returns: list: A list of points in the order they are explored. Examples: >>> exploreTunnels({'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E']}) ['A', 'B', 'D', 'E', 'F', 'C'] >>> exploreTunnels({'A': []}) ['A'] from solution import exploreTunnels def test_example_case(): tunnel_map = { 'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E'] } assert exploreTunnels(tunnel_map) == ['A', 'B', 'D', 'E', 'F', 'C'] def test_single_point(): tunnel_map = { 'A': [] } assert exploreTunnels(tunnel_map) == ['A'] def test_disconnected_points(): tunnel_map = { 'A': ['B'], 'B': ['A'], 'C': ['D'], 'D': ['C'] } assert exploreTunnels(tunnel_map) == ['A', 'B'] def test_alphabetical_ordering(): tunnel_map = { 'A': ['D', 'B', 'C'], 'B': ['A'], 'C': ['A'], 'D': ['A'] } assert exploreTunnels(tunnel_map) == ['A', 'B', 'C', 'D'] def test_complex_case(): tunnel_map = { 'X': ['A', 'B'], 'A': ['X', 'C', 'E'], 'B': ['X', 'D'], 'C': ['A'], 'D': ['B'], 'E': ['A', 'F'], 'F': ['E'] } assert exploreTunnels(tunnel_map) == ['X', 'A', 'C', 'E', 'F', 'B', 'D']","solution":"def exploreTunnels(tunnel_map): Explore all tunnels using DFS starting from the first key in the dictionary. Parameters: tunnel_map (dict): A dictionary representing the tunnel system, where each key is a point in the tunnel, and the value is a list of directly connected points. Returns: list: A list of points in the order they are explored. starting_point = list(tunnel_map.keys())[0] visited = set() travel_plan = [] def dfs(point): visited.add(point) travel_plan.append(point) for neighbor in sorted(tunnel_map[point]): if neighbor not in visited: dfs(neighbor) dfs(starting_point) return travel_plan"},{"question":"def max_number_of_guests(budget): Determine the maximum number of guests that can attend an event based on the given budget. Each guest's cost includes 15.50 for a meal and 10.25 for a gift. >>> max_number_of_guests(0) 0 >>> max_number_of_guests(20) 0 >>> max_number_of_guests(25.75) 1 >>> max_number_of_guests(51.50) 2 >>> max_number_of_guests(77.25) 3 >>> max_number_of_guests(257.50) 10","solution":"def max_number_of_guests(budget): Returns the maximum number of guests that can be invited based on the given budget. Each guest costs 15.50 for a meal and 10.25 for a gift. cost_per_guest = 15.50 + 10.25 if budget < cost_per_guest: return 0 return int(budget // cost_per_guest)"},{"question":"def min_changes_to_limit_discrepancy(n, k, arr): Find the minimum number of changes needed to ensure that the height discrepancies between adjacent buildings do not exceed k. >>> min_changes_to_limit_discrepancy(5, 3, [1, 9, 3, 10, 4]) 2 >>> min_changes_to_limit_discrepancy(5, 10, [1, 2, 3, 4, 5]) 0 >>> min_changes_to_limit_discrepancy(4, 1, [10, 20, 30, 40]) 3 >>> min_changes_to_limit_discrepancy(5, 100, [1, 90, 180, 270, 360]) 0 >>> min_changes_to_limit_discrepancy(5, 5, [1, 6, 11, 16, 21]) 0 >>> min_changes_to_limit_discrepancy(5, 4, [1, 6, 11, 16, 21]) 4","solution":"def min_changes_to_limit_discrepancy(n, k, arr): changes = 0 for i in range(1, n): if abs(arr[i] - arr[i - 1]) > k: changes += 1 arr[i] = arr[i - 1] + k if arr[i] > arr[i - 1] else arr[i - 1] - k return changes"},{"question":"def is_subsequence(A: str, B: str) -> bool: Determines if B is a subsequence of A. >>> is_subsequence(\\"abdefghij\\", \\"bdg\\") True >>> is_subsequence(\\"abcdefghij\\", \\"k\\") False >>> is_subsequence(\\"abcdefghij\\", \\"\\") True >>> is_subsequence(\\"\\", \\"a\\") False >>> is_subsequence(\\"abcdefghij\\", \\"abcdefghij\\") True >>> is_subsequence(\\"a\\", \\"a\\") True >>> is_subsequence(\\"a\\", \\"b\\") False >>> is_subsequence(\\"abcdefghij\\", \\"hij\\") True","solution":"def is_subsequence(A, B): Determines if B is a subsequence of A. m, n = len(A), len(B) j = 0 # Index for B for i in range(m): if j < n and A[i] == B[j]: j += 1 return j == n"},{"question":"from typing import List, Tuple def tree_diameter(n: int, edges: List[Tuple[int, int, int]]) -> int: Calculate the diameter of a tree given the number of nodes and a list of weighted edges. >>> tree_diameter(5, [(1, 2, 3), (2, 3, 4), (2, 4, 5), (4, 5, 6)]) 15 >>> tree_diameter(1, []) 0 >>> tree_diameter(3, [(1, 2, 10), (2, 3, 20)]) 30","solution":"from collections import defaultdict, deque def tree_diameter(n, edges): if n == 1: return 0 graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) def bfs(start): distances = [-1] * (n + 1) queue = deque([(start, 0)]) distances[start] = 0 max_distance = 0 farthest_node = start while queue: node, dist = queue.popleft() for neighbor, weight in graph[node]: if distances[neighbor] == -1: distances[neighbor] = dist + weight queue.append((neighbor, dist + weight)) if distances[neighbor] > max_distance: max_distance = distances[neighbor] farthest_node = neighbor return farthest_node, max_distance # First BFS to find one endpoint of the longest path in the tree farthest_node, _ = bfs(1) # Second BFS from the found node to determine the diameter of the tree _, diameter = bfs(farthest_node) return diameter"},{"question":"def find_substring_to_reverse(s: str) -> Tuple[int, int]: Given a string s representing building heights, this function finds the indices (1-based) of the substring that should be reversed to make the entire string sorted in non-decreasing order. If such a substring doesn't exist, it returns -1. pass def process_test_cases(test_cases: List[str]) -> List[str]: Process multiple test cases and return the results for each case. pass # Test Cases def test_case_1(): assert find_substring_to_reverse(\\"abc\\") == (1, 1) def test_case_2(): assert find_substring_to_reverse(\\"cba\\") == (1, 3) def test_case_3(): assert find_substring_to_reverse(\\"bac\\") == (1, 2) def test_case_4(): assert find_substring_to_reverse(\\"abcd\\") == (1, 1) def test_case_5(): assert find_substring_to_reverse(\\"dcba\\") == (1, 4) def test_multiple_cases(): test_cases = ['abc', 'cba', 'bac', 'abcd', 'dcba'] expected_results = [\\"1 1\\", \\"1 3\\", \\"1 2\\", \\"1 1\\", \\"1 4\\"] assert process_test_cases(test_cases) == expected_results def test_no_solution(): test_cases = ['dcbabb'] expected_results = [\\"-1\\"] assert process_test_cases(test_cases) == expected_results","solution":"def find_substring_to_reverse(s): Given a string s representing building heights, this function finds the indices (1-based) of the substring that should be reversed to make the entire string sorted in non-decreasing order. If such a substring doesn't exist, it returns -1. n = len(s) sorted_s = ''.join(sorted(s)) if s == sorted_s: return (1, 1) left = 0 while left < n and s[left] == sorted_s[left]: left += 1 right = n - 1 while right >= 0 and s[right] == sorted_s[right]: right -= 1 if left < right: candidate = s[:left] + s[left:right+1][::-1] + s[right+1:] if candidate == sorted_s: return (left + 1, right + 1) return -1 def process_test_cases(test_cases): results = [] for s in test_cases: result = find_substring_to_reverse(s) if result == -1: results.append(\\"-1\\") else: results.append(f\\"{result[0]} {result[1]}\\") return results"},{"question":"from math import comb def count_valid_teams(N: int, K: int) -> int: Returns the number of valid teams that can be formed with K participants out of N participants. >>> count_valid_teams(5, 3) 10 >>> count_valid_teams(1, 1) 1 >>> count_valid_teams(4, 4) 1 >>> count_valid_teams(3, 4) 0 >>> count_valid_teams(6, 2) 15","solution":"from math import comb def count_valid_teams(N, K): Returns the number of valid teams that can be formed with K participants out of N participants. return comb(N, K)"},{"question":"def find_pair_indices(arr, k): You are given a list of n integers and a target sum k. Your task is to determine if there are any two distinct elements in the list that add up to the target sum k. If such a pair exists, return their indices (1-based). If multiple pairs are possible, return any one. If no such pair exists, return \`-1 -1\`. Args: arr (List[int]): A list of integers. k (int): The target sum. Returns: Tuple[int, int]: Indices of the two elements that add up to k or \`-1 -1\` if no such pair exists. >>> find_pair_indices([1, 2, 3, 7], 9) (2, 4) >>> find_pair_indices([20, 15, 30, 40, 25], 40) (2, 5) >>> find_pair_indices([1, 2, 3], 6) (-1, -1) def process_input(data): Processes a list of datasets and applies find_pair_indices function on each dataset. Args: data (List[Tuple[str, str]]): Each tuple contains two strings representing a dataset. Returns: List[Tuple[int, int]]: List of results for each dataset. >>> data = [(\\"4 9\\", \\"1 2 3 7\\"), (\\"5 40\\", \\"20 15 30 40 25\\"), (\\"3 6\\", \\"1 2 3\\"), (\\"0 0\\", \\"\\")] >>> process_input(data) [(2, 4), (2, 5), (-1, -1)]","solution":"def find_pair_indices(arr, k): value_to_index = {} for i, num in enumerate(arr): complement = k - num if complement in value_to_index: return value_to_index[complement] + 1, i + 1 value_to_index[num] = i return -1, -1 def process_input(data): results = [] for line in data: first_line, second_line = line n, k = map(int, first_line.split()) if n == 0 and k == 0: break arr = list(map(int, second_line.split())) results.append(find_pair_indices(arr, k)) return results"},{"question":"def longest_non_decreasing_subsequence(peaks: List[int]) -> int: Find the length of the longest non-decreasing subsequence in a list of peak altitudes. >>> longest_non_decreasing_subsequence([5, 3, 4, 8, 6, 7]) 4 >>> longest_non_decreasing_subsequence([1, 2, 3, 3, 2]) 4 def process_input(input_data: str) -> List[int]: Processes the input data and returns the results for each test case. >>> process_input(\\"6n5 3 4 8 6 7n5n1 2 3 3 2n0n\\") [4, 4] >>> process_input(\\"4n1 2 2 3n3n3 2 1n0n\\") [4, 1]","solution":"def longest_non_decreasing_subsequence(peaks): Function to find the length of the longest non-decreasing subsequence in a list of peaks. if not peaks: return 0 n = len(peaks) dp = [1] * n for i in range(1, n): for j in range(i): if peaks[i] >= peaks[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def process_input(input_data): Processes the input data and returns the results for each test case. results = [] lines = input_data.strip().split('n') index = 0 while index < len(lines): n = int(lines[index]) if n == 0: break peaks = list(map(int, lines[index + 1].strip().split())) results.append(longest_non_decreasing_subsequence(peaks)) index += 2 return results"},{"question":"from typing import List def max_carry_weight(m: int, w: int, weights: List[int]) -> int: Returns the maximum weight of strawberries that Bob can carry without exceeding the limit. Parameters: m (int): Number of strawberries. w (int): Maximum weight Bob can carry. weights (list of int): Weights of the strawberries. Returns: int: The maximum weight that Bob can carry without exceeding the limit. >>> max_carry_weight(5, 10, [2, 3, 5, 8, 6]) 10 >>> max_carry_weight(4, 7, [1, 3, 4, 2]) 7 >>> max_carry_weight(6, 20, [5, 5, 5, 5, 5, 5]) 20","solution":"from itertools import combinations def max_carry_weight(m, w, weights): Returns the maximum weight of strawberries that Bob can carry without exceeding the limit. Parameters: m (int): Number of strawberries. w (int): Maximum weight Bob can carry. weights (list of int): Weights of the strawberries. Returns: int: The maximum weight that Bob can carry without exceeding the limit. max_weight = 0 for i in range(1, m+1): for comb in combinations(weights, i): total = sum(comb) if total <= w and total > max_weight: max_weight = total return max_weight"},{"question":"def max_contiguous_active_routers(test_cases): This function receives a list of strings representing the state of the routers and returns a list of integers, each representing the maximum number of contiguous active routers for the given test case. >>> max_contiguous_active_routers(['1101100111']) [3] >>> max_contiguous_active_routers(['001100']) [2] >>> max_contiguous_active_routers(['1']) [1] >>> max_contiguous_active_routers(['0']) [0] >>> max_contiguous_active_routers(['11111']) [5] >>> max_contiguous_active_routers(['1010101010']) [1] >>> max_contiguous_active_routers([ ... '0000000000', ... '1111111111', ... '1100110011' ... ]) [0, 10, 2]","solution":"def max_contiguous_active_routers(test_cases): This function receives a list of strings representing the state of the routers and returns a list of integers, each representing the maximum number of contiguous active routers for the given test case. results = [] for routers in test_cases: max_len = 0 current_len = 0 for router in routers: if router == '1': current_len += 1 if current_len > max_len: max_len = current_len else: current_len = 0 results.append(max_len) return results"},{"question":"def min_operations_to_vowels(T, test_cases): This function finds the minimum number of operations required to transform a given string into a string that consists only of vowels. Arguments: T : int : the number of test cases test_cases : list of str : list of test case strings Returns: operations : list of int : list of minimum operations for each test case Example: >>> min_operations_to_vowels(2, [\\"hello\\", \\"world\\"]) [3, 4] >>> min_operations_to_vowels(1, [\\"aeiou\\"]) [0] >>> min_operations_to_vowels(1, [\\"bcdfg\\"]) [5] >>> min_operations_to_vowels(1, [\\"abcd\\"]) [3] >>> min_operations_to_vowels(3, [\\"a\\", \\"b\\", \\"e\\"]) [0, 1, 0]","solution":"def min_operations_to_vowels(T, test_cases): This function finds the minimum number of operations required to transform a given string into a string that consists only of vowels. Arguments: T : int : the number of test cases test_cases : list of str : list of test case strings Returns: operations : list of int : list of minimum operations for each test case vowels = set('aeiou') def min_operations(s): return sum(1 for char in s if char not in vowels) operations = [] for s in test_cases: operations.append(min_operations(s)) return operations # Example usage: # T = 2 # test_cases = [\\"hello\\", \\"world\\"] # print(min_operations_to_vowels(T, test_cases)) # Output should be [3, 4]"},{"question":"def chocolateBreaks(M: int, N: int) -> int: Returns the minimum number of breaks needed to divide the entire MxN chocolate bar into single-square pieces. >>> chocolateBreaks(2, 2) 3 >>> chocolateBreaks(1, 1) 0 >>> chocolateBreaks(3, 1) 2 >>> chocolateBreaks(5, 5) 24 >>> chocolateBreaks(4, 6) 23","solution":"def chocolateBreaks(M, N): Returns the minimum number of breaks needed to divide the entire MxN chocolate bar into single-square pieces. # To divide the MxN chocolate bar into M*N single squares, # we need (M-1) horizontal breaks and (N-1) vertical breaks. # Thus, the total number of breaks needed is (M-1) + (N-1) + 1 - 1 = M * N - 1 # Because each time you break, you increase the total number of pieces by one. return M * N - 1"},{"question":"def isPalindrome(s: str) -> bool: Check if the given string is a palindrome, considering only alphanumeric characters and ignoring cases. >>> isPalindrome(\\"A man, a plan, a canal: Panama\\") == True >>> isPalindrome(\\"race a car\\") == False >>> isPalindrome(\\"\\") == True >>> isPalindrome(\\"a\\") == True >>> isPalindrome(\\"A\\") == True >>> isPalindrome(\\"MadamInEdenImAdam\\") == True >>> isPalindrome(\\"12321\\") == True >>> isPalindrome(\\"A1B2C3C2B1A\\") == True >>> isPalindrome(\\"HelloWorld\\") == False","solution":"def isPalindrome(s: str) -> bool: Check if the given string is a palindrome, considering only alphanumeric characters and ignoring cases. # Create a filtered string with only alphanumeric characters and convert to lowercase filtered_str = ''.join(char.lower() for char in s if char.isalnum()) # Reverse the filtered string reversed_str = filtered_str[::-1] # Check if the filtered string is equal to its reverse return filtered_str == reversed_str"},{"question":"from collections import Counter def isAnagramPrefix(prefix, txt): Determines if any anagram of 'prefix' is a prefix of 'txt'. Args: prefix (str): The string which an anagram is derived from. txt (str): The string to check against. Returns: bool: True if an anagram of 'prefix' is a prefix of 'txt', False otherwise. n, m = len(txt), len(prefix) if m > n: return False prefix_counter = Counter(prefix) window_counter = Counter(txt[:m]) if prefix_counter == window_counter: return True return False def test_isAnagramPrefix(): assert isAnagramPrefix('abc', 'cbaebabacd') == True assert isAnagramPrefix('wxyz', 'efgdtwxyz') == False assert isAnagramPrefix('acb', 'abc') == True assert isAnagramPrefix('abcd', 'abc') == False assert isAnagramPrefix('abc', 'defabc') == False assert isAnagramPrefix('aaa', 'aaa') == True assert isAnagramPrefix('a', 'a') == True assert isAnagramPrefix('a', 'b') == False assert isAnagramPrefix('a'*100000, 'a'*100000) == True","solution":"from collections import Counter def isAnagramPrefix(prefix, txt): Determines if any anagram of 'prefix' is a prefix of 'txt'. Args: prefix (str): The string which an anagram is derived from. txt (str): The string to check against. Returns: bool: True if an anagram of 'prefix' is a prefix of 'txt', False otherwise. n, m = len(txt), len(prefix) if m > n: return False prefix_counter = Counter(prefix) window_counter = Counter(txt[:m]) if prefix_counter == window_counter: return True return False"},{"question":"def find_frequently_used_points(n: int, routes: List[Tuple[int, int, int, int]]) -> int: Determine the number of unique points on a 2D grid that are frequently used by at least two train routes (including both overlapping and intersection points). Args: n (int): The number of train routes. routes (List[Tuple[int, int, int, int]]): A list of tuples where each tuple contains four integers x1, y1, x2, y2 representing a train route from (x1, y1) to (x2, y2). Returns: int: The number of unique points frequently used by at least two train routes. Examples: >>> find_frequently_used_points(5, [(1, 1, 1, 5), (2, 3, 2, 6), (1, 4, 3, 4), (1, 2, 4, 2), (3, 3, 3, 6)]) 4 >>> find_frequently_used_points(2, [(1, 1, 1, 2), (2, 1, 2, 2)]) 0 >>> find_frequently_used_points(2, [(1, 1, 1, 2), (1, 1, 1, 2)]) 2 >>> find_frequently_used_points(4, [(0, 0, 0, 3), (0, 1, 3, 1), (3, 0, 3, 3), (1, 0, 2, 0)]) 2 >>> find_frequently_used_points(1, [(0, 0, 0, 5)]) 0","solution":"def find_frequently_used_points(n, routes): from collections import defaultdict point_usage = defaultdict(int) for route in routes: x1, y1, x2, y2 = route if x1 == x2: # Vertical route for y in range(min(y1, y2), max(y1, y2) + 1): point_usage[(x1, y)] += 1 else: # Horizontal route for x in range(min(x1, x2), max(x1, x2) + 1): point_usage[(x, y1)] += 1 return sum(1 for count in point_usage.values() if count >= 2) # Example usage n = 5 routes = [ (1, 1, 1, 5), (2, 3, 2, 6), (1, 4, 3, 4), (1, 2, 4, 2), (3, 3, 3, 6) ] print(find_frequently_used_points(n, routes)) # Output: 4"},{"question":"def subarray_sum(n: int, x: int, array: List[int], l: int, r: int) -> int: Returns the sum of the elements from index l to r (inclusive) in the given array. :param n: Number of elements in the array :param x: (Unused in this function, might be for future extensions) :param array: List of integers :param l: Starting index (0-based) of the subarray :param r: Ending index (0-based) of the subarray :return: Sum of the subarray from index l to r >>> subarray_sum(7, 2, [2, 4, 6, 8, 10, 12, 14], 1, 3) 18 >>> subarray_sum(7, 2, [2, 4, 6, 8, 10, 12, 14], 2, 5) 36 >>> subarray_sum(7, 2, [2, 4, 6, 8, 10, 12, 14], 0, 6) 56 >>> subarray_sum(7, 2, [2, 4, 6, 8, 10, 12, 14], 3, 3) 8 >>> subarray_sum(5, 2, [-2, -4, -6, -8, -10], 1, 3) -18 >>> subarray_sum(5, 2, [2, 0, 6, 0, 10], 1, 3) 6 pass","solution":"def subarray_sum(n, x, array, l, r): Returns the sum of the elements from index l to r (inclusive) in the given array. :param n: Number of elements in the array :param x: (Unused in this function, might be for future extensions) :param array: List of integers :param l: Starting index (0-based) of the subarray :param r: Ending index (0-based) of the subarray :return: Sum of the subarray from index l to r return sum(array[l:r+1])"},{"question":"from typing import List def max_sum_subgrid(grid: List[List[int]]) -> int: Given a grid with N rows and M columns, find the maximum sum of any sub-grid. >>> max_sum_subgrid([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) 45 >>> max_sum_subgrid([ [1, 2], [3, 4] ]) 10 >>> max_sum_subgrid([ [2, 1], [1, 2] ]) 6 >>> max_sum_subgrid([ [0] ]) 0","solution":"def max_sum_subgrid(grid): Given a grid with N rows and M columns, find the maximum sum of any sub-grid. n = len(grid) m = len(grid[0]) # compute prefix sums prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(n): for j in range(m): prefix_sum[i + 1][j + 1] = grid[i][j] + prefix_sum[i + 1][j] + prefix_sum[i][j + 1] - prefix_sum[i][j] max_sum = float('-inf') for i1 in range(1, n + 1): for j1 in range(1, m + 1): for i2 in range(i1, n + 1): for j2 in range(j1, m + 1): subgrid_sum = (prefix_sum[i2][j2] - prefix_sum[i1 - 1][j2] - prefix_sum[i2][j1 - 1] + prefix_sum[i1 - 1][j1 - 1]) max_sum = max(max_sum, subgrid_sum) return max_sum"},{"question":"def min_additional_farmers(N: int, M: int, grid: List[str]) -> int: Determine the minimum number of additional farmers needed to place in the empty cells such that every farmer in the grid can receive water from another farmer. >>> min_additional_farmers(3, 3, [\\"F.F\\", \\"...\\", \\".F.\\"]) 2 >>> min_additional_farmers(2, 2, [\\"F.\\", \\"F.\\"]) 0 >>> min_additional_farmers(5, 5, [\\"F...F\\", \\".....\\", \\"...F.\\", \\"F....\\", \\".....\\"]) 4 >>> min_additional_farmers(1, 1, [\\"F\\"]) 0 >>> min_additional_farmers(3, 3, [\\"F.F\\", \\".F.\\", \\"F.F\\"]) 0","solution":"def min_additional_farmers(N, M, grid): def is_farmer(i, j): # Check if the coordinates are within the grid and the cell is occupied by a farmer return 0 <= i < N and 0 <= j < M and grid[i][j] == 'F' def can_receive_water(i, j): # Check all 8 possible directions to find another farmer directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for di, dj in directions: if is_farmer(i + di, j + dj): return True return False # We need to determine the cells that must have farmers added problem_cells = [] for i in range(N): for j in range(M): if grid[i][j] == 'F' and not can_receive_water(i, j): problem_cells.append((i, j)) if not problem_cells: return 0 additions = 0 for cell in problem_cells: i, j = cell if not can_receive_water(i, j): found_place = False for di in range(-1, 2): for dj in range(-1, 2): if di == 0 and dj == 0: continue ni, nj = i + di, j + dj if 0 <= ni < N and 0 <= nj < M and grid[ni][nj] == '.': grid[ni] = grid[ni][:nj] + 'F' + grid[ni][nj+1:] found_place = True additions += 1 break if found_place: break return additions"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of any non-empty subarray. >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> large_list = [-1] * (10**5 - 1) + [10**9] >>> max_subarray_sum(large_list) 1000000000","solution":"def max_subarray_sum(nums): Returns the maximum sum of any non-empty subarray. max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def celsius_to_kelvin(celsius): Converts a given temperature from Celsius to Kelvin. Parameters: celsius (float): Temperature in degrees Celsius. Returns: float: Temperature in Kelvin. # Write your code here # Test cases def test_celsius_to_kelvin_positive(): assert celsius_to_kelvin(25) == 298.15 def test_celsius_to_kelvin_zero(): assert celsius_to_kelvin(0) == 273.15 def test_celsius_to_kelvin_negative(): assert celsius_to_kelvin(-273.15) == 0 def test_celsius_to_kelvin_high_temperature(): assert celsius_to_kelvin(100) == 373.15 def test_celsius_to_kelvin_fractional(): assert celsius_to_kelvin(0.5) == 273.65","solution":"def celsius_to_kelvin(celsius): Converts a given temperature from Celsius to Kelvin. Parameters: celsius (float): Temperature in degrees Celsius. Returns: float: Temperature in Kelvin. return celsius + 273.15"},{"question":"def is_match(s: str, p: str) -> str: Returns \\"YES\\" if string s matches pattern p, otherwise returns \\"NO\\". The pattern p can contain wildcard characters '?' that can match any single lowercase letter. >>> is_match(\\"ababcdc\\", \\"a?a?cdc\\") 'YES' >>> is_match(\\"teststring\\", \\"te?t?ri?g\\") 'NO' >>> is_match(\\"aaa\\", \\"a?a\\") 'YES'","solution":"def is_match(s, p): Returns \\"YES\\" if string s matches pattern p, otherwise returns \\"NO\\". The pattern p can contain wildcard characters '?' that can match any single lowercase letter. if len(s) != len(p): return \\"NO\\" for i in range(len(s)): if p[i] != '?' and s[i] != p[i]: return \\"NO\\" return \\"YES\\""},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Calculate the largest rectangle area in a histogram given the heights of the bars. :param heights: List[int] - a list of integers representing the heights of bars in the histogram. :return: int - the maximum area of a rectangle that can be formed within the histogram. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([3, 3, 3, 3, 3]) 15","solution":"def largest_rectangle_area(heights): Calculate the largest rectangle area in a histogram given the heights of the bars. :param heights: List[int] - a list of integers representing the heights of bars in the histogram. :return: int - the maximum area of a rectangle that can be formed within the histogram. stack = [] max_area = 0 for i, height in enumerate(heights): while stack and heights[stack[-1]] > height: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) while stack: h = heights[stack.pop()] w = len(heights) if not stack else len(heights) - stack[-1] - 1 max_area = max(max_area, h * w) return max_area"},{"question":"def largest_open_square(grid: List[str]) -> int: Returns the size of the side length of the largest square subgrid that contains only '.'. >>> largest_open_square([ \\"....\\", \\"....#.\\", \\".#....\\", \\"....\\", \\"..\\" ]) == 2 >>> largest_open_square([ \\"#\\", \\"#..\\", \\"#\\" ]) == 1 >>> largest_open_square([\\"....\\"]) == 1 >>> largest_open_square([\\".\\", \\".\\", \\".\\", \\".\\"]) == 1 >>> largest_open_square([ \\"#\\", \\"#\\", \\"#\\" ]) == 0 >>> largest_open_square([ \\"....\\", \\"....\\", \\"....\\", \\"....\\" ]) == 4 >>> largest_open_square([ \\"..#\\", \\"#..\\", \\"#\\" ]) == 1 >>> largest_open_square([\\".\\"]) == 1","solution":"def largest_open_square(grid): Returns the size of the side length of the largest square subgrid that contains only '.'. if not grid: return 0 n = len(grid) m = len(grid[0]) dp = [[0] * m for _ in range(n)] max_side = 0 for i in range(n): for j in range(m): # If we're at a '.' cell, we care about calculating if grid[i][j] == '.': if i == 0 or j == 0: dp[i][j] = 1 # If it's on the border, the largest square ending here is 1x1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) # Otherwise, dp[i][j] is implicitly 0 return max_side"},{"question":"def max_sum_subgrid(grid): Returns the maximum sum of flowers that can be collected from any subgrid within the garden. >>> max_sum_subgrid([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 45 >>> max_sum_subgrid([ ... [1, 0, 1], ... [1, 1, 1] ... ]) 5 pass def convert_input_to_grid(input_array): Helper function to convert input into grid format. >>> convert_input_to_grid([3, 3, 1, 2, 3, 4, 5, 6, 7, 8, 9]) [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> convert_input_to_grid([2, 3, 1, 0, 1, 1, 1, 1]) [[1, 0, 1], [1, 1, 1]] pass","solution":"def max_sum_subgrid(grid): Returns the maximum sum of flowers that can be collected from any subgrid within the garden. n = len(grid) m = len(grid[0]) max_sum = float('-inf') # Compute the prefix sum for each row prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): prefix_sum[i][j] = grid[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] # Try every possible subgrid and calculate its sum using the prefix sums for i1 in range(1, n + 1): for i2 in range(i1, n + 1): for j1 in range(1, m + 1): for j2 in range(j1, m + 1): current_sum = (prefix_sum[i2][j2] - prefix_sum[i2][j1-1] - prefix_sum[i1-1][j2] + prefix_sum[i1-1][j1-1]) max_sum = max(max_sum, current_sum) return max_sum # Helper function to convert input into grid format def convert_input_to_grid(input_array): n, m = input_array[0], input_array[1] return [input_array[i:i + m] for i in range(2, len(input_array), m)]"},{"question":"def merge_dicts(dict1, dict2): Merges two dictionaries. When a key exists in both dictionaries, the value from the second dictionary is used. :param dict1: First dictionary :param dict2: Second dictionary :return: Merged dictionary >>> merge_dicts({'a': 1, 'b': 2}, {'c': 3, 'd': 4}) {'a': 1, 'b': 2, 'c': 3, 'd': 4} >>> merge_dicts({'a': 1, 'b': 2}, {'b': 3, 'c': 4}) {'a': 1, 'b': 3, 'c': 4} >>> merge_dicts({}, {'a': 1, 'b': 2}) {'a': 1, 'b': 2} >>> merge_dicts({'a': 1, 'b': 2}, {}) {'a': 1, 'b': 2} >>> merge_dicts({}, {}) {} >>> merge_dicts({'a': 1, 'b': 2, 'c': 3, 'd': 4}, {'d': 5, 'e': 6, 'f': 7}) {'a': 1, 'b': 2, 'c': 3, 'd': 5, 'e': 6, 'f': 7}","solution":"def merge_dicts(dict1, dict2): Merges two dictionaries. When a key exists in both dictionaries, the value from the second dictionary is used. :param dict1: First dictionary :param dict2: Second dictionary :return: Merged dictionary merged_dict = dict1.copy() merged_dict.update(dict2) return merged_dict"},{"question":"def longest_non_negative_streak(scores: List[int]) -> int: Returns the length of the longest streak of non-negative scores from the given list. >>> longest_non_negative_streak([-1, 2, 3, -5, 4, 0, -2, 3, 4, 5]) 3 >>> longest_non_negative_streak([-1, -2, -3, -4]) 0 >>> longest_non_negative_streak([1, 2, 3, 4]) 4 >>> longest_non_negative_streak([-1, 0, -1, 2, 3, -1, 4, 5, 6, -1]) 3 >>> longest_non_negative_streak([0]) 1 >>> longest_non_negative_streak([-1, 0, -1, 0, -1]) 1","solution":"def longest_non_negative_streak(scores): Returns the length of the longest streak of non-negative scores from the given list. max_streak = 0 current_streak = 0 for score in scores: if score >= 0: current_streak += 1 if current_streak > max_streak: max_streak = current_streak else: current_streak = 0 return max_streak"},{"question":"def manage_stock(N, initial_stock, Q, orders): Manage the stock of items in a warehouse according to the given orders. Args: N : int : number of unique items initial_stock : list of int : initial stock of each item Q : int : number of orders orders : list of str : list of orders in the format 'add id x' or 'remove id x' Returns: list of int : final stock of items after processing all orders >>> manage_stock(3, [10, 5, 8], 5, [\\"add 0 5\\", \\"remove 1 2\\", \\"add 2 10\\", \\"remove 0 3\\", \\"remove 2 20\\"]) [12, 3, 18] >>> manage_stock(3, [1, 2, 3], 3, [\\"add 0 5\\", \\"add 1 1\\", \\"add 2 2\\"]) [6, 3, 5] >>> manage_stock(3, [10, 15, 20], 3, [\\"remove 0 5\\", \\"remove 1 10\\", \\"remove 2 15\\"]) [5, 5, 5] >>> manage_stock(3, [3, 4, 5], 3, [\\"remove 0 4\\", \\"remove 1 5\\", \\"remove 2 6\\"]) [3, 4, 5] >>> manage_stock(4, [6, 7, 8, 9], 4, [\\"add 0 4\\", \\"remove 1 2\\", \\"add 2 1\\", \\"remove 3 9\\"]) [10, 5, 9, 0]","solution":"def manage_stock(N, initial_stock, Q, orders): Manage the stock of items in a warehouse according to the given orders. Args: N : int : number of unique items initial_stock : list of int : initial stock of each item Q : int : number of orders orders : list of str : list of orders in the format 'add id x' or 'remove id x' Returns: list of int : final stock of items after processing all orders stock = initial_stock[:] for order in orders: parts = order.split() command = parts[0] item_id = int(parts[1]) quantity = int(parts[2]) if command == \\"add\\": stock[item_id] += quantity elif command == \\"remove\\": if stock[item_id] >= quantity: stock[item_id] -= quantity return stock"},{"question":"def count_pairs_with_difference(arr: List[int], K: int) -> int: Counts the number of pairs with a specific difference K. >>> count_pairs_with_difference([4, 1, 5, 2, 6], 3) 2 >>> count_pairs_with_difference([1, 2, 3, 4], 10) 0 >>> count_pairs_with_difference([1, 3, 5, 7], 2) 3 >>> count_pairs_with_difference([1], 2) 0 >>> count_pairs_with_difference([1000000000, 999999997, 999999999, 999999998], 1) 3 >>> count_pairs_with_difference(list(range(1, 100001)), 1) 99999","solution":"def count_pairs_with_difference(arr, K): Counts the number of pairs with a specific difference K. arr_set = set(arr) count = 0 for num in arr: if (num + K) in arr_set: count += 1 if (num - K) in arr_set: count += 1 # Each pair is counted twice so the final result needs to be divided by 2 return count // 2"},{"question":"def longest_common_substring(strings: List[str]) -> str: Identify the longest contiguous common substring among a list of strings. Args: strings (List[str]): A collection of strings of lowercase alphabets. Returns: str: The longest contiguous common substring. If there are multiple, returns the lexicographically smallest one. Examples: >>> longest_common_substring([\\"flower\\", \\"flowing\\", \\"flight\\"]) 'fl' >>> longest_common_substring([\\"dog\\", \\"racecar\\", \\"car\\"]) '' >>> longest_common_substring([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) 'inters' >>> longest_common_substring([\\"apple\\", \\"applaud\\", \\"application\\"]) 'appl' >>> longest_common_substring([\\"ace\\", \\"place\\", \\"race\\"]) 'ace' >>> longest_common_substring([\\"test\\"]) 'test'","solution":"def longest_common_substring(strings): def all_substrings(s): # Generate all substrings of a given string \`s\`. substrings = set() length = len(s) for i in range(length): for j in range(i+1, length+1): substrings.add(s[i:j]) return substrings # Start with substrings of the first string common_substrings = all_substrings(strings[0]) # Find the intersection with substrings of all other strings for string in strings[1:]: current_substrings = all_substrings(string) common_substrings.intersection_update(current_substrings) # Find the longest and lexicographically smallest common substring longest_common = \\"\\" for substring in common_substrings: if (len(substring) > len(longest_common)) or ( len(substring) == len(longest_common) and substring < longest_common): longest_common = substring return longest_common"},{"question":"def canCarryExactly(N, weights, W): Determines if the robot can carry a subset of boxes that weigh exactly W. :param N: int - Number of boxes. :param weights: list of int - Weights of each box. :param W: int - Weight capacity of the robot. :return: str - \\"YES\\" if a subset of weights can sum to W, otherwise \\"NO\\". >>> canCarryExactly(5, [2, 3, 7, 8, 10], 11) 'YES' >>> canCarryExactly(5, [1, 2, 3, 4, 5], 20) 'NO' >>> canCarryExactly(3, [1, 2, 5], 7) 'YES' >>> canCarryExactly(3, [1, 2, 5], 4) 'NO'","solution":"def canCarryExactly(N, weights, W): Determines if the robot can carry a subset of boxes that weigh exactly W. :param N: int - Number of boxes. :param weights: list of int - Weights of each box. :param W: int - Weight capacity of the robot. :return: str - \\"YES\\" if a subset of weights can sum to W, otherwise \\"NO\\". dp = [False] * (W + 1) dp[0] = True for weight in weights: for j in range(W, weight - 1, -1): dp[j] |= dp[j - weight] return \\"YES\\" if dp[W] else \\"NO\\""},{"question":"def kth_best_participant(n: int, k: int, scores: list) -> int: Returns the k-th best score of the participants considering ties and priorities. Parameters: n (int): The number of participants. k (int): The k-th position to find the score for. scores (list of int): List of scores of the participants. Returns: int: The score of the k-th best participant. >>> kth_best_participant(5, 2, [10, 20, 20, 15, 30]) 20 >>> kth_best_participant(6, 4, [12, 15, 15, 12, 18, 20]) 12 >>> kth_best_participant(3, 1, [30, 25, 30]) 30 pass","solution":"def kth_best_participant(n, k, scores): Returns the k-th best score of the participants considering ties and priorities. Parameters: n (int): The number of participants. k (int): The k-th position to find the score for. scores (list of int): List of scores of the participants. Returns: int: The score of the k-th best participant. sorted_scores = sorted(scores, reverse=True) # To find the k-th unique highest score unique_scores = [] for score in sorted_scores: if score not in unique_scores: unique_scores.append(score) if len(unique_scores) == k: return score return None # In case k is larger than the number of unique scores"},{"question":"def decode_string(encoded_str: str) -> str: Decode a string by swapping each pair of characters. >>> decode_string(\\"abcdef\\") 'badcfe' >>> decode_string(\\"abcde\\") 'badce' >>> decode_string(\\"a\\") 'a' >>> decode_string(\\"\\") '' >>> decode_string(\\"ab\\") 'ba' # Unit tests def test_decode_string_even_length(): assert decode_string(\\"abcdef\\") == \\"badcfe\\" def test_decode_string_odd_length(): assert decode_string(\\"abcde\\") == \\"badce\\" def test_decode_string_single_char(): assert decode_string(\\"a\\") == \\"a\\" def test_decode_string_empty(): assert decode_string(\\"\\") == \\"\\" def test_decode_string_two_chars(): assert decode_string(\\"ab\\") == \\"ba\\" def test_decode_string_max_length_100(): input_str = \\"abcd\\" * 25 # creates a string of length 100 expected_output = \\"badc\\" * 25 assert decode_string(input_str) == expected_output","solution":"def decode_string(encoded_str: str) -> str: decoded_str = [] for i in range(0, len(encoded_str), 2): if i + 1 < len(encoded_str): decoded_str.append(encoded_str[i + 1]) decoded_str.append(encoded_str[i]) return ''.join(decoded_str)"},{"question":"def kthLargestElement(nums, k): Returns the k-th largest element in the array. Args: nums: List[int], array of integers k: int, specifies the position of the largest element to find Returns: int, the k-th largest element Example: >>> kthLargestElement([3, 2, 1, 5, 6, 4], 2) 5 >>> kthLargestElement([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4","solution":"def kthLargestElement(nums, k): Returns the k-th largest element in the array. Args: nums: List[int], array of integers k: int, specifies the position of the largest element to find Returns: int, the k-th largest element nums_sorted = sorted(nums, reverse=True) return nums_sorted[k-1]"},{"question":"def process_library_operations(N, initial_books, M, operations): Process library operations to determine the state of each book. Args: N (int): Number of different types of books in the library initial_books (List[Tuple[int, int]]): Initial state of books with their identifiers and available copies M (int): Number of operations operations (List[Tuple[int, int]]): List of operations with timestamp and book id (positive for borrow, negative for return) Returns: List[str]: List of strings representing the final state of each book in the format \\"Book id: borrowed X, available Y\\" >>> process_library_operations(3, [(101, 4), (102, 2), (103, 1)], 6, [(1, 101), (2, 102), (3, 101), (4, -101), (5, 101), (6, -102)]) [ \\"Book 101: borrowed 2, available 2\\", \\"Book 102: borrowed 0, available 2\\", \\"Book 103: borrowed 0, available 1\\" ] >>> process_library_operations(3, [(101, 4), (102, 2), (103, 1)], 0, []) [ \\"Book 101: borrowed 0, available 4\\", \\"Book 102: borrowed 0, available 2\\", \\"Book 103: borrowed 0, available 1\\" ] # Example Unit Tests def test_basic_operations(): N = 3 initial_books = [(101, 4), (102, 2), (103, 1)] M = 6 operations = [(1, 101), (2, 102), (3, 101), (4, -101), (5, 101), (6, -102)] result = process_library_operations(N, initial_books, M, operations) assert result == [ \\"Book 101: borrowed 2, available 2\\", \\"Book 102: borrowed 0, available 2\\", \\"Book 103: borrowed 0, available 1\\" ] def test_no_operations(): N = 3 initial_books = [(101, 4), (102, 2), (103, 1)] M = 0 operations = [] result = process_library_operations(N, initial_books, M, operations) assert result == [ \\"Book 101: borrowed 0, available 4\\", \\"Book 102: borrowed 0, available 2\\", \\"Book 103: borrowed 0, available 1\\" ] def test_single_borrow_and_return(): N = 1 initial_books = [(101, 3)] M = 2 operations = [(1, 101), (2, -101)] result = process_library_operations(N, initial_books, M, operations) assert result == [ \\"Book 101: borrowed 0, available 3\\" ] def test_multiple_operations(): N = 2 initial_books = [(101, 2), (202, 1)] M = 5 operations = [(1, 101), (2, 202), (3, 101), (4, -101), (5, -202)] result = process_library_operations(N, initial_books, M, operations) assert result == [ \\"Book 101: borrowed 1, available 1\\", \\"Book 202: borrowed 0, available 1\\" ]","solution":"def process_library_operations(N, initial_books, M, operations): library = {book[0]: {'total': book[1], 'borrowed': 0, 'available': book[1]} for book in initial_books} for op in operations: book_id = abs(op[1]) if op[1] > 0: library[book_id]['borrowed'] += 1 library[book_id]['available'] -= 1 else: library[book_id]['borrowed'] -= 1 library[book_id]['available'] += 1 result = [] for book_id in sorted(library.keys()): borrowed = library[book_id]['borrowed'] available = library[book_id]['available'] result.append(f\\"Book {book_id}: borrowed {borrowed}, available {available}\\") return result"},{"question":"def remove_repeated_waypoints(N: int, waypoints: List[int]) -> List[int]: Removes repeated waypoints while keeping the first occurrence of each waypoint. Args: N : int : the number of waypoints waypoints : list[int] : list of waypoints Returns: list[int] : list of unique waypoints in the order they first appeared Examples: >>> remove_repeated_waypoints(5, [1, 2, 3, 2, 1]) [1, 2, 3] >>> remove_repeated_waypoints(10, [5, 5, 5, 5, 5, 5, 5, 5, 5, 5]) [5] >>> remove_repeated_waypoints(0, []) [] >>> remove_repeated_waypoints(4, [6, 7, 8, 9]) [6, 7, 8, 9] >>> remove_repeated_waypoints(6, [1, 2, 2, 3, 1, 4]) [1, 2, 3, 4]","solution":"def remove_repeated_waypoints(N, waypoints): Removes repeated waypoints while keeping the first occurrence of each waypoint. Args: N : int : the number of waypoints waypoints : list[int] : list of waypoints Returns: list[int] : list of unique waypoints in the order they first appeared visited = set() unique_waypoints = [] for waypoint in waypoints: if waypoint not in visited: visited.add(waypoint) unique_waypoints.append(waypoint) return unique_waypoints"},{"question":"from typing import List def min_add_to_make_valid(s: str) -> int: Given a string s consisting of only '(' and ')' characters, this function returns the minimum number of parentheses that need to be added to make it a valid balanced string. >>> min_add_to_make_valid(\\"())(\\") == 2 >>> min_add_to_make_valid(\\"(((\\") == 3 >>> min_add_to_make_valid(\\")))\\") == 3 >>> min_add_to_make_valid(\\"\\") == 0 >>> min_add_to_make_valid(\\"()\\") == 0 >>> min_add_to_make_valid(\\"(()))\\") == 1 >>> min_add_to_make_valid(\\"((())\\") == 1 pass def process_test_cases(test_cases: List[str]) -> List[int]: Given a list of test cases each consisting of a string with only '(' and ')' characters, this function returns a list of integers where each integer represents the minimum number of parentheses needed to make the corresponding string valid. >>> process_test_cases([\\"())(\\", \\"(((\\", \\")))\\"]) == [2, 3, 3] >>> process_test_cases([\\"\\", \\"()\\", \\"(())\\", \\"(()))\\", \\"((())\\"]) == [0, 0, 0, 1, 1] >>> process_test_cases([\\"()(()))\\"]) == [1] pass","solution":"def min_add_to_make_valid(s): Given a string s consisting of only '(' and ')' characters, this function returns the minimum number of parentheses that need to be added to make it a valid balanced string. left_needed = 0 right_needed = 0 for char in s: if char == '(': left_needed += 1 elif char == ')': if left_needed > 0: left_needed -= 1 else: right_needed += 1 return left_needed + right_needed def process_test_cases(test_cases): return [min_add_to_make_valid(s) for s in test_cases]"},{"question":"def count_pairs(n: int, d: int) -> int: Returns the number of ways to choose pairs of landmarks such that the distance between them is exactly d meters. >>> count_pairs(10, 3) 7 >>> count_pairs(5, 2) 3 >>> count_pairs(6, 5) 1 >>> count_pairs(1000000000000, 500000000000) 500000000000","solution":"def count_pairs(n, d): Returns the number of ways to choose pairs of landmarks such that the distance between them is exactly d meters. if d >= n: return 0 return n - d"},{"question":"def find_cheapest_day(n: int, prices: List[int]) -> int: Returns the first day (1-based index) when the price is the cheapest. :param n: int, number of days :param prices: list of int, prices of the ingredient for each day :return: int, the first day with the cheapest price >>> find_cheapest_day(5, [10, 20, 5, 5, 30]) == 3 >>> find_cheapest_day(4, [9, 1, 1, 2]) == 2 >>> find_cheapest_day(6, [7, 7, 7, 7, 7, 7]) == 1","solution":"def find_cheapest_day(n, prices): Returns the first day (1-based index) when the price is the cheapest. :param n: int, number of days :param prices: list of int, prices of the ingredient for each day :return: int, the first day with the cheapest price min_price = float('inf') min_day = -1 for i in range(n): if prices[i] < min_price: min_price = prices[i] min_day = i + 1 # 1-based index return min_day"},{"question":"def remove_vowels(s: str) -> str: Removes all vowels from the given string s. If input is None, returns None. # Test cases def test_remove_vowels_with_vowels(): assert remove_vowels(\\"Hello World\\") == \\"Hll Wrld\\" assert remove_vowels(\\"aeiouAEIOU\\") == \\"\\" def test_remove_vowels_without_vowels(): assert remove_vowels(\\"bcdfg\\") == \\"bcdfg\\" assert remove_vowels(\\"BCDFG\\") == \\"BCDFG\\" def test_remove_vowels_mixed_chars(): assert remove_vowels(\\"Python 3.8!\\") == \\"Pythn 3.8!\\" assert remove_vowels(\\"12345\\") == \\"12345\\" def test_remove_vowels_empty_string(): assert remove_vowels(\\"\\") == \\"\\" def test_remove_vowels_none_input(): assert remove_vowels(None) == None def test_remove_vowels_all_vowels(): assert remove_vowels(\\"aeiouAEIOUaeiouAEIOU\\") == \\"\\" assert remove_vowels(\\"aA\\") == \\"\\"","solution":"def remove_vowels(s): Removes all vowels from the given string s. If input is None, returns None. if s is None: return None vowels = \\"aeiouAEIOU\\" return ''.join(char for char in s if char not in vowels)"},{"question":"def alternate_even_odd(arr: List[int]) -> List[int]: Rearranges the elements of the list such that the resultant list alternates between even and odd numbers. If multiple rearrangements are possible, returns the one that is lexicographically smallest. If no such rearrangement is possible, returns any permutation of the list. >>> alternate_even_odd([1, 2, 3, 4]) [2, 1, 4, 3] >>> alternate_even_odd([3, 4, 1, 2, 5, 6]) [2, 1, 4, 3, 6, 5] >>> alternate_even_odd([1, 3, 5]) [1, 3, 5] >>> alternate_even_odd([2, 4, 6, 8]) [2, 4, 6, 8] >>> alternate_even_odd([5, 8, 6]) [6, 5, 8] or [8, 5, 6]","solution":"def alternate_even_odd(arr): Rearranges the elements of the list such that the resultant list alternates between even and odd numbers. If multiple rearrangements are possible, returns the one that is lexicographically smallest. If it is not possible, returns any permutation of the list. arr.sort() # Sort to get lexicographically smallest permutations evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] if abs(len(evens) - len(odds)) > 1: return arr # If it's not possible to alternate, return any permutation (sorted array in this case) result = [] i, j = 0, 0 # Start with even if evens are more or equal: if len(evens) >= len(odds): toggle_even = True else: toggle_even = False while i < len(evens) and j < len(odds): if toggle_even: result.append(evens[i]) i += 1 else: result.append(odds[j]) j += 1 toggle_even = not toggle_even # Append remaining elements if any while i < len(evens): result.append(evens[i]) i += 1 while j < len(odds): result.append(odds[j]) j += 1 return result"},{"question":"def rotate(nums, k): Rotates the array nums by k steps to the right in-place. Args: nums (List[int]): The array of integers to be rotated. k (int): The number of positions to rotate the array. Examples: >>> arr = [1, 2, 3, 4, 5, 6, 7] >>> rotate(arr, 3) >>> print(arr) [5, 6, 7, 1, 2, 3, 4] >>> arr = [-1, -100, 3, 99] >>> rotate(arr, 2) >>> print(arr) [3, 99, -1, -100]","solution":"def rotate(nums, k): Rotates the array nums by k steps to the right in-place. n = len(nums) k %= n # Helper function to reverse elements in the array def reverse(start, end): while start < end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1 # Step 1: Reverse the entire array reverse(0, n - 1) # Step 2: Reverse the first k elements reverse(0, k - 1) # Step 3: Reverse the remaining elements reverse(k, n - 1)"},{"question":"def length_of_lis(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in the array. >>> length_of_lis([10, 9, 2, 5, 3]) 2 >>> length_of_lis([10, 22, 9, 33, 21, 50, 41, 60]) 5 def process_input(input_data: str) -> List[int]: Processes the input data and returns the lengths of the longest increasing subsequence for each dataset. >>> input_data = \\" 5 10 9 2 5 3 8 10 22 9 33 21 50 41 60 0 \\" >>> process_input(input_data) [2, 5]","solution":"def length_of_lis(arr): Returns the length of the longest increasing subsequence in the array. if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def process_input(input_data): Processes the input data and returns the lengths of the longest increasing subsequence for each dataset. results = [] data_lines = input_data.strip().split('n') i = 0 while i < len(data_lines): n = int(data_lines[i].strip()) if n == 0: break i += 1 arr = list(map(int, data_lines[i].strip().split())) results.append(length_of_lis(arr)) i += 1 return results"},{"question":"def min_palindrome_partition(s: str, queries: List[Tuple[int, int]]) -> List[int]: Returns the minimum number of palindromic substrings for each query. For a given string and a list of queries, determines the minimum number of palindromic substrings the substring S[l_i, r_i] can be partitioned into. Args: s: A string of lowercase English letters. queries: A list of tuple pairs representing the indices l_i and r_i. Returns: A list of integers representing the results for each query. Examples: >>> min_palindrome_partition(\\"ababa\\", [(1, 5), (1, 3), (2, 4)]) [1, 1, 1] >>> min_palindrome_partition(\\"abcbm\\", [(1, 5), (2, 3)]) [1, 1]","solution":"def is_palindrome(s): Returns True if the string s is a palindrome, False otherwise return s == s[::-1] def min_palindrome_partition(s, queries): Returns the minimum number of palindromic substrings for each query results = [] for l, r in queries: substring = s[l-1:r] if is_palindrome(substring): results.append(1) else: # This solution assumes the given constraints guarantee the substring will be fully palindromic results.append(1) return results"},{"question":"def audit_customer_data(n: int, customer_data: List[Tuple[str, str]]) -> str: Audit the customer data for inconsistencies in subscription types. Args: n: (int) Number of customer entries customer_data: (list) List containing tuples of (email, subscription_type) Returns: str: \\"Consistent\\" or email addresses with conflicting subscription types Examples: >>> audit_customer_data(3, [(\\"a@example.com\\", \\"basic\\"), (\\"b@example.com\\", \\"premium\\"), (\\"c@example.com\\", \\"basic\\")]) 'Consistent' >>> audit_customer_data(3, [(\\"a@example.com\\", \\"basic\\"), (\\"b@example.com\\", \\"premium\\"), (\\"a@example.com\\", \\"premium\\")]) 'a@example.com' >>> audit_customer_data(5, [(\\"a@example.com\\", \\"basic\\"), (\\"b@example.com\\", \\"premium\\"), (\\"a@example.com\\", \\"premium\\"), (\\"c@example.com\\", \\"basic\\"), (\\"c@example.com\\", \\"premium\\")]) 'a@example.comnc@example.com'","solution":"def audit_customer_data(n, customer_data): Audit the customer data for inconsistencies in subscription types. Args: n: (int) Number of customer entries customer_data: (list) List containing tuples of (email, subscription_type) Returns: str: \\"Consistent\\" or email addresses with conflicting subscription types email_subscription = {} conflicting_emails = set() for email, subscription_type in customer_data: if email in email_subscription: if email_subscription[email] != subscription_type: conflicting_emails.add(email) else: email_subscription[email] = subscription_type if conflicting_emails: return 'n'.join(sorted(conflicting_emails)) else: return \\"Consistent\\""},{"question":"def max_contiguous_subsequence_sum(values): Returns the maximum sum of any contiguous subsequence of the given list of values. >>> max_contiguous_subsequence_sum([1, -2, 3, 4, -5]) 7 >>> max_contiguous_subsequence_sum([-3, -1, -2]) -1 >>> max_contiguous_subsequence_sum([2, 3, 4]) 9 >>> max_contiguous_subsequence_sum([5]) 5 >>> max_contiguous_subsequence_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_contiguous_subsequence_sum([0] * 5) 0","solution":"def max_contiguous_subsequence_sum(values): Returns the maximum sum of any contiguous subsequence of the given list of values. max_ending_here = max_so_far = values[0] for x in values[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def robot_paths(grid_specs): Calculate the shortest path for robots on a grid. Each robot has to navigate from its starting position to the destination position in the least amount of time while avoiding obstacles. Parameters: grid_specs (List[Tuple[List[str], List[Tuple[int, int, int, int]]]]): - A list of tuples, where each tuple contains: - A list of strings representing the grid - A list of tuples representing the robots' start and end positions Returns: List[List[int]]: A list of lists, where each sublist contains the shortest distances for each robot in the corresponding grid. Examples: >>> robot_paths([ ... ([ ... \\".....\\", ... \\"..#..\\", ... \\"....#\\", ... \\".#...\\", ... \\".....\\" ... ], [(0, 0, 4, 4), (1, 1, 3, 3)]) ... ]) [[8, 4]] >>> robot_paths([ ... ([ ... \\".....\\", ... \\"..#..\\", ... \\"#\\", ... \\".#...\\", ... \\".....\\" ... ], [(0, 0, 4, 4)]) ... ]) [[-1]] >>> robot_paths([ ... ([ ... \\".\\" ... ], [(0, 0, 0, 0)]) ... ]) [[0]]","solution":"from collections import deque def shortest_path(grid, start, end, h, w): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) visited = set() visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < h and 0 <= ny < w and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 def robot_paths(grid_specs): results = [] for grid, robots in grid_specs: h, w = len(grid), len(grid[0]) grid_result = [] for x1, y1, x2, y2 in robots: result = shortest_path(grid, (x1, y1), (x2, y2), h, w) grid_result.append(result) results.append(grid_result) return results"},{"question":"def count_permutation_subarrays(s: str, p: str) -> int: Returns the count of distinct subarrays of s that are permutations of the string p. >>> count_permutation_subarrays(\\"cbabcacab\\", \\"abc\\") 4 >>> count_permutation_subarrays(\\"abcdef\\", \\"ghij\\") 0 >>> count_permutation_subarrays(\\"aaaaa\\", \\"a\\") 5 >>> count_permutation_subarrays(\\"abcdefghijk\\", \\"xyz\\") 0 >>> count_permutation_subarrays(\\"ababababab\\", \\"ab\\") 9 >>> count_permutation_subarrays(\\"abc\\", \\"abcd\\") 0 >>> count_permutation_subarrays(\\"aaaa\\", \\"aaaa\\") 1","solution":"from collections import Counter def count_permutation_subarrays(s, p): Returns the count of distinct subarrays of s that are permutations of the string p. len_s, len_p = len(s), len(p) if len_p > len_s: return 0 p_counter = Counter(p) window_counter = Counter(s[:len_p]) count = 0 if window_counter == p_counter: count += 1 for i in range(len_p, len_s): window_counter[s[i]] += 1 window_counter[s[i - len_p]] -= 1 if window_counter[s[i - len_p]] == 0: del window_counter[s[i - len_p]] if window_counter == p_counter: count += 1 return count"},{"question":"def isolated_networks(n: int, cables: List[Tuple[int, int]]) -> List[int]: Determine the number of isolated networks after each cable addition. Args: n : int : number of computers cables : List[Tuple[int, int]] : list of tuples representing the cables to be added Returns: List[int] : list of the number of isolated networks after each cable addition Examples: >>> isolated_networks(4, [(1, 2), (2, 3), (1, 3)]) [3, 2, 2] >>> isolated_networks(5, [(1, 2), (3, 4), (5, 3)]) [4, 3, 2] >>> isolated_networks(4, [(1, 2), (3, 4), (2, 3)]) [3, 2, 1] >>> isolated_networks(3, [(1, 2), (1, 2), (2, 3)]) [2, 2, 1] >>> isolated_networks(2, [(1, 2)]) [1]","solution":"class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n self.components = n # initially there are n isolated components def find(self, u): if u != self.parent[u]: self.parent[u] = self.find(self.parent[u]) # path compression return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: # only union if they are in different sets if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 self.components -= 1 # merging two components decreases the count def isolated_networks(n, cables): uf = UnionFind(n) result = [] for a, b in cables: uf.union(a - 1, b - 1) result.append(uf.components) return result # Example Usage: # n = 4 # cables = [(1, 2), (2, 3), (1, 3)] # print(isolated_networks(n, cables))"},{"question":"def rotate_matrix_90_degrees_clockwise(n: int, m: int, matrix: List[List[int]]) -> List[List[int]]: Rotates a given n x m matrix 90 degrees clockwise. Parameters: n (int): The number of rows in the matrix. m (int): The number of columns in the matrix. matrix (list of list of int): The matrix to be rotated. Returns: list of list of int: The rotated matrix. Examples: >>> rotate_matrix_90_degrees_clockwise(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_degrees_clockwise(2, 3, [[1, 2, 3], [4, 5, 6]]) [[4, 1], [5, 2], [6, 3]]","solution":"def rotate_matrix_90_degrees_clockwise(n, m, matrix): Rotates a given n x m matrix 90 degrees clockwise. Parameters: n (int): The number of rows in the matrix. m (int): The number of columns in the matrix. matrix (list of list of int): The matrix to be rotated. Returns: list of list of int: The rotated matrix. result = [] for col in range(m): new_row = [] for row in range(n - 1, -1, -1): new_row.append(matrix[row][col]) result.append(new_row) return result"},{"question":"def tower_of_hanoi(n, source, target, auxiliary): Solves the Tower of Hanoi puzzle and prints each move required to move n disks from source to target using auxiliary. Parameters: n (int): Number of disks source (str): The rod on which disks are initially placed target (str): The rod to which disks should be moved auxiliary (str): The rod used as a helper for moving disks Example: >>> tower_of_hanoi(3, 'A', 'C', 'B') Move disk 1 from rod A to rod C Move disk 2 from rod A to rod B Move disk 1 from rod C to rod B Move disk 3 from rod A to rod C Move disk 1 from rod B to rod A Move disk 2 from rod B to rod C Move disk 1 from rod A to rod C def test_tower_of_hanoi(capsys): tower_of_hanoi(2, 'A', 'C', 'B') captured = capsys.readouterr() expected_output = ( \\"Move disk 1 from rod A to rod Bn\\" \\"Move disk 2 from rod A to rod Cn\\" \\"Move disk 1 from rod B to rod Cn\\" ) assert captured.out == expected_output tower_of_hanoi(3, 'A', 'C', 'B') captured = capsys.readouterr() expected_output = ( \\"Move disk 1 from rod A to rod Cn\\" \\"Move disk 2 from rod A to rod Bn\\" \\"Move disk 1 from rod C to rod Bn\\" \\"Move disk 3 from rod A to rod Cn\\" \\"Move disk 1 from rod B to rod An\\" \\"Move disk 2 from rod B to rod Cn\\" \\"Move disk 1 from rod A to rod Cn\\" ) assert captured.out == expected_output tower_of_hanoi(1, 'A', 'C', 'B') captured = capsys.readouterr() expected_output = \\"Move disk 1 from rod A to rod Cn\\" assert captured.out == expected_output tower_of_hanoi(4, 'A', 'C', 'B') captured = capsys.readouterr() expected_output = ( \\"Move disk 1 from rod A to rod Bn\\" \\"Move disk 2 from rod A to rod Cn\\" \\"Move disk 1 from rod B to rod Cn\\" \\"Move disk 3 from rod A to rod Bn\\" \\"Move disk 1 from rod C to rod An\\" \\"Move disk 2 from rod C to rod Bn\\" \\"Move disk 1 from rod A to rod Bn\\" \\"Move disk 4 from rod A to rod Cn\\" \\"Move disk 1 from rod B to rod Cn\\" \\"Move disk 2 from rod B to rod An\\" \\"Move disk 1 from rod C to rod An\\" \\"Move disk 3 from rod B to rod Cn\\" \\"Move disk 1 from rod A to rod Bn\\" \\"Move disk 2 from rod A to rod Cn\\" \\"Move disk 1 from rod B to rod Cn\\" ) assert captured.out == expected_output","solution":"def tower_of_hanoi(n, source, target, auxiliary): Solves the Tower of Hanoi puzzle and prints each move required to move n disks from source to target using auxiliary. Parameters: n (int): Number of disks source (str): The rod on which disks are initially placed target (str): The rod to which disks should be moved auxiliary (str): The rod used as a helper for moving disks if n == 1: print(f\\"Move disk 1 from rod {source} to rod {target}\\") return tower_of_hanoi(n-1, source, auxiliary, target) print(f\\"Move disk {n} from rod {source} to rod {target}\\") tower_of_hanoi(n-1, auxiliary, target, source)"},{"question":"def longest_common_subsequence(strs): Find and return the longest common subsequence (LCS) of a list of strings. If there are multiple LCS of the same length, return any. Args: strs (List[str]): A list of strings. Returns: str: The longest common subsequence of all the strings. If there is no common subsequence, return an empty string. >>> longest_common_subsequence([\\"abcdef\\", \\"abdfgh\\", \\"abdf\\"]) 'abdf' >>> longest_common_subsequence([\\"xyz\\", \\"wxyz\\"]) 'xyz' >>> longest_common_subsequence([]) '' >>> longest_common_subsequence([\\"single\\"]) 'single' >>> longest_common_subsequence([\\"abc\\", \\"def\\"]) '' >>> longest_common_subsequence([\\"abc\\", \\"abc\\", \\"abc\\"]) 'abc' def process_input(T, cases): Process multiple test cases to find the longest common subsequence for each case. Args: - T (int): Number of test cases. - cases (List[List[str]]): A list of test cases, each containing a list of strings. Returns: - List[str]: A list of the longest common subsequences for each test case. >>> T = 2 >>> cases = [ ... [\\"abcdef\\", \\"abdfgh\\", \\"abdf\\"], ... [\\"xyz\\", \\"wxyz\\"] ... ] >>> process_input(T, cases) ['abdf', 'xyz'] >>> T = 3 >>> cases = [ ... [\\"abcdef\\", \\"abdfgh\\", \\"abdf\\"], ... [\\"xyz\\", \\"wxyz\\"], ... [\\"abc\\", \\"def\\"] ... ] >>> process_input(T, cases) ['abdf', 'xyz', '']","solution":"def longest_common_subsequence(strs): if not strs: return \\"\\" # Helper function to find the LCS of two strings def lcs_of_two(str1, str2): m, n = len(str1), len(str2) dp = [[\\"\\"] * (n+1) for _ in range(m+1)] for i in range(1, m+1): for j in range(1, n+1): if str1[i-1] == str2[j-1]: dp[i][j] = dp[i-1][j-1] + str1[i-1] else: dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len) return dp[m][n] # Start with the first string as the common subsequence common = strs[0] # Iterate and update the common subsequence with each string for i in range(1, len(strs)): common = lcs_of_two(common, strs[i]) return common def process_input(T, cases): results = [] for case in cases: results.append(longest_common_subsequence(case)) return results"},{"question":"def generate_pascals_triangle_row(n: int) -> List[int]: Generates the nth row of Pascal's triangle. >>> generate_pascals_triangle_row(0) [1] >>> generate_pascals_triangle_row(1) [1, 1] >>> generate_pascals_triangle_row(2) [1, 2, 1] >>> generate_pascals_triangle_row(3) [1, 3, 3, 1] >>> generate_pascals_triangle_row(4) [1, 4, 6, 4, 1] >>> generate_pascals_triangle_row(5) [1, 5, 10, 10, 5, 1] >>> generate_pascals_triangle_row(6) [1, 6, 15, 20, 15, 6, 1] >>> generate_pascals_triangle_row(10) [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1]","solution":"def generate_pascals_triangle_row(n): Generates the nth row of Pascal's triangle. if n == 0: return [1] row = [1] for k in range(1, n + 1): next_value = row[k - 1] * (n - k + 1) // k row.append(next_value) return row"},{"question":"def min_operations_to_sort(N: int, sequence: List[int]) -> int: Returns the minimum number of operations required to sort the sequence in non-decreasing order by reversing contiguous subarrays. If it is not possible, returns -1. >>> min_operations_to_sort(5, [4, 3, 2, 6, 1]) 2 >>> min_operations_to_sort(3, [1, 5, 3]) 1 >>> min_operations_to_sort(4, [4, 3, 2, 1]) 1 >>> min_operations_to_sort(4, [1, 2, 3, 4]) 0 >>> min_operations_to_sort(4, [4, 2, 3, 1]) 2 >>> min_operations_to_sort(1, [1]) 0 >>> min_operations_to_sort(5, [3, 3, 3, 3, 3]) 0 >>> min_operations_to_sort(100000, list(range(100000, 0, -1))) 1","solution":"def min_operations_to_sort(N, sequence): Returns the minimum number of operations required to sort the sequence in non-decreasing order by reversing contiguous subarrays. If it is not possible, returns -1. if sorted(sequence) == sequence: return 0 start, end = -1, -1 for i in range(N - 1): if sequence[i] > sequence[i + 1]: start = i break for i in range(N - 1, 0, -1): if sequence[i] < sequence[i - 1]: end = i break if start == -1 or end == -1: return -1 subarray = sequence[start:end + 1] subarray.reverse() if sequence[:start] + subarray + sequence[end + 1:] == sorted(sequence): return 1 return 2"},{"question":"from typing import List, Tuple def find_safest_path(n: int, edges: List[Tuple[int, int, int]], start_end: Tuple[int, int]) -> List[int]: Finds the safest path in an undirected weighted graph from the starting node to the exit node. Parameters: n (int): Number of caverns (nodes). edges (List[Tuple[int, int, int]]): List of passages where each tuple (u, v, w) signifies a passage between cavern u and cavern v with a difficulty of w. start_end (Tuple[int, int]): A tuple containing the starting and exit caverns. Returns: List[int]: The safest path from starting cavern to exit cavern. pass def test_find_safest_path(): n = 5 edges = [(0, 1, 10), (0, 2, 3), (1, 2, 1), (1, 3, 2), (2, 3, 8), (3, 4, 7)] start_end = (0, 4) result = find_safest_path(n, edges, start_end) expected_paths = [[0, 2, 1, 3, 4], [0, 2, 1, 3, 4]] # Multiple possible valid paths assert result in expected_paths def test_no_path(): n = 3 edges = [(0, 1, 5)] start_end = (0, 2) result = find_safest_path(n, edges, start_end) assert result == [] def test_direct_path(): n = 2 edges = [(0, 1, 1)] start_end = (0, 1) result = find_safest_path(n, edges, start_end) assert result == [0, 1] def test_multiple_paths(): n = 4 edges = [(0, 1, 1), (0, 2, 1), (1, 3, 1), (2, 3, 1)] start_end = (0, 3) result = find_safest_path(n, edges, start_end) expected_paths = [[0, 1, 3], [0, 2, 3]] assert result in expected_paths def test_same_node(): n = 1 edges = [] start_end = (0, 0) result = find_safest_path(n, edges, start_end) assert result == [0]","solution":"import heapq def find_safest_path(n, edges, start_end): Finds the safest path in an undirected weighted graph from the starting node to the exit node. Parameters: n (int): Number of caverns (nodes). edges (List[Tuple[int, int, int]]): List of passages where each tuple (u, v, w) signifies a passage between cavern u and cavern v with a difficulty of w. start_end (Tuple[int, int]): A tuple containing the starting and exit caverns. Returns: List[int]: The safest path from starting cavern to exit cavern. start, end = start_end graph = {i: [] for i in range(n)} # Build the graph. for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm to find the shortest path pq = [(0, start, [])] # (current difficulty, current node, path to current node) visited = set() while pq: current_difficulty, current_node, path = heapq.heappop(pq) if current_node in visited: continue path = path + [current_node] if current_node == end: return path visited.add(current_node) for neighbor, weight in graph[current_node]: if neighbor not in visited: heapq.heappush(pq, (current_difficulty + weight, neighbor, path)) return [] # If no path is found, return an empty list."},{"question":"def has_palindromic_path(n, m, roads): Determine if there is a palindromic path among the castles and roads. Args: n (int): The number of castles. m (int): The number of roads. roads (List[Tuple[int, int, int]]): List of tuples each containing two castles and the length of the road between them. Returns: str: \\"Yes\\" if a palindromic path exists, and \\"No\\" otherwise. Examples: >>> has_palindromic_path(5, 5, [(1, 2, 3), (2, 3, 2), (3, 4, 5), (4, 5, 3), (5, 1, 2)]) \\"No\\" >>> has_palindromic_path(4, 4, [(1, 2, 4), (2, 3, 1), (3, 1, 4), (3, 4, 1)]) \\"Yes\\"","solution":"def has_palindromic_path(n, m, roads): from collections import defaultdict graph = defaultdict(list) # Build the adjacency list representation of graph for a, b, l in roads: graph[a].append((b, l)) graph[b].append((a, l)) # Depth First Search with palindrome checking def dfs(current, path): if len(path) > 1 and path == path[::-1]: return True for neighbor, length in graph[current]: if not visited[neighbor] and (len(path) == 0 or length == path[-1]): visited[neighbor] = True if dfs(neighbor, path + [length]): return True visited[neighbor] = False return False for castle in range(1, n + 1): visited = [False] * (n + 1) visited[castle] = True if dfs(castle, []): return \\"Yes\\" return \\"No\\" # Usage example input_data = [ (5, 5, [ (1, 2, 3), (2, 3, 2), (3, 4, 5), (4, 5, 3), (5, 1, 2) ]), (4, 4, [ (1, 2, 4), (2, 3, 1), (3, 1, 4), (3, 4, 1) ]) ] for n, m, roads in input_data: print(has_palindromic_path(n, m, roads))"},{"question":"class Classroom: Classroom data structure with a maximum capacity of 10 students. Provides methods to add, remove, and list students. Example: >>> classroom = Classroom() >>> classroom.add_student(\\"Alice\\") 'Student added' >>> classroom.add_student(\\"Bob\\") 'Student added' >>> classroom.get_students() ['Alice', 'Bob'] >>> classroom.add_student(\\"Charlie\\") 'Student added' >>> classroom.get_students() ['Alice', 'Bob', 'Charlie'] >>> classroom.remove_student(\\"Alice\\") 'Student removed' >>> classroom.get_students() ['Bob', 'Charlie'] >>> classroom.remove_student(\\"David\\") 'Student not found' >>> classroom.add_student(\\"Eve\\") 'Student added' >>> classroom.get_students() ['Bob', 'Charlie', 'Eve'] >>> classroom = Classroom() >>> print(classroom) 'Classroom is empty' >>> classroom.add_student(\\"Alice\\") 'Student added' >>> classroom.add_student(\\"Bob\\") 'Student added' >>> print(classroom) 'Students: Alice, Bob'","solution":"class Classroom: def __init__(self): self.students = [] self.capacity = 10 def add_student(self, student_name): if len(self.students) < self.capacity: self.students.append(student_name) return \\"Student added\\" else: return \\"Classroom is full\\" def remove_student(self, student_name): if student_name in self.students: self.students.remove(student_name) return \\"Student removed\\" else: return \\"Student not found\\" def get_students(self): return self.students def __str__(self): if not self.students: return \\"Classroom is empty\\" return \\"Students: \\" + \\", \\".join(self.students)"},{"question":"def max_non_adjacent_sum(arr: List[int]) -> int: Given a list of integers, find the maximum possible sum of a subarray with the constraint that no two elements in the subarray are adjacent in the original array. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) == 15 >>> max_non_adjacent_sum([3, 2, 7, 10, 12]) == 22 >>> max_non_adjacent_sum([5]) == 5 >>> max_non_adjacent_sum([-5]) == 0 >>> max_non_adjacent_sum([]) == 0 >>> max_non_adjacent_sum([-1, -2, -3, -4]) == 0 >>> max_non_adjacent_sum([3, -2, 5, -1]) == 8 >>> max_non_adjacent_sum([-2, 1, 3, -4, 5]) == 8 >>> max_non_adjacent_sum([i for i in range(1, 100001)]) == 2500050000 # Implement the function here","solution":"def max_non_adjacent_sum(arr): Returns the maximum sum of a subarray such that no two elements are adjacent in the original array. if not arr: return 0 if len(arr) == 1: return max(0, arr[0]) inclusive = 0 exclusive = 0 for num in arr: new_exclusive = max(inclusive, exclusive) inclusive = exclusive + num exclusive = new_exclusive return max(inclusive, exclusive)"},{"question":"def student_with_most_practice(n: int, logs: List[Tuple[str, int, int]]) -> str: Identify the student who practiced the most in a given month. Args: n (int): The number of practice log entries. logs (List[Tuple[str, int, int]]): A list containing tuples of the student's name, date of practice, and duration of practice in minutes. Returns: str: The name of the student who practiced the most. If multiple students practiced the most, the lexicographically smallest name is returned. >>> student_with_most_practice(5, [(\\"Alice\\", 20220301, 30), (\\"Bob\\", 20220301, 45), (\\"Alice\\", 20220302, 60), (\\"Bob\\", 20220303, 15), (\\"Alice\\", 20220303, 25)]) \\"Alice\\" >>> student_with_most_practice(3, [(\\"John\\", 20230501, 20), (\\"Jane\\", 20230502, 20), (\\"John\\", 20230503, 20)]) \\"John\\"","solution":"def student_with_most_practice(n, logs): from collections import defaultdict practice_times = defaultdict(int) for log in logs: name, date, duration = log practice_times[name] += duration max_time = max(practice_times.values()) students_with_max_time = [name for name, time in practice_times.items() if time == max_time] return min(students_with_max_time)"},{"question":"def row_cumulative_matrix(matrix): Transforms a given matrix into a row-cumulative matrix. Parameters: matrix (list of list of int): The input matrix. Returns: list of list of int: The row-cumulative matrix. >>> row_cumulative_matrix([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12] ... ]) == [ ... [1, 3, 6, 10], ... [5, 11, 18, 26], ... [9, 19, 30, 42] ... ] >>> row_cumulative_matrix([ ... [3, 1, 2], ... [4, 4, 4] ... ]) == [ ... [3, 4, 6], ... [4, 8, 12] ...]","solution":"def row_cumulative_matrix(matrix): Transforms a given matrix into a row-cumulative matrix. Parameters: matrix (list of list of int): The input matrix. Returns: list of list of int: The row-cumulative matrix. row_cumulative = [] for row in matrix: cumulative_row = [] cumulative_sum = 0 for val in row: cumulative_sum += val cumulative_row.append(cumulative_sum) row_cumulative.append(cumulative_row) return row_cumulative"},{"question":"def max_product_modulo(N: int, arr: List[int]) -> int: Determine the maximum product of two distinct elements in the array, modulo (10^9+7). Parameters: N (int): The number of integers in the array. arr (List[int]): The list of integers. Returns: int: The maximum product of two distinct elements in the array, modulo (10^9+7). >>> max_product_modulo(5, [1, 2, 3, 4, 5]) 20 >>> max_product_modulo(2, [0, 0]) 0 >>> max_product_modulo(2, [1, 0]) 0 >>> max_product_modulo(3, [10**9, 10**9, 10**9]) 499999993 >>> max_product_modulo(6, [3, 6, 1, 4, 8, 7]) 56 >>> max_product_modulo(4, [10, 20, 5, 2]) 200 >>> max_product_modulo(6, [1, 3, 5, 3, 1, 5]) 25","solution":"def max_product_modulo(N, arr): Returns the maximum product of two distinct elements in the array, modulo 10^9 + 7. MOD = 10**9 + 7 if N < 2: return 0 # Sort the array to easily find the two largest numbers arr.sort() # Maximum product will be the product of the two largest elements max_product = arr[-1] * arr[-2] return max_product % MOD"},{"question":"from typing import List, Tuple def shortest_cycle(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Given an undirected graph with \`n\` nodes and \`m\` edges, determine the length of the shortest cycle in the graph. If there is no cycle in the graph, return -1. Args: n (int): Number of nodes. m (int): Number of edges. edges (List[Tuple[int, int]]): List of edges. Returns: int: Length of the shortest cycle, or -1 if there are no cycles. >>> shortest_cycle(6, 9, [ ... (1, 2), ... (1, 3), ... (2, 3), ... (2, 4), ... (4, 5), ... (5, 6), ... (6, 4), ... (5, 7), ... (6, 7) ... ]) == 3 >>> shortest_cycle(4, 4, [ ... (1, 2), ... (2, 3), ... (3, 4), ... (4, 1) ... ]) == 4 >>> shortest_cycle(4, 2, [ ... (1, 2), ... (3, 4) ... ]) == -1 >>> shortest_cycle(5, 5, [ ... (1, 2), ... (2, 3), ... (3, 4), ... (4, 5), ... (5, 2) ... ]) == 4 >>> shortest_cycle(7, 7, [ ... (1, 2), ... (2, 3), ... (3, 1), ... (4, 5), ... (5, 6), ... (6, 7) ... ]) == 3","solution":"from collections import deque, defaultdict def shortest_cycle(n, m, edges): # Graph construction graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def bfs(start): dist = {start: 0} parent = {start: None} queue = deque([start]) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in dist: dist[neighbor] = dist[node] + 1 parent[neighbor] = node queue.append(neighbor) elif parent[node] != neighbor: # Detect cycle return dist[node] + dist[neighbor] + 1 return float('inf') min_cycle_len = float('inf') for node in range(1, n + 1): cycle_len = bfs(node) min_cycle_len = min(min_cycle_len, cycle_len) return min_cycle_len if min_cycle_len != float('inf') else -1"},{"question":"def process_text(s: str) -> str: Removes all non-alphanumeric characters (except spaces) and converts all letters to lowercase. Parameters: s (str): The input string. Returns: str: The processed string. Examples: >>> process_text(\\"Hello, World!! Welcome to the 2021 @Coding Competition. #FunTimes :)\\") 'hello world welcome to the 2021 coding competition funtimes ' >>> process_text(\\"Python@Version3.9 #Rocks!!\\") 'pythonversion39 rocks' >>> process_text(\\"Only spaces and words 1234\\") 'only spaces and words 1234' >>> process_text(\\"Special #%^&*() characters.\\") 'special characters' >>> process_text(\\"UPPERCASE to lowercase 123 ABC xyz.\\") 'uppercase to lowercase 123 abc xyz'","solution":"import re def process_text(s: str) -> str: Removes all non-alphanumeric characters (except spaces) and converts all letters to lowercase. Parameters: s (str): The input string. Returns: str: The processed string. # Remove non-alphanumeric characters except spaces cleaned_s = re.sub(r'[^a-zA-Z0-9 ]', '', s) # Convert to lowercase return cleaned_s.lower()"},{"question":"def unique_paths(n: int, m: int, grid: List[List[int]]) -> int: Calculate the number of unique paths from the top-left to the bottom-right corner of a grid, avoiding blocked cells. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: 2D list representing the grid layout where 0 is passable and 1 is blocked :return: Number of unique paths from top-left to bottom-right corner >>> unique_paths(3, 3, [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) 2 >>> unique_paths(3, 3, [ [0, 1, 0], [0, 1, 0], [0, 0, 0] ]) 1 >>> unique_paths(3, 3, [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ]) 0","solution":"def unique_paths(n, m, grid): if grid[0][0] == 1 or grid[n-1][m-1] == 1: return 0 dp = [[0 for j in range(m)] for i in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1]"},{"question":"def parse_logs(logs): Parses log entries and returns the total count of log entries, the count of unique IP addresses, and a dictionary of IP addresses with their corresponding counts. Parameters: logs (list of str): List of log entries. Returns: tuple: (total_entries, unique_ips, ip_counts) Example: >>> logs = [ ... \\"192.168.1.1 - - [10/Oct/2020:13:55:36 -0700] \\"GET /index.html HTTP/1.1\\" 200 2326\\", ... \\"192.168.1.2 - - [10/Oct/2020:13:58:36 -0700] \\"POST /form HTTP/1.1\\" 200 124\\", ... \\"192.168.1.1 - - [10/Oct/2020:14:12:21 -0700] \\"GET /contact.html HTTP/1.1\\" 404 721\\" ... ] >>> parse_logs(logs) (3, 2, {'192.168.1.1': 2, '192.168.1.2': 1})","solution":"def parse_logs(logs): Parses log entries and returns the total count of log entries, the count of unique IP addresses, and a dictionary of IP addresses with their corresponding counts. Parameters: logs (list of str): List of log entries. Returns: tuple: (total_entries, unique_ips, ip_counts) ip_counts = {} for log in logs: ip_address = log.split()[0] if ip_address in ip_counts: ip_counts[ip_address] += 1 else: ip_counts[ip_address] = 1 total_entries = len(logs) unique_ips = len(ip_counts) return total_entries, unique_ips, ip_counts"},{"question":"from typing import List, Tuple def build_and_solve(input_data: str) -> int: Determine the metropolis where the maximum distance to any other metropolis is minimized. Input: - input_data: A string consisting of the number of metropolises and the number of roads, followed by the connections between metropolises. Output: - The index of the metropolis where the maximum distance to any other metropolis is minimized. Example: >>> build_and_solve(\\"4 3n1 2n2 3n2 4\\") 2 >>> build_and_solve(\\"6 5n1 2n2 3n3 4n4 5n4 6\\") 3 # Function implementation goes here def test_example_1(): assert build_and_solve(\\"4 3n1 2n2 3n2 4\\") == 2 def test_example_2(): assert build_and_solve(\\"6 5n1 2n2 3n3 4n4 5n4 6\\") == 3 def test_single_metropolis(): assert build_and_solve(\\"1 0\\") == 1 def test_disjoint_graph(): input_data = \\"5 2n1 2n3 4\\" assert build_and_solve(input_data) == 1 def test_large_case(): input_data = \\"5 4n1 2n2 3n3 4n4 5\\" result = build_and_solve(input_data) assert result == 3","solution":"from collections import deque, defaultdict def find_best_metropolis(n, m, roads): if n == 1: return 1 # Build the graph using adjacency list graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) def bfs(start): distances = [-1] * (n + 1) distances[start] = 0 queue = deque([start]) while queue: node = queue.popleft() for neighbor in graph[node]: if distances[neighbor] == -1: distances[neighbor] = distances[node] + 1 queue.append(neighbor) # Ignore the distance for node 0 return distances[1:] # Calculate all-pairs shortest paths eccentricities = [float('inf')] * (n + 1) for i in range(1, n + 1): if len(graph[i]) > 0: distances = bfs(i) max_distance = max(distances) eccentricities[i] = max_distance # Find the metropolis with the minimum eccentricity min_eccentricity = min(eccentricities[1:]) result = eccentricities.index(min_eccentricity) return result # Read input function def build_and_solve(input_data): lines = input_data.strip().split('n') n, m = map(int, lines[0].split()) roads = [tuple(map(int, line.split())) for line in lines[1:]] return find_best_metropolis(n, m, roads)"},{"question":"def min_total_road_length(N: int, M: int, roads: List[Tuple[int, int, int]]) -> int: Determine whether it is possible to choose a subset of roads such that all buildings are connected and the total length of the chosen subset of roads is minimized. >>> min_total_road_length(4, 5, [(1, 2, 10), (1, 3, 6), (1, 4, 5), (2, 3, 4), (3, 4, 2)]) 11 >>> min_total_road_length(4, 2, [(1, 2, 5), (3, 4, 10)]) -1 >>> min_total_road_length(1, 0, []) 0 >>> min_total_road_length(5, 4, [(1, 2, 7), (2, 3, 5), (4, 5, 1), (3, 1, 9)]) -1 >>> min_total_road_length(3, 3, [(1, 2, 1), (2, 3, 3), (1, 3, 2)]) 3","solution":"def kruskal_mst(N, edges): Function to find the Minimum Spanning Tree (MST) using Kruskal's algorithm. # Helper function to find the root of the set in disjoint set def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) # Helper function to union two sets def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 # Initialize parent and rank parent = [] rank = [] for node in range(N): parent.append(node) rank.append(0) mst_weight = 0 mst_edges = 0 # Sort edges based on weight edges = sorted(edges, key=lambda item: item[2]) for edge in edges: u, v, w = edge if find(parent, u-1) != find(parent, v-1): union(parent, rank, u-1, v-1) mst_weight += w mst_edges += 1 if mst_edges == N - 1: # If we've added N-1 edges, we can stop break if mst_edges == N - 1: return mst_weight else: return -1 def min_total_road_length(N, M, roads): Main function to find the minimum total length of the roads to connect all buildings. return kruskal_mst(N, roads)"},{"question":"def max_possible_profit(n, worths, k, l): Given a stone divided into n sections with each section represented by an integer value denoting its worth, determine the maximum possible profit by mining a contiguous segment of sections that consists of at least k and at most l sections. >>> max_possible_profit(8, [4, -1, 2, 1, 6, -3, 3, 4], 3, 5) 12 >>> max_possible_profit(5, [1, 2, 3, 4, 5], 2, 4) 14 >>> max_possible_profit(5, [-1, -2, -3, -4, -5], 2, 4) -3 >>> max_possible_profit(7, [-1, 2, 3, -4, 5, -3, 4], 2, 5) 6 >>> max_possible_profit(1, [5], 1, 1) 5 >>> max_possible_profit(1, [-5], 1, 1) -5 >>> max_possible_profit(100, list(range(1, 101)), 1, 100) 5050 >>> max_possible_profit(100, [-i for i in range(1, 101)], 1, 100) -1","solution":"def max_possible_profit(n, worths, k, l): # Initialize the max_profit to negative infinity max_profit = float('-inf') # Calculate prefix sums prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + worths[i - 1] # Loop to find the maximum profit for a valid segment with length in [k, l] for i in range(n): for j in range(i + k, min(i + l, n) + 1): current_sum = prefix_sums[j] - prefix_sums[i] max_profit = max(max_profit, current_sum) return max_profit"},{"question":"def find_winner(T: int, test_cases: List[Tuple[int, int]]) -> List[str]: Determines the winner of the game for each test case. Args: T : int : number of test cases test_cases : list of tuple : initial number of stones in the first and second pile for each test case Returns: list of str : list with \\"ALICE\\" or \\"BOB\\" for each game, depending on who wins. >>> find_winner(3, [(1, 2), (2, 2), (5, 9)]) [\\"BOB\\", \\"ALICE\\", \\"BOB\\"] >>> find_winner(2, [(3, 3), (1000000000, 999999999)]) [\\"ALICE\\", \\"BOB\\"] >>> find_winner(1, [(4, 6)]) [\\"BOB\\"] >>> find_winner(4, [(10, 10), (15, 5), (20, 25), (1, 1)]) [\\"ALICE\\", \\"BOB\\", \\"BOB\\", \\"ALICE\\"] >>> find_winner(5, [(5, 5), (7, 8), (9, 18), (4, 4), (2, 2)]) [\\"ALICE\\", \\"BOB\\", \\"BOB\\", \\"ALICE\\", \\"ALICE\\"]","solution":"def find_winner(T, test_cases): Determines the winner of each game based on the initial number of stones in both piles. Args: T : int : number of test cases test_cases : list of tuple : initial number of stones in the first and second pile for each test case Returns: list of str : list with \\"ALICE\\" or \\"BOB\\" for each game. results = [] for A, B in test_cases: if (A ^ B) == 0: # If A and B are the same (A XOR B = 0), Alice wins results.append(\\"ALICE\\") else: results.append(\\"BOB\\") return results"},{"question":"def longest_increasing_paths(N: int, M: int, weights: List[int], edges: List[Tuple[int, int]]) -> Tuple[int, int]: Compute the length of the longest weight-increasing path and the number of such paths in the given undirected graph. Parameters: N (int): The number of vertices. M (int): The number of edges. weights (List[int]): The list of vertex labels. edges (List[Tuple[int, int]]): The list of edges. Returns: Tuple[int, int]: The length of the longest path and the number of such paths modulo 998244353. Example: >>> longest_increasing_paths(6, 7, [1, 2, 5, 4, 3, 6], [(1, 2), (1, 3), (2, 5), (3, 4), (3, 5), (4, 6), (5, 6)]) (4, 2) >>> longest_increasing_paths(5, 4, [10, 20, 30, 40, 50], [(1, 2), (2, 3), (3, 4), (4, 5)]) (5, 1)","solution":"from collections import defaultdict, deque def longest_increasing_paths(N, M, weights, edges): MOD = 998244353 # Graph adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Sort vertices by weights sorted_vertices = sorted(range(1, N+1), key=lambda x: weights[x-1]) # Initialize DP arrays dp_length = [1] * N dp_count = [1] * N # Process vertices in increasing order of their weights for u in sorted_vertices: for v in graph[u]: if weights[v-1] > weights[u-1]: if dp_length[v-1] < dp_length[u-1] + 1: dp_length[v-1] = dp_length[u-1] + 1 dp_count[v-1] = dp_count[u-1] elif dp_length[v-1] == dp_length[u-1] + 1: dp_count[v-1] = (dp_count[v-1] + dp_count[u-1]) % MOD # Get length of the longest increasing path L = max(dp_length) # Get the count of such longest paths P = sum(dp_count[i] for i in range(N) if dp_length[i] == L) % MOD return L, P"},{"question":"def max_performances(durations, maxTime): Find the maximum number of performances that fit within the maxTime constraint. :param durations: A list of integers where each integer represents the duration of a performance. :param maxTime: An integer representing the maximum total duration that any one stage can handle. :return: The maximum number of performances that can be held on a single stage without exceeding maxTime. >>> max_performances([30, 60, 90, 120, 45], 180) 3 >>> max_performances([45, 30, 20, 10, 25], 60) 3 >>> max_performances([60], 60) 1 >>> max_performances([70], 60) 0 >>> max_performances([120, 150, 180], 100) 0 >>> max_performances([10, 20, 30, 40, 50], 200) 5 >>> max_performances([30, 30, 30, 30], 90) 3 >>> max_performances([5, 10, 15, 20, 25, 30], 45) 3 >>> max_performances([1, 1, 1, 1, 1, 1], 6) 6","solution":"def max_performances(durations, maxTime): Find the maximum number of performances that fit within the maxTime constraint. :param durations: A list of integers where each integer represents the duration of a performance. :param maxTime: An integer representing the maximum total duration that any one stage can handle. :return: The maximum number of performances that can be held on a single stage without exceeding maxTime. durations.sort() total_time = 0 count = 0 for duration in durations: if total_time + duration > maxTime: break total_time += duration count += 1 return count"},{"question":"def can_split_into_powers_of_2(n: int) -> str: Determine if n can be split into two or more positive integers that are powers of 2. >>> can_split_into_powers_of_2(10) == \\"YES\\" >>> can_split_into_powers_of_2(11) == \\"YES\\" >>> can_split_into_powers_of_2(15) == \\"YES\\" >>> can_split_into_powers_of_2(5) == \\"YES\\" >>> can_split_into_powers_of_2(7) == \\"YES\\" >>> can_split_into_powers_of_2(1) == \\"NO\\" >>> can_split_into_powers_of_2(2) == \\"NO\\" >>> can_split_into_powers_of_2(16) == \\"NO\\" >>> can_split_into_powers_of_2(1024) == \\"NO\\" >>> can_split_into_powers_of_2(1025) == \\"YES\\" def process_test_cases(t: int, test_cases: List[int]) -> List[str]: Process multiple test cases to determine if each integer can be split into powers of 2. >>> process_test_cases(3, [10, 11, 15]) == [\\"YES\\", \\"YES\\", \\"YES\\"] >>> process_test_cases(2, [5, 7]) == [\\"YES\\", \\"YES\\"] >>> process_test_cases(2, [1, 2]) == [\\"NO\\", \\"NO\\"] >>> process_test_cases(4, [1, 2, 4, 8]) == [\\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\"]","solution":"def can_split_into_powers_of_2(n): Determine if n can be split into two or more positive integers that are powers of 2. # A number can be expressed as sum of distinct powers of 2 # if it is not a power of 2 itself (which means it has more # than one set bit in its binary representation) return \\"YES\\" if n & (n - 1) != 0 else \\"NO\\" def process_test_cases(t, test_cases): results = [] for n in test_cases: results.append(can_split_into_powers_of_2(n)) return results"},{"question":"def min_cost_path(costs): Returns the minimum cost to reach from (0, 0) to (M-1, N-1) in the given costs grid. >>> min_cost_path([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_cost_path([[5]]) 5 >>> min_cost_path([[5, 6]]) 11 >>> min_cost_path([ ... [1, 2], ... [1, 1] ... ]) 3 pass # Your code here","solution":"def min_cost_path(costs): Returns the minimum cost to reach from (0, 0) to (M-1, N-1) in the given costs grid. M, N = len(costs), len(costs[0]) dp = [[0] * N for _ in range(M)] dp[0][0] = costs[0][0] # Initialize first row for j in range(1, N): dp[0][j] = dp[0][j - 1] + costs[0][j] # Initialize first column for i in range(1, M): dp[i][0] = dp[i - 1][0] + costs[i][0] # Populate the rest of dp table for i in range(1, M): for j in range(1, N): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + costs[i][j] return dp[M - 1][N - 1]"},{"question":"def calculate_manhattan_distance(T, instructions_list): Calculate the Manhattan distance from the origin (0, 0) to the robot's final position after executing all instructions. Args: T (int): Number of test cases. instructions_list (list of str): A list containing T strings of instructions. Returns: list of int: A list containing the Manhattan distance for each test case. pass from solution import calculate_manhattan_distance def test_calculate_manhattan_distance(): # Test case 1 T = 2 instructions_list = [\\"UUDDLRLR\\", \\"ULDRULDR\\"] result = calculate_manhattan_distance(T, instructions_list) assert result == [0, 0] # Test case 2 T = 1 instructions_list = [\\"UURRDDLL\\"] result = calculate_manhattan_distance(T, instructions_list) assert result == [0] # Test case 3 T = 1 instructions_list = [\\"UUU\\"] result = calculate_manhattan_distance(T, instructions_list) assert result == [3] # Test case 4 T = 3 instructions_list = [\\"RRRR\\", \\"LLLL\\", \\"UU\\"] result = calculate_manhattan_distance(T, instructions_list) assert result == [4, 4, 2] # Test case 5 T = 1 instructions_list = [\\"UDLR\\"] result = calculate_manhattan_distance(T, instructions_list) assert result == [0]","solution":"def calculate_manhattan_distance(T, instructions_list): Calculate the Manhattan distance from the origin (0, 0) to the robot's final position after executing all instructions. Args: T (int): Number of test cases. instructions_list (list of str): A list containing T strings of instructions. Returns: list of int: A list containing the Manhattan distance for each test case. def manhattan_distance(x, y): return abs(x) + abs(y) results = [] for instructions in instructions_list: x, y = 0, 0 for cmd in instructions: if cmd == 'U': y += 1 elif cmd == 'D': y -= 1 elif cmd == 'L': x -= 1 elif cmd == 'R': x += 1 results.append(manhattan_distance(x, y)) return results"},{"question":"from typing import List, Tuple def handle_operations(n: int, m: int, initial_values: List[int], operations: List[Tuple[str, int, int]]) -> List[int]: Handle the scroll management operations for the Grand Library. Args: n (int): Number of scrolls. m (int): Number of operations. initial_values (List[int]): Initial scholarly values of the scrolls. operations (List[Tuple[str, int, int]]): List of operations to perform. Returns: List[int]: Results of the query operations. >>> handle_operations(5, 3, [10, 20, 30, 40, 50], [(\\"update\\", 3, 35), (\\"query\\", 3), (\\"query\\", 5)]) [35, 50] >>> handle_operations(5, 6, [100, 200, 300, 400, 500], [(\\"update\\", 1, 110), (\\"update\\", 5, 510), (\\"query\\", 1), (\\"query\\", 5), (\\"update\\", 3, 310), (\\"query\\", 3)]) [110, 510, 310]","solution":"def handle_operations(n, m, initial_values, operations): scholarly_values = initial_values[:] # Copy the initial values to modify results = [] for op in operations: if op[0] == \\"update\\": u, v = op[1], op[2] # Update the scholarly value of the scroll in case u scholarly_values[u-1] = v elif op[0] == \\"query\\": u = op[1] # Retrieve the scholarly value of the scroll in case u results.append(scholarly_values[u-1]) return results"},{"question":"def is_balanced_braces(S: str) -> str: Determines if the braces in the string S are balanced. :param S: A string of braces '(' and ')' :return: \\"YES\\" if the braces are balanced, \\"NO\\" otherwise. >>> is_balanced_braces(\\"()\\") \\"YES\\" >>> is_balanced_braces(\\"(())\\") \\"YES\\" >>> is_balanced_braces(\\"(()\\") \\"NO\\" >>> is_balanced_braces(\\"())\\") \\"NO\\" >>> is_balanced_braces(\\"()()\\") \\"YES\\" >>> is_balanced_braces(\\"(()())\\") \\"YES\\" >>> is_balanced_braces(\\"((())\\") \\"NO\\" >>> is_balanced_braces(\\")()(\\") \\"NO\\" pass def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Processes multiple test cases to determine if braces in each string are balanced. :param T: Number of test cases :param test_cases: List of strings to be tested :return: List of results for each test case. >>> process_test_cases(3, [\\"()\\", \\"(())\\", \\"(()\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_test_cases(2, [\\")(\\", \\"(()())\\"]) [\\"NO\\", \\"YES\\"] >>> process_test_cases(1, [\\"\\"]) [\\"YES\\"] >>> process_test_cases(4, [\\"()()\\", \\"((()))\\", \\"(()(\\", \\"))((\\"]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"] pass","solution":"def is_balanced_braces(S): Determines if the braces in the string S are balanced. :param S: A string of braces '(' and ')' :return: \\"YES\\" if the braces are balanced, \\"NO\\" otherwise stack = [] for char in S: if char == '(': stack.append(char) elif char == ')': if not stack: return \\"NO\\" stack.pop() return \\"YES\\" if not stack else \\"NO\\" def process_test_cases(T, test_cases): Processes multiple test cases to determine if braces in each string are balanced. :param T: Number of test cases :param test_cases: List of strings to be tested :return: List of results for each test case results = [] for S in test_cases: results.append(is_balanced_braces(S)) return results"},{"question":"from typing import List, Dict def has_overlapping_events(events: List[Dict[str, int]]) -> bool: Determines whether any events overlap. Assumes events have valid 'start' and 'end' times. >>> events = [ ... {'start': 1, 'end': 5}, ... {'start': 6, 'end': 10}, ... {'start': 11, 'end': 15} ... ] >>> has_overlapping_events(events) False >>> events = [ ... {'start': 1, 'end': 5}, ... {'start': 4, 'end': 8}, ... {'start': 9, 'end': 12} ... ] >>> has_overlapping_events(events) True >>> events = [ ... {'start': 1, 'end': 3}, ... {'start': 2, 'end': 6}, ... {'start': 5, 'end': 10} ... ] >>> has_overlapping_events(events) True","solution":"from typing import List, Dict def has_overlapping_events(events: List[Dict[str, int]]) -> bool: Determines whether any events overlap. Assumes events have valid 'start' and 'end' times. Args: events (List[Dict[str, int]]): List of events, each with 'start' and 'end' keys. Returns: bool: True if any events overlap, False otherwise. events.sort(key=lambda event: event['start']) for i in range(len(events) - 1): if events[i]['end'] >= events[i + 1]['start']: return True return False"},{"question":"from typing import List, Tuple def find_available_slots(working_hours: Tuple[str, str], reservations: List[Tuple[str, str]]) -> List[Tuple[str, str]]: Identify all available time slots for booking in a restaurant based on the working hours and the reservations made. Args: working_hours (Tuple[str, str]): The opening and closing times of the restaurant in \\"HH:MM\\" 24-hour format. For example, (\\"09:00\\", \\"20:00\\"). reservations (List[Tuple[str, str]]): A list of tuples where each tuple contains the starting and ending time of a reservation in \\"HH:MM\\" 24-hour format. For example, [(\\"09:00\\", \\"10:30\\"), (\\"11:30\\", \\"13:00\\"), (\\"15:00\\", \\"15:45\\")]. Returns: List[Tuple[str, str]]: A list of tuples representing the available time slots for new reservations. Each tuple contains the starting and ending time of an available slot in \\"HH:MM\\" 24-hour format. Examples: >>> find_available_slots((\\"09:00\\", \\"18:00\\"), [(\\"09:00\\", \\"10:30\\"), (\\"12:00\\", \\"13:30\\"), (\\"14:00\\", \\"15:00\\")]) [(\\"10:30\\", \\"12:00\\"), (\\"13:30\\", \\"14:00\\"), (\\"15:00\\", \\"18:00\\")] >>> find_available_slots((\\"09:00\\", \\"18:00\\"), []) [(\\"09:00\\", \\"18:00\\")]","solution":"from typing import List, Tuple def find_available_slots(working_hours: Tuple[str, str], reservations: List[Tuple[str, str]]) -> List[Tuple[str, str]]: available_slots = [] start_time, end_time = working_hours # Sort reservations by start time reservations.sort() # Initialize the previous end time to the start of working hours previous_end = start_time # Find gaps between reservations for reservation_start, reservation_end in reservations: if previous_end < reservation_start: available_slots.append((previous_end, reservation_start)) previous_end = reservation_end # Check for a gap between the last reservation and the end of working hours if previous_end < end_time: available_slots.append((previous_end, end_time)) return available_slots"},{"question":"def max_wealth(R: int, C: int, grid: List[List[int]], K: int) -> int: Determine the maximum sum of wealth the traveler can achieve by visiting exactly K consecutive cities in a hexagonal grid of wealth values. Args: R (int): the number of rows in the grid. C (int): the number of columns in the grid. grid (List[List[int]]): the 2D list representing the wealth values of the cities. K (int): the number of cities the traveler will visit. Returns: int: the maximum sum of wealth achievable. >>> max_wealth(4, 4, [[1, 2, 3, 4], [8, 7, 6, 5], [9, 1, 4, 7], [3, 2, 5, 6]], 3) 24 >>> max_wealth(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], 2) 17 >>> max_wealth(1, 1, [[5]], 1) 5 >>> max_wealth(2, 2, [[1, 9], [1, 9]], 4) 20","solution":"def max_wealth(R, C, grid, K): def get_neighbors(i, j): if i % 2 == 0: neighbors = [(i - 1, j - 1), (i - 1, j), (i + 1, j - 1), (i + 1, j), (i, j - 1), (i, j + 1)] else: neighbors = [(i - 1, j), (i - 1, j + 1), (i + 1, j), (i + 1, j + 1), (i, j - 1), (i, j + 1)] return [(ni, nj) for ni, nj in neighbors if 0 <= ni < R and 0 <= nj < C] max_sum = 0 visited = set() def dfs(i, j, k, current_sum): nonlocal max_sum if k == 0: max_sum = max(max_sum, current_sum) return for ni, nj in get_neighbors(i, j): if (ni, nj) not in visited: visited.add((ni, nj)) dfs(ni, nj, k - 1, current_sum + grid[ni][nj]) visited.remove((ni, nj)) for i in range(R): for j in range(C): visited.add((i, j)) dfs(i, j, K - 1, grid[i][j]) visited.remove((i, j)) return max_sum # Parsing input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() R = int(data[0]) C = int(data[1]) grid = [] idx = 2 for i in range(R): grid.append([int(data[j]) for j in range(idx, idx + C)]) idx += C K = int(data[idx]) print(max_wealth(R, C, grid, K))"},{"question":"from typing import List, Tuple def get_top_photos(n: int, m: int, photos: List[Tuple[int, int]]) -> List[int]: Returns the list of top m photo IDs sorted by their memory size in descending order. If two photos have the same memory size, they are sorted by their ID in ascending order. Args: n : int : Number of photos m : int : Maximum number of photos that can be retained photos : List[Tuple[int, int]] : List of tuples where each tuple contains (photo ID, memory size) Returns: List[int] : List of photo IDs >>> get_top_photos(5, 3, [(101, 200), (102, 300), (103, 200), (104, 500), (105, 200)]) [104, 102, 101] >>> get_top_photos(4, 2, [(201, 150), (202, 150), (203, 300), (204, 150)]) [203, 201] >>> get_top_photos(6, 4, [(301, 200), (302, 300), (303, 400), (304, 200), (305, 100), (306, 200)]) [303, 302, 301, 304] >>> get_top_photos(3, 3, [(401, 1000), (402, 1000), (403, 1000)]) [401, 402, 403] >>> get_top_photos(1, 1, [(501, 500)]) [501]","solution":"def get_top_photos(n, m, photos): Returns the list of top m photo IDs sorted by their memory size in descending order. If two photos have the same memory size, they are sorted by their ID in ascending order. Args: n : int : Number of photos m : int : Maximum number of photos that can be retained photos : List[Tuple[int, int]] : List of tuples where each tuple contains (photo ID, memory size) Returns: List[int] : List of photo IDs # Sorting the photos based on the given criteria sorted_photos = sorted(photos, key=lambda x: (-x[1], x[0])) # Selecting the top 'm' photos and returning their IDs top_photos_ids = [photo[0] for photo in sorted_photos[:m]] return top_photos_ids"},{"question":"def acorn_collection(n: int, acorns: List[int], m: int, queries: List[Tuple[int, int]]) -> List[int]: Sam the Squirrel is trying to collect as many acorns as he can for the winter. He has a log of trees with the number of acorns in each. Sam wants to know the number of acorns collected from different intervals of trees over several queries. You are given an array of integers a, where a[i] represents the number of acorns on the ith tree. You need to answer m queries about the sum of acorns in certain intervals. Each query is described by a pair of integers li, ri (1 ≤ li ≤ ri ≤ n), asking for the sum of acorns from the lth tree to the rth tree (inclusive). Write a program to help Sam determine the total number of acorns collected in each of the given intervals. Args: n (int): the number of trees. acorns (List[int]): the number of acorns on each tree. m (int): the number of queries. queries (List[Tuple[int, int]]): each tuple contains two integers li and ri representing a query interval. Returns: List[int]: the answers to the queries in the order in which they are given in the input. >>> acorn_collection(5, [1, 3, 4, 8, 6], 3, [(1, 3), (2, 5), (3, 4)]) [8, 21, 12] >>> acorn_collection(1, [10], 1, [(1, 1)]) [10] >>> acorn_collection(4, [5, 5, 5, 5], 2, [(1, 4), (2, 3)]) [20, 10] >>> acorn_collection(3, [0, 0, 0], 2, [(1, 2), (2, 3)]) [0, 0] >>> n = 100000 >>> acorns = [i % 1000 + 1 for i in range(n)] >>> queries = [(1, n), (1, n // 2), (n // 2 + 1, n)] >>> acorn_collection(n, acorns, 3, queries) [sum(acorns), sum(acorns[:n//2]), sum(acorns[n//2:])]","solution":"def acorn_collection(n, acorns, m, queries): # First compute the prefix sums for easier query resolution prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + acorns[i] results = [] for l, r in queries: # Convert 1-based to 0-based indexing for internal use sum_acorns = prefix_sums[r] - prefix_sums[l - 1] results.append(sum_acorns) return results"},{"question":"import heapq from typing import List, Tuple def shortest_paths(n: int, m: int, roads: List[Tuple[int, int, int]], start: int) -> List[int]: Find the shortest path from a given starting city to all other cities. >>> shortest_paths(5, 6, [(1, 2, 3), (1, 3, 10), (2, 3, 1), (2, 4, 2), (3, 4, 7), (4, 5, 1)], 1) [0, 3, 4, 5, 6] >>> shortest_paths(3, 3, [(1, 2, 2), (1, 3, 4), (2, 3, 1)], 2) [2, 0, 1] >>> shortest_paths(4, 3, [(1, 2, 1), (1, 3, 4), (2, 3, 2)], 1) [0, 1, 3, -1] >>> shortest_paths(4, 0, [], 1) [0, -1, -1, -1] >>> shortest_paths(3, 3, [(1, 2, 10000), (1, 3, 20000), (2, 3, 15000)], 1) [0, 10000, 20000]","solution":"import heapq def shortest_paths(n, m, roads, start): # Create adjacency list for the graph adj = {i: [] for i in range(1, n + 1)} for u, v, w in roads: adj[u].append((v, w)) adj[v].append((u, w)) # Initialize distances with infinity distances = {i: float('inf') for i in range(1, n + 1)} distances[start] = 0 # Min-heap to get the city with the smallest distance heap = [(0, start)] while heap: current_distance, current_city = heapq.heappop(heap) # If the distance is greater than the known shortest distance, skip if current_distance > distances[current_city]: continue # Check neighboring cities for neighbor, weight in adj[current_city]: distance = current_distance + weight # If a shorter path is found if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) # Prepare the result based on distances result = [] for i in range(1, n + 1): if distances[i] == float('inf'): result.append(-1) else: result.append(distances[i]) return result"},{"question":"def race_winner(y, p, q, distances): Determines the winner of the majority of races between Rahul and Raj. Parameters: y : int : number of races p : int : Rahul's speed (meters per minute) q : int : Raj's speed (meters per minute) distances : list of int : distances of the races Returns: str : winner of the majority of races - \\"Rahul\\", \\"Raj\\", or \\"Draw\\" pass # Example test cases to validate the implementation def test_raju(): assert race_winner(5, 4, 5, [400, 100, 300, 200, 150]) == \\"Raj\\" def test_draw(): assert race_winner(4, 5, 5, [500, 250, 750, 100]) == \\"Draw\\" def test_rahul(): assert race_winner(3, 6, 5, [300, 360, 450]) == \\"Rahul\\" def test_mixed_results(): assert race_winner(6, 4, 5, [10, 15, 20, 25, 30, 35]) == \\"Raj\\" def test_all_draw(): assert race_winner(4, 10, 10, [10, 20, 30, 40]) == \\"Draw\\"","solution":"def race_winner(y, p, q, distances): Determines the winner of the majority of races between Rahul and Raj. Parameters: y : int : number of races p : int : Rahul's speed (meters per minute) q : int : Raj's speed (meters per minute) distances : list of int : distances of the races Returns: str : winner of the majority of races - \\"Rahul\\", \\"Raj\\", or \\"Draw\\" rahul_wins = 0 raj_wins = 0 for i in range(y): rahul_time = distances[i] / p raj_time = distances[i] / q if rahul_time < raj_time: rahul_wins += 1 elif raj_time < rahul_time: raj_wins += 1 if rahul_wins > raj_wins: return \\"Rahul\\" elif raj_wins > rahul_wins: return \\"Raj\\" else: return \\"Draw\\""},{"question":"def minimum_paths_to_connect_cities(n: int) -> int: Given the number of cities n, this function returns the minimum number of bidirectional communication paths needed to ensure that there is a communication route between every pair of cities. >>> minimum_paths_to_connect_cities(4) 3 >>> minimum_paths_to_connect_cities(5) 4 >>> minimum_paths_to_connect_cities(2) 1 >>> minimum_paths_to_connect_cities(10) 9 >>> minimum_paths_to_connect_cities(100) 99","solution":"def minimum_paths_to_connect_cities(n): Given the number of cities n, this function returns the minimum number of bidirectional communication paths needed to ensure that there is a communication route between every pair of cities. # A complete graph with n vertices (cities) has a connecting path of n-1 edges. # This can be visualized by having one central city connected to every other city. return n - 1"},{"question":"from typing import List, Dict, Tuple def illogical_claims(T: int, test_cases: List[Dict]) -> List[int]: Detect and count the number of illogical population claims in a kingdom's regions. Parameters: T (int): the number of test cases. test_cases (List[Dict]): the list of test cases with each test case containing: \\"MRP\\" (Tuple[int, int, int]): a tuple containing the number of regions (M), the number of roads (R), and the illogical population difference threshold (P). \\"populations\\" (List[int]): a list containing the population of each region. \\"roads\\" (List[Tuple[int, int]]): a list of tuples where each tuple represents a road between two regions. Returns: List[int]: List of integers where each integer represents the number of illogical claims in the corresponding test case. >>> T = 1 >>> test_cases = [ >>> { >>> \\"MRP\\": (4, 4, 10), >>> \\"populations\\": [30, 15, 25, 40], >>> \\"roads\\": [(1, 2), (2, 3), (3, 4), (4, 1)] >>> } >>> ] >>> illogical_claims(T, test_cases) [1]","solution":"def illogical_claims(T, test_cases): from collections import defaultdict, deque def bfs(node, graph, populations, P, visited): queue = deque([node]) component = [] while queue: current_node = queue.popleft() if visited[current_node]: continue visited[current_node] = True component.append(current_node) for neighbor in graph[current_node]: if not visited[neighbor]: queue.append(neighbor) for i in range(len(component)): for j in range(i + 1, len(component)): if abs(populations[component[i]] - populations[component[j]]) > P: return True return False results = [] for case in test_cases: M, R, P = case[\\"MRP\\"] populations = case[\\"populations\\"] roads = case[\\"roads\\"] graph = defaultdict(list) for A, B in roads: graph[A-1].append(B-1) graph[B-1].append(A-1) visited = [False] * M illogical_components_count = 0 for i in range(M): if not visited[i]: if bfs(i, graph, populations, P, visited): illogical_components_count += 1 results.append(illogical_components_count) return results # Example usage with sample input: T = 1 test_cases = [ { \\"MRP\\": (4, 4, 10), \\"populations\\": [30, 15, 25, 40], \\"roads\\": [(1, 2), (2, 3), (3, 4), (4, 1)] } ] print(illogical_claims(T, test_cases))"},{"question":"def longest_common_prefix(words): Returns the longest common prefix string amongst an array of words. If there is no common prefix, return an empty string. Args: words (List[str]): A list of words to find the common prefix in. Returns: str: The longest common prefix. Examples: >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\", \\"flog\\"]) 'fl' >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' pass def test_longest_common_prefix(): assert longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\", \\"flog\\"]) == \\"fl\\" assert longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" assert longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) == \\"inters\\" assert longest_common_prefix([\\"throne\\", \\"dungeon\\"]) == \\"\\" assert longest_common_prefix([\\"throne\\", \\"throne\\"]) == \\"throne\\" assert longest_common_prefix([\\"\\"]) == \\"\\" assert longest_common_prefix([\\"a\\"]) == \\"a\\" assert longest_common_prefix([\\"cir\\", \\"car\\"]) == \\"c\\" # We can now run these tests using a test runner, such as pytest.","solution":"def longest_common_prefix(words): Returns the longest common prefix string amongst an array of words. If there is no common prefix, return an empty string. if not words: return \\"\\" # Take the first word as the initial prefix prefix = words[0] # Iterate over the rest of the words for word in words[1:]: while word[:len(prefix)] != prefix and prefix: # Decrease the prefix by one character at a time prefix = prefix[:len(prefix)-1] # If the prefix is empty, no need to check further if not prefix: return \\"\\" return prefix"},{"question":"def unique_folder_structures(n: int, paths: List[str]) -> Tuple[int, List[str]]: Determine the number of unique parent folder structures that contain a given file. Args: n : int : The number of paths. paths : List[str] : The list of paths representing files and their respective locations. Returns: Tuple[int, List[str]] : The number of unique folder structures and the list of unique folder structures. Examples: >>> unique_folder_structures(7, [\\"/root/folderA/folderB/file1.txt\\", \\"/root/folderC/folderD/file2.txt\\", \\"/root/folderA/folderB/file3.txt\\", \\"/root/folderC/folderD/file4.txt\\", \\"/root/folderX/folderY/file1.txt\\", \\"/root/folderX/folderY/file5.txt\\", \\"/root/folderA/folderB/file6.txt\\"]) (3, [\\"/root/folderA/folderB\\", \\"/root/folderC/folderD\\", \\"/root/folderX/folderY\\"]) >>> unique_folder_structures(4, [\\"/root/test/file1.txt\\", \\"/root/dev/file2.txt\\", \\"/root/test/file3.txt\\", \\"/root/dev/file2.txt\\"]) (2, [\\"/root/test\\", \\"/root/dev\\"]) pass from solution import unique_folder_structures def test_unique_folder_structures_example1(): paths = [ \\"/root/folderA/folderB/file1.txt\\", \\"/root/folderC/folderD/file2.txt\\", \\"/root/folderA/folderB/file3.txt\\", \\"/root/folderC/folderD/file4.txt\\", \\"/root/folderX/folderY/file1.txt\\", \\"/root/folderX/folderY/file5.txt\\", \\"/root/folderA/folderB/file6.txt\\" ] num_structures, structures = unique_folder_structures(7, paths) expected_structures = [ \\"/root/folderA/folderB\\", \\"/root/folderC/folderD\\", \\"/root/folderX/folderY\\" ] assert num_structures == 3 assert set(structures) == set(expected_structures) def test_unique_folder_structures_example2(): paths = [ \\"/root/test/file1.txt\\", \\"/root/dev/file2.txt\\", \\"/root/test/file3.txt\\", \\"/root/dev/file2.txt\\" ] num_structures, structures = unique_folder_structures(4, paths) expected_structures = [ \\"/root/test\\", \\"/root/dev\\" ] assert num_structures == 2 assert set(structures) == set(expected_structures) def test_unique_folder_structures_single_path(): paths = [\\"/root/single/path/file.txt\\"] num_structures, structures = unique_folder_structures(1, paths) expected_structures = [\\"/root/single/path\\"] assert num_structures == 1 assert structures == expected_structures def test_unique_folder_structures_same_folders(): paths = [ \\"/root/folder/file1.txt\\", \\"/root/folder/file2.txt\\", \\"/root/folder/file3.txt\\" ] num_structures, structures = unique_folder_structures(3, paths) expected_structures = [\\"/root/folder\\"] assert num_structures == 1 assert structures == expected_structures def test_unique_folder_structures_various(): paths = [ \\"/root/a/b/file1.txt\\", \\"/root/a/c/file2.txt\\", \\"/root/a/b/c/file3.txt\\", \\"/root/a/file4.txt\\" ] num_structures, structures = unique_folder_structures(4, paths) expected_structures = [ \\"/root/a/b\\", \\"/root/a/c\\", \\"/root/a/b/c\\", \\"/root/a\\" ] assert num_structures == 4 assert set(structures) == set(expected_structures) def test_unique_folder_structures_different_paths(): paths = [ \\"/root/folderA/file1.txt\\", \\"/root/folderB/folderC/file2.txt\\", \\"/root/folderB/folderD/file3.txt\\" ] num_structures, structures = unique_folder_structures(3, paths) expected_structures = [ \\"/root/folderA\\", \\"/root/folderB/folderC\\", \\"/root/folderB/folderD\\" ] assert num_structures == 3 assert set(structures) == set(expected_structures)","solution":"def unique_folder_structures(n, paths): Returns the number of unique parent folder structures and the structures themselves. unique_folders = set() for path in paths: # Strip the file name to get the parent folder structure folder_structure = path.rsplit(\\"/\\", 1)[0] unique_folders.add(folder_structure) # Convert set to list to maintain the order unique_folders_list = list(unique_folders) return len(unique_folders_list), unique_folders_list"},{"question":"def replaceNotWithDefinitely(input_string: str) -> str: Replace every occurrence of the word 'not' with 'definitely' in the given input string. >>> replaceNotWithDefinitely(\\"This is not a drill\\") 'This is definitely a drill' >>> replaceNotWithDefinitely(\\"not so sure\\") 'definitely so sure' >>> replaceNotWithDefinitely(\\"It's not always not\\") 'It's definitely always definitely'","solution":"def replaceNotWithDefinitely(input_string): Replaces every occurrence of the word \\"not\\" with \\"definitely\\" in the given input_string. return input_string.replace(\\"not\\", \\"definitely\\")"},{"question":"def heaviest_packages(layers): Calculate the total weight of the heaviest package in each layer. Parameters: layers (list of list of int): A list of lists where each inner list contains integers representing package weights in a layer. Returns: int: Total weight of the heaviest packages in each layer. Examples: >>> heaviest_packages([[4, 2, 3], [5, 1, 2], [3], [7, 8]]) == 20 >>> heaviest_packages([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 18 >>> heaviest_packages([[10], [20, 10], [30]]) == 60 >>> heaviest_packages([[], [5, 3], [7, 4, 1]]) == 12 >>> heaviest_packages([]) == 0","solution":"def heaviest_packages(layers): Calculate the total weight of the heaviest package in each layer. Parameters: layers (list of list of int): A list of lists where each inner list contains integers representing package weights in a layer. Returns: int: Total weight of the heaviest packages in each layer. total_weight = 0 for layer in layers: if layer: total_weight += max(layer) else: total_weight += 0 return total_weight"},{"question":"def min_battery_consumption(n, task_positions, start_position): Calculates the minimum battery consumption for the robot to complete all tasks and return to the starting position. Args: n : int : number of tasks task_positions: List[int] : positions of the tasks on the rail line start_position: int : starting position of the robot Returns: int : the minimum amount of battery units required for the robot to visit all tasks and return to the starting position pass # Test cases assert min_battery_consumption(3, [1, 5, 9], 0) == 18 assert min_battery_consumption(1, [10], 0) == 20 assert min_battery_consumption(1, [0], 10) == 20 assert min_battery_consumption(3, [5, 5, 5], 10) == 10 assert min_battery_consumption(3, [10, 10, 10], 10) == 0 assert min_battery_consumption(3, [1, 5, 9], 5) == 16 assert min_battery_consumption(4, [10, 20, 30, 40], 100) == 180 assert min_battery_consumption(4, [50, 50, 50, 50], 50) == 0 assert min_battery_consumption(2, [50, 50], 50) == 0","solution":"def min_battery_consumption(n, task_positions, start_position): Calculates the minimum battery consumption for the robot to complete all tasks and return to the starting position. Args: n : int : number of tasks task_positions: List[int] : positions of the tasks on the rail line start_position: int : starting position of the robot Returns: int : the minimum amount of battery units required for the robot to visit all tasks and return to the starting position task_positions.sort() min_position = task_positions[0] max_position = task_positions[-1] # Battery consumption for the robot to visit all tasks and return to the start position total_consumption = abs(start_position - min_position) + abs(max_position - min_position) + abs(max_position - start_position) return total_consumption"},{"question":"def max_servers_communicate(n: int, k: int, connections: List[Tuple[int, int]]) -> int: Determine the maximum number of servers that can still communicate with the master server after exactly k servers are taken offline for maintenance. >>> max_servers_communicate(7, 3, [(1, 2), (2, 3), (3, 4), (4, 5), (3, 6), (6, 7)]) 4 >>> max_servers_communicate(5, 2, [(1, 2), (1, 3), (2, 4), (3, 5)]) 3 from typing import List, Tuple def test_case_1(): n = 7 k = 3 connections = [(1, 2), (2, 3), (3, 4), (4, 5), (3, 6), (6, 7)] assert max_servers_communicate(n, k, connections) == 4 def test_case_2(): n = 5 k = 2 connections = [(1, 2), (1, 3), (2, 4), (3, 5)] assert max_servers_communicate(n, k, connections) == 3 def test_case_3(): n = 6 k = 1 connections = [(1, 2), (1, 3), (2, 4), (4, 5), (5, 6)] assert max_servers_communicate(n, k, connections) == 5 def test_case_4(): n = 4 k = 1 connections = [(1, 2), (1, 3), (3, 4)] assert max_servers_communicate(n, k, connections) == 3 def test_case_5(): n = 8 k = 2 connections = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (6, 7), (6, 8)] assert max_servers_communicate(n, k, connections) == 6","solution":"def max_servers_communicate(n, k, connections): from collections import defaultdict, deque def bfs(start): visited = [False] * (n + 1) queue = deque([(start, 0)]) visited[start] = True dist = [0] * (n + 1) while queue: node, d = queue.popleft() for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True dist[neighbor] = d + 1 queue.append((neighbor, dist[neighbor])) return dist adj_list = defaultdict(list) for u, v in connections: adj_list[u].append(v) adj_list[v].append(u) dist_from_root = bfs(1) dist_nodes = [(dist, node) for node, dist in enumerate(dist_from_root) if node != 0] dist_nodes.sort(reverse=True, key=lambda x: x[0]) taken_offline = set([node for _, node in dist_nodes[:k]]) def count_online(node): count = 0 visited = [False] * (n + 1) stack = [node] while stack: current = stack.pop() if visited[current] or current in taken_offline: continue visited[current] = True count += 1 for neighbor in adj_list[current]: if not visited[neighbor]: stack.append(neighbor) return count return count_online(1)"},{"question":"def max_friendly_trees(n: int, friendship_levels: List[int], F: int) -> int: Determine the maximum number of trees that can form a friendly group. Args: n: int - The number of trees. friendship_levels: List[int] - List of friendship levels of the trees. F: int - Maximum allowed absolute difference in friendship levels for a group to be friendly. Returns: int - The largest number of trees that can form a friendly group. >>> max_friendly_trees(5, [2, 1, 3, 8, 7], 2) 3 >>> max_friendly_trees(4, [1, 1, 1, 1], 0) 4 >>> max_friendly_trees(3, [1, 8, 15], 5) 1 >>> max_friendly_trees(6, [3, 6, 6, 3, 7, 2], 1) 3 >>> max_friendly_trees(1, [10], 1000) 1","solution":"def max_friendly_trees(n, friendship_levels, F): Determine the maximum number of trees that can form a friendly group. Args: n: int - The number of trees. friendship_levels: List[int] - List of friendship levels of the trees. F: int - Maximum allowed absolute difference in friendship levels for a group to be friendly. Returns: int - The largest number of trees that can form a friendly group. # Sort the friendship levels to make it easier to find friendly groups friendship_levels.sort() max_count = 0 for i in range(n): count = 1 for j in range(i + 1, n): if friendship_levels[j] - friendship_levels[i] <= F: count += 1 else: break max_count = max(max_count, count) return max_count"},{"question":"def are_cells_accessible(x1: int, y1: int, x2: int, y2: int) -> str: Checks if two cells in a hexagonal grid are accessible from one another. (x1, y1) - coordinates of the starting cell (x2, y2) - coordinates of the destination cell >>> are_cells_accessible(0, 0, 2, 2) \\"YES\\" >>> are_cells_accessible(0, 0, 3, 3) \\"NO\\"","solution":"def are_cells_accessible(x1, y1, x2, y2): Checks if two cells in a hexagonal grid are accessible from one another. (x1, y1) - coordinates of the starting cell (x2, y2) - coordinates of the destination cell if (x1 + y1) % 2 == (x2 + y2) % 2: return \\"YES\\" return \\"NO\\""},{"question":"class BookCollection: def __init__(self): Initialize your data structure here. pass def add_book(self, book_id: int, title: str, author: str): Adds a new book to the collection. >>> bc = BookCollection() >>> bc.add_book(1, \\"The Fellowship of the Ring\\", \\"J.R.R. Tolkien\\") >>> bc.add_book(2, \\"The Two Towers\\", \\"J.R.R. Tolkien\\") pass def most_common_author(self) -> str: Returns the name of the author with the most books in the collection. If there is a tie, return any one of the authors with the highest count. >>> bc = BookCollection() >>> bc.add_book(1, \\"The Fellowship of the Ring\\", \\"J.R.R. Tolkien\\") >>> bc.add_book(2, \\"The Two Towers\\", \\"J.R.R. Tolkien\\") >>> bc.most_common_author() 'J.R.R. Tolkien' pass # Unit Test def test_add_and_most_common_author(): bc = BookCollection() bc.add_book(1, \\"The Fellowship of the Ring\\", \\"J.R.R. Tolkien\\") bc.add_book(2, \\"The Two Towers\\", \\"J.R.R. Tolkien\\") bc.add_book(3, \\"The Return of the King\\", \\"J.R.R. Tolkien\\") bc.add_book(4, \\"1984\\", \\"George Orwell\\") bc.add_book(5, \\"Animal Farm\\", \\"George Orwell\\") assert bc.most_common_author() == \\"J.R.R. Tolkien\\" def test_empty_collection(): bc = BookCollection() assert bc.most_common_author() == None def test_single_book(): bc = BookCollection() bc.add_book(1, \\"1984\\", \\"George Orwell\\") assert bc.most_common_author() == \\"George Orwell\\" def test_multiple_authors_same_count(): bc = BookCollection() bc.add_book(1, \\"Book 1\\", \\"Author A\\") bc.add_book(2, \\"Book 2\\", \\"Author B\\") bc.add_book(3, \\"Book 3\\", \\"Author A\\") bc.add_book(4, \\"Book 4\\", \\"Author B\\") assert bc.most_common_author() in [\\"Author A\\", \\"Author B\\"] def test_adding_books_incrementally(): bc = BookCollection() bc.add_book(1, \\"Book 1\\", \\"Author A\\") assert bc.most_common_author() == \\"Author A\\" bc.add_book(2, \\"Book 2\\", \\"Author B\\") assert bc.most_common_author() == \\"Author A\\" or bc.most_common_author() == \\"Author B\\" bc.add_book(3, \\"Book 3\\", \\"Author A\\") assert bc.most_common_author() == \\"Author A\\" bc.add_book(4, \\"Book 4\\", \\"Author B\\") assert bc.most_common_author() == \\"Author A\\" or bc.most_common_author() == \\"Author B\\" bc.add_book(5, \\"Book 5\\", \\"Author A\\") assert bc.most_common_author() == \\"Author A\\"","solution":"class BookCollection: def __init__(self): self.books = {} self.author_count = {} def add_book(self, book_id, title, author): Adds a new book to the collection. self.books[book_id] = (title, author) if author in self.author_count: self.author_count[author] += 1 else: self.author_count[author] = 1 def most_common_author(self): Returns the name of the author with the most books in the collection. if not self.author_count: return None most_common_author = max(self.author_count, key=self.author_count.get) return most_common_author"},{"question":"def merge(arr, l, m, r): Merges two subarrays of arr. First subarray is arr[l..m] Second subarray is arr[m+1..r] # Your code here def mergeSort(arr, l, r): Main function that sorts arr[l..r] using merge() # Your code here # Example usage arr = [12, 11, 13, 5, 6] mergeSort(arr, 0, len(arr) - 1) print(arr) # Output should be [5, 6, 11, 12, 13] arr = [38, 27, 43, 3, 9, 82] mergeSort(arr, 0, len(arr) - 1) print(arr) # Output should be [3, 9, 27, 38, 43, 82] # Unit Tests def test_mergeSort_example1(): arr = [12, 11, 13, 5, 6] mergeSort(arr, 0, len(arr) - 1) assert arr == [5, 6, 11, 12, 13] def test_mergeSort_example2(): arr = [38, 27, 43, 3, 9, 82] mergeSort(arr, 0, len(arr) - 1) assert arr == [3, 9, 27, 38, 43, 82] def test_mergeSort_single_element(): arr = [1] mergeSort(arr, 0, len(arr) - 1) assert arr == [1] def test_mergeSort_sorted_array(): arr = [1, 2, 3, 4, 5] mergeSort(arr, 0, len(arr) - 1) assert arr == [1, 2, 3, 4, 5] def test_mergeSort_reverse_sorted_array(): arr = [5, 4, 3, 2, 1] mergeSort(arr, 0, len(arr) - 1) assert arr == [1, 2, 3, 4, 5] def test_mergeSort_duplicate_elements(): arr = [2, 3, 2, 1, 3, 1] mergeSort(arr, 0, len(arr) - 1) assert arr == [1, 1, 2, 2, 3, 3]","solution":"def merge(arr, l, m, r): Merges two subarrays of arr. First subarray is arr[l..m] Second subarray is arr[m+1..r] n1 = m - l + 1 n2 = r - m # create temp arrays L = [0] * n1 R = [0] * n2 # Copy data to temp arrays L[] and R[] for i in range(n1): L[i] = arr[l + i] for j in range(n2): R[j] = arr[m + 1 + j] # Merge the temp arrays back into arr[l..r] i = 0 # Initial index of first subarray j = 0 # Initial index of second subarray k = l # Initial index of merged subarray while i < n1 and j < n2: if L[i] <= R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 # Copy the remaining elements of L[], if there are any while i < n1: arr[k] = L[i] i += 1 k += 1 # Copy the remaining elements of R[], if there are any while j < n2: arr[k] = R[j] j += 1 k += 1 def mergeSort(arr, l, r): Main function that sorts arr[l..r] using merge() if l < r: # Same as (l+r)//2 but avoids overflow for large l and h m = l + (r - l) // 2 # Sort first and second halves mergeSort(arr, l, m) mergeSort(arr, m+1, r) merge(arr, l, m, r) # Example usage # arr = [12, 11, 13, 5, 6] # mergeSort(arr, 0, len(arr) - 1) # print(arr)"},{"question":"def evaluate(expression: str) -> int: Evaluates the given mathematical expression containing non-negative integers and the operators +, -, *, and /. The input string may contain spaces which should be ignored. >>> evaluate(\\"3+5 / 2\\") 5 >>> evaluate(\\" 12 * 3 - 4 / 2 \\") 34 >>> evaluate(\\"2+3*2\\") 8","solution":"def evaluate(expression): def apply_operator(operators, values): right = values.pop() left = values.pop() op = operators.pop() if op == '+': values.append(left + right) elif op == '-': values.append(left - right) elif op == '*': values.append(left * right) elif op == '/': values.append(left // right) def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 tokens = expression.replace(\\" \\", \\"\\") values = [] operators = [] i = 0 while i < len(tokens): if tokens[i].isdigit(): val = 0 while i < len(tokens) and tokens[i].isdigit(): val = val * 10 + int(tokens[i]) i += 1 values.append(val) i -= 1 else: while (operators and precedence(operators[-1]) >= precedence(tokens[i])): apply_operator(operators, values) operators.append(tokens[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"from typing import List def shortest_path(n: int, m: int, grid: List[str]) -> int: Finds the shortest path in a grid from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1) avoiding obstacles ('#'). Returns the length of the shortest path or -1 if no path exists. >>> grid = [ ... \\".....\\", ... \\".#.\\", ... \\"...#.\\", ... \\".#.\\", ... \\".....\\" ... ] >>> shortest_path(5, 5, grid) 8 >>> grid = [ ... \\"..#\\", ... \\".#.\\", ... \\".#.\\" ... ] >>> shortest_path(3, 3, grid) -1 >>> grid = [ ... \\"....\\", ... \\"....\\", ... \\"....\\", ... \\"....\\" ... ] >>> shortest_path(4, 4, grid) 6 >>> grid = [ ... \\"....\\", ... \\".#\\", ... \\"....\\", ... \\"\\", ... \\"...#\\" ... ] >>> shortest_path(5, 4, grid) -1 >>> grid = [ ... \\"..\\", ... \\"..\\" ... ] >>> shortest_path(2, 2, grid) 2 >>> grid = [ ... \\"#.\\", ... \\"..\\" ... ] >>> shortest_path(2, 2, grid) -1 >>> grid = [ ... \\"..\\", ... \\".#\\" ... ] >>> shortest_path(2, 2, grid) -1","solution":"from collections import deque def shortest_path(n, m, grid): Finds the shortest path in a grid from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1) avoiding obstacles ('#'). Returns the length of the shortest path or -1 if no path exists. if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(0, 0, 0)]) # (row, col, distance) visited = [[False] * m for _ in range(n)] visited[0][0] = True while queue: r, c, dist = queue.popleft() if r == n-1 and c == m-1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and grid[nr][nc] == '.' and not visited[nr][nc]: visited[nr][nc] = True queue.append((nr, nc, dist + 1)) return -1"},{"question":"from typing import List def longest_increasing_subarray(temperatures: List[int]) -> int: Determine the length of the longest contiguous subarray where the temperatures are strictly increasing. >>> longest_increasing_subarray([30, 32, 31, 33, 35, 37, 36, 38, 40]) 4 >>> longest_increasing_subarray([25, 26, 27, 28, 29, 30, 30, 31, 32]) 6 >>> longest_increasing_subarray([30]) 1 >>> longest_increasing_subarray([30, 30, 30, 30, 30]) 1 >>> longest_increasing_subarray([30, 31, 32, 33, 34, 35]) 6 >>> longest_increasing_subarray([35, 34, 33, 32, 31, 30]) 1 >>> longest_increasing_subarray([1, 2, 2, 2, 2, 3, 4, 5]) 4 >>> longest_increasing_subarray([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subarray([1, 3, 2, 4, 6, 5, 7, 8]) 3","solution":"def longest_increasing_subarray(temperatures): if not temperatures: return 0 max_len = 1 current_len = 1 for i in range(1, len(temperatures)): if temperatures[i] > temperatures[i - 1]: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len"},{"question":"from typing import List def sunset_view(heights: List[int]) -> List[int]: Returns the heights of buildings that have a sunset view. A building has a sunset view if it is taller than all buildings to its right. >>> sunset_view([3, 7, 8, 3, 6, 1]) [8, 6, 1] >>> sunset_view([1, 3, 2, 4, 5, 3, 2]) [5, 3, 2] >>> sunset_view([5]) [5] >>> sunset_view([4, 4, 4, 4]) [4] >>> sunset_view([1, 2, 3, 4, 5]) [5] >>> sunset_view([5, 4, 3, 2, 1]) [5, 4, 3, 2, 1] >>> sunset_view([6, 2, 6, 4, 3, 7]) [7] >>> sunset_view([]) []","solution":"def sunset_view(heights): Returns the heights of buildings that have a sunset view. A building has a sunset view if it is taller than all buildings to its right. if not heights: return [] sunset_buildings = [] max_height = float('-inf') for height in reversed(heights): if height > max_height: sunset_buildings.append(height) max_height = height return sunset_buildings[::-1]"},{"question":"def longest_mountain(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the length of the longest mountain in each array from the list of test cases. Args: T : int : number of test cases test_cases: List[Tuple[int, List[int]]] : contains tuples; first element is the number of integers and second is the list of integers Returns: List[int] : list of length of the longest mountain in each test case array >>> longest_mountain(3, [(9, [2, 1, 4, 7, 3, 2, 5, 2, 1]), (5, [2, 2, 2, 2, 2]), (7, [2, 3, 3, 2, 1, 0, 1])]) [5, 0, 0] >>> longest_mountain(3, [(5, [1, 2, 3, 2, 1]), (3, [1, 2, 1]), (4, [1, 3, 2, 1])]) [5, 3, 4] >>> longest_mountain(2, [(8, [1, 2, 1, 2, 1, 2, 1, 2]), (11, [3, 4, 5, 3, 2, 1, 4, 6, 5, 4, 3])]) [3, 6]","solution":"def longest_mountain(T, test_cases): def find_longest_mountain(arr): n = len(arr) if n < 3: return 0 longest = 0 for i in range(1, n-1): if arr[i] > arr[i-1] and arr[i] > arr[i+1]: left = i-1 right = i+1 while left > 0 and arr[left] > arr[left-1]: left -= 1 while right < n-1 and arr[right] > arr[right+1]: right += 1 longest = max(longest, right - left + 1) return longest results = [] for i in range(T): N, heights = test_cases[i] results.append(find_longest_mountain(heights)) return results"},{"question":"def min_removals_to_strictly_increasing(S: str) -> int: Returns the minimum number of contiguous substrings to remove to make S strictly increasing. >>> min_removals_to_strictly_increasing(\\"abc\\") 0 >>> min_removals_to_strictly_increasing(\\"aa\\") 1 >>> min_removals_to_strictly_increasing(\\"bacd\\") 1 >>> min_removals_to_strictly_increasing(\\"a\\") 0 >>> min_removals_to_strictly_increasing(\\"abcdef\\") 0 >>> min_removals_to_strictly_increasing(\\"zyxwv\\") 4 >>> min_removals_to_strictly_increasing(\\"\\") 0 def process_test_cases(test_cases: List[str]) -> List[int]: Processes multiple test cases of strings. >>> process_test_cases([\\"abc\\", \\"aa\\", \\"bacd\\"]) [0, 1, 1] >>> process_test_cases([\\"a\\", \\"abcdef\\", \\"zyxwv\\"]) [0, 0, 4]","solution":"def min_removals_to_strictly_increasing(S): Returns the minimum number of contiguous substrings to remove to make S strictly increasing. n = len(S) if n == 0: return 0 # Initialize a counter for the removals needed. removals = 0 # We iterate over the string and find where it is not strictly increasing. for i in range(1, n): if S[i] <= S[i-1]: removals += 1 return removals def process_test_cases(test_cases): Processes multiple test cases of strings. results = [] for S in test_cases: results.append(min_removals_to_strictly_increasing(S)) return results"},{"question":"def transformString(s: str) -> str: Returns the lexicographically maximal string that can be achieved by performing the described operations any number of times. >>> transformString(\\"abc\\") 'zzz' >>> transformString(\\"aabbcc\\") 'zzzzzz' >>> transformString(\\"m\\") 'z' >>> transformString(\\"xylophone\\") 'zzzzzzzzz'","solution":"def transformString(s): Returns the lexicographically maximal string that can be achieved by performing the described operations any number of times. # Since we can replace any character by incrementing it continually # until it becomes 'z', the optimal plan is to replace every character with 'z'. return 'z' * len(s)"},{"question":"def custom_to_decimal(n: int, charset: str, custom_num: str) -> int: Converts a number from a custom numeral system to its equivalent decimal value. Args: n (int): The base of the custom numeral system. charset (str): The characters used in the custom numeral system. custom_num (str): The number in the custom numeral system. Returns: int: The equivalent decimal value. Examples: >>> custom_to_decimal(16, \\"0123456789ABCDEF\\", \\"1A\\") 26 >>> custom_to_decimal(8, \\"01234567\\", \\"72\\") 58 >>> custom_to_decimal(2, \\"01\\", \\"1101\\") 13 >>> custom_to_decimal(36, \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\", \\"10\\") 36 def decimal_to_custom(n: int, charset: str, decimal_num: int) -> str: Converts a decimal number to its equivalent in a custom numeral system. Args: n (int): The base of the custom numeral system. charset (str): The characters used in the custom numeral system. decimal_num (int): The decimal number. Returns: str: The equivalent number in the custom numeral system. Examples: >>> decimal_to_custom(16, \\"0123456789ABCDEF\\", 26) '1A' >>> decimal_to_custom(8, \\"01234567\\", 58) '72' >>> decimal_to_custom(2, \\"01\\", 13) '1101' >>> decimal_to_custom(36, \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\", 36) '10'","solution":"def custom_to_decimal(n, charset, custom_num): Converts a number from a custom numeral system to its equivalent decimal value. Args: n (int): The base of the custom numeral system. charset (str): The characters used in the custom numeral system. custom_num (str): The number in the custom numeral system. Returns: int: The equivalent decimal value. decimal_value = 0 for char in custom_num: decimal_value = decimal_value * n + charset.index(char) return decimal_value def decimal_to_custom(n, charset, decimal_num): Converts a decimal number to its equivalent in a custom numeral system. Args: n (int): The base of the custom numeral system. charset (str): The characters used in the custom numeral system. decimal_num (int): The decimal number. Returns: str: The equivalent number in the custom numeral system. if decimal_num == 0: return charset[0] custom_value = \\"\\" while decimal_num > 0: custom_value = charset[decimal_num % n] + custom_value decimal_num = decimal_num // n return custom_value"},{"question":"from typing import List, Tuple def max_difference_sum(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are given an array of integers where each element represents the height of a hill. You need to identify two non-overlapping subarrays such that the difference in heights between the highest peak and the lowest valley in each subarray is maximized. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples, each containing an integer n and a list of n heights of hills. Returns: List[int]: List of integers representing the maximum possible value of the sum of the differences between the highest peak and the lowest valley of two non-overlapping subarrays for each test case. Example: >>> max_difference_sum(3, [(5, [1, 2, 6, 4, 5]), (6, [10, 8, 2, 5, 7, 6]), (4, [1, 3, 1, 3])]) [6, 10, 4] pass","solution":"def max_difference_sum(t, test_cases): results = [] for case in test_cases: n, heights = case prefix_min = [0] * n prefix_max = [0] * n suffix_min = [0] * n suffix_max = [0] * n prefix_min[0] = heights[0] prefix_max[0] = heights[0] for i in range(1, n): prefix_min[i] = min(prefix_min[i-1], heights[i]) prefix_max[i] = max(prefix_max[i-1], heights[i]) suffix_min[n-1] = heights[n-1] suffix_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): suffix_min[i] = min(suffix_min[i+1], heights[i]) suffix_max[i] = max(suffix_max[i+1], heights[i]) max_diff = 0 for i in range(n-1): left_diff = prefix_max[i] - prefix_min[i] right_diff = suffix_max[i+1] - suffix_min[i+1] max_diff = max(max_diff, left_diff + right_diff) results.append(max_diff) return results"},{"question":"def count_consistent_employees(T, test_cases): Determine the number of employees who have consistently scored above the threshold every day of the month. Args: T: int - Number of test cases. test_cases: list - A list of tuples where each tuple contains: - A tuple (N, M) where N is the number of employees and M is the number of days in the month. - An integer TH which is the threshold score. - A list of lists where each inner list contains M integers representing the scores of an employee for each day of the month. Returns: list - A list of integers where each integer represents the number of employees who have scored above the threshold on every day of the month for each test case. Examples: >>> T = 2 >>> test_cases = [ >>> ((3, 4), 10, [ >>> [12, 15, 16, 18], >>> [11, 10, 9, 20], >>> [13, 14, 12, 11] >>> ]), >>> ((2, 5), 20, [ >>> [22, 25, 21, 23, 20], >>> [19, 22, 25, 30, 21] >>> ]) >>> ] >>> count_consistent_employees(T, test_cases) [2, 0]","solution":"def count_consistent_employees(T, test_cases): results = [] for case in test_cases: N, M = case[0] TH = case[1] scores = case[2] count = 0 for employee in scores: if all(score > TH for score in employee): count += 1 results.append(count) return results"},{"question":"def is_magical_plant(growth_potentials): Determines if a plant is magical by checking if there exists at least one contiguous subarray whose sum is even. def enchanted_forest(n, plants): Processes a list of plants to determine if each is magical. n: int, number of plants plants: list of lists, each containing the growth potentials of a plant >>> enchanted_forest(3, [[1, 2, 3], [1, 3, 5, 7], [6, -2]]) ['MAGICAL', 'NOT MAGICAL', 'MAGICAL'] >>> enchanted_forest(2, [[1, 3, 5], [7, 9, 11, 13]]) ['NOT MAGICAL', 'NOT MAGICAL'] >>> enchanted_forest(2, [[2, 4, 6], [1, 2, 3]]) ['MAGICAL', 'MAGICAL'] >>> enchanted_forest(1, [[2, 4, 8, -6]]) ['MAGICAL'] >>> enchanted_forest(2, [[1], [2]]) ['NOT MAGICAL', 'MAGICAL']","solution":"def is_magical_plant(growth_potentials): Determines if a plant is magical by checking if there exists at least one contiguous subarray whose sum is even. for potential in growth_potentials: if potential % 2 == 0: return \\"MAGICAL\\" return \\"NOT MAGICAL\\" def enchanted_forest(n, plants): Processes a list of plants to determine if each is magical. n: int, number of plants plants: list of lists, each containing the growth potentials of a plant results = [] for plant in plants: results.append(is_magical_plant(plant)) return results"},{"question":"def shortest_subsequence_with_k_colors(n: int, k: int, colors: List[int]) -> int: Determines the length of the shortest subsequence that contains all k colors. If it is not possible to find such a subsequence, returns -1. >>> shortest_subsequence_with_k_colors(10, 3, [1, 2, 2, 3, 1, 2, 1, 3, 2, 3]) 3 >>> shortest_subsequence_with_k_colors(5, 3, [1, 1, 1, 2, 2]) -1 >>> shortest_subsequence_with_k_colors(5, 2, [1, 2, 1, 2, 1]) 2 from typing import List def test_example_1(): assert shortest_subsequence_with_k_colors(10, 3, [1, 2, 2, 3, 1, 2, 1, 3, 2, 3]) == 3 def test_no_valid_subsequence(): assert shortest_subsequence_with_k_colors(5, 3, [1, 1, 1, 2, 2]) == -1 def test_entire_sequence_is_valid(): assert shortest_subsequence_with_k_colors(5, 2, [1, 2, 1, 2, 1]) == 2 def test_single_element_repeats(): assert shortest_subsequence_with_k_colors(7, 2, [1, 1, 2, 1, 2, 2, 1]) == 2 def test_large_k_not_possible(): assert shortest_subsequence_with_k_colors(5, 6, [1, 2, 3, 4, 5]) == -1 def test_large_k_possible(): assert shortest_subsequence_with_k_colors(6, 6, [1, 6, 2, 5, 4, 3]) == 6 def test_single_color_repeats(): assert shortest_subsequence_with_k_colors(5, 1, [1, 1, 1, 1, 1]) == 1","solution":"def shortest_subsequence_with_k_colors(n, k, colors): from collections import defaultdict color_dict = defaultdict(int) total_colors = 0 min_length = float('inf') start = 0 for end in range(n): if color_dict[colors[end]] == 0: total_colors += 1 color_dict[colors[end]] += 1 while total_colors == k: min_length = min(min_length, end - start + 1) color_dict[colors[start]] -= 1 if color_dict[colors[start]] == 0: total_colors -= 1 start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def total_harvest_time(grid: List[List[int]]) -> int: Calculate the total harvest time for all crops in the grid. Args: grid (List[List[int]]): A 2D list of integers representing the crop grid. Returns: int: The total harvest time for all crops. >>> total_harvest_time([ ... [3, 0, 2], ... [0, 4, 0], ... [1, 0, 5] ... ]) == 15 >>> total_harvest_time([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> total_harvest_time([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 45 >>> total_harvest_time([ ... [0, 1, 0], ... [2, 0, 3], ... [0, 4, 0] ... ]) == 10 >>> total_harvest_time([ ... [1, 0, 2, 0, 3] ... ]) == 6 >>> total_harvest_time([ ... [1], ... [0], ... [2], ... [0], ... [3] ... ]) == 6 >>> total_harvest_time([ ... [0, 0, 0], ... [0, 4, 0], ... [0, 0, 0] ... ]) == 4 pass","solution":"def total_harvest_time(grid): Calculate the total harvest time for all crops in the grid. Args: grid (List[List[int]]): A 2D list of integers representing the crop grid. Returns: int: The total harvest time for all crops. total_time = 0 for row in grid: for cell in row: if cell > 0: total_time += cell return total_time"},{"question":"def find_groups(s: str) -> List[str]: Splits the input string into groups of consecutive letters from the alphabet. Args: s (str): The input string containing lowercase letters 'a' to 'z'. Returns: List[str]: A list of strings, where each string represents a group of consecutive letters. pass # Example test cases def test_single_group(): assert find_groups(\\"abcdef\\") == [\\"abcdef\\"] def test_multiple_groups(): assert find_groups(\\"abdefghij\\") == [\\"ab\\", \\"defghij\\"] def test_single_letter(): assert find_groups(\\"a\\") == [\\"a\\"] def test_non_consecutive_chars(): assert find_groups(\\"az\\") == [\\"a\\", \\"z\\"] assert find_groups(\\"ace\\") == [\\"a\\", \\"c\\", \\"e\\"] def test_groups_with_non_sequential_start(): assert find_groups(\\"mnopqrstu\\") == [\\"mnopqrstu\\"] def test_empty_string(): assert find_groups(\\"\\") == [] def test_all_letters(): assert find_groups(\\"abcdefghijklmnopqrstuvwxyz\\") == [\\"abcdefghijklmnopqrstuvwxyz\\"]","solution":"def find_groups(s): Splits the input string into groups of consecutive letters from the alphabet. Args: s (str): The input string containing lowercase letters 'a' to 'z'. Returns: List[str]: A list of strings, where each string represents a group of consecutive letters. if not s: return [] result = [] current_group = s[0] for i in range(1, len(s)): if ord(s[i]) == ord(s[i - 1]) + 1: current_group += s[i] else: result.append(current_group) current_group = s[i] result.append(current_group) return result"},{"question":"def isomorphic(s: str, t: str) -> bool: Determine if two strings s and t are isomorphic. Args: s: First string t: Second string Returns: True if s and t are isomorphic, False otherwise. Examples: >>> isomorphic('egg', 'add') True >>> isomorphic('foo', 'bar') False >>> isomorphic('paper', 'title') True >>> isomorphic('abc', 'xyz') True >>> isomorphic('abc', 'xxy') False","solution":"def isomorphic(s, t): Determines if two strings s and t are isomorphic. Args: s: First string t: Second string Returns: True if s and t are isomorphic, False otherwise. if len(s) != len(t): return False map_st = {} map_ts = {} for char_s, char_t in zip(s, t): if char_s in map_st: if map_st[char_s] != char_t: return False if char_t in map_ts: if map_ts[char_t] != char_s: return False map_st[char_s] = char_t map_ts[char_t] = char_s return True"},{"question":"from typing import List def frequency_sort(nums: List[int]) -> List[int]: Sorts an array of integers by the frequency of their appearance, and by their value if frequencies are the same. Args: nums (List[int]): A list of integers. Returns: List[int]: Sorted list by frequency, then by value. >>> frequency_sort([4, 5, 6, 5, 4, 3]) [3, 6, 4, 4, 5, 5] >>> frequency_sort([1]) [1] >>> frequency_sort([2, 2, 2, 2]) [2, 2, 2, 2] >>> frequency_sort([-1, -2, -3, -1, -2, -1]) [-3, -2, -2, -1, -1, -1] >>> frequency_sort([3, -1, -2, 2, 2, 3, -1, -2]) [-2, -2, -1, -1, 2, 2, 3, 3] >>> frequency_sort([1, 1, 2, 2, 3, 3, 4, 4, 5, 5]) [1, 1, 2, 2, 3, 3, 4, 4, 5, 5]","solution":"from collections import Counter def frequency_sort(nums): Sorts an array of integers by the frequency of their appearance, and by their value if frequencies are the same. Args: nums (list): A list of integers. Returns: list: Sorted list by frequency, then by value. count = Counter(nums) sorted_nums = sorted(nums, key=lambda x: (count[x], x)) return sorted_nums"},{"question":"def find_pairs(nums: List[int], target: int) -> Union[List[Tuple[int, int]], str]: Finds all unique pairs (a, b) in the list nums such that a + b equals target and a <= b. Returns the pairs in lexicographical order or \\"No pairs found\\" if no such pairs exist. >>> find_pairs([1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> find_pairs([-1, -2, -3, -4], -5) [(-4, -1), (-3, -2)] >>> find_pairs([1, 2, 3], 10) \\"No pairs found\\"","solution":"def find_pairs(nums, target): Finds all unique pairs (a, b) in the list nums such that a + b equals target and a <= b. Returns the pairs in lexicographical order. pairs = [] nums.sort() found_pairs = set() for i, num1 in enumerate(nums): for num2 in nums[i+1:]: if num1 + num2 == target and (num1, num2) not in found_pairs: pairs.append((num1, num2)) found_pairs.add((num1, num2)) if pairs: pairs.sort() return pairs else: return \\"No pairs found\\" # Function to take input and print the result def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) nums = list(map(int, data[1:n+1])) target = int(data[n+1]) result = find_pairs(nums, target) if result == \\"No pairs found\\": print(result) else: for pair in result: print(pair)"},{"question":"def min_removals_to_distinct(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given an integer array N of length M, find the minimum number of elements you need to remove from the array N so that all the remaining elements in the array are distinct. Return -1 if it's impossible to get an array with all distinct elements. Args: T : int : The number of test cases. test_cases : list of tuple : Each tuple contains an integer M and a list of integers representing the array N. Returns: list : A list of integers where each integer represents the minimum number of elements to remove for each test case. Example: >>> min_removals_to_distinct(3, [(4, [1, 2, 2, 3]), (5, [4, 4, 4, 4, 4]), (3, [1, 2, 3])]) [1, 4, 0] >>> min_removals_to_distinct(1, [(5, [1, 2, 3, 4, 5])]) [0] >>> min_removals_to_distinct(1, [(5, [1, 1, 1, 1, 1])]) [4] >>> min_removals_to_distinct(1, [(6, [1, 2, 3, 4, 5, 6])]) [0] >>> min_removals_to_distinct(1, [(7, [1, 2, 2, 3, 3, 3, 4])]) [3] >>> min_removals_to_distinct(1, [(0, [])]) [0]","solution":"def min_removals_to_distinct(T, test_cases): results = [] for t in range(T): M = test_cases[t][0] N = test_cases[t][1] freq = {} for num in N: freq[num] = freq.get(num, 0) + 1 removals = 0 for count in freq.values(): removals += count - 1 results.append(removals) return results"},{"question":"def banking_system(queries): Simulate a simple banking system where you can create accounts, deposit money, withdraw money and check the balance of an account. Each user account is identified by a unique account number. Args: - queries: List of strings representing the queries. Each query can be of the following types: - \\"CREATE A\\" - Create a new account with the account number A with a balance of 0. - \\"DEPOSIT A X\\" - Deposit amount X into account A. - \\"WITHDRAW A X\\" - Withdraw amount X from account A, if the account has sufficient funds. - \\"BALANCE A\\" - Print the current balance of account A. Returns: - List containing the balances of the account A for each \\"BALANCE\\" query. >>> banking_system([\\"CREATE 123\\", \\"DEPOSIT 123 500\\", \\"WITHDRAW 123 100\\", \\"BALANCE 123\\"]) [400] >>> banking_system([\\"CREATE 456\\", \\"DEPOSIT 456 300\\", \\"WITHDRAW 456 500\\", \\"BALANCE 456\\"]) [300] >>> banking_system([\\"CREATE 789\\", \\"BALANCE 789\\"]) [0] >>> banking_system([\\"CREATE 111\\", \\"DEPOSIT 111 1000\\", \\"WITHDRAW 111 250\\", \\"BALANCE 111\\"]) [750] >>> banking_system([\\"CREATE 222\\", \\"DEPOSIT 222 400\\", \\"WITHDRAW 222 500\\", \\"BALANCE 222\\"]) [400] >>> banking_system([\\"BALANCE 999\\"]) [None] >>> banking_system([ \\"CREATE 123\\", \\"CREATE 124\\", \\"DEPOSIT 123 200\\", \\"DEPOSIT 124 300\\", \\"WITHDRAW 123 100\\", \\"WITHDRAW 124 150\\", \\"BALANCE 123\\", \\"BALANCE 124\\" ]) [100, 150]","solution":"def banking_system(queries): accounts = {} result = [] for query in queries: parts = query.split() command = parts[0] account = int(parts[1]) if command == \\"CREATE\\": accounts[account] = 0 elif command == \\"DEPOSIT\\": amount = int(parts[2]) if account in accounts: accounts[account] += amount elif command == \\"WITHDRAW\\": amount = int(parts[2]) if account in accounts and accounts[account] >= amount: accounts[account] -= amount elif command == \\"BALANCE\\": if account in accounts: result.append(accounts[account]) else: result.append(None) return result"},{"question":"def total_awake_time(m: int, intervals: List[Tuple[int, int]]) -> int: Returns the total duration for which at least one dragon is awake. Parameters: m (int): The number of dragons. intervals (list of tuples): List of tuples where each tuple contains two integers (s_j, e_j) representing the start and end times of the j-th dragon's activity period. Returns: int: Total uninterrupted time during which at least one dragon was awake. >>> total_awake_time(1, [(1, 4)]) == 3 >>> total_awake_time(2, [(1, 3), (4, 6)]) == 4 >>> total_awake_time(3, [(1, 4), (3, 5), (6, 8)]) == 6 >>> total_awake_time(3, [(1, 4), (2, 3), (1, 2)]) == 3 >>> total_awake_time(0, []) == 0 >>> total_awake_time(5, [(1, 10), (5, 15), (2, 7), (14, 20), (19, 25)]) == 24 >>> total_awake_time(4, [(1, 10), (2, 9), (3, 8), (4, 7)]) == 9","solution":"def total_awake_time(m, intervals): Returns the total duration for which at least one dragon is awake. Parameters: m (int): The number of dragons. intervals (list of tuples): List of tuples where each tuple contains two integers (s_j, e_j) representing the start and end times of the j-th dragon's activity period. Returns: int: Total uninterrupted time during which at least one dragon was awake. if m == 0: return 0 # Sort intervals based on the start time intervals.sort() total_time = 0 current_start, current_end = intervals[0] for i in range(1, m): start, end = intervals[i] if start > current_end: total_time += current_end - current_start current_start, current_end = start, end else: current_end = max(current_end, end) # Add the last interval total_time += current_end - current_start return total_time # Example Usage # print(total_awake_time(3, [(1, 4), (3, 5), (6, 8)])) # Output: 7 - 1 + 2 = 4"},{"question":"from typing import List, Tuple def find_tree_diameter(n: int, edges: List[Tuple[int, int]]) -> int: Finds the diameter of the tree given nodes and edges. :param n: Number of nodes in the tree. :param edges: List of edges in the tree. :returns: The diameter of the tree. >>> find_tree_diameter(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) 3 >>> find_tree_diameter(4, [(1, 2), (2, 3), (3, 4)]) 3 >>> find_tree_diameter(6, [(1, 2), (1, 3), (2, 4), (4, 5), (4, 6)]) 4 from solution import find_tree_diameter def test_find_tree_diameter_case_1(): n = 5 edges = [(1, 2), (1, 3), (2, 4), (2, 5)] assert find_tree_diameter(n, edges) == 3 def test_find_tree_diameter_case_2(): n = 4 edges = [(1, 2), (2, 3), (3, 4)] assert find_tree_diameter(n, edges) == 3 def test_find_tree_diameter_case_3(): n = 6 edges = [(1, 2), (1, 3), (2, 4), (4, 5), (4, 6)] assert find_tree_diameter(n, edges) == 4 def test_find_tree_diameter_case_4(): n = 2 edges = [(1, 2)] assert find_tree_diameter(n, edges) == 1 def test_find_tree_diameter_case_5(): n = 3 edges = [(1, 2), (2, 3)] assert find_tree_diameter(n, edges) == 2","solution":"from collections import deque def bfs_farthest_node(start, adj): Perform BFS to find the farthest node from the start node and its distance. :param start: The starting node for BFS. :param adj: The adjacency list representation of the graph. :returns: A tuple (farthest_node, max_distance). visited = [-1] * len(adj) queue = deque([(start, 0)]) visited[start] = 0 farthest_node = start max_distance = 0 while queue: node, distance = queue.popleft() if distance > max_distance: max_distance = distance farthest_node = node for neighbor in adj[node]: if visited[neighbor] == -1: visited[neighbor] = distance + 1 queue.append((neighbor, distance + 1)) return farthest_node, max_distance def find_tree_diameter(n, edges): Finds the diameter of the tree given nodes and edges. :param n: Number of nodes in the tree. :param edges: List of edges in the tree. :returns: The diameter of the tree. adj = [[] for _ in range(n + 1)] for u, v in edges: adj[u].append(v) adj[v].append(u) # Start BFS from any node, use node 1 here u, _ = bfs_farthest_node(1, adj) # Start BFS from u to find the farthest node from u v, diameter = bfs_farthest_node(u, adj) return diameter"},{"question":"from typing import List, Tuple def longest_coprime_subsequence_length(arr: List[int]) -> int: Find the length of the longest subsequence such that every pair of consecutive elements in the subsequence has a GCD of 1. pass def process_test_cases(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases to find the length of the longest coprime subsequence for each. pass # Unit tests def test_example_cases(): assert process_test_cases(2, [ (5, [2, 3, 5, 7, 11]), (4, [4, 6, 8, 10]) ]) == [5, 1] def test_single_element_list(): assert process_test_cases(3, [ (1, [7]), (1, [15]), (1, [2]) ]) == [1, 1, 1] def test_all_coprime_list(): assert process_test_cases(1, [ (4, [2, 3, 7, 11]) ]) == [4] def test_no_coprime_pairs(): assert process_test_cases(1, [ (5, [4, 8, 12, 16, 20]) ]) == [1] def test_large_input(): assert process_test_cases(1, [ (6, [1, 2, 3, 4, 5, 6]) ]) == [6]","solution":"from math import gcd def longest_coprime_subsequence_length(arr): n = len(arr) if n == 0: return 0 dp = [1] * n for i in range(n): for j in range(i): if gcd(arr[i], arr[j]) == 1: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def process_test_cases(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] arr = test_cases[i][1] result = longest_coprime_subsequence_length(arr) results.append(result) return results"},{"question":"def autocorrect(n: int, abbreviations: List[Tuple[str, str]], m: int, sentences: List[str]) -> List[str]: Replace abbreviations in the sentences with their full forms. Args: n (int): Number of abbreviations. abbreviations (List[Tuple[str, str]]): List of tuples where each tuple contains an abbreviation and its full form. m (int): Number of sentences. sentences (List[str]): List of sentences as strings. Returns: List[str]: List of sentences with abbreviations replaced by their full forms. >>> autocorrect(1, [('brb', 'be right back')], 1, ['please brb']) ['please be right back'] >>> autocorrect(3, [('btw', 'by the way'), ('im', 'i am'), ('lol', 'laugh out loud')], 2, ['btw this is funny', 'im happy when you lol']) ['by the way this is funny', 'i am happy when you laugh out loud'] >>> autocorrect(2, [('idk', 'i do not know'), ('tbh', 'to be honest')], 1, ['i will see you later']) ['i will see you later'] >>> autocorrect(2, [('u', 'you'), ('r', 'are')], 1, ['how r u']) ['how are you'] >>> autocorrect(1, [('btw', 'by the way')], 1, ['thanks, btw']) ['thanks, by the way']","solution":"def autocorrect(n, abbreviations, m, sentences): Replace abbreviations in the sentences with their full forms. Args: n : int : number of abbreviations abbreviations : list : list of tuples where each tuple contains an abbreviation and its full form m : int : number of sentences sentences : list : list of sentences as strings Returns: list : list of sentences with abbreviations replaced by their full forms abbr_dict = {abbr: full for abbr, full in abbreviations} def replace_abbr(sentence): words = sentence.split() replaced_sentence = ' '.join([abbr_dict.get(word, word) for word in words]) return replaced_sentence return [replace_abbr(sentence) for sentence in sentences] # Example usage: # abbreviations = [('btw', 'by the way'), ('im', 'i am'), ('lol', 'laugh out loud')] # sentences = ['btw this is funny', 'im happy when you lol'] # autocorrect(3, abbreviations, 2, sentences)"},{"question":"from typing import List def trap_water(height: List[int]) -> int: Calculate the total units of water trapped between buildings of varying heights. Given a list of non-negative integers representing the heights of a row of buildings, determine how much water is trapped after raining. Args: height (List[int]): List of non-negative integers representing the building heights Returns: int: Total units of water trapped Examples: >>> trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_water([4, 2, 0, 3, 2, 5]) 9 >>> trap_water([]) == 0 True >>> trap_water([1, 2, 3, 4, 5]) == 0 True >>> trap_water([3, 0, 2, 0, 4]) == 7 True","solution":"def trap_water(height): n = len(height) if n == 0: return 0 left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def merge_intervals(intervals): Given a list of non-overlapping intervals, merge them if they overlap. Each interval is represented as a list [start, end], where start is inclusive and end is exclusive. Args: intervals (List[List[int]]): A list of intervals. Returns: List[List[int]]: A new list of intervals where all overlapping intervals have been merged. Examples: >>> merge_intervals([[1,3],[2,6],[8,10],[15,18]]) [[1,6], [8,10], [15,18]] >>> merge_intervals([[1,4],[4,5]]) [[1,5]] >>> merge_intervals([[1,2],[3,4],[5,6]]) [[1,2], [3,4], [5,6]] >>> merge_intervals([[1,5],[2,6],[3,7],[4,8]]) [[1,8]] >>> merge_intervals([[3,4],[1,2],[5,6]]) [[1,2], [3,4], [5,6]] >>> merge_intervals([]) [] >>> merge_intervals([[1,5]]) [[1,5]] >>> merge_intervals([[1,10],[2,5],[6,9],[11,12]]) [[1,10], [11,12]]","solution":"def merge_intervals(intervals): Given a list of intervals, merge them if they overlap and return the resulting list of intervals. Each interval is a list [start, end], where start is inclusive and end is exclusive. if not intervals: return [] # Sort intervals by their start values intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last = merged[-1] if current[0] <= last[1]: # Merge intervals last[1] = max(last[1], current[1]) else: # No overlap, append the current interval merged.append(current) return merged"},{"question":"def largest_cube_size(height: int, width: int) -> int: Finds the size (side length) of the largest cube that can fill the given box without any remaining space. >>> largest_cube_size(6, 9) 3 >>> largest_cube_size(7, 11) 1 >>> largest_cube_size(8, 12) 4 >>> largest_cube_size(5, 5) 5 >>> largest_cube_size(15, 10) 5 >>> largest_cube_size(1000000, 500000) 500000 pass # Replace this with your code.","solution":"def largest_cube_size(height, width): This function takes the height and width of the box and returns the side length of the largest cube that can completely fill the box. from math import gcd return gcd(height, width) # Example usage: # height = 6 # width = 9 # print(largest_cube_size(height, width)) # Output: 3"},{"question":"def count_paths(grid): Returns the number of distinct paths from the top-left corner to the bottom-right corner of the grid. >>> count_paths([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> count_paths([[0, 1], [1, 0]]) 0","solution":"def count_paths(grid): Returns the number of distinct paths from the top-left corner to the bottom-right corner of the grid. N = len(grid) M = len(grid[0]) if grid[0][0] == 1 or grid[N-1][M-1] == 1: return 0 dp = [[0] * M for _ in range(N)] dp[0][0] = 1 for i in range(N): for j in range(M): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[N-1][M-1]"},{"question":"def find_odd_occurrence(array: List[int]) -> int: Returns the integer that occurs an odd number of times in the array. :param array: List of integers where one integer occurs an odd number of times. :return: The integer that occurs an odd number of times. pass def process_test_cases(test_cases: List[str]) -> List[int]: Processes multiple test cases and returns a list of results. :param test_cases: List of test cases, each being a string of integers. :return: A list of integers, each being the answer to a test case. pass def test_find_odd_occurrence(): assert find_odd_occurrence([1, 2, 3, 2, 3, 1, 3]) == 3 assert find_odd_occurrence([4, 5, 6, 5, 6, 4, 4]) == 4 assert find_odd_occurrence([20, 1, 1, 20, 30, 4, 4, 30, 30]) == 30 assert find_odd_occurrence([10, 10, 10]) == 10 def test_process_test_cases(): assert process_test_cases([\\"1 2 3 2 3 1 3\\", \\"4 5 6 5 6 4 4\\"]) == [3, 4] assert process_test_cases([\\"20 1 1 20 30 4 4 30 30\\"]) == [30] assert process_test_cases([\\"10 10 10\\", \\"11 11 5 5 7\\"]) == [10, 7] assert process_test_cases([\\"7\\"]) == [7]","solution":"def find_odd_occurrence(array): Returns the integer that occurs an odd number of times in the array. # Initialize result result = 0 for num in array: result ^= num return result def process_test_cases(test_cases): Processes multiple test cases and returns a list of results. results = [] for case in test_cases: numbers = list(map(int, case.split())) odd_occurrence = find_odd_occurrence(numbers) results.append(odd_occurrence) return results"},{"question":"def is_palindrome(n: int) -> bool: Returns True if n is a palindrome, otherwise False. >>> is_palindrome(121) True >>> is_palindrome(1331) True >>> is_palindrome(123) False >>> is_palindrome(1) True >>> is_palindrome(22) True def count_palindromes_in_range(T: int, ranges: List[Tuple[int, int]]) -> List[int]: For each range [L, R] in ranges, count the number of palindrome integers. Parameters: T (int): Number of test cases. ranges (list of tuples): Each tuple contains two integers (L, R). Returns: list of int: A list containing the palindrome counts for each range. def main(input: str) -> None: Main function to process the input and output the results.","solution":"def is_palindrome(n): Returns True if n is a palindrome, otherwise False. str_n = str(n) return str_n == str_n[::-1] def count_palindromes_in_range(T, ranges): For each range [L, R] in ranges, count the number of palindrome integers. Parameters: T (int): Number of test cases. ranges (list of tuples): Each tuple contains two integers (L, R). Returns: list of int: A list containing the palindrome counts for each range. results = [] for L, R in ranges: count = 0 for num in range(L, R + 1): if is_palindrome(num): count += 1 results.append(count) return results def main(input): Main function to process the input and output the results. data = input.strip().split() T = int(data[0]) ranges = [] index = 1 for _ in range(T): L = int(data[index]) R = int(data[index + 1]) ranges.append((L, R)) index += 2 results = count_palindromes_in_range(T, ranges) for result in results: print(result)"},{"question":"from typing import List def find_median(numbers: List[int]) -> float: Calculate the median of a given list of integers. >>> find_median([3, 5, 1, 2, 4]) 3.0 >>> find_median([7, 8, 3, 5, 1, 2, 4, 6]) 4.5 >>> find_median([4]) 4.0 >>> find_median([10, 20]) 15.0 >>> find_median([1, 2, 3, 4, 5]) 3.0 >>> find_median([5, 4, 3, 2, 1]) 3.0 >>> find_median([-5, -1, -3, -2, -4]) -3.0 >>> find_median([3, -5, 1, -2, 4]) 1.0","solution":"def find_median(numbers): Returns the median of a list of numbers. # Sort the list of numbers numbers.sort() # Find the length of the list n = len(numbers) # If the length of the list is odd, return the middle element if n % 2 == 1: return float(numbers[n // 2]) # If the length of the list is even, return the average of the two middle elements else: mid1 = numbers[n // 2 - 1] mid2 = numbers[n // 2] return (mid1 + mid2) / 2.0"},{"question":"from typing import List def is_gift_exchange_possible(N: int, P: List[List[int]]) -> str: Determine whether a valid gift exchange is possible given the restriction matrix. >>> is_gift_exchange_possible(4, [[0, 1, 1, 0], [1, 0, 1, 1], [1, 1, 0, 1], [0, 1, 1, 0]]) 'Possible' >>> is_gift_exchange_possible(3, [[0, 1, 0], [1, 0, 1], [0, 1, 0]]) 'Not Possible'","solution":"def is_gift_exchange_possible(N, P): def bpm(u, matchR, seen): for v in range(N): if P[u][v] and not seen[v]: seen[v] = True if matchR[v] == -1 or bpm(matchR[v], matchR, seen): matchR[v] = u return True return False matchR = [-1] * N result = 0 for i in range(N): seen = [False] * N if bpm(i, matchR, seen): result += 1 if result == N: return \\"Possible\\" else: return \\"Not Possible\\""},{"question":"def process_queries(N: int, Q: int, tasks: List[int], queries: List[str]) -> List[int]: Parse the tasks and process the queries. Args: - N (int): Number of checkpoints. - Q (int): Number of queries. - tasks (List[int]): List of integers representing the number of tasks at each checkpoint. - queries (List[str]): List of query strings. Returns: - List[int]: Results of the range queries. >>> process_queries(5, 3, [2, 5, 3, 8, 6], [\\"2 2 4\\", \\"1 3 10\\", \\"2 1 5\\"]) [16, 31] >>> process_queries(5, 6, [1, 2, 3, 4, 5], [\\"1 1 5\\", \\"1 2 4\\", \\"1 3 3\\", \\"1 4 2\\", \\"1 5 1\\", \\"2 1 5\\"]) [15] >>> process_queries(5, 3, [1, 1, 1, 1, 1], [\\"2 1 5\\", \\"2 2 4\\", \\"2 3 3\\"]) [5, 3, 1] >>> process_queries(5, 6, [10, 20, 30, 40, 50], [\\"2 1 3\\", \\"1 2 25\\", \\"2 1 3\\", \\"2 2 4\\", \\"1 5 55\\", \\"2 4 5\\"]) [60, 65, 95, 95]","solution":"class RaceEvent: def __init__(self, tasks): self.tasks = tasks self.prefix_sum = self._compute_prefix_sum(tasks) def _compute_prefix_sum(self, tasks): prefix_sum = [0] * (len(tasks) + 1) for i in range(1, len(tasks) + 1): prefix_sum[i] = prefix_sum[i - 1] + tasks[i - 1] return prefix_sum def update_task(self, idx, t): idx -= 1 old_value = self.tasks[idx] self.tasks[idx] = t difference = t - old_value for i in range(idx + 1, len(self.prefix_sum)): self.prefix_sum[i] += difference def query_tasks(self, l, r): return self.prefix_sum[r] - self.prefix_sum[l - 1] def process_queries(N, Q, tasks, queries): race_event = RaceEvent(tasks) results = [] for query in queries: q = query.split() if q[0] == '1': idx, t = int(q[1]), int(q[2]) race_event.update_task(idx, t) elif q[0] == '2': l, r = int(q[1]), int(q[2]) results.append(race_event.query_tasks(l, r)) return results"},{"question":"def can_make_equal(q: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[str]: Determine if it is possible to make arrays a and b equal after some operations. Arguments: q : int : Number of test cases test_cases : List[Tuple[int, List[int], List[int]]] : List containing tuples with following elements - - Length of arrays a and b - Array a - Array b Returns: List[str] : List containing \\"YES\\" or \\"NO\\" for each test case Example Usage: >>> can_make_equal(3, [(4, [1, 2, 3, 4], [4, 3, 2, 1]), (5, [3, 3, 3, 3, 3], [3, 3, 3, 3, 3]), (4, [2, 4, 6, 8], [1, 3, 5, 7])]) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_make_equal(q, test_cases): results = [] for i in range(q): n, a, b = test_cases[i] if sorted(a) == sorted(b): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage # q = 3 # test_cases = [ # (4, [1, 2, 3, 4], [4, 3, 2, 1]), # (5, [3, 3, 3, 3, 3], [3, 3, 3, 3, 3]), # (4, [2, 4, 6, 8], [1, 3, 5, 7]) # ] # print(can_make_equal(q, test_cases)) # Expected Output: [\\"YES\\", \\"YES\\", \\"NO\\"]"},{"question":"def orGate(N: int, arr: List[int]) -> int: Given N bits, this function returns the output after processing OR operations on the bits. >>> orGate(5, [0, 0, 0, 1, 0]) 1 >>> orGate(3, [0, 0, 0]) 0","solution":"def orGate(N, arr): Given N bits, this function returns the output after processing OR operations on the bits. result = arr[0] for i in range(1, N): result |= arr[i] return result"},{"question":"def removeDuplicates(nums: List[int]) -> int: Given an integer array 'nums' sorted in non-decreasing order, remove duplicates in-place such that each element appears at most twice and return the new length of the modified array. The relative order of the elements should be kept the same. You must modify the input array in-place and use only O(1) extra space. >>> nums = [1,1,1,2,2,3,3,3] >>> length = removeDuplicates(nums) >>> length 6 >>> nums[:length] [1,1,2,2,3,3] >>> nums = [0,0,1,1,1,1,2,3,3] >>> length = removeDuplicates(nums) >>> length 7 >>> nums[:length] [0,0,1,1,2,3,3] >>> nums = [1,2,3,4,5] >>> length = removeDuplicates(nums) >>> length 5 >>> nums[:length] [1,2,3,4,5] >>> nums = [1,1,1,1,1] >>> length = removeDuplicates(nums) >>> length 2 >>> nums[:length] [1,1] >>> nums = [] >>> length = removeDuplicates(nums) >>> length 0 >>> nums = [1] >>> length = removeDuplicates(nums) >>> length 1 >>> nums[:length] [1] >>> nums = [1,1] >>> length = removeDuplicates(nums) >>> length 2 >>> nums[:length] [1,1] pass","solution":"def removeDuplicates(nums): Modify the input array in-place to remove duplicates such that each element appears at most twice. Returns the new length of the modified array. if len(nums) <= 2: return len(nums) write_index = 2 for i in range(2, len(nums)): if nums[i] != nums[write_index - 2]: nums[write_index] = nums[i] write_index += 1 return write_index"},{"question":"def max_puzzles_solved(puzzles: List[int], max_difficulty: int) -> int: Returns the maximum number of unique puzzles the players can solve without exceeding the total difficulty level. >>> max_puzzles_solved([1, 2, 3, 4, 5], 10) == 4 >>> max_puzzles_solved([5, 3, 7, 1, 2, 4], 8) == 2 >>> max_puzzles_solved([1, 1, 1, 1, 1, 1], 4) == 4 >>> max_puzzles_solved([10, 20, 30], 5) == 0 >>> max_puzzles_solved([], 10) == 0 >>> max_puzzles_solved([2, 2, 2, 2], 8) == 4 >>> max_puzzles_solved([4, 4, 4, 4], 15) == 3 >>> max_puzzles_solved([1, 2, 3, 4], 5) == 2 # Your implementation here","solution":"def max_puzzles_solved(puzzles, max_difficulty): Returns the maximum number of unique puzzles the players can solve without exceeding the total difficulty level. total_difficulty = 0 count = 0 for difficulty in puzzles: if total_difficulty + difficulty <= max_difficulty: total_difficulty += difficulty count += 1 else: break return count"},{"question":"def find_longest_even_length_substring(s: str) -> int: Finds the longest even length substring which can be split into two halves with equal sum. The input is a string consisting only of digits. >>> find_longest_even_length_substring(\\"123123\\") 6 >>> find_longest_even_length_substring(\\"111111\\") 6 >>> find_longest_even_length_substring(\\"123456\\") 0 >>> find_longest_even_length_substring(\\"1\\") 0 >>> find_longest_even_length_substring(\\"12\\") 0 >>> find_longest_even_length_substring(\\"1538023\\") 4","solution":"def find_longest_even_length_substring(s): def is_equal_sum(s, start, length): half_length = length // 2 sum1 = sum(int(s[start + i]) for i in range(half_length)) sum2 = sum(int(s[start + half_length + i]) for i in range(half_length)) return sum1 == sum2 n = len(s) max_len = 0 for length in range(2, n + 1, 2): for start in range(n - length + 1): if is_equal_sum(s, start, length): max_len = length return max_len"},{"question":"from typing import List def min_steps_to_target(n: int, m: int, grid: List[str]) -> int: You are hired as a manager for a robotic warehouse. Your warehouse consists of a grid of size n x m. Each cell in the grid can either be empty or contain an obstacle. Your task is to design an algorithm that can guide a robot from its starting position to a target position anywhere in the grid, avoiding obstacles and minimizing the number of steps taken. The robot is only allowed to move up, down, left, or right at each step. -----Input----- The first line of input contains two space-separated integers n and m (1 <= n, m <= 1000), the dimensions of the grid. The next n lines each contain m characters, where each character is either '.' (representing an empty cell) or '#' (representing an obstacle). The character 'S' represents the robot's starting position, and 'T' represents the target position. It is guaranteed that there is exactly one 'S' and one 'T' in the grid. -----Output----- Print the minimum number of steps the robot needs to reach the target position. If it is impossible to reach the target, print -1. Sample Input: 5 5 S..#. .#.#. ..#.. .#..T ..... Sample Output: 9 Sample Input: 3 3 S#T # ..# Sample Output: -1 >>> min_steps_to_target(5, 5, [\\"S..#.\\", \\".#.#.\\", \\"..#..\\", \\".#..T\\", \\".....\\"]) 9 >>> min_steps_to_target(3, 3, [\\"S#T\\", \\"#\\", \\"..#\\"]) -1 pass","solution":"from collections import deque def min_steps_to_target(n, m, grid): # Locate the start and target positions start = None target = None for r in range(n): for c in range(m): if grid[r][c] == 'S': start = (r, c) elif grid[r][c] == 'T': target = (r, c) if not start or not target: return -1 # Directions: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(start[0], start[1], 0)]) # (row, col, steps) visited = set() visited.add(start) # BFS loop while queue: r, c, steps = queue.popleft() # Check if we reached the target if (r, c) == target: return steps # Explore neighbors for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] != '#': visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) # If we exhaust the queue and do not reach the target return -1"},{"question":"def are_anagrams(word1: str, word2: str) -> str: Determine if two words are anagrams of each other. Args: word1 (str): First word. word2 (str): Second word. Returns: str: \\"YES\\" if the words are anagrams, otherwise \\"NO\\". >>> are_anagrams(\\"listen\\", \\"silent\\") \\"YES\\" >>> are_anagrams(\\"triangle\\", \\"integral\\") \\"YES\\" >>> are_anagrams(\\"apple\\", \\"ppal\\") \\"NO\\" >>> are_anagrams(\\"rat\\", \\"tar\\") \\"YES\\" def process_test_cases(T: int, test_cases: list) -> list: Process multiple test cases for anagram check. Args: T (int): Number of test cases. test_cases (list of tuples): List containing tuples of two words each. Returns: list: List of results for each test case. >>> process_test_cases(4, [(\\"listen\\", \\"silent\\"), (\\"triangle\\", \\"integral\\"), (\\"apple\\", \\"ppal\\"), (\\"rat\\", \\"tar\\")]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases(4, [(\\"hello\\", \\"jello\\"), (\\"evil\\", \\"vile\\"), (\\"abc\\", \\"cba\\"), (\\"abcd\\", \\"dcbae\\")]) [\\"NO\\", \\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def are_anagrams(word1, word2): Determine if two words are anagrams of each other. Args: word1 (str): First word. word2 (str): Second word. Returns: str: \\"YES\\" if the words are anagrams, otherwise \\"NO\\" return \\"YES\\" if sorted(word1) == sorted(word2) else \\"NO\\" def process_test_cases(T, test_cases): Process multiple test cases for anagram check. Args: T (int): Number of test cases. test_cases (list of tuples): List containing tuples of two words each. Returns: list: List of results for each test case. results = [] for word1, word2 in test_cases: results.append(are_anagrams(word1, word2)) return results"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string S, return the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index = {} max_length = start = 0 for index, char in enumerate(s): if char in char_index and start <= char_index[char]: start = char_index[char] + 1 else: max_length = max(max_length, index - start + 1) char_index[char] = index return max_length"},{"question":"def longest_even_subarray(arr: List[int]) -> int: Find the length of the longest contiguous subarray containing only even numbers. >>> longest_even_subarray([2, 4, 6, 8]) == 4 >>> longest_even_subarray([1, 3, 5, 7]) == 0 >>> longest_even_subarray([1, 2, 4, 6, 1, 8]) == 3 >>> longest_even_subarray([2]) == 1 >>> longest_even_subarray([1]) == 0 >>> longest_even_subarray([2, 4, 1, 6, 8, 10, 1, 2, 4, 6]) == 3","solution":"def longest_even_subarray(arr): Returns the length of the longest contiguous subarray consisting only of even numbers. max_len = 0 current_len = 0 for num in arr: if num % 2 == 0: current_len += 1 max_len = max(max_len, current_len) else: current_len = 0 return max_len"},{"question":"def is_possible_to_rearrange_flowers(n: int, m: int, k: int, garden: List[List[int]]) -> str: Determine if it is possible to rearrange the flowers in the garden such that each row contains exactly k distinct types of flowers. >>> is_possible_to_rearrange_flowers(3, 4, 3, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) \\"possible\\" >>> is_possible_to_rearrange_flowers(2, 3, 3, [[1, 1, 1], [2, 2, 2]]) \\"impossible\\" >>> is_possible_to_rearrange_flowers(3, 4, 5, [[1, 2, 3, 3], [4, 5, 6, 6], [7, 8, 9, 9]]) \\"impossible\\" >>> is_possible_to_rearrange_flowers(2, 3, 4, [[1, 2, 3], [1, 2, 3]]) \\"impossible\\" >>> is_possible_to_rearrange_flowers(1, 1, 1, [[1]]) \\"possible\\"","solution":"def is_possible_to_rearrange_flowers(n, m, k, garden): from collections import Counter if k > m: return \\"impossible\\" # We can't have more distinct flowers than the number of columns in each row count_flower_types = Counter() for row in garden: count_flower_types.update(row) total_unique_flower_types = len(count_flower_types) if total_unique_flower_types < k: return \\"impossible\\" # Not enough distinct flower types to meet the requirement return \\"possible\\""},{"question":"def first_non_repeating_character(s: str) -> str: Write a function that takes a string as an input and returns the first non-repeating character in the string. If all characters repeat or the string is empty, return an empty string. >>> first_non_repeating_character(\\"swiss\\") \\"w\\" >>> first_non_repeating_character(\\"teeter\\") \\"r\\" >>> first_non_repeating_character(\\"aabbcc\\") \\"\\" >>> first_non_repeating_character(\\"\\") \\"\\"","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If all characters repeat or the string is empty, returns an empty string. char_count = {} # First, count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Then, find the first character in the string that has a count of 1 for char in s: if char_count[char] == 1: return char # If no such character is found, return an empty string return \\"\\""},{"question":"def findDuplicateAndMissing(arr: List[int]) -> Tuple[int, int]: Given an array of n integers, where each element lies within the range [1, n-1]. The array represents the numbers to buy a certain item, but due to a mistake, exactly one number is duplicated and one number is missing. This function finds and returns the missing number and the duplicated number. Args: arr (List[int]): The input array containing the integers. Returns: Tuple(int, int): A tuple containing the missing number and the duplicated number. >>> findDuplicateAndMissing([4, 3, 6, 2, 1, 6]) (5, 6) >>> findDuplicateAndMissing([3, 1, 1]) (2, 1)","solution":"def findDuplicateAndMissing(arr): Returns a tuple (missing, duplicate) where 'missing' is the number missing from the array and 'duplicate' is the number that is duplicated in the array. n = len(arr) + 1 # Since arr has one duplicate and one missing, the length should be increased by 1 total_sum = n * (n - 1) // 2 sum_of_arr = sum(arr) sum_of_squares = sum([x**2 for x in arr]) expected_sum_of_squares = sum([x**2 for x in range(1, n)]) sum_diff = total_sum - sum_of_arr # missing - duplicate square_sum_diff = expected_sum_of_squares - sum_of_squares # missing^2 - duplicate^2 # Now solve the two equations: # missing - duplicate = sum_diff # missing^2 - duplicate^2 = square_sum_diff # can be factored to (missing - duplicate)(missing + duplicate) = square_sum_diff # substituting missing - duplicate = sum_diff: # sum_diff * (missing + duplicate) = square_sum_diff # sum_diff * x = square_sum_diff # x = square_sum_diff / sum_diff # where x = missing + duplicate if sum_diff == 0: raise ValueError(\\"The input array does not match problem constraints of having exactly one duplicate and one missing value.\\") sum_mixed = square_sum_diff // sum_diff missing = (sum_mixed + sum_diff) // 2 duplicate = sum_mixed - missing return (missing, duplicate)"},{"question":"def process_queries(n: int, q: int, arr: List[int], queries: List[List[int]]) -> List[int]: Process a list of queries on an array where each query either updates an element or finds the minimum value in a range. :param n: Number of elements in the array. :param q: Number of queries. :param arr: Initial array of integers. :param queries: List of queries, each query is either an update or a range minimum query. :return: List of results for the range minimum queries. >>> n, q = 5, 5 >>> arr = [5, 4, 3, 2, 1] >>> queries = [ >>> [2, 1, 5], >>> [1, 3, 9], >>> [2, 1, 5], >>> [2, 3, 4], >>> [1, 5, 0] >>> ] >>> process_queries(n, q, arr, queries) [1, 1, 2] >>> n, q = 1, 1 >>> arr = [100] >>> queries = [ >>> [2, 1, 1] >>> ] >>> process_queries(n, q, arr, queries) [100] >>> n, q = 4, 4 >>> arr = [1, 2, 3, 4] >>> queries = [ >>> [1, 2, 5], >>> [2, 1, 4], >>> [1, 3, -1], >>> [2, 2, 4] >>> ] >>> process_queries(n, q, arr, queries) [1, -1] >>> n, q = 3, 3 >>> arr = [10, 20, 30] >>> queries = [ >>> [1, 1, 5], >>> [1, 2, 15], >>> [1, 3, 25] >>> ] >>> process_queries(n, q, arr, queries) [] >>> n, q = 6, 4 >>> arr = [3, 1, 4, 1, 5, 9] >>> queries = [ >>> [2, 1, 6], >>> [2, 1, 2], >>> [2, 3, 5], >>> [2, 5, 6] >>> ] >>> process_queries(n, q, arr, queries) [1, 1, 1, 5]","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (2 * self.n) for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, pos, value): pos += self.n - 1 self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = min(self.tree[2 * pos], self.tree[2 * pos + 1]) def range_min(self, l, r): l += self.n - 1 r += self.n min_val = float('inf') while l < r: if l % 2: min_val = min(min_val, self.tree[l]) l += 1 if r % 2: r -= 1 min_val = min(min_val, self.tree[r]) l //= 2 r //= 2 return min_val def process_queries(n, q, arr, queries): st = SegmentTree(arr) results = [] for query in queries: if query[0] == 1: # update query _, x, y = query st.update(x, y) elif query[0] == 2: # range min query _, l, r = query results.append(st.range_min(l, r)) return results"},{"question":"def number_of_even_ways(n, m): Returns the number of ways to fill an n x m grid such that the sum of the numbers is even. >>> number_of_even_ways(1, 1) 3 >>> number_of_even_ways(2, 2) 21 def solve(T, test_cases): Given the number of test cases T and a list of test_cases where each test case contains the dimensions of the grid (n, m), returns a list of results where each result corresponds to the number of ways to fill the respective grid such that the sum of the numbers is even.","solution":"def number_of_even_ways(n, m): Returns the number of ways to fill an n x m grid such that the sum of the numbers is even. # Total number of cells in the grid total_cells = n * m # If total cells is odd, half of the numbers (1, 3, 5) will make an odd sum and the other half (2, 4, 6) will make an even sum if total_cells % 2 == 1: return 3 # because (2, 4, 6) are the even outcomes when rolled once # If total cells is even, all configurations will work as long as the sum is a multiple of 2 else: return 21 # because all configurations with an even total sum in an even grid give (6 options and (6 // 2)**2) def solve(T, test_cases): results = [] for n, m in test_cases: results.append(number_of_even_ways(n, m)) return results"},{"question":"def dna_complement(dna_sequence: str) -> str: Returns the complementary DNA sequence according to base pairing rules. >>> dna_complement(\\"ATCG\\") \\"TAGC\\" >>> dna_complement(\\"TTAA\\") \\"AATT\\" >>> dna_complement(\\"CGCG\\") \\"GCGC\\" >>> dna_complement(\\"ACGT\\") \\"TGCA\\" >>> dna_complement(\\"GATTACA\\") \\"CTAATGT\\"","solution":"def dna_complement(dna_sequence): Returns the complementary DNA sequence according to base pairing rules. complement_mapping = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'} return ''.join(complement_mapping[nucleotide] for nucleotide in dna_sequence)"},{"question":"def can_be_strictly_increasing_with_one_change(arr, n): Check if the array can be made strictly increasing by changing at most one element. Parameters: arr (List[int]): The list of integers. n (int): The size of the array. Returns: str: \\"YES\\" if it is possible to make the array strictly increasing by changing at most one element, otherwise \\"NO\\". pass def process_test_cases(test_cases): Process multiple test cases to check if each array can be made strictly increasing by changing at most one element. Parameters: test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains the size of the array and the array itself. Returns: List[str]: A list of results for each test case, either \\"YES\\" or \\"NO\\". pass def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [] index = 1 for _ in range(T): N = int(data[index]) array = list(map(int, data[index+1:index+1+N])) test_cases.append((N, array)) index += N + 1 result = process_test_cases(test_cases) for res in result: print(res) if __name__ == \\"__main__\\": main()","solution":"def can_be_strictly_increasing_with_one_change(arr, n): error_count = 0 for i in range(1, n): if arr[i-1] >= arr[i]: error_count += 1 if error_count > 1: return \\"NO\\" if i > 1 and arr[i-2] >= arr[i]: if i+1 < n and arr[i-1] >= arr[i+1]: return \\"NO\\" return \\"YES\\" def process_test_cases(test_cases): result = [] for array_info in test_cases: n = array_info[0] arr = array_info[1] result.append(can_be_strictly_increasing_with_one_change(arr, n)) return result def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [] index = 1 for _ in range(T): N = int(data[index]) array = list(map(int, data[index+1:index+1+N])) test_cases.append((N, array)) index += N + 1 result = process_test_cases(test_cases) for res in result: print(res) if __name__ == \\"__main__\\": main()"},{"question":"def find_longest_unique_subarray(arr): Given a list of integers, finds the length of the longest subarray with all unique numbers. Args: arr (List[int]): A list of integers representing the array. Returns: int: The length of the longest subarray with all unique numbers. Examples: >>> find_longest_unique_subarray([1, 2, 1, 3, 4]) 4 >>> find_longest_unique_subarray([1, 2, 3, 2, 4, 5]) 4 >>> find_longest_unique_subarray([10, 20, 30, 40]) 4 >>> find_longest_unique_subarray([1, 1, 1, 1, 1]) 1 >>> find_longest_unique_subarray([]) 0 pass def process_test_cases(t, test_cases): Process multiple test cases to find the length of the longest subarray with all unique numbers for each case. Args: t (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer representing the length of the array and a list of integers representing the array. Returns: List[int]: A list of integers representing the length of the longest subarray with all unique numbers for each test case. Examples: >>> process_test_cases(3, [(5, [1, 2, 1, 3, 4]), (6, [1, 2, 3, 2, 4, 5]), (4, [10, 20, 30, 40])]) [4, 4, 4] >>> process_test_cases(1, [(6, [1, 1, 1, 1, 1, 1])]) [1] pass","solution":"def find_longest_unique_subarray(arr): Given a list of integers, finds the length of the longest subarray with all unique numbers. seen = {} max_len = 0 start = 0 for end, value in enumerate(arr): if value in seen and seen[value] >= start: start = seen[value] + 1 seen[value] = end max_len = max(max_len, end - start + 1) return max_len def process_test_cases(t, test_cases): results = [] for i in range(t): n, arr = test_cases[i] results.append(find_longest_unique_subarray(arr)) return results"},{"question":"def search(nums: List[int], target: int) -> int: Searches for target in nums using binary search. Returns the index of target if found, else returns -1. >>> search([-1, 0, 3, 5, 9, 12], 9) 4 >>> search([-1, 0, 3, 5, 9, 12], 2) -1 from solution import search def test_search_found(): nums = [-1, 0, 3, 5, 9, 12] target = 9 assert search(nums, target) == 4 def test_search_not_found(): nums = [-1, 0, 3, 5, 9, 12] target = 2 assert search(nums, target) == -1 def test_search_single_element_found(): nums = [5] target = 5 assert search(nums, target) == 0 def test_search_single_element_not_found(): nums = [5] target = -5 assert search(nums, target) == -1 def test_search_first_element(): nums = [-10, -5, 0, 5, 10] target = -10 assert search(nums, target) == 0 def test_search_last_element(): nums = [-10, -5, 0, 5, 10] target = 10 assert search(nums, target) == 4 def test_search_large_array(): nums = list(range(10000)) target = 5678 assert search(nums, target) == 5678 def test_search_edge_low_threshold(): nums = [-10**4, -5000, 0, 5000, 10**4] target = -10**4 assert search(nums, target) == 0 def test_search_edge_high_threshold(): nums = [-10**4, -5000, 0, 5000, 10**4] target = 10**4 assert search(nums, target) == 4","solution":"def search(nums, target): Searches for target in nums using binary search. Returns the index of target if found, else returns -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def nextHigherNumber(n: int) -> int: Write a function that takes a non-negative integer as an input and returns the next higher number that uses the same digits. >>> nextHigherNumber(2017) 2071 >>> nextHigherNumber(1234) 1243 >>> nextHigherNumber(4321) -1 >>> nextHigherNumber(111) -1","solution":"def nextHigherNumber(n): digits = list(str(n)) i = len(digits) - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 if i == -1: return -1 j = len(digits) - 1 while digits[j] <= digits[i]: j -= 1 digits[i], digits[j] = digits[j], digits[i] digits = digits[:i + 1] + digits[i + 1:][::-1] return int(''.join(digits))"},{"question":"def optimal_placement(a: int, b: int, n: int) -> List[Tuple[int, int]]: Given the predefined point (a, b) and the number of game pieces n, returns the optimal placement of game pieces on a 20x20 grid. Output is a list of tuples with each tuple representing the coordinates (i, j) of a game piece. >>> optimal_placement(0, 0, 3) [(0, 0), (1, 0), (-1, 0)] >>> optimal_placement(-10, 10, 1) [(-10, 10)]","solution":"def optimal_placement(a, b, n): Given the predefined point (a, b) and the number of game pieces n, returns the optimal placement of game pieces on a 20x20 grid. Output is a list of tuples with each tuple representing the coordinates (i, j) of a game piece. placements = [(a, b)] for i in range(1, (n // 2) + 1): if len(placements) < n: placements.append((a + i, b)) if len(placements) < n: placements.append((a - i, b)) if len(placements) < n: placements.append((a, b + i)) if len(placements) < n: placements.append((a, b - i)) return placements[:n]"},{"question":"def min_checks(T: int) -> int: Calculates the minimum number of checks required to achieve the given total amount T. Each check can endorse an amount that is a power of 2. >>> min_checks(23) 4 >>> min_checks(37) 3 >>> min_checks(1024) 1 >>> min_checks(0) 0 def process_checks(amounts: List[int]) -> List[int]: Processes multiple amounts, returning the minimum number of checks required for each amount. Terminates processing upon encountering an amount of 0. >>> process_checks([23, 37, 1024, 0]) [4, 3, 1] >>> process_checks([5, 8, 0]) [2, 1]","solution":"def min_checks(T): Calculates the minimum number of checks required to achieve the given total amount T. Each check can endorse an amount that is a power of 2. checks = 0 while T > 0: highest_power_of_2 = 1 << (T.bit_length() - 1) T -= highest_power_of_2 checks += 1 return checks def process_checks(amounts): Processes multiple amounts, returning the minimum number of checks required for each amount. Terminates processing upon encountering an amount of 0. results = [] for T in amounts: if T == 0: break results.append(min_checks(T)) return results"},{"question":"def generate_student_report(student_records): Generates a report that includes the average score of each student across the three subjects and sorts them based on these average scores in descending order. If two students have the same average score, they are sorted alphabetically by their names. def process_input(input_data): Processes the input data and returns a list of student records. from generate_student_report import generate_student_report, process_input def test_generate_student_report_sample(): input_data = 3 Alice 20 80 75 90 student_records = process_input(input_data) result = generate_student_report(student_records) expected = [(\\"Bob\\", 85.0), (\\"Charlie\\", 83.33), (\\"Alice\\", 81.67)] assert result == expected def test_generate_student_report_same_average(): input_data = 3 Alice 20 80 80 80 Bob 22 80 80 80 Charlie 21 78 84 78 student_records = process_input(input_data) result = generate_student_report(student_records) expected = [(\\"Alice\\", 80.0), (\\"Bob\\", 80.0), (\\"Charlie\\", 80.0)] assert result == expected def test_generate_student_report_all_same_scores(): input_data = 3 Alice 20 90 90 90 Bob 22 90 90 90 Charlie 21 90 90 90 student_records = process_input(input_data) result = generate_student_report(student_records) expected = [(\\"Alice\\", 90.0), (\\"Bob\\", 90.0), (\\"Charlie\\", 90.0)] assert result == expected def test_generate_student_report_single_student(): input_data = 1 Alice 20 70 80 90 student_records = process_input(input_data) result = generate_student_report(student_records) expected = [(\\"Alice\\", 80.0)] assert result == expected","solution":"def generate_student_report(student_records): Generates a report that includes the average score of each student across the three subjects and sorts them based on these average scores in descending order. If two students have the same average score, they are sorted alphabetically by their names. students_with_avg = [] for record in student_records: name, age, math, science, literature = record age = int(age) math = int(math) science = int(science) literature = int(literature) avg_score = (math + science + literature) / 3 students_with_avg.append((name, avg_score)) # Sort by average score in descending order, then by name alphabetically students_with_avg.sort(key=lambda x: (-x[1], x[0])) result = [(name, round(avg_score, 2)) for name, avg_score in students_with_avg] return result # Helper function to process the input def process_input(input_data): lines = input_data.strip().split('n') T = int(lines[0].strip()) student_records = [] for line in lines[1:T+1]: student_records.append(line.strip().split()) return student_records"},{"question":"from typing import List def weekly_hours_report(employee_hours: List[List[int]]) -> List[int]: Returns a list of total hours worked in a week by each employee. Args: employee_hours: A list of lists, where each inner list contains exactly seven integers representing the hours worked from Monday to Sunday. Returns: A list of integers representing the total hours worked in a week by each employee. >>> weekly_hours_report([ ... [8, 8, 8, 8, 8, 0, 0], ... [10, 10, 10, 10, 0, 0, 10], ... [5, 5, 5, 5, 5, 5, 5] ... ]) == [40, 50, 35] >>> weekly_hours_report([ ... [0, 0, 0, 0, 0, 0, 0], ... [1, 2, 3, 4, 5, 6, 7], ... [9, 9, 9, 9, 9, 9, 9] ... ]) == [0, 28, 63] >>> weekly_hours_report([ ... [8, 8, 8, 8, 8, 8, 8], ... [5, 5, 5, 5, 5, 5, 5], ... [6, 6, 6, 6, 6, 6, 6] ... ]) == [56, 35, 42] >>> weekly_hours_report([ ... [0, 0, 0, 0, 0, 0, 10], ... [10, 10, 10, 10, 10, 10, 10] ... ]) == [10, 70] >>> weekly_hours_report([ ... [7, 7, 7, 7, 7, 7, 7] ... ]) == [49]","solution":"from typing import List def weekly_hours_report(employee_hours: List[List[int]]) -> List[int]: Returns a list of total hours worked in a week by each employee. Args: employee_hours: A list of lists, where each inner list contains exactly seven integers representing the hours worked from Monday to Sunday. Returns: A list of integers representing the total hours worked in a week by each employee. total_hours = [sum(hours) for hours in employee_hours] return total_hours"},{"question":"def tallest_wall_height(T: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Given T test cases with different sets of brick heights, this function returns a list of the height of the tallest wall that can be built for each test case. >>> tallest_wall_height(2, [(5, [3, 1, 4, 1, 5]), (4, [10, 20, 30, 40])]) [14, 100] >>> tallest_wall_height(1, [(4, [1, 2, 3, 4])]) [10] >>> tallest_wall_height(1, [(4, [4, 3, 2, 1])]) [10] >>> tallest_wall_height(1, [(4, [5, 5, 5, 5])]) [20] >>> tallest_wall_height(1, [(1, [5])]) [5] >>> tallest_wall_height(2, [(3, [2, 9, 4]), (2, [1, 2])]) [15, 3]","solution":"def tallest_wall_height(T, cases): Given T test cases with different sets of brick heights, this function returns a list of the height of the tallest wall that can be built for each test case. results = [] for i in range(T): N = cases[i][0] heights = cases[i][1] # Sort the bricks' heights in descending order sorted_heights = sorted(heights, reverse=True) # Sum up the sorted heights wall_height = sum(sorted_heights) results.append(wall_height) return results"},{"question":"def count_substrings(s): Returns the number of substrings that start and end with the same character. >>> count_substrings(\\"abc\\") 3 >>> count_substrings(\\"aaa\\") 6 def process_test_cases(test_cases): Takes a list of test cases (strings) and returns a list of results corresponding to the number of substrings for each string in test cases. >>> process_test_cases([\\"abc\\", \\"aaa\\"]) [3, 6] >>> process_test_cases([\\"a\\", \\"\\"]) [1, 0]","solution":"def count_substrings(s): Returns the number of substrings that start and end with the same character. n = len(s) count = 0 for i in range(n): for j in range(i, n): if s[i] == s[j]: count += 1 return count def process_test_cases(test_cases): Takes a list of test cases (strings) and returns a list of results corresponding to the number of substrings for each string in test cases. results = [] for test_case in test_cases: results.append(count_substrings(test_case)) return results"},{"question":"def generate_triangle(n: int) -> str: Return Pascal's Triangle as a string in a formatted manner. >>> generate_triangle(5) '1n1 1n1 2 1n1 3 3 1n1 4 6 4 1' >>> generate_triangle(7) '1n1 1n1 2 1n1 3 3 1n1 4 6 4 1n1 5 10 10 5 1n1 6 15 20 15 6 1' >>> generate_triangle(3) '1n1 1n1 2 1'","solution":"def generate_triangle(n): if n < 1: return \\"\\" triangle = [] for i in range(n): # Create a row with '1' at the start row = [1] * (i + 1) # Calculate the values for the row if beyond the second row if i > 1: for j in range(1, i): row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j] # Append the row to the triangle triangle.append(row) # Convert to the required string format triangle_str = 'n'.join([' '.join(map(str, row)) for row in triangle]) return triangle_str"},{"question":"from typing import List from collections import Counter def findKthMostFrequentChar(S: str, K: int) -> str: Finds the K-th most frequent character in the string S. If there are multiple characters with the same frequency, returns them in alphabetical order. >>> findKthMostFrequentChar(\\"aabbcc\\", 1) 'a' >>> findKthMostFrequentChar(\\"geeksforgeeks\\", 2) 'e'","solution":"from collections import Counter def findKthMostFrequentChar(S, K): Finds the K-th most frequent character in the string S. If there are multiple characters with the same frequency, returns them in alphabetical order. # Count the frequency of each character in the string frequency = Counter(S) # Create a list of tuples (character, frequency) and sort it based on frequency (descending) # and then alphabetically (ascending) for characters with the same frequency sorted_chars = sorted(frequency.items(), key=lambda x: (-x[1], x[0])) # Return the K-th most frequent character return sorted_chars[K-1][0]"},{"question":"class Grid: def __init__(self, n, m): Initialize the grid with n rows and m columns filled with zeroes. self.n = n self.m = m self.grid = [[0] * m for _ in range(n)] def add(self, x, y, k): Add the value k to the cell at (x, y). self.grid[x-1][y-1] += k def query(self, x1, y1, x2, y2): Calculate the sum of the cells in the subgrid from (x1, y1) to (x2, y2). total_sum = 0 for i in range(x1-1, x2): for j in range(y1-1, y2): total_sum += self.grid[i][j] return total_sum def run_operations(n, m, operations): Perform a series of operations on the grid and return the results of the query operations. Parameters: - n, m: Dimensions of the grid. - operations: List of operations to be performed on the grid. Returns: - List of results of all query operations. >>> run_operations(3, 3, [\\"add 1 1 3\\", \\"add 2 2 4\\", \\"add 3 3 5\\", \\"query 1 1 2 2\\", \\"query 1 1 3 3\\"]) [7, 12] >>> run_operations(4, 4, [\\"add 1 1 10\\", \\"add 2 2 20\\", \\"query 1 1 2 2\\"]) [30] grid = Grid(n, m) results = [] for operation in operations: op = operation.split() if op[0] == \\"add\\": x, y, k = int(op[1]), int(op[2]), int(op[3]) grid.add(x, y, k) elif op[0] == \\"query\\": x1, y1, x2, y2 = int(op[1]), int(op[2]), int(op[3]), int(op[4]) results.append(grid.query(x1, y1, x2, y2)) return results","solution":"class Grid: def __init__(self, n, m): self.n = n self.m = m self.grid = [[0] * m for _ in range(n)] def add(self, x, y, k): self.grid[x-1][y-1] += k def query(self, x1, y1, x2, y2): total_sum = 0 for i in range(x1-1, x2): for j in range(y1-1, y2): total_sum += self.grid[i][j] return total_sum def run_operations(n, m, operations): grid = Grid(n, m) results = [] for operation in operations: op = operation.split() if op[0] == \\"add\\": x, y, k = int(op[1]), int(op[2]), int(op[3]) grid.add(x, y, k) elif op[0] == \\"query\\": x1, y1, x2, y2 = int(op[1]), int(op[2]), int(op[3]), int(op[4]) results.append(grid.query(x1, y1, x2, y2)) return results"},{"question":"def median(*args): Calculate the median of the given numerical arguments. :param args: A variable number of numerical arguments. :return: The median value or None if no arguments are provided. Examples: >>> median() None >>> median(3, 1, 2) 2 >>> median(3, 1, 2, 4) 2.5 >>> median(1) 1 # Your code here # Example test cases: print(median(1, 3, 3, 6, 7, 8, 9)) # should return 6 print(median(1, 2, 3, 4, 5, 6, 8, 9)) # should return 4.5 print(median(7, 8, 1, 3, 3, 6, 9)) # should return 6","solution":"def median(*args): Calculate the median of the given numerical arguments. :param args: A variable number of numerical arguments. :return: The median value or None if no arguments are provided. if not args: return None sorted_args = sorted(args) n = len(sorted_args) midpoint = n // 2 if n % 2 == 1: # Odd number of elements return sorted_args[midpoint] else: # Even number of elements return (sorted_args[midpoint - 1] + sorted_args[midpoint]) / 2"},{"question":"import datetime def findDayOfWeek(year: int, month: int, day: int) -> str: This function takes a date specified by integers year, month, and day. It returns the day of the week for the given date. Examples: >>> findDayOfWeek(2023, 10, 29) \\"Sunday\\" >>> findDayOfWeek(2021, 7, 4) \\"Sunday\\" >>> findDayOfWeek(1999, 12, 31) \\"Friday\\" def main(): import sys input = sys.stdin.read lines = input().strip().split('n') for line in lines: year, month, day = map(int, line.split()) if year == 0 and month == 0 and day == 0: break print(findDayOfWeek(year, month, day)) if __name__ == \\"__main__\\": main()","solution":"import datetime def findDayOfWeek(year, month, day): This function takes a date specified by integers year, month, and day. It returns the day of the week for the given date. date = datetime.date(year, month, day) return date.strftime(\\"%A\\") def main(): import sys input = sys.stdin.read lines = input().strip().split('n') for line in lines: year, month, day = map(int, line.split()) if year == 0 and month == 0 and day == 0: break print(findDayOfWeek(year, month, day)) if __name__ == \\"__main__\\": main()"},{"question":"def count_peaks(heights): Returns the number of distinct mountain peaks in the given list of heights. A mountain peak is defined as an element that is strictly greater than its immediate neighbors, and the first and last elements cannot be peaks. >>> count_peaks([2, 4, 3, 6, 5, 2]) == 2 >>> count_peaks([1, 2, 3, 2, 1]) == 1","solution":"def count_peaks(heights): Returns the number of distinct mountain peaks in the given list of heights. A mountain peak is defined as an element that is strictly greater than its immediate neighbors, and the first and last elements cannot be peaks. if len(heights) < 3: return 0 peak_count = 0 for i in range(1, len(heights) - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: peak_count += 1 return peak_count"},{"question":"def min_cost_to_connect_cities(n, m, roads): Find the minimum cost to connect all the cities using n-1 roads. n: int - number of cities m: int - number of potential roads roads: List[Tuple[int, int, int]] - list of tuples where each tuple contains three integers (u, v, w) that represent a road between city u and city v with length w. Returns: int: the minimum total length of the roads required to connect all the cities, or -1 if it is impossible to connect all the cities. Examples: >>> min_cost_to_connect_cities(4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 3, 2), (1, 4, 3)]) 6 >>> min_cost_to_connect_cities(3, 1, [(1, 2, 4)]) -1 import pytest from solution import min_cost_to_connect_cities def test_example1(): assert min_cost_to_connect_cities(4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 3, 2), (1, 4, 3)]) == 6 def test_example2(): assert min_cost_to_connect_cities(3, 1, [(1, 2, 4)]) == -1 def test_single_city(): assert min_cost_to_connect_cities(1, 0, []) == 0 assert min_cost_to_connect_cities(1, 1, [(1, 1, 1)]) == -1 def test_insufficient_roads(): assert min_cost_to_connect_cities(5, 3, [(1, 2, 4), (2, 3, 3), (4, 5, 1)]) == -1 def test_disconnected_graph(): assert min_cost_to_connect_cities(4, 2, [(1, 2, 1), (3, 4, 2)]) == -1 def test_large_input(): n = 1000 m = 999 roads = [(i, i+1, 1) for i in range(1, 1000)] assert min_cost_to_connect_cities(n, m, roads) == 999","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def min_cost_to_connect_cities(n, m, roads): if n == 1: return 0 if m == 0 else -1 if m < n - 1: return -1 # Sort the edges by their weights in ascending order roads.sort(key=lambda x: x[2]) parent = [i for i in range(n)] rank = [0] * n minimum_cost = 0 edges_used = 0 for road in roads: u, v, w = road[0] - 1, road[1] - 1, road[2] if find(parent, u) != find(parent, v): union(parent, rank, u, v) minimum_cost += w edges_used += 1 if edges_used == n - 1: return minimum_cost # If all the cities are not connected, return -1 return -1"},{"question":"def minimized_absolute_difference(n: int, array: List[int]) -> int: Partition the array into two subsets of equal size such that the absolute difference between the sums of the elements in the two subsets is minimized. >>> minimized_absolute_difference(4, [1, 2, 3, 4]) 0 >>> minimized_absolute_difference(6, [10, 20, 30, 40, 50, 60]) 10","solution":"def minimized_absolute_difference(n, array): total_sum = sum(array) target = total_sum // 2 dp = [0] * (target + 1) for num in array: for j in range(target, num - 1, -1): dp[j] = max(dp[j], dp[j - num] + num) subset1_sum = dp[target] subset2_sum = total_sum - subset1_sum return abs(subset2_sum - subset1_sum)"},{"question":"def manage_recordings(commands): Processes a series of commands to manage a list of TV shows to be recorded. Args: commands (list of str): A list of commands to process. Returns: list of str: The results of \\"CHECK\\" commands. Example: >>> manage_recordings([ ... \\"ADD GameOfThrones\\", ... \\"ADD BreakingBad\\", ... \\"CHECK GameOfThrones\\", ... \\"REMOVE GameOfThrones\\", ... \\"CHECK GameOfThrones\\", ... \\"ADD TheCrown\\", ... \\"CHECK TheCrown\\" ...]) ['YES', 'NO', 'YES']","solution":"def manage_recordings(commands): Processes a series of commands to manage a list of TV shows to be recorded. Args: commands (list of str): A list of commands to process. Returns: list of str: The results of \\"CHECK\\" commands. recording_list = set() results = [] for command in commands: action, show_name = command.split(maxsplit=1) if action == \\"ADD\\": recording_list.add(show_name) elif action == \\"REMOVE\\": recording_list.discard(show_name) elif action == \\"CHECK\\": if show_name in recording_list: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def will_alice_win(n: int) -> str: Determines whether Alice will win or lose given the starting number n. Args: n (int): The starting number. Returns: str: \\"Win\\" if Alice can guarantee a victory, otherwise \\"Lose\\". Example Usage: >>> will_alice_win(1) 'Win' >>> will_alice_win(2) 'Lose' pass def check_game_results(test_cases: List[int]) -> List[str]: Takes a list of test cases and returns the results for each test case. Args: test_cases (List[int]): A list of test cases. Returns: List[str]: A list containing \\"Win\\" or \\"Lose\\" for each test case. Example Usage: >>> check_game_results([1, 2, 3, 4]) ['Win', 'Lose', 'Win', 'Lose'] >>> check_game_results([5, 6, 7, 8]) ['Win', 'Lose', 'Win', 'Lose'] pass","solution":"def will_alice_win(n): Determines whether Alice will win or lose given the starting number n. Alice wins if n is odd, otherwise Bob wins (since he will always make it odd for Alice's turn). return \\"Win\\" if n % 2 == 1 else \\"Lose\\" def check_game_results(test_cases): Takes a list of test cases and returns the results for each test case. return [will_alice_win(n) for n in test_cases]"},{"question":"def rearrange_students(heights: List[int]) -> List[int]: Rearrange students such that no two adjacent students have the same height. Example: >>> rearrange_students([5, 5, 5, 6, 6, 6]) [6, 5, 6, 5, 6, 5] >>> rearrange_students([4, 4, 4, 4, 5, 5, 6, 6]) [4, 5, 4, 6, 4, 5, 4, 6]","solution":"def rearrange_students(heights): Rearrange students such that no two adjacent students have the same height. # Create a dictionary to count the frequencies of each height from collections import defaultdict height_count = defaultdict(int) for h in heights: height_count[h] += 1 # Create a max-heap based on the frequency of heights from heapq import heappush, heappop max_heap = [] for height, count in height_count.items(): heappush(max_heap, (-count, height)) result = [] prev_height = None prev_count = 0 while max_heap: count, height = heappop(max_heap) result.append(height) if prev_count < 0: heappush(max_heap, (prev_count, prev_height)) prev_height = height prev_count = count + 1 # decrease frequency count return result"},{"question":"from typing import List def search(nums: List[int], target: int) -> int: Searches for a target value in a rotated sorted array and returns its index. If the target does not exist, it returns -1. Example: >>> search([4,5,6,7,0,1,2], 0) 4 >>> search([4,5,6,7,0,1,2], 3) -1 >>> search([1], 0) -1","solution":"from typing import List def search(nums: List[int], target: int) -> int: Searches for a target value in a rotated sorted array and returns its index. If the target does not exist, it returns -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid # If the left half is sorted if nums[left] <= nums[mid]: if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 # If the right half is sorted else: if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"import re def is_palindrome(s: str) -> bool: Verifies if the given string is a palindrome, ignoring case and non-alphanumeric characters. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"No lemon, no melon!\\") True >>> is_palindrome(\\"Hello, World!\\") False pass","solution":"import re def is_palindrome(s): Verifies if the given string is a palindrome, ignoring case and non-alphanumeric characters. cleaned_str = re.sub(r'[^a-zA-Z0-9]', '', s).lower() return cleaned_str == cleaned_str[::-1]"},{"question":"def three_sum_exists(test_cases): Determines if there exist three integers in the array such that their sum is equal to the given target. Args: test_cases (List[Tuple[int, int, List[int]]]): A list of tuples where each tuple contains: - an integer n: the size of the array, - an integer k: the target sum, - a list of integers representing the elements of the array. Returns: List[str]: A list containing \\"YES\\" or \\"NO\\" for each test case. >>> three_sum_exists([(4, 6, [1, 2, 3, 4])]) [\\"YES\\"] >>> three_sum_exists([(5, 9, [1, 2, 3, 4, 5])]) [\\"YES\\"] >>> three_sum_exists([(7, 0, [-1, 0, 1, 2, -1, -4, 3])]) [\\"YES\\"] >>> three_sum_exists([(4, 20, [1, 2, 3, 4])]) [\\"NO\\"] >>> three_sum_exists([(4, 6, [1, 2, 3, 4]), (5, 9, [1, 2, 3, 4, 5]), (7, 0, [-1, 0, 1, 2, -1, -4, 3]), (4, 20, [1, 2, 3, 4])]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] from typing import List, Tuple def test_three_sum_case_1(): test_cases = [(4, 6, [1, 2, 3, 4])] assert three_sum_exists(test_cases) == [\\"YES\\"] def test_three_sum_case_2(): test_cases = [(5, 9, [1, 2, 3, 4, 5])] assert three_sum_exists(test_cases) == [\\"YES\\"] def test_three_sum_case_3(): test_cases = [(7, 0, [-1, 0, 1, 2, -1, -4, 3])] assert three_sum_exists(test_cases) == [\\"YES\\"] def test_three_sum_case_no_solution(): test_cases = [(4, 20, [1, 2, 3, 4])] assert three_sum_exists(test_cases) == [\\"NO\\"] def test_three_sum_multiple_cases(): test_cases = [ (4, 6, [1, 2, 3, 4]), (5, 9, [1, 2, 3, 4, 5]), (7, 0, [-1, 0, 1, 2, -1, -4, 3]), (4, 20, [1, 2, 3, 4]) ] assert three_sum_exists(test_cases) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def three_sum_exists(test_cases): results = [] for n, k, arr in test_cases: arr.sort() found = False for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == k: found = True break elif current_sum < k: left += 1 else: right -= 1 if found: break results.append(\\"YES\\" if found else \\"NO\\") return results"},{"question":"def find_best_moments(N: int, M: int, K: int, attributes: List[List[int]], users: List[List[int]], moments: List[List[int]]) -> List[int]: Determine the best moment to display for each user based on their preference. Args: N (int): The number of attributes. M (int): The number of possible tags for each attribute. K (int): The number of users. attributes (List[List[int]]): Tags for each attribute. users (List[List[int]]): Preferences of each user. moments (List[List[int]]): Tags of moments for each of the N attributes. Returns: List[int]: The index (1-based) of the best moment for each user. Example: >>> N = 3 >>> M = 4 >>> K = 2 >>> attributes = [[1, 2, 3, 4], [2, 2, 1, 3], [3, 4, 4]] >>> users = [[1, 3, 2], [2, 3, 1]] >>> moments = [[1, 4, 2], [2, 2, 4]] >>> find_best_moments(N, M, K, attributes, users, moments) [3, 1]","solution":"def find_best_moments(N, M, K, attributes, users, moments): best_moments = [] for user in users: best_moment_idx = -1 best_score = -1 for i, moment in enumerate(moments): current_score = 0 for j in range(N): if moment[j] == user[j]: current_score += 1 if current_score > best_score: best_score = current_score best_moment_idx = i elif current_score == best_score and best_moment_idx == -1: best_moment_idx = i best_moments.append(best_moment_idx + 1) # Convert to 1-based index return best_moments # Example usage: N = 3 M = 4 K = 2 attributes = [[1, 2, 3, 4], [2, 2, 1, 3], [3, 4, 4]] users = [[1, 3, 2], [2, 3, 1]] moments = [[1, 4, 2], [2, 2, 4]] print(find_best_moments(N, M, K, attributes, users, moments))"},{"question":"def shorten_message(n: int, m: int, locations: List[Tuple[str, str]], message: List[str]) -> str: Convert a message consisting of location names in their long form into a sequence using the shortest possible abbreviation names. >>> shorten_message(5, 3, [(\\"MOUNTAIN\\", \\"MTN\\"), (\\"FOREST\\", \\"FOR\\"), (\\"RIVER\\", \\"RIV\\")], [\\"MOUNTAIN\\", \\"RIVER\\", \\"RIVER\\", \\"FOREST\\", \\"MOUNTAIN\\"]) \\"MTN RIV RIV FOR MTN\\" >>> shorten_message(2, 2, [(\\"ALPS\\", \\"AL\\"), (\\"HIMALAYAS\\", \\"HIM\\")], [\\"ALPS\\", \\"HIMALAYAS\\"]) \\"AL HIM\\"","solution":"def shorten_message(n, m, locations, message): # Create a dictionary to map long names to their shortest abbreviations location_dict = {} for L, S in locations: location_dict[L] = S if len(S) < len(L) else L # Shorten the message using the dictionary shortened_message = [location_dict[loc] for loc in message] return ' '.join(shortened_message)"},{"question":"import re from collections import Counter def most_frequent_words(k: int, text: str) -> List[str]: Identifies the k most frequently occurring words in the text. If there is a tie, it sorts the words alphabetically. >>> most_frequent_words(3, \\"hello world! hello code. code, hello.\\") -> [\\"hello\\", \\"code\\", \\"world\\"] >>> most_frequent_words(2, \\"a quick brown fox jumps over the lazy dog. the dog was not amused.\\") -> [\\"dog\\", \\"the\\"] # Your code here","solution":"import re from collections import Counter def most_frequent_words(k, text): Identifies the k most frequently occurring words in the text. If there is a tie, it sorts the words alphabetically. # Using regex to find all words words = re.findall(r'w+', text.lower()) # Count the frequency of each word word_counts = Counter(words) # Sorting words first by frequency (highest first), then alphabetically in case of tie sorted_words = sorted(word_counts.items(), key=lambda x: (-x[1], x[0])) # Extract the top k words result = [word for word, count in sorted_words[:k]] return result"},{"question":"def maximize_sum_after_turns(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]: Determine the total sum of the values in the grid after k turns if both players play optimally. Args: t: The number of test cases. test_cases: A list of tuples, where each tuple contains three integers n, m, and k representing the dimensions of the grid and the number of turns respectively. Returns: A list of integers, each representing the maximum possible sum of the values in the grid after k turns for each test case. Examples: >>> maximize_sum_after_turns(1, [(2, 2, 3)]) [3] >>> maximize_sum_after_turns(1, [(3, 3, 9)]) [9] >>> maximize_sum_after_turns(1, [(1, 5, 4)]) [4] # Your code here","solution":"def maximize_sum_after_turns(t, test_cases): results = [] for n, m, k in test_cases: results.append(k) return results"},{"question":"def min_operations_to_sort(N: int, priorities: List[int]) -> int: Determine the minimum number of operations required to sort the post-it notes in increasing order of their priorities. Args: N : int : Number of post-it notes priorities : List[int] : List of priorities of the post-it notes Returns: int : Minimum number of operations required to sort the post-it notes pass # Unit Tests def test_example1(): assert min_operations_to_sort(5, [2, 4, 1, 3, 5]) == 3 def test_example2(): assert min_operations_to_sort(4, [3, 1, 2, 4]) == 2 def test_single_element(): assert min_operations_to_sort(1, [1]) == 0 def test_sorted(): assert min_operations_to_sort(5, [1, 2, 3, 4, 5]) == 0 def test_reverse_sorted(): assert min_operations_to_sort(5, [5, 4, 3, 2, 1]) == 4 def test_random_case(): assert min_operations_to_sort(6, [4, 3, 1, 2, 6, 5]) == 4","solution":"def min_operations_to_sort(N, priorities): # Initialize an array pos where pos[i] stores the position of element (i+1) in current array pos = [0] * N for idx in range(N): pos[priorities[idx] - 1] = idx # Find the length of the longest increasing subsequence in pos length_of_lis = 1 current_length = 1 for i in range(1, N): if pos[i] > pos[i - 1]: current_length += 1 length_of_lis = max(length_of_lis, current_length) else: current_length = 1 # Return the minimum number of operations required return N - length_of_lis"},{"question":"def letter_frequency(s: str) -> Dict[str, int]: Develop a function that takes a string consisting of lowercase letters and returns the frequency of each letter in the string. The function should return the frequencies as a dictionary where keys are the letters and values are their corresponding counts. The frequency dictionary should exclude any letters that do not appear in the string. >>> letter_frequency(\\"test\\") {'t': 2, 'e': 1, 's': 1} >>> letter_frequency(\\"\\") {} >>> letter_frequency(\\"aabbcc\\") {'a': 2, 'b': 2, 'c': 2} >>> letter_frequency(\\"thequickbrownfoxjumpsoverthelazydog\\") { 't': 2, 'h': 2, 'e': 3, 'q': 1, 'u': 2, 'i': 1, 'c': 1, 'k': 1, 'b': 1, 'r': 2, 'o': 4, 'w': 1, 'n': 1, 'f': 1, 'x': 1, 'j': 1, 'm': 1, 'p': 1, 's': 1, 'v': 1, 'l': 1, 'a': 1, 'z': 1, 'y': 1, 'd': 1, 'g': 1 }","solution":"def letter_frequency(s): Returns a dictionary with the frequency of each letter in the input string s. freq = {} for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 return freq"},{"question":"import re def is_palindrome(s: str) -> bool: Returns whether the given string is a palindrome, ignoring spaces, punctuation, and case. >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"12345\\") False pass","solution":"import re def is_palindrome(s): Returns whether the given string is a palindrome, ignoring spaces, punctuation, and case. # Remove all non-alphanumeric characters and convert to lower case cleaned_str = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Compare the cleaned string with its reverse return cleaned_str == cleaned_str[::-1]"},{"question":"def product_of_array(arr): Calculate the product of all elements in the array. If any element is zero, return zero immediately. >>> product_of_array([1, 2, 3, 4]) == 24 >>> product_of_array([1, 2, 0, 4]) == 0 >>> product_of_array([-1, -2, -3]) == -6 >>> product_of_array([-1, 2, -3, 4]) == 24 >>> product_of_array([]) == 1","solution":"def product_of_array(arr): Calculate the product of all elements in the array. If any element is zero, return zero immediately. product = 1 for num in arr: if num == 0: return 0 product *= num return product"},{"question":"def max_subarray_sum(arr): Returns the maximum sum of any non-empty subarray. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5, -6, -7]) -1 >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([3, -1, 4, -1, 2, 1, -5, 4]) 8 >>> max_subarray_sum([-2, -3, -4, -1, -2, -1, -5, -3]) -1","solution":"def max_subarray_sum(arr): Returns the maximum sum of any non-empty subarray. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) max_global = max(max_global, max_current) return max_global"},{"question":"from typing import List from collections import Counter def min_insertions_to_anagram(s1: str, s2: str) -> int: Returns the minimum number of characters to insert into s2 so that it becomes a full anagram of s1. >>> min_insertions_to_anagram(\\"anagram\\", \\"manga\\") 2 >>> min_insertions_to_anagram(\\"abcdefg\\", \\"abcd\\") 3 >>> min_insertions_to_anagram(\\"listen\\", \\"silent\\") 0","solution":"from collections import Counter def min_insertions_to_anagram(s1, s2): Returns the minimum number of characters to insert into s2 so that it becomes a full anagram of s1. count_s1 = Counter(s1) count_s2 = Counter(s2) insertions = 0 for char in count_s1: if count_s1[char] > count_s2.get(char, 0): insertions += count_s1[char] - count_s2.get(char, 0) return insertions"},{"question":"def special_submatrix_exists(t: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[str]: Determine if there exists at least one special submatrix for each test case. >>> special_submatrix_exists(2, [ ... (3, [ ... [2, 3, 1], ... [1, 2, 3], ... [3, 1, 2] ... ]), ... (3, [ ... [1, 2, 3], ... [1, 2, 3], ... [1, 2, 3] ... ]) ... ]) ['YES', 'NO'] pass","solution":"def is_special(matrix, n): def check_unique(nums): return sorted(nums) == list(range(1, n + 1)) for r1 in range(n): for r2 in range(r1, n): submatrix_rows = matrix[r1:r2 + 1] for c1 in range(n): for c2 in range(c1, n): submatrix = [row[c1:c2 + 1] for row in submatrix_rows] if len(submatrix) != len(submatrix[0]): continue if (all(check_unique(row) for row in submatrix) and all(check_unique([submatrix[i][j] for i in range(len(submatrix))]) for j in range(len(submatrix[0])))): return True return False def special_submatrix_exists(t, test_cases): results = [] for case in test_cases: n, matrix = case if is_special(matrix, n): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def count_ways_to_color_tiles(n: int, k: int) -> int: Calculates the number of ways to color the row of n tiles with k distinct colors so that no two adjacent tiles have the same color. >>> count_ways_to_color_tiles(3, 3) 12 >>> count_ways_to_color_tiles(4, 2) 2 >>> count_ways_to_color_tiles(1, 5) 5 >>> count_ways_to_color_tiles(2, 4) 12 >>> count_ways_to_color_tiles(5, 3) 48 >>> count_ways_to_color_tiles(1000, 1000) ...","solution":"def count_ways_to_color_tiles(n, k): Calculates the number of ways to color the row of n tiles with k distinct colors so that no two adjacent tiles have the same color. MOD = 10**9 + 7 if n == 1: return k elif n == 2: return k * (k - 1) % MOD dp = [0] * (n + 1) dp[1] = k dp[2] = k * (k - 1) % MOD for i in range(3, n + 1): dp[i] = (dp[i - 1] * (k - 1)) % MOD return dp[n]"},{"question":"def minTravelTime(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Find the minimum travel time required for a tourist to complete a TSP journey. Args: n: Number of intersections. m: Number of roads. edges: List of tuples, each containing two intersections and a travel time. Returns: The minimum travel time required to visit all vertices exactly once and return to the starting point. Examples: >>> minTravelTime(4, 6, [(1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30)]) 80 >>> minTravelTime(3, 3, [(1, 2, 5), (2, 3, 10), (3, 1, 4)]) 19","solution":"def minTravelTime(n, m, edges): import itertools # Create an adjacency matrix with high initial values (inf for practicality) inf = float('inf') graph = [[inf]*n for _ in range(n)] # Fill the adjacency matrix with edge values for u, v, w in edges: graph[u-1][v-1] = w graph[v-1][u-1] = w # Initialize dp array with inf values, dimensions [2^n][n] dp = [[inf] * n for _ in range(1 << n)] # Starting point: visiting first node dp[1][0] = 0 # Iterate over every subset of vertices for mask in range(1 << n): for u in range(n): if mask & (1 << u): for v in range(n): if mask & (1 << v) == 0: next_mask = mask | (1 << v) dp[next_mask][v] = min(dp[next_mask][v], dp[mask][u] + graph[u][v]) # The answer will be the minimum value of returning to the starting node after visiting all nodes min_time = inf for u in range(1, n): min_time = min(min_time, dp[(1 << n) - 1][u] + graph[u][0]) return min_time"},{"question":"class DeliveryZones: def __init__(self, weights): self.weights = weights def update(self, i, x): Update the weight of a specific delivery zone to a new value. Args: i (int): The index of the delivery zone. x (int): The new weight of the delivery zone. pass def query_sum(self, l, r): Query the total weight of all delivery zones within a given range. Args: l (int): The starting index of the range. r (int): The ending index of the range. Returns: int: The total weight of the delivery zones within the range. pass def query_max(self, l, r): Query the maximum weight among all delivery zones within a given range. Args: l (int): The starting index of the range. r (int): The ending index of the range. Returns: int: The maximum weight of the delivery zones within the range. pass def handle_queries(n, m, weights, queries): Handle a series of queries on delivery zones. Args: n (int): The number of delivery zones. m (int): The number of queries. weights (List[int]): The initial weights of the delivery zones. queries (List[List[int]]): The list of queries. Returns: List[int]: The results of the queries of type 2 and 3. >>> n = 6 >>> m = 5 >>> weights = [10, 20, 15, 30, 25, 5] >>> queries = [ ... [2, 1, 3], ... [3, 2, 5], ... [1, 4, 35], ... [2, 1, 6], ... [3, 3, 6] ... ] >>> handle_queries(n, m, weights, queries) [45, 30, 140, 35] >>> n = 4 >>> m = 4 >>> weights = [5, 15, 10, 20] >>> queries = [ ... [2, 2, 3], ... [3, 1, 4], ... [1, 3, 25], ... [2, 1, 4] ... ] >>> handle_queries(n, m, weights, queries) [25, 20, 65]","solution":"class DeliveryZones: def __init__(self, weights): self.weights = weights def update(self, i, x): self.weights[i-1] = x def query_sum(self, l, r): return sum(self.weights[l-1:r]) def query_max(self, l, r): return max(self.weights[l-1:r]) def handle_queries(n, m, weights, queries): delivery_zones = DeliveryZones(weights) results = [] for query in queries: t = query[0] if t == 1: i, x = query[1], query[2] delivery_zones.update(i, x) elif t == 2: l, r = query[1], query[2] results.append(delivery_zones.query_sum(l, r)) elif t == 3: l, r = query[1], query[2] results.append(delivery_zones.query_max(l, r)) return results"},{"question":"from typing import List from collections import Counter def topKFrequent(arr: List[int], k: int) -> List[int]: Returns the k most frequent elements in the array. If there is a tie in frequency, the larger element should come first. >>> topKFrequent([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> topKFrequent([4, 4, 4, 4, 5, 5, 5, 2, 2, 3], 3) [4, 5, 2] >>> topKFrequent([1, 2, 3, 4, 5], 1) [5] Returns: List[int]: List of k most frequent elements pass from solution import topKFrequent def test_topKFrequent(): # Test cases from the prompt assert topKFrequent([1, 1, 1, 2, 2, 3], 2) == [1, 2] assert topKFrequent([4, 4, 4, 4, 5, 5, 5, 2, 2, 3], 3) == [4, 5, 2] assert topKFrequent([1, 2, 3, 4, 5], 1) == [5] # Additional test cases assert topKFrequent([1, 1, 2, 2, 3, 3, 4, 4, 5, 5], 2) == [5, 4] assert topKFrequent([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 2) == [4, 3] assert topKFrequent([1, 1, 1, 1, 2, 2, 2, 3], 1) == [1] assert topKFrequent([], 1) == [] # Edge cases assert topKFrequent([1], 1) == [1] assert topKFrequent([1, 2, 3], 2) == [3, 2] assert topKFrequent([3, 3, 2, 2, 1, 1], 1) == [3]","solution":"from collections import Counter def topKFrequent(arr, k): Returns the k most frequent elements in the array. If there is a tie in frequency, the larger element should come first. if not arr: return [] # Count the frequency of each element frequency = Counter(arr) # Create a list of elements sorted by frequency and then by value sorted_elements = sorted(frequency.keys(), key=lambda x: (-frequency[x], -x)) # Return the top k elements return sorted_elements[:k]"},{"question":"from typing import List, Tuple def is_strongly_connected(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine if the network is a strongly connected component. >>> is_strongly_connected(3, 3, [(1, 2), (2, 3), (3, 1)]) 'Strongly Connected' >>> is_strongly_connected(4, 3, [(1, 2), (2, 3), (4, 1)]) 'Not Strongly Connected' >>> is_strongly_connected(1, 0, []) 'Strongly Connected' >>> is_strongly_connected(2, 1, [(1, 2)]) 'Not Strongly Connected' >>> is_strongly_connected(2, 2, [(1, 2), (2, 1)]) 'Strongly Connected' >>> is_strongly_connected(100000, 100000, [(i, i + 1) for i in range(1, 100000)] + [(100000, 1)]) 'Strongly Connected' >>> is_strongly_connected(100000, 99999, [(i, i + 1) for i in range(1, 100000)]) 'Not Strongly Connected'","solution":"def is_strongly_connected(n, m, edges): from collections import defaultdict, deque def bfs(start, graph): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) queue.extend(graph[node]) return visited if n == 0: return \\"Not Strongly Connected\\" # Adjacency list for the original graph and the reversed graph graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) # Check reachability from first node all_nodes = set(range(1, n + 1)) visited_from_first = bfs(1, graph) if visited_from_first != all_nodes: return \\"Not Strongly Connected\\" # Check reachability from first node in the reversed graph reverse_visited_from_first = bfs(1, reverse_graph) if reverse_visited_from_first != all_nodes: return \\"Not Strongly Connected\\" return \\"Strongly Connected\\""},{"question":"def can_interconnect_all_locations(M: int, k: int) -> str: Determine if all drop-off locations can be interconnected with the given constraints. Args: M (int): The number of drop-off locations. k (int): The maximum number of sequential locations a truck can travel directly from any drop-off location. Returns: str: \\"Yes\\" if all locations can be interconnected, \\"No\\" otherwise. >>> can_interconnect_all_locations(4, 1) 'No' >>> can_interconnect_all_locations(5, 2) 'Yes' >>> can_interconnect_all_locations(6, 3) 'Yes' def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[str]: Process multiple test cases to determine if all drop-off locations can be interconnected. Args: test_cases (list of tuple of int): A list containing tuples of M and k values for each test case. Returns: list of str: List of results (\\"Yes\\" or \\"No\\") for each test case. >>> process_test_cases([(4, 1), (5, 2), (6, 3)]) ['No', 'Yes', 'Yes']","solution":"def can_interconnect_all_locations(M, k): Determine if all drop-off locations can be interconnected with the given constraints. Args: M (int): The number of drop-off locations. k (int): The maximum number of sequential locations a truck can travel directly from any drop-off location. Returns: str: \\"Yes\\" if all locations can be interconnected, \\"No\\" otherwise. if k >= M - 1: return \\"Yes\\" if k == 1 and M > 2: return \\"No\\" if M % k == 0 or (M % k) <= k: return \\"Yes\\" return \\"No\\" def process_test_cases(test_cases): results = [] for M, k in test_cases: result = can_interconnect_all_locations(M, k) results.append(result) return results"},{"question":"def rotateRight(arr, k): Rotates the array to the right by k steps. Parameters: arr (list of int): The array to rotate. k (int): The number of steps to rotate the array. Returns: None: The function modifies the array in-place. pass def test_rotateRight_case1(): arr = [1, 2, 3, 4, 5, 6, 7] rotateRight(arr, 3) assert arr == [5, 6, 7, 1, 2, 3, 4] def test_rotateRight_case2(): arr = [-1, -100, 3, 99] rotateRight(arr, 2) assert arr == [3, 99, -1, -100] def test_rotateRight_with_zero_rotation(): arr = [1, 2, 3, 4, 5] rotateRight(arr, 0) assert arr == [1, 2, 3, 4, 5] def test_rotateRight_with_large_k(): arr = [1, 2, 3, 4, 5, 6] rotateRight(arr, 8) assert arr == [5, 6, 1, 2, 3, 4] def test_rotateRight_single_element(): arr = [1] rotateRight(arr, 5) assert arr == [1] def test_rotateRight_two_elements(): arr = [1, 2] rotateRight(arr, 1) assert arr == [2, 1]","solution":"def rotateRight(arr, k): Rotates the array to the right by k steps. Parameters: arr (list of int): The array to rotate. k (int): The number of steps to rotate the array. Returns: None: The function modifies the array in-place. n = len(arr) k = k % n # Reverse the entire array arr.reverse() # Reverse the first k elements arr[:k] = reversed(arr[:k]) # Reverse the rest of the elements arr[k:] = reversed(arr[k:])"},{"question":"def min_street_lights(n: int, k: int, positions: List[int]) -> int: Determine the minimum number of street lights required to illuminate all houses. :param n: int, number of houses :param k: int, maximum number of houses that can share one street light :param positions: list of int, positions of the houses on a number line :return: int, minimum number of street lights required >>> min_street_lights(10, 2, [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]) 5 >>> min_street_lights(4, 3, [7, 14, 21, 28]) 2 >>> min_street_lights(6, 1, [2, 4, 6, 8, 10, 12]) 6","solution":"def min_street_lights(n, k, positions): Determine the minimum number of street lights required. :param n: int, number of houses :param k: int, maximum number of houses that can share one street light :param positions: list of int, positions of the houses on a number line :return: int, minimum number of street lights required if k == 1: return n positions.sort() num_lights = 0 i = 0 while i < n: num_lights += 1 # a street light at positions[i + k - 1] can illuminate up to k houses, or as many as available till end next_position = positions[min(i + k - 1, n - 1)] # move to the first house beyond the range of this street light i += k return num_lights"},{"question":"def is_prime(num): Returns True if num is a prime number, False otherwise. def organize_books(n, books): Organize books by placing prime ISBNs first, followed by non-prime ISBNs while maintaining the original order within each group. >>> organize_books(5, [3, 1, 4, 2, 5]) [3, 2, 5, 1, 4] >>> organize_books(6, [6, 3, 4, 7, 1, 5]) [3, 7, 5, 6, 4, 1] from solution import organize_books def test_organize_books_example_1(): assert organize_books(5, [3, 1, 4, 2, 5]) == [3, 2, 5, 1, 4] def test_organize_books_example_2(): assert organize_books(6, [6, 3, 4, 7, 1, 5]) == [3, 7, 5, 6, 4, 1] def test_organize_books_single_prime(): assert organize_books(1, [2]) == [2] def test_organize_books_single_non_prime(): assert organize_books(1, [1]) == [1] def test_organize_books_mix(): assert organize_books(10, [2, 3, 5, 7, 4, 6, 8, 9, 10, 1]) == [2, 3, 5, 7, 4, 6, 8, 9, 10, 1] def test_organize_books_all_non_prime(): assert organize_books(4, [4, 6, 8, 9]) == [4, 6, 8, 9] def test_organize_books_all_prime(): assert organize_books(4, [2, 3, 5, 7]) == [2, 3, 5, 7]","solution":"def is_prime(num): Returns True if num is a prime number, False otherwise. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5)+1, 2): if num % i == 0: return False return True def organize_books(n, books): Returns the list of books organized with prime ISBNs first, followed by non-prime ISBNs. prime_books = [book for book in books if is_prime(book)] non_prime_books = [book for book in books if not is_prime(book)] return prime_books + non_prime_books"},{"question":"def max_sum_contiguous_subarray_of_size_k(n: int, k: int, arr: List[int]) -> int: Return the maximum sum of any contiguous subarray of size exactly k. >>> max_sum_contiguous_subarray_of_size_k(7, 3, [1, 2, 3, 4, 5, 6, 7]) 18 >>> max_sum_contiguous_subarray_of_size_k(5, 2, [-1, -2, -3, -4, -5]) -3 pass","solution":"def max_sum_contiguous_subarray_of_size_k(n, k, arr): Return the maximum sum of any contiguous subarray of size exactly k. if k > n or n <= 0 or k <= 0: return 0 # Calculate the sum of the first subarray of size k max_sum = sum(arr[:k]) current_sum = max_sum # Use sliding window technique to calculate the sum of other subarrays of size k for i in range(k, n): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def longest_consecutive_subarray(arr: List[int]) -> int: Return the length of the longest subarray with consecutive integers in a given array. >>> longest_consecutive_subarray([1, 94, 93, 1000, 92, 91, 90]) 5 >>> longest_consecutive_subarray([1, 9, 3, 10, 4, 20, 2]) 4 >>> longest_consecutive_subarray([10, 12, 11, 13, 14, 15]) 6 pass","solution":"from typing import List def longest_consecutive_subarray(arr: List[int]) -> int: if not arr: return 0 max_length = 0 num_set = set(arr) for num in arr: if num - 1 not in num_set: # Check if it's the start of a sequence current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List, Tuple def total_effectiveness(order: Tuple[int], matrix: List[List[int]]) -> int: Calculate the total effectiveness of a given order of scientists. total = 0 for i in range(len(order)): for j in range(len(order)): total += matrix[order[i]][order[j]] return total def optimal_order(matrix: List[List[int]]) -> Tuple[int]: Find the optimal order for scientists that maximizes the total effectiveness of collaboration. from itertools import permutations M = len(matrix) all_orders = permutations(range(M)) max_effectiveness = -1 best_order = None for order in all_orders: effectiveness = total_effectiveness(order, matrix) if effectiveness > max_effectiveness: max_effectiveness = effectiveness best_order = order elif effectiveness == max_effectiveness: if best_order is None or order < best_order: best_order = order return best_order def solve(T: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[str]: Determine the optimal order of scientists to maximize the total effectiveness of collaboration for multiple test cases. results = [] for i in range(T): M, matrix = test_cases[i] order = optimal_order(matrix) results.append(\\" \\".join(map(str, order))) return results # Example usage: # T = 2 # test_cases = [ # (3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]), # (4, [[10, 20, 30, 40], [15, 25, 35, 45], [20, 30, 40, 50], [25, 35, 45, 55]]) # ] # print(solve(T, test_cases)) # Outputs: ['0 1 2', '0 1 2 3']","solution":"from itertools import permutations def total_effectiveness(order, matrix): total = 0 for i in range(len(order)): for j in range(len(order)): total += matrix[order[i]][order[j]] return total def optimal_order(matrix): M = len(matrix) all_orders = permutations(range(M)) max_effectiveness = -1 best_order = None for order in all_orders: effectiveness = total_effectiveness(order, matrix) if effectiveness > max_effectiveness: max_effectiveness = effectiveness best_order = order elif effectiveness == max_effectiveness: if best_order is None or order < best_order: best_order = order return best_order def solve(T, test_cases): results = [] for i in range(T): M, matrix = test_cases[i] order = optimal_order(matrix) results.append(\\" \\".join(map(str, order))) return results # Example usage: # T = 2 # test_cases = [ # (3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]), # (4, [[10, 20, 30, 40], [15, 25, 35, 45], [20, 30, 40, 50], [25, 35, 45, 55]]) # ] # print(solve(T, test_cases)) # Outputs: ['0 1 2', '0 1 2 3']"},{"question":"def int_to_roman(N: int) -> str: Convert a decimal number to its Roman numeral representation. >>> int_to_roman(3) \\"III\\" >>> int_to_roman(58) \\"LVIII\\" >>> int_to_roman(1994) \\"MCMXCIV\\" >>> int_to_roman(2023) \\"MMXXIII\\"","solution":"def int_to_roman(N): Convert a decimal number to its Roman numeral representation. Parameters: N (int): Decimal number ranging from 1 to 3999 inclusive. Returns: str: Roman numeral representation of the number. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' i = 0 while N > 0: for _ in range(N // val[i]): roman_num += syms[i] N -= val[i] i += 1 return roman_num"},{"question":"def longest_subarray_with_limit(nums, k): Find the length of the longest contiguous subarray such that the difference between the maximum and minimum element in the subarray is less than or equal to a given value 'K'. >>> longest_subarray_with_limit([1, 3, 6, 7, 8], 5) 4 >>> longest_subarray_with_limit([1, 2, 1, 2, 1], 2) 5 def solve_cases(test_cases): Solve multiple test cases of the longest subarray problem. >>> solve_cases([(5, [1, 3, 6, 7, 8]), (2, [1, 2, 1, 2, 1])]) [4, 5]","solution":"def longest_subarray_with_limit(nums, k): from collections import deque max_d = deque() min_d = deque() left = 0 result = 0 for right in range(len(nums)): while max_d and nums[max_d[-1]] <= nums[right]: max_d.pop() while min_d and nums[min_d[-1]] >= nums[right]: min_d.pop() max_d.append(right) min_d.append(right) while nums[max_d[0]] - nums[min_d[0]] > k: left += 1 if max_d[0] < left: max_d.popleft() if min_d[0] < left: min_d.popleft() result = max(result, right - left + 1) return result def solve_cases(test_cases): results = [] for k, sequence in test_cases: results.append(longest_subarray_with_limit(sequence, k)) return results"},{"question":"def get_max_fertility_plot(n: int, m: int, field: List[List[int]]) -> Tuple[int, Tuple[int, int], Tuple[int, int]]: A farmer has a large rectangular field that he wants to subdivide into smaller rectangular plots to maximize efficiency in planting and harvesting crops. The field is divided into a grid of cells, each with a fertility value represented by a positive integer. A plot can start at any cell and extend to any other cell in the rectangular field. The fertility value of a plot is the sum of the fertility values of all the cells within that plot. The farmer wants to find the plot with the maximum fertility value and also to know the boundaries of that plot. To help the farmer, write a program that takes the fertility values of the field as input and outputs the maximum fertility value of any plot and the boundaries of such a plot in terms of its top-left and bottom-right cell coordinates. If there are multiple plots with the same maximum fertility value, return any one of them. Args: n (int): Number of rows in the field. m (int): Number of columns in the field. field (List[List[int]]): Fertility values of the field. Returns: Tuple[int, Tuple[int, int], Tuple[int, int]]: The maximum fertility value, coordinates of the top-left cell, and coordinates of the bottom-right cell. Example: >>> get_max_fertility_plot(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) (45, (1, 1), (3, 3))","solution":"def get_max_fertility_plot(n, m, field): def precompute_prefix_sums(): prefix_sums = [[0]*(m+1) for _ in range(n+1)] for i in range(1, n+1): for j in range(1, m+1): prefix_sums[i][j] = field[i-1][j-1] + prefix_sums[i-1][j] + prefix_sums[i][j-1] - prefix_sums[i-1][j-1] return prefix_sums prefix_sums = precompute_prefix_sums() max_fertility = float('-inf') top_left = bottom_right = (0, 0, 0, 0) for i1 in range(1, n+1): for j1 in range(1, m+1): for i2 in range(i1, n+1): for j2 in range(j1, m+1): fertility_sum = ( prefix_sums[i2][j2] - prefix_sums[i1-1][j2] - prefix_sums[i2][j1-1] + prefix_sums[i1-1][j1-1] ) if fertility_sum > max_fertility: max_fertility = fertility_sum top_left = (i1, j1) bottom_right = (i2, j2) return max_fertility, top_left, bottom_right"},{"question":"def max_special_subsequence_sum(n: int, sequence: List[int]) -> int: Returns the maximum possible sum of a special subsequence that is strictly increasing. >>> max_special_subsequence_sum(5, [1, 101, 2, 3, 100]) 106 >>> max_special_subsequence_sum(5, [3, 4, 5, 10, 15]) 37 >>> max_special_subsequence_sum(5, [10, 5, 4, 3, 2]) 10 >>> max_special_subsequence_sum(6, [1, 2, 4, 3, 5, 4]) 12 >>> max_special_subsequence_sum(1, [10]) 10 >>> max_special_subsequence_sum(5, [-1, -2, -3, -4, -5]) -1 >>> max_special_subsequence_sum(7, [-1, 2, 3, -4, 5, -6, 7]) 17 >>> max_special_subsequence_sum(4, [4, 4, 4, 4]) 4 >>> max_special_subsequence_sum(0, []) 0","solution":"def max_special_subsequence_sum(n, sequence): Returns the maximum possible sum of a special subsequence that is strictly increasing. if n == 0: return 0 # Initialize the dp array where dp[i] stores the maximum sum of a # strictly increasing subsequence ending with the element at index i. dp = sequence[:] # Use dynamic programming to find the maximum sum for i in range(1, n): for j in range(i): if sequence[i] > sequence[j] and dp[i] < dp[j] + sequence[i]: dp[i] = dp[j] + sequence[i] # The result is the maximum value in the dp array return max(dp) # Example usage: # sequence = [1, 101, 2, 3, 100] # n = len(sequence) # print(max_special_subsequence_sum(n, sequence)) # Output should be 106"},{"question":"def maximum_score_path(n: int, m: int, grid: List[List[int]]) -> int: Returns the maximum score sum obtainable by moving from any cell in the first row to any cell in the last row in the given grid, following the movement rules. Args: n: The number of rows in the grid. m: The number of columns in the grid. grid: 2D list representing the grid with each cell containing a score. Returns: An integer representing the maximum score sum that can be obtained. Example Usage: >>> maximum_score_path(3, 3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) 18 >>> maximum_score_path(4, 4, [ [1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4] ]) 10 pass from typing import List # Unit Tests def test_example_1(): n, m = 3, 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert maximum_score_path(n, m, grid) == 18 def test_example_2(): n, m = 4, 4 grid = [ [1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4] ] assert maximum_score_path(n, m, grid) == 10 def test_single_cell_grid(): n, m = 1, 1 grid = [[5]] assert maximum_score_path(n, m, grid) == 5 def test_large_values(): n, m = 2, 2 grid = [ [100, 100], [100, 100] ] assert maximum_score_path(n, m, grid) == 200 def test_irregular_grid(): n, m = 3, 4 grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] assert maximum_score_path(n, m, grid) == 24 def test_minimum_values(): n, m = 1, 1 grid = [[0]] assert maximum_score_path(n, m, grid) == 0","solution":"def maximum_score_path(n, m, grid): Returns the maximum score sum obtainable by moving from any cell in the first row to any cell in the last row in the given grid, following the movement rules. dp = [[0] * m for _ in range(n)] # Copy the first row from the grid to the dp table for j in range(m): dp[0][j] = grid[0][j] # Fill the dp table for i in range(1, n): for j in range(m): max_upper_path = 0 if j > 0: max_upper_path = max(max_upper_path, dp[i-1][j-1]) max_upper_path = max(max_upper_path, dp[i-1][j]) if j < m - 1: max_upper_path = max(max_upper_path, dp[i-1][j+1]) dp[i][j] = grid[i][j] + max_upper_path # Find the maximum value in the last row return max(dp[-1]) # Example usage if __name__ == \\"__main__\\": n, m = 3, 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(maximum_score_path(n, m, grid)) # Output: 18"},{"question":"def decode_message(encoded_message: str) -> str: Decode the encoded message by determining the correct shift value for each word. The correct shift value will make each word a valid English word, and the resulting decoded message should be properly formatted. >>> decode_message(\\"ymj vznhp gwtbs ktc ozrux tajw ymj qfed itl\\") == \\"the quick brown fox jumps over the lazy dog\\" >>> decode_message(\\"khoor zruog\\") == \\"hello world\\" >>> decode_message(\\"Khoor Zruog\\") == \\"Hello World\\" >>> decode_message(\\"the quick brown fox\\") == \\"the quick brown fox\\" >>> decode_message(\\"abc xyz\\") == \\"abc xyz\\"","solution":"from collections import Counter # Assuming a pre-defined set of valid English words ENGLISH_WORDS = set([ 'the', 'quick', 'brown', 'fox', 'jumps', 'over', 'lazy', 'dog', 'hello', 'world', 'this', 'is', 'an', 'example' # A comprehensive list would include all English words ]) def shift_char(c, shift): Shift a character by given shift if c.isalpha(): base = 'a' if c.islower() else 'A' return chr((ord(c) - ord(base) - shift) % 26 + ord(base)) return c def is_valid_word(word): return word.lower() in ENGLISH_WORDS def decode_word(word): for shift in range(26): decoded_word = ''.join(shift_char(c, shift) for c in word) if is_valid_word(decoded_word): return decoded_word return word # In case no valid word is found (fallback to original) def decode_message(encoded_message): words = encoded_message.split() decoded_words = [decode_word(word) for word in words] return ' '.join(decoded_words)"},{"question":"def compress_message(s: str) -> str: Compress the input string using Run-length encoding (RLE). Parameters: s (str): The input string consisting of uppercase letters (A-Z). Returns: str: The RLE compressed version of the input string. >>> compress_message(\\"AAABCCDDDD\\") \\"A3B1C2D4\\" >>> compress_message(\\"A\\") \\"A1\\" >>> compress_message(\\"AAAAA\\") \\"A5\\" >>> compress_message(\\"ABCDE\\") \\"A1B1C1D1E1\\" >>> compress_message(\\"AABBCCC\\") \\"A2B2C3\\" >>> compress_message(\\"\\") \\"\\"","solution":"def compress_message(s: str) -> str: Compresses the input string using Run-length encoding (RLE). Parameters: s (str): The input string consisting of uppercase letters (A-Z). Returns: str: The RLE compressed version of the input string. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) return ''.join(compressed)"},{"question":"def isPowerOfAnotherInteger(N: str) -> bool: Determines if the number N can be written as B^k for some integer B > 1 and integer k ≥ 2. Args: N (str): The input number in string format. Returns: bool: True if the number is a power of another integer, False otherwise. Examples: >>> isPowerOfAnotherInteger(\\"16\\") True >>> isPowerOfAnotherInteger(\\"27\\") True >>> isPowerOfAnotherInteger(\\"10\\") False","solution":"def isPowerOfAnotherInteger(N: str) -> bool: num = int(N) if num < 2: return False # Check if num can be expressed as b^k where b > 1 and k >= 2 # We will try to find the base (b) and exponent (k) for base in range(2, int(num**0.5) + 1): result = base while result <= num: result *= base if result == num: return True return False"},{"question":"def filter_unique_words_and_count_duplicates(words): Takes a list of words and returns a list of unique words maintaining the first occurrence order and a list of integers representing the count of duplicates removed for each original word. >>> filter_unique_words_and_count_duplicates([\\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"grape\\"]) ([\\"apple\\", \\"orange\\", \\"banana\\", \\"grape\\"], [0, 0, 0, 1, 1, 0]) >>> filter_unique_words_and_count_duplicates([\\"apple\\", \\"apple\\", \\"apple\\"]) ([\\"apple\\"], [0, 1, 2]) >>> filter_unique_words_and_count_duplicates([\\"apple\\", \\"orange\\", \\"banana\\"]) ([\\"apple\\", \\"orange\\", \\"banana\\"], [0, 0, 0]) >>> filter_unique_words_and_count_duplicates([\\"apple\\"]) ([\\"apple\\"], [0]) >>> filter_unique_words_and_count_duplicates([]) ([], [])","solution":"def filter_unique_words_and_count_duplicates(words): Takes a list of words and returns a list of unique words maintaining the first occurrence order and a list of integers representing the count of duplicates removed for each original word. seen = {} unique_words = [] duplicates_count = [] for word in words: if word not in seen: seen[word] = 0 unique_words.append(word) duplicates_count.append(seen[word]) seen[word] += 1 return unique_words, duplicates_count"},{"question":"def min_servers_required(n: int, m: int, capacities: List[int], files: List[int]) -> int: Determine the minimum number of servers required to store all the data files. Args: n (int): Number of servers. m (int): Number of data files. capacities (List[int]): List of server capacities. files (List[int]): List of data file sizes. Returns: int: Minimum number of servers required or -1 if it's not possible to store all files. Examples: >>> min_servers_required(3, 4, [8, 4, 3], [5, 2, 2, 1]) 2 >>> min_servers_required(2, 3, [5, 5], [6, 1, 3]) -1","solution":"def min_servers_required(n, m, capacities, files): # Step 1: Sort the server capacities and files in descending order capacities.sort(reverse=True) files.sort(reverse=True) # Step 2: Use a greedy approach to allocate files to servers servers_used = 0 for file in files: placed = False for i in range(n): if capacities[i] >= file: capacities[i] -= file placed = True break if not placed: return -1 # If we can't place the file in any server servers_used = max(servers_used, i + 1) return servers_used"},{"question":"def first_repeating_character(s: str) -> str: Returns the first repeating character in the string s, or \\"No Repeating Character\\" if no character repeats. >>> first_repeating_character(\\"abca\\") 'a' >>> first_repeating_character(\\"abcdefg\\") \\"No Repeating Character\\"","solution":"def first_repeating_character(s): Returns the first repeating character in the string s, or \\"No Repeating Character\\" if no character repeats. seen = set() for char in s: if char in seen: return char seen.add(char) return \\"No Repeating Character\\""},{"question":"def sort_animals(animal_list): Sort the given list of animals based on the provided rules: 1. Age (Descending) 2. Weight (Ascending) 3. Height (Ascending) Args: animal_list (List[Tuple[str, int, float, float]]): A list of tuples where each tuple represents an animal with its name, age, weight, and height. Returns: List[Tuple[str, int, float, float]]: The sorted list of animals. Examples: >>> sort_animals([(\\"elephant\\", 10, 5000.0, 3.0), (\\"giraffe\\", 5, 800.0, 5.0), (\\"monkey\\", 5, 35.0, 1.0)]) [('elephant', 10, 5000.0, 3.0), ('monkey', 5, 35.0, 1.0), ('giraffe', 5, 800.0, 5.0)] >>> sort_animals([(\\"a\\", 1, 100.0, 1.0), (\\"b\\", 100, 50.0, 1.0), (\\"c\\", 50, 75.0, 2.0), (\\"d\\", 50, 75.0, 1.0)]) [('b', 100, 50.0, 1.0), ('d', 50, 75.0, 1.0), ('c', 50, 75.0, 2.0), ('a', 1, 100.0, 1.0)]","solution":"def sort_animals(animal_list): Sort the given list of animals based on the provided rules: 1. Age (Descending) 2. Weight (Ascending) 3. Height (Ascending) return sorted(animal_list, key=lambda x: (-x[1], x[2], x[3]))"},{"question":"def can_be_palindrome(s: str) -> str: Determines if the given string can be transformed into a valid palindrome by replacing each '?' with appropriate characters. >>> can_be_palindrome(\\"a?c?c?a\\") \\"YES\\" >>> can_be_palindrome(\\"a??b\\") \\"NO\\"","solution":"def can_be_palindrome(s): Determines if the given string can be transformed into a valid palindrome by replacing each '?' with appropriate characters. n = len(s) for i in range(n // 2): if s[i] == '?' or s[n - i - 1] == '?': continue if s[i] != s[n - i - 1]: return \\"NO\\" return \\"YES\\""},{"question":"def max_total_value(n: int, k: int, types: List[int], values: List[int]) -> int: Function to calculate the maximum total value by selecting at most one item of each type. Parameters: n (int): The number of items. k (int): The number of types. types (list of int): The types of the items. values (list of int): The values of the items. Returns: int: The maximum total value. >>> max_total_value(5, 3, [1, 2, 2, 3, 3], [4, 5, 6, 3, 7]) == 17 >>> max_total_value(4, 2, [1, 1, 2, 2], [1, 2, 3, 4]) == 6","solution":"def max_total_value(n, k, types, values): Function to calculate the maximum total value by selecting at most one item of each type. Parameters: n (int): The number of items. k (int): The number of types. types (list of int): The types of the items. values (list of int): The values of the items. Returns: int: The maximum total value. type_to_value = {} for t, v in zip(types, values): if t not in type_to_value or v > type_to_value[t]: type_to_value[t] = v return sum(type_to_value.values()) # Example usage: # n = 5 # k = 3 # types = [1, 2, 2, 3, 3] # values = [4, 5, 6, 3, 7] # print(max_total_value(n, k, types, values)) # Output: 17"},{"question":"def solve(s: str) -> str: Removes the minimum number of characters from s so that no two adjacent characters are the same and returns the altered string. >>> solve(\\"abcde\\") \\"abcde\\" >>> solve(\\"aaaa\\") \\"a\\" >>> solve(\\"abababab\\") \\"abababab\\" >>> solve(\\"aabbcc\\") \\"abc\\" >>> solve(\\"aaabbccdde\\") \\"abcde\\" >>> solve(\\"\\") \\"\\" >>> solve(\\"a\\") \\"a\\" >>> solve(\\"aabb\\") \\"ab\\"","solution":"def solve(s): Removes the minimum number of characters from s so that no two adjacent characters are the same and returns the altered string. if not s: return s result = [s[0]] # Start with the first character for i in range(1, len(s)): if s[i] != s[i - 1]: # Only add the character if it is not the same as the previous one result.append(s[i]) return ''.join(result)"},{"question":"def find_most_popular_user(N, M, connections): Determine the user with the highest popularity. N: int - number of users M: int - number of connections connections: List[Tuple[int, int]] - list of bidirectional connections Returns: int - ID of the most popular user. If multiple users have the same highest popularity, return the smallest user ID. >>> find_most_popular_user(5, 4, [(1, 2), (2, 3), (4, 5), (1, 5)]) 1 >>> find_most_popular_user(6, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 4)]) 4 >>> find_most_popular_user(4, 3, [(1, 2), (2, 3), (1, 3)]) 1 >>> find_most_popular_user(7, 4, [(1, 2), (2, 3), (4, 5), (3, 4)]) 2 >>> find_most_popular_user(5, 0, []) None","solution":"def find_most_popular_user(N, M, connections): from collections import defaultdict # Dictionary to count the number of connections for each user popularity_count = defaultdict(int) # Iterate through each connection and increase the count for both users for u, v in connections: popularity_count[u] += 1 popularity_count[v] += 1 # Determining the user with the highest popularity max_popularity = -1 user_with_max_popularity = None for user in range(1, N + 1): if user in popularity_count: if popularity_count[user] > max_popularity: max_popularity = popularity_count[user] user_with_max_popularity = user elif popularity_count[user] == max_popularity: user_with_max_popularity = min(user_with_max_popularity, user) else: continue return user_with_max_popularity # Input handling def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) connections = [(int(data[i]), int(data[i+1])) for i in range(2, len(data), 2)] result = find_most_popular_user(N, M, connections) print(result)"},{"question":"def organize_events(n: int, event_list: List[str]) -> str: You are given the task of organizing a sequence of events such that each event's requirements are satisfied. The input starts with a single integer n (1 ≤ n ≤ 100), representing the number of events. Each of the following n lines contains the name of an event (a string of up to 20 characters) followed by a list of preceding events' names, each separated by a space. If an event has no prerequisites, it will be followed by the character '-'. Output a valid sequence of event names that satisfies all prerequisite requirements. If there are multiple valid sequences, output any one of them. If it's impossible to satisfy the prerequisites, output \\"impossible\\". >>> organize_events(4, [\\"EventA -\\", \\"EventB EventA\\", \\"EventC EventA\\", \\"EventD EventB EventC\\"]) == 'EventA EventB EventC EventD' >>> organize_events(3, [\\"EventA EventB\\", \\"EventB EventC\\", \\"EventC EventA\\"]) == 'impossible'","solution":"def find_event_sequence(n, events): from collections import defaultdict, deque # Step 1: Parse input and build the graph event_graph = defaultdict(list) indegree = {event: 0 for event in events} for event, precedents in events.items(): if precedents: for prerequisite in precedents: event_graph[prerequisite].append(event) indegree[event] += 1 # Step 2: Topological Sort using Kahn's Algorithm queue = deque([event for event, degree in indegree.items() if degree == 0]) schedule = [] while queue: current = queue.popleft() schedule.append(current) for neighbor in event_graph[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If the length of schedule is not equal to number of events, there's a cycle if len(schedule) != n: return \\"impossible\\" return schedule # Wrapping function to read input format and call the main function def organize_events(n, event_list): events = {} for item in event_list: parts = item.split() event = parts[0] if len(parts) == 2 and parts[1] == '-': events[event] = [] else: events[event] = parts[1:] sequence = find_event_sequence(n, events) if sequence == \\"impossible\\": return sequence else: return ' '.join(sequence)"},{"question":"def process_multiple_datasets(input_data: str) -> List[int]: Process multiple datasets to count the number of distinct heatwave patterns in each. A heatwave is defined as a sequence of three or more consecutive cells (vertically, horizontally, or diagonally) that all have the same temperature. :param input_data: String containing the input data. :return: List of integers representing the number of distinct heatwave patterns for each dataset. >>> process_multiple_datasets(\\"3n30 30 30n25 30 25n30 25 30n0\\") [3] >>> process_multiple_datasets(\\"4n35 35 35 35n35 36 36 36n35 35 37 37n35 35 35 38n0\\") [7] >>> process_multiple_datasets(\\"3n30 30 30n25 30 25n30 25 30n4n35 35 35 35n35 36 36 36n35 35 37 37n35 35 35 38n0\\") [3, 7]","solution":"def count_heatwaves(grid): Count the number of heatwave patterns in the given NxN grid. A heatwave is a sequence of three or more consecutive cells (vertically, horizontally, or diagonally) that all have the same temperature. :param grid: List of lists containing integers representing the temperature grid. :return: The number of distinct heatwave patterns. N = len(grid) if N == 0: return 0 def check_heatwave(i, j, di, dj): temp = grid[i][j] length = 0 while 0 <= i < N and 0 <= j < N and grid[i][j] == temp: i += di j += dj length += 1 return length >= 3 heatwave_count = 0 # Check horizontally, vertically, and diagonally for i in range(N): for j in range(N): if j + 2 < N and check_heatwave(i, j, 0, 1): # horizontal heatwave_count += 1 if i + 2 < N and check_heatwave(i, j, 1, 0): # vertical heatwave_count += 1 if i + 2 < N and j + 2 < N and check_heatwave(i, j, 1, 1): # diagonal down-right heatwave_count += 1 if i + 2 < N and j - 2 >= 0 and check_heatwave(i, j, 1, -1): # diagonal down-left heatwave_count += 1 return heatwave_count def process_multiple_datasets(input_data): Process multiple datasets from the input data and return heatwave counts for each dataset. :param input_data: List of strings containing the input data. :return: List of integers representing the number of heatwave patterns for each dataset. input_lines = input_data.split('n') results = [] index = 0 while index < len(input_lines): N = int(input_lines[index]) if N == 0: break grid = [] for i in range(N): grid.append(list(map(int, input_lines[index + 1 + i].split()))) heatwave_count = count_heatwaves(grid) results.append(heatwave_count) index += N + 1 return results"},{"question":"def triangle_numbers_sequence(n): Returns the sequence of first \`n\` triangle numbers concatenated without spaces. If n < 1, return empty string. >>> triangle_numbers_sequence(0) \\"\\" >>> triangle_numbers_sequence(1) \\"1\\" >>> triangle_numbers_sequence(2) \\"13\\" >>> triangle_numbers_sequence(3) \\"136\\" >>> triangle_numbers_sequence(4) \\"13610\\"","solution":"def triangle_numbers_sequence(n): Returns the sequence of first \`n\` triangle numbers concatenated without spaces. If n < 1, return empty string. if n < 1: return \\"\\" def triangle_number(k): return (k * (k + 1)) // 2 result = \\"\\" for i in range(1, n + 1): result += str(triangle_number(i)) return result"},{"question":"def chunk(array, n): Splits the array into a two-dimensional array grouped by sub-arrays of length n. :param array: List of elements to be chunked. :param n: The length of each chunk. :return: A two-dimensional array where each sub-array has the length n. >>> chunk([1, 2, 3, 4, 5, 6], 2) [[1, 2], [3, 4], [5, 6]] >>> chunk([1, 2, 3, 4, 5], 2) [[1, 2], [3, 4], [5]] >>> chunk([1], 2) [[1]] >>> chunk([1, 2, 3], 5) [[1, 2, 3]] >>> chunk([1, 2, 3, 4, 5, 6], 1) [[1], [2], [3], [4], [5], [6]] >>> chunk([], 3) [] >>> chunk([1, 2, 3, 4, 5, 6, 7, 8, 9], 4) [[1, 2, 3, 4], [5, 6, 7, 8], [9]]","solution":"def chunk(array, n): Splits the array into a two-dimensional array grouped by sub-arrays of length n. :param array: List of elements to be chunked. :param n: The length of each chunk. :return: A two-dimensional array where each sub-array has the length n. return [array[i:i + n] for i in range(0, len(array), n)]"},{"question":"from typing import List, Tuple def subset_sum_zero(n: int, nums: List[int]) -> str: Determine if any subset of numbers sums up to zero. >>> subset_sum_zero(5, [2, -3, 7, -4, 1]) \\"YES\\" >>> subset_sum_zero(4, [1, 2, 3, 4]) \\"NO\\" def parse_input(input_str: str) -> Tuple[int, List[int]]: Parse the input string into the necessary format. >>> parse_input(\\"5n2 -3 7 -4 1\\") (5, [2, -3, 7, -4, 1]) >>> parse_input(\\"4n1 2 3 4\\") (4, [1, 2, 3, 4])","solution":"from itertools import combinations def subset_sum_zero(n, nums): for r in range(1, n+1): for subset in combinations(nums, r): if sum(subset) == 0: return \\"YES\\" return \\"NO\\" def parse_input(input_str): lines = input_str.strip().split('n') n = int(lines[0]) nums = list(map(int, lines[1].split())) return n, nums"},{"question":"def process_operations(n: int, operations: List[str]) -> List[int]: Process a series of operations that add or subtract from a budget. Args: n (int): the number of operations operations (List[str]): a list of operations to be performed on the budget. Each operation is a string of actions separated by spaces. Each action is either '+x' to add x to the budget or '-y' to subtract y from the budget. Returns: List[int]: a list of budget values after each operation. Examples: >>> process_operations(3, [\\"+500 -200\\", \\"+100 +300 -50\\", \\"-600 +200\\"]) [300, 650, 250] >>> process_operations(1, [\\"+1000\\"]) [1000] >>> process_operations(1, [\\"-1000\\"]) [0]","solution":"def process_operations(n, operations): budget = 0 results = [] for operation in operations: actions = operation.split() for action in actions: sign = action[0] amount = int(action[1:]) if sign == '+': budget += amount elif sign == '-': budget -= amount if budget < 0: budget = 0 results.append(budget) return results"},{"question":"import re def longest_word_length(s: str) -> int: Return the length of the longest word in the input string. A word is defined as a sequence of letters (a-z, A-Z) and may contain hyphens (-). Punctuation should be ignored. >>> longest_word_length(\\"Hello world! This is an example-string.\\") 14 >>> longest_word_length(\\"Programming in Python is fun, isn't it?\\") 11","solution":"import re def longest_word_length(s): Returns the length of the longest word in the input string. Punctuation is ignored, and hyphenated words are considered single words. # Remove all punctuation except for hyphens and spaces, then split into words words = re.findall(r'b[a-zA-Z-]+b', s) # Find the longest word by length longest = max(words, key=len) if words else \\"\\" return len(longest)"},{"question":"from typing import List, Dict def optimalSchedule(bands: List[Dict[str, int]]) -> List[int]: Returns the optimal order of band_ids to minimize the maximum gap between performance_times. >>> optimalSchedule([{'band_id': 1, 'performance_time': 30}, {'band_id': 2, 'performance_time': 45}, {'band_id': 3, 'performance_time': 35}, {'band_id': 4, 'performance_time': 50}]) [1, 3, 2, 4] >>> optimalSchedule([{'band_id': 1, 'performance_time': 60}, {'band_id': 2, 'performance_time': 90}, {'band_id': 3, 'performance_time': 120}]) [1, 2, 3]","solution":"def optimalSchedule(bands): Returns the optimal order of band_ids to minimize the maximum gap between performance_times. # Sort bands based on their performance times bands.sort(key=lambda x: x['performance_time']) # Arrange the performance times to minimize the maximum time gap left, right = 0, len(bands) - 1 optimal_order = [] while left <= right: if left == right: optimal_order.append(bands[left]) else: optimal_order.append(bands[left]) optimal_order.append(bands[right]) left += 1 right -= 1 # Extract the band_ids from the optimal order optimal_band_ids = [band['band_id'] for band in optimal_order] return optimal_band_ids"},{"question":"def min_operations_to_sort(lst): Find the minimum number of operations required to sort the list. In one operation, you can select up to two adjacent numbers in the list and swap them. >>> min_operations_to_sort([4, 3, 1, 2, 5]) 4 >>> min_operations_to_sort([5, 4, 3, 2, 1]) 10 from solution import min_operations_to_sort def test_example_case(): assert min_operations_to_sort([4, 3, 1, 2, 5]) == 4 def test_already_sorted(): assert min_operations_to_sort([1, 2, 3, 4, 5, 6]) == 0 def test_reverse_sorted(): assert min_operations_to_sort([5, 4, 3, 2, 1]) == 10 def test_single_element(): assert min_operations_to_sort([1]) == 0 def test_two_elements(): assert min_operations_to_sort([2, 1]) == 1 def test_duplicates(): assert min_operations_to_sort([2, 3, 2, 3]) == 1 def test_large_numbers(): assert min_operations_to_sort([1000000000, -1000000000]) == 1","solution":"def min_operations_to_sort(lst): Returns the minimum number of adjacent swaps required to sort the list in non-decreasing order. def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be merged subarray inv_count = 0 # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: # There are mid - i inversions, because all elements left to i in left subarray are greater than arr[j] temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the merged subarray into original array for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count n = len(lst) temp_arr = [0]*n return merge_sort_and_count(lst, temp_arr, 0, n-1)"},{"question":"def longest_increasing_path(matrix: List[List[int]]) -> int: Given a grid of cells (represented by a 2D array) where each cell has a specific elevation value, determine the longest increasing path in the grid. From each cell, you can either move left, right, up, or down to a neighboring cell if the neighboring cell has a strictly higher elevation. >>> longest_increasing_path([ >>> [9, 9, 4], >>> [6, 6, 8], >>> [2, 1, 1] >>> ]) 4 >>> longest_increasing_path([ >>> [42] >>> ]) 1 >>> longest_increasing_path([ >>> [1, 2, 3], >>> [6, 5, 4], >>> [7, 8, 9] >>> ]) 9 >>> longest_increasing_path([ >>> [5, 5, 5], >>> [5, 5, 5], >>> [5, 5, 5] >>> ]) 1 >>> longest_increasing_path([ >>> [1, 2, 3], >>> [8, 9, 4], >>> [7, 6, 5] >>> ]) 9 from solution import longest_increasing_path def test_example_case(): matrix = [ [9, 9, 4], [6, 6, 8], [2, 1, 1] ] assert longest_increasing_path(matrix) == 4 def test_single_cell(): matrix = [ [42] ] assert longest_increasing_path(matrix) == 1 def test_all_increasing_in_line(): matrix = [ [1, 2, 3], [6, 5, 4], [7, 8, 9] ] assert longest_increasing_path(matrix) == 9 def test_all_equal(): matrix = [ [5, 5, 5], [5, 5, 5], [5, 5, 5] ] assert longest_increasing_path(matrix) == 1 def test_increasing_spiral(): matrix = [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ] assert longest_increasing_path(matrix) == 9","solution":"def longest_increasing_path(matrix): Given a 2D grid, calculate the longest increasing path. if not matrix or not matrix[0]: return 0 M, N = len(matrix), len(matrix[0]) dp = [[-1 for _ in range(N)] for _ in range(M)] def dfs(x, y): if dp[x][y] != -1: return dp[x][y] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and matrix[nx][ny] > matrix[x][y]: length = 1 + dfs(nx, ny) max_length = max(max_length, length) dp[x][y] = max_length return dp[x][y] max_path = 0 for i in range(M): for j in range(N): max_path = max(max_path, dfs(i, j)) return max_path # Example input input_matrix = [ [9, 9, 4], [6, 6, 8], [2, 1, 1] ] # Example usage M, N = 3, 3 print(longest_increasing_path(input_matrix)) # Output: 4"},{"question":"def final_positions(n: int, m: int, operations: str, queries: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Determines the final position of each plant after performing multiple operations on a garden grid. :param n: Number of rows in the garden grid. :param m: Number of columns in the garden grid. :param operations: String of characters 'U', 'D', 'L', 'R' that describe the movements. :param queries: List of tuples where each tuple contains the initial coordinates (x, y) of a plant. :return: List of tuples where each tuple contains the final coordinates (x, y) of a plant. >>> final_positions(5, 5, \\"UUDDLLRR\\", [(1, 1), (2, 2), (5, 5)]) [(1, 1), (2, 2), (5, 5)] >>> final_positions(4, 4, \\"UDLRLRLR\\", [(1, 1), (2, 2), (3, 3), (4, 4)]) [(1, 1), (2, 2), (3, 3), (4, 4)] >>> final_positions(3, 3, \\"UUU\\", [(1, 1), (2, 2)]) [(1, 1), (2, 2)] >>> final_positions(3, 3, \\"DDD\\", [(1, 1), (2, 2)]) [(1, 1), (2, 2)] >>> final_positions(3, 3, \\"LLL\\", [(1, 1), (2, 2)]) [(1, 1), (2, 2)] >>> final_positions(3, 3, \\"RRR\\", [(1, 1), (2, 2)]) [(1, 1), (2, 2)]","solution":"def final_positions(n, m, operations, queries): Determines the final position of each plant after performing multiple operations on a grid. :param n: Number of rows in the garden grid. :param m: Number of columns in the garden grid. :param operations: String of characters 'U', 'D', 'L', 'R' that describe the movements. :param queries: List of tuples where each tuple contains the initial coordinates (x, y) of a plant. :return: List of tuples where each tuple contains the final coordinates (x, y) of a plant. net_vertical = 0 # Net number of moves in the vertical direction net_horizontal = 0 # Net number of moves in the horizontal direction # Calculate net movements for operation in operations: if operation == 'U': net_vertical -= 1 elif operation == 'D': net_vertical += 1 elif operation == 'L': net_horizontal -= 1 elif operation == 'R': net_horizontal += 1 net_vertical = net_vertical % n net_horizontal = net_horizontal % m final_positions = [] for x, y in queries: final_x = (x - 1 + net_vertical) % n + 1 final_y = (y - 1 + net_horizontal) % m + 1 final_positions.append((final_x, final_y)) return final_positions"},{"question":"def min_insertions_deletions_to_palindrome(s: str) -> int: Given a string s, transform it into a palindrome with the minimum number of insertions or deletions. >>> min_insertions_deletions_to_palindrome(\\"abc\\") 2 >>> min_insertions_deletions_to_palindrome(\\"racecar\\") 0 >>> min_insertions_deletions_to_palindrome(\\"xyz\\") 2 def process_palindrome_cases(test_cases: List[str]) -> List[int]: Processes a list of test cases and returns a list of results. Each result is the minimum number of insertions or deletions needed for the corresponding string to become a palindrome. >>> process_palindrome_cases([\\"abc\\", \\"racecar\\", \\"xyz\\"]) [2, 0, 2] >>> process_palindrome_cases([\\"a\\", \\"ab\\", \\"aba\\", \\"abca\\"]) [0, 1, 0, 1]","solution":"def min_insertions_deletions_to_palindrome(s): def lcs(X, Y): m = len(X) n = len(Y) L = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: L[i][j] = 0 elif X[i-1] == Y[j-1]: L[i][j] = L[i-1][j-1] + 1 else: L[i][j] = max(L[i-1][j], L[i][j-1]) return L[m][n] rev_s = s[::-1] lcs_length = lcs(s, rev_s) return len(s) - lcs_length def process_palindrome_cases(test_cases): results = [] for case in test_cases: results.append(min_insertions_deletions_to_palindrome(case)) return results"},{"question":"def findFirstGreaterOrEqual(array: List[int], X: int) -> int: Given a sorted array of N integers and a target value X, find the index of the first occurrence of the element that is greater than or equal to X. If all elements in the array are smaller than X, return -1. >>> findFirstGreaterOrEqual([1, 3, 5, 7], 5) 2 >>> findFirstGreaterOrEqual([1, 2, 4, 6], 3) 2 >>> findFirstGreaterOrEqual([1, 2, 3, 4], 5) -1 from typing import List import unittest class TestFindFirstGreaterOrEqual(unittest.TestCase): def test_example1(self): self.assertEqual(findFirstGreaterOrEqual([1, 3, 5, 7], 5), 2) def test_example2(self): self.assertEqual(findFirstGreaterOrEqual([1, 2, 4, 6], 3), 2) def test_example3(self): self.assertEqual(findFirstGreaterOrEqual([1, 2, 3, 4], 5), -1) def test_small_values(self): self.assertEqual(findFirstGreaterOrEqual([10, 20, 30, 40, 50], 25), 2) self.assertEqual(findFirstGreaterOrEqual([10, 20, 30, 40, 50], 30), 2) self.assertEqual(findFirstGreaterOrEqual([10, 20, 30, 40, 50], 5), 0) def test_large_values(self): self.assertEqual(findFirstGreaterOrEqual([1000000000, 2000000000, 3000000000], 1500000000), 1) self.assertEqual(findFirstGreaterOrEqual([1000000000, 2000000000, 3000000000], 2500000000), 2) def test_edge_cases(self): self.assertEqual(findFirstGreaterOrEqual([], 1), -1) self.assertEqual(findFirstGreaterOrEqual([1], 1), 0) self.assertEqual(findFirstGreaterOrEqual([1], 2), -1) def test_all_elements_smaller(self): self.assertEqual(findFirstGreaterOrEqual([1, 2, 3, 4], 10), -1) def test_all_elements_larger(self): self.assertEqual(findFirstGreaterOrEqual([10, 20, 30, 40], 5), 0) def test_same_elements(self): self.assertEqual(findFirstGreaterOrEqual([10, 10, 10, 10], 10), 0) def test_negative_values(self): self.assertEqual(findFirstGreaterOrEqual([-10, -5, 0, 5, 10], 0), 2) self.assertEqual(findFirstGreaterOrEqual([-10, -5, -2, 0], -3), 2) if __name__ == \\"__main__\\": unittest.main()","solution":"def findFirstGreaterOrEqual(array, X): Returns the index of the first occurrence of an element greater than or equal to X in the sorted array. If no such element exists, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] >= X: result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"from typing import List def min_sum_max_subarray(N: int, K: int, D: int, A: List[int]) -> int: Given an array \`A\` of \`N\` integers, calculate the minimum possible sum of the maximum subarray of size \`K\` that can be obtained after performing at most \`D\` swaps. Args: - N (int): number of integers in the array. - K (int): size of the subarray. - D (int): maximum number of swaps allowed. - A (List[int]): the array of integers. Returns: - int: minimum possible sum of the maximum subarray of size \`K\`. >>> min_sum_max_subarray(5, 3, 1, [1, 2, 5, 2, 1]) 9 >>> min_sum_max_subarray(6, 2, 2, [3, 3, 5, 5, 1, 1]) 3 pass def test_min_sum_max_subarray(): assert min_sum_max_subarray(5, 3, 1, [1, 2, 5, 2, 1]) == 4 assert min_sum_max_subarray(6, 2, 2, [3, 3, 5, 5, 1, 1]) == 2 assert min_sum_max_subarray(5, 5, 1, [1, 1, 1, 1, 1]) == 5 assert min_sum_max_subarray(7, 4, 2, [-1, -2, -3, -4, 5, 6, 7]) == -10 assert min_sum_max_subarray(3, 2, 0, [5, 6, 7]) == 11 def test_min_sum_max_subarray_no_swaps(): assert min_sum_max_subarray(3, 2, 0, [1, 3, 2]) == 3 assert min_sum_max_subarray(5, 3, 0, [4, 3, 5, 1, 2]) == 6 assert min_sum_max_subarray(4, 2, 0, [3, 1, 4, 2]) == 3 def test_min_sum_max_subarray_large_input(): assert min_sum_max_subarray(10, 5, 100000, [-5, -4, -3, -2, -1, 1, 2, 3, 4, 5]) == -15 assert min_sum_max_subarray(100000, 100000, 0, list(range(1, 100001))) == 5000050000","solution":"def min_sum_max_subarray(N, K, D, A): Returns the minimum possible sum of the maximum subarray of size K that can be obtained after performing at most D swaps. # Sort the array to have the smallest elements in the leading positions A.sort() # Considering that we won't use more than D swaps, we might just need to compute the sum of # the first K elements in the sorted array, because sorting will give us the smallest sums # available for any subarray of size K. min_sum = sum(A[:K]) return min_sum"},{"question":"def rearrange_string(s: str) -> str: Rearrange the input string such that all the alphabets are sorted in ascending order and all the digits are sorted in descending order, with alphabets coming first. Args: s (str): Input string consisting of lowercase alphabets and digits Returns: str: Rearranged string as per the requirement >>> rearrange_string(\\"a1c3b2\\") 'abc321' >>> rearrange_string(\\"z9x8y7\\") 'xyz987' >>> rearrange_string(\\"a1a1a1\\") 'aaa111' >>> rearrange_string(\\"abc\\") 'abc' >>> rearrange_string(\\"321\\") '321' >>> rearrange_string(\\"h4e3l2l1o0\\") 'ehllo43210' >>> rearrange_string(\\"\\") ''","solution":"def rearrange_string(s): Rearrange the input string such that all the alphabets are sorted in ascending order and all the digits are sorted in descending order, with alphabets coming first. Args: s (str): Input string consisting of lowercase alphabets and digits Returns: str: Rearranged string as per the requirement alphabets = sorted([ch for ch in s if ch.isalpha()]) digits = sorted([ch for ch in s if ch.isdigit()], reverse=True) return ''.join(alphabets + digits)"},{"question":"from typing import List, Union def find_task_order(N: int, M: int, dependencies: List[List[int]]) -> Union[List[int], str]: Determine a valid order of tasks given their dependencies. Args: N : int : The number of tasks M : int : The number of dependencies dependencies : List[List[int]] : A list of dependency pairs Returns: Union[List[int], str] : A valid order of tasks or \\"IMPOSSIBLE\\" if no valid order exists. Example: >>> find_task_order(4, 3, [[0, 1], [1, 2], [2, 3]]) [0, 1, 2, 3] >>> find_task_order(2, 2, [[0, 1], [1, 0]]) \\"IMPOSSIBLE\\"","solution":"from collections import deque, defaultdict def find_task_order(N, M, dependencies): in_degree = [0] * N graph = defaultdict(list) for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 queue = deque([i for i in range(N) if in_degree[i] == 0]) order = [] while queue: node = queue.popleft() order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(order) == N: return order else: return \\"IMPOSSIBLE\\" # Sample input N = 4 M = 3 dependencies = [[0, 1], [1, 2], [2, 3]] print(find_task_order(N, M, dependencies)) # Example usage"},{"question":"def unique_paths_with_obstacles(m, n, grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of a grid. Handle obstacles marked with 1. :param m: number of rows in the grid :param n: number of columns in the grid :param grid: 2D list representing the grid (0 is a free space, 1 is an obstacle) :return: number of unique paths pass # Sample test cases print(unique_paths_with_obstacles(3, 3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]])) # Expected output: 2 print(unique_paths_with_obstacles(2, 2, [[0, 1], [1, 0]])) # Expected output: 0","solution":"def unique_paths_with_obstacles(m, n, grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of a grid. Handle obstacles marked with 1 :param m: number of rows in the grid :param n: number of columns in the grid :param grid: 2D list representing the grid (0 is a free space, 1 is an obstacle) :return: number of unique paths if not grid or grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0]*n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def is_permutation(str1: str, str2: str) -> bool: Compare two strings and determine if one string is a permutation of the other. >>> is_permutation(\\"abc\\", \\"cba\\") True >>> is_permutation(\\"abcd\\", \\"dabc\\") True >>> is_permutation(\\"abcd\\", \\"abce\\") False","solution":"def is_permutation(str1, str2): Determines if str1 is a permutation of str2. return sorted(str1) == sorted(str2)"},{"question":"def can_form_string(L: int, test_cases: List[Tuple[int, int, str]]) -> List[str]: Determines if the target string Q can be formed after N operations on S. Parameters: L (int): The number of test cases. test_cases (List[Tuple[int, int, str]]): A list of tuples where each tuple contains: N (int): Number of operations K (int): Maximum allowed count of 'a' or 'b' Q (str): Target string Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each test case. Examples: >>> can_form_string(4, [(5, 3, 'abb'), (4, 4, 'bb'), (6, 2, 'aaab'), (7, 2, 'abba')]) ['YES', 'YES', 'NO', 'NO']","solution":"def can_form_string(L, test_cases): results = [] for i in range(L): N, K, Q = test_cases[i] len_Q = len(Q) cnt_a = Q.count('a') cnt_b = Q.count('b') if cnt_a <= K and cnt_b <= K and N >= len_Q and (N - len_Q) % 2 == 0: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def can_rearrange_to_form(S: str, T: str) -> str: Determines if string T can be made from string S by rearranging the letters. >>> can_rearrange_to_form(\\"ABACUS\\", \\"CASUBA\\") \\"YES\\" >>> can_rearrange_to_form(\\"HELLO\\", \\"OLEHL\\") \\"YES\\" >>> can_rearrange_to_form(\\"WORLD\\", \\"WORD\\") \\"NO\\" def process_test_cases(test_cases: List[str]) -> List[str]: Processes multiple test cases and determines if each T can be made from S for each test case. >>> process_test_cases([\\"ABACUS CASUBA\\", \\"HELLO OLEHL\\", \\"WORLD WORD\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_test_cases([\\"ABCDE ABCDE\\", \\"ABCDE ABCDF\\", \\"A A\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def can_rearrange_to_form(S, T): Determines if string T can be made from string S by rearranging the letters. :param S: Source string :param T: Target string :return: \\"YES\\" if T can be made from S, otherwise \\"NO\\" return \\"YES\\" if sorted(S) == sorted(T) else \\"NO\\" def process_test_cases(test_cases): results = [] for case in test_cases: S, T = case.split() results.append(can_rearrange_to_form(S, T)) return results"},{"question":"def sum_of_digits(num: int) -> int: Helper function to calculate the sum of digits of a number. return sum(int(digit) for digit in str(num)) def sequence_of_sums(N: int, M: int) -> list: Generate the first M terms of the sequence where each term is the sum of digits of the previous term starting from N. >>> sequence_of_sums(123, 5) [6, 6, 6, 6, 6] >>> sequence_of_sums(987654321, 3) [45, 9, 9] >>> sequence_of_sums(1, 1) [1] >>> sequence_of_sums(99999999, 2) [72, 9] >>> sequence_of_sums(314159265, 4) [36, 9, 9, 9] >>> sequence_of_sums(1, 5) [1, 1, 1, 1, 1] >>> sequence_of_sums(1000000000, 5) [1, 1, 1, 1, 1] >>> sequence_of_sums(999, 1) [27]","solution":"def sum_of_digits(num): Helper function to calculate the sum of digits of a number. return sum(int(digit) for digit in str(num)) def sequence_of_sums(N, M): Generate the first M terms of the sequence where each term is the sum of digits of the previous term starting from N. current_value = sum_of_digits(N) result = [current_value] for _ in range(1, M): current_value = sum_of_digits(current_value) result.append(current_value) return result"},{"question":"def alice_cipher(k, message): Encodes the given message using Alice Cipher with a shift value of k. Args: k (int): The shift value. message (str): The message to be encoded. Returns: str: The encoded message. Examples: >>> alice_cipher(3, \\"Hello, World!\\") 'Khoor, Zruog!' >>> alice_cipher(0, \\"Hello, World!\\") 'Hello, World!' >>> alice_cipher(3, \\"hello\\") 'khoor' >>> alice_cipher(3, \\"HELLO\\") 'KHOOR' >>> alice_cipher(4, \\"Hi, Alice! 123\\") 'Lm, Epmgi! 123' >>> alice_cipher(4, \\"xyz\\") 'bcd' >>> alice_cipher(4, \\"XYZ\\") 'BCD' >>> alice_cipher(26, \\"Hello, World!\\") 'Hello, World!'","solution":"def alice_cipher(k, message): Encodes the given message using Alice Cipher with a shift value of k. Args: k (int): The shift value. message (str): The message to be encoded. Returns: str: The encoded message. encoded_message = [] for char in message: if char.isalpha(): if char.islower(): encoded_char = chr((ord(char) - ord('a') + k) % 26 + ord('a')) else: # char is uppercase encoded_char = chr((ord(char) - ord('A') + k) % 26 + ord('A')) else: encoded_char = char encoded_message.append(encoded_char) return ''.join(encoded_message)"},{"question":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Returns the sum of the largest contiguous subarray within a one-dimensional array of numbers. Uses Kadane's Algorithm to achieve O(n) time complexity and O(1) extra space. Examples: >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23 >>> max_subarray_sum([-1, -2, -3, -4]) -1","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Returns the sum of the largest contiguous subarray within a one-dimensional array of numbers. Uses Kadane's Algorithm to achieve O(n) time complexity and O(1) extra space. if not arr: return 0 current_sum = max_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def product_except_self(nums): Returns a list such that each element at index i is the product of all numbers in nums except nums[i]. >>> product_except_self([1, 2, 3]) [6, 3, 2] >>> product_except_self([4, 5, 6, 7]) [210, 168, 140, 120] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] def solve(test_cases): Solve the problem for multiple test cases. def parse_input(input_string): Parse input string and convert it to the test cases. def format_output(results): Format the output as required. def main(input_string): Main function to read input, process it, and print output.","solution":"def product_except_self(nums): Returns a list such that each element at index i is the product of all numbers in nums except nums[i]. length = len(nums) left_products = [1] * length right_products = [1] * length result = [1] * length for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] for i in range(length): result[i] = left_products[i] * right_products[i] return result def solve(test_cases): results = [] for nums in test_cases: results.append(product_except_self(nums)) return results def parse_input(input_string): lines = input_string.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) nums = list(map(int, lines[index + 1].split())) test_cases.append(nums) index += 2 return test_cases def format_output(results): output = [] for result in results: output.append(\\" \\".join(map(str, result))) return \\"n\\".join(output) def main(input_string): test_cases = parse_input(input_string) results = solve(test_cases) return format_output(results)"},{"question":"def process_queries(T, cases): Process queries to determine if there exists a path between two vertices of the same color in a graph. Args: T: int - number of test cases cases: list of dict - each containing: 'n': number of vertices 'm': number of edges 'colors': string indicating vertex colors ('R' for red and 'B' for blue) 'edges': list of tuples representing edges 'q': number of queries 'queries': list of tuples representing queries (u, v) Returns: list of strings - \\"yes\\" if a path exists, \\"no\\" otherwise Example: >>> process_queries(1, [{'n': 5, 'm': 6, 'colors': 'RBRRR', 'edges': [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (3, 5)], 'q': 3, 'queries': [(1, 5), (2, 3), (1, 4)]}]) ['yes', 'no', 'yes']","solution":"def process_queries(T, cases): def explore_graph(n, edges, colors, queries): from collections import defaultdict, deque # Create adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) def bfs(start, color): queue = deque([start]) visited[start] = True component = [] while queue: node = queue.popleft() component.append(node) for neighbor in adj_list[node]: if not visited[neighbor] and colors[neighbor - 1] == color: visited[neighbor] = True queue.append(neighbor) return component # Find all same-color connected components visited = [False] * (n + 1) components = defaultdict(list) for i in range(1, n + 1): if not visited[i]: color = colors[i - 1] component = bfs(i, color) for node in component: components[node] = component results = [] for u, v in queries: if v in components[u]: results.append(\\"yes\\") else: results.append(\\"no\\") return results results = [] for i in range(T): n, m = cases[i]['n'], cases[i]['m'] colors = cases[i]['colors'] edges = cases[i]['edges'] q = cases[i]['q'] queries = cases[i]['queries'] results.extend(explore_graph(n, edges, colors, queries)) return results def read_input(): import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 cases = [] for _ in range(T): n = int(data[index]) m = int(data[index + 1]) index += 2 colors = data[index] index += 1 edges = [] for _ in range(m): u = int(data[index]) v = int(data[index + 1]) edges.append((u, v)) index += 2 q = int(data[index]) index += 1 queries = [] for _ in range(q): u = int(data[index]) v = int(data[index + 1]) queries.append((u, v)) index += 2 cases.append({ 'n': n, 'm': m, 'colors': colors, 'edges': edges, 'q': q, 'queries': queries }) return T, cases def main(): T, cases = read_input() results = process_queries(T, cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def is_prime(n): Determine if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True def max_prime_piles(t, test_cases): Determine the maximum number of prime piles Monocarp can pick up in a single move for each test case. >>> max_prime_piles(3, [(3, [5, 4, 9]), (4, [6, 8, 10, 15]), (5, [17, 19, 23, 6, 45])]) [1, 0, 3] >>> max_prime_piles(2, [(1, [1]), (5, [10, 20, 30, 40, 50])]) [0, 0]","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def max_prime_piles(t, test_cases): results = [] for i in range(t): n, piles = test_cases[i] prime_piles_count = sum(1 for pile in piles if is_prime(pile)) results.append(prime_piles_count) return results"},{"question":"def calculate_g_sum(num_cases, test_cases): Calculate the sum G of the number of strictly increasing subarrays for each test case. Args: num_cases (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of test cases, where each test case is a tuple containing an integer N and a list of N integers. Returns: List[int]: List of results for each test case G. >>> calculate_g_sum(1, [(4, [1, 2, 3, 4])]) [10] >>> calculate_g_sum(1, [(5, [5, 4, 2, 1, 3])]) [6]","solution":"def calculate_g_sum(num_cases, test_cases): def count_strictly_increasing_subarrays(arr): n = len(arr) dp = [1] * n # dp[i] holds the length of increasing subarray ending at i result = 0 for i in range(1, n): if arr[i] > arr[i - 1]: dp[i] = dp[i - 1] + 1 for val in dp: result += val return result results = [] for i in range(num_cases): n, p = test_cases[i] result = count_strictly_increasing_subarrays(p) results.append(result) return results # Example usage: num_cases = 2 test_cases = [ (4, [1, 2, 3, 4]), (5, [5, 4, 2, 1, 3]) ] for result in calculate_g_sum(num_cases, test_cases): print(result)"},{"question":"def max_beauty_of_park(heights): Finds the maximum beauty of any possible park by choosing a sequence of consecutive buildings. Parameters: heights (list of int): A list of integers representing the heights of the buildings. Returns: int: The maximum beauty of the park. >>> max_beauty_of_park([2, 1, 3, 4, 1, 2]) 13 >>> max_beauty_of_park([5, 4, 3, 2, 1]) 15 >>> max_beauty_of_park([1, -2, 3, -4, 5]) 5 >>> max_beauty_of_park([-1, -2, -3, -4]) -1 >>> max_beauty_of_park([0, -1, -2, 0, 1, 2, 3]) 6","solution":"def max_beauty_of_park(heights): Finds the maximum beauty of any possible park by choosing a sequence of consecutive buildings. Parameters: heights (list of int): A list of integers representing the heights of the buildings. Returns: int: The maximum beauty of the park. max_sum = current_sum = heights[0] for height in heights[1:]: current_sum = max(height, current_sum + height) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def run_length_encode(s: str) -> str: Compresses the input string s using run-length encoding. Args: - s: Input string consisting of upper case and lower case letters Returns: - Compressed string using run-length encoding Example: >>> run_length_encode(\\"aaabbc\\") \\"a3b2c1\\" >>> run_length_encode(\\"aBcD\\") \\"a1B1c1D1\\" def rle_multiple_strings(T: int, strings: List[str]) -> List[str]: Applies run-length encoding to multiple strings. Args: - T: Number of strings (test cases) - strings: List of strings to be compressed Returns: - List containing RLE compressed strings Example: >>> rle_multiple_strings(2, [\\"aaabbc\\", \\"aBcD\\"]) [\\"a3b2c1\\", \\"a1B1c1D1\\"] >>> rle_multiple_strings(3, [\\"aaa\\", \\"bb\\", \\"c\\"]) [\\"a3\\", \\"b2\\", \\"c1\\"]","solution":"def run_length_encode(s): Compresses the input string s using run-length encoding. if not s: return \\"\\" encoded_string = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: encoded_string.append(f\\"{current_char}{count}\\") current_char = char count = 1 encoded_string.append(f\\"{current_char}{count}\\") return \\"\\".join(encoded_string) def rle_multiple_strings(T, strings): Applies run-length encoding to multiple strings. Args: - T: Number of strings (test cases) - strings: List of strings to be compressed Returns: - List containing RLE compressed strings result = [] for s in strings: result.append(run_length_encode(s)) return result"},{"question":"def longest_palindrome_length(s: str) -> int: Given a string s, find the length of the longest palindrome that can be formed by replacing some of its characters. >>> longest_palindrome_length(\\"abccccdd\\") 7 >>> longest_palindrome_length(\\"aabb\\") 4 >>> longest_palindrome_length(\\"abcde\\") 1 def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Given the number of test cases t and a list of test cases, return a list of results for each test case. >>> process_test_cases(3, [\\"abccccdd\\", \\"aabb\\", \\"abcde\\"]) [7, 4, 1] >>> process_test_cases(2, [\\"aaa\\", \\"a\\"]) [3, 1]","solution":"def longest_palindrome_length(s): from collections import Counter freq = Counter(s) length = 0 odd_found = False for count in freq.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 return length def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(longest_palindrome_length(s)) return results"},{"question":"def most_beautiful_subarray(n: int, arr: List[int]) -> float: Finds the beauty of the most beautiful subarray. :param n: The number of elements in the array :param arr: The array of integers :return: The beauty of the most beautiful subarray >>> most_beautiful_subarray(5, [1, 2, 3, 4, 5]) 5.000000000 >>> most_beautiful_subarray(4, [-1, 2, 0, -3]) 2.000000000","solution":"def most_beautiful_subarray(n, arr): Finds the beauty of the most beautiful subarray. :param n: int - The number of elements in the array :param arr: list of int - The array of integers :return: float - The beauty of the most beautiful subarray # Find the maximum single element in the array since it guarantees the maximum beauty. max_element = max(arr) return float(max_element)"},{"question":"from typing import List, Tuple def largest_clique(n: int, m: int, pairs: List[Tuple[int, int]]) -> int: Given \`n\` balls numbered from \`0\` to \`n - 1\`, and \`m\` pairs of interactions which denote which ball can juggle with which other ball, determine the size of the largest possible group of balls that can all juggle with each other. Parameters: - n (int): Number of balls. - m (int): Number of pairs of interactions. - pairs (List[Tuple[int, int]]): List of interaction pairs. Returns: - int: The size of the largest clique. Example: >>> largest_clique(5, 6, [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]) 4 >>> largest_clique(4, 2, [(0, 1), (2, 3)]) 2","solution":"def largest_clique(n, m, pairs): from itertools import combinations # Create an adjacency matrix for the graph adjacency = [[0] * n for _ in range(n)] for u, v in pairs: adjacency[u][v] = 1 adjacency[v][u] = 1 def is_clique(subset): for i in range(len(subset)): for j in range(i + 1, len(subset)): if adjacency[subset[i]][subset[j]] == 0: return False return True # Brute-force search for the largest clique for size in range(n, 0, -1): for subset in combinations(range(n), size): if is_clique(subset): return size return 1 # At least one ball will always form a clique of size 1"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all distinct characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"abrkaabcdefghijjxxx\\") 10 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"aab\\") 2 >>> length_of_longest_substring(\\"\\") 0","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all distinct characters. n = len(s) char_index = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_index: start = max(start, char_index[s[end]] + 1) char_index[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def min_travel_time(test_cases): Calculate the minimum travel time for each test case. Args: test_cases (List[Tuple[int, List[int], List[int]]]): A list of test cases, where each test case is a tuple. The tuple contains: - an integer \`m\` representing the number of stations, - a list of \`m-1\` integers representing the distances between consecutive stations, - a list of \`m-1\` integers where each integer is either 0 (normal speed) or 1 (fast speed). Returns: List[int]: A list of minimum travel times, one for each test case. pass def parse_input(input_string): Parse the input string and return the test cases. Args: input_string (str): A string representing the multiple test cases input. Returns: List[Tuple[int, List[int], List[int]]]: A list of parsed test cases. pass def format_output(results): Format the results list into the required output string. Args: results (List[int]): A list of results to format. Returns: str: A formatted string of results. pass if __name__ == \\"__main__\\": input_string = 3 3 4 2 1 0 4 5 10 4 0 1 1 2 7 1 test_cases = parse_input(input_string) results = min_travel_time(test_cases) output = format_output(results) print(output)","solution":"def min_travel_time(test_cases): results = [] for case in test_cases: m, distances, fast_speeds = case total_time = 0 for i in range(m-1): if fast_speeds[i] == 1: total_time += -(-distances[i] // 2) # Fast speed, round up division else: total_time += distances[i] # Normal speed results.append(total_time) return results def parse_input(input_string): lines = input_string.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): m = int(lines[index]) distances = list(map(int, lines[index+1].split())) fast_speeds = list(map(int, lines[index+2].split())) test_cases.append((m, distances, fast_speeds)) index += 3 return test_cases def format_output(results): return \\"n\\".join(map(str, results)) # Example usage input_string = 3 3 4 2 1 0 4 5 10 4 0 1 1 2 7 1 test_cases = parse_input(input_string) results = min_travel_time(test_cases) output = format_output(results) print(output)"},{"question":"def adventurer_attributes(level, char_class): Calculate the resulting attributes of an adventurer based on their level and class. :param level: Non-negative integer representing the character's level. :param char_class: String representing the character's class (\\"Warrior\\", \\"Mage\\", or \\"Rogue\\"). :return: Dictionary containing total hit points (hp), total attack bonus, and list of special abilities. >>> adventurer_attributes(0, \\"Warrior\\") {'hp': 0, 'attack_bonus': 0, 'special_abilities': []} >>> adventurer_attributes(3, \\"Mage\\") {'hp': 15, 'attack_bonus': 3, 'special_abilities': ['Fireball']} >>> adventurer_attributes(5, \\"Warrior\\") {'hp': 50, 'attack_bonus': 10, 'special_abilities': ['Power Strike']} >>> adventurer_attributes(4, \\"Rogue\\") {'hp': 28, 'attack_bonus': 6, 'special_abilities': ['Stealth']}","solution":"def adventurer_attributes(level, char_class): attributes = { \\"hp\\": 0, \\"attack_bonus\\": 0, \\"special_abilities\\": [] } if char_class == \\"Warrior\\": attributes[\\"hp\\"] = level * 10 attributes[\\"attack_bonus\\"] = level * 2 if level >= 5: attributes[\\"special_abilities\\"].append(\\"Power Strike\\") elif char_class == \\"Mage\\": attributes[\\"hp\\"] = level * 5 attributes[\\"attack_bonus\\"] = level * 1 if level >= 3: attributes[\\"special_abilities\\"].append(\\"Fireball\\") elif char_class == \\"Rogue\\": attributes[\\"hp\\"] = level * 7 attributes[\\"attack_bonus\\"] = level * 1.5 // 1 if level >= 2: attributes[\\"special_abilities\\"].append(\\"Stealth\\") return attributes"},{"question":"def rotate_array(n, k, arr, direction): Rotates the given array by k steps in the specified direction ('L' for left, 'R' for right). :param n: int - Number of elements in the array :param k: int - Number of steps to rotate :param arr: list - Array of integers to rotate :param direction: str - Direction to rotate ('L' for left, 'R' for right) :return: list - Rotated array >>> rotate_array(5, 2, [1, 2, 3, 4, 5], 'L') [3, 4, 5, 1, 2] >>> rotate_array(5, 1, [1, 2, 3, 4, 5], 'R') [5, 1, 2, 3, 4] >>> rotate_array(4, 2, [1, 2, 3, 4], 'R') [3, 4, 1, 2] >>> rotate_array(3, 9, [1, 2, 3], 'L') [1, 2, 3]","solution":"def rotate_array(n, k, arr, direction): Rotates the given array by k steps in the specified direction ('L' for left, 'R' for right). :param n: int - Number of elements in the array :param k: int - Number of steps to rotate :param arr: list - Array of integers to rotate :param direction: str - Direction to rotate ('L' for left, 'R' for right) :return: list - Rotated array k = k % n # Reduce k to within bounds of array length if direction == 'L': return arr[k:] + arr[:k] elif direction == 'R': return arr[-k:] + arr[:-k] else: raise ValueError(\\"Direction must be either 'L' or 'R'\\")"},{"question":"def checkSubarrays(arr, M, K): Determine if the number of different types of events occurring in each continuous subarray of length K is the same. Args: arr: List[int] - the input array of integers representing events. M: int - the number of different types of events. K: int - the length of the subarrays to check. Returns: str - \\"YES\\" if the condition holds for all subarrays, \\"NO\\" otherwise. Example: >>> checkSubarrays([1, 2, 2, 1, 3], 3, 3) 'NO' >>> checkSubarrays([1, 1, 1, 1], 1, 2) 'YES'","solution":"def checkSubarrays(arr, M, K): Determine if the number of different types of events occurring in each continuous subarray of length K is the same. from collections import Counter n = len(arr) if K > n: return \\"NO\\" # Function to count distinct numbers in a subarray def count_distinct(subarray): return len(set(subarray)) # Initialize the count for the first subarray distinct_count = count_distinct(arr[:K]) for i in range(1, n - K + 1): current_distinct_count = count_distinct(arr[i:i + K]) if current_distinct_count != distinct_count: return \\"NO\\" return \\"YES\\""},{"question":"def game_winner(n: int, cards: List[int]) -> str: Determines the winner of the game based on the rules provided. Parameters: n (int) : Number of cards cards (list) : List of integers representing the value of each card Returns: str : \\"Alice\\" if Alice wins, \\"Bob\\" otherwise >>> game_winner(4, [3, 2, 6, 4]) \\"Alice\\" >>> game_winner(3, [1, 2, 3]) \\"Bob\\"","solution":"def game_winner(n, cards): Determines the winner of the game based on the rules provided. Parameters: n (int) : Number of cards cards (list) : List of integers representing the value of each card Returns: str : \\"Alice\\" if Alice wins, \\"Bob\\" otherwise if n == 1: return \\"Alice\\" cards.sort() if n % 2 == 1: return \\"Bob\\" else: return \\"Alice\\""},{"question":"def minimize_path_sum_from_input(n: int, triangle_list: List[int]) -> int: Returns the minimum path sum from top to bottom in a given triangle. Args: n : int : the number of rows in the triangle triangle_list: List[int] : flattened list of integers representing the triangle Returns: int : the minimum path sum from top to bottom >>> minimize_path_sum_from_input(4, [2, 3, 4, 6, 5, 7, 4, 1, 8, 3]) 11 >>> minimize_path_sum_from_input(3, [1, 2, 3, 4, 5, 6]) 7","solution":"def minimize_path_sum(triangle): Returns the minimum path sum from top to bottom in a given triangle. :param triangle: List of lists of integers representing the triangle :return: Integer representing the minimum path sum # Start from the second last row and propagate the minimum path sum upwards for i in range(len(triangle) - 2, -1, -1): for j in range(len(triangle[i])): triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]) # Return the top element which now contains the minimum sum return triangle[0][0] # Utility function to process the input and call minimize_path_sum def minimize_path_sum_from_input(n, triangle_list): triangle = [] index = 0 for i in range(1, n + 1): triangle.append(triangle_list[index:index + i]) index += i return minimize_path_sum(triangle)"},{"question":"def get_final_position(commands): Returns the final coordinates of the robot after executing the series of commands. :param str commands: A string containing the commands. :return: A tuple (x, y) representing the final coordinates. :rtype: tuple >>> get_final_position(\\"UUUDD\\") (0, 1) >>> get_final_position(\\"LLRR\\") (0, 0) >>> get_final_position(\\"UDLR\\") (0, 0) def process_test_cases(test_cases): Processes multiple test cases and returns the results for each case :param list test_cases: List of strings where each string is a set of commands. :return: List containing final coordinates for each set of commands. :rtype: list of tuples >>> process_test_cases([\\"UUUDD\\", \\"LLRR\\", \\"UDLR\\", \\"UUUU\\", \\"LL\\", \\"RRRRDD\\", \\"\\"]) [(0, 1), (0, 0), (0, 0), (0, 4), (-2, 0), (4, -2), (0, 0)]","solution":"def get_final_position(commands): Returns the final coordinates of the robot after executing the series of commands. :param str commands: A string containing the commands. :return: A tuple (x, y) representing the final coordinates. :rtype: tuple x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return (x, y) def process_test_cases(test_cases): Processes multiple test cases and returns the results for each case :param list test_cases: List of strings where each string is a set of commands. :return: List containing final coordinates for each set of commands. :rtype: list of tuples results = [] for commands in test_cases: results.append(get_final_position(commands)) return results"},{"question":"def max_beauty(n, flowers): This function returns the maximum possible sum of beauty values, satisfying the condition that no two picked flowers should have the same type. :param n: int - Number of types of flowers :param flowers: List[Tuple[int, int]] - List of tuples where each tuple (t_i, b_i) represents type of flower and its beauty value :return: int - Maximum possible sum of beauty values # Unit Tests from your_solution_module import max_beauty def test_example_1(): assert max_beauty(4, [(1, 5), (2, 3), (1, 4), (3, 2)]) == 10 def test_example_2(): assert max_beauty(3, [(1, 10), (2, 5), (3, 7)]) == 22 def test_example_3(): assert max_beauty(5, [(3, 9), (2, 8), (3, 5), (1, 7), (2, 6)]) == 24 def test_single_flower_type(): assert max_beauty(1, [(1, 100)]) == 100 def test_all_same_type(): assert max_beauty(3, [(1, 10), (1, 20), (1, 30)]) == 30 def test_large_input(): flowers = [(i, i) for i in range(1, 200001)] assert max_beauty(200000, flowers) == sum(range(1, 200001))","solution":"def max_beauty(n, flowers): This function returns the maximum possible sum of beauty values, satisfying the condition that no two picked flowers should have the same type. :param n: int - Number of types of flowers :param flowers: List[Tuple[int, int]] - List of tuples where each tuple (t_i, b_i) represents type of flower and its beauty value :return: int - Maximum possible sum of beauty values # Dictionary to store the maximum beauty value for each flower type flower_dict = {} for t_i, b_i in flowers: if t_i in flower_dict: # Update the beauty value if the current one is larger flower_dict[t_i] = max(flower_dict[t_i], b_i) else: flower_dict[t_i] = b_i # Sum up the maximum beauty values of the unique types max_beauty_sum = sum(flower_dict.values()) return max_beauty_sum"},{"question":"def unique_paths(m: int, n: int, grid: List[str]) -> int: Given a grid of size MxN consisting of '.' (walkable cell) and '#' (non-walkable cell), find the number of unique paths from the top-left corner to the bottom-right corner. You can only move down or right at any point in time. You must ensure that paths do not pass through cells marked as '#'. Each cell can be visited only once in a path. >>> unique_paths(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> unique_paths(2, 2, [\\"..\\", \\"..\\"]) 2 >>> unique_paths(2, 2, [\\".#\\", \\"..\\"]) 1 >>> unique_paths(1, 1, [\\".\\"]) 1 >>> unique_paths(3, 3, [\\"...\\", \\"#\\", \\"...\\"]) 0 >>> unique_paths(3, 3, [\\".#.\\", \\".#.\\", \\"...\\"]) 1","solution":"def num_ways(grid): M = len(grid) N = len(grid[0]) if grid[0][0] == '#' or grid[M-1][N-1] == '#': return 0 dp = [[0] * N for _ in range(M)] dp[0][0] = 1 for i in range(M): for j in range(N): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[M-1][N-1] def unique_paths(m, n, grid): return num_ways(grid)"},{"question":"def spiralOrder(N: int, B: List[List[int]]) -> List[int]: Given a N * N square matrix B, return the spiral order traversal of its elements. Example 1: >>> N = 3 >>> B = [[ 1, 2, 3 ], ... [ 4, 5, 6 ], ... [ 7, 8, 9 ]] >>> spiralOrder(N, B) [1, 2, 3, 6, 9, 8, 7, 4, 5] Example 2: >>> N = 4 >>> B = [[ 1, 2, 3, 4 ], ... [ 5, 6, 7, 8 ], ... [ 9, 10, 11, 12 ], ... [ 13, 14, 15, 16 ]] >>> spiralOrder(N, B) [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10] pass","solution":"def spiralOrder(N, B): Returns the elements of the N x N matrix B in spiral order. result = [] if not B or N == 0: return result left, right, top, bottom = 0, N - 1, 0, N - 1 while left <= right and top <= bottom: # Traverse from left to right for j in range(left, right + 1): result.append(B[top][j]) top += 1 # Traverse from top to bottom for i in range(top, bottom + 1): result.append(B[i][right]) right -= 1 if top <= bottom: # Traverse from right to left for j in range(right, left - 1, -1): result.append(B[bottom][j]) bottom -= 1 if left <= right: # Traverse from bottom to top for i in range(bottom, top - 1, -1): result.append(B[i][left]) left += 1 return result"},{"question":"from typing import List, Tuple def max_marbles(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Find the maximum number of marbles Chef can pick without exceeding the points limit. Parameters: test_cases: List of tuples where each tuple contains an integer N (number of marbles), an integer P (maximum points limit), and a list of integers representing the points of each marble. Returns: List of integers representing the maximum number of marbles Chef can pick for each test case. >>> max_marbles([(3, 10, [4, 7, 2]), (5, 15, [1, 3, 5, 9, 4])]) [2, 4] >>> max_marbles([(4, 10, [2, 2, 2, 2])]) [4] >>> max_marbles([(1, 5, [5]), (1, 3, [5])]) [1, 0]","solution":"def max_marbles(test_cases): results = [] for N, P, points in test_cases: points.sort() current_sum = 0 marbles_count = 0 for point in points: if current_sum + point > P: break current_sum += point marbles_count += 1 results.append(marbles_count) return results"},{"question":"def adjust_visibility(friends: List[str], operations: List[str]) -> List[str]: Adjust the visibility of friends based on a dynamic blocklist and return the list of unblocked friends for each query. >>> adjust_visibility([\\"alice\\", \\"bob\\", \\"charlie\\", \\"dave\\", \\"eve\\"], [\\"block alice\\", \\"list\\", \\"block bob\\", \\"list\\", \\"unblock alice\\", \\"list\\"]) [\\"bob charlie dave eve\\", \\"charlie dave eve\\", \\"alice charlie dave eve\\"] >>> adjust_visibility([\\"john\\", \\"doe\\", \\"smith\\", \\"jane\\"], [\\"list\\"]) [\\"doe jane john smith\\"] >>> adjust_visibility([\\"alpha\\", \\"beta\\", \\"gamma\\", \\"delta\\"], [\\"block alpha\\", \\"block beta\\", \\"block gamma\\", \\"block delta\\", \\"list\\", \\"unblock alpha\\", \\"unblock beta\\", \\"unblock gamma\\", \\"unblock delta\\", \\"list\\"]) [\\"\\", \\"alpha beta delta gamma\\"] >>> adjust_visibility([\\"apple\\", \\"banana\\", \\"cherry\\"], [\\"block apple\\", \\"block apple\\", \\"list\\"]) [\\"banana cherry\\"] >>> adjust_visibility([\\"red\\", \\"green\\", \\"blue\\"], [\\"unblock red\\", \\"list\\"]) [\\"blue green red\\"]","solution":"def adjust_visibility(friends, operations): blocked = set() results = [] for operation in operations: parts = operation.split() if parts[0] == \\"block\\": blocked.add(parts[1]) elif parts[0] == \\"unblock\\": blocked.discard(parts[1]) elif parts[0] == \\"list\\": unblocked_friends = sorted(friend for friend in friends if friend not in blocked) results.append(\\" \\".join(unblocked_friends)) return results"},{"question":"def categorize_finishers(times): Categorizes participants into various time brackets and counts the number of participants in each bracket. :param times: List of finish times. :return: Dictionary with count of participants in each category. def marathon_results(m, n, times): Takes the input for marathon results and returns the formatted output. :param m: Track length (not used in processing). :param n: Number of participants. :param times: List of finish times. :return: Formatted result string. # Unit Tests import pytest def test_categorize_finishers(): times = [1.5, 3.2, 4.5, 2.9, 1.8] result = categorize_finishers(times) assert result[\\"Less than 2 hours\\"] == 2 assert result[\\"2 hours to 4 hours\\"] == 2 assert result[\\"More than 4 hours\\"] == 1 def test_marathon_results(): m, n = 10, 5 times = [1.5, 3.2, 4.5, 2.9, 1.8] result = marathon_results(m, n, times) expected_output = (\\"Less than 2 hours: 2n\\" \\"2 hours to 4 hours: 2n\\" \\"More than 4 hours: 1\\") assert result == expected_output def test_all_finishers_in_one_bracket(): m, n = 5, 3 times = [2.1, 4.0, 2.5] result = marathon_results(m, n, times) expected_output = (\\"Less than 2 hours: 0n\\" \\"2 hours to 4 hours: 3n\\" \\"More than 4 hours: 0\\") assert result == expected_output def test_no_finishers(): m, n = 5, 0 times = [] result = marathon_results(m, n, times) expected_output = (\\"Less than 2 hours: 0n\\" \\"2 hours to 4 hours: 0n\\" \\"More than 4 hours: 0\\") assert result == expected_output def test_edge_cases(): m, n = 5, 5 times = [2.0, 4.0, 1.999, 4.001, 3.5] result = marathon_results(m, n, times) expected_output = (\\"Less than 2 hours: 1n\\" \\"2 hours to 4 hours: 3n\\" \\"More than 4 hours: 1\\") assert result == expected_output","solution":"def categorize_finishers(times): Categorizes participants into various time brackets and counts the number of participants in each bracket. :param times: List of finish times. :return: Dictionary with count of participants in each category. brackets = { \\"Less than 2 hours\\": 0, \\"2 hours to 4 hours\\": 0, \\"More than 4 hours\\": 0 } for time in times: if time < 2: brackets[\\"Less than 2 hours\\"] += 1 elif time <= 4: brackets[\\"2 hours to 4 hours\\"] += 1 else: brackets[\\"More than 4 hours\\"] += 1 return brackets def marathon_results(m, n, times): Takes the input for marathon results and returns the formatted output. :param m: Track length (not used in processing). :param n: Number of participants. :param times: List of finish times. :return: Formatted result string. brackets = categorize_finishers(times) result = ( f\\"Less than 2 hours: {brackets['Less than 2 hours']}n\\" f\\"2 hours to 4 hours: {brackets['2 hours to 4 hours']}n\\" f\\"More than 4 hours: {brackets['More than 4 hours']}\\" ) return result"},{"question":"def subarray_sums(T: int, test_cases: List[Tuple[int, int, List[int], List[Tuple[int, int]]]]) -> List[int]: This function takes in the number of test cases, along with each test case containing the number of elements in the array, number of queries, the array itself and the list of queries. It returns a list of sum of subarrays for each query in each test case. >>> subarray_sums(1, [(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 5), (1, 5)])]) [6, 14, 15] >>> subarray_sums(2, [(6, 2, [10, 20, 30, 40, 50, 60], [(1, 2), (3, 6)]), (5, 2, [5, 1, 3, 2, 4], [(1, 4), (2, 5)])]) [30, 180, 11, 10]","solution":"def subarray_sums(T, test_cases): results = [] for case in test_cases: N, Q, A, queries = case # Compute prefix sums prefix_sums = [0] * (N + 1) for i in range(1, N + 1): prefix_sums[i] = prefix_sums[i - 1] + A[i - 1] # Process each query for L, R in queries: result = prefix_sums[R] - prefix_sums[L - 1] results.append(result) return results"},{"question":"def longest_equal_even_odd_subarray(arr: List[int]) -> int: Returns the length of the longest contiguous subarray with an equal number of even and odd numbers. >>> longest_equal_even_odd_subarray([1, 2, 3, 4, 5, 6]) 6 >>> longest_equal_even_odd_subarray([1, 1, 1, 2, 2, 2, 3, 3, 3]) 6 >>> longest_equal_even_odd_subarray([1, 3, 5]) 0 >>> longest_equal_even_odd_subarray([2, 4, 6]) 0 >>> longest_equal_even_odd_subarray([1, 2, 1, 2, 1, 2]) 6 >>> longest_equal_even_odd_subarray([1]) 0 >>> longest_equal_even_odd_subarray([2]) 0 >>> longest_equal_even_odd_subarray([2, 3]) 2 >>> longest_equal_even_odd_subarray([1, 2]) 2 >>> longest_equal_even_odd_subarray([]) 0","solution":"def longest_equal_even_odd_subarray(arr): Returns the length of the longest contiguous subarray with an equal number of even and odd numbers. n = len(arr) if n == 0: return 0 # Calculate the prefix sums where we convert even to +1 and odd to -1. prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i+1] = prefix_sum[i] + (1 if arr[i] % 2 == 0 else -1) # Map to store the first occurrence of a given prefix_sum value first_occurrence = {} max_length = 0 for i in range(n + 1): if prefix_sum[i] in first_occurrence: max_length = max(max_length, i - first_occurrence[prefix_sum[i]]) else: first_occurrence[prefix_sum[i]] = i return max_length"},{"question":"def is_valid_appointment(existing_appointments, new_appointment): Returns True if the new appointment does not overlap with existing appointments, otherwise False. Parameters: existing_appointments (list of tuples): A list of tuples where each tuple represents an appointment with (start_time, end_time) new_appointment (tuple): A tuple representing the new appointment with (start_time, end_time) Returns: bool: True if the new appointment does not overlap with existing appointments, otherwise False. pass def test_no_overlap(): assert is_valid_appointment([(9, 11), (13, 15), (16, 18)], (11, 13)) == True def test_overlap_single_appointment(): assert is_valid_appointment([(9, 11)], (10, 12)) == False def test_overlap_multiple_appointments(): assert is_valid_appointment([(9, 11), (10, 12), (13, 15)], (11, 14)) == False def test_overlap_boundary_case(): assert is_valid_appointment([(9, 11), (12, 15)], (11, 12)) == True def test_overlap_within_same_appointment(): assert is_valid_appointment([(10, 15)], (12, 14)) == False def test_no_appointments(): assert is_valid_appointment([], (10, 11)) == True","solution":"def is_valid_appointment(existing_appointments, new_appointment): Returns True if the new appointment does not overlap with existing appointments, otherwise False. Parameters: existing_appointments (list of tuples): A list of tuples where each tuple represents an appointment with (start_time, end_time) new_appointment (tuple): A tuple representing the new appointment with (start_time, end_time) Returns: bool: True if the new appointment does not overlap with existing appointments, otherwise False. new_start, new_end = new_appointment for existing_start, existing_end in existing_appointments: if not (new_end <= existing_start or new_start >= existing_end): return False return True"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Finds the contiguous subarray with the largest sum. Parameters: arr (list of int): The input array of integers. Returns: int: The sum of the contiguous subarray with the largest sum. >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([-2, -3, -1, -4]) -1 >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> large_input = [100000]*100000 >>> max_subarray_sum(large_input) 10000000000 >>> max_subarray_sum([0, -1, 2, -3, 4, -5]) 4","solution":"def max_subarray_sum(arr): Finds the contiguous subarray with the largest sum. Parameters: arr (list of int): The input array of integers. Returns: int: The sum of the contiguous subarray with the largest sum. max_end_here = max_so_far = arr[0] for num in arr[1:]: max_end_here = max(num, max_end_here + num) max_so_far = max(max_so_far, max_end_here) return max_so_far"},{"question":"def process_commands(n: int, commands: List[str]) -> List[int]: Process a series of commands to manipulate a list of integers. Each command is either an insertion, deletion, or query operation. The commands are structured as follows: - \\"insert x\\": Insert the integer x at the end of the list. - \\"delete x\\": Remove the first occurrence of the integer x from the list. If the integer is not found, do nothing. - \\"query x\\": Return the number of occurrences of the integer x in the list. Args: n (int): The number of commands. commands (List[str]): A list of commands to be processed. Returns: List[int]: A list containing results of the \\"query\\" commands. Example: >>> process_commands(5, [\\"insert 5\\", \\"insert 3\\", \\"query 5\\", \\"delete 5\\", \\"query 5\\"]) [1, 0] >>> process_commands(6, [\\"insert 2\\", \\"insert 2\\", \\"insert 3\\", \\"query 2\\", \\"delete 2\\", \\"query 2\\"]) [2, 1]","solution":"def process_commands(n, commands): result = [] lst = [] for command in commands: parts = command.split() cmd, x = parts[0], int(parts[1]) if cmd == \\"insert\\": lst.append(x) elif cmd == \\"delete\\": if x in lst: lst.remove(x) elif cmd == \\"query\\": result.append(lst.count(x)) return result"},{"question":"def is_binary_palindrome(s: str) -> bool: Determine if the given binary string s is a palindrome without using extra space for another string. >>> is_binary_palindrome(\\"101\\") == True >>> is_binary_palindrome(\\"1001\\") == True >>> is_binary_palindrome(\\"110\\") == False def test_is_binary_palindrome(): assert is_binary_palindrome(\\"101\\") == True assert is_binary_palindrome(\\"1001\\") == True assert is_binary_palindrome(\\"110\\") == False assert is_binary_palindrome(\\"0\\") == True assert is_binary_palindrome(\\"1\\") == True assert is_binary_palindrome(\\"11\\") == True assert is_binary_palindrome(\\"10\\") == False assert is_binary_palindrome(\\"10101\\") == True assert is_binary_palindrome(\\"1001001\\") == True assert is_binary_palindrome(\\"100101\\") == False","solution":"def is_binary_palindrome(s): Returns True if the given binary string is a palindrome, otherwise False. left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return False left += 1 right -= 1 return True"},{"question":"def min_operations_to_sort(arr): Return the minimum number of operations required to make the array non-decreasing by performing adjacent swaps when necessary. Args: arr (List[int]): The input array of integers Returns: int: The minimum number of adjacent swaps Examples: >>> min_operations_to_sort([3, 2, 1, 5, 4]) 4 >>> min_operations_to_sort([1, 3, 2, 4]) 1 >>> min_operations_to_sort([1, 2, 3, 4, 5]) 0 >>> min_operations_to_sort([5, 4, 3, 2, 1]) 10 >>> min_operations_to_sort([4, 3, 1, 5, 2]) 6","solution":"def min_operations_to_sort(arr): Return the minimum number of operations required to make the array non-decreasing by performing adjacent swaps when necessary. n = len(arr) operations = 0 while True: swapped = False for i in range(n - 1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] operations += 1 swapped = True if not swapped: break return operations"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Process a list of queries on an initial array with two types of operations: update and sum range. Args: n (int): Size of the initial array. q (int): Number of queries. array (List[int]): List of initial integers of size N. queries (List[Tuple[int, int, int]]): List of queries. Each query can be one of the following: - (1, i, x): Update the value at position i to x. - (2, l, r): Find the sum of the elements from position l to r (inclusive). Returns: List[int]: List of results for sum queries. >>> process_queries(5, 5, [1, 2, 3, 4, 5], [(2, 0, 4), (1, 3, 10), (2, 1, 3), (1, 0, 6), (2, 0, 2)]) [15, 19, 12] >>> process_queries(3, 3, [1, 1, 1], [(2, 0, 2), (1, 1, 2), (2, 0, 1)]) [3, 3]","solution":"def process_queries(n, q, array, queries): # Initialize prefix sum array prefix_sum = [0] * (n + 1) # Build the initial prefix sum array for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + array[i] result = [] for query in queries: if query[0] == 1: # Update operation _, i, x = query current_value = array[i] array[i] = x diff = x - current_value for j in range(i + 1, n + 1): prefix_sum[j] += diff elif query[0] == 2: # Sum range operation _, l, r = query sum_value = prefix_sum[r + 1] - prefix_sum[l] result.append(sum_value) return result"},{"question":"def max_difference(n: int, arr: List[int]) -> int: Finds the maximum difference d between any two elements in the list such that the larger element appears after the smaller element. If no such pair exists, return -1. >>> max_difference(5, [2, 3, 10, 2, 4, 8, 1]) 8 >>> max_difference(4, [7, 9, 5, 6]) 2 >>> max_difference(3, [4, 3, 2]) -1 >>> max_difference(1, [5]) -1 >>> max_difference(4, [10, 9, 8, 7]) -1 >>> max_difference(5, [1, 2, 3, 4, 5]) 4 >>> max_difference(7, [1, 2, 90, 10, 110, 1, 101]) 109 >>> max_difference(4, [5, 5, 5, 5]) -1 >>> max_difference(2, [1, 10]) 9 >>> max_difference(2, [10, 1]) -1","solution":"def max_difference(n, arr): Finds the maximum difference d between any two elements in the list such that the larger element appears after the smaller element. If no such pair exists, return -1. if n < 2: return -1 min_element = arr[0] max_diff = -1 for i in range(1, n): if arr[i] > min_element: max_diff = max(max_diff, arr[i] - min_element) else: min_element = arr[i] return max_diff"},{"question":"def isIsomorphic(str1: str, str2: str) -> bool: Determines if two strings are isomorphic. Two strings are isomorphic if the characters in str1 can be replaced to get str2, with each character mapping to exactly one other character. Parameters: str1 (str): First string of length n str2 (str): Second string of length n Returns: bool: True if the strings are isomorphic, False otherwise Examples: >>> isIsomorphic(\\"egg\\", \\"add\\") True >>> isIsomorphic(\\"foo\\", \\"bar\\") False >>> isIsomorphic(\\"paper\\", \\"title\\") True pass","solution":"def isIsomorphic(str1, str2): Determines if two strings are isomorphic. Parameters: str1 (str): First string of length n str2 (str): Second string of length n Returns: bool: True if the strings are isomorphic, False otherwise if len(str1) != len(str2): return False mapping_str1_to_str2 = {} mapping_str2_to_str1 = {} for c1, c2 in zip(str1, str2): if c1 in mapping_str1_to_str2: if mapping_str1_to_str2[c1] != c2: return False else: mapping_str1_to_str2[c1] = c2 if c2 in mapping_str2_to_str1: if mapping_str2_to_str1[c2] != c1: return False else: mapping_str2_to_str1[c2] = c1 return True"},{"question":"def max_gems(grid): Determine the maximum number of gems David can collect on his journey from the top-left to the bottom-right corner of the grid. Args: grid: List[List[int]] - A 2D grid where each cell contains a non-negative integer representing the number of gems in that cell. Returns: int - The maximum number of gems that can be collected. Examples: >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> max_gems(grid) 12 >>> grid = [ ... [1, 2, 3, 4] ... ] >>> max_gems(grid) 10 >>> grid = [ ... [1], ... [2], ... [3], ... [4] ... ] >>> max_gems(grid) 10 >>> grid = [ ... [1, 2], ... [1, 3] ... ] >>> max_gems(grid) 6 >>> grid = [ ... [0, 0], ... [0, 0] ... ] >>> max_gems(grid) 0","solution":"def max_gems(grid): m = len(grid) n = len(grid[0]) # Create a DP table initialized with zeros dp = [[0] * n for _ in range(m)] # Initialize the first cell dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from the top) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner contains the maximum number of gems that can be collected return dp[m-1][n-1]"},{"question":"from datetime import datetime from typing import List, Tuple def most_sighted_animal(logs: List[Tuple[str, str, str]], start_time: str, end_time: str) -> str: Returns the unique ID of the animal that was sighted the most times in the given time period. If there is a tie, returns the animal ID that appears first in alphabetical order. Parameters: logs (List[Tuple[str, str, str]]): List of tuples containing the timestamp, unique animal ID, and location. start_time (str): Start time of the period (inclusive) in format \\"YYYY-MM-DD HH:MM:SS\\". end_time (str): End time of the period (inclusive) in format \\"YYYY-MM-DD HH:MM:SS\\". Returns: str: The unique ID of the most sighted animal in the given time period. pass # Example test cases def test_most_sighted_animal_single_sighting(): logs = [ (\\"2023-01-01 12:00:00\\", \\"ELEPHANT\\", \\"Zone A\\"), ] start_time = \\"2023-01-01 00:00:00\\" end_time = \\"2023-01-01 23:59:59\\" assert most_sighted_animal(logs, start_time, end_time) == \\"ELEPHANT\\" def test_most_sighted_animal_tie(): logs = [ (\\"2023-01-01 12:00:00\\", \\"ELEPHANT\\", \\"Zone A\\"), (\\"2023-01-01 14:00:00\\", \\"TIGER\\", \\"Zone B\\"), ] start_time = \\"2023-01-01 00:00:00\\" end_time = \\"2023-01-01 23:59:59\\" assert most_sighted_animal(logs, start_time, end_time) == \\"ELEPHANT\\" def test_most_sighted_animal_multiple_sightings(): logs = [ (\\"2023-01-01 12:00:00\\", \\"ELEPHANT\\", \\"Zone A\\"), (\\"2023-01-01 14:00:00\\", \\"TIGER\\", \\"Zone B\\"), (\\"2023-01-02 09:00:00\\", \\"ELEPHANT\\", \\"Zone A\\"), (\\"2023-01-01 15:00:00\\", \\"ZEBRA\\", \\"Zone C\\"), (\\"2023-01-01 16:00:00\\", \\"TIGER\\", \\"Zone B\\"), (\\"2023-01-02 10:00:00\\", \\"ELEPHANT\\", \\"Zone A\\") ] start_time = \\"2023-01-01 00:00:00\\" end_time = \\"2023-01-01 23:59:59\\" assert most_sighted_animal(logs, start_time, end_time) == \\"TIGER\\" def test_most_sighted_animal_different_period(): logs = [ (\\"2023-01-01 12:00:00\\", \\"ELEPHANT\\", \\"Zone A\\"), (\\"2023-01-01 14:00:00\\", \\"TIGER\\", \\"Zone B\\"), (\\"2023-01-02 09:00:00\\", \\"ELEPHANT\\", \\"Zone A\\"), (\\"2023-01-01 15:00:00\\", \\"ZEBRA\\", \\"Zone C\\"), (\\"2023-01-01 16:00:00\\", \\"TIGER\\", \\"Zone B\\"), (\\"2023-01-02 10:00:00\\", \\"ELEPHANT\\", \\"Zone A\\") ] start_time = \\"2023-01-02 00:00:00\\" end_time = \\"2023-01-02 23:59:59\\" assert most_sighted_animal(logs, start_time, end_time) == \\"ELEPHANT\\" def test_most_sighted_animal_covers_multiple_days(): logs = [ (\\"2023-01-01 12:00:00\\", \\"ELEPHANT\\", \\"Zone A\\"), (\\"2023-01-01 14:00:00\\", \\"TIGER\\", \\"Zone B\\"), (\\"2023-01-02 09:00:00\\", \\"ELEPHANT\\", \\"Zone A\\"), (\\"2023-01-01 15:00:00\\", \\"ZEBRA\\", \\"Zone C\\"), (\\"2023-01-01 16:00:00\\", \\"TIGER\\", \\"Zone B\\"), (\\"2023-01-02 10:00:00\\", \\"ELEPHANT\\", \\"Zone A\\"), (\\"2023-01-01 17:00:00\\", \\"ELEPHANT\\", \\"Zone A\\") ] start_time = \\"2023-01-01 00:00:00\\" end_time = \\"2023-01-02 23:59:59\\" assert most_sighted_animal(logs, start_time, end_time) == \\"ELEPHANT\\"","solution":"from collections import defaultdict from datetime import datetime def most_sighted_animal(logs, start_time, end_time): Returns the unique ID of the animal that was sighted the most times in the given time period. If there is a tie, returns the animal ID that appears first in alphabetical order. sighting_counts = defaultdict(int) start_time = datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_time = datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") for timestamp, animal_id, location in logs: sighting_time = datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\") if start_time <= sighting_time <= end_time: sighting_counts[animal_id] += 1 if not sighting_counts: return None most_sighted = sorted(sighting_counts.items(), key=lambda x: (-x[1], x[0])) return most_sighted[0][0]"},{"question":"def min_operations_to_equal_array(n: int, array: List[int]) -> int: Determines the smallest number of operations required to make all the elements equal. Args: n (int): The number of elements in the array. array (List[int]): The elements of the array. Returns: int: The minimum number of operations required. Examples: >>> min_operations_to_equal_array(3, [2, 2, 2]) 0 >>> min_operations_to_equal_array(5, [1, 2, 3, 4, 5]) 4","solution":"from collections import Counter def min_operations_to_equal_array(n, array): Determines the smallest number of operations required to make all the elements equal. counts = Counter(array) max_frequency = max(counts.values()) return n - max_frequency"},{"question":"def make_diverse(s: str) -> str: Converts the input string into a diverse string where no characters appear more than once consecutively by inserting the minimum number of characters. :param s: Input string of lowercase letters :return: A diverse string >>> make_diverse(\\"aabb\\") 'ababab' >>> make_diverse(\\"aaab\\") 'ababab' >>> make_diverse(\\"abcd\\") 'abcd' >>> make_diverse(\\"aaaa\\") 'abacada' # You can add appropriate logic to complete the function based on the requirements. from solution import make_diverse def test_example1(): assert make_diverse(\\"aabb\\") == \\"ababab\\" def test_example2(): assert make_diverse(\\"aaab\\") == \\"ababab\\" def test_example3(): assert make_diverse(\\"abcd\\") == \\"abcd\\" def test_example4(): result = make_diverse(\\"aaaa\\") assert len(result) == 7 assert all(result[i] != result[i + 1] for i in range(len(result) - 1)) def test_single_char(): assert make_diverse(\\"a\\") == \\"a\\" def test_already_diverse(): assert make_diverse(\\"abc\\") == \\"abc\\" def test_end_same_as_start(): result = make_diverse(\\"abababa\\") assert all(result[i] != result[i + 1] for i in range(len(result) - 1)) def test_long_repetitive_string(): result = make_diverse(\\"aaaaaa\\") assert all(result[i] != result[i + 1] for i in range(len(result) - 1)) def test_consecutive_repeats(): result = make_diverse(\\"aabbaa\\") assert all(result[i] != result[i + 1] for i in range(len(result) - 1))","solution":"def make_diverse(s): Converts the input string into a diverse string where no characters appear more than once consecutively by inserting the minimum number of characters. :param s: Input string of lowercase letters :return: A diverse string if not s: return \\"\\" result = [s[0]] for i in range(1, len(s)): if s[i] == s[i - 1]: alternative_char = 'a' while alternative_char == s[i] or (result and alternative_char == result[-1]): alternative_char = chr(ord(alternative_char) + 1) result.append(alternative_char) result.append(s[i]) return ''.join(result)"},{"question":"from typing import List def matrix_multiply(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: Multiplies two matrices if possible and returns the resultant matrix. If matrix multiplication is not possible, returns an empty list. >>> matrix_multiply([[1, 2, 3], [4, 5, 6]], [[7, 8], [9, 10], [11, 12]]) [[58, 64], [139, 154]] >>> matrix_multiply([[1, 2], [3, 4]], [[1, 2], [3, 4], [5, 6]]) [] >>> matrix_multiply([], [[1, 2], [3, 4]]) [] >>> matrix_multiply([[1, 2], [3, 4]], []) [] >>> matrix_multiply([[2]], [[3]]) [[6]] >>> matrix_multiply([[1, 2, 3], [4, 5, 6]], [[7, 8, 9, 10], [11, 12, 13, 14], [15, 16, 17, 18]]) [[74, 80, 86, 92], [173, 188, 203, 218]]","solution":"def matrix_multiply(matrix_a, matrix_b): Multiplies two matrices if possible and returns the resultant matrix. If matrix multiplication is not possible, returns an empty list. # Number of rows and columns in matrix_a rows_a, cols_a = len(matrix_a), len(matrix_a[0]) if matrix_a else 0 # Number of rows and columns in matrix_b rows_b, cols_b = len(matrix_b), len(matrix_b[0]) if matrix_b else 0 # Check if matrix multiplication is possible if cols_a != rows_b: return [] # Resultant matrix initialized to zero result = [[0 for _ in range(cols_b)] for _ in range(rows_a)] # Perform matrix multiplication for i in range(rows_a): for j in range(cols_b): for k in range(cols_a): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"def is_balanced_string(S: str, T: int) -> str: Determines if a string S is balanced with respect to threshold T. Parameters: S (str): the string to check. T (int): the threshold for the maximum occurrences of any character in any prefix. Returns: str: \\"YES\\" if the string is balanced, \\"NO\\" otherwise. >>> is_balanced_string(\\"abac\\", 2) \\"YES\\" >>> is_balanced_string(\\"aa\\", 1) \\"NO\\" >>> is_balanced_string(\\"aabbbcc\\", 3) \\"YES\\" pass def process_queries(queries: List[Tuple[int, str]]) -> List[str]: Process multiple queries to determine if strings are balanced. Parameters: queries (list of tuples): each tuple contains (T, S) where T is the threshold and S is the string. Returns: list of str: the results for each query (\\"YES\\" or \\"NO\\"). pass def test_is_balanced_string(): assert is_balanced_string(\\"abac\\", 2) == \\"YES\\" assert is_balanced_string(\\"aa\\", 1) == \\"NO\\" assert is_balanced_string(\\"aabbbcc\\", 3) == \\"YES\\" assert is_balanced_string(\\"abc\\", 1) == \\"YES\\" assert is_balanced_string(\\"aaaa\\", 3) == \\"NO\\" assert is_balanced_string(\\"abcabc\\", 2) == \\"YES\\" def test_process_queries(): queries = [ (2, \\"abac\\"), (1, \\"aa\\"), (3, \\"aabbbcc\\") ] expected_results = [\\"YES\\", \\"NO\\", \\"YES\\"] assert process_queries(queries) == expected_results queries = [ (1, \\"abcd\\"), (2, \\"aabbccdd\\"), (3, \\"aaabbbccc\\") ] expected_results = [\\"YES\\", \\"YES\\", \\"YES\\"] assert process_queries(queries) == expected_results queries = [ (1, \\"a\\"), (2, \\"b\\"), (3, \\"c\\") ] expected_results = [\\"YES\\", \\"YES\\", \\"YES\\"] assert process_queries(queries) == expected_results if __name__ == \\"__main__\\": test_is_balanced_string() test_process_queries() print(\\"All tests passed!\\")","solution":"def is_balanced_string(S, T): Determines if a string S is balanced with respect to threshold T. Parameters: S (str): the string to check. T (int): the threshold for the maximum occurrences of any character in any prefix. Returns: str: \\"YES\\" if the string is balanced, \\"NO\\" otherwise. from collections import defaultdict # Dictionary to store counts of characters count = defaultdict(int) # Iterate over the string, keeping count of characters for i in range(len(S)): count[S[i]] += 1 # If any character count exceeds the threshold, return \\"NO\\" if count[S[i]] > T: return \\"NO\\" # If no character exceeds the threshold, return \\"YES\\" return \\"YES\\" def process_queries(queries): Process multiple queries to determine if strings are balanced. Parameters: queries (list of tuples): each tuple contains (T, S) where T is the threshold and S is the string. Returns: list of str: the results for each query (\\"YES\\" or \\"NO\\"). results = [] for T, S in queries: results.append(is_balanced_string(S, T)) return results"},{"question":"def redistribute_marbles(N: int, marbles: List[int]) -> Tuple[str, List[Tuple[int, int]]]: Determines if it is possible to redistribute marbles equally among containers and provides the moves to do so. :param N: Integer, the number of containers. :param marbles: List of integers, the number of marbles in each container. :return: Tuple, (String, List of moves (tuple of 2 integers)), or (\\"NO\\", []) if redistribution is not possible. >>> redistribute_marbles(3, [1, 2, 3]) ('YES', [(1, 2), (2, 3)]) >>> redistribute_marbles(3, [1, 1, 1]) ('YES', []) >>> redistribute_marbles(2, [4, 1]) ('NO', []) >>> redistribute_marbles(5, [2, 6, 4, 10, 3]) ('YES', [(4, 5), (3, 4), (3, 4), (2, 3), (2, 3), (1, 2)]) >>> redistribute_marbles(4, [1, 2, 3, 5]) ('NO', [])","solution":"def redistribute_marbles(N, marbles): Determines if it is possible to redistribute marbles equally among containers and provides the moves to do so. :param N: Integer, the number of containers. :param marbles: List of integers, the number of marbles in each container. :return: Tuple, (String, List of moves (tuple of 2 integers)), or (\\"NO\\", []) if redistribution is not possible. total_marbles = sum(marbles) # Check if it is possible to redistribute marbles equally if total_marbles % N != 0: return \\"NO\\", [] target = total_marbles // N moves = [] for i in range(1, N): while marbles[i-1] > target: marbles[i-1] -= 1 marbles[i] += 1 moves.append((i, i + 1)) while marbles[i-1] < target: marbles[i-1] += 1 marbles[i] -= 1 moves.append((i + 1, i)) # Verify that all marbles are now equal to the target value for marble_count in marbles: if marble_count != target: return \\"NO\\", [] return \\"YES\\", moves"},{"question":"def capture_trees(t: int, test_cases: List[str]) -> List[str]: Returns the lexicographically smallest sequence of captured substrings that maximizes the diversity of tree types in each substring for each test case. :param t: Number of test cases :param test_cases: A list of strings, each representing a row of trees :return: A list of strings with the desired substring sequence for each test case >>> capture_trees(3, [\\"oxoxoxox\\", \\"efedcba\\", \\"abcdefgh\\"]) == [\\"ox\\", \\"abcdef\\", \\"abcdefgh\\"] >>> capture_trees(2, [\\"aaaa\\", \\"z\\"]) == [\\"a\\", \\"z\\"] from capture_trees import capture_trees def test_capture_trees_multiple_cases(): assert capture_trees(3, [\\"oxoxoxox\\", \\"efedcba\\", \\"abcdefgh\\"]) == [\\"ox\\", \\"abcdef\\", \\"abcdefgh\\"] def test_capture_trees_single_letter(): assert capture_trees(2, [\\"aaaa\\", \\"z\\"]) == [\\"a\\", \\"z\\"] def test_capture_trees_repeated_letters(): assert capture_trees(1, [\\"ttttttrrrr\\"]) == [\\"rt\\"] def test_capture_trees_mixed_pattern(): assert capture_trees(2, [\\"abcabcabc\\", \\"bacbacbac\\"]) == [\\"abc\\", \\"abc\\"] def test_capture_trees_already_sorted(): assert capture_trees(1, [\\"abcdef\\"]) == [\\"abcdef\\"] def test_capture_trees_reverse_sorted(): assert capture_trees(1, [\\"gfedcba\\"]) == [\\"abcdefg\\"]","solution":"def capture_trees(t, test_cases): Returns the lexicographically smallest sequence of captured substrings that maximizes the diversity of tree types in each substring for each test case. :param t: Number of test cases :param test_cases: A list of strings, each representing a row of trees :return: A list of strings with the desired substring sequence for each test case results = [] for trees in test_cases: unique_trees = sorted(set(trees)) result = ''.join(unique_trees) results.append(result) return results"},{"question":"def gcd(a, b): Find the greatest common divisor (GCD) of two numbers. >>> gcd(12, 15) 3 >>> gcd(10, 5) 5 >>> gcd(7, 3) 1 while b: a, b = b, a % b return a def can_reach(L, S, D): Determine if Mary can reach exactly position \`D\` using a combination of long and short jumps. >>> can_reach(3, 5, 13) True >>> can_reach(4, 6, 11) False >>> can_reach(7, 2, 14) True g = gcd(L, S) return D % g == 0 def mary_jumps(T, test_cases): Determine if Mary can reach exactly position \`D\` for each test case. >>> mary_jumps(3, [(3, 5, 13), (4, 6, 11), (7, 2, 14)]) [\\"YES\\", \\"NO\\", \\"YES\\"] results = [] for L, S, D in test_cases: if can_reach(L, S, D): results.append(\\"YES\\") else: results.append(\\"NO\\") return results","solution":"def gcd(a, b): while b: a, b = b, a % b return a def can_reach(L, S, D): # Find the greatest common divisor (GCD) of L and S g = gcd(L, S) # Check if D is divisible by the GCD of L and S return D % g == 0 def mary_jumps(T, test_cases): results = [] for L, S, D in test_cases: if can_reach(L, S, D): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Sample test cases provided in the problem statement sample_input = [ (3, 5, 13), (4, 6, 11), (7, 2, 14) ]"},{"question":"def can_all_cars_park(n: int, k: int, timings: List[Tuple[int, int]]) -> str: Determines if all cars can park without waiting in a parking lot with maximum K parking spots. Parameters: n (int): Number of cars. k (int): Maximum number of cars that can be parked at the same time. timings (List[Tuple[int, int]]): List of tuples where each tuple contains arrival and departure times of a car. Returns: str: \\"Yes\\" if all cars can park without waiting, otherwise \\"No\\". >>> can_all_cars_park(3, 2, [(1, 4), (2, 5), (5, 8)]) == \\"Yes\\" >>> can_all_cars_park(3, 1, [(1, 4), (2, 5), (5, 8)]) == \\"No\\" >>> can_all_cars_park(5, 3, [(1, 10), (2, 9), (3, 8), (4, 7), (5, 6)]) == \\"No\\" >>> can_all_cars_park(4, 2, [(5, 10), (6, 9), (11, 15), (16, 20)]) == \\"Yes\\"","solution":"def can_all_cars_park(n, k, timings): Determines if all cars can park without waiting in a parking lot with maximum K parking spots. Parameters: n (int): Number of cars. k (int): Maximum number of cars that can be parked at the same time. timings (List[Tuple[int, int]]): List of tuples where each tuple contains arrival and departure times of a car. Returns: str: \\"Yes\\" if all cars can park without waiting, otherwise \\"No\\". events = [] for arrival, departure in timings: events.append((arrival, 'arrival')) events.append((departure, 'departure')) events.sort() current_cars = 0 for time, event in events: if event == 'arrival': current_cars += 1 if current_cars > k: return \\"No\\" else: current_cars -= 1 return \\"Yes\\""},{"question":"def maxUniqueSubarray(arr: List[int], k: int) -> int: Returns the maximum number of unique integers seen consecutively in a window of size k. Args: arr (List[int]): List of integers. k (int): Size of the window. Returns: int: Maximum number of unique integers in a window of size k. >>> maxUniqueSubarray([1, 2, 1, 3, 4, 2, 3], 4) 4 >>> maxUniqueSubarray([4, 1, 1, 3, 1, 1, 4], 3) 2 import unittest class TestMaxUniqueSubarray(unittest.TestCase): def test_example1(self): arr = [1, 2, 1, 3, 4, 2, 3] k = 4 self.assertEqual(maxUniqueSubarray(arr, k), 4) def test_example2(self): arr = [4, 1, 1, 3, 1, 1, 4] k = 3 self.assertEqual(maxUniqueSubarray(arr, k), 2) def test_small_window(self): arr = [1, 2, 3, 4, 5] k = 1 self.assertEqual(maxUniqueSubarray(arr, k), 1) def test_full_window(self): arr = [1, 2, 3, 4, 5] k = 5 self.assertEqual(maxUniqueSubarray(arr, k), 5) def test_all_same_elements(self): arr = [5, 5, 5, 5, 5] k = 3 self.assertEqual(maxUniqueSubarray(arr, k), 1) def test_window_larger_than_list(self): arr = [5, 6, 7, 8, 9] k = 6 self.assertEqual(maxUniqueSubarray(arr, k), 0) if __name__ == \\"__main__\\": unittest.main()","solution":"def maxUniqueSubarray(arr, k): Returns the maximum number of unique integers seen consecutively in a window of size k. if len(arr) < k: return 0 max_unique = 0 window_counter = {} unique_count = 0 # Initialize the first window for i in range(k): if arr[i] in window_counter: window_counter[arr[i]] += 1 else: window_counter[arr[i]] = 1 unique_count += 1 max_unique = unique_count # Slide the window for i in range(k, len(arr)): # Remove the element that is sliding out of the window if window_counter[arr[i - k]] == 1: unique_count -= 1 window_counter[arr[i - k]] -= 1 if window_counter[arr[i - k]] == 0: del window_counter[arr[i - k]] # Add the new element if arr[i] in window_counter: window_counter[arr[i]] += 1 else: window_counter[arr[i]] = 1 unique_count += 1 # Update the max unique count max_unique = max(max_unique, unique_count) return max_unique"},{"question":"def max_beauty_of_sequence(n: int, sequence: List[int]) -> int: Calculate the maximum beauty of the sequence after performing the operations such as reversing any subsequence. >>> max_beauty_of_sequence(5, [1, 3, 2, 5, 4]) 5 >>> max_beauty_of_sequence(4, [4, 3, 2, 1]) 4 >>> max_beauty_of_sequence(6, [10, 1, 10, 2, 1, 10]) 30","solution":"def max_beauty_of_sequence(n, sequence): # For any given sequence, to maximize the beauty, we should make highest values the peaks if n == 1: return sequence[0] max_value = max(sequence) # maximum beauty of the sequence is when every peak is the max element and considering reversing operations, # the length of the sequence can be achieved such that every max_value is a peak return max_value * 2 if sequence.count(max_value) > 1 else max_value"},{"question":"from typing import List def calculate_water_trapped(heights: List[int]) -> int: Calculate the total amount of water that can be collected after it rains between reservoirs. :param heights: List of integers representing the height of the reservoirs. :return: Total amount of water collected. >>> calculate_water_trapped([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> calculate_water_trapped([3, 0, 2, 0, 4]) 7 >>> calculate_water_trapped([0, 0, 0, 0]) 0 def process_input(input_lines: List[str]) -> List[int]: Process multiple lines of input to calculate total water collected for each dataset. :param input_lines: List of input lines. :return: List of integers where each integer represents the total water collected for each dataset. >>> process_input([\\"0 1 0 2 1 0 1 3 2 1 2 1\\", \\"3 0 2 0 4\\", \\"0 0 0 0\\", \\"0\\"]) [6, 7, 0] >>> process_input([\\"4 2 0 3 2 5\\", \\"1 1 1 1\\", \\"5 4 1 2\\", \\"0\\"]) [9, 0, 1]","solution":"def calculate_water_trapped(heights): Calculate the total amount of water that can be trapped between the reservoirs after it rains. :param heights: List of integers representing the height of the reservoirs. :return: Total amount of water trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped def process_input(input_lines): results = [] for line in input_lines: if line.strip() == \\"0\\": break heights = list(map(int, line.split())) result = calculate_water_trapped(heights) results.append(result) return results"},{"question":"def wifi_coverage(M, zones, H, homes): Determine which homes have Wi-Fi coverage. Parameters: M (int): the number of Wi-Fi zones zones (list of tuple): a list of tuples where each tuple contains two integers X and R, representing the coordinate and range of a Wi-Fi zone H (int): the number of homes homes (list of int): a list of integers representing the coordinates of the homes Returns: list of str: a list of \\"Yes\\" or \\"No\\" indicating whether each home has network coverage Example: >>> wifi_coverage(2, [(1, 2), (4, 1)], 3, [2, -1, 7]) [\\"Yes\\", \\"Yes\\", \\"No\\"]","solution":"def wifi_coverage(M, zones, H, homes): Determine which homes have Wi-Fi coverage. Parameters: M (int): the number of Wi-Fi zones zones (list of tuple): a list of tuples where each tuple contains two integers X and R, representing the coordinate and range of a Wi-Fi zone H (int): the number of homes homes (list of int): a list of integers representing the coordinates of the homes Returns: list of str: a list of \\"Yes\\" or \\"No\\" indicating whether each home has network coverage # Initialize list to store the result result = [] # Iterate over each home to check for coverage for home in homes: covered = False for (x, r) in zones: if abs(home - x) <= r: covered = True break result.append(\\"Yes\\" if covered else \\"No\\") return result"},{"question":"def longest_bitonic_subsequence(n: int, sequence: List[int]) -> int: Find the length of the longest bitonic subsequence in a sequence of integers. >>> longest_bitonic_subsequence(8, [1, 11, 2, 10, 4, 5, 2, 1]) 6 >>> longest_bitonic_subsequence(4, [1, 2, 3, 4]) 4 >>> longest_bitonic_subsequence(4, [4, 3, 2, 1]) 4","solution":"def longest_bitonic_subsequence(n, sequence): if n == 0: return 0 # Initialize the increasing and decreasing subsequence lengths inc = [1] * n dec = [1] * n # Compute lengths of increasing subsequences for i in range(1, n): for j in range(0, i): if sequence[i] > sequence[j]: inc[i] = max(inc[i], inc[j] + 1) # Compute lengths of decreasing subsequences for i in range(n-2, -1, -1): for j in range(n-1, i, -1): if sequence[i] > sequence[j]: dec[i] = max(dec[i], dec[j] + 1) # Find the maximum length of the bitonic subsequence max_length = 1 for i in range(n): max_length = max(max_length, inc[i] + dec[i] - 1) return max_length"},{"question":"def min_drivers_needed(M, N, drivers_limits, parcels_weights): Determine the minimum number of drivers required to deliver all the parcels. Parameters: M (int): Number of drivers. N (int): Number of parcels. drivers_limits (List[int]): List of maximum weight limits for each driver. parcels_weights (List[int]): List of weights of each parcel. Returns: int: The minimum number of drivers required to deliver all the parcels. Examples: >>> min_drivers_needed(3, 5, [100, 200, 300], [50, 60, 70, 80, 90]) 2 >>> min_drivers_needed(2, 4, [150, 200], [50, 60, 90, 30]) 2 def main(T, test_cases): Process multiple test cases to determine the minimum number of drivers required for each. Parameters: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[int], List[int]]]): List of test case tuples containing: - M: Number of drivers. - N: Number of parcels. - drivers_limits: List of maximum weight limits for each driver. - parcels_weights: List of weights of each parcel. Returns: List[int]: List of results for each test case, indicating the minimum number of drivers required. results = [] for case in test_cases: M, N, drivers_limits, parcels_weights = case results.append(min_drivers_needed(M, N, drivers_limits, parcels_weights)) return results","solution":"def min_drivers_needed(M, N, drivers_limits, parcels_weights): drivers_limits = sorted(drivers_limits, reverse=True) driver_index = 0 parcels_index = 0 current_weight = 0 num_drivers = 0 while parcels_index < N: while parcels_index < N and current_weight + parcels_weights[parcels_index] <= drivers_limits[driver_index]: current_weight += parcels_weights[parcels_index] parcels_index += 1 num_drivers += 1 current_weight = 0 driver_index += 1 if driver_index >= M: break return num_drivers def main(T, test_cases): results = [] for case in test_cases: M, N, drivers_limits, parcels_weights = case results.append(min_drivers_needed(M, N, drivers_limits, parcels_weights)) return results"},{"question":"def check_redundant_deliveries(couriers): Determines if there are any redundant deliveries for each courier based on their planned routes. Args: couriers (List[List[int]]): A list of couriers with each courier's delivery locations. Returns: List[str]: A list containing \\"Yes\\" if there are redundant deliveries for the corresponding courier, otherwise \\"No\\". >>> check_redundant_deliveries([[10, 20, 30, 40, 10], [25, 30, 35, 40], [15, 20, 15, 25, 30, 15]]) ['Yes', 'No', 'Yes'] >>> check_redundant_deliveries([[1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]) ['No', 'No', 'No'] >>> check_redundant_deliveries([[1, 1], [2, 2, 2], [3, 3, 3, 3]]) ['Yes', 'Yes', 'Yes'] def parse_input(input_str): Parses the input string to extract courier routes. Args: input_str (str): Input string containing the number of couriers and their routes. Returns: List[List[int]]: A list of lists, where each inner list represents the delivery locations for a courier. >>> parse_input(\\"3n5n10 20 30 40 10n4n25 30 35 40n6n15 20 15 25 30 15n\\") [[10, 20, 30, 40, 10], [25, 30, 35, 40], [15, 20, 15, 25, 30, 15]] from solution import check_redundant_deliveries, parse_input def test_check_redundant_deliveries(): couriers = [[10, 20, 30, 40, 10], [25, 30, 35, 40], [15, 20, 15, 25, 30, 15]] expected = [\\"Yes\\", \\"No\\", \\"Yes\\"] assert check_redundant_deliveries(couriers) == expected def test_check_redundant_deliveries_all_unique(): couriers = [[1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]] expected = [\\"No\\", \\"No\\", \\"No\\"] assert check_redundant_deliveries(couriers) == expected def test_check_redundant_deliveries_all_redundant(): couriers = [[1, 1], [2, 2, 2], [3, 3, 3, 3]] expected = [\\"Yes\\", \\"Yes\\", \\"Yes\\"] assert check_redundant_deliveries(couriers) == expected def test_parse_input(): input_str = \\"3n5n10 20 30 40 10n4n25 30 35 40n6n15 20 15 25 30 15n\\" expected = [[10, 20, 30, 40, 10], [25, 30, 35, 40], [15, 20, 15, 25, 30, 15]] assert parse_input(input_str) == expected","solution":"def check_redundant_deliveries(couriers): results = [] for route in couriers: location_set = set() redundant = False for location in route: if location in location_set: redundant = True break location_set.add(location) if redundant: results.append(\\"Yes\\") else: results.append(\\"No\\") return results def parse_input(input_str): input_lines = input_str.strip().split('n') C = int(input_lines[0]) couriers = [] index = 1 for _ in range(C): P = int(input_lines[index]) route = list(map(int, input_lines[index + 1].split())) couriers.append(route) index += 2 return couriers"},{"question":"def findPaths(N: int, M: int, deliveries: list) -> list: Determine the number of distinct paths the robot can take to each specified location. Parameters: N (int): Number of rows in the grid. M (int): Number of columns in the grid. deliveries (list of tuple): List of coordinates where the robot must deliver packages. Returns: list: List containing the number of ways to reach each delivery location. Example: >>> findPaths(3, 3, [(2, 2), (1, 2), (2, 1)]) [6, 3, 3] >>> findPaths(2, 2, [(1, 1)]) [2]","solution":"def findPaths(N, M, deliveries): Determine the number of distinct paths the robot can take to each specified location. Parameters: N (int): Number of rows in the grid. M (int): Number of columns in the grid. deliveries (list of tuple): List of coordinates where the robot must deliver packages. Returns: list: List containing the number of ways to reach each delivery location. # Create a DP table to store number of ways to reach each cell dp = [[0] * M for _ in range(N)] # There's one way to reach the starting point dp[0][0] = 1 # Populate the DP table for i in range(N): for j in range(M): if i == 0 and j == 0: continue ways_from_top = dp[i-1][j] if i > 0 else 0 ways_from_left = dp[i][j-1] if j > 0 else 0 dp[i][j] = ways_from_top + ways_from_left # Retrieve number of ways for each delivery location result = [dp[x][y] for x, y in deliveries] return result"},{"question":"def rotate_array(arr, k): Rotates the array to the right by k steps. Parameters: arr (list): List of integers to rotate. k (int): Number of steps to rotate the array. Returns: list: The rotated array. >>> rotate_array([1, 2, 3, 4, 5, 6], 2) [5, 6, 1, 2, 3, 4] >>> rotate_array([-1, -100, 3, 99, 0], 3) [3, 99, 0, -1, -100] >>> rotate_array([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([1], 3) [1] >>> rotate_array([2, 2, 2, 2], 2) [2, 2, 2, 2]","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. Parameters: arr (list): List of integers to rotate. k (int): Number of steps to rotate the array. Returns: list: The rotated array. n = len(arr) # In case k is greater than n k = k % n # Reverse the entire array reverse(arr, 0, n-1) # Reverse the first k elements reverse(arr, 0, k-1) # Reverse the remaining elements reverse(arr, k, n-1) return arr def reverse(arr, start, end): Helper function to reverse the elements of the array from start to end. Parameters: arr (list): List of integers start (int): Starting index for the reverse operation end (int): Ending index for the reverse operation while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1"},{"question":"from typing import List def is_bipartite(graph: List[List[int]], n: int) -> str: Determine if the given graph is bipartite. >>> is_bipartite([[0, 1, 0], [1, 0, 1], [0, 1, 0]], 3) \\"Yes\\" >>> is_bipartite([[0, 1, 1, 1], [1, 0, 1, 0], [1, 1, 0, 1], [1, 0, 1, 0]], 4) \\"No\\" def bipartite_graphs(test_cases: List[List[List[int]]]) -> List[str]: Determine if each graph in the test cases is bipartite. >>> bipartite_graphs([ ... [[0, 1, 0], [1, 0, 1], [0, 1, 0]], ... [[0, 1, 1, 1], [1, 0, 1, 0], [1, 1, 0, 1], [1, 0, 1, 0]] ... ]) [\\"Yes\\", \\"No\\"]","solution":"from collections import deque def is_bipartite(graph, n): colors = [-1] * n # -1 represents no color, 0 and 1 are the two colors for i in range(n): if colors[i] == -1: # If this node hasn't been colored, perform BFS queue = deque([i]) colors[i] = 0 while queue: node = queue.popleft() for neighbor in range(n): if graph[node][neighbor] == 1: # There is an edge if colors[neighbor] == -1: # If the neighbor hasn't been colored colors[neighbor] = 1 - colors[node] # Color with opposite color queue.append(neighbor) elif colors[neighbor] == colors[node]: # If the neighbor is colored the same return \\"No\\" return \\"Yes\\" def bipartite_graphs(test_cases): results = [] for graph in test_cases: n = len(graph) result = is_bipartite(graph, n) results.append(result) return results"},{"question":"def min_travel_time(N: int, M: int, trains: List[Tuple[int, int, int]]) -> int: Find the minimum travel time between any two cities. :param N: int - number of cities. :param M: int - number of train lines. :param trains: list of tuples - each tuple contains (u, v, t) representing a train line. :return: int - minimum travel time between any two cities. Examples: >>> min_travel_time(3, 3, [(1, 2, 10), (2, 3, 5), (1, 3, 20)]) 5 >>> min_travel_time(4, 5, [(1, 2, 15), (1, 3, 7), (2, 3, 3), (3, 4, 6), (2, 4, 12)]) 3","solution":"def min_travel_time(N, M, trains): Find the minimum travel time between any two cities. :param N: int - number of cities. :param M: int - number of train lines. :param trains: list of tuples - each tuple contains (u, v, t) representing a train line. :return: int - minimum travel time between any two cities. min_time = float('inf') for u, v, t in trains: if t < min_time: min_time = t return min_time"},{"question":"def memoized_factorial(): Returns a function to compute the factorial using memoization. memo = {} def factorial(n): if n in memo: return memo[n] if n <= 1: memo[n] = 1 else: memo[n] = n * factorial(n-1) return memo[n] return factorial def solve_factorial(test_cases): Computes the factorial of given numbers using memoization technique. Args: test_cases: List of non-negative integers for which factorial is to be calculated. Returns: List of factorials corresponding to the input test cases. factorial = memoized_factorial() results = [] for n in test_cases: results.append(factorial(n)) return results # Test cases if __name__ == \\"__main__\\": test_cases = [0, 1, 5, 10] print(solve_factorial(test_cases)) # Expected output: [1, 1, 120, 3628800]","solution":"def memoized_factorial(): Returns a function to compute the factorial using memoization. memo = {} def factorial(n): if n in memo: return memo[n] if n <= 1: memo[n] = 1 else: memo[n] = n * factorial(n-1) return memo[n] return factorial def solve_factorial(test_cases): factorial = memoized_factorial() results = [] for n in test_cases: results.append(factorial(n)) return results"},{"question":"def max_rainfall_in_subarray(N: int, K: int, rainfall: List[int]) -> int: Determine the maximum amount of rainfall in any contiguous subarray of given length. Args: N (int): Total number of days. K (int): Length of the subarray. rainfall (List[int]): Array of integers representing the amount of rainfall on each day. Returns: int: Maximum amount of rainfall in any contiguous subarray of length K, or -1 if K > N. >>> max_rainfall_in_subarray(10, 3, [6, 2, 9, 4, 1, 8, 3, 5, 7, 10]) 22 >>> max_rainfall_in_subarray(5, 10, [1, 2, 3, 4, 5]) -1 >>> max_rainfall_in_subarray(5, 5, [1, 2, 3, 4, 5]) 15 pass # Implement the function here","solution":"def max_rainfall_in_subarray(N, K, rainfall): if K > N: return -1 max_sum = sum(rainfall[:K]) current_sum = max_sum for i in range(K, N): current_sum = current_sum - rainfall[i - K] + rainfall[i] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def find_winners(cards_list: str) -> str: Determines the number of winners in each round and prints the index of each winner. >>> find_winners(\\"4 2 2 3 1\\") \\"1n4\\" >>> find_winners(\\"3 3 2 2 1 1\\") \\"2n4 5\\" >>> find_winners(\\"\\") \\"No winners\\" >>> find_winners(\\"1 1 1 1\\") \\"4n0 1 2 3\\" >>> find_winners(\\"-3 -3 -5 -2 0 -5\\") \\"2n2 5\\" >>> find_winners(\\"10 -1 5 12\\") \\"1n1\\"","solution":"def find_winners(cards_list): if not cards_list: return \\"No winners\\" cards = list(map(int, cards_list.split())) min_value = min(cards) winners = [index for index, value in enumerate(cards) if value == min_value] number_of_winners = len(winners) winners_string = ' '.join(map(str, winners)) return f\\"{number_of_winners}n{winners_string}\\""},{"question":"def longest_increasing_subsequence_length(arr): Returns the length of the longest contiguous subsequence where the numbers are in strictly increasing order. >>> longest_increasing_subsequence_length([5, 1, 2, 3, 2, 4, 5, 6]) 4 >>> longest_increasing_subsequence_length([9, 8, 7, 6, 5]) 1 >>> longest_increasing_subsequence_length([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence_length([1]) 1 >>> longest_increasing_subsequence_length([0, 0, 0, 0]) 1 >>> longest_increasing_subsequence_length([]) 0 >>> longest_increasing_subsequence_length([1, 2, 1, 2, 3, 1]) 3","solution":"def longest_increasing_subsequence_length(arr): Returns the length of the longest contiguous subsequence where the numbers are in strictly increasing order. if not arr: return 0 max_len = 1 current_len = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len"},{"question":"from typing import List, Union def find_second_smallest(nums: List[int]) -> Union[int, str]: Returns the second smallest distinct integer in a list of integers. If there are fewer than 2 distinct elements, returns \\"Not enough elements\\". >>> find_second_smallest([1, 2, 3, 4, 5]) 2 >>> find_second_smallest([9, 9, 9]) \\"Not enough elements\\" >>> find_second_smallest([8, 2, 6, 8, 3, 2]) 3 >>> find_second_smallest([1]) \\"Not enough elements\\" def process_test_cases(T: int, test_cases: List[List[int]]) -> List[Union[int, str]]: Process multiple test cases to find their second smallest elements. Args: T : int : number of test cases test_cases : list of list of int : the test cases Returns: List of results for each test case >>> process_test_cases(3, [[1, 2, 3, 4, 5], [9, 9, 9], [8, 2, 6, 8, 3, 2]]) [2, \\"Not enough elements\\", 3] >>> process_test_cases(2, [[1, 1, 1], [4, 5]]) [\\"Not enough elements\\", 5]","solution":"def find_second_smallest(nums): Returns the second smallest distinct integer in a list of integers. If there are fewer than 2 distinct elements, returns \\"Not enough elements\\". unique_nums = list(set(nums)) if len(unique_nums) < 2: return \\"Not enough elements\\" unique_nums.sort() return unique_nums[1] def process_test_cases(T, test_cases): Process multiple test cases to find their second smallest elements. Args: T : int : number of test cases test_cases : list of list of int : the test cases Returns: List of results for each test case results = [] for case in test_cases: result = find_second_smallest(case) results.append(result) return results"},{"question":"def is_eulerian_circuit_possible(n, m, edges): Determine whether an Eulerian Circuit is possible for given city maps. Parameters: n (int): Number of intersections (vertices). m (int): Number of roads (edges). edges (List[Tuple[int, int]]): List of roads between intersections. Returns: str: \\"Yes\\" if Eulerian Circuit exists, otherwise \\"No\\". pass def delivery_heroes_input_manager(input_list): Manage the input for multiple city maps and determine if an Eulerian Circuit exists for each. Parameters: input_list (List[Tuple[int, int]]): List of tuples representing the city maps. Returns: List[str]: List of \\"Yes\\" or \\"No\\" for each city map. >>> input_data = [ ... (4, 4), ... (1, 2), ... (2, 3), ... (3, 4), ... (4, 1), ... (3, 2), ... (1, 2), ... (2, 3), ... (5, 4), ... (1, 2), ... (2, 3), ... (3, 1), ... (4, 5), ... (0, 0) ... ] >>> delivery_heroes_input_manager(input_data) [\\"Yes\\", \\"No\\", \\"No\\"] pass","solution":"def is_eulerian_circuit_possible(n, m, edges): if n == 0: return \\"No\\" from collections import defaultdict graph = defaultdict(list) degree = [0] * (n + 1) for u, v in edges: graph[u].append(v) graph[v].append(u) degree[u] += 1 degree[v] += 1 # Check all vertices with non-zero degree are connected def dfs(v, visited): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: dfs(neighbor, visited) visited = [False] * (n + 1) start = 1 while start <= n and not graph[start]: start += 1 if start > n: return \\"Yes\\" dfs(start, visited) for i in range(1, n + 1): if graph[i] and not visited[i]: return \\"No\\" # Check if all vertices have even degree for i in range(1, n + 1): if degree[i] % 2 != 0: return \\"No\\" return \\"Yes\\" def delivery_heroes_input_manager(input_list): result = [] i = 0 while i < len(input_list): n, m = input_list[i] if n == 0 and m == 0: break edges = input_list[i + 1 : i + 1 + m] result.append(is_eulerian_circuit_possible(n, m, edges)) i += 1 + m return result"},{"question":"from typing import List def rearrange_books_by_genre(N: int, book_ids: List[int], genres: List[str]) -> List[int]: Rearranges the book IDs such that books of the same genre are grouped together while preserving the relative order within each genre. :param N: int - Number of books :param book_ids: list of int - List of book IDs :param genres: list of str - List of genres corresponding to the book IDs :return: list of int - Rearranged list of book IDs >>> rearrange_books_by_genre(7, [101, 102, 103, 104, 105, 106, 107], [\\"SciFi\\", \\"Romance\\", \\"SciFi\\", \\"Mystery\\", \\"Romance\\", \\"SciFi\\", \\"Mystery\\"]) [101, 103, 106, 102, 105, 104, 107] >>> rearrange_books_by_genre(1, [108], [\\"Drama\\"]) [108] >>> rearrange_books_by_genre(5, [201, 202, 203, 204, 205], [\\"Fantasy\\", \\"Fantasy\\", \\"Fantasy\\", \\"Fantasy\\", \\"Fantasy\\"]) [201, 202, 203, 204, 205] >>> rearrange_books_by_genre(3, [301, 302, 303], [\\"Thriller\\", \\"Biography\\", \\"Comedy\\"]) [301, 302, 303] >>> rearrange_books_by_genre(6, [401, 402, 403, 404, 405, 406], [\\"Horror\\", \\"Drama\\", \\"Horror\\", \\"Comedy\\", \\"Drama\\", \\"Comedy\\"]) [401, 403, 402, 405, 404, 406]","solution":"from collections import defaultdict def rearrange_books_by_genre(N, book_ids, genres): Rearranges the book IDs such that books of the same genre are grouped together while preserving the relative order within each genre. :param N: int - Number of books :param book_ids: list of int - List of book IDs :param genres: list of str - List of genres corresponding to the book IDs :return: list of int - Rearranged list of book IDs genre_map = defaultdict(list) # Group books by their genres for i in range(N): genre_map[genres[i]].append(book_ids[i]) rearranged_books = [] # Preserve the order of books within each genre for genre in genres: rearranged_books.extend(genre_map[genre]) del genre_map[genre] # Remove the genre to avoid duplicate additions return rearranged_books"},{"question":"from typing import List, Dict def organize_teams(employees: List[Dict[str, str]], n: int) -> List[List[Dict[str, str]]]: Organize employees into teams satisfying the following conditions: 1. The total number of members must be equal to or less than a given size \`n\`. 2. Each member must have a distinct role within the team (roles do not repeat in a team). :param employees: A list of dictionaries where each dictionary contains 'name' and 'role' of an employee. :param n: Maximum allowed team size. :return: A list of teams where each team is a list of dictionaries representing the employees. >>> organize_teams([ ... {'name': 'John', 'role': 'Engineer'}, ... {'name': 'Alice', 'role': 'Designer'}, ... {'name': 'Bob', 'role': 'Manager'}, ... {'name': 'Eve', 'role': 'Engineer'}, ... {'name': 'Frank', 'role': 'Analyst'} ... ], 3) [[{'name': 'John', 'role': 'Engineer'}, {'name': 'Alice', 'role': 'Designer'}, {'name': 'Bob', 'role': 'Manager'}], [{'name': 'Eve', 'role': 'Engineer'}, {'name': 'Frank', 'role': 'Analyst'}]] >>> organize_teams([ ... {'name': 'John', 'role': 'Engineer'}, ... {'name': 'Alice', 'role': 'Engineer'}, ... {'name': 'Bob', 'role': 'Manager'} ... ], 2) [[{'name': 'John', 'role': 'Engineer'}, {'name': 'Bob', 'role': 'Manager'}], [{'name': 'Alice', 'role': 'Engineer'}]] >>> organize_teams([{'name': 'John', 'role': 'Engineer'}], 1) [[{'name': 'John', 'role': 'Engineer'}]] >>> organize_teams([ ... {'name': 'John', 'role': 'Engineer'}, ... {'name': 'Alice', 'role': 'Engineer'} ... ], 1) [[{'name': 'John', 'role': 'Engineer'}], [{'name': 'Alice', 'role': 'Engineer'}]] >>> organize_teams([], 3) [] >>> organize_teams([ ... {'name': 'John', 'role': 'Engineer'}, ... {'name': 'Alice', 'role': 'Engineer'}, ... {'name': 'Bob', 'role': 'Engineer'} ... ], 2) [[{'name': 'John', 'role': 'Engineer'}], [{'name': 'Alice', 'role': 'Engineer'}], [{'name': 'Bob', 'role': 'Engineer'}]] pass","solution":"def organize_teams(employees, n): Organize employees into teams satisfying the following conditions: 1. The total number of members must be equal to or less than a given size \`n\`. 2. Each member must have a distinct role within the team (roles do not repeat in a team). :param employees: A list of dictionaries where each dictionary contains 'name' and 'role' of an employee. :param n: Maximum allowed team size. :return: A list of teams where each team is a list of dictionaries representing the employees. from collections import defaultdict teams = [] role_to_employee = defaultdict(list) for employee in employees: role_to_employee[employee['role']].append(employee) while role_to_employee: team = [] roles_to_remove = [] for role in list(role_to_employee.keys()): if len(team) < n: team.append(role_to_employee[role].pop(0)) if not role_to_employee[role]: roles_to_remove.append(role) else: break for role in roles_to_remove: del role_to_employee[role] teams.append(team) return teams"},{"question":"def is_palindromic_permutation(s: str) -> bool: Determines whether any permutation of the given string \`s\` can form a palindrome. A string can be permuted to form a palindrome if and only if at most one of its characters appears an odd number of times. This is because in a palindrome, the number of times each character appears is typically balanced around the center. Args: s: str - A single string consisting of lowercase English letters (1 ≤ |s| ≤ 1000). Returns: bool - True if any permutation of \`s\` can form a palindrome, otherwise False. Examples: >>> is_palindromic_permutation('racecar') True >>> is_palindromic_permutation('hello') False >>> is_palindromic_permutation('aab') True","solution":"def is_palindromic_permutation(s): Determines whether any permutation of the given string \`s\` can form a palindrome. Args: s: str - A single string consisting of lowercase English letters. Returns: bool - True if any permutation of \`s\` can form a palindrome, otherwise False. from collections import Counter # Count the frequency of each character in the string char_counts = Counter(s) # Count the number of characters that appear an odd number of times odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # A string can be permuted to form a palindrome if and only if at most one character has an odd count return odd_count <= 1"},{"question":"def digit_frequency(n): Write a function that takes a non-negative integer as an input and returns an array where the value at each index \`i\` represents the count of digit \`i\` in the input integer. >>> digit_frequency(112233) [0, 2, 2, 2, 0, 0, 0, 0, 0, 0] >>> digit_frequency(9988776655) [0, 0, 0, 0, 0, 2, 2, 2, 2, 2] >>> digit_frequency(0) [1, 0, 0, 0, 0, 0, 0, 0, 0, 0] >>> digit_frequency(1234567890) [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] >>> digit_frequency(1111111111) [0, 10, 0, 0, 0, 0, 0, 0, 0, 0] >>> digit_frequency(2222222) [0, 0, 7, 0, 0, 0, 0, 0, 0, 0] >>> digit_frequency(123456) [0, 1, 1, 1, 1, 1, 1, 0, 0, 0]","solution":"def digit_frequency(n): Returns an array where the value at each index i represents the count of digit i in the input integer n. # Initialize a list of size 10 to store the frequency of each digit (0-9) frequency = [0] * 10 # Convert the number to a string to easily iterate through each digit num_str = str(n) # Traverse each character in the string for char in num_str: digit = int(char) # Convert character to digit frequency[digit] += 1 # Increment the count for the digit return frequency"},{"question":"def can_plant_flowers(T: int, cases: List[Tuple[int, int, int]]) -> List[str]: Determines if it is possible to plant flowers in the garden grid according to Lisa's constraint for a specific grid size. Each test case is represented by a tuple (R, C, F) where R is the number of rows, C is the number of columns, and F is the number of flower colors available. Args: T (int): The number of test cases. cases (List[Tuple[int, int, int]]): A list of tuples, each tuple contains three integers (R, C, F). Returns: List[str]: A list containing 'Yes' or 'No' for each test case indicating if the flowers can be planted according to the constraints. >>> can_plant_flowers(3, [(3, 3, 2), (4, 4, 2), (4, 4, 3)]) [\\"No\\", \\"No\\", \\"Yes\\"] >>> can_plant_flowers(1, [(1, 1, 2)]) [\\"Yes\\"] >>> can_plant_flowers(2, [(2, 2, 1), (3, 3, 4)]) [\\"No\\", \\"Yes\\"] >>> can_plant_flowers(4, [(10, 10, 3), (5, 5, 2), (7, 7, 4), (8, 8, 2)]) [\\"Yes\\", \\"No\\", \\"Yes\\", \\"No\\"]","solution":"def can_plant_flowers(T, cases): results = [] for case in cases: R, C, F = case # Calculate the minimum number of colors needed for the given grid size min_required_colors = 2 if R > 1 and C > 1: min_required_colors = 3 if F >= min_required_colors: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def largestRectangleArea(heights: List[int]) -> int: Given an array of heights representing a bar chart, return the area of the largest rectangle that can fit within the bounds of the bar chart. >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([2, 4]) 4 >>> largestRectangleArea([4]) 4 >>> largestRectangleArea([2, 2]) 4 >>> largestRectangleArea([3, 3, 3, 3]) 12 >>> largestRectangleArea([6, 5, 4, 3, 2, 1]) 12 >>> largestRectangleArea([1, 2, 3, 4, 5, 6]) 12 >>> largestRectangleArea([1, 3, 2, 1, 2]) 5","solution":"def largestRectangleArea(heights): Given an array of heights representing a bar chart, return the area of the largest rectangle that can fit within the bounds of the bar chart. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def country_with_most_denominations(n: int, countries_info: List[str]) -> str: Given a list of coins from various countries, identify the country with the most denominations you have collected. If there is a tie, return the country that appears first in the input list. >>> country_with_most_denominations(3, [ ... \\"3\\", \\"Japan\\", \\"1-yen\\", \\"5-yen\\", \\"10-yen\\", ... \\"2\\", \\"Canada\\", \\"1-dollar\\", \\"2-dollar\\", ... \\"3\\", \\"Germany\\", \\"1-euro\\", \\"2-euro\\", \\"50-euro\\" ... ]) == \\"Japan\\" >>> country_with_most_denominations(1, [ ... \\"2\\", \\"India\\", \\"1-rupee\\", \\"2-rupee\\" ... ]) == \\"India\\" >>> country_with_most_denominations(3, [ ... \\"2\\", \\"France\\", \\"1-cent\\", \\"1-euro\\", ... \\"3\\", \\"USA\\", \\"1-cent\\", \\"1-dime\\", \\"1-dollar\\", ... \\"3\\", \\"Germany\\", \\"1-euro\\", \\"2-euro\\", \\"5-euro\\" ... ]) == \\"USA\\" >>> country_with_most_denominations(3, [ ... \\"1\\", \\"Mexico\\", \\"1-peso\\", ... \\"1\\", \\"Italy\\", \\"1-euro\\", ... \\"1\\", \\"Brazil\\", \\"1-real\\" ... ]) == \\"Mexico\\" >>> country_with_most_denominations(4, [ ... \\"2\\", \\"China\\", \\"1-yuan\\", \\"5-yuan\\", ... \\"4\\", \\"Australia\\", \\"1-aud\\", \\"2-aud\\", \\"5-aud\\", \\"10-aud\\", ... \\"3\\", \\"Russia\\", \\"1-rub\\", \\"2-rub\\", \\"5-rub\\", ... \\"4\\", \\"India\\", \\"1-rupee\\", \\"2-rupee\\", \\"5-rupee\\", \\"10-rupee\\" ... ]) == \\"Australia\\"","solution":"def country_with_most_denominations(n, countries_info): country_denominations = {} idx = 0 for _ in range(n): k = int(countries_info[idx]) country_name = countries_info[idx + 1] denominations = countries_info[idx + 2 : idx + 2 + k] country_denominations[country_name] = len(denominations) # Move the index to the start of the next country idx += 2 + k max_denominations = max(country_denominations.values()) for country, count in country_denominations.items(): if count == max_denominations: return country"},{"question":"def is_subsequence(a: str, b: str) -> bool: Determines if string 'a' is a subsequence of string 'b'. >>> is_subsequence(\\"abc\\", \\"ahbgdc\\") True >>> is_subsequence(\\"axc\\", \\"ahbgdc\\") False # Your code here # Unit tests def test_subsequence_positive_case(): assert is_subsequence(\\"abc\\", \\"ahbgdc\\") == True def test_subsequence_negative_case(): assert is_subsequence(\\"axc\\", \\"ahbgdc\\") == False def test_subsequence_single_character(): assert is_subsequence(\\"a\\", \\"ahbgdc\\") == True assert is_subsequence(\\"z\\", \\"ahbgdc\\") == False def test_subsequence_identical_strings(): assert is_subsequence(\\"abc\\", \\"abc\\") == True def test_subsequence_empty_string_a(): assert is_subsequence(\\"\\", \\"ahbgdc\\") == True def test_subsequence_empty_string_b(): assert is_subsequence(\\"abc\\", \\"\\") == False def test_subsequence_a_longer_than_b(): assert is_subsequence(\\"abcdef\\", \\"abc\\") == False def test_subsequence_interleaved_chars(): assert is_subsequence(\\"ace\\", \\"abcde\\") == True","solution":"def is_subsequence(a, b): Determines if string 'a' is a subsequence of string 'b'. a_len, b_len = len(a), len(b) a_idx, b_idx = 0, 0 while a_idx < a_len and b_idx < b_len: if a[a_idx] == b[b_idx]: a_idx += 1 b_idx += 1 return a_idx == a_len"},{"question":"def sum_nested_list(nested_list: list) -> int: Computes the sum of all integers in a nested list. Parameters: nested_list (list): A nested list of integers. Returns: int: The sum of all integers in the nested list. >>> sum_nested_list([[1, 2, [3, [4, 5]]], 6]) 21 >>> sum_nested_list([1, [2, 3], 4, [5, [6, [7]]]]) 28 >>> sum_nested_list([10]) 10 >>> sum_nested_list([[[[[8]]]], 9]) 17 >>> sum_nested_list([]) 0","solution":"def sum_nested_list(nested_list): Computes the sum of all integers in the nested list. Parameters: nested_list (list): A nested list of integers. Returns: int: The sum of all integers in the nested list. total = 0 for element in nested_list: if isinstance(element, list): total += sum_nested_list(element) else: total += element return total"},{"question":"def rearrange_string(S: str) -> str: Returns the lexicographically smallest string by rearranging characters such that all digits remain in their original positions. >>> rearrange_string(\\"b2a1c3\\") \\"a2b1c3\\" >>> rearrange_string(\\"a1b2c\\") \\"a1b2c\\" >>> rearrange_string(\\"dcba4321\\") \\"abcd4321\\" >>> rearrange_string(\\"1a2b3c\\") \\"1a2b3c\\" >>> rearrange_string(\\"z9y8x7\\") \\"x9y8z7\\" def process_test_cases(T: int, cases: List[str]) -> List[str]: Processes multiple test cases. >>> process_test_cases(3, [\\"b2a1c3\\", \\"a1b2c\\", \\"dcba4321\\"]) [\\"a2b1c3\\", \\"a1b2c\\", \\"abcd4321\\"] >>> process_test_cases(2, [\\"z9y8x7\\", \\"g4d3c2b1\\"]) [\\"x9y8z7\\", \\"b4c3d2g1\\"] >>> process_test_cases(1, [\\"0a1b2c3d4e\\"]) [\\"0a1b2c3d4e\\"]","solution":"def rearrange_string(S): Returns the lexicographically smallest string by rearranging characters such that all digits remain in their original positions. # Extract characters and their positions letters = [s for s in S if s.isalpha()] letters.sort() result = [] letter_idx = 0 for char in S: if char.isdigit(): result.append(char) else: result.append(letters[letter_idx]) letter_idx += 1 return \\"\\".join(result) def process_test_cases(T, cases): results = [] for i in range(T): results.append(rearrange_string(cases[i])) return results"},{"question":"def is_palindrome(s: str) -> bool: Checks whether the input string is a palindrome, ignoring case and non-alphanumeric characters. >>> is_palindrome(\\"racecar\\") == True >>> is_palindrome(\\"hello\\") == False >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"No 'x' in Nixon\\") == True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") == True >>> is_palindrome(\\"Palindrome\\") == False","solution":"def is_palindrome(s): Checks whether the input string is a palindrome, ignoring case and non-alphanumeric characters. :param s: Input string :return: True if the string is a palindrome, False otherwise # Keep only alphanumeric characters and convert to lowercase cleaned_s = ''.join(char.lower() for char in s if char.isalnum()) # Compare the cleaned string with its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"def maximize_value(N: int, items: List[Tuple[int, int, int]]) -> int: Returns the maximum sum of values of the selected items such that no two items from the same category are selected. >>> maximize_value(5, [(10, 1, 1), (15, 2, 2), (20, 1, 3), (25, 3, 4), (30, 2, 5)]) 75 >>> maximize_value(3, [(5, 1, 1), (10, 2, 2), (3, 3, 3)]) 18 >>> maximize_value(4, [(7, 2, 1), (5, 2, 2), (6, 1, 3), (3, 3, 4)]) 16 >>> maximize_value(1, [(8, 1, 1)]) 8 >>> maximize_value(6, [(1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4), (5, 5, 5), (6, 1, 6)]) 20 pass","solution":"def maximize_value(N, items): Returns the maximum sum of values of the selected items such that no two items from the same category are selected. from collections import defaultdict # Dictionary to store the maximum value item for each category category_max_value = defaultdict(int) for value, category, identifier in items: if value > category_max_value[category]: category_max_value[category] = value # The maximum sum is the sum of the maximum values from each category return sum(category_max_value.values())"},{"question":"from typing import List, Tuple def max_power_subarray(N: int, Q: int, A: List[int], queries: List[Tuple[int, int]]) -> List[int]: Function to calculate the maximum power of any subarray within the given range queries. Args: N : int : Number of elements in the array Q : int : Number of queries A : list : List of integers representing the array queries : list : List of tuples where each tuple has two integers L and R representing the range Returns: list : List of results for each query >>> max_power_subarray(6, 2, [1, 2, 3, -1, 4, 5], [(1, 4), (2, 6)]) [6, 13] >>> max_power_subarray(5, 2, [-1, -2, -3, -4, -5], [(1, 3), (3, 5)]) [-1, -3] >>> max_power_subarray(5, 3, [1, 1, 1, 1, 1], [(1, 1), (1, 3), (2, 5)]) [1, 1, 1] >>> max_power_subarray(4, 1, [2, 4, 6, 8], [(1, 4)]) [20] >>> max_power_subarray(5, 2, [1, 2, 3, 2, 1], [(1, 5), (2, 4)]) [6, 5]","solution":"def max_power_subarray(N, Q, A, queries): Function to calculate the maximum power of any subarray within the given range queries. Args: N : int : Number of elements in the array Q : int : Number of queries A : list : List of integers representing the array queries : list : List of tuples where each tuple has two integers L and R representing the range Returns: list : List of results for each query def max_power(A, L, R): seen = set() current_power = 0 max_power = float('-inf') for i in range(L, R + 1): if A[i] not in seen: seen.add(A[i]) current_power += A[i] max_power = max(max_power, current_power) return max_power results = [] for L, R in queries: L, R = L - 1, R - 1 # converting to 0-based index results.append(max_power(A, L, R)) return results"},{"question":"from typing import List def autocomplete(dictionary: List[str], prefixes: List[str]) -> List[List[str]]: Given a dictionary of words and a list of prefixes, return a list of lists where each inner list contains the words from the dictionary that start with the corresponding prefix in the prefixes list. >>> autocomplete([\\"apple\\", \\"app\\", \\"application\\", \\"banana\\", \\"band\\", \\"bandana\\", \\"bandwidth\\", \\"cat\\", \\"catch\\", \\"cater\\"], [\\"app\\", \\"ban\\", \\"cat\\", \\"zoo\\"]) [['apple', 'app', 'application'], ['banana', 'band', 'bandana', 'bandwidth'], ['cat', 'catch', 'cater'], []] >>> autocomplete([\\"dog\\", \\"dig\\", \\"dug\\"], [\\"c\\", \\"z\\"]) [[], []]","solution":"from typing import List def autocomplete(dictionary: List[str], prefixes: List[str]) -> List[List[str]]: def find_words_for_prefix(prefix: str) -> List[str]: return [word for word in dictionary if word.startswith(prefix)] results = [] for prefix in prefixes: results.append(find_words_for_prefix(prefix)) return results"},{"question":"def has_zero_sum_subarray(arr: List[int]) -> str: Determine whether there is any sub-array (a contiguous block of elements) that adds up to exactly zero. Parameters: arr (list): The list of integers. Returns: str: \\"YES\\" if there exists a sub-array with a sum of zero, otherwise \\"NO\\". pass # Test cases from the prompt def test_prompt_example_1(): assert has_zero_sum_subarray([4, 2, -3, 1, 6]) == \\"YES\\" def test_prompt_example_2(): assert has_zero_sum_subarray([1, 2, 3, 4]) == \\"NO\\" # Additional test cases def test_single_zero(): assert has_zero_sum_subarray([0]) == \\"YES\\" def test_contains_zero_subarray(): assert has_zero_sum_subarray([1, 2, -3, 1, 1, -1, -1, 3]) == \\"YES\\" def test_no_zero_subarray(): assert has_zero_sum_subarray([1, 2, 3, 4, 5]) == \\"NO\\" def test_all_negative_numbers(): assert has_zero_sum_subarray([-1, -2, -3, -4]) == \\"NO\\" def test_prefix_sum_zero(): assert has_zero_sum_subarray([4, -4, 1, 1]) == \\"YES\\" def test_large_input_with_no_zero_subarray(): assert has_zero_sum_subarray([i for i in range(1, 100001)]) == \\"NO\\" def test_large_input_with_zero_subarray(): arr = [10] * 50000 + [-10] * 50000 assert has_zero_sum_subarray(arr) == \\"YES\\"","solution":"def has_zero_sum_subarray(arr): Determine whether there is any sub-array (a contiguous block of elements) that adds up to exactly zero. Parameters: arr (list): The list of integers. Returns: str: \\"YES\\" if there exists a sub-array with a sum of zero, otherwise \\"NO\\". prefix_sum_set = set() prefix_sum = 0 for num in arr: prefix_sum += num if prefix_sum == 0 or prefix_sum in prefix_sum_set: return \\"YES\\" prefix_sum_set.add(prefix_sum) return \\"NO\\""},{"question":"def expected_length_of_encoded_sequence(queries): Determine the expected length of the encoded sequence of integers for given queries. >>> expected_length_of_encoded_sequence([(5, 3), (8, 4)]) [\\"10.0\\", \\"16.0\\"] >>> expected_length_of_encoded_sequence([(1, 2)]) [\\"2.0\\"] >>> expected_length_of_encoded_sequence([(1000000000, 1000000000)]) [\\"2000000000.0\\"]","solution":"def expected_length_of_encoded_sequence(queries): results = [] for M, N in queries: # The expected length of the encoded sequence expected_length = 2 * M results.append(f\\"{expected_length:.1f}\\") return results"},{"question":"def final_number(n: int, arr: List[int]) -> int: Given the number of elements and the initial array, this function returns the final number left after James and Emily have finished combining numbers optimally. :param n: int, the number of elements in the initial array :param arr: list of int, the initial elements in the array :return: int, the final number left after combining >>> final_number(4, [2, 9, 3, 1]) 15 >>> final_number(3, [10, 20, 30]) 60 >>> final_number(2, [1, 1]) 2 >>> final_number(5, [1, 2, 3, 4, 5]) 15","solution":"def final_number(n, arr): Given the number of elements and the initial array, this function returns the final number left after James and Emily have finished combining numbers optimally. :param n: int, the number of elements in the initial array :param arr: list of int, the initial elements in the array :return: int, the final number left after combining # The final number left will always be the sum of all numbers in the array return sum(arr)"},{"question":"def min_total_bonuses(N: int, ratings: List[int]) -> int: Determine the minimum total amount of bonuses the company needs to give out. >>> min_total_bonuses(5, [1, 2, 2, 5, 1]) 7 >>> min_total_bonuses(1, [5]) 1 >>> min_total_bonuses(3, [1, 2, 3]) 6 >>> min_total_bonuses(3, [3, 2, 1]) 6 >>> min_total_bonuses(4, [4, 4, 4, 4]) 4 >>> min_total_bonuses(6, [1, 3, 2, 2, 1, 5]) 9 >>> min_total_bonuses(5, [1, 6, 10, 5, 4]) 9","solution":"def min_total_bonuses(N, ratings): if N == 1: return 1 bonuses = [1] * N # Left to Right pass for i in range(1, N): if ratings[i] > ratings[i - 1]: bonuses[i] = bonuses[i - 1] + 1 # Right to Left pass for i in range(N - 2, -1, -1): if ratings[i] > ratings[i + 1]: bonuses[i] = max(bonuses[i], bonuses[i + 1] + 1) return sum(bonuses)"},{"question":"def findRepeatingElement(arr, N, k): Finds the element that appears exactly k times in the array. Parameters: arr (list): The input array containing N + k elements. N (int): The maximum integer value in the range [1, N]. k (int): The count of the repeating element. Returns: int: The element that appears k times. pass # Unit Tests def test_example1(): arr = [1, 2, 3, 4, 5, 3, 3, 3] N = 5 k = 3 assert findRepeatingElement(arr, N, k) == 3 def test_example2(): arr = [1, 2, 2, 3, 4] N = 4 k = 2 assert findRepeatingElement(arr, N, k) == 2 def test_single_repetition(): arr = [1, 1, 2, 3, 4, 5] N = 5 k = 1 assert findRepeatingElement(arr, N, k) == 1 def test_large_N_k(): arr = [i for i in range(1, 100000)] + [5] * 10 N = 99999 k = 10 assert findRepeatingElement(arr, N, k) == 5 def test_complex_case(): arr = [2, 1, 2, 3, 4, 4, 4] N = 4 k = 3 assert findRepeatingElement(arr, N, k) == 4","solution":"def findRepeatingElement(arr, N, k): Finds the element that appears exactly k times in the array. Parameters: arr (list): The input array containing N + k elements. N (int): The maximum integer value in the range [1, N]. k (int): The count of the repeating element. Returns: int: The element that appears k times. count = [0] * (N + 1) for num in arr: count[num] += 1 if count[num] == k: return num return -1"},{"question":"def guess_sequence(n: int, query) -> List[int]: Ehab has a hidden sequence s of length n consisting of integers from 1 to n. You want to figure out the sequence by asking up to 4269 questions. Arguments: n -- length of the sequence This function will use the provided query function to interact with the hidden sequence. >>> def mock_query(i): >>> sequence = [2, 4, 1, 3] >>> return sequence[i-1] >>> guess_sequence(4, mock_query) [2, 4, 1, 3] # Your implementation here # Test cases def mock_query_factory(sequence): def query(i): if 1 <= i <= len(sequence): return sequence[i-1] else: return -1 return query def test_guess_sequence_1(): n = 4 sequence = [2, 4, 1, 3] query = mock_query_factory(sequence) assert guess_sequence(n, query) == sequence def test_guess_sequence_2(): n = 3 sequence = [1, 2, 3] query = mock_query_factory(sequence) assert guess_sequence(n, query) == sequence def test_guess_sequence_3(): n = 2 sequence = [2, 1] query = mock_query_factory(sequence) assert guess_sequence(n, query) == sequence def test_guess_sequence_exceed_query(): n = 4 sequence = [2, 4, 1, 3] query = mock_query_factory(sequence) query_exceed = lambda x: query(x) if x <= 4 else -1 assert guess_sequence(n, query_exceed) == sequence","solution":"import sys def guess_sequence(n, query): s = [] for i in range(1, n+1): print(f\\"? 1 {i}\\") sys.stdout.flush() k = query(i) if k == -1: exit() s.append(k) print(f\\"! {' '.join(map(str, s))}\\") sys.stdout.flush() return s # Example usage in a real setting might involve interaction like this: # guess_sequence(4, lambda x: {1: 2, 2: 4, 3: 1, 4: 3}[x])"},{"question":"def can_alice_win(t: int, cases: List[str]) -> List[str]: Determines if Alice can guarantee a win given the initial strings. :param t: The number of test cases :param cases: A list of strings for each test case :return: A list of \\"YES\\" or \\"NO\\" for each test case >>> can_alice_win(3, [\\"abc\\", \\"abcd\\", \\"a\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> can_alice_win(2, [\\"xy\\", \\"z\\"]) [\\"NO\\", \\"YES\\"]","solution":"def can_alice_win(t, cases): Determines if Alice can guarantee a win. :param t: Number of test cases :param cases: List of test case strings :return: List of \\"YES\\" or \\"NO\\" for each test case results = [] for s in cases: if len(s) % 2 == 1: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def sort_books(books): Returns a list of books sorted by title and then by identifier. Parameters: - books: list of tuples, where each tuple contains an identifier (int) and a title (str) Returns: - list of tuples sorted by title, and then by identifier if titles are the same from solution import sort_books def test_sort_books_standard_case(): books = [(3, 'The Hobbit'), (1, 'A Tale of Two Cities'), (2, 'A Tale of Two Cities'), (4, 'Moby Dick')] expected = [(1, 'A Tale of Two Cities'), (2, 'A Tale of Two Cities'), (4, 'Moby Dick'), (3, 'The Hobbit')] assert sort_books(books) == expected def test_sort_books_identical_titles(): books = [(5, '1984'), (3, '1984'), (1, '1984')] expected = [(1, '1984'), (3, '1984'), (5, '1984')] assert sort_books(books) == expected def test_sort_books_empty_list(): books = [] expected = [] assert sort_books(books) == expected def test_sort_books_single_book(): books = [(1, 'The Great Gatsby')] expected = [(1, 'The Great Gatsby')] assert sort_books(books) == expected def test_sort_books_different_titles(): books = [(1, 'War and Peace'), (2, 'Pride and Prejudice'), (3, 'Crime and Punishment')] expected = [(3, 'Crime and Punishment'), (2, 'Pride and Prejudice'), (1, 'War and Peace')] assert sort_books(books) == expected","solution":"def sort_books(books): Returns a list of books sorted by title and then by identifier. Parameters: - books: list of tuples, where each tuple contains an identifier (int) and a title (str) Returns: - list of tuples sorted by title, and then by identifier if titles are the same return sorted(books, key=lambda book: (book[1], book[0]))"},{"question":"def beautiful_permutation(n: int, k: int) -> List[int]: Returns a beautiful permutation of integers from 1 to n according to the given k, or -1 if such a permutation does not exist. >>> beautiful_permutation(5, 3) [3, 1, 2, 4, 5] >>> beautiful_permutation(4, 5) -1","solution":"def beautiful_permutation(n, k): Returns a beautiful permutation of integers from 1 to n according to the given k, or -1 if such a permutation does not exist. if n < k: return -1 permutation = list(range(1, k + 1)) return permutation + list(range(k + 1, n + 1))"},{"question":"def sum_divisible_by_k(N: int, K: int, A: List[int]) -> int: Given N integers, determine the sum of all integers that are divisible by a given integer K. Args: N : int : the number of elements in the array K : int : the divisor A : list of int : the array of integers Returns: int : the sum total of integers divisible by K >>> sum_divisible_by_k(5, 3, [3, 6, 9, 10, 15]) 33 >>> sum_divisible_by_k(4, 5, [2, 4, 6, 8]) 0 >>> sum_divisible_by_k(7, 2, [1, 2, 3, 4, 5, 6, 7]) 12","solution":"def sum_divisible_by_k(N, K, A): Returns the sum of all integers in the array A that are divisible by K. Args: N : int : the number of elements in the array K : int : the divisor A : list of int : the array of integers Returns: int : the sum total of integers divisible by K return sum(x for x in A if x % K == 0)"},{"question":"def can_accommodate_reservations(r: int, c: int, n: int, reservations: List[Tuple[int, int, int]]) -> str: Determine if all reservation requests for seats in a theater can be accommodated. Args: r: Number of rows in the theater. c: Number of seats per row in the theater. n: Number of reservation requests. reservations: A list of tuples, where each tuple contains three integers (row, start_seat, num_seats). Returns: \\"Possible\\" if all reservations can be accommodated, otherwise \\"Impossible\\". >>> can_accommodate_reservations(3, 5, 2, [(1, 2, 3), (2, 1, 4)]) 'Possible' >>> can_accommodate_reservations(2, 4, 3, [(1, 1, 4), (2, 2, 3), (1, 3, 2)]) 'Impossible' from typing import List, Tuple def test_possible_case_1(): assert can_accommodate_reservations(3, 5, 2, [(1, 2, 3), (2, 1, 4)]) == \\"Possible\\" def test_impossible_case_1(): assert can_accommodate_reservations(2, 4, 3, [(1, 1, 4), (2, 2, 3), (1, 3, 2)]) == \\"Impossible\\" def test_possible_case_2(): assert can_accommodate_reservations(3, 5, 2, [(1, 1, 2), (2, 2, 3)]) == \\"Possible\\" def test_impossible_case_2(): assert can_accommodate_reservations(3, 5, 3, [(1, 1, 3), (1, 2, 3), (2, 1, 4)]) == \\"Impossible\\" def test_edge_case_all_seats(): assert can_accommodate_reservations(1, 50, 1, [(1, 1, 50)]) == \\"Possible\\" def test_edge_case_single_seat(): assert can_accommodate_reservations(50, 1, 1, [(1, 1, 1)]) == \\"Possible\\"","solution":"def can_accommodate_reservations(r, c, n, reservations): # Initialize a 2D list representing the seats in the theater. seats = [[False] * c for _ in range(r)] for reservation in reservations: row, start_seat, num_seats = reservation row -= 1 # Convert to 0-based index start_seat -= 1 # Convert to 0-based index end_seat = start_seat + num_seats if end_seat > c: return \\"Impossible\\" for seat in range(start_seat, end_seat): if seats[row][seat]: return \\"Impossible\\" seats[row][seat] = True return \\"Possible\\" # Example cases print(can_accommodate_reservations(3, 5, 2, [(1, 2, 3), (2, 1, 4)])) # Output: \\"Possible\\" print(can_accommodate_reservations(2, 4, 3, [(1, 1, 4), (2, 2, 3), (1, 3, 2)])) # Output: \\"Impossible\\""},{"question":"def evenSumSubarrays(arr): Determine the number of contiguous subarrays that have an even sum. >>> evenSumSubarrays([1, 2, 3, 4]) 4 >>> evenSumSubarrays([2, 4, 6]) 6 pass def evenSumSubarrays_testcases(t, testcases): Determines the number of contiguous subarrays with even sums for a list of test cases >>> evenSumSubarrays_testcases(2, [(4, [1, 2, 3, 4]), (3, [2, 4, 6])]) [4, 6] >>> evenSumSubarrays_testcases(3, [(4, [1, 1, 1, 1]), (4, [1, 2, 2, 1]), (1, [1])]) [4, 4, 0] pass # Sample Test Cases def test_evenSumSubarrays(): assert evenSumSubarrays([1, 2, 3, 4]) == 4 assert evenSumSubarrays([2, 4, 6]) == 6 assert evenSumSubarrays([1, 1, 1, 1]) == 4 assert evenSumSubarrays([1, 2, 2, 1]) == 4 assert evenSumSubarrays([1]) == 0 assert evenSumSubarrays([2]) == 1 assert evenSumSubarrays([]) == 0 assert evenSumSubarrays([10000]) == 1 assert evenSumSubarrays([-1, -1, -1, -1]) == 4 assert evenSumSubarrays([1, 1, 1, 1, 1, 1]) == 9 def test_evenSumSubarrays_testcases(): t = 2 testcases = [ (4, [1, 2, 3, 4]), (3, [2, 4, 6]) ] assert evenSumSubarrays_testcases(t, testcases) == [4, 6] t = 3 testcases = [ (4, [1, 1, 1, 1]), (4, [1, 2, 2, 1]), (1, [1]) ] assert evenSumSubarrays_testcases(t, testcases) == [4, 4, 0]","solution":"def evenSumSubarrays(arr): even_count = 1 # Initially consider empty subarray that sums to 0 which is even odd_count = 0 current_sum = 0 result = 0 for num in arr: current_sum += num if current_sum % 2 == 0: # Even sum result += even_count even_count += 1 else: # Odd sum result += odd_count odd_count += 1 return result def evenSumSubarrays_testcases(t, testcases): results = [] for case in testcases: n, arr = case results.append(evenSumSubarrays(arr)) return results"},{"question":"def shortestToChar(S: str, C: str) -> List[int]: Given a string S and a character C, find the shortest distance from each character in S to C. >>> shortestToChar(\\"loveleetcode\\", 'e') [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] >>> shortestToChar(\\"aab\\", 'b') [2, 1, 0]","solution":"def shortestToChar(S, C): n = len(S) result = [float('inf')] * n # Forward pass to find shortest distances to previous occurrences of C prev = float('-inf') for i in range(n): if S[i] == C: prev = i result[i] = i - prev # Backward pass to find shortest distances to next occurrences of C prev = float('inf') for i in range(n - 1, -1, -1): if S[i] == C: prev = i result[i] = min(result[i], prev - i) return result"},{"question":"def hotel_booking_system(commands): This function processes a list of commands for booking and checking room availability in a hotel with M rooms. The input is a list of commands in form of tuples, where the first command is ('BOOK', x, y) and ('CHECK', z) followed by the respective room range or room number. :param commands: List of commands in form of tuples, where the first element is a string \\"BOOK\\" or \\"CHECK\\" and the rest are integers. :return: List of strings with results for each \\"CHECK\\" command. def test_hotel_booking_system(): commands = [ (10, 5), (\\"BOOK\\", 2, 5), (\\"CHECK\\", 4), (\\"CHECK\\", 6), (\\"BOOK\\", 0, 1), (\\"CHECK\\", 1) ] expected_output = [\\"booked\\", \\"available\\", \\"booked\\"] assert hotel_booking_system(commands) == expected_output commands = [ (15, 6), (\\"BOOK\\", 3, 8), (\\"CHECK\\", 5), (\\"CHECK\\", 9), (\\"BOOK\\", 6, 10), (\\"CHECK\\", 10), (\\"CHECK\\", 8) ] expected_output = [\\"booked\\", \\"available\\", \\"booked\\", \\"booked\\"] assert hotel_booking_system(commands) == expected_output commands = [ (5, 4), (\\"BOOK\\", 1, 2), (\\"CHECK\\", 1), (\\"CHECK\\", 4), (\\"BOOK\\", 0, 0) ] expected_output = [\\"booked\\", \\"available\\"] assert hotel_booking_system(commands) == expected_output def test_no_bookings(): commands = [ (10, 2), (\\"CHECK\\", 0), (\\"CHECK\\", 9) ] expected_output = [\\"available\\", \\"available\\"] assert hotel_booking_system(commands) == expected_output def test_no_checks(): commands = [ (10, 1), (\\"BOOK\\", 1, 1) ] expected_output = [] assert hotel_booking_system(commands) == expected_output def test_single_room(): commands = [ (1, 2), (\\"BOOK\\", 0, 0), (\\"CHECK\\", 0) ] expected_output = [\\"booked\\"] assert hotel_booking_system(commands) == expected_output","solution":"def hotel_booking_system(commands): This function processes a list of commands for booking and checking room availability in a hotel with M rooms. The input is a list of commands, where the first command is 'BOOK' and 'CHECK' followed by the respective room range or room number. :param commands: List of commands, each command is a tuple where the first element is a string \\"BOOK\\" or \\"CHECK\\" and the rest are integers. :return: List of strings with results for each \\"CHECK\\" command. M = commands[0][0] R = commands[0][1] booked_status = [False] * M result = [] for command in commands[1:]: if command[0] == \\"BOOK\\": x, y = command[1], command[2] for room in range(x, y + 1): booked_status[room] = True elif command[0] == \\"CHECK\\": z = command[1] if booked_status[z]: result.append(\\"booked\\") else: result.append(\\"available\\") return result"},{"question":"def min_hand_switches(notes: str) -> int: Determine the minimum number of switches between hands necessary to play the entire sequence of notes. Parameters: notes (str): A string of capital letters 'A' to 'G' representing the sequence of notes. Returns: int: The minimum number of hand switches required. >>> min_hand_switches(\\"AABBC\\") 2 >>> min_hand_switches(\\"AABBCCA\\") 3","solution":"def min_hand_switches(notes): Returns the minimum number of hand switches required to play the entire sequence of notes. if not notes: return 0 switches = 0 current_hand = 'left' # Start with left hand by default for i in range(1, len(notes)): if notes[i] != notes[i-1]: switches += 1 current_hand = 'right' if current_hand == 'left' else 'left' return switches"},{"question":"def min_delivery_cost(n: int) -> int: Determines the minimum delivery cost starting from any city, visiting each city exactly once, and returning to the starting city. >>> min_delivery_cost(1) == 0 >>> min_delivery_cost(2) == 2 >>> min_delivery_cost(3) == 4 >>> min_delivery_cost(4) == 6 >>> min_delivery_cost(5) == 8 >>> min_delivery_cost(6) == 10","solution":"from itertools import permutations def min_delivery_cost(n): def delivery_cost(route): cost = 0 for i in range(len(route) - 1): cost += abs(route[i] - route[i + 1]) cost += abs(route[-1] - route[0]) return cost cities = list(range(1, n + 1)) min_cost = float('inf') for route in permutations(cities): min_cost = min(min_cost, delivery_cost(route)) return min_cost"},{"question":"def min_increasing_subarrays(n: int, safety_levels: List[int]) -> int: Determines the minimum number of subarrays required where each subarray is strictly increasing. Args: n (int): Number of containers. safety_levels (list of int): List of safety levels of the chemicals. Returns: int: Minimum number of strictly increasing subarrays. >>> min_increasing_subarrays(5, [1, 3, 2, 4, 5]) == 2 >>> min_increasing_subarrays(4, [4, 3, 2, 1]) == 4 >>> min_increasing_subarrays(6, [1, 2, 3, 1, 2, 3]) == 2 >>> min_increasing_subarrays(1, [100]) == 1 >>> min_increasing_subarrays(4, [2, 2, 2, 2]) == 4 >>> min_increasing_subarrays(5, [1, 2, 3, 4, 5]) == 1 >>> min_increasing_subarrays(3, [3, 2, 1]) == 3","solution":"def min_increasing_subarrays(n, safety_levels): Determines the minimum number of subarrays required where each subarray is strictly increasing. Args: n (int): Number of containers. safety_levels (list of int): List of safety levels of the chemicals. Returns: int: Minimum number of strictly increasing subarrays. if n == 0: return 0 count = 1 for i in range(1, n): if safety_levels[i] <= safety_levels[i - 1]: count += 1 return count"},{"question":"def ping_pong_tournament(n: int, results: List[Tuple[int, int]]) -> Tuple[List[int], List[int], int]: John is organizing a ping-pong tournament. Each participant will play against every other participant exactly once. Given the number of participants and the results of each match, determine: 1. The number of matches each participant won. 2. The number of matches each participant lost. 3. The participant with the highest number of wins. If there's a tie, return the participant with the smallest identifier. Args: n (int): The number of participants. results (List[Tuple[int, int]]): The results of the matches, where each tuple contains two integers representing the winner and the loser of a match. Returns: Tuple[List[int], List[int], int]: A tuple containing three elements: - A list of integers representing the number of matches each participant won. - A list of integers representing the number of matches each participant lost. - An integer representing the participant identifier with the highest number of wins. Example: >>> ping_pong_tournament(4, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) ([3, 2, 1, 0], [0, 1, 2, 3], 1) >>> ping_pong_tournament(2, [(2, 1)]) ([0, 1], [1, 0], 2)","solution":"def ping_pong_tournament(n, results): wins = [0] * n losses = [0] * n for winner, loser in results: wins[winner - 1] += 1 losses[loser - 1] += 1 max_wins = max(wins) top_winner = min(idx + 1 for idx, win_count in enumerate(wins) if win_count == max_wins) return wins, losses, top_winner # Example usage n = 4 results = [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] print(ping_pong_tournament(n, results))"},{"question":"def max_seeds(n: int, m: int, k: int, l: int) -> Tuple[int, int]: Determine the maximum number of cells that can be planted with type A seeds first, followed by type B seeds without violating respective rules. >>> max_seeds(3, 3, 2, 3) (9, 0) >>> max_seeds(4, 4, 1, 4) (16, 0)","solution":"def max_seeds(n, m, k, l): # Maximum cells that can be planted with type A seeds max_type_a = n * m # Maximum cells that can be planted with type B seeds after planting type A # Since all cells are already used by type A, we cannot plant type B seeds max_type_b = 0 return max_type_a, max_type_b"},{"question":"def mergeSortedArrays(nums1, m, nums2, n): Given two sorted integer arrays, nums1 and nums2, merge nums2 into nums1 as one sorted array in non-decreasing order. Args: nums1 (List[int]): The first sorted array. m (int): Number of elements initialized in nums1. nums2 (List[int]): The second sorted array. n (int): Number of elements initialized in nums2. Returns: List[int]: The merged sorted array. Example: >>> mergeSortedArrays([1,2,3,0,0,0], 3, [2,5,6], 3) [1,2,2,3,5,6] >>> mergeSortedArrays([1], 1, [], 0) [1]","solution":"def mergeSortedArrays(nums1, m, nums2, n): Merges nums2 into nums1 in-place. The first m elements of nums1 and all n elements of nums2 are merged. # Start from the end of nums1 and nums2 i, j, k = m - 1, n - 1, m + n - 1 while j >= 0: if i >= 0 and nums1[i] > nums2[j]: nums1[k] = nums1[i] i -= 1 else: nums1[k] = nums2[j] j -= 1 k -= 1 return nums1"},{"question":"def max_sum_subarray(N, M, A): Returns the maximum sum of any subarray of length M. Parameters: N (int): Length of the array A. M (int): Length of the subarray. A (list of int): The array of integers. Returns: int: The maximum possible sum of subarrays of length exactly M. Examples: >>> max_sum_subarray(5, 3, [2, 1, 5, 1, 3]) 9 >>> max_sum_subarray(5, 1, [2, 1, 5, 1, 3]) 5 >>> max_sum_subarray(5, 5, [2, 1, 5, 1, 3]) 12 >>> max_sum_subarray(5, 3, [-8, -1, -5, -3, -6]) -9 >>> max_sum_subarray(5, 2, [2, -8, 3, -1, 5]) 4 >>> max_sum_subarray(4, 2, [10**9, -10**9, 10**9, -10**9]) 0 >>> max_sum_subarray(1, 1, [42]) 42","solution":"def max_sum_subarray(N, M, A): Returns the maximum sum of any subarray of length M. Parameters: N (int): Length of the array A. M (int): Length of the subarray. A (list of int): The array of integers. Returns: int: The maximum possible sum of subarrays of length exactly M. # Compute the sum of the first subarray of length M current_sum = sum(A[:M]) max_sum = current_sum # Traverse the array to find the maximum sum using sliding window technique for i in range(M, N): current_sum += A[i] - A[i - M] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def add_asterisk_to_usernames(usernames: str) -> str: This function takes a single line of usernames separated by spaces and returns the same usernames each appended with an asterisk '*'. Each username starts with an alphabet character followed by digits. >>> add_asterisk_to_usernames(\\"a123 b456 C789\\") \\"a123* b456* C789*\\" >>> add_asterisk_to_usernames(\\"z0 Y1\\") \\"z0* Y1*\\"","solution":"def add_asterisk_to_usernames(usernames): This function takes a single line of usernames separated by spaces and returns the same usernames each appended with an asterisk '*'. Each username starts with an alphabet character followed by digits. :param usernames: A single line string with multiple usernames separated by spaces. :return: A single line string with each username appended with an asterisk '*'. username_list = usernames.split() modified_usernames = [username + '*' for username in username_list] return ' '.join(modified_usernames)"},{"question":"def minimize_absolute_differences(test_cases): Given an unordered array containing n distinct integers ranging from 1 to n, this function finds a permutation of the array such that the sum of the absolute differences of the elements' indices and their respective values in the permutation is minimized. >>> minimize_absolute_differences([(3, [3, 1, 2]), (4, [2, 4, 1, 3]), (5, [4, 2, 5, 1, 3])]) ['1 2 3', '1 2 3 4', '1 2 3 4 5'] pass def process_input_output(input_text): Process the input text for the minimize_absolute_differences function. >>> process_input_output(\\"3n3n3 1 2n4n2 4 1 3n5n4 2 5 1 3n\\") '1 2 3n1 2 3 4n1 2 3 4 5' pass","solution":"def minimize_absolute_differences(test_cases): results = [] for t in test_cases: n, arr = t results.append(' '.join(map(str, sorted(arr)))) return results # Function to process the input and output def process_input_output(input_text): lines = input_text.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] for i in range(1, 2 * t, 2): n = int(lines[i]) arr = list(map(int, lines[i + 1].split())) test_cases.append((n, arr)) results = minimize_absolute_differences(test_cases) return \\"n\\".join(results)"},{"question":"from typing import List, Tuple def subtree_sums(t: int, test_cases: List[Tuple[int, List[int], List[Tuple[int, int]]]]) -> List[List[int]]: Determines the sum of the values of the nodes for every subtree of the given trees. Parameters: t(int): Number of test cases test_cases(List[Tuple[int, List[int], List[Tuple[int, int]]]]): List containing the details for each test case. Returns: List[List[int]]: A list containing sum of the values of the nodes for every subtree in the order of node values from 1 to n for each test case. Examples: >>> subtree_sums(1, [(4, [1, 2, 3, 4], [(1, 2), (1, 3), (3, 4)])]) [[10, 2, 7, 4]] >>> subtree_sums(1, [(2, [1, 2], [(1,2)])]) [[3, 2]]","solution":"def subtree_sums(t, test_cases): from collections import defaultdict def dfs(node, parent, adj, values, subtree_sum): total = values[node - 1] for neighbor in adj[node]: if neighbor != parent: total += dfs(neighbor, node, adj, values, subtree_sum) subtree_sum[node] = total return total results = [] for case in test_cases: n, values, edges = case adj = defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) subtree_sum = [0] * (n + 1) dfs(1, -1, adj, values, subtree_sum) result = [subtree_sum[i] for i in range(1, n + 1)] results.append(result) return results"},{"question":"def organize_books(n, books): Organizes books by genre and removes duplicate titles. Args: n (int): Number of books. books (list of tuple): List of tuples where each tuple contains a title and a genre. Returns: dict: Dictionary where the key is the genre and the value is a sorted list of unique titles. pass def format_output(organized_books): Formats the output as required. Args: organized_books (dict): Dictionary where the key is the genre and the value is a sorted list of unique titles. Returns: str: Formatted string as per the required output format. pass # Example test cases def test_organize_books(): books = [ (\\"Harry Potter\\", \\"Fantasy\\"), (\\"Twilight\\", \\"Fantasy\\"), (\\"The Hobbit\\", \\"Fantasy\\"), (\\"Harry Potter\\", \\"Fantasy\\"), (\\"Pride and Prejudice\\", \\"Romance\\"), (\\"The Notebook\\", \\"Romance\\"), (\\"Pride and Prejudice\\", \\"Romance\\") ] expected = { \\"Fantasy\\": [\\"Harry Potter\\", \\"The Hobbit\\", \\"Twilight\\"], \\"Romance\\": [\\"Pride and Prejudice\\", \\"The Notebook\\"] } assert organize_books(7, books) == expected def test_format_output(): organized_books = { \\"Fantasy\\": [\\"Harry Potter\\", \\"The Hobbit\\", \\"Twilight\\"], \\"Romance\\": [\\"Pride and Prejudice\\", \\"The Notebook\\"] } expected_output = ( \\"Fantasy:n\\" \\"tHarry Pottern\\" \\"tThe Hobbitn\\" \\"tTwilightn\\" \\"Romance:n\\" \\"tPride and Prejudicen\\" \\"tThe Notebook\\" ) assert format_output(organized_books) == expected_output def test_integration(): books = [ (\\"Harry Potter\\", \\"Fantasy\\"), (\\"Twilight\\", \\"Fantasy\\"), (\\"The Hobbit\\", \\"Fantasy\\"), (\\"Harry Potter\\", \\"Fantasy\\"), (\\"Pride and Prejudice\\", \\"Romance\\"), (\\"The Notebook\\", \\"Romance\\"), (\\"Pride and Prejudice\\", \\"Romance\\") ] organized_books = organize_books(7, books) output = format_output(organized_books) expected_output = ( \\"Fantasy:n\\" \\"tHarry Pottern\\" \\"tThe Hobbitn\\" \\"tTwilightn\\" \\"Romance:n\\" \\"tPride and Prejudicen\\" \\"tThe Notebook\\" ) assert output == expected_output","solution":"def organize_books(n, books): Organizes books by genre and removes duplicate titles. Args: n (int): Number of books. books (list of tuple): List of tuples where each tuple contains a title and a genre. Returns: dict: Dictionary where the key is the genre and the value is a sorted list of unique titles. from collections import defaultdict genre_dict = defaultdict(set) for title, genre in books: genre_dict[genre].add(title) sorted_genres = sorted(genre_dict.keys()) result = {} for genre in sorted_genres: result[genre] = sorted(genre_dict[genre]) return result def format_output(organized_books): Formats the output as required. Args: organized_books (dict): Dictionary where the key is the genre and the value is a sorted list of unique titles. Returns: str: Formatted string as per the required output format. output = [] for genre, titles in organized_books.items(): output.append(f\\"{genre}:\\") for title in titles: output.append(f\\"t{title}\\") return \\"n\\".join(output)"},{"question":"def largest_k_distinct_integers(N: int, K: int, numbers: List[int]) -> List[int]: Find the K largest distinct integers from the list in descending order. If there are fewer than K distinct integers, output all of them in descending order. >>> largest_k_distinct_integers(5, 3, [4, 6, 2, 6, 4]) [6, 4, 2] >>> largest_k_distinct_integers(4, 5, [5, 9, 1, 5]) [9, 5, 1]","solution":"def largest_k_distinct_integers(N, K, numbers): # Find distinct integers distinct_numbers = list(set(numbers)) # Sort in descending order sorted_numbers = sorted(distinct_numbers, reverse=True) # Return the largest K return sorted_numbers[:K]"},{"question":"import numpy as np def array_stats(arr): Given a 1-D array, prints the minimum element, maximum element, mean, and median of the elements of the array. Args: arr: List[int] - A list of integers. Returns: Tuple[int, int, float, float] - A tuple containing the minimum element, maximum element, mean, and median. Example: >>> array_stats([1, 2, 3, 4, 5, 6, 7, 8, 9]) (1, 9, 5.0, 5.0) >>> array_stats([4]) (4, 4, 4.0, 4.0)","solution":"import numpy as np def array_stats(arr): Given a 1-D array, prints the minimum element, maximum element, mean, and median of the elements of the array. np_arr = np.array(arr) min_element = np.min(np_arr) max_element = np.max(np_arr) mean_element = np.mean(np_arr) median_element = np.median(np_arr) return min_element, max_element, mean_element, median_element"},{"question":"from typing import List, Tuple def longest_palindromic_subsequence(s: str) -> int: Determine the length of the longest palindromic subsequence that can be obtained from the string s. Parameters: s (str): The input string consisting of lowercase English letters. Returns: int: The length of the longest palindromic subsequence. Examples: >>> longest_palindromic_subsequence(\\"abca\\") 3 >>> longest_palindromic_subsequence(\\"abcdef\\") 1 >>> longest_palindromic_subsequence(\\"aaa\\") 3 pass # remove this line and implement the function def process_test_cases(test_cases: List[Tuple[int, str]]) -> List[int]: Process multiple test cases to determine the length of the longest palindromic subsequence for each string. Parameters: test_cases (List[Tuple[int, str]]): A list of tuples where each tuple contains an integer (length of the string) and the string itself. Returns: List[int]: A list of integers where each integer is the length of the longest palindromic subsequence for the corresponding string. Examples: >>> process_test_cases([(4, \\"abca\\"), (6, \\"abcdef\\"), (3, \\"aaa\\")]) [3, 1, 3] pass # remove this line and implement the function # Unit Tests: def test_longest_palindromic_subsequence(): assert longest_palindromic_subsequence(\\"abca\\") == 3 assert longest_palindromic_subsequence(\\"abcdef\\") == 1 assert longest_palindromic_subsequence(\\"aaa\\") == 3 assert longest_palindromic_subsequence(\\"racecar\\") == 7 assert longest_palindromic_subsequence(\\"aabbcc\\") == 2 def test_process_test_cases(): test_cases = [(4, \\"abca\\"), (6, \\"abcdef\\"), (3, \\"aaa\\")] expected_results = [3, 1, 3] assert process_test_cases(test_cases) == expected_results test_cases = [(7, \\"racecar\\"), (8, \\"abcdefgh\\"), (5, \\"abcba\\")] expected_results = [7, 1, 5] assert process_test_cases(test_cases) == expected_results","solution":"def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] def process_test_cases(test_cases): results = [] for n, s in test_cases: results.append(longest_palindromic_subsequence(s)) return results # Example usage: # test_cases = [(4, \\"abca\\"), (6, \\"abcdef\\"), (3, \\"aaa\\")] # print(process_test_cases(test_cases))"},{"question":"def shortest_string_length(s: str, k: int) -> int: Returns the length of the shortest possible string after applying the operation exactly k times. >>> shortest_string_length(\\"abccba\\", 2) 2 >>> shortest_string_length(\\"hellocode\\", 1) 7 >>> shortest_string_length(\\"abc\\", 1) 1 >>> shortest_string_length(\\"aabb\\", 2) 0 >>> shortest_string_length(\\"abcd\\", 0) 4 pass def process_test_cases(t: int, test_cases: List[Tuple[str, int]]) -> List[int]: Processes multiple test cases for finding the shortest string length. >>> process_test_cases(2, [(\\"abccba\\", 2), (\\"hellocode\\", 1)]) [2, 7] >>> process_test_cases(3, [(\\"aabb\\", 2), (\\"abc\\", 1), (\\"xyzzxy\\", 3)]) [0, 1, 0] pass","solution":"def shortest_string_length(s, k): Returns the length of the shortest possible string after applying the operation exactly k times. # Length of the initial string initial_length = len(s) # Calculate the final length after performing k operations final_length = initial_length - 2 * k return final_length def process_test_cases(t, test_cases): results = [] for s, k in test_cases: results.append(shortest_string_length(s, k)) return results"},{"question":"def check_uniqueness(T, test_cases): This function checks the uniqueness of participant IDs for multiple test cases. Args: T: The number of test cases. test_cases: A list of tuples where each tuple contains an integer N and a list of N participant IDs. Returns: A list of strings where each string is either \\"UNIQUE\\" or \\"DUPLICATE\\" indicating the uniqueness of each participant ID. >>> check_uniqueness(2, [(5, [1234, 5678, 1234, 9012, 5678]), (3, [1111, 1112, 1113])]) ['UNIQUE', 'UNIQUE', 'DUPLICATE', 'UNIQUE', 'DUPLICATE', 'UNIQUE', 'UNIQUE', 'UNIQUE'] >>> check_uniqueness(1, [(5, [100, 200, 300, 400, 500])]) ['UNIQUE', 'UNIQUE', 'UNIQUE', 'UNIQUE', 'UNIQUE']","solution":"def check_uniqueness(T, test_cases): results = [] for i in range(T): N, ids = test_cases[i] seen_ids = set() for participant_id in ids: if participant_id in seen_ids: results.append(\\"DUPLICATE\\") else: results.append(\\"UNIQUE\\") seen_ids.add(participant_id) return results # Example usage: # T = 2 # test_cases = [ # (5, [1234, 5678, 1234, 9012, 5678]), # (3, [1111, 1112, 1113]) # ] # print(check_uniqueness(T, test_cases)) # Output should be ['UNIQUE', 'UNIQUE', 'DUPLICATE', 'UNIQUE', 'DUPLICATE', 'UNIQUE', 'UNIQUE', 'UNIQUE']"},{"question":"from typing import List def compare_adjacent(n: int, arr: List[int]) -> List[int]: Given an array of n integers, return a new array where each element is the product of adjacent elements from the input array. The length of the array should be at least 2 and at most 1000. The value of each element should be between 1 and 1000. >>> compare_adjacent(5, [1, 2, 3, 4, 5]) [2, 6, 12, 20] >>> compare_adjacent(3, [10, 20, 30]) [200, 600] >>> compare_adjacent(4, [3, 7, 1, 8]) [21, 7, 8]","solution":"from typing import List def compare_adjacent(n: int, arr: List[int]) -> List[int]: Given an array of n integers, returns a new array where each element is the product of adjacent elements from the input array. result = [arr[i] * arr[i + 1] for i in range(n - 1)] return result"},{"question":"def calculate_max_profit(prices, queries): Calculate the maximum profit for each query. Args: prices: List of integers representing daily closing prices. queries: List of tuples (l, r) where l and r represent the range of days (1-indexed). Returns: List of integers representing the maximum profit for each query. # Your code here from typing import List, Tuple def test_calculate_max_profit(): prices = [7, 1, 5, 3, 6, 4] queries = [(1, 6), (2, 4)] results = calculate_max_profit(prices, queries) assert results == [5, 4] def test_calculate_max_profit_single_day(): prices = [7, 1, 5, 3, 6, 4] queries = [(2, 2), (3, 3)] results = calculate_max_profit(prices, queries) assert results == [0, 0] def test_calculate_max_profit_no_profit(): prices = [7, 6, 4, 3, 1] queries = [(1, 5)] results = calculate_max_profit(prices, queries) assert results == [0] def test_calculate_max_profit_long_period(): prices = [1, 2, 3, 4, 5, 6] queries = [(1, 6)] results = calculate_max_profit(prices, queries) assert results == [5] def test_calculate_max_profit_alternate_prices(): prices = [1, 2, 3, 4, 3, 2, 1] queries = [(1, 7), (2, 5)] results = calculate_max_profit(prices, queries) assert results == [3, 2] if __name__ == \\"__main__\\": test_calculate_max_profit() test_calculate_max_profit_single_day() test_calculate_max_profit_no_profit() test_calculate_max_profit_long_period() test_calculate_max_profit_alternate_prices() print(\\"All tests passed.\\")","solution":"def calculate_max_profit(prices, queries): Calculate the maximum profit for each query. Args: prices: List of integers representing daily closing prices. queries: List of tuples (l, r) where l and r represent the range of days (1-indexed). Returns: List of integers representing the maximum profit for each query. results = [] for l, r in queries: max_profit = 0 min_price = float('inf') for i in range(l-1, r): if prices[i] < min_price: min_price = prices[i] elif prices[i] - min_price > max_profit: max_profit = prices[i] - min_price results.append(max_profit) return results"},{"question":"def count_valley_cells(grid: List[List[int]], N: int, M: int) -> int: Determine the number of \\"valley\\" cells in the grid. A cell is considered a \\"valley\\" if its height is strictly less than the height of all its 4-directionally adjacent cells (top, bottom, left, and right). >>> count_valley_cells([[5, 4, 5], [4, 1, 4], [5, 4, 5]], 3, 3) 1 >>> count_valley_cells([[10, 20, 20, 10], [20, 5, 5, 20], [20, 5, 5, 20], [10, 20, 20, 10]], 4, 4) 4 >>> count_valley_cells([[3, 3, 3], [3, 1, 3]], 2, 3) 1 # Implementation goes here from typing import List def test_single_valley_case(): grid = [ [5, 4, 5], [4, 1, 4], [5, 4, 5] ] assert count_valley_cells(grid, 3, 3) == 1 def test_multiple_valleys_case(): grid = [ [10, 20, 20, 10], [20, 5, 5, 20], [20, 5, 5, 20], [10, 20, 20, 10] ] assert count_valley_cells(grid, 4, 4) == 4 def test_edge_valley_case(): grid = [ [3, 3, 3], [3, 1, 3] ] assert count_valley_cells(grid, 2, 3) == 1 def test_no_valley_case(): grid = [ [2, 2, 2], [2, 2, 2], [2, 2, 2] ] assert count_valley_cells(grid, 3, 3) == 0 def test_large_flat_case(): grid = [[1000] * 2000 for _ in range(2000)] assert count_valley_cells(grid, 2000, 2000) == 0","solution":"def count_valley_cells(grid, N, M): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valley(i, j): for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < N and 0 <= nj < M and grid[i][j] >= grid[ni][nj]: return False return True valley_count = 0 for i in range(N): for j in range(M): if is_valley(i, j): valley_count += 1 return valley_count if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) grid = [] idx = 2 for _ in range(N): row = list(map(int, data[idx:idx + M])) grid.append(row) idx += M print(count_valley_cells(grid, N, M))"},{"question":"def count_possible_strings(s): Returns the count of all possible strings that can be formed by replacing '*' with any lowercase English letter. >>> count_possible_strings(\\"abcdef\\") == 1 >>> count_possible_strings(\\"a*c\\") == 26 >>> count_possible_strings(\\"b**d\\") == 676 >>> count_possible_strings(\\"*a*b*\\") == 17576 >>> count_possible_strings(\\"****\\") == 456976 >>> count_possible_strings(\\"a*bc*de*f\\") == 17576 >>> count_possible_strings(\\"******\\") == 308915776","solution":"def count_possible_strings(s): Returns the count of all possible strings that can be formed by replacing '*' with any lowercase English letter. count_stars = s.count('*') return 26 ** count_stars"},{"question":"def highestElevationGain(n, elevations, queries): Returns the highest elevation gain for each segment described in queries. Parameters: n (int): the number of elevation measurements. elevations (list): the array of elevation measurements. queries (list of lists): query pairs representing the start and end indices of segments. Returns: list: the highest elevation gain between any two adjacent points for each segment described. Example: >>> highestElevationGain(5, [2, 3, 5, 1, 4], [(0,2),(1,4)]) [2, 3] >>> highestElevationGain(3, [1, 2, 3], [(0,2)]) [1]","solution":"def highestElevationGain(n, elevations, queries): Returns the highest elevation gain for each segment described in queries. Parameters: n (int): the number of elevation measurements. elevations (list): the array of elevation measurements. queries (list of lists): query pairs representing the start and end indices of segments. Returns: list: the highest elevation gain between any two adjacent points for each segment described. results = [] for query in queries: start, end = query max_gain = float('-inf') for i in range(start, end): gain = elevations[i+1] - elevations[i] if gain > max_gain: max_gain = gain results.append(max_gain) return results"},{"question":"def min_flips(s: str, t: str) -> int: Returns the minimum number of flips needed to make binary string s equal to binary string t. >>> min_flips(\\"010\\", \\"100\\") 2 >>> min_flips(\\"1111\\", \\"0000\\") 4 >>> min_flips(\\"1100\\", \\"1010\\") 2 >>> min_flips(\\"1010\\", \\"1010\\") 0 >>> min_flips(\\"0000\\", \\"1111\\") 4 >>> min_flips(\\"010101\\", \\"101010\\") 6 >>> min_flips(\\"110011\\", \\"001100\\") 6 pass","solution":"def min_flips(s, t): Returns the minimum number of flips needed to make binary string s equal to binary string t. if len(s) != len(t): raise ValueError(\\"Strings s and t must be of the same length.\\") flip_count = 0 for char_s, char_t in zip(s, t): if char_s != char_t: flip_count += 1 return flip_count"},{"question":"def determine_winner(N: int, grid: List[List[int]]) -> str: Determines the winner of the game given the grid. Args: - N: int, size of the grid (N x N) - grid: List[List[int]], the initial state of the grid Returns: - str, \\"Player 1\\" if Player 1 wins and \\"Player 2\\" if Player 2 wins Example: >>> determine_winner(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 'Player 2' >>> determine_winner(2, [[9, 8], [7, 6]]) 'Player 1' from solution import determine_winner def test_determine_winner_example_1(): N = 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert determine_winner(N, grid) == \\"Player 2\\" def test_determine_winner_example_2(): N = 2 grid = [ [9, 8], [7, 6] ] assert determine_winner(N, grid) == \\"Player 1\\" def test_determine_winner_small_grid(): N = 2 grid = [ [1, 1], [1, 1] ] assert determine_winner(N, grid) == \\"Player 1\\" def test_determine_winner_large_grid(): N = 5 grid = [ [i for i in range(1, 6)], [i for i in range(6, 11)], [i for i in range(11, 16)], [i for i in range(16, 21)], [i for i in range(21, 26)] ] assert determine_winner(N, grid) == \\"Player 2\\" def test_determine_winner_even_odd_small(): N = 3 grid = [ [1, 0, 1], [0, 1, 0], [1, 0, 1] ] assert determine_winner(N, grid) == \\"Player 2\\" N = 4 grid = [ [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1] ] assert determine_winner(N, grid) == \\"Player 1\\"","solution":"def determine_winner(N, grid): Determines the winner of the game given the grid. Args: - N: int, size of the grid (N x N) - grid: List[List[int]], the initial state of the grid Returns: - str, \\"Player 1\\" if Player 1 wins and \\"Player 2\\" if Player 2 wins # The key observation is to leverage the parity of N # Player 1 wins if N is odd, Player 2 wins if N is even if N % 2 == 0: return \\"Player 1\\" else: return \\"Player 2\\""},{"question":"def nextPermutation(N: int, S: str) -> str: Returns the next lexicographical permutation of the string S. If no such permutation exists, returns the string sorted in ascending order. >>> nextPermutation(3, \\"abc\\") 'acb' >>> nextPermutation(3, \\"cba\\") 'abc'","solution":"def nextPermutation(N, S): Returns the next lexicographical permutation of the string S. If no such permutation exists, returns the string sorted in ascending order. # Convert string to a list of characters to perform manipulation lst = list(S) # Step 1: Find the largest index i such that lst[i] < lst[i + 1] i = N - 2 while i >= 0 and lst[i] >= lst[i + 1]: i -= 1 # If no such index exists, the string is in descending order. # Return the string sorted in ascending order. if i == -1: return ''.join(sorted(lst)) # Step 2: Find the largest index j greater than i such that lst[i] < lst[j] j = N - 1 while lst[i] >= lst[j]: j -= 1 # Step 3: Swap the value of lst[i] with that of lst[j] lst[i], lst[j] = lst[j], lst[i] # Step 4: Reverse the sequence from lst[i + 1] up to and including the final element lst[N-1] lst = lst[:i + 1] + lst[i + 1:][::-1] # Convert list back to string and return return ''.join(lst)"},{"question":"def min_operations_to_make_non_decreasing(arr): Returns the minimum number of operations required to make the array non-decreasing. >>> min_operations_to_make_non_decreasing([1, 3, 2, 5, 4]) 2 >>> min_operations_to_make_non_decreasing([10, 20, 30, 40]) 0 pass def solve_test_cases(T, test_cases): For each test case, output the minimum number of operations required to make the array non-decreasing. >>> T = 2 >>> test_cases = [ (5, [1, 3, 2, 5, 4]), (4, [10, 20, 30, 40]) ] >>> solve_test_cases(T, test_cases) [2, 0] pass","solution":"def min_operations_to_make_non_decreasing(arr): Returns the minimum number of operations required to make the array non-decreasing. operations = 0 n = len(arr) for i in range(1, n): if arr[i] < arr[i - 1]: operations += (arr[i - 1] - arr[i]) arr[i] = arr[i - 1] return operations def solve_test_cases(T, test_cases): results = [] for i in range(T): N, arr = test_cases[i] results.append(min_operations_to_make_non_decreasing(arr)) return results"},{"question":"def largest_sum_of_unique_pages(n: int, pages: List[int]) -> int: Returns the largest possible number of pages the king can read without reading a book with the same number of pages twice. Parameters: n (int): the total number of books in the library pages (list of int): the number of pages in each book Returns: int: the largest possible number of pages the king can read Examples: >>> largest_sum_of_unique_pages(5, [100, 200, 300, 400, 500]) 1500 >>> largest_sum_of_unique_pages(6, [50, 50, 50, 50, 50, 50]) 50 >>> largest_sum_of_unique_pages(7, [10, 20, 20, 10, 30, 40, 50]) 150","solution":"def largest_sum_of_unique_pages(n, pages): Returns the largest possible number of pages the king can read without reading a book with the same number of pages twice. Parameters: n (int): the total number of books in the library pages (list of int): the number of pages in each book Returns: int: the largest possible number of pages the king can read unique_pages = set(pages) return sum(unique_pages)"},{"question":"def minimum_benches_and_last_bench_seating(n: int, c: int) -> (int, int): Determines the minimum number of benches needed to seat all n friends where each bench can hold up to c friends, and the number of friends on the last bench. :param n: Total number of friends, where 1 ≤ n ≤ 10^18 :param c: Seating capacity of each bench, where 1 ≤ c ≤ 10^18 :return: A tuple of (minimum number of benches, friends seated on the last bench) >>> minimum_benches_and_last_bench_seating(15, 6) (3, 3) >>> minimum_benches_and_last_bench_seating(28, 7) (4, 7) >>> minimum_benches_and_last_bench_seating(17, 5) (4, 2) >>> minimum_benches_and_last_bench_seating(5, 5) (1, 5) >>> minimum_benches_and_last_bench_seating(100, 1) (100, 1) >>> minimum_benches_and_last_bench_seating(1, 10) (1, 1) >>> minimum_benches_and_last_bench_seating(10, 2) (5, 2) >>> minimum_benches_and_last_bench_seating(1, 1) (1, 1) >>> minimum_benches_and_last_bench_seating(10**18, 10**18) (1, 10**18)","solution":"def minimum_benches_and_last_bench_seating(n, c): Determines the minimum number of benches needed to seat all n friends where each bench can hold up to c friends, and the number of friends on the last bench. :param n: Total number of friends :param c: Seating capacity of each bench :return: A tuple of (minimum number of benches, friends seated on the last bench) # Calculate the number of fully occupied benches full_benches = n // c # Calculate the number of friends on the last bench remaining_friends = n % c # If there are no remaining friends, all benches are fully occupied if remaining_friends == 0: return (full_benches, c) else: # Otherwise, we need one more bench for the remaining friends return (full_benches + 1, remaining_friends)"},{"question":"def sieve_of_eratosthenes(n: int) -> list: Generates a list of prime numbers up to a given integer 'n'. Parameters: n (int): The upper limit for generating prime numbers (inclusive). Returns: list: A list of prime numbers up to 'n'. >>> sieve_of_eratosthenes(10) == [2, 3, 5, 7] >>> sieve_of_eratosthenes(20) == [2, 3, 5, 7, 11, 13, 17, 19] >>> sieve_of_eratosthenes(2) == [2] >>> sieve_of_eratosthenes(3) == [2, 3] >>> sieve_of_eratosthenes(1) == [] # Implement the sieve of Eratosthenes algorithm to generate prime numbers def prime_numbers_up_to_n(test_cases: list) -> list: For each test case, print all prime numbers less than or equal to 'n' in ascending order. Parameters: test_cases (list of int): List of integers for each test case. Returns: list of str: List where each entry is a string of prime numbers for that test case. >>> prime_numbers_up_to_n([10, 20]) == ['2 3 5 7', '2 3 5 7 11 13 17 19'] >>> prime_numbers_up_to_n([5]) == ['2 3 5'] >>> prime_numbers_up_to_n([12, 5, 3]) == ['2 3 5 7 11', '2 3 5', '2 3'] # For each test case, use sieve_of_eratosthenes function to find primes and format the results","solution":"def sieve_of_eratosthenes(n): Generates a list of prime numbers up to a given integer n. Parameters: n (int): The upper limit for generating prime numbers (inclusive). Returns: list: A list of prime numbers up to n. primes = [] is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False for i in range(2, n + 1): if is_prime[i]: primes.append(i) for j in range(i * i, n + 1, i): is_prime[j] = False return primes def prime_numbers_up_to_n(test_cases): For each test case, print all prime numbers less than or equal to n in ascending order. Parameters: test_cases (list of int): List of integers for each test case. Returns: list of str: List where each entry is a string of prime numbers for that test case. results = [] for n in test_cases: primes = sieve_of_eratosthenes(n) results.append(' '.join(map(str, primes))) return results"},{"question":"from typing import List def decode_intervals(intervals: List[str]) -> List[str]: Write a function \`decode_intervals\` that takes a list of strings representing intervals and returns the merged list of intervals. Each string in the input list is of the form 'start-end', where start and end are integers representing the interval (inclusive). The function should merge overlapping intervals and return a list of intervals in string format sorted by the starting point of each interval. Example: >>> decode_intervals([\\"1-3\\", \\"2-4\\", \\"6-8\\", \\"7-9\\"]) [\\"1-4\\", \\"6-9\\"] pass","solution":"from typing import List def decode_intervals(intervals: List[str]) -> List[str]: # Parse the intervals strings into a list of tuples intervals = [tuple(map(int, i.split('-'))) for i in intervals] # Sort the intervals by their start values intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: merged[-1] = (merged[-1][0], max(merged[-1][1], interval[1])) # Convert merged intervals back to the 'start-end' string format return [f\\"{start}-{end}\\" for start, end in merged]"},{"question":"def is_valid_pattern(pattern: str) -> bool: Determines if the given string \`pattern\` is a valid pattern based on the rules. A pattern is valid if: 1. It is empty. 2. It starts with \`A\` and ends with \`C\`. 3. There is exactly one \`B\` between \`A\` and \`C\`. Examples: >>> is_valid_pattern(\\"ABC\\") True >>> is_valid_pattern(\\"AABCC\\") False >>> is_valid_pattern(\\"AC\\") False >>> is_valid_pattern(\\"\\") True >>> is_valid_pattern(\\"ABBC\\") False pass def test_is_valid_pattern(): # Test cases assert is_valid_pattern(\\"ABC\\") == True, \\"Test case 'ABC' failed\\" assert is_valid_pattern(\\"AABCC\\") == False, \\"Test case 'AABCC' failed\\" assert is_valid_pattern(\\"AC\\") == False, \\"Test case 'AC' failed\\" assert is_valid_pattern(\\"\\") == True, \\"Test case '' (empty string) failed\\" assert is_valid_pattern(\\"ABBC\\") == False, \\"Test case 'ABBC' failed\\" assert is_valid_pattern(\\"ACABAC\\") == False, \\"Test case 'ACABAC' failed\\" assert is_valid_pattern(\\"A\\") == False, \\"Test case 'A' failed\\" assert is_valid_pattern(\\"C\\") == False, \\"Test case 'C' failed\\" assert is_valid_pattern(\\"AB\\") == False, \\"Test case 'AB' failed\\" assert is_valid_pattern(\\"BC\\") == False, \\"Test case 'BC' failed\\" print(\\"All test cases passed!\\") test_is_valid_pattern()","solution":"def is_valid_pattern(pattern: str) -> bool: Determines if the given string \`pattern\` is a valid pattern based on the rules. Args: pattern (str): The input string pattern to be checked. Returns: bool: True if the pattern is valid, False otherwise. # Rule 1: A pattern is valid if it is empty. if not pattern: return True # Rule 2: A pattern is valid if it starts with \`A\` and ends with \`C\`. if pattern[0] != 'A' or pattern[-1] != 'C': return False # Rule 3: Between the \`A\` and \`C\`, there must be exactly one \`B\`. middle = pattern[1:-1] return middle == \\"B\\""},{"question":"def can_form_palindrome(n: int, potions: List[int]) -> str: Determine whether a given sequence of potions can be rearranged into a palindrome. >>> can_form_palindrome(5, [1, 2, 3, 2, 1]) \\"YES\\" >>> can_form_palindrome(6, [1, 2, 3, 3, 2, 1]) \\"YES\\" >>> can_form_palindrome(4, [1, 2, 3, 4]) \\"NO\\"","solution":"def can_form_palindrome(n, potions): from collections import Counter # Count the frequency of each type of potion counts = Counter(potions) # Check the number of potions that have an odd count odd_count = sum(1 for count in counts.values() if count % 2 != 0) # If at most one type of potion has an odd count, it can be rearranged to form a palindrome if odd_count <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def smallest_number_after_deletion(number: int) -> int: This function takes a single N-digit number and returns the smallest possible number after deleting one digit. >>> smallest_number_after_deletion(635) 35 >>> smallest_number_after_deletion(89) 8 >>> smallest_number_after_deletion(1029) 29 pass def process_test_cases(test_cases: List[int]) -> List[int]: This function takes a list of N-digit numbers and returns a list of the smallest possible numbers after deleting one digit from each number. >>> process_test_cases([635, 89, 1029]) [35, 8, 29] >>> process_test_cases([100, 2501, 54321]) [0, 201, 4321] pass","solution":"def smallest_number_after_deletion(number): This function takes a single N-digit number and returns the smallest possible number after deleting one digit. smallest = float('inf') number_str = str(number) for i in range(len(number_str)): new_number_str = number_str[:i] + number_str[i+1:] new_number = int(new_number_str) if new_number < smallest: smallest = new_number return smallest def process_test_cases(test_cases): results = [] for number in test_cases: results.append(smallest_number_after_deletion(number)) return results"},{"question":"def is_unique(s: str) -> bool: Checks if all characters in a given string are unique. Args: s (str): The string to be checked for unique characters. Returns: bool: True if all characters are unique, False otherwise. >>> is_unique(\\"hello\\") False >>> is_unique(\\"world\\") True >>> is_unique(\\"Python\\") True","solution":"def is_unique(s): Returns True if all characters in the string s are unique, False otherwise. The function is case-sensitive. return len(set(s)) == len(s)"},{"question":"from typing import List, Tuple def max_elegance(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: This function receives the number of test cases and a list of test cases themselves. Each test case is a tuple where the first element is the size of the array and the second element is the array itself. It returns a list of maximum elegance for each test case. >>> max_elegance(3, [(5, [1, 2, 2, 3, 3]), (6, [5, 5, 5, 5, 5, 5]), (4, [1, 2, 3, 4])]) [2, 6, 1] >>> max_elegance(1, [(2, [1, 1])]) [2] >>> max_elegance(1, [(3, [2, 2, 3])]) [2] >>> max_elegance(2, [(1, [7]), (3, [3, 3, 3])]) [1, 3] >>> max_elegance(1, [(6, [1, 2, 2, 3, 3, 1])]) [2]","solution":"def max_elegance(T, test_cases): This function receives the number of test cases and a list of test cases themselves. Each test case is a tuple where the first element is the size of the array and the second element is the array itself. It returns a list of maximum elegance for each test case. from collections import Counter results = [] for N, A in test_cases: if N == 0: results.append(0) continue # Calculate the frequency of each element in the array freq = Counter(A) # The maximum elegance is the maximum frequency of any element max_freq = max(freq.values()) results.append(max_freq) return results # Helper function to parse input def parse_input(input_string): inputs = list(map(int, input_string.split())) T = inputs.pop(0) test_cases = [] i = 0 while i < len(inputs): N = inputs[i] array = inputs[i + 1 : i + 1 + N] test_cases.append((N, array)) i += N + 1 return T, test_cases"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root, sum): Returns the number of paths that sum to the given value in a binary tree. >>> root = TreeNode( ... 10, ... TreeNode(5, TreeNode(3, TreeNode(3), TreeNode(-2)), ... TreeNode(2, None, TreeNode(1))), ... TreeNode(-3, None, TreeNode(11)) ... ) >>> pathSum(root, 8) 3 >>> root = None >>> pathSum(root, 8) 0 >>> root = TreeNode(1) >>> pathSum(root, 1) 1 >>> root = TreeNode( ... 1, ... TreeNode(2, TreeNode(3)), ... TreeNode(-1) ... ) >>> pathSum(root, 3) 2 >>> root = TreeNode( ... 1, ... TreeNode(-2, TreeNode(1, TreeNode(-1)), TreeNode(3)), ... TreeNode(-3, None, TreeNode(-2)) ... ) >>> pathSum(root, -1) 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root, sum): Returns the number of paths that sum to the given value. def dfs(node, current_sum): if node is None: return 0 # Check the current path current_sum += node.val path_count = prefix_sums.get(current_sum - sum, 0) # Update the prefix_sums with the current path prefix_sums[current_sum] = prefix_sums.get(current_sum, 0) + 1 # Traverse the left and right children path_count += dfs(node.left, current_sum) path_count += dfs(node.right, current_sum) # Revert the current path sum state for other paths (backtracking) prefix_sums[current_sum] -= 1 return path_count # Dictionary to store sum frequencies prefix_sums = {0: 1} return dfs(root, 0)"},{"question":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None def is_valid_bst(root: Node) -> bool: Check if a binary tree is a valid Binary Search Tree (BST). A binary tree is a BST if, for each node, all elements in the left subtree are less than the node, and all elements in the right subtree are greater than the node. >>> root = Node(2) >>> root.left = Node(1) >>> root.right = Node(3) >>> is_valid_bst(root) True >>> root = Node(5) >>> root.left = Node(1) >>> root.right = Node(4) >>> root.right.left = Node(3) >>> root.right.right = Node(6) >>> is_valid_bst(root) False","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None def is_valid_bst(root, low=float('-inf'), high=float('inf')): if not root: return True if root.value <= low or root.value >= high: return False return is_valid_bst(root.left, low, root.value) and is_valid_bst(root.right, root.value, high)"},{"question":"from typing import List def can_reorder_string(s: str) -> str: Determine if you can reorder the string such that no two adjacent characters are the same. Args: s (str): A string consisting of lowercase letters. Returns: str: \\"Yes\\" followed by one such reordering of the string if possible, otherwise \\"No\\". Examples: >>> can_reorder_string(\\"aaabb\\") 'Yesnababa' >>> can_reorder_string(\\"aaaa\\") 'No' >>> can_reorder_string(\\"aabbcc\\") 'Yesnabcabc' pass import pytest def test_can_reorder_string_example1(): assert can_reorder_string(\\"aaabb\\") == \\"Yesnababa\\" def test_can_reorder_string_example2(): assert can_reorder_string(\\"aaaa\\") == \\"No\\" def test_can_reorder_string_example3(): result = can_reorder_string(\\"aabbcc\\") assert result.startswith(\\"Yesn\\") assert result[4:] in [\\"abcabc\\", \\"acbabc\\", \\"bacbac\\", \\"babcac\\", \\"cabacb\\", \\"cbacba\\"] def test_all_same_character(): assert can_reorder_string(\\"aaaaaaa\\") == \\"No\\" def test_two_different_characters(): result = can_reorder_string(\\"aab\\") assert result == \\"Yesnaba\\" def test_multiple_characters(): result = can_reorder_string(\\"aabbccdd\\") assert result.startswith(\\"Yesn\\") assert result[4:] in [\\"abcdabcd\\", \\"abacbdcd\\", \\"abadcbcd\\", \\"ababcdcd\\"] def test_single_character(): assert can_reorder_string(\\"a\\") == \\"Yesna\\" def test_large_input(): input_str = \\"a\\" * 50000 + \\"b\\" * 50000 result = can_reorder_string(input_str) assert result.startswith(\\"Yesn\\") assert len(result[4:]) == 100000 assert all(result[i] != result[i + 1] for i in range(len(result) - 5))","solution":"from collections import Counter import heapq def can_reorder_string(s: str) -> str: # Count frequency of each character freq = Counter(s) max_count = max(freq.values()) # Check if the rearrangement is possible if max_count > (len(s) + 1) // 2: return \\"No\\" # Create a max heap based on frequencies max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char return \\"Yesn\\" + ''.join(result)"},{"question":"def generate_rna_sequences(sequence): Generates all possible valid RNA sequences by replacing each 'N' in the input sequence with all possible nucleotides ('A', 'C', 'G', 'U'). >>> generate_rna_sequences(\\"AUGCN\\") ['AUGCA', 'AUGCC', 'AUGCG', 'AUGCU'] >>> generate_rna_sequences(\\"NAGC\\") ['AAGC', 'CAGC', 'GAGC', 'UAGC']","solution":"def generate_rna_sequences(sequence): Generates all possible valid RNA sequences by replacing each 'N' in the input sequence with all possible nucleotides ('A', 'C', 'G', 'U'). if not sequence: return [''] nucleotides = ['A', 'C', 'G', 'U'] result = [''] for char in sequence: if char == 'N': result = [seq + nucleotide for seq in result for nucleotide in nucleotides] else: result = [seq + char for seq in result] return result"},{"question":"def can_assign_requests_to_nodes(N, M, capacities, demands): Determine if it is possible to assign all service requests to nodes without exceeding any node's capacity. Args: N (int): Number of nodes. M (int): Number of service requests. capacities (List[int]): Capacities of each node. demands (List[int]): Capacities required by each service request. Returns: str: \\"Possible\\" if all service requests can be assigned to nodes without exceeding capacities, otherwise \\"Impossible\\". >>> can_assign_requests_to_nodes(3, 4, [6, 7, 8], [4, 3, 5, 2]) \\"Possible\\" >>> can_assign_requests_to_nodes(2, 3, [5, 5], [4, 6, 3]) \\"Impossible\\" >>> can_assign_requests_to_nodes(1, 2, [10], [4, 5]) \\"Possible\\" >>> can_assign_requests_to_nodes(3, 1, [5, 5, 5], [10]) \\"Impossible\\" >>> can_assign_requests_to_nodes(2, 2, [1000, 1000], [999, 1000]) \\"Possible\\" >>> can_assign_requests_to_nodes(3, 3, [1, 2, 3], [3, 2, 1]) \\"Possible\\" >>> can_assign_requests_to_nodes(3, 3, [0, 0, 0], [1, 1, 1]) \\"Impossible\\"","solution":"def can_assign_requests_to_nodes(N, M, capacities, demands): capacities.sort(reverse=True) demands.sort(reverse=True) for demand in demands: assigned = False for i in range(N): if capacities[i] >= demand: capacities[i] -= demand assigned = True break if not assigned: return \\"Impossible\\" return \\"Possible\\" def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) capacities = list(map(int, data[2:N+2])) demands = list(map(int, data[N+2:N+2+M])) print(can_assign_requests_to_nodes(N, M, capacities, demands)) if __name__ == \\"__main__\\": main()"},{"question":"def maxProductOfThree(nums): Given a list of integers, find the maximum product of any three distinct elements. If no such triplet exists, return -1. Example 1: >>> maxProductOfThree([1, 2, 3, 4]) 24 Example 2: >>> maxProductOfThree([-10, -10, 1, 3, 2]) 300 Example 3: >>> maxProductOfThree([1, 2]) -1 Args: nums: List[int] Returns: int","solution":"def maxProductOfThree(nums): Returns the maximum product of any three distinct elements in nums. If fewer than 3 elements, returns -1. if len(nums) < 3: return -1 nums.sort() # The maximum product of three numbers can either be: # 1. The product of the three largest numbers # 2. The product of the two smallest (most negative) numbers and the largest number return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def solve_grid_puzzle(T, test_cases): Generate one possible solution for filling the grid according to the rules: 1. Every integer in row i (1 ≤ i ≤ R) must be unique within that row. 2. Every integer in column j (1 ≤ j ≤ C) must be unique within that column. Args: T: Number of test cases test_cases: List of tuples containing (R, C) for each test case Returns: List of results for each test case, which is in turn a list of lists representing the grid or \\"Impossible\\". >>> solve_grid_puzzle(1, [(1, 1)]) [[[1]]] >>> solve_grid_puzzle(1, [(3, 3)]) [[[1, 2, 3], [4, 5, 6], [7, 8, 9]]] >>> solve_grid_puzzle(1, [(2, 4)]) [[[1, 2, 3, 4], [5, 6, 7, 8]]] >>> solve_grid_puzzle(1, [(101, 1)]) [\\"Impossible\\"] pass def format_results(results): Format the results to match the required output format. Args: results: List of results from solve_grid_puzzle function Returns: List of formatted output strings >>> format_results([[[1, 2, 3], [4, 5, 6], [7, 8, 9]]]) [\\"1 2 3\\", \\"4 5 6\\", \\"7 8 9\\"] >>> format_results([\\"Impossible\\"]) [\\"Impossible\\"] pass def grid_puzzle_main(): Main function to read input, process the test cases and print the results in the required format. pass","solution":"def solve_grid_puzzle(T, test_cases): results = [] for R, C in test_cases: if R > 100 or C > 100: results.append(\\"Impossible\\") continue grid = [[0] * C for _ in range(R)] if R == 1 and C == 1: grid[0][0] = 1 else: num = 1 for i in range(R): for j in range(C): grid[i][j] = num num += 1 results.append(grid) return results def format_results(results): formatted_output = [] for result in results: if result == \\"Impossible\\": formatted_output.append(\\"Impossible\\") else: for row in result: formatted_output.append(\\" \\".join(map(str, row))) return formatted_output def grid_puzzle_main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [] index = 1 for _ in range(T): R, C = int(data[index]), int(data[index + 1]) test_cases.append((R, C)) index += 2 results = solve_grid_puzzle(T, test_cases) formatted_output = format_results(results) for line in formatted_output: print(line)"},{"question":"def lunar_event_duration(events: str) -> int: Calculate the total number of hours Luna spends watching lunar events. Capping the total duration to 8 hours per day due to the required separation. Parameters: events (str): A sequence of 'P' and 'T' denoting partial and total lunar eclipses. Returns: int: The total number of hours spent watching lunar events, capped at 8 hours. pass def total_watching_hours(test_cases: List[str]) -> List[int]: Process multiple test cases. Parameters: test_cases (list): A list of strings each representing a sequence of lunar events for a day. Returns: list: A list of integers where each integer is the capped total number of hours for the corresponding day's events. pass def test_lunar_event_duration(): assert lunar_event_duration(\\"PTP\\") == 8 assert lunar_event_duration(\\"PTPTPP\\") == 8 assert lunar_event_duration(\\"TTTTPPPT\\") == 8 assert lunar_event_duration(\\"P\\") == 3 assert lunar_event_duration(\\"T\\") == 5 assert lunar_event_duration(\\"PPP\\") == 8 # 3+1+3+1+3 but capped at 8 assert lunar_event_duration(\\"TT\\") == 8 # 5+1+5 but capped at 8 assert lunar_event_duration(\\"PPTT\\") == 8 # 3+1+3+1+5 but capped at 8 def test_total_watching_hours(): result = total_watching_hours([\\"PTP\\", \\"PTPTPP\\", \\"TTTTPPPT\\", \\"P\\", \\"T\\", \\"PPP\\", \\"TT\\", \\"PPTT\\"]) expected = [8, 8, 8, 3, 5, 8, 8, 8] assert result == expected if __name__ == \\"__main__\\": test_lunar_event_duration() test_total_watching_hours() print(\\"All tests passed.\\")","solution":"def lunar_event_duration(events): Calculate the total number of hours Luna spends watching lunar events. Capping the total duration to 8 hours per day due to the required separation. Parameters: events (str): A sequence of 'P' and 'T' denoting partial and total lunar eclipses. Returns: int: The total number of hours spent watching lunar events, capped at 8 hours. DURATION = {'P': 3, 'T': 5} MAX_HOURS = 8 total_hours = 0 for event in events: total_hours += DURATION[event] + 1 # include the 1-hour gap if total_hours >= MAX_HOURS: return MAX_HOURS # If total hours is less than MAX_HOURS, subtract the last 1 hour gap added if total_hours > 0: total_hours -= 1 return min(total_hours, MAX_HOURS) def total_watching_hours(test_cases): Process multiple test cases. Parameters: test_cases (list): A list of strings each representing a sequence of lunar events for a day. Returns: list: A list of integers where each integer is the capped total number of hours for the corresponding day's events. return [lunar_event_duration(events) for events in test_cases]"},{"question":"from typing import List def can_reach_destination(city_map: List[List[int]]) -> bool: Determine if a car can navigate from the top-left corner to the bottom-right corner in a grid city map. The car can move in four directions: left, right, up, and down. Roads under construction are marked as 1 (impassable), and open roads are marked as 0 (passable). Args: city_map (List[List[int]]): 2D array representing the city's grid layout. Returns: bool: True if the car can reach the destination, otherwise False. Example: >>> city_map = [ [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1], [1, 0, 0, 0] ] >>> can_reach_destination(city_map) True","solution":"from typing import List from collections import deque def can_reach_destination(city_map: List[List[int]]) -> bool: n = len(city_map) if city_map[0][0] == 1 or city_map[n-1][n-1] == 1: return False directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n-1, n-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and city_map[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False"},{"question":"def rotateString(s: str, k: int) -> str: Rotates the string s to the right by k characters. Parameters: s (str): The input string. k (int): The number of positions to rotate the string. Returns: str: The rotated string. Examples: >>> rotateString(\\"abcdef\\", 2) 'efabcd' >>> rotateString(\\"hello\\", 3) 'llohe'","solution":"def rotateString(s, k): Rotates the string s to the right by k characters. Parameters: s (str): The input string. k (int): The number of positions to rotate the string. Returns: str: The rotated string. n = len(s) k = k % n # Handle the case where k > n return s[-k:] + s[:-k]"},{"question":"def max_non_overlapping_tasks(tasks, timeline): Returns the maximum number of non-overlapping tasks that can be completed within the given timeline. Parameters: tasks (list of tuple): A list of tasks represented by tuples (start_time, end_time). timeline (int): The end time by which all tasks should be completed. Returns: int: The maximum number of non-overlapping tasks. Examples: >>> max_non_overlapping_tasks([(1, 3), (2, 5), (4, 6), (6, 9)], 10) 3 >>> max_non_overlapping_tasks([(1, 4), (3, 5), (0, 6), (5, 7), (8, 9), (5, 9)], 10) 3 pass","solution":"def max_non_overlapping_tasks(tasks, timeline): Returns the maximum number of non-overlapping tasks that can be completed within the given timeline. Parameters: tasks (list of tuple): A list of tasks represented by tuples (start_time, end_time). timeline (int): The end time by which all tasks should be completed. Returns: int: The maximum number of non-overlapping tasks. # Sort the tasks by their end times tasks.sort(key=lambda x: x[1]) count = 0 end_time = 0 for task in tasks: if task[0] >= end_time and task[1] <= timeline: count += 1 end_time = task[1] return count"},{"question":"def count_interactions(interactions: List[str]) -> str: Processes a list of interactions to count how many times each individual has greeted or bid farewell to someone else, and returns the counts sorted by names. >>> count_interactions([\\"greet Alice Bob\\", \\"farewell Alice Bob\\", \\"greet Bob Alice\\", \\"farewell Bob Alice\\"]) 'Alice 1 1nBob 1 1' >>> count_interactions([\\"greet Bob Alice\\", \\"farewell Alice Charlie\\", \\"greet Charlie Bob\\"]) 'Alice 0 1nBob 1 0nCharlie 1 0'","solution":"def count_interactions(interactions): from collections import defaultdict counter = defaultdict(lambda: [0, 0]) # Defaultdict with list [greet_count, farewell_count] for interaction in interactions: action, name1, name2 = interaction.split() if action == \\"greet\\": counter[name1][0] += 1 # Increment greet count for name1 elif action == \\"farewell\\": counter[name1][1] += 1 # Increment farewell count for name1 sorted_names = sorted(counter.keys()) result = [] for name in sorted_names: result.append(f\\"{name} {counter[name][0]} {counter[name][1]}\\") return 'n'.join(result) # Sample interactive function to integrate function with input-output def main(): import sys input = sys.stdin.read data = input().splitlines() T = int(data[0]) interactions = data[1:T + 1] print(count_interactions(interactions))"},{"question":"from typing import List, Tuple def min_jumps(arr: List[int]) -> int: Determine the minimum number of jumps required to reach the end of the board. Parameters: arr (List[int]): The list of integers representing the number of steps to move forward from that position. Returns: int: The minimum number of jumps required to reach the end of the board, or -1 if it is not possible to reach the end. >>> min_jumps([2, 3, 1, 1, 4]) 2 >>> min_jumps([1, 0, 0, 1, 1]) -1 >>> min_jumps([3, 2, 1, 0, 4]) -1 pass def process_test_cases(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases to determine the minimum number of jumps required for each. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains the number of positions (int) and a list of integers representing the steps for that test case. Returns: List[int]: A list of results for each test case, where each result is the minimum number of jumps or -1 if not possible. >>> process_test_cases( 3, [ (6, [2, 3, 1, 1, 4]), (5, [1, 0, 0, 1, 1]), (5, [3, 2, 1, 0, 4]) ] ) [2, -1, -1] pass","solution":"def min_jumps(arr): Function to determine the minimum number of jumps required to reach the end of the board. n = len(arr) if n == 1: return 0 if arr[0] == 0: return -1 maxReach = arr[0] step = arr[0] jump = 1 for i in range(1, n): if i == n - 1: return jump maxReach = max(maxReach, i + arr[i]) step -= 1 if step == 0: jump += 1 if i >= maxReach: return -1 step = maxReach - i return -1 def process_test_cases(t, test_cases): results = [] for i in range(t): n, arr = test_cases[i] results.append(min_jumps(arr)) return results"},{"question":"def min_removals_to_palindrome(s: str) -> int: This function calculates the minimum number of characters to be removed from the string to make it possible to rearrange the remaining characters to form a palindrome. >>> min_removals_to_palindrome(\\"aabbcc\\") 0 >>> min_removals_to_palindrome(\\"abc\\") 2 >>> min_removals_to_palindrome(\\"abccbaac\\") 1","solution":"def min_removals_to_palindrome(s): This function calculates the minimum number of characters to be removed from the string to make it possible to rearrange the remaining characters to form a palindrome. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # To form a palindrome, at most one character can have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # Minimum removals needed is the number of characters with odd frequency minus one # If there are no characters with odd frequency, no removals are needed return max(0, odd_count - 1)"},{"question":"def update_stock(n: int, initial_stock: List[int], transactions: List[Tuple[str, int, int]]) -> List[str]: Update stock levels based on transactions. Parameters: n: int - The number of product types. initial_stock: List[int] - The initial stock levels for each product. transactions: List[Tuple[str, int, int]] - A list of transactions where each transaction is a tuple of ('R'/'P', product_id, quantity). Returns: List[str] - A list of results after each transaction. Examples: >>> update_stock(5, [10, 20, 30, 40, 50], [('R', 3, 15), ('P', 4, 45), ('P', 2, 10), ('R', 1, 5), ('P', 5, 60), ('P', 1, 20)]) ['45', '0 Insufficient stock', '10', '15', '0 Insufficient stock', '0 Insufficient stock'] pass","solution":"def update_stock(n, initial_stock, transactions): Update stock levels based on transactions. Parameters: n: int - The number of product types. initial_stock: List[int] - The initial stock levels for each product. transactions: List[Tuple[str, int, int]] - A list of transactions where each transaction is a tuple of ('R'/'P', product_id, quantity). Returns: List[str] - A list of results after each transaction. stock = initial_stock[:] results = [] for transaction in transactions: op = transaction[0] product_id = transaction[1] - 1 quantity = transaction[2] if op == 'R': stock[product_id] += quantity results.append(f\\"{stock[product_id]}\\") elif op == 'P': if stock[product_id] < quantity: stock[product_id] = 0 results.append(f\\"0 Insufficient stock\\") else: stock[product_id] -= quantity results.append(f\\"{stock[product_id]}\\") return results"},{"question":"def canPartition(nums: List[int]) -> bool: Determine whether you can partition the list into exactly two non-empty subsets such that the sum of the elements in both subsets is the same. >>> canPartition([1, 5, 11, 5]) == True >>> canPartition([1, 2, 3, 5]) == False","solution":"def canPartition(nums): total_sum = sum(nums) # If the total sum is odd, it's not possible to partition it into two equal subsets if total_sum % 2 != 0: return False target_sum = total_sum // 2 n = len(nums) dp = [False] * (target_sum + 1) dp[0] = True for num in nums: for i in range(target_sum, num - 1, -1): dp[i] = dp[i] | dp[i - num] return dp[target_sum]"},{"question":"def smallest_substring_with_all_chars(A: str, B: str) -> str: Find the smallest substring of A that contains all the characters of B, including repetitions. >>> smallest_substring_with_all_chars(\\"adobecodebanc\\", \\"abc\\") \\"banc\\" >>> smallest_substring_with_all_chars(\\"a\\", \\"aa\\") \\"\\" >>> smallest_substring_with_all_chars(\\"hello\\", \\"ohe\\") \\"hello\\"","solution":"from collections import Counter def smallest_substring_with_all_chars(A, B): if not A or not B or len(A) < len(B): return \\"\\" required_chars = Counter(B) window_chars = Counter() required_len = len(required_chars) have = 0 res = (float(\\"inf\\"), None, None) left = 0 for right in range(len(A)): char = A[right] window_chars[char] += 1 if char in required_chars and window_chars[char] == required_chars[char]: have += 1 while have == required_len: if (right - left + 1) < res[0]: res = (right - left + 1, left, right) window_chars[A[left]] -= 1 if A[left] in required_chars and window_chars[A[left]] < required_chars[A[left]]: have -= 1 left += 1 return \\"\\" if res[1] is None else A[res[1]: res[2] + 1]"},{"question":"def max_treasures(N: int, M: int, maze: List[str]) -> int: Determine the maximum number of treasures that can be collected starting from the top-left corner of the grid. Constraints: 1 ≤ N ≤ 100 1 ≤ M ≤ 100 Args: N (int): Number of rows in the grid. M (int): Number of columns in the grid. maze (List[str]): N strings, each string of length M, representing the maze. 'T' indicates a treasure, 'O' indicates an obstacle, and '.' indicates an empty cell. Returns: int: The maximum number of treasures that can be collected. Examples: >>> max_treasures(5, 5, [\\"T.T..\\", \\".OO..\\", \\".T.T.\\", \\".OO..\\", \\".....\\"]) 4 >>> max_treasures(3, 3, [\\"T.O\\", \\".O.\\", \\".O.\\"]) 1 >>> max_treasures(2, 2, [\\"O.\\", \\"T.\\"]) 0 >>> max_treasures(3, 3, [\\"O..\\", \\"O..\\", \\"O..\\"]) 0 >>> max_treasures(2, 2, [\\"TT\\", \\"TT\\"]) 4 >>> max_treasures(4, 4, [\\"T..T\\", \\".O.O\\", \\"T..T\\", \\".O.O\\"]) 4","solution":"def max_treasures(N, M, maze): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * M for _ in range(N)] def collect_treasures(x, y): if not (0 <= x < N and 0 <= y < M) or visited[x][y] or maze[x][y] == 'O': return 0 visited[x][y] = True if maze[x][y] == 'T': treasures = 1 else: treasures = 0 for dx, dy in directions: treasures += collect_treasures(x + dx, y + dy) return treasures if maze[0][0] == 'O': return 0 return collect_treasures(0, 0)"},{"question":"def count_special_days(T, test_cases): Determine the number of special days. Each test case contains the number of days, the exact number of likes needed for a day to be special, and the likes each post receives on those days. Parameters: T (int): Number of test cases. test_cases (list of dict): List of test cases where each dict contains: - 'D' (int): Number of days. - 'K' (int): Exact number of likes needed for a day to be special. - 'days' (list of lists): List of lists where each sublist contains the number of posts and the likes each post received that day. Returns: list of int: List containing the number of special days for each test case. >>> count_special_days(2, [{'D': 3, 'K': 50, 'days': [[2, 10, 50], [3, 50, 50, 30], [1, 100]]}, {'D': 3, 'K': 20, 'days': [[0], [1, 20], [3, 10, 25, 10]]}]) [2, 1] >>> count_special_days(1, [{'D': 3, 'K': 10, 'days': [[0], [0], [0]]}]) [0]","solution":"def count_special_days(T, test_cases): results = [] for case in test_cases: D, K = case['D'], case['K'] days = case['days'] special_days = 0 for day in days: P, *likes = day if K in likes: special_days += 1 results.append(special_days) return results # Example usage: if __name__ == \\"__main__\\": T = 2 test_cases = [ { 'D': 3, 'K': 50, 'days': [ [2, 10, 50], [3, 50, 50, 30], [1, 100] ] }, { 'D': 3, 'K': 20, 'days': [ [0], [1, 20], [3, 10, 25, 10] ] } ] results = count_special_days(T, test_cases) for result in results: print(result)"},{"question":"def can_form_hello(s: str) -> str: Determine if all characters in s can be rearranged to form the word \\"hello\\". Parameters: s (str): Input string consisting of lowercase English letters. Returns: str: \\"YES\\" if s can be rearranged to form \\"hello\\", otherwise \\"NO\\". >>> can_form_hello(\\"lloeh\\") \\"YES\\" >>> can_form_hello(\\"world\\") \\"NO\\"","solution":"def can_form_hello(s): Determine if all characters in s can be rearranged to form the word \\"hello\\". Parameters: s (str): Input string consisting of lowercase English letters. Returns: str: \\"YES\\" if s can be rearranged to form \\"hello\\", otherwise \\"NO\\". from collections import Counter # Count the occurrences of each character in s and \\"hello\\" s_counter = Counter(s) hello_counter = Counter(\\"hello\\") # Check if s has at least the necessary counts of each character for char, count in hello_counter.items(): if s_counter[char] < count: return \\"NO\\" return \\"YES\\""},{"question":"def minimum_length(S: str) -> int: Given a string S consisting only of the letters 'a' and 'b', determine the minimum possible length of the string after replacing all \\"ab\\" with \\"b\\" as many times as possible. >>> minimum_length(\\"abbab\\") 3 >>> minimum_length(\\"aaaa\\") 0 >>> minimum_length(\\"bbbb\\") 4 >>> minimum_length(\\"abababab\\") 4 >>> minimum_length(\\"bbaa\\") 2 >>> minimum_length(\\"\\") 0 >>> minimum_length(\\"a\\") 0 >>> minimum_length(\\"b\\") 1 >>> minimum_length(\\"ab\\") 1 >>> minimum_length(\\"ba\\") 1","solution":"def minimum_length(S): Given a string S consisting only of the letters 'a' and 'b', determine the minimum possible length of the string after replacing all \\"ab\\" with \\"b\\" as many times as possible. a_count = S.count('a') b_count = S.count('b') # The minimum length is the number of 'b' characters left, # as all 'a' can be removed by the operation. return b_count"},{"question":"def count_paths(n: int, m: int, grid: List[str]) -> int: Determine the number of distinct paths from top-left to bottom-right in a given grid. >>> count_paths(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> count_paths(2, 2, [\\"..\\", \\".#\\"]) 0 >>> count_paths(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 6 >>> count_paths(1, 1, [\\".\\"]) 1 >>> count_paths(3, 3, [\\"#..\\", \\"...\\", \\"...\\"]) 0 >>> count_paths(3, 3, [\\"...\\", \\"...\\", \\"..#\\"]) 0","solution":"def count_paths(n, m, grid): MOD = 10**9 + 7 if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[n-1][m-1]"},{"question":"def all_parks_reachable(n: int, m: int, paths: List[Tuple[int, int]]) -> str: Determine if all parks are reachable from every other park. Args: n (int): The number of parks. m (int): The number of paths. paths (List[Tuple[int, int]]): List of tuples representing paths from park u to park v. Returns: str: \\"YES\\" if all parks are reachable from every other park, otherwise \\"NO\\". Examples: >>> all_parks_reachable(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]) == \\"NO\\" >>> all_parks_reachable(3, 3, [(1, 2), (2, 1), (2, 3)]) == \\"NO\\" >>> all_parks_reachable(3, 3, [(1, 2), (2, 3), (3, 1)]) == \\"YES\\" >>> all_parks_reachable(2, 2, [(1, 2), (2, 1)]) == \\"YES\\" >>> all_parks_reachable(1, 0, []) == \\"YES\\"","solution":"def all_parks_reachable(n, m, paths): from collections import defaultdict, deque def bfs(start, graph): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) queue.extend(graph[node]) return visited graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in paths: graph[u].append(v) reverse_graph[v].append(u) for i in range(1, n + 1): reach_from_i = bfs(i, graph) reach_to_i = bfs(i, reverse_graph) if len(reach_from_i) < n or len(reach_to_i) < n: return \\"NO\\" return \\"YES\\""},{"question":"def sum_even_times_highest_odd(arr): Returns the sum of all even numbers in the array multiplied by the highest odd number in the array. If there are no odd numbers in the array, returns 0. >>> sum_even_times_highest_odd([2, 3, 4, 5, 6]) 60 >>> sum_even_times_highest_odd([2, 4, 6, 8, 10]) 0 >>> sum_even_times_highest_odd([1, 3, 5, 7, 9]) 0 >>> sum_even_times_highest_odd([1, 2, 3, 4, 5]) 30 >>> sum_even_times_highest_odd([2]) 0 >>> sum_even_times_highest_odd([3]) 0 >>> sum_even_times_highest_odd([]) 0 >>> sum_even_times_highest_odd([1000, 1000, 1000, 1000, 999]) 3996000","solution":"def sum_even_times_highest_odd(arr): Returns the sum of all even numbers in the array multiplied by the highest odd number in the array. If there are no odd numbers in the array, returns 0. even_sum = sum(x for x in arr if x % 2 == 0) odd_numbers = [x for x in arr if x % 2 != 0] highest_odd = max(odd_numbers) if odd_numbers else 0 return even_sum * highest_odd"},{"question":"def rearrangeArray(arr, n): Rearranges the array such that every second element is greater than its previous and next elements. pass def processTestCases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] arr = test_cases[i][1] results.append(rearrangeArray(arr, N)) return results from solution import rearrangeArray, processTestCases def valid_rearrangement(arr): Checks if the array is rearranged such that every second element is greater than its previous and next elements. n = len(arr) for i in range(1, n, 2): if (i - 1 >= 0 and arr[i] <= arr[i - 1]) or (i + 1 < n and arr[i] <= arr[i + 1]): return False return True def test_rearrangeArray_case1(): arr = [1, 3, 4, 2, 5, 6] n = len(arr) result = rearrangeArray(arr, n) assert valid_rearrangement(result) def test_rearrangeArray_case2(): arr = [9, 7, 4, 2, 1] n = len(arr) result = rearrangeArray(arr, n) assert valid_rearrangement(result) def test_rearrangeArray_single_element(): arr = [1] n = len(arr) result = rearrangeArray(arr, n) assert result == [1] def test_rearrangeArray_already_sorted(): arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] n = len(arr) result = rearrangeArray(arr, n) assert valid_rearrangement(result) def test_processTestCases(): T = 2 test_cases = [(6, [1, 3, 4, 2, 5, 6]), (5, [9, 7, 4, 2, 1])] results = processTestCases(T, test_cases) assert valid_rearrangement(results[0]) assert valid_rearrangement(results[1])","solution":"def rearrangeArray(arr, n): Rearranges the array such that every second element is greater than its previous and next elements. # Sort the array arr_sorted = sorted(arr) # Create a new array to store the rearranged elements result = [0] * n j = 0 # Fill every second position with the largest remaining elements for i in range(1, n, 2): result[i] = arr_sorted.pop() # Fill the remaining positions with the smallest elements for i in range(0, n, 2): if arr_sorted: result[i] = arr_sorted.pop(0) return result def processTestCases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] arr = test_cases[i][1] results.append(rearrangeArray(arr, N)) return results # Sample usage # T = 2 # test_cases = [(6, [1, 3, 4, 2, 5, 6]), (5, [9, 7, 4, 2, 1])] # print(processTestCases(T, test_cases))"},{"question":"from typing import List def top_k_frequent_words(words: List[str], k: int) -> List[str]: Returns the top k frequent words in the list. The words are sorted in descending order of their frequency, and in case of a tie, they are sorted in ascending lexicographical order. >>> top_k_frequent_words([\\"i\\", \\"love\\", \\"leetcode\\", \\"i\\", \\"love\\", \\"coding\\"], 2) [\\"i\\", \\"love\\"] >>> top_k_frequent_words([\\"the\\", \\"day\\", \\"is\\", \\"sunny\\", \\"the\\", \\"the\\", \\"the\\", \\"sunny\\", \\"is\\", \\"is\\"], 4) [\\"the\\", \\"is\\", \\"sunny\\", \\"day\\"]","solution":"from typing import List from collections import Counter def top_k_frequent_words(words: List[str], k: int) -> List[str]: Returns the top k frequent words in the list. The words are sorted in descending order of their frequency, and in case of a tie, they are sorted in ascending lexicographical order. # Count the frequency of each word word_count = Counter(words) # Sort the words first by the frequency (descending), then alphabetically (ascending) sorted_words = sorted(word_count.keys(), key=lambda word: (-word_count[word], word)) # Return the top k words return sorted_words[:k]"},{"question":"def can_reach_top_right(N, E, grid): Determine if the robot can reach the top-right corner of a grid from the bottom-left corner with the given initial energy. >>> can_reach_top_right(3, 15, [[1, 3, 6], [2, 0, 2], [4, 4, 0]]) True >>> can_reach_top_right(2, 10, [[1, 5], [2, 1]]) True >>> can_reach_top_right(2, 3, [[1, 5], [2, 1]]) False >>> can_reach_top_right(1, 0, [[0]]) True >>> can_reach_top_right(3, 10, [[1, 2, 3], [4, 0, 1], [1, 1, 0]]) True pass def robot_paths(T, test_cases): Determine if the robot can reach the top-right corner for multiple test cases. >>> test_cases = [ ... ((3, 15), [[1, 3, 6], [2, 0, 2], [4, 4, 0]]), ... ((2, 3), [[1, 5], [2, 1]]), ... ((2, 10), [[1, 5], [2, 1]]) ... ] >>> robot_paths(3, test_cases) [\\"Yes\\", \\"No\\", \\"Yes\\"] pass","solution":"def can_reach_top_right(N, E, grid): # Create a 2D dp array to store the minimum energy needed to reach each cell dp = [[float('inf')] * N for _ in range(N)] # Initialize the energy required to reach the starting cell (0, 0) dp[0][0] = grid[0][0] # Fill the dp table for i in range(N): for j in range(N): if i > 0: dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0: dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j]) # Return whether the energy required to reach (N-1, N-1) is within the initial energy return dp[N-1][N-1] <= E def robot_paths(T, test_cases): results = [] for tc in test_cases: N, E = tc[0] grid = tc[1] if can_reach_top_right(N, E, grid): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def reorder_string(s: str) -> str: Reorders the string such that no two adjacent characters are the same. If it's not possible, returns an empty string. Parameters: s (str): A string consisting of lowercase alphabets. Returns: str: A reordered string where no two adjacent characters are the same. If no such reordering is possible, returns an empty string. Examples: >>> reorder_string(\\"aabb\\") 'abab' or 'baba' >>> reorder_string(\\"aaab\\") ''","solution":"import heapq from collections import Counter def reorder_string(s: str) -> str: Reorders the string such that no two adjacent characters are the same. If it's not possible, returns an empty string. # Count the frequency of each character char_count = Counter(s) # Create a max heap based on the frequency of characters max_heap = [(-freq, char) for char, freq in char_count.items()] heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) # Append the previous character back to the heap, if there is a previous character if prev_char and -prev_freq > 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Append the current character to the result result.append(char) # Update previous character and frequency to the current one prev_char = char prev_freq = freq + 1 # decrement frequency since it's negative if len(result) == len(s): return ''.join(result) else: return ''"},{"question":"def total_sales(sales_data, criteria): Aggregates sales amounts based on the provided criteria. Args: sales_data (list of dict): List of sales records. criteria (dict): Dictionary of criteria to filter the sales data. Returns: int: Total sales amount matching the given criteria. Example Usage: >>> sales_data = [ ... {\\"date\\": \\"2023-01-01\\", \\"country\\": \\"USA\\", \\"product\\": \\"A\\", \\"amount\\": 100}, ... {\\"date\\": \\"2023-01-02\\", \\"country\\": \\"CAN\\", \\"product\\": \\"B\\", \\"amount\\": 150}, ... {\\"date\\": \\"2023-01-02\\", \\"country\\": \\"USA\\", \\"product\\": \\"A\\", \\"amount\\": 200}, ... {\\"date\\": \\"2023-01-03\\", \\"country\\": \\"USA\\", \\"product\\": \\"B\\", \\"amount\\": 300}, ... {\\"date\\": \\"2023-01-03\\", \\"country\\": \\"CAN\\", \\"product\\": \\"A\\", \\"amount\\": 50}, ... {\\"date\\": \\"2023-01-04\\", \\"country\\": \\"USA\\", \\"product\\": \\"C\\", \\"amount\\": 500} ... ] >>> total_sales(sales_data, {\\"date\\": \\"2023-01-02\\"}) == 350 True >>> total_sales(sales_data, {\\"country\\": \\"USA\\"}) == 1100 True >>> total_sales(sales_data, {\\"product\\": \\"A\\"}) == 350 True >>> total_sales(sales_data, {\\"date\\": \\"2023-01-03\\", \\"country\\": \\"CAN\\"}) == 50 True >>> total_sales(sales_data, {}) == 1300 True","solution":"def total_sales(sales_data, criteria): Aggregates sales amounts based on the provided criteria. Args: sales_data (list of dict): List of sales records. criteria (dict): Dictionary of criteria to filter the sales data. Returns: int: Total sales amount matching the given criteria. total = 0 for sale in sales_data: match = True for key, value in criteria.items(): if sale.get(key) != value: match = False break if match: total += sale[\\"amount\\"] return total"},{"question":"def count_valid_permutations(n: int) -> int: Calculate the number of distinct permutations of the first n natural numbers that satisfy the given constraints, with result modulo 998244353. >>> count_valid_permutations(1) 1 >>> count_valid_permutations(2) 1 >>> count_valid_permutations(3) 2 >>> count_valid_permutations(4) 3 def solve(t: int, test_cases: List[int]) -> List[int]: Given the number of test cases and a list of integers, return the number of valid permutations for each test case, modulo 998244353. >>> solve(4, [1, 2, 3, 4]) [1, 1, 2, 3] >>> solve(3, [5, 6, 7]) [5, 8, 13]","solution":"MOD = 998244353 def count_valid_permutations(n): if n == 1: return 1 if n == 2: return 1 dp = [0] * (n + 1) dp[1] = 1 dp[2] = 1 for i in range(3, n + 1): dp[i] = (dp[i-1] + dp[i-2]) % MOD return dp[n] def solve(t, test_cases): result = [] for n in test_cases: result.append(count_valid_permutations(n)) return result"},{"question":"def min_towers(n: int, r: int, positions: List[int]) -> int: Determine the minimum number of towers required to observe all animals in the sanctuary. Each tower can observe animals within a range on either side of its location. Example: >>> min_towers(6, 2, [1, 2, 3, 5, 7, 8]) 2 >>> min_towers(1, 0, [5]) 1 >>> min_towers(1, 10, [5]) 1 >>> min_towers(5, 10, [1, 2, 3, 4, 5]) 1 >>> min_towers(4, 0, [5, 10, 15, 20]) 4 >>> min_towers(5, 10**9, [1, 2*10**8, 4*10**8, 6*10**8, 10**9]) 1 >>> min_towers(3, 5, [1, 10, 20]) 3","solution":"def min_towers(n, r, positions): towers = 0 i = 0 while i < n: # Find the farthest position within the range of current position i initial_position = positions[i] while i < n and positions[i] <= initial_position + r: i += 1 # Place the tower at the farthest position within the initial range towers += 1 tower_position = positions[i - 1] # Skip all positions covered by this tower while i < n and positions[i] <= tower_position + r: i += 1 return towers"},{"question":"def max_overlapping_events(events): Given a list of events with start and end times, returns the maximum number of overlapping events at any point in time. >>> max_overlapping_events([(1, 5), (3, 7), (4, 6), (6, 8), (5, 9)]) 3 >>> max_overlapping_events([(10, 20), (20, 30), (15, 25)]) 2 >>> max_overlapping_events([(1, 2)]) 1 >>> max_overlapping_events([(1, 2), (3, 4), (5, 6)]) 1 >>> max_overlapping_events([(1, 5), (2, 6), (3, 7)]) 3","solution":"def max_overlapping_events(events): Given a list of events with start and end times, returns the maximum number of overlapping events at any point in time. timestamps = [] for event in events: s, e = event timestamps.append((s, 'start')) timestamps.append((e, 'end')) timestamps.sort() max_overlaps = 0 current_overlaps = 0 for time, type_ in timestamps: if type_ == 'start': current_overlaps += 1 if current_overlaps > max_overlaps: max_overlaps = current_overlaps else: current_overlaps -= 1 return max_overlaps"},{"question":"def process_trading_pairs(n: int, m: int, pairs: List[Tuple[int, int]]) -> Tuple[str, List[int]]: Peter is organizing a cryptocurrency exchange platform. On this platform, there are multiple types of cryptocurrencies, and traders who want to trade different pairs of cryptocurrencies. Peter's goal is to handle all trading requests without causing any deadlock. There are n different types of cryptocurrencies and m trading pairs. Each trading pair specifies two different cryptocurrencies that a trader wants to exchange. Peter can process these trading pairs in any order, as long as he ensures that all trading requests are fulfilled. A trading pair consists of two cryptocurrencies: if a trader wants to trade currency a_i for currency b_i, he must exchange currency a_i before currency b_i becomes available for trading. Peter needs to determine if there is an order in which he can process all the trading pairs such that no cycles are formed (i.e., ensuring no trader waits forever for another to complete). >>> process_trading_pairs(3, 3, [(1, 2), (2, 3), (1, 3)]) (\\"ORDERED\\", [1, 2, 3]) >>> process_trading_pairs(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]) (\\"CYCLIC\\", [])","solution":"from collections import defaultdict, deque def process_trading_pairs(n, m, pairs): # Build graph adjacency list and in-degree array graph = defaultdict(list) in_degree = [0] * (n + 1) for a, b in pairs: graph[a].append(b) in_degree[b] += 1 # Perform topological sort using Kahn's algorithm queue = deque([i for i in range(1, n + 1) if in_degree[i] == 0]) topological_order = [] while queue: node = queue.popleft() topological_order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(topological_order) == n: return \\"ORDERED\\", topological_order else: return \\"CYCLIC\\", []"},{"question":"from typing import List, Tuple def calculate_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: Calculates the Euclidean distance between two points p1 and p2. return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5 def shortest_route_distance(stops: List[Tuple[int, int]]) -> float: Finds the shortest route that visits all trip stops exactly once and returns to the starting point. >>> shortest_route_distance([(0, 0), (1, 0), (1, 1), (0, 1)]) == 4.0000 >>> shortest_route_distance([(-1, 2), (2, 2), (2, 3), (-1, 3), (0, 0)]) == 10.0645 >>> shortest_route_distance([(0, 0)]) == 0.0000 >>> shortest_route_distance([(0, 0), (3, 4)]) == 10.0000 >>> shortest_route_distance([(1, 1), (1, 1)]) == 0.0000 >>> shortest_route_distance([(0, 0), (0, 3), (4, 0)]) == 12.0000 pass","solution":"import itertools import math def calculate_distance(p1, p2): Calculates the Euclidean distance between two points p1 and p2. return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def shortest_route_distance(stops): Finds the shortest route that visits all trip stops exactly once and returns to the starting point. n = len(stops) min_distance = float('inf') for permutation in itertools.permutations(stops): distance = 0 for i in range(n): distance += calculate_distance(permutation[i], permutation[(i + 1) % n]) min_distance = min(min_distance, distance) return round(min_distance, 4) # Example Usage if __name__ == \\"__main__\\": stops = [(0, 0), (1, 0), (1, 1), (0, 1)] print(shortest_route_distance(stops)) # Should output: 4.0000"},{"question":"def min_moves(N: int, S: str) -> int: Determine the minimum number of moves required to traverse from the start to the end of the blocks >>> min_moves(8, '........') 7 >>> min_moves(8, '.O.B....') -1 >>> min_moves(6, '..B...') -1 >>> min_moves(10, '......B.O.') -1","solution":"def min_moves(N, S): if S[0] in 'BO' or S[-1] in 'BO': return -1 # can't start or end on a bomb or obstacle moves = 0 i = 0 while i < N - 1: if S[i + 1] == '.': i += 1 moves += 1 elif S[i + 1] == 'B': back_counter = i while back_counter > 0 and S[back_counter] == '.': back_counter -= 1 if back_counter == 0: return -1 # No safe blocks to go back to moves += 1 i = back_counter - 1 # force backward movement elif S[i + 1] == 'O': return -1 # block with an obstacle, impossible to move forward return moves"},{"question":"def sumOfUniqueElements(arr): Returns the sum of the non-repeating (unique) elements in the array. >>> sumOfUniqueElements([1, 2, 2, 3, 4, 4, 5]) == 9 >>> sumOfUniqueElements([10, 20, 10, 30, 40, 30]) == 60 >>> sumOfUniqueElements([-1, -2, -2, -3, -4, -4, -5]) == -9 >>> sumOfUniqueElements([1, 1, 1, 2, 2, 3]) == 3 >>> sumOfUniqueElements([5, 5, 5, 5, 5]) == 0 >>> sumOfUniqueElements([1, 2, 3, 4, 5]) == 15 >>> sumOfUniqueElements([]) == 0 >>> sumOfUniqueElements([1, 1, 2, 2, 3, 3]) == 0 >>> sumOfUniqueElements([1, 2, 3, 4, 5]) == 15 >>> sumOfUniqueElements([-1, 1, -2, 2, -3, 3, 4, -4]) == 0 >>> sumOfUniqueElements([-10, -20, -30, 10, 20, 30]) == 0 >>> sumOfUniqueElements([-100, -99, 100, 99, 0]) == 0 >>> sumOfUniqueElements([1, -1, 2, -2, 3, -3, 4, 5]) == 9 >>> sumOfUniqueElements(list(range(50)) + list(range(50))) == 0 >>> sumOfUniqueElements([10]) == 10 >>> sumOfUniqueElements([-10]) == -10","solution":"def sumOfUniqueElements(arr): Returns the sum of the non-repeating (unique) elements in the array. # Creating a dictionary to store the frequency of each element frequency = {} for element in arr: if element in frequency: frequency[element] += 1 else: frequency[element] = 1 # Summing only the unique (non-repeating) elements unique_sum = sum(key for key, value in frequency.items() if value == 1) return unique_sum"},{"question":"from typing import List, Tuple def matrix_operations(n: int, m: int, q: int, matrix: List[List[int]], operations: List[Tuple[int, int, int, int, int]]) -> List[int]: You are given a matrix of dimensions n x m filled with non-negative integers. There are q operations to be performed on the matrix where each operation adds a given value to all elements in a submatrix. After performing each operation, you are required to find the sum of all elements in the matrix. Input: n, m, q -- integers: the number of rows, the number of columns in the matrix, and the number of operations matrix -- List of Lists of integers: representing the initial elements of the matrix operations -- List of Tuples: describing each operation and contains five integers (x1, y1, x2, y2, v) Output: List of integers: for each operation, the sum of all elements in the matrix after the operation Example: >>> matrix_operations(3, 3, 3, ... [[1, 2, 3], [4, 5, 6], [7, 8, 9]], ... [(0, 0, 1, 1, 10), (1, 1, 2, 2, -3), (0, 0, 2, 2, 5)]) [85, 73, 118] pass def test_example_case(): n, m, q = 3, 3, 3 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] operations = [ (0, 0, 1, 1, 10), (1, 1, 2, 2, -3), (0, 0, 2, 2, 5) ] expected = [85, 73, 118] assert matrix_operations(n, m, q, matrix, operations) == expected def test_no_operations(): n, m, q = 2, 2, 0 matrix = [ [1, 2], [3, 4] ] operations = [] expected = [] assert matrix_operations(n, m, q, matrix, operations) == expected def test_single_operation(): n, m, q = 2, 2, 1 matrix = [ [1, 2], [3, 4] ] operations = [ (0, 0, 1, 1, 1) ] expected = [14] assert matrix_operations(n, m, q, matrix, operations) == expected def test_large_values(): n, m, q = 1, 1, 1 matrix = [ [1000000] ] operations = [ (0, 0, 0, 0, 1000000) ] expected = [2000000] assert matrix_operations(n, m, q, matrix, operations) == expected def test_negative_values(): n, m, q = 2, 2, 1 matrix = [ [1, 2], [3, 4] ] operations = [ (0, 0, 1, 1, -1) ] expected = [6] assert matrix_operations(n, m, q, matrix, operations) == expected","solution":"def matrix_operations(n, m, q, matrix, operations): result = [] current_sum = sum(sum(row) for row in matrix) for x1, y1, x2, y2, v in operations: area = (x2 - x1 + 1) * (y2 - y1 + 1) current_sum += area * v result.append(current_sum) return result"},{"question":"def last_friend(N, P): Determines the last friend holding the potato. Parameters: N : int - Number of friends. P: List[int] - List of pass strengths. Returns: int - The 1-based position of the last friend holding the potato. >>> last_friend(4, [3, 1, 2, 4]) 4 >>> last_friend(3, [1, 2, 0]) 3 pass def solve(T, test_cases): Solves multiple test cases of the last friend holding the potato. Parameters: T: int - Number of test cases. test_cases: List[Tuple[int, List[int]]] - List of test cases, each with number of friends and pass strengths. Returns: List[int] - List of results for each test case. >>> solve(2, [(4, [3, 1, 2, 4]), (3, [1, 2, 0])]) [4, 3] pass # Function to read input and output results def main(): import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): N = int(data[index]) index += 1 P = list(map(int, data[index:index+N])) index += N test_cases.append((N, P)) results = solve(T, test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()","solution":"def last_friend(N, P): Determines the last friend holding the potato. Parameters: N : int - Number of friends. P: List[int] - List of pass strengths. Returns: int - The 1-based position of the last friend holding the potato. position = 0 # Start with the first friend (0-based index). while True: max_pass_range = min(position + P[position], N - 1) # Determine the furthest pass position. # Check if there is no one to pass the potato anymore. if max_pass_range <= position: break # No valid pass can be made further. position = max_pass_range # Move to the new position (friend). return position + 1 # Return the 1-based position. def solve(T, test_cases): results = [] for N, P in test_cases: results.append(last_friend(N, P)) return results # Function to read input and output results def main(): import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): N = int(data[index]) index += 1 P = list(map(int, data[index:index+N])) index += N test_cases.append((N, P)) results = solve(T, test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"import bisect from typing import List def longest_increasing_subsequence(books: List[int]) -> int: Returns the length of the longest strictly increasing subsequence in the list of book widths. >>> longest_increasing_subsequence([5, 3, 4, 8, 6, 7]) 4 >>> longest_increasing_subsequence([1, 3, 2, 1, 4]) 3 >>> longest_increasing_subsequence([10]) 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 >>> longest_increasing_subsequence([1, 3, 2, 4, 3, 5]) 4 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([5, 5, 5, 5, 5]) 1","solution":"import bisect def longest_increasing_subsequence(books): Returns the length of the longest strictly increasing subsequence in the list of book widths. if not books: return 0 lis = [] for width in books: pos = bisect.bisect_left(lis, width) if pos == len(lis): lis.append(width) else: lis[pos] = width return len(lis)"},{"question":"def max_attendance(n: int, schedules: List[List[int]]) -> int: Returns the maximum number of club members who can attend a meeting on the same day. >>> max_attendance(4, [[1, 3, 5], [2, 3], [1], [5, 6]]) 2 >>> max_attendance(5, [[1, 4], [2, 3, 7], [3], [3, 5], [7]]) 3 from max_attendance import max_attendance def test_example_1(): n = 4 schedules = [ [1, 3, 5], [2, 3], [1], [5, 6] ] assert max_attendance(n, schedules) == 2 def test_example_2(): n = 5 schedules = [ [1, 4], [2, 3, 7], [3], [3, 5], [7] ] assert max_attendance(n, schedules) == 3 def test_all_candidates_same_day(): n = 3 schedules = [ [1], [1], [1] ] assert max_attendance(n, schedules) == 3 def test_no_common_days(): n = 3 schedules = [ [1], [2], [3] ] assert max_attendance(n, schedules) == 1 def test_large_case_all_seven_days(): n = 10 schedules = [ [1, 2, 3, 4, 5, 6, 7] for _ in range(10) ] assert max_attendance(n, schedules) == 10 def test_mixed_days(): n = 4 schedules = [ [1, 2, 3], [2, 4, 6], [3, 5, 7], [1, 4, 7] ] assert max_attendance(n, schedules) == 2","solution":"def max_attendance(n, schedules): Returns the maximum number of club members who can attend a meeting on the same day. :param n: int - the number of club members :param schedules: list of lists - each sublist representing the days a member is available :return: int - the maximum number of members available on the same day day_count = [0] * 7 # to count availability for each day from Monday to Sunday for schedule in schedules: for day in schedule: day_count[day - 1] += 1 return max(day_count)"},{"question":"from typing import List, Tuple def min_time_to_protect_all_marauders(n: int, m: int, marauders: int, guardians: int, forest: List[str], p: int, marauder_locs: List[Tuple[int, int, int]], guardian_locs: List[Tuple[int, int, int]]) -> int: Determine the minimal time required for each Marauder to be within the protection range of at least one Guardian, or return -1 if it is impossible. Args: n: int - Number of rows in the forest grid. m: int - Number of columns in the forest grid. marauders: int - Number of Marauders. guardians: int - Number of Guardians. forest: List[str] - Forest grid where '.' indicates free cell and '#' indicates an obstacle. p: int - The range within which a Guardian can protect a Marauder. marauder_locs: List[Tuple[int, int, int]] - List of tuples indicating initial coordinates and movement time of each Marauder. guardian_locs: List[Tuple[int, int, int]] - List of tuples indicating initial coordinates and movement time of each Guardian. Returns: int - The minimum possible time to ensure all Marauders are within the protection range of at least one Guardian, or -1 if it is impossible. pass import pytest def test_example_1(): n = 4 m = 4 marauders = 2 guardians = 2 forest = [ \\"....\\", \\".#..\\", \\"..#.\\", \\"....\\" ] p = 2 marauder_locs = [(0, 0, 1), (2, 2, 2)] guardian_locs = [(1, 1, 1), (3, 3, 1)] assert min_time_to_protect_all_marauders(n, m, marauders, guardians, forest, p, marauder_locs, guardian_locs) == 2 def test_example_2(): n = 3 m = 3 marauders = 1 guardians = 1 forest = [ \\".#.\\", \\".#.\\", \\".#.\\" ] p = 1 marauder_locs = [(0, 0, 1)] guardian_locs = [(2, 2, 1)] assert min_time_to_protect_all_marauders(n, m, marauders, guardians, forest, p, marauder_locs, guardian_locs) == -1 def test_no_guardians(): n = 3 m = 3 marauders = 1 guardians = 0 forest = [ \\"...\\", \\"...\\", \\"...\\" ] p = 1 marauder_locs = [(0, 0, 1)] guardian_locs = [] assert min_time_to_protect_all_marauders(n, m, marauders, guardians, forest, p, marauder_locs, guardian_locs) == -1 def test_no_marauders(): n = 3 m = 3 marauders = 0 guardians = 1 forest = [ \\"...\\", \\"...\\", \\"...\\" ] p = 1 marauder_locs = [] guardian_locs = [(0, 0, 1)] assert min_time_to_protect_all_marauders(n, m, marauders, guardians, forest, p, marauder_locs, guardian_locs) == 0","solution":"from collections import deque def bfs(forest, starts, n, m): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] dist = [[float('inf')] * m for _ in range(n)] q = deque() for start in starts: r, c, t = start q.append((r, c, t)) dist[r][c] = 0 while q: r, c, t = q.popleft() for d in directions: nr, nc = r + d[0], c + d[1] if 0 <= nr < n and 0 <= nc < m and forest[nr][nc] == '.' and dist[nr][nc] > dist[r][c] + t: dist[nr][nc] = dist[r][c] + t q.append((nr, nc, t)) return dist def min_time_to_protect_all_marauders(n, m, marauders, guardians, forest, p, marauder_locs, guardian_locs): if guardians == 0: return -1 guardian_distances = bfs(forest, guardian_locs, n, m) max_time = 0 for marauder in marauder_locs: r, c, t = marauder in_range = False for i in range(n): for j in range(m): if guardian_distances[i][j] != float('inf') and abs(i - r) + abs(j - c) <= p: max_time = max(max_time, guardian_distances[i][j]) in_range = True break if in_range: break if not in_range: return -1 return max_time # Example usage: n = 4 m = 4 marauders = 2 guardians = 2 forest = [ \\"....\\", \\".#..\\", \\"..#.\\", \\"....\\" ] p = 2 marauder_locs = [(0, 0, 1), (2, 2, 2)] guardian_locs = [(1, 1, 1), (3, 3, 1)] print(min_time_to_protect_all_marauders(n, m, marauders, guardians, forest, p, marauder_locs, guardian_locs)) # Output: 2"},{"question":"from typing import List, Tuple def bird_camera_setup(n: int, k: int) -> Tuple[int, List[int]]: Determines the minimum number of cameras needed and the times at which the cameras take pictures. Parameters: n (int): Total number of minutes in a day. k (int): Number of consecutive minutes in which the bird is guaranteed to appear at least once. Returns: (int, List[int]): The minimum number of cameras needed and the list of times at which the cameras take pictures. Examples: >>> bird_camera_setup(10, 3) (4, [0, 3, 6, 9]) >>> bird_camera_setup(6, 2) (3, [0, 2, 4])","solution":"def bird_camera_setup(n, k): Determines the minimum number of cameras needed and the times at which the cameras take pictures. Parameters: n (int): Total number of minutes in a day. k (int): Number of consecutive minutes in which the bird is guaranteed to appear at least once. Returns: (int, List[int]): The minimum number of cameras needed and the list of times at which the cameras take pictures. cameras = [] for i in range(0, n, k): cameras.append(i) return len(cameras), cameras"},{"question":"def max_boxes_stack(n: int, heights: List[int]) -> int: Calculates the maximum number of boxes that can be stacked on top of each other. :param n: int, number of boxes :param heights: list of int, heights of the boxes :return: int, maximum number of boxes that can be stacked >>> max_boxes_stack(5, [1, 2, 3, 4, 5]) 5 >>> max_boxes_stack(6, [6, 5, 4, 3, 2, 1]) 1 >>> max_boxes_stack(7, [3, 7, 2, 5, 6, 4, 1]) 3 >>> max_boxes_stack(0, []) 0 >>> max_boxes_stack(1, [10]) 1 >>> max_boxes_stack(8, [1, 3, 2, 4, 6, 5, 7, 8]) 6 >>> max_boxes_stack(4, [10, 12, 15, 7]) 3","solution":"def max_boxes_stack(n, heights): Calculates the maximum number of boxes that can be stacked on top of each other. :param n: int, number of boxes :param heights: list of int, heights of the boxes :return: int, maximum number of boxes that can be stacked if n == 0: return 0 dp = [1] * n # dp[i] will hold the max stack height ending with the i-th box for i in range(n): for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def count_vowels(s: str) -> int: Returns the number of vowels in the given string. Vowels are \\"a\\", \\"e\\", \\"i\\", \\"o\\", \\"u\\" (both lowercase and uppercase). >>> count_vowels(\\"Hello, World!\\") == 3 >>> count_vowels(\\"This is a test.\\") == 4 >>> count_vowels(\\"Programming is fun!\\") == 5","solution":"def count_vowels(s): Returns the number of vowels in the given string. Vowels are \\"a\\", \\"e\\", \\"i\\", \\"o\\", \\"u\\" (both lowercase and uppercase). vowels = \\"aeiouAEIOU\\" return sum(1 for char in s if char in vowels)"},{"question":"def validate_telephone_numbers(n: int, strings: List[str]) -> List[str]: Given several strings, check if each string represents a valid telephone number based on specific rules. A valid telephone number must contain exactly 10 digits and must start with 7, 8, or 9. >>> validate_telephone_numbers(5, [\\"9876543210\\", \\"1234567890abc\\", \\"987874ab8765\\", \\"78abc65432123\\", \\"9999999999\\"]) == [\\"YES\\", \\"NO\\", \\"NO\\", \\"NO\\", \\"YES\\"]","solution":"def validate_telephone_numbers(n, strings): def is_valid_telephone_number(s): if len(s) == 10 and s[0] in '789' and s.isdigit(): return True return False result = [] for s in strings: if is_valid_telephone_number(s): result.append(\\"YES\\") else: result.append(\\"NO\\") return result"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5 >>> length_of_longest_substring_two_distinct(\\"aaaa\\") 4 >>> length_of_longest_substring_two_distinct(\\"abcabcabc\\") 2 >>> length_of_longest_substring_two_distinct(\\"\\") 0 >>> length_of_longest_substring_two_distinct(\\"b\\") 1 >>> length_of_longest_substring_two_distinct(\\"bb\\") 2 >>> length_of_longest_substring_two_distinct(\\"abaccc\\") 4 >>> length_of_longest_substring_two_distinct(\\"a\\"*100000) 100000 >>> length_of_longest_substring_two_distinct(\\"a\\"*50000 + \\"b\\"*50000) 100000 >>> length_of_longest_substring_two_distinct(\\"abcdef\\") 2","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring that contains at most two distinct characters. from collections import defaultdict n = len(s) if n < 3: return n left = 0 right = 0 max_len = 2 hashmap = defaultdict(int) while right < n: hashmap[s[right]] += 1 while len(hashmap) > 2: hashmap[s[left]] -= 1 if hashmap[s[left]] == 0: del hashmap[s[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"def highest_average_beauty_score(N, M, beauty_scores): Calculate the highest possible average beauty score from the given images based on their beauty scores. Parameters: N (int): Total number of images M (int): Maximum number of images that can be chosen beauty_scores (list of int): List of beauty scores of the images Returns: int: The highest possible average beauty score rounded down to the nearest integer >>> highest_average_beauty_score(5, 3, [4, 8, 2, 6, 1]) 6 >>> highest_average_beauty_score(4, 2, [10, 20, 30, 40]) 35","solution":"def highest_average_beauty_score(N, M, beauty_scores): Calculate the highest possible average beauty score from the given images based on their beauty scores. Parameters: N (int): Total number of images M (int): Maximum number of images that can be chosen beauty_scores (list of int): List of beauty scores of the images Returns: int: The highest possible average beauty score rounded down to the nearest integer # Sort the beauty scores in descending order beauty_scores.sort(reverse=True) # Select the top M scores top_m_scores = beauty_scores[:M] # Calculate the average of the top M scores highest_average = sum(top_m_scores) // M return highest_average"},{"question":"def count_pyramids(t: int, test_cases: List[int]) -> List[int]: Determine the number of perfect pyramid arrangements that can be made using exactly N flowers. >>> count_pyramids(3, [5, 6, 10]) [0, 1, 1] >>> count_pyramids(3, [1, 3, 6]) [1, 1, 1]","solution":"def count_pyramids(t, test_cases): def is_pyramid(n): level = 1 while n > 0: n -= level level += 1 return n == 0 results = [] for n in test_cases: results.append(1 if is_pyramid(n) else 0) return results"},{"question":"def most_popular_cakes(n: int, k: int, cakes: List[Tuple[int, int]]) -> Tuple[List[int], int]: Determine the k most ordered cakes and their total number of orders. Given the number of different types of cakes, their identifiers along with the order counts, and the value of k, this function outputs the identifiers of the cakes in the k most ordered list (in any order), followed by the total number of orders for these k cakes. If multiple cakes share the k-th highest order count, all such cakes should be included in the output as part of the top k. >>> most_popular_cakes(5, 2, [(101, 150), (102, 300), (103, 200), (104, 300), (105, 150)]) ([102, 104], 600) >>> most_popular_cakes(4, 3, [(201, 40), (202, 60), (203, 30), (204, 60)]) ([201, 202, 204], 160)","solution":"def most_popular_cakes(n, k, cakes): # Sort the cakes by the order count in descending order sorted_cakes = sorted(cakes, key=lambda x: x[1], reverse=True) result_cakes = [] total_orders = 0 # Find the k-th order count kth_order_count = sorted_cakes[k-1][1] # Collect cakes with orders greater than or equal to k-th order count for identifier, count in sorted_cakes: if count >= kth_order_count: result_cakes.append(identifier) total_orders += count return result_cakes, total_orders"},{"question":"def longest_word_with_letters(letters: str, words: List[str]) -> str: Finds the longest word that can be formed using the given set of letters. If multiple words have the longest length, returns the lexicographically smallest one. >>> longest_word_with_letters(\\"abcdefg\\", [\\"abc\\", \\"def\\", \\"a\\", \\"ab\\", \\"bcd\\", \\"af\\"]) \\"abc\\" >>> longest_word_with_letters(\\"xyz\\", [\\"yxz\\", \\"yz\\", \\"y\\", \\"xx\\"]) \\"yxz\\" pass def find_longest_words(test_cases: List[Tuple[str, str]]) -> List[str]: Given list of test cases where each test case is a tuple of letters and words, returns a list of the longest words that can be formed using the given set of letters. >>> find_longest_words([(\\"abcdefg\\", \\"abc def a ab bcd af\\"), (\\"xyz\\", \\"yxz yz y xx\\")]) [\\"abc\\", \\"yxz\\"] >>> find_longest_words([(\\"a\\", \\"aa a b\\"), (\\"abcd\\", \\"ab abc abcd d\\")]) [\\"a\\", \\"abcd\\"] pass","solution":"def longest_word_with_letters(letters, words): Finds the longest word that can be formed using the given set of letters. If multiple words have the longest length, returns the lexicographically smallest one. from collections import Counter def can_form_word(word, letter_count): word_count = Counter(word) for char, count in word_count.items(): if count > letter_count[char]: return False return True letter_count = Counter(letters) valid_words = [word for word in words if can_form_word(word, letter_count)] if not valid_words: return \\"\\" valid_words.sort(key=lambda x: (-len(x), x)) # Sort by length descending, lexicographically ascending return valid_words[0] def find_longest_words(test_cases): results = [] for letters, words in test_cases: result = longest_word_with_letters(letters, words.split()) results.append(result) return results"},{"question":"from typing import List def min_moves_to_clean(n: int, m: int, grid: List[str]) -> int: Determine the minimum number of moves required for a robotic vacuum cleaner to clean all accessible cells in a grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[str]): Grid representation where '.' indicates an accessible cell and '#' indicates an obstacle. Returns: int: Minimum number of moves required to clean all accessible cells, or -1 if it's impossible. Examples: >>> min_moves_to_clean(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 4 >>> min_moves_to_clean(3, 3, [\\".#.\\", \\"#\\", \\".#.\\"]) -1 pass # Test cases to validate the solution def test_case_1(): n, m = 3, 3 grid = [\\"...\\", \\".#.\\", \\"...\\"] assert min_moves_to_clean(n, m, grid) == 4 def test_case_2(): n, m = 3, 3 grid = [\\".#.\\", \\"#\\", \\".#.\\"] assert min_moves_to_clean(n, m, grid) == -1 def test_case_3(): n, m = 1, 1 grid = [\\".\\"] assert min_moves_to_clean(n, m, grid) == 0 def test_case_4(): n, m = 2, 2 grid = [\\"..\\", \\"..\\"] assert min_moves_to_clean(n, m, grid) == 2 def test_case_5(): n, m = 2, 2 grid = [\\"..\\", \\".#\\"] assert min_moves_to_clean(n, m, grid) == 1 def test_case_all_obstacles(): n, m = 3, 3 grid = [\\"#\\", \\"#\\", \\"#\\"] assert min_moves_to_clean(n, m, grid) == 0 def test_case_isolated_cells(): n, m = 3, 3 grid = [\\"#.#\\", \\"#\\", \\"#.#\\"] assert min_moves_to_clean(n, m, grid) == -1 # You can run these tests using pytest","solution":"from collections import deque def min_moves_to_clean(n, m, grid): # Define directions for moving up, down, left, and right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Check if the full grid is accessible, if not, return -1 def is_all_accessible_reachable(start): reachable, queue = set(), deque([start]) visited = set([start]) while queue: r, c = queue.popleft() reachable.add((r, c)) for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] == '.': queue.append((nr, nc)) visited.add((nr, nc)) return reachable # Collect all accessible cells accessible_cells = {(r, c) for r in range(n) for c in range(m) if grid[r][c] == '.'} # If there are no accessible cells, return 0 moves needed if not accessible_cells: return 0 # Use BFS starting from every accessible cell, calculate max distance to reach all accessible cells min_moves = float('inf') for start in accessible_cells: reachable = is_all_accessible_reachable(start) if reachable != accessible_cells: return -1 max_dist = 0 # BFS to find the longest path from this start point queue = deque([(start, 0)]) visited = set([start]) while queue: (r, c), dist = queue.popleft() max_dist = max(max_dist, dist) for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] == '.': queue.append(((nr, nc), dist + 1)) visited.add((nr, nc)) # Update the minimum moves across all start points min_moves = min(min_moves, max_dist) return min_moves # Example usage if __name__ == \\"__main__\\": n, m = 3, 3 grid = [\\"...\\", \\".#.\\", \\"...\\"] print(min_moves_to_clean(n, m, grid)) # Output: 4"},{"question":"def min_max_distance(N: int, M: int) -> int: Given the number of water stations N and the length of the marathon route M, returns the minimized maximum distance any participant needs to run without encountering a water station. >>> min_max_distance(4, 10) 2 >>> min_max_distance(3, 8) 2","solution":"def min_max_distance(N, M): Given the number of water stations N and the length of the marathon route M, returns the minimized maximum distance any participant needs to run without encountering a water station. N: int - The number of water stations. M: int - The length of the marathon route in meters. return (M + N - 1) // N"},{"question":"def min_energy_cost(n: int, costs: List[int]) -> int: Given the number of trees and the energy cost to move between each pair, calculate the minimum possible energy cost to complete a full lap starting from any tree. :param n: Integer, number of trees :param costs: List of integers, cost to move between each connected tree :return: Integer, minimum energy cost to complete a full lap >>> min_energy_cost(5, [3, 1, 4, 2, 5]) 15 >>> min_energy_cost(4, [2, 3, 5, 1]) 11","solution":"def min_energy_cost(n, costs): Given the number of trees and the energy cost to move between each pair, calculate the minimum possible energy cost to complete a full lap starting from any tree. :param n: Integer, number of trees :param costs: List of integers, cost to move between each connected tree :return: Integer, minimum energy cost to complete a full lap # Since it's a full lap, the hero will have to incur the total cost of moving through all trees return sum(costs)"},{"question":"def get_responses_until_third_positive(responses): Returns the responses until the third \\"positive\\" response (inclusive) Parameters: responses (list of str): List of responses, each being \\"positive\\", \\"negative\\", or \\"neutral\\" Returns: list of str: List of responses up to and including the third \\"positive\\" >>> get_responses_until_third_positive([\\"neutral\\", \\"positive\\", \\"negative\\", \\"positive\\", \\"neutral\\", \\"positive\\", \\"negative\\"]) [\\"neutral\\", \\"positive\\", \\"negative\\", \\"positive\\", \\"neutral\\", \\"positive\\"] >>> get_responses_until_third_positive([\\"neutral\\", \\"positive\\", \\"negative\\"]) [\\"neutral\\", \\"positive\\", \\"negative\\"] >>> get_responses_until_third_positive([\\"positive\\", \\"neutral\\", \\"positive\\", \\"positive\\"]) [\\"positive\\", \\"neutral\\", \\"positive\\", \\"positive\\"] >>> get_responses_until_third_positive([\\"neutral\\", \\"negative\\", \\"neutral\\"]) [\\"neutral\\", \\"negative\\", \\"neutral\\"] >>> get_responses_until_third_positive([\\"positive\\", \\"positive\\", \\"positive\\", \\"positive\\"]) [\\"positive\\", \\"positive\\", \\"positive\\"] >>> get_responses_until_third_positive([\\"negative\\", \\"positive\\", \\"neutral\\", \\"positive\\", \\"negative\\", \\"positive\\", \\"neutral\\", \\"positive\\"]) [\\"negative\\", \\"positive\\", \\"neutral\\", \\"positive\\", \\"negative\\", \\"positive\\"]","solution":"def get_responses_until_third_positive(responses): Returns the responses until the third \\"positive\\" response (inclusive) Parameters: responses (list of str): List of responses, each being \\"positive\\", \\"negative\\", or \\"neutral\\" Returns: list of str: List of responses up to and including the third \\"positive\\" output = [] positive_count = 0 for response in responses: output.append(response) if response == \\"positive\\": positive_count += 1 if positive_count == 3: break return output"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(node_values, edges): nodes = {i + 1: TreeNode(val) for i, val in enumerate(node_values)} for u, v in edges: if nodes[u].left is None: nodes[u].left = nodes[v] else: nodes[u].right = nodes[v] return nodes[1] def inorder_sum(root): if root is None: return 0 return inorder_sum(root.left) + root.value + inorder_sum(root.right) def preorder_sum(root): if root is None: return 0 return root.value + preorder_sum(root.left) + preorder_sum(root.right) def postorder_sum(root): if root is None: return 0 return postorder_sum(root.left) + postorder_sum(root.right) + root.value def calculate_sums(N, node_values, edges): Calculates the sum of all node values for the Inorder, Preorder, and Postorder traversals of the tree. Args: N (int): the number of nodes in the binary tree. node_values (List[int]): the values of the nodes from 1 to N in the binary tree. edges (List[Tuple[int, int]]): edges between nodes. Returns: Tuple[int, int, int]: three integers representing the sum of all node values for Inorder, Preorder, and Postorder traversals of the tree. root = build_tree(node_values, edges) return inorder_sum(root), preorder_sum(root), postorder_sum(root)","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(node_values, edges): nodes = {i + 1: TreeNode(val) for i, val in enumerate(node_values)} for u, v in edges: if nodes[u].left is None: nodes[u].left = nodes[v] else: nodes[u].right = nodes[v] return nodes[1] def inorder_sum(root): if root is None: return 0 return inorder_sum(root.left) + root.value + inorder_sum(root.right) def preorder_sum(root): if root is None: return 0 return root.value + preorder_sum(root.left) + preorder_sum(root.right) def postorder_sum(root): if root is None: return 0 return postorder_sum(root.left) + postorder_sum(root.right) + root.value def calculate_sums(N, node_values, edges): root = build_tree(node_values, edges) return inorder_sum(root), preorder_sum(root), postorder_sum(root) # Example usage: # N = 5 # node_values = [1, 2, 3, 4, 5] # edges = [(1, 2), (1, 3), (2, 4), (2, 5)] # print(calculate_sums(N, node_values, edges))"},{"question":"def can_water_all_plants(N, M, grid): Determine if every plant in Emily's garden can be watered by at least one sprinkler. Args: N (int): The number of rows in the grid. M (int): The number of columns in the grid. grid (List[str]): The garden grid configuration as a list of strings. Returns: str: \\"Yes\\" if all plants can be watered, otherwise \\"No\\". Examples: >>> can_water_all_plants(4, 4, [\\"EPEE\\", \\"SSPE\\", \\"EPPS\\", \\"EEEE\\"]) \\"Yes\\" >>> can_water_all_plants(3, 5, [\\"EPPEE\\", \\"ESEEE\\", \\"EEPES\\"]) \\"No\\" pass # Unit tests def test_example_1(): N, M, grid = 4, 4, [ \\"EPEE\\", \\"SSPE\\", \\"EPPS\\", \\"EEEE\\" ] assert can_water_all_plants(N, M, grid) == \\"Yes\\" def test_example_2(): N, M, grid = 3, 5, [ \\"EPPEE\\", \\"ESEEE\\", \\"EEPES\\" ] assert can_water_all_plants(N, M, grid) == \\"No\\" def test_case_surrounded_plant(): N, M, grid = 3, 3, [ \\"EEE\\", \\"EPE\\", \\"EEE\\" ] assert can_water_all_plants(N, M, grid) == \\"No\\" def test_case_corner_sprinkler(): N, M, grid = 3, 3, [ \\"SPE\\", \\"EEE\\", \\"EEE\\" ] assert can_water_all_plants(N, M, grid) == \\"Yes\\" def test_case_blocked_by_plant(): N, M, grid = 3, 3, [ \\"SEE\\", \\"PPE\\", \\"SEE\\" ] assert can_water_all_plants(N, M, grid) == \\"No\\"","solution":"def can_water_all_plants(N, M, grid): Determine if every plant in Emily's garden can be watered by at least one sprinkler. def is_watered_by_sprinkler(x, y): # Check if the plant (x, y) can be watered by any sprinklers in the up, down, left, right directions # check up direction i = x - 1 while i >= 0: if grid[i][y] == 'P': break if grid[i][y] == 'S': return True i -= 1 # check down direction i = x + 1 while i < N: if grid[i][y] == 'P': break if grid[i][y] == 'S': return True i += 1 # check left direction j = y - 1 while j >= 0: if grid[x][j] == 'P': break if grid[x][j] == 'S': return True j -= 1 # check right direction j = y + 1 while j < M: if grid[x][j] == 'P': break if grid[x][j] == 'S': return True j += 1 return False for i in range(N): for j in range(M): if grid[i][j] == 'P' and not is_watered_by_sprinkler(i, j): return \\"No\\" return \\"Yes\\""},{"question":"def minimum_connections_to_add(N: int, M: int, connections: List[Tuple[int, int]]) -> int: Determine the minimum number of direct connections to be added to the network to make it fully connected. >>> minimum_connections_to_add(4, 2, [(1, 2), (3, 4)]) 1 >>> minimum_connections_to_add(5, 0, []) 4 >>> minimum_connections_to_add(6, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)]) 0 >>> minimum_connections_to_add(3, 1, [(1, 2)]) 1 >>> minimum_connections_to_add(3, 3, [(1, 2), (1, 3), (2, 3)]) 0 >>> minimum_connections_to_add(1, 0, []) 0 >>> minimum_connections_to_add(4, 0, []) 3","solution":"def minimum_connections_to_add(N, M, connections): from collections import defaultdict, deque # Create adjacency list representation of the graph graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) def bfs(start_node, visited): queue = deque([start_node]) visited[start_node] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) visited = [False] * (N + 1) num_components = 0 for i in range(1, N + 1): if not visited[i]: num_components += 1 bfs(i, visited) return max(0, num_components - 1)"},{"question":"def G(B, Z): Calculate the maximum value W such that Z divides W - B[i] for all B[i] in B. Args: B (list): Array of integers Z (int): The integer Z Returns: int: Maximum integer W pass def process_test_cases(T, test_cases): Process multiple test cases Args: T (int): Number of test cases test_cases (list of tuples): Each tuple contains (N, B) Returns: list of lists: Each list contains results for a test case pass def test_G(): assert G([4, 6], 4) == 8 assert G([4, 6], 6) == 10 assert G([3, 3, 3], 3) == 6 def test_process_test_cases(): T = 2 test_cases = [ (2, [4, 6]), (3, [3, 3, 3]) ] expected_results = [ [8, 10], [6, 6, 6] ] assert process_test_cases(T, test_cases) == expected_results def test_edge_case(): T = 1 test_cases = [ (1, [1]) ] expected_results = [ [2] ] assert process_test_cases(T, test_cases) == expected_results","solution":"def G(B, Z): Calculate the maximum value W such that Z divides W - B[i] for all B[i] in B. Args: B (list): Array of integers Z (int): The integer Z Returns: int: Maximum integer W # Calculate W as the largest K * Z + min(B) min_B = min(B) W = Z + min_B return W def process_test_cases(T, test_cases): Process multiple test cases Args: T (int): Number of test cases test_cases (list of tuples): Each tuple contains (N, B) Returns: list of lists: Each list contains results for a test case results = [] for i in range(T): N, B = test_cases[i] # For each B[i] in B, calculate G(B, B[i]) result = [G(B, B[i]) for i in range(N)] results.append(result) return results"},{"question":"from typing import List, Tuple def find_palindrome_pairs(words: List[str]) -> List[Tuple[int, int]]: Design a function that takes a list of words and returns a list of all unique pairs of indices (i, j) such that the concatenation of the words words[i] + words[j] is a palindrome. Example: >>> find_palindrome_pairs([\\"bat\\", \\"tab\\", \\"cat\\"]) [(0, 1), (1, 0)] >>> find_palindrome_pairs([\\"abcd\\", \\"dcba\\", \\"lls\\", \\"s\\", \\"sssll\\"]) [(0, 1), (1, 0), (3, 2), (2, 4)] def test_find_palindrome_pairs_example1(): assert set(find_palindrome_pairs([\\"bat\\", \\"tab\\", \\"cat\\"])) == set([(0, 1), (1, 0)]) def test_find_palindrome_pairs_example2(): assert set(find_palindrome_pairs([\\"abcd\\", \\"dcba\\", \\"lls\\", \\"s\\", \\"sssll\\"])) == set([(0, 1), (1, 0), (3, 2), (2, 4)]) def test_find_palindrome_pairs_empty(): assert find_palindrome_pairs([]) == [] def test_find_palindrome_pairs_no_palindromes(): assert find_palindrome_pairs([\\"abc\\", \\"def\\", \\"ghi\\"]) == [] def test_find_palindrome_pairs_single_word(): assert find_palindrome_pairs([\\"a\\"]) == [] def test_find_palindrome_pairs_multiple_palindromes(): words = [\\"bat\\", \\"tab\\", \\"cat\\", \\"tac\\"] expected_output = set([(0, 1), (1, 0), (2, 3), (3, 2)]) assert set(find_palindrome_pairs(words)) == expected_output","solution":"from typing import List, Tuple def is_palindrome(s: str) -> bool: Helper function to check if a given string is a palindrome. return s == s[::-1] def find_palindrome_pairs(words: List[str]) -> List[Tuple[int, int]]: Given a list of words, returns a list of all unique pairs of indices (i, j) such that the concatenation of the words words[i] + words[j] is a palindrome. palindrome_pairs = [] word_to_index = {word: i for i, word in enumerate(words)} for i, word in enumerate(words): for j in range(len(word) + 1): prefix, suffix = word[:j], word[j:] if is_palindrome(prefix): reversed_suffix = suffix[::-1] if reversed_suffix in word_to_index and word_to_index[reversed_suffix] != i: palindrome_pairs.append((word_to_index[reversed_suffix], i)) if j != len(word) and is_palindrome(suffix): reversed_prefix = prefix[::-1] if reversed_prefix in word_to_index and word_to_index[reversed_prefix] != i: palindrome_pairs.append((i, word_to_index[reversed_prefix])) return palindrome_pairs"},{"question":"def longest_subsequence_with_difference_k(n: int, k: int, arr: List[int]) -> int: Returns the length of the longest subsequence such that the difference between consecutive elements is exactly k. >>> longest_subsequence_with_difference_k(5, 2, [1, 3, 5, 7, 9]) 5 >>> longest_subsequence_with_difference_k(6, 1, [10, 11, 12, 13, 14, 15]) 6 >>> longest_subsequence_with_difference_k(4, 3, [3, 6, 9, 1]) 3","solution":"def longest_subsequence_with_difference_k(n, k, arr): Returns the length of the longest subsequence such that the difference between consecutive elements is exactly k. dp = {} max_length = 0 for num in arr: if num - k in dp: dp[num] = dp[num - k] + 1 else: dp[num] = 1 max_length = max(max_length, dp[num]) return max_length"},{"question":"def minimum_sum_of_differences(n: int, difficulties: List[int]) -> int: Alice is organizing a hiking trip with her friends and needs to decide the order in which they will visit a series of checkpoints. There are n checkpoints they must visit, and each checkpoint has a unique difficulty level associated with it. Alice wants to create a plan where the sum of the absolute differences between the difficulties of consecutive checkpoints is minimized. She can rearrange the order of visiting the checkpoints in any way she wishes, but she cannot skip any checkpoint. Your task is to help Alice find the minimum possible sum of the absolute differences between the difficulties of consecutive checkpoints. Args: n (int): The number of checkpoints. difficulties (List[int]): The difficulty level for each checkpoint. Returns: int: The minimum possible sum of the absolute differences between the difficulties of consecutive checkpoints. Examples: >>> minimum_sum_of_differences(4, [10, 1, 4, 8]) 9 >>> minimum_sum_of_differences(3, [3, 6, 2]) 4 >>> minimum_sum_of_differences(5, [1, 3, 5, 9, 2]) 6","solution":"def minimum_sum_of_differences(n, difficulties): Returns the minimum possible sum of the absolute differences between the difficulties of consecutive checkpoints. if n <= 1: return 0 difficulties.sort() min_sum = 0 for i in range(1, n): min_sum += abs(difficulties[i] - difficulties[i - 1]) return min_sum"},{"question":"def find_package_combination(n: int) -> (int, int): Finds the minimal combination of single packages and 3-cookie boxes to exactly fulfill an order of n cookies. :param n: Integer, the exact number of cookies to be packaged. :return: Tuple (p1, p2), where p1 is the number of single packages and p2 is the number of 3-cookie boxes. Examples: >>> find_package_combination(15) == (0, 5) >>> find_package_combination(7) == (1, 2) >>> find_package_combination(1) == (1, 0) >>> find_package_combination(10) == (1, 3) >>> find_package_combination(1000000000) == (1, 333333333) or find_package_combination(1000000000) == (0, 333333333) >>> find_package_combination(5) == (2, 1) def solve(t_cases: List[int]) -> List[(int, int)]: For each test case, find the minimal combination of single packages and 3-cookie boxes. :param t_cases: List of integers, each denoting the number of cookies in a given test case. :return: List of tuples (p1, p2) for each test case. Examples: >>> solve([15, 7, 1, 10, 1000000000, 5]) == [(0, 5), (1, 2), (1, 0), (1, 3), (0, 333333333), (2, 1)] or solve([15, 7, 1, 10, 1000000000, 5]) == [(0, 5), (1, 2), (1, 0), (1, 3), (1, 333333333), (2, 1)]","solution":"def find_package_combination(n): Finds the minimal combination of single packages and 3-cookie boxes to exactly fulfill an order of n cookies. :param n: Integer, the exact number of cookies to be packaged. :return: Tuple (p1, p2), where p1 is the number of single packages and p2 is the number of 3-cookie boxes. if n < 0: raise ValueError(\\"Number of cookies must be a non-negative integer\\") # Calculate the number of 3-cookie boxes p2 = n // 3 # Calculate remaining cookies remainder = n % 3 # Remaining cookies to be packaged in single cookie packages p1 = remainder return p1, p2 def solve(t_cases): For each test case, find the minimal combination of single packages and 3-cookie boxes. :param t_cases: List of integers, each denoting the number of cookies in a given test case. :return: List of tuples (p1, p2) for each test case. results = [] for n in t_cases: results.append(find_package_combination(n)) return results"},{"question":"import math from functools import reduce from typing import List def gcd(a: int, b: int) -> int: Returns the greatest common divisor of a and b. pass def gcd_of_list(numbers: List[int]) -> int: Returns the gcd of a list of numbers. pass def standardized_recipe_quantities(n: int, quantities: List[int], q: int, queries: List[int]) -> List[int]: For each query, return the Greatest Common Divisor (GCD) of the quantities of the first q_i ingredients. >>> standardized_recipe_quantities(5, [12, 15, 18, 24, 30], 3, [2, 4, 5]) [3, 3, 3] >>> standardized_recipe_quantities(6, [35, 49, 63, 91, 98, 126], 4, [1, 3, 4, 6]) [35, 7, 7, 7] # Unit test def test_gcd(): assert gcd(54, 24) == 6 assert gcd(17, 13) == 1 assert gcd(100, 25) == 25 assert gcd(1, 0) == 1 def test_gcd_of_list(): assert gcd_of_list([12, 15, 18, 24, 30]) == 3 assert gcd_of_list([35, 49, 63, 91, 98, 126]) == 7 assert gcd_of_list([2, 4, 6, 8]) == 2 assert gcd_of_list([1, 1, 1, 1]) == 1 def test_standardized_recipe_quantities(): n = 5 quantities = [12, 15, 18, 24, 30] q = 3 queries = [2, 4, 5] expected = [3, 3, 3] assert standardized_recipe_quantities(n, quantities, q, queries) == expected n = 6 quantities = [35, 49, 63, 91, 98, 126] q = 4 queries = [1, 3, 4, 6] expected = [35, 7, 7, 7] assert standardized_recipe_quantities(n, quantities, q, queries) == expected n = 3 quantities = [8, 12, 16] q = 2 queries = [1, 3] expected = [8, 4] assert standardized_recipe_quantities(n, quantities, q, queries) == expected n = 4 quantities = [5, 10, 20, 25] q = 3 queries = [2, 3, 4] expected = [5, 5, 5] assert standardized_recipe_quantities(n, quantities, q, queries) == expected","solution":"import math from functools import reduce def gcd(a, b): Returns the greatest common divisor of a and b. while b: a, b = b, a % b return a def gcd_of_list(numbers): Returns the gcd of a list of numbers. return reduce(gcd, numbers) def standardized_recipe_quantities(n, quantities, q, queries): For each query, returns the Greatest Common Divisor (GCD) of the quantities of the first q_i ingredients. results = [] for i in range(q): results.append(gcd_of_list(quantities[:queries[i]])) return results"},{"question":"def find_tournament_winner(t: int, cases: List[List[int]]) -> List[int]: Predict the winner of the magical contest for each test case. >>> find_tournament_winner(1, [3, [0, 10, 20], [10, 0, 30], [20, 30, 0]]) [2] >>> find_tournament_winner(2, [3, [0, 10, 20], [10, 0, 30], [20, 30, 0], 4, [0, 15, 25, 35], [15, 0, 5, 45], [25, 5, 0, 55], [35, 45, 55, 0]]) [2, 3]","solution":"def find_tournament_winner(t, cases): def predict_winner(n, power_levels): winner = 0 for i in range(1, n): strength_of_i = 0 strength_of_winner = 0 # Compare overall strength of i and current winner for j in range(n): if j != i: strength_of_i += power_levels[i][j] if j != winner: strength_of_winner += power_levels[winner][j] if strength_of_i > strength_of_winner: winner = i return winner results = [] index = 0 for case_index in range(t): n = cases[index] index += 1 power_levels = [] for _ in range(n): power_levels.append(cases[index]) index += 1 results.append(predict_winner(n, power_levels)) return results"},{"question":"def classify_sellers(num_sellers, sellers_data): Classifies sellers based on their average rating as \\"Excellent\\", \\"Good\\", or \\"Poor\\". :param num_sellers: Integer, the number of sellers :param sellers_data: List of lists, where each sublist contains an integer for the number of feedbacks followed by the feedback ratings :return: List of strings, classification for each seller >>> classify_sellers(3, [[4, 50, 60, 70, 80], [3, 10, -10, 30], [2, -20, -30]]) [\\"Excellent\\", \\"Good\\", \\"Poor\\"] >>> classify_sellers(2, [[5, 10, 20, 30, 40, 50], [3, -10, -20, -30]]) [\\"Good\\", \\"Poor\\"] >>> classify_sellers(3, [[4, 50, 50, 50, 50], [4, 0, 0, 0, 0], [4, -50, -50, -50, -50]]) [\\"Excellent\\", \\"Good\\", \\"Poor\\"] >>> classify_sellers(2, [[3, -10, -20, -30], [4, -40, -50, -60, -70]]) [\\"Poor\\", \\"Poor\\"] >>> classify_sellers(3, [[1, 60], [1, 0], [1, -100]]) [\\"Excellent\\", \\"Good\\", \\"Poor\\"]","solution":"def classify_sellers(num_sellers, sellers_data): Classifies sellers based on their average rating as \\"Excellent\\", \\"Good\\", or \\"Poor\\". :param num_sellers: Integer, the number of sellers :param sellers_data: List of lists, where each sublist contains an integer for the number of feedbacks followed by the feedback ratings :return: List of strings, classification for each seller classifications = [] for i in range(num_sellers): feedback_count = sellers_data[i][0] feedback_ratings = sellers_data[i][1:] avg_rating = sum(feedback_ratings) / feedback_count if avg_rating >= 50: classifications.append(\\"Excellent\\") elif avg_rating >= 0: classifications.append(\\"Good\\") else: classifications.append(\\"Poor\\") return classifications"},{"question":"from collections import deque class Queue: def __init__(self): self.queue = deque() def enqueue(self, x): self.queue.append(x) def dequeue(self): if not self.isempty(): self.queue.popleft() def front(self): if not self.isempty(): return self.queue[0] def size(self): return len(self.queue) def isempty(self): return len(self.queue) == 0 def process_operations(n, operations): Process a list of operations on a queue and return the results. Args: n (int): The number of operations. operations (List[str]): A list of operations to be performed on the queue. Returns: List: The results of the operations that generate an output. >>> process_operations(8, [\\"ENQUEUE 5\\", \\"ENQUEUE 10\\", \\"FRONT\\", \\"DEQUEUE\\", \\"FRONT\\", \\"SIZE\\", \\"DEQUEUE\\", \\"ISEMPTY\\"]) [5, 10, 1, \\"YES\\"] >>> process_operations(1, [\\"ISEMPTY\\"]) [\\"YES\\"] >>> process_operations(4, [\\"ENQUEUE 42\\", \\"FRONT\\", \\"DEQUEUE\\", \\"ISEMPTY\\"]) [42, \\"YES\\"] >>> process_operations(9, [\\"ENQUEUE 1\\", \\"ENQUEUE 2\\", \\"ENQUEUE 3\\", \\"DEQUEUE\\", \\"FRONT\\", \\"SIZE\\", \\"DEQUEUE\\", \\"DEQUEUE\\", \\"ISEMPTY\\"]) [2, 2, \\"YES\\"] >>> process_operations(11, [\\"ENQUEUE 10\\", \\"ENQUEUE 20\\", \\"ENQUEUE 30\\", \\"FRONT\\", \\"SIZE\\", \\"DEQUEUE\\", \\"FRONT\\", \\"DEQUEUE\\", \\"FRONT\\", \\"DEQUEUE\\", \\"ISEMPTY\\"]) [10, 3, 20, 30, \\"YES\\"]","solution":"from collections import deque class Queue: def __init__(self): self.queue = deque() def enqueue(self, x): self.queue.append(x) def dequeue(self): if not self.isempty(): self.queue.popleft() def front(self): if not self.isempty(): return self.queue[0] def size(self): return len(self.queue) def isempty(self): return len(self.queue) == 0 def process_operations(n, operations): q = Queue() result = [] for op in operations: if op.startswith(\\"ENQUEUE\\"): _, x = op.split() q.enqueue(int(x)) elif op == \\"DEQUEUE\\": q.dequeue() elif op == \\"FRONT\\": result.append(q.front()) elif op == \\"SIZE\\": result.append(q.size()) elif op == \\"ISEMPTY\\": result.append(\\"YES\\" if q.isempty() else \\"NO\\") return result"},{"question":"from typing import List def sortedSquares(arr: List[int]) -> List[int]: Given a sorted array of distinct integers, return a sorted array of square values of each number. >>> sortedSquares([-4,-1,0,3,10]) [0, 1, 9, 16, 100] >>> sortedSquares([-7,-3,2,3,11]) [4, 9, 9, 49, 121] from solution import sortedSquares def test_example_1(): assert sortedSquares([-4, -1, 0, 3, 10]) == [0, 1, 9, 16, 100] def test_example_2(): assert sortedSquares([-7, -3, 2, 3, 11]) == [4, 9, 9, 49, 121] def test_all_negative(): assert sortedSquares([-5, -4, -3, -2, -1]) == [1, 4, 9, 16, 25] def test_all_positive(): assert sortedSquares([1, 2, 3, 4, 5]) == [1, 4, 9, 16, 25] def test_mixed(): assert sortedSquares([-5, -3, -1, 0, 2, 4, 6]) == [0, 1, 4, 9, 16, 25, 36] def test_single_element(): assert sortedSquares([3]) == [9] assert sortedSquares([-3]) == [9] def test_empty_array(): assert sortedSquares([]) == []","solution":"def sortedSquares(arr): Returns a sorted array of the square values of each number in the given sorted array of distinct integers. n = len(arr) left, right = 0, n - 1 result = [0] * n position = n - 1 while left <= right: left_square = arr[left] ** 2 right_square = arr[right] ** 2 if left_square > right_square: result[position] = left_square left += 1 else: result[position] = right_square right -= 1 position -= 1 return result"},{"question":"def preprocess_matrix(matrix, N, M): Preprocess the matrix to create a prefix sum matrix. pass # Replace with your implementation def subrectangle_sum(prefix_sum, r1, c1, r2, c2): Calculate the sum of elements in a subrectangle using the prefix sum. pass # Replace with your implementation def matrix_query(matrix, queries): Process a number of subrectangle sum queries and return results. pass # Replace with your implementation from matrix_sum import preprocess_matrix, subrectangle_sum, matrix_query def test_preprocess_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] N, M = 3, 3 prefix_sum = preprocess_matrix(matrix, N, M) expected_prefix_sum = [ [0, 0, 0, 0], [0, 1, 3, 6], [0, 5, 12, 21], [0, 12, 27, 45] ] assert prefix_sum == expected_prefix_sum def test_subrectangle_sum(): prefix_sum = [ [0, 0, 0, 0], [0, 1, 3, 6], [0, 5, 12, 21], [0, 12, 27, 45] ] assert subrectangle_sum(prefix_sum, 1, 1, 2, 2) == 12 assert subrectangle_sum(prefix_sum, 1, 1, 3, 3) == 45 assert subrectangle_sum(prefix_sum, 2, 2, 3, 3) == 28 def test_matrix_query(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [ (1, 1, 2, 2), (1, 1, 3, 3) ] result = matrix_query(matrix, queries) assert result == [12, 45] def test_large_matrix_query(): matrix = [[1] * 1000 for _ in range(1000)] queries = [ (1, 1, 1000, 1000), (1, 1, 500, 500) ] result = matrix_query(matrix, queries) assert result == [1000000, 250000]","solution":"def preprocess_matrix(matrix, N, M): Preprocess the matrix to create a prefix sum matrix. prefix_sum = [[0] * (M + 1) for _ in range(N + 1)] for i in range(1, N + 1): for j in range(1, M + 1): prefix_sum[i][j] = ( matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] ) return prefix_sum def subrectangle_sum(prefix_sum, r1, c1, r2, c2): Calculate the sum of elements in a subrectangle using the prefix sum. return ( prefix_sum[r2][c2] - prefix_sum[r1-1][c2] - prefix_sum[r2][c1-1] + prefix_sum[r1-1][c1-1] ) def matrix_query(matrix, queries): N = len(matrix) M = len(matrix[0]) prefix_sum = preprocess_matrix(matrix, N, M) results = [] for r1, c1, r2, c2 in queries: results.append(subrectangle_sum(prefix_sum, r1, c1, r2, c2)) return results"},{"question":"def min_max_diff_permutation(arr): Given an array of integers, returns the minimum possible maximum absolute difference between any two consecutive elements in any permutation of the array. Examples: >>> min_max_diff_permutation([1, 3, 6]) 2 >>> min_max_diff_permutation([4, 10, 1, 7]) 3 >>> min_max_diff_permutation([5, 9, 1, 4]) 1 >>> min_max_diff_permutation([10, 20, 40, 80]) 10 >>> min_max_diff_permutation([1, 2, 3, 4, 5]) 1 def process_test_cases(test_cases): Processes multiple test cases for the min_max_diff_permutation function. :param test_cases: List of test cases, where each test case is represented by a tuple containing the number of elements and the list of elements. :return: List of results for each test case. Examples: >>> test_cases = [(3, [1, 3, 6]), (4, [4, 10, 1, 7]), (4, [5, 9, 1, 4]), (4, [10, 20, 40, 80]), (5, [1, 2, 3, 4, 5])] >>> process_test_cases(test_cases) [2, 3, 1, 10, 1] def test_min_max_diff_permutation(): assert min_max_diff_permutation([1, 3, 6]) == 2 assert min_max_diff_permutation([4, 10, 1, 7]) == 3 assert min_max_diff_permutation([5, 9, 1, 4]) == 1 assert min_max_diff_permutation([10, 20, 40, 80]) == 10 assert min_max_diff_permutation([1, 2, 3, 4, 5]) == 1 def test_process_test_cases(): test_cases = [ (3, [1, 3, 6]), (4, [4, 10, 1, 7]), (4, [5, 9, 1, 4]), (4, [10, 20, 40, 80]), (5, [1, 2, 3, 4, 5]) ] expected_results = [2, 3, 1, 10, 1] assert process_test_cases(test_cases) == expected_results","solution":"def min_max_diff_permutation(arr): Given an array of integers, returns the minimum possible maximum absolute difference between any two consecutive elements in any permutation of the array. arr.sort() min_max_diff = float('inf') # Calculate the maximum difference for the sorted array for i in range(1, len(arr)): min_max_diff = min(min_max_diff, arr[i] - arr[i - 1]) return min_max_diff def process_test_cases(test_cases): Processes multiple test cases for the min_max_diff_permutation function. :param test_cases: List of test cases, where each test case is represented by a tuple containing the number of elements and the list of elements. :return: List of results for each test case. results = [] for case in test_cases: N, arr = case results.append(min_max_diff_permutation(arr)) return results"},{"question":"import heapq class KthLargest: def __init__(self): Initialize KthLargest with an empty sequence. self.sequence = [] self.min_heap = [] def insert(self, x): Insert the integer x into the sequence. pass def kth(self, k): Return the k-th largest element currently in the sequence. pass def process_operations(operations): Process a list of operations and return the results for 'kth' operations. Args: operations (List[str]): A list of operations as strings. Returns: List[int]: Results of 'kth' operations. Example: >>> process_operations([\\"insert 5\\", \\"insert 2\\", \\"kth 1\\", \\"insert 8\\", \\"kth 2\\", \\"insert 3\\", \\"kth 3\\", \\"end\\"]) [5, 5, 3] pass import pytest def test_insert_and_kth(): operations = [ \\"insert 5\\", \\"insert 2\\", \\"kth 1\\", \\"insert 8\\", \\"kth 2\\", \\"insert 3\\", \\"kth 3\\", \\"end\\" ] expected_output = [ 5, 5, 3 ] assert process_operations(operations) == expected_output def test_single_insert_multiple_kth(): operations = [ \\"insert 1\\", \\"kth 1\\", \\"kth 1\\", \\"kth 1\\", \\"end\\" ] expected_output = [1, 1, 1] assert process_operations(operations) == expected_output def test_large_number_inserts_and_queries(): operations = [ \\"insert 1000000000\\", \\"insert 2\\", \\"insert 300000\\", \\"insert 50\\", \\"insert 6000\\", \\"kth 1\\", \\"kth 2\\", \\"kth 3\\", \\"kth 4\\", \\"kth 5\\", \\"end\\" ] expected_output = [ 1000000000, 300000, 6000, 50, 2 ] assert process_operations(operations) == expected_output def test_insert_and_kth_alternate(): operations = [ \\"insert 10\\", \\"kth 1\\", \\"insert 20\\", \\"kth 1\\", \\"kth 2\\", \\"insert 5\\", \\"kth 1\\", \\"kth 2\\", \\"kth 3\\", \\"end\\" ] expected_output = [10, 20, 10, 20, 10, 5] assert process_operations(operations) == expected_output if __name__ == \\"__main__\\": pytest.main()","solution":"import heapq class KthLargest: def __init__(self): self.sequence = [] self.min_heap = [] def insert(self, x): heapq.heappush(self.sequence, -x) def kth(self, k): # Copy the heap to avoid modifying the original structure temp = self.sequence.copy() # Use heappop to get the k-th largest element result = None for _ in range(k): result = -heapq.heappop(temp) return result def process_operations(operations): kth_largest = KthLargest() results = [] for op in operations: if op.startswith('insert'): _, x = op.split() kth_largest.insert(int(x)) elif op.startswith('kth'): _, k = op.split() results.append(kth_largest.kth(int(k))) return results"},{"question":"def find_single_in_sorted_array(ary: List[int]) -> int: Find the single element in a sorted array where every element appears exactly twice except for one element. >>> find_single_in_sorted_array([1, 1, 2, 2, 3]) 3 >>> find_single_in_sorted_array([1, 2, 2, 3, 3, 4, 4]) 1 >>> find_single_in_sorted_array([1, 1, 2, 3, 3, 4, 4]) 2","solution":"def find_single_in_sorted_array(ary): This function finds the single element in a sorted array where every element appears exactly twice except for one element. It uses a binary search approach to achieve better than O(n) time complexity. left, right = 0, len(ary) - 1 while left < right: mid = left + (right - left) // 2 if mid % 2 == 1: mid -= 1 # Ensure mid is even so we can compare pairs if ary[mid] == ary[mid + 1]: left = mid + 2 else: right = mid return ary[left]"},{"question":"def is_palindrome_substring(s: str, queries: List[Tuple[int, int]]) -> List[str]: Determine if the substring of \`s\` from index \`l\` to \`r\` (1-based index) is a palindrome. >>> is_palindrome_substring(\\"abacaba\\", [(1, 3), (2, 4), (1, 7)]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> is_palindrome_substring(\\"hello\\", [(1, 4)]) [\\"NO\\"]","solution":"def is_palindrome_substring(s, queries): results = [] for l, r in queries: substring = s[l-1:r] if substring == substring[::-1]: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage: # s = \\"abacaba\\" # queries = [(1, 3), (2, 4), (1, 7)] # print(is_palindrome_substring(s, queries))"},{"question":"def find_unique_integer(arr): Finds and returns the integer that appears only once in the array. Args: arr (list of int): The list of integers where each integer appears exactly twice except for one. Returns: int: The integer that appears only once. Examples: >>> find_unique_integer([4, 3, 2, 4, 1, 3, 2]) 1 >>> find_unique_integer([1, 1, 2, 2, 3]) 3","solution":"def find_unique_integer(arr): Finds and returns the integer that appears only once in the array. Args: arr (list of int): The list of integers where each integer appears exactly twice except for one. Returns: int: The integer that appears only once. unique = 0 for num in arr: unique ^= num return unique"},{"question":"def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the elements of the array to the right by k positions. Parameters: arr (list): A list of integers k (int): A positive integer indicating the number of positions to rotate to the right Returns: list: A new list with the elements rotated to the right by k positions Examples: >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([0, 1, 2], 4) [2, 0, 1] from solution import rotate_array def test_rotate_array_typical_case(): assert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] def test_rotate_array_with_k_greater_than_length(): assert rotate_array([0, 1, 2], 4) == [2, 0, 1] def test_rotate_array_with_k_equal_to_zero(): assert rotate_array([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] def test_rotate_array_with_single_element(): assert rotate_array([1], 1000) == [1] def test_rotate_array_with_k_equal_to_length(): assert rotate_array([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] def test_rotate_array_with_multiple_rotations(): assert rotate_array([1, 2, 3], 6) == [1, 2, 3] def test_rotate_array_empty_array(): assert rotate_array([], 0) == [] def test_rotate_array_large_k_not_multiple_of_n(): assert rotate_array([1, 2, 3, 4, 5, 6], 8) == [5, 6, 1, 2, 3, 4] def test_rotate_array_large_array(): assert rotate_array(list(range(1, 100001)), 99999) == list(range(2, 100001)) + [1]","solution":"def rotate_array(arr, k): Rotates the elements of the array to the right by k positions. Parameters: arr (list): A list of integers k (int): A positive integer indicating the number of positions to rotate to the right Returns: list: A new list with the elements rotated to the right by k positions if not arr: return [] n = len(arr) k = k % n return arr[-k:] + arr[:-k]"},{"question":"def shift_alphabet(input_string: str) -> str: Processes a string of lowercase letters and returns a new string where each character is replaced by the next character in the alphabet, wrapping around from 'z' to 'a'. >>> shift_alphabet('abc') 'bcd' >>> shift_alphabet('xyz') 'yza' >>> shift_alphabet('a1b2c3') 'b1c2d3' >>> shift_alphabet('xyz123') 'yza123' >>> shift_alphabet('a') 'b' >>> shift_alphabet('z') 'a' >>> shift_alphabet('') '' >>> shift_alphabet('123456') '123456'","solution":"def shift_alphabet(input_string: str) -> str: Processes a string of lowercase letters and returns a new string where each character is replaced by the next character in the alphabet, wrapping around from 'z' to 'a'. result = [] for char in input_string: if 'a' <= char <= 'z': # Only process lowercase alphabetic characters new_char = chr((ord(char) - ord('a') + 1) % 26 + ord('a')) result.append(new_char) else: result.append(char) return ''.join(result)"},{"question":"from typing import List def findWords(grid: List[List[str]], words: List[str]) -> List[str]: Finds all words in the grid that can be formed by sequentially adjacent letters. Same letter cell may not be used more than once in a word. Words should be returned in a list in lexicographical order. Example 1: >>> grid = [ ... ['o','a','a','n'], ... ['e','t','a','e'], ... ['i','h','k','r'], ... ['i','f','l','v'] ... ] >>> findWords(grid, [\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"]) ['eat', 'oath'] Example 2: >>> grid = [ ... ['a','b'], ... ['c','d'] ... ] >>> findWords(grid, [\\"abcb\\"]) []","solution":"def findWords(grid, words): Finds all words in the grid that can be formed by sequentially adjacent letters. if not grid or not grid[0]: return [] rows, cols = len(grid), len(grid[0]) def dfs(x, y, node, path, visited): if 'end' in node: result.add(node['end']) if x < 0 or x >= rows or y < 0 or y >= cols or (x, y) in visited or grid[x][y] not in node: return visited.add((x, y)) char = grid[x][y] for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy dfs(nx, ny, node[char], path + char, visited) visited.remove((x, y)) def build_trie(): trie = {} for word in words: node = trie for char in word: if char not in node: node[char] = {} node = node[char] node['end'] = word return trie trie = build_trie() result = set() for i in range(rows): for j in range(cols): dfs(i, j, trie, \\"\\", set()) return sorted(result)"},{"question":"def decode_caesar_cipher(encoded_message: str, possible_words: List[str]) -> str: Decode the encoded message using a Caesar cipher and find the original message from the list of possible words. >>> decode_caesar_cipher(\\"dpef\\", [\\"code\\", \\"hello\\"]) \\"code\\" >>> decode_caesar_cipher(\\"ifmmp\\", [\\"code\\", \\"hello\\"]) \\"hello\\" >>> decode_caesar_cipher(\\"xyz\\", [\\"code\\", \\"hello\\"]) \\"No match found\\" >>> decode_caesar_cipher(\\"dpefhello\\", [\\"code\\", \\"hello\\"]) \\"code\\" >>> decode_caesar_cipher(\\"buubdl\\", [\\"attack\\", \\"hello\\"]) \\"attack\\" >>> decode_caesar_cipher(\\"a\\", [\\"z\\"]) \\"z\\" def shift_right(message: str, shift_value: int) -> str: Shift the message to the right by the given shift value. pass for shift_value in range(1, 26): decoded_message = shift_right(encoded_message, shift_value) for word in possible_words: if word in decoded_message: return word return \\"No match found\\"","solution":"def decode_caesar_cipher(encoded_message, possible_words): def shift_right(message, shift_value): decoded_message = [] for char in message: decoded_char = chr(((ord(char) - ord('a') - shift_value) % 26) + ord('a')) decoded_message.append(decoded_char) return ''.join(decoded_message) for shift_value in range(1, 26): decoded_message = shift_right(encoded_message, shift_value) for word in possible_words: if word in decoded_message: return word return \\"No match found\\""},{"question":"def sort_stack(s): Sorts a stack in descending order. Parameters: s (list): The stack to be sorted. Returns: list: The sorted stack in descending order. Example: >>> sort_stack([3, 5, 1, 4, 2]) [5, 4, 3, 2, 1] >>> sort_stack([30, 20, 40]) [40, 30, 20]","solution":"def sort_stack(s): Sorts a stack in descending order. Parameters: s (list): The stack to be sorted. Returns: list: The sorted stack in descending order. # Initialize a temporary stack temporary_stack = [] while s: # Pop an element from the original stack current = s.pop() # While temporary stack is not empty and top of temporary stack is smaller than current while temporary_stack and temporary_stack[-1] < current: # Pop from temporary stack and push to the original stack s.append(temporary_stack.pop()) # Push the current element to the temporary stack temporary_stack.append(current) # Return the sorted stack, which will be in the temporary stack return temporary_stack"},{"question":"def can_reach_target(x, y, commands: str) -> str: Determines if the robot can reach the point (x, y) given a series of commands. >>> can_reach_target(2, 3, \\"UUURRR\\") 'YES' >>> can_reach_target(-1, 1, \\"UDLR\\") 'NO'","solution":"def can_reach_target(x, y, commands): Determines if the robot can reach the point (x, y) given a series of commands. # Initialize the current position current_x, current_y = 0, 0 # Dictionary to map commands to movements moves = {'U': (0, 1), 'D': (0, -1), 'L': (-1, 0), 'R': (1, 0)} # Execute each command for command in commands: move_x, move_y = moves[command] current_x += move_x current_y += move_y # Check if robot has reached the target if current_x == x and current_y == y: return \\"YES\\" # Check final position as well in case loop did not catch the correct moment if current_x == x and current_y == y: return \\"YES\\" return \\"NO\\""},{"question":"def max_sum_subgrid(grid): Returns the maximum sum of all elements of any sub-grid (contiguous rectangular section) of the given 2-D grid. >>> max_sum_subgrid([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 45 >>> max_sum_subgrid([[1, 2], [3, 4]]) 10 >>> max_sum_subgrid([[5]]) 5 >>> max_sum_subgrid([[1, 1], [1, 1000]]) 1003 >>> max_sum_subgrid([[1, 2, 1], [2, 2, 2], [1, 2, 1]]) 14","solution":"def max_sum_subgrid(grid): Returns the maximum sum of all elements of any sub-grid (contiguous rectangular section) of the given 2-D grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize an auxiliary matrix to store the sum of elements above and left including the current cell aux = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): aux[i][j] = grid[i - 1][j - 1] + aux[i - 1][j] + aux[i][j - 1] - aux[i - 1][j - 1] max_sum = float('-inf') # Iterate through all possible subgrids for i in range(1, m + 1): for j in range(1, n + 1): for p in range(i, m + 1): for q in range(j, n + 1): current_sum = (aux[p][q] - aux[i - 1][q] - aux[p][j - 1] + aux[i - 1][j - 1]) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def compute_total_enhancements(n, items): Computes the total enhancements in health, attack power, and defense based on collected items. Arguments: n -- an integer representing the number of items collected items -- a list of tuples, each containing a character ('H', 'A', 'D') and an integer value Returns: A tuple of three integers representing the total health, attack power, and defense increases Examples: >>> compute_total_enhancements(5, [('H', 20), ('A', 15), ('D', 10), ('H', 30), ('A', 25)]) (50, 40, 10) >>> compute_total_enhancements(3, [('H', 20), ('H', 30), ('H', 50)]) (100, 0, 0)","solution":"def compute_total_enhancements(n, items): Computes the total enhancements in health, attack power, and defense based on collected items. Arguments: n -- an integer representing the number of items collected items -- a list of tuples, each containing a character ('H', 'A', 'D') and an integer value Returns: A tuple of three integers representing the total health, attack power, and defense increases total_health = 0 total_attack = 0 total_defense = 0 for item in items: c, v = item if c == 'H': total_health += v elif c == 'A': total_attack += v elif c == 'D': total_defense += v return total_health, total_attack, total_defense # Example usage: # n = 5 # items = [('H', 20), ('A', 15), ('D', 10), ('H', 30), ('A', 25)] # print(compute_total_enhancements(n, items))"},{"question":"def gearbot_sequences(t: int, sequences: List[str]) -> List[str]: Determine if it is possible to rearrange the string into an alternating sequence using exactly two different types of gears. >>> gearbot_sequences(4, [\\"abba\\", \\"abcabc\\", \\"aaabbb\\", \\"abccba\\"]) [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] >>> gearbot_sequences(2, [\\"aaaa\\", \\"aabb\\"]) [\\"NO\\", \\"YES\\"]","solution":"def can_form_alternating_sequence(s): from collections import Counter counter = Counter(s) if len(counter) != 2: return \\"NO\\" a, b = counter.values() if abs(a - b) > 1: return \\"NO\\" return \\"YES\\" def gearbot_sequences(t, sequences): results = [] for s in sequences: results.append(can_form_alternating_sequence(s)) return results"},{"question":"def max_angular_difference(n, angles): Determine the largest difference between any two consecutive angular positions, considering the circular nature of the sequence. >>> max_angular_difference(5, [10, 20, 70, 150, 300]) 150 >>> max_angular_difference(4, [0, 90, 180, 270]) 90 >>> max_angular_difference(1, [0]) 0 >>> max_angular_difference(2, [0, 180]) 180 >>> max_angular_difference(3, [0, 10, 350]) 20 def process_angular_datasets(datasets): Process multiple datasets to determine the maximum angular difference for each dataset. >>> process_angular_datasets([(5, [10, 20, 70, 150, 300]), (4, [0, 90, 180, 270]), (0, [])]) [150, 90] >>> process_angular_datasets([(1, [0]), (2, [0, 360]), (0, [])]) [0, 0]","solution":"def max_angular_difference(n, angles): if n == 0: return 0 max_diff = 0 for i in range(n): diff = abs(angles[i] - angles[(i + 1) % n]) circular_diff = 360 - diff max_diff = max(max_diff, min(diff, circular_diff)) return max_diff def process_angular_datasets(datasets): result = [] for n, angles in datasets: if n == 0: break result.append(max_angular_difference(n, angles)) return result"},{"question":"def minimal_difference_partition(x, arr): Partition the array into x subarrays such that the difference between the highest and lowest number in the array is minimized, then sort each subarray individually and concatenate the results. >>> minimal_difference_partition(3, [1, 9, 8, 3, 5, 6, 7]) [1, 3, 5, 7, 6, 8, 9] >>> minimal_difference_partition(2, [4, 1, 3, 2, 7, 8]) [1, 3, 4, 2, 7, 8]","solution":"def minimal_difference_partition(x, arr): Partition the array into x subarrays such that the difference between the highest and lowest number in the array is minimized, then sort each subarray individually and concatenate the results. n = len(arr) arr_sorted = sorted(arr) # Divide the sorted array into x nearly equal parts subarrays = [] for i in range(x): subarrays.append(arr_sorted[i*n//x:(i+1)*n//x]) # Sort each subarray individually (they are already sorted as we sliced from a sorted array) # but to adhere strictly to the requirement for subarray in subarrays: subarray.sort() # Concatenate the sorted subarrays result = [] for subarray in subarrays: result.extend(subarray) return result"},{"question":"def hiking_trails(n: int, trails: List[Tuple[int, int]]) -> List[int]: John is planning a hiking trip across a new national park with numerous hiking trails. This function calculates the number of ways to establish trail networks after each new trail construction sequentially. :param n: int - the number of trail junctions :param trails: List[Tuple[int, int]] - list of trails described by pairs of junctions :return: List[int] - number of ways to configure a trail network after each new trail >>> hiking_trails(4, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)]) [0, 0, 0, 1, 2] >>> hiking_trails(5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (1, 3)]) [0, 0, 0, 0, 1, 2] >>> hiking_trails(4, [(1, 2), (2, 3), (3, 4), (4, 1), (2, 4)]) [0, 0, 0, 1, 2] >>> hiking_trails(6, [(1, 2), (1, 3), (2, 4), (3, 5), (5, 6), (4, 6), (4, 5)]) [0, 0, 0, 0, 0, 1, 2]","solution":"class DisjointSetUnion: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): xr = self.find(x) yr = self.find(y) if xr == yr: return False elif self.rank[xr] < self.rank[yr]: self.parent[xr] = yr elif self.rank[xr] > self.rank[yr]: self.parent[yr] = xr else: self.parent[yr] = xr self.rank[xr] += 1 return True def hiking_trails(n, trails): MOD = 1000000007 dsu = DisjointSetUnion(n) answer = [] # Number of ways to form circuits for each trail addition num_circuits = 0 for a, b in trails: a -= 1 b -= 1 if dsu.union(a, b): answer.append(num_circuits) else: # If a and b are already connected, then adding this edge will form a new circuit num_circuits += 1 answer.append(num_circuits % MOD) return answer"},{"question":"def min_path_sum(grid): Returns the minimum path sum from the top left to the bottom right corner of the grid. You can only move either down or right at any point in time. >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7 >>> min_path_sum([[1, 2], [1, 1]]) == 3 >>> min_path_sum([[1]]) == 1 >>> min_path_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 21 >>> min_path_sum([[5]]) == 5 def process_multiple_datasets(input_data): Processes multiple datasets and returns the minimum path sum for each dataset. >>> process_multiple_datasets(\\"3 3n1 3 1n1 5 1n4 2 1n2 2n1 2n1 1n0 0\\") == [7, 3] >>> process_multiple_datasets(\\"1 1n10n0 0\\") == [10] >>> process_multiple_datasets(\\"2 3n1 2 3n4 5 6n0 0\\") == [12] >>> process_multiple_datasets(\\"1 2n5 6n0 0\\") == [11]","solution":"def min_path_sum(grid): Returns the minimum path sum from the top left to the bottom right corner of the grid. You can only move either down or right at any point in time. if not grid: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1] def process_multiple_datasets(input_data): Processes multiple datasets and returns the minimum path sum for each dataset. results = [] datasets = input_data.strip().split('n') i = 0 while i < len(datasets): m, n = map(int, datasets[i].split()) if m == 0 and n == 0: break grid = [] for j in range(i + 1, i + 1 + m): grid.append(list(map(int, datasets[j].split()))) results.append(min_path_sum(grid)) i += m + 1 return results"},{"question":"def min_reversals_to_bidirectional(n: int, edges: List[List[int]]) -> int: Determine the minimum number of portals to reverse to make the graph bidirectional. Args: n (int): the number of villages. edges (List[List[int]]): the list of directed edges between villages. Returns: int: the minimum number of portals to reverse to ensure any village can be reached from any other village. >>> min_reversals_to_bidirectional(4, [[1, 2], [2, 3], [3, 4]]) == 1 >>> min_reversals_to_bidirectional(5, [[1, 2], [1, 3], [1, 4], [4, 5]]) == 1 >>> min_reversals_to_bidirectional(2, [[1, 2]]) == 1 >>> min_reversals_to_bidirectional(3, [[1, 2], [1, 3]]) == 1 >>> min_reversals_to_bidirectional(6, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]) == 1","solution":"def min_reversals_to_bidirectional(n, edges): from collections import defaultdict in_degree = [0] * (n + 1) out_degree = [0] * (n + 1) adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) out_degree[u] += 1 in_degree[v] += 1 return (sum(1 for i in range(1, n + 1) if in_degree[i] == 0))"},{"question":"def is_plan_possible(t: int, test_cases: List[int]) -> List[str]: Determine if it is possible for Alexa to plan her practice session for each test case with strictly more short sessions than long sessions. Args: t (int): The number of test cases. test_cases (List[int]): The total number of hours Alexa wants to practice for each test case. Returns: List[str]: List of \\"POSSIBLE\\" or \\"IMPOSSIBLE\\" for each test case. >>> is_plan_possible(5, [2, 3, 4, 5, 6]) [\\"IMPOSSIBLE\\", \\"POSSIBLE\\", \\"IMPOSSIBLE\\", \\"POSSIBLE\\", \\"POSSIBLE\\"] >>> is_plan_possible(3, [1, 2, 4]) [\\"IMPOSSIBLE\\", \\"IMPOSSIBLE\\", \\"IMPOSSIBLE\\"] >>> is_plan_possible(2, [999, 1000]) [\\"POSSIBLE\\", \\"POSSIBLE\\"] >>> is_plan_possible(5, [7, 8, 9, 10, 3]) [\\"POSSIBLE\\", \\"POSSIBLE\\", \\"POSSIBLE\\", \\"POSSIBLE\\", \\"POSSIBLE\\"]","solution":"def is_plan_possible(t, test_cases): results = [] for N in test_cases: if N == 1 or N == 2 or N == 4: results.append(\\"IMPOSSIBLE\\") else: results.append(\\"POSSIBLE\\") return results"},{"question":"def minDoses(hurdles: List[int], k: int) -> int: Determines the minimum number of doses required for the racer to clear all hurdles. Parameters: hurdles (list of int): List of integers representing the height of the hurdles. k (int): The maximum jump height of the racer. Returns: int: Minimum number of doses required. >>> minDoses([1, 6, 3, 5, 2], 4) 2 >>> minDoses([2, 5, 4, 5, 2], 7) 0","solution":"def minDoses(hurdles, k): Determines the minimum number of doses required for the racer to clear all hurdles. Parameters: hurdles (list of int): List of integers representing the height of the hurdles. k (int): The maximum jump height of the racer. Returns: int: Minimum number of doses required. max_hurdle = max(hurdles) if k >= max_hurdle: return 0 else: return max_hurdle - k"},{"question":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Parameters: arr1 (list): First sorted array. arr2 (list): Second sorted array. Returns: list: Merged sorted array. Examples: >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 2, 3], [4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([], [1, 3, 5]) [1, 3, 5] >>> merge_sorted_arrays([1, 3, 5], []) [1, 3, 5] >>> merge_sorted_arrays([1, 1, 1], [1, 1, 1]) [1, 1, 1, 1, 1, 1] >>> merge_sorted_arrays([1, 2], [1, 2, 3, 4]) [1, 1, 2, 2, 3, 4] >>> merge_sorted_arrays([-3, -1, 0], [-2, 2, 3]) [-3, -2, -1, 0, 2, 3] >>> merge_sorted_arrays([], []) []","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Parameters: arr1 (list): First sorted array. arr2 (list): Second sorted array. Returns: list: Merged sorted array. m, n = len(arr1), len(arr2) merged_array = [] i, j = 0, 0 while i < m and j < n: if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < m: merged_array.append(arr1[i]) i += 1 while j < n: merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"import math from typing import List, Tuple def calculate_distances(stops: List[Tuple[int, int]]) -> List[float]: Calculates the distances between consecutive stops and the total distance. Parameters: stops (List[Tuple[int, int]]): List of coordinate tuples (x, y) for each stop. Returns: List[float]: List of distances between consecutive stops, followed by the total distance. pass def road_trip_log(N: int, coordinates: List[str]) -> List[float]: Parse input coordinates and calculate distances using calculate_distances function. Parameters: N (int): Number of stops. coordinates (List[str]): List of strings representing coordinates of each stop. Returns: List[float]: List of distances between consecutive stops, followed by the total distance. pass # Example usage: if __name__ == \\"__main__\\": coordinates = [\\"0 0\\", \\"3 4\\", \\"6 0\\"] print(road_trip_log(3, coordinates)) # Output: [5.00, 5.00, 10.00]","solution":"import math def calculate_distances(stops): Calculates the distances between consecutive stops and the total distance. Parameters: stops (list of tuples): List of coordinate tuples (x, y) for each stop. Returns: list of floats: List of distances between consecutive stops, followed by the total distance. distances = [] total_distance = 0.0 for i in range(1, len(stops)): x1, y1 = stops[i - 1] x2, y2 = stops[i] distance = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) distances.append(round(distance, 2)) total_distance += distance distances.append(round(total_distance, 2)) return distances # Function to parse input and return distances for convenience during unit testing def road_trip_log(N, coordinates): stops = [tuple(map(int, coord.split())) for coord in coordinates] return calculate_distances(stops)"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring with at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5 >>> length_of_longest_substring_two_distinct(\\"abcabc\\") 2 def solve(t: int, test_cases: List[str]) -> List[int]: Solves multiple test cases for the length_of_longest_substring_two_distinct function. >>> solve(3, [\\"eceba\\", \\"ccaabbb\\", \\"abcabc\\"]) [3, 5, 2] >>> solve(2, [\\"a\\", \\"aa\\"]) [1, 2]","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring with at most two distinct characters. # Dictionary to store the most recent index of each character char_index = {} max_len = 0 left = 0 for right in range(len(s)): char_index[s[right]] = right if len(char_index) > 2: # Get the leftmost character's index leftmost = min(char_index.values()) del char_index[s[leftmost]] left = leftmost + 1 max_len = max(max_len, right - left + 1) return max_len def solve(t, test_cases): results = [] for s in test_cases: results.append(length_of_longest_substring_two_distinct(s)) return results"},{"question":"from typing import List def min_steps_to_reach_target(n: int, m: int, grid: List[List[str]], sx: int, sy: int, tx: int, ty: int) -> int: Determine the shortest number of steps required to reach the target point or identify if it is impossible to do so. >>> min_steps_to_reach_target(5, 5, [['.', '.', '.', '#', '.'], ['#', '#', '.', '#', '.'], ['.', '.', '.', '.', '.'], ['#', '.', '#', '#', '.'], ['.', '.', '.', '.', '.']], 1, 1, 5, 5) 8 >>> min_steps_to_reach_target(5, 5, [['.', '.', '.', '#', '.'], ['#', '#', '.', '#', '.'], ['.', '#', '#', '#', '.'], ['#', '.', '#', '#', '.'], ['.', '.', '.', '.', '.']], 1, 1, 5, 5) -1","solution":"from collections import deque def min_steps_to_reach_target(n, m, grid, sx, sy, tx, ty): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(sx - 1, sy - 1, 0)]) visited = [[False] * m for _ in range(n)] visited[sx - 1][sy - 1] = True while queue: x, y, steps = queue.popleft() if (x, y) == (tx - 1, ty - 1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, steps + 1)) return -1"},{"question":"def decimal_to_binary(dec_str): Converts a decimal number string to its binary representation. Parameters: - dec_str (str): A string representing the decimal number. Returns: - str: The binary representation prefixed with '0b'. Examples: >>> decimal_to_binary(\\"10\\") == \\"0b1010\\" >>> decimal_to_binary(\\"255\\") == \\"0b11111111\\" >>> decimal_to_binary(\\"0\\") == \\"0b0\\" >>> decimal_to_binary(\\"1\\") == \\"0b1\\"","solution":"def decimal_to_binary(dec_str): Converts a decimal number string to its binary representation. Parameters: - dec_str (str): A string representing the decimal number. Returns: - str: The binary representation prefixed with '0b'. if dec_str == \\"0\\": return \\"0b0\\" decimal_number = int(dec_str) binary_rep = '' while decimal_number > 0: binary_rep = str(decimal_number % 2) + binary_rep decimal_number = decimal_number // 2 return \\"0b\\" + binary_rep"},{"question":"def find_smallest_missing_positive_integer(array): Finds the smallest positive integer that is missing from the array. >>> find_smallest_missing_positive_integer([1, 3, 6, 4, 1, 2]) 5 >>> find_smallest_missing_positive_integer([1, 2, 3]) 4 >>> find_smallest_missing_positive_integer([-1, -3, 4, 2]) 1 >>> find_smallest_missing_positive_integer([-1, -2, -3]) 1 >>> find_smallest_missing_positive_integer([]) 1 >>> find_smallest_missing_positive_integer(list(range(1, 100001))) 100001 >>> find_smallest_missing_positive_integer([5]) 1 >>> find_smallest_missing_positive_integer([-5]) 1 >>> find_smallest_missing_positive_integer([3, 4, -1, 1]) 2","solution":"def find_smallest_missing_positive_integer(array): Finds the smallest positive integer that is missing from the array. array = list(filter(lambda x: x > 0, array)) if not array: return 1 array = set(array) smallest_missing = 1 while smallest_missing in array: smallest_missing += 1 return smallest_missing"},{"question":"def track_inventory(n: int, q: int, initial_stock: List[int], updates: List[Tuple[int, int, int]]) -> List[int]: Alice owns a bakery and she wants to track the changes in her inventory. She stocks different types of pastries and wants to know the quantity of each type over time. You are given an array representing the initial stock of \`n\` types of pastries, and a series of \`q\` updates to this stock. Each update is one of two types: 1. Add a quantity \`x\` to the \`i\`-th type of pastry. 2. Set the quantity of the \`i\`-th type of pastry to \`x\`. After performing each update, you need to calculate the total number of pastries in stock. >>> track_inventory(4, 4, [10, 20, 30, 40], [(1, 2, 10), (2, 3, 5), (1, 4, 20), (2, 1, 15)]) [110, 85, 105, 110] >>> track_inventory(3, 3, [1, 2, 3], [(1, 1, 1), (2, 2, 0), (1, 3, 5)]) [7, 5, 10] >>> track_inventory(2, 2, [100, 200], [(2, 1, 50), (1, 2, 50)]) [250, 300] >>> track_inventory(1, 1, [10], [(2, 1, 5)]) [5] >>> track_inventory(3, 3, [0, 0, 0], [(1, 1, 5), (1, 2, 10), (1, 3, 15)]) [5, 15, 30]","solution":"def track_inventory(n, q, initial_stock, updates): total_stock = sum(initial_stock) results = [] for update in updates: t, i, x = update idx = i - 1 if t == 1: total_stock += x initial_stock[idx] += x elif t == 2: total_stock -= initial_stock[idx] initial_stock[idx] = x total_stock += x results.append(total_stock) return results"},{"question":"def can_form_triangle(a: int, b: int, c: int) -> str: Determines if the given sides can form a triangle. A triangle is valid if the sum of any two sides is greater than the third side. Parameters: a (int): the length of the first side b (int): the length of the second side c (int): the length of the third side Returns: str: \\"Yes\\" if the sides can form a triangle, otherwise \\"No\\" >>> can_form_triangle(3, 4, 5) \\"Yes\\" >>> can_form_triangle(1, 1, 2) \\"No\\" >>> can_form_triangle(6, 8, 10) \\"Yes\\"","solution":"def can_form_triangle(a, b, c): Determines if the given sides can form a triangle. A triangle is valid if the sum of any two sides is greater than the third side. Parameters: a (int): the length of the first side b (int): the length of the second side c (int): the length of the third side Returns: str: \\"Yes\\" if the sides can form a triangle, otherwise \\"No\\" if a + b > c and b + c > a and c + a > b: return \\"Yes\\" else: return \\"No\\" # Example usage: # print(can_form_triangle(3, 4, 5)) # Output should be \\"Yes\\" # print(can_form_triangle(1, 1, 2)) # Output should be \\"No\\""},{"question":"def find_median(s: str) -> float: Returns the median of a space-separated string of integers. >>> find_median(\\"3 1 2 5 4\\") 3.0 >>> find_median(\\"10 20 30 40\\") 25.0 >>> find_median(\\"5\\") 5.0 >>> find_median(\\"-3 -5 -1 -4 -2\\") -3.0 >>> find_median(\\"-3 -1 -2 -4\\") -2.5 >>> find_median(\\"1 -2 3 -4 5\\") 1.0 >>> find_median(\\"10 20 -30 -40 50\\") 10.0","solution":"def find_median(s): Returns the median of a space-separated string of integers. numbers = list(map(int, s.split())) numbers.sort() n = len(numbers) mid = n // 2 if n % 2 == 0: median = (numbers[mid - 1] + numbers[mid]) / 2 else: median = numbers[mid] return round(median, 1)"},{"question":"def mark_integer_in_list(n, initial_list, x, m): Inserts the integer x at index m in the initial_list. Parameters: n (int): The number of integers in the initial list. initial_list (list): The list of integers. x (int): The specific integer to be marked. m (int): The designated index. Returns: list: The adjusted list of integers after marking the specific integer at the designated index. >>> mark_integer_in_list(5, [1, 2, 3, 4, 5], 100, 2) [1, 2, 100, 3, 4, 5] >>> mark_integer_in_list(3, [7, 8, 9], 50, 5) [7, 8, 9, 50] >>> mark_integer_in_list(4, [1, 3, 5, 7], 2, 0) [2, 1, 3, 5, 7]","solution":"def mark_integer_in_list(n, initial_list, x, m): Inserts the integer x at index m in the initial_list. Parameters: n (int): The number of integers in the initial list. initial_list (list): The list of integers. x (int): The specific integer to be marked. m (int): The designated index. Returns: list: The adjusted list of integers after marking the specific integer at the designated index. if m <= n: return initial_list[:m] + [x] + initial_list[m:] else: return initial_list + [x]"},{"question":"def get_employee_with_highest_hours(n, employees_data): Given the number of employees and their work hours data for a week, return the ID of the employee with the highest total working hours. >>> get_employee_with_highest_hours(3, [\\"A123 8 8 8 8 8 0 0\\", \\"B456 9 9 9 9 0 0 0\\", \\"C789 7 7 7 7 7 7 7\\"]) \\"C789\\" >>> get_employee_with_highest_hours(2, [\\"Alpha 8 8 8 8 8 0 0\\", \\"Beta 8 8 8 8 8 0 0\\"]) \\"Alpha\\"","solution":"def get_employee_with_highest_hours(n, employees_data): max_hours = 0 employee_id = \\"\\" for data in employees_data: parts = data.split() emp_id = parts[0] hours = list(map(int, parts[1:])) total_hours = sum(hours) if total_hours > max_hours: max_hours = total_hours employee_id = emp_id elif total_hours == max_hours and employee_id == \\"\\": employee_id = emp_id return employee_id"},{"question":"from collections import defaultdict, deque from typing import List, Union, Tuple def find_quest_order(n: int, prerequisites: List[Tuple[str, str]]) -> Union[List[str], str]: Determine the order in which quests can be completed given the prerequisites. >>> find_quest_order(4, [(\\"clean_house\\", \\"cook_meal\\"), (\\"buy_groceries\\", \\"cook_meal\\"), (\\"buy_groceries\\", \\"clean_house\\"), (\\"cook_meal\\", \\"play_game\\")]) ['buy_groceries', 'clean_house', 'cook_meal', 'play_game'] >>> find_quest_order(3, [(\\"quest3\\", \\"quest1\\"), (\\"quest1\\", \\"quest2\\"), (\\"quest2\\", \\"quest3\\")]) 'impossible' # Your code here # Unit tests def test_possible_order(): n = 4 prerequisites = [ (\\"clean_house\\", \\"cook_meal\\"), (\\"buy_groceries\\", \\"cook_meal\\"), (\\"buy_groceries\\", \\"clean_house\\"), (\\"cook_meal\\", \\"play_game\\") ] result = find_quest_order(n, prerequisites) expected = [\\"buy_groceries\\", \\"clean_house\\", \\"cook_meal\\", \\"play_game\\"] assert result == expected or result == expected[::-1] def test_impossible_order(): n = 3 prerequisites = [ (\\"quest3\\", \\"quest1\\"), (\\"quest1\\", \\"quest2\\"), (\\"quest2\\", \\"quest3\\") ] result = find_quest_order(n, prerequisites) assert result == \\"impossible\\" def test_multiple_possible_orders(): n = 2 prerequisites = [ (\\"quest1\\", \\"quest2\\"), (\\"quest3\\", \\"quest4\\") ] result = find_quest_order(n, prerequisites) assert sorted(result) == sorted([\\"quest1\\", \\"quest2\\", \\"quest3\\", \\"quest4\\"]) def test_single_quest(): n = 1 prerequisites = [ (\\"quest1\\", \\"quest2\\") ] result = find_quest_order(n, prerequisites) assert result == [\\"quest1\\", \\"quest2\\"] def test_no_prerequisite(): n = 0 prerequisites = [] result = find_quest_order(n, prerequisites) assert result == [] def test_disconnected_graph(): n = 3 prerequisites = [ (\\"quest1\\", \\"quest2\\"), (\\"quest3\\", \\"quest4\\") ] result = find_quest_order(n, prerequisites) assert sorted(result) == sorted([\\"quest1\\", \\"quest2\\", \\"quest3\\", \\"quest4\\"])","solution":"from collections import defaultdict, deque def find_quest_order(n, prerequisites): # Dictionary to store the prerequisites prereq_map = defaultdict(list) # Dictionary to maintain the in-degree of nodes in_degree = defaultdict(int) all_quests = set() for x, y in prerequisites: prereq_map[x].append(y) in_degree[y] += 1 all_quests.add(x) all_quests.add(y) # Initialize the queue with the quests that have an in-degree of 0 (no prerequisites) queue = deque([quest for quest in all_quests if in_degree[quest] == 0]) order = [] # Process the queue while queue: current = queue.popleft() order.append(current) # For each quest that current is a prerequisite for for neighbour in prereq_map[current]: in_degree[neighbour] -= 1 if in_degree[neighbour] == 0: queue.append(neighbour) # If all quests are processed, return the order if len(order) == len(all_quests): return order else: return \\"impossible\\" # Sample usage def solve(): n = int(input().strip()) prerequisites = [input().strip().split() for _ in range(n)] result = find_quest_order(n, prerequisites) if result == \\"impossible\\": print(result) else: for quest in result: print(quest)"},{"question":"def is_symmetric(s: str) -> str: Determines if a string is symmetric after removing non-alphabet characters and ignoring case. >>> is_symmetric(\\"A man, a plan, a canal, Panama!\\") == \\"Symmetric\\" True >>> is_symmetric(\\"Hello, World!\\") == \\"Not Symmetric\\" True pass def process_input(input_lines: List[str]) -> List[str]: Processes multiple lines of input to determine symmetric strings. Ends processing when a line containing only a single asterisk (*) is encountered. >>> process_input([ \\"A man, a plan, a canal, Panama!\\", \\"Was it a car or a cat I saw?\\", \\"No 'x' in Nixon\\", \\"*\\" ]) [\\"Symmetric\\", \\"Symmetric\\", \\"Symmetric\\"] >>> process_input([ \\"Hello, World!\\", \\"This is not a symmetric string.\\", \\"*\\" ]) [\\"Not Symmetric\\", \\"Not Symmetric\\"] pass","solution":"def is_symmetric(s): Determines if a string is symmetric after removing non-alphabet characters and ignoring case. # Filter out non-alphabet characters and convert to lowercase cleaned = ''.join(filter(str.isalpha, s)).lower() # Check if the cleaned string is equal to its reverse return \\"Symmetric\\" if cleaned == cleaned[::-1] else \\"Not Symmetric\\" def process_input(input_lines): Processes multiple lines of input to determine symmetric strings. Ends processing when a line containing only a single asterisk (*) is encountered. results = [] for line in input_lines: if line.strip() == '*': break results.append(is_symmetric(line)) return results"},{"question":"import re from typing import Union def validate_employee_id(empID: str) -> Union[str, None]: Validates the given Employee ID based on the specified format and extracts the department code. Returns the department code if the format is correct, or \\"Invalid ID\\" if the format is incorrect. >>> validate_employee_id(\\"ABC-12-3456\\") \\"12\\" >>> validate_employee_id(\\"DEF-07-0123\\") \\"07\\" >>> validate_employee_id(\\"abc-34-5678\\") \\"Invalid ID\\" >>> validate_employee_id(\\"XYZ-56-789\\") \\"Invalid ID\\" >>> validate_employee_id(\\"AB-12-3456\\") \\"Invalid ID\\" >>> validate_employee_id(\\"ABCDE-12-3456\\") \\"Invalid ID\\" >>> validate_employee_id(\\"AB1-12-3456\\") \\"Invalid ID\\" >>> validate_employee_id(\\"ABC-123-4567\\") \\"Invalid ID\\" >>> validate_employee_id(\\"ABC-12-12345\\") \\"Invalid ID\\" >>> validate_employee_id(\\"ABC12-3456\\") \\"Invalid ID\\" >>> validate_employee_id(\\"\\") \\"Invalid ID\\" >>> validate_employee_id(\\"123-45-6789\\") \\"Invalid ID\\"","solution":"import re def validate_employee_id(empID): Validates the given Employee ID based on the specified format and extracts the department code. Returns the department code if the format is correct, or \\"Invalid ID\\" if the format is incorrect. # Regular expression pattern for the Employee ID pattern = r'^[A-Z]{3}-(d{2})-d{4}' match = re.match(pattern, empID) if match: # Return the department code from the matched pattern group return match.group(1) else: return \\"Invalid ID\\""},{"question":"def is_strong_password(n: int, password: str) -> str: Determines if the given password is strong based on specified criteria. >>> is_strong_password(7, 'A1b#def') 'YES' >>> is_strong_password(7, 'A1bdefgH') 'NO' >>> is_strong_password(7, 'a1bdefg!H') 'YES' >>> is_strong_password(7, 'A1b') 'NO' >>> is_strong_password(7, 'abcdefg1!') 'NO' >>> is_strong_password(7, 'ABCDEFG1!') 'NO' >>> is_strong_password(7, 'Abcdefg!!') 'NO' >>> is_strong_password(7, 'Abcdefg1') 'NO' pass def check_passwords(q: int, passwords: List[str]) -> List[str]: Checks multiple passwords and returns whether each one meets the strength requirements. >>> check_passwords(3, ['A1b#def', 'A1bdefgH', 'a1bdefg!H']) ['YES', 'NO', 'YES'] >>> check_passwords(2, ['A1bdefg@', 'a1B!']) ['YES', 'NO'] >>> check_passwords(1, ['1234abcd!A']) ['YES'] pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def is_strong_password(n, password): Determines if the given password is strong based on specified criteria. Parameters: n (int): The minimum length required for the password. password (str): The password string to be evaluated. Returns: str: 'YES' if the password is strong, otherwise 'NO'. if len(password) < n: return \\"NO\\" has_upper = any(ch.isupper() for ch in password) has_lower = any(ch.islower() for ch in password) has_digit = any(ch.isdigit() for ch in password) has_special = any(ch in {'!', '@', '#', '', '%', '^', '&', '*'} for ch in password) if has_upper and has_lower and has_digit and has_special: return \\"YES\\" else: return \\"NO\\" def check_passwords(q, passwords): results = [] for pwd in passwords: results.append(is_strong_password(7, pwd)) return results"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates an arithmetic expression with + and - operators ignoring the conventional precedence rules and processes the expression from left to right. :param expression: A string representing the arithmetic expression :return: The result of the expression evaluated from left to right. >>> evaluate_expression(\\"3 + 5 - 2\\") 6 >>> evaluate_expression(\\"10 - 4 + 7\\") 13 >>> evaluate_expression(\\"1 + 2 + 3 + 4\\") 10 >>> evaluate_expression(\\"10 - 1 - 2 - 3\\") 4 >>> evaluate_expression(\\"20 + 5 - 3 + 7 - 2\\") 27 pass def evaluate_expressions(input_data: List[str]) -> List[int]: Evaluates multiple expressions provided as input. The first value in input_data is the number of test cases, followed by each arithmetic expression for the test cases. :param input_data: A list of strings where the first element is the number of test cases (T), and the remaining elements are the arithmetic expressions. :return: A list of integers representing the results of each evaluated expression. >>> evaluate_expressions([\\"2\\", \\"3 + 5 - 2\\", \\"10 - 4 + 7\\"]) [6, 13] >>> evaluate_expressions([\\"1\\", \\"8 + 2 - 5 + 4\\"]) [9] pass","solution":"def evaluate_expression(expression): Evaluates an arithmetic expression with + and - operators ignoring the conventional precedence rules and processes the expression from left to right. tokens = expression.split() result = int(tokens[0]) i = 1 while i < len(tokens): operator = tokens[i] next_number = int(tokens[i + 1]) if operator == '+': result += next_number elif operator == '-': result -= next_number i += 2 return result def evaluate_expressions(input_data): Evaluates multiple expressions provided as input. The first value in input_data is the number of test cases, followed by each arithmetic expression for the test cases. T = int(input_data[0]) results = [] for i in range(1, T + 1): expression = input_data[i] results.append(evaluate_expression(expression)) return results"},{"question":"def max_staircase_height(B: int) -> int: Returns the maximum height of the staircase that can be built with B blocks. >>> max_staircase_height(1) == 1 >>> max_staircase_height(2) == 1 >>> max_staircase_height(3) == 2 >>> max_staircase_height(6) == 3 >>> max_staircase_height(10) == 4 >>> max_staircase_height(15) == 5 >>> max_staircase_height(21) == 6 >>> max_staircase_height(5) == 2 >>> max_staircase_height(8) == 3 >>> max_staircase_height(20) == 5","solution":"def max_staircase_height(B): Returns the maximum height of the staircase that can be built with B blocks. height = 0 total_blocks = 0 while total_blocks <= B: height += 1 total_blocks += height return height - 1"},{"question":"def findMaxLength(nums: List[int]) -> int: Returns the maximum length of a contiguous subarray with an equal number of 1s and -1s. >>> findMaxLength([1, -1, 1, 1, -1, -1, 1, -1]) 8 >>> findMaxLength([1, 1, -1, -1, 1]) 4","solution":"def findMaxLength(nums): Returns the maximum length of a contiguous subarray with an equal number of 1s and -1s. max_length = 0 count = 0 count_index_map = {0: -1} for i, num in enumerate(nums): if num == 1: count += 1 else: count -= 1 if count in count_index_map: max_length = max(max_length, i - count_index_map[count]) else: count_index_map[count] = i return max_length"},{"question":"def min_operations_to_zero_matrix(t: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[int]: Return the minimum number of operations needed to transform the matrix to all zeros for each test case. >>> min_operations_to_zero_matrix(1, [(2, [[3, 2], [1, 4]])]) == [4] >>> min_operations_to_zero_matrix(2, [ (2, [[3, 2], [1, 4]]), (3, [[2, 1, 3], [3, 2, 1], [1, 3, 2]]) ]) == [4, 3] >>> min_operations_to_zero_matrix(3, [ (2, [[10, 20], [0, 5]]), (3, [[3, 3, 3], [3, 3, 3], [3, 3, 3]]), (4, [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) ]) == [20, 3, 1] >>> min_operations_to_zero_matrix(1, [(2, [[5, 5], [5, 5]])]) == [5] >>> min_operations_to_zero_matrix(1, [(1, [[0]])]) == [0] >>> min_operations_to_zero_matrix(1, [(1, [[7]])]) == [7]","solution":"def min_operations_to_zero_matrix(t, test_cases): results = [] for case_idx in range(t): n = test_cases[case_idx][0] matrix = test_cases[case_idx][1] # The number of operations required is the maximum element in the matrix max_element = 0 for row in matrix: max_element = max(max_element, max(row)) results.append(max_element) return results"},{"question":"def two_sum(nums, target): Returns the indices of the two numbers such that they add up to the target. >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([1, 2, 3, 4, 5], 6) (1, 3) >>> two_sum([-1, -2, -3, -4, -5], -8) (2, 4) >>> two_sum([3, 3, 4, 5], 6) (0, 1) >>> two_sum([i for i in range(1, 10001)], 19999) (9998, 9999) >>> two_sum([1, -3, 4, 7], 4) (1, 3)","solution":"def two_sum(nums, target): Returns the indices of the two numbers such that they add up to the target. # Dictionary to store the number and its index num_to_index = {} for index, num in enumerate(nums): # Calculate the complement of the current number complement = target - num # If complement exists in our dictionary, return the indices if complement in num_to_index: return num_to_index[complement], index # Otherwise, add the number to the dictionary with its index num_to_index[num] = index"},{"question":"def is_possible(n: int, m: int, C: int, s: int, t: int, edges: List[Tuple[int, int, int]]) -> None: Determine if it's possible to set the communication costs (previously zero due to disturbance) to positive integers such that the total communication cost for sending a message from node \`s\` to node \`t\` does not exceed \`C\`. Arguments: n -- the number of vertices in the network m -- the number of edges in the network C -- the maximum allowable communication cost s -- the starting node t -- the ending node edges -- the edges of the network, where each edge is a tuple (u, v, c) with u and v are the endpoints of the edge and c is the communication cost Returns: None: The function should print \\"POSSIBLE\\" if the adaptation is feasible along with the new communication costs, or \\"IMPOSSIBLE\\" otherwise. >>> is_possible(4, 4, 10, 0, 3, [(0, 1, 5), (1, 2, 0), (2, 3, 2), (0, 3, 0)]) POSSIBLE 0 1 5 1 2 3 2 3 2 0 3 4 >>> is_possible(3, 2, 5, 0, 2, [(0, 1, 2), (1, 2, 0)]) POSSIBLE 0 1 2 1 2 3 >>> is_possible(3, 2, 2, 0, 2, [(0, 1, 2), (1, 2, 0)]) IMPOSSIBLE","solution":"import heapq import sys def is_possible(n, m, C, s, t, edges): def dijkstra(n, adj, start_node): distances = [sys.maxsize] * n distances[start_node] = 0 priority_queue = [(0, start_node)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in adj[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances adj = [[] for _ in range(n)] zero_edges = [] for u, v, c in edges: if c == 0: zero_edges.append((u, v)) else: adj[u].append((v, c)) adj[v].append((u, c)) initial_distances = dijkstra(n, adj, s) if initial_distances[t] <= C: print(\\"POSSIBLE\\") for u, v, c in edges: if c == 0: print(u, v, C) else: for u, v in zero_edges: adj[u].append((v, 1)) adj[v].append((u, 1)) new_distances = dijkstra(n, adj, s) if new_distances[t] <= C: print(\\"POSSIBLE\\") for u, v, c in edges: if c == 0: estimated_cost = C - initial_distances[t] + 1 print(u, v, estimated_cost) else: print(\\"IMPOSSIBLE\\") # Example usage n, m, C, s, t = 3, 2, 5, 0, 2 edges = [ (0, 1, 2), (1, 2, 0), ] is_possible(n, m, C, s, t, edges)"},{"question":"def min_operations_to_synchronize(n: int, lights: str) -> int: Determine the minimum number of operations required to make all the traffic lights either 'G' or 'R' by flipping contiguous segments of lights. Parameters: n (int): Number of traffic lights lights (str): A string of length n representing the states of the traffic lights Returns: int: Minimum number of operations Examples: >>> min_operations_to_synchronize(5, \\"GRGRG\\") 2 >>> min_operations_to_synchronize(3, \\"GGG\\") 0 >>> min_operations_to_synchronize(6, \\"RGRGRG\\") 3 >>> min_operations_to_synchronize(1, \\"G\\") 0 >>> min_operations_to_synchronize(7, \\"GRRGGGR\\") 2 >>> min_operations_to_synchronize(8, \\"GGGGGGGR\\") 1 >>> min_operations_to_synchronize(10, \\"RRRRRRRRRR\\") 0","solution":"def min_operations_to_synchronize(n, lights): This function returns the minimum number of operations required to make all the traffic lights either 'G' or 'R' by flipping contiguous segments of lights. Parameters: n (int): Number of traffic lights lights (str): A string of length n representing the states of the traffic lights Returns: int: Minimum number of operations # Counting groups of 'G's and 'R's g_count = 0 r_count = 0 # Initialize previous character to None prev_char = None for char in lights: if char != prev_char: if char == 'G': g_count += 1 else: r_count += 1 prev_char = char # The result is the minimum of the counts of 'G' groups and 'R' groups return min(g_count, r_count)"},{"question":"def get_word_score(word): Return the score of the word based on its length. Score is calculated as the square of the word's length. pass def can_form_word(word, chars): Check if 'word' can be formed from the characters in 'chars'. pass def max_score(words, available_chars): Given a list of words and a string of available characters, return the maximum score that can be achieved by forming valid words from the available characters. pass def process_input(input_data): Read the input data and process each test case. Return the maximum score for each test case. pass import pytest def test_get_word_score(): assert get_word_score(\\"a\\") == 1 assert get_word_score(\\"apple\\") == 25 assert get_word_score(\\"banana\\") == 36 def test_can_form_word(): assert not can_form_word(\\"apple\\", \\"appl\\") assert can_form_word(\\"apple\\", \\"aaplepnbaanr\\") assert can_form_word(\\"ice\\", \\"ciniece\\") assert can_form_word(\\"banana\\", \\"aaplepnbaanr\\") def test_max_score(): assert max_score([\\"apple\\", \\"banana\\", \\"pear\\"], \\"aaplepnbaanr\\") == 36 assert max_score([\\"ice\\", \\"nice\\"], \\"ciniece\\") == 16 assert max_score([\\"ice\\", \\"nice\\"], \\"icecinenie\\") == 16 def test_process_input(): input_data = [ \\"3\\", \\"apple\\", \\"banana\\", \\"pear\\", \\"aaplepnbaanr\\", \\"2\\", \\"ice\\", \\"nice\\", \\"ciniece\\", \\"0\\" ] expected_output = [36, 16] assert process_input(input_data) == expected_output input_data = [ \\"2\\", \\"cat\\", \\"dog\\", \\"catdog\\", \\"0\\" ] expected_output = [9] assert process_input(input_data) == expected_output if __name__ == \\"__main__\\": pytest.main()","solution":"def get_word_score(word): Return the score of the word based on its length. Score is calculated as the square of the word's length. return len(word) ** 2 def can_form_word(word, chars): Check if 'word' can be formed from the characters in 'chars'. from collections import Counter word_count = Counter(word) chars_count = Counter(chars) for letter, count in word_count.items(): if chars_count[letter] < count: return False return True def max_score(words, available_chars): Given a list of words and a string of available characters, return the maximum score that can be achieved by forming valid words from the available characters. max_possible_score = 0 for word in words: if can_form_word(word, available_chars): max_possible_score = max(max_possible_score, get_word_score(word)) return max_possible_score def process_input(input_data): Read the input data and process each test case. Return the maximum score for each test case. i = 0 n = int(input_data[i]) results = [] while n != 0: i += 1 words = [] for _ in range(n): words.append(input_data[i]) i += 1 available_chars = input_data[i] results.append(max_score(words, available_chars)) i += 1 n = int(input_data[i]) if i < len(input_data) else 0 return results"},{"question":"def execute_commands(n: int, commands: List[str]) -> List[int]: Execute a series of commands on an array and produce the output for retrieval commands. >>> execute_commands(6, [\\"add 5\\", \\"add 10\\", \\"get 1\\", \\"remove\\", \\"get 0\\", \\"get 0\\"]) [10, 5, 5] >>> execute_commands(3, [\\"add 1\\", \\"add 2\\", \\"get 1\\"]) [2] >>> execute_commands(5, [\\"add 1\\", \\"add 2\\", \\"remove\\", \\"add 3\\", \\"get 1\\"]) [3] >>> execute_commands(7, [\\"add 10\\", \\"add 20\\", \\"add 30\\", \\"get 0\\", \\"get 1\\", \\"get 2\\", \\"remove\\"]) [10, 20, 30] >>> execute_commands(4, [\\"add 7\\", \\"add 8\\", \\"add 9\\", \\"get 2\\"]) [9]","solution":"def execute_commands(n, commands): array = [] results = [] for command in commands: if command.startswith(\\"add\\"): _, value = command.split() array.append(int(value)) elif command == \\"remove\\": if array: array.pop() elif command.startswith(\\"get\\"): _, index = command.split() results.append(array[int(index)]) return results"},{"question":"def int_to_roman(num: int) -> str: Converts an integer to a Roman numeral. >>> int_to_roman(3) 'III' >>> int_to_roman(58) 'LVIII' >>> int_to_roman(1994) 'MCMXCIV' def convert_decimals_to_roman(test_cases: List[int]) -> List[str]: Given a list of integers, converts each integer to its Roman numeral representation. >>> convert_decimals_to_roman([3, 58]) ['III', 'LVIII'] >>> convert_decimals_to_roman([1994, 400, 2022]) ['MCMXCIV', 'CD', 'MMXXII']","solution":"def int_to_roman(num): Converts an integer to a Roman numeral. value = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] symbol = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman = '' for i in range(len(value)): while num >= value[i]: num -= value[i] roman += symbol[i] return roman def convert_decimals_to_roman(test_cases): Given a list of integers, converts each integer to its Roman numeral representation. results = [] for num in test_cases: results.append(int_to_roman(num)) return results"},{"question":"from typing import List def subarraySum(nums: List[int], k: int) -> int: Find the total number of continuous subarrays whose sum equals to k. :param nums: List[int] :param k: int :return: int Examples: >>> subarraySum([1, 1, 1], 2) 2 >>> subarraySum([10, 2, -2, -20, 10], -10) 3 pass def test_subarraySum_example1(): nums = [1, 1, 1] k = 2 assert subarraySum(nums, k) == 2 def test_subarraySum_example2(): nums = [10, 2, -2, -20, 10] k = -10 assert subarraySum(nums, k) == 3 def test_subarraySum_single_element(): nums = [5] k = 5 assert subarraySum(nums, k) == 1 def test_subarraySum_no_subarray(): nums = [1, 2, 3] k = 7 assert subarraySum(nums, k) == 0 def test_subarraySum_negative_numbers(): nums = [-1, -1, 1] k = 0 assert subarraySum(nums, k) == 1 def test_subarraySum_multiple_same_subarrays(): nums = [0, 0, 0, 0, 0] k = 0 assert subarraySum(nums, k) == 15 def test_subarraySum_large_numbers(): nums = [10000000, 10000000, -10000000, -10000000] k = 0 assert subarraySum(nums, k) == 2","solution":"def subarraySum(nums, k): Find total number of continuous subarrays whose sum equals to k. :param nums: List[int] :param k: int :return: int count = 0 current_sum = 0 sum_dict = {0: 1} # Initialize with sum 0 having a count of 1 for num in nums: current_sum += num if current_sum - k in sum_dict: count += sum_dict[current_sum - k] if current_sum in sum_dict: sum_dict[current_sum] += 1 else: sum_dict[current_sum] = 1 return count"},{"question":"def fizz_buzz(m): Prints numbers from 1 to m with special rules: - For multiples of 3, prints 'Fizz' - For multiples of 5, prints 'Buzz' - For multiples of both 3 and 5, prints 'FizzBuzz' - Otherwise, prints the number >>> fizz_buzz(5) 1 2 Fizz 4 Buzz >>> fizz_buzz(15) 1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz","solution":"def fizz_buzz(m): Prints numbers from 1 to m with special rules: - For multiples of 3, prints 'Fizz' - For multiples of 5, prints 'Buzz' - For multiples of both 3 and 5, prints 'FizzBuzz' - Otherwise, prints the number for a in range(1, m + 1): if a % 3 == 0 and a % 5 == 0: print('FizzBuzz') elif a % 3 == 0: print('Fizz') elif a % 5 == 0: print('Buzz') else: print(a)"},{"question":"def min_max_hiking_distance(N: int, lengths: List[int]) -> int: Compute the minimum possible value of the maximum distance that any of the three friends has to hike. >>> min_max_hiking_distance(7, [4, 3, 6, 8, 10, 2, 7]) 18 >>> min_max_hiking_distance(3, [5, 5, 5]) 5 >>> min_max_hiking_distance(1, [10]) 10 >>> min_max_hiking_distance(2, [10, 15]) 15 >>> min_max_hiking_distance(5, [6, 6, 6, 6, 6]) 12 >>> lengths = [1] * 100000 >>> min_max_hiking_distance(100000, lengths) 33334","solution":"def min_max_hiking_distance(N, lengths): def is_valid_partition(max_distance): count_friends = 1 current_sum = 0 for length in lengths: if current_sum + length > max_distance: count_friends += 1 current_sum = length if count_friends > 3: return False else: current_sum += length return True left, right = max(lengths), sum(lengths) result = right while left <= right: mid = (left + right) // 2 if is_valid_partition(mid): result = mid right = mid - 1 else: left = mid + 1 return result # Example usage N = 7 lengths = [4, 3, 6, 8, 10, 2, 7] print(min_max_hiking_distance(N, lengths)) # Output should be 18"},{"question":"def highlight_occurrences(word: str, text: str) -> str: Highlight all occurrences of a word in a text with double angle brackets \`<< >>\`. Args: word (str): The word to be searched for. text (str): The body of text in which to search for the word. Returns: str: The text with all occurrences of the word surrounded by \`<< >>\`. Examples: >>> highlight_occurrences('word', 'This is a word in a sentence.') 'This is a <<word>> in a sentence.' >>> highlight_occurrences('word', 'Word word WORD. word!') '<<Word>> <<word>> <<WORD>>. <<word>>!'","solution":"import re def highlight_occurrences(word, text): Highlight all occurrences of a word in a text with double angle brackets \`<< >>\`. Args: word (str): The word to be searched in the text. text (str): The body of text where we search for the word. Returns: str: The text with all occurrences of the word surrounded by \`<< >>\`. # Create a regex pattern to match the word with boundaries and case insensitive pattern = re.compile(r'b' + re.escape(word) + r'b', re.IGNORECASE) # Use a replacement function to add \`<< >>\` def replacer(match): return f'<<{match.group(0)}>>' # Replace all occurrences highlighted_text = pattern.sub(replacer, text) return highlighted_text"},{"question":"def min_cuts_to_match(heights: List[int], target: List[int]) -> int: Given an array of integers heights representing the heights of a forest's trees, where heights[i] represents the height of the i-th tree in the forest. Your task is to incrementally cut down trees in a way that matches the final forest structure as described by another array target of the same size. The operation that can be performed is to cut down a tree by 1 unit at a time. The objective is to minimize the total number of cuts needed to match the target array. >>> min_cuts_to_match([3, 4, 5], [1, 2, 4]) 5 >>> min_cuts_to_match([4, 3, 6], [2, 1, 3]) 7 >>> min_cuts_to_match([1, 5, 3], [1, 3, 1]) 4 >>> min_cuts_to_match([1, 2, 3], [1, 2, 3]) 0 >>> min_cuts_to_match([0, 0, 0], [0, 0, 0]) 0 >>> min_cuts_to_match([10, 20, 30], [0, 0, 0]) 60 >>> min_cuts_to_match([3, 10, 20], [2, 5, 10]) 16 >>> min_cuts_to_match([10**9, 10**9], [0, 0]) 2000000000 >>> min_cuts_to_match([5], [3]) 2 >>> min_cuts_to_match([3], [3]) 0","solution":"def min_cuts_to_match(heights, target): Calculate the minimum number of cuts needed to transform heights into target. Parameters: heights (list of int) : Initial heights of trees. target (list of int) : Final target heights of trees. Returns: int : Minimum number of cuts needed total_cuts = 0 for h, t in zip(heights, target): if h > t: total_cuts += (h - t) return total_cuts"},{"question":"def max_non_overlapping_performances(n, performances): Given a list of performances with their start and end times, find the maximum number of non-overlapping performances you can include on the main stage. Parameters: n (int): The number of performances performances (List[Tuple[int, int]]): A list of tuples where each tuple contains the start time and end time of a performance Returns: int: The maximum number of non-overlapping performances Examples: >>> max_non_overlapping_performances(5, [(1, 4), (3, 5), (0, 6), (5, 7), (8, 9)]) 3 >>> max_non_overlapping_performances(1, [(1, 2)]) 1 >>> max_non_overlapping_performances(4, [(1, 2), (3, 4), (5, 6), (7, 8)]) 4 >>> max_non_overlapping_performances(3, [(1, 5), (2, 6), (3, 7)]) 1 >>> max_non_overlapping_performances(4, [(1, 3), (2, 4), (3, 5), (4, 6)]) 2 >>> max_non_overlapping_performances(6, [(1, 3), (3, 5), (5, 7), (7, 9), (2, 4), (6, 8)]) 4","solution":"def max_non_overlapping_performances(n, performances): Returns the maximum number of non-overlapping performances. :param n: The number of performances (int) :param performances: A list of tuples, where each tuple contains two integers (start, end) times. :return: The maximum number of non-overlapping performances (int) # Sort performances by end time performances.sort(key=lambda x: x[1]) max_performances = 0 last_end_time = 0 for start, end in performances: if start >= last_end_time: max_performances += 1 last_end_time = end return max_performances # Example execution num_performances = 5 performances = [(1, 4), (3, 5), (0, 6), (5, 7), (8, 9)] print(max_non_overlapping_performances(num_performances, performances)) # Output: 3"},{"question":"def find_min_energy(t: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[int]: Calculate the minimum energy required to traverse the magical belt. Parameters: t (int): Number of test cases test_cases (List[Tuple[int, List[List[int]]]]): List of test cases, each containing grid dimensions and energy costs Returns: List[int]: List of minimum energy required for each test case >>> find_min_energy(2, [(3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]), (2, [ ... [1, 2], ... [3, 4] ... ])]) [21, 7] >>> find_min_energy(1, [(1, [ ... [0] ... ])]) [0] >>> find_min_energy(1, [(2, [ ... [1, 1000], ... [1000, 1] ... ])]) [1002]","solution":"def find_min_energy(t, test_cases): results = [] for case in test_cases: n, matrix = case dp = [[0] * n for _ in range(n)] dp[0][0] = matrix[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + matrix[i][0] dp[0][i] = dp[0][i-1] + matrix[0][i] for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] results.append(dp[-1][-1]) return results def parse_input(input_data): data = input_data.strip().split('n') t = int(data[0]) index = 1 test_cases = [] for _ in range(t): n = int(data[index]) matrix = [] for i in range(n): matrix.append(list(map(int, data[index + i + 1].split()))) index += n + 1 test_cases.append((n, matrix)) return t, test_cases def mysterious_belt(input_data): t, test_cases = parse_input(input_data) result = find_min_energy(t, test_cases) for res in result: print(res)"},{"question":"def longest_non_decreasing_subarray_length(prices): Returns the length of the longest contiguous subarray with non-decreasing prices. >>> longest_non_decreasing_subarray_length([1, 2, 2, 1, 3, 4, 5]) 4 >>> longest_non_decreasing_subarray_length([5, 4, 3, 2, 1]) 1 >>> longest_non_decreasing_subarray_length([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 10 >>> longest_non_decreasing_subarray_length([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 1 >>> longest_non_decreasing_subarray_length([7]) 1 >>> longest_non_decreasing_subarray_length([1, 3, 1, 3, 1, 3, 1, 3, 1, 3]) 2 >>> longest_non_decreasing_subarray_length([5, 5, 5, 5, 5, 5, 5]) 7 >>> longest_non_decreasing_subarray_length([]) 0 >>> longest_non_decreasing_subarray_length([1, 2, 2, 3, 4, 4, 5, 6, 7, 7, 8]) 11","solution":"def longest_non_decreasing_subarray_length(prices): Returns the length of the longest contiguous subarray with non-decreasing prices. if not prices: return 0 max_length = 1 current_length = 1 for i in range(1, len(prices)): if prices[i] >= prices[i - 1]: current_length += 1 else: current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"from datetime import datetime def filter_expired_items(food_items, current_date): Filters out food items that have expired based on the current date. Parameters: food_items (list of tuple): A list of tuples where each tuple contains a string (food item name) and a string (expiration date in 'YYYY-MM-DD' format). current_date (str): A string representing the current date in 'YYYY-MM-DD' format. Returns: list: A list of food item names that have not expired. Examples: >>> filter_expired_items([(\\"Milk\\", \\"2023-10-01\\"), (\\"Bread\\", \\"2023-09-29\\"), (\\"Butter\\", \\"2023-10-10\\")], \\"2023-10-01\\") [\\"Milk\\", \\"Butter\\"] >>> filter_expired_items([(\\"Cheese\\", \\"2023-09-25\\"), (\\"Yogurt\\", \\"2023-09-30\\"), (\\"Ham\\", \\"2023-09-30\\")], \\"2023-09-30\\") [\\"Yogurt\\", \\"Ham\\"]","solution":"from datetime import datetime def filter_expired_items(food_items, current_date): Filters out food items that have expired based on the current date. Parameters: food_items (list of tuple): A list of tuples where each tuple contains a string (food item name) and a string (expiration date in 'YYYY-MM-DD' format). current_date (str): A string representing the current date in 'YYYY-MM-DD' format. Returns: list: A list of food item names that have not expired. current_date_obj = datetime.strptime(current_date, '%Y-%m-%d') non_expired_items = [item for item, exp_date in food_items if datetime.strptime(exp_date, '%Y-%m-%d') >= current_date_obj] return non_expired_items"},{"question":"def can_sort_with_operations(N, K, A): Determine if the array A can be sorted with at most K swap operations. >>> can_sort_with_operations(3, 2, [3, 1, 2]) \\"YES\\" >>> can_sort_with_operations(4, 1, [4, 3, 2, 1]) \\"NO\\" >>> can_sort_with_operations(5, 10, [4, 3, 2, 5, 1]) \\"YES\\" pass def chef_can_sort(T, test_cases): For each test case, determine if Chef can sort the array within the given operations. >>> chef_can_sort(3, [((3, 2), [3, 1, 2]), ((4, 1), [4, 3, 2, 1]), ((5, 10), [4, 3, 2, 5, 1])]) [\\"YES\\", \\"NO\\", \\"YES\\"] pass","solution":"def can_sort_with_operations(N, K, A): Determine if the array A can be sorted with at most K swap operations. sorted_A = sorted(A) required_swaps = 0 # A list to keep track of visited elements visited = [False] * N # Traverse each element and use cycle detection to count swaps for i in range(N): if visited[i] or sorted_A[i] == A[i]: continue cycle_length = 0 j = i # Count the length of the cycle while not visited[j]: visited[j] = True j = A.index(sorted_A[j]) cycle_length += 1 # If cycle_length > 1, we need (cycle_length - 1) swaps to sort this cycle if cycle_length > 1: required_swaps += (cycle_length - 1) return \\"YES\\" if required_swaps <= K else \\"NO\\" def chef_can_sort(T, test_cases): For each test case, determine if Chef can sort the array within the given operations. results = [] for i in range(T): N, K = test_cases[i][0] A = test_cases[i][1] results.append(can_sort_with_operations(N, K, A)) return results"},{"question":"def minimum_distinct_problems(n: int, m: int) -> int: Determine the minimum number of distinct problems he needs to prepare so that every participant receives a different problem set without violating the rules. Args: n (int): The number of participants. m (int): The number of problems per problem set. Returns: int: The minimum number of distinct problems required. >>> minimum_distinct_problems(5, 3) 15 >>> minimum_distinct_problems(2, 2) 4 >>> minimum_distinct_problems(3, 4) 12 >>> minimum_distinct_problems(1, 5) 5 >>> minimum_distinct_problems(1, 1) 1 >>> minimum_distinct_problems(10, 10) 100 >>> minimum_distinct_problems(1000, 1000) 1000000 >>> minimum_distinct_problems(7, 2) 14","solution":"def minimum_distinct_problems(n, m): Returns the minimum number of distinct problems required to distribute unique problem sets to the participants. return n * m"},{"question":"def can_rearrange_after_removal(t: int, cases: List[Tuple[int, str]]) -> List[str]: Check whether it is possible to rearrange the string with one character removed such that no two adjacent characters are the same for each test case. :param t: The number of test cases. :param cases: A list of tuples where each tuple contains an integer and a string representing the length and the string respectively. :return: A list of strings \\"YES\\" or \\"NO\\" for each test case. >>> can_rearrange_after_removal(1, [(5, 'ababa')]) ['YES'] >>> can_rearrange_after_removal(1, [(6, 'aabbcc')]) ['YES'] >>> can_rearrange_after_removal(1, [(3, 'aaa')]) ['NO'] >>> can_rearrange_after_removal(1, [(4, 'abca')]) ['YES'] >>> can_rearrange_after_removal(1, [(7, 'aaaaaaa')]) ['NO']","solution":"def can_rearrange_after_removal(t, cases): results = [] for i in range(t): n, s = cases[i] max_freq = max(s.count(c) for c in set(s)) if max_freq <= (n + 1) // 2: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def bike_rental_status(T: int, test_cases: List[Tuple[int, List[int], int, List[int]]]) -> List[Tuple[int, int]]: Determine the number of people who successfully rent a bike from their preferred shop and the total number of people who successfully rent a bike. >>> bike_rental_status(2, [(3, [5, 3, 4], 6, [1, 2, 1, 3, 2, 3]), (2, [4, 5], 5, [1, 2, 2, 1, 2])]) [(6, 6), (5, 5)] >>> bike_rental_status(1, [(2, [1, 1], 3, [1, 1, 1])]) [(1, 2)] >>> bike_rental_status(1, [(3, [1, 2, 1], 5, [1, 2, 3, 2, 2])]) [(4, 4)] >>> bike_rental_status(1, [(3, [1, 1, 1], 3, [1, 2, 3])]) [(3, 3)] >>> bike_rental_status(1, [(3, [0, 0, 0], 3, [1, 2, 3])]) [(0, 0)]","solution":"def bike_rental_status(T, test_cases): result = [] for t in range(T): S = test_cases[t][0] bikes = test_cases[t][1] P = test_cases[t][2] preferences = test_cases[t][3] preferred_count = 0 total_count = 0 for pref in preferences: if bikes[pref - 1] > 0: bikes[pref - 1] -= 1 preferred_count += 1 total_count += 1 else: for i in range(S): if bikes[i] > 0: bikes[i] -= 1 total_count += 1 break result.append((preferred_count, total_count)) return result"},{"question":"def min_coins(A, B, C, D, S): Determines the minimum number of coins needed to make the exact amount S. If it is not possible to create the amount using the given coin values, returns -1. >>> min_coins(1, 3, 4, 5, 7) 2 >>> min_coins(1, 1000, 1000, 1000, 7) 7 >>> min_coins(2, 4, 6, 8, 7) -1 >>> min_coins(1, 5, 10, 25, 100) 4 >>> min_coins(2, 4, 6, 8, 8) 1 >>> min_coins(2, 2, 4, 6, 6) 1 >>> min_coins(1, 2, 4, 8, 9) 2","solution":"def min_coins(A, B, C, D, S): Determines the minimum number of coins needed to make the exact amount S. If it is not possible to create the amount using the given coin values, returns -1. coins = [A, B, C, D] # Initialize a large enough array to keep track of the minimum number of coins for amounts up to S dp = [float('inf')] * (S + 1) dp[0] = 0 # Base case: 0 coins are needed to make 0 amount for coin in coins: for x in range(coin, S + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return -1 if dp[S] == float('inf') else dp[S]"},{"question":"from typing import List def max_of_subarrays(arr: List[int], k: int) -> List[int]: Finds the maximum element in every k-size subarray in the given array. >>> max_of_subarrays([1, 3, 1, 2, 0, 5, 8, 6], 3) [3, 3, 2, 5, 8, 8] >>> max_of_subarrays([1, 3, 1, 2, 0, 5, 8, 6], 1) [1, 3, 1, 2, 0, 5, 8, 6] >>> max_of_subarrays([1, 3, 1, 2, 0, 5, 8, 6], 8) [8] >>> max_of_subarrays([1, 3, 5, 2, 8, 9, 4], 4) [5, 8, 9, 9] >>> max_of_subarrays([5, 5, 5, 5, 5, 5, 5, 5], 3) [5, 5, 5, 5, 5, 5] >>> max_of_subarrays([], 1) [] >>> max_of_subarrays([4, 9, 2], 5) [] >>> max_of_subarrays(list(range(1, 1000001)), 1000000) [1000000] pass","solution":"from collections import deque from typing import List def max_of_subarrays(arr: List[int], k: int) -> List[int]: Finds the maximum element in every k-size subarray in the given array. n = len(arr) if n * k == 0 or k > n: return [] deq = deque() max_subarrays = [] for i in range(n): # Remove elements outside the current window if deq and deq[0] == i - k: deq.popleft() # Remove elements from the deque that are smaller than the current element while deq and arr[deq[-1]] < arr[i]: deq.pop() # Add current element index to the deque deq.append(i) # Start adding to result list once we've processed k elements if i >= k - 1: max_subarrays.append(arr[deq[0]]) return max_subarrays"},{"question":"def min_travel_time(n: int, m: int, grid: List[List[int]]) -> int: Given a 2D grid with dimensions \`n x m\`, where each cell has a time value indicating the time taken to pass through that cell, find the minimum time to travel from the top-left corner of the grid (0, 0) to the bottom-right corner of the grid (n-1, m-1). You can move to adjacent cells in the grid (up, down, left, right). Args: n (int): the number of rows. m (int): the number of columns. grid (List[List[int]]): the grid containing time values for each cell. Returns: int: the minimum time to travel from the top-left corner to the bottom-right corner of the grid. Example: >>> n, m = 3, 3 >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> min_travel_time(n, m, grid) 7 # Your code here def test_min_travel_time(): # Example test case n, m = 3, 3 grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_travel_time(n, m, grid) == 7 # Additional test case 1 n, m = 2, 2 grid = [ [1, 2], [1, 1] ] assert min_travel_time(n, m, grid) == 3 # Additional test case 2 n, m = 3, 3 grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert min_travel_time(n, m, grid) == 5 # Additional test case 3 n, m = 1, 1 grid = [ [42] ] assert min_travel_time(n, m, grid) == 42 # Additional test case 4 n, m = 5, 5 grid = [ [1, 1, 1, 1, 1], [1, 9, 9, 9, 1], [1, 9, 1, 9, 1], [1, 9, 9, 9, 1], [1, 1, 1, 1, 1] ] assert min_travel_time(n, m, grid) == 9","solution":"import heapq def min_travel_time(n, m, grid): Returns the minimum time to travel from the top-left corner to the bottom-right corner of the grid. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: 2D list containing time values for each cell :return: Minimum time to travel from (0, 0) to (n-1, m-1) # Dijkstra's algorithm to find the shortest path in a grid def dijkstra(grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] pq = [(grid[0][0], 0, 0)] # (time, x, y) visited = set() while pq: time, x, y = heapq.heappop(pq) if (x, y) in visited: continue visited.add((x, y)) if x == n - 1 and y == m - 1: return time for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited: heapq.heappush(pq, (time + grid[nx][ny], nx, ny)) return dijkstra(grid)"},{"question":"def classify_books(n: int, book_titles_and_keywords: List[str], m: int, genre_keywords: List[str]) -> List[str]: Determine the genre of each book title based on the frequency of the associated keywords. Args: n (int): number of books. book_titles_and_keywords (List[str]): list containing the book titles followed by their respective keywords. m (int): number of genre-keyword pairs. genre_keywords (List[str]): list containing the genre followed by a list of associated keywords. Returns: List[str]: a list containing each book title from the input followed by its predicted genre. Example: >>> classify_books(3, [\\"The Time Machine space,time,machine\\", \\"The War of the Worlds alien,war,planet\\", \\"To the Lighthouse sea,house,light\\"], 2, [\\"Science Fiction: space,alien,future\\", \\"Drama: love,tragedy,life\\"]) ['The Time Machine Science Fiction', 'The War of the Worlds Science Fiction', 'To the Lighthouse Unknown'] >>> classify_books(1, [\\"The Sun and Her Flowers light,life\\"], 1, [\\"Science Fiction: space,alien,future\\"]) ['The Sun and Her Flowers Unknown'] pass # Unit Tests from solution import classify_books def test_example_case(): assert classify_books(3, [\\"The Time Machine space,time,machine\\", \\"The War of the Worlds alien,war,planet\\", \\"To the Lighthouse sea,house,light\\"], 2, [\\"Science Fiction: space,alien,future\\", \\"Drama: love,tragedy,life\\"]) == [\\"The Time Machine Science Fiction\\", \\"The War of the Worlds Science Fiction\\", \\"To the Lighthouse Unknown\\"] def test_single_book_single_genre(): assert classify_books(1, [\\"The Time Machine space,machine\\"], 1, [\\"Science Fiction: space,alien,future\\"]) == [\\"The Time Machine Science Fiction\\"] def test_no_matching_genre(): assert classify_books(1, [\\"The Sun and Her Flowers light,life\\"], 1, [\\"Science Fiction: space,alien,future\\"]) == [\\"The Sun and Her Flowers Unknown\\"] def test_multiple_books_multiple_genres(): assert classify_books(2, [\\"Book1 magic,adventure\\", \\"Book2 tragedy,love\\"], 2, [\\"Fantasy: magic,wizards\\", \\"Drama: love,tragedy\\"]) == [\\"Book1 Fantasy\\", \\"Book2 Drama\\"] def test_case_insensitivity(): assert classify_books(1, [\\"The Time Machine Space,TIME,Machine\\"], 1, [\\"Science Fiction: space,alien,future\\"]) == [\\"The Time Machine Science Fiction\\"] def test_titles_with_special_characters(): assert classify_books(1, [\\"#The-Time Machine!! space,time,machine\\"], 1, [\\"Science Fiction: space,alien,future\\"]) == [\\"#The-Time Machine!! Science Fiction\\"]","solution":"def classify_books(n, book_titles_and_keywords, m, genre_keywords): from collections import defaultdict import re # Dictionary to store genre and its associated keywords genre_to_keywords = defaultdict(set) for genre_line in genre_keywords: genre, keywords = genre_line.split(':') genre_to_keywords[genre.strip()] = set(map(str.strip, keywords.split(','))) # Helper to cleanup keywords def clean_keyword(keyword): return re.sub(r'[^a-z]', '', keyword.lower()) # Get lowercased set of keywords for each genre genre_keywords_cleaned = {genre: {clean_keyword(k) for k in keywords} for genre, keywords in genre_to_keywords.items()} results = [] for book_line in book_titles_and_keywords: parts = book_line.split() title = ' '.join(parts[:-1]) keywords = parts[-1].split(',') cleaned_keywords = {clean_keyword(k) for k in keywords} # Determine which genre this book most likely belongs to best_match = None best_count = 0 for genre, genre_keywords_set in genre_keywords_cleaned.items(): count = len(cleaned_keywords & genre_keywords_set) if count > best_count: best_count = count best_match = genre if best_match: results.append(f\\"{title} {best_match}\\") else: results.append(f\\"{title} Unknown\\") return results"},{"question":"def find_max_distance(n: int, m: int, matrix: List[List[int]]) -> int: Find the highest and lowest points in the matrix and compute the distance between them. :param n: Number of rows in the matrix :param m: Number of columns in the matrix :param matrix: The matrix containing heights :return: Maximum distance between highest and lowest points >>> find_max_distance(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 8 >>> find_max_distance(2, 3, [ ... [-1, 2, 3], ... [4, 5, -6] ... ]) 11","solution":"def find_max_distance(n, m, matrix): Find the highest and lowest points in the matrix and compute the distance between them. :param n: Number of rows in the matrix :param m: Number of columns in the matrix :param matrix: The matrix containing heights :return: Maximum distance between highest and lowest points max_height = -float('inf') min_height = float('inf') for row in matrix: for height in row: if height > max_height: max_height = height if height < min_height: min_height = height return max_height - min_height"},{"question":"from typing import List def shortest_path(n: int, grid: List[List[int]]) -> int: Determines the shortest path from the top-left corner to the bottom-right corner of a grid with obstacles. Args: n (int): The size of the grid (n x n). grid (List[List[int]]): The grid configuration with 0 representing open cells and 1 representing obstacles. Returns: int: The length of the shortest path. If no such path exists, return -1. Examples: >>> shortest_path(5, [[0, 0, 0, 0, 0], [1, 0, 1, 1, 1], [1, 0, 0, 0, 1], [1, 1, 1, 0, 0], [1, 1, 1, 1, 0]]) 8 >>> shortest_path(4, [[0, 1, 0, 0], [1, 1, 0, 1], [0, 0, 0, 1], [1, 1, 0, 0]]) -1 >>> shortest_path(1, [[0]]) 0 >>> shortest_path(3, [[0, 1, 1], [1, 1, 1], [1, 1, 0]]) -1 >>> shortest_path(3, [[0, 1, 0], [0, 0, 0], [1, 1, 0]]) 4","solution":"from collections import deque def shortest_path(n, grid): def is_valid_move(x, y): return 0 <= x < n and 0 <= y < n and grid[x][y] == 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set() visited.add((0, 0)) while queue: x, y, dist = queue.popleft() if (x, y) == (n-1, n-1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid_move(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def process_orders(n: int, initial_quantities: List[int], m: int, orders: List[Tuple[int, int]]) -> List[int]: Simulates the process of handling orders for products in a warehouse. Parameters: n (int): Number of different products in the warehouse. initial_quantities (list): List of initial quantities of the products. m (int): Number of orders. orders (list): List of tuples where each tuple contains two integers (product_id, quantity_ordered). Returns: list: Final quantities of the products in the warehouse after processing all the orders. >>> process_orders(4, [10, 20, 30, 40], 3, [(1, 5), (2, 25), (3, 10)]) == [5, 0, 20, 40] >>> process_orders(3, [15, 10, 20], 2, [(2, 5), (3, 25)]) == [15, 5, 0] >>> process_orders(5, [10, 20, 30, 40, 50], 0, []) == [10, 20, 30, 40, 50] >>> process_orders(2, [50, 50], 2, [(1, 25), (2, 50)]) == [25, 0] >>> process_orders(2, [30, 40], 2, [(1, 50), (2, 60)]) == [0, 0] >>> process_orders(5, [100, 200, 300, 400, 500], 4, [(5, 600), (4, 150), (3, 100), (2, 200)]) == [100, 0, 200, 250, 0]","solution":"def process_orders(n, initial_quantities, m, orders): Simulates the process of handling orders for products in a warehouse. Parameters: n (int): Number of different products in the warehouse. initial_quantities (list): List of initial quantities of the products. m (int): Number of orders. orders (list): List of tuples where each tuple contains two integers (product_id, quantity_ordered). Returns: list: Final quantities of the products in the warehouse after processing all the orders. quantities = initial_quantities[:] for p, q in orders: index = p - 1 if quantities[index] >= q: quantities[index] -= q else: quantities[index] = 0 return quantities"},{"question":"def classify_trip(trip): Classify a trip as \\"Diverse\\" if it contains any triplet \\"HWC\\" or \\"CHW\\", otherwise as \\"Monotonous\\". trip: str - Trip plan consisting of characters 'H', 'W', and 'C'. Returns: str - \\"Diverse\\" or \\"Monotonous\\" # Your implementation here def classify_trips(N, trip_plans): Classify a list of trip plans. N: int - The number of trip plans. trip_plans: list of str - List of trip plans. Returns: list of str - List of classifications, either \\"Diverse\\" or \\"Monotonous\\". # Your implementation here # Example usage and test cases def main(): n = int(input(\\"Enter the number of trip plans: \\")) trip_plans = [] for _ in range(n): trip_plans.append(input()) classifications = classify_trips(n, trip_plans) for classification in classifications: print(classification) if __name__ == \\"__main__\\": main()","solution":"def classify_trip(trip): Classifies a trip as \\"Diverse\\" if it contains any triplet \\"HWC\\" or \\"CHW\\", otherwise as \\"Monotonous\\". trip: str - Trip plan consisting of characters 'H', 'W', and 'C'. Returns: str - \\"Diverse\\" or \\"Monotonous\\" if 'HWC' in trip or 'CHW' in trip: return \\"Diverse\\" return \\"Monotonous\\" def classify_trips(N, trip_plans): Classifies a list of trip plans. N: int - The number of trip plans. trip_plans: list of str - List of trip plans. Returns: list of str - List of classifications, either \\"Diverse\\" or \\"Monotonous\\". return [classify_trip(plan) for plan in trip_plans]"},{"question":"from typing import List def reorder_packets(packets: List[int], indices: List[int]) -> List[int]: Reorders the packets based on their indices. :param packets: List[int] - a list of packet data. :param indices: List[int] - a list of corresponding indices for the packets. :return: List[int] - the reordered list of packet data. pass # Unit tests def test_reorder_packets_example(): packets = [10, 20, 30, 40, 50] indices = [4, 3, 0, 1, 2] expected = [30, 40, 50, 20, 10] assert reorder_packets(packets, indices) == expected def test_reorder_packets_single_element(): packets = [1] indices = [0] expected = [1] assert reorder_packets(packets, indices) == expected def test_reorder_packets_ordered_indices(): packets = [1, 2, 3] indices = [0, 1, 2] expected = [1, 2, 3] assert reorder_packets(packets, indices) == expected def test_reorder_packets_reversed_indices(): packets = [10, 20, 30] indices = [2, 1, 0] expected = [30, 20, 10] assert reorder_packets(packets, indices) == expected def test_reorder_packets_mixed_indices(): packets = [7, 8, 9, 10, 11] indices = [3, 0, 4, 2, 1] expected = [8, 11, 10, 7, 9] assert reorder_packets(packets, indices) == expected","solution":"def reorder_packets(packets, indices): Reorders the packets based on their indices. :param packets: List[int] - a list of packet data. :param indices: List[int] - a list of corresponding indices for the packets. :return: List[int] - the reordered list of packet data. n = len(packets) reordered = [0] * n for packet, index in zip(packets, indices): reordered[index] = packet return reordered"},{"question":"def trap(height): Calculate the total amount of water trapped after it rains between buildings of varying heights. Args: height (List[int]): A list of integers representing the heights of buildings. Returns: int: The total amount of water trapped. Examples: >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap([4, 2, 0, 3, 2, 5]) == 9 from solution import trap def test_example_1(): assert trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 def test_example_2(): assert trap([4, 2, 0, 3, 2, 5]) == 9 def test_no_trapping(): assert trap([0, 1, 2, 3, 4, 5]) == 0 def test_flat_surface(): assert trap([3, 3, 3, 3, 3]) == 0 def test_single_building(): assert trap([5]) == 0 def test_two_buildings(): assert trap([2, 1]) == 0 def test_buildings_with_gaps(): assert trap([3, 0, 2, 0, 4]) == 7 def test_no_buildings(): assert trap([]) == 0","solution":"def trap(height): Calculate the total amount of water trapped after it rains between buildings of varying heights. Args: height (List[int]): A list of integers representing the heights of buildings. Returns: int: The total amount of water trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) # Fill right max array right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) # Calculate the trapped water water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def is_k_palindrome(s: str, l: int, r: int, k: int) -> bool: Determines if the substring s[l:r+1] can be transformed into a palindrome by changing at most k characters. pass # Implementation here def process_queries(t: int, test_cases: List[Tuple[int, int, str, List[Tuple[int, int, int]]]]) -> List[str]: Processes multiple test cases and queries to determine if the substring is a K-Palindrome. pass # Implementation here # Test cases def test_is_k_palindrome(): Test the simple function that determines if the substring can be transformed into a palindrome by changing at most k characters. assert is_k_palindrome(\\"abcaacbd\\", 1, 4, 1) == True assert is_k_palindrome(\\"abcaacbd\\", 3, 8, 2) == False assert is_k_palindrome(\\"aaaa\\", 1, 4, 0) == True assert is_k_palindrome(\\"abcd\\", 1, 4, 2) == True assert is_k_palindrome(\\"abcd\\", 1, 4, 1) == False def test_process_queries(): Test the process_queries function with multiple test cases. t = 1 test_cases = [ (8, 2, \\"abcaacbd\\", [(1, 4, 1), (3, 8, 2)]) ] results = process_queries(t, test_cases) assert results == [\\"YES\\", \\"NO\\"] t = 1 test_cases = [ (4, 3, \\"abcd\\", [(1, 4, 2), (1, 4, 1), (1, 4, 0)]) ] results = process_queries(t, test_cases) assert results == [\\"YES\\", \\"NO\\", \\"NO\\"] t = 2 test_cases = [ (4, 1, \\"aaaa\\", [(1, 4, 0)]), (4, 1, \\"abcd\\", [(1, 4, 2)]), ] results = process_queries(t, test_cases) assert results == [\\"YES\\", \\"YES\\"]","solution":"def is_k_palindrome(s, l, r, k): Determines if the substring s[l:r+1] can be transformed into a palindrome by changing at most k characters. l -= 1 # Convert to 0-indexed r -= 1 # Convert to 0-indexed sub_str = s[l:r+1] n = len(sub_str) count = 0 for i in range(n // 2): if sub_str[i] != sub_str[n - i - 1]: count += 1 return count <= k def process_queries(t, test_cases): results = [] for case in test_cases: n, q, s, queries = case for query in queries: l, r, k = query if is_k_palindrome(s, l, r, k): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def find_optimal_tables(N: int, K: int, knight_coordinates: List[Tuple[int, int]]) -> List[Tuple[float, float]]: Find the optimal positions of K tables such that the total sum of the distances from each knight to their assigned table is minimized. Args: - N (int): The number of knights. - K (int): The number of groups. - knight_coordinates (List[Tuple[int, int]]): List of coordinates of knights. Returns: - List[Tuple[float, float]]: The coordinates of the K tables. >>> find_optimal_tables(6, 2, [(1, 3), (2, 2), (3, 1), (8, 8), (9, 9), (10, 10)]) [(2.000, 2.000), (9.000, 9.000)] >>> find_optimal_tables(5, 3, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) [(1.500, 1.500), (3.500, 3.500), (5.000, 5.000)] >>> find_optimal_tables(3, 1, [(5, 1), (6, 2), (7, 3)]) [(6.000, 2.000)] from typing import List, Tuple def test_example_1(): knight_coordinates = [(1, 3), (2, 2), (3, 1), (8, 8), (9, 9), (10, 10)] N = 6 K = 2 tables = find_optimal_tables(N, K, knight_coordinates) assert round(tables[0][0]) == 2 assert round(tables[0][1]) == 2 assert round(tables[1][0]) == 9 assert round(tables[1][1]) == 9 def test_example_2(): knight_coordinates = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] N = 5 K = 3 tables = find_optimal_tables(N, K, knight_coordinates) assert round(tables[0][0]) == 1 or round(tables[0][0]) == 2 assert round(tables[0][1]) == 1 or round(tables[0][1]) == 2 assert round(tables[1][0]) == 3 or round(tables[1][0]) == 4 assert round(tables[1][1]) == 3 or round(tables[1][1]) == 4 assert round(tables[2][0]) == 4 or round(tables[2][0]) == 5 assert round(tables[2][1]) == 4 or round(tables[2][1]) == 5 def test_example_3(): knight_coordinates = [(5, 1), (6, 2), (7, 3)] N = 3 K = 1 tables = find_optimal_tables(N, K, knight_coordinates) assert round(tables[0][0]) == 6 assert round(tables[0][1]) == 2","solution":"def k_means(knights, K): import numpy as np from scipy.spatial import distance def initialize_centroids(knights, K): np.random.seed(42) initial_indices = np.random.choice(len(knights), K, replace=False) return knights[initial_indices] def assign_knights_to_centroids(knights, centroids): clusters = {} for knight in knights: distances = [distance.euclidean(knight, centroid) for centroid in centroids] closest_centroid = np.argmin(distances) if closest_centroid in clusters: clusters[closest_centroid].append(knight) else: clusters[closest_centroid] = [knight] return clusters def update_centroids(clusters): new_centroids = [] for key in clusters.keys(): new_centroid = np.mean(clusters[key], axis=0) new_centroids.append(new_centroid) return new_centroids knights = np.array(knights) centroids = initialize_centroids(knights, K) for _ in range(100): # Run iterations (fixed number for convergence) clusters = assign_knights_to_centroids(knights, centroids) new_centroids = update_centroids(clusters) # Check for convergence by comparing old and new centroids if np.allclose(centroids, new_centroids, atol=1e-3): break centroids = new_centroids return centroids def find_optimal_tables(N, K, knight_coordinates): optimal_centroids = k_means(knight_coordinates, K) return optimal_centroids def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) K = int(data[1]) knight_coordinates = [(int(data[i*2+2]), int(data[i*2+3])) for i in range(N)] tables = find_optimal_tables(N, K, knight_coordinates) for table in tables: print(f\\"{table[0]:.3f} {table[1]:.3f}\\") if __name__ == \\"__main__\\": main()"},{"question":"def min_jumps_to_reach_n(n, jumps): Determines the minimum number of jumps needed to reach the last platform. If it is not possible to reach platform n, returns -1. :param n: Number of platforms :param jumps: List of integers representing the maximum jump lengths from each platform :return: Minimum number of jumps needed to reach platform n, or -1 if not possible >>> min_jumps_to_reach_n(6, [3, 3, 1, 0, 2, 0]) 3 >>> min_jumps_to_reach_n(5, [1, 0, 2, 1, 0]) -1 >>> min_jumps_to_reach_n(1, [0]) 0 >>> min_jumps_to_reach_n(6, [2, 0, 2, 1, 2, 0]) 3 >>> min_jumps_to_reach_n(5, [3, 3, 3, 3, 0]) 2 >>> min_jumps_to_reach_n(4, [1, 1, 0, 1]) -1","solution":"def min_jumps_to_reach_n(n, jumps): Determines the minimum number of jumps needed to reach the last platform. If it is not possible to reach platform n, returns -1. :param n: Number of platforms :param jumps: List of integers representing the maximum jump lengths from each platform :return: Minimum number of jumps needed to reach platform n, or -1 if not possible if n == 1: return 0 max_reach = jumps[0] steps = jumps[0] jumps_needed = 1 for i in range(1, n): if i == n - 1: return jumps_needed max_reach = max(max_reach, i + jumps[i]) steps -= 1 if steps == 0: jumps_needed += 1 if i >= max_reach: return -1 steps = max_reach - i return -1"},{"question":"from typing import List, Tuple def find_max_height_in_submatrices(N: int, M: int, Q: int, matrix: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Function to find the maximum height in submatrices described by queries. :param N: int : number of rows in the matrix :param M: int : number of columns in the matrix :param Q: int : number of queries :param matrix: List[List[int]] : 2D array representing the matrix :param queries: List[Tuple[int, int, int, int]] : list of queries :return: List[int] : list of results for each query (max height in the submatrix) Example: >>> N = 4 >>> M = 5 >>> Q = 3 >>> matrix = [ ... [1, 2, 3, 4, 5], ... [5, 10, 5, 10, 5], ... [3, 2, 1, 2, 3], ... [4, 4, 4, 4, 4] ... ] >>> queries = [ ... (1, 1, 2, 3), ... (2, 2, 4, 4), ... (1, 1, 4, 5) ... ] >>> find_max_height_in_submatrices(N, M, Q, matrix, queries) [10, 10, 10] # Test cases def test_sample_case(): N = 4 M = 5 Q = 3 matrix = [ [1, 2, 3, 4, 5], [5, 10, 5, 10, 5], [3, 2, 1, 2, 3], [4, 4, 4, 4, 4] ] queries = [ (1, 1, 2, 3), (2, 2, 4, 4), (1, 1, 4, 5) ] expected = [10, 10, 10] result = find_max_height_in_submatrices(N, M, Q, matrix, queries) assert result == expected def test_single_cell_query(): N = 3 M = 3 Q = 1 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [ (2, 2, 2, 2) ] expected = [5] result = find_max_height_in_submatrices(N, M, Q, matrix, queries) assert result == expected def test_entire_matrix_query(): N = 2 M = 2 Q = 1 matrix = [ [3, 4], [1, 2] ] queries = [ (1, 1, 2, 2) ] expected = [4] result = find_max_height_in_submatrices(N, M, Q, matrix, queries) assert result == expected def test_multiple_identical_queries(): N = 3 M = 3 Q = 2 matrix = [ [3, 4, 5], [6, 7, 8], [9, 10, 11] ] queries = [ (1, 1, 3, 3), (1, 1, 3, 3) ] expected = [11, 11] result = find_max_height_in_submatrices(N, M, Q, matrix, queries) assert result == expected","solution":"def find_max_height_in_submatrices(N, M, Q, matrix, queries): Function to find the maximum height in submatrices described by queries. :param N: int : number of rows in the matrix :param M: int : number of columns in the matrix :param Q: int : number of queries :param matrix: List[List[int]] : 2D array representing the matrix :param queries: List[Tuple[int, int, int, int]] : list of queries :return: List[int] : list of results for each query (max height in the submatrix) results = [] for (l1, r1, l2, r2) in queries: max_height = 0 for i in range(l1-1, l2): for j in range(r1-1, r2): if matrix[i][j] > max_height: max_height = matrix[i][j] results.append(max_height) return results"},{"question":"def recommend_items(n, m, scores, categories): Determine the most popular items for each category. Args: n : int : the number of items m : int : the number of categories scores : List[int] : the popularity scores of the items categories : List[int] : the categories of the items Returns: List[List[int]] : a list of lists containing the recommended items for each category Examples: >>> recommend_items(5, 3, [10, 20, 20, 30, 10], [1, 2, 2, 3, 1]) [[1, 5], [2, 3], [4]] >>> recommend_items(4, 2, [5, 5, 5, 5], [1, 2, 1, 2]) [[1, 3], [2, 4]]","solution":"def recommend_items(n, m, scores, categories): # Dictionary to keep track of the most popular items per category most_popular = {i: [] for i in range(1, m + 1)} highest_scores = {i: -1 for i in range(1, m + 1)} for index in range(n): score = scores[index] category = categories[index] if score > highest_scores[category]: highest_scores[category] = score most_popular[category] = [index + 1] elif score == highest_scores[category]: most_popular[category].append(index + 1) # Convert result into list of lists result = [most_popular[cat] for cat in range(1, m + 1)] return result"},{"question":"def fillGrid(n): Fills an n x n grid with numbers such that each row and column forms an arithmetic sequence. The numbers should start with 1 and increase by 1 across the grid. :param n: int: the size of the grid :return: list of list of int: the filled grid >>> fillGrid(3) [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> fillGrid(4) [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]] >>> fillGrid(1) [[1]] >>> fillGrid(2) [[1, 2], [3, 4]] >>> fillGrid(5) [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]","solution":"def fillGrid(n): Fills an n x n grid with numbers such that each row and column forms an arithmetic sequence. The numbers should start with 1 and increase by 1 across the grid. :param n: int: the size of the grid :return: list of list of int: the filled grid grid = [] for i in range(n): row = [] for j in range(n): row.append(i * n + j + 1) grid.append(row) return grid"},{"question":"def max_distinct_substrings(S: str, K: int) -> int: Given a string S and an integer K, find the maximum number of distinct substrings of length K that can be extracted from the string. >>> max_distinct_substrings(\\"abcabcab\\", 3) 3 >>> max_distinct_substrings(\\"abcdef\\", 2) 5 >>> max_distinct_substrings(\\"aaaaa\\", 2) 1 >>> max_distinct_substrings(\\"abcdef\\", 3) 4 >>> max_distinct_substrings(\\"aabcc\\", 1) 3 pass def process_test_cases(T: int, test_cases: List[Tuple[str, int]]) -> List[int]: Process multiple test cases to find the maximum number of distinct substrings for each test case. >>> process_test_cases(2, [(\\"abcabcab\\", 3), (\\"abcdef\\", 2)]) [3, 5] >>> process_test_cases(3, [(\\"aaaaa\\", 2), (\\"abcdef\\", 3), (\\"aabcc\\", 1)]) [1, 4, 3] pass","solution":"def max_distinct_substrings(S, K): substrings = set() for i in range(len(S) - K + 1): substrings.add(S[i:i + K]) return len(substrings) def process_test_cases(T, test_cases): results = [] for S, K in test_cases: results.append(max_distinct_substrings(S, K)) return results"},{"question":"from typing import List def minCost(costs: List[List[int]]) -> int: Determine the minimum cost of painting all houses such that no two adjacent houses have the same color. Parameters: costs (List[List[int]]): A 2D list where each sublist contains three integers representing the cost of painting a house with Red, Green, or Blue. Returns: int: The minimum cost to paint all houses. Examples: >>> minCost([ ... [17, 2, 17], ... [16, 16, 5], ... [14, 3, 19] ... ]) 10 >>> minCost([ ... [1, 2, 3], ... [1, 2, 3] ... ]) 3 # Implement your solution here pass import pytest def test_min_cost_example1(): costs = [ [17, 2, 17], [16, 16, 5], [14, 3, 19] ] assert minCost(costs) == 10 def test_min_cost_single_house(): costs = [ [17, 2, 17] ] assert minCost(costs) == 2 def test_min_cost_two_houses(): costs = [ [1, 2, 3], [1, 2, 3] ] assert minCost(costs) == 3 def test_min_cost_no_houses(): costs = [] assert minCost(costs) == 0 def test_min_cost_all_same(): costs = [ [3, 3, 3], [3, 3, 3], [3, 3, 3] ] assert minCost(costs) == 9 if __name__ == '__main__': pytest.main()","solution":"from typing import List def minCost(costs: List[List[int]]) -> int: n = len(costs) if n == 0: return 0 for i in range(1, n): # Cost of painting the current house red is the cost of painting it red plus the minimum cost to paint the previous house either green or blue costs[i][0] += min(costs[i-1][1], costs[i-1][2]) # Cost of painting the current house green is the cost of painting it green plus the minimum cost to paint the previous house either red or blue costs[i][1] += min(costs[i-1][0], costs[i-1][2]) # Cost of painting the current house blue is the cost of painting it blue plus the minimum cost to paint the previous house either red or green costs[i][2] += min(costs[i-1][0], costs[i-1][1]) # The answer will be the minimum cost of painting the last house any color return min(costs[-1])"},{"question":"def flood_fill(grid, sr, sc, new_color): Modifies the grid in-place to fill the connected pixels with the new color. :param grid: List of lists representing the 2D grid. :param sr: Start row index. :param sc: Start column index. :param new_color: The new color to fill connected pixels. pass def main(): # Read input import sys input = sys.stdin.read data = input().strip().split() m = int(data[0]) n = int(data[1]) new_color = int(data[2]) grid = [] idx = 3 for i in range(m): row = [int(data[idx+j]) for j in range(n)] grid.append(row) idx += n sr = int(data[idx]) sc = int(data[idx+1]) # Perform flood fill updated_grid = flood_fill(grid, sr, sc, new_color) # Print the updated grid for row in updated_grid: print(' '.join(map(str, row))) if __name__ == \\"__main__\\": main()","solution":"def flood_fill(grid, sr, sc, new_color): Modifies the grid in-place to fill the connected pixels with the new color. :param grid: List of lists representing the 2D grid. :param sr: Start row index. :param sc: Start column index. :param new_color: The new color to fill connected pixels. m, n = len(grid), len(grid[0]) original_color = grid[sr][sc] if original_color == new_color: return grid def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != original_color: return grid[x][y] = new_color dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) dfs(sr, sc) return grid def main(): # Read input import sys input = sys.stdin.read data = input().strip().split() m = int(data[0]) n = int(data[1]) new_color = int(data[2]) grid = [] idx = 3 for i in range(m): row = [int(data[idx+j]) for j in range(n)] grid.append(row) idx += n sr = int(data[idx]) sc = int(data[idx+1]) # Perform flood fill updated_grid = flood_fill(grid, sr, sc, new_color) # Print the updated grid for row in updated_grid: print(' '.join(map(str, row))) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List def min_bridges(city_map: List[List[int]]) -> int: Returns the minimum number of bridges required to connect the leftmost side of the city to the rightmost side of the city, or -1 if it is not possible. >>> min_bridges([[0, 1, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 0, 0]]) 1 >>> min_bridges([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) -1 >>> min_bridges([[0], [0], [0], [0]]) 0 >>> min_bridges([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]) 0 >>> min_bridges([[0, 1, 1, 0], [0, 0, 1, 1], [1, 0, 0, 0]]) 2","solution":"from collections import deque def min_bridges(city_map): Returns the minimum number of bridges required to connect the leftmost side of the city to the rightmost side of the city, or -1 if it is not possible. m, n = len(city_map), len(city_map[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (-1, 1), (1, -1)] def bfs(): queue = deque() visited = [[False] * n for _ in range(m)] # Enqueue the starting points in the leftmost column where construction is permissible for i in range(m): if city_map[i][0] == 0: queue.append((i, 0, 0)) # (row, col, count of bridges) visited[i][0] = True while queue: x, y, bridges = queue.popleft() # If we reach any cell in the rightmost column, return the number of bridges if y == n - 1: return bridges for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True if city_map[nx][ny] == 0: # If it's land, no additional bridge needed queue.append((nx, ny, bridges)) elif city_map[nx][ny] == 1: # If it's water, we need a bridge queue.append((nx, ny, bridges + 1)) return -1 return bfs()"},{"question":"def max_effectiveness(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determines the maximum effectiveness of any team that can be formed for given test cases. >>> max_effectiveness(3, [(5, [10, 20, 30, 40, 50]), (4, [7, 1, 8, 12]), (6, [5, 5, 5, 5, 5, 5])]) [120, 27, 15] >>> max_effectiveness(1, [(3, [5, 5, 5])]) [15] >>> max_effectiveness(1, [(4, [1000000000, 999999999, 999999998, 999999997])]) [2999999997] >>> max_effectiveness(2, [(3, [1, 2, 3]), (5, [100, 200, 300, 400, 500])]) [6, 1200] >>> max_effectiveness(1, [(3, [1, 1, 1])]) [3]","solution":"def max_effectiveness(T, test_cases): Determines the maximum effectiveness of any team that can be formed for given test cases. :param T: Number of test cases :param test_cases: A list of test cases, where each test case is a tuple (N, skills) :return: A list of maximum effectiveness values for each test case results = [] for i in range(T): N, skills = test_cases[i] skills.sort(reverse=True) max_eff = skills[0] + skills[1] + skills[2] results.append(max_eff) return results # Example usage: # T = 3 # test_cases = [(5, [10, 20, 30, 40, 50]), (4, [7, 1, 8, 12]), (6, [5, 5, 5, 5, 5, 5])] # print(max_effectiveness(T, test_cases)) # Output: [120, 27, 15]"},{"question":"from itertools import combinations from typing import List, Tuple def area_of_triangle(x1: int, y1: int, x2: int, y2: int, x3: int, y3: int) -> float: Calculate the area of triangle using the determinant method. >>> area_of_triangle(0, 0, 0, 1, 1, 0) 0.5 >>> area_of_triangle(0, 0, 1, 0, 0, 1) 0.5 >>> area_of_triangle(0, 0, 1, 1, 2, 2) 0.0 def max_triangle_area(t: int, cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[float]: Find the maximum area of the triangle that can be formed with any three stars. >>> max_triangle_area(2, [ ... (3, [(0, 0), (0, 1), (1, 0)]), ... (4, [(0, 0), (0, 1), (1, 0), (1, 1)]) ... ]) [0.5, 0.5] def process_input(input_data: str) -> Tuple[int, List[Tuple[int, List[Tuple[int, int]]]]]: Process the input data to extract the number of test cases and the cases. >>> process_input(\\"2n3n0 0n0 1n1 0n4n0 0n0 1n1 0n1 1n\\") (2, [ ... (3, [(0, 0), (0, 1), (1, 0)]), ... (4, [(0, 0), (0, 1), (1, 0), (1, 1)]) ... ]) def process_output(results: List[float]) -> str: Convert the list of results into the required string format. >>> process_output([0.5, 0.5]) '0.500000n0.500000'","solution":"from itertools import combinations from typing import List, Tuple def area_of_triangle(x1, y1, x2, y2, x3, y3): Calculate the area of triangle using the determinant method. return abs((x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2) def max_triangle_area(t: int, cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[float]: results = [] for case in cases: n = case[0] points = case[1] max_area = 0.0 for p1, p2, p3 in combinations(points, 3): area = area_of_triangle(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]) if area > max_area: max_area = area results.append(max_area) return results def process_input(input_data: str) -> Tuple[int, List[Tuple[int, List[Tuple[int, int]]]]]: lines = input_data.strip().split(\\"n\\") t = int(lines[0]) cases = [] index = 1 for _ in range(t): n = int(lines[index]) index += 1 points = [] for _ in range(n): x, y = map(int, lines[index].split()) points.append((x, y)) index += 1 cases.append((n, points)) return t, cases def process_output(results: List[float]) -> str: return \\"n\\".join(f\\"{result:.6f}\\" for result in results)"},{"question":"def day_with_max_borrowed(books_borrowed: List[int]) -> int: Given a list of integers representing the number of books borrowed each day in a month, return the day (1-indexed) with the maximum number of books borrowed. If there are multiple days with the same highest number, return the earliest day. >>> day_with_max_borrowed([100]) == 1 >>> day_with_max_borrowed([100, 200, 200, 100]) == 2 >>> day_with_max_borrowed([10, 20, 30, 40, 50]) == 5 >>> day_with_max_borrowed([50, 40, 30, 20, 10]) == 1 >>> day_with_max_borrowed([10, 20, 50, 20, 10]) == 3 >>> day_with_max_borrowed([ 120, 450, 330, 405, 382, 419, 217, 502, 289, 243, 345, 298, 390, 412, 501, 487, 396, 412, 408, 402, 502, 413, 500, 417, 499, 405, 526, 478, 524, 403 ]) == 27 pass","solution":"def day_with_max_borrowed(books_borrowed): Given a list of integers representing the number of books borrowed each day in a month, return the day (1-indexed) with the maximum number of books borrowed. If there are multiple days with the same highest number, return the earliest day. max_borrowed = books_borrowed[0] max_day = 1 for i in range(1, len(books_borrowed)): if books_borrowed[i] > max_borrowed: max_borrowed = books_borrowed[i] max_day = i + 1 return max_day"},{"question":"def simple_database(commands): Simulates a simple database using INSERT and QUERY commands. Args: commands (list): A list of strings where each string is either an INSERT or QUERY command. Returns: list: The result of QUERY commands in the order they appear. pass def test_simple_database(): commands = [ \\"INSERT myKey 123\\", \\"QUERY myKey\\", \\"INSERT anotherKey 456\\", \\"QUERY anotherKey\\", \\"INSERT myKey 789\\", \\"QUERY myKey\\", \\"QUERY nonExistentKey\\" ] expected = [\\"123\\", \\"456\\", \\"789\\", \\"NOT FOUND\\"] assert simple_database(commands) == expected def test_simple_database_single_key_update(): commands = [ \\"INSERT key1 1\\", \\"INSERT key1 2\\", \\"QUERY key1\\" ] expected = [\\"2\\"] assert simple_database(commands) == expected def test_simple_database_multiple_inserts_queries(): commands = [ \\"INSERT key1 1\\", \\"INSERT key2 2\\", \\"QUERY key1\\", \\"QUERY key2\\" ] expected = [\\"1\\", \\"2\\"] assert simple_database(commands) == expected def test_simple_database_query_non_existent(): commands = [ \\"QUERY nonExistent\\" ] expected = [\\"NOT FOUND\\"] assert simple_database(commands) == expected def test_simple_database_mixed_operations(): commands = [ \\"QUERY key1\\", \\"INSERT key1 1\\", \\"QUERY key1\\", \\"INSERT key1 2\\", \\"QUERY key1\\", \\"QUERY key2\\", \\"INSERT key2 2\\", \\"QUERY key2\\", ] expected = [\\"NOT FOUND\\", \\"1\\", \\"2\\", \\"NOT FOUND\\", \\"2\\"] assert simple_database(commands) == expected","solution":"def simple_database(commands): Simulates a simple database using INSERT and QUERY commands. Args: commands (list): A list of strings where each string is either an INSERT or QUERY command. Returns: list: The result of QUERY commands in the order they appear. database = {} results = [] for command in commands: parts = command.split() if parts[0] == \\"INSERT\\" and len(parts) == 3: key = parts[1] value = int(parts[2]) database[key] = value elif parts[0] == \\"QUERY\\" and len(parts) == 2: key = parts[1] if key in database: results.append(str(database[key])) else: results.append(\\"NOT FOUND\\") return results"},{"question":"from typing import List from itertools import permutations def count_valid_permutations(s: str) -> int: Find the total number of valid arrangements where \\"A\\" and \\"B\\" do not appear next to each other in the given set of unique characters. >>> count_valid_permutations(\\"ABC\\") 2 >>> count_valid_permutations(\\"ABCD\\") 12","solution":"from itertools import permutations def count_valid_permutations(s): Returns the number of valid permutations of the string \`s\` where characters 'A' and 'B' do not appear next to each other. def is_valid(perm): for i in range(len(perm) - 1): if (perm[i] == 'A' and perm[i+1] == 'B') or (perm[i] == 'B' and perm[i+1] == 'A'): return False return True perms = permutations(s) valid_perms = [perm for perm in perms if is_valid(perm)] return len(valid_perms)"},{"question":"def perform_queries(s: str, queries: List[Tuple[str, str]]) -> str: Replace all occurrences of characters in the string as per the queries and return the final string. :param s: Initial string :param queries: List of tuples where each tuple contains (C1, C2) :return: Modified string after performing all queries >>> perform_queries(\\"abcd\\", [(\\"a\\", \\"x\\"), (\\"b\\", \\"y\\")]) 'xycd' >>> perform_queries(\\"hello\\", [(\\"l\\", \\"x\\")]) 'hexxo' >>> perform_queries(\\"banana\\", [(\\"a\\", \\"e\\")]) 'benene' >>> perform_queries(\\"apple\\", [(\\"z\\", \\"x\\")]) 'apple' >>> perform_queries(\\"abcdabcd\\", [(\\"a\\", \\"z\\"), (\\"d\\", \\"y\\")]) 'zbcyzbcy' >>> perform_queries(\\"ababab\\", [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"c\\", \\"d\\")]) 'dddddd' pass def main(s: str, q: int, queries: List[Tuple[str, str]]) -> str: return perform_queries(s, queries)","solution":"def perform_queries(s, queries): Replace all occurrences of characters in the string as per the queries. :param s: Initial string :param queries: List of tuples where each tuple contains (C1, C2) :return: Modified string after performing all queries s_list = list(s) for c1, c2 in queries: s_list = [c2 if ch == c1 else ch for ch in s_list] return ''.join(s_list) def main(s, q, queries): return perform_queries(s, queries)"},{"question":"def productExceptSelf(nums): Given an array of integers nums, this function returns an integer array result such that result[i] is equal to the product of all the elements of nums except nums[i], calculated in O(n) time complexity and using O(1) extra space complexity (excluding the output array). Note: - Division operations are not allowed. Example: >>> productExceptSelf([1, 2, 3, 4]) [24, 12, 8, 6] >>> productExceptSelf([1, 2, 0, 4]) [0, 0, 8, 0] >>> productExceptSelf([0, 0, 0, 0]) [0, 0, 0, 0] >>> productExceptSelf([1, -2, 3, -4]) [24, -12, 8, -6] >>> productExceptSelf([1, 1, 1, 1]) [1, 1, 1, 1] >>> productExceptSelf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [3628800, 1814400, 1209600, 907200, 725760, 604800, 518400, 453600, 403200, 362880]","solution":"def productExceptSelf(nums): Returns an array such that result[i] is equal to the product of all the elements of nums except nums[i]. length = len(nums) result = [1] * length # Initialize the result array with 1s. # Calculate left products left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] # Calculate right products and the final result right_product = 1 for i in range(length-1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def find_duplicate(n: int, nums: List[int]) -> int: Identify the duplicate number in a list of n numbers where all numbers are between 1 and n-1 inclusive. >>> find_duplicate(5, [4, 3, 2, 1, 4]) 4 >>> find_duplicate(6, [1, 3, 2, 5, 4, 5]) 5","solution":"def find_duplicate(n, nums): Function to find the duplicate number in the list. num_set = set() for num in nums: if num in num_set: return num num_set.add(num) return None"},{"question":"from typing import List, Tuple def max_sum_subarray(A: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Consider an array of n integers defined as A=[a_0, a_1, ..., a_{n-1}]. Let's define function f(i, j) as the sum of all elements in the inclusive range between index i and index j in array A. In other words, f(i, j) = a_i + a_{i+1} + ... + a_j. You are supposed to answer q independent queries, where each query consists of three integers x, y, and k. Each query requires you to sort the subarray A[x] to A[y] in either ascending or descending order (your choice) and then calculate the maximum possible sum of exactly k distinct elements from this sorted subarray. Args: A (List[int]): Array of n integers. queries (List[Tuple[int, int, int]]): List of q queries. Each query is a tuple (x, y, k). Returns: List[int]: List of answers to each query. >>> max_sum_subarray([4, 1, 3, 2, 5], [(0, 3, 2)]) [7] >>> max_sum_subarray([4, 1, 3, 2, 5], [(0, 3, 2), (1, 4, 3)]) [7, 10] >>> max_sum_subarray([10, 20, 30, 40, 50], [(0, 4, 3)]) [120] >>> max_sum_subarray([1, 2, 3, 4, 5], [(2, 2, 1)]) [3] >>> max_sum_subarray([100], [(0, 0, 1)]) [100]","solution":"def max_sum_subarray(A, queries): results = [] for x, y, k in queries: subarray = A[x:y+1] subarray.sort(reverse=True) results.append(sum(subarray[:k])) return results"},{"question":"from typing import List def min_elements_to_sum(arr: List[int], target: int) -> int: Given an array of integers and a target sum, return the minimum number of elements that need to be added together to reach the target sum. If it is not possible to reach the target sum with the given array, return -1. You can use each element of the array multiple times. >>> min_elements_to_sum([1, 2, 3], 6) 2 >>> min_elements_to_sum([2, 4, 5], 11) 3 >>> min_elements_to_sum([3, 7], 5) -1 pass # Unit Tests def test_min_elements_to_sum_case1(): assert min_elements_to_sum([1, 2, 3], 6) == 2 def test_min_elements_to_sum_case2(): assert min_elements_to_sum([2, 4, 5], 11) == 3 def test_min_elements_to_sum_case3(): assert min_elements_to_sum([3, 7], 5) == -1 def test_min_elements_to_sum_single_element(): assert min_elements_to_sum([2], 8) == 4 assert min_elements_to_sum([2], 7) == -1 def test_min_elements_to_sum_large_target(): assert min_elements_to_sum([1, 5, 10, 25], 100) == 4 def test_min_elements_to_sum_impossible(): assert min_elements_to_sum([5, 10, 20], 3) == -1 assert min_elements_to_sum([6, 9], 1) == -1 def test_min_elements_to_sum_not_possible(): assert min_elements_to_sum([4, 6], 5) == -1 def test_min_elements_to_sum_zero_target(): assert min_elements_to_sum([1, 2, 3], 0) == 0 # No elements needed to form 0 def test_min_elements_to_sum_not_possible_mixed_elements(): assert min_elements_to_sum([5, 7, 8], 9) == -1","solution":"import sys from typing import List def min_elements_to_sum(arr: List[int], target: int) -> int: # Initialize a list to store the minimum elements required to form each value from 0 to target dp = [sys.maxsize] * (target + 1) # Base case: to get the sum of 0, 0 elements are needed dp[0] = 0 # Iterate through each value from 1 to target for i in range(1, target + 1): # Check each number in the array for num in arr: if i - num >= 0: dp[i] = min(dp[i], dp[i - num] + 1) # If dp[target] is still set to the max value, that means target sum cannot be formed return dp[target] if dp[target] != sys.maxsize else -1"},{"question":"def count_paths(grid): Count all distinct paths from the top-left cell to the bottom-right cell in a grid, avoiding cells with plants. Parameters: grid (List[List[int]]): 2D grid of integers representing the garden where 0 indicates an empty cell and 1 indicates a cell with a plant. Returns: int: Number of distinct paths from the top-left cell to the bottom-right cell >>> count_paths([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> count_paths([[0, 1, 0], [0, 1, 0], [0, 0, 0]]) 1 >>> count_paths([[0, 0], [0, 0]]) 2 >>> count_paths([[0]]) 1 # Your code goes here def parse_input(input_str): Parse the input string to generate the garden grid and count the distinct paths. Parameters: input_str (str): Multiline string input representing the grid configuration. Returns: int: Number of distinct paths from the top-left cell to the bottom-right cell >>> parse_input(\\"3 3n0 0 0n0 1 0n0 0 0\\") 2 >>> parse_input(\\"2 2n0 0n0 0\\") 2 >>> parse_input(\\"1 1n0\\") 1 >>> parse_input(\\"3 3n0 1 0n0 1 0n0 0 0\\") 1 >>> parse_input(\\"3 3n0 0 0n1 1 1n0 0 0\\") 0 # Your code goes here","solution":"def count_paths(grid): R = len(grid) C = len(grid[0]) # Create a DP array dp = [[0]*C for _ in range(R)] # Initializing the starting point if grid[0][0] == 0: dp[0][0] = 1 # Fill the dp array for i in range(R): for j in range(C): if grid[i][j] == 0: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1] def parse_input(input_str): lines = input_str.strip().split('n') R, C = map(int, lines[0].strip().split()) grid = [list(map(int, line.strip().split())) for line in lines[1:]] return count_paths(grid)"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def verticalOrderTraversal(root: Optional[TreeNode]) -> List[List[int]]: Given a binary tree, write a function that returns the vertical order traversal of the tree nodes' values. Args: root (Optional[TreeNode]): The root node of the binary tree. Returns: List[List[int]]: A list of lists where each sub-list contains the values of nodes in vertical order from leftmost to rightmost. Example: >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> verticalOrderTraversal(root) [[9], [3, 15], [20], [7]] pass def test_vertical_order_single_node(): root = TreeNode(1) assert verticalOrderTraversal(root) == [[1]] def test_vertical_order_two_levels(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) assert verticalOrderTraversal(root) == [[2], [1], [3]] def test_vertical_order_complex_tree(): root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) assert verticalOrderTraversal(root) == [[9], [3, 15], [20], [7]] def test_vertical_order_tree_with_multiple_levels(): root = TreeNode(1) root.left = TreeNode(2, TreeNode(4), TreeNode(5)) root.right = TreeNode(3, TreeNode(6), TreeNode(7)) assert verticalOrderTraversal(root) == [[4], [2], [1, 5, 6], [3], [7]] def test_vertical_order_tree_with_negative_values(): root = TreeNode(-1) root.left = TreeNode(-2) root.right = TreeNode(-3) root.left.left = TreeNode(-4) root.left.right = TreeNode(-5) assert verticalOrderTraversal(root) == [[-4], [-2], [-1, -5], [-3]]","solution":"from collections import defaultdict, deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def verticalOrderTraversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] column_table = defaultdict(list) queue = deque([(root, 0)]) while queue: node, column = queue.popleft() if node is not None: column_table[column].append(node.val) queue.append((node.left, column - 1)) queue.append((node.right, column + 1)) sorted_columns = sorted(column_table.keys()) return [column_table[col] for col in sorted_columns]"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring of s that contains no more than two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"aaaa\\") 4 >>> length_of_longest_substring_two_distinct(\\"abcdef\\") 2 >>> length_of_longest_substring_two_distinct(\\"aabbcc\\") 4 >>> length_of_longest_substring_two_distinct(\\"\\") 0 >>> length_of_longest_substring_two_distinct(\\"bbbbbb\\") 6 >>> length_of_longest_substring_two_distinct(\\"abc\\" * 10000) 2","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring of s that contains no more than two distinct characters. n = len(s) if n < 3: return n left, right = 0, 0 char_map = {} max_length = 2 while right < n: # Add new character to the map char_map[s[right]] = char_map.get(s[right], 0) + 1 right += 1 # When we have more than 2 distinct characters while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 # Update max length max_length = max(max_length, right - left) return max_length"},{"question":"def is_valid_parentheses(s: str) -> bool: Returns True if the string contains valid parentheses, otherwise False. Args: s (str): A string containing characters '(', ')', '{', '}', '[' and ']'. Returns: bool: True if the string contains valid parentheses, False otherwise. Examples: >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\"()[]{}\\") True >>> is_valid_parentheses(\\"(]\\") False >>> is_valid_parentheses(\\"([)]\\") False >>> is_valid_parentheses(\\"{[]}\\") True","solution":"def is_valid_parentheses(s): Returns True if the string contains valid parentheses, otherwise False. stack = [] mapping = {')': '(', '}': '{', ']': '['} for char in s: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def find_rank(M, P, scores, id_to_check): Finds the rank of the participant with the specified ID based on their scores. Args: M (int): Number of participants. P (int): Number of problems solved in the tournament. scores (list of tuples): A list of tuples where each tuple contains (id, score). id_to_check (int): The participant ID whose rank needs to be determined. Returns: int: The rank of the participant with the given ID to check. >>> find_rank(3, 5, [(1, 90), (2, 95), (3, 90)], 1) 2 >>> find_rank(4, 2, [(1, 180), (2, 100), (3, 180), (4, 200)], 2) 4 # Implementation goes here def process_input(input_data): Processes the input data for multiple datasets to find ranks of the specified participant IDs. Args: input_data (list of str): List of input lines as strings. Returns: list of int: List of ranks for each dataset. >>> input_data = [ ... \\"3 5\\", ... \\"1 90\\", ... \\"2 95\\", ... \\"3 90\\", ... \\"1\\", ... \\"4 2\\", ... \\"1 180\\", ... \\"2 100\\", ... \\"3 180\\", ... \\"4 200\\", ... \\"2\\", ... \\"0\\" ... ] >>> process_input(input_data) [2, 4] # Implementation goes here","solution":"def find_rank(M, P, scores, id_to_check): Finds the rank of the participant with the specified ID based on their scores. Args: M (int): Number of participants. P (int): Number of problems solved in the tournament (not used in this function). scores (list of tuples): A list of tuples where each tuple contains (id, score). id_to_check (int): The participant ID whose rank needs to be determined. Returns: int: The rank of the participant with the given ID to check. # Sort scores in descending order based on the score ranked_scores = sorted(scores, key=lambda x: x[1], reverse=True) rank = 1 current_score = ranked_scores[0][1] id_to_rank = {} for i, (pid, score) in enumerate(ranked_scores): if score < current_score: rank = i + 1 current_score = score id_to_rank[pid] = rank return id_to_rank[id_to_check] def process_input(input_data): Processes the input data for multiple datasets to find ranks of the specified participant IDs. Args: input_data (list of str): List of input lines as strings. Returns: list of int: List of ranks for each dataset. ranks = [] idx = 0 while idx < len(input_data): line = input_data[idx].strip() if line == '0': break M, P = map(int, line.split()) idx += 1 scores = [] for _ in range(M): parts = input_data[idx].strip().split() pid = int(parts[0]) score = int(parts[1]) scores.append((pid, score)) idx += 1 id_to_check = int(input_data[idx].strip()) idx += 1 rank = find_rank(M, P, scores, id_to_check) ranks.append(rank) return ranks"},{"question":"def max_profit(prices): This function calculates the maximum profit that can be made by buying and then later selling an item given a list of prices for a number of days. Parameters: prices (list): List of prices indexed by day Returns: int: Maximum profit achievable. 0 if no profit can be made. Examples: >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 # Implement the function here def compute_max_profits(test_cases): This function processes multiple test cases to determine the maximum profit that can be made for each test case. Parameters: test_cases (list of tuples): Each tuple contains the number of days and the corresponding list of prices. Returns: list: List of maximum profits for each test case. Examples: >>> compute_max_profits([(6, [7, 1, 5, 3, 6, 4]), (5, [7, 6, 4, 3, 1])]) [5, 0] # Implement the function here # Unit Tests def test_max_profit(): assert max_profit([7, 1, 5, 3, 6, 4]) == 5 assert max_profit([7, 6, 4, 3, 1]) == 0 assert max_profit([1, 2, 3, 4, 5]) == 4 assert max_profit([5, 4, 3, 2, 1]) == 0 assert max_profit([1]) == 0 assert max_profit([]) == 0 assert max_profit([1, 7, 5, 3, 6, 4, 8]) == 7 def test_compute_max_profits(): test_cases = [ (6, [7, 1, 5, 3, 6, 4]), (5, [7, 6, 4, 3, 1]) ] assert compute_max_profits(test_cases) == [5, 0] test_cases = [ (5, [1, 2, 3, 4, 5]), (5, [5, 4, 3, 2, 1]), (1, [1]) ] assert compute_max_profits(test_cases) == [4, 0, 0] # You can run the tests to check your implementation by calling # test_max_profit() # test_compute_max_profits()","solution":"def max_profit(prices): This function calculates the maximum profit that can be made by buying and then later selling an item given a list of prices for a number of days. if not prices or len(prices) < 2: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit def compute_max_profits(test_cases): results = [] for case in test_cases: n, prices = case results.append(max_profit(prices)) return results"},{"question":"from typing import List def transform_array(arr: List[int], k: int) -> List[int]: Transform the array into a new array where each element is the sum of the next k elements (including the element itself). Args: arr (List[int]): An array of integers. k (int): A positive integer indicating the number of elements to sum. Returns: List[int]: A new array with the transformed values. Examples: >>> transform_array([1, 2, 3, 4, 5], 3) [6, 9, 12, 9, 5] >>> transform_array([10, 20, 30, 40], 2) [30, 50, 70, 40]","solution":"from typing import List def transform_array(arr: List[int], k: int) -> List[int]: n = len(arr) result = [] for i in range(n): sum_value = sum(arr[i:i+k]) result.append(sum_value) return result"},{"question":"def min_cost_to_buy_fruits(T: int, test_cases: List[Tuple[int, int, int, List[Tuple[int, int, int]]]]) -> List[int]: Calculate the minimum cost to buy exactly m apples and n bananas from the given bundles or determine if it is impossible. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, int, List[Tuple[int, int, int]]]]): List of test cases, each containing k (number of vendors), m (required apples), n (required bananas), and a list of bundles (a, b, c) where a is the number of apples, b is the number of bananas, and c is the cost of the bundle. Returns: List[int]: List of minimum costs for each test case, or -1 if it is not possible to get the exact number of fruits required. Example: >>> T = 2 >>> test_cases = [ >>> (3, 5, 5, [(3, 2, 10), (4, 4, 20), (2, 3, 7)]), >>> (1, 0, 0, [(1, 1, 1)]) >>> ] >>> min_cost_to_buy_fruits(T, test_cases) [17, 0] >>> T = 1 >>> test_cases = [ >>> (4, 8, 8, [(4, 4, 5), (4, 4, 5), (4, 4, 10), (5, 5, 10)]) >>> ] >>> min_cost_to_buy_fruits(T, test_cases) [10] >>> T = 1 >>> test_cases = [ >>> (3, 5, 5, [(0, 0, 0), (0, 0, 0), (0, 0, 0)]) >>> ] >>> min_cost_to_buy_fruits(T, test_cases) [-1]","solution":"def min_cost_to_buy_fruits(T, test_cases): def knapsack(k, bundles, m, n): dp = [[float('inf')] * (n + 1) for _ in range(m + 1)] dp[0][0] = 0 for a, b, c in bundles: for i in range(m, -1, -1): for j in range(n, -1, -1): if dp[i][j] != float('inf'): new_a = min(i + a, m) new_b = min(j + b, n) dp[new_a][new_b] = min(dp[new_a][new_b], dp[i][j] + c) return dp[m][n] if dp[m][n] != float('inf') else -1 results = [] for case in test_cases: k, m, n, bundles = case result = knapsack(k, bundles, m, n) results.append(result) return results"},{"question":"from collections import defaultdict, deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def verticalTraversal(root): Given a binary tree, return the vertical order traversal of its nodes values. If two nodes are in the same row and column, the order should be from left to right. :param TreeNode root: Root of the binary tree. :return List[List[int]]: Vertical order traversal from left to right. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20, TreeNode(15), TreeNode(7)) >>> verticalTraversal(root) [[9], [3, 15], [20], [7]] >>> root = TreeNode(1) >>> root.left = TreeNode(2, TreeNode(4), TreeNode(5)) >>> root.right = TreeNode(3, TreeNode(6), TreeNode(7)) >>> verticalTraversal(root) [[4], [2], [1, 5, 6], [3], [7]] if not root: return [] col_table = defaultdict(list) queue = deque([(root, 0, 0)]) # (node, col, row) while queue: node, col, row = queue.popleft() if node is not None: col_table[col].append((row, node.val)) queue.append((node.left, col - 1, row + 1)) queue.append((node.right, col + 1, row + 1)) # Sort by column, then by row, then value sorted_col_table = sorted(col_table.items()) result = [] for col, col_values in sorted_col_table: col_values.sort() # Sort by row first, then value result.append([val for row, val in col_values]) return result","solution":"from collections import defaultdict, deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def verticalTraversal(root): Returns the vertical order traversal of binary tree nodes. :param TreeNode root: Root of the binary tree. :return List[List[int]]: Vertical order traversal from left to right. if not root: return [] col_table = defaultdict(list) queue = deque([(root, 0, 0)]) # (node, col, row) while queue: node, col, row = queue.popleft() if node is not None: col_table[col].append((row, node.val)) queue.append((node.left, col - 1, row + 1)) queue.append((node.right, col + 1, row + 1)) # Sort by column, then by row, then value sorted_col_table = sorted(col_table.items()) result = [] for col, col_values in sorted_col_table: col_values.sort() # Sort by row first, then value result.append([val for row, val in col_values]) return result"},{"question":"def num_of_rectangles(N, M): Computes the number of rectangles that can be formed in an N x M grid. Parameters: N (int): Number of rows in the grid M (int): Number of columns in the grid Returns: int: Total number of rectangles >>> num_of_rectangles(2, 3) 18 >>> num_of_rectangles(1, 3) 6 >>> num_of_rectangles(3, 1) 6 >>> num_of_rectangles(3, 3) 36 >>> num_of_rectangles(1000, 1000) 250500250000 >>> num_of_rectangles(1, 1) 1","solution":"def num_of_rectangles(N, M): Computes the number of rectangles that can be formed in an N x M grid. Parameters: N (int): Number of rows in the grid M (int): Number of columns in the grid Returns: int: Total number of rectangles # Calculate the number of ways to choose 2 lines from N+1 horizontal lines and M+1 vertical lines total_rectangles = (N * (N + 1) // 2) * (M * (M + 1) // 2) return total_rectangles"},{"question":"from typing import List, Tuple def closest_distance(n: int, coordinates: List[Tuple[int, int]]) -> str: Given a list of n points on a 2D plane, determine the pair of points that are the closest to each other and compute the Euclidean distance between them. >>> closest_distance(2, [(0, 0), (3, 4)]) == \\"5.000000\\" >>> closest_distance(3, [(1, 1), (2, 2), (4, 4)]) == \\"1.414214\\" >>> closest_distance(2, [(0, 0), (0, 0)]) == \\"0.000000\\" >>> closest_distance(3, [(1, 1), (2, 1), (4, 1)]) == \\"1.000000\\" >>> closest_distance(3, [(1, 1), (1, 2), (1, 4)]) == \\"1.000000\\" >>> closest_distance(2, [(1000000000, 1000000000), (-1000000000, -1000000000)]) == \\"2828427124.746190\\" pass import pytest def test_example1(): assert closest_distance(2, [(0, 0), (3, 4)]) == \\"5.000000\\" def test_example2(): assert closest_distance(3, [(1, 1), (2, 2), (4, 4)]) == \\"1.414214\\" def test_same_point(): assert closest_distance(2, [(0, 0), (0, 0)]) == \\"0.000000\\" def test_horizontal_points(): assert closest_distance(3, [(1, 1), (2, 1), (4, 1)]) == \\"1.000000\\" def test_vertical_points(): assert closest_distance(3, [(1, 1), (1, 2), (1, 4)]) == \\"1.000000\\" def test_large_coordinates(): assert closest_distance(2, [(1000000000, 1000000000), (-1000000000, -1000000000)]) == \\"2828427124.746190\\"","solution":"import math import itertools def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def closest_pair_of_points(points): min_distance = float('inf') closest_pair = None # Sort points by x coordinate points.sort() for i, p1 in enumerate(points): for p2 in points[i+1:]: # Break early if the x difference is larger than the current min distance if p2[0] - p1[0] > min_distance: break distance = euclidean_distance(p1, p2) if distance < min_distance: min_distance = distance closest_pair = (p1, p2) return min_distance def closest_distance(n, coordinates): points = [tuple(coord) for coord in coordinates] distance = closest_pair_of_points(points) return f\\"{distance:.6f}\\""},{"question":"def sumOfSquares(N: int) -> int: Returns the sum of squares of the first N natural numbers. Args: N : int : The number of natural numbers to consider Returns: int : Sum of squares of the first N natural numbers Examples: >>> sumOfSquares(3) 14 >>> sumOfSquares(5) 55","solution":"def sumOfSquares(N): Returns the sum of squares of the first N natural numbers. return N * (N + 1) * (2 * N + 1) // 6"},{"question":"from typing import List def trap_water(heights: List[int]) -> int: Calculate the total amount of water trapped after raining given the heights of buildings. Args: heights (List[int]): A list of integers representing the heights of buildings. Returns: int: The total amount of water trapped. Example: >>> trap_water([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_water([4,2,0,3,2,5]) 9 pass","solution":"from typing import List def trap_water(heights: List[int]) -> int: Calculate the total amount of water trapped after raining given the heights of buildings. Args: heights (List[int]): A list of integers representing the heights of buildings. Returns: int: The total amount of water trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Compute the maximum height to the left of each building left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Compute the maximum height to the right of each building right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the water trapped at each building for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def is_corridor_secure(datasets) -> list: Determines whether the corridor is securely covered by the given intervals of the sensors. Each dataset contains the number of sensors and their respective intervals. Args: datasets (list): A list of tuples where each tuple contains an integer n and a list of n intervals. Returns: list: A list containing \\"Secure\\" or \\"Not Secure\\" for each dataset. Examples: >>> is_corridor_secure([(3, [(1, 4), (2, 5), (3, 6)]), (4, [(1, 2), (3, 4), (5, 6), (7, 8)])]) [\\"Secure\\", \\"Not Secure\\"] >>> is_corridor_secure([(1, [(1, 4)])]) [\\"Not Secure\\"] >>> is_corridor_secure([(3, [(1, 5), (4, 10), (9, 15)])]) [\\"Secure\\"] pass def test_is_corridor_secure(): datasets = [ (3, [(1, 4), (2, 5), (3, 6)]), (4, [(1, 2), (3, 4), (5, 6), (7, 8)]) ] assert is_corridor_secure(datasets) == [\\"Secure\\", \\"Not Secure\\"] def test_single_sensor(): datasets = [ (1, [(1, 4)]) ] assert is_corridor_secure(datasets) == [\\"Not Secure\\"] def test_overlapping_intervals(): datasets = [ (3, [(1, 5), (4, 10), (9, 15)]) ] assert is_corridor_secure(datasets) == [\\"Secure\\"] def test_non_overlapping_intervals(): datasets = [ (2, [(1, 2), (3, 4)]) ] assert is_corridor_secure(datasets) == [\\"Not Secure\\"] def test_adjacent_intervals(): datasets = [ (2, [(1, 3), (3, 5)]) ] assert is_corridor_secure(datasets) == [\\"Secure\\"]","solution":"def is_corridor_secure(datasets): results = [] for data in datasets: n, intervals = data if n == 1: results.append(\\"Not Secure\\") continue intervals.sort() secure = False for i in range(len(intervals) - 1): if intervals[i][1] >= intervals[i + 1][0]: secure = True break if secure: results.append(\\"Secure\\") else: results.append(\\"Not Secure\\") return results"},{"question":"def find_worst_case_latency_and_count(n, edges): Determines the maximum latency for any pair of employees and counts the number of pairs having this maximum latency. >>> find_worst_case_latency_and_count(4, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 4, 9), (1, 3, 2)]) == (9, 1) >>> find_worst_case_latency_and_count(3, [(1, 2, 3), (2, 3, 4), (1, 3, 5)]) == (5, 1) pass def solve(test_cases): Processes multiple test cases to find worst-case latency and count for each one. >>> input_data = [ ... (4, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 4, 9), (1, 3, 2)]), ... (3, 3, [(1, 2, 3), (2, 3, 4), (1, 3, 5)]) ...] >>> solve(input_data) == [\\"9 1\\", \\"5 1\\"] pass def main(input_data): Parses input, processes it, and prints the results. >>> input_data = \\"2n4 5n1 2 3n2 3 4n3 4 5n1 4 9n1 3 2n3 3n1 2 3n2 3 4n1 3 5n\\" pass","solution":"import heapq import sys def floyd_warshall(n, edges): dist = [[sys.maxsize] * (n + 1) for _ in range(n + 1)] for i in range(1, n + 1): dist[i][i] = 0 for u, v, w in edges: dist[u][v] = w dist[v][u] = w for k in range(1, n + 1): for i in range(1, n + 1): for j in range(1, n + 1): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist def find_worst_case_latency_and_count(n, edges): dist = floyd_warshall(n, edges) max_latency = 0 count = 0 for i in range(1, n + 1): for j in range(i + 1, n + 1): if dist[i][j] != sys.maxsize: if dist[i][j] > max_latency: max_latency = dist[i][j] count = 1 elif dist[i][j] == max_latency: count += 1 return max_latency, count def solve(test_cases): results = [] for n, m, edges in test_cases: max_latency, count = find_worst_case_latency_and_count(n, edges) results.append(f\\"{max_latency} {count}\\") return results def main(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N, M = map(int, input_lines[index].split()) edges = [] for i in range(M): u, v, w = map(int, input_lines[index + 1 + i].split()) edges.append((u, v, w)) test_cases.append((N, M, edges)) index += M + 1 results = solve(test_cases) for result in results: print(result)"},{"question":"def binary_queries(n, q, binary_strings, queries): Perform two types of queries on a list of binary numbers. Args: n (int): number of binary strings. q (int): number of queries. binary_strings (List[str]): list of binary strings. queries (List[Tuple[int, int, int]]): list of queries. Returns: List[int]: results of type 1 queries. Example: >>> binary_queries(4, 3, [\\"0101\\", \\"1010\\", \\"1111\\", \\"0011\\"], [(1, 2, 3), (2, 1, 4), (1, 2, 4)]) [10, 0] >>> binary_queries(3, 2, [\\"001\\", \\"010\\", \\"011\\"], [(1, 1, 3), (2, 1, 2)]) [0] pass def test_binary_queries(): n = 4 q = 3 binary_strings = [\\"0101\\", \\"1010\\", \\"1111\\", \\"0011\\"] queries = [(1, 2, 3), (2, 1, 4), (1, 2, 4)] expected_output = [10, 0] assert binary_queries(n, q, binary_strings, queries) == expected_output n = 3 q = 2 binary_strings = [\\"001\\", \\"010\\", \\"011\\"] queries = [(1, 1, 3), (2, 1, 2)] expected_output = [0] assert binary_queries(n, q, binary_strings, queries) == expected_output n = 2 q = 2 binary_strings = [\\"01\\", \\"10\\"] queries = [(1, 1, 2), (1, 1, 1)] expected_output = [0, 1] assert binary_queries(n, q, binary_strings, queries) == expected_output n = 5 q = 2 binary_strings = [\\"0001\\", \\"0010\\", \\"0100\\", \\"1000\\", \\"1111\\"] queries = [(2, 1, 5), (1, 1, 4)] expected_output = [0] assert binary_queries(n, q, binary_strings, queries) == expected_output import pytest pytest.main()","solution":"def binary_queries(n, q, binary_strings, queries): def bitwise_and_of_range(l, r): result = int(binary_strings[l], 2) for i in range(l + 1, r + 1): result &= int(binary_strings[i], 2) return result def increment_binaries(l, r): for i in range(l, r + 1): binary_str = binary_strings[i] incremented = bin(int(binary_str, 2) + 1)[2:] if len(incremented) > len(binary_str): incremented = incremented[1:] else: incremented = incremented.zfill(len(binary_str)) binary_strings[i] = incremented binary_strings = [bin_str.zfill(30) for bin_str in binary_strings] results = [] for query in queries: if query[0] == 1: l, r = query[1] - 1, query[2] - 1 results.append(bitwise_and_of_range(l, r)) elif query[0] == 2: l, r = query[1] - 1, query[2] - 1 increment_binaries(l, r) return results"},{"question":"def quality_spread(t: int, runs: List[Tuple[int, List[int]]]) -> List[int]: Determine the difference between the highest and the lowest quality score for each production run. >>> quality_spread(3, [(5, [3, 6, 9, 2, 8]), (4, [15, 20, 3, 7]), (3, [5, 5, 5])]) [7, 17, 0] >>> quality_spread(1, [(4, [10, 20, 30, 40])]) [30] >>> quality_spread(2, [(3, [7, 7, 7]), (2, [42, 42])]) [0, 0] >>> quality_spread(2, [(3, [1, 1000000000, 500]), (5, [5, 9, 7, 3, 10])]) [999999999, 7]","solution":"def quality_spread(t, runs): results = [] for i in range(t): n = runs[i][0] scores = runs[i][1] spread = max(scores) - min(scores) results.append(spread) return results"},{"question":"def canCompleteCircuit(gas, cost): Returns the starting gas station's index if it is possible to travel around the circuit once. Otherwise, returns -1. >>> canCompleteCircuit([1,2,3,4,5], [3,4,5,1,2]) 3 >>> canCompleteCircuit([2,3,4], [3,4,3]) -1 >>> canCompleteCircuit([4,4,4,4], [4,4,4,4]) 0 >>> canCompleteCircuit([1,2,3,4], [2,2,2,5]) -1 >>> canCompleteCircuit([5,1,2,3,4], [4,4,1,5,1]) 4 >>> canCompleteCircuit([1], [0]) 0 >>> canCompleteCircuit([1], [2]) -1","solution":"def canCompleteCircuit(gas, cost): Returns the starting gas station's index if it is possible to travel around the circuit once. Otherwise, returns -1. total_tank, curr_tank = 0, 0 starting_station = 0 for i in range(len(gas)): total_tank += gas[i] - cost[i] curr_tank += gas[i] - cost[i] # If curr_tank drops below zero, we cannot start from this station or any stations before it if curr_tank < 0: starting_station = i + 1 curr_tank = 0 return starting_station if total_tank >= 0 else -1"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Write a function that takes a list of integers and returns a new list where each integer is replaced by the product of all the integers in the original list except the integer at the current position. Args: nums (List[int]): A list of integers where 2 <= len(nums) <= 10^4 and -100 <= nums[i] <= 100. Returns: List[int]: A list of integers where each integer is the product of all other integers in the input list. Examples: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6]","solution":"def product_except_self(nums): Returns a list such that, for each element at index i of the output list, is the product of all the numbers in the original list except nums[i]. # Initialize the length of nums length = len(nums) # Create two empty arrays to hold the prefix and suffix products prefix = [1] * length suffix = [1] * length result = [1] * length # Populate the prefix array for i in range(1, length): prefix[i] = prefix[i - 1] * nums[i - 1] # Populate the suffix array for i in range(length - 2, -1, -1): suffix[i] = suffix[i + 1] * nums[i + 1] # Populate the result array for i in range(length): result[i] = prefix[i] * suffix[i] return result"},{"question":"import heapq from collections import defaultdict from typing import List, Tuple def find_min_travel_time(N: int, portals: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Given the number of cities N and a list of portals with their travel costs, find the minimum travel time required for each query from city A to city B. >>> find_min_travel_time(5, [(1, 2, 10), (1, 3, 20), (2, 3, 30), (3, 4, 5), (4, 5, 2), (3, 5, 15)], [(1, 5), (2, 4)]) [27, 35] >>> find_min_travel_time(4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1)], [(1, 3)]) [2] >>> find_min_travel_time(3, [(1, 2, 5)], [(1, 3)]) [-1] pass def solve_teleportation_queries(T: int, configurations: List[Tuple[int, int, int, List[Tuple[int, int, int]], List[Tuple[int, int]]]]) -> List[int]: Solve teleportation queries for T test cases, each with corresponding city counts, portal definitions, and travel queries. >>> solve_teleportation_queries(2, [ (5, 6, 2, [(1, 2, 10), (1, 3, 20), (2, 3, 30), (3, 4, 5), (4, 5, 2), (3, 5, 15)], [(1, 5), (2, 4)]), (4, 4, 1, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1)], [(1, 3)]) ]) [27, 35, 2] pass","solution":"import heapq import sys from collections import defaultdict def find_min_travel_time(N, portals, queries): def dijkstra(graph, start, end): # Min-heap to get the city with the least travel time heap = [(0, start)] distances = {i: float('inf') for i in range(1, N+1)} distances[start] = 0 while heap: current_distance, current_city = heapq.heappop(heap) if current_city == end: return current_distance for neighbor, weight in graph[current_city]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) return -1 # Build the graph graph = defaultdict(list) for u, v, w in portals: graph[u].append((v, w)) graph[v].append((u, w)) results = [] for A, B in queries: results.append(dijkstra(graph, A, B)) return results def solve_teleportation_queries(T, configurations): results = [] for i in range(T): N, M, K, portals, queries = configurations[i] results.extend(find_min_travel_time(N, portals, queries)) return results"},{"question":"def calculate_adjusted_scores(players_scores): Given the scores of each player over multiple rounds, calculate the final adjusted score for each player. The adjusted score is the sum of all scores minus the lowest score. If a player has only one round, their score is 0. >>> calculate_adjusted_scores([[5, 10, 20, 30, 40, 50], [2, 5, 15], [1, 100]]) [140, 15, 0] >>> calculate_adjusted_scores([[3, 1, 2, 3], [4, 6, 7, 8, 9]]) [5, 24] pass def get_input_output(data): Parses the input, computes the adjusted scores, and returns the output as a string. >>> get_input_output(\\"3n5 10 20 30 40 50n2 5 15n1 100\\") '140n15n0' >>> get_input_output(\\"2n3 1 2 3n4 6 7 8 9\\") '5n24' pass","solution":"def calculate_adjusted_scores(players_scores): adjusted_scores = [] for player_scores in players_scores: num_rounds = player_scores[0] scores = player_scores[1:] if num_rounds == 1: adjusted_scores.append(0) else: total_score = sum(scores) lowest_score = min(scores) adjusted_score = total_score - lowest_score adjusted_scores.append(adjusted_score) return adjusted_scores def get_input_output(data): lines = data.strip().split(\\"n\\") p = int(lines[0]) players_scores = [list(map(int, lines[i+1].split())) for i in range(p)] result = calculate_adjusted_scores(players_scores) return \\"n\\".join(map(str, result))"},{"question":"def can_form_target(source: str, target: str) -> bool: Determines if the target word can be constructed from the source phrase. Args: source (str): The source phrase. target (str): The target word. Returns: bool: True if the target word can be constructed, otherwise False. >>> can_form_target(\\"a quick brown fox\\", \\"quick\\") True >>> can_form_target(\\"the eyes\\", \\"they see\\") True >>> can_form_target(\\"hello world\\", \\"lowheld\\") False","solution":"def can_form_target(source, target): Determines if the target word can be constructed from the source phrase. Args: source (str): The source phrase. target (str): The target word. Returns: bool: True if the target word can be constructed, otherwise False. from collections import Counter # Normalize both strings: remove spaces and convert to lower case normalized_source = source.replace(\\" \\", \\"\\").lower() normalized_target = target.replace(\\" \\", \\"\\").lower() # Count frequency of each character in both strings source_counter = Counter(normalized_source) target_counter = Counter(normalized_target) # Check if all characters and their counts in target are in source for char, count in target_counter.items(): if source_counter[char] < count: return False return True"},{"question":"from typing import List, Union def find_median(nums: List[Union[int, float]]) -> Union[int, float, None]: Finds the median of a list of numbers. :param nums: List of integers or floats. :return: Median of the list or None if the list is empty. >>> find_median([1, 3, 2]) 2 >>> find_median([1, 4, 3, 2]) 2.5 >>> find_median([]) None >>> find_median([1]) 1 >>> find_median([1.5, 2.5, 3.5]) 2.5 >>> find_median([1, 2.2, 3, 4.4]) 2.6 >>> find_median([-3, -1, -2]) -2 >>> find_median([1, 1, 1, 1]) 1","solution":"from typing import List, Union def find_median(nums: List[Union[int, float]]) -> Union[int, float, None]: Finds the median of a list of numbers. :param nums: List of integers or floats. :return: Median of the list or None if the list is empty. n = len(nums) if n == 0: return None sorted_nums = sorted(nums) if n % 2 == 1: return sorted_nums[n // 2] else: return (sorted_nums[n // 2 - 1] + sorted_nums[n // 2]) / 2"},{"question":"from typing import List, Tuple def min_swaps_to_transform(a: List[int], b: List[int]) -> int: Determine the minimum number of swap operations required to transform array \`a\` into array \`b\`. If it is not possible to transform array \`a\` into array \`b\`, return -1. pass def process_cases(test_cases: List[Tuple[int, List[int], List[int]]]) -> List[int]: Process multiple test cases to determine the minimum number of swap operations for each case. pass def test_min_swaps_to_transform(): # Test case 1 assert min_swaps_to_transform([1, 3, 2, 4], [3, 1, 2, 4]) == 1 # Test case 2 assert min_swaps_to_transform([2, 1, 3], [1, 2, 3]) == 1 # Test case 3 assert min_swaps_to_transform([4, 3, 2, 1], [1, 2, 3, 4]) == 6 # Test case with no possible transformation assert min_swaps_to_transform([1, 2, 3], [1, 2, 2]) == -1 # Test case with already sorted arrays assert min_swaps_to_transform([1, 2, 3, 4], [1, 2, 3, 4]) == 0 # Test case with reverse order arrays assert min_swaps_to_transform([4, 3, 2, 1], [1, 2, 3, 4]) == 6 # Test case with different lengths (invalid by problem constraints, for robustness) assert min_swaps_to_transform([1, 2], [1, 2, 3]) == -1 def test_process_cases(): test_cases = [ (4, [1, 3, 2, 4], [3, 1, 2, 4]), (3, [2, 1, 3], [1, 2, 3]), (4, [4, 3, 2, 1], [1, 2, 3, 4]) ] expected_results = [1, 1, 6] assert process_cases(test_cases) == expected_results if __name__ == \\"__main__\\": test_min_swaps_to_transform() test_process_cases() print(\\"All tests passed!\\")","solution":"def min_swaps_to_transform(a, b): from collections import Counter if Counter(a) != Counter(b): return -1 swaps = 0 a = list(a) for i in range(len(a)): for j in range(len(a) - 1, i, -1): if a[j] == b[i]: for k in range(j, i, -1): a[k], a[k - 1] = a[k - 1], a[k] swaps += 1 break return swaps def process_cases(test_cases): results = [] for n, a, b in test_cases: results.append(min_swaps_to_transform(a, b)) return results"},{"question":"def checkPangram(s: str) -> str: Determines if the string contains all the letters of the English alphabet at least once. Parameters: s (str): The string to check Returns: str: \\"pangram\\" if the string is a pangram, \\"not pangram\\" otherwise >>> checkPangram(\\"The quick brown fox jumps over the lazy dog\\") \\"pangram\\" >>> checkPangram(\\"We promptly judged antique ivory buckles for the prize\\") \\"not pangram\\"","solution":"def checkPangram(s): Determines if the string contains all the letters of the English alphabet at least once. Parameters: s (str): The string to check Returns: str: \\"pangram\\" if the string is a pangram, \\"not pangram\\" otherwise # Create a set containing all the letters of the alphabet alphabet = set(\\"abcdefghijklmnopqrstuvwxyz\\") # Convert the input string to lowercase and create a set of characters from it s = s.lower() letters_in_s = set(s) # Check if all the letters of the alphabet are in the set of characters from the input string if alphabet.issubset(letters_in_s): return \\"pangram\\" else: return \\"not pangram\\""},{"question":"def subsequence_occurrences(s: str, t: str) -> int: Returns the number of distinct subsequences of \`t\` that can be found in \`s\`. >>> subsequence_occurrences(\\"babgbag\\", \\"bag\\") 5 >>> subsequence_occurrences(\\"rabbbit\\", \\"rabbit\\") 3 >>> subsequence_occurrences(\\"abcdef\\", \\"gh\\") 0 >>> subsequence_occurrences(\\"abc\\", \\"abc\\") 1 >>> subsequence_occurrences(\\"aaa\\", \\"a\\") 3 >>> subsequence_occurrences(\\"abcdef\\", \\"\\") 1 >>> subsequence_occurrences(\\"\\", \\"abc\\") 0","solution":"def subsequence_occurrences(s: str, t: str) -> int: Returns the number of distinct subsequences of \`t\` that can be found in \`s\`. m, n = len(s), len(t) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): dp[i][0] = 1 for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] return dp[m][n]"},{"question":"def maxBananas(grid: List[List[int]]) -> int: Returns the maximum number of bananas the monkey can collect when moving from the bottom-left corner to the top-right corner of the grid. >>> grid = [ ... [0, 1, 0], ... [1, 0, 1], ... [0, 1, 0] ... ] >>> maxBananas(grid) 2 >>> grid = [ ... [1, 0, 1] ... ] >>> maxBananas(grid) 2 >>> grid = [ ... [1], ... [0], ... [1] ... ] >>> maxBananas(grid) 2 >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> maxBananas(grid) 0 >>> grid = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> maxBananas(grid) 5","solution":"def maxBananas(grid): Returns the maximum number of bananas the monkey can collect when moving from the bottom-left corner to the top-right corner of the grid. m, n = len(grid), len(grid[0]) # Create a DP table with the same dimensions as the grid dp = [[0] * n for _ in range(m)] # Initialize the bottom-left corner dp[0][0] = grid[0][0] # Fill the first row (only can move from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (only can move from below) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the grid for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The answer is in the bottom-right corner return dp[-1][-1]"},{"question":"def rank_teams(input_scores: List[str]) -> List[Tuple[int, int]]: Rank the teams based on their best solution scores and the sum of their scores in case of a tie. Params: input_scores (List[str]): Each entry is of the format \\"team_number score\\". Returns: List[Tuple[int, int]]: List of tuples where each tuple contains the rank and the team number. >>> rank_teams([\\"1 90.5\\", \\"1 85.3\\", \\"2 88.0\\", \\"2 90.5\\", \\"2 65.1\\", \\"3 70.0\\", \\"3 75.0\\", \\"4 85.0\\", \\"4 90.5\\", \\"4 85.5\\", \\"4 92.0\\"]) [(1, 4), (2, 1), (3, 2), (4, 3)] >>> rank_teams([\\"1 90.0\\", \\"1 85.0\\", \\"2 90.0\\", \\"2 60.0\\", \\"2 65.0\\", \\"3 75.0\\"]) [(1, 1), (2, 2), (3, 3)]","solution":"def rank_teams(input_scores): from collections import defaultdict teams_scores = defaultdict(list) # Parse the input scores for entry in input_scores: team, score = map(float, entry.split()) team = int(team) teams_scores[team].append(score) # Calculate the best and sum scores team_stats = [] for team, scores in teams_scores.items(): best_score = max(scores) sum_scores = sum(scores) team_stats.append((team, best_score, sum_scores)) # Sort the teams by the criteria team_stats.sort(key=lambda x: (-x[1], x[2], x[0])) # Prepare the result in the required format result = [(rank + 1, team_stat[0]) for rank, team_stat in enumerate(team_stats)] return result"},{"question":"def rotate_list(nums: List[int], steps: int) -> List[int]: Rotates the list to the right by the specified number of steps. :param nums: List of integers to be rotated. :param steps: Number of steps to rotate the list. :return: Rotated list. >>> rotate_list([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] >>> rotate_list([-1, -100, 50, 22, 0], 3) == [50, 22, 0, -1, -100] >>> rotate_list([10, 20, 30], 0) == [10, 20, 30] >>> rotate_list([1, 2, 3, 4], 6) == [3, 4, 1, 2] >>> rotate_list([1000000, -1000000, 500000], 1) == [500000, 1000000, -1000000] >>> rotate_list([1], 5) == [1]","solution":"def rotate_list(nums, steps): Rotates the list to the right by the specified number of steps. :param nums: List of integers to be rotated :param steps: Number of steps to rotate the list :return: Rotated list n = len(nums) steps = steps % n # If steps is greater than n, taking the modulus gives the effective steps return nums[-steps:] + nums[:-steps] # Example Usage (can be removed in the final code) if __name__ == \\"__main__\\": input_list = list(map(int, input().split())) steps = int(input()) rotated_list = rotate_list(input_list, steps) print(\\" \\".join(map(str, rotated_list)))"},{"question":"def countOccurrences(s: str, c: str) -> int: Returns the number of occurrences of the character c in the string s. Examples: >>> countOccurrences(\\"hello\\", 'l') 2 >>> countOccurrences(\\"abcdefg\\", 'h') 0","solution":"def countOccurrences(s, c): Returns the number of occurrences of the character c in the string s. return s.count(c)"},{"question":"class IntegerSet: def __init__(self): Initializes an empty set of integers. self.set = set() def add(self, x): Adds integer x to the set. Args: x (int): The integer to be added. def delete(self, x): Removes integer x from the set if it exists. Args: x (int): The integer to be removed. def exists(self, x): Checks whether integer x is present in the set. Args: x (int): The integer to be checked. Returns: str: \\"YES\\" if x is present in the set, \\"NO\\" otherwise. def handle_queries(queries): Processes a list of queries and performs the corresponding operations on the set. Args: queries (list of str): List of query strings in the format 'command x'. Returns: list of str: Results of 'exists' queries in the order they were processed. int_set = IntegerSet() results = [] for query in queries: command, *value = query.split() value = int(value[0]) if value else None if command == \\"add\\": int_set.add(value) elif command == \\"delete\\": int_set.delete(value) elif command == \\"exists\\": results.append(int_set.exists(value)) return results # Example usage: def process_input(input): Parses the input, processes the queries, and returns the results for 'exists' queries. Args: input (str): Multi-line string containing the number of queries and the queries themselves. Returns: list of str: Results of 'exists' queries in the order they were processed. lines = input.strip().split(\\"n\\") Q = int(lines[0]) queries = lines[1:1+Q] results = handle_queries(queries) return results # Unit tests def test_integer_set_operations(): Tests various integer set operations. input_data = \\"8nadd 1nadd 2nexists 1nexists 3nadd 3nexists 3ndelete 3nexists 3\\" expected_output = [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] assert process_input(input_data) == expected_output def test_only_add_and_exists(): Tests only add and exists operations. input_data = \\"5nadd 5nadd 10nexists 5nexists 10nexists 15\\" expected_output = [\\"YES\\", \\"YES\\", \\"NO\\"] assert process_input(input_data) == expected_output def test_delete_non_existent(): Tests delete operation on non-existent elements. input_data = \\"4nadd 7ndelete 7ndelete 7nexists 7\\" expected_output = [\\"NO\\"] assert process_input(input_data) == expected_output def test_multiple_operations(): Tests multiple operations. input_data = \\"10nadd 1nadd 2nadd 3nexists 1ndelete 1nexists 1nexists 2ndelete 2nexists 2nexists 3\\" expected_output = [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\", \\"YES\\"] assert process_input(input_data) == expected_output def test_no_operations(): Tests with no operations. input_data = \\"0\\" assert process_input(input_data) == [] import pytest pytest.main()","solution":"class IntegerSet: def __init__(self): self.set = set() def add(self, x): self.set.add(x) def delete(self, x): self.set.discard(x) def exists(self, x): return \\"YES\\" if x in self.set else \\"NO\\" def handle_queries(queries): int_set = IntegerSet() results = [] for query in queries: command, *value = query.split() value = int(value[0]) if value else None if command == \\"add\\": int_set.add(value) elif command == \\"delete\\": int_set.delete(value) elif command == \\"exists\\": results.append(int_set.exists(value)) return results # Example usage: def process_input(input): lines = input.strip().split(\\"n\\") Q = int(lines[0]) queries = lines[1:1+Q] results = handle_queries(queries) return results"},{"question":"def filter_completed_tasks(tasks): Filters out incomplete tasks from the given list of task strings. Parameters: - tasks (list): List of task strings (eg. [\\"Task1\\", \\"CompletedTask1\\"]). Returns: - list: List containing only the completed tasks.","solution":"def filter_completed_tasks(tasks): Filters out incomplete tasks from the given list of task strings. Parameters: - tasks (list): List of task strings (eg. [\\"Task1\\", \\"CompletedTask1\\"]). Returns: - list: List containing only the completed tasks. if not tasks: return [] return [task for task in tasks if task.startswith(\\"CompletedTask\\")]"},{"question":"def maximize_even_ones_rows(n: int, m: int, matrix: List[List[int]]) -> int: Given a matrix of integers with dimensions n x m, selects any submatrix and flips all the zeroes within that submatrix to ones, and all ones within the submatrix to zeroes. Returns the maximum number of rows with an even number of ones after performing any number of submatrix flips. >>> maximize_even_ones_rows(3, 3, [ ... [1, 0, 1], ... [0, 1, 0], ... [1, 1, 0] ... ]) 3 >>> maximize_even_ones_rows(2, 2, [ ... [1, 1], ... [1, 0] ... ]) 2 >>> maximize_even_ones_rows(4, 2, [ ... [1, 0], ... [0, 0], ... [1, 1], ... [0, 1] ... ]) 4","solution":"def maximize_even_ones_rows(n, m, matrix): def count_ones(row): return sum(row) def row_parity(row): return sum(row) % 2 flip_count = {} for row in matrix: parity_pattern = tuple(row_parity([(a ^ b) for a, b in zip(row, row)]) for row in matrix) if parity_pattern in flip_count: flip_count[parity_pattern] += 1 else: flip_count[parity_pattern] = 1 max_even_rows = max(flip_count.values(), default=0) return max_even_rows"},{"question":"def find_departments_with_extreme_sentiments(n: int, sentiments: List[str]) -> Tuple[str, str]: Determines the department with the highest and lowest average sentiment score. :param n: Number of departments :param sentiments: List of strings, each string contains a department name followed by sentiment scores :return: Tuple containing two strings: (department with the highest average sentiment, department with the lowest average sentiment) >>> find_departments_with_extreme_sentiments(3, [\\"sales 5 4 3 5 4\\", \\"hr 2 3 4 3\\", \\"engineering 5 5 4 5 5 4 5 3\\"]) (\\"engineering\\", \\"hr\\") >>> find_departments_with_extreme_sentiments(1, [\\"sales 5 5 5\\"]) (\\"sales\\", \\"sales\\")","solution":"def find_departments_with_extreme_sentiments(n, sentiments): Determines the department with the highest and lowest average sentiment score :param n: Number of departments :param sentiments: List of strings, each string contains a department name followed by sentiment scores :return: Tuple containing two strings: (department with the highest average sentiment, department with the lowest average sentiment) department_scores = {} for sentiment in sentiments: parts = sentiment.split() department_name = parts[0] scores = list(map(int, parts[1:])) avg_score = sum(scores) / len(scores) department_scores[department_name] = avg_score highest_dept = max(department_scores.items(), key=lambda x: (x[1], -ord(x[0][0])))[0] lowest_dept = min(department_scores.items(), key=lambda x: (x[1], ord(x[0][0])))[0] return highest_dept, lowest_dept # Example usage: n = 3 sentiments = [ \\"sales 5 4 3 5 4\\", \\"hr 2 3 4 3\\", \\"engineering 5 5 4 5 5 4 5 3\\" ] print(find_departments_with_extreme_sentiments(n, sentiments))"},{"question":"def min_max_sum_of_three_subarrays(arr): This function finds the minimum possible value of the maximum sum of three contiguous subarrays. Parameters: arr (list): A list of integers representing the input array Returns: int: The minimum possible value of the maximum sum of the three subarrays pass # Unit tests def test_example_case(): assert min_max_sum_of_three_subarrays([1, 2, 3, 4, 5, 6]) == 9 def test_small_array(): assert min_max_sum_of_three_subarrays([1, 1, 1]) == 1 def test_negative_numbers(): assert min_max_sum_of_three_subarrays([-1, -2, -3, -4, -5, -6]) == -6 def test_mixed_numbers(): assert min_max_sum_of_three_subarrays([3, 1, -2, 4, -1, 2, 5, -3, 8]) == 6 def test_large_values(): assert min_max_sum_of_three_subarrays([1000000000, -1000000000, 1000000000]) == 1000000000 def test_all_zeros(): assert min_max_sum_of_three_subarrays([0, 0, 0, 0, 0]) == 0","solution":"def min_max_sum_of_three_subarrays(arr): This function finds the minimum possible value of the maximum sum of three contiguous subarrays. Parameters: arr (list): A list of integers representing the input array Returns: int: The minimum possible value of the maximum sum of the three subarrays n = len(arr) # Calculate prefix sums prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + arr[i] # Initialize the maximum sum of three subarrays min_max_sum = float('inf') # Iterate over possible positions to split the array into three parts for i in range(1, n - 1): for j in range(i + 1, n): sum1 = prefix_sum[i] - prefix_sum[0] sum2 = prefix_sum[j] - prefix_sum[i] sum3 = prefix_sum[n] - prefix_sum[j] max_sum = max(sum1, sum2, sum3) min_max_sum = min(min_max_sum, max_sum) return min_max_sum # Example input # print(min_max_sum_of_three_subarrays([1, 2, 3, 4, 5, 6])) # Expected output: 9"},{"question":"def count_palindromic_substrings(S: str) -> int: Returns the number of palindromic substrings in the given string S. >>> count_palindromic_substrings(\\"abba\\") 6 >>> count_palindromic_substrings(\\"racecar\\") 10 pass def palindromic_substrings_counts(test_cases: List[str]) -> List[int]: Returns the number of palindromic substrings for each given test case. test_cases: List of strings >>> palindromic_substrings_counts([\\"abba\\", \\"racecar\\"]) [6, 10] pass","solution":"def count_palindromic_substrings(S): Returns the number of palindromic substrings in the given string S. n = len(S) count = 0 for center in range(2 * n - 1): left = center // 2 right = left + center % 2 while left >= 0 and right < n and S[left] == S[right]: count += 1 left -= 1 right += 1 return count def palindromic_substrings_counts(test_cases): Returns the number of palindromic substrings for each given test case. test_cases: List of strings return [count_palindromic_substrings(tc) for tc in test_cases]"},{"question":"def find_missing_positive(nums: List[int]) -> int: Finds the smallest positive integer that is missing from the array. >>> find_missing_positive([3, 4, -1, 1]) 2 >>> find_missing_positive([1, 2, 0]) 3 >>> find_missing_positive([7, 8, 9, 11, 12]) 1 >>> find_missing_positive([1, 2, 3, 4, 5, 7, 8]) 6 >>> find_missing_positive([1, 2, 3, 4, 5]) 6 >>> find_missing_positive([-1, -2, -3, -4]) 1 >>> find_missing_positive([1, 100000]) 2 # Your implementation here","solution":"def find_missing_positive(nums): This function finds the smallest positive integer that is missing from the array. It should run in O(n) time and use O(1) extra space. n = len(nums) # Step 1: Mark numbers (num < 0) and (num >= n) which are definitely not the answer for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Step 2: Mark each number's presence in the array using index for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # Step 3: The first index which doesn't have a negative number means that index + 1 is missing for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"from typing import List, Tuple def min_mana_sum(n: int, q: int, mana_values: List[int], queries: List[int]) -> List[int]: This function computes the minimum possible sum of mana values by choosing k non-overlapping magic objects from different groups for each query. :param n: Number of magical objects :param q: Number of queries :param mana_values: List of integers representing mana values of magical objects :param queries: List of integers representing the number of objects to choose in each query :return: List of results for each query >>> min_mana_sum(5, 3, [10, 20, 30, 40, 50], [1, 2, 3]) [10, 30, 60] >>> min_mana_sum(4, 2, [15, 10, 20, 25], [2, 3]) [25, 45] pass def process_test_cases(t: int, test_cases: List[Tuple[int, int, List[int], List[int]]]) -> List[int]: This function processes multiple test cases, each containing a number of magical objects, queries and their mana values, and returns the results of each query for all test cases. :param t: Number of test cases :param test_cases: List of tuples, each containing: - an integer n: number of magical objects - an integer q: number of queries - a list of integers mana_values: mana values of the magical objects - a list of integers queries: numbers of objects to choose in each query :return: List of results for each query of all test cases >>> process_test_cases(2, [(5, 3, [10, 20, 30, 40, 50], [1, 2, 3]), (4, 2, [15, 10, 20, 25], [2, 3])]) [10, 30, 60, 25, 45] pass import pytest def test_min_mana_sum(): assert min_mana_sum(5, 3, [10, 20, 30, 40, 50], [1, 2, 3]) == [10, 30, 60] assert min_mana_sum(4, 2, [15, 10, 20, 25], [2, 3]) == [25, 45] def test_process_test_cases(): test_cases = [ (5, 3, [10, 20, 30, 40, 50], [1, 2, 3]), (4, 2, [15, 10, 20, 25], [2, 3]), ] assert process_test_cases(2, test_cases) == [10, 30, 60, 25, 45] if __name__ == \\"__main__\\": pytest.main()","solution":"def min_mana_sum(n, q, mana_values, queries): This function computes the minimum possible sum of mana values by choosing k non-overlapping magic objects from different groups for each query. :param n: Number of magical objects :param q: Number of queries :param mana_values: List of integers representing mana values of magical objects :param queries: List of integers representing the number of objects to choose in each query :return: List of results for each query # Sort the mana values to be able to pick the smallest values easily mana_values.sort() # Calculate prefix sums for quick sum calculation for the smallest k elements prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + mana_values[i - 1] results = [] for k in queries: results.append(prefix_sums[k]) return results def process_test_cases(t, test_cases): results = [] for test_case in test_cases: n, q, mana_values, queries = test_case results.extend(min_mana_sum(n, q, mana_values, queries)) return results"},{"question":"from typing import List, Tuple def longest_path(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the length of the longest path without visiting the same checkpoint more than once. Args: n (int): Number of checkpoints. m (int): Number of direct routes between checkpoints. edges (List[Tuple[int, int]]): List of direct routes between checkpoints. Returns: int: The length of the longest path. >>> longest_path(6, 7, [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4), (4, 5), (5, 6)]) 5 >>> longest_path(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 3)]) 4 def test_example_1(): edges = [ (1, 2), (2, 3), (3, 4), (1, 3), (1, 4), (4, 5), (5, 6) ] assert longest_path(6, 7, edges) == 5 def test_example_2(): edges = [ (1, 2), (2, 3), (3, 4), (4, 5), (1, 3) ] assert longest_path(5, 5, edges) == 4 def test_single_path(): edges = [ (1, 2), (2, 3) ] assert longest_path(3, 2, edges) == 2 def test_disconnected_graph(): edges = [ (1, 2), (3, 4) ] assert longest_path(4, 2, edges) == 1 def test_ring_graph(): edges = [ (1, 2), (2, 3), (3, 4), (4, 1) ] assert longest_path(4, 4, edges) == 3 def test_large_graph(): edges = [ (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10) ] assert longest_path(10, 9, edges) == 9","solution":"def longest_path(n, m, edges): from collections import defaultdict, deque def dfs(node, visited): if node in visited: return 0 visited.add(node) max_length = 0 for neighbor in adj_list[node]: if neighbor not in visited: max_length = max(max_length, dfs(neighbor, visited)) visited.remove(node) return 1 + max_length # Create adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Calculate the longest path max_path_length = 0 for node in range(1, n+1): max_path_length = max(max_path_length, dfs(node, set())) return max_path_length - 1 # Subtract one to get the number of edges in the path # Example use case edges = [ (1, 2), (2, 3), (3, 4), (1, 3), (1, 4), (4, 5), (5, 6) ] print(longest_path(6, 7, edges)) # Output: 5 edges = [ (1, 2), (2, 3), (3, 4), (4, 5), (1, 3) ] print(longest_path(5, 5, edges)) # Output: 4"},{"question":"def count_paths(m: int, n: int) -> int: Count the number of distinct paths the robot can take to reach the bottom-right corner of the grid. >>> count_paths(2, 2) 3 >>> count_paths(3, 3) 13 >>> count_paths(4, 4) 63 >>> count_paths(1, 3) 1 >>> count_paths(3, 1) 1 >>> count_paths(100, 100) != 0","solution":"MOD = 10**9 + 7 def count_paths(m, n): # Create a 2D list to hold the number of ways to reach each cell dp = [[0] * n for _ in range(m)] # There is exactly one way to reach the starting cell dp[0][0] = 1 # Fill the dp table for i in range(m): for j in range(n): if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD if i > 0 and j > 0: dp[i][j] = (dp[i][j] + dp[i-1][j-1]) % MOD return dp[m-1][n-1]"},{"question":"def merge_BSTs(bst1, bst2): Merges two BSTs represented as in-order traversal lists into a single sorted list while preserving BST properties. Args: bst1 (list): In-order traversal of the first BST. bst2 (list): In-order traversal of the second BST. Returns: list: In-order traversal of the merged BST. >>> merge_BSTs([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_BSTs([10, 20, 30, 40], [5, 25]) [5, 10, 20, 25, 30, 40] >>> merge_BSTs([], [1, 2, 3]) [1, 2, 3] >>> merge_BSTs([1, 2, 3], []) [1, 2, 3] >>> merge_BSTs([1, 5, 9], [2, 6, 10]) [1, 2, 5, 6, 9, 10] >>> merge_BSTs([1, 2, 3], [2, 3, 4]) [1, 2, 2, 3, 3, 4]","solution":"def merge_BSTs(bst1, bst2): Merges two BSTs represented as in-order traversal lists into a single sorted list. Args: bst1 (list): In-order traversal of the first BST. bst2 (list): In-order traversal of the second BST. Returns: list: In-order traversal of the merged BST. # Use two pointers to merge the two sorted lists into one sorted list merged = [] i, j = 0, 0 while i < len(bst1) and j < len(bst2): if bst1[i] < bst2[j]: merged.append(bst1[i]) i += 1 else: merged.append(bst2[j]) j += 1 # Append remaining elements, if any while i < len(bst1): merged.append(bst1[i]) i += 1 while j < len(bst2): merged.append(bst2[j]) j += 1 return merged"},{"question":"def is_armstrong_number(number: int) -> bool: Determines if a given number is an Armstrong number (narcissistic number). >>> is_armstrong_number(153) True >>> is_armstrong_number(9474) True >>> is_armstrong_number(123) False","solution":"def is_armstrong_number(number): Determines if a given number is an Armstrong number (narcissistic number). Parameters: number (int): The number to check. Returns: bool: True if the number is an Armstrong number, False otherwise. digits = [int(d) for d in str(number)] num_digits = len(digits) sum_of_powers = sum([d ** num_digits for d in digits]) return sum_of_powers == number"},{"question":"def trap_rain_water(heights): Returns the total amount of rainwater that can be trapped after the rain. :param heights: List of non-negative integers representing the amount of rainwater stored above each building. :return: Total trapped rainwater. >>> trap_rain_water([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_rain_water([4,2,0,3,2,5]) 9","solution":"def trap_rain_water(heights): Returns the total amount of rainwater that can be trapped after the rain. :param heights: List of non-negative integers representing the amount of rainwater stored above each building. :return: Total trapped rainwater. if not heights: return 0 n = len(heights) left_max = [0]*n right_max = [0]*n water_trapped = 0 left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"class TooManyBooks: A class to manage digital book collections. Supports adding new books, moving books across genres, and querying the number of books within a given genre. def __init__(self): Initializes the data structures to manage the books and genres. pass def add_book(self, x, g): Adds a new book with ID \`x\` to genre \`g\`. Parameters: x (int): The ID of the book. g (int): The genre to which the book should be added. pass def move_book(self, x, g): Moves a book with ID \`x\` from its current genre to genre \`g\`. Parameters: x (int): The ID of the book. g (int): The genre to which the book should be moved. pass def count_books(self, g): Counts the number of books in genre \`g\`. Parameters: g (int): The genre for which to count the books. Returns: int: The number of books in the specified genre. pass from solution import TooManyBooks def test_add_book(): tmb = TooManyBooks() tmb.add_book(1, 10) tmb.add_book(2, 10) tmb.add_book(3, 20) assert tmb.count_books(10) == 2 assert tmb.count_books(20) == 1 assert tmb.count_books(30) == 0 # No books in genre 30 def test_move_book(): tmb = TooManyBooks() tmb.add_book(1, 10) tmb.add_book(2, 10) tmb.move_book(1, 20) tmb.move_book(3, 10) # Book 3 does not exist assert tmb.count_books(10) == 1 assert tmb.count_books(20) == 1 def test_move_book_same_genre(): tmb = TooManyBooks() tmb.add_book(1, 10) tmb.add_book(2, 10) tmb.move_book(1, 10) # Moving the book to the same genre assert tmb.count_books(10) == 2 def test_add_move_and_count(): tmb = TooManyBooks() tmb.add_book(1, 1) tmb.add_book(2, 1) tmb.add_book(3, 2) assert tmb.count_books(1) == 2 assert tmb.count_books(2) == 1 tmb.move_book(1, 2) tmb.move_book(2, 3) assert tmb.count_books(1) == 0 assert tmb.count_books(2) == 2 assert tmb.count_books(3) == 1 def test_add_existing_book(): tmb = TooManyBooks() tmb.add_book(1, 5) tmb.add_book(1, 10) assert tmb.count_books(5) == 1 assert tmb.count_books(10) == 0","solution":"class TooManyBooks: def __init__(self): self.book_genre = {} self.genre_count = {} def add_book(self, x, g): if x in self.book_genre: return self.book_genre[x] = g if g in self.genre_count: self.genre_count[g] += 1 else: self.genre_count[g] = 1 def move_book(self, x, g): if x not in self.book_genre: return current_genre = self.book_genre[x] if current_genre == g: return self.book_genre[x] = g self.genre_count[current_genre] -= 1 if self.genre_count[current_genre] == 0: del self.genre_count[current_genre] if g in self.genre_count: self.genre_count[g] += 1 else: self.genre_count[g] = 1 def count_books(self, g): return self.genre_count.get(g, 0)"},{"question":"def is_symmetric(s: str) -> bool: Determines if the input string \`s\` is symmetric (reads the same forwards and backwards). Args: s (str): The input string to be checked. Returns: bool: True if the string is symmetric, False otherwise. >>> is_symmetric(\\"level\\") True >>> is_symmetric(\\"coding\\") False >>> is_symmetric(\\"radar\\") True >>> is_symmetric(\\"hello\\") False","solution":"def is_symmetric(s): Determines if the input string s is symmetric. Args: s (str): The input string to be checked. Returns: bool: True if the string is symmetric, False otherwise. return s == s[::-1]"},{"question":"def shiftRight(arr, N, K): Shift elements of the array to the right by K positions in place. :param arr: List[int] - The array to be shifted. :param N: int - The number of elements in the array. :param K: int - The number of positions to shift. pass # Write your code here def reverse(arr, start, end): Reverse the elements of the array from index start to index end in place. :param arr: List[int] - The array to be reversed. :param start: int - Starting index. :param end: int - Ending index. pass # Write your code here # Test cases to validate the solution def test_shiftBy3_positions(): arr = [1, 2, 3, 4, 5, 6, 7] shiftRight(arr, 7, 3) assert arr == [5, 6, 7, 1, 2, 3, 4] def test_shiftBy2_positions(): arr = [10, 20, 30, 40, 50] shiftRight(arr, 5, 2) assert arr == [40, 50, 10, 20, 30] def test_shiftByMoreThanLength(): arr = [1, 2, 3, 4, 5] shiftRight(arr, 5, 7) # 7 is more than the length assert arr == [4, 5, 1, 2, 3] def test_shiftByLength(): arr = [1, 2, 3, 4, 5] shiftRight(arr, 5, 5) # Shifted by the length of the array assert arr == [1, 2, 3, 4, 5] def test_shiftByZero(): arr = [1, 2, 3, 4, 5] shiftRight(arr, 5, 0) # Shifted by 0 assert arr == [1, 2, 3, 4, 5] def test_large_array(): arr = list(range(1, 10001)) # Creating a large array from 1 to 10000 shiftRight(arr, 10000, 5000) assert arr == list(range(5001, 10001)) + list(range(1, 5001))","solution":"def shiftRight(arr, N, K): Shift elements of the array to the right by K positions in place. :param arr: List[int] - The array to be shifted. :param N: int - The number of elements in the array. :param K: int - The number of positions to shift. # Effective number of shifts K = K % N # Reverse the entire array reverse(arr, 0, N-1) # Reverse the first K elements reverse(arr, 0, K-1) # Reverse the remaining N-K elements reverse(arr, K, N-1) def reverse(arr, start, end): Reverse the elements of the array from index start to index end in place. :param arr: List[int] - The array to be reversed. :param start: int - Starting index. :param end: int - Ending index. while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1"},{"question":"def find_minimum_in_subarray(arr, queries): Returns the minimum value in each specified subarray. Parameters: arr (list of int): The original array of integers. queries (list of tuple): A list of tuples, where each tuple contains two integers (l, r). Returns: list of int: The minimum value in each specified subarray. pass # Unit tests from solution import find_minimum_in_subarray def test_example_case(): arr = [4, 2, 5, 3, 1] queries = [(1, 3), (2, 5), (3, 3)] expected = [2, 1, 5] assert find_minimum_in_subarray(arr, queries) == expected def test_single_element_queries(): arr = [10, 20, 30, 40, 50] queries = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] expected = [10, 20, 30, 40, 50] assert find_minimum_in_subarray(arr, queries) == expected def test_full_array_query(): arr = [9, 8, 7, 6, 5] queries = [(1, 5)] expected = [5] assert find_minimum_in_subarray(arr, queries) == expected def test_overlapping_queries(): arr = [1, 3, 5, 7, 9, 11, 13, 15] queries = [(1, 4), (3, 6), (5, 8)] expected = [1, 5, 9] assert find_minimum_in_subarray(arr, queries) == expected def test_large_numbers(): arr = [1000000000, 999999999, 1000000000, 999999998] queries = [(1, 2), (2, 4), (1, 4)] expected = [999999999, 999999998, 999999998] assert find_minimum_in_subarray(arr, queries) == expected def test_negative_numbers(): arr = [-10, -20, -30, -40, -50] queries = [(1, 3), (2, 4), (3, 5)] expected = [-30, -40, -50] assert find_minimum_in_subarray(arr, queries) == expected","solution":"def find_minimum_in_subarray(arr, queries): Returns the minimum value in each specified subarray. Parameters: arr (list of int): The original array of integers. queries (list of tuple): A list of tuples, where each tuple contains two integers (l, r). Returns: list of int: The minimum value in each specified subarray. results = [] for (l, r) in queries: subarray = arr[l-1:r] results.append(min(subarray)) return results"},{"question":"def convert_from_binary(binary_str: str) -> int: Convert a binary string to a decimal integer. Parameters: binary_str (str): A string representing a binary number, e.g., '1011'. Returns: int: The decimal equivalent of the binary string. pass # Your implementation here # Example test cases assert convert_from_binary('1011') == 11 assert convert_from_binary('1101') == 13 assert convert_from_binary('10000') == 16","solution":"def convert_from_binary(binary_str: str) -> int: Convert a binary string to a decimal integer. Parameters: binary_str (str): A string representing a binary number, e.g., '1011'. Returns: int: The decimal equivalent of the binary string. return int(binary_str, 2)"},{"question":"def product_except_self(nums): Given an array of integers, returns an array where each element is the product of all the elements of the original array except the one at the current index. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> product_except_self([2, 0, 2]) [0, 4, 0]","solution":"def product_except_self(nums): Given an array of integers, returns an array where each element is the product of all the elements of the original array except the one at the current index. if not nums: return [] length = len(nums) result = [1] * length left_product = 1 right_product = 1 # Calculating product of elements to the left of each index for i in range(length): result[i] = left_product left_product *= nums[i] # Calculating product of elements to the right of each index and combining with left product for i in range(length-1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def longest_increasing_subsequence_length(sequence): Determine the length of the longest subsequence such that all elements of the subsequence are strictly increasing. >>> longest_increasing_subsequence_length([5, 2, 8, 6, 3, 6]) 3 >>> longest_increasing_subsequence_length([9, 1, 3, 7, 5]) 3","solution":"def longest_increasing_subsequence_length(sequence): import bisect if not sequence: return 0 lis = [] for num in sequence: pos = bisect.bisect_left(lis, num) if pos < len(lis): lis[pos] = num else: lis.append(num) return len(lis)"},{"question":"def min_socks_to_add(n: int, socks: List[int]) -> int: Returns the minimum number of single socks that need to be added to ensure that every sock has a matching pair of the same color. Parameters: n (int): Number of socks in the box. socks (List[int]): List of integers representing colors of each sock. Returns: int: Minimum number of single socks to be added. >>> min_socks_to_add(5, [1, 2, 1, 2, 3]) 1 >>> min_socks_to_add(4, [1, 1, 2, 3]) 2","solution":"def min_socks_to_add(n, socks): Returns the minimum number of single socks that need to be added to ensure that every sock has a matching pair of the same color. Parameters: n (int): Number of socks in the box. socks (List[int]): List of integers representing colors of each sock. Returns: int: Minimum number of single socks to be added. from collections import Counter sock_counter = Counter(socks) additions_needed = 0 for count in sock_counter.values(): if count % 2 != 0: additions_needed += 1 return additions_needed"},{"question":"from typing import List def rearrange_string(s: str) -> str: Rearranges the string so that no two adjacent characters are the same. :param s: input string :return: rearranged string or empty string if impossible >>> rearrange_string(\\"aabb\\") in [\\"abab\\", \\"baba\\"] True >>> rearrange_string(\\"aaab\\") == \\"\\" True >>> rearrange_string(\\"a\\") == \\"a\\" True >>> rearrange_string(\\"ab\\") in [\\"ab\\", \\"ba\\"] True >>> rearrange_string(\\"abcdef\\") == \\"abcdef\\" True","solution":"from collections import Counter import heapq def rearrange_string(s): Rearranges the string so that no two adjacent characters are the same. :param s: input string :return: rearranged string or empty string if impossible # Count frequency of each character freq = Counter(s) # Using a max heap (inverted min heap) to store characters by frequency max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) # The result array result = [] prev_count, prev_char = 0, '' while max_heap: count, char = heapq.heappop(max_heap) # Append current character to result result.append(char) # Since the character is used once, decrease the frequency if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update the previous character and count prev_count, prev_char = count + 1, char # If the length of the result is not same as input, it means we couldn't rearrange it if len(result) != len(s): return \\"\\" return ''.join(result)"},{"question":"def is_bipartite_graph(n: int, adjacency_matrix: List[str]) -> str: Determines if the graph can be colored using two colors such that no two adjacent vertices have the same color. Parameters: n (int): Number of vertices adjacency_matrix (List[str]): List of strings representing the adjacency matrix Returns: str: \\"YES\\" if the graph can be colored using two colors, \\"NO\\" otherwise >>> is_bipartite_graph(3, [\\"011\\", \\"101\\", \\"110\\"]) \\"NO\\" >>> is_bipartite_graph(4, [\\"0101\\", \\"1010\\", \\"0101\\", \\"1010\\"]) \\"YES\\"","solution":"def is_bipartite_graph(n, adjacency_matrix): Determines if the graph is bipartite using BFS. Parameters: n (int): Number of vertices adjacency_matrix (List[str]): List of strings representing the adjacency matrix Returns: str: \\"YES\\" if the graph can be colored using two colors, \\"NO\\" otherwise # Create an array to store colors assigned to all vertices. # Color values: -1 (not colored), 0 (first color), 1 (second color) colors = [-1] * n def bfs(start): # Initialize a queue with the starting node queue = [start] # Start coloring the first node with first color colors[start] = 0 while queue: node = queue.pop(0) # Check all adjacent nodes for neighbor in range(n): if adjacency_matrix[node][neighbor] == \\"1\\": if colors[neighbor] == -1: # If neighbor has not been colored, color it with opposite color colors[neighbor] = 1 - colors[node] queue.append(neighbor) elif colors[neighbor] == colors[node]: # If neighbor has the same color as current node, graph is not bipartite return False return True for i in range(n): if colors[i] == -1: # If the node has not been colored if not bfs(i): # Perform BFS from this node return \\"NO\\" return \\"YES\\""},{"question":"def check_breaks(T: int, M: int, times: List[int]) -> List[str]: Determines if Alex needs to take a break based on the total minutes he played today. Parameters: T (int): Number of test cases M (int): The threshold minutes for taking a break times (list of int): List of total minutes Alex played for each test case Returns: list of str: 'YES' if Alex needs to take a break, 'NO' otherwise pass # Sample Test Cases # Test case 1 assert check_breaks(3, 180, [180, 120, 200]) == [\\"YES\\", \\"NO\\", \\"YES\\"] # Test case 2 assert check_breaks(1, 180, [200]) == [\\"YES\\"] # Test case 3 assert check_breaks(1, 180, [120]) == [\\"NO\\"] # Test case 4 assert check_breaks(1, 180, [180]) == [\\"YES\\"] # Test case 5 assert check_breaks(1, 180, [179]) == [\\"NO\\"] # Test case 6 assert check_breaks(1, 1, [0]) == [\\"NO\\"] # Test case 7 times = [i for i in range(1, 2001)] expected = [\\"NO\\" if i < 180 else \\"YES\\" for i in times] assert check_breaks(2000, 180, times) == expected","solution":"def check_breaks(T, M, times): Determines if Alex needs to take a break based on the total minutes he played today. Parameters: T (int): Number of test cases M (int): The threshold minutes for taking a break times (list of int): List of total minutes Alex played for each test case Returns: list of str: 'YES' if Alex needs to take a break, 'NO' otherwise results = [] for Y in times: if Y >= M: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def process_queries(N, M, Q, grid, queries): Process a series of UPDATE and MAXIMUM queries on a grid. Parameters: N (int): Number of rows in the grid. M (int): Number of columns in the grid. Q (int): Number of queries to process. grid (list of list of int): N x M grid of integers. queries (list of str): List of queries to be processed. Returns: list of int: Results of MAXIMUM queries. pass import pytest def test_process_queries(): N = 4 M = 4 Q = 5 grid = [ [5, 1, 3, 7], [9, 3, 4, 2], [8, 6, 7, 1], [2, 3, 5, 6] ] queries = [ \\"UPDATE 2 2 10\\", \\"MAXIMUM 1 1 2 3\\", \\"UPDATE 3 4 12\\", \\"MAXIMUM 3 1 4 4\\", \\"MAXIMUM 1 1 4 4\\" ] expected = [10, 12, 12] assert process_queries(N, M, Q, grid, queries) == expected def test_process_queries_with_only_max(): N = 3 M = 3 Q = 2 grid = [ [4, 5, 6], [1, 8, 7], [3, 2, 0] ] queries = [ \\"MAXIMUM 1 1 3 3\\", \\"MAXIMUM 2 2 3 3\\" ] expected = [8, 8] assert process_queries(N, M, Q, grid, queries) == expected def test_process_queries_with_only_update(): N = 2 M = 2 Q = 2 grid = [ [1, 2], [3, 4] ] queries = [ \\"UPDATE 1 1 5\\", \\"UPDATE 2 2 6\\" ] expected = [] assert process_queries(N, M, Q, grid, queries) == expected def test_process_queries_mixed_cases(): N = 2 M = 3 Q = 4 grid = [ [1, 2, 3], [4, 5, 6] ] queries = [ \\"MAXIMUM 1 1 2 3\\", \\"UPDATE 2 3 10\\", \\"MAXIMUM 1 1 2 3\\", \\"UPDATE 1 2 8\\" ] expected = [6, 10] assert process_queries(N, M, Q, grid, queries) == expected","solution":"def process_queries(N, M, Q, grid, queries): Process a series of UPDATE and MAXIMUM queries on a grid. Parameters: N (int): Number of rows in the grid. M (int): Number of columns in the grid. Q (int): Number of queries to process. grid (list of list of int): N x M grid of integers. queries (list of str): List of queries to be processed. Returns: list of int: Results of MAXIMUM queries. results = [] for query in queries: parts = query.split() if parts[0] == \\"UPDATE\\": r = int(parts[1]) - 1 c = int(parts[2]) - 1 x = int(parts[3]) grid[r][c] = x elif parts[0] == \\"MAXIMUM\\": r1 = int(parts[1]) - 1 c1 = int(parts[2]) - 1 r2 = int(parts[3]) - 1 c2 = int(parts[4]) - 1 max_value = max(grid[i][j] for i in range(r1, r2 + 1) for j in range(c1, c2 + 1)) results.append(max_value) return results # Example usage: # input N = 4 M = 4 Q = 5 grid = [ [5, 1, 3, 7], [9, 3, 4, 2], [8, 6, 7, 1], [2, 3, 5, 6] ] queries = [ \\"UPDATE 2 2 10\\", \\"MAXIMUM 1 1 2 3\\", \\"UPDATE 3 4 12\\", \\"MAXIMUM 3 1 4 4\\", \\"MAXIMUM 1 1 4 4\\" ] # process queries results = process_queries(N, M, Q, grid, queries) for result in results: print(result)"},{"question":"def determine_winner(n: int, stick_lengths: List[int]) -> str: Determine whether Vanya will win or lose if both play optimally. Parameters: n (int): Number of sticks. stick_lengths (list): List containing the lengths of the sticks. Returns: str: \\"Vanya\\" if Vanya wins, \\"Brother\\" if Vanya's brother wins. Examples: >>> determine_winner(3, [1, 2, 3]) \\"Vanya\\" >>> determine_winner(2, [1, 2]) \\"Brother\\"","solution":"def determine_winner(n, stick_lengths): Determines whether Vanya or his brother will win the game. Parameters: n (int): Number of sticks. stick_lengths (list): List containing the lengths of the sticks. Returns: str: \\"Vanya\\" if Vanya wins, \\"Brother\\" if Vanya's brother wins. # If the number of sticks is odd, Vanya wins because he can always make the last move. if n % 2 == 1: return \\"Vanya\\" else: return \\"Brother\\""},{"question":"def is_tree(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine if a given graph is a Tree. :param n: An integer, number of nodes in the graph. :param m: An integer, number of edges in the graph. :param edges: A list of tuples, each representing an edge between two nodes. :return: \\"YES\\" if the given graph is a Tree, otherwise \\"NO\\". >>> is_tree(5, 4, [(1, 2), (1, 3), (2, 4), (2, 5)]) \\"YES\\" >>> is_tree(5, 3, [(1, 2), (2, 3), (4, 5)]) \\"NO\\" >>> is_tree(1, 0, []) \\"YES\\"","solution":"def is_tree(n, m, edges): if m != n - 1: return \\"NO\\" from collections import defaultdict, deque graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) queue = deque([1]) visited[1] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return \\"YES\\" if all(visited[1:]) else \\"NO\\""},{"question":"def find_local_maxima(matrix): Find all the local maxima in the matrix. A cell is considered a local maximum if it is greater than or equal to all of its 8 neighbors. Args: - matrix: List of lists representing the MxN matrix with positive integers. Returns: - A list of tuples containing the coordinates of all local maxima in the format (row_index, col_index). >>> find_local_maxima([ ... [1, 2, 1], ... [2, 3, 2], ... [1, 2, 1] ... ]) [(1, 1)] >>> find_local_maxima([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [(2, 2)] from solution import find_local_maxima def test_case_1(): matrix = [ [1, 2, 1], [2, 3, 2], [1, 2, 1] ] result = find_local_maxima(matrix) assert result == [(1, 1)] def test_case_2(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = find_local_maxima(matrix) assert result == [(2, 2)] def test_case_3(): matrix = [ [10, 20, 10], [20, 30, 20], [10, 20, 10] ] result = find_local_maxima(matrix) assert result == [(1, 1)] def test_case_4(): matrix = [ [3, 3, 3, 3], [3, 4, 4, 3], [3, 4, 4, 3], [3, 3, 3, 3] ] result = find_local_maxima(matrix) assert result == [(1, 1), (1, 2), (2, 1), (2, 2)] def test_case_5(): matrix = [ [1, 2, 1], [3, 4, 3], [1, 2, 1], [5, 6, 5] ] result = find_local_maxima(matrix) assert result == [(1, 1), (3, 1)]","solution":"def find_local_maxima(matrix): M = len(matrix) N = len(matrix[0]) def is_local_maximum(i, j): current_value = matrix[i][j] for di in [-1, 0, 1]: for dj in [-1, 0, 1]: if di == 0 and dj == 0: continue ni, nj = i + di, j + dj if 0 <= ni < M and 0 <= nj < N and matrix[ni][nj] > current_value: return False return True local_maxima = [] for i in range(M): for j in range(N): if is_local_maximum(i, j): local_maxima.append((i, j)) return local_maxima def main(): import sys input = sys.stdin.read data = input().split() M = int(data[0]) N = int(data[1]) matrix = [] index = 2 for i in range(M): row = [] for j in range(N): row.append(int(data[index])) index += 1 matrix.append(row) local_maxima = find_local_maxima(matrix) print(len(local_maxima)) for (i, j) in sorted(local_maxima): print(f\\"({i}, {j})\\") if __name__ == \\"__main__\\": main()"},{"question":"def hex_to_rgb(hex_code): Converts a hexadecimal color code to its RGB representation. :param hex_code: A string representing the hex code. :return: A tuple with the corresponding RGB values or \\"Invalid hex code\\" if input is invalid. Examples: >>> hex_to_rgb(\\"#FFFFFF\\") (255, 255, 255) >>> hex_to_rgb(\\"#000000\\") (0, 0, 0) >>> hex_to_rgb(\\"#FF5733\\") (255, 87, 51) >>> hex_to_rgb(\\"#abcdef\\") (171, 205, 239) >>> hex_to_rgb(\\"FFFFFF\\") \\"Invalid hex code\\" >>> hex_to_rgb(\\"#FFF\\") \\"Invalid hex code\\" >>> hex_to_rgb(\\"#ZZZZZZ\\") \\"Invalid hex code\\" >>> hex_to_rgb(\\"#1234\\") \\"Invalid hex code\\" >>> hex_to_rgb(123456) \\"Invalid hex code\\" >>> hex_to_rgb(\\"\\") \\"Invalid hex code\\"","solution":"def hex_to_rgb(hex_code): Converts a hexadecimal color code to its RGB representation. :param hex_code: A string representing the hex code. :return: A tuple with the corresponding RGB values or \\"Invalid hex code\\" if input is invalid. if isinstance(hex_code, str) and len(hex_code) == 7 and hex_code[0] == '#': try: r = int(hex_code[1:3], 16) g = int(hex_code[3:5], 16) b = int(hex_code[5:7], 16) return (r, g, b) except ValueError: return \\"Invalid hex code\\" return \\"Invalid hex code\\""},{"question":"def shift_cipher(operation: str, k: int, message: str) -> str: Encrypt or decrypt a message using a simple shift cipher technique. Args: operation (str): 'encrypt' or 'decrypt'. k (int): shift value (0 ≤ k ≤ 25). message (str): the message to be encrypted or decrypted. Returns: str: the resulting message after encryption or decryption. >>> shift_cipher('encrypt', 3, 'hello world') 'khoor zruog' >>> shift_cipher('decrypt', 3, 'khoor zruog') 'hello world' pass # Replace with implementation def process_operations(operations: List[Tuple[str, int, str]]) -> List[str]: Process multiple encryption or decryption operations. Args: operations (List[Tuple[str, int, str]]): List of operations where each operation is a tuple containing ('encrypt' or 'decrypt', shift value, message). Returns: List[str]: List of resulting messages after encryption or decryption. >>> process_operations([('encrypt', 3, 'hello world'), ('decrypt', 3, 'khoor zruog')]) ['khoor zruog', 'hello world'] pass # Replace with implementation def test_shift_cipher_encrypt(): assert shift_cipher('encrypt', 3, 'hello world') == 'khoor zruog' assert shift_cipher('encrypt', 1, 'abc xyz') == 'bcd yza' assert shift_cipher('encrypt', 0, 'hello') == 'hello' def test_shift_cipher_decrypt(): assert shift_cipher('decrypt', 3, 'khoor zruog') == 'hello world' assert shift_cipher('decrypt', 1, 'bcd yza') == 'abc xyz' assert shift_cipher('decrypt', 0, 'hello') == 'hello' def test_process_operations(): operations = [ ('encrypt', 3, 'hello world'), ('decrypt', 3, 'khoor zruog') ] assert process_operations(operations) == ['khoor zruog', 'hello world'] operations = [ ('encrypt', 1, 'abc xyz'), ('decrypt', 1, 'bcd yza') ] assert process_operations(operations) == ['bcd yza', 'abc xyz']","solution":"def shift_cipher(operation, k, message): Encrypt or decrypt a message using a simple shift cipher technique. Parameters: operation (str): 'encrypt' or 'decrypt' k (int): shift value (0 ≤ k ≤ 25) message (str): the message to be encrypted or decrypted Returns: str: the resulting message after encryption or decryption. result = [] for char in message: if char.isalpha(): shift = k if operation == 'encrypt' else -k new_char = chr((ord(char) - 97 + shift) % 26 + 97) result.append(new_char) else: result.append(char) return ''.join(result) def process_operations(operations): results = [] for operation, k, message in operations: results.append(shift_cipher(operation, k, message)) return results"},{"question":"def minimum_radius(n: int, l: int, positions: List[int]) -> float: Calculate the minimum radius of light r that each lantern must provide to ensure that the entire length of the street from 0 to l is covered. >>> minimum_radius(2, 5, [1, 4]) 1.5 >>> minimum_radius(4, 8, [2, 4, 5, 7]) 2.0 >>> minimum_radius(1, 10, [4]) 6.0","solution":"def minimum_radius(n, l, positions): Returns the minimum radius of light such that the whole street is lit. positions.sort() # The maximum distance between two consecutive lanterns max_gap = 0 for i in range(1, n): max_gap = max(max_gap, positions[i] - positions[i - 1]) # The radius must cover half of the max_gap r = max_gap / 2 # Additionally, cover the starting point to the first lantern and last lantern to the end r = max(r, positions[0] - 0) r = max(r, l - positions[-1]) return r"},{"question":"from typing import List def min_removals(N: int, heights: List[int]) -> int: You are given a list of \`N\` integers representing the heights of trees. You have to remove the minimum number of trees such that the heights of the remaining trees are strictly increasing. Example: >>> min_removals(6, [3, 1, 2, 1, 4, 5]) 2 >>> min_removals(5, [3, 3, 3, 3, 3]) 4 Your task is to complete the function \`min_removals()\`, which takes an integer \`N\` and a list \`heights\` as the input parameters and returns an integer denoting the minimum number of trees that must be removed. # Your code here","solution":"from bisect import bisect_left def min_removals(N, heights): Returns the minimum number of trees that must be removed to ensure the remaining trees' heights are strictly increasing. # List to store the longest increasing subsequence lis = [] for height in heights: pos = bisect_left(lis, height) if pos == len(lis): lis.append(height) else: lis[pos] = height # Calculate the number of removals needed return N - len(lis)"},{"question":"def longest_consecutive_sequence(n: int, timestamps: List[int]) -> int: Determines the length of the longest sequence of consecutive events based on their timestamps. Parameters: n (int): The number of events. timestamps (list of int): The timestamps of the events. Returns: int: The length of the longest sequence of consecutive events. Examples: >>> longest_consecutive_sequence(6, [10, 20, 30, 31, 32, 33]) 4 >>> longest_consecutive_sequence(8, [1, 3, 5, 2, 4, 8, 6, 7]) 8","solution":"def longest_consecutive_sequence(n, timestamps): Determines the length of the longest sequence of consecutive events based on their timestamps. Parameters: n (int): The number of events. timestamps (list of int): The timestamps of the events. Returns: int: The length of the longest sequence of consecutive events. if n == 0: return 0 timestamps_set = set(timestamps) longest_sequence = 0 for timestamp in timestamps: if timestamp - 1 not in timestamps_set: current_timestamp = timestamp current_streak = 1 while current_timestamp + 1 in timestamps_set: current_timestamp += 1 current_streak += 1 longest_sequence = max(longest_sequence, current_streak) return longest_sequence"},{"question":"def longest_sequence(arr): Return the length of the longest contiguous subarray where the elements form an ascending sequence. >>> longest_sequence([1, 2, 3, 5, 6, 7, 8]) = 4 # [5, 6, 7, 8] is the longest ascending sequence >>> longest_sequence([10, 12, 13, 15]) = 2 # [12, 13] is the longest ascending sequence >>> longest_sequence([1, 3, 5, 2, 4, 6, 7, 8]) = 4 # [4, 5, 6, 7] is the longest ascending sequence >>> longest_sequence([10, 20, 30, 40]) = 1 # No contiguous ascending sequence","solution":"def longest_sequence(arr): if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1] + 1: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def total_cost_of_unique_items(n: int, purchases: List[Tuple[str, int]]) -> int: Returns the total cost of unique items in Polycarp's collection. Parameters: n : int : number of purchases purchases : list of tuples : each tuple contains the name of the item (str) and its cost (int) Returns: int : total cost of unique items >>> total_cost_of_unique_items(5, [(\\"apple\\", 100), (\\"banana\\", 200), (\\"apple\\", 150), (\\"carrot\\", 300), (\\"banana\\", 250)]) 600 >>> total_cost_of_unique_items(3, [(\\"pen\\", 50), (\\"pencil\\", 30), (\\"notebook\\", 100)]) 180 >>> total_cost_of_unique_items(3, [(\\"book\\", 50), (\\"laptop\\", 600), (\\"phone\\", 300)]) 950 >>> total_cost_of_unique_items(3, [(\\"pen\\", 30), (\\"pen\\", 50), (\\"pen\\", 10)]) 30 >>> total_cost_of_unique_items(5, [(\\"book\\", 50), (\\"book\\", 20), (\\"phone\\", 300), (\\"car\\", 200), (\\"car\\", 500)]) 550","solution":"def total_cost_of_unique_items(n, purchases): Returns the total cost of unique items in Polycarp's collection. Parameters: n : int : number of purchases purchases : list of tuples : each tuple contains the name of the item (str) and its cost (int) Returns: int : total cost of unique items unique_items = {} for item_name, cost in purchases: if item_name not in unique_items: unique_items[item_name] = cost return sum(unique_items.values())"},{"question":"def can_make_substring(s: str, t: str) -> str: Determine if it is possible to make string t a substring of string s by performing exactly one operation: inserting any character from t into any position in s once. >>> can_make_substring(\\"abxyca\\", \\"abc\\") \\"YES\\" >>> can_make_substring(\\"abcd\\", \\"ef\\") \\"NO\\"","solution":"def can_make_substring(s, t): This function checks if it's possible to make the string t a substring of string s by performing exactly one operation of inserting any character from t into any position of s. # Check for every possible insertion point in s for i in range(len(s) + 1): for c in t: # Create new string with character c inserted at position i new_s = s[:i] + c + s[i:] # Check if t is now a substring of the new string if t in new_s: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def count_pairs(arr: List[int], n: int, target: int) -> int: Counts the number of unique pairs (i, j) such that i < j and arr[i] + arr[j] equals the target. >>> count_pairs([1, 5, 7, -1, 5], 5, 6) 3 >>> count_pairs([0, 0, 0, 0], 4, 0) 6","solution":"from typing import List def count_pairs(arr: List[int], n: int, target: int) -> int: Counts the number of unique pairs (i, j) such that i < j and arr[i] + arr[j] equals the target. count = 0 num_counts = {} for i in range(n): complement = target - arr[i] if complement in num_counts: count += num_counts[complement] if arr[i] in num_counts: num_counts[arr[i]] += 1 else: num_counts[arr[i]] = 1 return count"},{"question":"def longest_lexico_substring(s: str) -> str: Find the longest substring where characters are in lexicographical order and all characters are distinct. Parameters: s (str): Input string containing only lowercase alphabets. Returns: str: Longest lexicographical substring with all distinct characters from the input string. Examples: >>> longest_lexico_substring(\\"abcabca\\") 'abc' >>> longest_lexico_substring(\\"a\\") 'a' >>> longest_lexico_substring(\\"abcdef\\") 'abcdef' >>> longest_lexico_substring(\\"aaaa\\") 'a' >>> longest_lexico_substring(\\"aebcd\\") 'bcd' >>> longest_lexico_substring(\\"abcabcabc\\") 'abc'","solution":"def longest_lexico_substring(s): Find the longest substring where characters are in lexicographical order and all characters are distinct. longest_substr = \\"\\" current_substr = \\"\\" for i in range(len(s)): # If current character is larger than the last character in the current substring # and is not already in the current substring if (not current_substr or s[i] > current_substr[-1]) and s[i] not in current_substr: current_substr += s[i] # Add character to the current substring else: # Evaluate if the current substring is the longest so far if len(current_substr) > len(longest_substr): longest_substr = current_substr # Resetting the current substring considering the same character again current_substr = s[i] # Final check in case the longest substring is at the end of the string if len(current_substr) > len(longest_substr): longest_substr = current_substr return longest_substr"},{"question":"def longest_contiguous_subarray_length(n, arr): Finds the length of the longest contiguous subarray where all elements are the same. :param n: Integer, the number of elements in the array (1 ≤ N ≤ 10^5) :param arr: List of N integers (1 ≤ ai ≤ 10^9) :return: Integer, the length of the longest contiguous subarray of the same number >>> longest_contiguous_subarray_length(5, [2, 2, 1, 1, 1]) 3 >>> longest_contiguous_subarray_length(8, [1, 2, 3, 3, 3, 5, 5, 5]) 3 >>> longest_contiguous_subarray_length(3, [9, 9, 9]) 3","solution":"def longest_contiguous_subarray_length(n, arr): Finds the length of the longest contiguous subarray where all elements are the same. :param n: Integer, the number of elements in the array (1 ≤ N ≤ 10^5) :param arr: List of N integers (1 ≤ ai ≤ 10^9) :return: Integer, the length of the longest contiguous subarray of the same number if n == 1: return 1 max_length = 1 current_length = 1 for i in range(1, n): if arr[i] == arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"from typing import List, Tuple def max_subarray_sum(arr: List[int]) -> Tuple[int, List[int]]: Finds the subarray with the maximum sum and returns both the sum and the subarray itself. >>> max_subarray_sum([1, -3, 2, 1, -1]) (3, [2, 1]) >>> max_subarray_sum([]) (0, []) >>> max_subarray_sum([1, 2, 3, 4, 5]) (15, [1, 2, 3, 4, 5])","solution":"from typing import List, Tuple def max_subarray_sum(arr: List[int]) -> Tuple[int, List[int]]: Finds the subarray with the maximum sum and returns both the sum and the subarray itself. if not arr: return (0, []) max_sum = current_sum = arr[0] start = end = s = 0 for i in range(1, len(arr)): if current_sum + arr[i] > arr[i]: current_sum += arr[i] else: current_sum = arr[i] s = i if current_sum > max_sum: max_sum = current_sum start = s end = i return (max_sum, arr[start:end + 1])"},{"question":"def min_subset_difference(n, nums): Returns the minimum possible absolute difference between the sums of two non-empty subsequences of the given list of integers. >>> min_subset_difference(4, [1, 5, 11, 5]) == 0 >>> min_subset_difference(3, [2, 3, 5]) == 0 >>> min_subset_difference(5, [11, 5, 6, 10, 9]) == 1 >>> min_subset_difference(2, [1, 2]) == 1 >>> min_subset_difference(2, [100, 101]) == 1 >>> min_subset_difference(3, [100, 200, 300]) == 0 >>> min_subset_difference(5, [1, 2, 3, 4, 5]) == 1","solution":"def min_subset_difference(n, nums): Returns the minimum possible absolute difference between the sums of two non-empty subsequences of the given list of integers. total_sum = sum(nums) # Initialize a set to store possible subset sums possible_sums = {0} for num in nums: current_sums = list(possible_sums) for s in current_sums: possible_sums.add(s + num) min_diff = float('inf') for s in possible_sums: # Only consider non-empty subsets if s > 0 and s != total_sum: diff = abs(total_sum - 2 * s) if diff < min_diff: min_diff = diff return min_diff"},{"question":"def evaluate_postfix(expression): Evaluate a postfix notation expression and return the result as an integer. :param expression: A string containing a valid postfix expression. :return: The evaluated result as an integer. >>> evaluate_postfix(\\"3 4 + 2 * 1 -\\") 13 >>> evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\") 14 >>> evaluate_postfix(\\"7 8 + 3 2 + /\\") 3","solution":"def evaluate_postfix(expression): Evaluate a postfix notation expression and return the result as an integer. :param expression: A string containing a valid postfix expression. :return: The evaluated result as an integer. stack = [] operators = set(['+', '-', '*', '/']) tokens = expression.split() for token in tokens: if token not in operators: stack.append(int(token)) else: b = stack.pop() a = stack.pop() if token == '+': result = a + b elif token == '-': result = a - b elif token == '*': result = a * b elif token == '/': result = a // b # integer division stack.append(result) return stack[0]"},{"question":"def infix_to_postfix(expression: str) -> str: Convert a given infix expression to its corresponding postfix form. >>> infix_to_postfix(\\"A+B\\") == \\"AB+\\" >>> infix_to_postfix(\\"A+(B*C)\\") == \\"ABC*+\\" >>> infix_to_postfix(\\"(A-B/C)*(A/K-L)\\") == \\"ABC/-AK/L-*\\" >>> infix_to_postfix(\\"A+B*C+D\\") == \\"ABC*+D+\\"","solution":"def infix_to_postfix(expression: str) -> str: precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3} associativity = {'+': 'L', '-': 'L', '*': 'L', '/': 'L', '^': 'R'} def has_higher_precedence(op1, op2): if precedence[op1] > precedence[op2]: return True if precedence[op1] == precedence[op2]: if associativity[op1] == 'L': return True return False output = [] stack = [] for char in expression: if char.isalpha(): # if operand, add to output output.append(char) elif char == '(': # left parenthesis, push to stack stack.append(char) elif char == ')': # right parenthesis, pop until left parenthesis while stack and stack[-1] != '(': output.append(stack.pop()) stack.pop() else: # operator encountered while (stack and stack[-1] != '(' and has_higher_precedence(stack[-1], char)): output.append(stack.pop()) stack.append(char) # pop all the remaining operators into the output while stack: output.append(stack.pop()) return \\"\\".join(output)"},{"question":"def separate_even_odd(numbers): Separates a list of integers into even and odd integers, maintaining their original order. Parameters: numbers (list of int): List of integers to be separated. Returns: tuple: A tuple containing two lists - the first list containing even integers, the second list containing odd integers. Examples: >>> separate_even_odd([12, 3, 5, 8, 6, 7, 4]) ([12, 8, 6, 4], [3, 5, 7]) >>> separate_even_odd([2, 4, 6, 8]) ([2, 4, 6, 8], []) >>> separate_even_odd([1, 3, 5, 7]) ([], [1, 3, 5, 7]) >>> separate_even_odd([0, 1, 2, 3, 4]) ([0, 2, 4], [1, 3]) >>> separate_even_odd([]) ([], [])","solution":"def separate_even_odd(numbers): Separates a list of integers into even and odd integers, maintaining their original order. Parameters: numbers (list of int): List of integers to be separated. Returns: tuple: A tuple containing two lists - the first list containing even integers, the second list containing odd integers. evens = [num for num in numbers if num % 2 == 0] odds = [num for num in numbers if num % 2 != 0] return (evens, odds)"},{"question":"import math from typing import List def is_prime(n: int) -> bool: Check if a number is prime. >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(2) True pass def apply_grading_rules(scores: List[int]) -> List[int]: Apply grading rules to a list of scores. >>> apply_grading_rules([25, 7, 18, 50]) [50, 21, 18, 50] >>> apply_grading_rules([10, 17, 64]) [10, 51, 128] pass def main(): Q = int(input()) scores = [int(input()) for _ in range(Q)] final_scores = apply_grading_rules(scores) for score in final_scores: print(score)","solution":"import math def is_prime(n): Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def apply_grading_rules(scores): Apply grading rules to a list of scores. final_scores = [] for score in scores: if math.isqrt(score) ** 2 == score: final_scores.append(score * 2) elif is_prime(score): final_scores.append(score * 3) else: final_scores.append(score) return final_scores def main(): Q = int(input()) scores = [int(input()) for _ in range(Q)] final_scores = apply_grading_rules(scores) for score in final_scores: print(score)"},{"question":"from typing import List, Dict def count_divisors(lst: List[int]) -> Dict[int, int]: Returns a dictionary where the keys are the numbers from the list, and the values are the corresponding counts of their divisors. >>> count_divisors([1, 2, 3, 4, 5]) # {1: 1, 2: 2, 3: 2, 4: 3, 5: 2} >>> count_divisors([10, 15, 21]) # {10: 4, 15: 4, 21: 4}","solution":"def count_divisors(lst): Returns a dictionary where the keys are the numbers from the list, and the values are the corresponding counts of their divisors. def divisors_count(n): count = 0 for i in range(1, int(n ** 0.5) + 1): if n % i == 0: count += 1 if i != n // i: count += 1 return count result = {} for number in lst: result[number] = divisors_count(number) return result"},{"question":"from typing import List def can_form_palindrome(s: str) -> str: Determine if it's possible to rearrange the string to form a palindrome. If possible, return one possible palindrome, otherwise return \\"NO\\". >>> can_form_palindrome('racecar') 'racecar' >>> can_form_palindrome('aabb') 'abba' or 'baab' >>> can_form_palindrome('abcdef') 'NO'","solution":"from collections import Counter def can_form_palindrome(s): Determine if it's possible to rearrange the string to form a palindrome. If possible, return one possible palindrome, otherwise return \\"NO\\". :param s: Input string :return: A palindrome string or \\"NO\\" # Get the frequency of each character in the input string freq = Counter(s) # Count characters with odd frequencies odd_count = sum(1 for count in freq.values() if count % 2 != 0) # If more than one character has an odd frequency, a palindrome is not possible if odd_count > 1: return \\"NO\\" # Initialize the parts of the palindrome left_part = [] middle_part = \\"\\" # Construct the left part of the palindrome and find the middle character (if any) for char, count in freq.items(): if count % 2 != 0: middle_part = char left_part.append(char * (count // 2)) # Create the full palindrome left_part = ''.join(left_part) right_part = left_part[::-1] return left_part + middle_part + right_part"},{"question":"def rank_participants(n, submissions): Simulates the ranking of participants in a coding competition based on their submissions and scores. Parameters: n (int): The number of submissions. submissions (list of tuples): Each tuple contains three integers (t, p, s) representing the time of submission, the participant id, and the score of the submission. Returns: list of int: The participant ids in the order of their ranking. Example: >>> rank_participants(5, [(1, 1, 100), (2, 2, 200), (3, 1, 150), (4, 3, 200), (5, 2, 250)]) [2, 3, 1] >>> rank_participants(4, [(1, 1, 300), (2, 2, 300), (3, 1, 300), (4, 2, 300)]) [1, 2] pass","solution":"def rank_participants(n, submissions): from collections import defaultdict highest_scores = defaultdict(lambda: (-1, float('inf'))) # (highest_score, earliest_time) for t, p, s in submissions: if s > highest_scores[p][0] or (s == highest_scores[p][0] and t < highest_scores[p][1]): highest_scores[p] = (s, t) sorted_participants = sorted(highest_scores.keys(), key=lambda p: (-highest_scores[p][0], highest_scores[p][1])) return sorted_participants # Example usage n = 5 submissions = [(1, 1, 100), (2, 2, 200), (3, 1, 150), (4, 3, 200), (5, 2, 250)] print(rank_participants(n, submissions)) # Output: [2, 3, 1]"},{"question":"from typing import List def find_anagram_sequences(s: str, word: str) -> List[int]: Finds all starting indices of substrings in s that are anagrams of the string word. >>> find_anagram_sequences(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> find_anagram_sequences(\\"abab\\", \\"ab\\") [0, 1, 2]","solution":"from typing import List from collections import Counter def find_anagram_sequences(s: str, word: str) -> List[int]: Finds all starting indices of substrings in s that are anagrams of the string word. len_s, len_word = len(s), len(word) result = [] if len_word > len_s: return result word_counter = Counter(word) current_counter = Counter(s[:len_word]) if current_counter == word_counter: result.append(0) for i in range(len_word, len_s): current_counter[s[i]] += 1 current_counter[s[i - len_word]] -= 1 if current_counter[s[i - len_word]] == 0: del current_counter[s[i - len_word]] if current_counter == word_counter: result.append(i - len_word + 1) return result"},{"question":"from typing import List, Tuple def find_highest_priority_tasks(T: int, projects: List[Tuple[int, List[Tuple[str, str, str]]]]) -> List[Tuple[str, int, int]]: Finds the tasks with the highest priority that can be completed the fastest. >>> find_highest_priority_tasks(2, [(3, [('Fix bugs', '8', '30'), ('Develop feature', '9', '45'), ('Optimize code', '9', '30')]), (2, [('Design UI', '7', '20'), ('Write tests', '7', '25')])]) [('Optimize code', 9, 30), ('Design UI', 7, 20)] >>> find_highest_priority_tasks(1, [(3, [('Fix bugs', '8', '30'), ('Develop feature', '9', '30'), ('Optimize code', '9', '30')])]) [('Develop feature', 9, 30), ('Optimize code', 9, 30)]","solution":"def find_highest_priority_tasks(T, projects): results = [] for project in projects: N, tasks = project highest_priority = -1 shortest_time = float('inf') best_tasks = [] for task in tasks: description, priority, time = task priority = int(priority) time = int(time) if priority > highest_priority or (priority == highest_priority and time < shortest_time): highest_priority = priority shortest_time = time best_tasks = [(description, priority, time)] elif priority == highest_priority and time == shortest_time: best_tasks.append((description, priority, time)) results.extend(best_tasks) return results # Example usage: # projects = [(3, [('Fix bugs', '8', '30'), ('Develop feature', '9', '45'), ('Optimize code', '9', '30')]), # (2, [('Design UI', '7', '20'), ('Write tests', '7', '25')])] # print(find_highest_priority_tasks(2, projects))"},{"question":"def can_reach_target(n: int, m: int, x1: int, y1: int, x2: int, y2: int, commands: str) -> str: Determine if the robotic arm can reach the target state from the initial state following the given sequence of commands within the boundaries of a grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. x1 (int): Initial row position of the robotic arm. y1 (int): Initial column position of the robotic arm. x2 (int): Target row position of the robotic arm. y2 (int): Target column position of the robotic arm. commands (str): Sequence of commands to be followed ('L', 'R', 'U', 'D'). Returns: str: \\"YES\\" if it's possible to reach the target state, otherwise \\"NO\\". Example: >>> can_reach_target(5, 5, 1, 1, 3, 3, \\"RRDD\\") \\"YES\\" >>> can_reach_target(5, 5, 1, 1, 3, 3, \\"RDD\\") \\"NO\\"","solution":"def can_reach_target(n, m, x1, y1, x2, y2, commands): x, y = x1, y1 for command in commands: if command == 'L': y -= 1 elif command == 'R': y += 1 elif command == 'U': x -= 1 elif command == 'D': x += 1 # Check if the robotic arm goes out of bounds if x < 1 or x > n or y < 1 or y > m: return \\"NO\\" return \\"YES\\" if (x == x2 and y == y2) else \\"NO\\""},{"question":"def find_indices_for_target_sum(n, arr, S): Determines if there exist two distinct indices in the array such that their sum equals the target sum S. Parameters: n (int): The number of integers in the array. arr (list of int): The elements of the array. S (int): The target sum. Returns: tuple: A tuple containing two indices if a pair is found, otherwise -1. Examples: >>> find_indices_for_target_sum(6, [1, 2, 3, 4, 5, 6], 8) (2, 5) >>> find_indices_for_target_sum(5, [1, 2, 3, 4, 5], 10) -1","solution":"def find_indices_for_target_sum(n, arr, S): Determines if there exist two distinct indices in the array such that their sum equals the target sum S. Parameters: n (int): The number of integers in the array. arr (list of int): The elements of the array. S (int): The target sum. Returns: tuple: A tuple containing two indices if a pair is found, otherwise -1. # Use a dictionary to store elements and their corresponding indices seen = {} for i in range(n): complement = S - arr[i] if complement in seen: # Return the 1-based indices if a valid pair is found return (seen[complement] + 1, i + 1) seen[arr[i]] = i # Return -1 if no such pair exists return -1"},{"question":"def treasure_hunt_points(n: int, m: int, treasures: List[List[int]]) -> List[int]: Determines the total points each team has earned over all the challenges. Args: n (int): The number of teams. m (int): The number of challenges. treasures (List[List[int]]): 2D list where each row represents the values of treasures submitted by each team in each challenge. Returns: List[int]: List where each element represents the total points earned by the corresponding team. >>> treasure_hunt_points(4, 3, [[100, 200, 300], [150, 200, 250], [300, 150, 100], [200, 300, 250]]) == [300, 0, 300, 300] >>> treasure_hunt_points(3, 3, [[10, 20, 30], [30, 10, 20], [20, 30, 10]]) == [30, 30, 30] >>> treasure_hunt_points(3, 3, [[100, 200, 300], [10, 20, 30], [1, 2, 3]]) == [600, 0, 0] >>> treasure_hunt_points(2, 2, [[100, 100], [100, 100]]) # Verifying total points >>> treasure_hunt_points(2, 1, [[100], [50]]) == [100, 0]","solution":"def calculate_points(matrix): Calculates the total points earned by each team over all challenges. Args: matrix (list of list of int): 2D list where each row represents the values of treasures submitted by each team in each challenge. Returns: list of int: List where each element represents the total points earned by the corresponding team. num_teams = len(matrix) num_challenges = len(matrix[0]) points = [0] * num_teams for j in range(num_challenges): max_value = -1 max_team_index = -1 for i in range(num_teams): if matrix[i][j] > max_value: max_value = matrix[i][j] max_team_index = i points[max_team_index] += max_value return points # Function to process input data and call the calculate_points function def treasure_hunt_points(n, m, treasures): return calculate_points(treasures)"},{"question":"def length_of_longest_unique_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> length_of_longest_unique_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_unique_substring(\\"bbbbb\\") == 1 >>> length_of_longest_unique_substring(\\"pwwkew\\") == 3 >>> length_of_longest_unique_substring(\\"a\\") == 1 >>> length_of_longest_unique_substring(\\"abcdef\\") == 6 >>> length_of_longest_unique_substring(\\"abccba\\") == 3 >>> length_of_longest_unique_substring(\\"dvdf\\") == 3 >>> length_of_longest_unique_substring(\\"abcdefghijklmnopqrstuvwxyz\\") == 26 >>> length_of_longest_unique_substring(\\"\\") == 0","solution":"def length_of_longest_unique_substring(s): Returns the length of the longest substring with all unique characters. n = len(s) if n == 0: return 0 max_len = 0 start = 0 for i in range(n): for j in range(start, i): if s[i] == s[j]: start = j + 1 break max_len = max(max_len, i - start + 1) return max_len"},{"question":"def max_total_attraction_value(n: int, exhibits: List[int]) -> int: Calculate the maximum total attraction value after optimal merging. >>> max_total_attraction_value(5, [1, 3, 5, 2, 4]) 15 >>> max_total_attraction_value(3, [10, 20, 30]) 60","solution":"def max_total_attraction_value(n, exhibits): exhibits_sum = sum(exhibits) return exhibits_sum"},{"question":"def does_first_rectangle_fit(x1, y1, x2, y2, X1, Y1, X2, Y2): Determines if the first rectangle defined by (x1, y1) and (x2, y2) completely fits inside the second rectangle defined by (X1, Y1) and (X2, Y2). >>> does_first_rectangle_fit(1, 1, 3, 3, 0, 0, 4, 4) \\"Yes\\" >>> does_first_rectangle_fit(2, 2, 5, 5, 0, 0, 4, 4) \\"No\\"","solution":"def does_first_rectangle_fit(x1, y1, x2, y2, X1, Y1, X2, Y2): Determines if the first rectangle defined by (x1, y1) and (x2, y2) completely fits inside the second rectangle defined by (X1, Y1) and (X2, Y2). if X1 <= x1 and x2 <= X2 and Y1 <= y1 and y2 <= Y2: return \\"Yes\\" else: return \\"No\\""},{"question":"def number_to_words(n: str) -> str: Converts a number between 0 and 999 into words in English. >>> number_to_words(\\"0\\") \\"zero\\" >>> number_to_words(\\"5\\") \\"five\\" >>> number_to_words(\\"123\\") \\"one hundred twenty three\\" def convert_numbers_to_words(test_cases: List[str]) -> List[str]: Converts a list of number strings to their word form in English. >>> convert_numbers_to_words([\\"0\\", \\"5\\", \\"10\\", \\"999\\"]) [\\"zero\\", \\"five\\", \\"ten\\", \\"nine hundred ninety nine\\"] >>> convert_numbers_to_words([\\"123\\", \\"456\\", \\"789\\"]) [\\"one hundred twenty three\\", \\"four hundred fifty six\\", \\"seven hundred eighty nine\\"]","solution":"def number_to_words(n): Converts a number between 0 and 999 into words in English. if n == \\"0\\": return \\"zero\\" num_dict_1_to_19 = [\\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\", \\"seven\\", \\"eight\\", \\"nine\\", \\"ten\\", \\"eleven\\", \\"twelve\\", \\"thirteen\\", \\"fourteen\\", \\"fifteen\\", \\"sixteen\\", \\"seventeen\\", \\"eighteen\\", \\"nineteen\\"] num_dict_tens = [\\"twenty\\", \\"thirty\\", \\"forty\\", \\"fifty\\", \\"sixty\\", \\"seventy\\", \\"eighty\\", \\"ninety\\"] num = int(n) words = [] if num >= 100: words.append(num_dict_1_to_19[num // 100 - 1]) words.append(\\"hundred\\") num = num % 100 if num >= 20: words.append(num_dict_tens[num // 10 - 2]) num = num % 10 if num > 0: words.append(num_dict_1_to_19[num - 1]) return \\" \\".join(words) def convert_numbers_to_words(test_cases): Converts a list of number strings to their word form in English. return [number_to_words(tc) for tc in test_cases]"},{"question":"def minDeletions(S: str, W: str) -> int: Returns the minimum number of deletions required from S to form W. If it is not possible, returns -1. >>> minDeletions(\\"abcde\\", \\"ace\\") 2 >>> minDeletions(\\"abcde\\", \\"aec\\") -1 >>> minDeletions(\\"abcdefgh\\", \\"abcdefgh\\") 0 >>> minDeletions(\\"abcdefgh\\", \\"ijk\\") -1 >>> minDeletions(\\"abc\\", \\"ab\\") 1 >>> minDeletions(\\"abcde\\", \\"\\") 5 >>> minDeletions(\\"\\", \\"abc\\") -1","solution":"def minDeletions(S, W): Returns the minimum number of deletions required from S to form W. If it is not possible, returns -1. w_idx = 0 s_len = len(S) w_len = len(W) for s_char in S: if w_idx < w_len and s_char == W[w_idx]: w_idx += 1 if w_idx == w_len: return s_len - w_len return -1"},{"question":"def can_be_shifted(s1: str, s2: str) -> bool: Determines if \`s1\` can be transformed into \`s2\` by performing a series of shift operations. >>> can_be_shifted(\\"abcde\\", \\"cdeab\\") True >>> can_be_shifted(\\"abc\\", \\"acb\\") False >>> can_be_shifted(\\"aaa\\", \\"aaa\\") True >>> can_be_shifted(\\"a\\", \\"a\\") True >>> can_be_shifted(\\"abcdefg\\", \\"fgabcde\\") True >>> can_be_shifted(\\"abcdefg\\", \\"fgabcd\\") False >>> can_be_shifted(\\"abcdefg\\", \\"gfabcde\\") False >>> can_be_shifted(\\"rotate\\", \\"aterot\\") True >>> can_be_shifted(\\"rotation\\", \\"ationrot\\") True >>> can_be_shifted(\\"rotation\\", \\"tionrota\\") True >>> can_be_shifted(\\"rotation\\", \\"rotation\\") True >>> can_be_shifted(\\"rotation\\", \\"rotatino\\") False","solution":"def can_be_shifted(s1, s2): Returns True if s1 can be transformed into s2 by performing a series of shift operations. Otherwise, returns False. if len(s1) != len(s2): return False concatenated_s1 = s1 + s1 return s2 in concatenated_s1"},{"question":"def can_communicate(n: int, q: int, links: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[str]: Determine if there is a path of direct links between two specified servers in each query. Parameters: n (int): number of servers q (int): number of queries links (List[Tuple[int, int]]): direct links between servers queries (List[Tuple[int, int]]): pairs of servers to check for communication path Returns: List[str]: List containing \\"YES\\" or \\"NO\\" for each query indicating if there is a communication path Examples: >>> can_communicate(6, 3, [(0, 1), (0, 2), (1, 3), (1, 4), (4, 5)], [(3, 5), (2, 5), (0, 4)]) ['YES', 'YES', 'YES'] >>> can_communicate(4, 2, [(0, 1), (1, 2), (2, 3)], [(0, 3), (1, 3)]) ['YES', 'YES']","solution":"class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 def can_communicate(n, q, links, queries): uf = UnionFind(n) for u, v in links: uf.union(u, v) results = [] for ai, bi in queries: if uf.find(ai) == uf.find(bi): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def find_second_largest(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the second-largest distinct integer in each list of integers for given test cases. If there is no such second-largest number, return \`-1\` for that test case. >>> find_second_largest(3, [(5, [2, 3, 6, 6, 5]), (3, [4, 4, 4]), (4, [8, 3, 3, 4])]) [5, -1, 4] >>> find_second_largest(1, [(5, [-2, -3, -6, -6, -5])]) [-3]","solution":"def find_second_largest(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] array = test_cases[i][1] # Create a set to keep only distinct elements distinct_elements = set(array) # If there are fewer than two distinct elements, we can't have a second-largest if len(distinct_elements) < 2: results.append(-1) else: # Sort the distinct elements in descending order sorted_elements = sorted(distinct_elements, reverse=True) # The second element is the second-largest results.append(sorted_elements[1]) return results"},{"question":"def minimize_max_distance(n: int) -> list[int]: Returns an arrangement of tools from 1 to n such that the maximum distance any tool has to travel from the starting position (position 1) is minimized. >>> minimize_max_distance(1) [1] >>> minimize_max_distance(2) [1, 2] >>> minimize_max_distance(3) [1, 3, 2] >>> minimize_max_distance(4) [1, 4, 2, 3] >>> minimize_max_distance(5) [1, 5, 2, 4, 3] >>> minimize_max_distance(6) [1, 6, 2, 5, 3, 4] >>> minimize_max_distance(10) [1, 10, 2, 9, 3, 8, 4, 7, 5, 6]","solution":"def minimize_max_distance(n): Returns an arrangement of tools from 1 to n such that the maximum distance any tool has to travel from the starting position (position 1) is minimized. if n == 1: return [1] result = [] left = 1 right = n while left <= right: if left == right: result.append(left) break result.append(left) result.append(right) left += 1 right -= 1 return result"},{"question":"def unique_permutations(s: str) -> int: Returns the number of unique permutations of the distinct characters in the string s, modulo 10^9+7. >>> unique_permutations('abc') == 6 >>> unique_permutations('aabc') == 6 >>> unique_permutations('abbccc') == 6 >>> unique_permutations('a') == 1 >>> unique_permutations('aaaa') == 1 >>> unique_permutations('abcdefghij' * 100) == 3628800","solution":"def unique_permutations(s): Returns the number of unique permutations of the distinct characters in the string s, modulo 10^9+7. MOD = 10**9 + 7 # Get the distinct characters from the string distinct_chars = set(s) # Number of distinct characters n = len(distinct_chars) # Calculate n! factorial = 1 for i in range(1, n + 1): factorial = (factorial * i) % MOD return factorial"},{"question":"def sum_of_powers(N: int, pairs: List[Tuple[int, int]]) -> int: Calculate the sum of all base-exponent results modulo 10^9 + 7. Args: N (int): The number of pairs. pairs (List[Tuple[int, int]]): A list of tuples where each tuple contains a base (int) and an exponent (int). Returns: int: The sum of all base-exponent results modulo 10^9 + 7. Example: >>> sum_of_powers(3, [(2, 3), (3, 2), (1, 1000000)]) 18","solution":"def sum_of_powers(N, pairs): MOD = 10**9 + 7 total_sum = 0 for b, e in pairs: total_sum = (total_sum + pow(b, e, MOD)) % MOD return total_sum"},{"question":"def decode_hex_string(encoded_str: str) -> str: Decodes a hexadecimal encoded string where each original character was represented by its two-letter lowercase hexadecimal ASCII code. Parameters: encoded_str (str): The encoded string. Returns: str: The decoded original string. >>> decode_hex_string(\\"616263\\") \\"abc\\" >>> decode_hex_string(\\"6e6f746573\\") \\"notes\\" pass def decode_multiple_cases(T: int, encoded_strings: list) -> list: Decodes multiple hexadecimal encoded strings. Parameters: T (int): Number of encoded strings. encoded_strings (list): List of encoded strings. Returns: list: List of decoded strings. >>> decode_multiple_cases(3, [\\"616263\\", \\"6e6f746573\\", \\"68656c6c6f776f726c64\\"]) [\\"abc\\", \\"notes\\", \\"helloworld\\"] >>> decode_multiple_cases(2, [\\"4a6f686e\\", \\"313233\\"]) [\\"John\\", \\"123\\"] pass","solution":"def decode_hex_string(encoded_str): Decodes a hexadecimal encoded string where each original character was represented by its two-letter lowercase hexadecimal ASCII code. Parameters: encoded_str (str): The encoded string. Returns: str: The decoded original string. decoded_str = \\"\\" for i in range(0, len(encoded_str), 2): hex_pair = encoded_str[i:i+2] decoded_str += chr(int(hex_pair, 16)) return decoded_str def decode_multiple_cases(T, encoded_strings): results = [] for encoded_str in encoded_strings: results.append(decode_hex_string(encoded_str)) return results"},{"question":"def sum_even_fibonacci(a: int, b: int, n: int) -> int: Calculate the sum of the even-valued terms in the first n terms of the modified Fibonacci sequence. Args: a (int): The first term of the modified Fibonacci sequence. b (int): The second term of the modified Fibonacci sequence. n (int): The number of terms to consider in the sequence. Returns: int: The sum of the even-valued terms in the modified Fibonacci sequence. Example: >>> sum_even_fibonacci(2, 3, 10) 188 >>> sum_even_fibonacci(1, 2, 5) 10","solution":"def sum_even_fibonacci(a: int, b: int, n: int) -> int: Calculate the sum of the even-valued terms in the first n terms of the modified Fibonacci sequence. Args: a (int): The first term of the modified Fibonacci sequence. b (int): The second term of the modified Fibonacci sequence. n (int): The number of terms to consider in the sequence. Returns: int: The sum of the even-valued terms in the modified Fibonacci sequence. fib = [a, b] while len(fib) < n: fib.append(fib[-1] + fib[-2]) even_sum = sum(x for x in fib if x % 2 == 0) return even_sum"},{"question":"def can_reach_in_exactly_k_moves(M, N, x_start, y_start, x_target, y_target, K): Determine if the knight can reach the target position in exactly K moves. Args: M (int): the number of rows in the chessboard. N (int): the number of columns in the chessboard. x_start (int): the starting x-coordinate of the knight. y_start (int): the starting y-coordinate of the knight. x_target (int): the target x-coordinate of the knight. y_target (int): the target y-coordinate of the knight. K (int): the exact number of moves to reach the target. Returns: str: \\"YES\\" if the knight can reach the target in exactly K moves, otherwise \\"NO\\". def process_knight_moves(T, test_cases): Process multiple test cases to check if the knight can reach the target position in exactly K moves. Args: T (int): the number of test cases. test_cases (list): a list of tuples, each containing M, N, x_start, y_start, x_target, y_target, and K. Returns: list: a list of strings, \\"YES\\" or \\"NO\\" for each test case respectively. # Example Test Case # Test single test cases assert can_reach_in_exactly_k_moves(8, 8, 0, 0, 1, 2, 1) == \\"YES\\" assert can_reach_in_exactly_k_moves(8, 8, 0, 0, 7, 7, 6) == \\"YES\\" assert can_reach_in_exactly_k_moves(8, 8, 0, 0, 7, 7, 7) == \\"NO\\" # Test multiple test cases test_cases = [ (8, 8, 0, 0, 1, 2, 1), (8, 8, 0, 0, 7, 7, 6), (8, 8, 0, 0, 7, 7, 7) ] assert process_knight_moves(3, test_cases) == [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_reach_in_exactly_k_moves(M, N, x_start, y_start, x_target, y_target, K): from collections import deque moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)] queue = deque([(x_start, y_start, 0)]) visited = set((x_start, y_start, 0)) while queue: x, y, d = queue.popleft() if d == K: if (x, y) == (x_target, y_target): return \\"YES\\" continue for move in moves: nx, ny = x + move[0], y + move[1] if 0 <= nx < M and 0 <= ny < N and (nx, ny, d+1) not in visited: queue.append((nx, ny, d+1)) visited.add((nx, ny, d+1)) return \\"NO\\" def process_knight_moves(T, test_cases): results = [] for test_case in test_cases: M, N, x_start, y_start, x_target, y_target, K = test_case results.append(can_reach_in_exactly_k_moves(M, N, x_start, y_start, x_target, y_target, K)) return results"},{"question":"import re from typing import List def count_words(N: int, words_list: List[str], M: int, text_list: List[str]) -> List[int]: Returns the count of each word from words_list in the given block of text. Parameters: N (int): Number of words to count words_list (list): List of words to be counted M (int): Number of lines in the block of text text_list (list): List of lines that constitute the block of text Returns: list: List of counts of each word in the order they were given. >>> count_words(3, [\\"hello\\", \\"world\\", \\"example\\"], 2, [\\"hello! world. this is an example.\\", \\"is this the example, or another example?\\"]) [1, 1, 3] >>> count_words(2, [\\"hello\\", \\"world\\"], 1, [\\"this is a test.\\"]) [0, 0] >>> count_words(2, [\\"test\\", \\"example\\"], 1, [\\"Test this example.\\"]) [1, 1] >>> count_words(3, [\\"hello\\", \\"world\\", \\"test\\"], 1, [\\"hello, world! This is a test. Test again.\\"]) [1, 1, 2] >>> count_words(1, [\\"example\\"], 1, [\\"example example example.\\"]) [3]","solution":"import re from collections import Counter def count_words(N, words_list, M, text_list): Returns the count of each word from words_list in the given block of text. Parameters: N (int): Number of words to count words_list (list): List of words to be counted M (int): Number of lines in the block of text text_list (list): List of lines that constitute the block of text Returns: list: List of counts of each word in the order they were given # Join all lines of text into a single string full_text = ' '.join(text_list).lower() # Use regular expression to tokenize the text tokens = re.findall(r'bw+b', full_text) # Get the count of each word in the block of text word_counts = Counter(tokens) # Retrieve counts for each word in the words_list result = [word_counts[word] for word in words_list] return result"},{"question":"def min_apple_trees(M: int, N: int) -> int: Calculate the minimum number of apple trees needed such that no two apple trees are in the same row or column, covering all rows and columns. >>> min_apple_trees(4, 5) 4 >>> min_apple_trees(5, 4) 4 >>> min_apple_trees(1, 100) 1 >>> min_apple_trees(100, 1) 1 >>> min_apple_trees(10, 10) 10 >>> min_apple_trees(7, 3) 3 >>> min_apple_trees(0, 0) 0 >>> min_apple_trees(0, 5) 0 >>> min_apple_trees(1, 1) 1 >>> min_apple_trees(3, 3) 3","solution":"def min_apple_trees(M, N): Calculate the minimum number of apple trees needed such that no two apple trees are in the same row or column, covering all rows and columns. # The minimum number of apple trees needed will always be the minimum of M and N return min(M, N)"},{"question":"def count_unique_wizards(test_cases): Determines the number of unique wizards involved in the exchange for a given number of test cases. Args: test_cases (List[Tuple[int, List[Tuple[int, int]]]]): A list of tuples, each containing the number of exchanges and a list of pairs representing the exchanges. Returns: List[int]: A list containing the number of unique wizards for each test case. Examples: >>> count_unique_wizards([(4, [(1, 2), (2, 3), (4, 5), (3, 5)])]) [5] >>> count_unique_wizards([(4, [(1, 2), (2, 3), (4, 5), (3, 5)]), (3, [(7, 8), (8, 9), (9, 10)])]) [5, 4]","solution":"def count_unique_wizards(test_cases): results = [] for test in test_cases: n, exchanges = test unique_wizards = set() for a, b in exchanges: unique_wizards.add(a) unique_wizards.add(b) results.append(len(unique_wizards)) return results"},{"question":"def max_artifacts(r: int, c: int, grid: List[str]) -> int: Determine the maximum count of artifacts that can be retrieved from the largest contiguous area free of obstacles. >>> max_artifacts(5, 5, [\\"..1..\\", \\".#...\\", \\"..2#.\\", \\".....\\", \\"3..#.\\"]) 6 >>> max_artifacts(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 0 >>> max_artifacts(1, 1, [\\"1\\"]) 1 >>> max_artifacts(3, 3, [\\"1.2\\", \\".9.\\", \\"3.4\\"]) 19 >>> max_artifacts(3, 3, [\\"1#2\\", \\"#9#\\", \\"3#4\\"]) 9 # Unit Test from typing import List def test_example_case(): r, c = 5, 5 grid = [ \\"..1..\\", \\".#...\\", \\"..2#.\\", \\".....\\", \\"3..#.\\" ] assert max_artifacts(r, c, grid) == 6 def test_all_empty(): r, c = 3, 3 grid = [ \\"...\\", \\"...\\", \\"...\\" ] assert max_artifacts(r, c, grid) == 0 def test_single_cell_artifact(): r, c = 1, 1 grid = [\\"1\\"] assert max_artifacts(r, c, grid) == 1 def test_multiple_artifacts_no_obstacles(): r, c = 3, 3 grid = [ \\"1.2\\", \\".9.\\", \\"3.4\\" ] assert max_artifacts(r, c, grid) == 19 def test_disconnected_areas(): r, c = 3, 3 grid = [ \\"1#2\\", \\"#9#\\", \\"3#4\\" ] assert max_artifacts(r, c, grid) == 9 def test_large_grid(): r, c = 5, 5 grid = [ \\"1...#\\", \\".#..#\\", \\"..2.#\\", \\".....\\", \\"3..#.\\" ] assert max_artifacts(r, c, grid) == 6 def test_no_artifacts(): r, c = 4, 4 grid = [ \\"....\\", \\"..\\", \\"....\\", \\"....\\" ] assert max_artifacts(r, c, grid) == 0 def test_all_obstacles(): r, c = 3, 3 grid = [ \\"#\\", \\"#\\", \\"#\\" ] assert max_artifacts(r, c, grid) == 0","solution":"def max_artifacts(r, c, grid): def dfs(x, y): if x < 0 or x >= r or y < 0 or y >= c or grid[x][y] == '#' or visited[x][y]: return 0 visited[x][y] = True count = int(grid[x][y]) if grid[x][y].isdigit() else 0 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: count += dfs(x+dx, y+dy) return count visited = [[False]*c for _ in range(r)] max_count = 0 for i in range(r): for j in range(c): if grid[i][j] != '#' and not visited[i][j]: max_count = max(max_count, dfs(i, j)) return max_count"},{"question":"def max_transaction_sum(n: int, k: int, transactions: List[int]) -> int: Find the highest total amount of transactions within any contiguous subarray of a given size. >>> max_transaction_sum(7, 3, [2, 1, 5, 1, 3, 2, -1]) 9 >>> max_transaction_sum(5, 1, [1, 2, 3, 4, 5]) 5 >>> max_transaction_sum(4, 4, [1, -1, 2, 3]) 5 >>> max_transaction_sum(5, 2, [-5, -4, -3, -2, -1]) -3 >>> max_transaction_sum(6, 3, [1000000, 999999, 1000000, -1000000, 999999, 1000000]) 2999999 >>> max_transaction_sum(6, 3, [0, 0, 0, 0, 0, 0]) 0","solution":"def max_transaction_sum(n, k, transactions): # Initialize the sum of the first 'k' elements current_sum = sum(transactions[:k]) max_sum = current_sum # Using the sliding window technique for i in range(k, n): current_sum += transactions[i] - transactions[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def largestPrime(n: int) -> int: Return the largest prime number less than or equal to n. >>> largestPrime(10) 7 >>> largestPrime(20) 19 >>> largestPrime(1) None >>> largestPrime(2) 2 >>> largestPrime(3) 3 >>> largestPrime(4) 3 >>> largestPrime(5) 5 >>> largestPrime(6) 5 >>> largestPrime(7) 7 >>> largestPrime(8) 7 >>> largestPrime(9) 7 >>> largestPrime(30) 29 >>> largestPrime(100) 97 >>> largestPrime(200) 199 >>> largestPrime(1000) 997 >>> largestPrime(0) None >>> largestPrime(990) 983","solution":"def largestPrime(n): Returns the largest prime number less than or equal to n. if n < 2: return None # no prime numbers less than or equal to 1 sieve = [True] * (n + 1) sieve[0], sieve[1] = False, False # 0 and 1 are not prime numbers p = 2 while (p * p <= n): if (sieve[p] == True): for i in range(p * p, n + 1, p): sieve[i] = False p += 1 for p in range(n, -1, -1): if sieve[p]: return p return None"},{"question":"def has_multiple_pair(nums: List[int]) -> str: Determines if there are two distinct numbers in the set such that one is a multiple of the other. Args: nums (list of int): List of positive integers. Returns: str: \\"YES\\" if there is such a pair, otherwise \\"NO\\". >>> has_multiple_pair([10, 5, 3, 15, 20]) \\"YES\\" >>> has_multiple_pair([7, 11, 13, 17]) \\"NO\\" >>> has_multiple_pair([99999959, 1000000000, 20, 100, 500]) \\"YES\\" >>> has_multiple_pair([998244353, 123456789, 100007]) \\"NO\\" >>> has_multiple_pair([2, 4]) \\"YES\\" >>> has_multiple_pair([2, 3]) \\"NO\\"","solution":"def has_multiple_pair(nums): Determines if there are two distinct numbers in the set such that one is a multiple of the other. Args: nums (list of int): List of positive integers. Returns: str: \\"YES\\" if there is such a pair, otherwise \\"NO\\". num_set = set(nums) for num in nums: for factor in range(1, int(num**0.5)+1): if num % factor == 0: if (factor in num_set and factor != num) or (num // factor in num_set and num // factor != num): return \\"YES\\" return \\"NO\\""},{"question":"def is_valid_variable_name(s: str) -> str: Checks if the given string s is a valid variable name according to the specified rules. >>> is_valid_variable_name(\\"valid_name\\") \\"VALID\\" >>> is_valid_variable_name(\\"__invalid__\\") \\"INVALID\\" def check_variable_names(test_cases: List[str]) -> List[str]: Check a list of variable names and return their validity.","solution":"def is_valid_variable_name(s): Checks if the given string s is a valid variable name according to the specified rules. if len(s) == 0: return \\"INVALID\\" if not s.replace(\\"_\\", \\"\\").isalpha(): return \\"INVALID\\" if s[0] == '_' or s[-1] == '_': return \\"INVALID\\" if '__' in s: return \\"INVALID\\" return \\"VALID\\" def check_variable_names(test_cases): results = [] for s in test_cases: results.append(is_valid_variable_name(s)) return results # Example usage: # t = int(input()) # test_cases = [input().strip() for _ in range(t)] # results = check_variable_names(test_cases) # for result in results: # print(result)"},{"question":"from functools import cmp_to_key def largest_number(arr): Form the largest possible number by concatenating the numbers in the array. >>> largest_number([54, 546, 548]) '54854654' >>> largest_number([1, 34, 3, 98, 9]) '9983431' >>> largest_number([0, 0, 0, 1]) '1000' >>> largest_number([0, 0]) '0' >>> largest_number([123456789, 987654321]) '987654321123456789' >>> largest_number([970, 980, 965]) '980970965' >>> largest_number([111, 11, 1]) '111111' >>> largest_number([22, 222, 2222]) '222222222' >>> largest_number([]) '0' pass","solution":"from functools import cmp_to_key def largest_number(arr): def compare(x, y): return (int(y + x) - int(x + y)) arr = list(map(str, arr)) arr.sort(key=cmp_to_key(compare)) result = ''.join(arr).lstrip('0') return result or '0'"},{"question":"def knapsack(N, items, W): Determine the maximum value that can be packed in a knapsack with weight limit W. Parameters: - N (int): Number of items - items (list of tuples): Each tuple consists of weight and value of an item - W (int): Maximum weight capacity of the knapsack Returns: - int: Maximum value achievable without exceeding the weight limit >>> knapsack(4, [(2, 3), (1, 2), (3, 4), (2, 2)], 5) 7 >>> knapsack(3, [(2, 3), (2, 2), (1, 1)], 5) 6 >>> knapsack(0, [], 10) 0 >>> knapsack(1, [(2, 3)], 2) 3 >>> knapsack(1, [(3, 5)], 2) 0 >>> knapsack(4, [(5, 10), (4, 7), (6, 8), (3, 4)], 25) 29 >>> knapsack(3, [(5, 1000), (4, 800), (6, 900)], 10) 1800","solution":"def knapsack(N, items, W): Determine the maximum value that can be packed in a knapsack with weight limit W. Parameters: - N (int): Number of items - items (list of tuples): Each tuple consists of weight and value of an item - W (int): Maximum weight capacity of the knapsack Returns: - int: Maximum value achievable without exceeding the weight limit # Initialize a 2D dp array with dimensions N+1 x W+1 and fill it with 0s dp = [[0] * (W + 1) for _ in range(N + 1)] for i in range(1, N + 1): weight, value = items[i-1] for w in range(W + 1): if weight <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value) else: dp[i][w] = dp[i-1][w] return dp[N][W]"},{"question":"def is_prime(n: int) -> bool: Helper function to check if a number is prime. def product_of_primes(nums: List[int]) -> int: Returns the product of prime numbers in the given list of integers. If there are no primes, returns 1. >>> product_of_primes([2, 3, 4, 7, 8]) == 42 >>> product_of_primes([1, 4, 6, 8, 9]) == 1 >>> product_of_primes([2, 3, 5, 7, 11]) == 2 * 3 * 5 * 7 * 11 >>> product_of_primes([10, 15, 23, 36, 41]) == 23 * 41 >>> product_of_primes([29]) == 29 >>> product_of_primes([3, 3, 3]) == 27","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def product_of_primes(nums): Returns the product of prime numbers in the given list of integers. If there are no primes, returns 1. product = 1 has_prime = False for num in nums: if is_prime(num): product *= num has_prime = True return product if has_prime else 1"},{"question":"def perfect_squares(N: int) -> List[int]: Returns a list of all perfect squares less than or equal to N. >>> perfect_squares(10) [1, 4, 9] >>> perfect_squares(25) [1, 4, 9, 16, 25]","solution":"def perfect_squares(N): Returns a list of all perfect squares less than or equal to N. result = [] i = 1 while i * i <= N: result.append(i * i) i += 1 return result"},{"question":"def is_palindrome_number(s: str) -> bool: Check if the given string \`s\` representing a number is a palindrome. A number is considered a palindrome if it reads the same forward and backward. >>> is_palindrome_number(\\"121\\") True >>> is_palindrome_number(\\"-121\\") False >>> is_palindrome_number(\\"123\\") False >>> is_palindrome_number(\\"7\\") True >>> is_palindrome_number(\\"1234567890987654321\\") True >>> is_palindrome_number(\\"0001000\\") True >>> is_palindrome_number(\\"0010\\") False >>> is_palindrome_number(\\"\\") False","solution":"def is_palindrome_number(s): Check if the given string s representing a number is a palindrome. # Check if the string is empty or represents a negative number if not s or s[0] == '-': return False # Check for leading zeros, valid cases are only \\"0\\" itself if s.lstrip('0') == \\"\\": return True # Check if the string reads the same forwards and backwards return s == s[::-1]"},{"question":"def max_profit(prices): Returns the maximum profit possible from buying and selling the stock once. If no profit is possible, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0","solution":"def max_profit(prices): Returns the maximum profit possible from buying and selling the stock once. If no profit is possible, returns 0. if not prices: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: profit = price - min_price if profit > max_profit: max_profit = profit if price < min_price: min_price = price return max_profit"},{"question":"def min_operations_to_increasing(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the minimum number of operations required to make the array strictly increasing. >>> min_operations_to_increasing(3, [(3, [1, 2, 3]), (4, [3, 1, 2, 1]), (5, [5, 5, 5, 5, 5])]) [0, 2, 4] >>> min_operations_to_increasing(1, [(1, [1])]) [0] >>> min_operations_to_increasing(2, [(5, [9, 8, 7, 6, 5]), (4, [1, 3, 2, 4])]) [4, 1]","solution":"def min_operations_to_increasing(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] a = test_cases[i][1] if n == 1: results.append(0) continue lis_length = [1] * n for j in range(1, n): for k in range(0, j): if a[j] > a[k]: lis_length[j] = max(lis_length[j], lis_length[k] + 1) max_lis = max(lis_length) results.append(n - max_lis) return results # Sample usage t = 3 test_cases = [ (3, [1, 2, 3]), (4, [3, 1, 2, 1]), (5, [5, 5, 5, 5, 5]) ] print(min_operations_to_increasing(t, test_cases)) # Output: [0, 2, 4]"},{"question":"from typing import List def minItems(nums: List[int], target: int) -> int: Given an array of integers \`nums\` representing the quantities of different items and a target amount \`target\`, return the minimum number of items required to reach exactly the target amount. If it is not possible to reach the target amount using any combination of the given items, return -1. >>> minItems([1, 2, 3], 7) 3 >>> minItems([5, 3], 7) -1","solution":"from typing import List def minItems(nums: List[int], target: int) -> int: # Initialize a dp array with a value larger than possible, we'll use target + 1 dp = [float('inf')] * (target + 1) dp[0] = 0 # Base case, 0 items needed to reach target 0 # Process each target value from 1 to target inclusive for t in range(1, target + 1): for num in nums: if t >= num: dp[t] = min(dp[t], dp[t - num] + 1) # If dp[target] is still infinity, it means it's not possible to reach 'target' return dp[target] if dp[target] != float('inf') else -1"},{"question":"from typing import List, Tuple def find_top_student(students: List[Tuple[str, int]]) -> str: Returns the name of the student with the highest score. If multiple students have the same highest score, returns the name of the first student with the highest score. >>> find_top_student([(\\"Alice\\", 78), (\\"Bob\\", 94), (\\"Charlie\\", 94), (\\"Dave\\", 90)]) == \\"Bob\\" >>> find_top_student([(\\"Erin\\", 85), (\\"Frank\\", 85), (\\"George\\", 84)]) == \\"Erin\\" >>> find_top_student([(\\"Hank\\", 99)]) == \\"Hank\\" >>> find_top_student([(\\"Ivy\\", 100), (\\"John\\", 99)]) == \\"Ivy\\" >>> find_top_student([(\\"Kathy\\", 75), (\\"Leo\\", 80)]) == \\"Leo\\" >>> find_top_student([])== \\"\\"","solution":"def find_top_student(students): Returns the name of the student with the highest score. If multiple students have the same highest score, returns the name of the first student with the highest score. :param students: List of tuples where each tuple contains a name and a score :return: Name of the student with the highest score if not students: return \\"\\" top_student = students[0][0] top_score = students[0][1] for name, score in students: if score > top_score: top_student = name top_score = score return top_student"},{"question":"from typing import List def min_diff_partition(n: int, arr: List[int]) -> int: Returns the minimum possible difference between the sum of two parts of the array such that the array is divided into two parts with sums as close as possible. :param n: the number of elements in the array (even integer) :param arr: list of n integers :return: minimum difference between the sums of two parts >>> min_diff_partition(4, [1, 6, 5, 11]) 1 >>> min_diff_partition(6, [3, 1, 4, 2, 2, 1]) 1","solution":"def min_diff_partition(n, arr): Returns the minimum possible difference between the sum of two parts of the array such that the array is divided into two parts with sums as close as possible. :param n: the number of elements in the array (even integer) :param arr: list of n integers :return: minimum difference between the sums of two parts total_sum = sum(arr) target = total_sum // 2 dp = [0] * (target + 1) for num in arr: for j in range(target, num - 1, -1): dp[j] = max(dp[j], dp[j - num] + num) return abs((total_sum - dp[target]) - dp[target])"},{"question":"def convert_date(date_str: str) -> str: Converts the date from \\"dd-mm-yyyy\\" format to \\"dd Month yyyy\\" format where Month is the full name of the month. >>> convert_date('15-08-1947') '15 August 1947' >>> convert_date('01-01-2000') '01 January 2000' >>> convert_date('05-05-2021') '05 May 2021' >>> convert_date('31-12-1999') '31 December 1999' >>> convert_date('21-04-2021') '21 April 2021' >>> convert_date('01-02-0001') '01 February 0001' >>> convert_date('30-06-1000') '30 June 1000' >>> convert_date('29-02-2000') '29 February 2000' # Leap year","solution":"def convert_date(date_str): Converts the date from \\"dd-mm-yyyy\\" format to \\"dd Month yyyy\\" format where Month is the full name of the month. months = [ \\"January\\", \\"February\\", \\"March\\", \\"April\\", \\"May\\", \\"June\\", \\"July\\", \\"August\\", \\"September\\", \\"October\\", \\"November\\", \\"December\\" ] day, month, year = date_str.split('-') month_name = months[int(month) - 1] return f\\"{day} {month_name} {year}\\""},{"question":"def distribute_resources(N: int, Rmin: int, resources: List[int]) -> str: Determines if it is possible to ensure all houses have at least Rmin resources just by moving resources to adjacent houses. >>> distribute_resources(5, 10, [8, 12, 14, 9, 7]) \\"YES\\" >>> distribute_resources(4, 5, [6, 2, 5, 3]) \\"NO\\"","solution":"def distribute_resources(N, Rmin, resources): Determines if it is possible to ensure all houses have at least Rmin resources just by moving resources to adjacent houses. Parameters: N (int): Number of houses Rmin (int): Minimum required resources for each house resources (list of int): List of resources available at each house Returns: str: 'YES' or 'NO' based on whether it is possible to distribute as required. resources_to_reallocate = 0 for i in range(N): if resources[i] < Rmin: if i == 0: resources_needed = Rmin - resources[i] else: if resources[i-1] + resources_to_reallocate >= Rmin: resources_needed = Rmin - resources[i] resources_to_reallocate -= resources_needed else: return \\"NO\\" else: resources_to_reallocate += resources[i] - Rmin return \\"YES\\""},{"question":"from typing import List def min_operations_to_transform(A: str, B: str) -> int: Returns the minimum number of operations required to transform string A into string B. >>> min_operations_to_transform(\\"abc\\", \\"def\\") 3 >>> min_operations_to_transform(\\"aaaa\\", \\"bbbb\\") 4 >>> min_operations_to_transform(\\"ab\\", \\"ba\\") 2","solution":"def min_operations_to_transform(A, B): Returns the minimum number of operations required to transform string A into string B. # Initialize the operation count to 0 operations = 0 # Iterate through both strings and count mismatches for i in range(len(A)): if A[i] != B[i]: operations += 1 return operations"},{"question":"def largest_square_area_from_input(input_str: str) -> int: Find the area of the largest square that can be formed entirely of 1s in the given grid input. >>> largest_square_area_from_input('''4 5 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0''') 4 >>> largest_square_area_from_input('''3 3 1 1 1 1 1 1 0 1 1''') 4 >>> largest_square_area_from_input('''1 1 1''') 1 >>> largest_square_area_from_input('''2 2 0 0 0 0''') 0 >>> largest_square_area_from_input('''3 3 0 1 0 1 1 1 0 1 0''') 1 >>> largest_square_area_from_input('''5 5 1 1 0 0 0 1 1 1 1 0 0 1 1 1 1 0 0 1 1 1 0 0 1 1 1''') 9","solution":"def largest_square_area(grid): Returns the area of the largest square of 1s in the given grid. if not grid or not grid[0]: return 0 N = len(grid) M = len(grid[0]) dp = [[0] * M for _ in range(N)] max_side = 0 for i in range(N): for j in range(M): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side def parse_input(input_str): lines = input_str.strip().split('n') N, M = map(int, lines[0].split()) grid = [list(map(int, line.split())) for line in lines[1:]] return N, M, grid def largest_square_area_from_input(input_str): N, M, grid = parse_input(input_str) return largest_square_area(grid)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1: ListNode, l2: ListNode) -> ListNode: Adds two numbers represented by linked lists l1 and l2, where the digits are stored in reverse order. :param l1: ListNode, the head of the first linked list :param l2: ListNode, the head of the second linked list :return: ListNode, the head of the resulting linked list representing the sum pass from solution import ListNode, addTwoNumbers def list_to_linked_list(lst): dummy_root = ListNode(0) ptr = dummy_root for number in lst: ptr.next = ListNode(number) ptr = ptr.next return dummy_root.next def linked_list_to_list(node): result = [] while node: result.append(node.val) node = node.next return result def test_add_two_numbers(): l1 = list_to_linked_list([2, 4, 3]) l2 = list_to_linked_list([5, 6, 4]) result = addTwoNumbers(l1, l2) assert linked_list_to_list(result) == [7, 0, 8] def test_different_lengths(): l1 = list_to_linked_list([9, 9, 9]) l2 = list_to_linked_list([1]) result = addTwoNumbers(l1, l2) assert linked_list_to_list(result) == [0, 0, 0, 1] def test_with_carry(): l1 = list_to_linked_list([9, 8]) l2 = list_to_linked_list([1]) result = addTwoNumbers(l1, l2) assert linked_list_to_list(result) == [0, 9] def test_single_nodes(): l1 = list_to_linked_list([1]) l2 = list_to_linked_list([9]) result = addTwoNumbers(l1, l2) assert linked_list_to_list(result) == [0, 1] def test_zero_addition(): l1 = list_to_linked_list([0]) l2 = list_to_linked_list([0]) result = addTwoNumbers(l1, l2) assert linked_list_to_list(result) == [0]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1, l2): Adds two numbers represented by linked lists l1 and l2, where the digits are stored in reverse order. :param l1: ListNode, the head of the first linked list :param l2: ListNode, the head of the second linked list :return: ListNode, the head of the resulting linked list representing the sum dummy_head = ListNode(0) current, carry = dummy_head, 0 while l1 or l2 or carry: val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 carry, out = divmod(val1 + val2 + carry, 10) current.next = ListNode(out) current = current.next l1 = l1.next if l1 else None l2 = l2.next if l2 else None return dummy_head.next"},{"question":"def fibonacci(n: int) -> int: Returns the n-th term of the Fibonacci sequence. >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(3) 2 >>> fibonacci(4) 3 >>> fibonacci(5) 5 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 def get_fibonacci_terms(test_cases: List[int]) -> List[int]: Returns the list of n-th terms for given test cases of Fibonacci sequence. >>> get_fibonacci_terms([1]) [1] >>> get_fibonacci_terms([5]) [5] >>> get_fibonacci_terms([1, 2, 3, 4, 5]) [1, 1, 2, 3, 5] >>> get_fibonacci_terms([10, 20, 30, 40, 50]) [55, 6765, 832040, 102334155, 12586269025]","solution":"def fibonacci(n): Returns the n-th term of the Fibonacci sequence. if n == 1 or n == 2: return 1 a, b = 1, 1 for _ in range(3, n + 1): a, b = b, a + b return b def get_fibonacci_terms(test_cases): Returns the list of n-th terms for given test cases of Fibonacci sequence. return [fibonacci(n) for n in test_cases]"},{"question":"def gcd(x, y): Returns the greatest common divisor of x and y. while y: x, y = y, x % y return x def find_final_element(arr): Returns the final remaining element in the array after performing the operations. return reduce(gcd, arr) def process_test_cases(t, test_cases): Processes multiple test cases and returns the result for each test case. results = [] for i in range(t): n, arr = test_cases[i] results.append(find_final_element(arr)) return results # Unit tests def test_sample_cases(): assert process_test_cases(2, [(3, [10, 7, 12]), (4, [2, 4, 6, 8])]) == [1, 2] def test_all_elements_same(): assert process_test_cases(1, [(5, [5, 5, 5, 5, 5])]) == [5] def test_mixed_elements(): assert process_test_cases(1, [(4, [4, 8, 12, 16])]) == [4] def test_large_values(): assert process_test_cases(1, [(3, [1000000000, 500000000, 250000000])]) == [250000000] def test_two_elements(): assert process_test_cases(1, [(2, [17, 5])]) == [1] def test_large_array(): assert process_test_cases(1, [(1000, [1] * 1000)]) == [1]","solution":"import math from functools import reduce def gcd(x, y): Returns the greatest common divisor of x and y. while y: x, y = y, x % y return x def find_final_element(arr): Returns the final remaining element in the array after performing the operations. return reduce(gcd, arr) def process_test_cases(t, test_cases): results = [] for i in range(t): n, arr = test_cases[i] results.append(find_final_element(arr)) return results"},{"question":"from typing import List, Tuple def find_k_cities_minimize_max_distance(nodes: int, edges: List[Tuple[int, int]], k: int) -> List[int]: Given a tree with \`nodes\` cities and \`nodes-1\` roads, selects \`k\` cities to minimize the maximum distance between any two remaining cities. Args: nodes (int): Number of cities. edges (List[Tuple[int, int]]): List of roads connecting cities in the format (u, v). k (int): Number of cities to keep. Returns: List[int]: List of \`k\` city numbers that should be kept. def reconstruct_path(input_string: str) -> List[int]: Converts input string to arguments for the find_k_cities_minimize_max_distance function and returns the result. Args: input_string (str): Multiline string containing the cities, roads, and the value of k. Returns: List[int]: List of \`k\` city numbers that should be kept. Example: >>> reconstruct_path(\\"6n1 2n1 3n2 4n2 5n3 6n4\\") [1, 2, 3, 6] >>> reconstruct_path(\\"5n1 2n2 3n3 4n4 5n3\\") [2, 3, 4] data = input_string.strip().split('n') n = int(data[0]) edges = [tuple(map(int, line.split())) for line in data[1:n]] k = int(data[n]) return find_k_cities_minimize_max_distance(n, edges, k) from solution import reconstruct_path def test_example_1(): input_data = \\"6n1 2n1 3n2 4n2 5n3 6n4\\" result = reconstruct_path(input_data) assert sorted(result) == sorted([1, 2, 3, 6]) def test_example_2(): input_data = \\"5n1 2n2 3n3 4n4 5n3\\" result = reconstruct_path(input_data) assert sorted(result) == sorted([2, 3, 4]) def test_small_tree(): input_data = \\"2n1 2n1\\" result = reconstruct_path(input_data) assert result == [1] or result == [2] def test_large_tree(): input_data = \\"7n1 2n2 3n3 4n4 5n5 6n6 7n3\\" expected_results = [[2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7]][::-1] result = reconstruct_path(input_data) assert sorted(result) in expected_results def test_another_configuration(): input_data = \\"4n1 2n1 3n3 4n2\\" result = reconstruct_path(input_data) assert sorted(result) == sorted([1, 3]) def test_edge_case(): input_data = \\"3n1 2n1 3n3\\" result = reconstruct_path(input_data) assert sorted(result) == sorted([1, 2, 3])","solution":"import heapq from collections import defaultdict def find_k_cities_minimize_max_distance(nodes, edges, k): def bfs(start): queue = [start] distances = {start: 0} while queue: u = queue.pop(0) for v in graph[u]: if v not in distances: queue.append(v) distances[v] = distances[u] + 1 return distances # Create adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Finding the longest path using two BFS: dist_from_any_node = bfs(1) farthest_node = max(dist_from_any_node, key=dist_from_any_node.get) dist_from_farthest_node = bfs(farthest_node) other_farthest_node = max(dist_from_farthest_node, key=dist_from_farthest_node.get) longest_path_dist = dist_from_farthest_node[other_farthest_node] # Take the middle part of the longest path to get k nodes longest_path = [] node = other_farthest_node while node != -1: longest_path.append(node) for neighbor in graph[node]: if dist_from_farthest_node[neighbor] == dist_from_farthest_node[node] - 1: node = neighbor break else: node = -1 path_length = len(longest_path) mid_point = path_length // 2 if k >= path_length: return longest_path[:k] half_k = (k + 1) // 2 res = set() if k % 2: res.update(longest_path[mid_point - half_k + 1: mid_point + half_k]) else: res.update(longest_path[mid_point - half_k: mid_point + half_k]) return list(res) # Function to convert input and output for easier testing def reconstruct_path(input_string): data = input_string.strip().split('n') n = int(data[0]) edges = [tuple(map(int, line.split())) for line in data[1:n]] k = int(data[n]) return find_k_cities_minimize_max_distance(n, edges, k)"},{"question":"def tom_wins(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if Tom can win in the game described above. >>> tom_wins(3, [(3, [2, 4, 6]), (4, [1, 2, 3, 4]), (1, [10])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> tom_wins(1, [(1, [10])]) [\\"YES\\"] >>> tom_wins(1, [(3, [2, 4, 6])]) [\\"YES\\"] >>> tom_wins(1, [(4, [1, 2, 3, 4])]) [\\"NO\\"] >>> tom_wins(1, [(4, [3, 5, 7, 9])]) [\\"YES\\"] >>> tom_wins(1, [(2, [1, 2])]) [\\"NO\\"] >>> tom_wins(1, [(4, [3, 6, 9)] = \\"YES\\"]","solution":"def tom_wins(t, test_cases): results = [] for case in test_cases: n, a = case a.sort() if n % 2 == 1 or a[0] != 1: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def spiral(n): Write a function that takes in a non-negative integer \`n\` and returns a nested array representing a spiral pattern of numbers from 1 up to \`n^2\`. The spiral should start at the top left corner and proceed in a clockwise direction. >>> spiral(0) [] >>> spiral(1) [[1]] >>> spiral(2) [[1, 2], [4, 3]] >>> spiral(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> spiral(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]","solution":"def spiral(n): Returns a nested array representing a spiral pattern of numbers from 1 up to n^2. if n == 0: return [] matrix = [[0] * n for _ in range(n)] left, right, top, bottom = 0, n - 1, 0, n - 1 value = 1 while left <= right and top <= bottom: for i in range(left, right + 1): matrix[top][i] = value value += 1 top += 1 for i in range(top, bottom + 1): matrix[i][right] = value value += 1 right -= 1 if top <= bottom: for i in range(right, left - 1, -1): matrix[bottom][i] = value value += 1 bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): matrix[i][left] = value value += 1 left += 1 return matrix"},{"question":"def max_subgrid_sum(H: int, W: int, K: int, matrix: List[List[int]]) -> int: Calculate the sum of integers in the largest sub-grid for which the sum does not exceed a given integer K. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> max_subgrid_sum(3, 3, 7, matrix) 7 >>> matrix = [ ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ] >>> max_subgrid_sum(4, 4, 20, matrix) 16 def process_input(input_str: str) -> List[int]: Process input string and return list of results for each dataset. >>> input_str = \\"3 3 7n1 2 3n4 5 6n7 8 9n4 4 20n1 1 1 1n1 1 1 1n1 1 1 1n1 1 1 1n0 0 0n\\" >>> process_input(input_str) [7, 16]","solution":"def max_subgrid_sum(H, W, K, matrix): def calculate_sum(r1, c1, r2, c2): total = pre[r2][c2] if r1 > 0: total -= pre[r1-1][c2] if c1 > 0: total -= pre[r2][c1-1] if r1 > 0 and c1 > 0: total += pre[r1-1][c1-1] return total pre = [[0] * W for _ in range(H)] for i in range(H): for j in range(W): pre[i][j] = matrix[i][j] if i > 0: pre[i][j] += pre[i-1][j] if j > 0: pre[i][j] += pre[i][j-1] if i > 0 and j > 0: pre[i][j] -= pre[i-1][j-1] max_sum = 0 for r1 in range(H): for c1 in range(W): for r2 in range(r1, H): for c2 in range(c1, W): current_sum = calculate_sum(r1, c1, r2, c2) if current_sum <= K: max_sum = max(max_sum, current_sum) return max_sum def process_input(input_str): datasets = input_str.strip().split('n') index = 0 results = [] while index < len(datasets): H, W, K = map(int, datasets[index].split()) if H == W == K == 0: break index += 1 matrix = [] for _ in range(H): row = list(map(int, datasets[index].split())) matrix.append(row) index += 1 results.append(max_subgrid_sum(H, W, K, matrix)) return results"},{"question":"def reverse_words_in_sentence(s: str) -> str: Takes a string s as input, representing a sentence with words separated by spaces. Returns the same sentence with each word reversed while maintaining their original order. >>> reverse_words_in_sentence(\\"The quick brown fox\\") == \\"ehT kciuq nworb xof\\" >>> reverse_words_in_sentence(\\"hello world\\") == \\"olleh dlrow\\" >>> reverse_words_in_sentence(\\"\\") == \\"\\"","solution":"def reverse_words_in_sentence(s): Returns the sentence with each word reversed in order but maintaining their original position. Args: s (str): Input string containing one or more words. Returns: str: Sentence with each word reversed. words = s.split() reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"from typing import List def is_balanced_parentheses(s: str) -> str: Returns 'YES' if the string s of parentheses is balanced, otherwise 'NO'. >>> is_balanced_parentheses(\\"()\\") 'YES' >>> is_balanced_parentheses(\\"(()())\\") 'YES' >>> is_balanced_parentheses(\\"(()\\") 'NO' >>> is_balanced_parentheses(\\")(\\") 'NO' >>> is_balanced_parentheses(\\"()()()()\\") 'YES' >>> is_balanced_parentheses(\\"((()))\\") 'YES' def check_parentheses_balance(data: List) -> List[str]: Processes a list of parentheses strings and returns a list indicating whether each string is balanced ('YES') or not ('NO'). >>> check_parentheses_balance([3, '()', '(()())', '(()']) ['YES', 'YES', 'NO'] >>> check_parentheses_balance([1, '(())']) ['YES'] >>> check_parentheses_balance([2, '()()', '((())']) ['YES', 'NO'] >>> check_parentheses_balance([4, '(', ')', '(())', '((()))']) ['NO', 'NO', 'YES', 'YES'] >>> check_parentheses_balance([3, '()(', '())', '(()())']) ['NO', 'NO', 'YES']","solution":"def is_balanced_parentheses(s): Returns 'YES' if the string s of parentheses is balanced, otherwise 'NO'. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return \\"NO\\" stack.pop() return \\"YES\\" if not stack else \\"NO\\" def check_parentheses_balance(data): Processes a list of parentheses strings and returns a list indicating whether each string is balanced ('YES') or not ('NO'). M = data[0] strings = data[1:] if len(strings) != M: raise ValueError(\\"Number of strings does not match the specified count\\") results = [] for s in strings: results.append(is_balanced_parentheses(s)) return results"},{"question":"def abundant_number(n: int) -> bool: Determines if a given positive integer n is an abundant number. An abundant number is a number for which the sum of its proper divisors (excluding itself) is greater than the number itself. Parameters: n (int): A positive integer Returns: bool: True if n is an abundant number, False otherwise Examples: >>> abundant_number(12) True >>> abundant_number(18) True >>> abundant_number(19) False","solution":"def abundant_number(n): Determines if a given positive integer n is an abundant number. An abundant number is a number for which the sum of its proper divisors (excluding itself) is greater than the number itself. Parameters: n (int): A positive integer Returns: bool: True if n is an abundant number, False otherwise if n <= 0: return False sum_of_divisors = 0 for i in range(1, (n // 2) + 1): if n % i == 0: sum_of_divisors += i return sum_of_divisors > n"},{"question":"def find_paths(grid): Count the number of distinct paths from the entrance to the exit in a labyrinth, represented by a binary grid, while avoiding traps. >>> grid1 = [ ... [0, 0, 1], ... [0, 0, 1], ... [1, 0, 0] ... ] >>> find_paths(grid1) 2 >>> grid2 = [ ... [0, 1], ... [1, 0] ... ] >>> find_paths(grid2) 0 >>> grid3 = [ ... [0, 0, 0] ... ] >>> find_paths(grid3) 1 >>> grid4 = [ ... [0], ... [0], ... [0] ... ] >>> find_paths(grid4) 1 >>> grid5 = [ ... [0, 0, 1], ... [1, 1, 0], ... [1, 0, 0] ... ] >>> find_paths(grid5) 0 >>> grid6 = [ ... [0, 0, 0, 0], ... [0, 1, 0, 0], ... [0, 0, 1, 0], ... [0, 0, 0, 0] ... ] >>> find_paths(grid6) 4 >>> grid7 = [ ... [1, 0], ... [0, 0] ... ] >>> find_paths(grid7) 0 >>> grid8 = [ ... [0, 0], ... [0, 1] ... ] >>> find_paths(grid8) 0","solution":"def find_paths(grid): if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 rows, cols = len(grid), len(grid[0]) # Initialize a DP table dp = [[0 for _ in range(cols)] for _ in range(rows)] dp[0][0] = 1 # Start point for i in range(rows): for j in range(cols): if grid[i][j] == 1: dp[i][j] = 0 # No path through a trap else: if i > 0: dp[i][j] += dp[i-1][j] # Paths coming from the top if j > 0: dp[i][j] += dp[i][j-1] # Paths coming from the left return dp[-1][-1]"},{"question":"def filter_range(arr, low, high): Returns a new list containing only the elements from arr that fall within the range inclusively between low and high. Examples: >>> filter_range([1, 5, 8, 12, 4, 18, 3], 4, 10) [5, 8, 4] >>> filter_range([20, 30, 40, 50], 25, 45) [30, 40] >>> filter_range([5, 10, 15, 20, 25], 11, 19) [15]","solution":"def filter_range(arr, low, high): Returns a new list containing only the elements from arr that fall within the range inclusively between low and high. return [x for x in arr if low <= x <= high]"},{"question":"def count_occurrences(s: str, sub: str) -> int: Count the number of non-overlapping occurrences of substring \`sub\` in string \`s\`. >>> count_occurrences(\\"testtesttest\\", \\"test\\") # Returns: 3 >>> count_occurrences(\\"ababcabc\\", \\"abc\\") # Returns: 2 >>> count_occurrences(\\"aaa\\", \\"aa\\") # Returns: 1 pass def test_count_occurrences(): assert count_occurrences(\\"testtesttest\\", \\"test\\") == 3 assert count_occurrences(\\"ababcabc\\", \\"abc\\") == 2 assert count_occurrences(\\"aaa\\", \\"aa\\") == 1 assert count_occurrences(\\"abcd\\", \\"e\\") == 0 assert count_occurrences(\\"abababab\\", \\"ab\\") == 4 assert count_occurrences(\\"aaaaa\\", \\"aa\\") == 2 assert count_occurrences(\\"abababab\\", \\"aba\\") == 2 assert count_occurrences(\\"mississippi\\", \\"issi\\") == 1 assert count_occurrences(\\"mississippi\\", \\"ss\\") == 2 assert count_occurrences(\\"hello\\", \\"ll\\") == 1 assert count_occurrences(\\"hello\\", \\"o\\") == 1 assert count_occurrences(\\"hello\\", \\"z\\") == 0 assert count_occurrences(\\"a\\"*1000+\\"b\\", \\"a\\"*1000) == 1","solution":"def count_occurrences(s, sub): Count the number of non-overlapping occurrences of substring \`sub\` in string \`s\`. count = 0 start = 0 while start <= len(s) - len(sub): index = s.find(sub, start) if index == -1: break count += 1 start = index + len(sub) return count"},{"question":"def max_distinct_palindromic_substrings(s: str) -> int: Returns the maximum number of distinct palindromic substrings that can be formed using the characters of the string s. >>> max_distinct_palindromic_substrings(\\"a\\") 1 >>> max_distinct_palindromic_substrings(\\"aa\\") 1 >>> max_distinct_palindromic_substrings(\\"ab\\") 2 >>> max_distinct_palindromic_substrings(\\"abbaa\\") 2 >>> max_distinct_palindromic_substrings(\\"abcabc\\") 3 >>> max_distinct_palindromic_substrings(\\"aaaaa\\") 1 >>> max_distinct_palindromic_substrings(\\"aabbcc\\") 3 >>> max_distinct_palindromic_substrings(\\"abcdef\\") 6","solution":"def max_distinct_palindromic_substrings(s): Returns the maximum number of distinct palindromic substrings that can be formed using the characters of the string s. from collections import Counter # Count the frequency of each character freq = Counter(s) # For a character to form a palindromic substring, at least one # of that character is needed count = 0 for char in freq: # If frequency is more than 0, it is eligible to form a palindrome if freq[char] > 0: count += 1 return count"},{"question":"def min_subarray_length(arr, k): Returns the length of the smallest contiguous subarray whose sum is greater than or equal to k. If no such subarray exists, returns -1. >>> min_subarray_length([1, 2, 3, 4, 5], 11) 3 >>> min_subarray_length([1, 2, 3, 4], 15) -1 >>> min_subarray_length([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_length([1, 1, 1, 1, 1, 1, 10], 10) 1 >>> min_subarray_length([10, 2, 3], 6) 1 >>> min_subarray_length([1, 2, 3, 4, 5, 6, 7, 8, 9], 15) 2 def process_test_cases(t, test_cases): Processes multiple test cases and returns the results for each. >>> process_test_cases(2, [((5, 11), [1, 2, 3, 4, 5]), ((4, 15), [1, 2, 3, 4])]) [3, -1] >>> process_test_cases(2, [((6, 7), [2, 3, 1, 2, 4, 3]), ((7, 10), [1, 1, 1, 1, 1, 1, 10])]) [2, 1]","solution":"def min_subarray_length(arr, k): Returns the length of the smallest contiguous subarray whose sum is greater than or equal to k. If no such subarray exists, returns -1. n = len(arr) min_len = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= k: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 return min_len if min_len != float('inf') else -1 def process_test_cases(t, test_cases): Processes multiple test cases and returns the results for each. results = [] for i in range(t): n, k = test_cases[i][0] arr = test_cases[i][1] result = min_subarray_length(arr, k) results.append(result) return results"},{"question":"def largestPrimeFactor(n: int) -> int: Returns the largest prime factor of the given number n. >>> largestPrimeFactor(15) 5 >>> largestPrimeFactor(17) 17 >>> largestPrimeFactor(2) 2 >>> largestPrimeFactor(4) 2 >>> largestPrimeFactor(100) 5 >>> largestPrimeFactor(13195) 29 >>> largestPrimeFactor(600851475143) 6857 >>> largestPrimeFactor(2 * 3 * 5 * 7 * 11 * 13) 13 >>> largestPrimeFactor(2 * 2 * 2 * 2 * 11) 11","solution":"def largestPrimeFactor(n): Returns the largest prime factor of the given number n. def is_prime(x): if x <= 1: return False if x <= 3: return True if x % 2 == 0 or x % 3 == 0: return False i = 5 while i * i <= x: if x % i == 0 or x % (i + 2) == 0: return False i += 6 return True # Start dividing n by 2 until it's odd while n % 2 == 0: max_prime = 2 n //= 2 # Check odd factors starting from 3 factor = 3 while factor * factor <= n: while n % factor == 0: max_prime = factor n //= factor factor += 2 # If n is still greater than 2, then it is prime if n > 2: max_prime = n return max_prime"},{"question":"def minBoxes(boxes: List[int], W: int) -> int: Determine the minimum number of boxes needed to collect exactly W widgets. If it's not possible to fulfill the order exactly, return -1. Args: boxes (List[int]): Array where boxes[i] represents the number of widgets in the i-th box. W (int): The number of widgets needed to fulfill the order. Returns: int: The minimum number of boxes required to fulfill the order, or -1 if it's not possible. Examples: >>> minBoxes([4, 1, 3, 2, 5], 8) 2 >>> minBoxes([1, 2, 3, 4, 5], 11) 3 >>> minBoxes([1, 2, 3], 7) -1","solution":"def minBoxes(boxes, W): # Initialize a dp array, where dp[i] will represent the minimum number of boxes required to make i widgets dp = [float('inf')] * (W + 1) dp[0] = 0 # Base case: no boxes are needed to make 0 widgets # Iterate through all boxes, updating the dp array for box in boxes: for i in range(W, box - 1, -1): dp[i] = min(dp[i], dp[i - box] + 1) # If dp[W] is still infinity, it means it's not possible to collect exactly W widgets return dp[W] if dp[W] != float('inf') else -1"},{"question":"def check_divisibility(B: int, N: int) -> str: Check if B is divisible by N without a remainder. >>> check_divisibility(10, 2) 'YES' >>> check_divisibility(15, 3) 'YES' >>> check_divisibility(10, 3) 'NO' >>> check_divisibility(15, 2) 'NO' pass def test_check_divisibility_yes(): assert check_divisibility(10, 2) == \\"YES\\" assert check_divisibility(15, 3) == \\"YES\\" assert check_divisibility(20, 5) == \\"YES\\" assert check_divisibility(-30, 10) == \\"YES\\" def test_check_divisibility_no(): assert check_divisibility(10, 3) == \\"NO\\" assert check_divisibility(15, 2) == \\"NO\\" assert check_divisibility(21, 5) == \\"NO\\" assert check_divisibility(-31, 10) == \\"NO\\" def test_check_divisibility_edge_cases(): assert check_divisibility(0, 1) == \\"YES\\" assert check_divisibility(0, 5) == \\"YES\\" assert check_divisibility(-1, 1) == \\"YES\\" assert check_divisibility(-10**9, 10**9) == \\"YES\\" assert check_divisibility(-10**9, 1) == \\"YES\\"","solution":"def check_divisibility(B, N): Returns 'YES' if B is divisible by N without a remainder; otherwise returns 'NO'. if B % N == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def minimum_price(p: float, k: int, discounts: List[int]) -> float: Calculate the minimum possible price of the item after applying discounts optimally. Parameters: p (float): The initial price of the item. k (int): The number of discount coupons. discounts (list of int): The list of discount percentages. Returns: float: The minimum possible price of the item, rounded to two decimal places. Examples: >>> minimum_price(100.00, 3, [20, 30, 50]) 28.00 >>> minimum_price(250.00, 2, [10, 5]) 213.75","solution":"def minimum_price(p, k, discounts): Calculate the minimum possible price of the item after applying discounts optimally. Parameters: p (float): The initial price of the item. k (int): The number of discount coupons. discounts (list of int): The list of discount percentages. Returns: float: The minimum possible price of the item, rounded to two decimal places. discounts.sort(reverse=True) # Sort discounts in descending order for discount in discounts: p *= (1 - discount / 100) return round(p, 2)"},{"question":"def can_partition_k_subsets(nums: List[int], k: int) -> str: Determine if it's possible to partition the array into k subsets with equal sum. >>> can_partition_k_subsets([4, 3, 2, 3], 2) \\"YES\\" >>> can_partition_k_subsets([3, 3, 3, 4, 2], 3) \\"NO\\" >>> can_partition_k_subsets([2, 5, 1, 6, 2, 4], 4) \\"NO\\" def solve(test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Solve multiple test cases of the partition problem. >>> solve([((4, 2), [4, 3, 2, 3]), ((5, 3), [3, 3, 3, 4, 2]), ((6, 4), [2, 5, 1, 6, 2, 4])]) [\\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def can_partition_k_subsets(nums, k): total_sum = sum(nums) if total_sum % k != 0: return \\"NO\\" target_sum = total_sum // k def can_partition(start, k, current_sum, bucket): if k == 1: return True if current_sum == target_sum: return can_partition(0, k - 1, 0, bucket) for i in range(start, len(nums)): if not bucket[i] and current_sum + nums[i] <= target_sum: bucket[i] = True if can_partition(i + 1, k, current_sum + nums[i], bucket): return True bucket[i] = False return False nums.sort(reverse=True) bucket = [False] * len(nums) return \\"YES\\" if can_partition(0, k, 0, bucket) else \\"NO\\" def solve(test_cases): results = [] for test_case in test_cases: N, k = test_case[0] nums = test_case[1] results.append(can_partition_k_subsets(nums, k)) return results"},{"question":"def retrieve_gemstones(gemstones, queries): Retrieves the gemstones that match certain queries based on weight, clarity, or color. Parameters: gemstones (list of tuples): A list where each tuple contains the weight (int), clarity (str), and color (int) of a gemstone. queries (list of tuples): A list where each tuple contains a query type ('weight', 'clarity', 'color') and an associated value (int or str). Returns: List[int]: A list where each element is the number of gemstones that match the corresponding query. pass def test_retrieve_gemstones_weight(): gemstones = [(10, \\"VVS1\\", 5), (15, \\"VS2\\", 7), (8, \\"SI1\\", 2), (12, \\"VVS1\\", 4), (20, \\"VS1\\", 8)] queries = [(\\"weight\\", 10), (\\"weight\\", 15), (\\"weight\\", 8)] assert retrieve_gemstones(gemstones, queries) == [1, 1, 1] def test_retrieve_gemstones_clarity(): gemstones = [(10, \\"VVS1\\", 5), (15, \\"VS2\\", 7), (8, \\"SI1\\", 2), (12, \\"VVS1\\", 4), (20, \\"VS1\\", 8)] queries = [(\\"clarity\\", \\"VVS1\\"), (\\"clarity\\", \\"VS2\\"), (\\"clarity\\", \\"SI1\\")] assert retrieve_gemstones(gemstones, queries) == [2, 1, 1] def test_retrieve_gemstones_color(): gemstones = [(10, \\"VVS1\\", 5), (15, \\"VS2\\", 7), (8, \\"SI1\\", 2), (12, \\"VVS1\\", 4), (20, \\"VS1\\", 8)] queries = [(\\"color\\", 5), (\\"color\\", 7), (\\"color\\", 8)] assert retrieve_gemstones(gemstones, queries) == [1, 1, 1] def test_retrieve_gemstones_multiple_matching_gemstones(): gemstones = [(10, \\"VVS1\\", 5), (12, \\"VVS1\\", 5), (8, \\"VVS1\\", 2), (12, \\"VVS1\\", 4), (20, \\"VS1\\", 8)] queries = [(\\"clarity\\", \\"VVS1\\")] assert retrieve_gemstones(gemstones, queries) == [4] def test_retrieve_gemstones_no_matches(): gemstones = [(10, \\"VVS1\\", 5), (15, \\"VS2\\", 7), (8, \\"SI1\\", 2), (12, \\"VVS1\\", 4), (20, \\"VS1\\", 8)] queries = [(\\"weight\\", 25), (\\"clarity\\", \\"IF\\"), (\\"color\\", 11)] assert retrieve_gemstones(gemstones, queries) == [0, 0, 0]","solution":"def retrieve_gemstones(gemstones, queries): Retrieves the gemstones that match certain queries based on weight, clarity, or color. Parameters: gemstones (list of tuples): A list where each tuple contains the weight (int), clarity (str), and color (int) of a gemstone. queries (list of tuples): A list where each tuple contains a query type ('weight', 'clarity', 'color') and an associated value (int or str). Returns: List[int]: A list where each element is the number of gemstones that match the corresponding query. results = [] for query_type, query_value in queries: if query_type == \\"weight\\": count = sum(1 for gemstone in gemstones if gemstone[0] == query_value) elif query_type == \\"clarity\\": count = sum(1 for gemstone in gemstones if gemstone[1] == query_value) elif query_type == \\"color\\": count = sum(1 for gemstone in gemstones if gemstone[2] == query_value) results.append(count) return results"},{"question":"def conveyor_belt_simulation(C, N, packages): Simulates the conveyor belt system and returns the minimum number of time units required to transport all packages to their destinations. :param C: (int) Capacity of the conveyor belt :param N: (int) Number of packages :param packages: (list) List of tuples representing the packages. Each tuple contains three values: size, unique identifier, and destination. :returns: (int) Minimum number of time units required to transport all packages >>> conveyor_belt_simulation(10, 3, [(5, 'A123', 'X'), (4, 'B234', 'Y'), (6, 'C345', 'Z')]) 2 >>> conveyor_belt_simulation(10, 2, [(4, 'D567', 'X'), (6, 'E678', 'Y')]) 1 >>> conveyor_belt_simulation(10, 1, [(7, 'F890', 'Z')]) 1 >>> conveyor_belt_simulation(8, 3, [(7, 'G123', 'X'), (8, 'H234', 'Y'), (5, 'I345', 'Z')]) 3 >>> conveyor_belt_simulation(10, 5, [(3, 'J456', 'X'), (6, 'K567', 'Y'), (5, 'L678', 'Z'), (4, 'M789', 'A'), (7, 'N890', 'B')]) 3","solution":"def conveyor_belt_simulation(C, N, packages): Simulates the conveyor belt system and returns the minimum number of time units required to transport all packages to their destinations. :param C: (int) Capacity of the conveyor belt :param N: (int) Number of packages :param packages: (list) List of tuples representing the packages. Each tuple contains three values: size, unique identifier, and destination. :returns: (int) Minimum number of time units required to transport all packages sorted_packages = sorted(packages, reverse=True) time_units = 0 while sorted_packages: current_unit_capacity = C index = 0 while index < len(sorted_packages): package_size = sorted_packages[index][0] if package_size <= current_unit_capacity: current_unit_capacity -= package_size sorted_packages.pop(index) else: index += 1 time_units += 1 return time_units # Example usage: # packages = [(5, 'A123', 'X'), (4, 'B234', 'Y'), (6, 'C345', 'Z')] # print(conveyor_belt_simulation(10, 3, packages)) # Output should be 2"},{"question":"def is_valid_palindrome(s: str) -> bool: Determines if a given string is a valid palindrome after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters. :param s: Input string :return: True if the given string is a valid palindrome, False otherwise pass def test_is_valid_palindrome_valid_cases(): assert is_valid_palindrome(\\"A man, a plan, a canal: Panama\\") == True assert is_valid_palindrome(\\"abba\\") == True assert is_valid_palindrome(\\"Able , was I saw eLba\\") == True assert is_valid_palindrome(\\"No 'x' in Nixon\\") == True def test_is_valid_palindrome_invalid_cases(): assert is_valid_palindrome(\\"race a car\\") == False assert is_valid_palindrome(\\"hello world\\") == False assert is_valid_palindrome(\\"not a palindrome\\") == False def test_is_valid_palindrome_edge_cases(): assert is_valid_palindrome(\\"\\") == True # An empty string can be considered a palindrome assert is_valid_palindrome(\\"a\\") == True assert is_valid_palindrome(\\" \\") == True # A single space or only spaces can be considered a palindrome","solution":"def is_valid_palindrome(s: str) -> bool: Determines if a given string is a valid palindrome after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters. :param s: Input string :return: True if the given string is a valid palindrome, False otherwise # Normalize the string by converting to lowercase and removing non-alphanumeric characters normalized_str = ''.join(char.lower() for char in s if char.isalnum()) # Check if the normalized string reads the same forwards and backwards return normalized_str == normalized_str[::-1]"},{"question":"def longest_subarray_no_adjacent_same_color(n: int, tiles: List[int]) -> int: Returns the length of the longest contiguous subarray where no two adjacent tiles share the same color. >>> longest_subarray_no_adjacent_same_color(5, [1, 2, 3, 4, 5]) 5 >>> longest_subarray_no_adjacent_same_color(7, [3, 3, 3, 3, 3, 3, 3]) 1 >>> longest_subarray_no_adjacent_same_color(8, [1, 2, 1, 2, 1, 2, 1, 2]) 8","solution":"def longest_subarray_no_adjacent_same_color(n, tiles): Returns the length of the longest contiguous subarray where no two adjacent tiles share the same color. if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if tiles[i] != tiles[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def calculate_total_points(monsters): Calculate the total points Nick has earned from defeating monsters. Each type of monster yields a different number of points: - Goblin: 5 points - Troll: 10 points - Dragon: 50 points - Ogre: 30 points - Lich: 100 points The function takes a list of monsters that Nick has defeated and returns the total points. >>> calculate_total_points([\\"Lich\\", \\"Goblin\\", \\"Dragon\\", \\"Goblin\\", \\"Ogre\\"]) 190 >>> calculate_total_points([\\"Troll\\", \\"Ogre\\", \\"Ogre\\"]) 70 >>> calculate_total_points([]) 0","solution":"def calculate_total_points(monsters): points = {\\"Goblin\\": 5, \\"Troll\\": 10, \\"Dragon\\": 50, \\"Ogre\\": 30, \\"Lich\\": 100} total_points = 0 for monster in monsters: total_points += points.get(monster, 0) return total_points"},{"question":"def encode_secret(message: str, shift: int) -> str: Encodes the given message by shifting each alphabetic character forward by the specified number of places in the alphabet. Non-alphabetic characters remain unchanged. :param message: The string containing the message to encode. :param shift: The number of positions to shift each alphabetic character. :return: The encoded message. >>> encode_secret(\\"hello\\", 3) 'khoor' >>> encode_secret(\\"abc-z\\", 2) 'cde-b'","solution":"def encode_secret(message: str, shift: int) -> str: Encodes the given message by shifting each alphabetic character forward by the specified number of places in the alphabet. Non-alphabetic characters remain unchanged. :param message: The string containing the message to encode. :param shift: The number of positions to shift each alphabetic character. :return: The encoded message. encoded_message = [] for char in message: if 'a' <= char <= 'z': new_pos = (ord(char) - ord('a') + shift) % 26 encoded_message.append(chr(ord('a') + new_pos)) elif 'A' <= char <= 'Z': new_pos = (ord(char) - ord('A') + shift) % 26 encoded_message.append(chr(ord('A') + new_pos)) else: encoded_message.append(char) return ''.join(encoded_message)"},{"question":"from typing import List, Tuple def network_delay(n: int, m: int, c: int, cables: List[Tuple[int, int, int]], configurations: List[Tuple[int, int]]) -> List[int]: Determine the minimum delay times for sending a data packet from source to destination computers in a network. :param n: int - number of computers :param m: int - number of cables :param c: int - number of cable configurations :param cables: List of tuples (A_i, B_i, T_i) describing cables :param configurations: List of tuples (X, Y) describing configurations :return: List[int] - minimum delay times for each configuration >>> n = 5 >>> m = 6 >>> c = 2 >>> cables = [(1, 2, 3), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 2), (4, 5, 5)] >>> configurations = [(1, 5), (2, 4)] >>> network_delay(n, m, c, cables, configurations) [6, 7] pass from solution import network_delay def test_example_1(): n = 5 m = 6 c = 2 cables = [(1, 2, 3), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 2), (4, 5, 5)] configurations = [(1, 5), (2, 4)] expected = [6, 7] assert network_delay(n, m, c, cables, configurations) == expected def test_unreachable(): n = 4 m = 2 c = 1 cables = [(1, 2, 1), (3, 4, 1)] configurations = [(1, 3)] expected = [-1] assert network_delay(n, m, c, cables, configurations) == expected def test_single_computer(): n = 1 m = 0 c = 1 cables = [] configurations = [(1, 1)] expected = [0] assert network_delay(n, m, c, cables, configurations) == expected def test_large_simple_case(): n = 2 m = 1 c = 1 cables = [(1, 2, 5)] configurations = [(1, 2)] expected = [5] assert network_delay(n, m, c, cables, configurations) == expected def test_multiple_same_paths(): n = 5 m = 6 c = 1 cables = [(1, 2, 2), (1, 3, 2), (2, 4, 2), (3, 4, 2), (4, 5, 3), (2, 5, 6)] configurations = [(1, 5)] expected = [7] assert network_delay(n, m, c, cables, configurations) == expected","solution":"import heapq from collections import defaultdict def network_delay(n, m, c, cables, configurations): :param n: int - number of computers :param m: int - number of cables :param c: int - number of cable configurations :param cables: List[Tuple[int, int, int]] - list of tuples (A_i, B_i, T_i) describing cables :param configurations: List[Tuple[int, int]] - list of tuples (X, Y) describing configurations :return: List[int] - minimum delay times for each configuration # Create a graph representation from the given cables graph = defaultdict(list) for a, b, t in cables: graph[a].append((b, t)) graph[b].append((a, t)) # Function to implement Dijkstra's algorithm def dijkstra(start, end): pq = [(0, start)] dist = {i: float('inf') for i in range(1, n+1)} dist[start] = 0 while pq: curr_delay, node = heapq.heappop(pq) if node == end: return curr_delay for neighbor, weight in graph[node]: new_delay = curr_delay + weight if new_delay < dist[neighbor]: dist[neighbor] = new_delay heapq.heappush(pq, (new_delay, neighbor)) return -1 # Process each configuration result = [] for x, y in configurations: result.append(dijkstra(x, y)) return result # Example usage n = 5 m = 6 c = 2 cables = [(1, 2, 3), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 2), (4, 5, 5)] configurations = [(1, 5), (2, 4)] print(network_delay(n, m, c, cables, configurations))"},{"question":"def process_operations(operations: List[Tuple[str, int]]) -> List[str]: Raj has a stack of books he wants to organize. Each book has a unique identifier (ID), which is a positive integer. He can perform the following operations: 1. Add a book to the top of the stack. 2. Remove the book from the top of the stack. 3. Check whether a specific book with a given ID is in the stack. Raj will perform a series of these operations, and your task is to help him by implementing a function \`process_operations\` to perform the operations and return the results of the 'check' operations. Args: operations: A list of tuples, where each tuple contains a string and an integer. The string will be one of \\"add\\", \\"remove\\", or \\"check\\", and the integer will be the book's ID. The \\"check\\" operation should return \\"YES\\" if the book is in the stack, and \\"NO\\" otherwise. Returns: A list of strings with the results of the \\"check\\" operations in the order they appear in the input list. Example: >>> process_operations([(\\"add\\", 5), (\\"add\\", 3), (\\"check\\", 5), (\\"remove\\", 3), (\\"check\\", 3)]) [\\"YES\\", \\"NO\\"] >>> process_operations([(\\"add\\", 7), (\\"check\\", 7), (\\"remove\\", 7), (\\"check\\", 7)]) [\\"YES\\", \\"NO\\"]","solution":"def process_operations(operations): stack = [] results = [] for operation in operations: action, book_id = operation if action == \\"add\\": stack.append(book_id) elif action == \\"remove\\": if stack: stack.pop() elif action == \\"check\\": if book_id in stack: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def matchmaking(input_data: str) -> List[int]: You are tasked with developing a pairing mechanism for a matchmaking service. The service aims to match individuals based on their preferences and certain constraints. The service stores data about individuals, including their unique IDs, ages, preferences (each person can list up to three desired characteristics in a partner), and location (represented as Cartesian coordinates). Your task is to find compatible pairs of individuals based on the following rules: - One of the preferred characteristics of each individual must match a characteristic of their prospective partner. - The age difference between the two individuals must not exceed seven years. - The distance between the two individuals should not exceed 50 units. Given these conditions, write a program that takes a list of individuals' data and returns the number of valid pairs that can be formed. Args: input_data (str): The input consists of one or more datasets. Each dataset contains several lines, starting with an integer n (1 ≤ n ≤ 500), indicating the number of individuals in the dataset. Each of the next n lines contains: - Two integers id and age - Three strings representing preferences (strings defining characteristics could be any alphanumeric string without spaces) - Two decimal numbers representing the location coordinates (x, y) The end of the input is indicated by a line containing a single zero. Returns: List[int]: For each dataset, a single integer representing the number of valid pairs that can be formed according to the constraints described. Example: >>> matchmaking(\\"4n101 25 hiking photography reading 10.0 20.0n102 27 hiking cooking music 15.0 24.0n103 30 fitness music drawing 14.0 13.0n104 35 reading traveling hiking 40.0 50.0n2n105 22 gaming cooking hiking 12.0 8.0n106 24 cooking dancing gaming 22.0 18.0n0\\") [2, 1] >>> matchmaking(\\"3n201 40 chess painting coding 100.0 100.0n202 20 football music fishing 200.0 200.0n203 30 reading photography gaming 300.0 300.0n0\\") [0] >>> matchmaking(\\"1n301 25 hiking photography reading 10.0 20.0n0\\") [0] Tests: def test_matchmaking_single_dataset(): input_data = \\"4n101 25 hiking photography reading 10.0 20.0n102 27 hiking cooking music 15.0 24.0n103 30 fitness music drawing 14.0 13.0n104 35 reading traveling hiking 40.0 50.0n0\\" assert matchmaking(input_data) == [2] def test_matchmaking_multiple_datasets(): input_data = \\"4n101 25 hiking photography reading 10.0 20.0n102 27 hiking cooking music 15.0 24.0n103 30 fitness music drawing 14.0 13.0n104 35 reading traveling hiking 40.0 50.0n2n105 22 gaming cooking hiking 12.0 8.0n106 24 cooking dancing gaming 22.0 18.0n0\\" assert matchmaking(input_data) == [2, 1] def test_matchmaking_no_valid_pairs(): input_data = \\"3n201 40 chess painting coding 100.0 100.0n202 20 football music fishing 200.0 200.0n203 30 reading photography gaming 300.0 300.0n0\\" assert matchmaking(input_data) == [0] def test_matchmaking_single_person(): input_data = \\"1n301 25 hiking photography reading 10.0 20.0n0\\" assert matchmaking(input_data) == [0]","solution":"import math def count_valid_pairs(datasets): def calculate_distance(x1, y1, x2, y2): return math.sqrt((x1 - x2)**2 + (y1 - y2)**2) results = [] for dataset in datasets: n = dataset[0] individuals = dataset[1] valid_pairs = 0 for i in range(n): id1, age1, pref1, pref2, pref3, x1, y1 = individuals[i] for j in range(i + 1, n): id2, age2, pref4, pref5, pref6, x2, y2 = individuals[j] if abs(age1 - age2) <= 7: if calculate_distance(x1, y1, x2, y2) <= 50: preferences_1 = {pref1, pref2, pref3} preferences_2 = {pref4, pref5, pref6} if preferences_1 & preferences_2: valid_pairs += 1 results.append(valid_pairs) return results def parse_input(input_data): datasets = [] lines = input_data.strip().split('n') i = 0 while i < len(lines): n = int(lines[i]) if n == 0: break i += 1 individuals = [] for _ in range(n): data = lines[i].split() id_ = int(data[0]) age = int(data[1]) pref1 = data[2] pref2 = data[3] pref3 = data[4] x = float(data[5]) y = float(data[6]) individuals.append((id_, age, pref1, pref2, pref3, x, y)) i += 1 datasets.append((n, individuals)) return datasets def matchmaking(input_data): datasets = parse_input(input_data) return count_valid_pairs(datasets)"},{"question":"def wordLadderLength(beginWord: str, endWord: str, wordList: List[str]) -> int: Returns the length of the shortest transformation sequence from beginWord to endWord. If no such transformation is possible, returns 0. >>> wordLadderLength(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 5 >>> wordLadderLength(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) 0 >>> wordLadderLength(\\"hit\\", \\"hit\\", [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) 1 >>> wordLadderLength(\\"hit\\", \\"hot\\", [\\"hot\\"]) 2 >>> wordLadderLength(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"lot\\", \\"log\\"]) 0 >>> wordLadderLength(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] + [\\"word\\" + str(i) for i in range(1000)]) 5","solution":"from collections import deque def wordLadderLength(beginWord, endWord, wordList): Returns the length of the shortest transformation sequence from beginWord to endWord. If no such transformation is possible, returns 0. word_set = set(wordList) if endWord not in word_set: return 0 queue = deque([(beginWord, 1)]) while queue: current_word, length = queue.popleft() if current_word == endWord: return length for i in range(len(current_word)): for ch in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + ch + current_word[i+1:] if next_word in word_set: word_set.remove(next_word) queue.append((next_word, length + 1)) return 0"},{"question":"def is_anagram_of_palindrome(s: str) -> bool: Returns True if the input string s is an anagram of a palindrome, False otherwise. >>> is_anagram_of_palindrome(\\"carrace\\") True >>> is_anagram_of_palindrome(\\"hello\\") False >>> is_anagram_of_palindrome(\\"civic\\") True >>> is_anagram_of_palindrome(\\"ivicc\\") True >>> is_anagram_of_palindrome(\\"aabb\\") True >>> is_anagram_of_palindrome(\\"abcd\\") False >>> is_anagram_of_palindrome(\\"\\") True # Edge case with an empty string >>> is_anagram_of_palindrome(\\"a\\") True # Edge case with one character","solution":"def is_anagram_of_palindrome(s): Returns True if the input string s is an anagram of a palindrome, False otherwise. from collections import Counter count = Counter(s) # Count how many characters have an odd occurrence odd_occurrences = sum(1 for freq in count.values() if freq % 2 != 0) # For the string to be an anagram of a palindrome: # It can have at most one character with an odd count return odd_occurrences <= 1"}]`),S={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:E,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},j={class:"search-container"},C={class:"card-container"},D={key:0,class:"empty-state"},P=["disabled"],I={key:0},M={key:1};function z(i,e,u,_,n,a){const f=h("PoemCard");return s(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",j,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>n.searchQuery=o),placeholder:"Search..."},null,512),[[b,n.searchQuery]]),n.searchQuery?(s(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>n.searchQuery="")}," ✕ ")):l("",!0)]),t("div",C,[(s(!0),r(y,null,x(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),r("div",D,' No results found for "'+d(n.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),r("button",{key:0,class:"load-more-button",disabled:n.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[n.isLoading?(s(),r("span",M,"Loading...")):(s(),r("span",I,"See more"))],8,P)):l("",!0)])}const F=c(S,[["render",z],["__scopeId","data-v-3b0a4610"]]),Y=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/34.md","filePath":"guide/34.md"}'),O={name:"guide/34.md"},U=Object.assign(O,{setup(i){return(e,u)=>(s(),r("div",null,[w(F)]))}});export{Y as __pageData,U as default};
