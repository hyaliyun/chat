import{_,o as r,c as s,a as t,m as c,t as u,C as h,M as g,U as b,f as d,F as y,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},N={class:"review-title"},L={class:"review-content"};function A(i,e,l,f,n,a){return r(),s("div",T,[t("div",q,[t("div",N,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(u(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",L,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(u(l.poem.solution),1)])])])}const E=_(k,[["render",A],["__scopeId","data-v-f3d02e30"]]),R=JSON.parse(`[{"question":"def evaluate_expression(expression: str) -> float: Evaluates an arithmetic expression containing +, -, *, / while ignoring arbitrary whitespace. >>> evaluate_expression(\\"3 + 5\\") 8.0 >>> evaluate_expression(\\"10 + 2 * 6\\") 22.0 >>> evaluate_expression(\\"100 * 2 + 12\\") 212.0 >>> evaluate_expression(\\"100 * ( 2 + 12 )\\") 1400.0 >>> evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\") 100.0 >>> evaluate_expression(\\"3.5 + 2.5 * 2\\") 8.5","solution":"def evaluate_expression(expression: str) -> float: Evaluates an arithmetic expression containing +, -, *, / while ignoring arbitrary whitespace. # Remove any whitespace characters expression = expression.replace(\\" \\", \\"\\") # Evaluate the expression, catch division by zero error if it occurs try: result = float(eval(expression)) except ZeroDivisionError: raise ZeroDivisionError(\\"division by zero is not allowed\\") return result"},{"question":"class CircularDeque: def __init__(self, k: int) -> None: Initialize an empty circular deque with a specified capacity. def insertFront(self, value: int) -> bool: Insert an element to the front of the deque. Returns True if the operation is successful, otherwise returns False. def insertLast(self, value: int) -> bool: Insert an element to the rear of the deque. Returns True if the operation is successful, otherwise returns False. def deleteFront(self) -> bool: Delete an element from the front of the deque. Returns True if the operation is successful, otherwise returns False. def deleteLast(self) -> bool: Delete an element from the rear of the deque. Returns True if the operation is successful, otherwise returns False. def getFront(self) -> int: Get the front element of the deque. Returns -1 if the deque is empty. def getRear(self) -> int: Get the rear element of the deque. Returns -1 if the deque is empty. def isEmpty(self) -> bool: Check if the deque is empty. Returns True if empty, otherwise False. def isFull(self) -> bool: Check if the deque is full. Returns True if full, otherwise False. def display(self) -> list: Display the current state of the deque's elements in a list format.","solution":"class CircularDeque: def __init__(self, k: int) -> None: self.k = k self.queue = [None] * k self.front = -1 self.rear = -1 self.size = 0 def insertFront(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.front = self.rear = 0 else: self.front = (self.front - 1) % self.k self.queue[self.front] = value self.size += 1 return True def insertLast(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.front = self.rear = 0 else: self.rear = (self.rear + 1) % self.k self.queue[self.rear] = value self.size += 1 return True def deleteFront(self) -> bool: if self.isEmpty(): return False if self.front == self.rear: self.front = self.rear = -1 else: self.front = (self.front + 1) % self.k self.size -= 1 return True def deleteLast(self) -> bool: if self.isEmpty(): return False if self.front == self.rear: self.front = self.rear = -1 else: self.rear = (self.rear - 1) % self.k self.size -= 1 return True def getFront(self) -> int: if self.isEmpty(): return -1 return self.queue[self.front] def getRear(self) -> int: if self.isEmpty(): return -1 return self.queue[self.rear] def isEmpty(self) -> bool: return self.size == 0 def isFull(self) -> bool: return self.size == self.k def display(self) -> list: if self.isEmpty(): return [] result = [] i = self.front while True: result.append(self.queue[i]) if i == self.rear: break i = (i + 1) % self.k return result"},{"question":"from typing import Optional, Tuple def sieve_of_eratosthenes(max_num: int) -> list: Generate a list indicating prime numbers up to max_num using the Sieve of Eratosthenes algorithm. is_prime = [True] * (max_num + 1) is_prime[0] = is_prime[1] = False for num in range(2, int(math.isqrt(max_num)) + 1): if is_prime[num]: for multiple in range(num * num, max_num + 1, num): is_prime[multiple] = False return is_prime def find_prime_pair(n: int) -> Optional[Tuple[int, int]]: Return a tuple of two primes that sum up to n, or None if no such pair exists. >>> find_prime_pair(10) in [(3, 7), (5, 5)] True >>> find_prime_pair(26) in [(3, 23), (13, 13)] True >>> find_prime_pair(44) in [(3, 41), (17, 27)] True >>> find_prime_pair(17) is None True pass # Implement the function here","solution":"from typing import Optional, Tuple import math def sieve_of_eratosthenes(max_num: int) -> list: is_prime = [True] * (max_num + 1) is_prime[0] = is_prime[1] = False for num in range(2, int(math.isqrt(max_num)) + 1): if is_prime[num]: for multiple in range(num * num, max_num + 1, num): is_prime[multiple] = False return is_prime def find_prime_pair(n: int) -> Optional[Tuple[int, int]]: if n <= 2: return None is_prime = sieve_of_eratosthenes(n) for i in range(2, n): if is_prime[i] and is_prime[n - i] and i != (n - i): return (i, n - i) return None"},{"question":"from typing import List def detect_anomalies(data: List[float], threshold: float) -> List[int]: Identifies and returns the indices of anomalies in the data based on the specified Z-Score threshold. Parameters: - data (List[float]): A list of numerical values representing the data set. - threshold (float): The Z-Score threshold for determining anomalies. A data point is considered an anomaly if its absolute Z-Score is greater than this threshold. Returns: - List[int]: The list of indices of anomalies. >>> detect_anomalies([10.0, 12.0, 15.0, 18.0, 9.0, 50.0, 11.0], 2.0) [5] >>> detect_anomalies([5.0, 6.0, 7.0, 8.0, 10.0, 50.0, 7.5], 1.5) [5] >>> detect_anomalies([1.0, 2.0, 2.5, 3.0, 2.0, 100.0, 2.0, 2.1], 3.0) [5] >>> detect_anomalies([10.0, 11.0, 9.0, 10.5, 10.3], 3.0) [] >>> detect_anomalies([5.0, 5.0, 5.0, 5.0, 5.0], 2.0) [] >>> detect_anomalies([1.0], 2.0) Traceback (most recent call last): ValueError: Data should contain at least two numerical values.","solution":"from typing import List import numpy as np def detect_anomalies(data: List[float], threshold: float) -> List[int]: Identifies and returns the indices of anomalies in the data based on the specified Z-Score threshold. Parameters: - data (List[float]): The data set. - threshold (float): The Z-Score threshold for determining anomalies. Returns: - List[int]: The list of indices of anomalies. if len(data) < 2: raise ValueError(\\"Data should contain at least two numerical values.\\") mean = np.mean(data) std_dev = np.std(data) anomalies = [] for index, value in enumerate(data): z_score = (value - mean) / std_dev if std_dev else 0 if abs(z_score) > threshold: anomalies.append(index) return anomalies"},{"question":"import heapq class RunningMedian: Maintains the running median of a stream of numbers. The class supports adding new numbers and retrieving the current median. def __init__(self): Initializes the data structures necessary for storing the numbers and calculating the median. pass def add_number(self, number: int) -> None: Adds a new number to the stream. >>> rm = RunningMedian() >>> rm.add_number(5) >>> rm.get_median() 5 pass def get_median(self) -> float: Returns the current median of the numbers in the stream. >>> rm = RunningMedian() >>> rm.add_number(5) >>> rm.get_median() 5 >>> rm.add_number(10) >>> rm.get_median() 7.5 >>> rm.add_number(1) >>> rm.get_median() 5 pass","solution":"import heapq class RunningMedian: def __init__(self): self.min_heap = [] # Holds the larger half self.max_heap = [] # Holds the smaller half def add_number(self, number: int) -> None: if not self.min_heap or number > self.min_heap[0]: heapq.heappush(self.min_heap, number) else: heapq.heappush(self.max_heap, -number) # Balance the heaps to ensure neither is more than one element larger if len(self.min_heap) > len(self.max_heap) + 1: heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) elif len(self.max_heap) > len(self.min_heap): heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) def get_median(self) -> float: if len(self.min_heap) == len(self.max_heap): if not self.min_heap: # Both are empty return 0.0 return (self.min_heap[0] - self.max_heap[0]) / 2.0 else: return float(self.min_heap[0])"},{"question":"def min_swaps_to_sort(arr: list) -> int: Determine the minimum number of swaps required to sort an array of distinct integers in ascending order. >>> min_swaps_to_sort([4, 3, 1, 2]) 3 >>> min_swaps_to_sort([1, 5, 4, 3, 2]) 2 >>> min_swaps_to_sort([3, 2, 1]) 1","solution":"def min_swaps_to_sort(arr: list) -> int: n = len(arr) arr_pos = [(val, i) for i, val in enumerate(arr)] arr_pos.sort(key=lambda it: it[0]) visited = [False] * n swaps = 0 for i in range(n): if visited[i] or arr_pos[i][1] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arr_pos[j][1] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"from typing import List def three_sum(nums: List[int]) -> List[List[int]]: Find all unique triplets in the array which gives the sum of zero. >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([0, 0, 0]) [[0, 0, 0]] >>> three_sum([1, 2, -2, -1]) [] >>> three_sum([-1, -1, -1, 2, 2, 2]) [[-1, -1, 2]] >>> three_sum([-100000, 50000, 50000, 100000, -100000, 0]) [[-100000, 50000, 50000], [-100000, 0, 100000]]","solution":"from typing import List def three_sum(nums: List[int]) -> List[List[int]]: Find all unique triplets in the array which gives the sum of zero. nums.sort() result = [] n = len(nums) for i in range(n - 2): # Avoid duplicates for the first element if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: result.append([nums[i], nums[left], nums[right]]) # Skip duplicates for the second and third element while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return result"},{"question":"import heapq from typing import List def sort_almost_sorted_array(arr: List[int], k: int) -> List[int]: Sorts an almost sorted array where each element is at most k positions away from its correct sorted position. Args: arr (List[int]): The almost sorted array. k (int): The maximum number of positions away each element is from its correct sorted position. Returns: List[int]: The sorted array. Example: >>> sort_almost_sorted_array([2, 6, 3, 12, 56, 8], 3) [2, 3, 6, 8, 12, 56] >>> sort_almost_sorted_array([1], 0) [1] >>> sort_almost_sorted_array([2, 1], 1) [1, 2] >>> sort_almost_sorted_array([1, 2, 3, 4, 5], 1) [1, 2, 3, 4, 5] >>> sort_almost_sorted_array([5, 4, 3, 2, 1], 4) [1, 2, 3, 4, 5] >>> sort_almost_sorted_array([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 9) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","solution":"import heapq def sort_almost_sorted_array(arr: list[int], k: int) -> list[int]: Sorts an almost sorted array where each element is at most k positions away from its correct sorted position. # Initialize a min-heap with the first k+1 elements min_heap = arr[:k+1] heapq.heapify(min_heap) sorted_array = [] n = len(arr) # Iterate over the rest of the array and maintain the heap for i in range(k+1, n): smallest = heapq.heappop(min_heap) sorted_array.append(smallest) heapq.heappush(min_heap, arr[i]) # Extract the remaining elements from the heap while min_heap: smallest = heapq.heappop(min_heap) sorted_array.append(smallest) return sorted_array"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten_binary_tree(root: TreeNode) -> None: Flattens a binary tree to a linked list in place by using the right pointer as the next pointer according to pre-order traversal. pass def test_flatten_binary_tree(): # Helper function to create a binary tree from a list of values def create_tree(nodes, index=0): if index < len(nodes) and nodes[index] is not None: node = TreeNode(nodes[index]) node.left = create_tree(nodes, 2 * index + 1) node.right = create_tree(nodes, 2 * index + 2) return node return None # Helper function to get the flattened tree values as a list def get_flattened_values(root): values = [] while root: values.append(root.val) root = root.right return values # Example 1 root1 = create_tree([1, 2, 5, 3, 4, None, 6]) flatten_binary_tree(root1) assert get_flattened_values(root1) == [1, 2, 3, 4, 5, 6] # Example 2 root2 = create_tree([0, None, 1]) flatten_binary_tree(root2) assert get_flattened_values(root2) == [0, 1] # Example 3 root3 = create_tree([4, 9]) flatten_binary_tree(root3) assert get_flattened_values(root3) == [4, 9] # Additional test cases root4 = create_tree([]) flatten_binary_tree(root4) assert get_flattened_values(root4) == [] root5 = create_tree([1, 2, None, 3, None, None, None]) flatten_binary_tree(root5) assert get_flattened_values(root5) == [1, 2, 3] root6 = create_tree([1]) flatten_binary_tree(root6) assert get_flattened_values(root6) == [1]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten_binary_tree(root: TreeNode) -> None: Flattens a binary tree to a linked list in place by using the right pointer as the next pointer according to pre-order traversal. if not root: return def flatten(node: TreeNode): Helper function to flatten the tree and return the last node in the flattened structure. if not node: return None # Flatten the left subtree left_tail = flatten(node.left) # Flatten the right subtree right_tail = flatten(node.right) # If there's a left subtree, we need to rewire the connections. if left_tail: left_tail.right = node.right node.right = node.left node.left = None # The new tail is the rightmost of right tail or left tail return right_tail if right_tail else left_tail if left_tail else node flatten(root)"},{"question":"from typing import List, Tuple def shortest_pallet_path(movement_log: List[Tuple[int, int]], start: int, end: int) -> int: Compute the shortest path a pallet must take to move from its current location to a new location using the least number of intermediate moves. >>> shortest_pallet_path([(1, 2), (2, 3), (3, 4)], 1, 4) 3 >>> shortest_pallet_path([(1, 2), (2, 3), (3, 4), (4, 5)], 1, 5) 4 >>> shortest_pallet_path([(1, 2), (3, 4)], 1, 4) -1","solution":"def shortest_pallet_path(movement_log, start, end): from collections import deque, defaultdict if start == end: return 0 graph = defaultdict(list) for a, b in movement_log: graph[a].append(b) queue = deque([(start, 0)]) visited = set() while queue: current, moves = queue.popleft() if current == end: return moves if current not in visited: visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append((neighbor, moves + 1)) return -1"},{"question":"def select_shipping_method(weight: float, shipping_options: list) -> str: Select the optimal shipping method based on the lowest cost for the given weight. Args: weight (float): The weight of the package in kilograms. Must be positive. shipping_options (list): A list of dictionaries, each representing a shipping method with: - 'name' (str): The name of the shipping method. - 'base_cost' (float): The base cost of this shipping method. Must be positive. - 'cost_per_kg' (float): The cost per kilogram for this shipping method. Must be positive. Returns: str: The name of the optimal shipping method. Raises: ValueError: If weight is not positive, or if base_cost or cost_per_kg are not positive in any shipping option. >>> shipping_options = [ ... {\\"name\\": \\"Economy\\", \\"base_cost\\": 5.00, \\"cost_per_kg\\": 1.00}, ... {\\"name\\": \\"Express\\", \\"base_cost\\": 10.00, \\"cost_per_kg\\": 1.50}, ... {\\"name\\": \\"Overnight\\", \\"base_cost\\": 20.00, \\"cost_per_kg\\": 2.00} ... ] >>> select_shipping_method(weight=2.5, shipping_options=shipping_options) 'Economy' >>> select_shipping_method(weight=0, shipping_options=shipping_options) Traceback (most recent call last): ... ValueError: Weight must be positive >>> shipping_options = [ ... {\\"name\\": \\"Economy\\", \\"base_cost\\": -5.00, \\"cost_per_kg\\": 1.00}, ... {\\"name\\": \\"Express\\", \\"base_cost\\": 10.00, \\"cost_per_kg\\": 1.50} ... ] >>> select_shipping_method(weight=2.5, shipping_options=shipping_options) Traceback (most recent call last): ... ValueError: Base costs must be positive >>> shipping_options = [ ... {\\"name\\": \\"Economy\\", \\"base_cost\\": 5.00, \\"cost_per_kg\\": -1.00}, ... {\\"name\\": \\"Express\\", \\"base_cost\\": 10.00, \\"cost_per_kg\\": 1.50} ... ] >>> select_shipping_method(weight=2.5, shipping_options=shipping_options) Traceback (most recent call last): ... ValueError: Cost per kg values must be positive # Your code here","solution":"def select_shipping_method(weight, shipping_options): Select the optimal shipping method based on the lowest cost for the given weight. Args: weight (float): The weight of the package in kilograms. Must be positive. shipping_options (list): A list of dictionaries, each representing a shipping method with: - 'name' (str): The name of the shipping method. - 'base_cost' (float): The base cost of this shipping method. Must be positive. - 'cost_per_kg' (float): The cost per kilogram for this shipping method. Must be positive. Returns: str: The name of the optimal shipping method. Raises: ValueError: If weight is not positive, or if base_cost or cost_per_kg are not positive in any shipping option. if weight <= 0: raise ValueError(\\"Weight must be positive\\") for option in shipping_options: if option['base_cost'] <= 0: raise ValueError(\\"Base costs must be positive\\") if option['cost_per_kg'] <= 0: raise ValueError(\\"Cost per kg values must be positive\\") optimal_method = None lowest_cost = float('inf') for option in shipping_options: total_cost = option['base_cost'] + option['cost_per_kg'] * weight if total_cost < lowest_cost: lowest_cost = total_cost optimal_method = option['name'] return optimal_method"},{"question":"# Optimized Merge K Sorted Lists Function From the given coding task and unit test, we need to create a completion task. Your goal is to fill the code template with the provided solution to achieve an optimal merging process. Task Implement the function \`merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]\` as given below. Use the following \`ListNode\` class definition: class ListNode: def __init__(self, val=0, next=None): self.val = val = val self.next = next The \`merge_k_sorted_lists\` function should take a list of \`ListNode\` objects (each representing a sorted linked list) and merge them into a single sorted linked list with optimal performance. The function should achieve at least O(N log k) time complexity, where N is the total number of nodes and k is the number of linked lists. Implement the function below: from typing import List, Optional import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def __lt__(self, other): # This is needed to compare the ListNode objects inside the heap return self.val < other.val def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: min_heap = [] for l in lists: if l: heapq.heappush(min_heap, (l.val, l)) dummy = ListNode() current = dummy while min_heap: _, node = heapq.heappop(min_heap) current.next = node current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, node.next)) return dummy.next","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def __lt__(self, other): # This is needed to compare the ListNode objects inside the heap return self.val < other.val def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: min_heap = [] for l in lists: if l: heapq.heappush(min_heap, (l.val, l)) dummy = ListNode() current = dummy while min_heap: _, node = heapq.heappop(min_heap) current.next = node current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, node.next)) return dummy.next"},{"question":"def is_mountain_array(numbers: list[int]) -> bool: Checks if an array is a mountain array. An array is considered a mountain array if: 1. It has at least three elements. 2. There exists some index \`i\` (0 < i < n-1) such that: - numbers[0] < numbers[1] < ... < numbers[i] - numbers[i] > numbers[i+1] > ... > numbers[n-1] >>> is_mountain_array([2, 1]) False >>> is_mountain_array([3, 5, 5]) False >>> is_mountain_array([0, 3, 2, 1]) True >>> is_mountain_array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) False >>> is_mountain_array([2, 0, 2]) False >>> is_mountain_array([3, 4, 1]) True","solution":"def is_mountain_array(numbers): Checks if the given list of numbers is a mountain array. if len(numbers) < 3: return False i = 0 # Ascending part while i + 1 < len(numbers) and numbers[i] < numbers[i + 1]: i += 1 # There must be a peak, meaning i cannot be 0 or the last index if i == 0 or i == len(numbers) - 1: return False # Descending part while i + 1 < len(numbers) and numbers[i] > numbers[i + 1]: i += 1 return i == len(numbers) - 1"},{"question":"import re def is_valid_number(s: str) -> bool: Checks if the input string is a valid number according to the given rules. Arguments: s : str : The input string to validate. Returns: bool : True if the string is a valid number, False otherwise. >>> is_valid_number(\\"123\\") True >>> is_valid_number(\\"3.14\\") True >>> is_valid_number(\\"-0.1\\") True >>> is_valid_number(\\"2e10\\") True >>> is_valid_number(\\"+.8E-4\\") True >>> is_valid_number(\\"12.34.56\\") False >>> is_valid_number(\\"abc\\") False >>> is_valid_number(\\" \\") False >>> is_valid_number(\\"+3.5e-2\\") True >>> is_valid_number(\\"1..2\\") False","solution":"import re def is_valid_number(s: str) -> bool: Checks if the input string is a valid number according to the given rules. Arguments: s : str : The input string to validate. Returns: bool : True if the string is a valid number, False otherwise. # Strip leading and trailing whitespaces s = s.strip() # Define regex pattern for a valid number number_pattern = re.compile(r ^ # start of string [+-]? # optional sign ( # group for the base part (d+(.d*)?)| # digits with optional decimal point (.d+) # decimal numbers with at least one digit ) ([eE][+-]?d+)? # optional exponent part # end of string , re.VERBOSE) # Match the stripped string against the pattern match = re.match(number_pattern, s) return match is not None"},{"question":"from typing import List, Tuple def add(num_1: float, num_2: float) -> float: Computes the sum of two numbers. pass def subtract(num_1: float, num_2: float) -> float: Computes the difference between two numbers. pass def multiply(num_1: float, num_2: float) -> float: Computes the product of two numbers. pass def divide(num_1: float, num_2: float) -> float: Computes the quotient of two numbers. If divided by zero, return float('inf'). pass def calculator_evaluator(operations: List[Tuple[str, List[float]]]) -> float: Evaluates a given sequence of arithmetic operations and applies them to inputs sequentially. pass def test_add(): assert add(1.5, 2.5) == 4.0 assert add(0, 1) == 1 assert add(-1, 1) == 0 assert add(-1.5, -2.5) == -4.0 def test_subtract(): assert subtract(5, 3) == 2 assert subtract(0, 3) == -3 assert subtract(3, 0) == 3 assert subtract(-3, -3) == 0 def test_multiply(): assert multiply(3, 4) == 12 assert multiply(2, 0) == 0 assert multiply(2, -2) == -4 assert multiply(-3, -4) == 12 def test_divide(): assert divide(20, 4) == 5 assert divide(20, 0) == float('inf') assert divide(0, 20) == 0 assert divide(-20, -4) == 5 def test_calculator_evaluator(): operations = [ (\\"add\\", [1.5, 2.5]), (\\"multiply\\", [3, 4]), (\\"subtract\\", [10, 5]), (\\"divide\\", [20, 4]) ] assert calculator_evaluator(operations) == 5.0 operations = [ (\\"add\\", [1, 2]), (\\"subtract\\", [4, 1]), (\\"multiply\\", [2, 3]), (\\"divide\\", [6, 2]) ] assert calculator_evaluator(operations) == 3.0 if __name__ == \\"__main__\\": test_add() test_subtract() test_multiply() test_divide() test_calculator_evaluator() print(\\"All tests passed.\\")","solution":"from typing import List, Tuple def add(num_1: float, num_2: float) -> float: Computes the sum of two numbers. return num_1 + num_2 def subtract(num_1: float, num_2: float) -> float: Computes the difference between two numbers. return num_1 - num_2 def multiply(num_1: float, num_2: float) -> float: Computes the product of two numbers. return num_1 * num_2 def divide(num_1: float, num_2: float) -> float: Computes the quotient of two numbers. If divided by zero, return float('inf'). if num_2 == 0: return float('inf') return num_1 / num_2 def calculator_evaluator(operations: List[Tuple[str, List[float]]]) -> float: Evaluates a given sequence of arithmetic operations and applies them to inputs sequentially. result = 0 for operation, numbers in operations: if operation == \\"add\\": result = add(numbers[0], numbers[1]) elif operation == \\"subtract\\": result = subtract(numbers[0], numbers[1]) elif operation == \\"multiply\\": result = multiply(numbers[0], numbers[1]) elif operation == \\"divide\\": result = divide(numbers[0], numbers[1]) return result"},{"question":"# Problem Statement A perfect square is an integer that is the square of some integer. For example, 1, 4, 9, and 16 are perfect squares because: - 1 = 1 * 1 - 4 = 2 * 2 - 9 = 3 * 3 - 16 = 4 * 4 Write a function \`is_perfect_square\` that takes an integer \`x\` as input and returns \`True\` if the number is a perfect square, otherwise returns \`False\`. The function should handle edge cases, such as when \`x\` is zero or negative gracefully. Input Format - An integer \`x\` which needs to be checked if it is a perfect square. Output Format - A boolean value: \`True\` if \`x\` is a perfect square, otherwise \`False\`. Constraints - The function should be efficient and handle up to large values of \`x\` within practical limits. - You are not allowed to use the \`sqrt\` function from Python's math module. def is_perfect_square(x: int) -> bool: Returns True if x is a perfect square, otherwise False. Handles edge cases for zero and negative numbers. >>> is_perfect_square(16) True >>> is_perfect_square(14) False >>> is_perfect_square(1) True >>> is_perfect_square(0) True >>> is_perfect_square(-4) False # Your code here Example assert is_perfect_square(16) == True assert is_perfect_square(14) == False assert is_perfect_square(1) == True assert is_perfect_square(0) == True assert is_perfect_square(-4) == False assert is_perfect_square(25) == True assert is_perfect_square(26) == False","solution":"def is_perfect_square(x): Returns True if x is a perfect square, otherwise False. Handles edge cases for zero and negative numbers. if x < 0: return False if x == 0: return True left, right = 1, x while left <= right: mid = (left + right) // 2 if mid * mid == x: return True elif mid * mid < x: left = mid + 1 else: right = mid - 1 return False"},{"question":"def merge_unique_sorted(list1: list[int], list2: list[int]) -> list[int]: Merge two non-decreasingly sorted lists of unique integers into one sorted list without duplicates. >>> merge_unique_sorted([1, 3, 5], [2, 3, 6]) [1, 2, 3, 5, 6] >>> merge_unique_sorted([-5, -3, 0], [-4, -3, 0, 2]) [-5, -4, -3, 0, 2] >>> merge_unique_sorted([1, 2, 3], [4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> merge_unique_sorted([], [1, 2, 3]) [1, 2, 3] >>> merge_unique_sorted([1, 2, 3], []) [1, 2, 3] >>> merge_unique_sorted([], []) [] # Your implementation here pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def merge_unique_sorted(list1: list[int], list2: list[int]) -> list[int]: # Initialize pointers for list1 and list2 i, j = 0, 0 merged_list = [] # Traverse both lists and merge them into a single sorted list while i < len(list1) and j < len(list2): if list1[i] < list2[j]: if not merged_list or merged_list[-1] != list1[i]: merged_list.append(list1[i]) i += 1 elif list1[i] > list2[j]: if not merged_list or merged_list[-1] != list2[j]: merged_list.append(list2[j]) j += 1 else: # list1[i] == list2[j] if not merged_list or merged_list[-1] != list1[i]: merged_list.append(list1[i]) i += 1 j += 1 # Append remaining elements from list1 while i < len(list1): if not merged_list or merged_list[-1] != list1[i]: merged_list.append(list1[i]) i += 1 # Append remaining elements from list2 while j < len(list2): if not merged_list or merged_list[-1] != list2[j]: merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def nth_term(a: int, d: int, n: int) -> int: Returns the n-th term of an arithmetic sequence where \`a\` is the first term and \`d\` is the common difference. Raises ValueError if \`n\` is less than or equal to zero. >>> nth_term(2, 3, 5) 14 >>> nth_term(1, -1, 1) 1 >>> nth_term(5, 0, 10) 5 >>> nth_term(-1, 2, 4) 5 pass def term_position(a: int, d: int, term: int) -> int: Returns the position of the given \`term\` in the arithmetic sequence starting with \`a\` and having common difference \`d\`. Raises ValueError if the term does not belong to the sequence. >>> term_position(2, 3, 14) 5 >>> term_position(1, -1, 1) 1 >>> term_position(-5, 5, 0) 2 >>> term_position(0, 10, 90) 10 pass def is_arithmetic(seq: list[int]) -> bool: Determines if the given sequence is an arithmetic sequence. Returns True if it is an arithmetic sequence, and False otherwise. Raises ValueError if the input list is empty or has less than two elements. >>> is_arithmetic([2, 5, 8, 11]) True >>> is_arithmetic([1, 2, 4, 8]) False >>> is_arithmetic([3, 3, 3, 3]) True >>> is_arithmetic([-1, -4, -7]) True pass # Unit tests def test_nth_term(): assert nth_term(2, 3, 5) == 14 assert nth_term(1, -1, 1) == 1 assert nth_term(5, 0, 10) == 5 assert nth_term(-1, 2, 4) == 5 try: nth_term(2, 3, -1) except ValueError as e: assert str(e) == \\"n must be greater than zero\\" def test_term_position(): assert term_position(2, 3, 14) == 5 assert term_position(1, -1, 1) == 1 assert term_position(-5, 5, 0) == 2 assert term_position(0, 10, 90) == 10 try: term_position(2, 3, 13) except ValueError as e: assert str(e) == \\"term does not belong to the arithmetic sequence\\" try: term_position(2, 0, 14) except ValueError as e: assert str(e) == \\"common difference d must not be zero\\" def test_is_arithmetic(): assert is_arithmetic([2, 5, 8, 11]) == True assert is_arithmetic([1, 2, 4, 8]) == False assert is_arithmetic([3, 3, 3, 3]) == True assert is_arithmetic([-1, -4, -7]) == True try: is_arithmetic([1]) except ValueError as e: assert str(e) == \\"sequence must have at least two elements\\" try: is_arithmetic([]) except ValueError as e: assert str(e) == \\"sequence must have at least two elements\\"","solution":"def nth_term(a, d, n): Returns the n-th term of an arithmetic sequence where \`a\` is the first term and \`d\` is the common difference. Raises ValueError if \`n\` is less than or equal to zero. if n <= 0: raise ValueError(\\"n must be greater than zero\\") return a + (n - 1) * d def term_position(a, d, term): Returns the position of the given \`term\` in the arithmetic sequence starting with \`a\` and having common difference \`d\`. Raises ValueError if the term does not belong to the sequence. if d == 0: raise ValueError(\\"common difference d must not be zero\\") pos = (term - a) / d + 1 if pos != int(pos) or pos <= 0: raise ValueError(\\"term does not belong to the arithmetic sequence\\") return int(pos) def is_arithmetic(seq): Determines if the given sequence is an arithmetic sequence. Returns True if it is an arithmetic sequence, and False otherwise. Raises ValueError if the input list is empty or has less than two elements. if len(seq) < 2: raise ValueError(\\"sequence must have at least two elements\\") d = seq[1] - seq[0] return all(seq[i+1] - seq[i] == d for i in range(len(seq) - 1))"},{"question":"class ListNode: def __init__(self, value: int = 0, next_node: 'ListNode' = None): self.value = value self.next = next_node def reverse_linked_list(head: 'ListNode') -> 'ListNode': Reverses the given linked list. Args: head (ListNode): The head node of the singly linked list. Returns: ListNode: The new head node of the reversed linked list. Examples: >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, None)))) >>> new_head = reverse_linked_list(head) >>> [new_head.value, new_head.next.value, new_head.next.next.value, new_head.next.next.next.value] [4, 3, 2, 1] >>> head = ListNode(1, None) >>> new_head = reverse_linked_list(head) >>> new_head.value 1 >>> new_head = reverse_linked_list(None) >>> new_head is None True pass","solution":"class ListNode: def __init__(self, value: int = 0, next_node: 'ListNode' = None): self.value = value self.next = next_node def reverse_linked_list(head: 'ListNode') -> 'ListNode': Reverses the given linked list. Args: head (ListNode): The head node of the singly linked list. Returns: ListNode: The new head node of the reversed linked list. prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"import math def shortest_distance(x1: int, y1: int, x2: int, y2: int) -> float: Computes the shortest distance between two points (x1, y1) and (x2, y2) on a Cartesian coordinate system. Parameters: x1 (int): The x-coordinate of the starting point. (-1000 <= x1 <= 1000) y1 (int): The y-coordinate of the starting point. (-1000 <= y1 <= 1000) x2 (int): The x-coordinate of the ending point. (-1000 <= x2 <= 1000) y2 (int): The y-coordinate of the ending point. (-1000 <= y2 <= 1000) Returns: float: The shortest distance between the two points with high precision. Examples: >>> shortest_distance(0, 0, 3, 4) 5.0 >>> shortest_distance(-1, -1, 2, 3) 5.0 >>> shortest_distance(0, 0, 0, 0) 0.0","solution":"import math def shortest_distance(x1: int, y1: int, x2: int, y2: int) -> float: Computes the shortest distance between two points (x1, y1) and (x2, y2) on a Cartesian coordinate system. Parameters: x1 (int): The x-coordinate of the starting point. y1 (int): The y-coordinate of the starting point. x2 (int): The x-coordinate of the ending point. y2 (int): The y-coordinate of the ending point. Returns: float: The shortest distance between the two points. return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)"},{"question":"class CustomSet: CustomSet data structure that supports various set operations efficiently. Operations: 1. add: Add an integer to the set. 2. remove: Remove an integer from the set. 3. contains: Check if a specific integer is in the set. 4. union: Return a new CustomSet that is the union of the current set and another CustomSet. 5. intersection: Return a new CustomSet that is the intersection of the current set and another CustomSet. 6. difference: Return a new CustomSet that is the difference between the current set and another CustomSet. Usage: >>> my_set = CustomSet() >>> my_set.add(1) >>> my_set.add(2) >>> my_set.contains(1) True >>> my_set.contains(3) False def __init__(self): Initialize an empty CustomSet. pass def add(self, value): Add an integer to the set. pass def remove(self, value): Remove an integer from the set. pass def contains(self, value): Check if a specific integer is in the set. pass def union(self, other_set): Return a new CustomSet that is the union of the current set and another CustomSet. pass def intersection(self, other_set): Return a new CustomSet that is the intersection of the current set and another CustomSet. pass def difference(self, other_set): Return a new CustomSet that is the difference between the current set and another CustomSet. pass from solution import CustomSet def test_add_and_contains(): my_set = CustomSet() my_set.add(1) assert my_set.contains(1) == True assert my_set.contains(2) == False def test_remove(): my_set = CustomSet() my_set.add(1) assert my_set.contains(1) == True my_set.remove(1) assert my_set.contains(1) == False try: my_set.remove(1) except KeyError: pass else: assert False, \\"Expected KeyError\\" def test_union(): set1 = CustomSet() set2 = CustomSet() set1.add(1) set1.add(2) set2.add(2) set2.add(3) union_set = set1.union(set2) assert union_set.contains(1) == True assert union_set.contains(2) == True assert union_set.contains(3) == True def test_intersection(): set1 = CustomSet() set2 = CustomSet() set1.add(1) set1.add(2) set2.add(2) set2.add(3) intersection_set = set1.intersection(set2) assert intersection_set.contains(1) == False assert intersection_set.contains(2) == True assert intersection_set.contains(3) == False def test_difference(): set1 = CustomSet() set2 = CustomSet() set1.add(1) set1.add(2) set2.add(2) set2.add(3) difference_set = set1.difference(set2) assert difference_set.contains(1) == True assert difference_set.contains(2) == False assert difference_set.contains(3) == False","solution":"class CustomSet: def __init__(self): self.data = {} def add(self, value): self.data[value] = True def remove(self, value): if value in self.data: del self.data[value] else: raise KeyError(\\"Value not found in set\\") def contains(self, value): return value in self.data def union(self, other_set): result = CustomSet() for value in self.data: result.add(value) for value in other_set.data: result.add(value) return result def intersection(self, other_set): result = CustomSet() for value in self.data: if value in other_set.data: result.add(value) return result def difference(self, other_set): result = CustomSet() for value in self.data: if value not in other_set.data: result.add(value) return result"},{"question":"def fibonacci_sequence(n: int) -> list: Generate the Fibonacci sequence up to the n-th term. >>> fibonacci_sequence(1) [0] >>> fibonacci_sequence(2) [0, 1] >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> fibonacci_sequence(15) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]","solution":"def fibonacci_sequence(n): Returns the first n terms of the Fibonacci sequence. if n == 1: return [0] elif n == 2: return [0, 1] sequence = [0, 1] for i in range(2, n): sequence.append(sequence[-1] + sequence[-2]) return sequence"},{"question":"class DictionaryCache: A DictionaryCache class that simulates a simple caching mechanism using a dictionary. The cache stores key-value pairs and has a maximum capacity. When the cache exceeds its capacity, it removes the least recently used (LRU) item. def __init__(self, capacity): Initialize the cache with a given capacity. # Your code here def get(self, key): Retrieve the value associated with the key. If the key is not present, return None. Move the accessed key to the most recently used position. # Your code here def put(self, key, value): Insert or update the key-value pair in the cache. If the cache is full, remove the least recently used item before adding the new key-value pair. Move the key to the most recently used position. # Your code here def delete(self, key): Remove the key-value pair associated with the key. If the key is not present, do nothing. # Your code here def is_full(self): Returns True if the cache is full, False otherwise. # Your code here def size(self): Returns the number of items currently in the cache. # Your code here def clear(self): Clears all items from the cache. # Your code here if __name__ == \\"__main__\\": # Example Usage cache = DictionaryCache(2) cache.put('a', 1) cache.put('b', 2) print(cache.get('a')) # Output: 1 print(cache.get('b')) # Output: 2 cache.put('c', 3) print(cache.get('a')) # Output: None print(cache.get('b')) # Output: 2 print(cache.get('c')) # Output: 3 print(cache.size()) # Output: 2 cache.clear() print(cache.size()) # Output: 0 print(cache.get('b')) # Output: None def test_put_and_get(): cache = DictionaryCache(2) cache.put('a', 1) cache.put('b', 2) assert cache.get('a') == 1 assert cache.get('b') == 2 def test_get_nonexistent_key(): cache = DictionaryCache(2) assert cache.get('a') == None def test_put_exceeds_capacity(): cache = DictionaryCache(2) cache.put('a', 1) cache.put('b', 2) cache.put('c', 3) assert cache.get('a') == None assert cache.get('b') == 2 assert cache.get('c') == 3 def test_update_existing_key(): cache = DictionaryCache(2) cache.put('a', 1) cache.put('a', 2) assert cache.get('a') == 2 def test_cache_size(): cache = DictionaryCache(2) cache.put('a', 1) cache.put('b', 2) assert cache.size() == 2 cache.put('c', 3) assert cache.size() == 2 def test_is_full(): cache = DictionaryCache(2) cache.put('a', 1) cache.put('b', 2) assert cache.is_full() == True cache.delete('a') assert cache.is_full() == False def test_delete(): cache = DictionaryCache(2) cache.put('a', 1) cache.put('b', 2) cache.delete('a') assert cache.get('a') == None assert cache.size() == 1 def test_clear(): cache = DictionaryCache(2) cache.put('a', 1) cache.put('b', 2) cache.clear() assert cache.size() == 0 assert cache.get('a') == None assert cache.get('b') == None","solution":"class DictionaryCache: def __init__(self, capacity): Initialize the cache with a given capacity. self.capacity = capacity self.cache = {} self.order = [] def get(self, key): Retrieve the value associated with the key. If the key is not present, return None. if key in self.cache: # Move the accessed key to the most recently used position self.order.remove(key) self.order.append(key) return self.cache[key] return None def put(self, key, value): Insert or update the key-value pair in the cache. If the cache is full, remove the least recently used item. if key in self.cache: # Update the value and move the key to the most recently used position self.order.remove(key) elif len(self.cache) >= self.capacity: # Remove the least recently used item lru_key = self.order.pop(0) del self.cache[lru_key] self.cache[key] = value self.order.append(key) def delete(self, key): Remove the key-value pair associated with the key. If the key is not present, do nothing. if key in self.cache: self.order.remove(key) del self.cache[key] def is_full(self): Returns True if the cache is full, False otherwise. return len(self.cache) >= self.capacity def size(self): Returns the number of items currently in the cache. return len(self.cache) def clear(self): Clears all items from the cache. self.cache.clear() self.order.clear()"},{"question":"def max_final_score(scores: List[int]) -> int: Returns the highest possible final score after performing the moves as described. Each move consists of picking any two distinct scores and replacing them with their sum until only one score remains. Args: scores (List[int]): A list of integers representing the scores achieved by a player. Returns: int: The highest possible final score. Examples: >>> max_final_score([4, 2, 1, 3]) 10 >>> max_final_score([5, 5, 5, 5]) 20","solution":"def max_final_score(scores): Returns the highest possible final score after performing the moves as described. Each move consists of picking any two distinct scores and replacing them with their sum until only one score remains. Args: scores (List[int]): A list of integers representing the scores achieved by a player. Returns: int: The highest possible final score. while len(scores) > 1: scores.sort(reverse=True) first = scores.pop(0) second = scores.pop(0) scores.append(first + second) return scores[0]"},{"question":"def next_greater_number(n: int) -> int: Calculate the next greater number using the same digits of a given number. If no such number is possible, return -1. >>> next_greater_number(123) == 132 >>> next_greater_number(321) == -1 >>> next_greater_number(534976) == 536479 >>> next_greater_number(218765) == 251678 >>> next_greater_number(1999999999) == -1","solution":"def next_greater_number(n: int) -> int: digits = list(str(n)) length = len(digits) # Step 1: Find the pivot where the digits[i] < digits[i + 1] for i in range(length - 2, -1, -1): if digits[i] < digits[i + 1]: break else: return -1 # No such pivot found # Step 2: Find the smallest digit on right side of (i'th digit) that is greater than digits[i] for j in range(length - 1, i, -1): if digits[j] > digits[i]: break # Step 3: Swap digits[i] and digits[j] digits[i], digits[j] = digits[j], digits[i] # Step 4: Sort the sublist after i to get the smallest lexicographic order digits = digits[:i + 1] + sorted(digits[i + 1:]) result = int(\\"\\".join(digits)) # Check if result is within the constraints if result > 10**9: return -1 return result"},{"question":"def convert_temperature(temp: float, from_scale: str, to_scale: str) -> tuple: Converts temperature between Celsius, Fahrenheit, and Kelvin. :param temp: The temperature value to be converted. :param from_scale: The current scale of the temperature. ('Celsius', 'Fahrenheit', or 'Kelvin') :param to_scale: The target scale to convert the temperature to. ('Celsius', 'Fahrenheit', or 'Kelvin') :return: A tuple (converted_temperature, target_scale) >>> convert_temperature(100, 'Celsius', 'Fahrenheit') (212.0, 'Fahrenheit') >>> convert_temperature(32, 'Fahrenheit', 'Celsius') (0.0, 'Celsius') >>> convert_temperature(0, 'Celsius', 'Kelvin') (273.15, 'Kelvin') >>> convert_temperature(273.15, 'Kelvin', 'Celsius') (0.0, 'Celsius') >>> convert_temperature(32, 'Fahrenheit', 'Kelvin') (273.15, 'Kelvin') >>> convert_temperature(273.15, 'Kelvin', 'Fahrenheit') (32.0, 'Fahrenheit')","solution":"def convert_temperature(temp: float, from_scale: str, to_scale: str) -> tuple: Converts temperature between Celsius, Fahrenheit, and Kelvin. :param temp: The temperature value to be converted. :param from_scale: The current scale of the temperature. ('Celsius', 'Fahrenheit', or 'Kelvin') :param to_scale: The target scale to convert the temperature to. ('Celsius', 'Fahrenheit', or 'Kelvin') :return: A tuple (converted_temperature, target_scale) from_scale = from_scale.lower() to_scale = to_scale.lower() if from_scale not in {'celsius', 'fahrenheit', 'kelvin'}: raise ValueError(\\"Invalid from_scale value\\") if to_scale not in {'celsius', 'fahrenheit', 'kelvin'}: raise ValueError(\\"Invalid to_scale value\\") if from_scale == 'celsius': if to_scale == 'fahrenheit': converted_temp = (temp * 9/5) + 32 elif to_scale == 'kelvin': converted_temp = temp + 273.15 else: # celsius to celsius converted_temp = temp elif from_scale == 'fahrenheit': if to_scale == 'celsius': converted_temp = (temp - 32) * 5/9 elif to_scale == 'kelvin': converted_temp = (temp - 32) * 5/9 + 273.15 else: # fahrenheit to fahrenheit converted_temp = temp elif from_scale == 'kelvin': if to_scale == 'celsius': converted_temp = temp - 273.15 elif to_scale == 'fahrenheit': converted_temp = (temp - 273.15) * 9/5 + 32 else: # kelvin to kelvin converted_temp = temp return (converted_temp, to_scale.capitalize())"},{"question":"import asyncio from concurrent.futures import ProcessPoolExecutor import os async def summarize_movie_reviews(file_path: str) -> dict: Reads movie review data from a file asynchronously, processes each review concurrently to generate a summary, and provides error handling for file access and data processing issues. Args: file_path (str): The path to the file containing the movie reviews, where each review is separated by a blank line. Returns: dict: A dictionary where each key is a unique review identifier and the value is the corresponding summary of the review. Example: >>> file_path = \\"path/to/reviews.txt\\" >>> summaries = asyncio.run(summarize_movie_reviews(file_path)) >>> print(summaries) {\\"review_0\\": \\"This\\", \\"review_1\\": \\"Second\\", \\"review_2\\": \\"Here\\"} def process_review(review): # Mock function to process individual reviews. async def read_reviews(file_path): loop = asyncio.get_event_loop() # Implement necessary logic here # Example usage file_path = \\"path/to/reviews.txt\\" summaries = asyncio.run(summarize_movie_reviews(file_path)) print(summaries) # Unit tests import pytest @pytest.fixture(scope=\\"module\\") def sample_reviews(tmpdir_factory): reviews = [ \\"This is the first review.nIt's quite informative.\\", \\"Second review here.nIt is more concise.\\", \\"Here is the third review.nShort and sweet.\\" ] file_path = tmpdir_factory.mktemp(\\"data\\").join(\\"reviews.txt\\") with open(file_path, 'w') as f: f.write('nn'.join(reviews)) return str(file_path) @pytest.mark.asyncio async def test_summarize_movie_reviews(sample_reviews): expected_summary = { \\"review_0\\": \\"This\\", \\"review_1\\": \\"Second\\", \\"review_2\\": \\"Here\\" } summaries = await summarize_movie_reviews(sample_reviews) assert summaries == expected_summary @pytest.mark.asyncio async def test_file_not_found(): with pytest.raises(FileNotFoundError): await summarize_movie_reviews(\\"non_existent_file.txt\\") @pytest.mark.asyncio async def test_empty_file(tmpdir_factory): empty_file = tmpdir_factory.mktemp(\\"data\\").join(\\"empty.txt\\") with open(empty_file, 'w') as f: pass summaries = await summarize_movie_reviews(str(empty_file)) assert summaries == {} @pytest.mark.asyncio async def test_file_with_one_review(tmpdir_factory): one_review_file = tmpdir_factory.mktemp(\\"data\\").join(\\"one_review.txt\\") with open(one_review_file, 'w') as f: f.write(\\"Only one review here. It stands alone.\\") expected_summary = { \\"review_0\\": \\"Only\\" } summaries = await summarize_movie_reviews(str(one_review_file)) assert summaries == expected_summary","solution":"import asyncio from concurrent.futures import ProcessPoolExecutor import os def process_review(review): A mock function to process individual reviews. In a real scenario, this function would have a more complex implementation to create a summary. return review.strip().split()[0] # just a simple example to return the first word as the 'summary' async def read_reviews(file_path): loop = asyncio.get_event_loop() with open(file_path, 'r') as review_file: content = await loop.run_in_executor(None, review_file.read) reviews = content.strip().split('nn') return reviews async def summarize_movie_reviews(file_path: str) -> dict: if not os.path.exists(file_path): raise FileNotFoundError(f\\"The file {file_path} does not exist.\\") reviews = await read_reviews(file_path) summaries = {} async with ProcessPoolExecutor() as executor: tasks = [] for i, review in enumerate(reviews): tasks.append(loop.run_in_executor(executor, process_review, review)) completed, pending = await asyncio.wait(tasks) for i, task in enumerate(completed): summaries[f\\"review_{i}\\"] = task.result() return summaries"},{"question":"def unique_elements(list1: list[int], list2: list[int]) -> list[int]: Returns a list containing unique elements that appear in either of the input lists. >>> sorted(unique_elements([1, 2, 3], [2, 3, 4])) [1, 2, 3, 4] >>> unique_elements([], [5, 6, 7]) [5, 6, 7] >>> unique_elements([7, 8, 9], []) [7, 8, 9] >>> unique_elements([], []) [] >>> sorted(unique_elements([2, 2, 2], [2, 2])) [2] >>> sorted(unique_elements([1, -1, 2, 2], [3, -1, 4])) [-1, 1, 2, 3, 4] >>> unique_elements([1, \\"a\\", 3], [2, 3, 4]) Traceback (most recent call last): ... TypeError: All elements in the list must be 'int' type","solution":"def unique_elements(list1: list[int], list2: list[int]) -> list[int]: Returns a list containing unique elements that appear in either of the input lists. # Check if all elements are integers if not all(isinstance(x, int) for x in list1 + list2): raise TypeError(\\"All elements in the list must be 'int' type\\") # Use a set to find unique elements unique_set = set(list1).union(set(list2)) return list(unique_set)"},{"question":"from typing import List def is_palindrome(s: str) -> bool: Determines whether the provided string s is a palindrome. >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"aa\\") True def longest_palindromic_substring(s: str) -> str: Finds the longest palindromic substring within the given string s. >>> longest_palindromic_substring(\\"babad\\") \\"bab\\" or \\"aba\\" >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" >>> longest_palindromic_substring(\\"a\\") \\"a\\" >>> longest_palindromic_substring(\\"\\") \\"\\" >>> longest_palindromic_substring(\\"abacdfgdcaba\\") \\"aba\\" or \\"aca\\" >>> longest_palindromic_substring(\\"abacdfgdcabba\\") \\"abba\\" >>> longest_palindromic_substring(\\"forgeeksskeegfor\\") \\"geeksskeeg\\"","solution":"def is_palindrome(s: str) -> bool: Determines whether the provided string s is a palindrome. return s == s[::-1] def longest_palindromic_substring(s: str) -> str: Finds the longest palindromic substring within the given string s. if len(s) == 0: return \\"\\" start = 0 max_length = 1 def expand_around_center(left: int, right: int) -> (int, int): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return left + 1, right for i in range(len(s)): # Check for odd length palindromes l1, r1 = expand_around_center(i, i) if r1 - l1 > max_length: start = l1 max_length = r1 - l1 # Check for even length palindromes l2, r2 = expand_around_center(i, i + 1) if r2 - l2 > max_length: start = l2 max_length = r2 - l2 return s[start:start + max_length]"},{"question":"import time import threading class RateLimiter: def __init__(self, max_requests: int, refill_time: int): Initializes the RateLimiter with a maximum number of requests allowed and the refill time in seconds. :param max_requests: The maximum number of requests allowed within the given time frame (refill_time). :param refill_time: The time frame in seconds within which the requests are counted. self.max_requests = max_requests self.refill_time = refill_time def allow_request(self) -> bool: Determines if a new request can be allowed under the current rate limiting conditions. :return: True if the request is allowed, False otherwise. # Unit Tests def test_allow_requests_within_limit(): rate_limiter = RateLimiter(5, 10) for _ in range(5): assert rate_limiter.allow_request() is True assert rate_limiter.allow_request() is False # Exceeding limit def test_refill_tokens_after_refill_time(): rate_limiter = RateLimiter(1, 2) # 1 request per 2 seconds assert rate_limiter.allow_request() is True assert rate_limiter.allow_request() is False # Exceeding limit time.sleep(2.1) assert rate_limiter.allow_request() is True # Should be allowed after refill def test_multiple_requests_refill(): rate_limiter = RateLimiter(3, 3) # 3 requests per 3 seconds for _ in range(3): assert rate_limiter.allow_request() is True assert rate_limiter.allow_request() is False # Exceeding limit time.sleep(3.1) assert rate_limiter.allow_request() is True # Should be allowed after refill assert rate_limiter.allow_request() is True # Within the new limit def test_thread_safety(): rate_limiter = RateLimiter(10, 10) results = [] def make_requests(): for _ in range(5): results.append(rate_limiter.allow_request()) threads = [threading.Thread(target=make_requests) for _ in range(2)] for thread in threads: thread.start() for thread in threads: thread.join() assert sum(results) == 10 # Exactly 10 requests should be allowed assert rate_limiter.allow_request() is False # Exceeded the limit","solution":"import time import threading class RateLimiter: def __init__(self, max_requests: int, refill_time: int): Initializes the RateLimiter with a maximum number of requests allowed and the refill time in seconds. :param max_requests: The maximum number of requests allowed within the given time frame (refill_time). :param refill_time: The time frame in seconds within which the requests are counted. self.max_requests = max_requests self.refill_time = refill_time self.tokens = max_requests self.last_refill_timestamp = time.monotonic() self.lock = threading.Lock() def allow_request(self) -> bool: Determines if a new request can be allowed under the current rate limiting conditions. :return: True if the request is allowed, False otherwise. with self.lock: current_timestamp = time.monotonic() time_passed = current_timestamp - self.last_refill_timestamp # Calculate how many tokens to refill tokens_to_add = (time_passed / self.refill_time) * self.max_requests if tokens_to_add > 0: self.tokens = min(self.max_requests, self.tokens + tokens_to_add) self.last_refill_timestamp = current_timestamp if self.tokens >= 1: self.tokens -= 1 return True else: return False"},{"question":"def validate_credit_card(card_number: str) -> bool: Verify if the credit card number is valid as per the Luhn algorithm. >>> validate_credit_card(\\"4539 1488 0343 6467\\") == True >>> validate_credit_card(\\"1234-5678-9012-3456\\") == False","solution":"def validate_credit_card(card_number: str) -> bool: # Remove spaces and dashes from the card number card_number = card_number.replace(\\" \\", \\"\\").replace(\\"-\\", \\"\\") # Check if the card number length is within the valid range if not 13 <= len(card_number) <= 19: return False # Check if all characters are digits if not card_number.isdigit(): return False total = 0 reverse_digits = card_number[::-1] for i, digit in enumerate(reverse_digits): n = int(digit) if (i % 2 == 1): # Index is odd in 0-based index (even when 1-based) n *= 2 if n > 9: n -= 9 total += n return total % 10 == 0"},{"question":"from collections import defaultdict from typing import Optional # Global dictionary to keep track of user requests. user_requests = defaultdict(list) def rate_limiter(user: str, timestamp: int, allowed_requests: int, time_window: int) -> Optional[str]: Track API requests from users and enforce rate limit. Args: user (str): The username of the requester. timestamp (int): The time in seconds since the epoch when the request is received. allowed_requests (int): The number of allowed requests in the given time window. time_window (int): The time window in seconds within which the allowed requests can be made. Returns: Optional[str]: A message \\"Rate limit exceeded\\" if the user exceeds the allowed requests within the time window, otherwise \`None\`. Example: >>> rate_limiter(\\"user1\\", 100, 3, 60) >>> rate_limiter(\\"user1\\", 120, 3, 60) >>> rate_limiter(\\"user1\\", 130, 3, 60) 'Rate limit exceeded' pass","solution":"from collections import defaultdict from typing import Optional # Global dictionary to keep track of user requests. user_requests = defaultdict(list) def rate_limiter(user: str, timestamp: int, allowed_requests: int, time_window: int) -> Optional[str]: Track API requests from users and enforce rate limit. Args: user (str): The username of the requester. timestamp (int): The time in seconds since the epoch when the request is received. allowed_requests (int): The number of allowed requests in the given time window. time_window (int): The time window in seconds within which the allowed requests can be made. Returns: Optional[str]: A message \\"Rate limit exceeded\\" if the user exceeds the allowed requests within the time window, otherwise \`None\`. if len(user_requests[user]) == allowed_requests: if timestamp - user_requests[user][0] < time_window: return \\"Rate limit exceeded\\" # Remove the oldest timestamp that's out of the time window user_requests[user].pop(0) # Add new timestamp user_requests[user].append(timestamp) return None"},{"question":"class Node: def __init__(self, data=None): self.data = data self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None def append(self, data): new_node = Node(data) if self.head is None: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node new_node.prev = last def reverse_between(self, m, n): Reverses the nodes of the doubly linked list from position m to n (both inclusive). :param m: The starting position of the reverse (1-based index) :param n: The ending position of the reverse (1-based index) >>> dll = DoublyLinkedList() >>> dll.append(1) >>> dll.append(2) >>> dll.append(3) >>> dll.append(4) >>> dll.append(5) >>> dll.reverse_between(2, 4) >>> dll.to_list() == [1, 4, 3, 2, 5] True >>> dll.reverse_between(1, 3) >>> dll.to_list() == [3, 4, 1, 2, 5] True def to_list(self): result = [] current = self.head while current: result.append(current.data) current = current.next return result def test_reverse_entire_list(): dll = DoublyLinkedList() dll.append(1) dll.append(2) dll.append(3) dll.reverse_between(1, 3) assert dll.to_list() == [3, 2, 1] def test_reverse_partial_list(): dll = DoublyLinkedList() dll.append(1) dll.append(2) dll.append(3) dll.append(4) dll.append(5) dll.reverse_between(2, 4) assert dll.to_list() == [1, 4, 3, 2, 5] def test_reverse_single_node(): dll = DoublyLinkedList() dll.append(1) dll.append(2) dll.append(3) dll.reverse_between(2, 2) assert dll.to_list() == [1, 2, 3] def test_reverse_head_section(): dll = DoublyLinkedList() dll.append(1) dll.append(2) dll.append(3) dll.append(4) dll.append(5) dll.reverse_between(1, 3) assert dll.to_list() == [3, 2, 1, 4, 5] def test_reverse_tail_section(): dll = DoublyLinkedList() dll.append(1) dll.append(2) dll.append(3) dll.append(4) dll.append(5) dll.reverse_between(3, 5) assert dll.to_list() == [1, 2, 5, 4, 3]","solution":"class Node: def __init__(self, data=None): self.data = data self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None def append(self, data): new_node = Node(data) if self.head is None: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node new_node.prev = last def reverse_between(self, m, n): if not self.head or m == n: return current = self.head pos = 1 # Move to the mth node while current and pos < m: current = current.next pos += 1 before_m_node = current.prev mth_node = current # Reverse nodes from m to n prev = None while current and pos <= n: next_node = current.next current.next = prev current.prev = next_node prev = current current = next_node pos += 1 nth_node = prev after_n_node = current # Connect before_m_node to nth_node if before_m_node: before_m_node.next = nth_node else: self.head = nth_node if nth_node: nth_node.prev = before_m_node # Connect mth_node to after_n_node if mth_node: mth_node.next = after_n_node if after_n_node: after_n_node.prev = mth_node def to_list(self): result = [] current = self.head while current: result.append(current.data) current = current.next return result"},{"question":"from typing import List def sieve_of_eratosthenes(limit: int) -> List[bool]: Generate a list of booleans where the index is marked True if it's a prime number. Uses Sieve of Eratosthenes method. # Implementation goes here def is_prime(n: int, prime_check: List[bool]) -> bool: Check if the number n is prime using the precomputed prime_check array # Implementation goes here def rotate_number(n: int) -> List[int]: Generate all rotations of the digits of the number n # Implementation goes here def is_circular_prime(n: int) -> bool: Check if the number n is a circular prime. >>> is_circular_prime(197) True >>> is_circular_prime(23) False # Implementation goes here","solution":"def sieve_of_eratosthenes(limit): Generate a list of booleans where the index is marked True if it's a prime number. Uses Sieve of Eratosthenes method. is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not primes p = 2 while (p * p <= limit): if (is_prime[p] == True): for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 return is_prime def is_prime(n, prime_check): Check if the number n is prime using the precomputed prime_check array return prime_check[n] def rotate_number(n): Generate all rotations of the digits of the number n rotations = [] s = str(n) for i in range(len(s)): rotated = s[i:] + s[:i] rotations.append(int(rotated)) return rotations def is_circular_prime(n): Check if the number n is a circular prime upper_limit = 1000000 primes_sieve = sieve_of_eratosthenes(upper_limit) # Generate all rotations of the number rotations = rotate_number(n) # Check if all rotations are prime for rota in rotations: if not is_prime(rota, primes_sieve): return False return True"},{"question":"def remove_duplicates(nums: list[int]) -> list[int]: Filter out duplicate integers from the list while maintaining their order of appearance. Raise a TypeError if any of the elements is not an integer. >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([10, 10, 10]) [10] >>> remove_duplicates([7, 8, 9, 7, 8, 9, 10]) [7, 8, 9, 10] >>> remove_duplicates([1]) [1] >>> remove_duplicates([]) [] >>> remove_duplicates([1, 1, 'a']) Traceback (most recent call last): ... TypeError: remove_duplicates() accepts only integers pass","solution":"def remove_duplicates(nums: list[int]) -> list[int]: Filter out duplicate integers from the list while maintaining order of appearance. Raise a TypeError if any of the elements is not an integer. :param nums: List of integers :return: List of integers without duplicates if not all(isinstance(n, int) for n in nums): raise TypeError(\\"remove_duplicates() accepts only integers\\") seen = set() result = [] for num in nums: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"# Problem: Implement a function named \`find_shortest_path_with_constraints\` inside the \`ConstrainedGraph\` class that computes the shortest path from a starting node to a target node in a graph, considering specified constraints such as maximum path length and prohibitive nodes. # Function Signature: class ConstrainedGraph(Graph): def find_shortest_path_with_constraints(self, start: str, end: str, max_length: int, prohibitive_nodes: list[str]) -> list[str]: pass # Example usage: adjacency_list = { 'a': [('b', 1), ('c', 2)], 'b': [('a', 1), ('d', 3)], 'c': [('a', 2), ('d', 1)], 'd': [('b', 3), ('c', 1)] } # Initialize ConstrainedGraph with the adjacency list graph = ConstrainedGraph(adjacency_list) # Set constraints max_length = 3 prohibitive_nodes = ['c'] # Find the shortest path with constraints result = graph.find_shortest_path_with_constraints('a', 'd', max_length, prohibitive_nodes) # result is expected to return: # ['a', 'b', 'd'] or [] if no valid path exists # Unit Test: def test_find_shortest_path_with_constraints_basic(): adjacency_list = { 'a': [('b', 1), ('c', 2)], 'b': [('a', 1), ('d', 3)], 'c': [('a', 2), ('d', 1)], 'd': [('b', 3), ('c', 1)] } graph = ConstrainedGraph(adjacency_list) assert graph.find_shortest_path_with_constraints('a', 'd', 3, ['c']) == ['a', 'b', 'd'] def test_find_shortest_path_with_constraints_no_path_due_to_max_length(): adjacency_list = { 'a': [('b', 1), ('c', 2)], 'b': [('a', 1), ('d', 3)], 'c': [('a', 2), ('d', 1)], 'd': [('b', 3), ('c', 1)] } graph = ConstrainedGraph(adjacency_list) assert graph.find_shortest_path_with_constraints('a', 'd', 1, []) == [] def test_find_shortest_path_with_constraints_no_path_due_to_prohibitive_nodes(): adjacency_list = { 'a': [('b', 1), ('c', 2)], 'b': [('a', 1), ('d', 3)], 'c': [('a', 2), ('d', 1)], 'd': [('b', 3), ('c', 1)] } graph = ConstrainedGraph(adjacency_list) assert graph.find_shortest_path_with_constraints('a', 'd', 3, ['b', 'c']) == [] def test_find_shortest_path_with_constraints_start_is_prohibitive(): adjacency_list = { 'a': [('b', 1), ('c', 2)], 'b': [('a', 1), ('d', 3)], 'c': [('a', 2), ('d', 1)], 'd': [('b', 3), ('c', 1)] } graph = ConstrainedGraph(adjacency_list) assert graph.find_shortest_path_with_constraints('a', 'd', 3, ['a']) == [] def test_find_shortest_path_with_constraints_end_is_prohibitive(): adjacency_list = { 'a': [('b', 1), ('c', 2)], 'b': [('a', 1), ('d', 3)], 'c': [('a', 2), ('d', 1)], 'd': [('b', 3), ('c', 1)] } graph = ConstrainedGraph(adjacency_list) assert graph.find_shortest_path_with_constraints('a', 'd', 3, ['d']) == []","solution":"import heapq class Graph: def __init__(self, adjacency_list): self.adjacency_list = adjacency_list class ConstrainedGraph(Graph): def __init__(self, adjacency_list): super().__init__(adjacency_list) def find_shortest_path_with_constraints(self, start, end, max_length, prohibitive_nodes): prohibitive_nodes = set(prohibitive_nodes) if start in prohibitive_nodes or end in prohibitive_nodes: return [] queue = [(0, start, [])] visited = set() while queue: (cost, current, path) = heapq.heappop(queue) if current in visited: continue path = path + [current] if current == end: if len(path) - 1 <= max_length: return path visited.add(current) for neighbor, weight in self.adjacency_list.get(current, []): if neighbor not in visited and neighbor not in prohibitive_nodes: heapq.heappush(queue, (cost + weight, neighbor, path)) return []"},{"question":"def find_intersection(lists: list[list[int]]) -> list[int]: Returns a list containing the common elements present in all the given lists. If the input 'lists' is empty or contains an empty list, the function should return an empty list. >>> find_intersection([[1, 2, 3], [2, 3, 4], [2, 4, 6]]) == [2] >>> find_intersection([[5, 3, 2], [3, 4, 5], [5, 3]]) == [5, 3] >>> find_intersection([[1, 2], []]) == [] >>> find_intersection([[]]) == [] >>> find_intersection([[1, 3, 5], [9, 7], [2]]) == []","solution":"def find_intersection(lists): Returns the intersection of all input lists. if not lists or any(not sublist for sublist in lists): return [] # Initialize the intersection set with the first list's elements intersection_set = set(lists[0]) for sublist in lists[1:]: intersection_set.intersection_update(sublist) # Maintain the order of first appearance of elements in any list intersection_list = [] first_appearance_set = set() for sublist in lists: for el in sublist: if el in intersection_set and el not in first_appearance_set: first_appearance_set.add(el) intersection_list.append(el) return intersection_list"},{"question":"from typing import List def first_unique_character(s: str) -> int: Find the index of the first non-repeating character in a string. >>> first_unique_character(\\"leetcode\\") 0 >>> first_unique_character(\\"loveleetcode\\") 2 >>> first_unique_character(\\"aabb\\") -1 pass # Test cases to verify the accuracy of your implementation def test_first_unique_character_example1(): assert first_unique_character(\\"leetcode\\") == 0 def test_first_unique_character_example2(): assert first_unique_character(\\"loveleetcode\\") == 2 def test_first_unique_character_example3(): assert first_unique_character(\\"aabb\\") == -1 def test_first_unique_character_single_char(): assert first_unique_character(\\"a\\") == 0 def test_first_unique_character_no_unique_chars(): assert first_unique_character(\\"aabbcc\\") == -1 def test_first_unique_character_all_unique(): assert first_unique_character(\\"abc\\") == 0 def test_first_unique_character_large_input(): input_str = \\"a\\" * 100000 + \\"b\\" assert first_unique_character(input_str) == 100000 def test_first_unique_character_edge_case_empty(): assert first_unique_character(\\"\\") == -1","solution":"def first_unique_character(s: str) -> int: from collections import Counter # Create a counter for all characters in the string char_count = Counter(s) # Iterate through the string and find the first character with count 1 for idx, char in enumerate(s): if char_count[char] == 1: return idx # If no unique character found, return -1 return -1"},{"question":"class Node: def __init__(self, data): self.data = data self.next = None def reverse_linked_list_in_groups(head: Node, k: int) -> Node: Reverse a linked list in groups of given size k. Args: head (Node): The head of the singly linked list. k (int): The size of groups to reverse. Returns: Node: The head of the modified linked list. Example: >>> head = Node(1) >>> head.next = Node(2) >>> head.next.next = Node(3) >>> head.next.next.next = Node(4) >>> head.next.next.next.next = Node(5) >>> k = 2 >>> new_head = reverse_linked_list_in_groups(head, k) >>> linked_list_to_list(new_head) [2, 1, 4, 3, 5] pass","solution":"class Node: def __init__(self, data): self.data = data self.next = None def reverse_linked_list_in_groups(head: Node, k: int) -> Node: if not head or k <= 0: return None current = head prev_tail = None new_head = None while current: count = 0 curr_tail = current prev = None # Reverse k nodes of the linked list while current and count < k: next_node = current.next current.next = prev prev = current current = next_node count += 1 # new_head will be the head of the first set of reversed nodes if not new_head: new_head = prev # Connect the previous reversed group's tail to the new reversed head if prev_tail: prev_tail.next = prev prev_tail = curr_tail return new_head"},{"question":"from typing import List, Dict def group_and_count(input_list: List[int]) -> Dict[int, int]: Groups the integers by their value, counts the occurrences of each integer, and returns a dictionary with each unique integer as the key and the count of its occurrences as the value. Parameters: input_list (list): A list of integers. Returns: dict: A dictionary with unique integers as keys and their counts as values. Examples: >>> group_and_count([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) {1: 1, 2: 2, 3: 3, 4: 4} >>> group_and_count([4, 4, 4, 4]) {4: 4} >>> group_and_count([-1, -1, 0, 1, 1, 1]) {-1: 2, 0: 1, 1: 3} >>> group_and_count([]) {}","solution":"def group_and_count(input_list): Groups the integers by their value, counts the occurrences of each integer, and returns a dictionary with each unique integer as the key and the count of its occurrences as the value. Parameters: input_list (list): A list of integers. Returns: dict: A dictionary with unique integers as keys and their counts as values. count_dict = {} for num in input_list: if num in count_dict: count_dict[num] += 1 else: count_dict[num] = 1 return count_dict"},{"question":"from typing import List class ProductSearch: A class to add products and find products based on a prefix. Methods ------- add_product(product: str) -> None Takes a string product and adds it to an internal list of product names. find_products(prefix: str) -> List[str] Takes a string prefix and returns a list of all product names that start with the given prefix. >>> ps = ProductSearch() >>> ps.add_product(\\"Apple iPhone 13\\") >>> ps.add_product(\\"Samsung Galaxy S21\\") >>> ps.add_product(\\"Apple iPad Air\\") >>> ps.find_products(\\"Samsung\\") ['Samsung Galaxy S21'] >>> ps.find_products(\\"Apple\\") ['Apple iPhone 13', 'Apple iPad Air'] def __init__(self): self.products = [] def add_product(self, product: str) -> None: pass def find_products(self, prefix: str) -> List[str]: pass","solution":"from typing import List class ProductSearch: def __init__(self): self.products = [] def add_product(self, product: str) -> None: self.products.append(product) def find_products(self, prefix: str) -> List[str]: prefix_lower = prefix.lower() result = [product for product in self.products if product.lower().startswith(prefix_lower)] return result"},{"question":"from typing import List def longest_increasing_subsequence(nums: List[int]) -> int: Find the length of the longest strictly increasing subsequence in a given list of integers. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7]) 1 >>> longest_increasing_subsequence([1, 3, 6, 7, 9, 4, 10, 5, 6]) 6 pass def test_lis_example_cases(): assert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 assert longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4 assert longest_increasing_subsequence([7, 7, 7, 7, 7, 7]) == 1 assert longest_increasing_subsequence([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6 def test_lis_edge_cases(): assert longest_increasing_subsequence([]) == 0 assert longest_increasing_subsequence([1]) == 1 assert longest_increasing_subsequence([10, 9, 8, 7, 6, 5]) == 1 assert longest_increasing_subsequence([1, 2, 3, 4, 5]) == 5 def test_lis_various_cases(): assert longest_increasing_subsequence([1, 2, 4, 3, 5, 4, 6, 8]) == 6 assert longest_increasing_subsequence([-1, 3, 4, 5, 2, 2, 2, 2, 6]) == 5 assert longest_increasing_subsequence([2, 2, 2, 2, 2, 2, 2, 2]) == 1 assert longest_increasing_subsequence([i for i in range(1000)]) == 1000 assert longest_increasing_subsequence([i for i in range(1000, -1, -1)]) == 1","solution":"def longest_increasing_subsequence(nums: list) -> int: if not nums: return 0 lis = [] def binary_search(data, target): left, right = 0, len(data) while left < right: mid = (left + right) // 2 if data[mid] >= target: right = mid else: left = mid + 1 return left for num in nums: pos = binary_search(lis, num) if pos >= len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"def correct_sentence(sentence: str, dictionary: dict) -> str: Corrects spelling mistakes in a sentence based on a provided dictionary. Parameters: sentence (str): The input sentence to be corrected. dictionary (dict): A dictionary where keys are incorrect words and values are their corresponding correct words. Returns: str: A corrected sentence. Example: >>> sentence = \\"Ths is a smple snetence with sme mstakes.\\" >>> dictionary = { ... \\"Ths\\": \\"This\\", ... \\"smple\\": \\"simple\\", ... \\"snetence\\": \\"sentence\\", ... \\"sme\\": \\"some\\", ... \\"mstakes\\": \\"mistakes\\" ... } >>> correct_sentence(sentence, dictionary) 'This is a simple sentence with some mistakes.'","solution":"def correct_sentence(sentence: str, dictionary: dict) -> str: Corrects spelling mistakes in a sentence based on a provided dictionary. Parameters: sentence (str): The input sentence to be corrected. dictionary (dict): A dictionary where keys are incorrect words and values are their corresponding correct words. Returns: str: A corrected sentence. words = sentence.split() corrected_words = [] for word in words: # Remove punctuation from the word for checking stripped_word = ''.join(char for char in word if char.isalnum() or char == \\"'\\") if stripped_word in dictionary: # Replace the word, but preserve original punctuation corrected_word = dictionary[stripped_word] for char in word: if not char.isalnum() and char != \\"'\\": corrected_word += char corrected_words.append(corrected_word) else: corrected_words.append(word) return ' '.join(corrected_words)"},{"question":"from datetime import datetime class Library: def __init__(self): Initializes an empty Library instance. pass def borrow_book(self, title: str, due_date: str) -> None: Records the borrowing of a book with the given title and due date. Parameters: title: The title of the book being borrowed. due_date: The due date for returning the book, formatted as \\"YYYY-MM-DD\\". pass def return_book(self, title: str, return_date: str) -> float: Processes the return of a book and calculates the fine amount if it is returned late. Parameters: title: The title of the book being returned. return_date: The actual return date of the book, formatted as \\"YYYY-MM-DD\\". Returns: float: The calculated fine based on the days late. pass # Unit Tests def test_borrow_and_return_book_on_time(): library = Library() library.borrow_book(\\"The Great Gatsby\\", \\"2023-10-10\\") fine = library.return_book(\\"The Great Gatsby\\", \\"2023-10-10\\") assert fine == 0.0 def test_borrow_and_return_book_late(): library = Library() library.borrow_book(\\"1984\\", \\"2023-10-15\\") fine = library.return_book(\\"1984\\", \\"2023-10-20\\") assert fine == 2.5 def test_return_book_with_no_borrow_record(): library = Library() fine = library.return_book(\\"Moby Dick\\", \\"2023-10-20\\") assert fine == 0.0 # Since the book was not borrowed def test_multiple_books(): library = Library() library.borrow_book(\\"Book A\\", \\"2023-10-10\\") library.borrow_book(\\"Book B\\", \\"2023-10-15\\") fine1 = library.return_book(\\"Book A\\", \\"2023-10-12\\") # Expected fine: 1.0 fine2 = library.return_book(\\"Book B\\", \\"2023-10-14\\") # Expected fine: 0.0 assert fine1 == 1.0 assert fine2 == 0.0 def test_return_books_in_different_order(): library = Library() library.borrow_book(\\"Book A\\", \\"2023-10-10\\") library.borrow_book(\\"Book B\\", \\"2023-10-15\\") fine2 = library.return_book(\\"Book B\\", \\"2023-10-17\\") # Expected fine: 1.0 fine1 = library.return_book(\\"Book A\\", \\"2023-10-09\\") # Expected fine: 0.0 assert fine2 == 1.0 assert fine1 == 0.0","solution":"from datetime import datetime class Library: def __init__(self): Initializes an empty Library instance. self.borrowed_books = {} def borrow_book(self, title: str, due_date: str) -> None: Records the borrowing of a book with the given title and due date. Parameters: title: The title of the book being borrowed. due_date: The due date for returning the book, formatted as \\"YYYY-MM-DD\\". self.borrowed_books[title] = due_date def return_book(self, title: str, return_date: str) -> float: Processes the return of a book and calculates the fine amount if it is returned late. Parameters: title: The title of the book being returned. return_date: The actual return date of the book, formatted as \\"YYYY-MM-DD\\". Returns: float: The calculated fine based on the days late. due_date = self.borrowed_books.pop(title, None) if due_date is None: return 0.0 # or raise an error since the book was not borrowed due_date_dt = datetime.strptime(due_date, \\"%Y-%m-%d\\") return_date_dt = datetime.strptime(return_date, \\"%Y-%m-%d\\") if return_date_dt <= due_date_dt: return 0.0 else: late_days = (return_date_dt - due_date_dt).days fine = late_days * 0.50 return fine"},{"question":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, value): Inserts a value into the binary tree. if self.root is None: self.root = Node(value) else: self._insert(value, self.root) def _insert(self, value, current_node): if value < current_node.value: if current_node.left is None: current_node.left = Node(value) else: self._insert(value, current_node.left) else: if current_node.right is None: current_node.right = Node(value) else: self._insert(value, current_node.right) def find_node(self, value): Finds and returns the node with the specified value. return self._find_node(value, self.root) def _find_node(self, value, current_node): if current_node is None: return None elif current_node.value == value: return current_node elif value < current_node.value: return self._find_node(value, current_node.left) else: return self._find_node(value, current_node.right) def is_balanced(self): Checks if the binary tree is height-balanced. >>> tree = BinaryTree() >>> nodes = [10, 5, 15, 3, 7, 13, 17] >>> for value in nodes: ... tree.insert(value) >>> tree.is_balanced() True >>> unbalanced_tree = BinaryTree() >>> unbalanced_nodes = [10, 5, 15, 3, 7, 17, 20] >>> for value in unbalanced_nodes: ... unbalanced_tree.insert(value) >>> unbalanced_tree.is_balanced() False pass def find_lowest_common_ancestor(self, node1, node2): Finds and returns the lowest common ancestor of two given nodes. >>> tree = BinaryTree() >>> nodes = [10, 5, 15, 3, 7, 13, 17] >>> for value in nodes: ... tree.insert(value) >>> node1 = tree.find_node(3) >>> node2 = tree.find_node(7) >>> tree.find_lowest_common_ancestor(node1, node2).value 5 >>> node1 = tree.find_node(3) >>> node2 = tree.find_node(15) >>> tree.find_lowest_common_ancestor(node1, node2).value 10 pass def path_sum(self, target_sum): Checks if there is a root-to-leaf path such that adding up all the values along the path equals the given sum. >>> tree = BinaryTree() >>> nodes = [10, 5, 15, 3, 7, 13, 17] >>> for value in nodes: ... tree.insert(value) >>> tree.path_sum(22) True >>> tree.path_sum(18) True >>> tree.path_sum(45) False pass","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = Node(value) else: self._insert(value, self.root) def _insert(self, value, current_node): if value < current_node.value: if current_node.left is None: current_node.left = Node(value) else: self._insert(value, current_node.left) else: if current_node.right is None: current_node.right = Node(value) else: self._insert(value, current_node.right) def find_node(self, value): return self._find_node(value, self.root) def _find_node(self, value, current_node): if current_node is None: return None elif current_node.value == value: return current_node elif value < current_node.value: return self._find_node(value, current_node.left) else: return self._find_node(value, current_node.right) def is_balanced(self): def check_height(node): if node is None: return 0 left_height = check_height(node.left) if left_height == -1: return -1 right_height = check_height(node.right) if right_height == -1: return -1 if abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return check_height(self.root) != -1 def find_lowest_common_ancestor(self, node1, node2): def lca_helper(node, node1, node2): if node is None or node == node1 or node == node2: return node left = lca_helper(node.left, node1, node2) right = lca_helper(node.right, node1, node2) if left and right: return node return left if left else right return lca_helper(self.root, node1, node2) def path_sum(self, target_sum): def has_path_sum(node, current_sum): if node is None: return False current_sum += node.value if node.left is None and node.right is None: return current_sum == target_sum return has_path_sum(node.left, current_sum) or has_path_sum(node.right, current_sum) return has_path_sum(self.root, 0)"},{"question":"def prime_roll_probability(N: int) -> float: Calculate the probability that at least one of the N rolls of a 12-sided die results in a prime number. The prime numbers between 1 and 12 are 2, 3, 5, 7, and 11. Therefore, the probability of rolling a prime number on a single roll is 5/12. We can use the complement rule to find the probability of at least one prime number in N rolls. Args: N (int): The number of rolls. Returns: float: The probability, rounded to seven decimal places. Examples: >>> abs(prime_roll_probability(1) - 0.3333333) < 1e-7 True >>> abs(prime_roll_probability(2) - 0.5555556) < 1e-7 True >>> abs(prime_roll_probability(3) - 0.7037037) < 1e-7 True","solution":"def prime_roll_probability(N: int) -> float: Calculate the probability that at least one of the N rolls of a 12-sided die results in a prime number. The prime numbers between 1 and 12 are 2, 3, 5, 7, and 11. Therefore, the probability of rolling a prime number on a single roll is 5/12. We can use the complement rule to find the probability of at least one prime number in N rolls. # Probability of rolling a non-prime number in a single roll p_non_prime = 7 / 12 # Probability of not rolling a prime number in N rolls p_no_prime_in_N = p_non_prime ** N # Probability of at least one prime number in N rolls p_at_least_one_prime_in_N = 1 - p_no_prime_in_N # Return the result rounded to 7 decimal places return round(p_at_least_one_prime_in_N, 7)"},{"question":"def weather_data_sum(data: List[Union[List, float, int]]) -> float: Calculate the sum of all numbers in a multi-dimensional array of weather data. Parameters ---------- data : List A multi-dimensional array of floats or integers representing weather data, which can be deeply nested. Returns ------- total_sum : float The sum of all numbers in the data array. Examples -------- >>> weather_data_sum([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]) 36.0 >>> weather_data_sum([[[1.5, 2.5], [3.5, 4.5]], [[5.5, 6.5], [7.5, 8.5]]]) 40.0 import pytest from solution import weather_data_sum def test_single_integer(): assert weather_data_sum(5) == 5.0 def test_single_float(): assert weather_data_sum(5.5) == 5.5 def test_one_dimensional_list(): assert weather_data_sum([1, 2, 3, 4]) == 10.0 def test_two_dimensional_list(): assert weather_data_sum([[1, 2], [3, 4]]) == 10.0 def test_three_dimensional_list(): assert weather_data_sum([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]) == 36.0 def test_mixed_integers_and_floats(): assert weather_data_sum([[[1, 2.0], [3, 4.5]], [[5.5, 6], [7, 8.5]]]) == 37.5 def test_empty_list(): assert weather_data_sum([]) == 0.0 def test_nested_empty_lists(): assert weather_data_sum([[], [[]], [[], []]]) == 0.0 def test_invalid_data_type(): with pytest.raises(ValueError): weather_data_sum(\\"invalid\\") def test_large_nested_structure(): nested_data = [[[1 for _ in range(10)] for _ in range(10)] for _ in range(10)] assert weather_data_sum(nested_data) == 1000.0","solution":"from typing import List, Union def weather_data_sum(data: Union[List, float, int]) -> float: Calculate the sum of all numbers in a multi-dimensional array of weather data. Parameters ---------- data : List A multi-dimensional array of floats or integers representing weather data, which can be deeply nested. Returns ------- total_sum : float The sum of all numbers in the data array. Examples -------- >>> weather_data_sum([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]) 36.0 >>> weather_data_sum([[[1.5, 2.5], [3.5, 4.5]], [[5.5, 6.5], [7.5, 8.5]]]) 40.0 if isinstance(data, (int, float)): return float(data) elif isinstance(data, list): total_sum = 0.0 for element in data: total_sum += weather_data_sum(element) return total_sum else: raise ValueError(\\"Invalid data type: must be list, int, or float.\\")"},{"question":"def longest_common_subsequence(s1: str, s2: str) -> int: Determine the length of longest common subsequence of two strings. >>> longest_common_subsequence(\\"abcdef\\", \\"axcyeff\\") 4 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"abcdef\\", \\"abcdef\\") 6 >>> longest_common_subsequence(\\"abc\\", \\"aebdc\\") 3 >>> longest_common_subsequence(\\"\\", \\"abc\\") 0 >>> longest_common_subsequence(\\"a\\", \\"a\\") 1 >>> longest_common_subsequence(\\"a\\", \\"b\\") 0 >>> longest_common_subsequence(\\"a\\" * 1000, \\"a\\" * 1000) 1000","solution":"def longest_common_subsequence(s1: str, s2: str) -> int: Function to determine length of the longest common subsequence between two strings. # initialize the 2D dp array dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)] # build the dp array from bottom up for i in range(1, len(s1) + 1): for j in range(1, len(s2) + 1): if s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) # the last cell contains the length of the LCS return dp[-1][-1]"},{"question":"from typing import List def min_cost_path(grid: List[List[int]]) -> int: Find the minimum cost path from the top-left corner to the bottom-right corner of the grid. You can only move right or down from a cell. >>> min_cost_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_path([[1, 2, 3, 4]]) 10 >>> min_cost_path([[1], [2], [3], [4]]) 10 >>> min_cost_path([[0]]) 0 >>> min_cost_path([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 5 >>> min_cost_path([[1000, 1000], [1000, 1000]]) 3000 >>> min_cost_path([[0, 0], [0, 0]]) 0","solution":"from typing import List def min_cost_path(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"def binary_search_iterative(arr: list, target: int) -> int: Perform an iterative binary search to find the index of the target element in a sorted list. :param arr: List of sorted integers. :param target: Integer target value to search for. :return: Index of the target element if found, otherwise -1. Examples: >>> binary_search_iterative([1, 2, 3, 4, 5, 6, 7, 8, 9], 6) 5 >>> binary_search_iterative([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) -1 >>> binary_search_iterative([], 4) -1","solution":"def binary_search_iterative(arr: list, target: int) -> int: Perform an iterative binary search to find the index of the target element in a sorted list. :param arr: List of sorted integers. :param target: Integer target value to search for. :return: Index of the target element if found, otherwise -1. left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def sum_of_multiples(numbers: list, limit: int) -> int: Calculate the sum of all multiples of given numbers up to the specified limit. >>> sum_of_multiples([3, 5], 10) 23 >>> sum_of_multiples([7, 3], 20) 84 >>> sum_of_multiples([1], 5) 10 >>> sum_of_multiples([], 100) 0 >>> sum_of_multiples([5], 5) 0","solution":"def sum_of_multiples(numbers, limit): Calculate the sum of all multiples of given numbers up to the specified limit. if not numbers: return 0 multiples = set() for number in numbers: if number <= 0: continue for multiple in range(number, limit, number): multiples.add(multiple) return sum(multiples)"},{"question":"def encode(message: str, shift: int) -> str: Encode a message using the Caesar Cipher. >>> encode('hello world', 3) 'khoor zruog' >>> encode('caesar cipher', 5) 'hfjxfw hnumjw' def decode(encoded_message: str, shift: int) -> str: Decode an encoded message using the Caesar Cipher. >>> decode('khoor zruog', 3) 'hello world' >>> decode('hfjxfw hnumjw', 5) 'caesar cipher'","solution":"def encode(message: str, shift: int) -> str: encoded_message = [] for char in message: if char == ' ': encoded_message.append(char) else: # Calculate the shifted character shifted_char = chr(((ord(char) - 97 + shift) % 26) + 97) encoded_message.append(shifted_char) return ''.join(encoded_message) def decode(encoded_message: str, shift: int) -> str: decoded_message = [] for char in encoded_message: if char == ' ': decoded_message.append(char) else: # Calculate the original character after reversing the shift original_char = chr(((ord(char) - 97 - shift) % 26) + 97) decoded_message.append(original_char) return ''.join(decoded_message)"},{"question":"def min_operations_to_transform(str1: str, str2: str) -> int: Calculates the minimum number of operations required to transform str1 into str2. >>> min_operations_to_transform('1101', '1011') 2 >>> min_operations_to_transform('1000', '0111') 3","solution":"def min_operations_to_transform(str1: str, str2: str) -> int: flips = 0 for i in range(len(str1)): if str1[i] != str2[i]: flips += 1 return flips"},{"question":"def evaluate_math_expression(expression: str) -> float: Evaluate a mathematical expression and return the result. :param expression: A string representing a mathematical expression. :return: A float representing the result of the evaluation. Examples: >>> evaluate_math_expression(\\"3 + 2 * (1 + 2)\\") 9.0 >>> evaluate_math_expression(\\"10 / 2 + 5 * (3 - 1)\\") 15.0 >>> evaluate_math_expression(\\"7 + (6 * 5^2 + 3)\\") 160.0 pass def test_simple_addition(): assert evaluate_math_expression(\\"3 + 2\\") == 5.0 def test_multiplication_and_addition(): assert evaluate_math_expression(\\"3 + 2 * (1 + 2)\\") == 9.0 def test_division_and_addition(): assert evaluate_math_expression(\\"10 / 2 + 5 * (3 - 1)\\") == 15.0 def test_expression_with_nested_parentheses(): assert evaluate_math_expression(\\"3 + 2 * ((1 + 2) * (2 + 1))\\") == 21.0 def test_whitespace_in_expression(): assert evaluate_math_expression(\\"3 + 2 * ( 1 + 2 )\\") == 9.0 def test_complex_expression(): assert evaluate_math_expression(\\"10 / 2 + 5 * (3 - 1) + (4 + 5) * 2\\") == 33.0 def test_expression_with_only_parentheses(): assert evaluate_math_expression(\\"((2))\\") == 2.0 def test_expression_with_multiple_operations(): assert evaluate_math_expression(\\"7 - 2 * 3 + 4 / 2\\") == 3.0","solution":"def evaluate_math_expression(expression: str) -> float: def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_op(a, b, op): if op == '+': return a + b if op == '-': return a - b if op == '*': return a * b if op == '/': return a / b def evaluate(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == ' ': i += 1 continue if tokens[i] == '(': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while i < len(tokens) and tokens[i].isdigit(): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == ')': while len(ops) != 0 and ops[-1] != '(': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1] return float(evaluate(expression))"},{"question":"def unique_paths(rows: int, cols: int) -> int: Calculates the number of unique paths from the top-left to the bottom-right of a grid with the given number of rows and columns. Parameters: rows (int): Number of rows in the grid cols (int): Number of columns in the grid Returns: int: Number of unique paths Raises: ValueError: If rows or cols are not positive integers. def test_unique_paths(): assert unique_paths(1, 1) == 1 assert unique_paths(2, 2) == 2 assert unique_paths(3, 2) == 3 assert unique_paths(2, 3) == 3 assert unique_paths(3, 3) == 6 assert unique_paths(7, 3) == 28 assert unique_paths(3, 7) == 28 assert unique_paths(10, 10) == 48620 assert unique_paths(20, 20) == 35345263800 assert unique_paths(1, 10) == 1 assert unique_paths(10, 1) == 1 for non_integer in ['3', 3.5]: try: unique_paths(non_integer, 2) except ValueError as e: assert str(e) == \\"rows and cols must be integers\\" for non_positive in [-1, 0]: try: unique_paths(non_positive, 5) except ValueError as e: assert str(e) == \\"rows and cols must be positive integers\\" try: unique_paths(5, non_positive) except ValueError as e: assert str(e) == \\"rows and cols must be positive integers\\"","solution":"def unique_paths(rows: int, cols: int) -> int: Calculates the number of unique paths from the top-left to the bottom-right of a grid with the given number of rows and columns. Parameters: rows (int): Number of rows in the grid cols (int): Number of columns in the grid Returns: int: Number of unique paths Raises: ValueError: If rows or cols are not positive integers. if not (isinstance(rows, int) and isinstance(cols, int)): raise ValueError(\\"rows and cols must be integers\\") if rows <= 0 or cols <= 0: raise ValueError(\\"rows and cols must be positive integers\\") dp = [[0] * cols for _ in range(rows)] for i in range(rows): dp[i][0] = 1 for j in range(cols): dp[0][j] = 1 for i in range(1, rows): for j in range(1, cols): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[rows-1][cols-1]"},{"question":"import threading class InMemoryStorage: def __init__(self): Initialize an in-memory key-value storage with thread-safety using a lock self.store = {} self.lock = threading.Lock() def set(self, key: str, value: str): Store the key-value pair. If the key already exists, update its value def get(self, key: str) -> str: Retrieve the value associated with the given key. If the key does not exist, return None def delete(self, key: str): Delete the given key and its associated value. If the key does not exist, do nothing def list_keys(self) -> [str]: Return a list of all stored keys # Unit Tests def test_set_and_get_single(): store = InMemoryStorage() store.set('key1', 'value1') assert store.get('key1') == 'value1' def test_update_value(): store = InMemoryStorage() store.set('key1', 'value1') store.set('key1', 'value2') assert store.get('key1') == 'value2' def test_get_nonexistent_key(): store = InMemoryStorage() assert store.get('nonexistent') == None def test_delete_key(): store = InMemoryStorage() store.set('key1', 'value1') store.delete('key1') assert store.get('key1') == None def test_delete_nonexistent_key(): store = InMemoryStorage() store.delete('nonexistent') # should not raise exception assert store.get('nonexistent') == None def test_list_keys(): store = InMemoryStorage() store.set('key1', 'value1') store.set('key2', 'value2') keys = store.list_keys() assert 'key1' in keys assert 'key2' in keys assert len(keys) == 2","solution":"import threading class InMemoryStorage: def __init__(self): self.store = {} self.lock = threading.Lock() def set(self, key: str, value: str): with self.lock: self.store[key] = value def get(self, key: str) -> str: with self.lock: return self.store.get(key, None) def delete(self, key: str): with self.lock: if key in self.store: del self.store[key] def list_keys(self) -> [str]: with self.lock: return list(self.store.keys())"},{"question":"from typing import List def find_odd_occurrence(nums: List[int]) -> int: Find and return the integer that appears an odd number of times in the list. Args: nums (List[int]): List of integers where each integer appears an even number of times, except for one integer that appears an odd number of times. Returns: int: The integer that appears an odd number of times. Examples: >>> find_odd_occurrence([1, 2, 2, 1, 3, 3, 4]) 4 >>> find_odd_occurrence([10]) 10 >>> find_odd_occurrence([5, 7, 7, 5, 3]) 3 >>> find_odd_occurrence([0, 0, 1, 1, 2, 2, 2]) 2 def test_single_element(): assert find_odd_occurrence([10]) == 10 def test_all_pairs_but_one(): assert find_odd_occurrence([1, 2, 2, 1, 3, 3, 4]) == 4 def test_with_multiple_pairs(): assert find_odd_occurrence([5, 7, 7, 5, 3]) == 3 def test_odd_occurrence_in_larger_set(): assert find_odd_occurrence([0, 0, 1, 1, 2, 2, 2]) == 2 def test_large_input(): # Test with an input containing 1,000,000 elements large_list = [1, 2] * 500000 + [3] assert find_odd_occurrence(large_list) == 3 def test_mixed_elements(): assert find_odd_occurrence([4, 3, 3, 4, 5, 5, 4, 4, 5, 5, 6]) == 6","solution":"from typing import List def find_odd_occurrence(nums: List[int]) -> int: odd_occurrence = 0 for num in nums: odd_occurrence ^= num return odd_occurrence"},{"question":"from typing import List def longest_consecutive_subarray(arr: List[int]) -> int: Find the length of the longest subarray consisting of the same element from a given list of integers. Args: arr (List[int]): A list of integers. Returns: int: The length of the longest subarray consisting of the same element. Raises: TypeError: If the input is not a list. ValueError: If any element of the list is not an integer. Examples: >>> longest_consecutive_subarray([1, 1, 2, 2, 2, 3, 1]) 3 >>> longest_consecutive_subarray([1, 1, 1, 1, 1]) 5 >>> longest_consecutive_subarray([]) 0 def test_longest_consecutive_subarray(): # Test with repeated elements assert longest_consecutive_subarray([1, 1, 2, 2, 2, 3, 1]) == 3 # Test with all elements the same assert longest_consecutive_subarray([1, 1, 1, 1, 1]) == 5 # Test with no elements assert longest_consecutive_subarray([]) == 0 # Test with list containing single element assert longest_consecutive_subarray([1]) == 1 assert longest_consecutive_subarray([1, 2, 3, 4, 5]) == 1 # Test with alternating elements assert longest_consecutive_subarray([1, 2, 1, 2, 1]) == 1 # Test with longer subarrays of same elements assert longest_consecutive_subarray([1, 1, 2, 2, 2, 3, 3, 3, 3]) == 4 def test_longest_consecutive_subarray_type_error(): try: longest_consecutive_subarray(\\"12345\\") except TypeError as e: assert str(e) == \\"Input should be a list\\" def test_longest_consecutive_subarray_value_error(): try: longest_consecutive_subarray([1, 1, '2', 2, 2, 3, 1]) except ValueError as e: assert str(e) == \\"All elements must be integers\\"","solution":"from typing import List def longest_consecutive_subarray(arr: List[int]) -> int: if not isinstance(arr, list): raise TypeError(\\"Input should be a list\\") for element in arr: if not isinstance(element, int): raise ValueError(\\"All elements must be integers\\") if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"from datetime import datetime, timedelta from typing import List, Tuple def merge_events(events: List[Tuple[str, str]], time_window: int) -> List[List[Tuple[str, str]]]: Merge consecutive events occurring within a specified time window. Args: events (List[Tuple[str, str]]): A list of tuples, where each tuple contains an event timestamp in the format 'YYYY-MM-DD HH:MM:SS' and an event description. time_window (int): The maximum number of seconds between consecutive events for them to be considered part of the same consolidated event. Returns: List[List[Tuple[str, str]]]: A list of lists, where each inner list contains tuples of merged consecutive events within the given time window. Examples: >>> merge_events( events=[ (\\"2023-10-01 12:00:00\\", \\"Event A\\"), (\\"2023-10-01 12:00:10\\", \\"Event B\\"), (\\"2023-10-01 12:01:00\\", \\"Event C\\"), (\\"2023-10-01 13:00:00\\", \\"Event D\\") ], time_window=30 ) [[(\\"2023-10-01 12:00:00\\", \\"Event A\\"), (\\"2023-10-01 12:00:10\\", \\"Event B\\")], [(\\"2023-10-01 12:01:00\\", \\"Event C\\")], [(\\"2023-10-01 13:00:00\\", \\"Event D\\")]] >>> merge_events( events=[ (\\"2023-10-01 12:00:00\\", \\"Event A\\"), (\\"2023-10-01 12:00:10\\", \\"Event B\\"), (\\"2023-10-01 12:01:00\\", \\"Event C\\"), (\\"2023-10-01 13:00:00\\", \\"Event D\\") ], time_window=3600 ) [[(\\"2023-10-01 12:00:00\\", \\"Event A\\"), (\\"2023-10-01 12:00:10\\", \\"Event B\\"), (\\"2023-10-01 12:01:00\\", \\"Event C\\"), (\\"2023-10-01 13:00:00\\", \\"Event D\\")]]","solution":"from datetime import datetime, timedelta from typing import List, Tuple def merge_events(events: List[Tuple[str, str]], time_window: int) -> List[List[Tuple[str, str]]]: if not events: return [] merged_events = [] current_group = [events[0]] for i in range(1, len(events)): current_timestamp = datetime.strptime(events[i][0], \\"%Y-%m-%d %H:%M:%S\\") last_timestamp = datetime.strptime(events[i - 1][0], \\"%Y-%m-%d %H:%M:%S\\") if (current_timestamp - last_timestamp).total_seconds() <= time_window: current_group.append(events[i]) else: merged_events.append(current_group) current_group = [events[i]] merged_events.append(current_group) return merged_events"},{"question":"def reconstruct_with_parity(encoded: str, block_size: int) -> str: Reconstructs the original data by removing parity bits from the encoded string and correcting any single-bit errors. The encoded string is divided into blocks of length block_size with the last bit being the parity bit. >>> reconstruct_with_parity('100111010011', 4) '101011' >>> reconstruct_with_parity('110010111000', 4) '100110' >>> reconstruct_with_parity('101011010011', 4) '101011' >>> reconstruct_with_parity('110011011000', 4) '100110' >>> reconstruct_with_parity('110110001010', 4) '111000' >>> reconstruct_with_parity('1001110110110000', 4) '101011000' >>> reconstruct_with_parity('1010110101111100010110', 4) '101011111000'","solution":"def reconstruct_with_parity(encoded: str, block_size: int) -> str: Reconstructs the original data by removing parity bits from the encoded string and correcting any single-bit errors. The encoded string is divided into blocks of length block_size with the last bit being the parity bit. original_data = [] for i in range(0, len(encoded), block_size): block = encoded[i:i+block_size] data_bits = block[:-1] parity_bit = block[-1] # Calculate the expected parity from the data bits expected_parity = str(sum(int(bit) for bit in data_bits) % 2) if expected_parity != parity_bit: # There is a single-bit error, find it and correct it corrected_data_bits = list(data_bits) for j in range(len(data_bits)): # Flip each bit and check parity corrected_data_bits[j] = '1' if corrected_data_bits[j] == '0' else '0' if str(sum(int(bit) for bit in corrected_data_bits) % 2) == parity_bit: data_bits = ''.join(corrected_data_bits) break # Revert the bit back corrected_data_bits[j] = '1' if corrected_data_bits[j] == '0' else '0' original_data.append(data_bits) return ''.join(original_data)"},{"question":"def string_to_integer(s: str) -> int: Convert a string representation of an integer into its numerical form. >>> string_to_integer(\\" -42\\") -42 >>> string_to_integer(\\"4193 with words\\") 4193 >>> string_to_integer(\\"words and 987\\") 0 >>> string_to_integer(\\"+-12\\") 0 >>> string_to_integer(\\"42\\") 42 >>> string_to_integer(\\" +0 123\\") 0 >>> string_to_integer(\\" +123\\") 123 >>> string_to_integer(\\" -0012\\") -12","solution":"def string_to_integer(s: str) -> int: n = len(s) if n == 0: return 0 index = 0 sign = 1 result = 0 # Skip leading whitespaces while index < n and s[index] == ' ': index += 1 # Check for sign if index < n and (s[index] == '+' or s[index] == '-'): if s[index] == '-': sign = -1 index += 1 # Convert digits to integer while index < n and s[index].isdigit(): result = result * 10 + int(s[index]) index += 1 # Return the final result with sign return sign * result"},{"question":"class BookstoreInventory: def __init__(self): self.inventory = {} def add_book(self, title: str, author: str, price: float, quantity: int) -> None: Add a book to the inventory or update it if it already exists. >>> inventory = BookstoreInventory() >>> inventory.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 10.99, 5) >>> inventory.inventory[\\"The Great Gatsby\\"] {'author': 'F. Scott Fitzgerald', 'price': 10.99, 'quantity': 5} pass def remove_book(self, title: str, quantity: int) -> None: Remove a specified quantity of a book from the inventory. If quantity exceeds current stock, remove the book. >>> inventory = BookstoreInventory() >>> inventory.add_book(\\"1984\\", \\"George Orwell\\", 8.99, 10) >>> inventory.remove_book(\\"1984\\", 5) >>> inventory.inventory[\\"1984\\"] {'author': 'George Orwell', 'price': 8.99, 'quantity': 5} pass def search_book(self, title: str) -> Optional[Dict[str, Any]]: Search for a book by its title and return its details. >>> inventory = BookstoreInventory() >>> inventory.add_book(\\"The Catcher in the Rye\\", \\"J.D. Salinger\\", 6.99, 7) >>> inventory.search_book(\\"The Catcher in the Rye\\") {'author': 'J.D. Salinger', 'price': 6.99, 'quantity': 7} pass def get_stock_report(self) -> List[Dict[str, Any]]: Generate a stock report of all books in the inventory. >>> inventory = BookstoreInventory() >>> inventory.add_book(\\"Book One\\", \\"Author A\\", 5.99, 10) >>> inventory.add_book(\\"Book Two\\", \\"Author B\\", 7.99, 3) >>> inventory.get_stock_report() [{'title': 'Book One', 'author': 'Author A', 'price': 5.99, 'quantity': 10}, {'title': 'Book Two', 'author': 'Author B', 'price': 7.99, 'quantity': 3}] pass","solution":"class BookstoreInventory: def __init__(self): self.inventory = {} def add_book(self, title: str, author: str, price: float, quantity: int) -> None: if title in self.inventory: if self.inventory[title]['author'] != author or self.inventory[title]['price'] != price: self.inventory[title]['author'] = author self.inventory[title]['price'] = price self.inventory[title]['quantity'] += quantity else: self.inventory[title] = {'author': author, 'price': price, 'quantity': quantity} def remove_book(self, title: str, quantity: int) -> None: if title in self.inventory: if quantity >= self.inventory[title]['quantity']: del self.inventory[title] else: self.inventory[title]['quantity'] -= quantity def search_book(self, title: str) -> dict: return self.inventory.get(title, None) def get_stock_report(self) -> list: return [{'title': title, 'author': details['author'], 'price': details['price'], 'quantity': details['quantity']} for title, details in self.inventory.items()] # Initialize the inventory system instance for testing inventory_instance = BookstoreInventory()"},{"question":"import csv def analyze_movie_ratings(file_path: str) -> dict: Reads a CSV file containing movie titles and their corresponding ratings, and returns a dictionary with various statistical calculations. Args: file_path (str): Path to the CSV file. Returns: dict: Dictionary containing total_movies, average_rating, highest_rated_movie, and lowest_rated_movie. Example: >>> file_path = 'movies.csv' >>> analyze_movie_ratings(file_path) { \\"total_movies\\": 4, \\"average_rating\\": 8.7, \\"highest_rated_movie\\": \\"The Dark Knight\\", \\"lowest_rated_movie\\": \\"Memento\\" }","solution":"import csv def analyze_movie_ratings(file_path: str) -> dict: movies = [] ratings = [] with open(file_path, mode='r') as file: reader = csv.DictReader(file) for row in reader: title = row.get('Title') try: rating = float(row.get('Rating')) movies.append(title) ratings.append(rating) except (TypeError, ValueError): continue if not ratings: return { \\"total_movies\\": 0, \\"average_rating\\": 0.0, \\"highest_rated_movie\\": \\"\\", \\"lowest_rated_movie\\": \\"\\" } total_movies = len(movies) average_rating = round(sum(ratings) / total_movies, 2) max_rating_index = ratings.index(max(ratings)) min_rating_index = ratings.index(min(ratings)) highest_rated_movie = movies[max_rating_index] lowest_rated_movie = movies[min_rating_index] return { \\"total_movies\\": total_movies, \\"average_rating\\": average_rating, \\"highest_rated_movie\\": highest_rated_movie, \\"lowest_rated_movie\\": lowest_rated_movie }"},{"question":"def process_transactions(start_balance: float | str, transactions: list[tuple[str, float | str]]) -> float: Simulate a simple banking transaction system by processing a series of transactions for a single account and return the final balance. >>> process_transactions(1000, [(\\"deposit\\", \\"500\\"), (\\"withdraw\\", \\"200\\"), (\\"withdraw\\", \\"2000\\")]) 1300.0 >>> process_transactions(1000, [(\\"withdraw\\", \\"500\\"), (\\"withdraw\\", 600)]) 500.0 >>> process_transactions(\\"invalid\\", [(\\"deposit\\", \\"500\\")]) 0.0 >>> process_transactions(1000, [(\\"invalid\\", \\"500\\")]) 0.0 >>> process_transactions(1000, [(\\"deposit\\", \\"200\\"), (\\"withdraw\\", \\"50.5\\")]) 1149.5","solution":"def process_transactions(start_balance: float | str, transactions: list[tuple[str, float | str]]) -> float: try: balance = float(start_balance) except ValueError: return 0.0 if balance < 0: return 0.0 for transaction in transactions: try: trans_type, amount = transaction amount = float(amount) except (ValueError, TypeError): return 0.0 if trans_type == 'deposit': balance += amount elif trans_type == 'withdraw': if balance >= amount: balance -= amount else: return 0.0 return balance"},{"question":"class Friend: def __init__(self, name, mutual_interests): self.name = name self.mutual_interests = mutual_interests def get_mutual_interests(self): return self.mutual_interests def __repr__(self): return f\\"{self.__class__.__name__}({self.name}, {self.mutual_interests})\\" def __eq__(self, other): return (self.name, self.mutual_interests) == (other.name, other.mutual_interests) def build_friend_list(names, mutual_interests): Constructs a list of Friend objects from the given names and mutual interests. pass def organize_friends(friend_list): Sorts a list of Friend objects by the number of mutual interests in descending order. If two friends have the same number of mutual interests, sort them alphabetically by name. pass import pytest def test_organize_friends_basic(): names = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\"] mutual_interests = [5, 3, 5, 2] friend_list = build_friend_list(names, mutual_interests) sorted_friends = organize_friends(friend_list) expected_result = [ Friend(\\"Alice\\", 5), Friend(\\"Charlie\\", 5), Friend(\\"Bob\\", 3), Friend(\\"David\\", 2) ] assert sorted_friends == expected_result, f\\"Expected {expected_result} but got {sorted_friends}\\" def test_organize_friends_same_interests(): names = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\"] mutual_interests = [3, 3, 3, 3] friend_list = build_friend_list(names, mutual_interests) sorted_friends = organize_friends(friend_list) expected_result = [ Friend(\\"Alice\\", 3), Friend(\\"Bob\\", 3), Friend(\\"Charlie\\", 3), Friend(\\"David\\", 3) ] assert sorted_friends == expected_result, f\\"Expected {expected_result} but got {sorted_friends}\\" def test_organize_friends_different_interests(): names = [\\"Bob\\", \\"Alice\\", \\"David\\", \\"Charlie\\"] mutual_interests = [2, 5, 1, 3] friend_list = build_friend_list(names, mutual_interests) sorted_friends = organize_friends(friend_list) expected_result = [ Friend(\\"Alice\\", 5), Friend(\\"Charlie\\", 3), Friend(\\"Bob\\", 2), Friend(\\"David\\", 1) ] assert sorted_friends == expected_result, f\\"Expected {expected_result} but got {sorted_friends}\\" def test_build_friend_list(): names = [\\"Alice\\", \\"Bob\\"] mutual_interests = [3, 2] friend_objects = build_friend_list(names, mutual_interests) expected_result = [Friend(\\"Alice\\", 3), Friend(\\"Bob\\", 2)] assert friend_objects == expected_result, f\\"Expected {expected_result} but got {friend_objects}\\"","solution":"class Friend: def __init__(self, name, mutual_interests): self.name = name self.mutual_interests = mutual_interests def get_mutual_interests(self): return self.mutual_interests def __repr__(self): return f\\"Friend({self.name}, {self.mutual_interests})\\" def __eq__(self, other): return (self.name, self.mutual_interests) == (other.name, other.mutual_interests) def build_friend_list(names, mutual_interests): Constructs a list of Friend objects from the given names and mutual interests. return [Friend(name, interests) for name, interests in zip(names, mutual_interests)] def organize_friends(friend_list): Sorts a list of Friend objects by the number of mutual interests in descending order. If two friends have the same number of mutual interests, sort them alphabetically by name. return sorted(friend_list, key=lambda friend: (-friend.get_mutual_interests(), friend.name))"},{"question":"def is_prefix_free(codes: List[str]) -> bool: Determines if the given list of binary codes is prefix-free. :param codes: List of strings where each string represents a binary code. :return: Boolean value True if the list is prefix-free, otherwise False. pass from typing import List def test_empty_list(): assert is_prefix_free([]) == True def test_single_element_list(): assert is_prefix_free([\\"0\\"]) == True assert is_prefix_free([\\"1\\"]) == True def test_simple_prefix_free(): assert is_prefix_free([\\"101\\", \\"1001\\", \\"1110\\", \\"1111\\"]) == True def test_simple_non_prefix_free(): assert is_prefix_free([\\"101\\", \\"10\\", \\"1110\\", \\"1111\\"]) == False def test_multiple_codes_prefix_free(): assert is_prefix_free([\\"010\\", \\"10000\\", \\"01101\\", \\"111\\"]) == True def test_multiple_codes_non_prefix_free(): assert is_prefix_free([\\"101\\", \\"1010\\", \\"1011\\", \\"10\\"]) == False def test_long_codes_prefix_free(): assert is_prefix_free([\\"100000\\", \\"1111111\\", \\"101010101\\", \\"1110001010\\", \\"0000111100\\"]) == True def test_long_codes_non_prefix_free(): assert is_prefix_free([\\"100000\\", \\"111\\", \\"101010101\\", \\"1110001010\\", \\"0000111100\\", \\"10\\"]) == False","solution":"def is_prefix_free(codes): Determines if the given list of binary codes is prefix-free. :param codes: List of strings where each string represents a binary code. :return: Boolean value True if the list is prefix-free, otherwise False. # Sort the list of codes codes.sort() # Traverse the sorted list and check for prefix condition for i in range(len(codes) - 1): # If the current code is a prefix of the next one, return False if codes[i+1].startswith(codes[i]): return False return True"},{"question":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix): node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def list_words_with_prefix(trie, prefix): Retrieve all words stored in the Trie that start with the given prefix. Args: trie (Trie): An instance of the Trie class. prefix (str): The prefix string to search for. Returns: List[str]: A list of words in lexicographical order that start with the given prefix. Example: >>> trie = Trie() >>> words = [\\"apple\\", \\"app\\", \\"application\\", \\"apply\\", \\"apt\\", \\"cat\\", \\"catalog\\", \\"catch\\"] >>> for word in words: >>> trie.insert(word) >>> list_words_with_prefix(trie, \\"app\\") [\\"app\\", \\"apple\\", \\"application\\", \\"apply\\"] >>> list_words_with_prefix(trie, \\"cat\\") [\\"cat\\", \\"catalog\\", \\"catch\\"] >>> list_words_with_prefix(trie, \\"do\\") [] # Implement your function here import pytest from solution import Trie, list_words_with_prefix def test_list_words_with_prefix_basic(): trie = Trie() words = [\\"apple\\", \\"app\\", \\"application\\", \\"apply\\", \\"apt\\", \\"cat\\", \\"catalog\\", \\"catch\\"] for word in words: trie.insert(word) assert list_words_with_prefix(trie, \\"app\\") == [\\"app\\", \\"apple\\", \\"application\\", \\"apply\\"] assert list_words_with_prefix(trie, \\"cat\\") == [\\"cat\\", \\"catalog\\", \\"catch\\"] assert list_words_with_prefix(trie, \\"do\\") == [] def test_list_words_with_prefix_empty_trie(): trie = Trie() assert list_words_with_prefix(trie, \\"a\\") == [] def test_list_words_with_prefix_no_match(): trie = Trie() words = [\\"apple\\", \\"app\\", \\"banana\\"] for word in words: trie.insert(word) assert list_words_with_prefix(trie, \\"xyz\\") == [] def test_list_words_with_prefix_no_prefix(): trie = Trie() words = [\\"dog\\", \\"deer\\", \\"deal\\"] for word in words: trie.insert(word) assert list_words_with_prefix(trie, \\"\\") == [\\"deal\\", \\"deer\\", \\"dog\\"] def test_list_words_with_prefix_single_char_prefix(): trie = Trie() words = [\\"a\\", \\"an\\", \\"ant\\", \\"bear\\", \\"bee\\", \\"cat\\"] for word in words: trie.insert(word) assert list_words_with_prefix(trie, \\"a\\") == [\\"a\\", \\"an\\", \\"ant\\"] assert list_words_with_prefix(trie, \\"b\\") == [\\"bear\\", \\"bee\\"] assert list_words_with_prefix(trie, \\"c\\") == [\\"cat\\"] def test_list_words_with_prefix_exact_word(): trie = Trie() words = [\\"hello\\", \\"helium\\"] for word in words: trie.insert(word) assert list_words_with_prefix(trie, \\"hello\\") == [\\"hello\\"] assert list_words_with_prefix(trie, \\"helium\\") == [\\"helium\\"]","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix): node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def list_words_with_prefix(trie, prefix): result = [] node = trie.root for char in prefix: if char not in node.children: return result node = node.children[char] def dfs(current_node, current_prefix): if current_node.is_end_of_word: result.append(current_prefix) for char in sorted(current_node.children): dfs(current_node.children[char], current_prefix + char) dfs(node, prefix) return result"},{"question":"def is_balanced(code: str) -> bool: Given a string representing a piece of code, determine if the code contains balanced brackets. The brackets that need to be balanced are: \`()\`, \`{}\`, \`[]\`, and \`<>\`. >>> is_balanced(\\"{[(<>)<()>]}\\") True >>> is_balanced(\\"((([[[<>]]])))\\") True >>> is_balanced(\\"{[(<>)<()>]\\") False >>> is_balanced(\\"[(])\\") False >>> is_balanced(\\"\\") True >>> is_balanced(\\"<>{}[]()\\") True >>> is_balanced(\\"{[}]\\") False >>> is_balanced(\\"{[<]>}\\") False >>> is_balanced(\\"a(b){c}[d]<e>\\") True >>> is_balanced(\\"a(b{c}[d]<e>\\") False","solution":"def is_balanced(code: str) -> bool: This function checks if the input string has balanced brackets. stack = [] matching_bracket = {')': '(', '}': '{', ']': '[', '>': '<'} for char in code: if char in matching_bracket.values(): # if it's an opening bracket stack.append(char) elif char in matching_bracket: # if it's a closing bracket if stack and stack[-1] == matching_bracket[char]: stack.pop() else: return False return not stack"},{"question":"def correct_spelling(text: str, dictionary: List[str]) -> Dict[str, str]: Correct misspelled words in the text based on the provided dictionary. :param text: A string containing the document text. :param dictionary: A list of correctly spelled words. :return: A dictionary mapping each incorrect word to its corrected form. pass","solution":"from typing import List, Dict def levenshtein_distance(word1: str, word2: str) -> int: Calculate the Levenshtein distance between two words. m, n = len(word1), len(word2) if m < n: word1, word2 = word2, word1 m, n = n, m previous_row = range(n + 1) for i, c1 in enumerate(word1): current_row = [i + 1] for j, c2 in enumerate(word2): insertions = previous_row[j + 1] + 1 deletions = current_row[j] + 1 substitutions = previous_row[j] + (c1 != c2) current_row.append(min(insertions, deletions, substitutions)) previous_row = current_row return previous_row[-1] def correct_spelling(text: str, dictionary: List[str]) -> Dict[str, str]: Correct misspelled words in the text based on the provided dictionary. :param text: A string containing the document text. :param dictionary: A list of correctly spelled words. :return: A dictionary mapping each incorrect word to its corrected form. words = text.split() corrections = {} for word in words: if word not in dictionary: min_distance = float('inf') correction = word for correct_word in dictionary: distance = levenshtein_distance(word, correct_word) if distance < min_distance: min_distance = distance correction = correct_word corrections[word] = correction return corrections"},{"question":"def most_frequent_char(s: str) -> str: Given a string s containing only lowercase alphabets, return the most frequent character in the string. In the case of a tie, return the lexicographically smallest character among them. >>> most_frequent_char(\\"aabbbcc\\") 'b' >>> most_frequent_char(\\"abcdabcdabcde\\") 'a' >>> most_frequent_char(\\"zzzzxy\\") 'z'","solution":"def most_frequent_char(s: str) -> str: from collections import Counter # Create a counter for all characters in the string count = Counter(s) # Find the maximum frequency of any character max_frequency = max(count.values()) # Get all characters with the maximum frequency candidates = [char for char, freq in count.items() if freq == max_frequency] # Return the lexicographically smallest character among the candidates return min(candidates)"},{"question":"from typing import List def longest_active_streak(dates: List[str]) -> int: Find the longest streak of consecutive days the user was active. Parameters: - dates (List[str]): List of strings representing active dates in \\"YYYY-MM-DD\\" format. Returns: - int: Length of the longest streak of consecutive active days. Exceptions: - Raise ValueError if the date format is invalid. pass # Test cases def test_longest_active_streak(): assert longest_active_streak([\\"2022-12-01\\", \\"2022-12-02\\", \\"2022-12-03\\", \\"2022-12-07\\", \\"2022-12-08\\"]) == 3 assert longest_active_streak([\\"2023-01-01\\", \\"2023-01-02\\", \\"2023-01-04\\", \\"2023-01-05\\", \\"2023-01-06\\"]) == 3 assert longest_active_streak([\\"2023-03-01\\", \\"2022-08-01\\", \\"2022-08-02\\", \\"2022-08-03\\"]) == 3 assert longest_active_streak([\\"2022-11-15\\"]) == 1 def test_longest_active_streak_unsorted_dates(): assert longest_active_streak([\\"2022-12-03\\", \\"2022-12-01\\", \\"2022-12-02\\", \\"2022-12-08\\", \\"2022-12-07\\"]) == 3 def test_longest_active_streak_invalid_date_format(): try: longest_active_streak([\\"2022-12-01\\", \\"invalid-date\\", \\"2022-12-02\\"]) except ValueError as e: assert str(e) == \\"Invalid date format\\" else: assert False, \\"Expected ValueError to be raised\\" def test_longest_active_streak_empty_list(): try: longest_active_streak([]) except ValueError as e: assert str(e) == \\"The dates list is empty\\" else: assert False, \\"Expected ValueError to be raised\\" def test_longest_active_streak_single_date(): assert longest_active_streak([\\"2020-05-20\\"]) == 1 def test_longest_active_streak_multiple_gaps(): assert longest_active_streak([\\"2023-01-01\\", \\"2023-01-02\\", \\"2023-01-05\\", \\"2023-01-06\\", \\"2023-01-09\\", \\"2023-01-10\\", \\"2023-01-11\\"]) == 3","solution":"from datetime import datetime, timedelta from typing import List def longest_active_streak(dates: List[str]) -> int: Find the longest streak of consecutive days the user was active. Parameters: - dates (List[str]): List of strings representing active dates in \\"YYYY-MM-DD\\" format. Returns: - int: Length of the longest streak of consecutive active days. Exceptions: - Raise ValueError if the date format is invalid. if not dates: raise ValueError(\\"The dates list is empty\\") # Convert date strings to datetime objects and sort them try: dates = sorted(datetime.strptime(date, \\"%Y-%m-%d\\") for date in dates) except ValueError: raise ValueError(\\"Invalid date format\\") max_streak = 1 current_streak = 1 for i in range(1, len(dates)): if dates[i] - dates[i - 1] == timedelta(days=1): current_streak += 1 else: max_streak = max(max_streak, current_streak) current_streak = 1 max_streak = max(max_streak, current_streak) return max_streak"},{"question":"from typing import List def increase_brightness(image: List[List[int]], factor: float) -> List[List[int]]: Increases the brightness of a grayscale image by a given factor. :param image: List[List[int]] - 2D list of integers representing the grayscale image :param factor: float - Factor by which to increase the brightness :return: List[List[int]] - The brightened image as a 2D list pass def decrease_brightness(image: List[List[int]], factor: float) -> List[List[int]]: Decreases the brightness of a grayscale image by a given factor. :param image: List[List[int]] - 2D list of integers representing the grayscale image :param factor: float - Factor by which to decrease the brightness :return: List[List[int]] - The darkened image as a 2D list pass def test_increase_brightness(): image = [ [100, 120, 130], [140, 160, 180], [200, 220, 240] ] factor = 1.2 expected = [ [120, 144, 156], [168, 192, 216], [240, 255, 255] ] assert increase_brightness(image, factor) == expected def test_increase_brightness_max(): image = [ [210, 220, 230], [240, 250, 255] ] factor = 2.0 expected = [ [255, 255, 255], [255, 255, 255] ] assert increase_brightness(image, factor) == expected def test_decrease_brightness(): image = [ [100, 120, 130], [140, 160, 180], [200, 220, 240] ] factor = 0.8 expected = [ [80, 96, 104], [112, 128, 144], [160, 176, 192] ] assert decrease_brightness(image, factor) == expected def test_decrease_brightness_min(): image = [ [10, 20, 30], [40, 50, 60] ] factor = 0.1 expected = [ [1, 2, 3], [4, 5, 6] ] assert decrease_brightness(image, factor) == expected def test_decrease_brightness_to_zero(): image = [ [10, 20, 30], [40, 50, 60] ] factor = 0.0 expected = [ [0, 0, 0], [0, 0, 0] ] assert decrease_brightness(image, factor) == expected","solution":"def increase_brightness(image, factor): Increases the brightness of a grayscale image by a given factor. :param image: List[List[int]] - 2D list of integers representing the grayscale image :param factor: float - Factor by which to increase the brightness :return: List[List[int]] - The brightened image as a 2D list brightened_image = [] for row in image: brightened_row = [min(255, round(pixel * factor)) for pixel in row] brightened_image.append(brightened_row) return brightened_image def decrease_brightness(image, factor): Decreases the brightness of a grayscale image by a given factor. :param image: List[List[int]] - 2D list of integers representing the grayscale image :param factor: float - Factor by which to decrease the brightness :return: List[List[int]] - The darkened image as a 2D list darkened_image = [] for row in image: darkened_row = [max(0, round(pixel * factor)) for pixel in row] darkened_image.append(darkened_row) return darkened_image"},{"question":"import math from collections import Counter def compute_statistics(data: list[int]) -> dict: Compute various statistical values from a list of integers. Parameters: - data (list[int]): A list of integers. Returns: - dict: Dictionary containing the computed statistics. >>> compute_statistics([1, 2, 2, 3, 4, 5, 5, 5, 6]) { \\"mean\\": 3.67, \\"median\\": 4.0, \\"mode\\": [5], \\"range\\": 5, \\"standard_deviation\\": 1.67 } >>> compute_statistics([1, 3, 5, 7]) { \\"mean\\": 4, \\"median\\": 4.0, \\"mode\\": [1, 3, 5, 7], \\"range\\": 6, \\"standard_deviation\\": 2.24 } def test_single_element(): data = [5] result = compute_statistics(data) assert result == { \\"mean\\": 5, \\"median\\": 5, \\"mode\\": [5], \\"range\\": 0, \\"standard_deviation\\": 0.0 } def test_even_number_of_elements(): data = [1, 3, 5, 7] result = compute_statistics(data) assert result == { \\"mean\\": 4, \\"median\\": 4.0, \\"mode\\": [1, 3, 5, 7], \\"range\\": 6, \\"standard_deviation\\": 2.24 } def test_odd_number_of_elements(): data = [1, 2, 3, 4, 5] result = compute_statistics(data) assert result == { \\"mean\\": 3.0, \\"median\\": 3, \\"mode\\": [1, 2, 3, 4, 5], \\"range\\": 4, \\"standard_deviation\\": 1.41 } def test_mode_with_multiple_modes(): data = [1, 2, 2, 3, 3] result = compute_statistics(data) assert result == { \\"mean\\": 2.2, \\"median\\": 2, \\"mode\\": [2, 3], \\"range\\": 2, \\"standard_deviation\\": 0.75 } def test_large_dataset(): data = list(range(1, 1000001)) # From 1 to 1,000,000 result = compute_statistics(data) assert result == { \\"mean\\": 500000.5, \\"median\\": 500000.5, \\"mode\\": list(range(1, 1000001)), \\"range\\": 999999, \\"standard_deviation\\": 288675.13 }","solution":"import math from collections import Counter def compute_statistics(data): Compute various statistical values from a list of integers. Parameters: - data (list[int]): A list of integers. Returns: - dict: Dictionary containing the computed statistics. if not data: return {} n = len(data) # Mean mean = round(sum(data) / n, 2) # Median sorted_data = sorted(data) mid = n // 2 if n % 2 == 0: median = (sorted_data[mid - 1] + sorted_data[mid]) / 2 else: median = sorted_data[mid] # Mode counter = Counter(data) max_freq = max(counter.values()) mode = sorted([k for k, v in counter.items() if v == max_freq]) # Range data_range = max(data) - min(data) # Standard Deviation variance = sum((x - mean) ** 2 for x in data) / n standard_deviation = round(math.sqrt(variance), 2) return { \\"mean\\": mean, \\"median\\": median, \\"mode\\": mode, \\"range\\": data_range, \\"standard_deviation\\": standard_deviation }"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a boolean expression containing 1 (true), 0 (false), &, |, !, and parentheses. >>> evaluate_expression(\\"1&0|1\\") 1 >>> evaluate_expression(\\"1&(0|0)\\") 0 >>> evaluate_expression(\\"!(1|0)&1\\") 0 >>> evaluate_expression(\\"!1|1\\") 1 pass def test_simple_and_or(): assert evaluate_expression(\\"1&0|1\\") == 1 assert evaluate_expression(\\"1&1|0\\") == 1 assert evaluate_expression(\\"1&0|0\\") == 0 assert evaluate_expression(\\"0|0|1\\") == 1 def test_parentheses(): assert evaluate_expression(\\"1&(0|1)\\") == 1 assert evaluate_expression(\\"(1|0)&(0|1)\\") == 1 assert evaluate_expression(\\"1&(0|0)\\") == 0 assert evaluate_expression(\\"(0|0)&1\\") == 0 def test_not_operator(): assert evaluate_expression(\\"!1\\") == 0 assert evaluate_expression(\\"!0\\") == 1 assert evaluate_expression(\\"!(1&0)\\") == 1 assert evaluate_expression(\\"!(1|1)\\") == 0 def test_complex_expressions(): assert evaluate_expression(\\"!(1|0)&1\\") == 0 assert evaluate_expression(\\"1&!(1|0)\\") == 0 assert evaluate_expression(\\"!1|1\\") == 1 assert evaluate_expression(\\"(0&1)|(1&0)\\") == 0 def test_long_expression(): assert evaluate_expression(\\"1&1&1|0&0&0|1\\") == 1 assert evaluate_expression(\\"1&(1|0)&(1&1)&(0|1)\\") == 1 assert evaluate_expression(\\"(1&1&1)|0|(0&0&0)\\") == 1 assert evaluate_expression(\\"((1|0)|!(1&0)&1)|0\\") == 1","solution":"def evaluate_expression(expression: str) -> int: def eval_not(val): return 1 if val == 0 else 0 def eval_and(val1, val2): return val1 & val2 def eval_or(val1, val2): return val1 | val2 def compute(operators, values): operator = operators.pop() if operator == '!': value = values.pop() values.append(eval_not(value)) else: right = values.pop() left = values.pop() if operator == '&': values.append(eval_and(left, right)) elif operator == '|': values.append(eval_or(left, right)) precedence = {'!': 3, '&': 2, '|': 1} operators = [] values = [] i = 0 while i < len(expression): if expression[i] == '1': values.append(1) elif expression[i] == '0': values.append(0) elif expression[i] in precedence: while (operators and operators[-1] != '(' and precedence[operators[-1]] >= precedence[expression[i]]): compute(operators, values) operators.append(expression[i]) elif expression[i] == '(': operators.append('(') elif expression[i] == ')': while operators[-1] != '(': compute(operators, values) operators.pop() # popping '(' i += 1 while operators: compute(operators, values) return values[0]"},{"question":"import random RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace'] SUITS = ['Hearts', 'Diamonds', 'Clubs', 'Spades'] def initialize_deck(): Initialize and return a shuffled 52-card deck. deck = [{'rank': rank, 'suit': suit} for suit in SUITS for rank in RANKS] random.shuffle(deck) return deck def card_value(card): Return the value of a card for comparison. return RANKS.index(card['rank']) def display_card(card): Return a string representation of a card. return f\\"{card['rank']} of {card['suit']}\\" def play_high_low_game(): Play the High-Low card game where the player guesses if the next card will be higher or lower. The game continues until the deck is empty or the player decides to stop. Example: Current card: 7 of Hearts Will the next card be higher or lower? (h/l): h Next card: Jack of Clubs Your guess was correct! Current score: 1 Would you like to continue playing? (y/n): y pass","solution":"import random # Initialize rank and suits RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace'] SUITS = ['Hearts', 'Diamonds', 'Clubs', 'Spades'] def initialize_deck(): Initialize and return a shuffled 52-card deck. deck = [{'rank': rank, 'suit': suit} for suit in SUITS for rank in RANKS] random.shuffle(deck) return deck def card_value(card): Return the value of a card for comparison. return RANKS.index(card['rank']) def display_card(card): Return a string representation of a card. return f\\"{card['rank']} of {card['suit']}\\" def play_high_low_game(): Main function to play the High-Low card game. deck = initialize_deck() score = 0 # Draw the first card current_card = deck.pop() while True: print(f\\"Current card: {display_card(current_card)}\\") # Get player guess guess = input(\\"Will the next card be higher or lower? (h/l): \\").strip().lower() while guess not in ['h', 'l']: print(\\"Invalid input. Please enter 'h' for higher or 'l' for lower.\\") guess = input(\\"Will the next card be higher or lower? (h/l): \\").strip().lower() # Draw the next card if not deck: print(\\"The deck is empty. The game is over.\\") break next_card = deck.pop() print(f\\"Next card: {display_card(next_card)}\\") # Compare cards if (guess == 'h' and card_value(next_card) > card_value(current_card)) or (guess == 'l' and card_value(next_card) < card_value(current_card)): print(\\"Your guess was correct!\\") score += 1 else: print(\\"Your guess was incorrect.\\") print(f\\"Current score: {score}\\") # Check if player wants to continue continue_playing = input(\\"Would you like to continue playing? (y/n): \\").strip().lower() while continue_playing not in ['y', 'n']: print(\\"Invalid input. Please enter 'y' to continue or 'n' to stop.\\") continue_playing = input(\\"Would you like to continue playing? (y/n): \\").strip().lower() if continue_playing == 'n': break current_card = next_card print(f\\"Final score: {score}\\")"},{"question":"def max_subarray_sum(changes: list) -> int: This function returns the maximum possible sum of any contiguous subarray. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1","solution":"def max_subarray_sum(changes): Returns the maximum possible sum of any contiguous subarray. max_ending_here = max_so_far = changes[0] for x in changes[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: Determine which words from the list match the given pattern. >>> find_and_replace_pattern([\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"], \\"abb\\") [\\"mee\\", \\"aqq\\"] >>> find_and_replace_pattern([\\"xyz\\"], \\"abc\\") [\\"xyz\\"] >>> find_and_replace_pattern([\\"aa\\", \\"bb\\", \\"cc\\"], \\"ab\\") [] >>> find_and_replace_pattern([\\"abc\\", \\"def\\", \\"ghi\\"], \\"xyz\\") [\\"abc\\", \\"def\\", \\"ghi\\"] >>> find_and_replace_pattern([], \\"any\\") [] >>> find_and_replace_pattern([\\"abc\\"], \\"abcdefg\\") [] import pytest from solution import find_and_replace_pattern def test_find_and_replace_pattern_basic(): words = [\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"] pattern = \\"abb\\" assert find_and_replace_pattern(words, pattern) == [\\"mee\\", \\"aqq\\"] def test_find_and_replace_pattern_single_word(): words = [\\"xyz\\"] pattern = \\"abc\\" assert find_and_replace_pattern(words, pattern) == [\\"xyz\\"] def test_find_and_replace_pattern_no_match(): words = [\\"aa\\", \\"bb\\", \\"cc\\"] pattern = \\"ab\\" assert find_and_replace_pattern(words, pattern) == [] def test_find_and_replace_pattern_all_match(): words = [\\"abc\\", \\"def\\", \\"ghi\\"] pattern = \\"xyz\\" assert find_and_replace_pattern(words, pattern) == [\\"abc\\", \\"def\\", \\"ghi\\"] def test_find_and_replace_pattern_empty_list(): words = [] pattern = \\"any\\" assert find_and_replace_pattern(words, pattern) == [] def test_find_and_replace_pattern_different_pattern_lengths(): words = [\\"abc\\"] pattern = \\"abcdefg\\" assert find_and_replace_pattern(words, pattern) == [] # Run the tests pytest.main(args=['-v'])","solution":"def find_and_replace_pattern(words, pattern): def normalize(word): mapping = {} normalized_word = [] next_char = 'a' for char in word: if char not in mapping: mapping[char] = next_char next_char = chr(ord(next_char) + 1) normalized_word.append(mapping[char]) return ''.join(normalized_word) normalized_pattern = normalize(pattern) return [word for word in words if normalize(word) == normalized_pattern]"},{"question":"import re class TextEditor: def __init__(self, text: str): self.text = text def find_longest_word(self) -> str: Find the longest word within the text. Ignore punctuation when determining the longest word. >>> te = TextEditor(\\"This is a sample text, with several words. Longestword should be here.\\") >>> te.find_longest_word() \\"Longestword\\" def replace_word(self, old_word: str, new_word: str) -> None: Replace all occurrences of old_word with new_word within the text. Ensure whole words are matched and replaced, case-sensitive. >>> te = TextEditor(\\"This is a simple text for testing.\\") >>> te.replace_word(\\"simple\\", \\"complex\\") >>> te.text \\"This is a complex text for testing.\\"","solution":"import re class TextEditor: def __init__(self, text): self.text = text def find_longest_word(self) -> str: words = re.findall(r'bw+b', self.text) longest_word = max(words, key=len) return longest_word def replace_word(self, old_word: str, new_word: str) -> None: pattern = re.compile(rf'b{re.escape(old_word)}b') self.text = pattern.sub(new_word, self.text) # Example Usage # te = TextEditor(\\"This is a sample text, with several words. Longestword should be here.\\") # print(te.find_longest_word()) # Outputs: 'Longestword' # te.replace_word(\\"sample\\", \\"example\\") # print(te.text) # Outputs: 'This is a example text, with several words. Longestword should be here.'"},{"question":"import numpy as np class ParametricReLU: Parametric ReLU activation function for a neural network. Attributes: alpha (float): Slope for negative part of the activation function, initialized as a learnable parameter. Methods: __init__(self, alpha=0.1): Initialize with optional alpha value. forward(self, X): Forward pass of the PReLU activation. backward(self, X, dout): Backward pass for gradient computation. def __init__(self, alpha=0.1): Initialize the PReLU object with the slope \`alpha\` (default: 0.1). self.alpha = alpha def forward(self, X): Compute the forward pass through the PReLU activation function. Parameters: X (np.ndarray): Input array of shape \`(batch_size, num_features)\`. Returns: np.ndarray: Activated values, same shape as X. def backward(self, X, dout): Compute the backward pass through the PReLU activation. Parameters: X (np.ndarray): Input array of shape \`(batch_size, num_features)\`. dout (np.ndarray): Gradient of the loss with respect to the output of this layer, of shape \`(batch_size, num_features)\`. Returns: tuple: (dX, dalpha) dX (np.ndarray): Gradient of the loss with respect to the input \`X\`, of the same shape as \`X\`. dalpha (float): Gradient of the loss with respect to the parameter \`alpha\`.","solution":"import numpy as np class ParametricReLU: def __init__(self, alpha=0.1): Initialize the PReLU object with the slope \`alpha\` (default: 0.1). self.alpha = alpha def forward(self, X): Compute the forward pass through the PReLU activation function. Parameters: X (np.ndarray): Input array of shape \`(batch_size, num_features)\`. Returns: np.ndarray: Activated values, same shape as X. self.input = X output = np.maximum(self.alpha * X, X) return output def backward(self, X, dout): Compute the backward pass through the PReLU activation. Parameters: X (np.ndarray): Input array of shape \`(batch_size, num_features)\`. dout (np.ndarray): Gradient of the loss with respect to the output of this layer, of shape \`(batch_size, num_features)\`. Returns: tuple: (dX, dalpha) dX (np.ndarray): Gradient of the loss with respect to the input \`X\`, of the same shape as \`X\`. dalpha (float): Gradient of the loss with respect to the parameter \`alpha\`. dX = np.where(X > 0, 1, self.alpha) * dout dalpha = np.sum(np.where(X <= 0, X, 0) * dout) return dX, dalpha"},{"question":"from typing import List def maxProfit(prices: List[int]) -> int: Computes the maximum profit possible with multiple transactions. >>> maxProfit([1, 2, 3, 4, 5]) 4 >>> maxProfit([7, 1, 5, 3, 6, 4]) 7 >>> maxProfit([7, 6, 4, 3, 1]) 0 >>> maxProfit([]) 0","solution":"from typing import List def maxProfit(prices: List[int]) -> int: Computes the maximum profit possible with multiple transactions. :param prices: List of stock prices on consecutive days :return: Maximum profit if not prices: return 0 max_profit = 0 # Loop through the list and sum up the profit of all increasing sequences for i in range(1, len(prices)): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"from typing import List, Tuple def max_non_overlapping_sessions(sessions: List[Tuple[int, int]]) -> int: Determine the maximum number of non-overlapping sessions that can be attended given a list of session time intervals. >>> max_non_overlapping_sessions([(1, 3), (2, 4), (3, 5)]) 2 >>> max_non_overlapping_sessions([(1, 2), (2, 3), (3, 4), (1, 10)]) 3 >>> max_non_overlapping_sessions([(1, 3), (4, 6), (5, 8), (7, 9)]) 3 >>> max_non_overlapping_sessions([(1, 2), (3, 4), (0, 6), (5, 7), (8, 9), (5, 9)]) 4 >>> max_non_overlapping_sessions([]) 0 >>> max_non_overlapping_sessions([(1, 2), (2, 3), (3, 4)]) 3 >>> max_non_overlapping_sessions([(1, 5), (2, 6), (3, 7)]) 1 >>> max_non_overlapping_sessions([(1, 5)]) 1 >>> max_non_overlapping_sessions([(1, 5), (5, 10)]) 2 pass","solution":"from typing import List, Tuple def max_non_overlapping_sessions(sessions: List[Tuple[int, int]]) -> int: # Sort the sessions by their ending times sessions.sort(key=lambda x: x[1]) # Initialize the last end time and count last_end_time = float('-inf') count = 0 for start, end in sessions: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def sql_query_for_country_orders(country: str) -> str: Returns the SQL query to fetch customer order details for all customers from a given country. :param country: The country to filter customers by. :return: The SQL query string. >>> sql_query_for_country_orders(\\"USA\\")","solution":"def sql_query_for_country_orders(country): Returns the SQL query to fetch customer order details for all customers from a given country. query = f SELECT Customers.CustomerName, Orders.OrderDate, OrderDetails.ProductID, OrderDetails.Quantity FROM Customers JOIN Orders ON Customers.CustomerID = Orders.CustomerID JOIN OrderDetails ON Orders.OrderID = OrderDetails.OrderID WHERE Customers.Country = '{country}' ORDER BY Orders.OrderDate DESC; return query"},{"question":"class Node: def __init__(self, key=None, value=None): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity): self.capacity = capacity self.cache = {} self.head = Node() self.tail = Node() self.head.next = self.tail self.tail.prev = self.head def get(self, key): Retrieve the value associated with the key if it exists; return -1 otherwise. >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) 1 >>> cache.get(3) -1 pass def put(self, key, value): Insert or update the value with the associated key. If the cache exceeds the capacity, evict the least recently accessed item. >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.put(1, 10) >>> cache.get(1) 10 pass @property def cache_contents(self): Return the current state of the cache as a dictionary. >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.cache_contents {1: 1, 2: 2} pass","solution":"class Node: def __init__(self, key=None, value=None): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity): self.capacity = capacity self.cache = {} self.head = Node() self.tail = Node() self.head.next = self.tail self.tail.prev = self.head def _remove(self, node): prev = node.prev nxt = node.next prev.next = nxt nxt.prev = prev def _add(self, node): prev = self.tail.prev prev.next = node self.tail.prev = node node.prev = prev node.next = self.tail def get(self, key): if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key, value): if key in self.cache: node = self.cache[key] self._remove(node) elif len(self.cache) == self.capacity: node = self.head.next self._remove(node) del self.cache[node.key] node = Node(key, value) self.cache[key] = node self._add(node) @property def cache_contents(self): contents = {} current = self.head.next while current != self.tail: contents[current.key] = current.value current = current.next return contents"},{"question":"def max_sum_non_adjacent(arr: list) -> int: Returns the maximum sum of non-adjacent elements in the given array. >>> max_sum_non_adjacent([3, 2, 5, 10, 7]) 15 >>> max_sum_non_adjacent([3, 2, 7, 10]) 13 >>> max_sum_non_adjacent([5, 5, 10, 100, 10, 5]) 110 >>> max_sum_non_adjacent([0, 0, 0]) 0 >>> max_sum_non_adjacent([]) 0 >>> max_sum_non_adjacent([7]) 7 >>> max_sum_non_adjacent([-1, -2, -3, -4]) 0 >>> max_sum_non_adjacent([2, 4, 6, 2, 5]) 13","solution":"def max_sum_non_adjacent(arr): if not arr: return 0 if len(arr) == 1: return max(0, arr[0]) include = 0 exclude = 0 for num in arr: new_exclude = max(include, exclude) include = exclude + num exclude = new_exclude return max(include, exclude)"},{"question":"from typing import List from collections import defaultdict class DAGraph: A class used to represent a Directed Acyclic Graph (DAG) Methods ------- __init__(self, n: int): Initializes the graph with \`n\` vertices (0 to n-1). add_edge(self, from_vertex: int, to_vertex: int): Adds a directed edge from \`from_vertex\` to \`to_vertex\`. topological_sort(self) -> List[int]: Performs a topological sort of the vertices and returns the sorted list of vertices. If the graph contains a cycle, raises a \`ValueError\`. def __init__(self, n: int): Initialize the DAG with n vertices. pass def add_edge(self, from_vertex: int, to_vertex: int): Add a directed edge from \`from_vertex\` to \`to_vertex\`. pass def topological_sort(self) -> List[int]: Perform a topological sort on the graph. Returns: List[int]: The list of vertices in topologically sorted order. Raises: ValueError: If the graph contains a cycle. >>> g = DAGraph(6) >>> g.add_edge(5, 2) >>> g.add_edge(5, 0) >>> g.add_edge(4, 0) >>> g.add_edge(4, 1) >>> g.add_edge(2, 3) >>> g.add_edge(3, 1) >>> g.topological_sort() [5, 4, 2, 3, 1, 0] pass # Example test cases using pytest import pytest def test_dagraph_initialization(): graph = DAGraph(5) assert graph.n == 5 assert graph.graph == defaultdict(list) def test_add_edge(): graph = DAGraph(3) graph.add_edge(0, 1) graph.add_edge(0, 2) graph.add_edge(1, 2) assert graph.graph == {0: [1, 2], 1: [2]} def test_topological_sort_simple(): graph = DAGraph(3) graph.add_edge(0, 1) graph.add_edge(1, 2) assert graph.topological_sort() == [0, 1, 2] def test_topological_sort_complex(): graph = DAGraph(6) graph.add_edge(5, 2) graph.add_edge(5, 0) graph.add_edge(4, 0) graph.add_edge(4, 1) graph.add_edge(2, 3) graph.add_edge(3, 1) result = graph.topological_sort() assert result == [5, 4, 2, 3, 1, 0] or result == [4, 5, 2, 0, 3, 1] def test_topological_sort_with_cycle(): graph = DAGraph(3) graph.add_edge(0, 1) graph.add_edge(1, 2) graph.add_edge(2, 0) with pytest.raises(ValueError, match=\\"The graph contains a cycle.\\"): graph.topological_sort() def test_topological_sort_no_edges(): graph = DAGraph(3) assert set(graph.topological_sort()) == {0, 1, 2} def test_topological_sort_independent_nodes(): graph = DAGraph(4) graph.add_edge(1, 0) graph.add_edge(2, 1) assert set(graph.topological_sort()) == set([2, 1, 0, 3]) # node 3 has no connections # Run the tests pytest.main([\\"-v\\"])","solution":"from collections import defaultdict, deque class DAGraph: def __init__(self, n): self.graph = defaultdict(list) self.n = n def add_edge(self, from_vertex, to_vertex): self.graph[from_vertex].append(to_vertex) def topological_sort(self): in_degree = [0] * self.n for node in self.graph: for adjacent in self.graph[node]: in_degree[adjacent] += 1 queue = deque([i for i in range(self.n) if in_degree[i] == 0]) sorted_list = [] while queue: vertex = queue.popleft() sorted_list.append(vertex) for neighbor in self.graph[vertex]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(sorted_list) == self.n: return sorted_list else: raise ValueError(\\"The graph contains a cycle.\\") # Example usage # g = DAGraph(6) # g.add_edge(5, 2) # g.add_edge(5, 0) # g.add_edge(4, 0) # g.add_edge(4, 1) # g.add_edge(2, 3) # g.add_edge(3, 1) # print(g.topological_sort()) # Expected valid output: [5, 4, 2, 3, 1, 0]"},{"question":"def generate_subsets(nums: list[int]) -> list[list[int]]: Generate all possible subsets of the given list of integers. Args: nums (list[int]): A list of distinct integers. Returns: list[list[int]]: A list of all possible subsets, where each subset is sorted in non-decreasing order. >>> generate_subsets([1]) [[], [1]] >>> generate_subsets([1, 2]) [[], [1], [2], [1, 2]] >>> generate_subsets([1, 2, 3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> generate_subsets([-1, -2, -3]) [[], [-3], [-2], [-1], [-3, -2], [-3, -1], [-2, -1], [-3, -2, -1]] >>> generate_subsets([-1, 0, 1]) [[], [-1], [0], [1], [-1, 0], [-1, 1], [0, 1], [-1, 0, 1]] >>> generate_subsets([1, 2, 3, 4]) [[], [1], [2], [3], [4], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4], [1, 2, 3, 4]]","solution":"from itertools import chain, combinations def generate_subsets(nums: list[int]) -> list[list[int]]: Generate all possible subsets of the given list of integers. Args: nums (list[int]): A list of distinct integers. Returns: list[list[int]]: A list of all possible subsets, where each subset is sorted in non-decreasing order. nums.sort() # Ensure the list is sorted subsets = list(chain.from_iterable(combinations(nums, r) for r in range(len(nums) + 1))) return [list(subset) for subset in subsets]"},{"question":"import statistics from typing import List, Union def find_most_stable_sensor(sensors_data: List[List[float]]) -> Union[int, ValueError]: Input Parameters: ----------------- sensors_data: List of lists, where each sublist contains float values representing sensor readings. Returns: -------- An integer representing the index (0-based) of the most stable sensor, i.e., the sensor with the smallest standard deviation in its readings. If the inputs are invalid (empty list or any empty sublist), raises a ValueError with an appropriate error message. Examples: --------- >>> find_most_stable_sensor([[2.3, 2.5, 2.7], [3.2, 3.5, 3.4], [1.2, 1.3, 1.1]]) 2 >>> find_most_stable_sensor([[2.1, 2.3], [], [1.5, 1.7]]) ValueError('Input Error: Each sensor must have at least one reading.') >>> find_most_stable_sensor([]) ValueError('Input Error: Sensor data cannot be empty.')","solution":"import statistics def find_most_stable_sensor(sensors_data): Input Parameters: ----------------- sensors_data: List of lists, where each sublist contains float values representing sensor readings. Returns: -------- An integer representing the index (0-based) of the most stable sensor, i.e., the sensor with the smallest standard deviation in its readings. If the inputs are invalid (empty list or any empty sublist), raises a ValueError with an appropriate error message. Examples: --------- >>> find_most_stable_sensor([[2.3, 2.5, 2.7], [3.2, 3.5, 3.4], [1.2, 1.3, 1.1]]) 2 >>> find_most_stable_sensor([[2.1, 2.3], [], [1.5, 1.7]]) ValueError('Input Error: Each sensor must have at least one reading.') >>> find_most_stable_sensor([]) ValueError('Input Error: Sensor data cannot be empty.') if not sensors_data: raise ValueError('Input Error: Sensor data cannot be empty.') min_std = float('inf') most_stable_sensor_idx = -1 for idx, readings in enumerate(sensors_data): if not readings: raise ValueError('Input Error: Each sensor must have at least one reading.') std_dev = statistics.stdev(readings) if std_dev < min_std: min_std = std_dev most_stable_sensor_idx = idx return most_stable_sensor_idx"},{"question":"from typing import List def shortest_transformation_sequence(beginWord: str, endWord: str, wordList: List[str]) -> int: Find the length of the shortest transformation sequence from a start word to an end word, given a dictionary of allowed intermediate words. Each transformed word must be in the dictionary, and only one letter can be changed at a time. The solution should follow a Breadth-First Search (BFS) approach. Parameters: beginWord (str): The starting word for the transformation. endWord (str): The target word for the transformation. wordList (List[str]): A list of strings representing the dictionary of words. Returns: int: The length of the shortest transformation sequence from beginWord to endWord, including both the begin and end words. If no such transformation sequence exists, return 0. Examples: >>> shortest_transformation_sequence(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 5 >>> shortest_transformation_sequence(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) 0 pass","solution":"from collections import deque from typing import List def shortest_transformation_sequence(beginWord: str, endWord: str, wordList: List[str]) -> int: if endWord not in wordList: return 0 wordList = set(wordList) queue = deque([(beginWord, 1)]) # Store current word and transformation count while queue: current_word, level = queue.popleft() if current_word == endWord: return level # Try changing each character of the current_word to every letter from 'a' to 'z' for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': if c == current_word[i]: continue # Skip same letter next_word = current_word[:i] + c + current_word[i+1:] if next_word in wordList: wordList.remove(next_word) queue.append((next_word, level + 1)) return 0 # If no transformation sequence is found"},{"question":"from typing import List, Tuple class BookInventory: Class to manage the inventory of books for an online bookstore. Methods: - add_book(title: str, quantity: int) -> None: Add a specified quantity of a book to the inventory. - sell_book(title: str, quantity: int) -> bool: Sell a specified quantity of a book from the inventory. - check_stock(title: str) -> int: Return the current stock of the specified book. - current_inventory() -> List[Tuple[str, int]]: Return a list of all books in the inventory and their quantities, sorted by book titles in alphabetical order. Usage: >>> inventory = BookInventory() >>> inventory.add_book(\\"The Great Gatsby\\", 3) >>> inventory.add_book(\\"1984\\", 5) >>> inventory.check_stock(\\"1984\\") 5 >>> inventory.sell_book(\\"1984\\", 2) True >>> inventory.check_stock(\\"1984\\") 3 >>> inventory.sell_book(\\"The Great Gatsby\\", 4) False >>> inventory.check_stock(\\"The Great Gatsby\\") 3 >>> inventory.add_book(\\"1984\\", 10) >>> inventory.check_stock(\\"1984\\") 13 >>> inventory.current_inventory() [('1984', 13), ('The Great Gatsby', 3)]","solution":"from typing import List, Tuple class BookInventory: def __init__(self): self.inventory = {} def add_book(self, title: str, quantity: int) -> None: if title in self.inventory: self.inventory[title] += quantity else: self.inventory[title] = quantity def sell_book(self, title: str, quantity: int) -> bool: if title not in self.inventory or self.inventory[title] < quantity: return False self.inventory[title] -= quantity if self.inventory[title] == 0: del self.inventory[title] return True def check_stock(self, title: str) -> int: return self.inventory.get(title, 0) def current_inventory(self) -> List[Tuple[str, int]]: return sorted(self.inventory.items())"},{"question":"class MinHeap: Implement a Min-Heap data structure with the following operations: - insert(key: int) -> None: Insert a new element into the heap. - extract_min() -> int: Remove and return the minimum element from the heap. - decrease_key(i: int, new_key: int) -> None: Update the value at index i to the new key. - heapify(arr: list[int]) -> None: Convert an arbitrary list into a valid Min-Heap. Example: >>> min_heap = MinHeap() >>> min_heap.insert(10) >>> min_heap.insert(5) >>> min_heap.insert(20) >>> min_heap.insert(2) >>> print(min_heap.extract_min()) # Output: 2 >>> min_heap.decrease_key(2, 1) >>> print(min_heap.extract_min()) # Output: 1 >>> arr = [10, 3, 15, 8, 2, 7] >>> min_heap.heapify(arr) >>> print(min_heap.extract_min()) # Output: 2 Unit Tests: from solution import MinHeap def test_insert_and_extract_min(): min_heap = MinHeap() min_heap.insert(10) min_heap.insert(5) min_heap.insert(20) min_heap.insert(2) assert min_heap.extract_min() == 2 assert min_heap.extract_min() == 5 assert min_heap.extract_min() == 10 assert min_heap.extract_min() == 20 def test_decrease_key(): min_heap = MinHeap() min_heap.insert(10) min_heap.insert(5) min_heap.insert(20) min_heap.insert(2) min_heap.extract_min() # removes 2 min_heap.decrease_key(2, 1) # Index 2 with value 20 -> 1 assert min_heap.extract_min() == 1 assert min_heap.extract_min() == 5 assert min_heap.extract_min() == 10 def test_heapify(): min_heap = MinHeap() arr = [10, 3, 15, 8, 2, 7] min_heap.heapify(arr) assert min_heap.extract_min() == 2 assert min_heap.extract_min() == 3 assert min_heap.extract_min() == 7 assert min_heap.extract_min() == 8 assert min_heap.extract_min() == 10 assert min_heap.extract_min() == 15 def test_empty_extract_min(): min_heap = MinHeap() try: min_heap.extract_min() except IndexError as e: assert str(e) == \\"Extracting from an empty heap\\" def test_invalid_decrease_key(): min_heap = MinHeap() min_heap.insert(10) try: min_heap.decrease_key(0, 15) # Invalid: new key > current key except ValueError as e: assert str(e) == \\"new_key should be smaller than the current key\\" def __init__(self): self.heap = [] def insert(self, key: int) -> None: pass def extract_min(self) -> int: pass def decrease_key(self, i: int, new_key: int) -> None: pass def heapify(self, arr: list[int]) -> None: pass","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, key: int) -> None: self.heap.append(key) self._sift_up(len(self.heap) - 1) def extract_min(self) -> int: if len(self.heap) == 0: raise IndexError(\\"Extracting from an empty heap\\") min_element = self.heap[0] if len(self.heap) > 1: self.heap[0] = self.heap.pop() self._sift_down(0) else: self.heap.pop() return min_element def decrease_key(self, i: int, new_key: int) -> None: if new_key > self.heap[i]: raise ValueError(\\"new_key should be smaller than the current key\\") self.heap[i] = new_key self._sift_up(i) def heapify(self, arr: list[int]) -> None: self.heap = arr[:] for i in range((len(self.heap) // 2) - 1, -1, -1): self._sift_down(i) def _sift_up(self, index): parent = (index - 1) // 2 while index > 0 and self.heap[index] < self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] index = parent parent = (index - 1) // 2 def _sift_down(self, index): smallest = index left = 2 * index + 1 right = 2 * index + 2 if left < len(self.heap) and self.heap[left] < self.heap[smallest]: smallest = left if right < len(self.heap) and self.heap[right] < self.heap[smallest]: smallest = right if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._sift_down(smallest)"},{"question":"from typing import List, Tuple def sort_students(students: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts the list of students in non-increasing order by their marks. If two students have the same marks, they are sorted alphabetically by name. Args: students (List[Tuple[str, int]]): A list of tuples where each tuple contains a student's name (string) and their marks (integer). Returns: List[Tuple[str, int]]: The sorted list of students. Examples: >>> sort_students([(\\"Alice\\", 88), (\\"Bob\\", 95), (\\"Charlie\\", 88)]) [('Bob', 95), ('Alice', 88), ('Charlie', 88)] >>> sort_students([(\\"Dave\\", 92), (\\"Eve\\", 85), (\\"Frank\\", 92), (\\"Grace\\", 70)]) [('Dave', 92), ('Frank', 92), ('Eve', 85), ('Grace', 70)]","solution":"from typing import List, Tuple def sort_students(students: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts the list of students in non-increasing order by their marks. If two students have the same marks, they are sorted alphabetically by name. Args: students (List[Tuple[str, int]]): A list of tuples where each tuple contains a student's name (string) and their marks (integer). Returns: List[Tuple[str, int]]: The sorted list of students. # Sort primarily by marks in descending order, and by name in ascending order return sorted(students, key=lambda x: (-x[1], x[0]))"},{"question":"def has_path(n: int, edges: List[Tuple[int, int]], start: int, end: int) -> bool: Determine if there exists a path between two nodes using Depth-First Search (DFS) algorithm. :param n: An integer representing the number of nodes. :param edges: A list of tuples (u, v), where 'u' is the starting node, and 'v' is the ending node of a directed edge. :param start: The starting node from which to search (integer). :param end: The ending node that we want to reach (integer). :return: A boolean value, True if there is a path from \`start\` to \`end\`, False otherwise. Example: >>> has_path(3, [(0, 1), (1, 2)], 0, 2) True >>> has_path(3, [(0, 1), (1, 2)], 1, 0) False pass from typing import List, Tuple def test_has_path_direct(): assert has_path(3, [(0, 1), (1, 2)], 0, 2) == True def test_has_path_reverse(): assert has_path(3, [(0, 1), (1, 2)], 1, 0) == False def test_has_path_self(): assert has_path(3, [(0, 1), (1, 2)], 2, 2) == True def test_has_path_no_edges(): assert has_path(3, [], 0, 2) == False def test_has_path_multiple_paths(): assert has_path(5, [(0, 1), (0, 2), (2, 3), (3, 4)], 0, 4) == True def test_has_path_no_path(): assert has_path(5, [(0, 1), (2, 3), (3, 4)], 0, 4) == False def test_has_path_disconnected_graph(): assert has_path(5, [(0, 1), (1, 0), (2, 3), (3, 2)], 0, 4) == False def test_has_path_indirect(): assert has_path(4, [(0, 1), (1, 2), (2, 3), (3, 0)], 0, 3) == True","solution":"def has_path(n, edges, start, end): Determine if there exists a path between two nodes using Depth-First Search (DFS) algorithm. :param n: An integer representing the number of nodes. :param edges: A list of tuples (u, v), where 'u' is the starting node, and 'v' is the ending node of a directed edge. :param start: The starting node from which to search (integer). :param end: The ending node that we want to reach (integer). :return: A boolean value, True if there is a path from \`start\` to \`end\`, False otherwise. graph = {i: [] for i in range(n)} for u, v in edges: graph[u].append(v) stack = [start] visited = set() while stack: node = stack.pop() if node == end: return True if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: stack.append(neighbor) return False"},{"question":"import random def simulate_weather(days: int, initial_state: str, transition_matrix: dict) -> dict: Simulates weather changes over a sequence of days based on transition probabilities. Parameters: days (int): The number of days to simulate (1 ≤ days ≤ 365). initial_state (str): The initial weather state (\\"sunny\\", \\"cloudy\\", or \\"rainy\\"). transition_matrix (dict): A dictionary representing the transition probabilities between states. Each key is a weather state (string) and each value is a dictionary with keys as possible next states (strings) and values as respective probabilities (floats). Returns: dict: A dictionary with the final counts of each weather state across the simulation period. {\\"sunny\\": <number of sunny days>, \\"cloudy\\": <number of cloudy days>, \\"rainy\\": <number of rainy days>} Example: >>> days = 30 >>> initial_state = \\"sunny\\" >>> transition_matrix = { ... \\"sunny\\": {\\"sunny\\": 0.8, \\"cloudy\\": 0.15, \\"rainy\\": 0.05}, ... \\"cloudy\\": {\\"sunny\\": 0.2, \\"cloudy\\": 0.6, \\"rainy\\": 0.2}, ... \\"rainy\\": {\\"sunny\\": 0.1, \\"cloudy\\": 0.4, \\"rainy\\": 0.5} ... } >>> result = simulate_weather(days, initial_state, transition_matrix) >>> print(result) {'sunny': X, 'cloudy': Y, 'rainy': Z} pass import pytest def test_simulate_weather_basic(): transition_matrix = { \\"sunny\\": {\\"sunny\\": 0.8, \\"cloudy\\": 0.15, \\"rainy\\": 0.05}, \\"cloudy\\": {\\"sunny\\": 0.2, \\"cloudy\\": 0.6, \\"rainy\\": 0.2}, \\"rainy\\": {\\"sunny\\": 0.1, \\"cloudy\\": 0.4, \\"rainy\\": 0.5} } days = 30 initial_state = \\"sunny\\" result = simulate_weather(days, initial_state, transition_matrix) total_days = sum(result.values()) assert total_days == days def test_simulate_weather_all_sunny(): transition_matrix = { \\"sunny\\": {\\"sunny\\": 1.0, \\"cloudy\\": 0.0, \\"rainy\\": 0.0}, \\"cloudy\\": {\\"sunny\\": 1.0, \\"cloudy\\": 0.0, \\"rainy\\": 0.0}, \\"rainy\\": {\\"sunny\\": 1.0, \\"cloudy\\": 0.0, \\"rainy\\": 0.0} } days = 30 initial_state = \\"sunny\\" result = simulate_weather(days, initial_state, transition_matrix) assert result['sunny'] == days assert result['cloudy'] == 0 assert result['rainy'] == 0 def test_simulate_weather_equal_probabilities(): transition_matrix = { \\"sunny\\": {\\"sunny\\": 1/3, \\"cloudy\\": 1/3, \\"rainy\\": 1/3}, \\"cloudy\\": {\\"sunny\\": 1/3, \\"cloudy\\": 1/3, \\"rainy\\": 1/3}, \\"rainy\\": {\\"sunny\\": 1/3, \\"cloudy\\": 1/3, \\"rainy\\": 1/3} } days = 30 initial_state = \\"sunny\\" result = simulate_weather(days, initial_state, transition_matrix) total_days = sum(result.values()) assert total_days == days # As it's random, we can't assert the exact values, so just verify sum def test_simulate_weather_single_day(): transition_matrix = { \\"sunny\\": {\\"sunny\\": 1.0, \\"cloudy\\": 0.0, \\"rainy\\": 0.0}, \\"cloudy\\": {\\"sunny\\": 1.0, \\"cloudy\\": 0.0, \\"rainy\\": 0.0}, \\"rainy\\": {\\"sunny\\": 1.0, \\"cloudy\\": 0.0, \\"rainy\\": 0.0} } days = 1 initial_state = \\"cloudy\\" result = simulate_weather(days, initial_state, transition_matrix) assert result['sunny'] == 0 assert result['cloudy'] == 1 assert result['rainy'] == 0","solution":"import random def simulate_weather(days: int, initial_state: str, transition_matrix: dict) -> dict: Simulates weather changes over a sequence of days based on transition probabilities. Parameters: days (int): The number of days to simulate (1 ≤ days ≤ 365). initial_state (str): The initial weather state (\\"sunny\\", \\"cloudy\\", or \\"rainy\\"). transition_matrix (dict): A dictionary representing the transition probabilities between states. Each key is a weather state (string) and each value is a dictionary with keys as possible next states (strings) and values as respective probabilities (floats). Returns: dict: A dictionary with the final counts of each weather state across the simulation period. {\\"sunny\\": <number of sunny days>, \\"cloudy\\": <number of cloudy days>, \\"rainy\\": <number of rainy days>} # Initialize counts for each weather state weather_counts = {\\"sunny\\": 0, \\"cloudy\\": 0, \\"rainy\\": 0} # Set the initial state current_state = initial_state weather_counts[current_state] += 1 # Simulate the weather changes over the given number of days for _ in range(1, days): next_state_probs = transition_matrix[current_state] next_state = random.choices( population=list(next_state_probs.keys()), weights=list(next_state_probs.values()) )[0] weather_counts[next_state] += 1 current_state = next_state return weather_counts"},{"question":"def is_steady_stock(stock: str) -> bool: Determines if the given stock is steady. A stock is considered \\"steady\\" if the relative order of both alphabets and digits remains consistent independently. Parameters: stock (str): The stock performance string consisting of alphanumeric characters. Returns: bool: True if the stock is steady, False otherwise. >>> is_steady_stock(\\"a1b2c3\\") True >>> is_steady_stock(\\"3a2b1c\\") False","solution":"def is_steady_stock(stock: str) -> bool: Determines if the given stock is steady. A stock is considered \\"steady\\" if the relative order of both alphabets and digits remains consistent. Parameters: stock (str): The stock performance string consisting of alphanumeric characters. Returns: bool: True if the stock is steady, False otherwise. alphabets = [] digits = [] for char in stock: if char.isalpha(): alphabets.append(char) elif char.isdigit(): digits.append(char) if alphabets != sorted(alphabets): return False if digits != sorted(digits): return False return True"},{"question":"import hashlib import re def register_user(users: dict, username: str, password: str) -> bool: Register a new user with a given username and password. Requirements: 1. Username should be a non-empty string containing only alphanumeric characters and underscores, with a length of 3 to 20 characters. 2. Password must be at least 8 characters long and contain at least one uppercase letter, one lowercase letter, one digit, and one special character from \`!@#%^&*()_+\`. 3. Check if the username already exists in the \`users\` dictionary. If the username and password meet the criteria and the username does not already exist, hash the password using SHA-256, add the username and hashed password to the \`users\` dictionary, and return \`True\`, otherwise return \`False\`. >>> users = {} >>> register_user(users, \\"new_user\\", \\"Password123!\\") True >>> register_user(users, \\"new_user\\", \\"Password456!\\") False >>> register_user(users, \\"user@\\", \\"Pass123!\\") False >>> register_user(users, \\"validuser\\", \\"password\\") False","solution":"import hashlib import re def register_user(users: dict, username: str, password: str) -> bool: # Validate username if not (3 <= len(username) <= 20) or not re.match(r'^w+', username): return False # Validate password if (len(password) < 8 or not re.search(r'[A-Z]', password) or not re.search(r'[a-z]', password) or not re.search(r'd', password) or not re.search(r'[!@#%^&*()_+]', password)): return False # Check if username already exists if username in users: return False # Hash the password hashed_password = hashlib.sha256(password.encode()).hexdigest() # Register new user users[username] = hashed_password return True"},{"question":"import os import shutil def organize_files_by_extension(directory_path: str) -> dict: Organize files in a given directory based on their file extensions, creating subdirectories for each type and moving the files accordingly. >>> organize_files_by_extension(\\"/my_directory\\") { \\"success\\": True, \\"data\\": \\"Files organized successfully.\\" } >>> organize_files_by_extension(\\"/empty_directory\\") { \\"success\\": True, \\"data\\": \\"No files to organize.\\" } >>> organize_files_by_extension(\\"/restricted_directory\\") { \\"success\\": False, \\"data\\": \\"Permission denied while accessing the directory.\\" }","solution":"import os import shutil def organize_files_by_extension(directory_path: str) -> dict: try: if not os.path.exists(directory_path): return { \\"success\\": False, \\"data\\": \\"Directory does not exist.\\" } files_moved = False for item in os.listdir(directory_path): item_path = os.path.join(directory_path, item) if os.path.isfile(item_path): files_moved = True _, extension = os.path.splitext(item) if extension: extension = extension[1:].lower() else: extension = \\"no_extension\\" target_dir = os.path.join(directory_path, extension) if not os.path.exists(target_dir): os.makedirs(target_dir) shutil.move(item_path, os.path.join(target_dir, item)) if files_moved: return { \\"success\\": True, \\"data\\": \\"Files organized successfully.\\" } else: return { \\"success\\": True, \\"data\\": \\"No files to organize.\\" } except PermissionError: return { \\"success\\": False, \\"data\\": \\"Permission denied while accessing the directory.\\" } except Exception as e: return { \\"success\\": False, \\"data\\": f\\"An error occurred: {str(e)}\\" }"},{"question":"def is_palindrome(s: str) -> bool: Determines if a given string is a palindrome. >>> is_palindrome(\\"racecar\\") == True >>> is_palindrome(\\"hello\\") == False >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") == True def longest_palindromic_substring(s: str) -> str: Finds the longest palindromic substring within the given string. >>> longest_palindromic_substring(\\"babad\\") == \\"bab\\" >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" >>> longest_palindromic_substring(\\"a\\") == \\"a\\" >>> longest_palindromic_substring(\\"\\") == \\"\\" >>> longest_palindromic_substring(\\"abc\\") == \\"a\\"","solution":"def is_palindrome(s: str) -> bool: Determines if a given string is a palindrome. # Remove non-alphanumeric characters and convert to lowercase filtered_chars = [c.lower() for c in s if c.isalnum()] return filtered_chars == filtered_chars[::-1] def longest_palindromic_substring(s: str) -> str: Finds the longest palindromic substring within the given string. n = len(s) if n == 0: return \\"\\" start = 0 max_length = 1 # Create a 2D array to keep track of palindromes dp = [[False] * n for _ in range(n)] # All substrings of length 1 are palindromes for i in range(n): dp[i][i] = True # Check for substrings of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if dp[i + 1][j - 1] and s[i] == s[j]: dp[i][j] = True if length > max_length: start = i max_length = length return s[start:start + max_length]"},{"question":"def replace_characters(S: str, rules: dict) -> str: Given a string S and a set of rules that define how certain characters can be replaced, return the resulting string after all possible replacements are applied iteratively until no more replacements can be made. >>> replace_characters(\\"abc\\", {\\"a\\": \\"b\\", \\"b\\": \\"c\\"}) == \\"ccc\\" >>> replace_characters(\\"abcdef\\", {\\"a\\": \\"b\\", \\"b\\": \\"c\\", \\"c\\": \\"d\\"}) == \\"ddddef\\" >>> replace_characters(\\"aaa\\", {\\"a\\": \\"b\\"}) == \\"bbb\\" >>> replace_characters(\\"xyz\\", {}) == \\"xyz\\" pass def test_replace_characters_basic(): assert replace_characters(\\"abc\\", {\\"a\\": \\"b\\", \\"b\\": \\"c\\"}) == \\"ccc\\" assert replace_characters(\\"abcdef\\", {\\"a\\": \\"b\\", \\"b\\": \\"c\\", \\"c\\": \\"d\\"}) == \\"ddddef\\" assert replace_characters(\\"aaa\\", {\\"a\\": \\"b\\"}) == \\"bbb\\" assert replace_characters(\\"xyz\\", {}) == \\"xyz\\" def test_replace_characters_no_replacements(): assert replace_characters(\\"abc\\", {}) == \\"abc\\" assert replace_characters(\\"xyz\\", {\\"a\\": \\"b\\", \\"c\\": \\"d\\"}) == \\"xyz\\" def test_replace_characters_partial_replacements(): assert replace_characters(\\"abcdef\\", {\\"a\\": \\"b\\", \\"c\\": \\"d\\"}) == \\"bbddef\\" assert replace_characters(\\"abcxyz\\", {\\"a\\": \\"b\\"}) == \\"bbcxyz\\" def test_replace_characters_invalid_input(): try: replace_characters(123, {\\"a\\": \\"b\\"}) except ValueError as e: assert str(e) == \\"Invalid input\\" try: replace_characters(\\"abc\\", [(\\"a\\", \\"b\\")]) except ValueError as e: assert str(e) == \\"Invalid input\\" try: replace_characters(\\"a\\"*1001, {\\"a\\": \\"b\\"}) except ValueError as e: assert str(e) == \\"Invalid input\\" try: replace_characters(\\"abc\\", {chr(i): chr(i+1) for i in range(97, 124)}) except ValueError as e: assert str(e) == \\"Invalid input\\" def test_replace_characters_edge_cases(): assert replace_characters(\\"a\\", {\\"a\\": \\"b\\"}) == \\"b\\" assert replace_characters(\\"a\\"*1000, {\\"a\\": \\"b\\"}) == \\"b\\"*1000","solution":"def replace_characters(S: str, rules: dict) -> str: if not isinstance(S, str) or not isinstance(rules, dict): raise ValueError(\\"Invalid input\\") if not (1 <= len(S) <= 1000) or len(rules) > 26: raise ValueError(\\"Invalid input\\") while True: new_S = ''.join(rules.get(char, char) for char in S) if new_S == S: break S = new_S return S"},{"question":"def deduplicate_transaction_ids(transaction_ids: list[int]) -> list[int]: Removes duplicate transaction IDs from the list while maintaining their order of first occurrences. >>> deduplicate_transaction_ids([1, 2, 3, 2, 1, 4, 5]) [1, 2, 3, 4, 5] >>> deduplicate_transaction_ids([5, 5, 5, 2, 3, 4, 2]) [5, 2, 3, 4] >>> deduplicate_transaction_ids([7, -1, 7, -1, 2]) [7, -1, 2]","solution":"def deduplicate_transaction_ids(transaction_ids): Removes duplicate transaction IDs from the list while maintaining their order of first occurrences. Args: transaction_ids (list[int]): A list of integers representing transaction IDs. Returns: list[int]: A list of integers with duplicates removed. seen = set() deduplicated_list = [] for transaction_id in transaction_ids: if transaction_id not in seen: seen.add(transaction_id) deduplicated_list.append(transaction_id) return deduplicated_list"},{"question":"def can_balance_parentheses(s: str, k: int) -> bool: Checks if a given string of parentheses can be balanced by performing at most k replacements. Args: s (str): The string consisting of '(' and ')' characters. k (int): The maximum number of replacements allowed. Returns: bool: True if the string can be balanced with at most k replacements, False otherwise. Examples: >>> can_balance_parentheses(\\"())(\\", 1) True >>> can_balance_parentheses(\\"()))(\\", 1) False >>> can_balance_parentheses(\\"(())\\", 0) True >>> can_balance_parentheses(\\"((())())\\", 0) True >>> can_balance_parentheses(\\"()())(()\\", 2) True >>> can_balance_parentheses(\\"))))(((\\", 2) False >>> can_balance_parentheses(\\"(((\\", 3) True >>> can_balance_parentheses(\\")))\\", 3) True >>> can_balance_parentheses(\\"\\", 0) True","solution":"def can_balance_parentheses(s: str, k: int) -> bool: Checks if the given string of parentheses can be balanced by performing at most k replacements. Args: s (str): The string consisting of '(' and ')' characters. k (int): The maximum number of replacements allowed. Returns: bool: True if the string can be balanced with at most k replacements, False otherwise. unbalanced_left = unbalanced_right = 0 # Check how many unmatched '(' and ')' we have for char in s: if char == '(': unbalanced_left += 1 elif char == ')': if unbalanced_left > 0: unbalanced_left -= 1 else: unbalanced_right += 1 # To balance the string, the total replacements needed is the maximum of unbalanced_left and unbalanced_right return max(unbalanced_left, unbalanced_right) <= k"},{"question":"def is_permutation(str1: str, str2: str) -> bool: Determines if one string is a permutation of another. >>> is_permutation(\\"abc\\", \\"bca\\") True >>> is_permutation(\\"abc\\", \\"def\\") False >>> is_permutation(\\"aabbcc\\", \\"abccba\\") True >>> is_permutation(\\"hello\\", \\"holle\\") True >>> is_permutation(\\"test\\", \\"best\\") False pass from collections import Counter def test_is_permutation_true_cases(): assert is_permutation(\\"abc\\", \\"bca\\") == True assert is_permutation(\\"aabbcc\\", \\"abccba\\") == True assert is_permutation(\\"hello\\", \\"holle\\") == True assert is_permutation(\\"123456\\", \\"654321\\") == True def test_is_permutation_false_cases(): assert is_permutation(\\"abc\\", \\"def\\") == False assert is_permutation(\\"abcd\\", \\"abcc\\") == False assert is_permutation(\\"hello\\", \\"helolp\\") == False assert is_permutation(\\"test\\", \\"best\\") == False def test_is_permutation_edge_cases(): assert is_permutation(\\"\\", \\"\\") == True assert is_permutation(\\"a\\", \\"a\\") == True assert is_permutation(\\"a\\", \\"\\") == False assert is_permutation(\\"\\", \\"a\\") == False def test_is_permutation_case_sensitivity(): assert is_permutation(\\"a\\", \\"A\\") == False assert is_permutation(\\"ABC\\", \\"abc\\") == False assert is_permutation(\\"AaBb\\", \\"bBaA\\") == True","solution":"def is_permutation(str1: str, str2: str) -> bool: Determine if two strings are permutations of each other. if len(str1) != len(str2): return False from collections import Counter return Counter(str1) == Counter(str2)"},{"question":"def is_rotated_version(s1: str, s2: str) -> bool: Determines if one string is a rotated version of another. :param s1: The original string. :param s2: The string to check as a rotated version. :return: True if s2 is a rotated version of s1, False otherwise. >>> is_rotated_version(\\"abcde\\", \\"cdeab\\") True >>> is_rotated_version(\\"abcde\\", \\"abced\\") False >>> is_rotated_version(\\"waterbottle\\", \\"erbottlewat\\") True >>> is_rotated_version(\\"\\", \\"\\") True >>> is_rotated_version(\\"a\\", \\"a\\") True >>> is_rotated_version(\\"a\\", \\"b\\") False","solution":"def is_rotated_version(s1: str, s2: str) -> bool: Determines if one string is a rotated version of another. if len(s1) != len(s2): return False combined = s1 + s1 return s2 in combined"},{"question":"def is_palindrome(s: str) -> bool: This function checks if the given string is a palindrome, ignoring non-alphabetical characters and cases. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"race a car\\") == False >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"aa\\") == True >>> is_palindrome(\\"Noon\\") == True >>> is_palindrome(\\"!!!@@@#\\") == True >>> is_palindrome(\\"MadamInEdenImAdam\\") == True >>> is_palindrome(\\"Hello, World!\\") == False","solution":"def is_palindrome(s: str) -> bool: This function checks if the given string is a palindrome, ignoring non-alphabetical characters and cases. # Filter out non-alphabetical characters and convert to lowercase filtered_chars = [c.lower() for c in s if c.isalpha()] # Check if the filtered list is a palindrome return filtered_chars == filtered_chars[::-1]"},{"question":"def longest_increasing_subsequence(nums: list) -> int: You need to implement an efficient algorithm to find the length of the longest increasing subsequence in a given list of integers. Use memoization to avoid redundant calculations and achieve optimal performance. :param nums: List of integers representing data points. :return: Length of the longest increasing subsequence. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1 pass def test_longest_increasing_subsequence(): assert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 assert longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4 assert longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) == 1 assert longest_increasing_subsequence([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6 assert longest_increasing_subsequence([]) == 0 assert longest_increasing_subsequence([1]) == 1 assert longest_increasing_subsequence([2, 2, 2, 2]) == 1 assert longest_increasing_subsequence([1, 2, 3, 4, 5]) == 5 assert longest_increasing_subsequence([5, 4, 3, 2, 1]) == 1 assert longest_increasing_subsequence([2, 5, 1, 8, 3, 6, 7, 9]) == 5 if __name__ == \\"__main__\\": test_longest_increasing_subsequence()","solution":"def longest_increasing_subsequence(nums): Returns the length of the longest increasing subsequence in a list of integers. if not nums: return 0 n = len(nums) memo = [1] * n # Initialize memo table with 1, as each element is an LIS of length 1 for i in range(1, n): for j in range(i): if nums[i] > nums[j]: memo[i] = max(memo[i], memo[j] + 1) return max(memo)"},{"question":"def convert_coordinates(ra: float, dec: float, lat: float, lon: float, timestamp: int) -> tuple: Converts right ascension and declination into Altitude and Azimuth. Parameters: ra (float): Right ascension in degrees. dec (float): Declination in degrees. lat (float): Observer's latitude in degrees. Must be between -90 and 90 degrees. lon (float): Observer's longitude in degrees. Must be between -180 and 180 degrees. timestamp (int): Unix timestamp in seconds. Returns: tuple: (altitude, azimuth) in degrees. Raises: ValueError: If latitude is not between -90 and 90 degrees or longitude is not between -180 and 180 degrees. >>> convert_coordinates(180.0, 45.0, 52.5, 13.4, 1609459200) (30.0, 60.0) >>> convert_coordinates(90.0, -30.0, -33.9, 151.2, 1609455600) (-10.0, 150.0) >>> convert_coordinates(225.0, 88.0, 45.0, -93.0, 1609452000) (75.0, 210.0) >>> convert_coordinates(180.0, 45.0, 120.0, 13.4, 1609459200) ValueError: Invalid latitude. >>> convert_coordinates(180.0, 45.0, 52.5, 200.0, 1609459200) ValueError: Invalid longitude. pass","solution":"import math from datetime import datetime, timezone import numpy as np def convert_coordinates(ra: float, dec: float, lat: float, lon: float, timestamp: int) -> tuple: Converts right ascension and declination into Altitude and Azimuth. Parameters: ra (float): Right ascension in degrees. dec (float): Declination in degrees. lat (float): Observer's latitude in degrees. lon (float): Observer's longitude in degrees. timestamp (int): Unix timestamp in seconds. Returns: tuple: (altitude, azimuth) in degrees. if not (-90 <= lat <= 90): raise ValueError(\\"Invalid latitude. Must be between -90 and 90 degrees.\\") if not (-180 <= lon <= 180): raise ValueError(\\"Invalid longitude. Must be between -180 and 180 degrees.\\") # Convert RA and Dec to radians ra_rad = math.radians(ra) dec_rad = math.radians(dec) lat_rad = math.radians(lat) lon_rad = math.radians(lon) # Convert timestamp to datetime and then calculate the Greenwich Mean Sidereal Time (GMST) utc_time = datetime.fromtimestamp(timestamp, timezone.utc) jd = 367 * utc_time.year - (7 * (utc_time.year + (utc_time.month + 9) // 12)) // 4 + (275 * utc_time.month) // 9 + utc_time.day + 1721013.5 + (utc_time.hour + utc_time.minute / 60 + utc_time.second / 3600) / 24 T = (jd - 2451545.0) / 36525 GMST = 280.46061837 + 360.98564736629 * (jd - 2451545) + 0.000387933 * T**2 - T**3 / 38710000 GMST = math.radians(GMST % 360) # Calculate Local Sidereal Time (LST) LST = GMST + lon_rad LST = LST % (2 * math.pi) # Normalize the LST # Convert RA to Hour Angle (HA) HA = LST - ra_rad HA = HA % (2 * math.pi) # Normalize the HA # Perform the conversion from equatorial to horizontal coordinates sin_alt = math.sin(dec_rad) * math.sin(lat_rad) + math.cos(dec_rad) * math.cos(lat_rad) * math.cos(HA) altitude = math.degrees(math.asin(sin_alt)) cos_az = (math.sin(dec_rad) - math.sin(math.radians(altitude)) * math.sin(lat_rad)) / (math.cos(math.radians(altitude)) * math.cos(lat_rad)) # Check for edge cases where the arccos might not work properly due to floating point arithmetic issues. if cos_az > 1: cos_az = 1 elif cos_az < -1: cos_az = -1 azimuth = math.degrees(math.acos(cos_az)) if math.sin(HA) > 0: azimuth = 360 - azimuth return (altitude, azimuth)"},{"question":"def maximal_bipartite_matching(N: int, M: int, edges: list[tuple[int, int]]) -> int: Compute the maximum number of matching pairs in a bipartite graph such that no two edges share the same node. >>> maximal_bipartite_matching(3, 3, [(1, 1), (1, 2), (2, 2), (2, 3), (3, 3)]) 3 >>> maximal_bipartite_matching(3, 3, []) 0 >>> maximal_bipartite_matching(3, 3, [(1, 1)]) 1 >>> maximal_bipartite_matching(4, 4, [(1, 2), (2, 2), (3, 3), (4, 4), (1, 3)]) 3 >>> maximal_bipartite_matching(5, 5, [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (2, 1), (2, 3), (2, 4), (2, 5), (3, 1), (3, 2), (3, 4), (3, 5), (4, 1), (4, 2), (4, 3), (4, 5), (5, 1), (5, 2), (5, 3), (5, 4)]) 5","solution":"def maximal_bipartite_matching(N: int, M: int, edges: list[tuple[int, int]]) -> int: from collections import deque, defaultdict def bpm(u, matchR, seen): for v in adj[u]: if not seen[v]: seen[v] = True if matchR[v] == -1 or bpm(matchR[v], matchR, seen): matchR[v] = u return True return False adj = defaultdict(list) for u, v in edges: adj[u].append(v) matchR = [-1] * (M + 1) result = 0 for u in range(1, N + 1): seen = [False] * (M + 1) if bpm(u, matchR, seen): result += 1 return result"},{"question":"def decompress(src_path: str, dest_path: str) -> None: Decompresses the content of the file specified by src_path using Run-Length Encoding (RLE) and writes the decompressed content to the file specified by dest_path. >>> with open('test_compressed.rle', 'w') as f: ... f.write('a1b3c2d4e1') >>> decompress('test_compressed.rle', 'test_decompressed.txt') >>> with open('test_decompressed.txt', 'r') as f: ... content = f.read() >>> content == 'abbbccdddde' True","solution":"def decompress(src_path: str, dest_path: str) -> None: Decompresses the content of the file specified by src_path using Run-Length Encoding (RLE) and writes the decompressed content to the file specified by dest_path. with open(src_path, 'r') as f: compressed_content = f.read() decompressed_content = [] i = 0 while i < len(compressed_content): char = compressed_content[i] i += 1 count = '' while i < len(compressed_content) and compressed_content[i].isdigit(): count += compressed_content[i] i += 1 decompressed_content.append(char * int(count)) with open(dest_path, 'w') as f: f.write(''.join(decompressed_content))"},{"question":"import math def has_integer_square_root_sum(numbers: list) -> bool: Returns True if the sum of square roots of the elements in the list is an integer, False otherwise. Raises a TypeError if any element in the list is not an integer. >>> has_integer_square_root_sum([4, 16, 1]) True >>> has_integer_square_root_sum([2, 3, 5]) False >>> has_integer_square_root_sum([9, 16, 25]) True pass","solution":"import math def has_integer_square_root_sum(numbers: list) -> bool: Returns True if the sum of square roots of the elements in the list is an integer, False otherwise. Raises a TypeError if any element in the list is not an integer. if not all(isinstance(num, int) for num in numbers): raise TypeError(\\"All elements in the list must be integers\\") sum_of_roots = sum(math.sqrt(num) for num in numbers) return sum_of_roots.is_integer()"},{"question":"class FileSystem: Virtual file system that allows the creation, deletion, and navigation of directories and files. >>> fs = FileSystem() >>> fs.create_directory(\\"/home\\") >>> fs.create_directory(\\"/home/user\\") >>> fs.create_file(\\"/home/user/file1.txt\\", \\"Hello World\\") >>> print(fs.read_file(\\"/home/user/file1.txt\\")) # Output: \\"Hello World\\" >>> fs.create_file(\\"/home/user/file2.txt\\", \\"Another file\\") >>> fs.change_directory(\\"/home/user\\") >>> print(fs.list_directory()) # Output: [\\"file1.txt\\", \\"file2.txt\\"] >>> fs.delete_file(\\"/home/user/file1.txt\\") >>> print(fs.list_directory()) # Output: [\\"file2.txt\\"] >>> fs.delete_directory(\\"/home\\") >>> print(fs.list_directory(\\"/\\")) # Output: [] def __init__(self): Initialize an empty root directory. pass def create_directory(self, path: str): Create a directory at a specified path. pass def create_file(self, path: str, content: str): Create a file with a given name and content at a specified path. pass def read_file(self, path: str) -> str: Read the content of a file at a specified path. pass def delete_file(self, path: str): Delete a file at a specified path. pass def delete_directory(self, path: str): Delete a directory at a specified path. pass def change_directory(self, path: str): Change the current directory. pass def list_directory(self, path: str = None) -> list: List the contents of the current directory. pass","solution":"class FileSystem: def __init__(self): self.root = {'/': {}} self.current_directory = '/' def _get_element(self, path): elements = path.strip('/').split('/') current = self.root['/'] for element in elements: if element: current = current.get(element, None) if current is None: return None return current def create_directory(self, path): elements = path.strip('/').split('/') current = self.root['/'] for element in elements: if element not in current: current[element] = {} current = current[element] def create_file(self, path, content): *dirs, filename = path.strip('/').split('/') current = self.root['/'] for dir_ in dirs: if dir_ not in current: raise FileNotFoundError(f\\"Directory {dir_} does not exist.\\") current = current[dir_] if filename in current: raise FileExistsError(f\\"File {filename} already exists.\\") current[filename] = content def read_file(self, path): *dirs, filename = path.strip('/').split('/') current = self.root['/'] for dir_ in dirs: if dir_ not in current: raise FileNotFoundError(f\\"Directory {dir_} does not exist.\\") current = current[dir_] if filename not in current: raise FileNotFoundError(f\\"File {filename} does not exist.\\") return current[filename] def delete_file(self, path): *dirs, filename = path.strip('/').split('/') current = self.root['/'] for dir_ in dirs: if dir_ not in current: raise FileNotFoundError(f\\"Directory {dir_} does not exist.\\") current = current[dir_] if filename not in current: raise FileNotFoundError(f\\"File {filename} does not exist.\\") del current[filename] def delete_directory(self, path): elements = path.strip('/').split('/') current = self.root['/'] for element in elements[:-1]: current = current[element] del current[elements[-1]] def change_directory(self, path): if self._get_element(path) is None: raise FileNotFoundError(f\\"Directory {path} does not exist.\\") self.current_directory = path def list_directory(self, path=None): if path is None: path = self.current_directory current = self._get_element(path) if current is None: raise FileNotFoundError(f\\"Directory {path} does not exist.\\") return list(current.keys())"},{"question":"from typing import List def min_path_sum(matrix: List[List[int]]) -> int: Find the minimum path sum in a matrix from the top-left corner to the bottom-right corner. You can only move either down or right at any point in time. Args: matrix (List[List[int]]): A 2D list of non-negative integers representing the matrix. Returns: int: The minimum sum of values along a path from the top-left to the bottom-right corner. >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_path_sum([ ... [1, 2], ... [1, 1] ... ]) 3 >>> min_path_sum([ ... [1] ... ]) 1","solution":"from typing import List def min_path_sum(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 M, N = len(matrix), len(matrix[0]) # Initialize a 2D list for storing the minimum path sum at each cell dp = [[0] * N for _ in range(M)] # Set the value for the top-left cell dp[0][0] = matrix[0][0] # Fill the first row for j in range(1, N): dp[0][j] = dp[0][j - 1] + matrix[0][j] # Fill the first column for i in range(1, M): dp[i][0] = dp[i - 1][0] + matrix[i][0] # Fill the rest of the dp table for i in range(1, M): for j in range(1, N): dp[i][j] = matrix[i][j] + min(dp[i - 1][j], dp[i][j - 1]) # The bottom-right cell contains the minimum path sum return dp[M - 1][N - 1]"},{"question":"def max_single_sell_profit(profits: List[int]) -> int: Given a list of integers representing the profits from certain units sold, determine the maximum profit that can be achieved by buying at one low point and selling at a later high point. Returns the maximum possible profit that can be achieved by making a single buy-sell transaction. If no profit is possible, returns 0. >>> max_single_sell_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_single_sell_profit([7, 6, 4, 3, 1]) 0","solution":"def max_single_sell_profit(profits): Returns the maximum possible profit that can be achieved by making a single buy-sell transaction. If no profit is possible, returns 0. if not profits: return 0 min_price = profits[0] max_profit = 0 for price in profits: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"import numpy as np # Set minimum and maximum clamp values MIN_CLAMP = 1e-10 MAX_CLAMP = 1e10 class Variable: def __init__(self, values): self.values = np.array(values) def safe_exp(self): Compute the safe exponential of the variable's values, clamped to avoid overflow and underflow. >>> var = Variable([1.0, 2.0, 3.0]) >>> safe_var = var.safe_exp() >>> safe_var.values array([ 2.71828183, 7.3890561 , 20.08553692]) >>> var_large = Variable([1000.0, 2000.0]) >>> safe_var_large = var_large.safe_exp() >>> safe_var_large.values array([1.e+10, 1.e+10]) >>> var_small = Variable([-1000.0, -2000.0]) >>> safe_var_small = var_small.safe_exp() >>> safe_var_small.values array([1.e-10, 1.e-10]) class GradientTracker: def __enter__(self): # Initialize tracker return self def __exit__(self, exc_type, exc_value, traceback): # Cleanup tracker pass def gradient(self, b, a): A mock implementation for gradient computation. Assuming the gradient of e^x is e^x, modified to consider the clamping: >>> with GradientTracker() as tracker: ... var = Variable([1.0, 2.0, 3.0]) ... safe_var = var.safe_exp() ... gradient = tracker.gradient(safe_var, var) ... gradient.values array([ 2.71828183, 7.3890561 , 20.08553692]) return Variable(np.zeros_like(a.values)) # Placeholder implementation # Test cases for the Variable.safe_exp method def test_safe_exp_normal_values(): a = Variable([1.0, 2.0, 3.0]) b = a.safe_exp() np.testing.assert_allclose(b.values, np.exp([1.0, 2.0, 3.0]), rtol=1e-5) def test_safe_exp_large_values(): a = Variable([1000.0, 2000.0]) b = a.safe_exp() assert all(b.values == MAX_CLAMP) def test_safe_exp_small_values(): a = Variable([-1000.0, -2000.0]) b = a.safe_exp() assert all(b.values == MIN_CLAMP) def test_safe_exp_mixed_values(): a = Variable([-1000.0, 0.0, 1000.0]) b = a.safe_exp() np.testing.assert_array_equal(b.values, [MIN_CLAMP, np.exp(0.0), MAX_CLAMP])","solution":"import numpy as np # Set minimum and maximum clamp values MIN_CLAMP = 1e-10 MAX_CLAMP = 1e10 class Variable: def __init__(self, values): self.values = np.array(values) def safe_exp(self): Compute the safe exponential of the variable's values, clamped to avoid overflow and underflow. exp_values = np.exp(self.values) clamped_values = np.clip(exp_values, MIN_CLAMP, MAX_CLAMP) return Variable(clamped_values) class GradientTracker: def __enter__(self): # Initialize tracker return self def __exit__(self, exc_type, exc_value, traceback): # Cleanup tracker pass def gradient(self, b, a): A mock implementation for gradient computation. Assuming the gradient of e^x is e^x, modified to consider the clamping: grad_values = np.exp(a.values) grad_values = np.where(grad_values > MAX_CLAMP, 0, grad_values) # Assuming clamped high values have zero gradient grad_values = np.where(grad_values < MIN_CLAMP, 0, grad_values) # Assuming clamped low values have zero gradient return Variable(grad_values)"},{"question":"def sanitize_string(input_string: str, replacements: dict[str, str], remove_extra_whitespace: bool) -> str: Sanitize a string by replacing specified characters and optionally removing extra whitespace. Args: input_string (str): The text to be sanitized. replacements (dict[str, str]): A dictionary where each key-value pair specifies a character to replace (key) and its replacement (value). remove_extra_whitespace (bool): A boolean indicating whether to remove extra spaces (consecutive spaces). Returns: str: The sanitized string after applying the replacements and whitespace removal if specified. >>> sanitize_string(\\"Hello, World!\\", {\\"!\\": \\".\\"}, False) 'Hello, World.' >>> sanitize_string(\\"Hello, World! This isn't some random text.\\", {\\"!\\": \\".\\", \\"'\\": \\"\\"}, False) 'Hello, World. This isnt some random text.' >>> sanitize_string(\\"Hello, World! This isn't some random text.\\", {\\"!\\": \\".\\", \\"'\\": \\"\\"}, True) 'Hello, World. This isnt some random text.' >>> sanitize_string(\\"Hello, World!\\", {}, True) 'Hello, World!' >>> sanitize_string(\\"This is a test.\\", {}, True) 'This is a test.' >>> sanitize_string(\\"\\", {\\"a\\": \\"b\\"}, True) '' >>> sanitize_string(\\" \\", {\\" \\": \\"\\"}, True) '' >>> sanitize_string(\\"Hello, World! This isn't some random text.\\", {\\"!\\": \\".\\", \\"'\\": \\"\\"}, False) 'Hello, World. This isnt some random text.'","solution":"def sanitize_string(input_string: str, replacements: dict[str, str], remove_extra_whitespace: bool) -> str: # replace characters according to the replacement dictionary for key, value in replacements.items(): input_string = input_string.replace(key, value) # remove extra whitespaces if required if remove_extra_whitespace: input_string = ' '.join(input_string.split()) return input_string"},{"question":"def sparse_matrix_query(elements, rows, cols, queries): Generates a sparse matrix from the given elements and counts the number of non-zero elements in the specified sub-regions defined by the queries. Parameters: - elements: List[Tuple[int, int, int]]: List of (row, column, value) indicating non-zero elements. - rows: int: Number of rows in the matrix. - cols: int: Number of columns in the matrix. - queries: List[Tuple[int, int, int, int]]: List of (row_start, col_start, row_end, col_end) indicating sub-regions. Returns: - List[int]: List containing counts of non-zero elements for each sub-region. def test_sparse_matrix_query(): # Example 1 elements1 = [(0, 1, 2), (2, 3, 5), (4, 0, 3)] rows1 = 5 cols1 = 5 queries1 = [(0, 0, 2, 2), (2, 2, 4, 4), (0, 0, 4, 4)] assert sparse_matrix_query(elements1, rows1, cols1, queries1) == [1, 1, 3] # Example 2 elements2 = [(1, 1, 4), (2, 2, 5), (3, 3, 6)] rows2 = 4 cols2 = 4 queries2 = [(0, 0, 1, 1), (1, 1, 3, 3), (0, 0, 3, 3)] assert sparse_matrix_query(elements2, rows2, cols2, queries2) == [1, 3, 3] # Example 3 elements3 = [(0, 2, 1), (3, 1, 2), (5, 5, 3)] rows3 = 6 cols3 = 6 queries3 = [(0, 0, 5, 5), (1, 1, 4, 4), (3, 3, 5, 5)] assert sparse_matrix_query(elements3, rows3, cols3, queries3) == [3, 1, 1] def test_sparse_matrix_edge_cases(): # Edge case 1: No elements elements = [] rows = 5 cols = 5 queries = [(0, 0, 4, 4)] assert sparse_matrix_query(elements, rows, cols, queries) == [0] # Edge case 2: All non-zero elements elements = [(i, j, 1) for i in range(5) for j in range(5)] queries = [(0, 0, 4, 4), (1, 1, 3, 3)] assert sparse_matrix_query(elements, rows, cols, queries) == [25, 9] # Edge case 3: Query sub-region with no non-zero elements elements = [(1, 1, 4), (2, 2, 5)] queries = [(0, 0, 0, 0), (3, 3, 4, 4)] assert sparse_matrix_query(elements, rows, cols, queries) == [0, 0] # Edge case 4: All elements are towards the end elements = [(4, 4, 10), (4, 3, 20), (3, 4, 30)] queries = [(3, 3, 4, 4)] assert sparse_matrix_query(elements, rows, cols, queries) == [3]","solution":"def sparse_matrix_query(elements, rows, cols, queries): Generates a sparse matrix from the given elements and counts the number of non-zero elements in the specified sub-regions defined by the queries. Parameters: - elements: List[Tuple[int, int, int]]: List of (row, column, value) indicating non-zero elements. - rows: int: Number of rows in the matrix. - cols: int: Number of columns in the matrix. - queries: List[Tuple[int, int, int, int]]: List of (row_start, col_start, row_end, col_end) indicating sub-regions. Returns: - List[int]: List containing counts of non-zero elements for each sub-region. from collections import defaultdict # Create a sparse representation of the matrix using a dictionary sparse_matrix = defaultdict(int) # Populate the sparse matrix with non-zero elements for row, col, value in elements: if value != 0: sparse_matrix[(row, col)] = value results = [] # Process each query for row_start, col_start, row_end, col_end in queries: count = 0 for (row, col), value in sparse_matrix.items(): if row_start <= row <= row_end and col_start <= col <= col_end: count += 1 results.append(count) return results"},{"question":"def levenshtein_distance(str1: str, str2: str) -> int: Calculate the minimum number of edits (operations) needed to convert one string into another. This operation is known as the Levenshtein distance and supports three types of edits: insertion, deletion, and substitution. Args: str1 (str): The first string. str2 (str): The second string. Returns: int: The minimum number of operations required to convert \`str1\` into \`str2\`. Examples: >>> levenshtein_distance(\\"kitten\\", \\"sitting\\") 3 >>> levenshtein_distance(\\"flaw\\", \\"lawn\\") 2 >>> levenshtein_distance(\\"intention\\", \\"execution\\") 5","solution":"def levenshtein_distance(str1: str, str2: str) -> int: len_str1 = len(str1) len_str2 = len(str2) # Create a 2D list to store the distances dp = [[0 for _ in range(len_str2 + 1)] for _ in range(len_str1 + 1)] # Initialize the distance for the first row and first column for i in range(len_str1 + 1): dp[i][0] = i for j in range(len_str2 + 1): dp[0][j] = j # Fill the dp table for i in range(1, len_str1 + 1): for j in range(1, len_str2 + 1): if str1[i - 1] == str2[j - 1]: cost = 0 else: cost = 1 dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + cost) # Substitution return dp[len_str1][len_str2]"},{"question":"class SparseMatrix: def __init__(self): self.elements = {} # dictionary to store non-zero elements {(row, col): value} def insert(self, row: int, col: int, value: int) -> None: if value != 0: self.elements[(row, col)] = value elif (row, col) in self.elements: del self.elements[(row, col)] def print_matrix(self, rows: int, cols: int) -> None: for i in range(rows): for j in range(cols): print(self.elements.get((i, j), 0), end=' ') print() def add(self, other: 'SparseMatrix') -> 'SparseMatrix': Add two sparse matrices and return the resultant sparse matrix. Args: other (SparseMatrix): Another sparse matrix to add to self. Returns: SparseMatrix: The resultant sparse matrix. Example: >>> matrix1 = SparseMatrix() >>> matrix1.insert(0, 0, 1) >>> matrix1.insert(1, 2, 3) >>> matrix2 = SparseMatrix() >>> matrix2.insert(0, 0, 4) >>> matrix2.insert(1, 2, 5) >>> matrix_sum = matrix1.add(matrix2) >>> matrix_sum.print_matrix(2, 3) 5 0 0 0 0 8","solution":"class SparseMatrix: def __init__(self): self.elements = {} # dictionary to store non-zero elements {(row, col): value} def insert(self, row: int, col: int, value: int) -> None: if value != 0: self.elements[(row, col)] = value elif (row, col) in self.elements: del self.elements[(row, col)] def print_matrix(self, rows: int, cols: int) -> None: for i in range(rows): for j in range(cols): print(self.elements.get((i, j), 0), end=' ') print() def add(self, other: 'SparseMatrix') -> 'SparseMatrix': Add two sparse matrices and return the resultant sparse matrix. Args: other (SparseMatrix): Another sparse matrix to add to self. Returns: SparseMatrix: The resultant sparse matrix. result = SparseMatrix() # Add elements from the first matrix for (row, col), value in self.elements.items(): result.insert(row, col, value) # Add elements from the second matrix for (row, col), value in other.elements.items(): if (row, col) in result.elements: result.insert(row, col, result.elements[(row, col)] + value) else: result.insert(row, col, value) return result"},{"question":"def max_crops_in_subgrid(grid: list[list[int]], k: int) -> int: Given a 2D grid representing a farm where each cell contains a value representing the number of crops in that cell, find the maximum sum of crops from any sub-grid of size k x k. Args: grid (list[list[int]]): A 2D list of integers representing the farm grid. k (int): The size of the sub-grid. Returns: int: The maximum sum of crops from any k x k sub-grid. Examples: >>> max_crops_in_subgrid([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16]], 2) 54 >>> max_crops_in_subgrid([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1]], 2) 4 >>> max_crops_in_subgrid([ ... [1, -1, 0], ... [0, 1, 1], ... [1, 0, 1]], 1) 1 >>> max_crops_in_subgrid([ ... [1, 2], ... [3, 4]], 2) 10 pass","solution":"def max_crops_in_subgrid(grid: list[list[int]], k: int) -> int: m, n = len(grid), len(grid[0]) max_sum = float('-inf') # Create an auxiliary sum array to store sums of sub-grids sum_grid = [[0] * (n + 1) for _ in range(m + 1)] # Building the prefix sum grid for i in range(1, m + 1): for j in range(1, n + 1): sum_grid[i][j] = grid[i - 1][j - 1] + sum_grid[i - 1][j] + sum_grid[i][j - 1] - sum_grid[i - 1][j - 1] # Calculate the sum of each kxk sub-grid for i in range(k, m + 1): for j in range(k, n + 1): current_sum = sum_grid[i][j] - sum_grid[i - k][j] - sum_grid[i][j - k] + sum_grid[i - k][j - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def find_missing_number(nums): Finds the missing number in the list of distinct numbers ranging from 0 to n. Args: nums (list): A list of distinct integers from 0 to n, with one number missing. Returns: int: The missing number. Examples: >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([0, 1]) 2 >>> find_missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1]) 8 >>> find_missing_number([0]) 1","solution":"def find_missing_number(nums): Finds the missing number in the list of distinct numbers ranging from 0 to n. Args: nums (list): A list of distinct integers from 0 to n, with one number missing. Returns: int: The missing number. n = len(nums) total_sum = n * (n + 1) / 2 actual_sum = sum(nums) return int(total_sum - actual_sum)"},{"question":"# Task Implement the following function: def has_all_unique_chars(s: str) -> bool: This function checks if all characters in the string are unique. It does not use additional data structures. :param s: input string :return: True if all characters are unique, False otherwise pass Write test cases to verify the correctness of your implementation using the provided template: # Test cases def test_has_all_unique_chars_empty_string(): assert has_all_unique_chars(\\"\\") == True def test_has_all_unique_chars_single_char(): assert has_all_unique_chars(\\"a\\") == True def test_has_all_unique_chars_unique_chars(): assert has_all_unique_chars(\\"abcdefg\\") == True assert has_all_unique_chars(\\"AaBbCcDd\\") == True def test_has_all_unique_chars_repeating_chars(): assert has_all_unique_chars(\\"aabcdef\\") == False assert has_all_unique_chars(\\"AaBbCcAa\\") == False def test_has_all_unique_chars_case_sensitivity(): assert has_all_unique_chars(\\"aA\\") == True assert has_all_unique_chars(\\"abAB\\") == True def test_has_all_unique_chars_long_string(): long_string = \\"\\".join(chr(65 + (i % 26)) for i in range(1000)) assert has_all_unique_chars(long_string) == False def test_has_all_unique_chars_max_length_distinct_chars(): long_string = \\"\\".join(chr(65 + (i % 26)) for i in range(26)) # 26 distinct characters assert has_all_unique_chars(long_string) == True","solution":"def has_all_unique_chars(s: str) -> bool: This function checks if all characters in the string are unique. It does not use additional data structures. :param s: input string :return: True if all characters are unique, False otherwise n = len(s) for i in range(n): for j in range(i + 1, n): if s[i] == s[j]: return False return True"},{"question":"def knapsack(weights: list[int], values: list[int], W: int) -> int: Determine the maximum value that fits into the knapsack with capacity W using memoization. :param weights: List of weights of items. :param values: List of values of items. :param W: Maximum weight capacity. :return: Maximum value achievable. >>> knapsack([2, 3, 4, 5], [3, 4, 5, 6], 5) 7 >>> knapsack([1, 3, 4, 5], [1, 4, 5, 7], 7) 9 # Implement the knapsack problem with memoization pass # Example Test Cases if __name__ == \\"__main__\\": weights = [1] values = [10] W = 1 print(knapsack(weights, values, W)) # Output: 10 weights = [2] values = [10] W = 1 print(knapsack(weights, values, W)) # Output: 0 weights = [2, 3, 4, 5] values = [3, 4, 5, 6] W = 5 print(knapsack(weights, values, W)) # Output: 7 weights = [1, 3, 4, 5] values = [1, 4, 5, 7] W = 7 print(knapsack(weights, values, W)) # Output: 9 weights = [1, 2, 3] values = [10, 20, 30] W = 6 print(knapsack(weights, values, W)) # Output: 60 weights = [1, 2, 3] values = [10, 20, 30] W = 0 print(knapsack(weights, values, W)) # Output: 0","solution":"def knapsack(weights, values, W): Determine the maximum value that fits into the knapsack with capacity W using memoization. :param weights: List of weights of items. :param values: List of values of items. :param W: Maximum weight capacity. :return: Maximum value achievable. memo = {} def helper(i, remaining_weight): # Base case: no items left or no remaining capacity if i == len(weights) or remaining_weight == 0: return 0 # Check if result already computed if (i, remaining_weight) in memo: return memo[(i, remaining_weight)] # Option 1: Exclude the current item max_value = helper(i + 1, remaining_weight) # Option 2: Include the current item (if it does not exceed the remaining capacity) if weights[i] <= remaining_weight: max_value = max(max_value, values[i] + helper(i + 1, remaining_weight - weights[i])) # Save the result in memo dictionary memo[(i, remaining_weight)] = max_value return max_value return helper(0, W)"},{"question":"def energy_consumption(wattage: int, hours: float) -> float: Calculate the total energy consumption of an appliance over a given period. The energy consumption can be calculated using the formula: Energy Consumption = wattage * hours / 1000 where the result is in kilowatt-hours (kWh). :param wattage: An integer representing the power rating of the appliance in watts. :param hours: A floating-point number representing the usage duration in hours. :return: A floating-point number representing the total energy consumption in kilowatt-hours (kWh). >>> energy_consumption(100, 5) 0.5 >>> energy_consumption(2000, 1.5) 3.0 >>> energy_consumption(1500, 24) 36.0 from solution import energy_consumption def test_energy_consumption_standard_case(): assert energy_consumption(100, 5) == 0.5 assert energy_consumption(2000, 1.5) == 3.0 assert energy_consumption(1500, 24) == 36.0 def test_energy_consumption_zero_hours(): assert energy_consumption(100, 0) == 0.0 assert energy_consumption(1500, 0) == 0.0 def test_energy_consumption_min_wattage(): assert energy_consumption(1, 10.5) == 0.0105 def test_energy_consumption_max_wattage_and_hours(): assert energy_consumption(10000, 24) == 240.0 def test_energy_consumption_floating_point_hours(): assert energy_consumption(200, 0.75) == 0.15 assert energy_consumption(450, 2.5) == 1.125","solution":"def energy_consumption(wattage: int, hours: float) -> float: Calculate the total energy consumption of an appliance over a given period. :param wattage: An integer representing the power rating of the appliance in watts. :param hours: A floating-point number representing the usage duration in hours. :return: A floating-point number representing the total energy consumption in kilowatt-hours (kWh). return wattage * hours / 1000"},{"question":"from typing import List def longest_increasing_subsequence(difficulties: List[int]) -> int: Determines the length of the longest subsequence of workshops with strictly increasing difficulty levels. Parameters: difficulties (List[int]): A list of integers representing the difficulty levels of the workshops. Returns: int: Length of the longest increasing subsequence. >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([9, 8, 7, 6]) 1 pass def test_example_case(): assert longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6 def test_empty_list(): assert longest_increasing_subsequence([]) == 0 def test_single_element_list(): assert longest_increasing_subsequence([10]) == 1 def test_all_increasing(): assert longest_increasing_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 9 def test_all_decreasing(): assert longest_increasing_subsequence([9, 8, 7, 6, 5, 4, 3, 2, 1]) == 1 def test_random_order(): assert longest_increasing_subsequence([3, 10, 2, 1, 20]) == 3 def test_all_same_elements(): assert longest_increasing_subsequence([5, 5, 5, 5, 5, 5]) == 1 def test_some_increasing_subsequences(): assert longest_increasing_subsequence([3, 4, 1, 2, 8, 5, 6]) == 4","solution":"from typing import List def longest_increasing_subsequence(difficulties: List[int]) -> int: if not difficulties: return 0 n = len(difficulties) lis = [1] * n # Initialize LIS values for all indexes as 1 # Compute optimized LIS values in a bottom-up manner for i in range(1, n): for j in range(i): if difficulties[i] > difficulties[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Find the maximum of all LIS values return max(lis)"},{"question":"class ListNode: def __init__(self, x: int = 0, next: 'ListNode' = None): self.val = x self.next = next def merge_sorted_lists(head1: ListNode, head2: ListNode) -> ListNode: Merge two sorted linked lists into a single sorted linked list containing distinct elements. >>> head1 = create_linked_list([1, 3, 5]) >>> head2 = create_linked_list([1, 2, 4]) >>> linked_list_to_list(merge_sorted_lists(head1, head2)) [1, 2, 3, 4, 5] >>> head1 = create_linked_list([10, 20, 30]) >>> head2 = create_linked_list([5, 10, 15]) >>> linked_list_to_list(merge_sorted_lists(head1, head2)) [5, 10, 15, 20, 30] >>> head1 = create_linked_list([1, 4, 5]) >>> head2 = create_linked_list([2, 3, 6]) >>> linked_list_to_list(merge_sorted_lists(head1, head2)) [1, 2, 3, 4, 5, 6] >>> head1 = create_linked_list([1, 4, 5]) >>> head2 = create_linked_list([2, 4, 6]) >>> linked_list_to_list(merge_sorted_lists(head1, head2)) [1, 2, 4, 5, 6] >>> head1 = create_linked_list([1, 2, 3]) >>> head2 = create_linked_list([1, 2, 3]) >>> linked_list_to_list(merge_sorted_lists(head1, head2)) [1, 2, 3] >>> head1 = create_linked_list([1, 2, 3]) >>> head2 = create_linked_list([]) >>> linked_list_to_list(merge_sorted_lists(head1, head2)) [1, 2, 3] >>> head1 = create_linked_list([]) >>> head2 = create_linked_list([]) >>> linked_list_to_list(merge_sorted_lists(head1, head2)) [] pass def create_linked_list(vals): if not vals: return None head = ListNode(vals[0]) current = head for val in vals[1:]: current.next = ListNode(val) current = current.next return head def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result","solution":"class ListNode: def __init__(self, x: int = 0, next: 'ListNode' = None): self.val = x self.next = next def merge_sorted_lists(head1: ListNode, head2: ListNode) -> ListNode: dummy = ListNode() current = dummy while head1 and head2: if head1.val < head2.val: if not current.next or current.next.val != head1.val: current.next = ListNode(head1.val) current = current.next head1 = head1.next elif head1.val > head2.val: if not current.next or current.next.val != head2.val: current.next = ListNode(head2.val) current = current.next head2 = head2.next else: if not current.next or current.next.val != head1.val: current.next = ListNode(head1.val) current = current.next head1 = head1.next head2 = head2.next # Process the remaining nodes in head1 while head1: if not current.next or current.next.val != head1.val: current.next = ListNode(head1.val) current = current.next head1 = head1.next # Process the remaining nodes in head2 while head2: if not current.next or current.next.val != head2.val: current.next = ListNode(head2.val) current = current.next head2 = head2.next return dummy.next def create_linked_list(vals): if not vals: return None head = ListNode(vals[0]) current = head for val in vals[1:]: current.next = ListNode(val) current = current.next return head def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result"},{"question":"import heapq def dijkstra_shortest_path(graph, start_node, end_node): Finds the shortest path between start_node and end_node in a weighted graph using Dijkstra's algorithm. Parameters: graph (dict[int, list[tuple[int, int]]]): A weighted graph represented as an adjacency list. start_node (int): The start node for the path. end_node (int): The target node for the path. Returns: tuple[int, list[int]]: The total weight of the shortest path and the nodes in the shortest path from start_node to end_node. Example: >>> dijkstra_shortest_path({0: [(1, 4), (2, 1)], 1: [(2, 2), (3, 5)], 2: [(3, 1)], 3: []}, 0, 3) (2, [0, 2, 3]) >>> dijkstra_shortest_path({0: [(1, 1), (2, 4)], 1: [(2, 2), (3, 6)], 2: [(3, 3)], 3: []}, 0, 3) (6, [0, 1, 2, 3])","solution":"import heapq def dijkstra_shortest_path(graph, start_node, end_node): Finds the shortest path between start_node and end_node in a weighted graph using Dijkstra's algorithm. Parameters: graph (dict[int, list[tuple[int, int]]]): A weighted graph represented as an adjacency list. start_node (int): The start node for the path. end_node (int): The target node for the path. Returns: tuple[int, list[int]]: The total weight of the shortest path and the nodes in the shortest path from start_node to end_node. # Initialize distance to all nodes as infinity and distance to start_node as 0 distances = {node: float('inf') for node in graph} distances[start_node] = 0 # Priority queue for maintaining nodes to explore priority_queue = [(0, start_node)] # Dictionary to keep track of the shortest path previous_nodes = {node: None for node in graph} while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If we reach the end_node, reconstruct and return the path if current_node == end_node: path = [] while previous_nodes[current_node] is not None: path.insert(0, current_node) current_node = previous_nodes[current_node] path.insert(0, start_node) return current_distance, path if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it's better if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) # If there is no path from start_node to end_node return float('inf'), [] # Example usage graph_example = { 0: [(1, 4), (2, 1)], 1: [(2, 2), (3, 5)], 2: [(3, 1)], 3: [] } start_node_example = 0 end_node_example = 3 shortest_path_weight, shortest_path = dijkstra_shortest_path(graph_example, start_node_example, end_node_example) print(\\"Shortest Path Weight:\\", shortest_path_weight) print(\\"Shortest Path:\\", shortest_path)"},{"question":"from typing import List, Tuple def calculate_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: Calculates the Euclidean distance between two points p1 and p2. pass def total_route_distance(route: List[Tuple[int, int]]) -> float: Calculates the total distance of the given route returning to the start point. pass def optimal_delivery_route(locations: List[Tuple[int, int]], warehouse: Tuple[int, int]) -> List[Tuple[int, int]]: Determines the optimal order in which to visit all the given locations starting and ending at the warehouse to minimize the total travel distance. Args: locations (List[Tuple[int, int]]): A list of tuples where each tuple represents the coordinates (x, y) of a location. warehouse (Tuple[int, int]): A tuple representing the coordinates (x, y) of the warehouse, where the delivery route starts and ends. Returns: List[Tuple[int, int]]: A list of tuples representing the optimal order of locations (including the warehouse at the start and the end) to minimize the total travel distance. Example: >>> optimal_delivery_route([(1, 2), (3, 4), (5, 6)], (0, 0)) [(0, 0), (1, 2), (3, 4), (5, 6), (0, 0)] >>> optimal_delivery_route([(1, 1), (6, 6), (2, 2)], (0, 0)) [(0, 0), (1, 1), (2, 2), (6, 6), (0, 0)] >>> optimal_delivery_route([(2, 3), (1, 7), (6, 8)], (4, 1)) [(4, 1), (2, 3), (1, 7), (6, 8), (4, 1)] >>> optimal_delivery_route([], (0, 0)) [(0, 0), (0, 0)] >>> optimal_delivery_route([(5, 5)], (3, 3)) [(3, 3), (5, 5), (3, 3)] pass","solution":"import itertools import math def calculate_distance(p1, p2): Calculates the Euclidean distance between two points p1 and p2. return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def total_route_distance(route): Calculates the total distance of the given route returning to the start point. if len(route) < 2: return 0 distance = 0 for i in range(len(route) - 1): distance += calculate_distance(route[i], route[i + 1]) distance += calculate_distance(route[-1], route[0]) # Return to warehouse(0) return distance def optimal_delivery_route(locations, warehouse): Determines the optimal order in which to visit all the given locations starting and ending at the warehouse to minimize the total travel distance. if not locations: return [warehouse, warehouse] min_distance = float('inf') min_route = [] for perm in itertools.permutations(locations): current_route = [warehouse] + list(perm) + [warehouse] current_distance = total_route_distance(current_route) if current_distance < min_distance: min_distance = current_distance min_route = current_route return min_route"},{"question":"def compare_sorting_algorithms(arr: list[int]) -> dict[str, list[list[int]]]: Compares Bubble Sort and Selection Sort algorithms by showing intermediate steps. Example: >>> compare_sorting_algorithms([4, 3, 1, 5]) { \\"Bubble Sort\\": [ [3, 1, 4, 5], [1, 3, 4, 5], [1, 3, 4, 5] ], \\"Selection Sort\\": [ [1, 3, 4, 5], [1, 3, 4, 5], [1, 3, 4, 5] ] } >>> compare_sorting_algorithms([20, 5, 13, 2]) { \\"Bubble Sort\\": [ [5, 13, 2, 20], [5, 2, 13, 20], [2, 5, 13, 20] ], \\"Selection Sort\\": [ [2, 5, 13, 20], [2, 5, 13, 20], [2, 5, 13, 20] ] } >>> compare_sorting_algorithms([6, 2, 8, 1]) { \\"Bubble Sort\\": [ [2, 6, 1, 8], [2, 1, 6, 8], [1, 2, 6, 8] ], \\"Selection Sort\\": [ [1, 2, 8, 6], [1, 2, 8, 6], [1, 2, 6, 8] ] }","solution":"def compare_sorting_algorithms(arr): def bubble_sort_steps(array): n = len(array) steps = [] arr_copy = array[:] for i in range(n-1): for j in range(n-i-1): if arr_copy[j] > arr_copy[j+1]: arr_copy[j], arr_copy[j+1] = arr_copy[j+1], arr_copy[j] steps.append(arr_copy[:]) return steps def selection_sort_steps(array): n = len(array) steps = [] arr_copy = array[:] for i in range(n-1): min_idx = i for j in range(i+1, n): if arr_copy[j] < arr_copy[min_idx]: min_idx = j arr_copy[i], arr_copy[min_idx] = arr_copy[min_idx], arr_copy[i] steps.append(arr_copy[:]) return steps result = { \\"Bubble Sort\\": bubble_sort_steps(arr), \\"Selection Sort\\": selection_sort_steps(arr) } return result"},{"question":"def consistent_performers(scores: dict) -> list: Identify users who improved their scores in each subsequent competition. Args: scores (dict): A dictionary where keys are user IDs (strings) and values are lists of integers representing scores. Returns: list: Returns a list of user IDs (strings) who have improved their score in every subsequent competition. Examples: >>> consistent_performers({ \\"user1\\": [50, 60, 80], \\"user2\\": [45, 30, 50, 65], \\"user3\\": [70, 80, 75], \\"user4\\": [40, 40, 40] }) ['user1', 'user2'] from solution import consistent_performers def test_consistent_performers_all_consistent(): all_consistent = { \\"user1\\": [1, 2, 3], \\"user2\\": [10, 20, 30, 40], \\"user3\\": [5, 6, 7, 8], } assert consistent_performers(all_consistent) == [\\"user1\\", \\"user2\\", \\"user3\\"] def test_consistent_performers_mixed(): mixed = { \\"user1\\": [1, 2, 3], \\"user2\\": [3, 2, 1], \\"user3\\": [5, 5, 5], \\"user4\\": [10, 20, 15, 30], \\"user5\\": [5, 6, 7, 8], } assert consistent_performers(mixed) == [\\"user1\\", \\"user5\\"] def test_consistent_performers_none_consistent(): none_consistent = { \\"user1\\": [3, 3, 3], \\"user2\\": [10, 9, 8, 7], \\"user3\\": [5, 4, 3, 2], } assert consistent_performers(none_consistent) == [] def test_consistent_performers_single_user(): single_user = { \\"user1\\": [1, 3, 7], } assert consistent_performers(single_user) == [\\"user1\\"] def test_consistent_performers_large_input(): large_input = { f\\"user{i}\\": list(range(1, 101)) for i in range(1000) # All users have improving scores from 1 to 100 } assert consistent_performers(large_input) == [f\\"user{i}\\" for i in range(1000)]","solution":"def consistent_performers(scores: dict) -> list: consistent_users = [] for user, user_scores in scores.items(): if all(user_scores[i] < user_scores[i+1] for i in range(len(user_scores) - 1)): consistent_users.append(user) return consistent_users"},{"question":"def dijkstra(graph: dict, start: int) -> dict: Finds the shortest path from a starting node to all other nodes in the graph. :param graph: A dictionary representing an undirected graph where keys are nodes and values are lists of tuples [(neighbor, weight)]. :param start: The starting node for Dijkstra's algorithm. :return: A dictionary where keys are nodes and values are the shortest path distances from the start node. Example usage: >>> graph = { ... 0: [(1, 4), (2, 1)], ... 1: [(0, 4), (2, 2), (3, 5)], ... 2: [(0, 1), (1, 2), (3, 1)], ... 3: [(1, 5), (2, 1)] ... } >>> dijkstra(graph, 0) {0: 0, 1: 3, 2: 1, 3: 2} def test_dijkstra(): graph = { 0: [(1, 4), (2, 1)], 1: [(0, 4), (2, 2), (3, 5)], 2: [(0, 1), (1, 2), (3, 1)], 3: [(1, 5), (2, 1)] } result = dijkstra(graph, 0) expected = {0: 0, 1: 3, 2: 1, 3: 2} assert result == expected graph = { 0: [(1, 7), (2, 9), (5, 14)], 1: [(0, 7), (2, 10), (3, 15)], 2: [(0, 9), (1, 10), (3, 11), (5, 2)], 3: [(1, 15), (2, 11), (4, 6)], 4: [(3, 6)], 5: [(0, 14), (2, 2)] } result = dijkstra(graph, 0) expected = {0: 0, 1: 7, 2: 9, 3: 20, 4: 26, 5: 11} assert result == expected graph = { 0: [] } result = dijkstra(graph, 0) expected = {0: 0} assert result == expected graph = { 0: [(1, 1)], 1: [(0, 1), (2, 1)], 2: [(1, 1), (3, 1)], 3: [(2, 1), (4, 1)], 4: [(3, 1)] } result = dijkstra(graph, 0) expected = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4} assert result == expected graph = { 1: [(2, 2), (4, 1)], 2: [(1, 2), (3, 5)], 3: [(2, 5), (4, 2)], 4: [(1, 1), (3, 2), (5, 3)], 5: [(4, 3)] } result = dijkstra(graph, 1) expected = {1: 0, 2: 2, 3: 3, 4: 1, 5: 4} assert result == expected","solution":"import heapq def dijkstra(graph, start): Finds the shortest path from a starting node to all other nodes in the graph. :param graph: A dictionary representing an undirected graph where keys are nodes and values are lists of tuples [(neighbor, weight)]. :param start: The starting node for Dijkstra's algorithm. :return: A dictionary where keys are nodes and values are the shortest path distances from the start node. # Priority queue to hold vertex distances pq = [(0, start)] # Dictionary to hold the shortest distance to each vertex distances = {node: float('inf') for node in graph} distances[start] = 0 while pq: current_distance, current_vertex = heapq.heappop(pq) # If the popped vertex distance is greater than the recorded shortest distance, continue if current_distance > distances[current_vertex]: continue # Explore neighbors for neighbor, weight in graph[current_vertex]: distance = current_distance + weight # Only consider this path if it's shorter if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances"},{"question":"import re from collections import Counter from typing import List STOPWORDS = set([ \\"a\\", \\"an\\", \\"and\\", \\"are\\", \\"as\\", \\"at\\", \\"be\\", \\"by\\", \\"for\\", \\"from\\", \\"has\\", \\"he\\", \\"in\\", \\"is\\", \\"it\\", \\"its\\", \\"of\\", \\"on\\", \\"that\\", \\"the\\", \\"to\\", \\"was\\", \\"were\\", \\"will\\", \\"with\\" ]) def top_n_frequent_words(text: str, n: int) -> List[str]: Determine the top N most frequent words in the given text. Words are defined as contiguous sequences of alphabetic characters and should be treated case-insensitively (i.e., \\"Word\\" is the same as \\"word\\"). Exclude common stopwords (e.g., \\"the\\", \\"is\\", \\"in\\", etc.) from the frequency count. Args: text (str): The input text string. n (int): The number of top frequent words to return. Returns: List[str]: A list of the top n most frequent words, sorted by frequency in descending order. If two words have the same frequency, they should be sorted lexicographically. Examples: >>> top_n_frequent_words(\\"In a village of La Mancha, the name of which I have no desire to call to mind, there lived not long since one of those gentlemen that keep a lance in the lance-rack, an old buckler, a lean hack, and a greyhound for coursing.\\", 3) ['lance', 'a', 'an'] >>> top_n_frequent_words(\\"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness.\\", 4) ['age', 'it', 'times', 'was'] >>> top_n_frequent_words(\\"To be or not to be, that is the question.\\", 2) ['be', 'not']","solution":"import re from collections import Counter from typing import List STOPWORDS = set([ \\"a\\", \\"an\\", \\"and\\", \\"are\\", \\"as\\", \\"at\\", \\"be\\", \\"by\\", \\"for\\", \\"from\\", \\"has\\", \\"he\\", \\"in\\", \\"is\\", \\"it\\", \\"its\\", \\"of\\", \\"on\\", \\"that\\", \\"the\\", \\"to\\", \\"was\\", \\"were\\", \\"will\\", \\"with\\" ]) def top_n_frequent_words(text: str, n: int) -> List[str]: # Convert the text to lowercase and use regex to find all words words = re.findall(r'b[a-zA-Z]+b', text.lower()) # Filter out stopwords words = [word for word in words if word not in STOPWORDS] # Use Counter to count the frequency of each word word_counts = Counter(words) # Get the most common words most_common = word_counts.most_common() # Sort by frequency (descending) and then alphabetically (ascending) most_common.sort(key=lambda x: (-x[1], x[0])) # Get the top N frequent words return [word for word, _ in most_common[:n]]"},{"question":"import random from typing import List, Tuple import math def k_means_clustering(data_points: List[Tuple[float, float]], num_centroids: int, num_iterations: int = 100) -> Tuple[List[Tuple[float, float]], List[int]]: Perform basic clustering using the K-means algorithm with a specified number of centroids and fixed number of iterations. >>> points = [(1.0, 2.0), (1.5, 1.8), (5.0, 8.0), (8.0, 8.0), (1.0, 0.6), (9.0, 11.0)] >>> num_centroids = 2 >>> num_iterations = 10 >>> centroids, assignments = k_means_clustering(points, num_centroids, num_iterations) >>> len(centroids) == num_centroids True >>> all(a in range(num_centroids) for a in assignments) True >>> points = [(2.0, 2.0)] >>> num_centroids = 1 >>> num_iterations = 10 >>> centroids, assignments = k_means_clustering(points, num_centroids, num_iterations) >>> centroids == [(2.0, 2.0)] True >>> assignments == [0] True >>> points = [(1.0, 1.0), (1.0, 1.0), (1.0, 1.0)] >>> num_centroids = 1 >>> num_iterations = 10 >>> centroids, assignments = k_means_clustering(points, num_centroids, num_iterations) >>> centroids == [(1.0, 1.0)] True >>> assignments == [0, 0, 0] True >>> try: ... points = [(1.0, 1.0), (5.0, 5.0)] ... num_centroids = 3 ... num_iterations = 10 ... centroids, assignments = k_means_clustering(points, num_centroids, num_iterations) ... False, \\"Expected an error when number of centroids is greater than number of points\\" ... except ValueError: ... pass # Expected >>> points = [(1.0, 2.0), (1.5, 1.8), (5.0, 8.0), (8.0, 8.0), (1.0, 0.6), (9.0, 11.0)] >>> num_centroids = 2 >>> num_iterations = 1 >>> centroids_before, _ = k_means_clustering(points, num_centroids, num_iterations) >>> num_iterations = 10 >>> centroids_after, _ = k_means_clustering(points, num_centroids, num_iterations) >>> centroids_before != centroids_after True","solution":"import random from typing import List, Tuple import math def k_means_clustering(data_points: List[Tuple[float, float]], num_centroids: int, num_iterations: int = 100) -> Tuple[List[Tuple[float, float]], List[int]]: def euclidean_distance(point1, point2): return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) # Step 1: Randomly initialize centroids centroids = random.sample(data_points, num_centroids) for _ in range(num_iterations): # Step 2: Assign points to the nearest centroid clusters = [[] for _ in range(num_centroids)] for point in data_points: distances = [euclidean_distance(point, centroid) for centroid in centroids] closest_centroid_index = distances.index(min(distances)) clusters[closest_centroid_index].append(point) # Step 3: Update centroids as the mean of their points for i in range(num_centroids): if clusters[i]: # Avoid empty cluster division by zero centroids[i] = ( sum([point[0] for point in clusters[i]]) / len(clusters[i]), sum([point[1] for point in clusters[i]]) / len(clusters[i]) ) # Final assignment cluster_assignments = [] for point in data_points: distances = [euclidean_distance(point, centroid) for centroid in centroids] closest_centroid_index = distances.index(min(distances)) cluster_assignments.append(closest_centroid_index) return centroids, cluster_assignments"},{"question":"def longest_palindromic_substring(s: str) -> str: Write a function \`longest_palindromic_substring(s: str) -> str\` to find the longest palindromic substring in the given string \`s\`. >>> longest_palindromic_substring(\\"babad\\") 'bab' # or 'aba' >>> longest_palindromic_substring(\\"cbbd\\") 'bb' >>> longest_palindromic_substring(\\"a\\") 'a' >>> longest_palindromic_substring(\\"ac\\") 'a' # or 'c'","solution":"def longest_palindromic_substring(s: str) -> str: def expand_around_center(left: int, right: int) -> str: while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] if len(s) == 0: return \\"\\" longest = \\"\\" for i in range(len(s)): # Odd length palindromes odd_palindrome = expand_around_center(i, i) if len(odd_palindrome) > len(longest): longest = odd_palindrome # Even length palindromes even_palindrome = expand_around_center(i, i + 1) if len(even_palindrome) > len(longest): longest = even_palindrome return longest"},{"question":"from typing import List, Tuple class DynamicGraph: def __init__(self, edges: List[Tuple[int, int]]) -> None: Initialize the graph with the provided list of edges. pass def are_connected(self, u: int, v: int) -> bool: Check if there is a path between vertex \`u\` and vertex \`v\`. pass def insert_edge(self, u: int, v: int) -> None: Insert an edge between vertex \`u\` and vertex \`v\`. pass def delete_edge(self, u: int, v: int) -> None: Delete the edge between vertex \`u\` and vertex \`v\`, if it exists. pass # Unit tests def test_initial_insert_edge(): dg = DynamicGraph([(0, 1), (1, 2), (2, 3)]) assert dg.are_connected(0, 3) == True def test_delete_edge(): dg = DynamicGraph([(0, 1), (1, 2), (2, 3)]) dg.delete_edge(1, 2) assert dg.are_connected(0, 3) == False def test_insert_edge(): dg = DynamicGraph([(0, 1), (1, 2), (2, 3)]) dg.delete_edge(1, 2) dg.insert_edge(0, 3) assert dg.are_connected(0, 3) == True def test_no_path_in_disconnected_graph(): dg = DynamicGraph([(0, 1), (2, 3)]) assert dg.are_connected(0, 3) == False def test_self_loop_connectivity(): dg = DynamicGraph([(0, 0)]) assert dg.are_connected(0, 0) == True def test_path_after_multiple_insertions(): dg = DynamicGraph([]) dg.insert_edge(0, 1) dg.insert_edge(1, 2) dg.insert_edge(2, 3) assert dg.are_connected(0, 3) == True def test_path_after_multiple_deletions(): dg = DynamicGraph([(0, 1), (1, 2), (2, 3)]) dg.delete_edge(0, 1) dg.delete_edge(1, 2) dg.delete_edge(2, 3) assert dg.are_connected(0, 3) == False","solution":"from collections import defaultdict class DynamicGraph: def __init__(self, edges): self.graph = defaultdict(set) for u, v in edges: self.graph[u].add(v) self.graph[v].add(u) def are_connected(self, u, v): visited = set() return self._dfs(u, v, visited) def _dfs(self, current, target, visited): if current == target: return True visited.add(current) for neighbor in self.graph[current]: if neighbor not in visited: if self._dfs(neighbor, target, visited): return True return False def insert_edge(self, u, v): self.graph[u].add(v) self.graph[v].add(u) def delete_edge(self, u, v): if v in self.graph[u]: self.graph[u].remove(v) if u in self.graph[v]: self.graph[v].remove(u)"},{"question":"class CustomStack: Implement a stack with increment operations. Initialize the stack with a given maximum size. Methods: - push(x: int): Adds the element x to the top if stack hasn't reached maxSize. - pop() -> int: Removes and returns the top element. Returns -1 if stack is empty. - increment(k: int, val: int): Increments the bottom k elements by val. >>> stack = CustomStack(3) >>> stack.push(1) >>> stack.push(2) >>> stack.pop() 2 >>> stack.push(2) >>> stack.push(3) >>> stack.push(4) >>> stack.increment(5, 100) >>> stack.increment(2, 100) >>> stack.pop() 103 >>> stack.pop() 202 >>> stack.pop() 201 >>> stack.pop() -1 def __init__(self, maxSize: int): # Initialize with empty stack and max size def push(self, x: int) -> None: # Push element to the stack if it doesn't exceed maxSize def pop(self) -> int: # Pop and return top element, or -1 if stack is empty def increment(self, k: int, val: int) -> None: # Increment bottom k elements by val # Test cases def test_custom_stack_operations(): stack = CustomStack(3) stack.push(1) stack.push(2) assert stack.pop() == 2 stack.push(2) stack.push(3) stack.push(4) stack.increment(5, 100) # stack should become [101, 102, 103] assert stack.stack == [101, 102, 103] stack.increment(2, 100) # stack should become [201, 202, 103] assert stack.stack == [201, 202, 103] assert stack.pop() == 103 assert stack.pop() == 202 assert stack.pop() == 201 assert stack.pop() == -1 def test_push_pop_limits(): stack = CustomStack(2) stack.push(1) stack.push(2) assert stack.pop() == 2 assert stack.pop() == 1 assert stack.pop() == -1 def test_increment_partial(): stack = CustomStack(5) stack.push(1) stack.push(2) stack.push(3) stack.increment(2, 10) # only [1, 2] should be incremented assert stack.stack == [11, 12, 3] def test_increment_fully(): stack = CustomStack(3) stack.push(1) stack.push(2) stack.push(3) stack.increment(5, 10) # more elements than present assert stack.stack == [11, 12, 13]","solution":"class CustomStack: def __init__(self, maxSize: int): self.stack = [] self.maxSize = maxSize def push(self, x: int) -> None: if len(self.stack) < self.maxSize: self.stack.append(x) def pop(self) -> int: if not self.stack: return -1 return self.stack.pop() def increment(self, k: int, val: int) -> None: for i in range(min(k, len(self.stack))): self.stack[i] += val"},{"question":"def summarize_logs(log_file_path: str) -> tuple[dict, dict]: Parse a log file and summarize specific events. Each log entry contains a timestamp, an event type, and a message. The function categorizes events by their type and provides a summary of event counts and a list of unique messages per event type. Args: log_file_path (str): The path to the log file. Returns: tuple[dict, dict]: - event_counts (dict): A dictionary where keys are event types and values are the counts of each event type. - unique_messages (dict): A dictionary where keys are event types and values are sets of unique messages per event type. Example: >>> summarize_logs(\\"path/to/logfile\\") ({\\"ERROR\\": 2, \\"INFO\\": 3, \\"WARN\\": 1}, {\\"ERROR\\": {\\"Failed to connect to database\\", \\"Timeout occurred\\"}, \\"INFO\\": {\\"User logged in\\", \\"User logged out\\"}, \\"WARN\\": {\\"Low disk space\\"}}) # Create a temporary log file for testing def create_temp_log(content): with open(\\"temp_log.txt\\", \\"w\\") as temp_file: temp_file.write(content) def test_summarize_logs(): test_log_content = 2023-10-01 10:00:00 ERROR Failed to connect to database 2023-10-01 10:05:00 INFO User logged in 2023-10-01 10:10:00 ERROR Timeout occurred 2023-10-01 10:15:00 INFO User logged out 2023-10-01 10:20:00 INFO User logged in 2023-10-01 10:25:00 WARN Low disk space create_temp_log(test_log_content) event_counts, unique_messages = summarize_logs(\\"temp_log.txt\\") expected_event_counts = { \\"ERROR\\": 2, \\"INFO\\": 3, \\"WARN\\": 1 } expected_unique_messages = { \\"ERROR\\": {\\"Failed to connect to database\\", \\"Timeout occurred\\"}, \\"INFO\\": {\\"User logged in\\", \\"User logged out\\"}, \\"WARN\\": {\\"Low disk space\\"} } assert event_counts == expected_event_counts assert unique_messages == expected_unique_messages def test_empty_log_file(): create_temp_log(\\"\\") event_counts, unique_messages = summarize_logs(\\"temp_log.txt\\") assert event_counts == {} assert unique_messages == {} def test_log_file_with_single_entry(): single_entry_log = \\"2023-10-01 10:00:00 INFO System startedn\\" create_temp_log(single_entry_log) event_counts, unique_messages = summarize_logs(\\"temp_log.txt\\") expected_event_counts = { \\"INFO\\": 1 } expected_unique_messages = { \\"INFO\\": {\\"System started\\"} } assert event_counts == expected_event_counts assert unique_messages == expected_unique_messages","solution":"def summarize_logs(log_file_path: str) -> tuple[dict, dict]: event_counts = {} unique_messages = {} with open(log_file_path, 'r') as file: for line in file: # Split the log entry parts = line.split(' ', 2) timestamp = parts[0] + ' ' + parts[1] event_type = parts[2].strip().split(' ', 1)[0] message = parts[2].strip().split(' ', 1)[1] if ' ' in parts[2].strip() else \\"\\" # Update event counts if event_type in event_counts: event_counts[event_type] += 1 else: event_counts[event_type] = 1 # Update unique messages if event_type in unique_messages: unique_messages[event_type].add(message) else: unique_messages[event_type] = {message} return event_counts, unique_messages"},{"question":"class FilmDatabase: A database class to store and search films by various criteria def __init__(self): Initializes the FilmDatabase with an empty list of films. self.films = [] def add_film(self, film: dict): Adds a new film to the database. Args: film (dict): A dictionary representing a film with keys 'title', 'year', and 'rating'. pass def find_by_title(self, title: str) -> list[dict]: Finds films by title (exact match). Args: title (str): The title of the film to search for. Returns: list[dict]: A list of films that match the specified title. pass def find_by_year(self, year: int) -> list[dict]: Finds films released in a specific year. Args: year (int): The year of release to search for. Returns: list[dict]: A list of films released in the specified year. pass def find_by_rating(self, rating: float) -> list[dict]: Finds films with a rating equal to or higher than a specified value. Args: rating (float): The rating threshold. Returns: list[dict]: A list of films with ratings equal to or higher than the specified value. pass def search_films(films: list[dict], criteria: dict) -> list[dict]: Search films based on specific criteria. Args: films (list[dict]): A list of films, where each film is represented as a dictionary. criteria (dict): A dictionary of criteria to search films by. Returns: list[dict]: A list of films that match the given criteria. Examples: >>> films = [ ... {\\"title\\": \\"Inception\\", \\"year\\": 2010, \\"rating\\": 8.8}, ... {\\"title\\": \\"The Matrix\\", \\"year\\": 1999, \\"rating\\": 8.7}, ... {\\"title\\": \\"Interstellar\\", \\"year\\": 2014, \\"rating\\": 8.6}, ... {\\"title\\": \\"Shutter Island\\", \\"year\\": 2010, \\"rating\\": 8.1} ... ] >>> criteria = {\\"title\\": \\"Inception\\"} >>> search_films(films, criteria) [{'title': 'Inception', 'year': 2010, 'rating': 8.8}] pass","solution":"class FilmDatabase: def __init__(self): self.films = [] def add_film(self, film): self.films.append(film) def find_by_title(self, title): return [film for film in self.films if film['title'] == title] def find_by_year(self, year): return [film for film in self.films if film['year'] == year] def find_by_rating(self, rating): return [film for film in self.films if film['rating'] >= rating] def search_films(films, criteria): db = FilmDatabase() for film in films: db.add_film(film) if 'title' in criteria: return db.find_by_title(criteria['title']) elif 'year' in criteria: return db.find_by_year(criteria['year']) elif 'rating' in criteria: return db.find_by_rating(criteria['rating']) else: return db.films"},{"question":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class CustomBinarySearchTree: Implements a Binary Search Tree with methods to insert, find, delete, and get in-order string representation. Inserts a new integer into the BST. Duplicate values are not allowed; raise a \`ValueError\` for duplicates. Args: data (int): The integer to be inserted. Returns: None Deletes the specified value from the BST. Raise a \`ValueError\` if the value does not exist. Args: data (int): The integer to be deleted. Returns: None Finds if the value exists in the BST. Args: data (int): The integer to find. Returns: bool: \`True\` if found, \`False\` otherwise. def __init__(self): Initializes an empty tree. pass def insert(self, data: int): Inserts a new integer into the BST. pass def find(self, data: int) -> bool: Returns \`True\` if the value exists in the BST, \`False\` otherwise. pass def delete(self, data: int): Removes the specified value from the BST. pass def __str__(self) -> str: Returns a string representation of the tree in an in-order traversal. pass import pytest def test_insert(): bst = CustomBinarySearchTree() bst.insert(10) bst.insert(20) bst.insert(5) result = str(bst) assert result == \\"[5, 10, 20]\\" def test_insert_duplicate(): bst = CustomBinarySearchTree() bst.insert(10) with pytest.raises(ValueError): bst.insert(10) def test_find(): bst = CustomBinarySearchTree() bst.insert(10) bst.insert(20) bst.insert(5) assert bst.find(10) == True assert bst.find(5) == True assert bst.find(20) == True assert bst.find(15) == False def test_delete(): bst = CustomBinarySearchTree() bst.insert(10) bst.insert(20) bst.insert(5) bst.insert(6) bst.insert(15) bst.delete(10) assert bst.find(10) == False result = str(bst) assert result == \\"[5, 6, 15, 20]\\" def test_delete_non_existent(): bst = CustomBinarySearchTree() bst.insert(10) with pytest.raises(ValueError): bst.delete(20) def test_in_order_traversal(): bst = CustomBinarySearchTree() bst.insert(10) bst.insert(20) bst.insert(5) bst.insert(15) result = str(bst) assert result == \\"[5, 10, 15, 20]\\" def test_delete_node_with_one_child(): bst = CustomBinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(3) bst.insert(20) bst.insert(15) bst.delete(5) assert bst.find(5) == False result = str(bst) assert result == \\"[3, 10, 15, 20]\\" def test_delete_node_with_two_children(): bst = CustomBinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(20) bst.insert(7) bst.insert(3) bst.insert(15) bst.insert(25) bst.delete(5) assert bst.find(5) == False result = str(bst) assert result == \\"[3, 7, 10, 15, 20, 25]\\"","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class CustomBinarySearchTree: def __init__(self): self.root = None def insert(self, data): if self.root is None: self.root = Node(data) else: self._insert(self.root, data) def _insert(self, node, data): if data == node.data: raise ValueError(\\"Duplicate value\\") elif data < node.data: if node.left is None: node.left = Node(data) else: self._insert(node.left, data) else: # data > node.data if node.right is None: node.right = Node(data) else: self._insert(node.right, data) def find(self, data): return self._find(self.root, data) def _find(self, node, data): if node is None: return False if data == node.data: return True elif data < node.data: return self._find(node.left, data) else: # data > node.data return self._find(node.right, data) def delete(self, data): self.root = self._delete(self.root, data) def _delete(self, node, data): if node is None: raise ValueError(\\"Value not found\\") if data < node.data: node.left = self._delete(node.left, data) elif data > node.data: node.right = self._delete(node.right, data) else: # data == node.data if node.left is None: return node.right if node.right is None: return node.left temp_val = self._min_value_node(node.right) node.data = temp_val.data node.right = self._delete(node.right, temp_val.data) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def __str__(self): elements = [] self._in_order_traversal(self.root, elements) return str(elements) def _in_order_traversal(self, node, elements): if node: self._in_order_traversal(node.left, elements) elements.append(node.data) self._in_order_traversal(node.right, elements)"},{"question":"def add_item(inventory: dict, item_name: str, quantity: int) -> dict: Adds a specified quantity of an item to the inventory. Args: - inventory (dict): The player's current inventory, with item names as keys and quantities as values. - item_name (str): The name of the item to add. - quantity (int): The quantity of the item to add. Returns: - dict: The updated inventory. pass def remove_item(inventory: dict, item_name: str, quantity: int) -> dict: Removes a specified quantity of an item from the inventory. If the quantity to remove exceeds the current amount, the item is removed completely from the inventory. Args: - inventory (dict): The player's current inventory, with item names as keys and quantities as values. - item_name (str): The name of the item to remove. - quantity (int): The quantity of the item to remove. Returns: - dict: The updated inventory. pass def display_inventory(inventory: dict) -> None: Displays the current inventory in a readable format. Args: - inventory (dict): The player's current inventory, with item names as keys and quantities as values. Returns: - None: This function prints the inventory and does not return anything. pass","solution":"def add_item(inventory: dict, item_name: str, quantity: int) -> dict: Adds a specified quantity of an item to the inventory. Args: - inventory (dict): The player's current inventory, with item names as keys and quantities as values. - item_name (str): The name of the item to add. - quantity (int): The quantity of the item to add. Returns: - dict: The updated inventory. if item_name in inventory: inventory[item_name] += quantity else: inventory[item_name] = quantity return inventory def remove_item(inventory: dict, item_name: str, quantity: int) -> dict: Removes a specified quantity of an item from the inventory. If the quantity to remove exceeds the current amount, the item is removed completely from the inventory. Args: - inventory (dict): The player's current inventory, with item names as keys and quantities as values. - item_name (str): The name of the item to remove. - quantity (int): The quantity of the item to remove. Returns: - dict: The updated inventory. if item_name in inventory: if inventory[item_name] <= quantity: del inventory[item_name] else: inventory[item_name] -= quantity return inventory def display_inventory(inventory: dict) -> None: Displays the current inventory in a readable format. Args: - inventory (dict): The player's current inventory, with item names as keys and quantities as values. Returns: - None: This function prints the inventory and does not return anything. for item in sorted(inventory): print(f\\"{item}: {inventory[item]}\\")"},{"question":"def can_form_palindrome(s: str) -> bool: Checks if any permutation of the string s can form a palindrome. :param s: The input string consisting of alphabetic characters only. :return: True if any permutation of s can form a palindrome, False otherwise. :raises ValueError: If the input is not a string or is empty. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"\\") Traceback (most recent call last): ... ValueError: Input string cannot be empty >>> can_form_palindrome(\\"AbleWasiEreISawElba\\") True >>> can_form_palindrome(12345) Traceback (most recent call last): ... ValueError: Input must be a string >>> can_form_palindrome(\\"madam\\") True >>> can_form_palindrome(\\"MadAm\\") True","solution":"from collections import Counter def can_form_palindrome(s: str) -> bool: Checks if any permutation of the string s can form a palindrome. :param s: The input string consisting of alphabetic characters only. :return: True if any permutation of s can form a palindrome, False otherwise. :raises ValueError: If the input is not a string or is empty. if not isinstance(s, str): raise ValueError(\\"Input must be a string\\") if s == \\"\\": raise ValueError(\\"Input string cannot be empty\\") s = s.lower() counter = Counter(s) odd_count = sum(1 for count in counter.values() if count % 2 != 0) return odd_count <= 1"},{"question":"Prime Number Checker with Memoization Create a function to check if a given number is prime using memoization to improve efficiency. # Parameters: - \`num\` (int): The number to check for primality. - \`memo\` (dict, optional): A dictionary used to store the primality results of previous checks for memoization. # Returns: - \`True\` if the number is prime, \`False\` otherwise. # Constraints: - The function should handle cases where \`num\` is 0 or 1. - The maximum value for \`num\` is 1,000,000. - Handle any invalid input within the provided range and raise a ValueError with an appropriate message (e.g., for negative numbers or non-integer inputs). # Examples: Function signature: \`def is_prime(num: int, memo: dict = {}) -> bool\` Example 1: >>> is_prime(0) False Example 2: >>> is_prime(1) False Example 3: >>> is_prime(2) True Example 4: >>> is_prime(17) True Example 5: >>> is_prime(18) False Example 6: >>> is_prime(997) True # Unit Test: from solution import is_prime def test_is_prime(): # Testing known primes and non-primes assert is_prime(0) == False assert is_prime(1) == False assert is_prime(2) == True assert is_prime(17) == True assert is_prime(18) == False assert is_prime(997) == True # Testing edge cases assert is_prime(3) == True assert is_prime(4) == False assert is_prime(5) == True assert is_prime(6) == False # Testing memoization memo = {} assert is_prime(19, memo) == True assert memo[19] == True assert is_prime(21, memo) == False assert memo[21] == False def test_is_prime_invalid_inputs(): # Testing invalid inputs try: is_prime(-1) except ValueError as e: assert str(e) == \\"The number must be non-negative.\\" try: is_prime(2.5) except ValueError as e: assert str(e) == \\"The number must be an integer.\\"","solution":"def is_prime(num: int, memo: dict = {}) -> bool: Check if a given number is prime using memoization. Parameters: num (int): The number to check for primality. memo (dict, optional): A dictionary used to store the primality results of previous checks for memoization. Returns: bool: \`True\` if the number is prime, \`False\` otherwise. Raises: ValueError: If the input is negative or non-integer. if not isinstance(num, int): raise ValueError(\\"The number must be an integer.\\") if num < 0: raise ValueError(\\"The number must be non-negative.\\") if num in memo: return memo[num] if num < 2: memo[num] = False return False if num == 2: memo[num] = True return True if num % 2 == 0: memo[num] = False return False sqrt_num = int(num ** 0.5) + 1 for i in range(3, sqrt_num, 2): if num % i == 0: memo[num] = False return False memo[num] = True return True"},{"question":"def number_to_excel_column(n: int) -> str: Convert a given number into its corresponding Excel column name. >>> number_to_excel_column(1) 'A' >>> number_to_excel_column(28) 'AB' >>> number_to_excel_column(701) 'ZY' >>> number_to_excel_column(702) 'ZZ' >>> number_to_excel_column(703) 'AAA' >>> number_to_excel_column(2147483647) 'FXSHRXW'","solution":"def number_to_excel_column(n: int) -> str: result = [] while n > 0: n -= 1 # Decrement n because Excel columns are 1-based result.append(chr(n % 26 + ord('A'))) # Get the current letter n //= 26 # Move on to the next significant place return ''.join(result[::-1]) # Reverse the result to get the correct column name"},{"question":"from typing import List def rotate_90(matrix: List[List[int]]) -> List[List[int]]: Rotates a given n x n matrix by 90 degrees clockwise. pass def can_rotate_to_match(mat1: List[List[int]], mat2: List[List[int]]) -> bool: Determines if mat1 can be rotated to match mat2 (by 0, 90, 180, or 270 degrees). pass def test_rotate_90(): mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated_90 = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_90(mat) == rotated_90 mat = [ [1, 2], [3, 4] ] rotated_90 = [ [3, 1], [4, 2] ] assert rotate_90(mat) == rotated_90 def test_can_rotate_to_match(): mat1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] mat2 = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert can_rotate_to_match(mat1, mat2) == True mat1 = [ [1, 2], [3, 4] ] mat2 = [ [2, 4], [1, 3] ] assert can_rotate_to_match(mat1, mat2) == True mat1 = [ [1, 2], [3, 4] ] mat2 = [ [2, 1], [4, 3] ] assert can_rotate_to_match(mat1, mat2) == False mat1 = [ [1] ] mat2 = [ [1] ] assert can_rotate_to_match(mat1, mat2) == True mat1 = [ [1] ] mat2 = [ [0] ] assert can_rotate_to_match(mat1, mat2) == False mat1 = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] mat2 = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert can_rotate_to_match(mat1, mat2) == True","solution":"from typing import List def rotate_90(matrix: List[List[int]]) -> List[List[int]]: Rotates a given n x n matrix by 90 degrees clockwise. return [list(row)[::-1] for row in zip(*matrix)] def can_rotate_to_match(mat1: List[List[int]], mat2: List[List[int]]) -> bool: Determines if mat1 can be rotated to match mat2 (by 0, 90, 180, or 270 degrees). for _ in range(4): if mat1 == mat2: return True mat1 = rotate_90(mat1) return False"},{"question":"from typing import List, Tuple def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Finds the shortest path from a starting point to an ending point in a grid with obstacles. Parameters: grid (List[List[int]]): A 2D list representing the grid where 0 indicates a free cell and 1 indicates an obstacle. start (Tuple[int, int]): A tuple (x, y) representing the starting point in the grid. end (Tuple[int, int]): A tuple (x, y) representing the ending point in the grid. Returns: int: The length of the shortest path as an integer. Returns -1 if no path exists. Examples: >>> grid = [ >>> [0, 1, 0, 0, 0], >>> [0, 1, 0, 1, 0], >>> [0, 0, 0, 1, 0], >>> [0, 1, 1, 1, 0], >>> [0, 0, 0, 0, 0] >>> ] >>> start = (0, 0) >>> end = (4, 4) >>> shortest_path(grid, start, end) 10 >>> grid = [ >>> [0, 1, 0], >>> [0, 1, 0], >>> [0, 0, 0] >>> ] >>> start = (0, 0) >>> end = (2, 2) >>> shortest_path(grid, start, end) 4","solution":"from typing import List, Tuple from collections import deque def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] == 0 queue = deque([(start[0], start[1], 0)]) visited = set() visited.add(start) while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def compute_final_balances(file_path: str) -> dict: Compute the final balance of each user after processing all transactions. The transactions are recorded in a file where each line is in the format 'sender,receiver,amount'. Example: Given a file 'transactions.txt' containing: alice,bob,100 bob,charlie,200 alice,charlie,50 Calling compute_final_balances('transactions.txt') should return: {'alice': -150, 'bob': -100, 'charlie': 250} # Implementation here import pytest def test_compute_final_balances_simple(): with open('transactions_simple.txt', 'w') as f: f.write(\\"alice,bob,100nbob,charlie,200nalice,charlie,50n\\") expected = {'alice': -150, 'bob': -100, 'charlie': 250} assert compute_final_balances('transactions_simple.txt') == expected def test_compute_final_balances_empty_file(): with open('transactions_empty.txt', 'w') as f: pass expected = {} assert compute_final_balances('transactions_empty.txt') == expected def test_compute_final_balances_single_transaction(): with open('transactions_single.txt', 'w') as f: f.write(\\"alice,bob,100n\\") expected = {'alice': -100, 'bob': 100} assert compute_final_balances('transactions_single.txt') == expected def test_compute_final_balances_large_amounts(): with open('transactions_large.txt', 'w') as f: f.write(\\"alice,bob,1000000000nbob,charlie,500000000n\\") expected = {'alice': -1000000000, 'bob': 500000000, 'charlie': 500000000} assert compute_final_balances('transactions_large.txt') == expected def test_compute_final_balances_multiple_same_user(): with open('transactions_multiple.txt', 'w') as f: f.write(\\"alice,bob,100nalice,bob,200n\\") expected = {'alice': -300, 'bob': 300} assert compute_final_balances('transactions_multiple.txt') == expected","solution":"def compute_final_balances(file_path: str) -> dict: from collections import defaultdict balances = defaultdict(int) with open(file_path, 'r') as file: for line in file: sender, receiver, amount = line.strip().split(',') amount = int(amount) balances[sender] -= amount balances[receiver] += amount return dict(balances)"},{"question":"from typing import List def calculate_score(answers: List[str], student_responses: List[str]) -> int: Calculate the score of a student's responses based on correct answers. Parameters: answers (List[str]): The correct answers. student_responses (List[str]): The student's responses. Returns: int: The score based on the number of correct answers. Examples: >>> calculate_score(['A', 'B', 'C'], ['A', 'B', 'C']) 3 >>> calculate_score(['A', 'B', 'C', 'D'], ['A', 'C', 'C', 'D']) 3 >>> calculate_score(['A', 'B', 'C'], ['B', 'A', 'D']) 0 >>> calculate_score([], []) 0 >>> calculate_score(['A'], ['A']) 1 >>> calculate_score(['A'], ['B']) 0","solution":"from typing import List def calculate_score(answers: List[str], student_responses: List[str]) -> int: Calculate the score of a student's responses based on correct answers. Parameters: answers (List[str]): The correct answers. student_responses (List[str]): The student's responses. Returns: int: The score based on the number of correct answers. return sum(1 for a, s in zip(answers, student_responses) if a == s)"},{"question":"from typing import List def calculate_final_grade(assignments: List[float], project: float, exams: List[float]) -> str: Compute and return the final grade based on weighted average calculations for assignments, project, and exams scores. >>> calculate_final_grade([85, 90, 93], 88, [76, 82]) 'B' >>> calculate_final_grade([70, 75, 80], 72, [68, 74]) 'C' >>> calculate_final_grade([100, 100], 100, [100]) 'A' >>> calculate_final_grade([50, 60], 55, [45, 50]) 'F' >>> calculate_final_grade([], 85, [75, 80]) Traceback (most recent call last): ... ValueError: Each of assignments and exams must contain at least one score. >>> calculate_final_grade([105], 85, [75]) Traceback (most recent call last): ... ValueError: Scores must be between 0 and 100.","solution":"from typing import List def calculate_final_grade(assignments: List[float], project: float, exams: List[float]) -> str: Compute and return the final grade based on weighted average calculations for assignments, project, and exams scores. # Validate inputs if not assignments or not exams: raise ValueError(\\"Each of assignments and exams must contain at least one score.\\") if any(not (0 <= score <= 100) for score in assignments + [project] + exams): raise ValueError(\\"Scores must be between 0 and 100.\\") # Calculate weighted average assignment_score = sum(assignments) / len(assignments) exam_score = sum(exams) / len(exams) final_score = (0.4 * assignment_score) + (0.3 * project) + (0.3 * exam_score) # Determine final grade if final_score >= 90: return 'A' elif final_score >= 80: return 'B' elif final_score >= 70: return 'C' elif final_score >= 60: return 'D' else: return 'F'"},{"question":"from typing import List def merge_sorted_versions(files: List[List[int]], v: int) -> bool: Implement a function \`merge_sorted_versions\` which takes as input a list of lists where each inner list contains version numbers of a file, and an integer \`v\`. Each list represents the versions of a different file. You need to merge these lists and check if the version \`v\` exists in the merged list. >>> merge_sorted_versions([[1, 3, 5], [2, 4, 6], [7, 8, 9]], 4) True >>> merge_sorted_versions([[10, 20, 30], [5, 9, 15], [3, 7, 13]], 8) False # Your implementation here pass # Unit Tests def test_merge_sorted_versions_found(): files = [ [1, 3, 5], [2, 4, 6], [7, 8, 9] ] v = 4 assert merge_sorted_versions(files, v) == True def test_merge_sorted_versions_not_found(): files = [ [10, 20, 30], [5, 9, 15], [3, 7, 13] ] v = 8 assert merge_sorted_versions(files, v) == False def test_merge_sorted_versions_single_list_found(): files = [ [1, 2, 3] ] v = 2 assert merge_sorted_versions(files, v) == True def test_merge_sorted_versions_empty_list(): files = [ [] ] v = 1 assert merge_sorted_versions(files, v) == False def test_merge_sorted_versions_multiple_lists(): files = [ [1, 3, 5], [2, 4, 6, 8], [7, 10, 12], [9, 11] ] v = 10 assert merge_sorted_versions(files, v) == True def test_merge_sorted_versions_large_numbers(): files = [ [100, 200, 300], [150, 250, 350], [120, 220, 320] ] v = 250 assert merge_sorted_versions(files, v) == True","solution":"from typing import List def merge_sorted_versions(files: List[List[int]], v: int) -> bool: from heapq import merge # Use heapq.merge to merge sorted lists efficiently merged_list = list(merge(*files)) # Perform binary search to check if \`v\` exists in the merged list left, right = 0, len(merged_list) - 1 while left <= right: mid = (left + right) // 2 if merged_list[mid] == v: return True elif merged_list[mid] < v: left = mid + 1 else: right = mid - 1 return False"},{"question":"def list_directory_paths(directory, current_path=\\"\\", current_depth=0): Generates a list of file paths with their corresponding depths in a directory structure. Args: - directory (dict): The directory structure represented as a nested dictionary. - current_path (str): The current path being traversed. Default is an empty string. - current_depth (int): The depth in the directory hierarchy. Default is 0. Returns: - list of tuples: Each tuple contains a file path (str) and its corresponding depth (int). >>> directory = { ... \\"folderA\\": [\\"file1.txt\\", \\"file2.txt\\"], ... \\"folderB\\": { ... \\"subfolderB1\\": [\\"file3.txt\\"], ... \\"subfolderB2\\": [\\"file4.txt\\", \\"file5.txt\\"] ... } ... } >>> list_directory_paths(directory) [('folderA/file1.txt', 1), ('folderA/file2.txt', 1), ('folderB/subfolderB1/file3.txt', 2), ('folderB/subfolderB2/file4.txt', 2), ('folderB/subfolderB2/file5.txt', 2)]","solution":"def list_directory_paths(directory, current_path=\\"\\", current_depth=0): Generates a list of file paths with their corresponding depths in a directory structure. Args: - directory (dict): The directory structure represented as a nested dictionary. - current_path (str): The current path being traversed. Default is an empty string. - current_depth (int): The depth in the directory hierarchy. Default is 0. Returns: - list of tuples: Each tuple contains a file path (str) and its corresponding depth (int). paths = [] for key, value in directory.items(): if isinstance(value, list): for file in value: paths.append((f\\"{current_path}/{key}/{file}\\".strip('/'), current_depth + 1)) elif isinstance(value, dict): paths.extend(list_directory_paths(value, f\\"{current_path}/{key}\\".strip('/'), current_depth + 1)) return paths"},{"question":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: Find the path from the top-left corner to the bottom-right corner which has the minimum sum of values. Args: - grid (List[List[int]]): A 2D grid of non-negative integers. Returns: - int: The minimum sum of values from the top-left to the bottom-right corner. >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> min_path_sum(grid) 7","solution":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize the first column for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[n - 1][m - 1]"},{"question":"def can_form_palindrome(s: str, n: int) -> bool: Determine if a string can be rearranged to form a palindrome with character repetitions allowed up to \`n\` times. :param s: The input string :param n: Maximum repetitions allowed for any character :return: Boolean indicating if the string can form a palindrome >>> can_form_palindrome(\\"aabb\\", 0) True >>> can_form_palindrome(\\"abc\\", 1) False >>> can_form_palindrome(\\"aaabbb\\", 1) True >>> can_form_palindrome(\\"abcdcba\\", 2) True >>> can_form_palindrome(\\"a\\", 0) True pass","solution":"def can_form_palindrome(s: str, n: int) -> bool: Determine if a string can be rearranged to form a palindrome with character repetitions allowed up to \`n\` times. :param s: The input string :param n: Maximum repetitions allowed for any character :return: Boolean indicating if the string can form a palindrome >>> can_form_palindrome(\\"aabb\\", 0) True >>> can_form_palindrome(\\"abc\\", 1) False >>> can_form_palindrome(\\"aaabbb\\", 1) True >>> can_form_palindrome(\\"abcdcba\\", 2) True >>> can_form_palindrome(\\"a\\", 0) True from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A palindrome can have at most one character with an odd count if odd_count <= 1: return True # If there are more characters with odd counts than n can cover if odd_count - 1 <= n: return True return False"},{"question":"class LibraryError(Exception): Custom exception for library-related errors. pass def add_new_user(user_data: dict) -> str: Adds a new user to the system. :param user_data: dict, A dictionary containing 'user_id', 'name', and 'email'. :return: str, Confirmation message. Raises LibraryError for duplicate users and invalid data. def borrow_book(user_id: str, book_id: str, due_date: str) -> str: Allows a user to borrow a book. :param user_id: str, The ID of the user borrowing the book. :param book_id: str, The ID of the book being borrowed. :param due_date: str, The due date for returning the book in 'YYYY-MM-DD'. :return: str, Confirmation message. Raises LibraryError if the book is already borrowed, the user does not exist, or invalid data is supplied.","solution":"import datetime # Data storage users_db = {} books_db = {} class LibraryError(Exception): Custom exception for library-related errors. pass def validate_user_data(user_data): if not isinstance(user_data, dict): raise LibraryError(\\"Invalid user data format\\") required_keys = {'user_id', 'name', 'email'} if not required_keys.issubset(user_data.keys()): raise LibraryError(\\"Missing required user data fields\\") def add_new_user(user_data): Adds a new user to the system. :param user_data: dict, A dictionary containing 'user_id', 'name', and 'email'. :return: str, Confirmation message. validate_user_data(user_data) user_id = user_data['user_id'] email = user_data['email'] if user_id in users_db: raise LibraryError(f\\"User ID {user_id} already exists.\\") if any(user['email'] == email for user in users_db.values()): raise LibraryError(f\\"Email {email} already exists.\\") users_db[user_id] = { 'name': user_data['name'], 'email': user_data['email'], 'borrowed_books': [] } return f\\"User {user_data['name']} added successfully\\" def validate_date(date_str): Validates the date format and returns a datetime object try: return datetime.datetime.strptime(date_str, '%Y-%m-%d') except ValueError: raise LibraryError(\\"Invalid date format, should be YYYY-MM-DD\\") def borrow_book(user_id, book_id, due_date): Allows a user to borrow a book. :param user_id: str, The ID of the user borrowing the book. :param book_id: str, The ID of the book being borrowed. :param due_date: str, The due date for returning the book in 'YYYY-MM-DD'. :return: str, Confirmation message. if user_id not in users_db: raise LibraryError(f\\"User ID {user_id} does not exist.\\") if book_id in books_db and books_db[book_id]['borrowed_by'] is not None: raise LibraryError(f\\"Book ID {book_id} is already borrowed.\\") due_date_obj = validate_date(due_date) if due_date_obj < datetime.datetime.now(): raise LibraryError(\\"Due date cannot be in the past.\\") books_db[book_id] = { 'borrowed_by': user_id, 'due_date': due_date_obj } users_db[user_id]['borrowed_books'].append(book_id) return f\\"Book {book_id} borrowed by user {user_id}, due on {due_date}\\""},{"question":"def mode(numbers): Returns the mode (most frequent number) of a list of integers. If there are multiple modes, return the smallest one. If the list is empty, return None. >>> mode([1, 2, 3, 2, 4, 2, 5, 3, 3]) 2 >>> mode([]) None >>> mode([1]) 1 >>> mode([1, 1, 2, 2, 3, 3]) 1 >>> mode([4, 4, 2, 5, 5, 2, 1]) 2 pass def reverse_sublist(lst, start, end): Reverses the sublist from start to end (inclusive). If start or end is out of bounds, raise an IndexError. >>> reverse_sublist([1, 2, 3, 4, 5], 1, 3) [1, 4, 3, 2, 5] >>> reverse_sublist([1], 0, 0) [1] >>> reverse_sublist([1, 2, 3], 0, 2) [3, 2, 1] >>> try: ... reverse_sublist([1, 2, 3], -1, 2) ... except IndexError: ... pass >>> try: ... reverse_sublist([1, 2, 3], 1, 4) ... except IndexError: ... pass >>> try: ... reverse_sublist([1, 2, 3], 3, 3) ... except IndexError: ... pass pass def largest_sum_subarray(lst): Returns the sum of the contiguous subarray with the largest sum. Uses Kadane's algorithm for optimal performance. >>> largest_sum_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> largest_sum_subarray([1, 2, 3, 4, 5]) 15 >>> largest_sum_subarray([-1, -2, -3, -4, -5]) -1 >>> largest_sum_subarray([]) 0 >>> largest_sum_subarray([-2, -3, 4, -1, -2, 1, 5, -3]) 7 pass","solution":"def mode(numbers): Returns the mode (most frequent number) of a list of integers. If there are multiple modes, return the smallest one. If the list is empty, return None. if not numbers: return None from collections import Counter freq = Counter(numbers) max_freq = max(freq.values()) # Get all numbers with the highest frequency modes = [num for num, count in freq.items() if count == max_freq] return min(modes) def reverse_sublist(lst, start, end): Reverses the sublist from start to end (inclusive). If start or end is out of bounds, raise an IndexError. if start < 0 or end >= len(lst) or start > end: raise IndexError(\\"start or end index out of bounds.\\") lst[start:end+1] = lst[start:end+1][::-1] return lst def largest_sum_subarray(lst): Returns the sum of the contiguous subarray with the largest sum. Uses Kadane's algorithm for optimal performance. if not lst: return 0 max_current = max_global = lst[0] for num in lst[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List, Dict def summarize_orders(orders: List[Dict[str, int]]) -> Dict[str, int]: Aggregates orders from multiple tables into a single dictionary that contains the total count of each item ordered. Example: >>> summarize_orders([ ... {\\"burger\\": 2, \\"fries\\": 1, \\"soda\\": 3}, ... {\\"pizza\\": 1, \\"burger\\": 1, \\"fries\\": 2}, ... {\\"soda\\": 2, \\"pizza\\": 3} ... ]) {'burger': 3, 'fries': 3, 'soda': 5, 'pizza': 4} >>> summarize_orders([ ... {\\"steak\\": 1, \\"salad\\": 2}, ... {\\"salad\\": 1, \\"water\\": 3}, ... {\\"steak\\": 2, \\"water\\": 2, \\"burger\\": 1} ... ]) {'burger': 1, 'salad': 3, 'steak': 3, 'water': 5} >>> summarize_orders([ ... {\\"pasta\\": 1}, ... ]) {'pasta': 1}","solution":"from typing import List, Dict def summarize_orders(orders: List[Dict[str, int]]) -> Dict[str, int]: Aggregates orders from multiple tables into a single dictionary that contains the total count of each item ordered. summary = {} for table_order in orders: for item, count in table_order.items(): if item in summary: summary[item] += count else: summary[item] = count return dict(sorted(summary.items()))"},{"question":"from collections import deque from typing import List def max_sliding_window(nums: List[int], k: int) -> List[int]: Computes the maximum values in each sliding window of size k in the given list of integers. Args: nums: List of integers. k: Size of the sliding window. Returns: A list of integers representing the maximum values in each sliding window position. Example: >>> max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3) [3, 3, 5, 5, 6, 7] >>> max_sliding_window([9, 11], 2) [11] >>> max_sliding_window([4, -2], 1) [4, -2] def test_sliding_window_case1(): assert max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3) == [3, 3, 5, 5, 6, 7] def test_sliding_window_case2(): assert max_sliding_window([9, 11], 2) == [11] def test_sliding_window_case3(): assert max_sliding_window([4, -2], 1) == [4, -2] def test_sliding_window_single_element(): assert max_sliding_window([1], 1) == [1] def test_sliding_window_large_k(): assert max_sliding_window([1, 2, 3, 4, 5], 5) == [5] def test_sliding_window_k_equals_length(): assert max_sliding_window([2, 1, 4, 5, 3], 5) == [5] def test_sliding_window_empty_list(): assert max_sliding_window([], 3) == [] def test_sliding_window_extra_large_values(): assert max_sliding_window([1000, 1001, 1002, 1003, 1004], 2) == [1001, 1002, 1003, 1004] def test_sliding_window_negatives(): assert max_sliding_window([-1, -3, -5, -7], 2) == [-1, -3, -5]","solution":"from collections import deque from typing import List def max_sliding_window(nums: List[int], k: int) -> List[int]: if not nums or k == 0: return [] # Initialize a deque to store indices deq = deque() max_vals = [] for i in range(len(nums)): # Remove elements not within the sliding window if deq and deq[0] < i - k + 1: deq.popleft() # Remove all elements which are less than nums[i] from the deque while deq and nums[deq[-1]] < nums[i]: deq.pop() # Add the current element index to the deque deq.append(i) # Append the maximum for the current window to the results list if i >= k - 1: max_vals.append(nums[deq[0]]) return max_vals"},{"question":"def first_non_repeating_character(s: str) -> int: Finds the index of the first non-repeating character in a string. >>> first_non_repeating_character(\\"leetcode\\") == 0 >>> first_non_repeating_character(\\"loveleetcode\\") == 2 >>> first_non_repeating_character(\\"aabbcc\\") == -1 >>> first_non_repeating_character(\\"abcd\\") == 0 >>> first_non_repeating_character(\\"zzyyxx\\") == -1","solution":"def first_non_repeating_character(s: str) -> int: Finds the index of the first non-repeating character in a string. If there is no non-repeating character, returns -1. # Dictionary to store character count char_count = {} # First pass to store count of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass to find the first non-repeating character for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"from typing import Callable def trapezoidal_rule(func: Callable[[float], float], start: float, end: float, n: int) -> float: Estimates the definite integral of a function using the composite trapezoidal rule. :param func: Callable, the function to integrate, expressed as f(x) :param start: float, the starting value of the interval over which to integrate :param end: float, the ending value of the interval over which to integrate :param n: int, the number of equally spaced subintervals to use for the trapezoidal rule :return: float, the estimated value of the definite integral of f(x) over the interval [start, end] >>> def f(x): ... return x**2 >>> trapezoidal_rule(f, 0, 1, 4) 0.34375 >>> def f(x): ... return 2 * x + 3 >>> trapezoidal_rule(f, 1, 3, 100) 14.0","solution":"from typing import Callable def trapezoidal_rule(func: Callable[[float], float], start: float, end: float, n: int) -> float: Estimates the definite integral of a function using the composite trapezoidal rule. :param func: Callable, the function to integrate, expressed as f(x) :param start: float, the starting value of the interval over which to integrate :param end: float, the ending value of the interval over which to integrate :param n: int, the number of equally spaced subintervals to use for the trapezoidal rule :return: float, the estimated value of the definite integral of f(x) over the interval [start, end] # Validate inputs if start >= end: raise ValueError(\\"The start of the interval must be less than the end.\\") if n <= 0: raise ValueError(\\"The number of subintervals must be a positive integer.\\") # Compute the width of each subinterval h = (end - start) / n # Initialize the sum integral_sum = 0.5 * (func(start) + func(end)) # Sum up the area of each trapezoid for i in range(1, n): x_i = start + i * h integral_sum += func(x_i) # Multiply by the width to get the total integral integral_sum *= h return integral_sum"},{"question":"def arrange_seating(heights: List[int]) -> List[int]: Arranges the list of students' heights in non-decreasing order from back to front. Parameters: heights (List[int]): A list of students' heights. Returns: List[int]: A new list representing the seating arrangement from back to front in non-decreasing order. Examples: >>> arrange_seating([160, 150, 170, 145, 155]) == [170, 160, 155, 150, 145] >>> arrange_seating([120, 110, 130, 125, 115]) == [130, 125, 120, 115, 110]","solution":"def arrange_seating(heights): Arranges the list of students' heights in non-decreasing order from back to front. Parameters: heights (List[int]): A list of students' heights. Returns: List[int]: A new list representing the seating arrangement from back to front in non-decreasing order. # Sorting the list in descending order to represent from back to front return sorted(heights, reverse=True)"},{"question":"class AttendanceTracker: A class to track employee attendance. >>> tracker = AttendanceTracker() >>> tracker.add_employee(\\"John Doe\\") 'Employee added successfully' >>> tracker.add_employee(\\"Jane Smith\\") 'Employee added successfully' >>> tracker.add_employee(\\"John Doe\\") 'Employee already exists' >>> tracker.mark_attendance(\\"John Doe\\") 'Attendance marked successfully' >>> tracker.mark_attendance(\\"John Doe\\") 'Attendance already marked' >>> tracker.mark_attendance(\\"Jane Doe\\") 'Employee not found' >>> tracker.attendance_report() ['John Doe Present', 'Jane Smith Absent'] def add_employee(self, name: str) -> str: pass def mark_attendance(self, name: str) -> str: pass def attendance_report(self) -> list: pass def test_add_employee(): tracker = AttendanceTracker() assert tracker.add_employee(\\"John Doe\\") == \\"Employee added successfully\\" assert tracker.add_employee(\\"Jane Smith\\") == \\"Employee added successfully\\" assert tracker.add_employee(\\"John Doe\\") == \\"Employee already exists\\" def test_mark_attendance(): tracker = AttendanceTracker() tracker.add_employee(\\"John Doe\\") tracker.add_employee(\\"Jane Smith\\") assert tracker.mark_attendance(\\"John Doe\\") == \\"Attendance marked successfully\\" assert tracker.mark_attendance(\\"John Doe\\") == \\"Attendance already marked\\" assert tracker.mark_attendance(\\"Jane Doe\\") == \\"Employee not found\\" assert tracker.mark_attendance(\\"Jane Smith\\") == \\"Attendance marked successfully\\" def test_attendance_report(): tracker = AttendanceTracker() tracker.add_employee(\\"John Doe\\") tracker.add_employee(\\"Jane Smith\\") tracker.mark_attendance(\\"John Doe\\") report = tracker.attendance_report() assert \\"John Doe Present\\" in report assert \\"Jane Smith Absent\\" in report def test_empty_attendance_report(): tracker = AttendanceTracker() report = tracker.attendance_report() assert report == [] def test_multiple_days_reset(): tracker = AttendanceTracker() tracker.add_employee(\\"John Doe\\") # Day 1: Mark attendance assert tracker.mark_attendance(\\"John Doe\\") == \\"Attendance marked successfully\\" assert tracker.attendance_report() == [\\"John Doe Present\\"] # Simulate reset for a new day (reinitialize the tracker) tracker = AttendanceTracker() tracker.add_employee(\\"John Doe\\") assert tracker.attendance_report() == [\\"John Doe Absent\\"]","solution":"class AttendanceTracker: def __init__(self): self.employees = {} def add_employee(self, name: str) -> str: if name in self.employees: return \\"Employee already exists\\" else: self.employees[name] = False return \\"Employee added successfully\\" def mark_attendance(self, name: str) -> str: if name not in self.employees: return \\"Employee not found\\" elif self.employees[name]: return \\"Attendance already marked\\" else: self.employees[name] = True return \\"Attendance marked successfully\\" def attendance_report(self) -> list: report = [] for name, attended in self.employees.items(): status = \\"Present\\" if attended else \\"Absent\\" report.append(f\\"{name} {status}\\") return report"},{"question":"def staircase_ways(n: int) -> int: Calculate the number of distinct ways to reach the top of a staircase with n steps, taking 1, 2, or 3 steps at a time. :param n: The total number of steps in the staircase. :return: The number of distinct ways to reach the top. >>> staircase_ways(0) == 1 >>> staircase_ways(1) == 1 >>> staircase_ways(2) == 2 >>> staircase_ways(3) == 4 >>> staircase_ways(4) == 7 >>> staircase_ways(5) == 13 >>> staircase_ways(30) == 53798080","solution":"def staircase_ways(n): Calculate the number of distinct ways to reach the top of a staircase with n steps, taking 1, 2, or 3 steps at a time. :param n: The total number of steps in the staircase. :return: The number of distinct ways to reach the top. if n == 0: return 1 elif n == 1: return 1 elif n == 2: return 2 # Initialize an array to store results of subproblems dp = [0] * (n + 1) # Base cases dp[0] = 1 dp[1] = 1 dp[2] = 2 # Fill the dp array in bottom-up fashion for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] return dp[n]"},{"question":"def check_temperature_readings(readings: list[int], min_temp: int, max_temp: int) -> list[int]: Identify out-of-range temperature readings. :param readings: List of temperature readings as integers. :param min_temp: Minimum acceptable temperature. :param max_temp: Maximum acceptable temperature. :return: List of indices where readings are out of the specified range. :raises ValueError: If min_temp is greater than max_temp. >>> check_temperature_readings([15, 30, 25, 40, 10], 20, 35) [0, 3, 4] >>> check_temperature_readings([22, 25, 28, 33, 30], 20, 30) [3] >>> check_temperature_readings([10, 20, 30, 25, 23], 10, 30) [] >>> check_temperature_readings([25, 15, 14, 22, 35], 10, 34) [4] >>> check_temperature_readings([15, 20, 25], 25, 20) Traceback (most recent call last): ... ValueError: min_temp must be less than or equal to max_temp","solution":"def check_temperature_readings(readings: list[int], min_temp: int, max_temp: int) -> list[int]: Identify out-of-range temperature readings. :param readings: List of temperature readings as integers. :param min_temp: Minimum acceptable temperature. :param max_temp: Maximum acceptable temperature. :return: List of indices where readings are out of the specified range. :raises ValueError: If min_temp is greater than max_temp. if min_temp > max_temp: raise ValueError(\\"min_temp must be less than or equal to max_temp\\") out_of_range_indices = [] for i, reading in enumerate(readings): if reading < min_temp or reading > max_temp: out_of_range_indices.append(i) return out_of_range_indices"},{"question":"def longest_consecutive_sequence(arr: list[int]) -> int: Find the length of the longest consecutive elements sequence in an unsorted list of integers. Args: arr (list[int]): An array of integers where we need to find the longest consecutive sequence. Returns: int: The length of the longest consecutive elements sequence. Examples: >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([0, 0, 1, -1, -2, 2]) 5 >>> longest_consecutive_sequence([9, 1, 4, 7, 3, -1, 0, 5, 8, -1, 6]) 7 >>> longest_consecutive_sequence([]) 0","solution":"def longest_consecutive_sequence(arr: list[int]) -> int: if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in num_set: # Only check for the start of the sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def group_domains(domains: list[str]) -> dict[str, list[str]]: Groups a list of domain names by their top-level domains (TLDs). Parameters: domains (list of str): List of domain names. Returns: dict of str: list of str: Dictionary where keys are TLDs and values are lists of associated domains. Examples: >>> group_domains([\\"example.com\\", \\"test.org\\", \\"website.net\\", \\"example.org\\", \\"example.net\\"]) {'com': ['example.com'], 'org': ['test.org', 'example.org'], 'net': ['website.net', 'example.net']} >>> group_domains([\\"hello.world\\", \\"another.world\\", \\"example.com\\"]) {'world': ['hello.world', 'another.world'], 'com': ['example.com']} >>> group_domains([\\"my.website\\", \\"another.website\\", \\"new.site\\"]) {'website': ['my.website', 'another.website'], 'site': ['new.site']} >>> group_domains([]) {}","solution":"def group_domains(domains: list[str]) -> dict[str, list[str]]: Groups a list of domain names by their top-level domains (TLDs). Parameters: domains (list of str): List of domain names. Returns: dict of str: list of str: Dictionary where keys are TLDs and values are lists of associated domains. grouped_domains = {} for domain in domains: # Split the domain by the last '.' to get the TLD tld = domain.split('.')[-1] # If the TLD is not in the dictionary, add it with an empty list if tld not in grouped_domains: grouped_domains[tld] = [] # Append the domain to the appropriate TLD list grouped_domains[tld].append(domain) return grouped_domains"},{"question":"def product_except_self(nums: list[int]) -> list[int]: Given a list of integers, calculate the product of all elements in the list except for the current element without using the division operation. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24]","solution":"def product_except_self(nums: list[int]) -> list[int]: n = len(nums) # Initialize the arrays to store the product of all the elements to the left and right left_products = [1] * n right_products = [1] * n # Fill left_products from left to right for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Fill right_products from right to left for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Now multiply left_products and right_products to get the result result = [1] * n for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"class ListNode: def __init__(self, value=0, next=None, prev=None): self.value = value self.next = next self.prev = prev def reverse_doubly_linked_list(head: ListNode) -> ListNode: Reverses a doubly linked list in place and returns the new head of the list. >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(3) >>> node4 = ListNode(4) >>> node1.next = node2 >>> node2.prev = node1 >>> node2.next = node3 >>> node3.prev = node2 >>> node3.next = node4 >>> node4.prev = node3 >>> new_head = reverse_doubly_linked_list(node1) >>> new_head.value 4 >>> new_head.next.value 3 >>> new_head.next.next.value 2 >>> new_head.next.next.next.value 1 >>> reverse_doubly_linked_list(None) is None True >>> single_node = ListNode(1) >>> new_head = reverse_doubly_linked_list(single_node) >>> new_head.value 1 >>> new_head.next is None True >>> new_head.prev is None True >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node1.next = node2 >>> node2.prev = node1 >>> new_head = reverse_doubly_linked_list(node1) >>> new_head.value 2 >>> new_head.next.value 1 >>> new_head.next.next is None True pass","solution":"class ListNode: def __init__(self, value=0, next=None, prev=None): self.value = value self.next = next self.prev = prev def reverse_doubly_linked_list(head: ListNode) -> ListNode: Reverses a doubly linked list in place and returns the new head of the list. if not head: return None current = head new_head = None while current: # Swap the next and prev pointers temp = current.next current.next = current.prev current.prev = temp # Update the new_head to the current node new_head = current # Move to the next node in the original list current = temp return new_head"},{"question":"import random import string def generate_unique_order_id(timestamp: int) -> str: Generates a unique order ID based on a Unix timestamp and a random alphanumeric suffix. Args: timestamp: An integer representing a Unix timestamp. Returns: A string that combines the timestamp and a 5 character long random alphanumeric suffix. Raises: ValueError: If the input is not a valid Unix timestamp. >>> generate_unique_order_id(1633072800).startswith(\\"1633072800\\") True >>> len(generate_unique_order_id(1633072800)) == 15 True >>> generate_unique_order_id(-1633072800) Traceback (most recent call last): ... ValueError: Input must be a valid Unix timestamp >>> generate_unique_order_id(\\"notatimestamp\\") Traceback (most recent call last): ... ValueError: Input must be a valid Unix timestamp >>> generate_unique_order_id(1625097600.123) Traceback (most recent call last): ... ValueError: Input must be a valid Unix timestamp ...","solution":"import random import string def generate_unique_order_id(timestamp: int) -> str: Generates a unique order ID based on a Unix timestamp and a random alphanumeric suffix. Args: timestamp: An integer representing a Unix timestamp. Returns: A string that combines the timestamp and a 5 character long random alphanumeric suffix. Raises: ValueError: If the input is not a valid Unix timestamp. if not isinstance(timestamp, int) or timestamp < 0: raise ValueError(\\"Input must be a valid Unix timestamp\\") suffix = ''.join(random.choices(string.ascii_uppercase + string.digits, k=5)) return f\\"{timestamp}{suffix}\\""},{"question":"def largest_number_smaller_than_x(arr: List[int], X: int) -> int: ''' Returns the largest number in arr that is smaller than X. Args: arr: List[int]: a list of integers. X: int: the target value. Returns: int: The largest number in the list less than X or -1 if no such number exists. ''' max_num = -1 for num in arr: if num < X: max_num = max(max_num, num) return max_num","solution":"from typing import List def largest_number_smaller_than_x(arr: List[int], X: int) -> int: Returns the largest number in arr that is smaller than X. Args: arr: List[int]: a list of integers. X: int: the target value. Returns: int: The largest number in the list less than \`X\` or -1 if no such number exists. max_num = -1 for num in arr: if num < X: max_num = max(max_num, num) return max_num"},{"question":"from typing import List, Tuple def analyze_scores(scores: List[int]) -> Tuple[int, int, float]: Analyzes the scores of students and returns the highest, lowest, and average score. Args: scores (List[int]): A list of integers representing the scores of students. Returns: Tuple[int, int, float]: A tuple containing the highest score, lowest score, and the average score rounded to two decimal places. Examples: >>> analyze_scores([85, 90, 78, 92, 88, 76]) (92, 76, 84.83) >>> analyze_scores([50, 50, 50, 50]) (50, 50, 50.00) >>> analyze_scores([95]) (95, 95, 95.00)","solution":"from typing import List, Tuple def analyze_scores(scores: List[int]) -> Tuple[int, int, float]: Analyzes the scores of students and returns the highest, lowest, and average score. Args: scores (List[int]): A list of integers representing the scores of students. Returns: Tuple[int, int, float]: A tuple containing the highest score, lowest score, and the average score rounded to two decimal places. highest_score = max(scores) lowest_score = min(scores) average_score = round(sum(scores) / len(scores), 2) return highest_score, lowest_score, average_score"},{"question":"def encode_caesar_cipher(text: str, shift: int) -> str: Encode a plain text message using Caesar cipher. >>> encode_caesar_cipher(\\"Hello, World!\\", 3) \\"Khoor, Zruog!\\" >>> encode_caesar_cipher(\\"abcXYZ\\", 2) \\"cdeZAB\\" pass # replace with your implementation def decode_caesar_cipher(encoded_text: str, shift: int) -> str: Decode an encoded message using Caesar cipher. >>> decode_caesar_cipher(\\"Khoor, Zruog!\\", 3) \\"Hello, World!\\" >>> decode_caesar_cipher(\\"cdeZAB\\", 2) \\"abcXYZ\\" pass # replace with your implementation from pytest import mark @mark.parametrize(\\"text, shift, expected\\", [ (\\"abcXYZ\\", 2, \\"cdeZAB\\"), (\\"\\", 5, \\"\\"), (\\"unchanged\\", 0, \\"unchanged\\"), (\\"Hello, World!\\", 3, \\"Khoor, Zruog!\\"), (\\"abcXYZ\\", -2, \\"yzaVWX\\"), (\\"zZaA\\", 1, \\"aAbB\\"), (\\"zZaA\\", 26, \\"zZaA\\"), ]) def test_encode_caesar_cipher(text, shift, expected): assert encode_caesar_cipher(text, shift) == expected @mark.parametrize(\\"encoded_text, shift, expected\\", [ (\\"cdeZAB\\", 2, \\"abcXYZ\\"), (\\"\\", 5, \\"\\"), (\\"unchanged\\", 0, \\"unchanged\\"), (\\"Khoor, Zruog!\\", 3, \\"Hello, World!\\"), (\\"yzaVWX\\", -2, \\"abcXYZ\\"), (\\"aAbB\\", 1, \\"zZaA\\"), (\\"zZaA\\", 26, \\"zZaA\\"), ]) def test_decode_caesar_cipher(encoded_text, shift, expected): assert decode_caesar_cipher(encoded_text, shift) == expected","solution":"def encode_caesar_cipher(text: str, shift: int) -> str: def shift_char(c, shift): if c.isalpha(): start = ord('A') if c.isupper() else ord('a') return chr((ord(c) - start + shift) % 26 + start) return c return ''.join(shift_char(c, shift) for c in text) def decode_caesar_cipher(encoded_text: str, shift: int) -> str: return encode_caesar_cipher(encoded_text, -shift)"},{"question":"def min_elements_to_sum(lst: List[int], target: int) -> int: Determines the smallest number of elements needed from the list to sum up to at least the target value. Returns -1 if it is not possible to reach the target sum with the provided integers. Parameters: lst (List[int]): The list of positive integers. target (int): The target sum value. Returns: int: The smallest number of elements needed, or -1 if not possible. Examples: >>> min_elements_to_sum([1, 2, 3, 4, 5], 11) 3 >>> min_elements_to_sum([1, 1, 1, 1, 1], 5) 5 >>> min_elements_to_sum([5, 5, 5, 5], 20) 4 >>> min_elements_to_sum([1, 2, 3, 3, 4, 5], 6) 2 >>> min_elements_to_sum([1, 2, 3, 4, 5], 16) -1 def test_min_elements_to_sum(): assert min_elements_to_sum([1, 2, 3, 4, 5], 11) == 3 assert min_elements_to_sum([1, 1, 1, 1, 1], 5) == 5 assert min_elements_to_sum([5, 5, 5, 5], 20) == 4 assert min_elements_to_sum([1, 2, 3, 3, 4, 5], 6) == 2 # One of the quick combinations [4, 2] assert min_elements_to_sum([1, 2, 3, 4, 5], 16) == -1 # edge cases assert min_elements_to_sum([1000], 1000) == 1 assert min_elements_to_sum([1000], 1001) == -1 assert min_elements_to_sum([1, 2, 1000], 1000) == 1 assert min_elements_to_sum([500, 500], 1000) == 2 # Testing large list assert min_elements_to_sum([1] * 999 + [1000], 1000) == 1 print(\\"All tests passed.\\") test_min_elements_to_sum()","solution":"from typing import List def min_elements_to_sum(lst: List[int], target: int) -> int: Determines the smallest number of elements needed from the list to sum up to at least the target value. Returns -1 if it is not possible to reach the target sum with the provided integers. Parameters: lst (List[int]): The list of positive integers. target (int): The target sum value. Returns: int: The smallest number of elements needed, or -1 if not possible. lst.sort(reverse=True) current_sum = 0 count = 0 for num in lst: current_sum += num count += 1 if current_sum >= target: return count return -1"},{"question":"import time from collections import defaultdict class EventLogger: def __init__(self, initial_events: dict[int, str] = {}) -> None: Initialize the event logger with initial events. >>> logger = EventLogger({1609459200: \\"Event 1\\", 1609462800: \\"Event 2\\"}) >>> len(logger.events) 2 self.events = initial_events def log_event(self, timestamp: int, event: str) -> None: Logs a new event with the given timestamp. >>> logger = EventLogger() >>> timestamp = int(time.time()) >>> logger.log_event(timestamp, \\"Test Event\\") >>> logger.events[timestamp] 'Test Event' self.events[timestamp] = event def query_recent(self, seconds: int) -> list[str]: Retrieves all events within the last given number of seconds from now. >>> logger = EventLogger({int(time.time()) - 10: \\"Event 1\\", int(time.time()) - 5: \\"Event 2\\"}) >>> len(logger.query_recent(20)) 2 >>> logger.query_recent(-5) Traceback (most recent call last): ... ValueError: Invalid time window, must be non-negative. current_time = int(time.time()) def categorize_by_hour(self) -> dict[int, list[str]]: Groups the events by hourly intervals of their timestamps. >>> logger = EventLogger({1609459200: \\"Event 1\\", 1609462800: \\"Event 2\\"}) >>> categorized = logger.categorize_by_hour() >>> categorized == {0: [\\"Event 1\\"], 1: [\\"Event 2\\"]} True","solution":"import time from collections import defaultdict class EventLogger: def __init__(self, initial_events: dict[int, str] = {}) -> None: self.events = initial_events def log_event(self, timestamp: int, event: str) -> None: Logs a new event with the given timestamp. self.events[timestamp] = event def query_recent(self, seconds: int) -> list[str]: Retrieves all events within the last given number of seconds from now. if seconds < 0: raise ValueError(\\"Invalid time window, must be non-negative.\\") current_time = int(time.time()) results = [event for ts, event in self.events.items() if current_time - ts <= seconds] if not results: raise ValueError(\\"No events within the specified range.\\") return results def categorize_by_hour(self) -> dict[int, list[str]]: Groups the events by hourly intervals of their timestamps. categorized_events = defaultdict(list) for timestamp, event in self.events.items(): hour_index = (timestamp // 3600) % 24 categorized_events[hour_index].append(event) return dict(categorized_events)"},{"question":"import re from typing import List def extract_unique_ips(log: str) -> List[str]: Extracts unique IP addresses from the log and returns them in the order they first appeared. >>> log_data = ... 2023-03-15 10:15:42 INFO - Connection from 192.168.1.1 ... 2023-03-15 10:15:43 WARNING - Failed login attempt from 10.0.0.1 ... 2023-03-15 10:15:44 INFO - Connection from 192.168.1.1 ... 2023-03-15 10:16:00 ERROR - Connection timeout from 10.0.0.2 ... 2023-03-15 10:16:30 INFO - Connection from 8.8.8.8 ... ... extract_unique_ips(log_data) ['192.168.1.1', '10.0.0.1', '10.0.0.2', '8.8.8.8'] >>> log_data = ... 2023-03-15 10:15:42 INFO - Connection from ... 2023-03-15 10:15:43 WARNING - Failed login attempt from ... 2023-03-15 10:15:44 INFO - Connection from ... 2023-03-15 10:16:00 ERROR - Connection timeout from ... 2023-03-15 10:16:30 INFO - Connection from ... ... extract_unique_ips(log_data) [] >>> log_data = ... 2023-03-15 10:15:42 INFO - Connection from 999.999.999.999 ... 2023-03-15 10:15:43 WARNING - Failed login attempt from 256.256.256.256 ... 2023-03-15 10:15:44 INFO - Connection from 123.456.78.90 ... 2023-03-15 10:16:00 ERROR - Connection timeout from aaa.bbb.ccc.ddd ... 2023-03-15 10:16:30 INFO - Connection from 192.300.500.700 ... ... extract_unique_ips(log_data) [] >>> log_data = ... 2023-03-15 10:15:42 INFO - Connection from 192.168.1.1 ... 2023-03-15 10:15:43 WARNING - Failed login attempt from 10.0.0.1 ... 2023-03-15 10:15:44 INFO - Connection from 192.168.1.500 ... 2023-03-15 10:16:00 ERROR - Connection timeout from 10.0.0.2 ... 2023-03-15 10:16:30 INFO - Connection from 8.8.8.8 ... \\"\\" ... extract_unique_ips(log_data) ['192.168.1.1', '10.0.0.1', '10.0.0.2', '8.8.8.8']","solution":"import re def extract_unique_ips(log: str) -> list[str]: Extracts unique IP addresses from the log and returns them in the order they first appeared. ip_pattern = re.compile(r'b(?:[0-9]{1,3}.){3}[0-9]{1,3}b') unique_ips = [] seen_ips = set() for line in log.splitlines(): for ip in ip_pattern.findall(line): if ip not in seen_ips and valid_ip(ip): seen_ips.add(ip) unique_ips.append(ip) return unique_ips def valid_ip(ip: str) -> bool: Validates if a given IP address is a valid IPv4 address. parts = ip.split('.') for part in parts: if not 0 <= int(part) <= 255: return False return True"},{"question":"def compress_string(input_string: str) -> str: Compresses a string using run-length encoding. >>> compress_string(\\"aaabbcdddde\\") \\"a3b2cd4e\\" >>> compress_string(\\"abcdef\\") \\"abcdef\\" # Test Cases def test_compress_string_basic_cases(): assert compress_string(\\"aaabbcdddde\\") == \\"a3b2cd4e\\" assert compress_string(\\"abcdef\\") == \\"abcdef\\" assert compress_string(\\"aabbcc\\") == \\"a2b2c2\\" def test_compress_string_edge_cases(): assert compress_string(\\"\\") == \\"\\" assert compress_string(\\"a\\") == \\"a\\" assert compress_string(\\"aaa\\") == \\"a3\\" def test_compress_string_various_patterns(): assert compress_string(\\"aabbaa\\") == \\"a2b2a2\\" assert compress_string(\\"abbbba\\") == \\"ab4a\\" assert compress_string(\\"abababab\\") == \\"abababab\\" def test_compress_string_all_repeats(): assert compress_string(\\"cccccccc\\") == \\"c8\\" def test_compress_string_single_repeats(): assert compress_string(\\"xyz\\") == \\"xyz\\"","solution":"def compress_string(input_string: str) -> str: if not input_string: return \\"\\" compressed = [] count = 1 prev_char = input_string[0] for char in input_string[1:]: if char == prev_char: count += 1 else: if count > 1: compressed.append(f\\"{prev_char}{count}\\") else: compressed.append(prev_char) prev_char = char count = 1 if count > 1: compressed.append(f\\"{prev_char}{count}\\") else: compressed.append(prev_char) return \\"\\".join(compressed)"},{"question":"class UniqueIDManager: A class to Manage Unique Numeric IDs def __init__(self): self.ids_set = set() def add_id(self, id: int) -> None: Add a unique ID. Args: id (int): The ID to add. Raises: ValueError: If the ID already exists. pass # Replace with implementation def remove_id(self, id: int) -> None: Remove an existing ID. Args: id (int): The ID to remove. Raises: ValueError: If the ID does not exist. pass # Replace with implementation def get_all_ids(self) -> list[int]: Retrieve all unique IDs in ascending order. Returns: list[int]: A sorted list of all unique IDs. pass # Replace with implementation # Tests def test_add_id(): manager = UniqueIDManager() manager.add_id(1) assert manager.get_all_ids() == [1] manager.add_id(2) assert manager.get_all_ids() == [1, 2] with pytest.raises(ValueError): manager.add_id(1) # ID already exists def test_remove_id(): manager = UniqueIDManager() manager.add_id(1) manager.add_id(2) manager.remove_id(1) assert manager.get_all_ids() == [2] with pytest.raises(ValueError): manager.remove_id(1) # ID not found manager.remove_id(2) assert manager.get_all_ids() == [] with pytest.raises(ValueError): manager.remove_id(2) # ID not found def test_get_all_ids(): manager = UniqueIDManager() manager.add_id(3) manager.add_id(1) manager.add_id(2) assert manager.get_all_ids() == [1, 2, 3] def test_no_duplicates(): manager = UniqueIDManager() manager.add_id(1) with pytest.raises(ValueError): manager.add_id(1) def test_remove_nonexistent_id(): manager = UniqueIDManager() with pytest.raises(ValueError): manager.remove_id(1)","solution":"class UniqueIDManager: def __init__(self): self.ids_set = set() def add_id(self, id: int) -> None: if id in self.ids_set: raise ValueError(\\"ID already exists.\\") self.ids_set.add(id) def remove_id(self, id: int) -> None: if id not in self.ids_set: raise ValueError(\\"ID not found.\\") self.ids_set.remove(id) def get_all_ids(self) -> list[int]: return sorted(self.ids_set)"},{"question":"import heapq from collections import defaultdict import sys def min_transport_cost(n: int, edges: list[tuple], start: int, end: int) -> int: Returns the minimum transportation cost from start warehouse to end warehouse. >>> min_transport_cost(5, [(0, 1, 10), (0, 2, 5), (1, 2, 2), (2, 1, 3), (1, 3, 1), (2, 3, 9), (3, 4, 4)], 0, 4) == 14 >>> min_transport_cost(3, [(0, 1, 6), (0, 2, 10), (1, 2, 4)], 0, 2) == 10 >>> min_transport_cost(4, [(0, 1, 1), (1, 2, 1), (2, 3, 1)], 0, 3) == 3 >>> min_transport_cost(4, [(0, 1, 1), (1, 2, 1), (2, 3, 1)], 3, 0) == -1 >>> min_transport_cost(4, [(0, 1, 1), (1, 2, 1)], 1, 1) == 0 >>> min_transport_cost(4, [(0, 1, 1), (2, 3, 1)], 0, 3) == -1 >>> min_transport_cost(6, [(0, 1, 1), (1, 2, 1), (1, 4, 7), (2, 4, 2), (4, 5, 1), (3, 5, 10)], 0, 5) == 5 >>> min_transport_cost(4, [], 0, 3) == -1","solution":"import heapq from collections import defaultdict import sys def min_transport_cost(n: int, edges: list[tuple], start: int, end: int) -> int: Returns the minimum transportation cost from start warehouse to end warehouse. graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) # Dijkstra's algorithm to find the shortest path pq = [(0, start)] dist = {i: sys.maxsize for i in range(n)} dist[start] = 0 while pq: current_distance, u = heapq.heappop(pq) # If we reached the end node if u == end: return current_distance if current_distance > dist[u]: continue for neighbor, weight in graph[u]: distance = current_distance + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 if dist[end] == sys.maxsize else dist[end]"},{"question":"def min_replacements_to_palindrome(s: str) -> int: Returns the minimum number of character replacements required to make the given string a palindrome. >>> min_replacements_to_palindrome(\\"abca\\") 1 >>> min_replacements_to_palindrome(\\"racecar\\") 0 >>> min_replacements_to_palindrome(\\"abcdef\\") 3","solution":"def min_replacements_to_palindrome(s: str) -> int: Returns the minimum number of character replacements required to make the given string a palindrome. left = 0 right = len(s) - 1 replacements = 0 while left < right: if s[left] != s[right]: replacements += 1 left += 1 right -= 1 return replacements"},{"question":"def longest_common_subsequence(str1: str, str2: str) -> int: Computes the length of the longest common subsequence between two given strings. Example usage: >>> longest_common_subsequence(\\"abcdef\\", \\"acf\\") 3 >>> longest_common_subsequence(\\"12345\\", \\"54321\\") 1 # Your code here from typing import List def test_longest_common_subsequence(): assert longest_common_subsequence(\\"abcdef\\", \\"acf\\") == 3 assert longest_common_subsequence(\\"12345\\", \\"54321\\") == 1 assert longest_common_subsequence(\\"abc\\", \\"abc\\") == 3 assert longest_common_subsequence(\\"abc\\", \\"def\\") == 0 assert longest_common_subsequence(\\"abcde\\", \\"ace\\") == 3 assert longest_common_subsequence(\\"\\", \\"abc\\") == 0 assert longest_common_subsequence(\\"abc\\", \\"\\") == 0 assert longest_common_subsequence(\\"\\", \\"\\") == 0","solution":"def longest_common_subsequence(str1, str2): Computes the length of the longest common subsequence between two given strings. m, n = len(str1), len(str2) # Create a 2D DP table to store lengths of LCS dp = [[0] * (n+1) for _ in range(m+1)] # Iterate through both strings for i in range(1, m+1): for j in range(1, n+1): if str1[i-1] == str2[j-1]: # Match dp[i][j] = dp[i-1][j-1] + 1 else: # No match dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[m][n]"},{"question":"import math def quadratic_roots(a: float, b: float, c: float) -> tuple[float, float]: Computes the roots of a quadratic equation ax^2 + bx + c = 0 using the quadratic formula. Parameters: a (float): Coefficient of x^2. b (float): Coefficient of x. c (float): Constant term. Returns: tuple: A tuple containing two roots sorted in ascending order. Raises: ValueError: If a is zero or the discriminant is negative. >>> quadratic_roots(1, -3, 2) (1.0, 2.0) >>> quadratic_roots(1, 2, 1) (-1.0, -1.0) >>> quadratic_roots(1, 0, -1) (-1.0, 1.0) >>> quadratic_roots(1, 1, 1) Traceback (most recent call last): ... ValueError: No real roots. (Negative discriminant) >>> quadratic_roots(0, 2, 1) Traceback (most recent call last): ... ValueError: Coefficient 'a' cannot be zero.","solution":"import math def quadratic_roots(a: float, b: float, c: float) -> tuple[float, float]: Computes the roots of a quadratic equation ax^2 + bx + c = 0. Parameters: a (float): Coefficient of x^2. b (float): Coefficient of x. c (float): Constant term. Returns: tuple: A tuple containing two roots sorted in ascending order. Raises: ValueError: If a is zero or the discriminant is negative. if a == 0: raise ValueError(\\"Coefficient 'a' cannot be zero.\\") discriminant = b**2 - 4*a*c if discriminant < 0: raise ValueError(\\"No real roots. (Negative discriminant)\\") sqrt_discriminant = math.sqrt(discriminant) root1 = (-b - sqrt_discriminant) / (2*a) root2 = (-b + sqrt_discriminant) / (2*a) return tuple(sorted((root1, root2)))"},{"question":"class Library: def __init__(self): self.books = [] def add_book(self, title: str, author: str, publication_year: int, genres: list[str]): Add a new book to the library. Parameters: - title: The title of the book. - author: The author of the book. - publication_year: The year the book was published. - genres: A list of genres the book belongs to. def search_by_title(self, title: str) -> list[dict]: Search for books by exact title match. Parameters: - title: The title of the book to search for. Returns: - A list of dictionaries representing books that match the title. def search_by_author(self, author: str) -> list[dict]: Search for books by partial or exact author match. Parameters: - author: The author to search for. Returns: - A list of dictionaries representing books that have the author name partially or exactly matched. def search_by_genre(self, genre: str) -> list[dict]: Search for books by exact genre match. Parameters: - genre: The genre to search for. Returns: - A list of dictionaries representing books that belong to the provided genre. def test_add_book(): library = Library() library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925, [\\"Novel\\", \\"Historical\\"]) assert len(library.books) == 1 assert library.books[0][\\"title\\"] == \\"The Great Gatsby\\" assert library.books[0][\\"author\\"] == \\"F. Scott Fitzgerald\\" assert library.books[0][\\"publication_year\\"] == 1925 assert library.books[0][\\"genres\\"] == [\\"Novel\\", \\"Historical\\"] def test_search_by_title(): library = Library() library.add_book(\\"1984\\", \\"George Orwell\\", 1949, [\\"Dystopian\\", \\"Science Fiction\\"]) result = library.search_by_title(\\"1984\\") assert len(result) == 1 assert result[0][\\"title\\"] == \\"1984\\" assert result[0][\\"author\\"] == \\"George Orwell\\" def test_search_by_title_case_insensitive(): library = Library() library.add_book(\\"1984\\", \\"George Orwell\\", 1949, [\\"Dystopian\\", \\"Science Fiction\\"]) result = library.search_by_title(\\"1984\\".lower()) assert len(result) == 1 assert result[0][\\"title\\"] == \\"1984\\" assert result[0][\\"author\\"] == \\"George Orwell\\" def test_search_by_author_partial_match(): library = Library() library.add_book(\\"1984\\", \\"George Orwell\\", 1949, [\\"Dystopian\\", \\"Science Fiction\\"]) library.add_book(\\"Animal Farm\\", \\"George Orwell\\", 1945, [\\"Political satire\\", \\"Allegory\\"]) result = library.search_by_author(\\"Orwell\\") assert len(result) == 2 def test_search_by_genre(): library = Library() library.add_book(\\"1984\\", \\"George Orwell\\", 1949, [\\"Dystopian\\", \\"Science Fiction\\"]) library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960, [\\"Novel\\", \\"Southern Gothic\\", \\"Fiction\\"]) result = library.search_by_genre(\\"Dystopian\\") assert len(result) == 1 assert result[0][\\"title\\"] == \\"1984\\" assert result[0][\\"author\\"] == \\"George Orwell\\" def test_search_by_genre_case_insensitive(): library = Library() library.add_book(\\"1984\\", \\"George Orwell\\", 1949, [\\"Dystopian\\", \\"Science Fiction\\"]) result = library.search_by_genre(\\"dystopian\\".lower()) assert len(result) == 1 assert result[0][\\"title\\"] == \\"1984\\" assert result[0][\\"author\\"] == \\"George Orwell\\" def test_search_no_match(): library = Library() library.add_book(\\"1984\\", \\"George Orwell\\", 1949, [\\"Dystopian\\", \\"Science Fiction\\"]) result = library.search_by_title(\\"Unknown Title\\") assert len(result) == 0","solution":"class Library: def __init__(self): self.books = [] def add_book(self, title: str, author: str, publication_year: int, genres: list[str]): Add a new book to the library. Parameters: - title: The title of the book. - author: The author of the book. - publication_year: The year the book was published. - genres: A list of genres the book belongs to. self.books.append({\\"title\\": title, \\"author\\": author, \\"publication_year\\": publication_year, \\"genres\\": genres}) def search_by_title(self, title: str) -> list[dict]: Search for books by exact title match. Parameters: - title: The title of the book to search for. Returns: - A list of dictionaries representing books that match the title. return [book for book in self.books if book[\\"title\\"].lower() == title.lower()] def search_by_author(self, author: str) -> list[dict]: Search for books by partial or exact author match. Parameters: - author: The author to search for. Returns: - A list of dictionaries representing books that have the author name partially or exactly matched. return [book for book in self.books if author.lower() in book[\\"author\\"].lower()] def search_by_genre(self, genre: str) -> list[dict]: Search for books by exact genre match. Parameters: - genre: The genre to search for. Returns: - A list of dictionaries representing books that belong to the provided genre. return [book for book in self.books if genre.lower() in [g.lower() for g in book[\\"genres\\"]]]"},{"question":"[Completion Task in Python] Implement a basic class, \`LinearRegression\`, which performs simple linear regression on a given dataset. The class should include methods for fitting the model to the data, predicting values based on the model, calculating the coefficient of determination (R²), and handling potential exceptions during initialization and computation. - Name of the class: \`LinearRegression\` - The \`fit\` method should handle invalid data input (e.g., non-numeric or mismatched data lengths) gracefully. - Ensure proper exceptions are raised where necessary. Class Definition and Methods: 1. **Class Name**: LinearRegression 2. **Initialization**: - Initialize a linear regression model with empty parameters for slope and intercept. Initialize placeholders for the data (x and y). - If data is provided directly at initialization, ensure it is properly formatted; otherwise, raise a \`ValueError\`. 3. **Methods**: - \`fit(self, x: List[float], y: List[float]) -> None\`: Calculate and set the slope and intercept for the linear regression model using the least squares method. If x and y have different lengths, raise a \`ValueError\`. - \`predict(self, x: float) -> float\`: Predict and return the y value using the linear model for a given x. If the model hasn't been fitted yet, raise a \`RuntimeError\`. - \`r_squared(self) -> float\`: Calculate and return the R² value for the fitted model. If the model hasn't been fitted yet, raise a \`RuntimeError\`. Implement the class \`LinearRegression\` as per the above requirements.","solution":"class LinearRegression: def __init__(self, x=None, y=None): self.slope = None self.intercept = None self.x = [] self.y = [] if x is not None and y is not None: if len(x) != len(y): raise ValueError(\\"Mismatched input lengths for x and y.\\") self.x = x self.y = y self.fit(x, y) def fit(self, x, y): if len(x) != len(y): raise ValueError(\\"Mismatched input lengths for x and y.\\") n = len(x) if n <= 1: raise ValueError(\\"At least two data points are required to fit the model.\\") x_mean = sum(x) / n y_mean = sum(y) / n num = sum((x[i] - x_mean) * (y[i] - y_mean) for i in range(n)) den = sum((x[i] - x_mean) ** 2 for i in range(n)) if den == 0: raise ValueError(\\"Cannot fit a model with zero variance in input data.\\") self.slope = num / den self.intercept = y_mean - self.slope * x_mean def predict(self, x): if self.slope is None or self.intercept is None: raise RuntimeError(\\"Model has not been fitted yet.\\") return self.slope * x + self.intercept def r_squared(self): if self.slope is None or self.intercept is None: raise RuntimeError(\\"Model has not been fitted yet.\\") y_mean = sum(self.y) / len(self.y) total_variance = sum((y - y_mean) ** 2 for y in self.y) explained_variance = sum((self.predict(self.x[i]) - y_mean) ** 2 for i in range(len(self.x))) return explained_variance / total_variance"},{"question":"def word_count(sentence: str) -> int: Compute the number of words in the sentence. >>> word_count(\\"the quick brown fox jumps over the lazy dog\\") 9 >>> word_count(\\"hello world\\") 2 >>> word_count(\\"one\\") 1 def frequency_distribution(sentence: str) -> dict: Calculate the frequency of each word in the sentence. >>> frequency_distribution(\\"the quick brown fox jumps over the lazy dog\\") {'the': 2, 'quick': 1, 'brown': 1, 'fox': 1, 'jumps': 1, 'over': 1, 'lazy': 1, 'dog': 1} >>> frequency_distribution(\\"hello hello world\\") {'hello': 2, 'world': 1} >>> frequency_distribution(\\"one two two\\") {'one': 1, 'two': 2} def most_frequent_word(sentence: str) -> list: Identify the word(s) with the highest frequency. If there is a tie, return a list of words sorted alphabetically. >>> most_frequent_word(\\"the quick brown fox jumps over the lazy dog\\") ['the'] >>> most_frequent_word(\\"quick brown fox jumps quick over quick jumps\\") ['quick'] >>> most_frequent_word(\\"a b c b a a a b c\\") ['a'] >>> most_frequent_word(\\"dog dog cat cat\\") ['cat', 'dog'] def reverse_sentence(sentence: str) -> str: Return the sentence with the words' order reversed. >>> reverse_sentence(\\"the quick brown fox jumps over the lazy dog\\") \\"dog lazy the over jumps fox brown quick the\\" >>> reverse_sentence(\\"hello world\\") \\"world hello\\" >>> reverse_sentence(\\"one\\") \\"one\\" def capitalize_alternate_words(sentence: str) -> str: Capitalize every alternate word in the sentence, starting with the first word. >>> capitalize_alternate_words(\\"the quick brown fox jumps over the lazy dog\\") \\"The quick Brown fox Jumps over The lazy Dog\\" >>> capitalize_alternate_words(\\"hello world\\") \\"Hello world\\" >>> capitalize_alternate_words(\\"one\\") \\"One\\" >>> capitalize_alternate_words(\\"capitalize these alternate words please\\") \\"Capitalize these Alternate words Please\\"","solution":"def word_count(sentence: str) -> int: Compute the number of words in the sentence. return len(sentence.split()) def frequency_distribution(sentence: str) -> dict: Calculate the frequency of each word in the sentence. words = sentence.split() freq = {} for word in words: if word in freq: freq[word] += 1 else: freq[word] = 1 return freq def most_frequent_word(sentence: str) -> list: Identify the word(s) with the highest frequency. If there is a tie, return a list of words sorted alphabetically. freq = frequency_distribution(sentence) max_freq = max(freq.values()) most_freq_words = [word for word, count in freq.items() if count == max_freq] return sorted(most_freq_words) def reverse_sentence(sentence: str) -> str: Return the sentence with the words' order reversed. words = sentence.split() return ' '.join(reversed(words)) def capitalize_alternate_words(sentence: str) -> str: Capitalize every alternate word in the sentence, starting with the first word. words = sentence.split() for i in range(0, len(words), 2): words[i] = words[i].capitalize() return ' '.join(words)"},{"question":"def round_number(x: float) -> int: Returns the nearest integer to x using banker's rounding. If the fractional component of x is 0.5, round to the nearest even number. >>> round_number(3.5) 4 >>> round_number(4.5) 4 >>> round_number(-3.5) -4 >>> round_number(-4.5) -4 >>> round_number(2.0) 2 >>> round_number(-2.0) -2 >>> round_number(1.1) 1 >>> round_number(-1.1) -1 >>> round_number(0.0) 0 >>> round_number(1_000_000_000.5) 1_000_000_000 >>> round_number(1_000_000_001.5) 1_000_000_002 >>> round_number(-1_000_000_000.5) -1_000_000_000 >>> round_number(-1_000_000_001.5) -1_000_000_002 >>> round_number(2.5) 2 >>> round_number(-2.5) -2 >>> round_number(0.5) 0 >>> round_number(-0.5) 0 >>> round_number(1.6) 2 >>> round_number(-1.6) -2","solution":"def round_number(x: float) -> int: Returns the nearest integer to x using banker's rounding. If the fractional component of x is 0.5, round to the nearest even number. integer_part = int(x) fractional_part = x - integer_part if fractional_part > 0.5 or (fractional_part == 0.5 and (integer_part % 2 != 0)): return integer_part + 1 elif fractional_part < -0.5 or (fractional_part == -0.5 and (integer_part % 2 != 0)): return integer_part - 1 else: return integer_part"},{"question":"def longest_increasing_trend(prices: list[float]) -> int: Returns the length of the longest continuous increasing trend in stock prices. >>> longest_increasing_trend([100.0, 101.5, 102.0, 99.9, 100.5, 101.0]) 3 >>> longest_increasing_trend([102.0, 101.5, 100.0, 99.9]) 1 >>> longest_increasing_trend([100.0, 100.0, 100.0]) 1 >>> longest_increasing_trend([]) 0 >>> longest_increasing_trend([99.0]) 1","solution":"def longest_increasing_trend(prices): Returns the length of the longest continuous increasing trend in stock prices. if not prices: return 0 longest_trend = 1 current_trend = 1 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: current_trend += 1 longest_trend = max(longest_trend, current_trend) else: current_trend = 1 return longest_trend"},{"question":"from typing import List def find_missing_number(nums: List[int]) -> int: Find the missing number in a given list of unique numbers from the range 0 to n. >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([0, 1]) 2 >>> find_missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1]) 8 >>> find_missing_number([0]) 1 >>> find_missing_number([1]) 0","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"import pytest def test_count_words_in_file(tmpdir): Test function for count_words_in_file This function creates a temporary text file and verifies that count_words_in_file returns the correct word counts. def test_count_words_with_punctuation(tmpdir): Test function for count_words_in_file handling punctuation. This function creates a temporary text file with punctuation and verifies that count_words_in_file returns the correct word counts. def test_count_words_case_insensitivity(tmpdir): Test function for count_words_in_file handling case insensitivity. This function creates a temporary text file with mixed case words and verifies that count_words_in_file returns the correct word counts. def test_count_words_empty_file(tmpdir): Test function for count_words_in_file handling empty file. This function creates a temporary empty text file and verifies that count_words_in_file returns an empty dictionary.","solution":"def count_words_in_file(filename): Reads a large text file and counts the occurrence of each word. Returns a dictionary with words as keys and their counts as values. word_counts = {} with open(filename, 'r') as file: for line in file: words = line.split() for word in words: # Normalize the word by converting to lowercase and stripping punctuation word = word.lower().strip('.,!?') if word in word_counts: word_counts[word] += 1 else: word_counts[word] = 1 return word_counts"},{"question":"class Node: def __init__(self, value: int): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, value: int): new_node = Node(value) if self.head is None: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def reverse_linked_list(self) -> None: Reverse the linked list in-place such that the last node becomes the first node, the second last node becomes the second node, and so on. >>> ll = LinkedList() >>> ll.insert(1) >>> ll.insert(2) >>> ll.insert(3) >>> ll.insert(4) >>> ll.reverse_linked_list() >>> ll.to_list() == [4, 3, 2, 1] True >>> ll = LinkedList() >>> ll.reverse_linked_list() >>> ll.to_list() == [] True >>> ll = LinkedList() >>> ll.insert(1) >>> ll.reverse_linked_list() >>> ll.to_list() == [1] True def to_list(self) -> list: result = [] current = self.head while current: result.append(current.value) current = current.next return result","solution":"class Node: def __init__(self, value: int): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, value: int): new_node = Node(value) if self.head is None: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def reverse_linked_list(self) -> None: prev = None current = self.head while current: next_node = current.next # Store the next node current.next = prev # Reverse the current node's pointer prev = current # Move prev and current one step forward current = next_node self.head = prev def to_list(self) -> list: result = [] current = self.head while current: result.append(current.value) current = current.next return result"},{"question":"def count_pattern_matches(grid: List[List[int]], pattern: List[List[int]]) -> int: Count the number of times a pattern appears in a larger grid. >>> count_pattern_matches( ... [ ... [1, 2, 3, 4], ... [5, 1, 2, 3], ... [1, 2, 3, 4], ... [5, 1, 2, 3] ... ], ... [ ... [1, 2, 3], ... [5, 1, 2] ... ] ... ) == 2 >>> count_pattern_matches( ... [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], ... [ ... [5, 6], ... [8, 9] ... ] ... ) == 1 >>> count_pattern_matches( ... [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], ... [ ... [1, 2], ... [7, 9] ... ] ... ) == 0 >>> count_pattern_matches( ... [ ... [1, 2], ... [3, 4] ... ], ... [ ... [4] ... ] ... ) == 1 >>> count_pattern_matches( ... [ ... [1, 2], ... [3, 4] ... ], ... [ ... [1, 2], ... [3, 4] ... ] ... ) == 1 >>> count_pattern_matches( ... [ ... [1, 2, 3], ... [4, 5, 6] ... ], ... [ ... [1, 2, 3, 4], ... [4, 5, 6, 7] ... ] ... ) == 0","solution":"def count_pattern_matches(grid, pattern): def is_pattern_found(grid, pattern, start_row, start_col): for i in range(len(pattern)): for j in range(len(pattern[0])): if grid[start_row + i][start_col + j] != pattern[i][j]: return False return True count = 0 rows_grid = len(grid) cols_grid = len(grid[0]) rows_pattern = len(pattern) cols_pattern = len(pattern[0]) for i in range(rows_grid - rows_pattern + 1): for j in range(cols_grid - cols_pattern + 1): if is_pattern_found(grid, pattern, i, j): count += 1 return count"},{"question":"def is_permutation(s1: str, s2: str) -> bool: Checks if one string is a permutation of another string. :param s1: First string :param s2: Second string :return: True if s1 is a permutation of s2, otherwise False >>> is_permutation(\\"abc\\", \\"bca\\") True >>> is_permutation(\\"abcd\\", \\"dcba\\") True >>> is_permutation(\\"a\\", \\"a\\") True >>> is_permutation(\\"\\", \\"\\") True >>> is_permutation(\\"abc\\", \\"abcd\\") False","solution":"def is_permutation(s1: str, s2: str) -> bool: Checks if one string is a permutation of another string. :param s1: First string :param s2: Second string :return: True if s1 is a permutation of s2, otherwise False # If lengths of the strings are not equal, they cannot be permutations if len(s1) != len(s2): return False # Sort both strings and compare the results return sorted(s1) == sorted(s2)"},{"question":"def social_media_followers(users: list[int], follows: list[tuple[int, int]], user_id: int) -> tuple[list[int], list[int]]: Returns the list of people followed by the specified user and the list of people who follow that user. >>> social_media_followers([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5), (2, 4), (1, 5)], 2) ([3, 4], [1]) >>> social_media_followers([1, 2, 3, 4, 5], [(1, 2), (3, 4)], 5) ([], []) >>> social_media_followers([1, 2, 3, 4, 5], [(1, 2), (3, 4), (5, 2)], 2) ([], [1, 5]) >>> social_media_followers([1, 2, 3, 4, 5], [(2, 3), (2, 4)], 2) ([3, 4], []) >>> social_media_followers([1, 2, 3, 4], [(1, 2), (3, 4)], 5) ([], []) >>> social_media_followers([], [], 1) ([], []) >>> social_media_followers([1, 2, 3, 4], [], 1) ([], [])","solution":"def social_media_followers(users, follows, user_id): Returns the list of people followed by the specified user and the list of people who follow that user. if user_id not in users: return ([], []) followed_by_user = set() followers_of_user = set() for follower, followed in follows: if follower == user_id: followed_by_user.add(followed) if followed == user_id: followers_of_user.add(follower) return (sorted(followed_by_user), sorted(followers_of_user))"},{"question":"class SimpleJSONParser: def __init__(self): self.index = 0 self.json_str = \\"\\" def parse(self, json_str): Parse a JSON string into a Python dictionary or list. >>> parser = SimpleJSONParser() >>> parser.parse('{\\"key\\": \\"value\\"}') {'key': 'value'} >>> parser.parse('[1, 2, 3]') [1, 2, 3] self.json_str = json_str.strip() self.index = 0 return self._parse_value() def _parse_value(self): pass # Implementation needed def _parse_object(self): pass # Implementation needed def _parse_array(self): pass # Implementation needed def _parse_string(self): pass # Implementation needed def _parse_number(self): pass # Implementation needed # Additional methods as required to support the above functionality # Test cases to verify correctness of the implementation def test_parse_simple_object(): parser = SimpleJSONParser() assert parser.parse('{\\"key\\": \\"value\\"}') == {\\"key\\": \\"value\\"} def test_parse_nested_objects(): parser = SimpleJSONParser() json_str = '{\\"nested\\": {\\"a\\": 1, \\"b\\": [2, 3]}, \\"empty_list\\": []}' expected_output = {\\"nested\\": {\\"a\\": 1, \\"b\\": [2, 3]}, \\"empty_list\\": []} assert parser.parse(json_str) == expected_output def test_parse_simple_array(): parser = SimpleJSONParser() assert parser.parse('[1, 2, 3]') == [1, 2, 3] def test_parse_array_of_objects(): parser = SimpleJSONParser() json_str = '[{\\"name\\": \\"Jane\\"}, {\\"name\\": \\"Doe\\"}]' expected_output = [{\\"name\\": \\"Jane\\"}, {\\"name\\": \\"Doe\\"}] assert parser.parse(json_str) == expected_output def test_parse_mixed_array(): parser = SimpleJSONParser() json_str = '[{\\"name\\": \\"Jane\\"}, 1, 2.5, \\"text\\", true, false, null]' expected_output = [{\\"name\\": \\"Jane\\"}, 1, 2.5, \\"text\\", True, False, None] assert parser.parse(json_str) == expected_output def test_parse_empty_object(): parser = SimpleJSONParser() assert parser.parse('{}') == {} def test_parse_empty_array(): parser = SimpleJSONParser() assert parser.parse('[]') == [] def test_parse_booleans_and_null(): parser = SimpleJSONParser() assert parser.parse('true') == True assert parser.parse('false') == False assert parser.parse('null') == None","solution":"class SimpleJSONParser: def __init__(self): self.index = 0 self.json_str = \\"\\" def parse(self, json_str): self.json_str = json_str.strip() self.index = 0 return self._parse_value() def _parse_value(self): char = self.json_str[self.index] if char == '{': return self._parse_object() elif char == '[': return self._parse_array() elif char == '\\"': return self._parse_string() elif char in '0123456789-': return self._parse_number() elif self.json_str.startswith(\\"true\\", self.index): self.index += 4 return True elif self.json_str.startswith(\\"false\\", self.index): self.index += 5 return False elif self.json_str.startswith(\\"null\\", self.index): self.index += 4 return None else: raise ValueError(\\"Invalid JSON value\\") def _parse_object(self): obj = {} self.index += 1 # skip '{' while self.json_str[self.index] != '}': if self.json_str[self.index] in ' tnr': self.index += 1 continue key = self._parse_string() while self.json_str[self.index] in ' tnr': self.index += 1 self.index += 1 # skip ':' while self.json_str[self.index] in ' tnr': self.index += 1 value = self._parse_value() obj[key] = value while self.json_str[self.index] in ' tnr': self.index += 1 if self.json_str[self.index] == ',': self.index += 1 # skip ',' self.index += 1 # skip '}' return obj def _parse_array(self): array = [] self.index += 1 # skip '[' while self.json_str[self.index] != ']': while self.json_str[self.index] in ' tnr': self.index += 1 value = self._parse_value() array.append(value) while self.json_str[self.index] in ' tnr': self.index += 1 if self.json_str[self.index] == ',': self.index += 1 # skip ',' self.index += 1 # skip ']' return array def _parse_string(self): self.index += 1 # skip initial quote string = \\"\\" while self.json_str[self.index] != '\\"': if self.json_str[self.index] == '': self.index += 1 # skip the escape character string += self.json_str[self.index] self.index += 1 self.index += 1 # skip final quote return string def _parse_number(self): num_str = \\"\\" while self.json_str[self.index] in '0123456789.-': num_str += self.json_str[self.index] self.index += 1 if '.' in num_str: return float(num_str) else: return int(num_str)"},{"question":"Given a task to filter log entries for error messages and a function \`extract_error_logs\`, complete the code. def extract_error_logs(log_entries: list) -> list: Extracts error messages from a list of log entries. Parameters: log_entries (list): A list of log entries, where each entry is a string. Returns: list: A list of strings, where each string is an error message extracted from the log entries. error_logs = [] for entry in log_entries: if \\"[ERROR]\\" in entry: error_logs.append(entry) return error_logs","solution":"def extract_error_logs(log_entries: list) -> list: Extracts error messages from a list of log entries. Parameters: log_entries (list): A list of log entries, where each entry is a string. Returns: list: A list of strings, where each string is an error message extracted from the log entries. error_logs = [] for entry in log_entries: if \\"[ERROR]\\" in entry: error_logs.append(entry) return error_logs"},{"question":"def encrypt(text: str, shift: int) -> str: Encrypts the given text using the Caesar Cipher technique. >>> encrypt(\\"hello\\", 3) 'khoor' >>> encrypt(\\"xyz\\", 3) 'abc' >>> encrypt(\\"hello world!\\", 3) 'khoor zruog!' pass def decrypt(encrypted_text: str, shift: int) -> str: Decrypts the given encrypted text using the Caesar Cipher technique. >>> decrypt(\\"khoor\\", 3) 'hello' >>> decrypt(\\"abc\\", 3) 'xyz' >>> decrypt(\\"khoor zruog!\\", 3) 'hello world!' pass","solution":"def encrypt(text: str, shift: int) -> str: encrypted_text = [] for char in text: if char.isalpha(): new_char = chr(((ord(char) - ord('a') + shift) % 26) + ord('a')) encrypted_text.append(new_char) else: encrypted_text.append(char) return ''.join(encrypted_text) def decrypt(encrypted_text: str, shift: int) -> str: decrypted_text = [] for char in encrypted_text: if char.isalpha(): new_char = chr(((ord(char) - ord('a') - shift + 26) % 26) + ord('a')) decrypted_text.append(new_char) else: decrypted_text.append(char) return ''.join(decrypted_text)"},{"question":"def num_pairs_with_sum(nums: list[int], target: int) -> int: Returns the number of unique pairs of elements in the list that add up to the target sum. >>> num_pairs_with_sum([1, 2, 3, 4, 3], 6) 2 >>> num_pairs_with_sum([1, 3, 2, 2], 4) 2 >>> num_pairs_with_sum([1, 1, 1, 1], 2) 1 >>> num_pairs_with_sum([1, 2, 3, 4, 5], 10) 0 >>> num_pairs_with_sum([], 0) 0 from solution import num_pairs_with_sum def test_example_cases(): assert num_pairs_with_sum([1, 2, 3, 4, 3], 6) == 2 # Pairs: (2, 4), (3, 3) assert num_pairs_with_sum([1, 3, 2, 2], 4) == 2 # Pairs: (1, 3), (2, 2) assert num_pairs_with_sum([1, 1, 1, 1], 2) == 1 # Pair: (1, 1) assert num_pairs_with_sum([1, 2, 3, 4, 5], 10) == 0 # No pairs add up to 10 assert num_pairs_with_sum([], 0) == 0 # No pairs in an empty list def test_additional_cases(): assert num_pairs_with_sum([1], 2) == 0 # Only one element, no pairs possible assert num_pairs_with_sum([2, 2, 2, 2], 4) == 1 # Only one unique pair (2, 2) assert num_pairs_with_sum([-1, 1, -2, 2, 0], 0) == 2 # Pairs: (-1, 1), (-2, 2) assert num_pairs_with_sum([1, 5, 7, -1, 5], 6) == 2 # Pairs: (1, 5), (7, -1) assert num_pairs_with_sum([0, 0, 0, 0], 0) == 1 # Only one unique pair (0, 0)","solution":"def num_pairs_with_sum(nums: list[int], target: int) -> int: Returns the number of unique pairs of elements in the list that add up to the target sum. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"from typing import List, Dict def recommend_products(user_history: List[str], product_db: Dict[str, List[str]]) -> List[str]: Recommend up to 5 unique product IDs based on user history and product database. Ensures recommendations are diverse and handles inconsistencies gracefully. Args: user_history (List[str]): List of product categories the user has viewed. product_db (Dict[str, List[str]]): Dictionary with product categories as keys and lists of product IDs as values. Returns: List[str]: List of recommended product IDs, up to 5. Example: >>> recommend_products(['electronics', 'books', 'clothing'], { ... 'electronics': ['e1', 'e2', 'e3'], ... 'books': ['b1', 'b2'], ... 'clothing': ['c1', 'c2', 'c3', 'c4'], ... 'toys': ['t1', 't2'] ... }) ['e1', 'b1', 'c1', 't1']","solution":"from typing import List, Dict def recommend_products(user_history: List[str], product_db: Dict[str, List[str]]) -> List[str]: recommended = set() recommendations = [] # Process each category in user history for category in user_history: if category in product_db: for product in product_db[category]: if product not in recommended: recommended.add(product) recommendations.append(product) if len(recommendations) == 5: break if len(recommendations) == 5: break # Fill the remaining recommendations, if needed, from unused categories if len(recommendations) < 5: for category, products in product_db.items(): if category not in user_history: for product in products: if product not in recommended: recommended.add(product) recommendations.append(product) if len(recommendations) == 5: break if len(recommendations) == 5: break return recommendations"},{"question":"from typing import List, Tuple def find_horizontal_word_positions(grid: List[List[str]], word: str) -> List[Tuple[int, int]]: Find all starting positions (row and column indices) in the grid where the target word appears horizontally (from left to right). >>> grid = [ ... ['h', 'e', 'l', 'l', 'o'], ... ['w', 'o', 'r', 'l', 'd'], ... ['h', 'e', 'l', 'l', 'o'], ... ['r', 'o', 'w', 'i', 'n'] ... ] >>> word = \\"hello\\" >>> find_horizontal_word_positions(grid, word) [(0, 0), (2, 0)] >>> grid = [ ... ['c', 'o', 'd', 'e'], ... ['j', 'a', 'v', 'a'], ... ['p', 'y', 't', 'h', 'o', 'n'] ... ] >>> word = \\"code\\" >>> find_horizontal_word_positions(grid, word) [(0, 0)]","solution":"from typing import List, Tuple def find_horizontal_word_positions(grid: List[List[str]], word: str) -> List[Tuple[int, int]]: positions = [] word_length = len(word) for row_index, row in enumerate(grid): row_str = ''.join(row) start = 0 while True: start = row_str.find(word, start) if start == -1: break positions.append((row_index, start)) start += 1 # Move start index one character to the right to find subsequent matches return positions"},{"question":"def robot_final_position(commands: str) -> (int, int): Write a function \`robot_final_position(commands)\` that takes a string representing a sequence of commands and returns the final coordinates of the robot after executing all the commands. :param commands: A string of directions 'U', 'D', 'L', 'R' :return: A tuple (x, y) representing the final coordinates. >>> robot_final_position(\\"UUUDDDLLRR\\") (0, 0) >>> robot_final_position(\\"UULDR\\") (0, 1) >>> robot_final_position(\\"LLLLDDDDRRRRUUUU\\") (0, 0)","solution":"def robot_final_position(commands): Computes the final position of the robot after executing all commands. :param commands: A string of directions 'U', 'D', 'L', 'R' :return: A tuple (x, y) representing the final coordinates. x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return (x, y)"},{"question":"def custom_split(string: str, delimiter: str) -> List[str]: Splits the input string based on the given delimiter and returns a list of substrings. >>> custom_split(\\"apple;banana;cherry;date\\", \\";\\") == [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"] >>> custom_split(\\"dog:cat:mouse\\", \\":\\") == [\\"dog\\", \\"cat\\", \\"mouse\\"] # Your code goes here class SubstringIterator: def __init__(self, substrings: List[str]): Initializes the iterator with the list of substrings. >>> substrings = [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"] >>> iterator = SubstringIterator(substrings) >>> list(iterator) == [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"] self.substrings = substrings self.index = 0 def __iter__(self): Returns self as an iterator object. # Your code goes here def __next__(self): Returns the next substring from the list. # Your code goes here","solution":"def custom_split(string, delimiter): Splits the input string based on the given delimiter and returns a list of substrings. return string.split(delimiter) class SubstringIterator: def __init__(self, substrings): self.substrings = substrings self.index = 0 def __iter__(self): return self def __next__(self): if self.index < len(self.substrings): result = self.substrings[self.index] self.index += 1 return result else: raise StopIteration"},{"question":"def trap_rainwater(heights: List[int]) -> int: Calculate the total amount of trapped rainwater given the heights of buildings. Args: heights (List[int]): List of integers representing heights of buildings. Returns: int: Total units of trapped rainwater. Examples: >>> trap_rainwater([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_rainwater([4,2,0,3,2,5]) 9 >>> trap_rainwater([]) 0 >>> trap_rainwater([1,1,1,1,1]) 0 >>> trap_rainwater([2,1,0,2]) 3 >>> trap_rainwater([3,0,1,3,0,5]) 8 >>> trap_rainwater([2]) 0 >>> trap_rainwater([3,2]) 0 >>> trap_rainwater([3,2,3]) 1","solution":"def trap_rainwater(height): Calculate the total amount of rainwater trapped. :param height: List of building heights. :return: Total units of trapped rainwater. if not height or len(height) <= 2: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] trapped_water = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) trapped_water += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) trapped_water += max(0, right_max - height[right]) return trapped_water"},{"question":"def longest_words(words: list, length: int) -> list: Retrieves all the words from the list that have the exact length of the target word length. Examples: >>> longest_words([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], 5) ['apple'] >>> longest_words([\\"elephant\\", \\"dog\\", \\"cat\\", \\"hippopotamus\\"], 3) ['dog', 'cat'] >>> longest_words([\\"kiwi\\", \\"mango\\", \\"pineapple\\", \\"grape\\"], 6) ['mango'] >>> longest_words([\\"strawberry\\", \\"blueberry\\", \\"raspberry\\"], 10) ['strawberry', 'blueberry']","solution":"def longest_words(words, length): Retrieves all words from the list that have the exact length of the target word length. return [word for word in words if len(word) == length] # Example usage: print(longest_words([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], 5)) # Output: [\\"apple\\"] print(longest_words([\\"elephant\\", \\"dog\\", \\"cat\\", \\"hippopotamus\\"], 3)) # Output: [\\"dog\\", \\"cat\\"] print(longest_words([\\"kiwi\\", \\"mango\\", \\"pineapple\\", \\"grape\\"], 6)) # Output: [\\"mango\\"] print(longest_words([\\"strawberry\\", \\"blueberry\\", \\"raspberry\\"], 10)) # Output: [\\"strawberry\\", \\"blueberry\\"]"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_path_to_node(root: TreeNode, target: int) -> list: Find the path from the root to a given target node in a binary tree. Args: root (TreeNode): The root node of the binary tree. target (int): The value of the target node. Returns: list: The list containing the values of nodes forming the path from the root to the target node. If the target node does not exist, returns an empty list. Examples: >>> nodes = iter([3, 9, 'null', 'null', 20, 15, 'null', 'null', 7, 'null', 'null']) >>> root = build_tree(nodes) >>> find_path_to_node(root, 15) [3, 20, 15] >>> find_path_to_node(root, 9) [3, 9] >>> find_path_to_node(root, 7) [3, 20, 7] >>> find_path_to_node(root, 10) []","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_path_to_node(root: TreeNode, target: int) -> list: def helper(node, path): if not node: return False path.append(node.value) if node.value == target: return True if helper(node.left, path) or helper(node.right, path): return True path.pop() return False path = [] if helper(root, path): return path else: return []"},{"question":"def replace_substring(text: str, old: str, new: str) -> str: Replaces all occurrences of the substring \`old\` within \`text\` with the substring \`new\`. >>> replace_substring(\\"the cat sat on the mat\\", \\"cat\\", \\"dog\\") == \\"the dog sat on the mat\\" >>> replace_substring(\\"hello world\\", \\"o\\", \\"oo\\") == \\"helloo woorld\\" >>> replace_substring(\\"aaaaaa\\", \\"aa\\", \\"a\\") == \\"aaa\\" >>> replace_substring(\\"ababab\\", \\"ab\\", \\"ba\\") == \\"bababa\\" >>> replace_substring(\\"text without old substring\\", \\"xyz\\", \\"abc\\") == \\"text without old substring\\" >>> replace_substring(\\"empty old\\", \\"\\", \\"new\\") == \\"empty old\\"","solution":"def replace_substring(text: str, old: str, new: str) -> str: Replaces all occurrences of the substring \`old\` within \`text\` with the substring \`new\`. if not old: return text # If old is an empty string, return the original text unchanged. return text.replace(old, new)"},{"question":"class LRUCache: def __init__(self, capacity: int) -> None: Initializes the LRU cache with a given capacity. Parameters: capacity (int): The capacity of the cache. # Task implementation here pass def get(self, key: int) -> int: Retrieves the value associated with the given key if it exists, else returns -1. Parameters: key (int): The key to look up in the cache. Returns: int: The value associated with the key or -1 if the key is not found. # Task implementation here pass def put(self, key: int, value: int) -> None: Inserts or updates the key-value pair in the cache. If the cache exceeds its capacity, the least recently used item will be removed. Parameters: key (int): The key to be added or updated in the cache. value (int): The value to be associated with the key. # Task implementation here pass import pytest def test_lru_cache_initialization(): cache = LRUCache(2) assert cache.capacity == 2 def test_lru_cache_put_and_get(): cache = LRUCache(2) cache.put(1, 1) assert cache.get(1) == 1 def test_lru_cache_eviction(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) # should evict key 1 assert cache.get(1) == -1 def test_lru_cache_order_update(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.get(1) cache.put(3, 3) # should evict key 2 assert cache.get(2) == -1 def test_lru_cache_update_existing_key(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(1, 10) assert cache.get(1) == 10","solution":"class LRUCache: def __init__(self, capacity: int) -> None: Initializes the LRU cache with a given capacity. Parameters: capacity (int): The capacity of the cache. self.capacity = capacity self.cache = {} self.order = [] def get(self, key: int) -> int: Retrieves the value associated with the given key if it exists, else returns -1. Parameters: key (int): The key to look up in the cache. Returns: int: The value associated with the key or -1 if the key is not found. if key in self.cache: self.order.remove(key) self.order.append(key) return self.cache[key] else: return -1 def put(self, key: int, value: int) -> None: Inserts or updates the key-value pair in the cache. If the cache exceeds its capacity, the least recently used item will be removed. Parameters: key (int): The key to be added or updated in the cache. value (int): The value to be associated with the key. if key in self.cache: self.cache[key] = value self.order.remove(key) self.order.append(key) else: if len(self.cache) >= self.capacity: lru_key = self.order.pop(0) del self.cache[lru_key] self.cache[key] = value self.order.append(key)"},{"question":"from typing import List, Dict, Any def most_active_user(dataset: List[Dict[str, Any]], start_time: int, end_time: int) -> str: Process the dataset to find the user with the highest number of distinct activities in a given time window. Args: dataset (List[Dict[str, Any]]): A list of dictionaries where each dictionary represents an activity entry. start_time (int): The starting timestamp of the time window. end_time (int): The ending timestamp of the time window. Returns: str: The userID of the user with the highest number of distinct activities within the provided time window. >>> dataset = [ ... {'userID': 'user1', 'activityType': 'login', 'timestamp': 1610000000}, ... {'userID': 'user2', 'activityType': 'purchase', 'timestamp': 1610000300}, ... {'userID': 'user1', 'activityType': 'logout', 'timestamp': 1610000600}, ... {'userID': 'user3', 'activityType': 'login', 'timestamp': 1610000900}, ... {'userID': 'user1', 'activityType': 'login', 'timestamp': 1610001200}, ... {'userID': 'user2', 'activityType': 'login', 'timestamp': 1610001500} ... ] >>> start_time = 1610000000 >>> end_time = 1610001000 >>> most_active_user(dataset, start_time, end_time) 'user1'","solution":"from typing import List, Dict, Any from collections import defaultdict def most_active_user(dataset: List[Dict[str, Any]], start_time: int, end_time: int) -> str: user_activities = defaultdict(set) # Dictionary to store unique activities for each user # Iterate through each activity in the dataset for activity in dataset: user_id = activity['userID'] activity_type = activity['activityType'] timestamp = activity['timestamp'] # Check if the activity is within the specified time window if start_time <= timestamp <= end_time: user_activities[user_id].add(activity_type) # Find the user with the maximum number of distinct activities max_activities = 0 most_active_user_id = None for user_id, activities in user_activities.items(): if len(activities) > max_activities: max_activities = len(activities) most_active_user_id = user_id return most_active_user_id"},{"question":"# Problem Statement: Implement a function to merge two pre-sorted arrays into one sorted array. The function should take in two lists of integers that are already sorted in non-decreasing order and combine them into a single list that remains sorted in non-decreasing order. # Constraints: * Each of the input lists will contain at most 10^5 integers. * The integers in the input lists will be in the range from -10^9 to 10^9. * The combined length of both input lists will be at most 2 * 10^5. # Function Signature: from typing import List def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Merge two pre-sorted arrays into one sorted array. Merges two input lists that are already sorted in non-decreasing order into a single list that maintains non-decreasing order. Args: arr1: List[int] - first sorted list of integers arr2: List[int] - second sorted list of integers Returns: List[int] - merged sorted list of integers Examples: >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([-5, 0, 3], [-4, -1, 2, 10]) [-5, -4, -1, 0, 2, 3, 10] >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3] # Requirements: 1. Initialize an empty list for the merged output. 2. Use two pointers to iterate through each of the input lists. 3. Compare the current elements of both lists and append the smaller element to the merged list. 4. Increment the pointer of the list from which the element was chosen. 5. If one list is exhausted before the other, append the remaining elements of the other list to the merged list. 6. Return the sorted merged list. # Test Cases: from solution import merge_sorted_arrays def test_merge_both_non_empty_one(): assert merge_sorted_arrays([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] def test_merge_both_non_empty_two(): assert merge_sorted_arrays([-5, 0, 3], [-4, -1, 2, 10]) == [-5, -4, -1, 0, 2, 3, 10] def test_merge_one_empty(): assert merge_sorted_arrays([], [1, 2, 3]) == [1, 2, 3] def test_merge_other_empty(): assert merge_sorted_arrays([1, 2, 3], []) == [1, 2, 3] def test_merge_both_empty(): assert merge_sorted_arrays([], []) == [] def test_merge_duplicates(): assert merge_sorted_arrays([1, 2, 2], [2, 2, 3]) == [1, 2, 2, 2, 2, 3] def test_merge_negative_and_positive(): assert merge_sorted_arrays([-10, -5, 0], [-1, 2, 3]) == [-10, -5, -1, 0, 2, 3]","solution":"from typing import List def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: merged = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 while i < len(arr1): merged.append(arr1[i]) i += 1 while j < len(arr2): merged.append(arr2[j]) j += 1 return merged"},{"question":"from typing import List def apply_convolution(image: List[List[int]], filter_matrix: List[List[float]]) -> List[List[int]]: Applies the given convolution filter to the grayscale image. Args: image (List[List[int]]): A 2D list representing the grayscale image where each element is a pixel value (0-255). filter_matrix (List[List[float]]): A 2D list representing the convolution filter matrix. Returns: List[List[int]]: A 2D list representing the filtered image. # Example grayscale image image = [ [10, 30, 50], [90, 110, 130], [170, 190, 210] ] # Example filter matrix for edge detection filter_matrix = [ [-1, -1, -1], [-1, 8, -1], [-1, -1, -1] ] # Apply the filter to the image filtered_image = apply_convolution(image, filter_matrix) print(filtered_image) # Output should be a 3x3 matrix with the applied convolution filter's result, clamped to the 0-255 range.","solution":"from typing import List def apply_convolution(image: List[List[int]], filter_matrix: List[List[float]]) -> List[List[int]]: height, width = len(image), len(image[0]) filter_size = len(filter_matrix) offset = filter_size // 2 def clamp(value): return max(0, min(255, value)) def apply_filter_at_pixel(row, col): result = 0 for i in range(filter_size): for j in range(filter_size): image_row = row + i - offset image_col = col + j - offset image_value = image[image_row][image_col] filter_value = filter_matrix[i][j] result += image_value * filter_value return clamp(int(result)) filtered_image = [[0] * width for _ in range(height)] for r in range(offset, height - offset): for c in range(offset, width - offset): filtered_image[r][c] = apply_filter_at_pixel(r, c) return filtered_image"},{"question":"def most_frequent_substring(s: str, length: int) -> str: Takes an input string \`s\` and an integer \`length\`, and returns the most frequent substring of the specified length. In case of a tie, returns the lexicographically smallest substring. Examples: >>> most_frequent_substring(\\"banana\\", 2) \\"an\\" >>> most_frequent_substring(\\"abcabcabc\\", 3) \\"abc\\" >>> most_frequent_substring(\\"abcdefg\\", 4) \\"abcd\\" >>> most_frequent_substring(\\"\\", 1) \\"\\" >>> most_frequent_substring(\\"a\\", 2) \\"\\"","solution":"def most_frequent_substring(s: str, length: int) -> str: Takes an input string \`s\` and an integer \`length\`, and returns the most frequent substring of the specified length. In case of a tie, returns the lexicographically smallest substring. Examples: >>> most_frequent_substring(\\"banana\\", 2) \\"an\\" >>> most_frequent_substring(\\"abcabcabc\\", 3) \\"abc\\" >>> most_frequent_substring(\\"abcdefg\\", 4) \\"abcd\\" >>> most_frequent_substring(\\"\\", 1) \\"\\" >>> most_frequent_substring(\\"a\\", 2) \\"\\" if length > len(s): return \\"\\" from collections import defaultdict substring_count = defaultdict(int) for i in range(len(s) - length + 1): substring = s[i:i + length] substring_count[substring] += 1 max_count = 0 result = None for substring, count in substring_count.items(): if count > max_count or (count == max_count and (result is None or substring < result)): max_count = count result = substring return result if result is not None else \\"\\""},{"question":"class MedianTracker: Class to track the median of dynamically changing grades. Methods: add_grade(grade: int) -> None Adds a new grade to the list. find_median() -> float Returns the median of the current grades. >>> tracker = MedianTracker() >>> tracker.add_grade(85) >>> tracker.add_grade(92) >>> tracker.add_grade(75) >>> tracker.add_grade(88) >>> tracker.find_median() 86.5 >>> tracker.add_grade(95) >>> tracker.find_median() 88.0 >>> tracker.add_grade(100) >>> tracker.find_median() 92.0 def __init__(self): pass def add_grade(self, grade: int) -> None: pass def find_median(self) -> float: pass def test_add_single_grade(): tracker = MedianTracker() tracker.add_grade(85) assert tracker.find_median() == 85 def test_even_number_of_grades(): tracker = MedianTracker() grades = [85, 92, 75, 88] for grade in grades: tracker.add_grade(grade) assert tracker.find_median() == 86.5 def test_odd_number_of_grades(): tracker = MedianTracker() grades = [85, 92, 75, 88, 95] for grade in grades: tracker.add_grade(grade) assert tracker.find_median() == 88.0 def test_more_additions(): tracker = MedianTracker() grades = [85, 92, 75, 88, 95, 100] for grade in grades: tracker.add_grade(grade) assert tracker.find_median() == 90.0 def test_grades_with_duplicates(): tracker = MedianTracker() grades = [50, 50, 60, 60, 50, 60] for grade in grades: tracker.add_grade(grade) assert tracker.find_median() == 55.0","solution":"import heapq class MedianTracker: def __init__(self): self.min_heap = [] # Min heap for the larger half self.max_heap = [] # Max heap for the smaller half def add_grade(self, grade: int) -> None: if len(self.max_heap) == 0 or grade <= -self.max_heap[0]: heapq.heappush(self.max_heap, -grade) else: heapq.heappush(self.min_heap, grade) # Balance the heaps if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) if len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def find_median(self) -> float: if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] else: return (-self.max_heap[0] + self.min_heap[0]) / 2"},{"question":"def largest_cluster_size(grid: List[List[int]]) -> int: Find the size of the largest cluster of occupied cells in the given 2D grid. >>> largest_cluster_size([[0, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 0], [0, 0, 1, 1]]) == 3 >>> largest_cluster_size([[1, 0, 0], [0, 0, 0], [0, 0, 1]]) == 1 >>> largest_cluster_size([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) == 0 >>> largest_cluster_size([[1, 1, 1], [0, 1, 0], [1, 1, 1]]) == 7 >>> largest_cluster_size([[1]]) == 1 >>> largest_cluster_size([[0]]) == 0 >>> largest_cluster_size([ [1, 0, 1, 0, 1], [0, 1, 0, 1, 0], [1, 0, 1, 0, 1], [0, 1, 0, 1, 0], [1, 0, 1, 0, 1] ]) == 1 >>> largest_cluster_size([ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ]) == 16","solution":"def largest_cluster_size(grid): def dfs(x, y): Perform a Depth First Search to find the size of the cluster starting from (x, y). # Stack for DFS stack = [(x, y)] size = 0 while stack: cx, cy = stack.pop() # Check bounds and if the cell is part of a cluster if 0 <= cx < len(grid) and 0 <= cy < len(grid[0]) and grid[cx][cy] == 1: size += 1 grid[cx][cy] = 0 # mark as visited # Add neighboring cells to stack stack.extend([(cx - 1, cy), (cx + 1, cy), (cx, cy - 1), (cx, cy + 1)]) return size max_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: current_cluster_size = dfs(i, j) max_size = max(max_size, current_cluster_size) return max_size"},{"question":"def min_moves_to_end(maze: List[List[int]]) -> int: Calculate the minimum number of moves required to reach the end of a given maze from the start position. >>> min_moves_to_end([[0, 0, 1], [0, 1, 0], [0, 0, 0]]) == 4 >>> min_moves_to_end([[0, 1], [1, 0]]) == -1 >>> min_moves_to_end([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 4 >>> min_moves_to_end([[0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0]]) == 8 pass","solution":"from typing import List def min_moves_to_end(maze: List[List[int]]) -> int: from collections import deque # Edge case: checking if the start or end is blocked if maze[0][0] == 1 or maze[-1][-1] == 1: return -1 n, m = len(maze), len(maze[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if row == n - 1 and col == m - 1: return dist for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < n and 0 <= c < m and maze[r][c] == 0 and (r, c) not in visited: visited.add((r, c)) queue.append((r, c, dist + 1)) return -1"},{"question":"def maximize_tasks(tasks: list[tuple[int, int]]) -> int: Maximizes the number of non-overlapping tasks. Args: tasks (list of tuples): List where each tuple is a (start_time, end_time). Returns: int: The maximum number of non-overlapping tasks. Example: >>> maximize_tasks([(1, 4), (2, 5), (3, 6), (7, 8), (5, 9), (8, 10)]) 3 pass def test_single_task(): tasks = [(1, 2)] assert maximize_tasks(tasks) == 1 def test_no_overlap(): tasks = [(1, 2), (2, 3), (3, 4), (4, 5)] assert maximize_tasks(tasks) == 4 def test_with_overlap(): tasks = [(1, 3), (2, 5), (4, 6)] assert maximize_tasks(tasks) == 2 def test_mixed_intervals(): tasks = [(1, 3), (3, 5), (4, 6), (6, 8)] assert maximize_tasks(tasks) == 3 def test_all_overlap(): tasks = [(1, 4), (2, 5), (3, 6), (1, 7)] assert maximize_tasks(tasks) == 1 def test_large_intervals(): tasks = [(1, 10), (2, 9), (3, 8), (4, 7), (5, 11)] assert maximize_tasks(tasks) == 1 def test_edge_case_empty(): tasks = [] assert maximize_tasks(tasks) == 0 def test_edge_case_single_long_task(): tasks = [(0, 100000)] assert maximize_tasks(tasks) == 1","solution":"def maximize_tasks(tasks): Maximizes the number of non-overlapping tasks. Args: tasks (list of tuples): List where each tuple is a (start_time, end_time). Returns: int: The maximum number of non-overlapping tasks. # Sort tasks based on their end times tasks.sort(key=lambda x: x[1]) max_tasks = 0 last_end_time = 0 for start, end in tasks: if start >= last_end_time: max_tasks += 1 last_end_time = end return max_tasks"},{"question":"def is_pattern_in_sequence(main_sequence: list[int], pattern: list[int]) -> bool: Determines if the pattern sequence can be formed by deleting some elements from the main sequence without reordering the remaining elements. >>> is_pattern_in_sequence([1, 2, 3, 4, 5], [1, 3, 5]) True >>> is_pattern_in_sequence([1, 2, 4, 3, 5], [1, 2, 3, 6]) False","solution":"def is_pattern_in_sequence(main_sequence: list[int], pattern: list[int]) -> bool: Determines if the pattern sequence can be formed by deleting some elements from the main sequence without reordering the remaining elements. pattern_index = 0 pattern_length = len(pattern) for el in main_sequence: if pattern_index < pattern_length and el == pattern[pattern_index]: pattern_index += 1 if pattern_index == pattern_length: return True return False"},{"question":"def compress_rle(text: str) -> str: Compress a given string using Run-Length Encoding (RLE) :param text: The input string to be compressed. :return: The RLE compressed version of the input string. >>> compress_rle(\\"aaabbcdddaaa\\") 'a3b2c1d3a3' >>> compress_rle(\\"aAaBBb\\") 'a1A1a1B2b1' pass def decompress_rle(compressed_text: str) -> str: Decompress a string that was compressed using Run-Length Encoding (RLE) :param compressed_text: The RLE compressed string. :return: The decompressed original string. >>> decompress_rle(\\"a3b2c1d3a3\\") 'aaabbcdddaaa' >>> decompress_rle(\\"a1A1a1B2b1\\") 'aAaBBb' pass","solution":"def compress_rle(text: str) -> str: if not text: return \\"\\" compressed = [] count = 1 for i in range(1, len(text)): if text[i] == text[i-1]: count += 1 else: compressed.append(text[i-1] + str(count)) count = 1 compressed.append(text[-1] + str(count)) return ''.join(compressed) def decompress_rle(compressed_text: str) -> str: if not compressed_text: return \\"\\" decompressed = [] i = 0 while i < len(compressed_text): char = compressed_text[i] count_str = [] i += 1 while i < len(compressed_text) and compressed_text[i].isdigit(): count_str.append(compressed_text[i]) i += 1 count = int(''.join(count_str)) decompressed.append(char * count) return ''.join(decompressed)"},{"question":"def simplify_path(path: str) -> str: Simplify the given Unix-style absolute path by resolving \`.\` and \`..\` and removing any redundant slashes. >>> simplify_path(\\"/home/\\") == \\"/home\\" >>> simplify_path(\\"/../\\") == \\"/\\" >>> simplify_path(\\"/home//foo/\\") == \\"/home/foo\\" >>> simplify_path(\\"/a/./b/../../c/\\") == \\"/c\\" >>> simplify_path(\\"/a/../../b/../c//.//\\") == \\"/c\\" >>> simplify_path(\\"/a//b////c/d//././/..\\") == \\"/a/b/c\\" >>> simplify_path(\\"/\\") == \\"/\\" >>> simplify_path(\\"/./\\") == \\"/\\" >>> simplify_path(\\"/...\\") == \\"/...\\" >>> simplify_path(\\"/.../\\") == \\"/...\\" >>> simplify_path(\\"//foo//bar\\") == \\"/foo/bar\\" >>> simplify_path(\\"/foo/bar/../bar/\\") == \\"/foo/bar\\" >>> simplify_path(\\"/.././../././../\\") == \\"/\\" >>> simplify_path(\\"/a/b/../c/./d/e/../../\\") == \\"/a/c\\" pass","solution":"def simplify_path(path: str) -> str: Simplify the given Unix-style absolute path by resolving \`.\` and \`..\` and removing any redundant slashes. components = path.split('/') path_stack = [] for component in components: if component == '' or component == '.': continue elif component == '..': if path_stack: path_stack.pop() else: path_stack.append(component) return '/' + '/'.join(path_stack)"},{"question":"# Write a function \`extract_unique_words\` that extracts all unique words from a list of sentences, performs case normalization, and sorts them lexicographically. def extract_unique_words(sentences): Extracts all unique words from a list of sentences, performs case normalization, and sorts them lexicographically. Args: - sentences: A list of strings, where each string is a sentence. Returns: - A list of unique, sorted words. # Set to store unique words unique_words = set() # Regular expression to find words word_pattern = re.compile(r'bw+b') for sentence in sentences: # Find all words ignoring punctuation words = word_pattern.findall(sentence) # Convert words to lowercase and add to the unique words set unique_words.update(word.lower() for word in words) # Return sorted list of unique words return sorted(unique_words)","solution":"import re def extract_unique_words(sentences): Extracts all unique words from a list of sentences, performs case normalization, and sorts them lexicographically. Args: - sentences: A list of strings, where each string is a sentence. Returns: - A list of unique, sorted words. # Set to store unique words unique_words = set() # Regular expression to find words word_pattern = re.compile(r'bw+b') for sentence in sentences: # Find all words ignoring punctuation words = word_pattern.findall(sentence) # Convert words to lowercase and add to the unique words set unique_words.update(word.lower() for word in words) # Return sorted list of unique words return sorted(unique_words)"},{"question":"import numpy as np def custom_activation(x: np.ndarray, activation_type: str) -> np.ndarray: Apply custom activation function on input numpy array. This function supports 'relu', 'sigmoid', and 'tanh' activation types. Parameters: x (np.ndarray): Input array to activate. activation_type (str): Type of activation function to apply. Returns: np.ndarray: Activated array. Examples: >>> custom_activation(np.array([-1, 0, 1]), 'relu') array([0, 0, 1]) >>> custom_activation(np.array([-1, 0, 1]), 'sigmoid') array([0.26894142, 0.5, 0.73105858]) >>> custom_activation(np.array([-1, 0, 1]), 'tanh') array([-0.76159416, 0, 0.76159416]) pass class NeuralNetwork: def __init__(self, input_size, hidden_size, output_size): self.input_size = input_size self.hidden_size = hidden_size self.output_size = output_size self.weights1 = np.random.rand(self.input_size, self.hidden_size) self.weights2 = np.random.rand(self.hidden_size, self.output_size) def feedforward(self, X, activation_type='relu'): self.hidden = custom_activation(np.dot(X, self.weights1), activation_type) self.output = custom_activation(np.dot(self.hidden, self.weights2), activation_type) return self.output import pytest def test_custom_activation_relu(): x = np.array([-1, 0, 1]) result = custom_activation(x, 'relu') expected = np.array([0, 0, 1]) assert np.array_equal(result, expected) def test_custom_activation_sigmoid(): x = np.array([-1, 0, 1]) result = custom_activation(x, 'sigmoid') expected = np.array([0.26894142, 0.5, 0.73105858]) assert np.allclose(result, expected) def test_custom_activation_tanh(): x = np.array([-1, 0, 1]) result = custom_activation(x, 'tanh') expected = np.array([-0.76159416, 0, 0.76159416]) assert np.allclose(result, expected) def test_custom_activation_invalid_type(): x = np.array([-1, 0, 1]) with pytest.raises(ValueError): custom_activation(x, 'invalid') def test_neural_network_feedforward_relu(): nn = NeuralNetwork(3, 3, 2) X = np.array([[1, 2, 3]]) output = nn.feedforward(X, 'relu') assert output.shape == (1, 2) def test_neural_network_feedforward_sigmoid(): nn = NeuralNetwork(3, 3, 2) X = np.array([[1, 2, 3]]) output = nn.feedforward(X, 'sigmoid') assert output.shape == (1, 2) def test_neural_network_feedforward_tanh(): nn = NeuralNetwork(3, 3, 2) X = np.array([[1, 2, 3]]) output = nn.feedforward(X, 'tanh') assert output.shape == (1, 2)","solution":"import numpy as np def custom_activation(x: np.ndarray, activation_type: str) -> np.ndarray: if activation_type == 'relu': return np.maximum(0, x) elif activation_type == 'sigmoid': return 1 / (1 + np.exp(-x)) elif activation_type == 'tanh': return np.tanh(x) else: raise ValueError(\\"Unsupported activation type. Supported types: 'relu', 'sigmoid', 'tanh'.\\") class NeuralNetwork: def __init__(self, input_size, hidden_size, output_size): self.input_size = input_size self.hidden_size = hidden_size self.output_size = output_size self.weights1 = np.random.rand(self.input_size, self.hidden_size) self.weights2 = np.random.rand(self.hidden_size, self.output_size) def feedforward(self, X, activation_type='relu'): self.hidden = custom_activation(np.dot(X, self.weights1), activation_type) self.output = custom_activation(np.dot(self.hidden, self.weights2), activation_type) return self.output"},{"question":"def flatten_list(nested_list: list) -> list: Flattens a nested list of arbitrary depth into a single list of values. Args: nested_list (list): A list potentially nested to various depths. Returns: list: A flat list containing all elements from the nested structure. Raises: TypeError: If the input is not a list. Examples: >>> flatten_list([1, 2, [3, 4], [5, [6, 7]]]) [1, 2, 3, 4, 5, 6, 7] >>> flatten_list([['a', 'b'], ['c', ['d', ['e', 'f']]], 'g']) ['a', 'b', 'c', 'd', 'e', 'f', 'g'] >>> flatten_list([-1, [-2, -3, [-4, -5], 0], 1]) [-1, -2, -3, -4, -5, 0, 1] >>> flatten_list([]) [] >>> flatten_list([[[], [[]]]]) [] try: flatten_list(\\"Not a list\\") except TypeError as e: assert str(e) == \\"Input must be a list\\" try: flatten_list(123) except TypeError as e: assert str(e) == \\"Input must be a list\\" try: flatten_list({'key': 'value'}) except TypeError as e: assert str(e) == \\"Input must be a list\\" pass","solution":"def flatten_list(nested_list): Flattens a nested list of arbitrary depth into a single list of values. Args: nested_list (list): A list potentially nested to various depths. Returns: list: A flat list containing all elements from the nested structure. Raises: TypeError: If the input is not a list. if not isinstance(nested_list, list): raise TypeError(\\"Input must be a list\\") result = [] for element in nested_list: if isinstance(element, list): result.extend(flatten_list(element)) else: result.append(element) return result"},{"question":"import os import pandas as pd import matplotlib.pyplot as plt def load_data(file_path): Loads the data from the given file path. pass def data_exploration(data): Performs exploratory data analysis on the dataset. pass def generate_visualizations(data): Generates visualizations for the dataset. pass def main(file_path): Main function to run the data analysis and visualization process. pass if __name__ == \\"__main__\\": file_path = 'path_to_your_csv_file/movies.csv' main(file_path) import pytest from solution import load_data, data_exploration, generate_visualizations def create_test_csv(file_path): Helper function to create a test CSV file. test_data = { 'title': [\\"Movie 1\\", \\"Movie 2\\", \\"Movie 3\\"], 'genre': [\\"Action\\", \\"Comedy\\", \\"Drama\\"], 'release_year': [2015, 2016, 2017], 'rating': [7.8, 6.5, None], 'box_office': [123456.78, 234567.89, None] } df = pd.DataFrame(test_data) df.to_csv(file_path, index=False) @pytest.fixture def test_csv_file(): file_path = 'test_movies.csv' create_test_csv(file_path) yield file_path os.remove(file_path) def test_load_data(test_csv_file): data = load_data(test_csv_file) assert not data.empty assert list(data.columns) == ['title', 'genre', 'release_year', 'rating', 'box_office'] def test_data_exploration(test_csv_file): data = load_data(test_csv_file) summary_stats, missing_data, data_types = data_exploration(data) assert summary_stats['release_year']['mean'] == 2016 assert missing_data['rating'] == 1 assert data_types['box_office'] == 'float64' def test_generate_visualizations(test_csv_file): data = load_data(test_csv_file) generate_visualizations(data) assert os.path.exists('rating_distribution.png') assert os.path.exists('box_office_boxplot.png') # Clean up generated files os.remove('rating_distribution.png') os.remove('box_office_boxplot.png')","solution":"import pandas as pd import matplotlib.pyplot as plt def load_data(file_path): Loads the data from the given file path. data = pd.read_csv(file_path) return data def data_exploration(data): Performs exploratory data analysis on the dataset. summary_stats = data.describe() missing_data = data.isnull().sum() data_types = data.dtypes print(\\"Summary Statistics:n\\", summary_stats) print(\\"nMissing Data:n\\", missing_data) print(\\"nData Types:n\\", data_types) return summary_stats.to_dict(), missing_data.to_dict(), data_types.to_dict() def generate_visualizations(data): Generates visualizations for the dataset. # Plotting rating distribution plt.figure(figsize=(10, 6)) data['rating'].dropna().hist(bins=20) plt.title('Distribution of Movie Ratings') plt.xlabel('Rating') plt.ylabel('Frequency') plt.savefig('rating_distribution.png') plt.close() # Plotting box office revenue distribution plt.figure(figsize=(10, 6)) data['box_office'].dropna().plot(kind='box') plt.title('Box Office Revenue Distribution') plt.ylabel('Revenue') plt.savefig('box_office_boxplot.png') plt.close() def main(file_path): Main function to run the data analysis and visualization process. data = load_data(file_path) data_exploration(data) generate_visualizations(data) if __name__ == \\"__main__\\": file_path = 'path_to_your_csv_file/movies.csv' main(file_path)"},{"question":"def find_missing_positive(nums: list[int]) -> int: Finds the first missing positive integer from a given list of positive integers. :param nums: List of integers :type nums: list[int] :return: The first missing positive integer :rtype: int Example: >>> find_missing_positive([3, 4, -1, 1]) 2 >>> find_missing_positive([1, 2, 0]) 3 >>> find_missing_positive([7, 8, 9, 11, 12]) 1 pass if __name__ == \\"__main__\\": print(find_missing_positive([3, 4, -1, 1])) # Output: 2 print(find_missing_positive([1, 2, 0])) # Output: 3 print(find_missing_positive([7, 8, 9, 11, 12])) # Output: 1","solution":"def find_missing_positive(nums: list[int]) -> int: Finds the first missing positive integer from a given list of positive integers. :param nums: List of integers :type nums: list[int] :return: The first missing positive integer :rtype: int n = len(nums) # Place each number in its right place, i.e., 1 at index 0, 2 at index 1, etc. for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # After all numbers are placed correctly, the first place where # the index doesn't match the value will be our answer. for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def is_valid_bracket_sequence(s: str) -> bool: Validates if the given string is a valid bracket sequence. A bracket sequence is considered valid if every opening bracket has a corresponding closing bracket in the correct order. >>> is_valid_bracket_sequence(\\"()\\") == True >>> is_valid_bracket_sequence(\\"()[]{}\\") == True >>> is_valid_bracket_sequence(\\"(]\\") == False >>> is_valid_bracket_sequence(\\"([)]\\") == False >>> is_valid_bracket_sequence(\\"{[]}\\") == True >>> is_valid_bracket_sequence(\\"\\") == True >>> is_valid_bracket_sequence(\\"({[)]\\") == False >>> is_valid_bracket_sequence(\\"([{}])\\") == True >>> is_valid_bracket_sequence(\\"{{{{}}}}\\") == True >>> is_valid_bracket_sequence(\\"[(({})])\\") == False pass","solution":"def is_valid_bracket_sequence(s: str) -> bool: Checks if the given string is a valid bracket sequence. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map: if not stack or stack.pop() != bracket_map[char]: return False return not stack"},{"question":"import json from typing import List, Dict def load_json(file_path: str) -> List[Dict]: Load data from a JSON file. Args: file_path (str): Path to the input JSON file. Returns: List[Dict]: List of dictionaries containing product data. ... def validate_data(data: List[Dict]) -> bool: Validate the structure of JSON data. Args: data (List[Dict]): List of dictionaries containing product data. Returns: bool: True if the data is valid, False otherwise. >>> validate_data([{\\"product_id\\": \\"12345\\", \\"name\\": \\"Product A\\", \\"price\\": \\"19.99\\", \\"quantity\\": \\"100\\"}]) True >>> validate_data([{\\"product_id\\": \\"12345\\", \\"name\\": \\"Product A\\", \\"price\\": \\"abc\\", \\"quantity\\": \\"100\\"}]) False ... def clean_data(data: List[Dict]) -> List[Dict]: Clean and normalize product data. Args: data (List[Dict]): List of dictionaries containing product data. Returns: List[Dict]: List of cleaned dictionaries. >>> clean_data([{\\"product_id\\": \\"12345\\", \\"name\\": \\" product a \\", \\"price\\": \\"19.996\\", \\"quantity\\": \\"100\\"}]) [{\\"product_id\\": \\"12345\\", \\"name\\": \\"Product A\\", \\"price\\": 20.00, \\"quantity\\": 100}] ... def save_json(data: List[Dict], file_path: str) -> None: Save data to a JSON file. Args: data (List[Dict]): List of dictionaries containing product data. file_path (str): Path to the output JSON file. ...","solution":"import json def load_json(file_path: str) -> list[dict]: with open(file_path, 'r') as file: return json.load(file) def validate_data(data: list[dict]) -> bool: required_fields = {\\"product_id\\", \\"name\\", \\"price\\", \\"quantity\\"} for entry in data: if not all(field in entry and entry[field] for field in required_fields): return False if not is_float(entry[\\"price\\"]) or not is_int(entry[\\"quantity\\"]): return False return True def is_float(value: str) -> bool: try: float(value) return True except ValueError: return False def is_int(value: str) -> bool: try: int(value) return True except ValueError: return False def clean_data(data: list[dict]) -> list[dict]: cleaned_data = [] for entry in data: try: clean_entry = { \\"product_id\\": entry[\\"product_id\\"], \\"name\\": entry[\\"name\\"].strip().title(), \\"price\\": round(float(entry[\\"price\\"]), 2), \\"quantity\\": int(entry[\\"quantity\\"]) } cleaned_data.append(clean_entry) except (ValueError, KeyError): # Skip malformed entries continue return cleaned_data def save_json(data: list[dict], file_path: str) -> None: with open(file_path, 'w') as file: json.dump(data, file, indent=4)"},{"question":"from typing import List class StringSegmenter: @staticmethod def segment_into_equal_counts(input_string: str, chars: str) -> List[str]: Split the input string into minimal segments where each segment contains the same number of occurrences of every character in the \`chars\` string. If it is not possible to split the string into such segments, return an empty list. >>> StringSegmenter.segment_into_equal_counts(\\"abcabc\\", \\"abc\\") ['abc', 'abc'] >>> StringSegmenter.segment_into_equal_counts(\\"aabbcc\\", \\"abc\\") ['aabbcc'] >>> StringSegmenter.segment_into_equal_counts(\\"abbcc\\", \\"abc\\") [] pass @staticmethod def segment_by_length(input_string: str, length: int) -> List[str]: Split the input string into segments of a given length. If the last segment is shorter than the specified length, include it as is. >>> StringSegmenter.segment_by_length(\\"abcdefghijkl\\", 3) ['abc', 'def', 'ghi', 'jkl'] >>> StringSegmenter.segment_by_length(\\"abcdefghij\\", 3) ['abc', 'def', 'ghi', 'j'] pass @staticmethod def segment_by_delimiter(input_string: str, delimiter: str) -> List[str]: Split the input string by a specified delimiter string. >>> StringSegmenter.segment_by_delimiter(\\"one-two-three\\", \\"-\\") ['one', 'two', 'three'] >>> StringSegmenter.segment_by_delimiter(\\"one--two---three\\", \\"-\\") ['one', '', 'two', '', '', 'three'] pass @staticmethod def is_segmentable(input_string: str, chars: str) -> bool: Check if the input string can be segmented such that each segment contains the same number of occurrences of each character in the \`chars\` string. >>> StringSegmenter.is_segmentable(\\"abcabc\\", \\"abc\\") True >>> StringSegmenter.is_segmentable(\\"abcab\\", \\"abc\\") False >>> StringSegmenter.is_segmentable(\\"abcddabc\\", \\"abcd\\") True pass # Example usage assert StringSegmenter.segment_into_equal_counts(\\"aabbcc\\", \\"abc\\") == [\\"aabbcc\\"] assert StringSegmenter.segment_into_equal_counts(\\"abcabc\\", \\"abc\\") == [\\"abc\\", \\"abc\\"] assert StringSegmenter.segment_into_equal_counts(\\"abbcc\\", \\"abc\\") == [] assert StringSegmenter.segment_by_length(\\"abcdefghijkl\\", 3) == [\\"abc\\", \\"def\\", \\"ghi\\", \\"jkl\\"] assert StringSegmenter.segment_by_length(\\"abcdefghij\\", 3) == [\\"abc\\", \\"def\\", \\"ghi\\", \\"j\\"] assert StringSegmenter.segment_by_delimiter(\\"one-two-three\\", \\"-\\") == [\\"one\\", \\"two\\", \\"three\\"] assert StringSegmenter.is_segmentable(\\"abcabc\\", \\"abc\\") == True assert StringSegmenter.is_segmentable(\\"abcab\\", \\"abc\\") == False","solution":"from typing import List class StringSegmenter: @staticmethod def segment_into_equal_counts(input_string: str, chars: str) -> List[str]: count = {char: 0 for char in chars} segment = [] result = [] for char in input_string: if char in count: count[char] += 1 segment.append(char) if all(count[c] == count[chars[0]] for c in count): result.append(''.join(segment)) segment = [] count = {char: 0 for char in chars} else: segment.append(char) if any(count[c] != 0 for c in count): # Check if any leftover counts return [] return result @staticmethod def segment_by_length(input_string: str, length: int) -> List[str]: return [input_string[i:i + length] for i in range(0, len(input_string), length)] @staticmethod def segment_by_delimiter(input_string: str, delimiter: str) -> List[str]: return input_string.split(delimiter) @staticmethod def is_segmentable(input_string: str, chars: str) -> bool: count = {char: 0 for char in chars} for char in input_string: if char in count: count[char] += 1 # All counts must be equal and greater than zero return len(set(count.values())) == 1 and next(iter(count.values())) > 0"},{"question":"from typing import List def largest_non_adjacent_sum(nums: List[int]) -> int: Calculate the largest sum of a non-adjacent subarray from a given list of integers. >>> largest_non_adjacent_sum([2, 4, 6, 2, 5]) 13 >>> largest_non_adjacent_sum([5, 1, 1, 5]) 10 >>> largest_non_adjacent_sum([-1, -2, -3, -4]) 0 >>> largest_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> largest_non_adjacent_sum([]) 0","solution":"from typing import List def largest_non_adjacent_sum(nums: List[int]) -> int: if not nums: return 0 if len(nums) == 1: return max(0, nums[0]) include, exclude = 0, 0 for num in nums: # Current max excluding num new_exclude = max(include, exclude) # Current max including num include = exclude + num exclude = new_exclude return max(include, exclude)"},{"question":"def is_rotation(arr1: List[int], arr2: List[int]) -> bool: Checks if arr2 is a rotation of arr1. >>> is_rotation([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]) == True >>> is_rotation([1, 2, 3, 4, 5], [4, 5, 1, 2, 3]) == True >>> is_rotation([1, 2, 3, 4, 5], [2, 3, 4, 5, 6]) == False >>> is_rotation([1, 2, 3], [1, 2, 3]) == True >>> is_rotation([], []) == True >>> is_rotation([1, 2, 3], [2, 3, 1, 4]) == False >>> is_rotation([1], [1]) == True >>> is_rotation([1], [2]) == False","solution":"from typing import List def is_rotation(arr1: List[int], arr2: List[int]) -> bool: if len(arr1) != len(arr2): return False concatenated = arr1 + arr1 str_arr2 = ''.join(map(str, arr2)) str_concatenated = ''.join(map(str, concatenated)) return str_arr2 in str_concatenated"},{"question":"from typing import List def min_cost_path(matrix: List[List[int]]) -> int: Compute the minimal cost required for the robot to reach the bottom-right corner of the grid from the top-left corner. Example: >>> min_cost_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_path([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21 pass # Your implementation here def test_min_cost_path_example_1(): matrix = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_cost_path(matrix) == 7 def test_min_cost_path_example_2(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert min_cost_path(matrix) == 21 def test_min_cost_path_single_row(): matrix = [[1, 3, 1, 2]] assert min_cost_path(matrix) == 7 def test_min_cost_path_single_column(): matrix = [[1], [4], [6], [2]] assert min_cost_path(matrix) == 13 def test_min_cost_path_single_cell(): matrix = [[5]] assert min_cost_path(matrix) == 5 def test_min_cost_path_large_grid(): matrix = [[1] * 1000 for _ in range(1000)] assert min_cost_path(matrix) == 1999","solution":"from typing import List def min_cost_path(matrix: List[List[int]]) -> int: n, m = len(matrix), len(matrix[0]) dp = [[0] * m for _ in range(n)] # Initialize the dp array with the cost of the starting point dp[0][0] = matrix[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] # The bottom-right corner will have the minimal cost return dp[n-1][m-1]"},{"question":"import bisect class ContactList: A class to efficiently manage a sorted list of contacts allowing for fast search, insertion, and deletion. def __init__(self): Initializes an empty contact list. self.contacts = [] def add_contact(self, name: str) -> None: Adds a contact to the list in sorted order. :param name: The name of the contact to add. # Your code here def remove_contact(self, name: str) -> bool: Removes a contact from the list if it exists. :param name: The name of the contact to remove. :return: True if the contact was removed, False if the contact was not found. # Your code here def find_contact(self, name: str) -> bool: Searches for a contact in the list. :param name: The name of the contact to search for. :return: True if the contact is found, False otherwise. # Your code here def test_add_contact(): contacts = ContactList() contacts.add_contact(\\"Alice\\") contacts.add_contact(\\"Bob\\") contacts.add_contact(\\"Charlie\\") assert contacts.contacts == [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] def test_remove_contact(): contacts = ContactList() contacts.add_contact(\\"Alice\\") contacts.add_contact(\\"Bob\\") assert contacts.remove_contact(\\"Alice\\") == True assert contacts.remove_contact(\\"Alice\\") == False assert contacts.contacts == [\\"Bob\\"] def test_find_contact(): contacts = ContactList() contacts.add_contact(\\"Alice\\") contacts.add_contact(\\"Bob\\") contacts.add_contact(\\"Charlie\\") assert contacts.find_contact(\\"Alice\\") == True assert contacts.find_contact(\\"David\\") == False assert contacts.find_contact(\\"Charlie\\") == True contacts.remove_contact(\\"Charlie\\") assert contacts.find_contact(\\"Charlie\\") == False def test_sorted_order(): contacts = ContactList() contacts.add_contact(\\"Charlie\\") contacts.add_contact(\\"Alice\\") contacts.add_contact(\\"Bob\\") assert contacts.contacts == [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] def test_add_remove_find_contact(): contacts = ContactList() contacts.add_contact(\\"David\\") contacts.add_contact(\\"Alice\\") contacts.add_contact(\\"Eve\\") assert contacts.find_contact(\\"David\\") == True assert contacts.remove_contact(\\"Eve\\") == True assert contacts.find_contact(\\"Eve\\") == False","solution":"import bisect class ContactList: def __init__(self): Initializes an empty contact list. self.contacts = [] def add_contact(self, name: str) -> None: Adds a contact to the list in sorted order. :param name: The name of the contact to add. bisect.insort(self.contacts, name) def remove_contact(self, name: str) -> bool: Removes a contact from the list if it exists. :param name: The name of the contact to remove. :return: True if the contact was removed, False if the contact was not found. index = bisect.bisect_left(self.contacts, name) if index < len(self.contacts) and self.contacts[index] == name: self.contacts.pop(index) return True return False def find_contact(self, name: str) -> bool: Searches for a contact in the list. :param name: The name of the contact to search for. :return: True if the contact is found, False otherwise. index = bisect.bisect_left(self.contacts, name) return index < len(self.contacts) and self.contacts[index] == name"},{"question":"def can_achieve_target(initial: list[int], operations: list[tuple[str, int]], target: list[int]) -> bool: Determines if a target array can be achieved through a sequence of operations on the initial array. Operations can either be 'append' or 'delete'. Parameters: initial (list[int]): Initial state of the array. operations (list[tuple[str, int]]): List of operations to be performed on the array. target (list[int]): Target array to be achieved. Returns: bool: True if the target array can be achieved, False otherwise. >>> can_achieve_target([1, 2, 3], [('append', 4), ('delete', 2), ('append', 5)], [1, 3, 4, 5]) True >>> can_achieve_target([1, 2, 3], [('append', 4), ('delete', 2), ('append', 5), ('delete', 6)], [1, 3, 4, 5]) False >>> can_achieve_target([1, 2, 3], [('append', 4), ('delete', 2), ('append', 5), ('delete', 1)], [3, 4, 5]) True","solution":"def can_achieve_target(initial: list[int], operations: list[tuple[str, int]], target: list[int]) -> bool: Checks if the target array can be achieved through a sequence of operations on the initial array. Operations can either be 'append' or 'delete'. Parameters: initial (list[int]): Initial state of the array. operations (list[tuple[str, int]]): List of operations to be performed on the array. target (list[int]): Target array to be achieved. Returns: bool: True if the target array can be achieved, False otherwise. current_array = initial.copy() for operation, value in operations: if operation == 'append': current_array.append(value) elif operation == 'delete': if value in current_array: current_array.remove(value) else: return False return current_array == target"},{"question":"# Interactive Directory System Context You have been tasked with developing a command-line interactive directory system that enables users to navigate through directories, add or remove files, and display the directory structure. This question aims to test your ability to handle nested data structures and implement basic file system operations. Problem Statement 1. **Navigate**: Implement a method \`navigate(self, path: str)\` that navigates to the specified directory. * **Input**: A string \`path\` representing the path to navigate to. Path segments are separated by forward slashes (\`/\`). * **Output**: Modify the current directory context. 2. **Add File**: Implement a method \`add_file(self, filename: str)\` to add a file to the current directory. * **Input**: \`filename\` is a string representing the name of the file to be added. * **Output**: Modify the directory to include the new file. 3. **Remove File**: Implement a method \`remove_file(self, filename: str)\` to remove a file from the current directory. * **Input**: \`filename\` is a string representing the name of the file to be removed. * **Output**: Modify the directory to remove the file specified. 4. **Display Structure**: Implement a method \`display(self) -> None\` to display the entire directory structure from the root. * **Input**: None. * **Output**: Print the full directory structure in a readable format. # Implementation Details * Implement the following methods inside the \`DirectorySystem\` class provided: class DirectorySystem: def __init__(self): self.root = {\\"type\\": \\"directory\\", \\"contents\\": {}} self.current_dir = self.root def navigate(self, path: str): # Your implementation here def add_file(self, filename: str): # Your implementation here def remove_file(self, filename: str): # Your implementation here def display(self) -> None: # Your implementation here def _print_structure(self, directory, indent): for name, info in directory.items(): if info['type'] == 'directory': print(\\" \\" * indent + name + \\"/\\") self._print_structure(info['contents'], indent + 1) else: print(\\" \\" * indent + name) # Example Usage ds = DirectorySystem() # Adding files to the root directory ds.add_file(\\"file1.txt\\") ds.add_file(\\"file2.txt\\") # Creating a new directory and navigating into it ds.navigate(\\"new_folder\\") ds.add_file(\\"file3.txt\\") # Display the directory structure ds.display() # Output should display the structure: # / # file1.txt # file2.txt # new_folder/ # file3.txt # Constraints: - \`filename\` and \`path\` are guaranteed to be valid strings. - The system should correctly handle nested directories and files. - Navigating to a non-existing directory should raise an appropriate error. # Unit Test import pytest from solution import DirectorySystem def test_navigate_and_add_file(): ds = DirectorySystem() ds.add_file(\\"root_file.txt\\") ds.navigate(\\"/\\") # This should not raise any error since it's the root ds.current_dir[\\"contents\\"][\\"new_folder\\"] = {\\"type\\": \\"directory\\", \\"contents\\": {}} ds.navigate(\\"new_folder\\") ds.add_file(\\"nested_file.txt\\") assert \\"nested_file.txt\\" in ds.current_dir[\\"contents\\"] assert ds.current_dir[\\"contents\\"][\\"nested_file.txt\\"][\\"type\\"] == \\"file\\" def test_add_duplicate_file(): ds = DirectorySystem() ds.add_file(\\"file.txt\\") with pytest.raises(ValueError, match=r\\"File file.txt already exists.\\"): ds.add_file(\\"file.txt\\") def test_remove_file(): ds = DirectorySystem() ds.add_file(\\"file_to_remove.txt\\") ds.remove_file(\\"file_to_remove.txt\\") assert \\"file_to_remove.txt\\" not in ds.current_dir[\\"contents\\"] def test_remove_nonexistent_file(): ds = DirectorySystem() with pytest.raises(ValueError, match=r\\"File nonexistent.txt does not exist.\\"): ds.remove_file(\\"nonexistent.txt\\") def test_navigate_nonexistent_directory(): ds = DirectorySystem() with pytest.raises(ValueError, match=r\\"Directory nonexisting does not exist.\\"): ds.navigate(\\"nonexisting\\") def test_display(capsys): ds = DirectorySystem() ds.add_file(\\"file1.txt\\") ds.add_file(\\"file2.txt\\") ds.current_dir[\\"contents\\"][\\"folder1\\"] = {\\"type\\": \\"directory\\", \\"contents\\": {}} ds.current_dir[\\"contents\\"][\\"folder1\\"][\\"contents\\"][\\"file3.txt\\"] = {\\"type\\": \\"file\\"} ds.display() captured = capsys.readouterr() assert captured.out == \\"/n file1.txtn file2.txtn folder1/n file3.txtn\\"","solution":"class DirectorySystem: def __init__(self): self.root = {\\"type\\": \\"directory\\", \\"contents\\": {}} self.current_dir = self.root def navigate(self, path: str): parts = path.strip(\\"/\\").split(\\"/\\") temp_dir = self.root for part in parts: if not part: # Skip any empty strings (e.g., leading or trailing slashes) continue if part not in temp_dir[\\"contents\\"] or temp_dir[\\"contents\\"][part][\\"type\\"] != \\"directory\\": raise ValueError(f\\"Directory {part} does not exist.\\") temp_dir = temp_dir[\\"contents\\"][part] self.current_dir = temp_dir def add_file(self, filename: str): if filename in self.current_dir[\\"contents\\"]: raise ValueError(f\\"File {filename} already exists.\\") self.current_dir[\\"contents\\"][filename] = {\\"type\\": \\"file\\"} def remove_file(self, filename: str): if filename not in self.current_dir[\\"contents\\"] or self.current_dir[\\"contents\\"][filename][\\"type\\"] != \\"file\\": raise ValueError(f\\"File {filename} does not exist.\\") del self.current_dir[\\"contents\\"][filename] def display(self) -> None: print(\\"/\\") self._print_structure(self.root[\\"contents\\"], 1) def _print_structure(self, directory, indent): for name, info in directory.items(): if info[\\"type\\"] == \\"directory\\": print(\\" \\" * indent + name + \\"/\\") self._print_structure(info[\\"contents\\"], indent + 1) else: print(\\" \\" * indent + name)"},{"question":"def can_reach_destination(n: int, commands: str) -> bool: Determine if a robot can reach the bottom-right corner of an n x n grid following specific commands. The robot can move: - 'U' (up) - 'D' (down) - 'L' (left) - 'R' (right) The robot starts at position (0, 0) and must avoid moving outside the grid boundaries. The bottom-right corner is at position (n-1, n-1). Args: - n (int): Grid dimension size (2 <= n <= 10^4). - commands (str): String of commands ('U', 'D', 'L', 'R') the robot will follow (1 <= len(commands) <= 10^6). Returns: - bool: True if the robot can reach the bottom-right corner, False otherwise. Raises: - TypeError: If inputs are of incorrect types. - ValueError: If input values are out of the expected range or commands contain invalid characters. Examples: >>> can_reach_destination(3, \\"RRDD\\") True >>> can_reach_destination(3, \\"RRDDD\\") False >>> can_reach_destination(3, \\"RURDLD\\") True >>> can_reach_destination(2, \\"RR\\") False >>> can_reach_destination(2, \\"DD\\") False >>> can_reach_destination(4, \\"DRDRRRDDLLLU\\") False pass # Define test cases def test_can_reach_destination_basic(): assert can_reach_destination(3, \\"RRDD\\") == True assert can_reach_destination(3, \\"RRDDD\\") == False assert can_reach_destination(3, \\"RURDLD\\") == False assert can_reach_destination(3, \\"RRDD\\") == True def test_can_reach_destination_invalid_moves(): assert can_reach_destination(2, \\"RR\\") == False assert can_reach_destination(2, \\"DD\\") == False def test_can_reach_destination_boundary(): assert can_reach_destination(4, \\"DRDRRRDDLLLU\\") == False assert can_reach_destination(2, \\"DR\\") == True def test_can_reach_destination_invalid_input(): try: can_reach_destination(\\"3\\", \\"RRDD\\") except TypeError: assert True else: assert False try: can_reach_destination(3, 123) except TypeError: assert True else: assert False try: can_reach_destination(3, \\"RRDRX\\") except ValueError: assert True else: assert False try: can_reach_destination(1, \\"R\\") except ValueError: assert True else: assert False def test_can_reach_destination_edge_cases(): assert can_reach_destination(2, \\"RD\\") == True assert can_reach_destination(2, \\"DR\\") == True","solution":"def can_reach_destination(n: int, commands: str) -> bool: # Input validation if not isinstance(n, int) or not isinstance(commands, str): raise TypeError(\\"Invalid input types. 'n' should be an integer and 'commands' should be a string.\\") # Early exits based on constraints if n < 2 or n > 10**4: raise ValueError(\\"Invalid grid size. 'n' should be between 2 and 10^4.\\") if len(commands) < 1 or len(commands) > 10**6: raise ValueError(\\"Invalid commands length. It should be between 1 and 10^6.\\") valid_commands = {'U', 'D', 'L', 'R'} if not all(c in valid_commands for c in commands): raise ValueError(\\"Invalid commands. Commands should only contain 'U', 'D', 'L', 'R'.\\") x, y = 0, 0 # Starting position (top-left corner) for command in commands: if command == 'U': x -= 1 elif command == 'D': x += 1 elif command == 'L': y -= 1 elif command == 'R': y += 1 # Check boundaries if x < 0 or x >= n or y < 0 or y >= n: return False # Check if we reached the bottom-right corner return x == n-1 and y == n-1"},{"question":"# Problem: Implement Matrix Multiplication Given two matrices \`A\` and \`B\`, implement a function to perform matrix multiplication and return the resulting matrix. Matrix multiplication is defined as the dot product of the rows of \`A\` and the columns of \`B\`. Input * **A**: A list of lists of integers representing the first matrix. * **B**: A list of lists of integers representing the second matrix. Output * Return a list of lists of integers representing the resulting matrix after multiplication. # Constraints 1. The number of columns in \`A\` must be equal to the number of rows in \`B\`. 2. Elements in matrices \`A\` and \`B\` will be integers within the range \`-1000 <= element <= 1000\`. 3. The dimensions of \`A\` and \`B\` will be between 1 and 100 inclusive. # Example A = [ [1, 2, 3], [4, 5, 6] ] B = [ [7, 8], [9, 10], [11, 12] ] print(matrix_multiplication(A, B)) # Outputs: # [ # [58, 64], # [139, 154] # ] A = [ [1, 4], [2, 5], [3, 6] ] B = [ [7, 8, 9], [10, 11, 12] ] print(matrix_multiplication(A, B)) # Outputs: # [ # [47, 52, 57], # [64, 71, 78], # [81, 90, 99] # ] # Notes * Ensure to handle edge cases such as single-element matrices and non-square matrices. * Validate that multiplication is possible with given matrix dimensions and raise a \`ValueError\` with the message \\"Matrix dimensions mismatch\\" if they are not compatible. * Aim to optimize your solution for performance considering the constraints. # Function Signature def matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Perform matrix multiplication of A and B and return the result as a new matrix. The number of columns in A must be equal to the number of rows in B. Args: - A (List[List[int]]): The first matrix. - B (List[List[int]]): The second matrix. Returns: - List[List[int]]: The resulting matrix after multiplication. Raises: - ValueError: If the matrices dimensions do not match for multiplication. # Implement this function.","solution":"from typing import List def matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Perform matrix multiplication of A and B and return the result as a new matrix. The number of columns in A must be equal to the number of rows in B. Args: - A (List[List[int]]): The first matrix. - B (List[List[int]]): The second matrix. Returns: - List[List[int]]: The resulting matrix after multiplication. Raises: - ValueError: If the matrices dimensions do not match for multiplication. # Get the dimensions of the matrices rows_A, cols_A = len(A), len(A[0]) if A else 0 rows_B, cols_B = len(B), len(B[0]) if B else 0 # Check if matrices can be multiplied if cols_A != rows_B: raise ValueError(\\"Matrix dimensions mismatch\\") # Initialize the resultant matrix with zero values result = [[0 for _ in range(cols_B)] for _ in range(rows_A)] # Perform the matrix multiplication for i in range(rows_A): for j in range(cols_B): for k in range(cols_A): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"def custom_sort(strings: list) -> list: Sorts a list of strings based on embedded numeric and alphabetical segments. Examples: >>> custom_sort([\\"10apple\\", \\"2banana\\", \\"1cherry\\", \\"22date\\", \\"2apricot\\"]) ['1cherry', '2apricot', '2banana', '10apple', '22date'] >>> custom_sort([\\"30cat\\", \\"2dog\\", \\"10bird\\", \\"2antelope\\"]) ['2antelope', '2dog', '10bird', '30cat'] >>> custom_sort([]) [] >>> custom_sort([\\"1alpha\\", \\"2beta\\"]) ['1alpha', '2beta'] pass","solution":"def custom_sort(strings: list) -> list: Sorts a list of strings based on embedded numeric and alphabetical segments. Examples: >>> custom_sort([\\"10apple\\", \\"2banana\\", \\"1cherry\\", \\"22date\\", \\"2apricot\\"]) ['1cherry', '2apricot', '2banana', '10apple', '22date'] >>> custom_sort([\\"30cat\\", \\"2dog\\", \\"10bird\\", \\"2antelope\\"]) ['2antelope', '2dog', '10bird', '30cat'] >>> custom_sort([]) [] >>> custom_sort([\\"1alpha\\", \\"2beta\\"]) ['1alpha', '2beta'] def extract_parts(s): # Find the position where the numeric part ends and the alphabetic part starts for i, char in enumerate(s): if char.isalpha(): break numeric_part = int(s[:i]) # Convert the numeric part to an integer alphabetic_part = s[i:] # Remainder is the alphabetic part return numeric_part, alphabetic_part return sorted(strings, key=extract_parts)"},{"question":"def longest_unique_substring(s: str) -> str: Finds the longest substring without repeating characters in a given input string. >>> longest_unique_substring(\\"abcabcbb\\") 'abc' >>> longest_unique_substring(\\"bbbbb\\") 'b' >>> longest_unique_substring(\\"pwwkew\\") 'wke' >>> longest_unique_substring(\\"abcdedcba\\") 'abcde' >>> longest_unique_substring(\\"a\\") 'a' >>> longest_unique_substring(\\"abcdefghijklmnopqrstuvwxyz\\") 'abcdefghijklmnopqrstuvwxyz' >>> longest_unique_substring(\\"aaaaaaabaaaaa\\") 'ab' >>> longest_unique_substring(\\"AaBbCcDdEeFfGg\\") 'AaBbCcDdEeFfGg' >>> longest_unique_substring(\\"\\") ''","solution":"def longest_unique_substring(s: str) -> str: Finds the longest substring without repeating characters in a given string. char_index_map = {} start = 0 max_length = 0 max_substring = \\"\\" for end in range(len(s)): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end current_length = end - start + 1 if current_length > max_length: max_length = current_length max_substring = s[start:end + 1] return max_substring"},{"question":"Write a function \`validate_isbn\` that checks if a given ISBN-10 string is valid or not. The ISBN-10 is a 10-character code that contains 9 digits followed by an optional 'X' which stands for the hexadecimal value 10. The formula for checking the validity of an ISBN-10 is as follows: - Take the first digit and multiply it by 10, the second digit by 9, and so on until the 9th digit which is multiplied by 2. - Add these values together. - Add the last digit (or 'X' treated as 10) directly to the sum. - If the resulting sum is divisible by 11, the ISBN-10 is valid. def validate_isbn(isbn: str) -> bool: Input Parameters ---------------- isbn : str The ISBN-10 string to be validated. Returns ------- result : bool True if the ISBN-10 is valid, otherwise False. Examples -------- >>> validate_isbn(\\"0306406152\\") True >>> validate_isbn(\\"123456789X\\") True >>> validate_isbn(\\"1234567890\\") False >>> validate_isbn(\\"12345678X0\\") False >>> validate_isbn(\\"12345678\\") False if len(isbn) != 10: return False if not isbn[:-1].isdigit() or (isbn[-1] not in '0123456789X'): return False total = 0 for i in range(9): total += int(isbn[i]) * (10 - i) last_digit = 10 if isbn[-1] == 'X' else int(isbn[-1]) total += last_digit return total % 11 == 0","solution":"def validate_isbn(isbn: str) -> bool: Input Parameters ---------------- isbn : str The ISBN-10 string to be validated. Returns ------- result : bool True if the ISBN-10 is valid, otherwise False. if len(isbn) != 10: return False if not isbn[:-1].isdigit() or (isbn[-1] not in '0123456789X'): return False total = 0 for i in range(9): total += int(isbn[i]) * (10 - i) last_digit = 10 if isbn[-1] == 'X' else int(isbn[-1]) total += last_digit return total % 11 == 0"},{"question":"from typing import List, Tuple def find_convex_hull(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Computes the convex hull of a set of 2D points using Andrew's monotone chain algorithm. # Remove duplicates points = sorted(set(points)) # There must be at least 3 unique points if len(points) < 3: raise ValueError(\\"At least three unique points are required to form a convex hull\\") # Helper function to determine orientation def cross_product(o, a, b): return (a[0] - o[0]) * (b[1] - o[0]) * (b[0] - o[0]) # Building the lower hull lower = [] for p in points: while len(lower) >= 2 and cross_product(lower[-2], lower[-1], p) <= 0: lower.pop() lower.append(p) # Building the upper hull upper = [] for p in reversed(points): while len(upper) >= 2 and cross_product(upper[-2], upper[-1], p) <= 0: upper.pop() upper.append(p) # Concatenate lower and upper hull to make full hull, # excluding the last point of each half because it's repeated at the beginning of the other half return lower[:-1] + upper[:-1]","solution":"from typing import List, Tuple def find_convex_hull(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Computes the convex hull of a set of 2D points using Andrew's monotone chain algorithm. # Remove duplicates points = sorted(set(points)) # There must be at least 3 unique points if len(points) < 3: raise ValueError(\\"At least three unique points are required to form a convex hull\\") # Helper function to determine orientation def cross_product(o, a, b): return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]) # Building the lower hull lower = [] for p in points: while len(lower) >= 2 and cross_product(lower[-2], lower[-1], p) <= 0: lower.pop() lower.append(p) # Building the upper hull upper = [] for p in reversed(points): while len(upper) >= 2 and cross_product(upper[-2], upper[-1], p) <= 0: upper.pop() upper.append(p) # Concatenate lower and upper hull to make full hull, # excluding the last point of each half because it's repeated at the beginning of the other half return lower[:-1] + upper[:-1]"},{"question":"import math def calculate_geometry(shape: str, *dimensions: float) -> dict: Calculates the area and perimeter of a given geometric shape. :param shape: String representing the type of shape. Can be \\"rectangle\\", \\"triangle\\", or \\"circle\\". :param dimensions: Dimensions required to calculate the area and perimeter. - Rectangle: width and height - Triangle: base and height (assuming equilateral triangle for perimeter) - Circle: radius :return: Dictionary containing 'area' and 'perimeter' of the shape. >>> calculate_geometry(\\"rectangle\\", 5, 10) {'area': 50, 'perimeter': 30} >>> calculate_geometry(\\"triangle\\", 6, 8) {'area': 24.0, 'perimeter': 18} >>> calculate_geometry(\\"circle\\", 7) {'area': 153.93804002589985, 'perimeter': 43.982297150257104}","solution":"import math def calculate_geometry(shape: str, *dimensions: float) -> dict: Calculates the area and perimeter of a given geometric shape. :param shape: String representing the type of shape. Can be \\"rectangle\\", \\"triangle\\", or \\"circle\\". :param dimensions: Dimensions required to calculate the area and perimeter. - Rectangle: width and height - Triangle: base and height (assuming equilateral triangle for perimeter) - Circle: radius :return: Dictionary containing 'area' and 'perimeter' of the shape. if shape == \\"rectangle\\": width, height = dimensions area = width * height perimeter = 2 * (width + height) elif shape == \\"triangle\\": base, height = dimensions area = 0.5 * base * height perimeter = 3 * base # assuming equilateral triangle for simplicity elif shape == \\"circle\\": radius = dimensions[0] area = math.pi * radius ** 2 perimeter = 2 * math.pi * radius else: raise ValueError(\\"Unsupported shape!\\") return {\\"area\\": area, \\"perimeter\\": perimeter}"},{"question":"def word_count(sentence: str) -> dict: Counts the frequency of each word in a given sentence. Words are case-insensitive and punctuation is ignored. Examples: >>> word_count(\\"Hello world!\\") == {\\"hello\\": 1, \\"world\\": 1} >>> word_count(\\"This is a test. A simple test!\\") == {\\"this\\": 1, \\"is\\": 1, \\"a\\": 2, \\"test\\": 2, \\"simple\\": 1} >>> word_count(\\"Python, python. PYTHON!\\") == {\\"python\\": 3} >>> word_count(\\"\\") == {} >>> word_count(\\"...,,!\\") == {} >>> word_count(\\" Mixed CASE words.\\") == {\\"mixed\\": 1, \\"case\\": 1, \\"words\\": 1}","solution":"import re from collections import defaultdict def word_count(sentence: str) -> dict: Returns the frequency count of each word in the input sentence. Words are considered case-insensitive and punctuation is ignored. # Use regular expressions to remove punctuation cleaned_sentence = re.sub(r'[^ws]', '', sentence) # Split the sentence into words and convert to lower case words = cleaned_sentence.lower().split() # Count the frequency of each word word_counts = defaultdict(int) for word in words: word_counts[word] += 1 return dict(word_counts)"},{"question":"def projectile_motion_simulation(initial_position: tuple, initial_velocity: tuple, time_span: float, step_size: float) -> np.ndarray: Simulates the projectile motion using Verlet integration. Parameters: initial_position (tuple): Initial x and y coordinates (x0, y0). initial_velocity (tuple): Initial velocity components (vx0, vy0). time_span (float): Total time for which the simulation runs. Must be positive. step_size (float): Time increment for each step. Must be positive. Returns: np.ndarray: Array of shape (n, 2) containing x and y coordinates of the projectile at each timestep. >>> import numpy as np >>> initial_position = (0.0, 0.0) >>> initial_velocity = (10.0, 10.0) >>> time_span = 2.0 >>> step_size = 0.1 >>> trajectory = projectile_motion_simulation(initial_position, initial_velocity, time_span, step_size) >>> trajectory.shape == (21, 2) True >>> np.allclose(trajectory[0], [0.0, 0.0]) True >>> np.allclose(trajectory[1], [1.0, 0.9505], atol=1e-3) True pass","solution":"import numpy as np def projectile_motion_simulation(initial_position: tuple, initial_velocity: tuple, time_span: float, step_size: float) -> np.ndarray: Simulates the projectile motion using Verlet integration. Parameters: initial_position (tuple): Initial x and y coordinates (x0, y0). initial_velocity (tuple): Initial velocity components (vx0, vy0). time_span (float): Total time for which the simulation runs. Must be positive. step_size (float): Time increment for each step. Must be positive. Returns: np.ndarray: Array of shape (n, 2) containing x and y coordinates of the projectile at each timestep. if time_span <= 0 or step_size <= 0: raise ValueError(\\"time_span and step_size must be positive\\") num_steps = int(time_span / step_size) + 1 trajectory = np.zeros((num_steps, 2)) x0, y0 = initial_position vx0, vy0 = initial_velocity trajectory[0] = [x0, y0] # Initial positions x_new = x0 + vx0 * step_size y_new = y0 + vy0 * step_size - 0.5 * 9.81 * step_size**2 trajectory[1] = [x_new, y_new] for i in range(1, num_steps-1): x_current, y_current = trajectory[i] x_prev, y_prev = trajectory[i-1] x_next = 2 * x_current - x_prev + 0 y_next = 2 * y_current - y_prev - 9.81 * step_size**2 trajectory[i+1] = [x_next, y_next] return trajectory"},{"question":"def index_sum(lst: list[int], index_pairs: list[tuple[int, int]]) -> int: Calculates the total sum of elements in the list \`lst\` based on ranges provided in \`index_pairs\`. Args: lst (list[int]): The list of integers. index_pairs (list[tuple[int, int]]): List of tuples containing pairs of start and end indices (inclusive). Returns: int: The total sum of all sub-lists derived from the index pairs. Examples: >>> index_sum([1, 2, 3, 4, 5], [(0, 1), (2, 4)]) 15 >>> index_sum([10, 20, 30, 40], [(1, 2), (0, 3)]) 120 >>> index_sum([5, 15, 25, 35, 45], [(0, 0), (3, 3)]) 40","solution":"def index_sum(lst: list[int], index_pairs: list[tuple[int, int]]) -> int: Computes the total sum of elements in the list \`lst\` based on ranges provided in \`index_pairs\`. total_sum = 0 for start, end in index_pairs: total_sum += sum(lst[start:end+1]) return total_sum"},{"question":"def vending_machine(price: float, money_inserted: float) -> dict: Calculate the change to be returned by the vending machine in the least number of coins. Args: price (float): Purchase price of the item money_inserted (float): Money inserted into the machine Returns: dict: A dictionary with the number of each coin type needed for change Raises: ValueError: If price or money_inserted is negative or if money_inserted is less than price >>> vending_machine(0.75, 1.00) {25: 1} >>> vending_machine(1.25, 2.00) {50: 1, 25: 1} >>> vending_machine(1.10, 1.50) {25: 1, 10: 1, 5: 1} >>> vending_machine(1.00, 1.00) {} >>> vending_machine(0.99, 1.00) {1: 1} >>> vending_machine(0.99, 0.98) Traceback (most recent call last): ... ValueError: money_inserted must be greater than or equal to price >>> vending_machine(-1.00, 1.00) Traceback (most recent call last): ... ValueError: price and money_inserted must be non-negative >>> vending_machine(1.00, -0.50) Traceback (most recent call last): ... ValueError: price and money_inserted must be non-negative","solution":"def vending_machine(price: float, money_inserted: float) -> dict: Calculate the change to be returned by the vending machine in the least number of coins. Args: price (float): Purchase price of the item money_inserted (float): Money inserted into the machine Returns: dict: A dictionary with the number of each coin type needed for change Raises: ValueError: If price or money_inserted is negative or if money_inserted is less than price if price < 0 or money_inserted < 0: raise ValueError(\\"price and money_inserted must be non-negative\\") if money_inserted < price: raise ValueError(\\"money_inserted must be greater than or equal to price\\") # Convert dollars to cents to avoid floating-point precision issues price_cents = round(price * 100) money_inserted_cents = round(money_inserted * 100) change_cents = money_inserted_cents - price_cents # Denominations of the coins available coin_types = [50, 25, 10, 5, 1] change_dict = {} for coin in coin_types: if change_cents >= coin: coin_count = change_cents // coin change_cents -= coin_count * coin change_dict[coin] = coin_count return change_dict"},{"question":"import re from collections import Counter def find_highest_frequency_word(text: str) -> str: Find the word that appears most frequently in the input text. If there is a tie, return the word that comes first lexicographically. Punctuation and case should be ignored. >>> find_highest_frequency_word(\\"apple! bear bear. apple, bear. Mango mango mango! apple\\") \\"apple\\" >>> find_highest_frequency_word(\\"dog cat! dog. cat? elephant, cat elephant elephant. dog!\\") \\"cat\\" >>> find_highest_frequency_word(\\"it's a tie tie-break!\\") \\"a\\" # Test cases def test_single_word(): assert find_highest_frequency_word(\\"hello\\") == \\"hello\\" def test_tie_with_lexicographic_order(): assert find_highest_frequency_word(\\"apple banana apple banana cherry\\") == \\"apple\\" def test_punctuation_removal(): assert find_highest_frequency_word(\\"hello! HELLO? Hello.\\") == \\"hello\\" def test_mixed_case_handling(): assert find_highest_frequency_word(\\"Cat cat CAT dog DOG\\") == \\"cat\\" def test_multiple_spaces(): assert find_highest_frequency_word(\\" dog dog cat \\") == \\"dog\\" def test_empty_string(): assert find_highest_frequency_word(\\"\\") == \\"\\" def test_no_valid_words(): assert find_highest_frequency_word(\\"!!! ???\\") == \\"\\" def test_example_case_1(): assert find_highest_frequency_word(\\"apple! bear bear. apple, bear. Mango mango mango! apple\\") == \\"apple\\" def test_example_case_2(): assert find_highest_frequency_word(\\"dog cat! dog. cat? elephant, cat elephant elephant. dog!\\") == \\"cat\\" def test_example_case_3(): assert find_highest_frequency_word(\\"it's a tie tie-break!\\") == \\"a\\"","solution":"import re from collections import Counter def find_highest_frequency_word(text: str) -> str: Finds the word with the highest frequency in the given text. If there's a tie, returns the word that comes first lexicographically. # Normalize case and remove punctuation text = text.lower() text = re.sub(r'[^a-zs]', '', text) # Split the text into words words = text.split() # Count the frequency of each word word_counts = Counter(words) # Find the word with the highest frequency max_frequency = max(word_counts.values(), default=0) candidates = [word for word, count in word_counts.items() if count == max_frequency] # Return the lexicographically smallest word return min(candidates) if candidates else \\"\\""},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotate the given square matrix 90 degrees clockwise in place. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate_matrix(matrix) >>> matrix [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]] pass","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotate the given square matrix 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"from typing import List, Tuple def compute_color_transition(start_color: Tuple[int, int, int], end_color: Tuple[int, int, int], steps: int) -> List[Tuple[int, int, int]]: Compute the interpolated colors for each time step given the starting and ending colors, as well as the total number of time steps. Parameters: 1. start_color (Tuple[int, int, int]): The starting color as an (R, G, B) tuple where each component is an integer between 0 and 255. 2. end_color (Tuple[int, int, int]): The ending color as an (R, G, B) tuple where each component is an integer between 0 and 255. 3. steps (int): The total number of steps for the transition. Returns: List[Tuple[int, int, int]]: A list of (R, G, B) tuples representing the interpolated colors at each step. Raises: ValueError: If any color component is outside the range 0-255 or if 'steps' is non-positive. Examples: >>> compute_color_transition((255, 0, 0), (0, 0, 255), 5) [(255, 0, 0), (191, 0, 63), (127, 0, 127), (63, 0, 191), (0, 0, 255)] >>> compute_color_transition((0, 255, 0), (0, 0, 0), 4) [(0, 255, 0), (0, 170, 0), (0, 85, 0), (0, 0, 0)] pass def test_compute_color_transition(): assert compute_color_transition((255, 0, 0), (0, 0, 255), 5) == [ (255, 0, 0), (191, 0, 63), (127, 0, 127), (63, 0, 191), (0, 0, 255) ] assert compute_color_transition((0, 255, 0), (0, 0, 0), 4) == [ (0, 255, 0), (0, 170, 0), (0, 85, 0), (0, 0, 0) ] try: compute_color_transition((255, 0, 0), (0, 0, 255), 0) except ValueError as e: assert str(e) == \\"The number of steps must be greater than 0.\\" try: compute_color_transition((256, 0, 0), (0, 0, 255), 5) except ValueError as e: assert str(e) == \\"Start color components must be in the range 0-255.\\" try: compute_color_transition((0, 0, 0), (0, 256, 0), 5) except ValueError as e: assert str(e) == \\"End color components must be in the range 0-255.\\"","solution":"from typing import List, Tuple def compute_color_transition(start_color: Tuple[int, int, int], end_color: Tuple[int, int, int], steps: int) -> List[Tuple[int, int, int]]: if not (0 <= start_color[0] <= 255 and 0 <= start_color[1] <= 255 and 0 <= start_color[2] <= 255): raise ValueError(\\"Start color components must be in the range 0-255.\\") if not (0 <= end_color[0] <= 255 and 0 <= end_color[1] <= 255 and 0 <= end_color[2] <= 255): raise ValueError(\\"End color components must be in the range 0-255.\\") if steps <= 0: raise ValueError(\\"The number of steps must be greater than 0.\\") interpolated_colors = [] for step in range(steps): r = start_color[0] + (end_color[0] - start_color[0]) * step // (steps - 1) g = start_color[1] + (end_color[1] - start_color[1]) * step // (steps - 1) b = start_color[2] + (end_color[2] - start_color[2]) * step // (steps - 1) interpolated_colors.append((r, g, b)) return interpolated_colors"},{"question":"from typing import List, Tuple def sort_students(records: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts a list of student records primarily by grade in descending order, and by name in ascending order in case of ties. :param records: List of tuples where each tuple contains a student's name (str) and grade (int) :return: Sorted list of records according to the specified criteria >>> sort_students([('Alice', 90), ('Bob', 85), ('Charlie', 90), ('Dave', 95)]) [('Dave', 95), ('Alice', 90), ('Charlie', 90), ('Bob', 85)] >>> sort_students([('Bob', 75), ('Alice', 75)]) [('Alice', 75), ('Bob', 75)] >>> sort_students([('Eve', 100), ('Mallory', 80), ('Oscar', 90)]) [('Eve', 100), ('Oscar', 90), ('Mallory', 80)] >>> sort_students([]) [] >>> sort_students([('Anna', 50)]) [('Anna', 50)] >>> sort_students([('Zoe', 60), ('Yara', 60), ('Liam', 90), ('Olivia', 100), ('Emma', 90)]) [('Olivia', 100), ('Emma', 90), ('Liam', 90), ('Yara', 60), ('Zoe', 60)] pass # Implementation goes here","solution":"from typing import List, Tuple def sort_students(records: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts a list of student records primarily by grade in descending order, and by name in ascending order in case of ties. :param records: List of tuples where each tuple contains a student's name (str) and grade (int) :return: Sorted list of records according to the specified criteria # Sorting by grade in descending order and then by name in ascending order return sorted(records, key=lambda record: (-record[1], record[0]))"},{"question":"from typing import List class DocumentHistory: A version control system for document versions that supports functionality to add new versions, retrieve specific versions, and compare differences between versions. Methods: - add_version(self, content: str) -> int: Accepts the content of a new document version and returns the version number of the newly added version. - get_version(self, version_number: int) -> str: Accepts a version number and returns the content of the requested version. - compare_versions(self, first_version: int, second_version: int) -> List[str]: Accepts two version numbers and returns a list of differences between the versions. >>> doc_history = DocumentHistory() >>> doc_history.add_version('First versionnSecond line') 1 >>> doc_history.add_version('First versionnSecond linenThird line') 2 >>> doc_history.add_version('Updated first linenSecond linenThird line') 3 >>> doc_history.get_version(1) 'First versionnSecond line' >>> doc_history.compare_versions(1, 3) ['-First version', '+Updated first line', '+Third line'] def __init__(self): pass def add_version(self, content: str) -> int: pass def get_version(self, version_number: int) -> str: pass def compare_versions(self, first_version: int, second_version: int) -> List[str]: pass # Sample usage of the DocumentHistory class doc_history = DocumentHistory() version_1 = doc_history.add_version('First versionnSecond line') print(version_1) # Output: 1 version_2 = doc_history.add_version('First versionnSecond linenThird line') print(version_2) # Output: 2 version_3 = doc_history.add_version('Updated first linenSecond linenThird line') print(version_3) # Output: 3 content = doc_history.get_version(1) print(content) # Output: \\"First versionnSecond line\\" differences = doc_history.compare_versions(1, 3) print(differences) # Output: [\\"-First version\\", \\"+Updated first line\\", \\"+Third line\\"]","solution":"class DocumentHistory: def __init__(self): self.versions = [] def add_version(self, content: str) -> int: self.versions.append(content.split('n')) return len(self.versions) def get_version(self, version_number: int) -> str: if version_number < 1 or version_number > len(self.versions): raise ValueError(\\"Invalid version number\\") return 'n'.join(self.versions[version_number - 1]) def compare_versions(self, first_version: int, second_version: int) -> list: if first_version < 1 or first_version > len(self.versions) or second_version < 1 or second_version > len(self.versions): raise ValueError(\\"Invalid version number\\") first_content = self.versions[first_version - 1] second_content = self.versions[second_version - 1] max_lines = max(len(first_content), len(second_content)) differences = [] for i in range(max_lines): line1 = first_content[i] if i < len(first_content) else '' line2 = second_content[i] if i < len(second_content) else '' if line1 != line2: if line1: differences.append(f\\"-{line1}\\") if line2: differences.append(f\\"+{line2}\\") return differences"},{"question":"from typing import List def find_common_elements(arr1: List[int], arr2: List[int]) -> List[int]: Finds the common elements in two sorted arrays. Args: arr1 (List[int]): First sorted array. arr2 (List[int]): Second sorted array. Returns: List[int]: List containing common elements. Example: >>> find_common_elements([1, 2, 4, 5, 7], [2, 3, 5, 6]) [2, 5] >>> find_common_elements([1, 3, 4, 6], [2, 5, 8]) [] ... # Unit tests def test_common_elements(): assert find_common_elements([1, 2, 4, 5, 7], [2, 3, 5, 6]) == [2, 5] def test_no_common_elements(): assert find_common_elements([1, 3, 4, 6], [2, 5, 8]) == [] def test_empty_arrays(): assert find_common_elements([], []) == [] assert find_common_elements([1, 3, 4], []) == [] assert find_common_elements([], [2, 5, 8]) == [] def test_identical_arrays(): assert find_common_elements([1, 2, 3], [1, 2, 3]) == [1, 2, 3] def test_no_overlap(): assert find_common_elements([1, 2, 3], [4, 5, 6]) == [] def test_single_element_common(): assert find_common_elements([1], [1]) == [1] assert find_common_elements([1, 3, 4, 5], [2, 3, 7]) == [3] def test_large_numbers(): assert find_common_elements( [1000000000, 2000000000], [1000000000, 3000000000] ) == [1000000000]","solution":"def find_common_elements(arr1, arr2): This function finds the common elements in two sorted arrays. It assumes that both input arrays are sorted in ascending order. i, j = 0, 0 common_elements = [] while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: i += 1 elif arr1[i] > arr2[j]: j += 1 else: common_elements.append(arr1[i]) i += 1 j += 1 return common_elements"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_kth_smallest(root: TreeNode | None, k: int) -> int: Given the root of a binary search tree (BST) and an integer \`k\`, return the kth smallest element in the BST. If the tree is empty or \`k\` is out of boundary, return -1. >>> tree = TreeNode(5) >>> tree.left = TreeNode(3) >>> tree.right = TreeNode(6) >>> tree.left.left = TreeNode(2) >>> tree.left.right = TreeNode(4) >>> tree.left.left.left = TreeNode(1) >>> find_kth_smallest(tree, 3) == 3 >>> tree = TreeNode(1) >>> find_kth_smallest(tree, 1) == 1 >>> find_kth_smallest(None, 1) == -1 >>> tree = TreeNode(2) >>> tree.left = TreeNode(1) >>> find_kth_smallest(tree, 3) == -1 >>> tree = TreeNode(5) >>> tree.left = TreeNode(3) >>> tree.right = TreeNode(6) >>> tree.left.left = TreeNode(2) >>> tree.left.right = TreeNode(4) >>> tree.left.left.left = TreeNode(1) >>> find_kth_smallest(tree, 1) == 1 >>> find_kth_smallest(tree, 2) == 2 >>> find_kth_smallest(tree, 4) == 4 >>> find_kth_smallest(tree, 5) == 5 >>> find_kth_smallest(tree, 6) == 6","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_kth_smallest(root: TreeNode | None, k: int) -> int: Returns the k-th smallest element in the BST. if not root: return -1 def in_order_traversal(node): if not node: return [] return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) sorted_elements = in_order_traversal(root) if 1 <= k <= len(sorted_elements): return sorted_elements[k-1] return -1"},{"question":"from typing import List def find_missing_number(sequence: List[int]) -> int: Identifies the missing number from a given sequence of integers from 1 to n, where n is the length of the sequence plus one. >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6 >>> find_missing_number([1, 2, 3, 5]) 4 >>> find_missing_number([1]) 2","solution":"from typing import List def find_missing_number(sequence: List[int]) -> int: Identifies the missing number from a given sequence of integers from 1 to n, where n is the length of the sequence plus one. n = len(sequence) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(sequence) return expected_sum - actual_sum"},{"question":"def create_playlist(playlist_name: str) -> dict: Create a new playlist with the specified name. >>> create_playlist('Road Trip') {'Road Trip': []} pass def add_song_to_playlist(playlist: dict, song_name: str) -> dict: Add a song to the specified playlist. >>> playlist = create_playlist('Road Trip') >>> add_song_to_playlist(playlist, 'Song A') {'Road Trip': ['Song A']} pass def remove_song_from_playlist(playlist: dict, song_name: str) -> dict: Remove a song from the specified playlist. >>> playlist = create_playlist('Road Trip') >>> playlist = add_song_to_playlist(playlist, 'Song A') >>> remove_song_from_playlist(playlist, 'Song A') {'Road Trip': []} pass def get_playlist_length(playlist: dict) -> int: Return the number of songs in the playlist. >>> playlist = create_playlist('Road Trip') >>> add_song_to_playlist(playlist, 'Song A') >>> add_song_to_playlist(playlist, 'Song B') >>> get_playlist_length(playlist) 2 pass def find_song_in_playlists(playlists: list[dict], song_name: str) -> list[str]: Find playlists that contain the specified song. >>> playlist1 = add_song_to_playlist(create_playlist('Road Trip'), 'Song A') >>> playlist2 = add_song_to_playlist(create_playlist('Workout'), 'Song A') >>> playlist3 = add_song_to_playlist(create_playlist('Chill'), 'Song B') >>> find_song_in_playlists([playlist1, playlist2, playlist3], 'Song A') ['Road Trip', 'Workout'] pass","solution":"def create_playlist(playlist_name: str) -> dict: Create a new playlist with the specified name. return {playlist_name: []} def add_song_to_playlist(playlist: dict, song_name: str) -> dict: Add a song to the specified playlist. playlist_name = list(playlist.keys())[0] if song_name not in playlist[playlist_name]: playlist[playlist_name].append(song_name) return playlist def remove_song_from_playlist(playlist: dict, song_name: str) -> dict: Remove a song from the specified playlist. playlist_name = list(playlist.keys())[0] if song_name in playlist[playlist_name]: playlist[playlist_name].remove(song_name) return playlist def get_playlist_length(playlist: dict) -> int: Return the number of songs in the playlist. playlist_name = list(playlist.keys())[0] return len(playlist[playlist_name]) def find_song_in_playlists(playlists: list[dict], song_name: str) -> list[str]: Find playlists that contain the specified song. result = [] for playlist in playlists: playlist_name = list(playlist.keys())[0] if song_name in playlist[playlist_name]: result.append(playlist_name) return result"},{"question":"def can_form_arithmetic_seq(arr: list[int]) -> bool: Checks whether a given sequence of integers can form an arithmetic progression after at most one swap of any two elements. >>> can_form_arithmetic_seq([3, 1, 2]) == True >>> can_form_arithmetic_seq([1, 3, 3, 1, 2]) == False >>> can_form_arithmetic_seq([1, 2, 4, 3]) == True >>> can_form_arithmetic_seq([-1, 0, 1]) == True >>> can_form_arithmetic_seq([5, 10, 15, 5]) == False","solution":"def can_form_arithmetic_seq(arr): Checks whether a given sequence can form an arithmetic progression after at most one swap of any two elements. Parameters: arr (list of int): The sequence of integers to check. Returns: bool: True if one swap can result in an arithmetic progression, False otherwise. n = len(arr) if n <= 2: return True # Any sequence of length 2 or less is trivially an arithmetic sequence sorted_arr = sorted(arr) diffs = [sorted_arr[i] - sorted_arr[i - 1] for i in range(1, n)] if len(set(diffs)) == 1: return True # Already can form an arithmetic progression # Test the possibility with one swap def is_arithmetic_with_one_swap(arr): for i in range(n): for j in range(i + 1, n): arr[i], arr[j] = arr[j], arr[i] if len(set(arr[k] - arr[k - 1] for k in range(1, n))) == 1: return True arr[i], arr[j] = arr[j], arr[i] return False return is_arithmetic_with_one_swap(arr)"},{"question":"from typing import List def contains_cycle(adj_matrix: List[List[int]]) -> bool: Determine if a directed graph contains a cycle based on the adjacency matrix. >>> adj_matrix_1 = [ ... [0, 1, 0, 0], ... [0, 0, 1, 0], ... [0, 0, 0, 1], ... [1, 0, 0, 0] ... ] >>> contains_cycle(adj_matrix_1) True >>> adj_matrix_2 = [ ... [0, 1, 0, 0], ... [0, 0, 1, 0], ... [0, 0, 0, 1], ... [0, 0, 0, 0] ... ] >>> contains_cycle(adj_matrix_2) False","solution":"from typing import List def contains_cycle(adj_matrix: List[List[int]]) -> bool: def dfs(node: int, visiting: List[bool], visited: List[bool]) -> bool: visiting[node] = True for neighbor, has_edge in enumerate(adj_matrix[node]): if has_edge: if not visited[neighbor]: # If not fully processed if visiting[neighbor]: # If visiting again, cycle detected return True if dfs(neighbor, visiting, visited): # DFS the neighbor return True visiting[node] = False visited[node] = True return False n = len(adj_matrix) if n == 0: return False visiting = [False] * n visited = [False] * n for i in range(n): if not visited[i]: if dfs(i, visiting, visited): # Start DFS from the current node return True return False"},{"question":"class Node: def __init__(self, data): self.data = data self.next = None def merge_circular_lists(head1, head2): Merges two circular linked lists into one sorted circular linked list. head1 : Node The head of the first circular linked list. head2 : Node The head of the second circular linked list. Returns the head of the merged sorted circular linked list. >>> n1 = Node(1) >>> n2 = Node(3) >>> n3 = Node(5) >>> n1.next = n2 >>> n2.next = n3 >>> n3.next = n1 >>> m1 = Node(2) >>> m2 = Node(4) >>> m3 = Node(6) >>> m1.next = m2 >>> m2.next = m3 >>> m3.next = m1 >>> new_head = merge_circular_lists(n1, m1) >>> result = [] >>> current = new_head >>> while True: >>> result.append(current.data) >>> current = current.next >>> if current == new_head: >>> break >>> result [1, 2, 3, 4, 5, 6]","solution":"class Node: def __init__(self, data): self.data = data self.next = None def merge_circular_lists(head1, head2): # Helper function to break the circular nature of the list def break_circle(head): if not head: return None current = head while current.next != head: current = current.next current.next = None return head # Helper function to form the circular list def form_circle(head): if not head: return None current = head while current.next: current = current.next current.next = head return head # Helper function to merge two normal sorted linked lists def merge_sorted_lists(l1, l2): dummy = Node(0) tail = dummy while l1 and l2: if l1.data < l2.data: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next if l1: tail.next = l1 if l2: tail.next = l2 return dummy.next # Break the circular nature of both lists head1 = break_circle(head1) head2 = break_circle(head2) # Merge the two non-circular lists merged_head = merge_sorted_lists(head1, head2) # Form the circular list merged_head = form_circle(merged_head) return merged_head"},{"question":"def run_length_encode(input_str: str) -> str: Encodes the input string using run-length encoding. @param input_str: a string to be encoded using RLE @return: the run-length encoded string >>> run_length_encode(\\"aaabccddd\\") 'a3bc2d3' >>> run_length_encode(\\"hello\\") 'hel2o' >>> run_length_encode(\\"wwwwaaad\\") 'w4a3d' >>> run_length_encode(\\"a\\") 'a' >>> run_length_encode(\\"\\") '' >>> run_length_encode(\\"bbbaaaccd\\") 'b3a3c2d' >>> run_length_encode(\\"aabbcc\\") 'a2b2c2' >>> run_length_encode(\\"abcd\\") 'abcd' >>> run_length_encode(\\"aaaabbbbcccc\\") 'a4b4c4' >>> run_length_encode(\\"aabbaa\\") 'a2b2a2'","solution":"def run_length_encode(input_str: str) -> str: if not input_str: return \\"\\" encoded = [] prev_char = input_str[0] count = 1 for i in range(1, len(input_str)): if input_str[i] == prev_char: count += 1 else: if count > 1: encoded.append(f\\"{prev_char}{count}\\") else: encoded.append(prev_char) prev_char = input_str[i] count = 1 if count > 1: encoded.append(f\\"{prev_char}{count}\\") else: encoded.append(prev_char) return ''.join(encoded)"},{"question":"from typing import List def can_be_rotated(arr: List[int], target: List[int]) -> bool: Determine if one array can be transformed into another by a series of rotations. >>> can_be_rotated([1, 2, 3, 4], [3, 4, 1, 2]) True >>> can_be_rotated([1, 2, 3, 4], [4, 3, 2, 1]) False >>> can_be_rotated([7, 7, 7], [7, 7, 7]) True >>> can_be_rotated([1, 2, 3], [2, 3, 1, 4]) False","solution":"from typing import List def can_be_rotated(arr: List[int], target: List[int]) -> bool: if len(arr) != len(target): return False # Concatenate arr with itself concatenated = arr + arr # Convert lists to strings for easier substring search str_concatenated = ' '.join(map(str, concatenated)) str_target = ' '.join(map(str, target)) return str_target in str_concatenated"},{"question":"class StockPortfolio: def __init__(self): self._stocks = {} def add_stock(self, name: str, price: float): Adds or updates a stock with the given name and price. pass def remove_stock(self, name: str): Removes a stock by its name if it exists. pass def record_price_change(self, name: str, new_price: float): Records a new price for an existing stock. Raises ValueError if the stock does not exist. pass def calculate_total_value(self) -> float: Calculates and returns the total value of the portfolio. pass # Example Usage: portfolio = StockPortfolio() portfolio.add_stock(\\"AAPL\\", 150.00) portfolio.add_stock(\\"GOOGL\\", 2800.00) portfolio.add_stock(\\"AMZN\\", 3400.00) print(portfolio.calculate_total_value()) # Expected Output: 6350.0 portfolio.record_price_change(\\"AAPL\\", 155.00) portfolio.remove_stock(\\"GOOGL\\") print(portfolio.calculate_total_value()) # Expected Output: 3555.0 # Test Cases: def test_add_stock(): portfolio = StockPortfolio() portfolio.add_stock(\\"AAPL\\", 150.00) assert portfolio._stocks[\\"AAPL\\"] == 150.00 def test_add_stock_updates_existing_stock(): portfolio = StockPortfolio() portfolio.add_stock(\\"AAPL\\", 150.00) portfolio.add_stock(\\"AAPL\\", 155.00) assert portfolio._stocks[\\"AAPL\\"] == 155.00 def test_remove_stock(): portfolio = StockPortfolio() portfolio.add_stock(\\"AAPL\\", 150.00) portfolio.remove_stock(\\"AAPL\\") assert \\"AAPL\\" not in portfolio._stocks def test_remove_non_existing_stock(): portfolio = StockPortfolio() portfolio.add_stock(\\"AAPL\\", 150.00) portfolio.remove_stock(\\"GOOGL\\") assert \\"AAPL\\" in portfolio._stocks def test_record_price_change(): portfolio = StockPortfolio() portfolio.add_stock(\\"AAPL\\", 150.00) portfolio.record_price_change(\\"AAPL\\", 155.00) assert portfolio._stocks[\\"AAPL\\"] == 155.00 def test_record_price_change_for_non_existing_stock(): portfolio = StockPortfolio() try: portfolio.record_price_change(\\"GOOGL\\", 2800.00) except ValueError as e: assert str(e) == \\"Stock not found\\" def test_calculate_total_value(): portfolio = StockPortfolio() portfolio.add_stock(\\"AAPL\\", 150.00) portfolio.add_stock(\\"GOOGL\\", 2800.00) portfolio.add_stock(\\"AMZN\\", 3400.00) assert portfolio.calculate_total_value() == 6350.00 def test_calculate_total_value_after_removing_stock(): portfolio = StockPortfolio() portfolio.add_stock(\\"AAPL\\", 150.00) portfolio.add_stock(\\"GOOGL\\", 2800.00) portfolio.add_stock(\\"AMZN\\", 3400.00) portfolio.remove_stock(\\"GOOGL\\") assert portfolio.calculate_total_value() == 3550.00","solution":"class StockPortfolio: def __init__(self): self._stocks = {} def add_stock(self, name: str, price: float): Adds or updates a stock with the given name and price. self._stocks[name] = price def remove_stock(self, name: str): Removes a stock by its name if it exists. if name in self._stocks: del self._stocks[name] def record_price_change(self, name: str, new_price: float): Records a new price for an existing stock. Raises ValueError if the stock does not exist. if name in self._stocks: self._stocks[name] = new_price else: raise ValueError(\\"Stock not found\\") def calculate_total_value(self) -> float: Calculates and returns the total value of the portfolio. return sum(self._stocks.values())"},{"question":"def matrix_intersection(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]: Computes the intersection matrix of two input matrices. The intersection of elements is determined element-wise, and the result is presented in the same dimensions as the given input matrices. If the matrices have different dimensions, the function raises a ValueError. Args: - matrix_a: A list of lists of integers representing the first matrix. - matrix_b: A list of lists of integers representing the second matrix. Returns: - A list of lists of integers representing the intersection matrix, with a 0 at positions where the elements do not intersect. Raises: - ValueError: If the dimensions of the input matrices do not match, or if the matrices are empty. Examples: >>> matrix_intersection([[1, 2, 3], [4, 5, 6]], [[3, 2, 1], [6, 5, 4]]) [[0, 2, 0], [0, 5, 0]] >>> matrix_intersection([[1, 2], [3, 4]], [[1, 3], [2, 4]]) [[1, 0], [0, 4]] pass def test_matrix_intersection(): assert matrix_intersection( [[1, 2, 3], [4, 5, 6]], [[3, 2, 1], [6, 5, 4]]) == [[0, 2, 0], [0, 5, 0]] assert matrix_intersection( [[1, 2], [3, 4]], [[1, 3], [2, 4]]) == [[1, 0], [0, 4]] assert matrix_intersection( [[1]], [[1]]) == [[1]] assert matrix_intersection( [[1]], [[2]]) == [[0]] def test_empty_matrices(): try: matrix_intersection([], []) except ValueError as e: assert str(e) == \\"Matrices should not be empty.\\" def test_non_matching_dimensions(): try: matrix_intersection([[1, 2]], [[1]]) except ValueError as e: assert str(e) == \\"Matrices dimensions do not match.\\" try: matrix_intersection([[1, 2], [3, 4]], [[1, 2, 3], [4, 5, 6]]) except ValueError as e: assert str(e) == \\"Matrices dimensions do not match.\\"","solution":"def matrix_intersection(matrix_a, matrix_b): Returns the intersection matrix of given two matrices A and B. The intersection matrix at each position (i, j) is the element if both are the same in A and B, otherwise 0. # Check if the dimensions match if not matrix_a or not matrix_b: raise ValueError(\\"Matrices should not be empty.\\") rows_a, cols_a = len(matrix_a), len(matrix_a[0]) rows_b, cols_b = len(matrix_b), len(matrix_b[0]) if rows_a != rows_b or cols_a != cols_b: raise ValueError(\\"Matrices dimensions do not match.\\") # Initialize the result matrix with zeros result_matrix = [[0] * cols_a for _ in range(rows_a)] # Compute the intersection matrix for i in range(rows_a): for j in range(cols_a): if matrix_a[i][j] == matrix_b[i][j]: result_matrix[i][j] = matrix_a[i][j] return result_matrix"},{"question":"class AVLTreeNode: def __init__(self, key: int): self.left = None self.right = None self.height = 1 self.key = key class AVLTree: def insert(self, root: AVLTreeNode, key: int) -> AVLTreeNode: Insert a node with the given key into the AVL tree and return the new root of the tree after insertion. def delete(self, root: AVLTreeNode, key: int) -> AVLTreeNode: Delete the node with the given key from the AVL tree and return the new root of the tree after deletion. def search(self, root: AVLTreeNode, key: int) -> bool: Search for a node with the given key in the AVL tree and return True if the key exists, otherwise return False. # Sample usage: avl = AVLTree() root = None root = avl.insert(root, 10) root = avl.insert(root, 20) root = avl.insert(root, 30) assert root.key == 20 # After balancing, 20 should be the new root root = avl.insert(root, 40) root = avl.insert(root, 50) assert avl.search(root, 30) == True assert avl.search(root, 60) == False root = avl.delete(root, 20) assert avl.search(root, 20) == False Unit Test: from solution import AVLTree, AVLTreeNode def test_insert(): avl = AVLTree() root = None root = avl.insert(root, 10) assert root.key == 10 root = avl.insert(root, 20) assert root.right.key == 20 root = avl.insert(root, 30) assert root.key == 20 root = avl.insert(root, 40) root = avl.insert(root, 50) assert root.right.right.key == 50 def test_search(): avl = AVLTree() root = None root = avl.insert(root, 10) root = avl.insert(root, 20) root = avl.insert(root, 30) root = avl.insert(root, 40) root = avl.insert(root, 50) assert avl.search(root, 30) == True assert avl.search(root, 60) == False def test_delete(): avl = AVLTree() root = None root = avl.insert(root, 10) root = avl.insert(root, 20) root = avl.insert(root, 30) root = avl.insert(root, 40) root = avl.insert(root, 50) root = avl.delete(root, 30) assert avl.search(root, 30) == False root = avl.delete(root, 10) assert avl.search(root, 10) == False def test_tree_balancing(): avl = AVLTree() root = None root = avl.insert(root, 10) root = avl.insert(root, 20) root = avl.insert(root, 30) root = avl.insert(root, 40) root = avl.insert(root, 50) root = avl.insert(root, 25) assert root.key == 30 # root should balance to 30 def test_edge_cases(): avl = AVLTree() root = None # Test deleting from an empty tree root = avl.delete(root, 10) assert root == None # Test inserting duplicate keys (should maintain current structure) root = avl.insert(root, 10) initial_tree = root root = avl.insert(root, 10) assert root == initial_tree","solution":"class AVLTreeNode: def __init__(self, key: int): self.left = None self.right = None self.height = 1 self.key = key class AVLTree: def get_height(self, node: AVLTreeNode) -> int: if not node: return 0 return node.height def get_balance(self, node: AVLTreeNode) -> int: if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def left_rotate(self, z: AVLTreeNode) -> AVLTreeNode: y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def right_rotate(self, y: AVLTreeNode) -> AVLTreeNode: x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) x.height = 1 + max(self.get_height(x.left), self.get_height(x.right)) return x def insert(self, root: AVLTreeNode, key: int) -> AVLTreeNode: if not root: return AVLTreeNode(key) elif key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) # Left Left Case if balance > 1 and key < root.left.key: return self.right_rotate(root) # Right Right Case if balance < -1 and key > root.right.key: return self.left_rotate(root) # Left Right Case if balance > 1 and key > root.left.key: root.left = self.left_rotate(root.left) return self.right_rotate(root) # Right Left Case if balance < -1 and key < root.right.key: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def min_value_node(self, node: AVLTreeNode) -> AVLTreeNode: if node is None or node.left is None: return node return self.min_value_node(node.left) def delete(self, root: AVLTreeNode, key: int) -> AVLTreeNode: if not root: return root if key < root.key: root.left = self.delete(root.left, key) elif key > root.key: root.right = self.delete(root.right, key) else: if root.left is None: temp = root.right root = None return temp elif root.right is None: temp = root.left root = None return temp temp = self.min_value_node(root.right) root.key = temp.key root.right = self.delete(root.right, temp.key) if root is None: return root root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) # Left Left if balance > 1 and self.get_balance(root.left) >= 0: return self.right_rotate(root) # Left Right if balance > 1 and self.get_balance(root.left) < 0: root.left = self.left_rotate(root.left) return self.right_rotate(root) # Right Right if balance < -1 and self.get_balance(root.right) <= 0: return self.left_rotate(root) # Right Left if balance < -1 and self.get_balance(root.right) > 0: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def search(self, root: AVLTreeNode, key: int) -> bool: if not root: return False if root.key == key: return True elif key < root.key: return self.search(root.left, key) else: return self.search(root.right, key)"},{"question":"from typing import List def generate_fibonacci(n: int) -> List[int]: Generates the first n numbers in the Fibonacci sequence. :param n: Integer value representing the number of terms in the Fibonacci sequence to generate. :return: List of the first n numbers in the Fibonacci sequence. :raises ValueError: If n is not a non-negative integer. Examples: >>> generate_fibonacci(0) [] >>> generate_fibonacci(1) [0] >>> generate_fibonacci(5) [0, 1, 1, 2, 3] >>> generate_fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> generate_fibonacci(\\"five\\") Traceback (most recent call last): ... ValueError: generate_fibonacci() requires a non-negative integer for n","solution":"from typing import List def generate_fibonacci(n: int) -> List[int]: Generates the first n numbers in the Fibonacci sequence. :param n: Integer value representing the number of terms in the Fibonacci sequence to generate. :return: List of the first n numbers in the Fibonacci sequence. :raises ValueError: If n is not a non-negative integer. if not isinstance(n, int) or n < 0: raise ValueError(\\"generate_fibonacci() requires a non-negative integer for n\\") if n == 0: return [] if n == 1: return [0] fib_sequence = [0, 1] for i in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence"},{"question":"def reverse_string(s: str) -> str: Takes a string input and returns the string with the characters in reverse order. >>> reverse_string(\\"hello\\") \\"olleh\\" >>> reverse_string(\\"12345\\") \\"54321\\" >>> reverse_string(\\"A man, a plan, a canal, Panama\\") \\"amanaP ,lanac a ,nalp a ,nam A\\"","solution":"def reverse_string(s: str) -> str: Returns the reverse of the input string s. return s[::-1]"},{"question":"import numpy as np def bacterial_growth_simulation(initial_population: int, carrying_capacity: int, growth_rate: float, time_span: int) -> np.ndarray: Simulates bacterial growth using the logistic growth model. Parameters: initial_population (int): The initial size of the bacterial population. carrying_capacity (int): The maximum population size that the environment can sustain. growth_rate (float): The rate at which the population grows. time_span (int): The total time for which the simulation runs. Returns: np.ndarray: An array showing the estimated bacterial population at each timestep. Examples: >>> bacterial_growth_simulation(50, 500, 0.1, 10) array([ 50. , 54.5 , 59.295 , 64.39855 , 69.8252535 , 75.59132047, 81.7141448 , 88.21263932, 95.1070571 , 102.41893149, 110.1711836 ]) >>> bacterial_growth_simulation(0, 500, 0.1, 10) array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])","solution":"import numpy as np def bacterial_growth_simulation(initial_population: int, carrying_capacity: int, growth_rate: float, time_span: int) -> np.ndarray: Simulates bacterial growth using the logistic growth model. Parameters: initial_population (int): The initial size of the bacterial population. carrying_capacity (int): The maximum population size that the environment can sustain. growth_rate (float): The rate at which the population grows. time_span (int): The total time for which the simulation runs. Returns: np.ndarray: An array showing the estimated bacterial population at each timestep. # Ensure inputs are valid if initial_population < 0: raise ValueError(\\"Initial population must be non-negative.\\") if carrying_capacity <= 0: raise ValueError(\\"Carrying capacity must be positive.\\") if growth_rate <= 0: raise ValueError(\\"Growth rate must be positive.\\") if time_span < 0: raise ValueError(\\"Time span must be non-negative.\\") # Initialize the population array population = np.zeros(time_span + 1) population[0] = initial_population # Use Euler's method to simulate the logistic growth for t in range(1, time_span + 1): P = population[t - 1] dPdt = growth_rate * P * (1 - P / carrying_capacity) population[t] = P + dPdt return population"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_left_leaf(root: Optional[TreeNode]) -> int: Find the value of the deepest left leaf node in the binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> root.right.left.left = TreeNode(8) >>> deepest_left_leaf(root) 8 >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> root.right.right.right = TreeNode(4) >>> deepest_left_leaf(root) is None True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> deepest_left_leaf(root) 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_left_leaf(root): if not root: return None from collections import deque queue = deque([(root, False, 0)]) # (node, is_left, depth) deepest_node = None max_depth = -1 while queue: node, is_left, depth = queue.popleft() if node.left is None and node.right is None and is_left: if depth > max_depth: max_depth = depth deepest_node = node.val if node.left: queue.append((node.left, True, depth + 1)) if node.right: queue.append((node.right, False, depth + 1)) return deepest_node"},{"question":"import os import requests def fetch_recent_tweets(username: str, count: int) -> list[str]: Fetches the most recent tweets of a user. Parameters: - username (str): The Twitter username whose tweets are to be fetched. - count (int): The number of recent tweets to fetch (maximum 10). Returns: - List of tweet texts (List[str]). Empty list if an error occurs. Examples: >>> fetch_recent_tweets(\\"jack\\", 2) [\\"Just setting up my twttr\\", \\"inviting coworkers\\"] pass from unittest.mock import patch, Mock import requests from solution import fetch_recent_tweets def test_fetch_recent_tweets_success(): mock_response = Mock() expected_tweets = [ {\\"text\\": \\"Just setting up my twttr\\"}, {\\"text\\": \\"inviting coworkers\\"} ] mock_response.json.return_value = {\\"data\\": expected_tweets} mock_response.raise_for_status = Mock() with patch('requests.get', return_value=mock_response): tweets = fetch_recent_tweets(\\"jack\\", 2) assert tweets == [\\"Just setting up my twttr\\", \\"inviting coworkers\\"] def test_fetch_recent_tweets_empty_on_error(): mock_response = Mock() mock_response.raise_for_status.side_effect = requests.HTTPError with patch('requests.get', return_value=mock_response): tweets = fetch_recent_tweets(\\"jack\\", 2) assert tweets == [] def test_fetch_recent_tweets_network_error(): with patch('requests.get', side_effect=requests.ConnectionError): tweets = fetch_recent_tweets(\\"jack\\", 2) assert tweets == [] def test_fetch_recent_tweets_timeout(): with patch('requests.get', side_effect=requests.Timeout): tweets = fetch_recent_tweets(\\"jack\\", 2) assert tweets == [] def test_fetch_recent_tweets_count_constraint(): mock_response = Mock() expected_tweets_count_exceed = [ {\\"text\\": \\"Tweet 1\\"}, {\\"text\\": \\"Tweet 2\\"}, {\\"text\\": \\"Tweet 3\\"}, {\\"text\\": \\"Tweet 4\\"}, {\\"text\\": \\"Tweet 5\\"}, {\\"text\\": \\"Tweet 6\\"}, {\\"text\\": \\"Tweet 7\\"}, {\\"text\\": \\"Tweet 8\\"}, {\\"text\\": \\"Tweet 9\\"}, {\\"text\\": \\"Tweet 10\\"} ] mock_response.json.return_value = {\\"data\\": expected_tweets_count_exceed} mock_response.raise_for_status = Mock() with patch('requests.get', return_value=mock_response): tweets = fetch_recent_tweets(\\"jack\\", 15) assert tweets == [\\"Tweet 1\\", \\"Tweet 2\\", \\"Tweet 3\\", \\"Tweet 4\\", \\"Tweet 5\\", \\"Tweet 6\\", \\"Tweet 7\\", \\"Tweet 8\\", \\"Tweet 9\\", \\"Tweet 10\\"]","solution":"import os import requests def fetch_recent_tweets(bearer_token: str, username: str, count: int) -> list[str]: Fetches the most recent tweets of a user. Parameters: - bearer_token (str): A valid Twitter API bearer token. - username (str): The Twitter username whose tweets are to be fetched. - count (int): The number of recent tweets to fetch (maximum 10). Returns: - List of tweet texts (List[str]). Empty list if an error occurs. if count > 10: count = 10 headers = { \\"Authorization\\": f\\"Bearer {bearer_token}\\" } url = f\\"https://api.twitter.com/2/tweets?screen_name={username}&count={count}\\" try: response = requests.get(url, headers=headers, timeout=10) response.raise_for_status() tweets = response.json().get('data', []) tweet_texts = [tweet['text'] for tweet in tweets] return tweet_texts except requests.RequestException: return [] os.environ['TWITTER_BEARER_TOKEN'] = \\"ABCDE\\" # Example token for demonstration purposes"},{"question":"def radix_sort(collection: list[int]) -> list[int]: Performs Radix Sort on a list of integers. Parameters: collection (list[int]): A list of positive integers to be sorted. Returns: list[int]: Sorted list of integers. >>> radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) [2, 24, 45, 66, 75, 90, 170, 802] >>> radix_sort([123, 1, 45, 72, 8, 12]) [1, 8, 12, 45, 72, 123] >>> radix_sort([]) []","solution":"def radix_sort(collection: list[int]) -> list[int]: Performs Radix Sort on a list of integers. Parameters: collection (list[int]): A list of positive integers to be sorted. Returns: list[int]: Sorted list of integers. if len(collection) == 0: return collection # Function to perform Counting Sort on the basis of digit represented by exp. def counting_sort(arr, exp): n = len(arr) output = [0] * n # Output array initialized to 0. count = [0] * 10 # Count array to store count of occurrences of digits 0-9. for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 for i in range(n): arr[i] = output[i] max_val = max(collection) exp = 1 # Initial exponent (1, 10, 100, ...) while max_val // exp > 0: counting_sort(collection, exp) exp *= 10 return collection"},{"question":"def max_subarray_with_indices(nums: list[int]) -> tuple[int, int, int]: Finds the maximum sum subarray and returns the sum and its starting and ending indices. >>> max_subarray_with_indices([1]) (1, 0, 0) >>> max_subarray_with_indices([-1]) (-1, 0, 0) >>> max_subarray_with_indices([1, 2, 3, 4, 5]) (15, 0, 4) >>> max_subarray_with_indices([-1, -2, -3, -4, -5]) (-1, 0, 0) >>> max_subarray_with_indices([-2, 1, -3, 4, -1, 2, 1, -5, 4]) (6, 3, 6) >>> max_subarray_with_indices([4, -1, 2, 1]) (6, 0, 3) >>> max_subarray_with_indices([-1, 3, 4, -2, 1, -2]) (7, 1, 2) pass","solution":"def max_subarray_with_indices(nums: list[int]) -> tuple[int, int, int]: Finds the maximum sum subarray and returns the sum and its starting and ending indices. Uses Kadane's Algorithm with additional indices tracking. :param nums: List of integers :return: Tuple of (maximum sum, start index, end index) max_sum = float('-inf') current_sum = 0 start = end = 0 temp_start = 0 for i in range(len(nums)): current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i if current_sum < 0: current_sum = 0 temp_start = i + 1 return max_sum, start, end"},{"question":"def get_skyline(buildings: list[list[int]]) -> list[list[int]]: Computes the skyline formed by a list of buildings. Parameters: buildings (list): A list of lists, where each sublist contains three integers [left, right, height]. Returns: list: A list of key points that form the skyline, where each key point is represented as [x, height]. Examples: >>> get_skyline([ ... [2, 9, 10], [3, 7, 15], [5, 12, 12], ... [15, 20, 10], [19, 24, 8] ... ]) [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]] >>> get_skyline([[1, 5, 11]]) [[1, 11], [5, 0]] >>> get_skyline([]) [] >>> get_skyline([[1, 2, 1], [3, 4, 1]]) [[1, 1], [2, 0], [3, 1], [4, 0]] >>> get_skyline([[1, 5, 11], [2, 6, 6], [3, 8, 13]]) [[1, 11], [3, 13], [8, 0]] pass","solution":"def get_skyline(buildings): import heapq from collections import defaultdict # Create a list of all start and end points events = [] for left, right, height in buildings: events.append((left, -height, right)) events.append((right, 0, 0)) # Sort the events by position, break ties by height events.sort() # Max-Heap to keep track of building heights live_buildings_heap = [(0, float(\\"inf\\"))] skyline = [] prev_max_height = 0 for x, neg_height, end in events: while live_buildings_heap[0][1] <= x: heapq.heappop(live_buildings_heap) if neg_height != 0: heapq.heappush(live_buildings_heap, (neg_height, end)) current_max_height = -live_buildings_heap[0][0] if current_max_height != prev_max_height: skyline.append([x, current_max_height]) prev_max_height = current_max_height return skyline"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: stack = [] # stack to keep track of indices of heights max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def test_largest_rectangle_area(): assert largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 assert largest_rectangle_area([4, 2, 0, 3, 2, 5]) == 6 assert largest_rectangle_area([2, 4]) == 4 assert largest_rectangle_area([1, 1, 1, 1]) == 4 assert largest_rectangle_area([1]) == 1 assert largest_rectangle_area([0, 1]) == 1 assert largest_rectangle_area([1, 0, 1]) == 1 assert largest_rectangle_area([2, 1, 2]) == 3 assert largest_rectangle_area([]) == 0 assert largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) == 12 assert largest_rectangle_area([1, 3, 2, 1, 2]) == 5 assert largest_rectangle_area([4, 2, 0, 3, 2, 4]) == 6 test_largest_rectangle_area()","solution":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: stack = [] # stack to keep track of indices of heights max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def build_lps(pattern: str) -> list[int]: Build the longest prefix suffix (LPS) array for the pattern. :param pattern: The pattern string for which to build the LPS array. :return: A list of integers representing the LPS array. >>> build_lps(\\"ababd\\") [0, 0, 1, 2, 0] >>> build_lps(\\"aaaa\\") [0, 1, 2, 3] >>> build_lps(\\"abcab\\") [0, 0, 0, 1, 2] >>> build_lps(\\"aabaac\\") [0, 1, 0, 1, 2, 0] # Your implementation here def kmp_search(text: str, pattern: str) -> list[int]: Search for the pattern in the text using the KMP algorithm. :param text: The text string in which to search for the pattern. :param pattern: The pattern string to search for in the text. :return: A list of integers representing the starting indices of each occurrence of the pattern. >>> kmp_search(\\"ababcabcabababd\\", \\"ababd\\") [10] >>> kmp_search(\\"aaaaaaa\\", \\"aa\\") [0, 1, 2, 3, 4, 5] >>> kmp_search(\\"abcabcabcabc\\", \\"abc\\") [0, 3, 6, 9] >>> kmp_search(\\"ababababa\\", \\"ababa\\") [0, 2, 4] >>> kmp_search(\\"abcdefgh\\", \\"abc\\") [0] >>> kmp_search(\\"abcdefgh\\", \\"xyz\\") [] # Your implementation here","solution":"def build_lps(pattern: str) -> list[int]: Build the longest prefix suffix (LPS) array for the pattern. :param pattern: The pattern string for which to build the LPS array. :return: A list of integers representing the LPS array. lps = [0] * len(pattern) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def kmp_search(text: str, pattern: str) -> list[int]: Search for the pattern in the text using the KMP algorithm. :param text: The text string in which to search for the pattern. :param pattern: The pattern string to search for in the text. :return: A list of integers representing the starting indices of each occurrence of the pattern. if not pattern: return [] # An empty pattern is not considered for searching lps = build_lps(pattern) result = [] i, j = 0, 0 while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"def calculate_rectangle_area(length: float, width: float) -> float: Calculate the area of a rectangle given its length and width. Parameters: length (float): The length of the rectangle. Must be non-negative. width (float): The width of the rectangle. Must be non-negative. Returns: float: The area of the rectangle. Raises: ValueError: If length or width is negative. Examples: >>> round(calculate_rectangle_area(5.0, 10.0), 2) 50.0 >>> round(calculate_rectangle_area(7.5, 3.2), 2) 24.0 >>> round(calculate_rectangle_area(0, 9.8), 2) 0.0 >>> try: ... calculate_rectangle_area(-5, 7) ... except ValueError as e: ... assert str(e) == \\"Length must be non-negative\\" >>> try: ... calculate_rectangle_area(6, -3) ... except ValueError as e: ... assert str(e) == \\"Width must be non-negative\\" >>> try: ... calculate_rectangle_area(-4, -2) ... except ValueError as e: ... assert str(e) == \\"Length must be non-negative\\"","solution":"def calculate_rectangle_area(length: float, width: float) -> float: Calculate the area of a rectangle given its length and width. Parameters: length (float): The length of the rectangle. Must be non-negative. width (float): The width of the rectangle. Must be non-negative. Returns: float: The area of the rectangle. Raises: ValueError: If length or width is negative. if length < 0: raise ValueError(\\"Length must be non-negative\\") if width < 0: raise ValueError(\\"Width must be non-negative\\") return length * width"},{"question":"def count_pattern_occurrences(text, pattern): Count occurrences of the pattern in the text, including overlapping ones. :param text: The string in which to search for the pattern :param pattern: The string pattern to search for :return: The count of occurrences of the pattern in the text including overlaps # Your implementation here pass # Unit tests def test_example_case(): assert count_pattern_occurrences(\\"abababa\\", \\"aba\\") == 3 def test_no_overlap(): assert count_pattern_occurrences(\\"abcdabcd\\", \\"abcd\\") == 2 def test_complete_overlap(): assert count_pattern_occurrences(\\"aaaaaa\\", \\"aaa\\") == 4 def test_single_character_pattern(): assert count_pattern_occurrences(\\"aaaaaa\\", \\"a\\") == 6 def test_large_text(): text = \\"a\\" * 100000 pattern = \\"aa\\" # The pattern should occur 99999 times in this text assert count_pattern_occurrences(text, pattern) == 99999 def test_pattern_not_in_text(): assert count_pattern_occurrences(\\"abcdef\\", \\"gh\\") == 0 def test_pattern_same_as_text(): assert count_pattern_occurrences(\\"abcdef\\", \\"abcdef\\") == 1 def test_text_smaller_than_pattern(): assert count_pattern_occurrences(\\"abc\\", \\"abcd\\") == 0","solution":"def count_pattern_occurrences(text, pattern): Count occurrences of the pattern in the text, including overlapping ones. :param text: The string in which to search for the pattern :param pattern: The string pattern to search for :return: The count of occurrences of the pattern in the text including overlaps count = 0 pattern_length = len(pattern) text_length = len(text) for i in range(text_length - pattern_length + 1): if text[i:i + pattern_length] == pattern: count += 1 return count"},{"question":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Determines the maximum sum of any contiguous subarray within the given list \`arr\`. >>> max_subarray_sum([3, -2, 5, -1]) 6 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([4, -1, -2, 1, 5]) 7","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Determines the maximum sum of any contiguous subarray within the given list \`arr\`. if not arr: return 0 max_current = max_global = arr[0] for i in range(1, len(arr)): max_current = max(arr[i], max_current + arr[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class SinglyLinkedList: def __init__(self): self.head = None def add(self, val): Adds a new node with the given value to the end of the list. Args: val (int): The value to add to the list. new_node = ListNode(val) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def find_nth_from_end(self, n: int) -> ListNode: Finds and returns the n-th node from the end of the singly linked list. Args: n (int): The position (1-based index) from the end of the list. Returns: ListNode: The node at the n-th position from the end, or None if the position is invalid. >>> list = SinglyLinkedList() >>> for i in range(1, 6): ... list.add(i) >>> nth_node = list.find_nth_from_end(2) >>> nth_node.val if nth_node else None 4 >>> nth_node = list.find_nth_from_end(6) >>> nth_node if nth_node else None None pass def test_find_nth_from_end_normal_case(): list = SinglyLinkedList() for i in range(1, 6): # List: 1 -> 2 -> 3 -> 4 -> 5 list.add(i) nth_node = list.find_nth_from_end(2) assert nth_node is not None assert nth_node.val == 4 def test_find_nth_from_end_invalid_n(): list = SinglyLinkedList() for i in range(1, 4): # List: 1 -> 2 -> 3 list.add(i) nth_node_0 = list.find_nth_from_end(0) nth_node_4 = list.find_nth_from_end(4) assert nth_node_0 is None assert nth_node_4 is None def test_find_nth_from_end_greater_than_length(): list = SinglyLinkedList() list.add(1) # List: 1 nth_node = list.find_nth_from_end(2) assert nth_node is None def test_find_nth_from_end_last_element(): list = SinglyLinkedList() for i in range(1, 5): # List: 1 -> 2 -> 3 -> 4 list.add(i) nth_node = list.find_nth_from_end(1) assert nth_node is not None assert nth_node.val == 4 def test_find_nth_from_end_single_element(): list = SinglyLinkedList() list.add(1) # List: 1 nth_node = list.find_nth_from_end(1) assert nth_node is not None assert nth_node.val == 1 def test_find_nth_from_end_empty_list(): list = SinglyLinkedList() nth_node = list.find_nth_from_end(1) assert nth_node is None","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class SinglyLinkedList: def __init__(self): self.head = None def add(self, val): new_node = ListNode(val) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def find_nth_from_end(self, n: int) -> ListNode: if n <= 0: return None first = self.head second = self.head # Move first pointer \`n\` steps ahead for _ in range(n): if not first: return None first = first.next # Move both pointers until first reaches the end while first: first = first.next second = second.next return second"},{"question":"def count_distinct_subsets(arr: List[int], k: int) -> int: Given a list of integers, count the number of distinct subsets of size \`k\` that can be formed. >>> count_distinct_subsets([1, 2, 2], 2) == 2 >>> count_distinct_subsets([1, 1, 1, 2], 1) == 2 >>> count_distinct_subsets([], 0) == 1 >>> count_distinct_subsets([1, 2, 3, 4], 5) == 0 >>> count_distinct_subsets([1, 2, 3], 3) == 1 >>> count_distinct_subsets([1, 1, 1, 1, 1], 3) == 1","solution":"from typing import List def count_distinct_subsets(arr: List[int], k: int) -> int: def generate_subsets(curr, start): if len(curr) == k: result.add(tuple(sorted(curr))) return for i in range(start, len(arr)): generate_subsets(curr + [arr[i]], i + 1) if k > len(arr): return 0 if k == 0: return 1 # Only the empty subset. result = set() generate_subsets([], 0) return len(result)"},{"question":"def count_hanoi_moves(n: int) -> int: Returns the minimal number of moves required to solve the Tower of Hanoi puzzle with \`n\` disks. >>> count_hanoi_moves(1) 1 >>> count_hanoi_moves(2) 3 >>> count_hanoi_moves(3) 7 >>> count_hanoi_moves(4) 15 >>> count_hanoi_moves(5) 31 >>> count_hanoi_moves(6) 63 >>> count_hanoi_moves(10) 1023 >>> count_hanoi_moves(20) 1048575 pass","solution":"def count_hanoi_moves(n: int) -> int: Returns the minimal number of moves required to solve the Tower of Hanoi puzzle with n disks. return 2**n - 1"},{"question":"# Task Implement a Python function that evaluates a string containing valid mathematical expressions and computes their results. def evaluate_expression(expression: str) -> float: Evaluates a string containing a mathematical expression and returns its result as a float. def apply_operator(operands, operator): b = operands.pop() a = operands.pop() if operator == '+': operands.append(a + b) elif operator == '-': operands.append(a - b) elif operator == '*': operands.append(a * b) elif operator == '/': operands.append(a / b) if not expression.strip(): return 0 operands, operators = [], [] i, n = 0, len(expression) while i < n: ch = expression[i] if ch.isdigit() or ch == '.': num = [] while i < n and (expression[i].isdigit() or expression[i] == '.'): num.append(expression[i]) i += 1 operands.append(float(\\"\\".join(num))) continue elif ch in \\"+-*/\\": while operators and precedence(operators[-1]) >= precedence(ch): apply_operator(operands, operators.pop()) operators.append(ch) i += 1 while operators: apply_operator(operands, operators.pop()) return operands[0] def precedence(op): if op in '+-': return 1 elif op in '*/': return 2 return 0 # Unit Tests from solution import evaluate_expression def test_evaluate_simple_addition(): assert evaluate_expression(\\"3 + 2\\") == 5.0 def test_evaluate_with_mult_operations(): assert evaluate_expression(\\"3 + 2 * 2\\") == 7.0 def test_evaluate_with_spaces(): assert evaluate_expression(\\" 3 + 2 \\") == 5.0 def test_evaluate_combined_operations(): assert evaluate_expression(\\"10 - 3 * 2 + 1\\") == 5.0 def test_evaluate_with_division(): assert evaluate_expression(\\"3 + 5 / 2\\") == 5.5 def test_evaluate_complex_expression(): assert evaluate_expression(\\"0 / 1 + 2 * 3\\") == 6.0 def test_evaluate_empty_expression(): assert evaluate_expression(\\"\\") == 0 def test_evaluate_single_number(): assert evaluate_expression(\\"42\\") == 42.0","solution":"def evaluate_expression(expression: str) -> float: Evaluates a string containing a mathematical expression and returns its result as a float. def apply_operator(operands, operator): b = operands.pop() a = operands.pop() if operator == '+': operands.append(a + b) elif operator == '-': operands.append(a - b) elif operator == '*': operands.append(a * b) elif operator == '/': operands.append(a / b) if not expression.strip(): return 0 operands, operators = [], [] i, n = 0, len(expression) while i < n: ch = expression[i] if ch.isdigit() or ch == '.': num = [] while i < n and (expression[i].isdigit() or expression[i] == '.'): num.append(expression[i]) i += 1 operands.append(float(\\"\\".join(num))) continue elif ch in \\"+-*/\\": while operators and precedence(operators[-1]) >= precedence(ch): apply_operator(operands, operators.pop()) operators.append(ch) i += 1 while operators: apply_operator(operands, operators.pop()) return operands[0] def precedence(op): if op in '+-': return 1 elif op in '*/': return 2 return 0"},{"question":"import pytest from typing import Optional, List class BinarySearchTree: class Node: def __init__(self, key): self.left = None self.right = None self.value = key def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = self.Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.value: if node.left is None: node.left = self.Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = self.Node(key) else: self._insert(node.right, key) def in_order_traversal(self): result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, node, result): if node is not None: self._in_order_traversal(node.left, result) result.append(node.value) self._in_order_traversal(node.right, result) def kth_smallest(self, k: int) -> Optional[int]: Return the k-th smallest element in the BST. If k is out of bounds, return None. elements = self.in_order_traversal() if 0 < k <= len(elements): return elements[k - 1] else: return None def test_kth_smallest_basic(): bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) bst.insert(6) bst.insert(8) assert bst.kth_smallest(1) == 2 assert bst.kth_smallest(4) == 5 assert bst.kth_smallest(7) == 8 assert bst.kth_smallest(8) == None def test_kth_smallest_single_element(): bst = BinarySearchTree() bst.insert(10) assert bst.kth_smallest(1) == 10 assert bst.kth_smallest(2) == None def test_kth_smallest_multiple_elements(): bst = BinarySearchTree() for value in [15, 10, 20, 8, 12, 17, 25, 6, 11, 14]: bst.insert(value) assert bst.kth_smallest(5) == 12 assert bst.kth_smallest(6) == 14 assert bst.kth_smallest(10) == 25 def test_kth_smallest_out_of_bounds(): bst = BinarySearchTree() bst.insert(30) bst.insert(20) bst.insert(40) assert bst.kth_smallest(0) == None assert bst.kth_smallest(4) == None def test_kth_smallest_large_k(): bst = BinarySearchTree() values = [20, 10, 30, 5, 15, 25, 35] for value in values: bst.insert(value) assert bst.kth_smallest(8) == None assert bst.kth_smallest(100) == None","solution":"class BinarySearchTree: class Node: def __init__(self, key): self.left = None self.right = None self.value = key def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = self.Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.value: if node.left is None: node.left = self.Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = self.Node(key) else: self._insert(node.right, key) def in_order_traversal(self): result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, node, result): if node is not None: self._in_order_traversal(node.left, result) result.append(node.value) self._in_order_traversal(node.right, result) def kth_smallest(self, k): elements = self.in_order_traversal() if 0 < k <= len(elements): return elements[k - 1] else: return None"},{"question":"def max_overlapping_events(logs: list) -> int: Determines the maximum number of overlapping events from the given list of logs. Args: logs (list): A list where each element is a tuple of start and end times in \\"HH:MM\\" format Returns: int: The maximum number of overlapping events at any point in time Examples: >>> max_overlapping_events([(\\"10:00\\", \\"10:05\\"), (\\"10:03\\", \\"10:08\\")]) 2 >>> max_overlapping_events([(\\"10:00\\", \\"10:05\\"), (\\"10:06\\", \\"10:08\\")]) 1 >>> max_overlapping_events([(\\"09:00\\", \\"10:00\\"), (\\"09:30\\", \\"09:45\\"), (\\"09:45\\", \\"10:15\\")]) 2 >>> max_overlapping_events([(\\"08:00\\", \\"08:30\\"), (\\"08:15\\", \\"08:45\\"), (\\"10:00\\", \\"11:00\\")]) 2 >>> max_overlapping_events([]) 0 pass","solution":"def max_overlapping_events(logs): Determines the maximum number of overlapping events from the given list of logs. Args: logs (list): A list where each element is a tuple of start and end times in \\"HH:MM\\" format Returns: int: The maximum number of overlapping events at any point in time # Convert time to minutes from the start of the day for easy comparison def time_to_minutes(time): hours, minutes = map(int, time.split(\\":\\")) return hours * 60 + minutes # Create events list with (+1 for start, -1 for end) events = [] for start, end in logs: events.append((time_to_minutes(start), 1)) events.append((time_to_minutes(end), -1)) # Sort events first by time, then by type of event (start before end if they are at the same time) events.sort(key=lambda x: (x[0], x[1])) max_overlap = 0 current_overlap = 0 # Traverse through the events to find the peak overlap for time, event_type in events: current_overlap += event_type max_overlap = max(max_overlap, current_overlap) return max_overlap"},{"question":"def search_matrix(matrix: list[list[int]], target: int) -> bool: Optimize the search function to check if a given integer exists in the matrix. The matrix rows and columns are sorted in ascending order. :param matrix: List of lists of integers representing the matrix. :param target: Integer target to search for in the matrix. :return: Boolean indicating whether the target exists in the matrix. >>> matrix = [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ] >>> search_matrix(matrix, 5) True >>> search_matrix(matrix, 20) False # Test Cases def test_search_matrix_found(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] assert search_matrix(matrix, 5) == True def test_search_matrix_not_found(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] assert search_matrix(matrix, 20) == False def test_search_matrix_edge_case(): # Test edge case with single element matrix matrix = [ [5] ] assert search_matrix(matrix, 5) == True assert search_matrix(matrix, 6) == False def test_search_matrix_empty(): matrix = [] assert search_matrix(matrix, 5) == False def test_search_matrix_boundary_conditions(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] assert search_matrix(matrix, 1) == True assert search_matrix(matrix, 30) == True","solution":"def search_matrix(matrix: list[list[int]], target: int) -> bool: Search for a target value in a sorted matrix. :param matrix: List of lists of integers representing the matrix. :param target: Integer target to search for in the matrix. :return: Boolean indicating whether the target exists in the matrix. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"def word_ladder(start: str, end: str, word_list: list) -> list: Find the shortest path from start to end by changing one letter at a time using words from word_list. >>> word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] >>> word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) [] >>> word_ladder(\\"apple\\", \\"appla\\", [\\"appla\\", \\"apply\\", \\"appls\\"]) [\\"apple\\", \\"appla\\"] >>> word_ladder(\\"hit\\", \\"lot\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) [\\"hit\\", \\"hot\\", \\"lot\\"] >>> word_ladder(\\"start\\", \\"end\\", []) [] >>> word_ladder(123, \\"end\\", [\\"end\\", \\"edt\\", \\"ent\\", \\"end\\"]) Raises: TypeError: Inputs must be valid strings >>> word_ladder(\\"start\\", 456, [\\"end\\", \\"edt\\", \\"ent\\", \\"end\\"]) Raises: TypeError: Inputs must be valid strings >>> word_ladder(\\"start\\", \\"end\\", \\"not_a_list\\") Raises: TypeError: Inputs must be valid strings >>> word_ladder(\\"start\\", \\"end\\", [\\"end\\", 123, \\"ent\\", \\"end\\"]) Raises: TypeError: Inputs must be valid strings","solution":"from collections import deque def word_ladder(start: str, end: str, word_list: list) -> list: if not isinstance(start, str) or not isinstance(end, str) or not isinstance(word_list, list): raise TypeError(\\"Inputs must be valid strings\\") for word in word_list: if not isinstance(word, str): raise TypeError(\\"Inputs must be valid strings\\") word_set = set(word_list) if end not in word_set: return [] def get_neighbors(word): neighbors = [] for i in range(len(word)): for char in 'abcdefghijklmnopqrstuvwxyz': possible_word = word[:i] + char + word[i+1:] if possible_word != word and possible_word in word_set: neighbors.append(possible_word) return neighbors queue = deque([(start, [start])]) visited = set([start]) while queue: current_word, path = queue.popleft() for neighbor in get_neighbors(current_word): if neighbor == end: return path + [end] if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return []"},{"question":"Implement a Least Recently Used (LRU) cache in Python with two primary functions \`refer\` and \`get_cache\`. from collections import deque cache = deque() def refer(cache_size: int, pages: list[int]) -> list[int]: global cache cache.clear() for page in pages: if page in cache: cache.remove(page) elif len(cache) == cache_size: cache.popleft() cache.append(page) return list(cache) def get_cache() -> list[int]: return list(cache) # Example Usage cache_size = 3 pages = [1, 2, 3, 4, 2, 1, 5, 1, 2, 3, 4, 5] final_cache_state = refer(cache_size, pages) print(final_cache_state) # Output: [3, 4, 5] current_cache_state = get_cache() print(current_cache_state) # Output: [3, 4, 5]","solution":"from collections import deque cache = deque() def refer(cache_size: int, pages: list[int]) -> list[int]: global cache cache.clear() for page in pages: if page in cache: cache.remove(page) elif len(cache) == cache_size: cache.popleft() cache.append(page) return list(cache) def get_cache() -> list[int]: return list(cache)"},{"question":"def length_of_lis(nums: List[int]) -> int: Finds the length of the longest increasing subsequence in a list of integers. >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([9, 8, 7, 6, 5, 4, 3, 2, 1]) 1 >>> length_of_lis([1, 2, 3, 4, 5, 6, 7, 8, 9]) 9 >>> length_of_lis([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 >>> length_of_lis([10]) 1 >>> length_of_lis([]) 0 >>> length_of_lis([2, 2, 2, 2, 2]) 1 >>> length_of_lis([1, 3, 2, 3, 4, 1, 5]) 5","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the given list of numbers. if not nums: return 0 from bisect import bisect_left # The array to store our subsequence sub = [] for num in nums: # Find the index of the smallest number >= num i = bisect_left(sub, num) # If num is larger than any element in sub if i == len(sub): sub.append(num) # If there is an element in sub great or equal to num, replace it with num else: sub[i] = num return len(sub)"},{"question":"from datetime import datetime from typing import List, Dict, Any class LogParser: def __init__(self): self.logs = [] def load(self, logs: List[str]) -> None: Load a list of log messages into the parser. Args: logs (List[str]): A list of log messages. pass def filter_by_level(self, level: str) -> List[str]: Filter and return logs of a specified log level. Args: level (str): The log level to filter by. Returns: List[str]: A list of log messages matching the specified level. pass def within_time_range(self, start: datetime, end: datetime) -> List[str]: Return logs within a specific time range. Args: start (datetime): The start time of the range. end (datetime): The end time of the range. Returns: List[str]: A list of log messages within the given time range. pass def extract_json_data(self, log: str) -> Dict[str, Any]: Extract and return key-value pairs from the JSON payload in a log message. Args: log (str): The log message containing a JSON payload. Returns: Dict[str, Any]: A dictionary of key-value pairs extracted from the JSON payload. pass # Example Usage logs = [ \\"2023-09-10 10:00:00 INFO User login successful\\", \\"2023-09-10 10:01:00 ERROR User login failed: {\\"user_id\\": 123, \\"error\\": \\"Invalid credentials\\"}\\", \\"2023-09-10 10:02:00 DEBUG Initiating background job\\", \\"2023-09-10 10:03:00 INFO Background job completed successfully\\", ] parser = LogParser() parser.load(logs) # Filter logs by level error_logs = parser.filter_by_level(\\"ERROR\\") # Filter logs within a specific time range start_time = datetime.strptime('2023-09-10 10:00:00', '%Y-%m-%d %H:%M:%S') end_time = datetime.strptime('2023-09-10 10:02:00', '%Y-%m-%d %H:%M:%S') time_filtered_logs = parser.within_time_range(start_time, end_time) # Extract JSON data from a log json_data = parser.extract_json_data(error_logs[0]) print(error_logs) print(time_filtered_logs) print(json_data)","solution":"import json from datetime import datetime from typing import List, Dict, Any class LogParser: def __init__(self): self.logs = [] def load(self, logs: List[str]) -> None: self.logs = logs def filter_by_level(self, level: str) -> List[str]: return [log for log in self.logs if f\\" {level} \\" in log] def within_time_range(self, start: datetime, end: datetime) -> List[str]: result = [] for log in self.logs: timestamp_str = log.split(' ')[0] + ' ' + log.split(' ')[1] log_time = datetime.strptime(timestamp_str, '%Y-%m-%d %H:%M:%S') if start <= log_time <= end: result.append(log) return result def extract_json_data(self, log: str) -> Dict[str, Any]: try: json_str = log[log.index('{'):log.rindex('}')+1] return json.loads(json_str) except (ValueError, json.JSONDecodeError): return {}"},{"question":"class Minesweeper: def __init__(self, board): self.board = board self.rows = len(board) self.cols = len(board[0]) self.game_over = False def visualize_board(self): for row in self.board: print(' '.join(row)) def reveal_grid(self, row: int, col: int) -> None: Reveal the content of the grid when a cell is clicked. Args: row (int): The row index of the cell to be revealed. col (int): The column index of the cell to be revealed. - If the clicked cell contains a mine ('M'), the game should be marked as over. - If the clicked cell contains a number ('1'-'8'), only that cell should be revealed. - If the clicked cell is an empty cell ('.'), reveal all connected empty cells up to cells that contain numbers. >>> board = [ ... ['1', 'M', '1', '.', '.'], ... ['1', '1', '1', '.', '.'], ... ['.', '.', '.', '2', 'M'], ... ['.', '.', '.', '2', '1'], ... ['.', 'M', '1', '1', '.'] ... ] >>> minesweeper = Minesweeper(board) >>> minesweeper.reveal_grid(0, 3) >>> minesweeper.visualize_board() 1 M 1 _ _ 1 1 1 _ _ _ _ _ 2 M _ _ _ 2 1 _ M 1 1 _ pass def test_reveal_single_mine(): minesweeper = Minesweeper([ ['1', 'M', '1', '.', '.'], ['1', '1', '1', '.', '.'], ['.', '.', '.', '2', 'M'], ['.', '.', '.', '2', '1'], ['.', 'M', '1', '1', '.'] ]) minesweeper.reveal_grid(0, 1) assert minesweeper.game_over == True def test_reveal_number(): minesweeper = Minesweeper([ ['1', 'M', '1', '.', '.'], ['1', '1', '1', '.', '.'], ['.', '.', '.', '2', 'M'], ['.', '.', '.', '2', '1'], ['.', 'M', '1', '1', '.'] ]) minesweeper.reveal_grid(0, 0) assert minesweeper.board[0][0] == '_' def test_reveal_empty_connected_cells(): minesweeper = Minesweeper([ ['1', 'M', '1', '.', '.'], ['1', '1', '1', '.', '.'], ['.', '.', '.', '2', 'M'], ['.', '.', '.', '2', '1'], ['.', 'M', '1', '1', '.'] ]) minesweeper.reveal_grid(0, 3) assert minesweeper.board[0][3] == '_' assert minesweeper.board[0][4] == '_' assert minesweeper.board[1][3] == '_' assert minesweeper.board[1][4] == '_' assert minesweeper.board[2][0] == '_' assert minesweeper.board[2][1] == '_' assert minesweeper.board[2][2] == '_' def test_reveal_empty_on_boundary(): minesweeper = Minesweeper([ ['M', '.', '1'], ['.', '.', '.'], ['1', '.', 'M'], ]) minesweeper.reveal_grid(2, 1) assert minesweeper.board[1][1] == '_' assert minesweeper.board[1][0] == '_' assert minesweeper.board[1][2] == '_' assert minesweeper.board[0][1] == '_' def test_cannot_reveal_mine(): board = [ [\\"M\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\"M\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\"M\\", \\".\\", \\".\\", \\".\\"] ] minesweeper = Minesweeper(board) minesweeper.reveal_grid(0, 0) assert minesweeper.game_over == True","solution":"class Minesweeper: def __init__(self, board): self.board = board self.rows = len(board) self.cols = len(board[0]) self.game_over = False def visualize_board(self): for row in self.board: print(' '.join(row)) def reveal_grid(self, row, col): if self.board[row][col] == 'M': self.game_over = True print(\\"Game Over\\") return if self.board[row][col] != '.': self.board[row][col] = '_' return def dfs(r, c): if r < 0 or r >= self.rows or c < 0 or c >= self.cols or self.board[r][c] == '_' or self.board[r][c] == 'M': return if self.board[r][c] != '.': self.board[r][c] = '_' return self.board[r][c] = '_' dfs(r - 1, c) dfs(r + 1, c) dfs(r, c - 1) dfs(r, c + 1) dfs(r - 1, c - 1) dfs(r - 1, c + 1) dfs(r + 1, c - 1) dfs(r + 1, c + 1) dfs(row, col)"},{"question":"def balanced_string_splits(s: str) -> int: Calculates the number of balanced substrings that can be obtained from the given string. A string is considered balanced if it contains an equal number of 'R' and 'L' characters. Parameters: s (str): A non-empty string consisting only of the characters 'R' and 'L'. Returns: int: The number of balanced substrings that can be obtained from the given string. >>> balanced_string_splits(\\"RLRRLLRLRL\\") == 4 >>> balanced_string_splits(\\"RLLLLRRRLR\\") == 3 >>> balanced_string_splits(\\"LLLLRRRR\\") == 1 >>> balanced_string_splits(\\"RLRRLLR\\") == 2","solution":"def balanced_string_splits(s: str) -> int: Calculates the number of balanced substrings that can be obtained from the given string. A string is considered balanced if it contains an equal number of 'R' and 'L' characters. Parameters: s (str): A non-empty string consisting only of the characters 'R' and 'L'. Returns: int: The number of balanced substrings that can be obtained from the given string. if not isinstance(s, str): raise ValueError(\\"Input must be a string\\") if any(c not in 'RL' for c in s): raise ValueError(\\"String can only contain 'R' and 'L'\\") count = 0 balance = 0 for char in s: if char == 'R': balance += 1 elif char == 'L': balance -= 1 if balance == 0: count += 1 return count"},{"question":"# Matrix Rotation with Boundary Constraints Update Context You are tasked with creating a utility for rotating submatrices within a larger matrix. This utility will help in various data manipulation scenarios where specific regions of a matrix need to be processed separately. Task Write a function that rotates a specified submatrix (given by its top-left and bottom-right coordinates) within a larger n x n matrix by 90 degrees clockwise. The submatrix and matrix are both represented as 2D arrays. def rotate_submatrix( matrix: list[list[int]], top_left: tuple[int, int], bottom_right: tuple[int, int] ) -> list[list[int]]: Rotates the submatrix defined by top_left and bottom_right coordinates by 90 degrees clockwise. :param matrix: List of lists representing the n x n matrix. :param top left: Tuple[int, int] representing the top left coordinates of the submatrix. :param bottom right: Tuple[int, int] representing the bottom right coordinates of the submatrix. :return: The modified n x n matrix after rotating the specified submatrix. r1, c1 = top_left r2, c2 = bottom_right # Extract the submatrix submatrix = [row[c1:c2+1] for row in matrix[r1:r2+1]] # Transpose and reverse rows to achieve 90 degree rotation rotated_submatrix = [list(row) for row in zip(*submatrix[::-1])] # Place the rotated submatrix back into the original matrix for i in range(len(rotated_submatrix)): matrix[r1 + i][c1:c2+1] = rotated_submatrix[i] return matrix","solution":"def rotate_submatrix(matrix, top_left, bottom_right): Rotates the submatrix defined by top_left and bottom_right coordinates by 90 degrees clockwise. :param matrix: List of lists representing the n x n matrix. :param top_left: Tuple[int, int] representing the top left coordinates of the submatrix. :param bottom_right: Tuple[int, int] representing the bottom right coordinates of the submatrix. :return: The modified n x n matrix after rotating the specified submatrix. r1, c1 = top_left r2, c2 = bottom_right # Extract the submatrix submatrix = [row[c1:c2+1] for row in matrix[r1:r2+1]] # Transpose and reverse rows to achieve 90 degree rotation rotated_submatrix = [list(row) for row in zip(*submatrix[::-1])] # Place the rotated submatrix back into the original matrix for i in range(len(rotated_submatrix)): matrix[r1 + i][c1:c2+1] = rotated_submatrix[i] return matrix"},{"question":"class Elevator: def __init__(self, id: int, current_floor: int = 0): # Initializes an elevator with a unique ID and its starting floor self.id = id self.current_floor = current_floor self.direction = \\"idle\\" # Can be \\"up\\", \\"down\\", or \\"idle\\" def request(self, start_floor: int, end_floor: int): # Simulates an elevator request where the elevator needs to travel and stop at the requested floors pass def move(self): # Moves the elevator one floor in its current direction pass def __repr__(self): # Returns a string representation of the elevator's status return f\\"Elevator {self.id} at floor {self.current_floor} going {self.direction}\\" class Building: def __init__(self, floors: int, elevators: int): # Initializes the building with a given number of floors and elevators self.floors = floors self.elevators = [Elevator(id=i) for i in range(elevators)] def request_elevator(self, start_floor: int, end_floor: int) -> int: # Selects the best elevator to fulfill the request and returns its ID pass def step(self): # Advances the state of all elevators by one simulation step pass def __repr__(self): # Returns a string representation of all elevators in the building return \\"n\\".join(str(elevator) for elevator in self.elevators) # Unit tests def test_elevator_initial_state(): elevator = Elevator(id=0) assert elevator.current_floor == 0 assert elevator.direction == \\"idle\\" assert elevator.target_floors == [] def test_elevator_request_and_move(): elevator = Elevator(id=0) elevator.request(1, 3) assert elevator.target_floors == [1, 3] assert elevator.direction == \\"up\\" elevator.move() assert elevator.current_floor == 1 assert elevator.target_floors == [3] elevator.move() assert elevator.current_floor == 2 assert elevator.target_floors == [3] elevator.move() assert elevator.current_floor == 3 assert elevator.target_floors == [] assert elevator.direction == \\"idle\\" def test_building_initial_state(): building = Building(floors=5, elevators=2) assert str(building) == \\"Elevator 0 at floor 0 going idlenElevator 1 at floor 0 going idle\\" def test_building_request_and_step(): building = Building(floors=5, elevators=2) elevator_id = building.request_elevator(1, 3) assert elevator_id == 0 assert str(building) == \\"Elevator 0 at floor 0 going upnElevator 1 at floor 0 going idle\\" building.step() assert str(building) == \\"Elevator 0 at floor 1 going upnElevator 1 at floor 0 going idle\\" building.step() assert str(building) == \\"Elevator 0 at floor 2 going upnElevator 1 at floor 0 going idle\\" building.step() assert str(building) == \\"Elevator 0 at floor 3 going idlenElevator 1 at floor 0 going idle\\"","solution":"class Elevator: def __init__(self, id: int, current_floor: int = 0): self.id = id self.current_floor = current_floor self.direction = \\"idle\\" # Can be \\"up\\", \\"down\\", or \\"idle\\" self.target_floors = [] # List of pending floors to stop at def request(self, start_floor: int, end_floor: int): if start_floor != self.current_floor: self.target_floors.append(start_floor) self.target_floors.append(end_floor) self.update_direction() def move(self): if not self.target_floors: self.direction = \\"idle\\" return next_floor = self.target_floors[0] if self.current_floor < next_floor: self.direction = \\"up\\" self.current_floor += 1 elif self.current_floor > next_floor: self.direction = \\"down\\" self.current_floor -= 1 if self.current_floor == next_floor: self.target_floors.pop(0) self.update_direction() def update_direction(self): if not self.target_floors: self.direction = \\"idle\\" elif self.current_floor < self.target_floors[0]: self.direction = \\"up\\" elif self.current_floor > self.target_floors[0]: self.direction = \\"down\\" def __repr__(self): return f\\"Elevator {self.id} at floor {self.current_floor} going {self.direction}\\" class Building: def __init__(self, floors: int, elevators: int): self.floors = floors self.elevators = [Elevator(id=i) for i in range(elevators)] def request_elevator(self, start_floor: int, end_floor: int) -> int: best_elevator = min(self.elevators, key=lambda e: abs(e.current_floor - start_floor)) best_elevator.request(start_floor, end_floor) return best_elevator.id def step(self): for elevator in self.elevators: elevator.move() def __repr__(self): return \\"n\\".join(str(elevator) for elevator in self.elevators)"},{"question":"from typing import List def stock_prices(starting_price: float, changes: List[float]) -> List[float]: Calculates the stock price for each day given the starting price and a list of daily percentage changes. Parameters: starting_price (float): The initial price of the stock. changes (List[float]): A list of daily percentage changes in stock price. Returns: List[float]: A list of stock prices for each day. >>> stock_prices(100, [10, -5, 7]) [110.0, 104.5, 111.815] >>> stock_prices(100, [0, 0, 0]) [100.0, 100.0, 100.0] >>> stock_prices(1000000, [50, -50, 25]) [1500000.0, 750000.0, 937500.0]","solution":"from typing import List def stock_prices(starting_price: float, changes: List[float]) -> List[float]: Calculates the stock price for each day given the starting price and a list of daily percentage changes. Parameters: starting_price (float): The initial price of the stock. changes (List[float]): A list of daily percentage changes in stock price. Returns: List[float]: A list of stock prices for each day. prices = [] current_price = starting_price for change in changes: current_price += current_price * (change / 100) prices.append(round(current_price, 6)) # Round to maintain precision return prices"},{"question":"from typing import Dict, List, Tuple def enhanced_shortest_path(graph: Dict[int, List[Tuple[int, float]]], start: int) -> List[Tuple[int, float]]: Enhance the function to find the shortest path from a starting node to all other nodes in a directed weighted graph. Parameters: graph (Dict[int, List[Tuple[int, float]]]): A dictionary where keys are node identifiers and values are lists of tuples. Each tuple contains a neighboring node and the weight of the edge to that neighboring node. start (int): The starting node from which to calculate the shortest paths. Returns: List[Tuple[int, float]]: A list of tuples, where each tuple contains a node identifier and the shortest distance from the start node to that node. The list is sorted by the node identifiers in ascending order. Examples: >>> graph = { ... 0: [(1, 4.0), (2, 1.0)], ... 1: [(3, 1.0)], ... 2: [(1, 2.0), (3, 5.0)], ... 3: [] ... } >>> start = 0 >>> enhanced_shortest_path(graph, start) [(0, 0.0), (1, 3.0), (2, 1.0), (3, 4.0)]","solution":"import heapq from typing import Dict, List, Tuple def enhanced_shortest_path(graph: Dict[int, List[Tuple[int, float]]], start: int) -> List[Tuple[int, float]]: # Initialize distances with infinity, and distance to start node as 0 distances = {node: float('inf') for node in graph} distances[start] = 0.0 # Priority queue to select the next node with the smallest distance pq = [(0.0, start)] heapq.heapify(pq) while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) # Convert distances to a sorted list of tuples sorted_distances = sorted(distances.items()) return sorted_distances"},{"question":"import heapq class PriorityQueue: def __init__(self): Initialize an empty priority queue using Min-Heap. self.heap = [] def insert(self, element: int): Insert an element into the priority queue. >>> pq = PriorityQueue() >>> pq.insert(10) >>> pq.insert(4) >>> pq.size() 2 >>> pq.peek() 4 pass def extract_min(self) -> int | None: Remove and return the minimum element from the priority queue. >>> pq = PriorityQueue() >>> pq.insert(10) >>> pq.insert(4) >>> pq.extract_min() 4 >>> pq.extract_min() 10 >>> pq.extract_min() is None True pass def peek(self) -> int | None: Return the minimum element without removing it. >>> pq = PriorityQueue() >>> pq.insert(10) >>> pq.insert(4) >>> pq.peek() 4 >>> pq.extract_min() 4 >>> pq.peek() 10 pass def size(self) -> int: Return the number of elements in the priority queue. >>> pq = PriorityQueue() >>> pq.insert(10) >>> pq.size() 1 pass def is_empty(self) -> bool: Return \`True\` if the priority queue is empty, otherwise \`False\`. >>> pq = PriorityQueue() >>> pq.is_empty() True >>> pq.insert(10) >>> pq.is_empty() False pass","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] def insert(self, element: int): Insert an element into the priority queue. Time Complexity: O(log n) heapq.heappush(self.heap, element) def extract_min(self) -> int | None: Remove and return the minimum element from the priority queue. Time Complexity: O(log n) if not self.is_empty(): return heapq.heappop(self.heap) return None def peek(self) -> int | None: Return the minimum element without removing it. Time Complexity: O(1) if not self.is_empty(): return self.heap[0] return None def size(self) -> int: Return the number of elements in the priority queue. Time Complexity: O(1) return len(self.heap) def is_empty(self) -> bool: Return True if the priority queue is empty, otherwise False. Time Complexity: O(1) return len(self.heap) == 0"},{"question":"def min_operations(start: str, target: str) -> int: Determine the minimum number of operations required to transform \`start\` into \`target\`, where the allowed operations are Insert, Delete, and Replace a character. Args: start (str): The initial string. target (str): The target string to transform to. Returns: int: The minimum number of operations required to transform \`start\` to \`target\`. Examples: >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"lawn\\") 2 >>> min_operations(\\"intention\\", \\"execution\\") 5 >>> min_operations(\\"\\", \\"abc\\") 3 >>> min_operations(\\"abc\\", \\"\\") 3","solution":"def min_operations(start: str, target: str) -> int: Returns the minimum number of operations (insertions, deletions, substitutions) required to transform the start string into the target string. m, n = len(start), len(target) # Initialize a table to store the minimum operations at each step dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill out the first column and the first row for i in range(1, m + 1): dp[i][0] = i for j in range(1, n + 1): dp[0][j] = j # Fill out the dp table for i in range(1, m + 1): for j in range(1, n + 1): if start[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Replacement # The answer is in the bottom-right cell of the matrix return dp[m][n]"},{"question":"def max_weight_packages(weights: list, capacity: int) -> int: Compute the maximum weight that can be loaded onto the truck without exceeding its weight capacity. >>> max_weight_packages([2, 3, 4, 5, 9], 10) 10 >>> max_weight_packages([], 10) 0 >>> max_weight_packages([2, 3, 4], 0) 0 >>> max_weight_packages([2, 3, 4, 5, 9], 100000) 23 >>> max_weight_packages([1, 4, 8, 5], 10) 10 >>> max_weight_packages([5], 6) 5 >>> max_weight_packages([7], 6) 0 >>> max_weight_packages([2, 3, 5], 10) 10 >>> max_weight_packages([2, 3, 4, 8], 7) 7","solution":"def max_weight_packages(weights, capacity): Returns the maximum weight that can be loaded onto the truck without exceeding its weight capacity. n = len(weights) dp = [0] * (capacity + 1) for weight in weights: for c in range(capacity, weight - 1, -1): dp[c] = max(dp[c], dp[c - weight] + weight) return dp[capacity]"},{"question":"import threading from typing import List # Shared state for prime generation class PrimeSystem: def __init__(self): self.max_num = 0 self.initialize = False prime_system = PrimeSystem() def initialize_prime_system(n: int): Initializes the system state for prime number generation up to a max number n. pass def generate_primes(start: int, end: int, num_threads: int) -> List[int]: Generates primes using multiple threads. >>> initialize_prime_system(1000) >>> generate_primes(1, 100, 4) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] >>> generate_primes(100, 1, 4) ValueError: Start must be less than or equal to end. >>> generate_primes(0, 1, 4) [] >>> reset_prime_system() >>> generate_primes(1, 100, 4) RuntimeError: Prime system not initialized. Please call initialize_prime_system first. >>> generate_primes(1, 100, 1) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] pass def reset_prime_system(): Resets the generator system to its initial unpopulated state. pass","solution":"import threading from typing import List # Shared state for prime generation class PrimeSystem: def __init__(self): self.max_num = 0 self.initialize = False prime_system = PrimeSystem() def initialize_prime_system(n: int): Initializes the system state for prime number generation up to a max number n. prime_system.max_num = n prime_system.initialize = True def is_prime(n: int) -> bool: Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def primes_in_range(start: int, end: int) -> List[int]: Generates a list of primes in the given range [start, end). primes = [] for number in range(start, end): if is_prime(number): primes.append(number) return primes def generate_primes(start: int, end: int, num_threads: int) -> List[int]: Generates primes using multiple threads. if not prime_system.initialize: raise RuntimeError(\\"Prime system not initialized. Please call initialize_prime_system first.\\") if start > end: raise ValueError(\\"Start must be less than or equal to end.\\") if end <= 1: return [] step = (end - start) // num_threads threads = [] results = [[] for _ in range(num_threads)] def thread_task(thread_index: int, start: int, stop: int): Task run by each thread. results[thread_index] = primes_in_range(start, stop) for i in range(num_threads): thread_start = start + i * step thread_end = min(start + (i + 1) * step, end) if i == num_threads - 1: thread_end = end thread = threading.Thread(target=thread_task, args=(i, thread_start, thread_end)) threads.append(thread) thread.start() for thread in threads: thread.join() unique_primes = sorted(set(prime for sublist in results for prime in sublist)) return unique_primes def reset_prime_system(): Resets the generator system to its initial unpopulated state. prime_system.max_num = 0 prime_system.initialize = False"},{"question":"import re from typing import Union def format_phone_number(phone: str) -> Union[str, None]: Formats a phone number string to the format (XXX) XXX-XXXX if valid, otherwise returns None. >>> format_phone_number(\\"123-456-7890\\") == \\"(123) 456-7890\\" >>> format_phone_number(\\"(123) 456 7890\\") == \\"(123) 456-7890\\" >>> format_phone_number(\\"123 456--7890\\") == \\"(123) 456-7890\\" >>> format_phone_number(\\"12345\\") is None","solution":"import re from typing import Union def format_phone_number(phone: str) -> Union[str, None]: Formats a phone number string to the format (XXX) XXX-XXXX if valid, otherwise returns None. Parameters: phone (str): A string representing the phone number. Returns: Union[str, None]: A string in the format (XXX) XXX-XXXX if valid, else None. # Remove all non-numeric characters digits = re.sub(r'D', '', phone) # Validate if the string has exactly 10 digits if len(digits) != 10: return None # Format the string into (XXX) XXX-XXXX formatted = f\\"({digits[:3]}) {digits[3:6]}-{digits[6:]}\\" return formatted"},{"question":"# Graph Search Algorithm Implement the function \`longest_common_prefix\` that returns the longest common prefix among a list of strings. >>> from typing import List >>> def longest_common_prefix(strs: List[str]) -> str: if not strs: return \\"\\" shortest = min(strs, key=len) for i, char in enumerate(shortest): for other in strs: if other[i] != char: return shortest[:i] return shortest Unit Test: >>> def test_longest_common_prefix(): >>> assert longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" >>> assert longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" >>> assert longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) == \\"inters\\" >>> assert longest_common_prefix([\\"throne\\", \\"throne\\"]) == \\"throne\\" Solution: >>> from typing import List >>> def longest_common_prefix(strs: List[str]) -> str: if not strs: return \\"\\" shortest = min(strs, key=len) for i, char in enumerate(shortest): for other in strs: if other[i] != char: return shortest[:i] return shortest","solution":"from typing import List from collections import deque class Graph: def __init__(self, n: int): self.n = n self.adj_list = [[] for _ in range(n)] def add_edge(self, u: int, v: int): self.adj_list[u].append(v) self.adj_list[v].append(u) def bfs(self, start_node: int) -> List[int]: visited = [False] * self.n queue = deque([start_node]) visited[start_node] = True bfs_order = [] while queue: node = queue.popleft() bfs_order.append(node) for neighbor in self.adj_list[node]: if not visited[neighbor]: queue.append(neighbor) visited[neighbor] = True return bfs_order"},{"question":"from typing import List, Optional from dataclasses import dataclass @dataclass class Node: value: int left: Optional['Node'] = None right: Optional['Node'] = None def right_side_view(root: Optional[Node]) -> List[int]: Perform a right side view traversal of the binary tree and return the values of the nodes as seen from the right side. >>> root = Node(1) >>> root.left = Node(2) >>> root.right = Node(3) >>> root.left.right = Node(5) >>> root.right.right = Node(4) >>> right_side_view(root) [1, 3, 4] >>> root = Node(10) >>> root.left = Node(7) >>> root.right = Node(15) >>> root.right.left = Node(11) >>> root.right.right = Node(18) >>> right_side_view(root) [10, 15, 18] def test_example_1(): root = Node(1) root.left = Node(2) root.right = Node(3) root.left.right = Node(5) root.right.right = Node(4) assert right_side_view(root) == [1, 3, 4] def test_example_2(): root = Node(10) root.left = Node(7) root.right = Node(15) root.right.left = Node(11) root.right.right = Node(18) assert right_side_view(root) == [10, 15, 18] def test_empty_tree(): root = None assert right_side_view(root) == [] def test_single_node_tree(): root = Node(42) assert right_side_view(root) == [42] def test_left_skewed_tree(): root = Node(1) root.left = Node(2) root.left.left = Node(3) root.left.left.left = Node(4) assert right_side_view(root) == [1, 2, 3, 4] def test_right_skewed_tree(): root = Node(1) root.right = Node(2) root.right.right = Node(3) root.right.right.right = Node(4) assert right_side_view(root) == [1, 2, 3, 4]","solution":"from typing import List, Optional from dataclasses import dataclass from collections import deque @dataclass class Node: value: int left: Optional['Node'] = None right: Optional['Node'] = None def right_side_view(root: Optional[Node]) -> List[int]: if not root: return [] queue = deque([root]) rightside = [] while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() # If it's the rightmost element at the level if i == level_length - 1: rightside.append(node.value) # Add child nodes for the next level if node.left: queue.append(node.left) if node.right: queue.append(node.right) return rightside"},{"question":"def calculate_distance(speed: float, time: float) -> float: Calculate the distance traveled given the speed and time. :param speed: Speed in meters per second (float) :param time: Time in seconds (float) :return: Distance traveled in meters (float) >>> calculate_distance(10, 3600) 36000.0 >>> calculate_distance(2.5, 100) 250.0 >>> calculate_distance(0, 10) 0.0 >>> calculate_distance(20, 0) 0.0 >>> calculate_distance(25.3, 2000) 50600.0 # Ensure the speed and time are within valid ranges if not (0 <= speed <= 300): raise ValueError(\\"Speed must be between 0 and 300 meters per second.\\") if not (0 <= time <= 86400): raise ValueError(\\"Time must be between 0 and 86400 seconds (24 hours).\\") # Calculate distance using the formula d = s * t distance = speed * time return distance","solution":"def calculate_distance(speed: float, time: float) -> float: Calculate the distance traveled given the speed and time. :param speed: Speed in meters per second (float) :param time: Time in seconds (float) :return: Distance traveled in meters (float) # Ensure the speed and time are within valid ranges if not (0 <= speed <= 300): raise ValueError(\\"Speed must be between 0 and 300 meters per second.\\") if not (0 <= time <= 86400): raise ValueError(\\"Time must be between 0 and 86400 seconds (24 hours).\\") # Calculate distance using the formula d = s * t distance = speed * time return distance"},{"question":"def calculate_top_student(students: list) -> str: Identifies the student with the highest average score across all subjects. If multiple students have the same highest average score, returns the alphabetically first name. Examples: >>> students = [ ... {\\"Alice\\": {\\"Math\\": 90, \\"English\\": 85, \\"Science\\": 95}}, ... {\\"Bob\\": {\\"Math\\": 70, \\"English\\": 80, \\"Science\\": 75, \\"History\\": 85}}, ... {\\"Charlie\\": {\\"Math\\": 85, \\"English\\": 90, \\"History\\": 80}} ... ] >>> calculate_top_student(students) 'Alice' pass # Unit tests def test_single_student(): students = [{\\"Alice\\": {\\"Math\\": 90, \\"English\\": 85, \\"Science\\": 95}}] assert calculate_top_student(students) == \\"Alice\\" def test_multiple_students(): students = [ {\\"Alice\\": {\\"Math\\": 90, \\"English\\": 85, \\"Science\\": 95}}, {\\"Bob\\": {\\"Math\\": 70, \\"English\\": 80, \\"Science\\": 75, \\"History\\": 85}}, {\\"Charlie\\": {\\"Math\\": 85, \\"English\\": 90, \\"History\\": 80}} ] assert calculate_top_student(students) == \\"Alice\\" def test_tie_with_alphabetically_first(): students = [ {\\"Alice\\": {\\"Math\\": 90, \\"English\\": 90}}, {\\"Bob\\": {\\"Math\\": 95, \\"English\\": 85}} ] assert calculate_top_student(students) == \\"Alice\\" def test_tie_with_same_name(): students = [ {\\"Alice\\": {\\"Math\\": 85, \\"English\\": 90}}, {\\"Alice\\": {\\"Math\\": 90, \\"English\\": 85}} ] assert calculate_top_student(students) == \\"Alice\\" def test_all_same_average(): students = [ {\\"Alice\\": {\\"Math\\": 80, \\"English\\": 90}}, {\\"Bob\\": {\\"Math\\": 85, \\"English\\": 85}}, {\\"Charlie\\": {\\"Math\\": 90, \\"English\\": 80}} ] assert calculate_top_student(students) == \\"Alice\\" def test_no_subjects(): students = [ {\\"Alice\\": {\\"Math\\": 0}}, ] assert calculate_top_student(students) == \\"Alice\\" def test_mixed_number_of_subjects(): students = [ {\\"Alice\\": {\\"Math\\": 90, \\"English\\": 80, \\"Science\\": 70}}, {\\"Bob\\": {\\"Math\\": 95, \\"English\\": 85}}, {\\"Charlie\\": {\\"Math\\": 85}} ] assert calculate_top_student(students) == \\"Bob\\"","solution":"def calculate_top_student(students): Returns the name of the student with the highest average score. If multiple students have the same highest average score, returns the alphabetically first name. top_student = \\"\\" highest_avg = -1 for student_dict in students: for name, scores in student_dict.items(): total_score = sum(scores.values()) num_subjects = len(scores) average_score = total_score / num_subjects if (average_score > highest_avg) or (average_score == highest_avg and name < top_student): highest_avg = average_score top_student = name return top_student"},{"question":"from typing import List, Tuple, Dict import hashlib def hash_block(block: Dict) -> str: Generate the hash for a given block using SHA256. >>> block = { ... \\"sender\\": \\"Alice\\", ... \\"receiver\\": \\"Bob\\", ... \\"amount\\": 50, ... \\"previous_hash\\": \\"0\\" ... } >>> hash_block(block) == hashlib.sha256(\\"AliceBob500\\".encode()).hexdigest() True block_string = f\\"{block['sender']}{block['receiver']}{block['amount']}{block['previous_hash']}\\" return hashlib.sha256(block_string.encode()).hexdigest() def add_to_blockchain(transactions: List[Tuple[str, str, int]]) -> List[Dict]: Add transactions to the blockchain. Each block in the blockchain should contain: - sender: The sender's address. - receiver: The receiver's address. - amount: The amount transferred. - hash: The hash of the current block. - previous_hash: The hash of the previous block (use '0' for the first block's previous hash). >>> transactions = [(\\"Alice\\", \\"Bob\\", 50), (\\"Bob\\", \\"Charlie\\", 30), (\\"Alice\\", \\"Charlie\\", 20)] >>> blockchain = add_to_blockchain(transactions) >>> len(blockchain) 3 >>> blockchain[0][\\"sender\\"] 'Alice' >>> blockchain[0][\\"receiver\\"] 'Bob' >>> blockchain[0][\\"amount\\"] 50 >>> blockchain[0][\\"previous_hash\\"] '0' >>> blockchain[0][\\"hash\\"] == hash_block(blockchain[0]) True >>> blockchain[1][\\"sender\\"] 'Bob' >>> blockchain[1][\\"receiver\\"] 'Charlie' >>> blockchain[1][\\"amount\\"] 30 >>> blockchain[1][\\"previous_hash\\"] == blockchain[0][\\"hash\\"] True >>> blockchain[1][\\"hash\\"] == hash_block(blockchain[1]) True >>> blockchain[2][\\"sender\\"] 'Alice' >>> blockchain[2][\\"receiver\\"] 'Charlie' >>> blockchain[2][\\"amount\\"] 20 >>> blockchain[2][\\"previous_hash\\"] == blockchain[1][\\"hash\\"] True >>> blockchain[2][\\"hash\\"] == hash_block(blockchain[2]) True","solution":"import hashlib from typing import List, Tuple, Dict def hash_block(block: Dict) -> str: block_string = f\\"{block['sender']}{block['receiver']}{block['amount']}{block['previous_hash']}\\" return hashlib.sha256(block_string.encode()).hexdigest() def add_to_blockchain(transactions: List[Tuple[str, str, int]]) -> List[Dict]: blockchain = [] previous_hash = \\"0\\" for sender, receiver, amount in transactions: block = { \\"sender\\": sender, \\"receiver\\": receiver, \\"amount\\": amount, \\"previous_hash\\": previous_hash } current_hash = hash_block(block) block[\\"hash\\"] = current_hash blockchain.append(block) previous_hash = current_hash return blockchain"},{"question":"def evaluate_rpn(tokens: list[str]) -> float: Evaluate a mathematical expression in Reverse Polish Notation (RPN). Args: tokens (list): List of tokens representing the RPN expression. Returns: float: The evaluation result of the RPN expression. Examples: >>> evaluate_rpn([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) # Equivalent to ((2 + 1) * 3) 9.0 >>> evaluate_rpn([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) # Equivalent to (4 + (13 / 5)) 6.6 >>> evaluate_rpn([\\"2\\", \\"-1\\", \\"+\\"]) 1.0 >>> evaluate_rpn([\\"2\\", \\"3\\", \\"*\\", \\"-2\\", \\"/\\"]) -3.0 >>> evaluate_rpn([\\"3\\", \\"4\\", \\"+\\", \\"2\\", \\"*\\", \\"7\\", \\"/\\"]) 2.0 >>> evaluate_rpn([\\"5\\", \\"1\\", \\"2\\", \\"+\\", \\"4\\", \\"*\\", \\"+\\", \\"3\\", \\"-\\"]) 14.0 >>> evaluate_rpn([\\"5\\"]) 5.0 >>> evaluate_rpn([\\"3.5\\", \\"1.5\\", \\"+\\", \\"2\\", \\"/\\"]) 2.5","solution":"def evaluate_rpn(tokens: list[str]) -> float: Evaluate a mathematical expression in Reverse Polish Notation (RPN). Args: tokens (list): List of tokens representing the RPN expression. Returns: float: The evaluation result of the RPN expression. stack = [] for token in tokens: if token in {\\"+\\", \\"-\\", \\"*\\", \\"/\\"}: b = stack.pop() a = stack.pop() if token == \\"+\\": stack.append(a + b) elif token == \\"-\\": stack.append(a - b) elif token == \\"*\\": stack.append(a * b) elif token == \\"/\\": stack.append(a / b) else: stack.append(float(token)) return stack.pop()"},{"question":"class FileSystem: Create a class \`FileSystem\` that mimics simple file system operations including creating directories, adding files, and retrieving the content of a file or listing contents of a directory. >>> fs = FileSystem() >>> fs.mkdir(\\"/a/b/c\\") >>> fs.addFile(\\"/a/b/c/file.txt\\", \\"Hello World\\") >>> fs.readFile(\\"/a/b/c/file.txt\\") 'Hello World' >>> fs.mkdir(\\"/x/y\\") >>> fs.addFile(\\"/x/y/file.txt\\", \\"Another File\\") >>> fs.readFile(\\"/x/y/file.txt\\") 'Another File' >>> fs.ls(\\"/a/b\\") ['c'] >>> fs.ls(\\"/x/y/file.txt\\") ['file.txt'] >>> fs.ls(\\"/\\") ['a', 'x'] def __init__(self): pass def mkdir(self, path: str) -> None: pass def addFile(self, path: str, content: str) -> None: pass def readFile(self, path: str) -> str: pass def ls(self, path: str) -> list: pass","solution":"class FileSystem: def __init__(self): self.root = {} def mkdir(self, path: str) -> None: dirs = path.split('/') node = self.root for d in dirs: if d: # ignore empty strings from split if d not in node: node[d] = {} node = node[d] def addFile(self, path: str, content: str) -> None: dirs = path.split('/') node = self.root for d in dirs[:-1]: if d: # ignore empty strings from split node = node[d] node[dirs[-1]] = content def readFile(self, path: str) -> str: dirs = path.split('/') node = self.root for d in dirs: if d: # ignore empty strings from split node = node[d] return node def ls(self, path: str) -> list: dirs = path.split('/') node = self.root for d in dirs: if d: # ignore empty strings from split node = node[d] if isinstance(node, str): return [dirs[-1]] return sorted(node.keys())"},{"question":"from typing import List def normalize_data(data: List[float]) -> List[float]: Normalize a given list of numerical data to the range [0, 1]. Parameters: data (List[float]): A list of numerical values. Returns: List[float]: A list of normalized values. Raises: Exception: If the input data list is empty. Exception: If all values in the input data list are the same. Examples: >>> normalize_data([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] >>> normalize_data([10.0, 20.0, 30.0, 40.0]) [0.0, 0.3333333333333333, 0.6666666666666666, 1.0] >>> normalize_data([]) # Raises Exception(\\"Data should not be an empty list\\") >>> normalize_data([5, 5, 5, 5]) # Raises Exception(\\"Data values should not all be the same\\")","solution":"from typing import List def normalize_data(data: List[float]) -> List[float]: Normalize a given list of numerical data to the range [0, 1]. Parameters: data (List[float]): A list of numerical values. Returns: List[float]: A list of normalized values. Raises: Exception: If the input data list is empty. Exception: If all values in the input data list are the same. if not data: raise Exception(\\"Data should not be an empty list\\") min_val = min(data) max_val = max(data) if min_val == max_val: raise Exception(\\"Data values should not all be the same\\") return [(x - min_val) / (max_val - min_val) for x in data]"},{"question":"def find_palindromes(words: list[str]) -> list[str]: Finds all the palindromes in a given list of strings. Args: words (list[str]): A list of strings where each string is a word or phrase. Returns: list[str]: A list containing all palindromic strings from the input list. >>> find_palindromes(['racecar', 'level', 'hello', 'world']) ['racecar', 'level'] >>> find_palindromes(['madam', 'deified', 'test', 'rotor']) ['madam', 'deified', 'rotor'] >>> find_palindromes([]) [] pass # Test Cases def test_find_palindromes(): assert find_palindromes([]) == [] assert find_palindromes(['hello', 'world', 'python']) == [] assert find_palindromes(['racecar', 'level', 'madam']) == ['racecar', 'level', 'madam'] assert find_palindromes(['racecar', 'hello', 'level', 'world']) == ['racecar', 'level'] assert find_palindromes(['a', 'b', 'c']) == ['a', 'b', 'c'] assert find_palindromes(['deified', 'rotator', 'repaper']) == ['deified', 'rotator', 'repaper'] assert find_palindromes(['aabbaa', 'ab', 'civic', 'radar', 'refer', 'non']) == ['aabbaa', 'civic', 'radar', 'refer', 'non']","solution":"def find_palindromes(words: list[str]) -> list[str]: Finds all the palindromes in a given list of strings. Args: words (list[str]): A list of strings where each string is a word or phrase. Returns: list[str]: A list containing all palindromic strings from the input list. return [word for word in words if word == word[::-1]]"},{"question":"def max_rectangle_area(heights: List[int]) -> int: Determine the maximum rectangular area that can be formed by contiguous buildings. >>> max_rectangle_area([2, 1, 5, 6, 2, 3]) # Outputs: 10 >>> max_rectangle_area([2, 4]) # Outputs: 4","solution":"def max_rectangle_area(heights): Returns the maximum rectangular area that can be formed by contiguous buildings. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def total_resistance(resistances, configuration): Calculate the total resistance of a circuit based on the given configuration. Parameters: resistances (list of float): List of resistances in ohms. configuration (str): Configuration of the resistances. Can be \\"series\\" or \\"parallel\\". Returns: float: The total resistance of the circuit. Raises: ValueError: If configuration is not \\"series\\" or \\"parallel\\" or if any resistance is non-positive. Examples: >>> total_resistance([10.0, 20.0, 30.0], \\"series\\") 60.0 >>> total_resistance([10.0, 20.0, 30.0], \\"parallel\\") 5.454545454545454 def test_total_resistance_series(): assert total_resistance([10.0, 20.0, 30.0], \\"series\\") == 60.0 assert total_resistance([5.0, 10.0], \\"series\\") == 15.0 assert total_resistance([1.0], \\"series\\") == 1.0 assert total_resistance([], \\"series\\") == 0.0 def test_total_resistance_parallel(): assert abs(total_resistance([10.0, 20.0, 30.0], \\"parallel\\") - 5.454545454545454) < 1e-6 assert abs(total_resistance([5.0, 10.0], \\"parallel\\") - 3.3333333333333335) < 1e-6 assert total_resistance([1.0], \\"parallel\\") == 1.0 assert total_resistance([], \\"parallel\\") == 0.0 def test_total_resistance_invalid_configuration(): try: total_resistance([10.0, 20.0, 30.0], \\"invalid\\") except ValueError as e: assert str(e) == \\"Invalid configuration. Must be 'series' or 'parallel'.\\" def test_total_resistance_non_positive_resistance(): try: total_resistance([-10.0, 20.0, 30.0], \\"series\\") except ValueError as e: assert str(e) == \\"All resistances must be positive.\\" try: total_resistance([10.0, 0, 30.0], \\"parallel\\") except ValueError as e: assert str(e) == \\"All resistances must be positive.\\"","solution":"def total_resistance(resistances, configuration): Calculate the total resistance of a circuit based on the given configuration. Parameters: resistances (list of float): List of resistances in ohms. configuration (str): Configuration of the resistances. Can be \\"series\\" or \\"parallel\\". Returns: float: The total resistance of the circuit. Raises: ValueError: If configuration is not \\"series\\" or \\"parallel\\" or if any resistance is non-positive. if configuration not in [\\"series\\", \\"parallel\\"]: raise ValueError(\\"Invalid configuration. Must be 'series' or 'parallel'.\\") if any(r <= 0 for r in resistances): raise ValueError(\\"All resistances must be positive.\\") if configuration == \\"series\\": return sum(resistances) if configuration == \\"parallel\\": if not resistances: return 0.0 # Handle case of empty list for parallel total_inverse_resistance = sum(1.0 / r for r in resistances) if total_inverse_resistance == 0: return float('inf') # This handles case where all resistances are infinite (which is admittedly theoretical) return 1.0 / total_inverse_resistance"},{"question":"def multiplexer(inputs: List[int], select: List[int]) -> int: Simulates a 4-to-1 multiplexer and returns the selected value based on the select lines. Parameters: inputs (List[int]): A list of 4 binary integers (0 or 1). select (List[int]): A list of 2 binary integers (0 or 1). Returns: int: The selected input line value, either 0 or 1. Examples: >>> multiplexer([0, 1, 1, 0], [0, 0]) == 0 >>> multiplexer([0, 1, 1, 0], [0, 1]) == 1 >>> multiplexer([0, 1, 1, 0], [1, 0]) == 1 >>> multiplexer([0, 1, 1, 0], [1, 1]) == 0 pass # Test cases provided in the unit test def test_multiplexer_00(): inputs = [0, 1, 1, 0] select = [0, 0] assert multiplexer(inputs, select) == 0 def test_multiplexer_01(): inputs = [0, 1, 1, 0] select = [0, 1] assert multiplexer(inputs, select) == 1 def test_multiplexer_10(): inputs = [0, 1, 1, 0] select = [1, 0] assert multiplexer(inputs, select) == 1 def test_multiplexer_11(): inputs = [0, 1, 1, 0] select = [1, 1] assert multiplexer(inputs, select) == 0 def test_multiplexer_all_ones(): inputs = [1, 1, 1, 1] select = [0, 0] assert multiplexer(inputs, select) == 1 select = [0, 1] assert multiplexer(inputs, select) == 1 select = [1, 0] assert multiplexer(inputs, select) == 1 select = [1, 1] assert multiplexer(inputs, select) == 1 def test_multiplexer_all_zeros(): inputs = [0, 0, 0, 0] select = [0, 0] assert multiplexer(inputs, select) == 0 select = [0, 1] assert multiplexer(inputs, select) == 0 select = [1, 0] assert multiplexer(inputs, select) == 0 select = [1, 1] assert multiplexer(inputs, select) == 0 def test_multiplexer_mixed_numbers(): inputs = [1, 0, 1, 0] select = [0, 0] assert multiplexer(inputs, select) == 1 select = [0, 1] assert multiplexer(inputs, select) == 0 select = [1, 0] assert multiplexer(inputs, select) == 1 select = [1, 1] assert multiplexer(inputs, select) == 0","solution":"def multiplexer(inputs, select): Returns the selected value from inputs based on the select lines. Parameters: inputs (List[int]): A list of 4 binary integers (0 or 1). select (List[int]): A list of 2 binary integers (0 or 1). Returns: int: The selected input line value, either 0 or 1. # Convert the select lines to a binary index index = select[0] * 2 + select[1] return inputs[index]"},{"question":"def reverse_words_and_uppercase(sentence: str) -> str: Given a string containing a mix of characters and spaces, this function reverses each word in the sentence individually and converts each word to uppercase. >>> reverse_words_and_uppercase(\\"Hello world\\") \\"OLLEH DLROW\\" >>> reverse_words_and_uppercase(\\"coding is fun\\") \\"GNIDOC SI NUF\\" >>> reverse_words_and_uppercase(\\"a b cdef\\") \\"A B FEDC\\" pass","solution":"def reverse_words_and_uppercase(sentence: str) -> str: Given a string containing a mix of characters and spaces, this function reverses each word in the sentence individually and converts each word to uppercase. :param sentence: A string containing words separated by a single space. :return: A string with each word reversed and converted to uppercase. words = sentence.split() reversed_uppercase_words = [word[::-1].upper() for word in words] return ' '.join(reversed_uppercase_words)"},{"question":"import os from collections import defaultdict def group_files_by_extension(directory: str) -> dict: Groups files in the given directory by their extensions. Args: directory (str): The path to the directory to scan for files. Returns: dict: A dictionary where keys are file extensions and values are lists of file names with that extension. file_groups = defaultdict(list) # Check if the directory exists if not os.path.isdir(directory): raise ValueError(f\\"The directory {directory} does not exist or is not a directory.\\") # Iterate through the directory for item in os.listdir(directory): item_path = os.path.join(directory, item) if os.path.isfile(item_path): _, extension = os.path.splitext(item) extension = extension.lstrip('.') file_groups[extension].append(item) return dict(file_groups) # Unit tests def test_group_files_by_extension(tmpdir): test_dir = tmpdir.mkdir(\\"test_dir\\") (test_dir / \\"document1.txt\\").write(\\"\\") (test_dir / \\"image1.png\\").write(\\"\\") (test_dir / \\"document2.txt\\").write(\\"\\") (test_dir / \\"presentation.pptx\\").write(\\"\\") (test_dir / \\"image2.jpg\\").write(\\"\\") (test_dir / \\"script.py\\").write(\\"\\") expected_output = { 'txt': ['document1.txt', 'document2.txt'], 'png': ['image1.png'], 'pptx': ['presentation.pptx'], 'jpg': ['image2.jpg'], 'py': ['script.py'] } assert group_files_by_extension(test_dir) == expected_output def test_group_files_with_no_extension(tmpdir): test_dir = tmpdir.mkdir(\\"test_dir\\") (test_dir / \\"file1\\").write(\\"\\") (test_dir / \\"file2\\").write(\\".data\\") expected_output = { '': ['file1', 'file2'] } assert group_files_by_extension(test_dir) == expected_output def test_empty_directory(tmpdir): test_dir = tmpdir.mkdir(\\"test_dir\\") assert group_files_by_extension(test_dir) == {} def test_directory_does_not_exist(): with pytest.raises(ValueError): group_files_by_extension(\\"/non/existent/directory\\") def test_ignore_subdirectories(tmpdir): test_dir = tmpdir.mkdir(\\"test_dir\\") (test_dir / \\"document1.txt\\").write(\\"\\") sub_dir = test_dir.mkdir(\\"sub_dir\\") (sub_dir / \\"document2.txt\\").write(\\"\\") expected_output = { 'txt': ['document1.txt'] } assert group_files_by_extension(test_dir) == expected_output","solution":"import os from collections import defaultdict def group_files_by_extension(directory: str) -> dict: Groups files in the given directory by their extensions. Args: directory (str): The path to the directory to scan for files. Returns: dict: A dictionary where keys are file extensions and values are lists of file names with that extension. file_groups = defaultdict(list) # Check if the directory exists if not os.path.isdir(directory): raise ValueError(f\\"The directory {directory} does not exist or is not a directory.\\") # Iterate through the directory for item in os.listdir(directory): item_path = os.path.join(directory, item) if os.path.isfile(item_path): _, extension = os.path.splitext(item) extension = extension.lstrip('.') file_groups[extension].append(item) return dict(file_groups)"},{"question":"def generate_balanced_bracket_sequences(n: int) -> List[str]: Generate all possible balanced sequences of n pairs of parentheses. >>> generate_balanced_bracket_sequences(1) ['()'] >>> generate_balanced_bracket_sequences(2) ['(())', '()()'] >>> generate_balanced_bracket_sequences(3) ['((()))', '(()())', '(())()', '()(())', '()()()'] >>> generate_balanced_bracket_sequences(0) ['']","solution":"from typing import List def generate_balanced_bracket_sequences(n: int) -> List[str]: Generate all combinations of n pairs of balanced parentheses. def backtrack(s='', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + '(', left + 1, right) if right < left: backtrack(s + ')', left, right + 1) result = [] backtrack() return result"},{"question":"import re from collections import Counter from typing import List def most_common_word(text: str, banned: List[str]) -> str: Determine the most common word in the text that is not banned. >>> most_common_word(\\"Bob hit a ball, the hit BALL flew far after it was hit.\\", [\\"hit\\"]) \\"ball\\" >>> most_common_word(\\"a.\\", []) \\"a\\"","solution":"import re from collections import Counter def most_common_word(text: str, banned: list[str]) -> str: # Convert text to lowercase and replace punctuation with spaces text = re.sub(r'[^ws]', ' ', text).lower() # Split text into words words = text.split() # Filter out banned words words = [word for word in words if word not in banned] # Count the frequency of each word word_counts = Counter(words) # Find the most common word most_common = word_counts.most_common(1) return most_common[0][0] if most_common else \\"\\""},{"question":"def find_longest_word(text: str) -> str: Finds the longest word containing only alphabetic characters in the given text. >>> find_longest_word(\\"Hello there! Isn't this a great day?\\") \\"hello\\" >>> find_longest_word(\\"\\") \\"\\" >>> find_longest_word(\\"Well, this is awkward...\\") \\"awkward\\" >>> find_longest_word(\\"Cat bat hat mat scat brat spat\\") \\"scat\\" >>> find_longest_word(\\"A b c d e f g h i\\") \\"a\\" >>> find_longest_word(\\"MiXeD CaSe StrInG\\") \\"string\\" pass","solution":"import re def find_longest_word(text: str) -> str: Finds the longest word containing only alphabetic characters in the given text. Parameters: text (str): The input text containing letters, spaces, punctuation, etc. Returns: str: The longest word in lowercase. words = re.findall(r'b[a-zA-Z]+b', text) longest_word = max(words, key=len).lower() if words else '' return longest_word"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None @staticmethod def from_list(values): Create a linked list from a list of values. ll = LinkedList() if values: ll.head = ListNode(values[0]) current = ll.head for value in values[1:]: current.next = ListNode(value) current = current.next return ll def to_list(self): Convert the linked list to a list of values. values = [] current = self.head while current: values.append(current.value) current = current.next return values def reverse(self) -> None: Reverse the linked list in place. >>> l = LinkedList.from_list([1, 2, 3, 4, 5]) >>> l.reverse() >>> print(l.to_list()) # Output: [5, 4, 3, 2, 1] # Your implementation here def has_cycle(self) -> bool: Check if the linked list contains a cycle. Returns: A boolean indicating if there is a cycle in the linked list. >>> l = LinkedList.from_list([1, 2, 3, 4, 5]) >>> l.head.next.next.next.next = l.head.next >>> l.has_cycle() True >>> l = LinkedList.from_list([1, 2, 3, 4, 5]) >>> l.has_cycle() False # Your implementation here import pytest from solution import LinkedList, ListNode def test_reverse_linked_list(): l = LinkedList.from_list([1, 2, 3, 4, 5]) l.reverse() assert l.to_list() == [5, 4, 3, 2, 1] def test_reverse_empty_linked_list(): l = LinkedList.from_list([]) l.reverse() assert l.to_list() == [] def test_reverse_single_element_linked_list(): l = LinkedList.from_list([1]) l.reverse() assert l.to_list() == [1] def test_detect_cycle_linked_list(): l = LinkedList.from_list([1, 2, 3, 4, 5]) l.head.next.next.next.next.next = l.head.next assert l.has_cycle() == True def test_detect_cycle_empty_linked_list(): l = LinkedList.from_list([]) assert l.has_cycle() == False def test_detect_no_cycle_linked_list(): l = LinkedList.from_list([1, 2, 3, 4, 5]) assert l.has_cycle() == False def test_detect_cycle_single_element_linked_list(): l = LinkedList.from_list([1]) l.head.next = l.head assert l.has_cycle() == True","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None @staticmethod def from_list(values): Create a linked list from a list of values. ll = LinkedList() if values: ll.head = ListNode(values[0]) current = ll.head for value in values[1:]: current.next = ListNode(value) current = current.next return ll def to_list(self): Convert the linked list to a list of values. values = [] current = self.head while current: values.append(current.value) current = current.next return values def reverse(self) -> None: Reverse the linked list in place. prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def has_cycle(self) -> bool: Check if the linked list contains a cycle. slow = fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"def shortest_subsequence_with_k_distinct(sequence: str, k: int) -> int: Given a string sequence and an integer k, find the length of the shortest subsequence of sequence that contains at least k distinct characters. If no such subsequence exists, return -1. Args: sequence (str): A string consisting only of lowercase English letters. k (int): An integer representing the number of distinct characters required. Returns: int: The length of the shortest subsequence containing at least k distinct characters, or -1 if no such subsequence exists. Examples: >>> shortest_subsequence_with_k_distinct(\\"abcde\\", 3) 3 >>> shortest_subsequence_with_k_distinct(\\"aaabbbccc\\", 2) 2 >>> shortest_subsequence_with_k_distinct(\\"aaaaa\\", 2) -1","solution":"def shortest_subsequence_with_k_distinct(sequence: str, k: int) -> int: if len(set(sequence)) < k: return -1 n = len(sequence) min_length = n + 1 for i in range(n): char_set = set() for j in range(i, n): char_set.add(sequence[j]) if len(char_set) == k: min_length = min(min_length, j - i + 1) break return min_length if min_length != n + 1 else -1"},{"question":"def compute_directory_size(directory: Dict[str, Any]) -> int: Computes the total size of all files within the input directory and its subdirectories. :param directory: Dictionary representing the root directory. :return: Integer representing the total size of all files. >>> directory = { ... \\"file1.txt\\": 100, ... \\"folder1\\": { ... \\"file2.txt\\": 200, ... \\"folder2\\": { ... \\"file3.txt\\": 300 ... }, ... }, ... \\"file4.txt\\": 400 ... } >>> compute_directory_size(directory) 1000 from typing import Dict, Any def test_flat_directory(): directory = { \\"file1.txt\\": 100, \\"file2.txt\\": 200, \\"file3.txt\\": 300 } assert compute_directory_size(directory) == 600 def test_nested_directory(): directory = { \\"file1.txt\\": 100, \\"folder1\\": { \\"file2.txt\\": 200, \\"folder2\\": { \\"file3.txt\\": 300 }, }, \\"file4.txt\\": 400 } assert compute_directory_size(directory) == 1000 def test_empty_directory(): directory = {} assert compute_directory_size(directory) == 0 def test_directory_with_no_files(): directory = { \\"folder1\\": { \\"folder2\\": { \\"folder3\\": {} } } } assert compute_directory_size(directory) == 0 def test_mixed_directory(): directory = { \\"file1.txt\\": 50, \\"folder1\\": { \\"file2.txt\\": 70, \\"subfolder1\\": { \\"file3.txt\\": 30, \\"subfolder2\\": {} }, }, \\"file4.txt\\": 10 } assert compute_directory_size(directory) == 160","solution":"def compute_directory_size(directory): Computes the total size of all files within the input directory and its subdirectories. :param directory: Dictionary representing the root directory. :return: Integer representing the total size of all files. total_size = 0 for key, value in directory.items(): if isinstance(value, dict): total_size += compute_directory_size(value) elif isinstance(value, int): total_size += value return total_size"},{"question":"class URLShortener: URL Shortener Implementation. Methods: - encode(self, long_url: str) -> str: Encodes a long URL into a shortened URL. - decode(self, short_url: str) -> str: Decodes a shortened URL back into the original long URL. Example: >>> shortener = URLShortener() >>> long_url = \\"https://www.example.com/some/long/path/to/resource\\" >>> short_url = shortener.encode(long_url) >>> decoded_url = shortener.decode(short_url) >>> assert decoded_url == long_url >>> long_url2 = \\"https://www.anotherexample.com/different/path\\" >>> short_url2 = shortener.encode(long_url2) >>> decoded_url2 = shortener.decode(short_url2) >>> assert decoded_url2 == long_url2 def __init__(self): Initialize the URL shortener. self.url_to_code = {} self.code_to_url = {} self.base = \\"http://short.url/\\" self.counter = 0 def encode(self, long_url: str) -> str: Encodes a long URL into a shortened URL. pass def decode(self, short_url: str) -> str: Decodes a shortened URL back into the original long URL. pass","solution":"class URLShortener: def __init__(self): self.url_to_code = {} self.code_to_url = {} self.base = \\"http://short.url/\\" self.counter = 0 def _generate_code(self): return str(self.counter) def encode(self, long_url: str) -> str: if long_url in self.url_to_code: return self.base + self.url_to_code[long_url] self.counter += 1 code = self._generate_code() self.url_to_code[long_url] = code self.code_to_url[code] = long_url return self.base + code def decode(self, short_url: str) -> str: code = short_url.replace(self.base, \\"\\") if code in self.code_to_url: return self.code_to_url[code] return \\"\\""},{"question":"from typing import List def find_ladders(start: str, end: str, word_list: List[str]) -> List[List[str]]: Find all shortest transformation sequences from a start word to an end word, changing one letter at a time. Parameters: - start (str): The start word - end (str): The end word - word_list (List[str]): Dictionary of unique words Returns: - List[List[str]]: List of shortest transformation sequences >>> find_ladders(\\"hit\\", \\"cog\\", [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\", \\"lot\\", \\"log\\"]) [['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'lot', 'log', 'cog']] >>> find_ladders(\\"hit\\", \\"cog\\", [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cot\\", \\"log\\"]) [] >>> find_ladders(\\"hit\\", \\"hit\\", [\\"hit\\"]) [['hit']] >>> find_ladders(\\"a\\", \\"c\\", [\\"a\\", \\"b\\", \\"c\\"]) [['a', 'c']] >>> find_ladders(\\"hit\\", \\"cog\\", [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) [['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'lot', 'log', 'cog']] pass","solution":"from collections import defaultdict, deque from typing import List def find_ladders(start: str, end: str, word_list: List[str]) -> List[List[str]]: word_set = set(word_list) if end not in word_set: return [] # Breadth-First Search to find the shortest path layers = {} layers[start] = [[start]] while layers: new_layer = defaultdict(list) for word in layers: if word == end: return layers[word] for i in range(len(word)): for c in 'abcdefghijklmnopqrstuvwxyz': new_word = word[:i] + c + word[i+1:] if new_word in word_set: new_layer[new_word] += [j + [new_word] for j in layers[word]] word_set -= set(new_layer.keys()) layers = new_layer return []"},{"question":"def sum_and_group_transactions(transactions: list[int]) -> list[int]: Summarizes a list of financial transactions by grouping consecutive items with the same sign and calculating their sums. Args: - transactions (list[int]): List of integers where each integer is a transaction (either positive or negative). Returns: - list[int]: New list where consecutive numbers with the same sign are summed together. if not transactions: return [] grouped_transactions = [] current_sum = transactions[0] for i in range(1, len(transactions)): if (transactions[i] >= 0 and current_sum >= 0) or (transactions[i] < 0 and current_sum < 0): current_sum += transactions[i] else: grouped_transactions.append(current_sum) current_sum = transactions[i] grouped_transactions.append(current_sum) return grouped_transactions # Sample testing if __name__ == \\"__main__\\": assert sum_and_group_transactions([100, 200, -50, -300, 400, 700, -200]) == [300, -350, 1100, -200] assert sum_and_group_transactions([1, 2, 3, -4, -5, -6, 7, -8]) == [6, -15, 7, -8] assert sum_and_group_transactions([5, -5, 5, -5]) == [5, -5, 5, -5] assert sum_and_group_transactions([-3, -2, -1]) == [-6] assert sum_and_group_transactions([]) == [] print(\\"All tests passed.\\")","solution":"def sum_and_group_transactions(transactions: list[int]) -> list[int]: if not transactions: return [] grouped_transactions = [] current_sum = transactions[0] for i in range(1, len(transactions)): if (transactions[i] >= 0 and current_sum >= 0) or (transactions[i] < 0 and current_sum < 0): current_sum += transactions[i] else: grouped_transactions.append(current_sum) current_sum = transactions[i] grouped_transactions.append(current_sum) return grouped_transactions"},{"question":"def binary_search(arr, target): Perform binary search on a sorted list to find the index of the target. If the target is found, return its index. Otherwise, return -1. >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 7) 6 >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 11) -1 # Implementation goes here","solution":"def binary_search(arr, target): Perform binary search on a sorted list to find the index of the target. If the target is found, return its index. Otherwise, return -1. left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"class Node: def __init__(self, data: int, left: 'Node' = None, right: 'Node' = None): self.data = data self.left = left self.right = right class BinaryTree: def __init__(self, root: Node): self.root = root def is_balanced_tree(tree: BinaryTree) -> bool: Determine if the given binary tree is height-balanced. :param tree: BinaryTree representing the binary tree. :return: True if the tree is height-balanced, False otherwise.","solution":"class Node: def __init__(self, data: int, left: 'Node' = None, right: 'Node' = None): self.data = data self.left = left self.right = right class BinaryTree: def __init__(self, root: Node): self.root = root def is_balanced_tree(tree: BinaryTree) -> bool: Determine if the given binary tree is height-balanced. :param tree: BinaryTree representing the binary tree. :return: True if the tree is height-balanced, False otherwise. def check_balance(node: Node) -> (bool, int): if node is None: return True, 0 left_balanced, left_height = check_balance(node.left) right_balanced, right_height = check_balance(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 height = max(left_height, right_height) + 1 return balanced, height is_balanced, _ = check_balance(tree.root) return is_balanced"},{"question":"def total_journey_time(num_stops: int, intervals: list[int]) -> int: Calculates the total journey time for completing the bus route. :param num_stops: The total number of bus stops. :param intervals: A list of time intervals in minutes between each successive pair of bus stops. :return: The total journey time in minutes. >>> total_journey_time(2, [5]) 5 >>> total_journey_time(5, [5, 10, 15, 20]) 50 >>> total_journey_time(3, [7, 11]) 18 >>> total_journey_time(4, [8, 3, 6]) 17","solution":"def total_journey_time(num_stops: int, intervals: list[int]) -> int: Calculates the total journey time for completing the bus route. :param num_stops: The total number of bus stops. :param intervals: A list of time intervals in minutes between each successive pair of bus stops. :return: The total journey time in minutes. return sum(intervals)"},{"question":"from typing import List def rotate_image_90_clockwise(image: List[List[int]]) -> List[List[int]]: Rotates the given 2D image 90 degrees clockwise. >>> rotate_image_90_clockwise([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_image_90_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] pass def rotate_image_90_counterclockwise(image: List[List[int]]) -> List[List[int]]: Rotates the given 2D image 90 degrees counterclockwise. >>> rotate_image_90_counterclockwise([[1, 2], [3, 4]]) [[2, 4], [1, 3]] >>> rotate_image_90_counterclockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[3, 6, 9], [2, 5, 8], [1, 4, 7]] pass","solution":"from typing import List def rotate_image_90_clockwise(image: List[List[int]]) -> List[List[int]]: Rotates the given 2D image 90 degrees clockwise. if not image or not image[0]: return image rows = len(image) cols = len(image[0]) rotated = [[0] * rows for _ in range(cols)] for r in range(rows): for c in range(cols): rotated[c][rows - 1 - r] = image[r][c] return rotated def rotate_image_90_counterclockwise(image: List[List[int]]) -> List[List[int]]: Rotates the given 2D image 90 degrees counterclockwise. if not image or not image[0]: return image rows = len(image) cols = len(image[0]) rotated = [[0] * rows for _ in range(cols)] for r in range(rows): for c in range(cols): rotated[cols - 1 - c][r] = image[r][c] return rotated"},{"question":"def create_library_management_schema() -> str: Produce the SQL statements to create a relational schema for Library Management System. >>> schema = create_library_management_schema() >>> \\"CREATE TABLE Authors\\" in schema True >>> \\"CREATE TABLE Books\\" in schema True >>> \\"CREATE TABLE Members\\" in schema True >>> \\"CREATE TABLE Loans\\" in schema True from solution import create_library_management_schema def test_create_library_management_schema(): schema = create_library_management_schema() assert \\"CREATE TABLE Authors\\" in schema assert \\"CREATE TABLE Books\\" in schema assert \\"CREATE TABLE Members\\" in schema assert \\"CREATE TABLE Loans\\" in schema def test_authors_table(): schema = create_library_management_schema() assert \\"author_id INT PRIMARY KEY\\" in schema assert \\"name VARCHAR(255) NOT NULL\\" in schema assert \\"birth_year INT\\" in schema def test_books_table(): schema = create_library_management_schema() assert \\"book_id INT PRIMARY KEY\\" in schema assert \\"title VARCHAR(255) NOT NULL\\" in schema assert \\"author_id INT\\" in schema assert \\"genre VARCHAR(100)\\" in schema assert \\"published_year INT\\" in schema assert \\"FOREIGN KEY (author_id) REFERENCES Authors (author_id)\\" in schema def test_members_table(): schema = create_library_management_schema() assert \\"member_id INT PRIMARY KEY\\" in schema assert \\"name VARCHAR(255) NOT NULL\\" in schema assert \\"join_date DATE NOT NULL\\" in schema def test_loans_table(): schema = create_library_management_schema() assert \\"loan_id INT PRIMARY KEY\\" in schema assert \\"member_id INT\\" in schema assert \\"book_id INT\\" in schema assert \\"loan_date DATE NOT NULL\\" in schema assert \\"return_date DATE\\" in schema assert \\"FOREIGN KEY (member_id) REFERENCES Members (member_id)\\" in schema assert \\"FOREIGN KEY (book_id) REFERENCES Books (book_id)\\" in schema assert \\"CHECK (loan_date <= return_date OR return_date IS NULL)\\" in schema","solution":"def create_library_management_schema(): schema = CREATE TABLE Authors ( author_id INT PRIMARY KEY, name VARCHAR(255) NOT NULL, birth_year INT ); CREATE TABLE Books ( book_id INT PRIMARY KEY, title VARCHAR(255) NOT NULL, author_id INT, genre VARCHAR(100), published_year INT, FOREIGN KEY (author_id) REFERENCES Authors (author_id) ); CREATE TABLE Members ( member_id INT PRIMARY KEY, name VARCHAR(255) NOT NULL, join_date DATE NOT NULL ); CREATE TABLE Loans ( loan_id INT PRIMARY KEY, member_id INT, book_id INT, loan_date DATE NOT NULL, return_date DATE, FOREIGN KEY (member_id) REFERENCES Members (member_id), FOREIGN KEY (book_id) REFERENCES Books (book_id), CHECK (loan_date <= return_date OR return_date IS NULL) ); return schema"},{"question":"import random from typing import Tuple def random_walk_2d(steps: int) -> Tuple[int, int]: Simulate a random walk of 'steps' steps in a 2D grid. :param steps: int - The number of steps for the random walk. :return: Tuple[int, int] - The final position (x, y) of the point on the 2D grid. >>> random_walk_2d(10) (3, -1) # Note: Output will vary as the walk is random. >>> random_walk_2d(-5) Traceback (most recent call last): ... ValueError: number of steps must be > 0. >>> random_walk_2d('a') Traceback (most recent call last): ... TypeError: number of steps must be an integer. >>> random_walk_2d(1500) Traceback (most recent call last): ... ValueError: number of steps too large to simulate (>1000). from solution import random_walk_2d import pytest def test_random_walk_result_type(): assert isinstance(random_walk_2d(10), tuple) def test_random_walk_with_negative_steps(): with pytest.raises(ValueError): random_walk_2d(-5) def test_random_walk_with_non_integer_steps(): with pytest.raises(TypeError): random_walk_2d('a') def test_random_walk_with_large_number_of_steps(): with pytest.raises(ValueError): random_walk_2d(1500) def test_random_walk_single_step(): x, y = random_walk_2d(1) assert (x, y) in [(0, 1), (0, -1), (-1, 0), (1, 0)] def test_random_walk_randomness(): results = {random_walk_2d(10) for _ in range(100)} assert len(results) > 1 # Expecting different results due to randomness","solution":"import random from typing import Tuple def random_walk_2d(steps: int) -> Tuple[int, int]: Simulate a random walk of 'steps' steps in a 2D grid. :param steps: int - The number of steps for the random walk. :return: Tuple[int, int] - The final position (x, y) of the point on the 2D grid. if not isinstance(steps, int): raise TypeError(\\"number of steps must be an integer.\\") if steps <= 0: raise ValueError(\\"number of steps must be > 0.\\") if steps > 1000: raise ValueError(\\"number of steps too large to simulate (>1000).\\") x, y = 0, 0 for _ in range(steps): direction = random.choice(['up', 'down', 'left', 'right']) if direction == 'up': y += 1 elif direction == 'down': y -= 1 elif direction == 'left': x -= 1 elif direction == 'right': x += 1 return x, y"},{"question":"from typing import List def primes_sieve(limit: int) -> List[int]: Generates all prime numbers up to and including limit using the Sieve of Eratosthenes. Raises ValueError if limit is less than 2. >>> primes_sieve(10) [2, 3, 5, 7] >>> primes_sieve(29) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> primes_sieve(1) Traceback (most recent call last): ... ValueError: Limit should be greater than or equal to 2 pass def primes_basic(limit: int) -> List[int]: Generates all prime numbers up to and including limit using a basic iterative approach. Raises ValueError if limit is less than 2. >>> primes_basic(10) [2, 3, 5, 7] >>> primes_basic(29) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> primes_basic(1) Traceback (most recent call last): ... ValueError: Limit should be greater than or equal to 2 pass","solution":"from typing import List def primes_sieve(limit: int) -> List[int]: Generates all prime numbers up to and including limit using the Sieve of Eratosthenes. Raises ValueError if limit is less than 2. if limit < 2: raise ValueError(\\"Limit should be greater than or equal to 2\\") sieve = [True] * (limit + 1) sieve[0] = sieve[1] = False for start in range(2, int(limit**0.5) + 1): if sieve[start]: for multiple in range(start*start, limit + 1, start): sieve[multiple] = False return [num for num in range(2, limit + 1) if sieve[num]] def primes_basic(limit: int) -> List[int]: Generates all prime numbers up to and including limit using a basic iterative approach. Raises ValueError if limit is less than 2. if limit < 2: raise ValueError(\\"Limit should be greater than or equal to 2\\") primes = [] for num in range(2, limit + 1): is_prime = True for prime in primes: if prime * prime > num: break if num % prime == 0: is_prime = False break if is_prime: primes.append(num) return primes"},{"question":"def shortest_route(routes, start, end): Calculates the minimum travel distance between two cities based on given routes. Parameters: - routes: List of tuples each containing (starting city, destination city, travel distance) - start: Starting city - end: Destination city Returns: - Minimum travel distance from start city to end city. If no route exists, returns -1. from heapq import heappop, heappush from collections import defaultdict graph = defaultdict(list) for u, v, w in routes: graph[u].append((v, w)) graph[v].append((u, w)) # If routes are bidirectional heap = [(0, start)] distances = {start: 0} while heap: current_distance, current_city = heappop(heap) if current_city == end: return current_distance for neighbor, weight in graph[current_city]: distance = current_distance + weight if neighbor not in distances or distance < distances[neighbor]: distances[neighbor] = distance heappush(heap, (distance, neighbor)) return -1 # Example usage print(shortest_route([(\\"A\\", \\"B\\", 10), (\\"B\\", \\"C\\", 20), (\\"A\\", \\"C\\", 15)], \\"A\\", \\"C\\")) print(shortest_route([(\\"A\\", \\"B\\", 10), (\\"B\\", \\"C\\", 20), (\\"A\\", \\"C\\", 10)], \\"A\\", \\"C\\")) print(shortest_route([(\\"A\\", \\"B\\", 5), (\\"B\\", \\"C\\", 10), (\\"C\\", \\"D\\", 7), (\\"A\\", \\"D\\", 20)], \\"A\\", \\"D\\")) print(shortest_route([(\\"A\\", \\"B\\", 5), (\\"B\\", \\"C\\", 10), (\\"C\\", \\"D\\", 7)], \\"A\\", \\"E\\")) print(shortest_route([(\\"A\\", \\"B\\", 5), (\\"B\\", \\"C\\", 10)], \\"A\\", \\"D\\"))","solution":"from typing import List, Tuple from heapq import heappop, heappush from collections import defaultdict, deque def shortest_route(routes: List[Tuple[str, str, int]], start: str, end: str) -> int: Calculates the minimum travel distance between two cities based on given routes. Parameters: - routes: List of tuples each containing (starting city, destination city, travel distance) - start: Starting city - end: Destination city Returns: - Minimum travel distance from start city to end city. If no route exists, returns -1. graph = defaultdict(list) for u, v, w in routes: graph[u].append((v, w)) graph[v].append((u, w)) # If routes are bidirectional heap = [(0, start)] distances = {start: 0} while heap: current_distance, current_city = heappop(heap) if current_city == end: return current_distance for neighbor, weight in graph[current_city]: distance = current_distance + weight if neighbor not in distances or distance < distances[neighbor]: distances[neighbor] = distance heappush(heap, (distance, neighbor)) return -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_root_to_leaf_sum(root: TreeNode) -> int: Calculate the maximum sum of values from the root node to any leaf node in a binary tree. >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(20) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(8) >>> root.right.right = TreeNode(25) >>> max_root_to_leaf_sum(root) 55 # 10 -> 20 -> 25","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_root_to_leaf_sum(root): if root is None: return 0 if root.left is None and root.right is None: return root.val left_sum = max_root_to_leaf_sum(root.left) right_sum = max_root_to_leaf_sum(root.right) return root.val + max(left_sum, right_sum)"},{"question":"def remove_consecutive_duplicates(sentence: str) -> str: Removes consecutive duplicate words from the sentence. Args: sentence (str): A string containing a sentence composed of words separated by spaces. Returns: str: A string where all consecutive duplicated words are removed. words = sentence.split() if not words: return sentence result = [words[0]] for i in range(1, len(words)): if words[i] != words[i-1]: result.append(words[i]) return ' '.join(result) Example sentence = \\"this is is a test test sentence\\" assert remove_consecutive_duplicates(sentence) == \\"this is a test sentence\\" sentence = \\"hello hello world\\" assert remove_consecutive_duplicates(sentence) == \\"hello world\\" Unit Tests def test_remove_consecutive_duplicates_basic(): assert remove_consecutive_duplicates(\\"this is is a test test sentence\\") == \\"this is a test sentence\\" assert remove_consecutive_duplicates(\\"hello hello world\\") == \\"hello world\\" assert remove_consecutive_duplicates(\\"a a a a\\") == \\"a\\" assert remove_consecutive_duplicates(\\"no duplicates here\\") == \\"no duplicates here\\" def test_remove_consecutive_duplicates_empty(): assert remove_consecutive_duplicates(\\"\\") == \\"\\" def test_remove_consecutive_duplicates_single_word(): assert remove_consecutive_duplicates(\\"word\\") == \\"word\\" def test_remove_consecutive_duplicates_trailing_spaces(): assert remove_consecutive_duplicates(\\"apple apple ball ball cat cat\\") == \\"apple ball cat\\" def test_remove_consecutive_duplicates_case_sensitive(): assert remove_consecutive_duplicates(\\"Hello hello Hello hello\\") == \\"Hello hello Hello hello\\" assert remove_consecutive_duplicates(\\"Case Case case\\") == \\"Case case\\"","solution":"def remove_consecutive_duplicates(sentence: str) -> str: Removes consecutive duplicate words from the sentence. Args: sentence (str): A string containing a sentence composed of words separated by spaces. Returns: str: A string where all consecutive duplicated words are removed. words = sentence.split() if not words: return sentence result = [words[0]] for i in range(1, len(words)): if words[i] != words[i-1]: result.append(words[i]) return ' '.join(result)"},{"question":"def min_insertions_to_balance(s: str) -> int: Determine the minimum number of parenthesis insertions required to make the string valid. >>> min_insertions_to_balance(\\"(()\\") 1 >>> min_insertions_to_balance(\\")(()\\") 2 >>> min_insertions_to_balance(\\"())(()\\") 2","solution":"def min_insertions_to_balance(s: str) -> int: open_needed = 0 # To track the number of \`(\` needed balance_needed = 0 # To track the number of \`)\` needed for char in s: if char == '(': open_needed += 1 else: # char == ')' if open_needed > 0: open_needed -= 1 else: # Need an extra \`(\` for this \`)\` balance_needed += 1 # Any remaining \`(\` needs a closing \`)\` return open_needed + balance_needed"},{"question":"def count_distinct_elements(nums: list) -> int: Returns the count of unique elements within the list. >>> count_distinct_elements([1, 2, 2, 3, 4, 4, 4, 5, 6]) 6 >>> count_distinct_elements([10, 10, 10, -1, -1, 0, 0, 20]) 4 >>> count_distinct_elements([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]) 11","solution":"def count_distinct_elements(nums: list) -> int: Returns the count of unique elements within the list. return len(set(nums))"},{"question":"def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Rotates the given NxN matrix by 90 degrees clockwise in place. Args: matrix (list of list of int): The NxN matrix to be rotated. Returns: list of list of int: The rotated matrix. Example: >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1]]) [[1]] >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) [[-7, -4, -1], [-8, -5, -2], [-9, -6, -3]] # Test Cases def test_rotate_matrix_3x3(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix(matrix) == rotated def test_rotate_matrix_1x1(): matrix = [ [1] ] rotated = [ [1] ] assert rotate_matrix(matrix) == rotated def test_rotate_matrix_2x2(): matrix = [ [1, 2], [3, 4] ] rotated = [ [3, 1], [4, 2] ] assert rotate_matrix(matrix) == rotated def test_rotate_matrix_negative_values(): matrix = [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ] rotated = [ [-7, -4, -1], [-8, -5, -2], [-9, -6, -3] ] assert rotate_matrix(matrix) == rotated def test_rotate_matrix_4x4(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] rotated = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_matrix(matrix) == rotated def test_rotate_matrix_5x5(): matrix = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] rotated = [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ] assert rotate_matrix(matrix) == rotated","solution":"def rotate_matrix(matrix): Rotates the given NxN matrix by 90 degrees clockwise in place. Args: matrix (list of list of int): The NxN matrix to be rotated. Returns: list of list of int: The rotated matrix. n = len(matrix) # Rotate the matrix layer by layer for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): offset = i - first # Save top top = matrix[first][i] # left -> top matrix[first][i] = matrix[last - offset][first] # bottom -> left matrix[last - offset][first] = matrix[last][last - offset] # right -> bottom matrix[last][last - offset] = matrix[i][last] # top -> right matrix[i][last] = top return matrix"},{"question":"def decode_message(digits: str, word_map: dict) -> str: Returns the decoded message by replacing each digit in the sequence with its corresponding word from the dictionary. >>> word_map = {'0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four', '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine'} >>> decode_message(\\"123\\", word_map) 'one two three' >>> decode_message(\\"98765\\", word_map) 'nine eight seven six five' def test_decode_message_single_digit(): word_map = { '0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four', '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine' } assert decode_message(\\"1\\", word_map) == \\"one\\" assert decode_message(\\"5\\", word_map) == \\"five\\" def test_decode_message_multiple_digits(): word_map = { '0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four', '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine' } assert decode_message(\\"123\\", word_map) == \\"one two three\\" assert decode_message(\\"98765\\", word_map) == \\"nine eight seven six five\\" def test_decode_message_all_digits(): word_map = { '0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four', '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine' } assert decode_message(\\"0123456789\\", word_map) == \\"zero one two three four five six seven eight nine\\" def test_decode_message_repeated_digits(): word_map = { '0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four', '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine' } assert decode_message(\\"111222\\", word_map) == \\"one one one two two two\\" assert decode_message(\\"999000\\", word_map) == \\"nine nine nine zero zero zero\\" def test_decode_message_empty_string(): word_map = { '0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four', '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine' } assert decode_message(\\"\\", word_map) == \\"\\"","solution":"def decode_message(digits: str, word_map: dict) -> str: Returns the decoded message by replacing each digit in the sequence with its corresponding word from the dictionary. return ' '.join(word_map[digit] for digit in digits)"},{"question":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Perform a Merge Sort on a given list of integers and returns the sorted list. >>> merge_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] >>> merge_sort([1, 20, 6, 4, 5]) [1, 4, 5, 6, 20] >>> merge_sort([]) [] >>> merge_sort([-1, -3, -2]) [-3, -2, -1] pass def test_merge_sort_with_unsorted_array(): assert merge_sort([38, 27, 43, 3, 9, 82, 10]) == [3, 9, 10, 27, 38, 43, 82] def test_merge_sort_with_single_element_array(): assert merge_sort([1]) == [1] def test_merge_sort_with_empty_array(): assert merge_sort([]) == [] def test_merge_sort_with_sorted_array(): assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_merge_sort_with_negative_values(): assert merge_sort([-1, -3, -2]) == [-3, -2, -1] def test_merge_sort_with_mixed_positive_and_negative_values(): assert merge_sort([1, -1, 0, 3, -2, 2]) == [-2, -1, 0, 1, 2, 3] def test_merge_sort_with_duplicates(): assert merge_sort([4, 2, 2, 1, 3, 4]) == [1, 2, 2, 3, 4, 4] def test_merge_sort_large_array(): import random large_array = random.sample(range(-10**6, 10**6), 10**6) sorted_large_array = sorted(large_array) assert merge_sort(large_array) == sorted_large_array","solution":"def merge_sort(arr): if len(arr) <= 1: return arr def merge(left, right): sorted_array = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 sorted_array.extend(left[i:]) sorted_array.extend(right[j:]) return sorted_array mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right)"},{"question":"def has_min_length(password: str) -> bool: Check if the password has a minimum length of 8 characters. >>> has_min_length(\\"abcdefgh\\") True >>> has_min_length(\\"abc\\") False def has_uppercase(password: str) -> bool: Check if the password contains at least one uppercase letter. >>> has_uppercase(\\"Abcdefgh\\") True >>> has_uppercase(\\"abcdefgh\\") False def has_digit(password: str) -> bool: Check if the password contains at least one digit. >>> has_digit(\\"a1bcdefgh\\") True >>> has_digit(\\"abcdefgh\\") False def has_special_char(password: str) -> bool: Check if the password contains at least one special character. >>> has_special_char(\\"abc!defgh\\") True >>> has_special_char(\\"abcdefgh\\") False def password_strength_checker(password: str) -> bool: Assess the strength of a given password. >>> password_strength_checker('Aa1abcd') Aa1abcd is a strong password. True >>> password_strength_checker('a1abcd') a1abcd is a weak password because it does not contain an uppercase letter. False >>> password_strength_checker('Aabcdef') Aabcdef is a weak password because it does not contain a digit. False >>> password_strength_checker('Aa1bcdef') Aa1bcdef is a weak password because it does not contain a special character. False >>> password_strength_checker('Aa1abc') Aa1abc is a weak password because it does not have a minimum length of 8 characters. False","solution":"def has_min_length(password: str) -> bool: return len(password) >= 8 def has_uppercase(password: str) -> bool: return any(char.isupper() for char in password) def has_digit(password: str) -> bool: return any(char.isdigit() for char in password) def has_special_char(password: str) -> bool: return any(not char.isalnum() for char in password) def password_strength_checker(password: str) -> bool: errors = [] if not has_min_length(password): errors.append(\\"does not have a minimum length of 8 characters\\") if not has_uppercase(password): errors.append(\\"does not contain an uppercase letter\\") if not has_digit(password): errors.append(\\"does not contain a digit\\") if not has_special_char(password): errors.append(\\"does not contain a special character\\") if errors: print(f\\"{password} is a weak password because it {' and '.join(errors)}.\\") return False else: print(f\\"{password} is a strong password.\\") return True"},{"question":"def find_articulation_points(graph: dict) -> list: Find all articulation points in an undirected graph. >>> graph = { ... 0: [1, 2], ... 1: [0, 2], ... 2: [0, 1, 3, 4], ... 3: [2, 4], ... 4: [2, 3, 5], ... 5: [4] ... } >>> sorted(find_articulation_points(graph)) [2, 4] >>> graph = { ... 0: [1], ... 1: [0], ... 2: [3], ... 3: [2] ... } >>> find_articulation_points(graph) [] >>> graph = { ... 0: [1, 2], ... 1: [0, 2], ... 2: [0, 1] ... } >>> find_articulation_points(graph) [] >>> graph = { ... 0: [1], ... 1: [0, 2, 3], ... 2: [1, 3], ... 3: [1, 2, 4], ... 4: [3, 5, 6], ... 5: [4], ... 6: [4] ... } >>> sorted(find_articulation_points(graph)) [1, 3, 4] >>> graph = { ... 0: [1, 2, 3, 4], ... 1: [0, 2], ... 2: [0, 1, 5], ... 3: [0], ... 4: [0], ... 5: [2, 6, 7], ... 6: [5], ... 7: [5] ... } >>> sorted(find_articulation_points(graph)) [0, 2, 5]","solution":"def find_articulation_points(graph): def dfs(u, parent, visited, disc, low, ap, time): children = 0 visited[u] = True disc[u] = low[u] = time time += 1 for v in graph[u]: if not visited[v]: children += 1 dfs(v, u, visited, disc, low, ap, time) low[u] = min(low[u], low[v]) if parent is None and children > 1: ap[u] = True if parent is not None and low[v] >= disc[u]: ap[u] = True elif v != parent: low[u] = min(low[u], disc[v]) visited = {u: False for u in graph} disc = {u: float(\\"Inf\\") for u in graph} low = {u: float(\\"Inf\\") for u in graph} ap = {u: False for u in graph} # articulation points time = 0 for u in graph: if not visited[u]: dfs(u, None, visited, disc, low, ap, time) return [u for u in ap if ap[u]]"},{"question":"class CustomString: def __init__(self, initial_string: str): Initialize the CustomString with the given initial string. :param initial_string: str - The initial string to manipulate. def insert(self, index: int, substring: str) -> None: Insert a substring into the current string at the specified index. :param index: int - The position at which to insert the substring. :param substring: str - The substring to be inserted. def remove(self, substring: str) -> None: Remove the first occurrence of the specified substring. :param substring: str - The substring to be removed. def replace(self, old_substring: str, new_substring: str) -> None: Replace the first occurrence of an old substring with a new substring. :param old_substring: str - The substring to be replaced. :param new_substring: str - The substring to replace with. def get_string(self) -> str: Return the current state of the string. :return: str - The current string. # Example usage: cs = CustomString(\\"hello world\\") cs.insert(5, \\" beautiful\\") print(cs.get_string()) # \\"hello beautiful world\\" cs.remove(\\"beautiful \\") print(cs.get_string()) # \\"hello world\\" cs.replace(\\"world\\", \\"everyone\\") print(cs.get_string()) # \\"hello everyone\\"","solution":"class CustomString: def __init__(self, initial_string: str): Initialize the CustomString with the given initial string. :param initial_string: str - The initial string to manipulate. self.string = initial_string def insert(self, index: int, substring: str) -> None: Insert a substring into the current string at the specified index. :param index: int - The position at which to insert the substring. :param substring: str - The substring to be inserted. if 0 <= index <= len(self.string): self.string = self.string[:index] + substring + self.string[index:] def remove(self, substring: str) -> None: Remove the first occurrence of the specified substring. :param substring: str - The substring to be removed. index = self.string.find(substring) if index != -1: self.string = self.string[:index] + self.string[index+len(substring):] def replace(self, old_substring: str, new_substring: str) -> None: Replace the first occurrence of an old substring with a new substring. :param old_substring: str - The substring to be replaced. :param new_substring: str - The substring to replace with. self.string = self.string.replace(old_substring, new_substring, 1) def get_string(self) -> str: Return the current state of the string. :return: str - The current string. return self.string"},{"question":"def kmp_search(text: str, pattern: str) -> bool: Check if the pattern exists in the text using the KMP algorithm. >>> kmp_search(\\"abxabcabcaby\\", \\"abcaby\\") True >>> kmp_search(\\"hello\\", \\"ll\\") True >>> kmp_search(\\"aaaaa\\", \\"bba\\") False >>> kmp_search(\\"mississippi\\", \\"issi\\") True >>> kmp_search(\\"abc\\", \\"abcd\\") False >>> kmp_search(\\"abc\\", \\"\\") True >>> kmp_search(\\"\\", \\"abc\\") False >>> kmp_search(\\"abababcdababc\\", \\"ababd\\") False >>> kmp_search(\\"abracadabra\\", \\"acad\\") True >>> kmp_search(\\"abracadabra\\", \\"abracadabra\\") True >>> kmp_search(\\"\\", \\"\\") True >>> kmp_search(\\"a\\", \\"a\\") True >>> kmp_search(\\"a\\", \\"b\\") False >>> kmp_search(\\"abc\\", \\"abcabcabc\\") False >>> kmp_search(\\"repeatedrepeatedrepeated\\", \\"reprepeated\\") False >>> kmp_search(\\"aaabbaaaabaababbaabbaa\\", \\"aaba\\") True","solution":"def kmp_search(text: str, pattern: str) -> bool: if not pattern: return True if not text: return False # Preprocess the pattern to generate the longest prefix suffix (LPS) array lps = [0] * len(pattern) j = 0 # length of previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[j]: j += 1 lps[i] = j i += 1 else: if j != 0: j = lps[j - 1] else: lps[i] = 0 i += 1 # Start searching using the KMP algorithm i = j = 0 # index for text[], index for pattern[] while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): return True # Found pattern at index (i-j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return False # Pattern not found"},{"question":"from typing import List, Tuple def detect_repeated_changes(arr: List[int], transformations: List[Tuple[int, int, int]], threshold: int) -> int: Detect how many times a specific change has occurred consecutively across multiple transformations. Parameters: arr (List[int]): An initial list of integers. transformations (List[Tuple[int, int, int]]): A list of transformations where each transformation is a tuple (index, operation, value). threshold (int): An integer representing the number of consecutive transformations needed to produce the same result for it to be counted as a repeated change. Returns: int: An integer representing the number of times a specific change has occurred exactly 'threshold' times consecutively. Examples: >>> arr = [1, 2, 3] >>> transformations = [ >>> (0, 1, 4), >>> (0, 2, 2), >>> (2, 1, -1), >>> (0, 1, 4), >>> (0, 1, 4), >>> (1, 2, 3) >>> ] >>> threshold = 2 >>> detect_repeated_changes(arr, transformations, threshold) 1 >>> arr = [1, 2, 3] >>> transformations = [ >>> (0, 1, 4), >>> (0, 2, 2), >>> (2, 1, -1), >>> (0, 2, 4) >>> ] >>> threshold = 2 >>> detect_repeated_changes(arr, transformations, threshold) 0 pass","solution":"from typing import List, Tuple def detect_repeated_changes(arr: List[int], transformations: List[Tuple[int, int, int]], threshold: int) -> int: change_count = 0 # Track the current number of consecutive changes current_streak = 0 last_change = None for index, operation, value in transformations: # Apply the transformation if operation == 1: # Addition new_value = arr[index] + value elif operation == 2: # Multiplication new_value = arr[index] * value change = (index, operation, value) # Check if this change is the same as the last one if change == last_change: current_streak += 1 else: current_streak = 1 last_change = change # Increment the change count if current streak meets the threshold if current_streak == threshold: change_count += 1 # Update the array arr[index] = new_value return change_count"},{"question":"from typing import List def sum_of_proper_divisors(num: int) -> int: Returns the sum of proper divisors of num (excluding itself). >>> sum_of_proper_divisors(6) 6 >>> sum_of_proper_divisors(28) 28 >>> sum_of_proper_divisors(12) 16 >>> sum_of_proper_divisors(1) 0 >>> sum_of_proper_divisors(2) 1 pass def find_perfect_numbers(n: int) -> List[int]: Returns a list of all perfect numbers less than n. >>> find_perfect_numbers(10) [6] >>> find_perfect_numbers(1000) [6, 28, 496] >>> find_perfect_numbers(10000) [6, 28, 496, 8128] >>> find_perfect_numbers(20000) [6, 28, 496, 8128] pass","solution":"from typing import List def sum_of_proper_divisors(num: int) -> int: Returns the sum of proper divisors of num (excluding itself). if num < 2: return 0 divisors_sum = 1 # 1 is a proper divisor for any number > 1 sqrt_num = int(num ** 0.5) for i in range(2, sqrt_num + 1): if num % i == 0: divisors_sum += i if i != num // i: # Ensure we do not add the square root twice divisors_sum += num // i return divisors_sum def find_perfect_numbers(n: int) -> List[int]: Returns a list of all perfect numbers less than n. perfect_numbers = [] for num in range(2, n): if sum_of_proper_divisors(num) == num: perfect_numbers.append(num) return perfect_numbers"},{"question":"def is_rotation(A: str, B: str) -> bool: Determine if one string is a rotation of another string. :param A: A string which we suspect might be a rotation of string B. :param B: A string to be checked against string A. :returns: True if A is a rotation of B, False otherwise. >>> is_rotation(\\"waterbottle\\", \\"erbottlewat\\") # True >>> is_rotation(\\"hello\\", \\"elloh\\") # True >>> is_rotation(\\"hello\\", \\"llohe\\") # True >>> is_rotation(\\"hello\\", \\"helloo\\") # False >>> is_rotation(\\"hello\\", \\"world\\") # False >>> is_rotation(\\"abc\\", \\"cab\\") # True","solution":"def is_rotation(A: str, B: str) -> bool: Returns True if A is a rotation of B. if len(A) != len(B): return False return B in A + A"},{"question":"class Node: A node in the binary search tree. Attributes: key: An integer value stored in the node. left: Reference to the left child node. right: Reference to the right child node. def __init__(self, key: int): self.key = key self.left = None self.right = None class BST: A binary search tree (BST) implementation. Methods: __init__: Initializes an empty BST. insert: Inserts a value into the BST. delete: Deletes a value from the BST. find_LCA: Finds the lowest common ancestor of two nodes. in_order_traversal: Returns a list of all node values in ascending order. def __init__(self): Initializes an empty Binary Search Tree. self.root = None def insert(self, key: int): Inserts an integer value into the BST. Args: key: The integer value to insert. pass def delete(self, key: int): Deletes an integer value from the BST. Args: key: The integer value to delete. pass def find_LCA(self, n1: int, n2: int) -> int: Finds the lowest common ancestor of two given node values. Args: n1: The first node value. n2: The second node value. Returns: The value of the lowest common ancestor. pass def in_order_traversal(self) -> list[int]: Performs in-order traversal of the BST. Returns: A list of all node values in ascending order. pass","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.key: if node.left: self._insert(node.left, key) else: node.left = Node(key) elif key > node.key: if node.right: self._insert(node.right, key) else: node.right = Node(key) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp_val = self._minValueNode(node.right) node.key = temp_val.key node.right = self._delete(node.right, temp_val.key) return node def _minValueNode(self, node): current = node while current.left: current = current.left return current def find_LCA(self, n1, n2): return self._find_LCA(self.root, n1, n2).key def _find_LCA(self, node, n1, n2): if not node: return None if node.key > n1 and node.key > n2: return self._find_LCA(node.left, n1, n2) if node.key < n1 and node.key < n2: return self._find_LCA(node.right, n1, n2) return node def in_order_traversal(self): res = [] self._in_order_traversal(self.root, res) return res def _in_order_traversal(self, node, res): if node: self._in_order_traversal(node.left, res) res.append(node.key) self._in_order_traversal(node.right, res)"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_symmetric(root: TreeNode) -> bool: Check whether a given binary tree is symmetric around its center. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(4) >>> root.right.right = TreeNode(3) >>> is_symmetric(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(3) >>> is_symmetric(root) False >>> is_symmetric(None) True >>> root = TreeNode(1) >>> is_symmetric(root) True","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_symmetric(root: TreeNode) -> bool: def is_mirror(t1: TreeNode, t2: TreeNode) -> bool: if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val) and is_mirror(t1.right, t2.left) and is_mirror(t1.left, t2.right) if not root: return True return is_mirror(root.left, root.right)"},{"question":"class FenwickTree: def __init__(self, array: List[int]): Initializes the Fenwick Tree with the given list of integers. :param array: List of integers to build the Fenwick Tree from. def update(self, index: int, value: int): Updates the value at the specified index. :param index: Index of the element to be updated (0-based). :param value: New value to set at the specified index. def prefix_sum(self, index: int) -> int: Computes the sum of elements from the start up to the given index. :param index: Index up to which the prefix sum is calculated (inclusive, 0-based). :return: Sum of elements from the start up to the given index. from solution import FenwickTree def test_fenwick_tree_initial_prefix_sum(): array = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3] fenwick_tree = FenwickTree(array) assert fenwick_tree.prefix_sum(0) == 3 assert fenwick_tree.prefix_sum(1) == 5 # 3 + 2 assert fenwick_tree.prefix_sum(2) == 4 # 3 + 2 - 1 assert fenwick_tree.prefix_sum(4) == 15 # 3 + 2 - 1 + 6 + 5 assert fenwick_tree.prefix_sum(6) == 16 # 3 + 2 - 1 + 6 + 5 + 4 - 3 assert fenwick_tree.prefix_sum(10) == 31 # sum of entire array def test_fenwick_tree_updates(): array = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3] fenwick_tree = FenwickTree(array) fenwick_tree.update(3, 10) # updating index 3 to 10 from original value 6 assert fenwick_tree.prefix_sum(4) == 19 # 3 + 2 - 1 + 10 + 5 assert fenwick_tree.prefix_sum(6) == 20 # 3 + 2 - 1 + 10 + 5 + 4 - 3 def test_fenwick_tree_boundaries(): array = [3] fenwick_tree = FenwickTree(array) assert fenwick_tree.prefix_sum(0) == 3 fenwick_tree.update(0, 5) assert fenwick_tree.prefix_sum(0) == 5 def test_fenwick_tree_large_array(): array = list(range(1, 1001)) # [1, 2, 3, ..., 1000] fenwick_tree = FenwickTree(array) assert fenwick_tree.prefix_sum(999) == sum(range(1, 1001)) # sum of first 1000 numbers fenwick_tree.update(999, 2000) assert fenwick_tree.prefix_sum(999) == sum(range(1, 1000)) + 2000 # sum of first 999 numbers plus 2000","solution":"class FenwickTree: def __init__(self, array): self.n = len(array) self.tree = [0] * (self.n + 1) self.array = array[:] for i, val in enumerate(array): self._add(i + 1, val) def _add(self, index, value): while index <= self.n: self.tree[index] += value index += index & -index def update(self, index, value): old_value = self.array[index] self.array[index] = value self._add(index + 1, value - old_value) def prefix_sum(self, index): index += 1 # Fenwick Tree is 1-based result = 0 while index > 0: result += self.tree[index] index -= index & -index return result"},{"question":"def rle_compress(text: str) -> str: Compresses the input text using Run-Length Encoding (RLE). Args: text (str): The input string to be compressed. Returns: str: The compressed string using RLE. >>> rle_compress(\\"aaabbcccc\\") \\"a3b2c4\\" >>> rle_compress(\\"abcd\\") \\"a1b1c1d1\\" >>> rle_compress(\\"wwwwww\\") \\"w6\\" >>> rle_compress(\\"a\\") \\"a1\\" # Example test cases print(rle_compress(\\"aaabbcccc\\")) # Expected output: \\"a3b2c4\\" print(rle_compress(\\"abcd\\")) # Expected output: \\"a1b1c1d1\\" print(rle_compress(\\"wwwwww\\")) # Expected output: \\"w6\\" print(rle_compress(\\"a\\")) # Expected output: \\"a1\\"","solution":"def rle_compress(text: str) -> str: Compresses the input text using Run-Length Encoding (RLE). Args: text (str): The input string to be compressed. Returns: str: The compressed string using RLE. if not text: return \\"\\" compressed = [] count = 1 for i in range(1, len(text)): if text[i] == text[i-1]: count += 1 else: compressed.append(f\\"{text[i-1]}{count}\\") count = 1 # Append the last character and its count compressed.append(f\\"{text[-1]}{count}\\") return ''.join(compressed)"},{"question":"def is_wildcard_balanced(s: str) -> bool: Checks if the given string with '(', ')', and '*' can be balanced. Args: s (str): The input string containing '(', ')', and '*'. Returns: bool: True if the string can be balanced, False otherwise. >>> is_wildcard_balanced(\\"(*))\\") True >>> is_wildcard_balanced(\\"(*)\\") True >>> is_wildcard_balanced(\\"(*)))\\") False >>> is_wildcard_balanced(\\"(()*\\") True >>> is_wildcard_balanced(\\"((*)\\") True >>> is_wildcard_balanced(\\"(**)\\") True >>> is_wildcard_balanced(\\"*()\\") True >>> is_wildcard_balanced(\\"**\\") True >>> is_wildcard_balanced(\\")*(\\") False >>> is_wildcard_balanced(\\"(******))\\") True >>> is_wildcard_balanced(\\"))\\") False >>> is_wildcard_balanced(\\"****\\") True","solution":"def is_wildcard_balanced(s: str) -> bool: Checks if the given string with '(', ')', and '*' can be balanced. Args: s (str): The input string containing '(', ')', and '*'. Returns: bool: True if the string can be balanced, False otherwise. low = high = 0 for char in s: if char == '(': low += 1 high += 1 elif char == ')': if low > 0: low -= 1 high -= 1 elif char == '*': if low > 0: low -= 1 high += 1 if high < 0: return False return low == 0"},{"question":"from typing import List def unique_subsets(nums: List[int]) -> List[List[int]]: Generates all possible unique subsets of a given set of integers without duplicates. The generated subsets are output in lexicographical order. >>> unique_subsets([1, 2, 2]) [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]] >>> unique_subsets([0]) [[], [0]] >>> unique_subsets([1, 2, 3]) [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] >>> unique_subsets([-1, 0, 1]) [[], [-1], [-1, 0], [-1, 0, 1], [-1, 1], [0], [0, 1], [1]] >>> unique_subsets([4, 4, 4, 1, 4]) [[], [1], [1, 4], [1, 4, 4], [1, 4, 4, 4], [1, 4, 4, 4, 4], [4], [4, 4], [4, 4, 4], [4, 4, 4, 4]] >>> unique_subsets([5]) [[], [5]] >>> unique_subsets([]) [[]]","solution":"from typing import List def unique_subsets(nums: List[int]) -> List[List[int]]: Generates all possible unique subsets of a given set of integers, output in lexicographical order. nums.sort() result = [] subset = [] def backtrack(start): result.append(subset[:]) for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: # skip duplicates continue subset.append(nums[i]) backtrack(i + 1) subset.pop() backtrack(0) return result"},{"question":"class NetworkGraph: def __init__(self, vertices): self.vertices = vertices self.edges = [] def add_edge(self, u: int, v: int, w: int) -> None: Add an edge to the graph. Args: u (int): Starting node of the edge. v (int): Ending node of the edge. w (int): Weight of the edge. pass def find_mst(self) -> list[tuple[int, int, int]]: Find the Minimum Spanning Tree (MST) of the graph. Returns: list[tuple[int, int, int]]: List of edges representing the MST, where each edge is represented as a tuple (u, v, w). pass from solution import NetworkGraph def test_add_edge(): graph = NetworkGraph(4) graph.add_edge(0, 1, 10) graph.add_edge(0, 2, 6) graph.add_edge(0, 3, 5) graph.add_edge(1, 3, 15) graph.add_edge(2, 3, 4) assert len(graph.edges) == 5 def test_find_mst(): graph = NetworkGraph(4) graph.add_edge(0, 1, 10) graph.add_edge(0, 2, 6) graph.add_edge(0, 3, 5) graph.add_edge(1, 3, 15) graph.add_edge(2, 3, 4) mst = graph.find_mst() expected_mst = [(2, 3, 4), (0, 3, 5), (0, 1, 10)] assert len(mst) == 3 assert sorted(mst) == sorted(expected_mst) def test_mst_large_graph(): graph = NetworkGraph(5) edges = [ (0, 1, 2), (0, 3, 6), (1, 2, 3), (1, 3, 8), (1, 4, 5), (2, 4, 7), (3, 4, 9) ] for u, v, w in edges: graph.add_edge(u, v, w) mst = graph.find_mst() expected_mst = [(0, 1, 2), (1, 2, 3), (1, 4, 5), (0, 3, 6)] assert len(mst) == 4 assert sorted(mst) == sorted(expected_mst)","solution":"class NetworkGraph: def __init__(self, vertices): self.vertices = vertices self.edges = [] def add_edge(self, u: int, v: int, w: int) -> None: self.edges.append((u, v, w)) def find_mst(self) -> list[tuple[int, int, int]]: # Implementing Kruskal's Algorithm self.edges.sort(key=lambda edge: edge[2]) parent = list(range(self.vertices)) def find(x): if parent[x] == x: return x else: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX mst = [] for u, v, w in self.edges: if find(u) != find(v): union(u, v) mst.append((u, v, w)) return mst"},{"question":"Write a Python function \`knapsack(max_weight: int, weights: List[int], values: List[int]) -> int\` that takes three parameters: - \`max_weight\`: An integer representing the maximum weight the knapsack can carry. - \`weights\`: A list of integers where \`weights[i]\` is the weight of the \`i-th\` item. - \`values\`: A list of integers where \`values[i]\` is the value of the \`i-th\` item. You need to complete the following implementation using dynamic programming to solve the Knapsack Problem. from typing import List def knapsack(max_weight: int, weights: List[int], values: List[int]) -> int: Returns the maximum value that can be accommodated in the knapsack without exceeding the weight capacity. n = len(weights) # dp[i][w] will be the maximum value that can be attained with weight <= w and using first i items dp = [[0 for _ in range(max_weight + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(max_weight + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][max_weight] def test_knapsack_example1(): weights = [10, 20, 30] values = [60, 100, 120] max_weight = 50 assert knapsack(max_weight, weights, values) == 220 def test_knapsack_example2(): weights = [1, 2, 3, 8] values = [20, 30, 50, 60] max_weight = 5 assert knapsack(max_weight, weights, values) == 80 def test_knapsack_small_weight_capacity(): weights = [10, 20, 30] values = [60, 100, 120] max_weight = 10 assert knapsack(max_weight, weights, values) == 60 def test_knapsack_large_weights(): weights = [2, 5, 10, 20] values = [20, 50, 100, 200] max_weight = 50 assert knapsack(max_weight, weights, values) == 370 def test_knapsack_multiple_items_same_weight_and_value(): weights = [20, 20, 20] values = [60, 60, 60] max_weight = 40 assert knapsack(max_weight, weights, values) == 120","solution":"from typing import List def knapsack(max_weight: int, weights: List[int], values: List[int]) -> int: Returns the maximum value that can be accommodated in the knapsack without exceeding the weight capacity. n = len(weights) # dp[i][w] will be the maximum value that can be attained with weight <= w and using first i items dp = [[0 for _ in range(max_weight + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(max_weight + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][max_weight]"},{"question":"def validate_subnet_mask(mask: str) -> (bool, str or int): Validates the given subnet mask and returns a tuple indicating its validity and the number of possible hosts it supports. :param mask: A string representing the subnet mask in dot-decimal notation. :return: A tuple (isValid, result) where isValid is a boolean indicating the validity of the subnet mask, and result is either an integer representing the number of possible hosts or an error message. >>> validate_subnet_mask('255.255.255.0') (True, 254) >>> validate_subnet_mask('255.255.0.255') (False, 'Subnet mask is invalid') >>> validate_subnet_mask('255.255.255.128') (True, 126) >>> validate_subnet_mask('255.255.255.255.0') (False, 'Incorrect format for subnet mask') from solution import validate_subnet_mask def test_valid_subnet_mask_255_255_255_0(): assert validate_subnet_mask('255.255.255.0') == (True, 254) def test_invalid_subnet_mask_contiguous_ones(): assert validate_subnet_mask('255.255.0.255') == (False, 'Subnet mask is invalid') def test_invalid_subnet_mask_non_numeric(): assert validate_subnet_mask('255.255.255.a') == (False, 'Invalid numeric value in subnet mask') def test_invalid_subnet_mask_wrong_number_of_octets(): assert validate_subnet_mask('255.255.255.255.0') == (False, 'Incorrect format for subnet mask') def test_valid_subnet_mask_255_255_255_128(): assert validate_subnet_mask('255.255.255.128') == (True, 126) def test_invalid_subnet_mask_invalid_range(): assert validate_subnet_mask('255.255.256.0') == (False, 'Each octet must be in the range 0-255') def test_valid_subnet_mask_255_255_255_192(): assert validate_subnet_mask('255.255.255.192') == (True, 62) def test_valid_subnet_mask_255_255_255_255(): assert validate_subnet_mask('255.255.255.255') == (True, 0)","solution":"def validate_subnet_mask(mask: str) -> (bool, str or int): Validates the given subnet mask and returns a tuple indicating its validity and the number of possible hosts it supports. :param mask: A string representing the subnet mask in dot-decimal notation. :return: A tuple (isValid, result) where isValid is a boolean indicating the validity of the subnet mask, and result is either an integer representing the number of possible hosts or an error message. # Split the mask by dots octets = mask.split('.') if len(octets) != 4: return (False, 'Incorrect format for subnet mask') # Convert each octet to binary string and check validity try: binary_mask = \\"\\".join([bin(int(octet))[2:].zfill(8) for octet in octets]) except ValueError: return (False, 'Invalid numeric value in subnet mask') if any(int(octet) < 0 or int(octet) > 255 for octet in octets): return (False, 'Each octet must be in the range 0-255') # Check for the contiguous block of 1s followed by a block of 0s if '01' in binary_mask: return (False, 'Subnet mask is invalid') # Calculate the number of hosts zero_bits = binary_mask.count('0') if zero_bits == 0: return (True, 0) num_hosts = (2 ** zero_bits) - 2 return (True, num_hosts)"},{"question":"def are_permutations(arr1: list, arr2: list) -> bool: Determines if two arrays are permutations of each other. Args: arr1 (list): First array of integers. arr2 (list): Second array of integers. Returns: bool: True if arr1 and arr2 are permutations of each other, False otherwise. >>> are_permutations([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) True >>> are_permutations([1, 2, 2, 3, 4], [1, 2, 3, 4, 4]) False >>> are_permutations([], []) True >>> are_permutations([-1, 0, 1], [1, 0, -1]) True >>> are_permutations([1, 2], [1, 2, 3]) False pass from collections import Counter def test_identical_arrays(): assert are_permutations([1, 2, 3], [1, 2, 3]) == True def test_permuted_arrays(): assert are_permutations([1, 2, 3], [3, 2, 1]) == True def test_different_length_arrays(): assert are_permutations([1, 2], [1, 2, 3]) == False def test_same_elements_different_frequencies(): assert are_permutations([1, 2, 2, 3], [1, 2, 3, 3]) == False def test_empty_arrays(): assert are_permutations([], []) == True def test_one_empty_array(): assert are_permutations([], [1, 2, 3]) == False def test_negative_numbers(): assert are_permutations([-1, -2, -3], [-3, -2, -1]) == True assert are_permutations([-1, -2, -3], [-3, -2, -2]) == False def test_mixed_sign_numbers(): assert are_permutations([-1, 0, 1], [1, 0, -1]) == True assert are_permutations([-1, 1, 1], [1, -1, -1]) == False","solution":"from collections import Counter def are_permutations(arr1: list, arr2: list) -> bool: Determines if two arrays are permutations of each other. Args: arr1 (list): First array of integers. arr2 (list): Second array of integers. Returns: bool: True if arr1 and arr2 are permutations of each other, False otherwise. return Counter(arr1) == Counter(arr2)"},{"question":"from typing import List, Optional import collections class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Perform a level order traversal on a binary tree. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20, TreeNode(15), TreeNode(7)) >>> level_order_traversal(root) [[3], [9, 20], [15, 7]] >>> level_order_traversal(None) [] >>> root = TreeNode(1) >>> level_order_traversal(root) [[1]] pass def test_level_order_traversal_null_root(): assert level_order_traversal(None) == [] def test_level_order_traversal_single_node(): root = TreeNode(1) assert level_order_traversal(root) == [[1]] def test_level_order_traversal_complete_binary_tree(): root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20, TreeNode(15), TreeNode(7)) expected_output = [[3], [9, 20], [15, 7]] assert level_order_traversal(root) == expected_output def test_level_order_traversal_all_left_nodes(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) root.left.left.left = TreeNode(4) expected_output = [[1], [2], [3], [4]] assert level_order_traversal(root) == expected_output def test_level_order_traversal_all_right_nodes(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) root.right.right.right = TreeNode(4) expected_output = [[1], [2], [3], [4]] assert level_order_traversal(root) == expected_output def test_level_order_traversal_mixed_tree(): root = TreeNode(1) root.left = TreeNode(2, TreeNode(4), TreeNode(5)) root.right = TreeNode(3, None, TreeNode(7)) expected_output = [[1], [2, 3], [4, 5, 7]] assert level_order_traversal(root) == expected_output","solution":"from typing import List, Optional import collections class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = collections.deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"# Global dictionary to store user balances user_balances = {} def create_account(username: str) -> bool: Creates a new user account. Returns True if successful, False if the user already exists. >>> create_account('Alice') True >>> create_account('Bob') True >>> create_account('Alice') False pass def deposit(username: str, amount: float) -> float: Adds money to a user’s account. Returns the new balance if successful. Raises ValueError if the user does not exist. >>> create_account('Alice') True >>> deposit('Alice', 50.0) 50.0 >>> deposit('Bob', 100.0) Traceback (most recent call last): ... ValueError: User does not exist. pass def withdraw(username: str, amount: float) -> float: Removes money from a user’s account. Returns the new balance if successful. Raises ValueError if the user does not exist. Returns None if the balance is insufficient. >>> create_account('Alice') True >>> deposit('Alice', 50.0) 50.0 >>> withdraw('Alice', 30.0) 20.0 >>> withdraw('Alice', 30.0) None >>> withdraw('Bob', 50.0) Traceback (most recent call last): ... ValueError: User does not exist. pass def check_balance(username: str) -> float: Returns the current balance of a user's account. Raises ValueError if the user does not exist. >>> create_account('Alice') True >>> check_balance('Alice') 0.0 >>> check_balance('Bob') Traceback (most recent call last): ... ValueError: User does not exist. pass","solution":"# Global dictionary to store user balances user_balances = {} def create_account(username: str) -> bool: Creates a new user account. Returns True if successful, False if the user already exists. if username in user_balances: return False user_balances[username] = 0.0 return True def deposit(username: str, amount: float) -> float: Adds money to a user’s account. Returns the new balance if successful. Raises ValueError if the user does not exist. if username not in user_balances: raise ValueError(\\"User does not exist.\\") user_balances[username] += amount return user_balances[username] def withdraw(username: str, amount: float) -> float: Removes money from a user’s account. Returns the new balance if successful. Raises ValueError if the user does not exist. Returns None if the balance is insufficient. if username not in user_balances: raise ValueError(\\"User does not exist.\\") if user_balances[username] < amount: return None user_balances[username] -= amount return user_balances[username] def check_balance(username: str) -> float: Returns the current balance of a user's account. Raises ValueError if the user does not exist. if username not in user_balances: raise ValueError(\\"User does not exist.\\") return user_balances[username]"},{"question":"from heapq import heappush, heappop class TaskManager: def __init__(self): self.tasks = {} self.task_queue = [] self.counter = 0 def add_task(self, description: str, priority: int) -> None: Add a task with a given description and priority pass def remove_task(self, description: str) -> bool: Remove a task by its description, returning True if successful and False otherwise pass def get_next_task(self) -> str: Get and remove the task with the highest priority, returning the description pass # Unit Tests import pytest def test_add_and_get_next_task(): tm = TaskManager() tm.add_task(\\"Task A\\", 2) tm.add_task(\\"Task B\\", 1) tm.add_task(\\"Task C\\", 3) assert tm.get_next_task() == \\"Task B\\" assert tm.get_next_task() == \\"Task A\\" assert tm.get_next_task() == \\"Task C\\" def test_remove_existing_task(): tm = TaskManager() tm.add_task(\\"Task A\\", 2) assert tm.remove_task(\\"Task A\\") == True assert tm.get_next_task() == \\"\\" def test_remove_non_existing_task(): tm = TaskManager() assert tm.remove_task(\\"Task A\\") == False def test_add_duplicate_task(): tm = TaskManager() tm.add_task(\\"Task A\\", 2) with pytest.raises(ValueError): tm.add_task(\\"Task A\\", 3) def test_get_task_from_empty_manager(): tm = TaskManager() assert tm.get_next_task() == \\"\\" def test_handle_invalidated_task_in_queue(): tm = TaskManager() tm.add_task(\\"Task A\\", 2) tm.add_task(\\"Task B\\", 1) tm.remove_task(\\"Task A\\") assert tm.get_next_task() == \\"Task B\\" def test_multiple_same_priority_tasks(): tm = TaskManager() tm.add_task(\\"Task A\\", 1) tm.add_task(\\"Task B\\", 1) assert tm.get_next_task() == \\"Task A\\" assert tm.get_next_task() == \\"Task B\\"","solution":"from heapq import heappush, heappop class TaskManager: def __init__(self): self.tasks = {} self.task_queue = [] self.counter = 0 def add_task(self, description: str, priority: int) -> None: if description in self.tasks: raise ValueError(\\"Task already exists\\") task = (priority, self.counter, description) self.counter += 1 self.tasks[description] = task heappush(self.task_queue, task) def remove_task(self, description: str) -> bool: if description not in self.tasks: return False task = self.tasks.pop(description) # Mark task as invalid by using a sentinel value removed_task = (float('inf'), float('inf'), '') heappush(self.task_queue, removed_task) return True def get_next_task(self) -> str: while self.task_queue: priority, _, description = heappop(self.task_queue) if description != '' and description in self.tasks: self.tasks.pop(description, None) return description return ''"},{"question":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum using the divide and conquer approach to achieve O(n log n) time complexity. >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([5,4,-1,7,8]) 23 >>> max_subarray_sum([-1,-2,-3,-4,-5]) -1 >>> max_subarray_sum([4,-1,2,1]) 6 >>> max_subarray_sum([1,2,3,4,5]) 15 >>> max_subarray_sum([-3,-2,-1]) -1 >>> max_subarray_sum([3,-1,2,-1,2,-1,2,1]) 7","solution":"from typing import List def max_crossing_sum(nums: List[int], left: int, mid: int, right: int) -> int: left_sum = float('-inf') total = 0 for i in range(mid, left - 1, -1): total += nums[i] if total > left_sum: left_sum = total right_sum = float('-inf') total = 0 for i in range(mid + 1, right + 1): total += nums[i] if total > right_sum: right_sum = total return left_sum + right_sum def max_subarray_sum_util(nums: List[int], left: int, right: int) -> int: if left == right: return nums[left] mid = (left + right) // 2 left_sum = max_subarray_sum_util(nums, left, mid) right_sum = max_subarray_sum_util(nums, mid + 1, right) crossing_sum = max_crossing_sum(nums, left, mid, right) return max(left_sum, right_sum, crossing_sum) def max_subarray_sum(nums: List[int]) -> int: return max_subarray_sum_util(nums, 0, len(nums) - 1)"},{"question":"def unique_permutations(nums: List[int]) -> List[List[int]]: Given a list of integers \`nums\` which might contain duplicates, return a list of all unique permutations. Parameters: nums (List[int]): The list of integers to permute. Returns: List[List[int]]: A list of unique permutations, where each permutation is itself a list of integers. pass # Unit Tests def test_no_duplicates(): assert sorted(unique_permutations([1, 2, 3])) == sorted([[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]) def test_with_duplicates(): assert sorted(unique_permutations([1, 1, 2])) == sorted([[1, 1, 2], [1, 2, 1], [2, 1, 1]]) def test_all_duplicates(): assert sorted(unique_permutations([3, 3, 3])) == sorted([[3, 3, 3]]) def test_empty_list(): assert unique_permutations([]) == [[]] def test_single_element(): assert unique_permutations([1]) == [[1]] def test_same_elements(): assert sorted(unique_permutations([2, 2, 2, 2])) == sorted([[2, 2, 2, 2]]) def test_more_complex_case(): assert sorted(unique_permutations([2, 2, 1, 1])) == sorted([[2, 2, 1, 1], [2, 1, 2, 1], [2, 1, 1, 2], [1, 2, 2, 1], [1, 2, 1, 2], [1, 1, 2, 2]])","solution":"from typing import List from itertools import permutations def unique_permutations(nums: List[int]) -> List[List[int]]: Given a list of integers \`nums\` which might contain duplicates, return a list of all unique permutations. Parameters: nums (List[int]): The list of integers to permute. Returns: List[List[int]]: A list of unique permutations, where each permutation is itself a list of integers. return list(map(list, set(permutations(nums))))"},{"question":"def count_characters(input_string: str) -> Dict[str, int]: Count the occurrences of each character in a given string. Parameters: input_string (str): The input string consisting of ASCII characters. Returns: Dict[str, int]: A dictionary with characters as keys and their counts as values. >>> count_characters(\\"Hello, World!\\") {'H': 1, 'e': 1, 'l': 3, 'o': 2, ',': 1, ' ': 1, 'W': 1, 'r': 1, 'd': 1, '!': 1} >>> count_characters(\\"aaaaBBBcc\\") {'a': 4, 'B': 3, 'c': 2} >>> count_characters(\\"\\") {} pass def test_count_characters_basic(): assert count_characters(\\"Hello, World!\\") == { 'H': 1, 'e': 1, 'l': 3, 'o': 2, ',': 1, ' ': 1, 'W': 1, 'r': 1, 'd': 1, '!': 1 } def test_count_characters_mixed_case(): assert count_characters(\\"aaaaBBBcc\\") == { 'a': 4, 'B': 3, 'c': 2 } def test_count_characters_empty_string(): assert count_characters(\\"\\") == {} def test_count_characters_special_characters(): assert count_characters(\\"!@#%^&*()_+\\") == { '!': 1, '@': 1, '#': 1, '': 1, '%': 1, '^': 1, '&': 1, '*': 1, '(': 1, ')': 1, '_': 1, '+': 1 } def test_count_characters_single_character(): assert count_characters(\\"a\\") == {'a': 1} def test_count_characters_repeating_single_character(): assert count_characters(\\"bbbbbb\\") == {'b': 6}","solution":"from typing import Dict def count_characters(input_string: str) -> Dict[str, int]: Count the occurrences of each character in a given string. Parameters: input_string (str): The input string consisting of ASCII characters. Returns: Dict[str, int]: A dictionary with characters as keys and their counts as values. char_count = {} for char in input_string: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"class Product: A class to represent a product in the inventory. Attributes: name (str): The name of the product. quantity (int): The quantity of the product. price (float): The price of the product. def __init__(self, name: str, quantity: int, price: float) -> None: Initialize a new product with the given name, quantity, and price. pass class Inventory: A class to manage the inventory of products. def __init__(self) -> None: Initialize the inventory with an empty dictionary of products. pass def add_product(self, name: str, quantity: int, price: float) -> None: Add a new product to the inventory. Args: name (str): The name of the product. quantity (int): The quantity of the product. price (float): The price of the product. pass def update_product(self, name: str, quantity: int, price: float) -> None: Update the details of an existing product in the inventory. Args: name (str): The name of the product. quantity (int): The new quantity of the product. price (float): The new price of the product. pass def query_product(self, name: str) -> tuple: Query the details of a product in the inventory. Args: name (str): The name of the product. Returns: tuple: A tuple containing the quantity and price of the product. pass def list_products(self) -> list: List all the products in the inventory. Returns: list: A list of tuples, each containing the name, quantity, and price of a product. pass import pytest from solution import Product, Inventory def test_add_product(): inventory = Inventory() inventory.add_product('Apple', 10, 0.99) assert inventory.query_product('Apple') == (10, 0.99) with pytest.raises(ValueError, match=\\"Product already exists\\"): inventory.add_product('Apple', 5, 0.8) def test_update_product(): inventory = Inventory() inventory.add_product('Banana', 20, 1.5) inventory.update_product('Banana', 25, 1.3) assert inventory.query_product('Banana') == (25, 1.3) with pytest.raises(ValueError, match=\\"Product does not exist\\"): inventory.update_product('Orange', 10, 0.5) with pytest.raises(ValueError, match=\\"Quantity and price must be non-negative\\"): inventory.update_product('Banana', -5, 1.3) def test_query_product(): inventory = Inventory() inventory.add_product('Apple', 15, 0.8) assert inventory.query_product('Apple') == (15, 0.8) with pytest.raises(ValueError, match=\\"Product does not exist\\"): inventory.query_product('Banana') def test_list_products(): inventory = Inventory() inventory.add_product('Apple', 10, 0.99) inventory.add_product('Banana', 20, 1.5) assert inventory.list_products() == [('Apple', 10, 0.99), ('Banana', 20, 1.5)] def test_add_product_invalid_values(): inventory = Inventory() with pytest.raises(ValueError, match=\\"Quantity and price must be non-negative\\"): inventory.add_product('Orange', -3, 1.0) with pytest.raises(ValueError, match=\\"Quantity and price must be non-negative\\"): inventory.add_product('Orange', 3, -1.0)","solution":"class Product: def __init__(self, name: str, quantity: int, price: float) -> None: self.name = name self.quantity = quantity self.price = price class Inventory: def __init__(self) -> None: self.products = {} def add_product(self, name: str, quantity: int, price: float) -> None: if name in self.products: raise ValueError(\\"Product already exists\\") if quantity < 0 or price < 0: raise ValueError(\\"Quantity and price must be non-negative\\") self.products[name] = Product(name, quantity, price) def update_product(self, name: str, quantity: int, price: float) -> None: if name not in self.products: raise ValueError(\\"Product does not exist\\") if quantity < 0 or price < 0: raise ValueError(\\"Quantity and price must be non-negative\\") self.products[name].quantity = quantity self.products[name].price = price def query_product(self, name: str) -> tuple: if name not in self.products: raise ValueError(\\"Product does not exist\\") product = self.products[name] return (product.quantity, product.price) def list_products(self) -> list: return [(product.name, product.quantity, product.price) for product in self.products.values()]"},{"question":"class InventoryManagement: Inventory Management System for a Retail Store Manages the addition, updating, and querying of product information. Attributes: inventory (dict): A dictionary to store product details, where the key is the product ID, and the value is another dictionary with keys 'name', 'quantity', and 'price'. Methods: add_product(self, product_id: int, name: str, quantity: int, price: float) -> None: Adds a new product to the inventory. If the product ID already exists, it should not change the existing product and should return an error message. update_product(self, product_id: int, quantity: int, price: float) -> str: Updates the product's quantity and price. If the product ID does not exist, it should return an error message. get_product(self, product_id: int) -> dict: Returns the product details for the given product ID. If the product ID does not exist, it should return an error message. inventory_value(self) -> float: Returns the total value of the inventory, calculated as the sum of each product's quantity multiplied by its price. def __init__(self): self.inventory = {} def add_product(self, product_id: int, name: str, quantity: int, price: float) -> None: Adds a new product to the inventory. Args: product_id (int): Unique identifier for the product. name (str): Name of the product. quantity (int): Number of items available. price (float): Price per item. Returns: None or str: Returns None if product is added successfully, otherwise an error message. pass def update_product(self, product_id: int, quantity: int, price: float) -> str: Updates the product's quantity and price. Args: product_id (int): Unique identifier for the product. quantity (int): Updated number of items available. price (float): Updated price per item. Returns: str: Confirmation message if product is updated successfully, otherwise an error message. pass def get_product(self, product_id: int) -> dict: Returns the product details for the given product ID. Args: product_id (int): Unique identifier for the product. Returns: dict or str: A dictionary containing product details if product ID exists, otherwise an error message. pass def inventory_value(self) -> float: Returns the total value of the inventory. Returns: float: Total value of the inventory. pass # Unit Tests def test_add_product(): inventory = InventoryManagement() result = inventory.add_product(101, \\"Laptop\\", 5, 800.00) assert result == None assert inventory.inventory[101] == {'name': \\"Laptop\\", 'quantity': 5, 'price': 800.00} def test_add_existing_product(): inventory = InventoryManagement() inventory.add_product(101, \\"Laptop\\", 5, 800.00) result = inventory.add_product(101, \\"Smartphone\\", 10, 500.00) assert result == \\"Error: Product ID already exists.\\" assert inventory.inventory[101] == {'name': \\"Laptop\\", 'quantity': 5, 'price': 800.00} def test_update_product(): inventory = InventoryManagement() inventory.add_product(101, \\"Laptop\\", 5, 800.00) result = inventory.update_product(101, 7, 820.00) assert result == \\"Product 101 updated successfully.\\" assert inventory.inventory[101] == {'name': \\"Laptop\\", 'quantity': 7, 'price': 820.00} def test_update_nonexistent_product(): inventory = InventoryManagement() result = inventory.update_product(102, 10, 1000.00) assert result == \\"Error: Product ID does not exist.\\" def test_get_product(): inventory = InventoryManagement() inventory.add_product(101, \\"Laptop\\", 5, 800.00) product = inventory.get_product(101) assert product == {'name': \\"Laptop\\", 'quantity': 5, 'price': 800.00} def test_get_nonexistent_product(): inventory = InventoryManagement() result = inventory.get_product(102) assert result == \\"Error: Product ID does not exist.\\" def test_inventory_value(): inventory = InventoryManagement() inventory.add_product(101, \\"Laptop\\", 5, 800.00) inventory.add_product(102, \\"Smartphone\\", 10, 500.00) assert inventory.inventory_value() == 5*800.00 + 10*500.00","solution":"class InventoryManagement: def __init__(self): self.inventory = {} def add_product(self, product_id: int, name: str, quantity: int, price: float) -> None: if product_id in self.inventory: return \\"Error: Product ID already exists.\\" self.inventory[product_id] = { 'name': name, 'quantity': quantity, 'price': price } def update_product(self, product_id: int, quantity: int, price: float) -> str: if product_id not in self.inventory: return \\"Error: Product ID does not exist.\\" self.inventory[product_id]['quantity'] = quantity self.inventory[product_id]['price'] = price return f\\"Product {product_id} updated successfully.\\" def get_product(self, product_id: int) -> dict: if product_id not in self.inventory: return \\"Error: Product ID does not exist.\\" return self.inventory[product_id] def inventory_value(self) -> float: total_value = 0.0 for product in self.inventory.values(): total_value += product['quantity'] * product['price'] return total_value"},{"question":"def fibonacci(n: int) -> int: Returns the nth term in the Fibonacci sequence. >>> fibonacci(1) # Output: 0 >>> fibonacci(2) # Output: 1 >>> fibonacci(10) # Output: 34 >>> fibonacci(50) # Output: 7778742049","solution":"def fibonacci(n: int) -> int: Returns the nth term in the Fibonacci sequence. if n == 1: return 0 elif n == 2: return 1 a, b = 0, 1 for _ in range(3, n + 1): a, b = b, a + b return b"},{"question":"from typing import List def custom_sort(nums: List[int]) -> List[int]: Returns a list of integers sorted such that all even numbers appear before all odd numbers, and both groups are sorted in ascending order. >>> custom_sort([3, 1, 2, 4, 5, 7, 6]) [2, 4, 6, 1, 3, 5, 7] >>> custom_sort([3, -1, 2, 4, -5, 7, 6, -2]) [-2, 2, 4, 6, -5, -1, 3, 7] >>> custom_sort([4, 2, 6, 8, 0]) [0, 2, 4, 6, 8] >>> custom_sort([3, 1, 5, 7, 9]) [1, 3, 5, 7, 9] >>> custom_sort([-12, 3, 0, -5, 2, 11, -8]) [-12, -8, 0, 2, -5, 3, 11] >>> custom_sort([]) [] >>> custom_sort([8]) [8] >>> custom_sort([7]) [7] >>> custom_sort([2, 3, 2, 1, 4, 1, 4, 6, 7]) [2, 2, 4, 4, 6, 1, 1, 3, 7] pass","solution":"from typing import List def custom_sort(nums: List[int]) -> List[int]: Returns a list of integers sorted such that all even numbers appear before all odd numbers, and both groups are sorted in ascending order. evens = sorted([num for num in nums if num % 2 == 0]) odds = sorted([num for num in nums if num % 2 != 0]) return evens + odds"},{"question":"def filter_csv_columns(input_file: str, output_file: str, columns: List[int]) -> None: Filter columns of a CSV file based on provided column indices. :param input_file: Path to the input CSV file. :param output_file: Path to the output CSV file, where the filtered data should be saved. :param columns: List of zero-based column indices to retain. >>> input_file = \\"path/to/input.csv\\" >>> output_file = \\"path/to/output.csv\\" >>> columns = [0, 2, 4] >>> filter_csv_columns(input_file, output_file, columns) # The output.csv will now contain only columns 0, 2, and 4 from input.csv import os import csv import pytest from typing import List def create_csv_file(path, content): with open(path, 'w', newline='', encoding='utf-8') as file: writer = csv.writer(file) for row in content: writer.writerow(row) def test_filter_csv_columns_basic(): input_file = 'test_input.csv' output_file = 'test_output.csv' content = [ ['A', 'B', 'C', 'D'], ['1', '2', '3', '4'], ['5', '6', '7', '8'], ['9', '10', '11', '12'] ] expected_output = [ ['A', 'C', 'D'], ['1', '3', '4'], ['5', '7', '8'], ['9', '11', '12'] ] create_csv_file(input_file, content) filter_csv_columns(input_file, output_file, [0, 2, 3]) with open(output_file, 'r', newline='', encoding='utf-8') as file: reader = csv.reader(file) output_content = [row for row in reader] assert output_content == expected_output os.remove(input_file) os.remove(output_file) def test_filter_csv_columns_empty_file(): input_file = 'test_input.csv' output_file = 'test_output.csv' content = [] create_csv_file(input_file, content) with pytest.raises(StopIteration): filter_csv_columns(input_file, output_file, [0, 2, 3]) os.remove(input_file) def test_filter_csv_columns_index_out_of_bounds(): input_file = 'test_input.csv' output_file = 'test_output.csv' content = [ ['A', 'B', 'C'], ['1', '2', '3'], ] create_csv_file(input_file, content) with pytest.raises(ValueError, match=\\"Column index 5 is out of bounds for the input file.\\"): filter_csv_columns(input_file, output_file, [0, 1, 5]) os.remove(input_file) def test_filter_csv_columns_single_column(): input_file = 'test_input.csv' output_file = 'test_output.csv' content = [ ['A', 'B', 'C'], ['1', '2', '3'], ['4', '5', '6'] ] expected_output = [ ['B'], ['2'], ['5'] ] create_csv_file(input_file, content) filter_csv_columns(input_file, output_file, [1]) with open(output_file, 'r', newline='', encoding='utf-8') as file: reader = csv.reader(file) output_content = [row for row in reader] assert output_content == expected_output os.remove(input_file) os.remove(output_file)","solution":"import csv from typing import List def filter_csv_columns(input_file: str, output_file: str, columns: List[int]) -> None: Filter columns of a CSV file based on provided column indices. with open(input_file, mode='r', newline='', encoding='utf-8') as infile: reader = csv.reader(infile) header = next(reader) # Validating column indices max_valid_index = len(header) - 1 for col in columns: if col < 0 or col > max_valid_index: raise ValueError(f\\"Column index {col} is out of bounds for the input file.\\") with open(output_file, mode='w', newline='', encoding='utf-8') as outfile: writer = csv.writer(outfile) writer.writerow([header[i] for i in columns]) for row in reader: writer.writerow([row[i] for i in columns])"},{"question":"def knapsack_max_value(capacity: int, items: list[tuple[int, int]]) -> int: Function to determine the maximum value that can be obtained from the given items within the given capacity of the backpack. Args: capacity (int): The weight capacity of the backpack. items (list of tuples): A list of items where each item is represented as a tuple (weight, value). Returns: int: The maximum value obtainable without exceeding the weight capacity. Examples: >>> knapsack_max_value(50, [(10, 60), (20, 100), (30, 120)]) 220 >>> knapsack_max_value(10, [(5, 50), (5, 50), (5, 50)]) 100 from solution import knapsack_max_value def test_knapsack_max_value_basic(): assert knapsack_max_value(50, [(10, 60), (20, 100), (30, 120)]) == 220 def test_knapsack_max_value_zero_capacity(): assert knapsack_max_value(0, [(10, 60), (20, 100), (30, 120)]) == 0 def test_knapsack_max_value_items_fit_exactly(): assert knapsack_max_value(30, [(10, 60), (10, 70), (10, 80)]) == 210 def test_knapsack_max_value_exceeds_capacity(): assert knapsack_max_value(5, [(10, 60), (20, 100), (30, 120)]) == 0 def test_knapsack_max_value_duplicate_items(): assert knapsack_max_value(50, [(10, 60), (10, 60), (10, 60)]) == 180 def test_knapsack_max_value_mixed_items(): assert knapsack_max_value(10, [(5, 50), (5, 50), (5, 50)]) == 100 def test_knapsack_max_value_no_items(): assert knapsack_max_value(50, []) == 0 def test_knapsack_max_value_large_capacities(): assert knapsack_max_value(10000, [(1, 1) for _ in range(1000)]) == 1000","solution":"def knapsack_max_value(capacity: int, items: list[tuple[int, int]]) -> int: Function to determine the maximum value that can be obtained from the given items within the given capacity of the backpack. Args: capacity (int): The weight capacity of the backpack. items (list of tuples): A list of items where each item is represented as a tuple (weight, value). Returns: int: The maximum value obtainable without exceeding the weight capacity. n = len(items) # Create a 2D DP array to store the maximum value that can be achieved with # various capacities. dp = [[0] * (capacity + 1) for _ in range(n + 1)] # Populate the DP array for i in range(1, n + 1): weight, value = items[i - 1] for w in range(1, capacity + 1): if weight <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + value) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity]"},{"question":"def find_mutual_friends(graph: dict, user1: str, user2: str) -> list: Finds all mutual friends between two users in an undirected graph. Args: graph (dict): Dictionary representing the graph where each key is a node (user), and its value is a list of neighbors (friends). { \\"userA\\": [\\"friend1\\", \\"friend2\\", ...], ... } user1 (str): The first user. user2 (str): The second user. Returns: list: A list of mutual friends' usernames. If there are no mutual friends, return an empty list. pass # Example Tests graph = { \\"Alice\\": [\\"Bob\\", \\"Charlie\\", \\"David\\"], \\"Bob\\": [\\"Alice\\", \\"Charlie\\"], \\"Charlie\\": [\\"Alice\\", \\"Bob\\", \\"Eve\\"], \\"David\\": [\\"Alice\\"], \\"Eve\\": [\\"Charlie\\"] } user1 = \\"Alice\\" user2 = \\"Charlie\\" print(find_mutual_friends(graph, user1, user2)) # Output: [\\"Bob\\"] graph = { \\"Alice\\": [\\"Bob\\"], \\"Bob\\": [\\"Alice\\"], \\"Charlie\\": [\\"Eve\\"], \\"Eve\\": [\\"Charlie\\"] } user1 = \\"Alice\\" user2 = \\"Charlie\\" print(find_mutual_friends(graph, user1, user2)) # Output: [] graph = { \\"Alice\\": [\\"Bob\\", \\"Charlie\\", \\"David\\"], \\"Bob\\": [\\"Alice\\", \\"Charlie\\", \\"David\\"], \\"Charlie\\": [\\"Alice\\", \\"Bob\\"], \\"David\\": [\\"Alice\\", \\"Bob\\"], \\"Eve\\": [\\"Frank\\"], \\"Frank\\": [\\"Eve\\"] } user1 = \\"Alice\\" user2 = \\"Bob\\" print(sorted(find_mutual_friends(graph, user1, user2))) # Output: [\\"Charlie\\", \\"David\\"] graph = { \\"Alice\\": [\\"Bob\\"], \\"Bob\\": [\\"Alice\\"] } user1 = \\"Alice\\" user2 = \\"Charlie\\" print(find_mutual_friends(graph, user1, user2)) # Output: [] graph = { \\"Alice\\": [\\"Bob\\", \\"Charlie\\"], \\"Bob\\": [\\"Alice\\"], \\"Charlie\\": [\\"Alice\\"] } user1 = \\"Alice\\" user2 = \\"Alice\\" print(sorted(find_mutual_friends(graph, user1, user2))) # Output: [\\"Bob\\", \\"Charlie\\"]","solution":"def find_mutual_friends(graph: dict, user1: str, user2: str) -> list: Finds all mutual friends between two users in an undirected graph. Args: graph (dict): Dictionary representing the graph where each key is a node (user), and its value is a list of neighbors (friends). { \\"userA\\": [\\"friend1\\", \\"friend2\\", ...], ... } user1 (str): The first user. user2 (str): The second user. Returns: list: A list of mutual friends' usernames. If there are no mutual friends, return an empty list. if user1 not in graph or user2 not in graph: return [] user1_friends = set(graph[user1]) user2_friends = set(graph[user2]) mutual_friends = user1_friends.intersection(user2_friends) return list(mutual_friends)"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates an NxN matrix by 90 degrees clockwise in place. Args: matrix (List[List[int]]): A square matrix of integers. Example Usage: >>> matrix1 = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix1) >>> matrix1 [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix2 = [ ... [5, 1], ... [2, 9] ... ] >>> rotate_matrix(matrix2) >>> matrix2 [[2, 5], [9, 1]] ...","solution":"def rotate_matrix(matrix): Rotates an NxN matrix by 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def is_valid_identifier(identifier: str) -> bool: Determine if the provided identifier is valid. Parameters: identifier (str): The identifier string to be evaluated. Returns: bool: True if the identifier is valid, otherwise False. # Unit tests def test_is_valid_identifier(): # Valid identifiers assert is_valid_identifier(\\"_variable1\\") == True assert is_valid_identifier(\\"variable\\") == True assert is_valid_identifier(\\"var1able\\") == True assert is_valid_identifier(\\"vari_able\\") == True assert is_valid_identifier(\\"_\\") == True assert is_valid_identifier(\\"a1_b2\\") == True # Invalid identifiers assert is_valid_identifier(\\"\\") == False assert is_valid_identifier(\\"2variable\\") == False assert is_valid_identifier(\\"variable!name\\") == False assert is_valid_identifier(\\"variable-name\\") == False assert is_valid_identifier(\\" \\") == False assert is_valid_identifier(\\"-variable\\") == False assert is_valid_identifier(\\"1variable\\") == False assert is_valid_identifier(\\"variable@name\\") == False","solution":"def is_valid_identifier(identifier: str) -> bool: Determine if the provided identifier is valid. Parameters: identifier (str): The identifier string to be evaluated. Returns: bool: True if the identifier is valid, otherwise False. if not identifier: return False if not (identifier[0].isalpha() or identifier[0] == '_'): return False for char in identifier[1:]: if not (char.isalnum() or char == '_'): return False return True"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def has_path_sum(self, target_sum: int) -> bool: Determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given target sum. :param target_sum: int, desired sum of the path. :returns: bool, True if such a path exists, else False. >>> binary_tree = make_binary_tree([5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, None, 1]) >>> binary_tree.has_path_sum(22) True >>> binary_tree = make_binary_tree([1, 2, 3]) >>> binary_tree.has_path_sum(5) False pass # Helper function to construct binary tree from list def make_binary_tree(values): Helper function to build a binary tree from a list of values. :param values: List of values where None signifies missing nodes. :returns: BinaryTree instance representing the binary tree. >>> make_binary_tree([1, 2, 3]).root.value 1 if not values: return BinaryTree() nodes = [None if val is None else TreeNode(val) for val in values] kids = nodes[::-1] root = kids.pop() for node in nodes: if node: if kids: node.left = kids.pop() if kids: node.right = kids.pop() return BinaryTree(root)","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def has_path_sum(self, target_sum): def has_path_sum_helper(node, current_sum): if not node: return False current_sum += node.value if not node.left and not node.right: # Reached a leaf node return current_sum == target_sum # Otherwise, continue the search on left and right subtrees return has_path_sum_helper(node.left, current_sum) or has_path_sum_helper(node.right, current_sum) return has_path_sum_helper(self.root, 0) # Helper function to construct binary tree from list def make_binary_tree(values): if not values: return BinaryTree() nodes = [None if val is None else TreeNode(val) for val in values] kids = nodes[::-1] root = kids.pop() for node in nodes: if node: if kids: node.left = kids.pop() if kids: node.right = kids.pop() return BinaryTree(root)"},{"question":"class ParkingLot: A class to simulate the management of a parking lot. Attributes: total_spaces (int): The total number of parking spaces in the lot. Methods: __init__(self, total_spaces: int): Initializes the parking lot. enter(self, license_plate: str) -> bool: Registers a vehicle entering the parking lot. exit(self, license_plate: str) -> bool: Registers a vehicle exiting the parking lot. get_current_occupancy(self) -> int: Returns the current number of occupied spaces. get_available_spaces(self) -> int: Returns the current number of available spaces. def __init__(self, total_spaces: int): Initializes the parking lot with a given number of total parking spaces. pass def enter(self, license_plate: str) -> bool: Registers a vehicle entering the parking lot. Returns True if the vehicle successfully entered, False otherwise. pass def exit(self, license_plate: str) -> bool: Registers a vehicle exiting the parking lot. Returns True if the vehicle successfully exited, False otherwise. pass def get_current_occupancy(self) -> int: Returns the current number of occupied spaces. pass def get_available_spaces(self) -> int: Returns the current number of available spaces. pass # Example Usage if __name__ == \\"__main__\\": parking_lot = ParkingLot(3) print(parking_lot.enter('ABC123')) # Output: True print(parking_lot.enter('DEF456')) # Output: True print(parking_lot.enter('GHI789')) # Output: True print(parking_lot.enter('JKL012')) # Output: False print(parking_lot.get_current_occupancy()) # Output: 3 print(parking_lot.get_available_spaces()) # Output: 0 print(parking_lot.exit('DEF456')) # Output: True print(parking_lot.get_current_occupancy()) # Output: 2 print(parking_lot.get_available_spaces()) # Output: 1 print(parking_lot.enter('JKL012')) # Output: True","solution":"class ParkingLot: def __init__(self, total_spaces: int): Initializes the parking lot with a given number of total parking spaces. self.total_spaces = total_spaces self.occupied_spaces = 0 self.vehicles = set() # Use a set to keep track of vehicles in the parking lot def enter(self, license_plate: str) -> bool: Registers a vehicle entering the parking lot. Returns True if the vehicle successfully entered, False otherwise. if self.occupied_spaces < self.total_spaces and license_plate not in self.vehicles: self.vehicles.add(license_plate) self.occupied_spaces += 1 return True return False def exit(self, license_plate: str) -> bool: Registers a vehicle exiting the parking lot. Returns True if the vehicle successfully exited, False otherwise. if license_plate in self.vehicles: self.vehicles.remove(license_plate) self.occupied_spaces -= 1 return True return False def get_current_occupancy(self) -> int: Returns the current number of occupied spaces. return self.occupied_spaces def get_available_spaces(self) -> int: Returns the current number of available spaces. return self.total_spaces - self.occupied_spaces"},{"question":"from typing import List def extract_unique_words(text: str) -> List[str]: Extract unique words from a given text, ignoring punctuation and case, and returns them sorted in alphabetical order. >>> extract_unique_words(\\"Hello, world! Hello again.\\") == ['again', 'hello', 'world'] >>> extract_unique_words(\\"Python is great. PYTHON, python programming.\\") == ['great', 'is', 'programming', 'python'] >>> extract_unique_words(\\"\\") == []","solution":"import re from typing import List def extract_unique_words(text: str) -> List[str]: Extracts unique words from a given text, ignoring punctuation and capitalization, and returns them sorted in alphabetical order. # Convert text to lowercase text = text.lower() # Use regex to find words, ignoring punctuation words = re.findall(r'bw+b', text) # Use a set to remove duplicates unique_words = set(words) # Return the unique words sorted alphabetically return sorted(unique_words)"},{"question":"import aiohttp import asyncio from typing import List, Dict _GRADES_API = \\"https://api.mockgrades.com/v1/classes/\\" async def fetch_student_grades(class_id: str) -> List[Dict[str, List[int]]]: Asynchronously fetches the grade data from a mock API. The function should handle potential exceptions and validate the response structure. pass def calculate_average(grades_data: List[Dict[str, List[int]]]) -> List[Dict[str, float]]: Calculates the average grade for each student. >>> calculate_average([{'name': 'John Doe', 'grades': [90, 80, 85]}, {'name': 'Jane Smith', 'grades': [100, 90, 95]}]) [{'name': 'John Doe', 'average_grade': 85.0}, {'name': 'Jane Smith', 'average_grade': 95.0}] pass def save_to_file(averages: List[Dict[str, float]], filename: str) -> None: Writes the student's average grades to the specified file. Each student's name and their average grade should be written on a new line. pass if __name__ == \\"__main__\\": class_id = \\"<Your Class ID goes here>\\" grades_data = asyncio.run(fetch_student_grades(class_id)) averages = calculate_average(grades_data) save_to_file(averages, 'grades_report.txt') Unit Test: import pytest from unittest.mock import patch, AsyncMock from solution import fetch_student_grades, calculate_average, save_to_file @pytest.mark.asyncio async def test_fetch_student_grades_valid_data(): response_data = { 'students': [ {'name': 'John Doe', 'grades': [90, 80, 85]}, {'name': 'Jane Smith', 'grades': [100, 90, 95]} ] } with patch('aiohttp.ClientSession.get', new_callable=AsyncMock) as mock_get: mock_response = AsyncMock() mock_response.status = 200 mock_response.json.return_value = response_data mock_get.return_value.__aenter__.return_value = mock_response result = await fetch_student_grades(\\"class_1001\\") assert result == [ {'name': 'John Doe', 'grades': [90, 80, 85]}, {'name': 'Jane Smith', 'grades': [100, 90, 95]} ] @pytest.mark.asyncio async def test_fetch_student_grades_no_students_key(): response_data = {} with patch('aiohttp.ClientSession.get', new_callable=AsyncMock) as mock_get: mock_response = AsyncMock() mock_response.status = 200 mock_response.json.return_value = response_data mock_get.return_value.__aenter__.return_value = mock_response result = await fetch_student_grades(\\"class_1001\\") assert result == [] @pytest.mark.asyncio async def test_fetch_student_grades_request_failure(): with patch('aiohttp.ClientSession.get', new_callable=AsyncMock) as mock_get: mock_response = AsyncMock() mock_response.status = 404 mock_get.return_value.__aenter__.return_value = mock_response result = await fetch_student_grades(\\"class_1001\\") assert result == [] def test_calculate_average(): grades_data = [ {'name': 'John Doe', 'grades': [90, 80, 85]}, {'name': 'Jane Smith', 'grades': [100, 90, 95]}, {'name': 'Empty Grades', 'grades': []} ] result = calculate_average(grades_data) expected = [ {'name': 'John Doe', 'average_grade': 85.0}, {'name': 'Jane Smith', 'average_grade': 95.0}, {'name': 'Empty Grades', 'average_grade': 0.0} ] assert result == expected def test_save_to_file(tmp_path): averages = [ {'name': 'John Doe', 'average_grade': 85.0}, {'name': 'Jane Smith', 'average_grade': 95.0} ] filename = tmp_path / \\"grades_report.txt\\" save_to_file(averages, filename) with open(filename, 'r') as file: content = file.readlines() assert content == [\\"John Doe: 85.00n\\", \\"Jane Smith: 95.00n\\"]","solution":"import aiohttp import asyncio from typing import List, Dict _GRADES_API = \\"https://api.mockgrades.com/v1/classes/\\" async def fetch_student_grades(class_id: str) -> List[Dict[str, List[int]]]: async with aiohttp.ClientSession() as session: try: async with session.get(f\\"{_GRADES_API}{class_id}\\", timeout=5) as response: response.raise_for_status() json_response = await response.json() if 'students' not in json_response: raise ValueError(\\"Invalid response structure: 'students' key not found\\") return [ {'name': student['name'], 'grades': student['grades']} for student in json_response['students'] ] except (aiohttp.ClientError, asyncio.TimeoutError, ValueError, KeyError) as e: print(f\\"An error occurred: {e}\\") return [] def calculate_average(grades_data: List[Dict[str, List[int]]]) -> List[Dict[str, float]]: averages = [] for student in grades_data: if len(student['grades']) == 0: avg_grade = 0.0 else: avg_grade = sum(student['grades']) / len(student['grades']) averages.append({'name': student['name'], 'average_grade': avg_grade}) return averages def save_to_file(averages: List[Dict[str, float]], filename: str) -> None: try: with open(filename, 'w') as file: for student in averages: file.write(f\\"{student['name']}: {student['average_grade']:.2f}n\\") except IOError as e: print(f\\"File operation error: {e}\\")"},{"question":"def count_substrings(s: str, K: int) -> dict: Returns a dictionary with counts of all distinct substrings of lengths ranging from 1 to K. if not s or K < 1 or K > len(s): return {} substring_count = {} # Iterate over all possible substring lengths for length in range(1, K + 1): # Iterate over the string to find all substrings of the current length for i in range(len(s) - length + 1): substring = s[i:i + length] if substring in substring_count: substring_count[substring] += 1 else: substring_count[substring] = 1 return substring_count","solution":"def count_substrings(s: str, K: int) -> dict: Returns a dictionary with counts of all distinct substrings of lengths ranging from 1 to K. if not s or K < 1 or K > len(s): return {} substring_count = {} # Iterate over all possible substring lengths for length in range(1, K + 1): # Iterate over the string to find all substrings of the current length for i in range(len(s) - length + 1): substring = s[i:i + length] if substring in substring_count: substring_count[substring] += 1 else: substring_count[substring] = 1 return substring_count"},{"question":"def is_strictly_increasing(lst: list) -> bool: Determines if the given list of integers is strictly increasing. Parameters: lst: list - A list of integers Returns: bool - True if the list is strictly increasing, False otherwise. Raises: TypeError - If the input is not a list. ValueError - If any element in the list is not an integer. Examples: >>> is_strictly_increasing([1, 2, 3, 4, 5]) True >>> is_strictly_increasing([1, 2, 2, 4, 5]) False >>> is_strictly_increasing([5, 6, 7, 8, 9]) True >>> is_strictly_increasing([]) True >>> is_strictly_increasing([1]) True >>> is_strictly_increasing([1, 'a', 3]) Traceback (most recent call last): ... ValueError: List elements must be integers >>> is_strictly_increasing(\\"12345\\") Traceback (most recent call last): ... TypeError: Input value must be a list","solution":"def is_strictly_increasing(lst): Determines if the given list of integers is strictly increasing. Parameters: lst: list - A list of integers Returns: bool - True if the list is strictly increasing, False otherwise. if not isinstance(lst, list): raise TypeError(\\"Input value must be a list\\") for i in lst: if not isinstance(i, int): raise ValueError(\\"List elements must be integers\\") for i in range(len(lst) - 1): if lst[i] >= lst[i + 1]: return False return True"},{"question":"def longest_common_subsequence_length(X: str, Y: str) -> int: Returns the length of the longest common subsequence of strings X and Y. >>> longest_common_subsequence_length(\\"abcdgh\\", \\"aedfhr\\") 3 >>> longest_common_subsequence_length(\\"aggtab\\", \\"gxtxayb\\") 4 def test_example_1(): assert longest_common_subsequence_length(\\"abcdgh\\", \\"aedfhr\\") == 3 def test_example_2(): assert longest_common_subsequence_length(\\"aggtab\\", \\"gxtxayb\\") == 4 def test_no_common_subsequence(): assert longest_common_subsequence_length(\\"abc\\", \\"def\\") == 0 def test_same_strings(): assert longest_common_subsequence_length(\\"abcdefgh\\", \\"abcdefgh\\") == 8 def test_one_char_common(): assert longest_common_subsequence_length(\\"a\\", \\"a\\") == 1 assert longest_common_subsequence_length(\\"a\\", \\"b\\") == 0 def test_disjoint_characters(): assert longest_common_subsequence_length(\\"abc\\", \\"xyz\\") == 0 def test_large_input(): X = \\"a\\" * 1000 Y = \\"a\\" * 500 + \\"b\\" * 500 assert longest_common_subsequence_length(X, Y) == 500","solution":"def longest_common_subsequence_length(X: str, Y: str) -> int: Returns the length of the longest common subsequence of strings X and Y. m, n = len(X), len(Y) # Initialize DP array with two rows dp = [[0] * (n + 1) for _ in range(2)] for i in range(1, m + 1): for j in range(1, n + 1): if X[i - 1] == Y[j - 1]: dp[i % 2][j] = dp[(i - 1) % 2][j - 1] + 1 else: dp[i % 2][j] = max(dp[(i - 1) % 2][j], dp[i % 2][j - 1]) return dp[m % 2][n]"},{"question":"class Rectangle: def __init__(self, length: float, width: float): Initializes the Rectangle with the given length and width. Raises a ValueError if either length or width is non-positive with the message \\"Dimensions must be positive.\\" pass def perimeter(self) -> float: Calculates and returns the perimeter of the rectangle. pass def area(self) -> float: Calculates and returns the area of the rectangle. pass def scale(self, factor: float) -> None: Scales the dimensions of the rectangle by the given factor. Raises a ValueError if the factor is non-positive with the message \\"Scaling factor must be positive.\\" pass","solution":"class Rectangle: def __init__(self, length: float, width: float): Initializes the Rectangle with the given length and width. Raises a ValueError if either length or width is non-positive. if length <= 0 or width <= 0: raise ValueError(\\"Dimensions must be positive.\\") self.length = length self.width = width def perimeter(self) -> float: Calculates and returns the perimeter of the rectangle. return 2 * (self.length + self.width) def area(self) -> float: Calculates and returns the area of the rectangle. return self.length * self.width def scale(self, factor: float) -> None: Scales the dimensions of the rectangle by the given factor. Raises a ValueError if the factor is non-positive. if factor <= 0: raise ValueError(\\"Scaling factor must be positive.\\") self.length *= factor self.width *= factor"},{"question":"from typing import List, Dict, Union def merge_sort(collection: List[int]) -> List[int]: Sort a list of integers using the Merge Sort algorithm. >>> merge_sort([12, 11, 13, 5, 6, 7]) [5, 6, 7, 11, 12, 13] >>> merge_sort([-3, 10, 0, -19, 2]) [-19, -3, 0, 2, 10] >>> merge_sort([1, 2, 3, 2, 1]) [1, 1, 2, 2, 3] >>> merge_sort([]) [] >>> merge_sort([1]) [1] pass def merge_sort_dict(collection: List[Dict[str, Union[int, str]]], key: str) -> List[Dict[str, Union[int, str]]]: Sort a list of dictionaries based on a specified key using the Merge Sort algorithm. >>> merge_sort_dict([{ \\"name\\": \\"John\\", \\"age\\": 23 }, { \\"name\\": \\"Jane\\", \\"age\\": 31 }, { \\"name\\": \\"Dave\\", \\"age\\": 20 }], 'age') [{ \\"name\\": \\"Dave\\", \\"age\\": 20 }, { \\"name\\": \\"John\\", \\"age\\": 23 }, { \\"name\\": \\"Jane\\", \\"age\\": 31 }] >>> merge_sort_dict([{ \\"name\\": \\"John\\", \\"age\\": 23 }, { \\"name\\": \\"Jane\\", \\"age\\": 31 }, { \\"name\\": \\"Dave\\", \\"age\\": 20 }], 'name') [{ \\"name\\": \\"Dave\\", \\"age\\": 20 }, { \\"name\\": \\"Jane\\", \\"age\\": 31 }, { \\"name\\": \\"John\\", \\"age\\": 23 }] >>> merge_sort_dict([], 'name') [] >>> merge_sort_dict([{ \\"name\\": \\"Alice\\", \\"level\\": 3 }, { \\"name\\": \\"Bob\\", \\"level\\": 1 }], 'level') [{ \\"name\\": \\"Bob\\", \\"level\\": 1 }, { \\"name\\": \\"Alice\\", \\"level\\": 3 }] >>> merge_sort_dict([{ \\"name\\": \\"Cat\\", \\"age\\": 12 }, { \\"name\\": \\"Mouse\\", \\"age\\": 10 }, { \\"name\\": \\"Dog\\", \\"age\\": 15 }], 'age') [{ \\"name\\": \\"Mouse\\", \\"age\\": 10 }, { \\"name\\": \\"Cat\\", \\"age\\": 12 }, { \\"name\\": \\"Dog\\", \\"age\\": 15 }] pass","solution":"from typing import List, Dict, Union def merge_sort(collection: List[int]) -> List[int]: if len(collection) <= 1: return collection middle = len(collection) // 2 left_half = merge_sort(collection[:middle]) right_half = merge_sort(collection[middle:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] left_index = right_index = 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list def merge_sort_dict(collection: List[Dict[str, Union[int, str]]], key: str) -> List[Dict[str, Union[int, str]]]: if len(collection) <= 1: return collection middle = len(collection) // 2 left_half = merge_sort_dict(collection[:middle], key) right_half = merge_sort_dict(collection[middle:], key) return merge_dict(left_half, right_half, key) def merge_dict(left: List[Dict[str, Union[int, str]]], right: List[Dict[str, Union[int, str]]], key: str) -> List[Dict[str, Union[int, str]]]: sorted_list = [] left_index = right_index = 0 while left_index < len(left) and right_index < len(right): if left[left_index][key] <= right[right_index][key]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list"},{"question":"def is_fibonacci_subsequence(arr: list[int]) -> bool: Checks whether a given list of integers forms a subsequence of the Fibonacci sequence. >>> is_fibonacci_subsequence([1, 2, 3, 5, 8]) True >>> is_fibonacci_subsequence([8, 2, 3, 1]) False >>> is_fibonacci_subsequence([13, 21, 34, 55]) True >>> is_fibonacci_subsequence([0, 1, 4, 5, 9]) False >>> is_fibonacci_subsequence([]) True >>> is_fibonacci_subsequence([8, -1, 13]) ValueError: Elements in the input list must be non-negative","solution":"def is_fibonacci_subsequence(arr: list[int]) -> bool: if any(x < 0 for x in arr): raise ValueError(\\"Elements in the input list must be non-negative\\") if not arr: return True fib_set = set() a, b = 0, 1 while b <= max(arr): fib_set.add(b) a, b = b, a + b fib_set.add(0) # explicitly add 0 to handle the start of the sequence index = 0 for num in arr: if num in fib_set and (index == 0 or num >= arr[index - 1]): index += 1 else: return False return True"},{"question":"def integer_to_roman(num: int) -> str: Convert an integer to a Roman numeral. >>> integer_to_roman(1) 'I' >>> integer_to_roman(58) 'LVIII' # L = 50, V = 5, III = 3 >>> integer_to_roman(1994) 'MCMXCIV' # M = 1000, CM = 900, XC = 90, IV = 4 def roman_to_integer(s: str) -> int: Convert a Roman numeral to an integer. >>> roman_to_integer('I') 1 >>> roman_to_integer('LVIII') 58 # L = 50, V = 5, III = 3 >>> roman_to_integer('MCMXCIV') 1994 # M = 1000, CM = 900, XC = 90, IV = 4","solution":"def integer_to_roman(num: int) -> str: values = [ (1000, \\"M\\"), (900, \\"CM\\"), (500, \\"D\\"), (400, \\"CD\\"), (100, \\"C\\"), (90, \\"XC\\"), (50, \\"L\\"), (40, \\"XL\\"), (10, \\"X\\"), (9, \\"IX\\"), (5, \\"V\\"), (4, \\"IV\\"), (1, \\"I\\") ] result = [] for value, numeral in values: while num >= value: result.append(numeral) num -= value return ''.join(result) def roman_to_integer(s: str) -> int: roman_to_int = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000, 'IV': 4, 'IX': 9, 'XL': 40, 'XC': 90, 'CD': 400, 'CM': 900 } i, total = 0, 0 while i < len(s): if i + 1 < len(s) and s[i:i+2] in roman_to_int: total += roman_to_int[s[i:i+2]] i += 2 else: total += roman_to_int[s[i]] i += 1 return total"},{"question":"def summarize_log(input_file, output_file, event_keywords): Reads a log file, summarizes the occurrences of specified event keywords, and writes the summary to an output file. Args: input_file : str Path to the input log file. output_file : str Path where the summary output file should be saved. event_keywords : list List of keywords representing the event types to be summarized. Example: >>> event_keywords = [\\"ERROR\\", \\"WARNING\\", \\"INFO\\"] >>> summarize_log(\\"system.log\\", \\"summary.txt\\", event_keywords) # The summary.txt file should contain: # INFO: 3 # ERROR: 2 # WARNING: 1 import os import pytest # Example unit tests def test_summarize_log_basic(): log_content = INFO: System started ERROR: Failed to load module INFO: User login WARNING: Low disk space INFO: System shutdown ERROR: Disk failure with open(\\"temp_log.txt\\", 'w') as file: file.write(log_content) event_keywords = [\\"ERROR\\", \\"WARNING\\", \\"INFO\\"] summarize_log(\\"temp_log.txt\\", \\"summary.txt\\", event_keywords) with open(\\"summary.txt\\", 'r') as file: result = file.read() expected_output = \\"ERROR: 2nWARNING: 1nINFO: 3n\\" assert result == expected_output def test_summarize_log_no_keywords(): log_content = DEBUG: This is a debug message TRACE: Entering function with open(\\"temp_log.txt\\", 'w') as file: file.write(log_content) event_keywords = [\\"ERROR\\", \\"WARNING\\", \\"INFO\\"] summarize_log(\\"temp_log.txt\\", \\"summary.txt\\", event_keywords) with open(\\"summary.txt\\", 'r') as file: result = file.read() expected_output = \\"ERROR: 0nWARNING: 0nINFO: 0n\\" assert result == expected_output def test_summarize_log_empty_file(): log_content = \\"\\" with open(\\"temp_log.txt\\", 'w') as file: file.write(log_content) event_keywords = [\\"ERROR\\", \\"WARNING\\", \\"INFO\\"] summarize_log(\\"temp_log.txt\\", \\"summary.txt\\", event_keywords) with open(\\"summary.txt\\", 'r') as file: result = file.read() expected_output = \\"ERROR: 0nWARNING: 0nINFO: 0n\\" assert result == expected_output def test_summarize_log_large_file(): log_content = (\\"INFO: Processingn\\" * 1000) + (\\"ERROR: Issue detectedn\\" * 500) + (\\"WARNING: Check systemn\\" * 100) with open(\\"temp_log.txt\\", 'w') as file: file.write(log_content) event_keywords = [\\"ERROR\\", \\"WARNING\\", \\"INFO\\"] summarize_log(\\"temp_log.txt\\", \\"summary.txt\\", event_keywords) with open(\\"summary.txt\\", 'r') as file: result = file.read() expected_output = \\"ERROR: 500nWARNING: 100nINFO: 1000n\\" assert result == expected_output @pytest.fixture(scope=\\"module\\", autouse=True) def cleanup(): yield # Clean up the files after running tests os.remove(\\"temp_log.txt\\") os.remove(\\"summary.txt\\")","solution":"def summarize_log(input_file, output_file, event_keywords): Reads a log file, summarizes the occurrences of specified event keywords, and writes the summary to an output file. Arguments: input_file : str : Path to the input log file. output_file : str : Path where the summary output file should be saved. event_keywords : list : List of keywords representing the event types to be summarized. # Initialize a dictionary to keep the count of each event keyword event_counts = {keyword: 0 for keyword in event_keywords} # Open and read the input file line by line with open(input_file, 'r') as infile: for line in infile: # Check if any keyword is in the line, and increment its count if found for keyword in event_keywords: if keyword in line: event_counts[keyword] += 1 # Write the summary to the output file with open(output_file, 'w') as outfile: for keyword, count in event_counts.items(): outfile.write(f\\"{keyword}: {count}n\\")"},{"question":"class EmployeeInformationSystem: A simple Employee Information System (EIS). Methods: add_employee(employee): Adds a new employee. remove_employee(employee_id): Removes an existing employee by their ID. get_employee(employee_id): Retrieves employee details using their ID. list_employees_by_age(min_age, max_age): Lists all employees within a specified age range. def __init__(self): self.employees = {} def add_employee(self, employee): Adds a new employee to the system. :param employee: Dictionary containing 'ID', 'name', and 'age' of the employee def remove_employee(self, employee_id): Removes an employee from the system by their ID. :param employee_id: Integer representing the employee ID to remove def get_employee(self, employee_id): Retrieves an employee's details by their ID. :param employee_id: Integer representing the employee ID :return: Dictionary containing the employee details or a message if the employee does not exist def list_employees_by_age(self, min_age, max_age): Lists all employees within a specified age range. :param min_age: Integer representing the minimum age :param max_age: Integer representing the maximum age :return: List of dictionaries containing employee details import pytest from solution import EmployeeInformationSystem def test_add_employee(): eis = EmployeeInformationSystem() eis.add_employee({\\"ID\\": 101, \\"name\\": \\"Alice\\", \\"age\\": 30}) assert eis.get_employee(101) == {\\"ID\\": 101, \\"name\\": \\"Alice\\", \\"age\\": 30} def test_add_employee_with_duplicate_id(): eis = EmployeeInformationSystem() eis.add_employee({\\"ID\\": 101, \\"name\\": \\"Alice\\", \\"age\\": 30}) with pytest.raises(ValueError, match='Employee ID must be unique'): eis.add_employee({\\"ID\\": 101, \\"name\\": \\"Bob\\", \\"age\\": 40}) def test_remove_employee(): eis = EmployeeInformationSystem() eis.add_employee({\\"ID\\": 101, \\"name\\": \\"Alice\\", \\"age\\": 30}) eis.remove_employee(101) assert eis.get_employee(101) == \\"Employee does not exist\\" def test_remove_non_existent_employee(): eis = EmployeeInformationSystem() with pytest.raises(ValueError, match='Employee ID not found'): eis.remove_employee(999) def test_get_non_existent_employee(): eis = EmployeeInformationSystem() assert eis.get_employee(999) == \\"Employee does not exist\\" def test_list_employees_by_age(): eis = EmployeeInformationSystem() eis.add_employee({\\"ID\\": 101, \\"name\\": \\"Alice\\", \\"age\\": 30}) eis.add_employee({\\"ID\\": 102, \\"name\\": \\"Bob\\", \\"age\\": 40}) eis.add_employee({\\"ID\\": 103, \\"name\\": \\"Charlie\\", \\"age\\": 25}) result = eis.list_employees_by_age(20, 35) expected = [{\\"ID\\": 101, \\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"ID\\": 103, \\"name\\": \\"Charlie\\", \\"age\\": 25}] assert result == expected def test_list_employees_by_age_no_match(): eis = EmployeeInformationSystem() eis.add_employee({\\"ID\\": 101, \\"name\\": \\"Alice\\", \\"age\\": 30}) eis.add_employee({\\"ID\\": 102, \\"name\\": \\"Bob\\", \\"age\\": 40}) eis.add_employee({\\"ID\\": 103, \\"name\\": \\"Charlie\\", \\"age\\": 25}) result = eis.list_employees_by_age(50, 60) expected = [] assert result == expected","solution":"class EmployeeInformationSystem: def __init__(self): self.employees = {} def add_employee(self, employee): Adds a new employee to the system. :param employee: Dictionary containing 'ID', 'name', and 'age' of the employee if employee['ID'] in self.employees: raise ValueError(\\"Employee ID must be unique\\") self.employees[employee['ID']] = employee def remove_employee(self, employee_id): Removes an employee from the system by their ID. :param employee_id: Integer representing the employee ID to remove if employee_id in self.employees: del self.employees[employee_id] else: raise ValueError(\\"Employee ID not found\\") def get_employee(self, employee_id): Retrieves an employee's details by their ID. :param employee_id: Integer representing the employee ID :return: Dictionary containing the employee details or a message if the employee does not exist return self.employees.get(employee_id, \\"Employee does not exist\\") def list_employees_by_age(self, min_age, max_age): Lists all employees within a specified age range. :param min_age: Integer representing the minimum age :param max_age: Integer representing the maximum age :return: List of dictionaries containing employee details return [emp for emp in self.employees.values() if min_age <= emp['age'] <= max_age]"},{"question":"class Node: def __init__(self, key): self.left = None self.right = None self.value = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): Insert a value into the BST. Args: key: integer value to be inserted. pass def _insert(self, node, key): pass def delete(self, key): Delete a value from the BST. Args: key: integer value to be deleted. pass def _delete(self, node, key): pass def _find_min(self, node): pass def search(self, key): Search for a value in the BST. Args: key: integer value to search for. Returns: True if the value exists, False otherwise. pass def _search(self, node, key): pass def inorder_traversal(self): Perform in-order traversal of the BST. Returns: A list of integers representing the in-order traversal. pass def _inorder(self, node, values): pass # Example Usage bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) bst.insert(12) bst.insert(18) print(bst.inorder_traversal()) # Outputs: [3, 5, 7, 10, 12, 15, 18] print(bst.search(7)) # Outputs: True print(bst.search(13)) # Outputs: False bst.delete(10) print(bst.inorder_traversal()) # Outputs: [3, 5, 7, 12, 15, 18]","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.value = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.value: if node.left: self._insert(node.left, key) else: node.left = Node(key) elif key > node.value: if node.right: self._insert(node.right, key) else: node.right = Node(key) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.value: node.left = self._delete(node.left, key) elif key > node.value: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._find_min(node.right) node.value = temp.value node.right = self._delete(node.right, temp.value) return node def _find_min(self, node): current = node while current.left: current = current.left return current def search(self, key): return self._search(self.root, key) def _search(self, node, key): if not node: return False if key == node.value: return True elif key < node.value: return self._search(node.left, key) else: return self._search(node.right, key) def inorder_traversal(self): values = [] self._inorder(self.root, values) return values def _inorder(self, node, values): if node: self._inorder(node.left, values) values.append(node.value) self._inorder(node.right, values)"},{"question":"def fib(n: int) -> int: Computes the n-th Fibonacci number using an iterative approach. Args: n (int): The position in the Fibonacci sequence (0 <= n <= 10,000). Returns: int: The n-th Fibonacci number. Examples: >>> fib(0) 0 >>> fib(1) 1 >>> fib(10) 55 >>> fib(100) 354224848179261915075","solution":"def fib(n: int) -> int: Computes the n-th Fibonacci number using an iterative approach. Args: n (int): The position in the Fibonacci sequence (0 <= n <= 10,000). Returns: int: The n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"import numpy as np def game_of_life(initial_grid: np.ndarray, steps: int) -> np.ndarray: Simulate the Game of Life for a specified number of steps. Args: initial_grid (np.ndarray): Initial grid state with cells marked as alive (1) or dead (0). steps (int): Number of steps to simulate. Returns: np.ndarray: Final grid state after simulation steps. pass def test_small_grid(): initial_grid = np.array([ [0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0] ]) expected_grid_after_1_step = np.array([ [0, 0, 0], [1, 0, 1], [0, 1, 1], [0, 1, 0] ]) result = game_of_life(initial_grid, 1) assert np.array_equal(result, expected_grid_after_1_step) def test_empty_grid(): initial_grid = np.zeros((4, 4)) expected_grid = np.zeros((4, 4)) result = game_of_life(initial_grid, 10) assert np.array_equal(result, expected_grid) def test_full_grid(): initial_grid = np.ones((3, 3)) expected_grid_after_1_step = np.array([ [1, 0, 1], [0, 0, 0], [1, 0, 1] ]) result = game_of_life(initial_grid, 1) assert np.array_equal(result, expected_grid_after_1_step) def test_block_pattern(): initial_grid = np.array([ [1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ]) expected_grid = initial_grid.copy() result = game_of_life(initial_grid, 10) assert np.array_equal(result, expected_grid) def test_blinker_pattern(): initial_grid = np.array([ [0, 1, 0], [0, 1, 0], [0, 1, 0] ]) expected_grid_after_1_step = np.array([ [0, 0, 0], [1, 1, 1], [0, 0, 0] ]) result = game_of_life(initial_grid, 1) assert np.array_equal(result, expected_grid_after_1_step) expected_grid_after_2_steps = np.array([ [0, 1, 0], [0, 1, 0], [0, 1, 0] ]) result = game_of_life(initial_grid, 2) assert np.array_equal(result, expected_grid_after_2_steps) def test_glider_pattern(): initial_grid = np.array([ [0, 1, 0, 0], [0, 0, 1, 0], [1, 1, 1, 0], [0, 0, 0, 0] ]) expected_grid_after_4_steps = np.array([ [0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 1, 1, 1] ]) result = game_of_life(initial_grid, 4) assert np.array_equal(result, expected_grid_after_4_steps)","solution":"import numpy as np def simulate_step(grid: np.ndarray) -> np.ndarray: Simulate one step in the Game of Life. m, n = grid.shape # Create a padded version of the grid to handle edge cells more easily padded_grid = np.pad(grid, pad_width=1, mode='constant', constant_values=0) # Create a copy of the grid to store the results new_grid = np.zeros_like(grid) # Iterate over each cell in the original grid for i in range(1, m + 1): for j in range(1, n + 1): # Extract the 3x3 neighborhood of the current cell neighborhood = padded_grid[i-1:i+2, j-1:j+2] # Count the number of alive cells around the current cell live_neighbors = np.sum(neighborhood) - padded_grid[i, j] # Apply the Game of Life rules if padded_grid[i, j] == 1 and (live_neighbors == 2 or live_neighbors == 3): new_grid[i-1, j-1] = 1 elif padded_grid[i, j] == 0 and live_neighbors == 3: new_grid[i-1, j-1] = 1 else: new_grid[i-1, j-1] = 0 return new_grid def game_of_life(initial_grid: np.ndarray, steps: int) -> np.ndarray: Simulate the Game of Life for a specified number of steps. current_grid = initial_grid.copy() for _ in range(steps): current_grid = simulate_step(current_grid) return current_grid"},{"question":"from typing import List, Tuple def schedule_tasks(num_tasks: int, dependencies: List[Tuple[int, int]]) -> List[int]: Schedules tasks based on their dependencies using topological sorting. Args: num_tasks: Number of tasks to schedule. dependencies: A list of tuples where each tuple (a, b) represents that task \`a\` must be completed before task \`b\`. Returns: A list of task indices in the order they should be completed. >>> schedule_tasks(4, [(1, 0), (2, 0), (3, 1), (3, 2)]) [3, 1, 2, 0] >>> schedule_tasks(4, [(1, 0), (0, 1)]) [] from solution import schedule_tasks def test_no_tasks(): assert schedule_tasks(0, []) == [] def test_no_dependencies(): assert schedule_tasks(3, []) == [0, 1, 2] assert schedule_tasks(1, []) == [0] def test_linear_dependencies(): assert schedule_tasks(4, [(0, 1), (1, 2), (2, 3)]) == [0, 1, 2, 3] def test_multiple_dependencies(): result = schedule_tasks(4, [(1, 0), (2, 0), (3, 1), (3, 2)]) assert result in [[0, 3, 2, 1], [0, 3, 1, 2], [3, 1, 2, 0], [3, 2, 1, 0], [0, 1, 2, 3]] def test_circular_dependency(): assert schedule_tasks(4, [(1, 0), (0, 1)]) == [] def test_complex_graph(): result = schedule_tasks(6, [(5, 0), (5, 2), (4, 0), (4, 1), (2, 3), (3, 1)]) possible_results = [ [4, 5, 0, 2, 3, 1], [4, 5, 2, 0, 3, 1], [5, 4, 0, 2, 3, 1], [5, 4, 2, 0, 3, 1], [5, 2, 4, 0, 3, 1], [4, 5, 0, 3, 2, 1], [4, 0, 5, 2, 3, 1], [4, 2, 5, 0, 3, 1], ] assert result in possible_results","solution":"from typing import List, Tuple from collections import defaultdict, deque def schedule_tasks(num_tasks: int, dependencies: List[Tuple[int, int]]) -> List[int]: # If no tasks, return an empty list if num_tasks == 0: return [] # Create a graph representation graph = defaultdict(list) in_degree = [0] * num_tasks # Build the graph and track in-degrees for prereq, task in dependencies: graph[prereq].append(task) in_degree[task] += 1 # Find all starting points (tasks with no prerequisites) queue = deque([i for i in range(num_tasks) if in_degree[i] == 0]) sorted_order = [] while queue: current = queue.popleft() sorted_order.append(current) # Process and reduce in-degrees of the neighboring tasks for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Check if we were able to process all tasks, if not, it's a circular dependency if len(sorted_order) == num_tasks: return sorted_order else: return []"},{"question":"from collections import defaultdict def average_department_salaries(employees: list[dict[str, str or int]]) -> dict[str, float]: Calculate the average salary for each department from the given list of employee records. Parameters: employees (list[dict]): List of employee records, each record contains 'name', 'department', and 'salary'. Returns: dict: Dictionary with department names as keys and average salaries as values. Examples: >>> employees1 = [ ... {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"salary\\": 120000}, ... {\\"name\\": \\"Bob\\", \\"department\\": \\"Engineering\\", \\"salary\\": 110000}, ... {\\"name\\": \\"Charlie\\", \\"department\\": \\"Sales\\", \\"salary\\": 90000}, ... {\\"name\\": \\"David\\", \\"department\\": \\"Sales\\", \\"salary\\": 87000}, ... {\\"name\\": \\"Eve\\", \\"department\\": \\"HR\\", \\"salary\\": 70000}, ... {\\"name\\": \\"Frank\\", \\"department\\": \\"Engineering\\", \\"salary\\": 105000} ... ] >>> average_department_salaries(employees1) {'Engineering': 111666.67, 'Sales': 88500.0, 'HR': 70000.0} >>> employees2 = [ ... {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"salary\\": 120000} ... ] >>> average_department_salaries(employees2) {'Engineering': 120000} >>> employees3 = [ ... {\\"name\\": \\"Alice\\", \\"salary\\": 120000}, ... {\\"name\\": \\"Bob\\", \\"department\\": \\"Engineering\\"}, ... {\\"department\\": \\"Engineering\\", \\"salary\\": 110000}, ... {\\"name\\": \\"Eve\\", \\"department\\": \\"HR\\", \\"salary\\": 70000} ... ] >>> average_department_salaries(employees3) {'HR': 70000, 'Engineering': 110000} >>> employees4 = [ ... {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"salary\\": \\"NaN\\"}, ... {\\"name\\": \\"Bob\\", \\"department\\": \\"Engineering\\", \\"salary\\": 110000}, ... {\\"name\\": \\"Eve\\", \\"department\\": \\"HR\\", \\"salary\\": 70000} ... ] >>> average_department_salaries(employees4) {'HR': 70000, 'Engineering': 110000} >>> average_department_salaries([]) {} pass","solution":"from collections import defaultdict def average_department_salaries(employees): Calculate the average salary for each department from the given list of employee records. Parameters: employees (list[dict]): List of employee records, each record contains 'name', 'department', and 'salary'. Returns: dict: Dictionary with department names as keys and average salaries as values. department_salaries = defaultdict(list) for employee in employees: try: department = employee['department'] salary = employee['salary'] if isinstance(salary, int): department_salaries[department].append(salary) except KeyError: pass # Ignore entries with missing 'department' or 'salary' average_salaries = { department: sum(salaries) / len(salaries) for department, salaries in department_salaries.items() } return average_salaries"},{"question":"def max_count(m: int, n: int, operations: list[tuple[int, int]]) -> int: Implement the function \`max_count\` that returns the count of the largest integers in the grid after performing all given operations on an m x n grid initialized with all zeros. Args: m (int): Number of rows of the grid. n (int): Number of columns of the grid. operations (list[tuple[int, int]]): Operations to be performed, where each tuple contains two integers representing the top-left corner to the subrectangle to be incremented. Returns: int: The count of the largest integers in the grid after all operations are completed. Examples: >>> max_count(3, 3, [(2, 2), (3, 3)]) 4 >>> max_count(3, 3, [(2, 2), (2, 2)]) 4 >>> max_count(3, 3, []) 9 >>> max_count(4, 4, [(1, 1)]) 1 >>> max_count(5, 5, [(1, 2), (3, 3), (2, 2)]) 4 # Your code here","solution":"def max_count(m: int, n: int, operations: list[tuple[int, int]]) -> int: if not operations: return m * n min_a = m min_b = n for a, b in operations: if a < min_a: min_a = a if b < min_b: min_b = b return min_a * min_b"},{"question":"def generate_ip_report(log: str) -> dict: Parse the given log file and generate a summary report based on the IP addresses and the number of times they accessed the server. >>> log = \\"192.168.1.1 2023-03-15 10:15:32n192.168.1.2 2023-03-15 10:17:42n192.168.1.1 2023-03-15 10:18:22n\\" >>> generate_ip_report(log) {'192.168.1.1': 2, '192.168.1.2': 1}","solution":"def generate_ip_report(log: str) -> dict: ip_count = {} lines = log.splitlines() for line in lines: ip, _ = line.split(maxsplit=1) if ip in ip_count: ip_count[ip] += 1 else: ip_count[ip] = 1 return ip_count"},{"question":"# Task: Summarize transactions by their type and calculate total count, # and amount for each type. def summarize_transactions(transactions: list) -> dict: Summarizes transactions by their type and calculates total count and amount for each type. Args: transactions (list): A list of transaction dictionaries with keys 'type' and 'amount'. Returns: dict: A dictionary summarizing the count and total amount of each transaction type. summary = {} for transaction in transactions: transaction_type = transaction['type'] amount = transaction['amount'] if transaction_type not in summary: summary[transaction_type] = {'count': 0, 'total_amount': 0.0} summary[transaction_type]['count'] += 1 summary[transaction_type]['total_amount'] += amount return summary Example: transactions = [ {'type': 'income', 'amount': 100.0}, {'type': 'expense', 'amount': 50.0}, {'type': 'income', 'amount': 200.0} ] summarize_transactions(transactions) # Expected Output: # {'income': {'count': 2, 'total_amount': 300.0}, 'expense': {'count': 1, 'total_amount': 50.0}} # Unit Tests def test_summarize_transactions_simple_case(): transactions = [ {'type': 'income', 'amount': 100.0}, {'type': 'expense', 'amount': 50.0}, {'type': 'income', 'amount': 200.0} ] result = summarize_transactions(transactions) assert result == { 'income': {'count': 2, 'total_amount': 300.0}, 'expense': {'count': 1, 'total_amount': 50.0} } def test_summarize_transactions_empty_list(): transactions = [] result = summarize_transactions(transactions) assert result == {} def test_summarize_transactions_negative_amounts(): transactions = [ {'type': 'income', 'amount': -100.0}, {'type': 'expense', 'amount': -50.0} ] result = summarize_transactions(transactions) assert result == { 'income': {'count': 1, 'total_amount': -100.0}, 'expense': {'count': 1, 'total_amount': -50.0} } def test_summarize_transactions_zero_amounts(): transactions = [ {'type': 'income', 'amount': 0.0}, {'type': 'expense', 'amount': 0.0}, {'type': 'income', 'amount': 0.0} ] result = summarize_transactions(transactions) assert result == { 'income': {'count': 2, 'total_amount': 0.0}, 'expense': {'count': 1, 'total_amount': 0.0} } def test_summarize_transactions_large_amounts(): transactions = [ {'type': 'income', 'amount': 1e10}, {'type': 'expense', 'amount': 1e9}, {'type': 'income', 'amount': 2e10} ] result = summarize_transactions(transactions) assert result == { 'income': {'count': 2, 'total_amount': 3e10}, 'expense': {'count': 1, 'total_amount': 1e9} }","solution":"def summarize_transactions(transactions): Summarizes transactions by their type and calculates total count and amount for each type. Args: transactions (list): A list of transaction dictionaries with keys 'type' and 'amount'. Returns: dict: A dictionary summarizing the count and total amount of each transaction type. summary = {} for transaction in transactions: transaction_type = transaction['type'] amount = transaction['amount'] if transaction_type not in summary: summary[transaction_type] = {'count': 0, 'total_amount': 0.0} summary[transaction_type]['count'] += 1 summary[transaction_type]['total_amount'] += amount return summary"},{"question":"class BankAccount: A class to handle basic account management functionalities for a financial application. Methods: deposit(amount: float): Adds the specified amount to the balance and records the transaction. withdraw(amount: float): Subtracts the specified amount from the balance if sufficient funds are available and records the transaction. Raises an exception if there are insufficient funds. get_balance() -> float: Returns the current balance. get_transactions() -> list: Returns a list of strings representing transaction records. def __init__(self, balance: float): Initialize the BankAccount with a balance. >>> account = BankAccount(100.0) >>> account.get_balance() 100.0 self.balance = balance self.transactions = [] def deposit(self, amount: float): Deposit a positive amount into the account and record the transaction. >>> account = BankAccount(100.0) >>> account.deposit(50.0) >>> account.get_balance() 150.0 >>> account.get_transactions() ['Deposit: 50.0'] pass def withdraw(self, amount: float): Withdraw a positive amount from the account, if sufficient funds are available. Raise an exception if there are insufficient funds. >>> account = BankAccount(100.0) >>> account.withdraw(30.0) >>> account.get_balance() 70.0 >>> account.get_transactions() ['Withdrawal: 30.0'] pass def get_balance(self) -> float: Return the current balance. >>> account = BankAccount(100.0) >>> account.get_balance() 100.0 return self.balance def get_transactions(self) -> list: Return the transaction records. >>> account = BankAccount(200.0) >>> account.deposit(100.0) >>> account.withdraw(50.0) >>> account.deposit(150.0) >>> account.get_transactions() ['Deposit: 100.0', 'Withdrawal: 50.0', 'Deposit: 150.0'] return self.transactions","solution":"class BankAccount: def __init__(self, balance: float): self.balance = balance self.transactions = [] def deposit(self, amount: float): if amount > 0: self.balance += amount self.transactions.append(f\\"Deposit: {amount}\\") else: raise ValueError(\\"Deposit amount must be positive\\") def withdraw(self, amount: float): if amount > 0: if self.balance >= amount: self.balance -= amount self.transactions.append(f\\"Withdrawal: {amount}\\") else: raise ValueError(\\"Insufficient funds\\") else: raise ValueError(\\"Withdrawal amount must be positive\\") def get_balance(self) -> float: return self.balance def get_transactions(self) -> list: return self.transactions"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def add(self, value: int) -> None: Adds a value to the binary tree according to the binary search tree property. if not self.root: self.root = TreeNode(value) else: self._add_recursive(self.root, value) def _add_recursive(self, node, value): if value < node.val: if node.left: self._add_recursive(node.left, value) else: node.left = TreeNode(value) else: if node.right: self._add_recursive(node.right, value) else: node.right = TreeNode(value) def max_depth(self) -> int: This method should return the maximum depth of the binary tree. >>> tree = BinaryTree() >>> tree.add(1) >>> tree.add(2) >>> tree.add(3) >>> tree.max_depth() 3 >>> tree = BinaryTree() >>> tree.add(5) >>> tree.add(4) >>> tree.add(6) >>> tree.add(2) >>> tree.max_depth() 3 >>> tree = BinaryTree() >>> tree.max_depth() 0","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def add(self, value: int) -> None: Adds a value to the binary tree according to the binary search tree property. if not self.root: self.root = TreeNode(value) else: self._add_recursive(self.root, value) def _add_recursive(self, node, value): if value < node.val: if node.left: self._add_recursive(node.left, value) else: node.left = TreeNode(value) else: if node.right: self._add_recursive(node.right, value) else: node.right = TreeNode(value) def max_depth(self) -> int: This method should return the maximum depth of the binary tree. def depth(node): if not node: return 0 else: left_depth = depth(node.left) right_depth = depth(node.right) return max(left_depth, right_depth) + 1 return depth(self.root)"},{"question":"from typing import List def find_shortest_path(adjacency_matrix: List[List[float]], start: int, end: int) -> List[int]: Finds the shortest path in a weighted directed graph represented by an adjacency matrix. Args: adjacency_matrix (List[List[float]]): A 2D list representing the weights of the edges in the graph. start (int): The index of the starting node. end (int): The index of the destination node. Returns: List[int]: The list of nodes representing the shortest path from the start node to the end node. Examples: >>> find_shortest_path([[0, 2, float('inf'), 1], [float('inf'), 0, 3, float('inf')], [float('inf'), float('inf'), 0, 1], [float('inf'), float('inf'), 1, 0]], 0, 2) [0, 3, 2] >>> find_shortest_path([[0, float('inf')], [float('inf'), 0]], 0, 1) [] import heapq def test_find_shortest_path_simple(): adjacency_matrix = [ [0, 2, float('inf'), 1], [float('inf'), 0, 3, float('inf')], [float('inf'), float('inf'), 0, 1], [float('inf'), float('inf'), 1, 0] ] assert find_shortest_path(adjacency_matrix, 0, 2) == [0, 3, 2] def test_find_shortest_path_no_path(): adjacency_matrix = [ [0, float('inf')], [float('inf'), 0] ] assert find_shortest_path(adjacency_matrix, 0, 1) == [] def test_find_shortest_path_single_node(): adjacency_matrix = [[0]] assert find_shortest_path(adjacency_matrix, 0, 0) == [0] def test_find_shortest_path_same_start_end(): adjacency_matrix = [ [0, 1, float('inf')], [1, 0, 1], [float('inf'), 1, 0] ] assert find_shortest_path(adjacency_matrix, 1, 1) == [1] def test_find_shortest_path_large_graph(): adjacency_matrix = [ [0, 1, 4, float('inf'), float('inf'), float('inf')], [1, 0, 4, 2, 7, float('inf')], [4, 4, 0, 3, float('inf'), float('inf')], [float('inf'), 2, 3, 0, 2, 1], [float('inf'), 7, float('inf'), 2, 0, 6], [float('inf'), float('inf'), float('inf'), 1, 6, 0] ] assert find_shortest_path(adjacency_matrix, 0, 5) == [0, 1, 3, 5] def test_find_shortest_path_disconnected_graph(): adjacency_matrix = [ [0, 1, float('inf')], [1, 0, float('inf')], [float('inf'), float('inf'), 0] ] assert find_shortest_path(adjacency_matrix, 0, 2) == []","solution":"from typing import List import heapq def find_shortest_path(adjacency_matrix: List[List[float]], start: int, end: int) -> List[int]: n = len(adjacency_matrix) dist = [float('inf')] * n prev = [-1] * n dist[start] = 0 priority_queue = [(0, start)] while priority_queue: current_dist, current_node = heapq.heappop(priority_queue) if current_dist > dist[current_node]: continue for neighbor in range(n): if adjacency_matrix[current_node][neighbor] != float('inf'): distance = current_dist + adjacency_matrix[current_node][neighbor] if distance < dist[neighbor]: dist[neighbor] = distance prev[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) path = [] current_node = end while current_node != -1: path.append(current_node) current_node = prev[current_node] path.reverse() if dist[end] == float('inf'): return [] return path"},{"question":"from typing import List def find_non_dominant(arr: List[int]) -> int: Find the first element that is not the most frequent (non-dominant) in the list. If all elements are equally frequent, return the first element. If the input list is empty, return None. >>> find_non_dominant([3, 1, 2, 2, 3, 3]) 1 >>> find_non_dominant([1, 1, 2, 2, 3]) 3 >>> find_non_dominant([1, 1, 1, 1, 1]) 1 >>> find_non_dominant([2, 2, 2, 3, 3, 4, 4]) 3 >>> find_non_dominant([]) None >>> find_non_dominant([7]) 7 def test_example_cases(): assert find_non_dominant([3, 1, 2, 2, 3, 3]) == 1 assert find_non_dominant([1, 1, 2, 2, 3]) == 3 assert find_non_dominant([1, 1, 1, 1, 1]) == 1 assert find_non_dominant([2, 2, 2, 3, 3, 4, 4]) == 3 assert find_non_dominant([]) == None assert find_non_dominant([7]) == 7 def test_additional_cases(): assert find_non_dominant([10, 20, 30, 10, 20, 20]) == 10 assert find_non_dominant([5, 5, 6, 7, 5]) == 6 assert find_non_dominant([4, 4, 2, 2, 2]) == 4 assert find_non_dominant([9, 9, 9, 9, 8, 8, 8]) == 8 assert find_non_dominant([1, 2, 3, 4, 5]) == 1","solution":"from typing import List from collections import Counter def find_non_dominant(arr: List[int]) -> int: if not arr: return None # Count the frequencies of elements in the list frequency = Counter(arr) # Find the maximum frequency max_freq = max(frequency.values()) # Iterate through the list and return the first element that is not the most frequent for num in arr: if frequency[num] != max_freq: return num return arr[0]"},{"question":"from typing import List def count_events_within_interval(events: List[str], start_time: str, end_time: str) -> int: Count the number of events that occurred within a specific time interval. Args: events (List[str]): A list of strings representing timestamps in \\"YYYY-MM-DD hh:mm:ss\\" format. start_time (str): A string representing the start of the interval in \\"YYYY-MM-DD hh:mm:ss\\" format. end_time (str): A string representing the end of the interval in \\"YYYY-MM-DD hh:mm:ss\\" format. Returns: int: The count of events within the given interval (inclusive). Examples: >>> events = [ ... \\"2023-10-01 12:30:45\\", ... \\"2023-10-01 12:45:00\\", ... \\"2023-10-02 14:00:00\\", ... \\"2023-10-03 10:15:20\\", ... \\"2023-10-04 08:30:10\\" ... ] >>> start_time = \\"2023-10-01 12:00:00\\" >>> end_time = \\"2023-10-02 15:00:00\\" >>> count_events_within_interval(events, start_time, end_time) 3 >>> events = [ ... \\"2023-10-01 12:00:00\\", ... \\"2023-10-02 15:00:00\\", ... \\"2023-10-02 16:00:00\\", ... ] >>> start_time = \\"2023-10-01 12:00:00\\" >>> end_time = \\"2023-10-02 15:00:00\\" >>> count_events_within_interval(events, start_time, end_time) 2","solution":"from typing import List from datetime import datetime def count_events_within_interval(events: List[str], start_time: str, end_time: str) -> int: start_dt = datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_dt = datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") count = 0 for event in events: event_dt = datetime.strptime(event, \\"%Y-%m-%d %H:%M:%S\\") if start_dt <= event_dt <= end_dt: count += 1 return count"},{"question":"from typing import List class LFUCache: LFUCache (Least Frequently Used Cache) data structure which supports efficient retrieval and insertion of elements based on their usage frequency. def __init__(self, capacity: int): Initializes the cache with a specified capacity. Args: capacity (int): The maximum capacity of the cache. pass def get(self, key: int) -> int: Returns the value of the key if the key exists in the cache. Otherwise, returns -1. This operation should update the usage frequency of the key. Args: key (int): The key to retrieve the value of. Returns: int: The value of the key, or -1 if the key does not exist. pass def put(self, key: int, value: int) -> None: Updates the value of the key if the key exists. Otherwise, adds the key-value pair to the cache. If the cache is at full capacity, it should remove the least frequently used element before inserting the new pair. This operation should update the usage frequency of the key. Args: key (int): The key to insert or update. value (int): The value to associate with the key. pass # Example Usage lfu = LFUCache(2) lfu.put(1, 1) lfu.put(2, 2) assert lfu.get(1) == 1 lfu.put(3, 3) assert lfu.get(2) == -1 assert lfu.get(3) == 3 lfu.put(4, 4) assert lfu.get(1) == -1 assert lfu.get(3) == 3 assert lfu.get(4) == 4","solution":"class LFUCache: def __init__(self, capacity: int): self.capacity = capacity self.min_freq = 0 self.key_to_val = {} self.key_to_freq = {} self.freq_to_keys = {} def _update_freq(self, key): freq = self.key_to_freq[key] self.key_to_freq[key] += 1 self.freq_to_keys[freq].remove(key) if not self.freq_to_keys[freq]: if freq == self.min_freq: self.min_freq += 1 del self.freq_to_keys[freq] new_freq = freq + 1 if new_freq not in self.freq_to_keys: self.freq_to_keys[new_freq] = set() self.freq_to_keys[new_freq].add(key) def get(self, key: int) -> int: if key not in self.key_to_val: return -1 self._update_freq(key) return self.key_to_val[key] def put(self, key: int, value: int) -> None: if self.capacity == 0: return if key in self.key_to_val: self.key_to_val[key] = value self._update_freq(key) return if len(self.key_to_val) >= self.capacity: lfu_key = next(iter(self.freq_to_keys[self.min_freq])) del self.key_to_val[lfu_key] del self.key_to_freq[lfu_key] self.freq_to_keys[self.min_freq].remove(lfu_key) if not self.freq_to_keys[self.min_freq]: del self.freq_to_keys[self.min_freq] self.key_to_val[key] = value self.key_to_freq[key] = 1 self.min_freq = 1 if 1 not in self.freq_to_keys: self.freq_to_keys[1] = set() self.freq_to_keys[1].add(key)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def has_cycle(head: ListNode) -> bool: Determines if the linked list has a cycle. :param head: head node of the linked list :return: True if there is a cycle, False otherwise >>> test_has_cycle_empty_list() >>> test_has_cycle_single_node_no_cycle() >>> test_has_cycle_two_nodes_no_cycle() >>> test_has_cycle_two_nodes_with_cycle() >>> test_has_cycle_multiple_nodes_no_cycle() >>> test_has_cycle_multiple_nodes_with_cycle() >>> test_has_cycle_long_list_with_cycle() >>> test_has_cycle_long_list_no_cycle() def test_has_cycle_empty_list(): assert not has_cycle(None) def test_has_cycle_single_node_no_cycle(): node = ListNode(1) assert not has_cycle(node) def test_has_cycle_two_nodes_no_cycle(): node1 = ListNode(1) node2 = ListNode(2) node1.next = node2 assert not has_cycle(node1) def test_has_cycle_two_nodes_with_cycle(): node1 = ListNode(1) node2 = ListNode(2) node1.next = node2 node2.next = node1 assert has_cycle(node1) def test_has_cycle_multiple_nodes_no_cycle(): node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node1.next = node2 node2.next = node3 node3.next = node4 assert not has_cycle(node1) def test_has_cycle_multiple_nodes_with_cycle(): node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node2 # Creates a cycle assert has_cycle(node1) def test_has_cycle_long_list_with_cycle(): nodes = [ListNode(i) for i in range(100)] for i in range(99): nodes[i].next = nodes[i + 1] nodes[-1].next = nodes[50] # Creates a cycle assert has_cycle(nodes[0]) def test_has_cycle_long_list_no_cycle(): nodes = [ListNode(i) for i in range(100)] for i in range(99): nodes[i].next = nodes[i + 1] assert not has_cycle(nodes[0])","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def has_cycle(head: ListNode) -> bool: Determines if the linked list has a cycle. :param head: head node of the linked list :return: True if there is a cycle, False otherwise if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True"},{"question":"import numpy as np def predict_user_rating( rating_matrix: np.ndarray, user_index: int, item_index: int, k: int ) -> float: Predicts the rating a user would give to a specific item based on the ratings of similar users. Args: rating_matrix: 2D ndarray of shape (u, i) representing the ratings given by u users to i items. If a rating is not available, it will be represented by zero. user_index: An integer representing the index of the target user in the rating matrix. item_index: An integer representing the index of the target item in the rating matrix. k: An integer representing the number of nearest neighbors (similar users) to consider. Returns: float: The predicted rating for the specified item by the specified user. # Function implementation goes here # Example usage of the function with a test case rating_matrix = np.array([ [5, 3, 0, 1], [4, 0, 0, 1], [1, 1, 0, 5], [1, 0, 0, 4], [0, 1, 5, 4] ]) user_index = 0 item_index = 2 k = 2 predicted_rating = predict_user_rating(rating_matrix, user_index, item_index, k) print(predicted_rating) # Expected output: a float value representing the predicted rating","solution":"import numpy as np def predict_user_rating(rating_matrix: np.ndarray, user_index: int, item_index: int, k: int) -> float: def cosine_similarity(user1, user2): Calculate the Cosine similarity between two users. norm_user1 = np.linalg.norm(user1) norm_user2 = np.linalg.norm(user2) if norm_user1 == 0 or norm_user2 == 0: return 0 return np.dot(user1, user2) / (norm_user1 * norm_user2) def get_k_nearest_neighbors(): Get indices and similarities of k nearest neighbors user_ratings = rating_matrix[user_index] similarities = [] for i in range(len(rating_matrix)): if i != user_index: sim = cosine_similarity(user_ratings, rating_matrix[i]) similarities.append((i, sim)) # Sorting by similarity and selecting k nearest neighbors similarities.sort(key=lambda x: x[1], reverse=True) return similarities[:k] nearest_neighbors = get_k_nearest_neighbors() numerator = 0 denominator = 0 for neighbor_index, similarity in nearest_neighbors: neighbor_rating = rating_matrix[neighbor_index][item_index] if neighbor_rating > 0: # Consider only non-zero ratings numerator += similarity * neighbor_rating denominator += similarity if denominator == 0: return 0.0 # If no neighbors rated the target item return numerator / denominator"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def merge_sort_linked_list(head: ListNode) -> ListNode: Sort a singly linked list using the merge sort algorithm. >>> def create_linked_list(arr): ... head = ListNode(arr[0]) if arr else None ... current = head ... for value in arr[1:]: ... current.next = ListNode(value) ... current = current.next ... return head >>> def linked_list_to_list(head): ... arr = [] ... current = head ... while current: ... arr.append(current.value) ... current = current.next ... return arr >>> head = create_linked_list([1, 2, 3, 4, 5]) >>> sorted_head = merge_sort_linked_list(head) >>> linked_list_to_list(sorted_head) [1, 2, 3, 4, 5] >>> head = create_linked_list([5, 4, 3, 2, 1]) >>> sorted_head = merge_sort_linked_list(head) >>> linked_list_to_list(sorted_head) [1, 2, 3, 4, 5] >>> head = create_linked_list([4, 2, 5, 1, 3]) >>> sorted_head = merge_sort_linked_list(head) >>> linked_list_to_list(sorted_head) [1, 2, 3, 4, 5] >>> head = merge_sort_linked_list(None) >>> linked_list_to_list(head) [] # Implement the merge sort algorithm for a linked list","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def find_middle(head): slow = head fast = head.next while fast and fast.next: slow = slow.next fast = fast.next.next return slow def merge_lists(l1, l2): dummy = ListNode() tail = dummy while l1 and l2: if l1.value < l2.value: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next tail.next = l1 if l1 else l2 return dummy.next def merge_sort_linked_list(head: ListNode) -> ListNode: if not head or not head.next: return head middle = find_middle(head) next_to_middle = middle.next middle.next = None left_side = merge_sort_linked_list(head) right_side = merge_sort_linked_list(next_to_middle) sorted_list = merge_lists(left_side, right_side) return sorted_list"},{"question":"class Member: def __init__(self, member_id: int, name: str, email: str): self.member_id = member_id self.name = name self.email = email self.borrowed_books = [] def add_borrowed_book(self, book_id: int): Add a book to the member's borrowed books list. def remove_borrowed_book(self, book_id: int): Remove a book from the member's borrowed books list. class Book: def __init__(self, book_id: int, title: str, author: str, genre: str): self.book_id = book_id self.title = title self.author = author self.genre = genre self.is_borrowed = False def mark_as_borrowed(self): Mark the book as borrowed. def mark_as_returned(self): Mark the book as returned. class Library: def __init__(self): self.members = {} self.books = {} self.metrics = { \\"borrowed_books_count\\": 0, \\"returned_books_count\\": 0, \\"total_members\\": 0, \\"total_books\\": 0 } def add_member(self, member: Member) -> None: Add a new member to the library. def add_book(self, book: Book) -> None: Add a new book to the library collection. def borrow_book(self, member_id: int, book_id: int) -> bool: Allow a member to borrow a book if available. def return_book(self, member_id: int, book_id: int) -> bool: Facilitate returning a borrowed book. def search_books_by_author(self, author: str) -> List[Book]: Search books by the given author. def get_performance_metrics(self): Get performance metrics of the library. import pytest def test_member_operations(): member = Member(1, \\"John Doe\\", \\"john@example.com\\") member.add_borrowed_book(101) assert 101 in member.borrowed_books member.remove_borrowed_book(101) assert 101 not in member.borrowed_books def test_book_operations(): book = Book(101, \\"Some Book\\", \\"Some Author\\", \\"Fiction\\") assert not book.is_borrowed book.mark_as_borrowed() assert book.is_borrowed book.mark_as_returned() assert not book.is_borrowed def test_library_operations(): library = Library() member_1 = Member(1, \\"Alice\\", \\"alice@example.com\\") library.add_member(member_1) member_2 = Member(2, \\"Bob\\", \\"bob@example.com\\") library.add_member(member_2) assert library.metrics[\\"total_members\\"] == 2 book_1 = Book(101, \\"Title A\\", \\"Author X\\", \\"Fiction\\") library.add_book(book_1) book_2 = Book(102, \\"Title B\\", \\"Author Y\\", \\"Non-Fiction\\") library.add_book(book_2) assert library.metrics[\\"total_books\\"] == 2 assert library.borrow_book(1, 101) == True assert book_1.is_borrowed == True assert 101 in member_1.borrowed_books assert library.return_book(1, 101) == True assert book_1.is_borrowed == False assert 101 not in member_1.borrowed_books books_by_author_x = library.search_books_by_author(\\"Author X\\") assert len(books_by_author_x) == 1 assert books_by_author_x[0].title == \\"Title A\\" metrics = library.get_performance_metrics() assert metrics[\\"borrowed_books_count\\"] == 1 assert metrics[\\"returned_books_count\\"] == 1 def test_exceptions(): library = Library() member = Member(1, \\"Alice\\", \\"alice@example.com\\") library.add_member(member) book = Book(101, \\"Title A\\", \\"Author X\\", \\"Fiction\\") library.add_book(book) with pytest.raises(Exception, match=\\"Book already borrowed or member has max borrowed books\\"): library.borrow_book(1, 101) library.borrow_book(1, 101) with pytest.raises(Exception, match=\\"Invalid member ID or book ID\\"): library.borrow_book(999, 101) library.borrow_book(1, 999) with pytest.raises(Exception, match=\\"Member already exists or maximum members reached\\"): library.add_member(member) with pytest.raises(Exception, match=\\"Book already exists or maximum books reached\\"): library.add_book(book)","solution":"from typing import List class Member: def __init__(self, member_id: int, name: str, email: str): self.member_id = member_id self.name = name self.email = email self.borrowed_books = [] def add_borrowed_book(self, book_id: int): if len(self.borrowed_books) < 5: self.borrowed_books.append(book_id) else: raise Exception(\\"Member has already borrowed the maximum number of books\\") def remove_borrowed_book(self, book_id: int): if book_id in self.borrowed_books: self.borrowed_books.remove(book_id) else: raise Exception(\\"Book not found in member's borrowed books\\") class Book: def __init__(self, book_id: int, title: str, author: str, genre: str): self.book_id = book_id self.title = title self.author = author self.genre = genre self.is_borrowed = False def mark_as_borrowed(self): if not self.is_borrowed: self.is_borrowed = True else: raise Exception(\\"Book is already borrowed\\") def mark_as_returned(self): if self.is_borrowed: self.is_borrowed = False else: raise Exception(\\"Book is not borrowed\\") class Library: def __init__(self): self.members = {} self.books = {} self.metrics = { \\"borrowed_books_count\\": 0, \\"returned_books_count\\": 0, \\"total_members\\": 0, \\"total_books\\": 0 } def add_member(self, member: Member) -> None: if member.member_id not in self.members and self.metrics[\\"total_members\\"] < 1000: self.members[member.member_id] = member self.metrics[\\"total_members\\"] += 1 else: raise Exception(\\"Member already exists or maximum members reached\\") def add_book(self, book: Book) -> None: if book.book_id not in self.books and self.metrics[\\"total_books\\"] < 10000: self.books[book.book_id] = book self.metrics[\\"total_books\\"] += 1 else: raise Exception(\\"Book already exists or maximum books reached\\") def borrow_book(self, member_id: int, book_id: int) -> bool: if member_id in self.members and book_id in self.books: member = self.members[member_id] book = self.books[book_id] if not book.is_borrowed and len(member.borrowed_books) < 5: member.add_borrowed_book(book_id) book.mark_as_borrowed() self.metrics[\\"borrowed_books_count\\"] += 1 return True else: raise Exception(\\"Book already borrowed or member has max borrowed books\\") else: raise Exception(\\"Invalid member ID or book ID\\") def return_book(self, member_id: int, book_id: int) -> bool: if member_id in self.members and book_id in self.books: member = self.members[member_id] book = self.books[book_id] if book.is_borrowed and book_id in member.borrowed_books: member.remove_borrowed_book(book_id) book.mark_as_returned() self.metrics[\\"returned_books_count\\"] += 1 return True else: raise Exception(\\"Book not borrowed or invalid return attempt\\") else: raise Exception(\\"Invalid member ID or book ID\\") def search_books_by_author(self, author: str) -> List[Book]: return [book for book in self.books.values() if book.author == author] def get_performance_metrics(self): return self.metrics"},{"question":"def remove_duplicates(arr: list) -> list: Remove duplicates from a list while maintaining the order of first occurrences. Parameters: arr (list): A list of integers. Returns: list: A new list with duplicates removed and order preserved. Raises: TypeError: If input is not a list or if list elements are not integers. >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([5, 5, 5, 5]) [5] >>> remove_duplicates([1, 2, 3, 4]) [1, 2, 3, 4] >>> remove_duplicates([]) [] >>> remove_duplicates([1, 'a', 2]) Traceback (most recent call last): ... TypeError: All elements in the list must be integers >>> remove_duplicates(\\"string\\") Traceback (most recent call last): ... TypeError: Expected a list as input","solution":"def remove_duplicates(arr): Remove duplicates from a list while maintaining the order of first occurrences. Parameters: arr (list): A list of integers. Returns: list: A new list with duplicates removed and order preserved. Raises: TypeError: If input is not a list or if list elements are not integers. if not isinstance(arr, list): raise TypeError(\\"Expected a list as input\\") if not all(isinstance(i, int) for i in arr): raise TypeError(\\"All elements in the list must be integers\\") seen = set() result = [] for item in arr: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"class PrimeFactorization: def __init__(self): pass def prime_factors(self, n: int) -> list: Efficiently compute the prime factors of a given integer. :param n: int - The number to factorize. :return: list - A list of prime factors in ascending order. >>> pf = PrimeFactorization() >>> pf.prime_factors(100) [2, 2, 5, 5] >>> pf.prime_factors(53) [53]","solution":"class PrimeFactorization: def __init__(self): pass def prime_factors(self, n: int) -> list: factors = [] # Deal with 2 separately to allow incrementing by 2 later while n % 2 == 0: factors.append(2) n //= 2 # Check odd factors from 3 onward factor = 3 max_factor = int(n**0.5) + 1 while factor <= max_factor: while n % factor == 0: factors.append(factor) n //= factor factor += 2 # Only test odd numbers max_factor = int(n**0.5) + 1 if n > 1: # If n is still a prime number greater than 2 factors.append(n) return factors if __name__ == \\"__main__\\": pf = PrimeFactorization() number = 100 factors = pf.prime_factors(number) print(f\\"Prime factors of {number} are: {' '.join(map(str, factors))}\\")"},{"question":"def compress(data: str) -> str: Run-Length Encoding compression algorithm implementation. Compresses the input string using run-length encoding. >>> compress('aaabbbbcc') 'a3b4c2' >>> compress('') '' >>> compress('a') 'a1' >>> compress('abcdef') 'a1b1c1d1e1f1' pass def decompress(data: str) -> str: Run-Length Encoding decompression algorithm implementation. Decompresses the run-length encoded string back to its original form. >>> decompress('a3b4c2') 'aaabbbbcc' >>> decompress('') '' >>> decompress('a1') 'a' >>> decompress('a1b1c1d1e1f1') 'abcdef' pass # Unit Tests def test_compress_empty_string(): assert compress('') == '' def test_compress_single_character(): assert compress('a') == 'a1' def test_compress_multiple_characters(): assert compress('aaabbbbcc') == 'a3b4c2' def test_compress_no_repeated_characters(): assert compress('abcdef') == 'a1b1c1d1e1f1' def test_decompress_empty_string(): assert decompress('') == '' def test_decompress_single_character(): assert decompress('a1') == 'a' def test_decompress_multiple_characters(): assert decompress('a3b4c2') == 'aaabbbbcc' def test_decompress_no_repeated_characters(): assert decompress('a1b1c1d1e1f1') == 'abcdef' def test_compress_decompress_consistency(): original = 'aaabbbbcc' assert decompress(compress(original)) == original","solution":"def compress(data: str) -> str: Run-Length Encoding compression algorithm implementation. if not data: return \\"\\" compressed = [] count = 1 length = len(data) for i in range(1, length): if data[i] == data[i-1]: count += 1 else: compressed.append(f\\"{data[i-1]}{count}\\") count = 1 compressed.append(f\\"{data[-1]}{count}\\") return ''.join(compressed) def decompress(data: str) -> str: Run-Length Encoding decompression algorithm implementation. if not data: return \\"\\" decompressed = [] length = len(data) i = 0 while i < length: char = data[i] count = 0 i += 1 while i < length and data[i].isdigit(): count = count * 10 + int(data[i]) i += 1 decompressed.append(char * count) return ''.join(decompressed)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class RangeSumBST: def __init__(self): self.root = None def insert(self, val: int): Inserts a new value into the BST. >>> bst = RangeSumBST() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(15) pass def range_sum(self, low: int, high: int) -> int: Computes the sum of node values within a specified range [low, high]. >>> bst = RangeSumBST() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(15) >>> bst.insert(3) >>> bst.insert(7) >>> bst.insert(18) >>> bst.range_sum(7, 15) 32 >>> bst.range_sum(5, 10) 22 pass import pytest def test_insert_and_range_sum(): bst = RangeSumBST() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) bst.insert(18) assert bst.range_sum(7, 15) == 32 assert bst.range_sum(5, 10) == 22 assert bst.range_sum(3, 18) == 58 assert bst.range_sum(16, 20) == 18 assert bst.range_sum(1, 2) == 0 def test_empty_tree(): bst = RangeSumBST() assert bst.range_sum(1, 10) == 0 def test_single_element_tree(): bst = RangeSumBST() bst.insert(10) assert bst.range_sum(5, 15) == 10 assert bst.range_sum(10, 10) == 10 assert bst.range_sum(11, 20) == 0 assert bst.range_sum(0, 9) == 0 def test_non_overlapping_range(): bst = RangeSumBST() for val in [8, 3, 10, 1, 6, 14, 4, 7, 13]: bst.insert(val) assert bst.range_sum(20, 30) == 0 def test_insert_duplicates(): bst = RangeSumBST() bst.insert(5) bst.insert(3) bst.insert(3) bst.insert(7) bst.insert(7) assert bst.range_sum(3, 7) == 15 # Only unique values are summed","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class RangeSumBST: def __init__(self): self.root = None def insert(self, val: int): if self.root is None: self.root = TreeNode(val) else: self._insert_recursive(self.root, val) def _insert_recursive(self, node: TreeNode, val: int): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert_recursive(node.left, val) elif val > node.val: if node.right is None: node.right = TreeNode(val) else: self._insert_recursive(node.right, val) def range_sum(self, low: int, high: int) -> int: return self._range_sum_recursive(self.root, low, high) def _range_sum_recursive(self, node: TreeNode, low: int, high: int) -> int: if node is None: return 0 total = 0 if low <= node.val <= high: total += node.val if node.val > low: total += self._range_sum_recursive(node.left, low, high) if node.val < high: total += self._range_sum_recursive(node.right, low, high) return total"},{"question":"from typing import List import numpy as np def sigmoid(z): Compute the sigmoid of z return 1 / (1 + np.exp(-z)) def logistic_regression_predict(train_scores: List[int], train_defaults: List[int], query_score: int) -> float: Predict the probability of default for a given credit score using logistic regression. >>> logistic_regression_predict( ... [600, 650, 700, 750, 800], ... [1, 0, 0, 0, 0], ... 675) ... 0 <= result <= 1 pass","solution":"from typing import List import numpy as np def sigmoid(z): Compute the sigmoid of z return 1 / (1 + np.exp(-z)) def logistic_regression_predict(train_scores: List[int], train_defaults: List[int], query_score: int) -> float: Predict the probability of default for a given credit score using logistic regression. # Convert lists to numpy arrays X = np.array(train_scores).reshape(-1, 1) y = np.array(train_defaults) # Adding intercept term (bias) to the features X = np.hstack([np.ones((X.shape[0], 1)), X]) # Initialize the weights weights = np.zeros(X.shape[1]) # Learning rate and number of iterations learning_rate = 0.01 num_iterations = 10000 # Gradient Descent to optimize weights for _ in range(num_iterations): predictions = sigmoid(np.dot(X, weights)) errors = y - predictions gradient = np.dot(X.T, errors) weights += learning_rate * gradient # Predict probability for query_score query_data = np.array([1, query_score]) query_prob = sigmoid(np.dot(query_data, weights)) return query_prob"},{"question":"import heapq class MedianFinder: def __init__(self): Initialize the MedianFinder with necessary data structures. self.min_heap = [] self.max_heap = [] def add_number(self, num: float) -> None: Add a number to the data set. Args: num (float): The number to be added. Example: >>> mf = MedianFinder() >>> mf.add_number(1.0) >>> mf.add_number(2.0) >>> mf.add_number(3.0) # No output for add_number method pass def find_median(self) -> float: Find and return the median of the current data set. Returns: float: The median of the current data set. Example: >>> mf = MedianFinder() >>> mf.add_number(1.0) >>> mf.find_median() 1.0 >>> mf.add_number(2.0) >>> mf.find_median() 1.5 >>> mf.add_number(3.0) >>> mf.find_median() 2.0 pass","solution":"import heapq class MedianFinder: def __init__(self): # Initialize min-heap and max-heap self.min_heap = [] self.max_heap = [] def add_number(self, num: float) -> None: # Add number to max_heap (negative values for max behavior) heapq.heappush(self.max_heap, -num) # Ensure max_heap's largest is not bigger than min_heap's smallest if self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0]): heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) # Balance the sizes of the heaps if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def find_median(self) -> float: if len(self.max_heap) > len(self.min_heap): return float(-self.max_heap[0]) else: return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"Given a class named SensorDataStream, implement the following methods: # \`__init__\` Implement the constructor method to initialize the sensor data stream manager with a given window size \`k\`. # \`add_reading\` Implement the \`add_reading\` method to add a new reading for a specific sensor. Each reading is composed of a \`sensor_id\`, a \`timestamp\`, and a \`value\`. # \`get_current_window\` Implement the \`get_current_window\` method to retrieve the list of readings in the current window for a specified sensor. Each reading should include the \`timestamp\` and \`value\`. # \`get_moving_average\` Implement the \`get_moving_average\` method to calculate and return the moving average of the readings within the current window for a specified sensor. Example: from solution import SensorDataStream def test_sensor_data_stream(): manager = SensorDataStream(3) # Test adding readings and getting current window manager.add_reading(1, 1617709952, 10.5) manager.add_reading(1, 1617709953, 12.0) manager.add_reading(1, 1617709954, 11.0) assert manager.get_current_window(1) == [(1617709952, 10.5), (1617709953, 12.0), (1617709954, 11.0)] # Test moving average assert manager.get_moving_average(1) == 11.166666666666666 # Adding another reading causing the oldest to be removed from the window manager.add_reading(1, 1617709955, 13.0) assert manager.get_current_window(1) == [(1617709953, 12.0), (1617709954, 11.0), (1617709955, 13.0)] assert manager.get_moving_average(1) == 12.0 # Test for another sensor manager.add_reading(2, 1617709956, 9.0) manager.add_reading(2, 1617709957, 8.0) manager.add_reading(2, 1617709958, 7.0) manager.add_reading(2, 1617709959, 6.0) assert manager.get_current_window(2) == [(1617709957, 8.0), (1617709958, 7.0), (1617709959, 6.0)] assert manager.get_moving_average(2) == 7.0 def test_sensor_data_stream_no_data(): manager = SensorDataStream(3) # Test moving average with no data assert manager.get_moving_average(1) == 0.0 # Test getting current window with no data assert manager.get_current_window(1) == []","solution":"from collections import defaultdict, deque from typing import List, Tuple class SensorDataStream: def __init__(self, k: int): Initializes the sensor data stream manager with a given window size k. self.k = k self.data = defaultdict(deque) def add_reading(self, sensor_id: int, timestamp: int, value: float) -> None: Adds a new reading for a specific sensor. if sensor_id not in self.data: self.data[sensor_id] = deque() sensor_window = self.data[sensor_id] if len(sensor_window) == self.k: sensor_window.popleft() sensor_window.append((timestamp, value)) def get_current_window(self, sensor_id: int) -> List[Tuple[int, float]]: Retrieves the list of readings in the current window for a specified sensor. if sensor_id in self.data: return list(self.data[sensor_id]) else: return [] def get_moving_average(self, sensor_id: int) -> float: Calculates and returns the moving average of the readings within the current window for a specified sensor. if sensor_id not in self.data or not self.data[sensor_id]: return 0.0 sensor_window = self.data[sensor_id] total = sum(value for timestamp, value in sensor_window) return total / len(sensor_window)"},{"question":"Create a function named \`count_unique_elements\` that returns the number of unique elements in a list. def count_unique_elements(lst: list) -> int: def count_unique_elements(lst: list) -> int: Returns the number of unique elements in the given list. Parameters: - lst (list of integers): The list in which you need to determine the number of unique elements. Returns: - int: The number of unique elements in the list. return len(set(lst))","solution":"def count_unique_elements(lst: list) -> int: Returns the number of unique elements in the given list. Parameters: - lst (list of integers): The list in which you need to determine the number of unique elements. Returns: - int: The number of unique elements in the list. return len(set(lst))"},{"question":"from typing import List, Tuple def update_leaderboard(leaderboard: List[Tuple[str, int]], player: str, new_score: int) -> List[Tuple[str, int]]: Update the leaderboard rankings when a player's new score is added. >>> update_leaderboard([(\\"Alice\\", 1500), (\\"Bob\\", 1800), (\\"Charlie\\", 1700)], \\"Alice\\", 1900) == [('Alice', 1900), ('Bob', 1800), ('Charlie', 1700)] >>> update_leaderboard([(\\"Alice\\", 1500), (\\"Bob\\", 1500), (\\"Charlie\\", 1500)], \\"Charlie\\", 1600) == [('Charlie', 1600), ('Alice', 1500), ('Bob', 1500)]","solution":"from typing import List, Tuple def update_leaderboard(leaderboard: List[Tuple[str, int]], player: str, new_score: int) -> List[Tuple[str, int]]: updated_leaderboard = [(name, new_score if name == player else score) for name, score in leaderboard] updated_leaderboard.sort(key=lambda x: (-x[1], x[0])) return updated_leaderboard"},{"question":"class FileSystem: An efficient in-memory file system. Methods: - mkdir(path: str) -> None: Create a directory at the given path. - create_file(path: str, content: str) -> None: Create a file at the given path with the specified content. - read_file(path: str) -> str: Read the content of the file at the given path. - write_file(path: str, content: str) -> None: Write content to the file at the given path. - list_dir(path: str) -> list[str]: List the contents of the directory at the given path. Example: >>> fs = FileSystem() >>> fs.mkdir(\\"/a/b/c\\") >>> fs.create_file(\\"/a/b/c/file1.txt\\", \\"Hello\\") >>> fs.write_file(\\"/a/b/c/file1.txt\\", \\"Hello, how are you?\\") >>> content = fs.read_file(\\"/a/b/c/file1.txt\\") >>> print(content) Hello, how are you? >>> listing = fs.list_dir(\\"/a/b\\") >>> print(listing) ['c'] def __init__(self): self.root = {} def mkdir(self, path: str) -> None: pass def create_file(self, path: str, content: str) -> None: pass def read_file(self, path: str) -> str: pass def write_file(self, path: str, content: str) -> None: pass def list_dir(self, path: str) -> list[str]: pass","solution":"class FileSystem: def __init__(self): self.root = {} def mkdir(self, path: str) -> None: nodes = path.strip('/').split('/') current = self.root for node in nodes: if node not in current: current[node] = {} current = current[node] def create_file(self, path: str, content: str) -> None: parts = path.strip('/').split('/') file_name = parts.pop() current = self.root for part in parts: if part not in current: current[part] = {} current = current[part] current[file_name] = content def read_file(self, path: str) -> str: parts = path.strip('/').split('/') file_name = parts.pop() current = self.root for part in parts: current = current[part] return current[file_name] def write_file(self, path: str, content: str) -> None: parts = path.strip('/').split('/') file_name = parts.pop() current = self.root for part in parts: current = current[part] current[file_name] = content def list_dir(self, path: str) -> list[str]: parts = path.strip('/').split('/') current = self.root for part in parts: current = current[part] return sorted(current.keys())"},{"question":"def left_rotate_array(arr: list, positions: int) -> list: Rotates the elements of an array to the left by the specified number of positions. Args: arr (list): The list of integers to be rotated. positions (int): The number of positions to rotate the list. Returns: list: The list rotated to the left by the specified number of positions. Examples: >>> left_rotate_array([1, 2, 3, 4, 5], 2) [3, 4, 5, 1, 2] >>> left_rotate_array([1, 2, 3], 4) [2, 3, 1] >>> left_rotate_array([], 3) [] >>> left_rotate_array([7], 5) [7] >>> left_rotate_array([5, 10, 15, 20], 0) [5, 10, 15, 20] >>> left_rotate_array([-1, -2, -3, -4, -5], 3) [-4, -5, -1, -2, -3]","solution":"def left_rotate_array(arr: list, positions: int) -> list: Rotates elements of a list to the left by a specified number of positions. Args: arr (list): The list of integers to be rotated. positions (int): The number of positions to rotate the list. Returns: list: The list rotated to the left by the specified number of positions. if not arr: return [] n = len(arr) positions = positions % n # handle cases where positions > len(arr) return arr[positions:] + arr[:positions]"},{"question":"class Library: A class to represent a library system that manages books. def __init__(self): Initialize an empty library. pass def add_book(self, book_id: int, title: str, author: str): Add a new book to the library. :param book_id: A unique integer identifier for the book. :param title: The title of the book. :param author: The author of the book. pass def search_books_by_title(self, title: str) -> list[dict]: Search for books by their title. :param title: The title to search for. :return: A list of dictionaries with keys 'id', 'title', and 'author' of matching books. pass def search_books_by_author(self, author: str) -> list[dict]: Search for books by their author. :param author: The author to search for. :return: A list of dictionaries with keys 'id', 'title', and 'author' of matching books. pass def borrow_book(self, book_id: int) -> bool: Borrow a book from the library. :param book_id: The unique identifier of the book to borrow. :return: True if the book was successfully borrowed, False if the book ID is not found. pass","solution":"class Library: A class to represent a library system that manages books. def __init__(self): Initialize an empty library. self.books = {} self.borrowed_books = set() def add_book(self, book_id: int, title: str, author: str): Add a new book to the library. :param book_id: A unique integer identifier for the book. :param title: The title of the book. :param author: The author of the book. if book_id not in self.books: self.books[book_id] = {'id': book_id, 'title': title, 'author': author} def search_books_by_title(self, title: str) -> list[dict]: Search for books by their title. :param title: The title to search for. :return: A list of dictionaries with keys 'id', 'title', and 'author' of matching books. return [book for book in self.books.values() if book['title'] == title] def search_books_by_author(self, author: str) -> list[dict]: Search for books by their author. :param author: The author to search for. :return: A list of dictionaries with keys 'id', 'title', and 'author' of matching books. return [book for book in self.books.values() if book['author'] == author] def borrow_book(self, book_id: int) -> bool: Borrow a book from the library. :param book_id: The unique identifier of the book to borrow. :return: True if the book was successfully borrowed, False if the book ID is not found or already borrowed. if book_id in self.books and book_id not in self.borrowed_books: self.borrowed_books.add(book_id) return True return False"},{"question":"from typing import List def parallel_matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiplies two matrices A and B in parallel. Parameters: A (List[List[int]]): A 2D list representing matrix A. B (List[List[int]]): A 2D list representing matrix B. Returns: List[List[int]]: The resultant matrix product of A and B. Example: >>> A = [ ... [1, 2], ... [3, 4] ... ] >>> B = [ ... [5, 6], ... [7, 8] ... ] >>> parallel_matrix_multiplication(A, B) [[19, 22], [43, 50]] pass # Test cases def test_parallel_matrix_multiplication_basic(): A = [ [1, 2], [3, 4] ] B = [ [5, 6], [7, 8] ] result = parallel_matrix_multiplication(A, B) expected = [ [19, 22], [43, 50] ] assert result == expected def test_parallel_matrix_multiplication_single_element(): A = [ [2] ] B = [ [3] ] result = parallel_matrix_multiplication(A, B) expected = [ [6] ] assert result == expected def test_parallel_matrix_multiplication_single_row(): A = [ [1, 2, 3] ] B = [ [4], [5], [6] ] result = parallel_matrix_multiplication(A, B) expected = [ [32] ] assert result == expected def test_parallel_matrix_multiplication_single_column(): A = [ [1], [2], [3] ] B = [ [4, 5, 6] ] result = parallel_matrix_multiplication(A, B) expected = [ [4, 5, 6], [8, 10, 12], [12, 15, 18] ] assert result == expected def test_parallel_matrix_multiplication_mismatched_dimensions(): A = [ [1, 2, 3] ] B = [ [4, 5] ] with pytest.raises(ValueError): parallel_matrix_multiplication(A, B)","solution":"from typing import List from multiprocessing import Pool def parallel_worker(args): A_row, B, col_idx = args value = sum(A_row[k] * B[k][col_idx] for k in range(len(A_row))) return value def parallel_matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: if not A or not B or not A[0] or not B[0]: return [] m, n = len(A), len(A[0]) n_b, p = len(B), len(B[0]) if n != n_b: raise ValueError(\\"Number of columns in A must be equal to the number of rows in B.\\") # Initialize result matrix result = [[0] * p for _ in range(m)] # Prepare arguments for parallel workers pool_args = [] for i in range(m): for j in range(p): pool_args.append((A[i], B, j)) # Use multiprocessing Pool for parallel computation with Pool() as pool: results = pool.map(parallel_worker, pool_args) # Fill the result matrix for idx, value in enumerate(results): i = idx // p j = idx % p result[i][j] = value return result"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverse a singly linked list. >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) >>> new_head = reverse_linked_list(head) >>> result = [] >>> while new_head: >>> result.append(new_head.val) >>> new_head = new_head.next >>> result [5, 4, 3, 2, 1] def detect_cycle(head: ListNode) -> bool: Detect if a cycle exists in a singly linked list. >>> node1 = ListNode(3) >>> node2 = ListNode(2) >>> node3 = ListNode(0) >>> node4 = ListNode(-4) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node4 >>> node4.next = node2 >>> detect_cycle(node1) True >>> node1 = ListNode(1, ListNode(2, ListNode(3))) >>> detect_cycle(node1) False def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted singly linked lists and return it as a sorted linked list. >>> l1 = ListNode(1, ListNode(2, ListNode(4))) >>> l2 = ListNode(1, ListNode(3, ListNode(4))) >>> merged_head = merge_two_sorted_lists(l1, l2) >>> result = [] >>> while merged_head: >>> result.append(merged_head.val) >>> merged_head = merged_head.next >>> result [1, 1, 2, 3, 4, 4] def remove_nth_from_end(head: ListNode, n: int) -> ListNode: Remove the nth node from the end of the linked list and return its head. >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) >>> new_head = remove_nth_from_end(head, 2) >>> result = [] >>> while new_head: >>> result.append(new_head.val) >>> new_head = new_head.next >>> result [1, 2, 3, 5] >>> head = ListNode(1) >>> new_head = remove_nth_from_end(head, 1) >>> new_head is None True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: prev = None curr = head while curr: next_node = curr.next curr.next = prev prev = curr curr = next_node return prev def detect_cycle(head: ListNode) -> bool: slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: dummy = ListNode() current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next current.next = l1 or l2 return dummy.next def remove_nth_from_end(head: ListNode, n: int) -> ListNode: dummy = ListNode(0, head) first = second = dummy for _ in range(n + 1): first = first.next while first: first = first.next second = second.next second.next = second.next.next return dummy.next"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_nth_from_end(head: ListNode | None, n: int) -> ListNode | None: Remove the nth node from the end of the list and return the head of the modified list. >>> head = from_list([1, 2, 3, 4, 5]) >>> new_head = remove_nth_from_end(head, 2) >>> to_list(new_head) [1, 2, 3, 5] >>> head = from_list([1]) >>> new_head = remove_nth_from_end(head, 1) >>> to_list(new_head) [] >>> head = from_list([1, 2]) >>> new_head = remove_nth_from_end(head, 1) >>> to_list(new_head) [1] >>> head = from_list([1, 2]) >>> new_head = remove_nth_from_end(head, 2) >>> to_list(new_head) [2] pass def reverse_linked_list(head: ListNode | None) -> ListNode | None: Reverse the entire linked list and return the head of the reversed list. >>> head = from_list([1, 2, 3, 4, 5]) >>> reversed_head = reverse_linked_list(head) >>> to_list(reversed_head) [5, 4, 3, 2, 1] >>> head = from_list([1]) >>> reversed_head = reverse_linked_list(head) >>> to_list(reversed_head) [1] >>> head = from_list([1, 2]) >>> reversed_head = reverse_linked_list(head) >>> to_list(reversed_head) [2, 1] pass def to_list(head: ListNode | None) -> list: Helper function to convert a linked list to a Python list result = [] current = head while current: result.append(current.val) current = current.next return result def from_list(values: list) -> ListNode | None: Helper function to convert a Python list to a linked list dummy = ListNode() current = dummy for val in values: current.next = ListNode(val) current = current.next return dummy.next","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_nth_from_end(head: ListNode | None, n: int) -> ListNode | None: dummy = ListNode(0, head) first = dummy second = dummy # Move first pointer n+1 steps ahead for _ in range(n + 1): first = first.next # Move both first and second pointers while first: first = first.next second = second.next # Remove the nth node from end second.next = second.next.next return dummy.next def reverse_linked_list(head: ListNode | None) -> ListNode | None: prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev def to_list(head: ListNode | None) -> list: Helper function to convert a linked list to a Python list result = [] current = head while current: result.append(current.val) current = current.next return result def from_list(values: list) -> ListNode | None: Helper function to convert a Python list to a linked list dummy = ListNode() current = dummy for val in values: current.next = ListNode(val) current = current.next return dummy.next"},{"question":"from typing import List def max_area_of_island(grid: List[List[int]]) -> int: Identify the maximum area of an island in the grid. >>> grid = [ ... [0,0,1,0,0,0,0,1,0,0,0,0,0], ... [0,0,0,0,0,0,0,1,1,1,0,0,0], ... [0,1,1,0,1,0,0,0,0,0,0,0,0], ... [0,1,0,0,1,1,0,0,1,0,1,0,0], ... [0,1,0,0,1,1,0,0,1,1,1,0,0], ... [0,0,0,0,0,0,0,0,0,0,1,0,0], ... [0,0,0,0,0,0,0,1,1,1,0,0,0], ... [0,0,0,0,0,0,0,1,1,0,0,0,0] ... ] >>> max_area_of_island(grid) 6 >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> max_area_of_island(grid) 0 >>> grid = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> max_area_of_island(grid) 9 pass def test_no_island(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert max_area_of_island(grid) == 0 def test_one_big_island(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert max_area_of_island(grid) == 9 def test_multiple_islands(): grid = [ [0, 1, 0], [1, 0, 1], [0, 1, 0] ] assert max_area_of_island(grid) == 1 def test_example_case(): grid = [ [0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0] ] assert max_area_of_island(grid) == 6 def test_single_cell_island(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert max_area_of_island(grid) == 1 def test_islands_with_diff_size(): grid = [ [1, 0, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0], [1, 0, 1, 0, 1, 1] ] assert max_area_of_island(grid) == 3","solution":"from typing import List def max_area_of_island(grid: List[List[int]]) -> int: # DFS method to explore the island def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark the cell as visited by setting it to 0 area = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: area += dfs(x + dx, y + dy) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"from typing import List, Tuple def find_notification_order(events: int, dependencies: List[Tuple[int, int]]) -> List[int]: Perform a topological sort to determine one possible order of event notifications. Parameters: events (int): The total number of events. dependencies (List[Tuple[int, int]]): A list of tuples where each tuple (a, b) represents that event 'a' needs to be notified before event 'b'. Returns: List[int]: A list of integers representing one of the possible valid sequences of event notification order. Examples: >>> find_notification_order(4, [(0, 1), (1, 2), (2, 3), (1, 3)]) [0, 1, 2, 3] >>> find_notification_order(3, [(1, 0), (2, 0)]) [1, 2, 0]","solution":"from typing import List, Tuple from collections import deque, defaultdict def find_notification_order(events: int, dependencies: List[Tuple[int, int]]) -> List[int]: Perform a topological sort to determine one possible order of event notifications. Parameters: events (int): The total number of events. dependencies (List[Tuple[int, int]]): A list of tuples where each tuple (a, b) represents that event 'a' needs to be notified before event 'b'. Returns: List[int]: A list of integers representing one of the possible valid sequences of event notification order. # Initialize graph and in-degree dictionary graph = defaultdict(list) in_degree = {i: 0 for i in range(events)} # Build the graph and in-degree dictionary for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 # Find all nodes with no incoming edges (in-degree 0) queue = deque([node for node in in_degree if in_degree[node] == 0]) result = [] while queue: node = queue.popleft() result.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(result) != events: return [] # In case there is a cycle, but the problem guarantees it's a DAG return result"},{"question":"def convert_to_title(column_number: int) -> str: Converts a given integer to its corresponding column title as it appears in an Excel sheet. Args: column_number (int): The column number to be converted. Returns: str: The corresponding column title. Examples: >>> convert_to_title(1) 'A' >>> convert_to_title(28) 'AB' >>> convert_to_title(701) 'ZY' >>> convert_to_title(702) 'ZZ' >>> convert_to_title(703) 'AAA'","solution":"def convert_to_title(column_number: int) -> str: Converts a given integer to its corresponding column title as it appears in an Excel sheet. Args: column_number (int): The column number to be converted. Returns: str: The corresponding column title. result = [] while column_number > 0: column_number -= 1 result.append(chr(column_number % 26 + ord('A'))) column_number //= 26 return ''.join(result[::-1])"},{"question":"def encode_morse(message: str) -> str: Encode a given string into its Morse code equivalent. Morse code is a method used in telecommunication to encode text characters as standardized sequences of two different signal durations, dots and dashes. Each Morse code letter or digit should be separated by a single space. There should be a triple space between Morse codes of separate words. 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.'. Example: >>> encode_morse(\\"HELLO WORLD\\") \\".... . .-.. .-.. --- .-- --- .-. .-.. -..\\" >>> encode_morse(\\"123\\") \\".---- ..--- ...--\\" pass","solution":"def encode_morse(message: str) -> str: morse_code = { 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.' } encoded_message = [] words = message.split(' ') for word in words: encoded_word = ' '.join(morse_code[char.upper()] for char in word) encoded_message.append(encoded_word) return ' '.join(encoded_message)"},{"question":"def calculate_power(base: int, exponent: int) -> int: Calculate the power of a number using exponentiation by squaring. Arguments: base -- the base number (integer) exponent -- the exponent (non-negative integer) Returns: result of base raised to the power of exponent (integer) Raises: ValueError -- if exponent is negative Examples: >>> calculate_power(2, 3) 8 >>> calculate_power(5, 4) 625 >>> calculate_power(3, 0) 1 >>> calculate_power(10, 5) 100000 >>> calculate_power(2, -1) Traceback (most recent call last): ... ValueError: Exponent must be a non-negative integer def test_calculate_power_positive_exponents(): assert calculate_power(2, 3) == 8 assert calculate_power(5, 4) == 625 assert calculate_power(10, 5) == 100000 def test_calculate_power_zero_exponent(): assert calculate_power(2, 0) == 1 assert calculate_power(100, 0) == 1 def test_calculate_power_one_exponent(): assert calculate_power(2, 1) == 2 assert calculate_power(3, 1) == 3 def test_calculate_power_base_one(): assert calculate_power(1, 100) == 1 assert calculate_power(1, 0) == 1 def test_calculate_power_large_exponent(): assert calculate_power(2, 10) == 1024 assert calculate_power(3, 5) == 243 def test_calculate_power_negative_exponent(): try: calculate_power(2, -1) except ValueError as e: assert str(e) == \\"Exponent must be a non-negative integer\\" else: assert False, \\"Expected ValueError not raised.\\"","solution":"def calculate_power(base, exponent): Calculate the power of a number using exponentiation by squaring. Arguments: base -- the base number (integer) exponent -- the exponent (non-negative integer) Returns: result of base raised to the power of exponent (integer) Raises: ValueError -- if exponent is negative if exponent < 0: raise ValueError(\\"Exponent must be a non-negative integer\\") result = 1 current_base = base current_exponent = exponent while current_exponent > 0: if (current_exponent % 2) == 1: # If the exponent is odd result *= current_base current_base *= current_base current_exponent //= 2 return result"},{"question":"from typing import List def generate_palindromic_permutations(s: str) -> List[str]: Find all possible combinations of a given string's characters that can be rearranged into palindromes. Args: s (str): A string consisting of lowercase letters. Returns: List[str]: List of all unique palindromic permutations of the string, sorted in lexicographical order. An empty list if no palindromic permutation exists. Examples: >>> generate_palindromic_permutations(\\"aabb\\") [\\"abba\\", \\"baab\\"] >>> generate_palindromic_permutations(\\"abc\\") [] >>> generate_palindromic_permutations(\\"a\\") [\\"a\\"] >>> generate_palindromic_permutations(\\"aaa\\") [\\"aaa\\"]","solution":"from collections import Counter def generate_palindromic_permutations(s): def can_form_palindrome(s): count = Counter(s) odd_count = sum(1 for v in count.values() if v % 2 != 0) return odd_count <= 1 def generate_half_permutations(half): perm = [] def backtrack(path, counter): if len(path) == len(half): perm.append(\\"\\".join(path)) return for char in sorted(counter.keys()): # Sort to ensure lexicographic order if counter[char] > 0: path.append(char) counter[char] -= 1 backtrack(path, counter) path.pop() counter[char] += 1 backtrack([], Counter(half)) return perm if not can_form_palindrome(s): return [] char_counter = Counter(s) middle = [char for char, count in char_counter.items() if count % 2 != 0] half = [char * (count // 2) for char, count in char_counter.items()] half = \\"\\".join(half) half_permutations = generate_half_permutations(half) palindromic_permutations = [ perm + \\"\\".join(middle) + perm[::-1] for perm in half_permutations ] return palindromic_permutations"},{"question":"from typing import List def get_unique_elements(lst: List[int]) -> List[int]: Given a list of integers, return a list of the unique elements in the order they first appear in the input list. >>> get_unique_elements([1, 2, 2, 3, 4, 3, 5]) [1, 2, 3, 4, 5] >>> get_unique_elements([7, 8, 8, 8, 9, 7]) [7, 8, 9] >>> get_unique_elements([]) [] >>> get_unique_elements([1, 1, 1, 1, 1, 1, 1]) [1] >>> get_unique_elements([-1, -2, -2, -1, 0, 1, 0, 1, 2]) [-1, -2, 0, 1, 2]","solution":"from typing import List def get_unique_elements(lst: List[int]) -> List[int]: seen = set() unique_elements = [] for num in lst: if num not in seen: seen.add(num) unique_elements.append(num) return unique_elements"},{"question":"def combinatorial_sum(n: int, k: int) -> int: Calculate the sum of binomial coefficients from C(n, 0) to C(n, k). Args: n (int): The upper index of the binomial coefficient. k (int): The lower limit up to which we calculate the sum of binomial coefficients. Returns: int: The sum of binomial coefficients from C(n, 0) to C(n, k). >>> combinatorial_sum(5, 2) 16 >>> combinatorial_sum(10, 0) 1 >>> combinatorial_sum(7, 7) 128 >>> combinatorial_sum(6, 3) 42 >>> combinatorial_sum(0, 0) 1 >>> combinatorial_sum(4, 4) 16 >>> combinatorial_sum(1000, 0) 1","solution":"def combinatorial_sum(n, k): Calculate the sum of binomial coefficients from C(n, 0) to C(n, k). Args: n (int): The upper index of the binomial coefficient. k (int): The lower limit up to which we calculate the sum of binomial coefficients. Returns: int: The sum of binomial coefficients from C(n, 0) to C(n, k). # Using mathematical property: Sum of binomial coefficients from C(n, 0) to C(n, k) can be computed using Pascal's Identity. # P(n, k) = P(n-1, k-1) + P(n-1, k) # Pascal's triangle is used here for building the binomial coefficients row C = [0] * (k + 1) C[0] = 1 # C(n, 0) is always 1 for any n for i in range(1, n + 1): for j in range(min(i, k), 0, -1): C[j] = C[j] + C[j - 1] if i <= k: C[i] = 1 return sum(C)"},{"question":"from typing import List def max_fishermans_profit(profits: List[int]) -> int: Given a list of profit values for a series of fishing spots along a linear river bank, find the maximum profit a fisherman can earn without fishing in two adjacent spots. Args: profits (List[int]): A list of integers representing the profit of fishing at each spot. Returns: int: The maximum profit achievable without fishing two adjacent spots. Examples: >>> max_fishermans_profit([]) 0 >>> max_fishermans_profit([3]) 3 >>> max_fishermans_profit([3, 2, 5, 10, 7]) 15 >>> max_fishermans_profit([0, 0, 0]) 0 >>> max_fishermans_profit([-1, -2, -3, -4]) 0 >>> max_fishermans_profit([10, -1, -1, 10, -1, -1, 10]) 30 pass","solution":"from typing import List def max_fishermans_profit(profits: List[int]) -> int: if len(profits) == 0: return 0 if len(profits) == 1: return max(0, profits[0]) n = len(profits) dp = [0] * n dp[0] = max(0, profits[0]) if n > 1: dp[1] = max(dp[0], profits[1]) for i in range(2, n): dp[i] = max(dp[i-1], profits[i] + dp[i-2]) return dp[-1]"},{"question":"def fit_knn_model(features: list[list[float]], labels: list[int], k: int) -> dict: Fits a KNN model. :param features: List[List[float]]: The feature vectors. :param labels: List[int]: The corresponding labels. :param k: int: The number of neighbors to consider. :return: dict: The model containing the features, labels, and k value. >>> features = [ ... [5.1, 3.5], ... [4.9, 3.0], ... [7.0, 3.2], ... [6.4, 3.2], ... ] >>> labels = [0, 0, 1, 1] >>> k = 3 >>> fit_knn_model(features, labels, k) == { ... \\"features\\": features, \\"labels\\": labels, \\"k\\": k ... } True pass def predict_instances(unknown_features: list[list[float]], model: dict) -> list[int]: Predicts the labels for unknown instances using the KNN model. :param unknown_features: List[List[float]]: The features of unknown instances. :param model: dict: The fitted model. :return: List[int]: The predicted labels. >>> features = [ ... [5.1, 3.5], ... [4.9, 3.0], ... [7.0, 3.2], ... [6.4, 3.2], ... ] >>> labels = [0, 0, 1, 1] >>> k = 3 >>> model = fit_knn_model(features, labels, k) >>> unknown_features = [ ... [4.7, 3.2], ... [6.6, 3.0] ... ] >>> predict_instances(unknown_features, model) == [0, 1] True pass def calculate_accuracy(actual_labels: list[int], predicted_labels: list[int]) -> float: Calculates accuracy of the predictions. :param actual_labels: List[int]: The actual labels. :param predicted_labels: List[int]: The predicted labels. :return: float: The accuracy percentage. >>> actual_labels = [0, 1] >>> predicted_labels = [0, 1] >>> calculate_accuracy(actual_labels, predicted_labels) == 100.0 True >>> actual_labels = [0, 1, 1, 0] >>> predicted_labels = [0, 0, 1, 1] >>> calculate_accuracy(actual_labels, predicted_labels) == 50.0 True pass","solution":"import math from collections import Counter def fit_knn_model(features, labels, k): Fits a KNN model. :param features: List[List[float]]: The feature vectors. :param labels: List[int]: The corresponding labels. :param k: int: The number of neighbors to consider. :return: dict: The model containing the features, labels, and k value. return { \\"features\\": features, \\"labels\\": labels, \\"k\\": k } def euclidean_distance(point1, point2): Calculates the Euclidean distance between two points. :param point1: List[float]: The first point. :param point2: List[float]: The second point. :return: float: The Euclidean distance between the two points. return math.sqrt(sum((x - y) ** 2 for x, y in zip(point1, point2))) def predict_instances(unknown_features, model): Predicts the labels for unknown instances using the KNN model. :param unknown_features: List[List[float]]: The features of unknown instances. :param model: dict: The fitted model. :return: List[int]: The predicted labels. features = model[\\"features\\"] labels = model[\\"labels\\"] k = model[\\"k\\"] predictions = [] for unknown_feature in unknown_features: # Calculate distances to all known points distances = [(euclidean_distance(unknown_feature, feature), label) for feature, label in zip(features, labels)] # Sort based on distance and get the k nearest neighbors k_nearest_neighbors = sorted(distances, key=lambda x: x[0])[:k] # Get the most common label among the neighbors k_nearest_labels = [label for _, label in k_nearest_neighbors] most_common_label = Counter(k_nearest_labels).most_common(1)[0][0] predictions.append(most_common_label) return predictions def calculate_accuracy(actual_labels, predicted_labels): Calculates accuracy of the predictions. :param actual_labels: List[int]: The actual labels. :param predicted_labels: List[int]: The predicted labels. :return: float: The accuracy percentage. correct_predictions = sum(a == p for a, p in zip(actual_labels, predicted_labels)) return (correct_predictions / len(actual_labels)) * 100"},{"question":"from typing import List, Dict def shortest_path_bfs(graph: Dict[str, List[str]], start: str, end: str) -> List[str]: Finds the shortest path between two nodes using the Breadth-First Search (BFS) algorithm. >>> shortest_path_bfs({\\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"A\\", \\"D\\"], \\"C\\": [\\"A\\"], \\"D\\": [\\"B\\"]}, \\"A\\", \\"D\\") ['A', 'B', 'D'] >>> shortest_path_bfs({\\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"A\\", \\"D\\"], \\"C\\": [\\"A\\"], \\"D\\": [\\"B\\"]}, \\"A\\", \\"C\\") ['A', 'C'] >>> shortest_path_bfs({\\"A\\": [\\"B\\"], \\"B\\": [\\"A\\"]}, \\"A\\", \\"C\\") [] >>> shortest_path_bfs({\\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"A\\", \\"C\\"], \\"C\\": [\\"A\\", \\"B\\"]}, \\"A\\", \\"B\\") ['A', 'B'] >>> shortest_path_bfs({\\"A\\": []}, \\"A\\", \\"A\\") ['A'] >>> shortest_path_bfs({\\"A\\": [\\"B\\"], \\"B\\": [\\"A\\", \\"C\\"], \\"C\\": [\\"B\\", \\"D\\"], \\"D\\": [\\"C\\"]}, \\"A\\", \\"D\\") ['A', 'B', 'C', 'D'] def validate_graph(graph: Dict[str, List[str]]) -> bool: Validates the structure of the graph to ensure it is properly formatted. >>> validate_graph({\\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"A\\", \\"D\\"], \\"C\\": [\\"A\\"], \\"D\\": [\\"B\\"]}) True >>> validate_graph({\\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"A\\", 2], \\"C\\": [\\"A\\"], \\"D\\": [\\"B\\"]}) False >>> validate_graph({\\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"A\\"], \\"C\\": [\\"A\\"], \\"D\\": \\"B\\"}) False","solution":"from collections import deque def shortest_path_bfs(graph, start, end): Finds the shortest path between two nodes using BFS algorithm. if start not in graph or end not in graph: return [] queue = deque([[start]]) visited = set([start]) while queue: path = queue.popleft() node = path[-1] if node == end: return path for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) new_path = list(path) new_path.append(neighbor) queue.append(new_path) return [] def validate_graph(graph): Validates the graph structure to ensure all values are lists of strings that contain valid nodes. if not isinstance(graph, dict) or not all(isinstance(v, list) for v in graph.values()): return False nodes = set(graph.keys()) for neighbors in graph.values(): if not all(isinstance(neighbor, str) and neighbor in nodes for neighbor in neighbors): return False return True"},{"question":"def min_window_subsequence(S: str, T: str) -> str: Find the minimum window in S which contains all characters in order in T. Args: S (str): The source string containing only lowercase English letters. T (str): The target string containing only lowercase English letters. Returns: str: The minimum window in S which contains all characters in order in T or an empty string if no such window exists. Examples: >>> min_window_subsequence(\\"abcdebdde\\", \\"bde\\") \\"bcde\\" >>> min_window_subsequence(\\"jmeqksfrsdcmsiwvaovztaqenprpvnbstl\\", \\"k\\") \\"k\\" >>> min_window_subsequence(\\"abdec\\", \\"ec\\") \\"ec\\" >>> min_window_subsequence(\\"abc\\", \\"xyz\\") \\"\\" >>> min_window_subsequence(\\"\\", \\"a\\") \\"\\" pass","solution":"def min_window_subsequence(S: str, T: str) -> str: m, n = len(S), len(T) dp = [[-1] * n for _ in range(m)] # Base case for the first character of T for i in range(m): if S[i] == T[0]: dp[i][0] = i # Fill the dp array for j in range(1, n): prev = -1 for i in range(m): if prev != -1 and S[i] == T[j]: dp[i][j] = prev if dp[i][j - 1] != -1: prev = dp[i][j - 1] # Find the minimum window min_len = float('inf') start_index = -1 for i in range(m): if dp[i][n - 1] != -1: if i - dp[i][n - 1] + 1 < min_len: min_len = i - dp[i][n - 1] + 1 start_index = dp[i][n - 1] return \\"\\" if start_index == -1 else S[start_index:start_index + min_len]"},{"question":"def reverse_words(sentence: str) -> str: Reverse the words in a sentence while maintaining their original capitalization. Each word in the sentence should be reversed individually while maintaining its original case. Punctuation marks attached to words should remain at the same positions relative to those words. >>> reverse_words(\\"Hello, World!\\") == \\",olleH !dlroW\\" >>> reverse_words(\\"Python3.8 rocks!\\") == \\"8.3nohtyP !skcor\\" pass def test_reverse_single_word(): assert reverse_words(\\"Hello\\") == \\"olleH\\" assert reverse_words(\\"World!\\") == \\"!dlroW\\" assert reverse_words(\\"Python3.8\\") == \\"8.3nohtyP\\" def test_reverse_multiple_words(): assert reverse_words(\\"Hello, World!\\") == \\",olleH !dlroW\\" assert reverse_words(\\"Python3.8 rocks!\\") == \\"8.3nohtyP !skcor\\" def test_reverse_sentence(): assert reverse_words(\\"This is a Test-Sentence.\\") == \\"sihT si a .ecnetneS-tseT\\" def test_reverse_special_cases(): assert reverse_words(\\"123 456\\") == \\"321 654\\" assert reverse_words(\\"abc def ghi\\") == \\"cba fed ihg\\" assert reverse_words(\\"a! b? c.\\") == \\"!a ?b .c\\" def test_reverse_mixed_capitalization(): assert reverse_words(\\"Hello, World!\\") == \\",olleH !dlroW\\" assert reverse_words(\\"PyTHon IS cool!\\") == \\"noHTyP SI !looc\\"","solution":"def reverse_words(sentence: str) -> str: This function takes a sentence as input and reverses each word individually while maintaining the original capitalization. def reverse_word(word: str) -> str: return word[::-1] words = sentence.split(' ') reversed_words = [reverse_word(word) for word in words] return ' '.join(reversed_words)"},{"question":"def sort_tuples_by_key(tuples_list: list, key_index: int) -> list: Sort a list of tuples by the specified key index. Parameters: tuples_list (list): List of tuples to be sorted. key_index (int): Index of the tuple element to sort by. Returns: list: Sorted list of tuples. Example: >>> tuples_list = [(1, 3), (2, 2), (3, 1)] >>> sorted_list = sort_tuples_by_key(tuples_list, 1) >>> print(sorted_list) [(3, 1), (2, 2), (1, 3)]","solution":"def sort_tuples_by_key(tuples_list: list, key_index: int) -> list: Sort a list of tuples by the specified key index. Parameters: tuples_list (list): List of tuples to be sorted. key_index (int): Index of the tuple element to sort by. Returns: list: Sorted list of tuples. return sorted(tuples_list, key=lambda x: x[key_index])"},{"question":"import numpy as np def genetic_tsp(distances: np.ndarray, num_generations: int, population_size: int, mutation_rate: float) -> list: Implement a genetic algorithm to solve the Traveling Salesperson Problem. Args: distances (np.ndarray): 2D array where distances[i][j] is the distance between city i and city j. num_generations (int): Number of generations to run the genetic algorithm. population_size (int): Size of the population. mutation_rate (float): Probability of mutation for each individual. Returns: list: A list of integers representing the best route found that starts and ends at the same city. Example: >>> distances = np.array([ ... [0, 2, 9, 10], ... [1, 0, 6, 4], ... [15, 7, 0, 8], ... [6, 3, 12, 0] ... ]) >>> num_generations = 100 >>> population_size = 20 >>> mutation_rate = 0.01 >>> genetic_tsp(distances, num_generations, population_size, mutation_rate) [0, 1, 3, 2, 0] from solution import genetic_tsp import numpy as np def test_genetic_tsp_simple(): distances = np.array([ [0, 2, 9, 10], [1, 0, 6, 4], [15, 7, 0, 8], [6, 3, 12, 0] ]) num_generations = 100 population_size = 20 mutation_rate = 0.01 best_route = genetic_tsp(distances, num_generations, population_size, mutation_rate) assert isinstance(best_route, list) assert len(best_route) == len(distances) + 1 def test_genetic_tsp_larger_case(): distances = np.random.randint(0, 30, size=(10, 10)) np.fill_diagonal(distances, 0) num_generations = 200 population_size = 30 mutation_rate = 0.05 best_route = genetic_tsp(distances, num_generations, population_size, mutation_rate) assert isinstance(best_route, list) assert len(best_route) == 11 # 10 cities + return to origin def test_genetic_tsp_zero_mutation(): distances = np.random.randint(0, 30, size=(12, 12)) np.fill_diagonal(distances, 0) num_generations = 100 population_size = 25 mutation_rate = 0.0 best_route = genetic_tsp(distances, num_generations, population_size, mutation_rate) assert isinstance(best_route, list) assert len(best_route) == 13 # 12 cities + return to origin","solution":"import numpy as np import random def genetic_tsp(distances, num_generations, population_size, mutation_rate): def create_route(): return random.sample(range(num_cities), num_cities) def initial_population(pop_size): return [create_route() for _ in range(pop_size)] def route_distance(route): total_distance = sum(distances[route[i]][route[i+1]] for i in range(len(route)-1)) total_distance += distances[route[-1]][route[0]] return total_distance def rank_routes(population): return sorted(population, key=lambda route: route_distance(route)) def selection(pop_ranked): selected = [] for i in range(population_size // 2): selected.append(pop_ranked[i]) return selected def crossover(parent1, parent2): gene_a = int(random.random() * len(parent1)) gene_b = int(random.random() * len(parent1)) start_gene = min(gene_a, gene_b) end_gene = max(gene_a, gene_b) child_p1 = [] for i in range(start_gene, end_gene): child_p1.append(parent1[i]) child_p2 = [item for item in parent2 if item not in child_p1] return child_p1 + child_p2 def mutate(route): for swapped in range(len(route)): if random.random() < mutation_rate: swap_with = int(random.random() * len(route)) city1 = route[swapped] city2 = route[swap_with] route[swapped] = city2 route[swap_with] = city1 def mutate_population(population): for i in range(len(population)): mutate(population[i]) def next_generation(current_gen): pop_ranked = rank_routes(current_gen) selected = selection(pop_ranked) next_gen = selected[:] for i in range(len(pop_ranked) // 2): parent1 = random.choice(selected) parent2 = random.choice(selected) child = crossover(parent1, parent2) next_gen.append(child) mutate_population(next_gen) return next_gen num_cities = len(distances) population = initial_population(population_size) for _ in range(num_generations): population = next_generation(population) best_route = rank_routes(population)[0] return best_route + [best_route[0]]"},{"question":"def classify_transactions(transactions: list[tuple[str, float]]) -> dict[str, float]: Classifies transactions based on their type and calculates the sum of amounts for each type. :param transactions: List of tuples, with each tuple containing a transaction type and an amount. :return: Dictionary with transaction types as keys and the total amounts as values. >>> classify_transactions([(\\"deposit\\", 100.0), (\\"withdrawal\\", -50.0), (\\"deposit\\", 200.0), (\\"withdrawal\\", -75.0)]) {'deposit': 300.0, 'withdrawal': -125.0} >>> classify_transactions([]) {} >>> classify_transactions([(\\"deposit\\", 100.0), (\\"deposit\\", 200.0), (\\"deposit\\", -50.0)]) {'deposit': 250.0} >>> classify_transactions([(\\"deposit\\", 0.0), (\\"withdrawal\\", 0.0), (\\"deposit\\", 0.0), (\\"withdrawal\\", 0.0)]) {'deposit': 0.0, 'withdrawal': 0.0} >>> classify_transactions([(\\"deposit\\", 100.12345), (\\"deposit\\", -50.12345), (\\"withdrawal\\", 50.56789), (\\"withdrawal\\", -50.56789)]) {'deposit': 50.0, 'withdrawal': 0.0} >>> classify_transactions([(\\"large\\", 1e6), (\\"large\\", -999999.12345), (\\"small\\", -100.87655), (\\"small\\", 200)]) {'large': 0.88, 'small': 99.12}","solution":"def classify_transactions(transactions): Classifies transactions based on their type and calculates the sum of amounts for each type. :param transactions: List of tuples, with each tuple containing a transaction type and an amount. :return: Dictionary with transaction types as keys and the total amounts as values. result = {} for transaction_type, amount in transactions: if transaction_type in result: result[transaction_type] += amount else: result[transaction_type] = amount # Round amounts to two decimal places result = {k: round(v, 2) for k, v in result.items()} return result"},{"question":"from typing import List def generate_permutations(s: str) -> List[str]: Generates all unique permutations of the input string in sorted order. Parameters: s (str): The input string (1 <= len(s) <= 8) consisting of lowercase alphabets only. Returns: List[str]: Sorted list of unique permutations of the string. Examples: >>> generate_permutations(\\"abc\\") [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> generate_permutations(\\"aab\\") [\\"aab\\", \\"aba\\", \\"baa\\"] >>> generate_permutations(\\"aaa\\") [\\"aaa\\"]","solution":"from itertools import permutations def generate_permutations(s): Generates all unique permutations of the input string in sorted order. Parameters: s (str): The input string (1 <= len(s) <= 8) consisting of lowercase alphabets only. Returns: List[str]: Sorted list of unique permutations of the string. # Generate permutations using itertools.permutations all_permutations = set(permutations(s)) # Convert each permutation tuple to a string perm_list = [''.join(p) for p in all_permutations] # Sort the list of permutations perm_list.sort() return perm_list"},{"question":"def sum_of_digits(number: int) -> int: Calculates the sum of the digits of a given number. If the number is negative, it sums the digits of its absolute value. Parameters: number (int): The integer number whose digits are to be summed. Returns: int: The sum of the digits. Raises: TypeError: If the input is not an integer. Examples: >>> sum_of_digits(0) # Output: 0 >>> sum_of_digits(123) # Output: 6 >>> sum_of_digits(-456) # Output: 15 >>> sum_of_digits(98765) # Output: 35 >>> sum_of_digits(-10101) # Output: 3","solution":"def sum_of_digits(number: int) -> int: Returns the sum of the digits of the given integer number. If the number is negative, it sums the digits of its absolute value. Parameters: number (int): The integer number whose digits are to be summed. Returns: int: The sum of the digits. Raises: TypeError: If the input is not an integer. if not isinstance(number, int): raise TypeError(\\"Input must be an integer\\") # Use absolute value to handle negative numbers number = abs(number) # Convert the number to a string, iterate over its characters, convert them back to integers and sum them return sum(int(digit) for digit in str(number))"},{"question":"from typing import Dict, List def generate_attendance_report(attendance: Dict[str, List[str]], file_path: str=None) -> None: Generates an attendance report for given sessions. If file_path is provided, saves the report to the file. Otherwise, prints the report. :param attendance: dict - the dictionary with session names as keys and lists of attendee names as values :param file_path: str - optional, the path to the file where the report should be saved >>> generate_attendance_report({\\"Session 1\\": [\\"Alice\\", \\"Bob\\"], \\"Session 2\\": [\\"Charlie\\"]}) Session 1: Number of attendees: 2 Attendees: Alice, Bob Session 2: Number of attendees: 1 Attendees: Charlie >>> generate_attendance_report({\\"Workshop A\\": [\\"David\\", \\"Eva\\", \\"Frank\\"]}, \\"attendance_report.txt\\") # The content of 'attendance_report.txt' should be: # Workshop A: # Number of attendees: 3 # Attendees: David, Eva, Frank","solution":"from typing import Dict, List def generate_attendance_report(attendance: Dict[str, List[str]], file_path: str=None) -> None: Generates an attendance report for given sessions. If file_path is provided, saves the report to the file. Otherwise, prints the report. :param attendance: dict - the dictionary with session names as keys and lists of attendee names as values :param file_path: str - optional, the path to the file where the report should be saved if not isinstance(attendance, dict): raise ValueError(\\"The attendance should be a dictionary\\") report_lines = [] for session, attendees in attendance.items(): if not isinstance(session, str) or not isinstance(attendees, list): raise ValueError(\\"Each key should be a string and each value should be a list of strings\\") attendees_list = \\", \\".join(attendees) report_lines.append(f\\"{session}:nNumber of attendees: {len(attendees)}nAttendees: {attendees_list}n\\") report = \\"n\\".join(report_lines) if file_path: with open(file_path, 'w') as file: file.write(report) else: print(report)"},{"question":"def rotate_vector(vector, angle): Rotates a 2D vector by the given angle in radians. Parameters: - vector (list): A list of two floats representing the vector to rotate. - angle (float): The angle in radians to rotate the vector. Returns: - list: The rotated vector. >>> rotate_vector([1, 0], 1.5707963267948966) # 90 degrees [0.0, 1.0] >>> rotate_vector([0, 1], -1.5707963267948966) # -90 degrees [1.0, 0.0] pass def check_rotation_matrix(matrix): Checks if the given 2x2 matrix is a valid rotation matrix. Parameters: - matrix (list): A 2D list containing the 2x2 matrix. Returns: - bool: True if the matrix is a valid rotation matrix, False otherwise. >>> check_rotation_matrix([[0, -1], [1, 0]]) True >>> check_rotation_matrix([[0, -1.1], [1, 0]]) False pass import pytest import math def test_rotate_vector_90_degrees(): assert rotate_vector([1, 0], math.pi / 2) == pytest.approx([0.0, 1.0]) assert rotate_vector([0, 1], -math.pi / 2) == pytest.approx([1.0, 0.0]) def test_rotate_vector_180_degrees(): assert rotate_vector([1, 0], math.pi) == pytest.approx([-1.0, 0.0]) assert rotate_vector([0, 1], math.pi) == pytest.approx([0.0, -1.0]) def test_rotate_vector_360_degrees(): assert rotate_vector([1, 0], 2 * math.pi) == pytest.approx([1.0, 0.0]) assert rotate_vector([0, 1], 2 * math.pi) == pytest.approx([0.0, 1.0]) def test_check_rotation_matrix_valid(): assert check_rotation_matrix([[0, -1], [1, 0]]) == True assert check_rotation_matrix([[math.cos(math.pi/4), -math.sin(math.pi/4)], [math.sin(math.pi/4), math.cos(math.pi/4)]]) == True def test_check_rotation_matrix_invalid(): assert check_rotation_matrix([[0, -1.1], [1, 0]]) == False assert check_rotation_matrix([[1, 1], [1, 1]]) == False def test_check_rotation_matrix_non_orthogonal(): assert check_rotation_matrix([[1, 2], [3, 4]]) == False def test_check_rotation_matrix_invalid_size(): assert check_rotation_matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) == False assert check_rotation_matrix([[1, 0]]) == False","solution":"import math def rotate_vector(vector, angle): Rotates a 2D vector by the given angle in radians. Parameters: vector (list): A list of two floats representing the vector to rotate. angle (float): The angle in radians to rotate the vector. Returns: list: The rotated vector. cos_theta = math.cos(angle) sin_theta = math.sin(angle) x, y = vector x_new = cos_theta * x - sin_theta * y y_new = sin_theta * x + cos_theta * y return [x_new, y_new] def check_rotation_matrix(matrix): Checks if the given 2x2 matrix is a valid rotation matrix. Parameters: matrix (list): A 2D list containing the 2x2 matrix. Returns: bool: True if the matrix is a valid rotation matrix, False otherwise. if len(matrix) != 2 or not all(len(row) == 2 for row in matrix): return False # Calculate the transpose of the matrix transpose = [[matrix[0][0], matrix[1][0]], [matrix[0][1], matrix[1][1]]] # Calculate the product of matrix and its transpose product = [ [matrix[0][0] * transpose[0][0] + matrix[0][1] * transpose[1][0], matrix[0][0] * transpose[0][1] + matrix[0][1] * transpose[1][1]], [matrix[1][0] * transpose[0][0] + matrix[1][1] * transpose[1][0], matrix[1][0] * transpose[0][1] + matrix[1][1] * transpose[1][1]] ] # Identity matrix identity = [[1, 0], [0, 1]] # Check if product equals the identity matrix is_orthogonal = all(math.isclose(product[row][col], identity[row][col]) for row in range(2) for col in range(2)) # Calculate determinant determinant = matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] # Valid rotation matrix if orthogonal and determinant equal to ±1 return is_orthogonal and math.isclose(abs(determinant), 1)"},{"question":"def move_character(grid: List[List[str]], moves: str) -> Tuple[int, int]: Move a character around a grid based on a sequence of moves. The grid is a 2D list where each element is either an empty space ('.') or an obstacle ('#'). The character starts at the top-left corner of the grid (position (0, 0)) and can move up, down, left, or right, but cannot move into obstacles or out of the grid boundaries. Parameters: grid (List[List[str]]): A 2D list representing the game grid. moves (str): A string containing a sequence of moves where 'U' stands for up, 'D' for down, 'L' for left, and 'R' for right. Returns: Tuple[int, int]: The final position of the character as a tuple (row, col) after performing all the moves. Example: >>> grid = [ ... ['.', '.', '.', '.'], ... ['.', '#', '.', '.'], ... ['.', '.', '.', '.'], ... ['.', '.', '#', '.'] ... ] >>> moves = \\"DDRRU\\" >>> move_character(grid, moves) (1, 2) # Your code here def test_move_character(): grid = [ ['.', '.', '.', '.'], ['.', '#', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '#', '.'] ] moves = \\"DDRRU\\" assert move_character(grid, moves) == (1, 2) def test_move_character_stopping_at_obstacle(): grid = [ ['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.'] ] moves = \\"DDRRU\\" assert move_character(grid, moves) == (1, 2) def test_move_character_ignore_out_of_bounds(): grid = [ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ] moves = \\"DDDDRRRR\\" assert move_character(grid, moves) == (2, 2) def test_move_character_complex_path(): grid = [ ['.', '.', '.'], ['#', '#', '.'], ['.', '.', '.'] ] moves = \\"RRDDLLUURRDD\\" assert move_character(grid, moves) == (2, 2) def test_move_character_no_moves(): grid = [ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ] moves = \\"\\" assert move_character(grid, moves) == (0, 0)","solution":"def move_character(grid, moves): # Starting position row, col = 0, 0 rows, cols = len(grid), len(grid[0]) move_dict = { 'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1) } for move in moves: new_row = row + move_dict[move][0] new_col = col + move_dict[move][1] # Check if new position is within grid bounds and not an obstacle if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != '#': row, col = new_row, new_col return (row, col)"},{"question":"def validate_isbn(isbn: str) -> bool: Validate the given ISBN-13 string. Parameters: isbn (str): A 13-character string to be validated as an ISBN-13. Returns: bool: True if the ISBN-13 is valid, False otherwise. >>> validate_isbn(\\"9780306406157\\") True >>> validate_isbn(\\"9780306406158\\") False pass def convert_isbn10_to_isbn13(isbn10: str) -> str: Convert a given ISBN-10 string to ISBN-13. Parameters: isbn10 (str): A 10-character string representing an ISBN-10. Returns: str: A valid ISBN-13 string generated from the provided ISBN-10. >>> convert_isbn10_to_isbn13(\\"0306406152\\") '9780306406157' >>> convert_isbn10_to_isbn13(\\"123456789X\\") '9781234567897' pass def test_validate_isbn_valid(): assert validate_isbn(\\"9780306406157\\") == True def test_validate_isbn_invalid(): assert validate_isbn(\\"9780306406158\\") == False def test_validate_isbn_with_non_digit_characters(): assert validate_isbn(\\"97803064061a7\\") == False assert validate_isbn(\\"978030640615#\\") == False def test_convert_isbn10_to_isbn13_valid(): assert convert_isbn10_to_isbn13(\\"0306406152\\") == '9780306406157' def test_convert_isbn10_to_isbn13_with_invalid_isbn10(): assert convert_isbn10_to_isbn13(\\"030640615\\") == \\"\\" assert convert_isbn10_to_isbn13(\\"03064061529\\") == \\"\\" def test_convert_isbn10_to_isbn13_edge_case(): assert convert_isbn10_to_isbn13(\\"123456789X\\") == '9781234567897'","solution":"def validate_isbn(isbn: str) -> bool: Validate the given ISBN-13 string. Parameters: isbn (str): A 13-character string to be validated as an ISBN-13. Returns: bool: True if the ISBN-13 is valid, False otherwise. if len(isbn) != 13 or not isbn.isdigit(): return False total = 0 for i in range(12): digit = int(isbn[i]) if i % 2 == 0: total += digit else: total += digit * 3 check_digit = (10 - (total % 10)) % 10 return check_digit == int(isbn[12]) def convert_isbn10_to_isbn13(isbn10: str) -> str: Convert a given ISBN-10 string to ISBN-13. Parameters: isbn10 (str): A 10-character string representing an ISBN-10. Returns: str: A valid ISBN-13 string generated from the provided ISBN-10. if len(isbn10) != 10: return \\"\\" isbn13_base = '978' + isbn10[:9] total = 0 for i in range(12): digit = int(isbn13_base[i]) if i % 2 == 0: total += digit else: total += digit * 3 check_digit = (10 - (total % 10)) % 10 return isbn13_base + str(check_digit)"},{"question":"def rotate_array(arr: list, k: int) -> None: Rotates the array 'arr' to the right by 'k' positions in-place. >>> arr = [1, 2, 3, 4, 5] >>> rotate_array(arr, 2) >>> print(arr) [4, 5, 1, 2, 3] >>> arr = [1, 2, 3, 4, 5] >>> rotate_array(arr, 5) >>> print(arr) [1, 2, 3, 4, 5] >>> arr = [1, 2, 3, 4, 5] >>> rotate_array(arr, 7) >>> print(arr) [4, 5, 1, 2, 3]","solution":"def rotate_array(arr: list, k: int) -> None: Rotates the array 'arr' to the right by 'k' positions in-place. n = len(arr) k = k % n # Handle cases where k is greater than n # Reverse the entire array arr.reverse() # Reverse the first k elements arr[:k] = reversed(arr[:k]) # Reverse the remaining elements arr[k:] = reversed(arr[k:])"},{"question":"def highest_frequency_tree(frequencies: list) -> int: Returns the index of the tree with the highest frequency. If there are multiple trees with the same highest frequency, returns the index of the tree that appears last in the list. If the list is empty, returns -1. >>> highest_frequency_tree([1, 3, 7, 3, 7]) 4 >>> highest_frequency_tree([5, 5, 5]) 2 >>> highest_frequency_tree([10, 20, 30, 10, 20]) 2 >>> highest_frequency_tree([]) -1 >>> highest_frequency_tree([9]) 0","solution":"def highest_frequency_tree(frequencies: list) -> int: Returns the index of the tree with the highest frequency. If there are multiple trees with the same highest frequency, returns the index of the tree that appears last in the list. If the list is empty, returns -1. if not frequencies: return -1 max_freq = max(frequencies) max_index = len(frequencies) - 1 - frequencies[::-1].index(max_freq) return max_index"},{"question":"class LinkedList: class Node: def __init__(self, data=None): self.data = data self.next = None def __init__(self): self.head = None def add(self, data): new_node = self.Node(data) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def __str__(self): nodes = [] current = self.head while current: nodes.append(str(current.data)) current = current.next return \\" -> \\".join(nodes) def reorder_list(self): Reorder the linked list in-place by interleaving elements from the beginning and the end of the list. >>> ll = LinkedList() >>> ll.add(1) >>> ll.add(2) >>> ll.add(3) >>> ll.add(4) >>> ll.add(5) >>> print(ll) '1 -> 2 -> 3 -> 4 -> 5' >>> ll.reorder_list() >>> print(ll) '1 -> 5 -> 2 -> 4 -> 3' ... # Unit tests import pytest from solution import LinkedList def test_empty_list(): ll = LinkedList() ll.reorder_list() assert str(ll) == \\"\\" def test_single_element_list(): ll = LinkedList() ll.add(1) ll.reorder_list() assert str(ll) == \\"1\\" def test_two_element_list(): ll = LinkedList() ll.add(1) ll.add(2) ll.reorder_list() assert str(ll) == \\"1 -> 2\\" def test_odd_elements_list(): ll = LinkedList() ll.add(1) ll.add(2) ll.add(3) ll.add(4) ll.add(5) ll.reorder_list() assert str(ll) == \\"1 -> 5 -> 2 -> 4 -> 3\\" def test_even_elements_list(): ll = LinkedList() ll.add(1) ll.add(2) ll.add(3) ll.add(4) ll.add(5) ll.add(6) ll.reorder_list() assert str(ll) == \\"1 -> 6 -> 2 -> 5 -> 3 -> 4\\" def test_large_list(): ll = LinkedList() for i in range(1, 11): # 1 - 10 ll.add(i) ll.reorder_list() assert str(ll) == \\"1 -> 10 -> 2 -> 9 -> 3 -> 8 -> 4 -> 7 -> 5 -> 6\\"","solution":"class LinkedList: class Node: def __init__(self, data=None): self.data = data self.next = None def __init__(self): self.head = None def add(self, data): new_node = self.Node(data) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def __str__(self): nodes = [] current = self.head while current: nodes.append(str(current.data)) current = current.next return \\" -> \\".join(nodes) def reorder_list(self): if not self.head or not self.head.next: return # Step 1: Find the middle of the linked list slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next # Step 2: Reverse the second half of the list prev = None current = slow while current: next_node = current.next current.next = prev prev = current current = next_node # Step 3: Merge the two halves first = self.head second = prev while second.next: first_next = first.next second_next = second.next first.next = second second.next = first_next first = first_next second = second_next"},{"question":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sort a list of integers using the Merge Sort algorithm. >>> merge_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] >>> merge_sort([5, 3, 8, 6, 2, 7, 4, 1]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sort([]) [] >>> merge_sort([1]) [1] >>> merge_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> merge_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> merge_sort([-1, -3, -2, 0, 2, 1]) [-3, -2, -1, 0, 1, 2] >>> merge_sort([5, 2, 8, 5, 6, 2, 7, 1]) [1, 2, 2, 5, 5, 6, 7, 8] >>> merge_sort(list(range(100000, 0, -1))) == list(range(1, 100001)) True","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list"},{"question":"def sum_digit_factorial_numbers(limit: int) -> int: Find the sum of all digit factorial numbers not exceeding the specified limit. A digit factorial number is a number that equals the sum of the factorial of its digits. >>> sum_digit_factorial_numbers(1000) 145 >>> sum_digit_factorial_numbers(50000) 40730 >>> sum_digit_factorial_numbers(10) 0 >>> sum_digit_factorial_numbers(145) 145","solution":"def sum_digit_factorial_numbers(limit: int) -> int: from math import factorial # Precompute factorials of digits 0-9 factorials = {str(i): factorial(i) for i in range(10)} def is_digit_factorial_number(n: int) -> bool: return n == sum(factorials[digit] for digit in str(n)) # Find all digit factorial numbers up to the limit return sum(n for n in range(10, limit + 1) if is_digit_factorial_number(n))"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self): self.root = None def is_balanced(self, root: TreeNode) -> bool: Check if the binary tree is balanced. Params: root (TreeNode): The root node of the binary tree. Returns: bool: True if the tree is balanced, False otherwise. Examples: >>> tree = BinaryTree() >>> tree.root = TreeNode(1) >>> tree.root.left = TreeNode(2) >>> tree.root.right = TreeNode(3) >>> tree.root.left.left = TreeNode(4) >>> tree.root.left.right = TreeNode(5) >>> tree.is_balanced(tree.root) True >>> tree.root.left.left.left = TreeNode(6) >>> tree.is_balanced(tree.root) False def test_empty_tree(): tree = BinaryTree() assert tree.is_balanced(tree.root) == True def test_single_node_tree(): tree = BinaryTree() tree.root = TreeNode(1) assert tree.is_balanced(tree.root) == True def test_balanced_tree(): tree = BinaryTree() tree.root = TreeNode(1) tree.root.left = TreeNode(2) tree.root.right = TreeNode(3) tree.root.left.left = TreeNode(4) tree.root.left.right = TreeNode(5) assert tree.is_balanced(tree.root) == True def test_unbalanced_tree(): tree = BinaryTree() tree.root = TreeNode(1) tree.root.left = TreeNode(2) tree.root.right = TreeNode(3) tree.root.left.left = TreeNode(4) tree.root.left.left.left = TreeNode(5) assert tree.is_balanced(tree.root) == False def test_balanced_tree_with_varying_heights(): tree = BinaryTree() tree.root = TreeNode(1) tree.root.left = TreeNode(2) tree.root.right = TreeNode(3) tree.root.left.left = TreeNode(4) tree.root.left.right = TreeNode(5) tree.root.right.right = TreeNode(6) assert tree.is_balanced(tree.root) == True def test_right_heavy_tree(): tree = BinaryTree() tree.root = TreeNode(1) tree.root.right = TreeNode(2) tree.root.right.right = TreeNode(3) assert tree.is_balanced(tree.root) == False","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self): self.root = None def is_balanced(self, root: TreeNode) -> bool: Check if the binary tree is balanced. def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) if not left_balanced or not right_balanced: return 0, False if abs(left_height - right_height) > 1: return 0, False return max(left_height, right_height) + 1, True _, is_bal = check_balance(root) return is_bal"},{"question":"def is_subset_sum(arr: List[int], target: int) -> bool: Determine if there is a subset in the array \`arr\` with a sum equal to \`target\`. :param arr: List[int] representing the array of integers. :param target: int representing the target sum. :return: True if a subset with sum equal to \`target\` exists, False otherwise. >>> is_subset_sum([3, 34, 4, 12, 5, 2], 9) True >>> is_subset_sum([1, 2, 3, 7], 6) True >>> is_subset_sum([3, 34, 4, 12, 5, 2], 30) False","solution":"from typing import List def is_subset_sum(arr: List[int], target: int) -> bool: Determine if there is a subset in the array \`arr\` with a sum equal to \`target\`. :param arr: List[int] representing the array of integers. :param target: int representing the target sum. :return: True if a subset with sum equal to \`target\` exists, False otherwise. n = len(arr) dp = [[False] * (target + 1) for _ in range(n + 1)] # When target is 0, subset sum is always True (empty subset) for i in range(n + 1): dp[i][0] = True # Populate the DP table for i in range(1, n + 1): for j in range(1, target + 1): if arr[i-1] > j: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]] return dp[n][target]"},{"question":"from typing import List def coinChange(coins: List[int], amount: int) -> int: Calculates the minimum number of coins needed to make up the given amount. If the amount cannot be made up by any combination of the given coins, returns -1. Args: coins (List[int]): A list of integers representing the denominations of the available coins. amount (int): An integer representing the amount of money. Returns: int: The minimum number of coins needed to make up the given amount, or -1 if it is not possible. Examples: >>> coinChange([1, 2, 5], 11) 3 >>> coinChange([2], 3) -1 >>> coinChange([1], 0) 0 >>> coinChange([1], 1) 1 >>> coinChange([1], 2) 2","solution":"from typing import List def coinChange(coins: List[int], amount: int) -> int: This function returns the minimum number of coins needed to make up the given amount. If the amount cannot be made up by any combination of the given coins, it returns -1. # Create a list to hold the minimum number of coins needed for each amount dp = [float('inf')] * (amount + 1) dp[0] = 0 # No coins needed to make amount 0 # Loop over each coin and update the dp array for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) # Return the answer for the original amount return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"from typing import List def firstMissingPositive(nums: List[int]) -> int: Identify the first missing positive integer in a given list. >>> firstMissingPositive([1, 2, 0]) 3 >>> firstMissingPositive([3, 4, -1, 1]) 2 >>> firstMissingPositive([7, 8, 9, 11, 12]) 1","solution":"from typing import List def firstMissingPositive(nums: List[int]) -> int: n = len(nums) # Place each number in its right place for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: # Swap numbers to their right places nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Find the first number missing for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Finds the maximum sum of a contiguous subarray within a given array of integers. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([5, -4, -2, 6, -1]) 6 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([0, 0, -1, 0, -2, 0]) 0","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Finds the maximum sum of a contiguous subarray within a given array of integers. Implements Kadane's Algorithm to achieve this. if not arr: return 0 max_current = max_global = arr[0] for i in range(1, len(arr)): max_current = max(arr[i], max_current + arr[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List def min_bundles(order_quantity: int, bundle_sizes: List[int]) -> int: Determines the minimum number of bundles required to meet the order quantity. Parameters: - order_quantity: An integer representing the total number of items needed (1 <= order_quantity <= 10^6). - bundle_sizes: A list of integers where each integer denotes the number of items in a bundle (1 <= len(bundle_sizes) <= 1000, 1 <= bundle_sizes[i] <= 1000). Returns: - The minimum number of bundles required to meet or exceed the order quantity. >>> min_bundles(100, [1, 10, 50]) 2 >>> min_bundles(30, [5, 10, 25]) 2 >>> min_bundles(12, [3, 6, 9]) 2 >>> min_bundles(7, [2, 5]) 2 >>> min_bundles(10, [2, 4, 8]) 2 >>> min_bundles(15, [3, 6, 9]) 2 >>> min_bundles(1000, [500, 300, 200]) 2 >>> min_bundles(13, [2, 6]) -1 >>> min_bundles(1000000, [500, 1000, 250]) 1000","solution":"from typing import List def min_bundles(order_quantity: int, bundle_sizes: List[int]) -> int: bundle_sizes.sort(reverse=True) count = 0 for size in bundle_sizes: if order_quantity <= 0: break count += order_quantity // size order_quantity %= size return count if order_quantity == 0 else -1"},{"question":"from collections import defaultdict class NetworkMetrics: A class for Tracking and Analyzing Real-time Network Metrics. The NetworkMetrics class manages and analyzes real-time network metrics. It allows adding metric samples for different nodes and querying the average metrics over a specified time window. def __init__(self): Initializes the NetworkMetrics class. self.metrics = defaultdict(list) def add_metric_sample(self, node: str, timestamp: float, latency: float, throughput: float, packet_loss: float) -> None: Adds a metric sample for a specific network node. :param node: str: The network node identifier :param timestamp: float: The timestamp of the sample (in seconds) :param latency: float: The latency value (in milliseconds) :param throughput: float: The throughput value (in Mbps) :param packet_loss: float: The packet loss percentage def get_average_metrics(self, node: str, start_time: float, end_time: float) -> dict[str, float]: Calculates and returns the average metrics for a specific node over a given time window. :param node: str: The network node identifier :param start_time: float: The start time of the query window :param end_time: float: The end time of the query window :return: dict[str, float]: A dictionary with keys \`latency\`, \`throughput\`, and \`packet_loss\` mapping to the average value of the respective metric over the given time window. import pytest def test_add_metric_sample_and_avg_metrics(): nm = NetworkMetrics() nm.add_metric_sample('node1', 1632867460.0, 20.5, 100.0, 0.01) nm.add_metric_sample('node1', 1632867465.0, 23.0, 98.5, 0.02) nm.add_metric_sample('node1', 1632867470.0, 22.0, 99.0, 0.015) nm.add_metric_sample('node2', 1632867475.0, 30.0, 95.0, 0.005) result = nm.get_average_metrics('node1', 1632867460.0, 1632867470.0) assert result == {'latency': 21.833333333333332, 'throughput': 99.16666666666667, 'packet_loss': 0.015} result = nm.get_average_metrics('node1', 1632867480.0, 1632867490.0) assert result == {'latency': 0.0, 'throughput': 0.0, 'packet_loss': 0.0} result = nm.get_average_metrics('node2', 1632867460.0, 1632867480.0) assert result == {'latency': 30.0, 'throughput': 95.0, 'packet_loss': 0.005} result = nm.get_average_metrics('node1', 1632867470.0, 1632867460.0) assert result == {'latency': 0.0, 'throughput': 0.0, 'packet_loss': 0.0} def test_no_data(): nm = NetworkMetrics() result = nm.get_average_metrics('node1', 1632867460.0, 1632867480.0) assert result == {'latency': 0.0, 'throughput': 0.0, 'packet_loss': 0.0}","solution":"from collections import defaultdict import bisect class NetworkMetrics: def __init__(self): self.metrics = defaultdict(list) def add_metric_sample(self, node: str, timestamp: float, latency: float, throughput: float, packet_loss: float) -> None: metric_sample = (timestamp, latency, throughput, packet_loss) self.metrics[node].append(metric_sample) def get_average_metrics(self, node: str, start_time: float, end_time: float) -> dict[str, float]: if node not in self.metrics or start_time >= end_time: return {'latency': 0.0, 'throughput': 0.0, 'packet_loss': 0.0} samples = self.metrics[node] relevant_samples = [sample for sample in samples if start_time <= sample[0] <= end_time] if not relevant_samples: return {'latency': 0.0, 'throughput': 0.0, 'packet_loss': 0.0} avg_latency = sum(sample[1] for sample in relevant_samples) / len(relevant_samples) avg_throughput = sum(sample[2] for sample in relevant_samples) / len(relevant_samples) avg_packet_loss = sum(sample[3] for sample in relevant_samples) / len(relevant_samples) return { 'latency': avg_latency, 'throughput': avg_throughput, 'packet_loss': avg_packet_loss }"},{"question":"from typing import List, Dict, Union def unique_visitors_per_day(visits: List[Dict[str, Union[str, int]]], target_date: str) -> int: Returns the number of unique visitors for a specified date. :param visits: A list of dictionaries each containing 'visitor_id' (int) and 'timestamp' (str). :param target_date: The target date as a string in \\"YYYY-MM-DD\\" format. :return: An integer representing the number of unique visitors. pass def parse_visit_data(raw_data: List[str]) -> List[Dict[str, Union[str, int]]]: Parses raw visit data strings into a list of dictionaries. :param raw_data: A list of strings, each formatted as \\"visitor_id, timestamp\\". :return: A list of dictionaries each with 'visitor_id' (int) and 'timestamp' (str). pass # Test cases def test_parse_visit_data(): raw_data = [ \\"123, 2023-10-15 14:23:11\\", \\"456, 2023-10-15 11:34:56\\", \\"789, 2023-10-14 09:01:45\\" ] expected_output = [ {'visitor_id': 123, 'timestamp': '2023-10-15 14:23:11'}, {'visitor_id': 456, 'timestamp': '2023-10-15 11:34:56'}, {'visitor_id': 789, 'timestamp': '2023-10-14 09:01:45'} ] assert parse_visit_data(raw_data) == expected_output def test_parse_visit_data_invalid_format(): raw_data = [ \\"123, 2023-10-15 14:23:11\\", \\"invalid_data\\" ] try: parse_visit_data(raw_data) except ValueError as e: assert str(e) == \\"Invalid data format\\" def test_unique_visitors_per_day(): visits = [ {'visitor_id': 123, 'timestamp': '2023-10-15 14:23:11'}, {'visitor_id': 456, 'timestamp': '2023-10-15 11:34:56'}, {'visitor_id': 123, 'timestamp': '2023-10-15 16:45:12'}, {'visitor_id': 789, 'timestamp': '2023-10-14 09:01:45'} ] target_date = '2023-10-15' assert unique_visitors_per_day(visits, target_date) == 2 def test_unique_visitors_per_day_no_visits(): visits = [ {'visitor_id': 123, 'timestamp': '2023-10-14 14:23:11'}, {'visitor_id': 456, 'timestamp': '2023-10-14 11:34:56'} ] target_date = '2023-10-15' assert unique_visitors_per_day(visits, target_date) == 0 def test_unique_visitors_per_day_different_dates(): visits = [ {'visitor_id': 123, 'timestamp': '2023-10-15 14:23:11'}, {'visitor_id': 456, 'timestamp': '2023-10-15 11:34:56'}, {'visitor_id': 123, 'timestamp': '2023-10-16 16:45:12'}, {'visitor_id': 789, 'timestamp': '2023-10-14 09:01:45'} ] target_date = '2023-10-16' assert unique_visitors_per_day(visits, target_date) == 1","solution":"def unique_visitors_per_day(visits, target_date): Returns the number of unique visitors for a specified date. :param visits: A list of dictionaries each containing 'visitor_id' (int) and 'timestamp' (str). :param target_date: The target date as a string in \\"YYYY-MM-DD\\" format. :return: An integer representing the number of unique visitors. unique_visitors = set() for visit in visits: if visit['timestamp'].startswith(target_date): unique_visitors.add(visit['visitor_id']) return len(unique_visitors) def parse_visit_data(raw_data): Parses raw visit data strings into a list of dictionaries. :param raw_data: A list of strings, each formatted as \\"visitor_id, timestamp\\". :return: A list of dictionaries each with 'visitor_id' (int) and 'timestamp' (str). parsed_data = [] for entry in raw_data: try: visitor_id, timestamp = entry.split(\\", \\") parsed_data.append({ 'visitor_id': int(visitor_id), 'timestamp': timestamp }) except ValueError: raise ValueError(\\"Invalid data format\\") return parsed_data"},{"question":"class LRUCache: A simple Least Recently Used (LRU) Cache. Methods: - __init__(self, capacity: int) -> None: Initializes the cache with a given positive capacity. - get(self, key: int) -> int: Returns the value of the key if the key exists in the cache, otherwise returns -1. - put(self, key: int, value: int) -> None: Updates the value of the key if the key exists, otherwise adds the key-value pair to the cache. If the number of keys exceeds the capacity, it should evict the least recently used key before adding the new key-value pair. def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass # Unit tests def test_lru_cache_initialization(): cache = LRUCache(2) assert cache.capacity == 2 assert isinstance(cache.cache, OrderedDict) def test_lru_cache_put_and_get(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 assert cache.get(2) == 2 def test_lru_cache_eviction(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) assert cache.get(1) == -1 # least recently used key 1 should be evicted assert cache.get(2) == 2 assert cache.get(3) == 3 def test_lru_cache_update(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(2, 20) assert cache.get(2) == 20 # key 2's value should be updated def test_lru_cache_multiple_evictions(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) cache.put(4, 4) assert cache.get(1) == -1 # key 1 should be evicted assert cache.get(2) == -1 # key 2 should be evicted assert cache.get(3) == 3 # key 3 should be present assert cache.get(4) == 4 # key 4 should be present def test_lru_cache_get_nonexistent_key(): cache = LRUCache(2) assert cache.get(100) == -1 # key 100 does not exist def test_lru_cache_repeated_get_updates_order(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.get(1) cache.put(3, 3) assert cache.get(2) == -1 # key 2 should be evicted as key 1 was recently accessed assert cache.get(1) == 1 assert cache.get(3) == 3","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): Initialize the LRU cache with a given positive capacity. self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: Return the value of the key if it exists, otherwise return -1. Move the key to the end to show it was recently used. if key not in self.cache: return -1 value = self.cache.pop(key) self.cache[key] = value return value def put(self, key: int, value: int) -> None: Update the value of the key if it exists, otherwise add the key-value pair. If the cache exceeds the capacity, remove the least recently used item. if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = value"},{"question":"def longest_increasing_substring(s: str) -> str: Determine the longest substring in which the characters occur in lexicographically increasing order. If there are multiple substrings with the same maximum length, return the one which appears first. >>> longest_increasing_substring(\\"abcdxyzabxy\\") \\"abcdxyz\\" >>> longest_increasing_substring(\\"abcabcabc\\") \\"abc\\" >>> longest_increasing_substring(\\"zyxwvutsrq\\") \\"z\\"","solution":"def longest_increasing_substring(s: str) -> str: n = len(s) if n == 0: return \\"\\" max_length = 1 start_idx = 0 current_length = 1 current_start = 0 for i in range(1, n): if s[i-1] < s[i]: current_length += 1 else: if current_length > max_length: max_length = current_length start_idx = current_start current_length = 1 current_start = i # Final check at the end of the loop if current_length > max_length: max_length = current_length start_idx = current_start return s[start_idx:start_idx + max_length]"},{"question":"from typing import List def longest_str_chain(words: List[str]) -> int: Implement a function to find the length of the longest string chain in an array of strings. >>> longest_str_chain([\\"a\\", \\"b\\", \\"ba\\", \\"bca\\", \\"bda\\", \\"bdca\\"]) 4 >>> longest_str_chain([\\"xbc\\", \\"pcxbcf\\", \\"xb\\", \\"cxbc\\", \\"pcxbc\\"]) 5 >>> longest_str_chain([\\"abcd\\", \\"dbqca\\"]) 1 >>> longest_str_chain([\\"a\\"]) 1 >>> longest_str_chain([\\"abc\\", \\"def\\", \\"ghi\\"]) 1 >>> longest_str_chain([\\"a\\", \\"ab\\", \\"ac\\", \\"abc\\", \\"bac\\"]) 3 >>> longest_str_chain([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\", \\"abcdef\\"]) 6 >>> longest_str_chain([\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) 1","solution":"from typing import List from collections import defaultdict def longest_str_chain(words: List[str]) -> int: words.sort(key=len) # Sorting the words based on their lengths longest_chain = defaultdict(int) max_chain_length = 1 for word in words: for i in range(len(word)): predecessor = word[:i] + word[i+1:] longest_chain[word] = max(longest_chain[word], longest_chain[predecessor] + 1) max_chain_length = max(max_chain_length, longest_chain[word]) return max_chain_length"},{"question":"# Completion Task Implement the function \`analyze_temperature_data\` based on the provided function specification and the example calls. Here is the Python function definition and implementation: import csv from datetime import datetime def analyze_temperature_data(file_path: str, start_date: str, end_date: str) -> dict: try: # Convert dates to datetime objects start_date = datetime.strptime(start_date, \\"%Y-%m-%d\\") end_date = datetime.strptime(end_date, \\"%Y-%m-%d\\") if start_date > end_date: return {\\"error\\": \\"Start date cannot be after end date\\"} temperatures = [] with open(file_path, 'r') as file: reader = csv.DictReader(file) for row in reader: row_date = datetime.strptime(row['date'], \\"%Y-%m-%d\\") if start_date <= row_date <= end_date: try: temperature = float(row['temperature']) temperatures.append(temperature) except ValueError: continue if not temperatures: return {\\"error\\": \\"No temperatures found in the given date range\\"} average_temperature = sum(temperatures) / len(temperatures) highest_temperature = max(temperatures) lowest_temperature = min(temperatures) return { 'average_temperature': average_temperature, 'highest_temperature': highest_temperature, 'lowest_temperature': lowest_temperature } except FileNotFoundError: return {\\"error\\": \\"File not found\\"} except ValueError as ve: return {\\"error\\": str(ve)} # Additional helper function to create a sample CSV for testing def create_sample_csv(file_path: str, data: list): headers = [\\"date\\", \\"temperature\\"] with open(file_path, 'w', newline='') as file: writer = csv.DictWriter(file, fieldnames=headers) writer.writeheader() for row in data: writer.writerow(row)","solution":"import csv from datetime import datetime def analyze_temperature_data(file_path: str, start_date: str, end_date: str) -> dict: try: # Convert dates to datetime objects start_date = datetime.strptime(start_date, \\"%Y-%m-%d\\") end_date = datetime.strptime(end_date, \\"%Y-%m-%d\\") if start_date > end_date: return {\\"error\\": \\"Start date cannot be after end date\\"} temperatures = [] with open(file_path, 'r') as file: reader = csv.DictReader(file) for row in reader: row_date = datetime.strptime(row['date'], \\"%Y-%m-%d\\") if start_date <= row_date <= end_date: try: temperature = float(row['temperature']) temperatures.append(temperature) except ValueError: continue if not temperatures: return {\\"error\\": \\"No temperatures found in the given date range\\"} average_temperature = sum(temperatures) / len(temperatures) highest_temperature = max(temperatures) lowest_temperature = min(temperatures) return { 'average_temperature': average_temperature, 'highest_temperature': highest_temperature, 'lowest_temperature': lowest_temperature } except FileNotFoundError: return {\\"error\\": \\"File not found\\"} except ValueError as ve: return {\\"error\\": str(ve)} # Additional helper function to create a sample CSV for testing def create_sample_csv(file_path: str, data: list): headers = [\\"date\\", \\"temperature\\"] with open(file_path, 'w', newline='') as file: writer = csv.DictWriter(file, fieldnames=headers) writer.writeheader() for row in data: writer.writerow(row)"},{"question":"def first_duplicate(nums: List[int]) -> int: Determine the first duplicated element in the list of integers nums. If no duplicates are found, return None. >>> first_duplicate([1, 2, 3, 1]) 1 >>> first_duplicate([1, 2, 3, 4, 5]) None >>> first_duplicate([5, 1, 5, 1, 7, 8]) 5 >>> first_duplicate([]) None >>> first_duplicate([2, 4, 2, 4]) 2","solution":"def first_duplicate(nums): This function returns the first duplicated element it encounters in the list of integers nums. If no duplicates are found, it returns None. seen = set() for num in nums: if num in seen: return num seen.add(num) return None"},{"question":"def next_permutation(nums: list[int]) -> None: Rearrange numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, rearrange it to the lowest possible order. >>> nums = [1, 2, 3] >>> next_permutation(nums) >>> print(nums) [1, 3, 2] >>> nums = [3, 2, 1] >>> next_permutation(nums) >>> print(nums) [1, 2, 3] >>> nums = [1, 1, 5] >>> next_permutation(nums) >>> print(nums) [1, 5, 1] >>> nums = [1, 3, 2] >>> next_permutation(nums) >>> print(nums) [2, 1, 3] # Implementation goes here...","solution":"def next_permutation(nums: list[int]) -> None: Rearrange numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, rearrange it to the lowest possible order. # Step 1: Find the first decreasing element from the right i = len(nums) - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 # Step 2: If we found a number at i which is less than its next number, then we need to swap if i >= 0: j = len(nums) - 1 while nums[j] <= nums[i]: j -= 1 nums[i], nums[j] = nums[j], nums[i] # Step 3: Reverse the numbers after the i-th position to get the next smallest lexicographical arrangement left, right = i + 1, len(nums) - 1 while left < right: nums[left], nums[right] = nums[right], nums[left] left += 1 right -= 1"},{"question":"import csv import logging logging.basicConfig(level=logging.ERROR) def get_sales_summary(file_path: str) -> dict: Reads sales data from CSV and returns a summary of total sales per product. :param file_path: Path to the CSV file containing sales data :return: Dictionary with product names as keys and total sales as values >>> get_sales_summary(\\"test_file.csv\\") {'Product1': 15.0, 'Product2': 20.0} sales_summary = {} try: with open(file_path, mode='r') as file: reader = csv.DictReader(file) if 'product_name' not in reader.fieldnames or 'sales' not in reader.fieldnames: raise ValueError(\\"CSV file must contain 'product_name' and 'sales' columns.\\") for row in reader: try: product_name = row['product_name'] sales = float(row['sales']) if product_name in sales_summary: sales_summary[product_name] += sales else: sales_summary[product_name] = sales except ValueError: logging.error(f\\"Skipping invalid row: {row}\\") return sales_summary except FileNotFoundError: raise Exception(f\\"The file at {file_path} was not found.\\") except Exception as e: logging.error(f\\"Error processing file {file_path}: {e}\\") raise if __name__ == \\"__main__\\": file_path = input(\\"Enter the path to the sales CSV file: \\").strip() try: summary = get_sales_summary(file_path) for product, total_sales in summary.items(): print(f\\"Product: {product}, Total Sales: {total_sales}\\") print(\\"Sales summary completed.\\") except Exception as e: print(f\\"Failed to generate sales summary: {e}\\")","solution":"import csv import logging logging.basicConfig(level=logging.ERROR) def get_sales_summary(file_path: str) -> dict: Reads sales data from CSV and returns a summary of total sales per product. :param file_path: Path to the CSV file containing sales data :return: Dictionary with product names as keys and total sales as values sales_summary = {} try: with open(file_path, mode='r') as file: reader = csv.DictReader(file) # Validate necessary columns if 'product_name' not in reader.fieldnames or 'sales' not in reader.fieldnames: raise ValueError(\\"CSV file must contain 'product_name' and 'sales' columns.\\") for row in reader: # Skip rows with missing data if not row['product_name'] or not row['sales']: logging.error(f\\"Skipping incomplete row: {row}\\") continue try: product_name = row['product_name'] sales = float(row['sales']) if product_name in sales_summary: sales_summary[product_name] += sales else: sales_summary[product_name] = sales except ValueError: logging.error(f\\"Skipping invalid row: {row}\\") return sales_summary except FileNotFoundError: logging.error(f\\"The file at {file_path} was not found.\\") return {\\"error\\": \\"File not found\\"} except Exception as e: logging.error(f\\"Error processing file {file_path}: {e}\\") return {\\"error\\": str(e)}"},{"question":"class UniqueElementsList: A class to manage a list of unique elements. Methods ------- add(item: int) -> None: Adds the item to the list if it is not already present. remove(item: int) -> None: Removes the item from the list if it is present; otherwise, raises an IndexError. get_unique_elements() -> list[int]: Returns a list of all unique elements currently in the list. contains(item: int) -> bool: Checks if the item exists in the list. def __init__(self): Initializes an empty set to store unique elements. pass def add(self, item: int) -> None: Adds an item to the list. If the item already exists, it will not be added. >>> u = UniqueElementsList() >>> u.add(1) >>> u.get_unique_elements() [1] pass def remove(self, item: int) -> None: Removes the item from the list if it exists; raises IndexError if it does not. >>> u = UniqueElementsList() >>> u.add(1) >>> u.remove(1) >>> u.get_unique_elements() [] >>> u.remove(1) # doctest: +IGNORE_EXCEPTION_DETAIL Traceback (most recent call last): IndexError: Item not found pass def get_unique_elements(self) -> list[int]: Retrieves all unique elements from the list. >>> u = UniqueElementsList() >>> u.add(1) >>> u.add(2) >>> u.get_unique_elements() [1, 2] pass def contains(self, item: int) -> bool: Checks if the item exists in the list. >>> u = UniqueElementsList() >>> u.add(1) >>> u.contains(1) True >>> u.contains(2) False pass # Unit tests def test_add_items(): u = UniqueElementsList() u.add(1) assert u.get_unique_elements() == [1] u.add(2) assert u.get_unique_elements() == [1, 2] u.add(2) assert u.get_unique_elements() == [1, 2] # 2 should not be added again def test_remove_items(): u = UniqueElementsList() u.add(1) u.add(2) u.remove(1) assert u.get_unique_elements() == [2] with pytest.raises(IndexError, match=\\"Item not found\\"): u.remove(1) # Removing an item that does not exist def test_contains(): u = UniqueElementsList() u.add(1) assert u.contains(1) == True assert u.contains(2) == False u.add(2) assert u.contains(2) == True def test_get_unique_elements(): u = UniqueElementsList() u.add(1) u.add(2) u.add(3) u.add(2) # Duplicate value should not be added assert set(u.get_unique_elements()) == {1, 2, 3}","solution":"class UniqueElementsList: def __init__(self): self.items = set() def add(self, item: int) -> None: Adds the item to the list if it is not already present. self.items.add(item) def remove(self, item: int) -> None: Removes the item from the list if it is present; otherwise, raises an IndexError. if item in self.items: self.items.remove(item) else: raise IndexError(\\"Item not found\\") def get_unique_elements(self) -> list[int]: Returns a list of all unique elements currently in the set. return list(self.items) def contains(self, item: int) -> bool: Checks if the item exists in the list. return item in self.items"},{"question":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balance_tree(root: Optional[TreeNode]) -> Optional[TreeNode]: Rearranges the nodes of the binary tree such that it becomes height-balanced. Args: root (Optional[TreeNode]): The root node of the binary tree. Returns: Optional[TreeNode]: The new root of the height-balanced binary tree. Examples: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> new_root = balance_tree(root) >>> is_balanced(new_root) True pass def is_balanced(root: Optional[TreeNode]) -> bool: def check(node): if not node: return 0, True left_height, left_balanced = check(node.left) right_height, right_balanced = check(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return 1 + max(left_height, right_height), balanced _, balanced = check(root) return balanced def test_balance_tree_empty(): assert balance_tree(None) is None def test_balance_tree_single_node(): root = TreeNode(1) assert is_balanced(balance_tree(root)) def test_balance_tree_example_case(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) new_root = balance_tree(root) assert is_balanced(new_root) def test_balance_tree_left_skewed(): root = TreeNode(5) root.left = TreeNode(3) root.left.left = TreeNode(2) root.left.left.left = TreeNode(1) balanced_root = balance_tree(root) assert is_balanced(balanced_root) def test_balance_tree_right_skewed(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) root.right.right.right = TreeNode(4) balanced_root = balance_tree(root) assert is_balanced(balanced_root) def test_balance_tree_complex_case(): root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(20) root.left.left = TreeNode(3) root.left.right = TreeNode(7) root.right.left = TreeNode(15) root.right.right = TreeNode(25) balanced_root = balance_tree(root) assert is_balanced(balanced_root) if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balance_tree(root: Optional[TreeNode]) -> Optional[TreeNode]: # Helper function to perform in-order traversal and collect nodes. def inorder_traversal(node: Optional[TreeNode], nodes: List[TreeNode]): if not node: return inorder_traversal(node.left, nodes) nodes.append(node) inorder_traversal(node.right, nodes) # Helper function to construct the balanced binary tree. def sorted_array_to_bst(start: int, end: int, nodes: List[TreeNode]) -> Optional[TreeNode]: if start > end: return None mid = (start + end) // 2 node = nodes[mid] node.left = sorted_array_to_bst(start, mid - 1, nodes) node.right = sorted_array_to_bst(mid + 1, end, nodes) return node # Extract nodes in in-order sequence. nodes = [] inorder_traversal(root, nodes) # Construct balanced BST from the sorted nodes. return sorted_array_to_bst(0, len(nodes) - 1, nodes)"},{"question":"import math def gcd_of_factorials(a: int, b: int) -> int: This function returns the gcd of the factorials of two given numbers. Parameters: a (int): First non-negative integer. Should be >= 0. b (int): Second non-negative integer. Should be >= 0. Returns: int: The gcd of a! and b!. Examples: >>> gcd_of_factorials(5, 10) 120 >>> gcd_of_factorials(7, 12) 5040 >>> gcd_of_factorials(3, 8) 6 >>> gcd_of_factorials(0, 0) 1 pass def test_gcd_of_factorials(): assert gcd_of_factorials(5, 10) == 120 assert gcd_of_factorials(7, 12) == 5040 assert gcd_of_factorials(3, 8) == 6 assert gcd_of_factorials(0, 0) == 1 assert gcd_of_factorials(1, 1) == 1 assert gcd_of_factorials(6, 6) == 720 assert gcd_of_factorials(0, 5) == 1 assert gcd_of_factorials(5, 0) == 1 assert gcd_of_factorials(10, 7) == 5040 assert gcd_of_factorials(2, 14) == 2","solution":"import math def gcd_of_factorials(a: int, b: int) -> int: This function returns the gcd of the factorials of two given numbers. Parameters: a (int): First non-negative integer. Should be >= 0. b (int): Second non-negative integer. Should be >= 0. Returns: int: The gcd of a! and b!. # Compute the factorial of the smaller of the two numbers min_number = min(a, b) return math.factorial(min_number)"},{"question":"def merge_sort(arr: List[int]) -> List[int]: Sorts a given list of integers using the merge sort algorithm. >>> merge_sort([3, 1, 4, 1, 5, 9, 2]) [1, 1, 2, 3, 4, 5, 9] >>> merge_sort([5, -2, -2, 2, 0, 8, 7]) [-2, -2, 0, 2, 5, 7, 8] >>> merge_sort([]) [] pass # Unit tests def test_merge_sort_empty_list(): assert merge_sort([]) == [] def test_merge_sort_single_element(): assert merge_sort([1]) == [1] def test_merge_sort_two_elements(): assert merge_sort([2, 1]) == [1, 2] def test_merge_sort_multiple_elements(): assert merge_sort([3, 1, 4, 1, 5, 9, 2]) == [1, 1, 2, 3, 4, 5, 9] def test_merge_sort_negative_elements(): assert merge_sort([5, -2, -2, 2, 0, 8, 7]) == [-2, -2, 0, 2, 5, 7, 8] def test_merge_sort_identical_elements(): assert merge_sort([2, 2, 2, 2, 2]) == [2, 2, 2, 2, 2] def test_merge_sort_already_sorted(): assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_merge_sort_reverse_sorted(): assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_merge_sort_large_numbers(): large_input = [1000000000, -1000000000, 0] assert merge_sort(large_input) == [-1000000000, 0, 1000000000]","solution":"def merge_sort(arr): Sorts a list of integers using the merge sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left, right): Merges two sorted lists into a single sorted list. sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list"},{"question":"def fibonacci_recursive(n: int) -> int: Calculates the nth Fibonacci number using recursion with memoization. Params: n (int): Position in the Fibonacci sequence (non-negative integer). Returns: int: The nth Fibonacci number. Raises: ValueError: If the input n is negative. >>> fibonacci_recursive(10) 55 >>> fibonacci_recursive(0) 0 >>> fibonacci_recursive(-5) Traceback (most recent call last): ... ValueError: Position in the Fibonacci sequence can't be negative. def fibonacci_iterative(n: int) -> int: Calculates the nth Fibonacci number using iterative approach. Params: n (int): Position in the Fibonacci sequence (non-negative integer). Returns: int: The nth Fibonacci number. Raises: ValueError: If the input n is negative. >>> fibonacci_iterative(10) 55 >>> fibonacci_iterative(0) 0 >>> fibonacci_iterative(-5) Traceback (most recent call last): ... ValueError: Position in the Fibonacci sequence can't be negative.","solution":"def fibonacci_recursive(n, memo = None): Calculates the nth Fibonacci number using recursion with memoization. Params: n (int): Position in the Fibonacci sequence (non-negative integer). Returns: int: The nth Fibonacci number. Raises: ValueError: If the input n is negative. if n < 0: raise ValueError(\\"Position in the Fibonacci sequence can't be negative.\\") if memo is None: memo = {} if n in memo: return memo[n] if n in {0, 1}: memo[n] = n else: memo[n] = fibonacci_recursive(n-1, memo) + fibonacci_recursive(n-2, memo) return memo[n] def fibonacci_iterative(n): Calculates the nth Fibonacci number using iterative approach. Params: n (int): Position in the Fibonacci sequence (non-negative integer). Returns: int: The nth Fibonacci number. Raises: ValueError: If the input n is negative. if n < 0: raise ValueError(\\"Position in the Fibonacci sequence can't be negative.\\") if n in {0, 1}: return n a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def count_items_by_category(inventory: dict) -> dict: Count the number of items in each category. @param inventory: a dictionary where keys are category names and values are lists of item names @return: a dictionary with the same keys as the input, but values indicating the number of items in each category Example: >>> count_items_by_category({'Electronics': ['Phone', 'Tablet'], 'Furniture': ['Chair', 'Table', 'Desk']}) {'Electronics': 2, 'Furniture': 3} >>> count_items_by_category({'Groceries': [], 'Clothes': ['T-shirt']}) {'Groceries': 0, 'Clothes': 1} def find_duplicate_items(inventory: dict) -> list: Check if there are any items with the same name across different categories and return a list of duplicates. @param inventory: a dictionary where keys are category names and values are lists of item names @return: a list of item names that appear in more than one category Example: >>> find_duplicate_items({'Electronics': ['Phone', 'Tablet'], 'Furniture': ['Chair', 'Table', 'Phone']}) ['Phone'] >>> find_duplicate_items({'Groceries': ['Apple'], 'Clothes': ['T-shirt']}) []","solution":"def count_items_by_category(inventory: dict) -> dict: Returns a dictionary with the same keys as the input, but values indicating the number of items in each category. return {category: len(items) for category, items in inventory.items()} def find_duplicate_items(inventory: dict) -> list: Returns a list of item names that appear in more than one category. item_to_categories = {} for category, items in inventory.items(): for item in items: if item in item_to_categories: item_to_categories[item].add(category) else: item_to_categories[item] = {category} duplicates = [item for item, categories in item_to_categories.items() if len(categories) > 1] return duplicates"},{"question":"def replace_substring(s: str, target: str, replacement: str) -> str: Replaces all occurrences of a target substring in the input string with the replacement substring. Parameters: - s: str, the original string - target: str, the substring to be replaced - replacement: str, the substring to replace with Returns: - str, the modified string with replacements made >>> replace_substring(\\"hello world\\", \\"world\\", \\"there\\") \\"hello there\\" >>> replace_substring(\\"abc abc abc\\", \\"abc\\", \\"xyz\\") \\"xyz xyz xyz\\" >>> replace_substring(\\"aaaaa\\", \\"aa\\", \\"b\\") \\"bba\\" >>> replace_substring(\\"no matches here\\", \\"nomatch\\", \\"replace\\") \\"no matches here\\" >>> replace_substring(\\"\\", \\"target\\", \\"replace\\") \\"\\"","solution":"def replace_substring(s: str, target: str, replacement: str) -> str: Replaces all occurrences of target substring in the input string with the replacement substring. Parameters: - s: str, the original string - target: str, the substring to be replaced - replacement: str, the substring to replace with Returns: - str, the modified string with replacements made if not isinstance(s, str) or not isinstance(target, str) or not isinstance(replacement, str): raise ValueError(\\"All inputs must be of type str\\") if target == \\"\\": return s # If target is empty, we do nothing as we cannot replace an empty string return s.replace(target, replacement)"},{"question":"def partition_tasks(tasks: list, T: int) -> list: Partitions a list of task durations into sessions, each not exceeding total duration \`T\`. Parameters: tasks (list): A list of integers representing task durations. T (int): The maximum duration allowed for each session. Returns: list: A nested list, where each inner list contains the tasks for a single session. Raises: ValueError: If any task duration exceeds \`T\`.","solution":"def partition_tasks(tasks: list, T: int) -> list: Partitions a list of task durations into sessions, each not exceeding total duration \`T\`. Parameters: tasks (list): A list of integers representing task durations. T (int): The maximum duration allowed for each session. Returns: list: A nested list, where each inner list contains the tasks for a single session. Raises: ValueError: If any task duration exceeds \`T\`. sessions = [] current_session = [] current_duration = 0 for task in tasks: if task > T: raise ValueError(\\"Task duration cannot exceed T\\") if current_duration + task <= T: current_session.append(task) current_duration += task else: sessions.append(current_session) current_session = [task] current_duration = task if current_session: sessions.append(current_session) return sessions"},{"question":"# Completion Task Find the missing numbers in a sorted list of distinct integers that should be present in the range from the smallest to the largest number in the list. def find_missing_numbers(nums: list[int]) -> list[int]: Find the missing numbers in a sorted list of distinct integers that should be present in the range from the smallest to the largest number in the list. Args: nums (list[int]): A sorted list of distinct integers. Returns: list[int]: A list of the missing integers in the range. Example: >>> find_missing_numbers([1, 2, 4, 6]) [3, 5] >>> find_missing_numbers([3, 7, 8, 10]) [4, 5, 6, 9] if not nums: return [] return [i for i in range(nums[0], nums[-1] + 1) if i not in nums] def test_find_missing_numbers(): assert find_missing_numbers([1, 2, 4, 6]) == [3, 5] assert find_missing_numbers([3, 7, 8, 10]) == [4, 5, 6, 9] assert find_missing_numbers([-3, -1, 0, 1, 3]) == [-2, 2] assert find_missing_numbers([5, 6, 9, 11]) == [7, 8, 10] assert find_missing_numbers([]) == [] assert find_missing_numbers([10, 11, 12, 13, 14]) == [] assert find_missing_numbers([-10, -8, -6, -5, -3]) == [-9, -7, -4] assert find_missing_numbers([1]) == []","solution":"def find_missing_numbers(nums: list[int]) -> list[int]: Find the missing numbers in a sorted list of distinct integers that should be present in the range from the smallest to the largest number in the list. Args: nums (list[int]): A sorted list of distinct integers. Returns: list[int]: A list of the missing integers in the range. Example: >>> find_missing_numbers([1, 2, 4, 6]) [3, 5] >>> find_missing_numbers([3, 7, 8, 10]) [4, 5, 6, 9] if not nums: return [] return [i for i in range(nums[0], nums[-1] + 1) if i not in nums]"},{"question":"def custom_xor_encrypt(message: bytes, key: bytes) -> bytes: Encrypts the message using XOR with the provided key. Args: message (bytes): The original message as a byte string. key (bytes): The encryption key as a byte string. Returns: bytes: The encrypted message. Examples: >>> custom_xor_encrypt(b\\"\\", b\\"key\\") b\\"\\" >>> custom_xor_encrypt(b\\"hello\\", b\\"key\\") != b\\"hello\\" pass def custom_xor_decrypt(encrypted_message: bytes, key: bytes) -> bytes: Decrypts the message that was encrypted using XOR with the provided key. Args: encrypted_message (bytes): The encrypted message as a byte string. key (bytes): The encryption key as a byte string. Returns: bytes: The decrypted original message. Examples: >>> message = b\\"this is a secret message\\" >>> key = b\\"mykey\\" >>> encrypted_message = custom_xor_encrypt(message, key) >>> custom_xor_decrypt(encrypted_message, key) == message True pass # Unit tests def test_empty_message(): assert custom_xor_encrypt(b\\"\\", b\\"key\\") == b\\"\\" assert custom_xor_decrypt(b\\"\\", b\\"key\\") == b\\"\\" def test_empty_key(): message = b\\"hello\\" assert custom_xor_encrypt(message, b\\"\\") == message assert custom_xor_decrypt(message, b\\"\\") == message def test_same_length_key(): message = b\\"hello\\" key = b\\"abcde\\" encrypted_message = custom_xor_encrypt(message, key) assert encrypted_message != message assert custom_xor_decrypt(encrypted_message, key) == message def test_different_length_key(): message = b\\"longer message\\" key = b\\"key\\" encrypted_message = custom_xor_encrypt(message, key) assert encrypted_message != message assert custom_xor_decrypt(encrypted_message, key) == message def test_long_message_short_key(): message = b\\"this is a long secret message\\" key = b\\"key\\" encrypted_message = custom_xor_encrypt(message, key) assert encrypted_message != message assert custom_xor_decrypt(encrypted_message, key) == message def test_long_key_short_message(): message = b\\"short\\" key = b\\"averyverylongkey\\" encrypted_message = custom_xor_encrypt(message, key) assert encrypted_message != message assert custom_xor_decrypt(encrypted_message, key) == message def test_reversible_process(): message = b\\"this is a test message\\" key = b\\"mykey\\" encrypted_message = custom_xor_encrypt(message, key) decrypted_message = custom_xor_decrypt(encrypted_message, key) assert decrypted_message == message def test_non_ascii_characters(): message = b\\"x00xffxccxdd\\" key = b\\"xaaxbb\\" encrypted_message = custom_xor_encrypt(message, key) assert encrypted_message != message assert custom_xor_decrypt(encrypted_message, key) == message","solution":"def custom_xor_encrypt(message: bytes, key: bytes) -> bytes: Encrypts the message using XOR with the provided key. if not key: return message encrypted_message = bytearray() key_length = len(key) for i, byte in enumerate(message): encrypted_message.append(byte ^ key[i % key_length]) return bytes(encrypted_message) def custom_xor_decrypt(encrypted_message: bytes, key: bytes) -> bytes: Decrypts the message that was encrypted using XOR with the provided key. # Since XOR encryption is symmetric, decryption is the same as encryption return custom_xor_encrypt(encrypted_message, key)"},{"question":"def dfs_traversal(n, edges): Perform a Depth-First Search (DFS) traversal of a directed graph and detect if a cycle exists. Args: n (int): Number of nodes in the graph. edges (List[Tuple[int, int]]): List of directed edges (u, v). Returns: Tuple[List[int], bool]: A tuple with the order of DFS traversal and a boolean indicating if a cycle exists. >>> dfs_traversal(4, [(0, 1), (1, 2), (2, 0), (2, 3)]) ([0, 1, 2, 3], True) >>> dfs_traversal(2, [(0, 1)]) ([0, 1], False) pass # Example Usage n = 4 edges = [(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3)] dfs_order, contains_cycle = dfs_traversal(n, edges) print(dfs_order) # Example Output: [0, 1, 2, 3] print(contains_cycle) # Example Output: True","solution":"def dfs_traversal(n, edges): from collections import defaultdict # Build adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = [False] * n rec_stack = [False] * n dfs_order = [] contains_cycle = False def dfs(node): nonlocal contains_cycle visited[node] = True rec_stack[node] = True dfs_order.append(node) for neighbor in graph[node]: if not visited[neighbor]: if dfs(neighbor): contains_cycle = True elif rec_stack[neighbor]: contains_cycle = True rec_stack[node] = False return contains_cycle for node in range(n): if not visited[node]: if dfs(node): contains_cycle = True return dfs_order, contains_cycle"},{"question":"def count_occurrences(numbers: list[int]) -> dict[int, int]: Returns a dictionary with the counts of each integer in the input list. >>> count_occurrences([1, 2, 2, 3, 1, 1, 4]) {1: 3, 2: 2, 3: 1, 4: 1} >>> count_occurrences([4, 4, 4, 4]) {4: 4} >>> count_occurrences([]) {} >>> count_occurrences([-1, -1, -1, -2, -2, 0]) {-1: 3, -2: 2, 0: 1} >>> count_occurrences([-1, 1, 0, 1, 0, -1, 1]) {-1: 2, 1: 3, 0: 2}","solution":"def count_occurrences(numbers: list[int]) -> dict[int, int]: Returns a dictionary with the counts of each integer in the input list. occurrence_dict = {} for number in numbers: if number in occurrence_dict: occurrence_dict[number] += 1 else: occurrence_dict[number] = 1 return occurrence_dict"},{"question":"def valid_palindrome(s: str) -> bool: Determine if the string can be made into a palindrome by removing at most one character. >>> valid_palindrome(\\"abca\\") == True >>> valid_palindrome(\\"palap\\") == True >>> valid_palindrome(\\"racecar\\") == True >>> valid_palindrome(\\"deified\\") == True >>> valid_palindrome(\\"hello\\") == False >>> valid_palindrome(\\"abcdef\\") == False >>> valid_palindrome(\\"a\\") == True >>> valid_palindrome(\\"b\\") == True >>> valid_palindrome(\\"\\") == True","solution":"def valid_palindrome(s: str) -> bool: Determine if the string can be made into a palindrome by removing at most one character. def is_palindrome_range(i, j): Check if s[i:j+1] is a palindrome. return all(s[k] == s[j-k+i] for k in range(i, (i+j)//2 + 1)) l, r = 0, len(s) - 1 while l < r: if s[l] != s[r]: # Try to skip either the left character or the right character return is_palindrome_range(l+1, r) or is_palindrome_range(l, r-1) l += 1 r -= 1 return True"},{"question":"from typing import List def has_path(grid: List[List[int]]) -> bool: Determine if there is a path from the top-left corner to the bottom-right corner of the grid. >>> has_path([ ... [1, 0, 0, 0], ... [1, 1, 0, 0], ... [0, 1, 0, 0], ... [0, 1, 1, 1] ... ]) True >>> has_path([ ... [1, 0, 0, 0], ... [0, 1, 0, 0], ... [0, 1, 0, 0], ... [0, 0, 0, 1] ... ]) False pass","solution":"from collections import deque from typing import List def has_path(grid: List[List[int]]) -> bool: if not grid or grid[0][0] == 0 or grid[-1][-1] == 0: return False rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (rows - 1, cols - 1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1 and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"class BankAccount: Class to simulate basic bank account operations: deposit, withdraw, check balance, and maintain transaction history. def __init__(self): self._balance = 0 self._history = [] def deposit(self, amount): Add a specified amount to the balance and log the transaction. def withdraw(self, amount): Subtract a specified amount from the balance if sufficient funds are available and log the transaction. def check_balance(self): Return the current balance and log the check balance operation. def get_history(self): Return the transaction history. def process_transactions(transactions): Function to process a list of transactions on a bank account and return results for check balance and history operations. Args: transactions (list): List of transactions, where each transaction is a list with operation name followed by parameters. Returns: list: Results of check balance and history operations. Example: >>> process_transactions([[\\"deposit\\", 100], [\\"withdraw\\", 50], [\\"check_balance\\"], [\\"deposit\\", 200], [\\"history\\"]]) [50, 250, [\\"Deposited 100\\", \\"Withdrew 50\\", \\"Checked balance: 50\\", \\"Deposited 200\\"]] # Unit Tests from solution import process_transactions def test_single_deposit(): assert process_transactions([[\\"deposit\\", 100], [\\"check_balance\\"]]) == [100] def test_single_withdraw(): assert process_transactions([[\\"deposit\\", 100], [\\"withdraw\\", 50], [\\"check_balance\\"]]) == [50] def test_withdraw_insufficient_funds(): assert process_transactions([[\\"deposit\\", 100], [\\"withdraw\\", 150], [\\"check_balance\\"], [\\"history\\"]]) == [100, [\\"Deposited 100\\", \\"Attempted to withdraw 150: Insufficient funds\\", \\"Checked balance: 100\\"]] def test_check_balance(): assert process_transactions([[\\"deposit\\", 100], [\\"check_balance\\"], [\\"deposit\\", 200], [\\"check_balance\\"]]) == [100, 300] def test_transaction_history(): response = process_transactions([[\\"deposit\\", 100], [\\"withdraw\\", 50], [\\"check_balance\\"], [\\"deposit\\", 200], [\\"history\\"]]) expected_history = [\\"Deposited 100\\", \\"Withdrew 50\\", \\"Checked balance: 50\\", \\"Deposited 200\\"] assert response == [50, expected_history] def test_empty_history(): assert process_transactions([[\\"history\\"]]) == [[]]","solution":"class BankAccount: def __init__(self): self._balance = 0 self._history = [] def deposit(self, amount): self._balance += amount self._history.append(f\\"Deposited {amount}\\") def withdraw(self, amount): if amount <= self._balance: self._balance -= amount self._history.append(f\\"Withdrew {amount}\\") else: self._history.append(f\\"Attempted to withdraw {amount}: Insufficient funds\\") def check_balance(self): self._history.append(f\\"Checked balance: {self._balance}\\") return self._balance def get_history(self): return self._history def process_transactions(transactions): account = BankAccount() results = [] for transaction in transactions: if transaction[0] == \\"deposit\\": account.deposit(transaction[1]) elif transaction[0] == \\"withdraw\\": account.withdraw(transaction[1]) elif transaction[0] == \\"check_balance\\": results.append(account.check_balance()) elif transaction[0] == \\"history\\": results.append(account.get_history()) return results"},{"question":"from typing import List, Tuple def a_star_search(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]: Perform A* search to find the shortest path from start to goal in a grid with obstacles. Args: grid: A 2D list of integers representing the grid. 0 represents an open cell, and 1 represents an obstacle. start: A tuple representing the starting cell (x, y) in the grid. goal: A tuple representing the goal cell (x, y) in the grid. Returns: A list of tuples representing the cells (x, y) that form the path from start to goal (inclusive). If no path is found, return an empty list. >>> grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] >>> start = (0, 0) >>> goal = (4, 4) >>> a_star_search(grid, start, goal) [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (4, 2), (4, 3), (4, 4)] >>> grid = [ [0, 1, 0], [1, 1, 0], [0, 1, 0] ] >>> start = (0, 0) >>> goal = (2, 2) >>> a_star_search(grid, start, goal) []","solution":"from heapq import heappop, heappush from typing import List, Tuple def heuristic(a: Tuple[int, int], b: Tuple[int, int]) -> int: Calculate the Manhattan distance heuristic. return abs(a[0] - b[0]) + abs(a[1] - b[1]) def a_star_search(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]: Perform A* search to find the shortest path from start to goal in a grid with obstacles. rows, cols = len(grid), len(grid[0]) open_set = [(0, start)] # Priority queue: (f_score, position) came_from = {} # Path dictionary g_score = {start: 0} f_score = {start: heuristic(start, goal)} while open_set: current = heappop(open_set)[1] if current == goal: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) path.reverse() return path for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: neighbor = (current[0] + dx, current[1] + dy) if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols and grid[neighbor[0]][neighbor[1]] == 0: tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal) heappush(open_set, (f_score[neighbor], neighbor)) return []"},{"question":"def unique_elements_in_subarrays(arr: list[int], k: int) -> list[int]: Calculates the number of unique elements in every subarray of length k. Args: arr: list[int] - A list of integers. k: int - The length of the subarray. Returns: list[int]: A list where the i-th element is the number of unique elements in the subarray starting at index i. Examples: >>> unique_elements_in_subarrays([1, 2, 2, 1, 3, 4, 2, 3, 3], 3) [2, 2, 3, 3, 3, 3, 2] >>> unique_elements_in_subarrays([4, 4, 4, 4, 4], 1) [1, 1, 1, 1, 1] from solution import unique_elements_in_subarrays def test_unique_elements_in_subarrays_basic(): assert unique_elements_in_subarrays([1, 2, 2, 1, 3, 4, 2, 3, 3], 3) == [2, 2, 3, 3, 3, 3, 2] def test_unique_elements_in_subarrays_single_repeated_element(): assert unique_elements_in_subarrays([4, 4, 4, 4, 4], 1) == [1, 1, 1, 1, 1] def test_unique_elements_in_subarrays_entirely_non_repeating(): assert unique_elements_in_subarrays([1, 2, 3, 4, 5], 5) == [5] def test_unique_elements_in_subarrays_single_element_subarrays(): assert unique_elements_in_subarrays([1, 2, 3, 2, 1], 1) == [1, 1, 1, 1, 1] def test_unique_elements_in_subarrays_k_equals_length(): assert unique_elements_in_subarrays([7, 8, 9, 10, 9], 5) == [4] def test_unique_elements_in_subarrays_empty_array(): assert unique_elements_in_subarrays([], 3) == [] def test_unique_elements_in_subarrays_k_larger_than_array(): assert unique_elements_in_subarrays([1, 2, 3], 4) == [] def test_unique_elements_in_subarrays_negative_numbers(): assert unique_elements_in_subarrays([-1, -2, -2, -1, -3], 3) == [2, 2, 3]","solution":"def unique_elements_in_subarrays(arr: list[int], k: int) -> list[int]: if not arr or k <= 0 or k > len(arr): return [] from collections import defaultdict unique_count = [] element_counts = defaultdict(int) unique_elements = 0 for i in range(len(arr)): if element_counts[arr[i]] == 0: unique_elements += 1 element_counts[arr[i]] += 1 if i >= k: if element_counts[arr[i - k]] == 1: unique_elements -= 1 element_counts[arr[i - k]] -= 1 if i >= k - 1: unique_count.append(unique_elements) return unique_count"},{"question":"def trap_rain_water(heights: list) -> int: Calculate the total volume of water trapped between the buildings after raining. :param heights: List of positive integers where each integer represents the height of a building. :return: Integer representing the total volume of water trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped def test_example_cases(): assert trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 assert trap_rain_water([4, 2, 0, 3, 2, 5]) == 9 def test_uniform_height(): assert trap_rain_water([3, 3, 3, 3]) == 0 def test_increasing_height(): assert trap_rain_water([1, 2, 3, 4, 5]) == 0 def test_decreasing_height(): assert trap_rain_water([5, 4, 3, 2, 1]) == 0 def test_single_element(): assert trap_rain_water([5]) == 0 def test_two_elements(): assert trap_rain_water([1, 2]) == 0 def test_complex_case(): assert trap_rain_water([0, 2, 0, 3, 0, 1]) == 3 assert trap_rain_water([4, 2, 3]) == 1 def test_empty_list(): assert trap_rain_water([]) == 0","solution":"def trap_rain_water(heights: list) -> int: Calculate the total volume of water trapped between the buildings after raining. :param heights: List of positive integers where each integer represents the height of a building. :return: Integer representing the total volume of water trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def diagonal_sum(matrix: list[list[int]]) -> int: Calculate the sum of the main diagonal elements of a square matrix. Args: matrix (list[list[int]]): a square matrix of integers. Returns: int: the sum of the main diagonal elements. Examples: >>> diagonal_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 15 >>> diagonal_sum([ ... [10, 0, 0, 1], ... [0, 20, 0, 2], ... [0, 0, 30, 3], ... [4, 5, 6, 40] ... ]) 100 >>> diagonal_sum([[1]]) 1 >>> diagonal_sum([ ... [2, 2], ... [2, 2] ... ]) 4 >>> diagonal_sum([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) 3","solution":"def diagonal_sum(matrix: list[list[int]]) -> int: Calculate the sum of the main diagonal elements of a square matrix. Args: matrix (list[list[int]]): a square matrix of integers. Returns: int: the sum of the main diagonal elements. return sum(matrix[i][i] for i in range(len(matrix)))"},{"question":"def remove_consecutive_duplicates(text: str) -> str: Create a function that identifies and removes consecutive duplicate words in a given text. The function should also ensure that the resulting text has only single spaces between words and no leading or trailing spaces. >>> remove_consecutive_duplicates(\\"This is is a test test\\") == \\"This is a test\\" >>> remove_consecutive_duplicates(\\"Hello Hello world world\\") == \\"Hello world\\" >>> remove_consecutive_duplicates(\\"No duplicates here\\") == \\"No duplicates here\\" >>> remove_consecutive_duplicates(\\" a a a b c c \\") == \\"a b c\\" >>> remove_consecutive_duplicates(\\"\\") == \\"\\" >>> remove_consecutive_duplicates(\\"Same word same word\\") == \\"Same word same word\\"","solution":"def remove_consecutive_duplicates(text: str) -> str: if not text: return \\"\\" words = text.split() result = [] for i, word in enumerate(words): if i == 0 or word != words[i - 1]: result.append(word) return ' '.join(result)"},{"question":"def compute_employee_reports(employee_hierarchy: List[Tuple[int, int]]) -> Dict[int, int]: Compute the total number of direct and indirect reports for each employee in a given hierarchy. Args: employee_hierarchy (List[Tuple[int, int]]): A list of tuples representing the employee-manager relationships, where each tuple is (employee, manager). Returns: Dict[int, int]: A dictionary where keys are employee IDs and values are the total number of reports (direct and indirect). Example: >>> compute_employee_reports([(2, 1), (3, 1), (4, 2), (5, 2), (6, 3)]) {1: 5, 2: 2, 3: 1, 4: 0, 5: 0, 6: 0}","solution":"from typing import List, Tuple, Dict from collections import defaultdict def compute_employee_reports(employee_hierarchy: List[Tuple[int, int]]) -> Dict[int, int]: # Build the graph adjacency list and a dictionary to hold the counts graph = defaultdict(list) report_counts = defaultdict(int) for employee, manager in employee_hierarchy: graph[manager].append(employee) # Initialize all employees in the hierarchy report_counts[employee] report_counts[manager] # Function to count reports using DFS def dfs(employee): count = 0 for report in graph[employee]: count += 1 + dfs(report) report_counts[employee] = count return count # Find the CEO (the one who is not anybody's report) all_employees = set(report_counts.keys()) non_ceos = set(employee for employee, _ in employee_hierarchy) ceo = (all_employees - non_ceos).pop() # Start DFS from the CEO dfs(ceo) return report_counts"},{"question":"def enhanced_community_detection( graph: dict[int, list[tuple[int, int]]], max_passes: int, min_modularity_gain: float ) -> dict[int, int]: Detects communities in a given graph using an optimized version of the Louvain method. >>> graph = { ... 0: [(1, 1), (2, 1)], ... 1: [(0, 1), (2, 1)], ... 2: [(0, 1), (1, 1), (3, 1)], ... 3: [(2, 1), (4, 1)], ... 4: [(3, 1)] ... } >>> enhanced_community_detection(graph, 10, 0.0001) {0: 0, 1: 0, 2: 0, 3: 1, 4: 1} pass # Unit tests def test_community_detection_small_graph(): graph = { 0: [(1, 1), (2, 1)], 1: [(0, 1), (2, 1)], 2: [(0, 1), (1, 1), (3, 1)], 3: [(2, 1), (4, 1)], 4: [(3, 1)] } result = enhanced_community_detection(graph, max_passes=10, min_modularity_gain=0.0001) assert result in [ {0: 0, 1: 0, 2: 0, 3: 1, 4: 1}, {0: 1, 1: 1, 2: 1, 3: 0, 4: 0} ] def test_disconnected_graph(): graph = { 0: [(1, 1)], 1: [(0, 1)], 2: [(3, 1)], 3: [(2, 1)] } result = enhanced_community_detection(graph, max_passes=10, min_modularity_gain=0.0001) assert result in [ {0: 0, 1: 0, 2: 1, 3: 1}, {0: 1, 1: 1, 2: 0, 3: 0} ] def test_single_node_graph(): graph = { 0: [] } result = enhanced_community_detection(graph, max_passes=10, min_modularity_gain=0.0001) assert result == {0: 0} def test_graph_with_no_edges(): graph = { 0: [], 1: [] } result = enhanced_community_detection(graph, max_passes=10, min_modularity_gain=0.0001) assert result == {0: 0, 1: 1} def test_complete_graph(): graph = { 0: [(1, 1), (2, 1), (3, 1)], 1: [(0, 1), (2, 1), (3, 1)], 2: [(0, 1), (1, 1), (3, 1)], 3: [(0, 1), (1, 1), (2, 1)] } result = enhanced_community_detection(graph, max_passes=10, min_modularity_gain=0.0001) assert result == {0: 0, 1: 0, 2: 0, 3: 0}","solution":"def enhanced_community_detection( graph: dict[int, list[tuple[int, int]]], max_passes: int, min_modularity_gain: float ) -> dict[int, int]: from collections import defaultdict import math def modularity_gain(graph, communities, node, new_comm, total_weight): # calculates modularity gain of moving node to new_comm current_comm = communities[node] node_weight = sum([weight for _, weight in graph[node]]) community_weight = sum([sum([weight for _, weight in graph[n]]) for n in communities if communities[n] == new_comm]) inner_links = sum([weight for neighbor, weight in graph[node] if communities[neighbor] == new_comm]) if current_comm == new_comm: return 0 delta_q = (inner_links / total_weight) - (node_weight / (2 * total_weight)) * (community_weight / (2 * total_weight)) return delta_q def total_modularity(graph, communities, total_weight): # calculates total modularity q = 0 for node in graph: for neighbor, weight in graph[node]: if communities[node] == communities[neighbor]: q += weight return q / (2 * total_weight) # Initialization communities = {node: node for node in graph} # initially each node is its own community total_weight = sum([weight for neighbors in graph.values() for _, weight in neighbors]) / 2 for _ in range(max_passes): improved = False for node in graph: best_comm = communities[node] best_gain = 0 # Remove node from its community original_comm = communities[node] communities[node] = None for neighbor, _ in graph[node]: new_comm = communities[neighbor] gain = modularity_gain(graph, communities, node, new_comm, total_weight) if gain > best_gain: best_gain = gain best_comm = new_comm if best_gain > min_modularity_gain: communities[node] = best_comm improved = True else: communities[node] = original_comm if not improved: break # Re-index communities to be sequential comm_index = {} counter = 0 for node in communities: if communities[node] not in comm_index: comm_index[communities[node]] = counter counter += 1 communities[node] = comm_index[communities[node]] return communities"},{"question":"def filter_even_numbers(nums: list[int]) -> list[int]: return [num for num in nums if num % 2 == 0] def filter_odd_numbers(nums: list[int]) -> list[int]: return [num for num in nums if num % 2 != 0] def filter_numbers(nums: list[int], filter_type: str) -> list[int]: Filters the list of integers based on the specified filter type. Uses the \`filter_even_numbers\` function if the \`filter_type\` provided is \\"even\\". Uses the \`filter_odd_numbers\` function if the \`filter_type\` provided is \\"odd\\". Raises a \`ValueError\` with an appropriate error message if the \`filter_type\` is neither \\"even\\" nor \\"odd\\". Handles an empty list by returning an empty list. Args: nums (list of int): The list of numbers to be filtered. filter_type (str): A string indicating the type of numbers to filter, either \\"even\\" or \\"odd\\". Returns: list of int: A new list of integers containing only the filtered numbers based on the \`filter_type\`. Examples: >>> filter_numbers([1, 2, 3, 4, 5, 6], \\"even\\") [2, 4, 6] >>> filter_numbers([1, 2, 3, 4, 5, 6], \\"odd\\") [1, 3, 5] >>> filter_numbers([], \\"even\\") [] >>> filter_numbers([10, 15, 20, 25], \\"even\\") [10, 20] >>> filter_numbers([10, 15, 20, 25], \\"odd\\") [15, 25] >>> filter_numbers([1, 3, 5, 7, 9], \\"odd\\") [1, 3, 5, 7, 9] >>> filter_numbers([1, 3, 5, 7, 9], \\"even\\") [] >>> filter_numbers([1, 2, 3, 4], \\"prime\\") Traceback (most recent call last): ... ValueError: filter_numbers() unknown filter type \\"prime\\" if filter_type == \\"even\\": return filter_even_numbers(nums) elif filter_type == \\"odd\\": return filter_odd_numbers(nums) else: raise ValueError(f'filter_numbers() unknown filter type \\"{filter_type}\\"')","solution":"def filter_even_numbers(nums: list[int]) -> list[int]: return [num for num in nums if num % 2 == 0] def filter_odd_numbers(nums: list[int]) -> list[int]: return [num for num in nums if num % 2 != 0] def filter_numbers(nums: list[int], filter_type: str) -> list[int]: if filter_type == \\"even\\": return filter_even_numbers(nums) elif filter_type == \\"odd\\": return filter_odd_numbers(nums) else: raise ValueError(f'filter_numbers() unknown filter type \\"{filter_type}\\"')"},{"question":"def rotate_clockwise(matrix: list[list[int]]) -> list[list[int]]: Rotate the given NxN matrix 90 degrees clockwise. >>> rotate_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ] >>> rotate_clockwise([[1]]) == [[1]] >>> rotate_clockwise([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) == [ ... [13, 9, 5, 1], ... [14, 10, 6, 2], ... [15, 11, 7, 3], ... [16, 12, 8, 4] ... ] pass def rotate_counterclockwise(matrix: list[list[int]]) -> list[list[int]]: Rotate the given NxN matrix 90 degrees counterclockwise. >>> rotate_counterclockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [ ... [3, 6, 9], ... [2, 5, 8], ... [1, 4, 7] ... ] >>> rotate_counterclockwise([[1]]) == [[1]] >>> rotate_counterclockwise([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) == [ ... [4, 8, 12, 16], ... [3, 7, 11, 15], ... [2, 6, 10, 14], ... [1, 5, 9, 13] ... ] pass","solution":"def rotate_clockwise(matrix: list[list[int]]) -> list[list[int]]: Rotate the given NxN matrix 90 degrees clockwise. n = len(matrix) result = [] for i in range(n): new_row = [matrix[n - j - 1][i] for j in range(n)] result.append(new_row) return result def rotate_counterclockwise(matrix: list[list[int]]) -> list[list[int]]: Rotate the given NxN matrix 90 degrees counterclockwise. n = len(matrix) result = [] for i in range(n): new_row = [matrix[j][n - i - 1] for j in range(n)] result.append(new_row) return result"},{"question":"def find_optimal_path(grid: list[list[int]], start: tuple[int, int], end: tuple[int, int]) -> list[tuple[int, int]]: Finds the shortest path in a rectangular grid from the start point to the end point. from collections import deque rows, cols = len(grid), len(grid[0]) queue = deque([(start, [start])]) visited = set([start]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: (current_row, current_col), path = queue.popleft() if (current_row, current_col) == end: return path for d_row, d_col in directions: new_row, new_col = current_row + d_row, current_col + d_col if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1 and (new_row, new_col) not in visited: queue.append(((new_row, new_col), path + [(new_row, new_col)])) visited.add((new_row, new_col)) return []","solution":"from collections import deque def find_optimal_path(grid, start, end): Finds the shortest path in a rectangular grid from the start point to the end point. rows, cols = len(grid), len(grid[0]) queue = deque([(start, [start])]) visited = set([start]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: (current_row, current_col), path = queue.popleft() if (current_row, current_col) == end: return path for d_row, d_col in directions: new_row, new_col = current_row + d_row, current_col + d_col if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1 and (new_row, new_col) not in visited: queue.append(((new_row, new_col), path + [(new_row, new_col)])) visited.add((new_row, new_col)) return []"},{"question":"def find_min_rotated_sorted_array(nums: list[int]) -> int: Returns the smallest element in the rotated sorted array. >>> find_min_rotated_sorted_array([3, 4, 5, 1, 2]) 1 >>> find_min_rotated_sorted_array([4, 5, 6, 7, 0, 1, 2]) 0 >>> find_min_rotated_sorted_array([11, 13, 15, 17]) 11 >>> find_min_rotated_sorted_array([2, 1]) 1 Raises: ValueError: If nums is not a list of integers or is empty. if not isinstance(nums, list) or not nums: raise ValueError(\\"nums must be a list of integers and cannot be empty\\") if not all(isinstance(x, int) for x in nums): raise ValueError(\\"nums must be a list of integers\\") left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: left = mid + 1 else: right = mid return nums[left]","solution":"def find_min_rotated_sorted_array(nums): Returns the smallest element in the rotated sorted array. Parameters: nums (list[int]): List of integers representing a rotated sorted array. Returns: int: The smallest element in the array. Raises: ValueError: If nums is not a list of integers or is empty. if not isinstance(nums, list) or not nums: raise ValueError(\\"nums must be a list of integers and cannot be empty\\") if not all(isinstance(x, int) for x in nums): raise ValueError(\\"nums must be a list of integers\\") left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: left = mid + 1 else: right = mid return nums[left]"},{"question":"from typing import List, Dict def schedule_tasks(tasks: List[str], durations: Dict[str, int], dependencies: Dict[str, List[str]], n: int) -> List[str]: You are tasked with implementing a task scheduling function that organizes a list of tasks to be executed in a way that minimizes the total time. Each task has a specific duration, and certain tasks cannot start until others are completed. Implement a function to determine the order of task execution based on dependencies and concurrent execution capacity. >>> tasks = [\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"] >>> durations = {\\"A\\": 3, \\"B\\": 2, \\"C\\": 1, \\"D\\": 4, \\"E\\": 1} >>> dependencies = {\\"B\\": [\\"A\\"], \\"C\\": [\\"A\\"], \\"D\\": [\\"B\\", \\"C\\"], \\"E\\": [\\"D\\"]} >>> n = 2 >>> schedule_tasks(tasks, durations, dependencies, n) [\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"] >>> tasks = [\\"A\\", \\"B\\", \\"C\\"] >>> durations = {\\"A\\": 1, \\"B\\": 2, \\"C\\": 3} >>> dependencies = {} >>> n = 2 >>> schedule_tasks(tasks, durations, dependencies, n) [\\"A\\", \\"B\\", \\"C\\"] >>> tasks = [\\"A\\", \\"B\\", \\"C\\"] >>> durations = {\\"A\\": 1, \\"B\\": 2, \\"C\\": 3} >>> dependencies = {\\"B\\": [\\"A\\"], \\"C\\": [\\"B\\"]} >>> n = 3 >>> schedule_tasks(tasks, durations, dependencies, n) [\\"A\\", \\"B\\", \\"C\\"] >>> tasks = [\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\", \\"F\\", \\"G\\"] >>> durations = {\\"A\\": 1, \\"B\\": 2, \\"C\\": 1, \\"D\\": 2, \\"E\\": 3, \\"F\\": 1, \\"G\\": 2} >>> dependencies = {\\"B\\": [\\"A\\"], \\"C\\": [\\"B\\"], \\"D\\": [\\"B\\"], \\"E\\": [\\"C\\", \\"D\\"], \\"F\\": [\\"B\\"], \\"G\\": [\\"F\\", \\"E\\"]} >>> n = 3 >>> schedule_tasks(tasks, durations, dependencies, n) [\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"F\\", \\"E\\", \\"G\\"] >>> tasks = [\\"A\\", \\"B\\", \\"C\\"] >>> durations = {\\"A\\": 1, \\"B\\": 2, \\"C\\": 3} >>> dependencies = {\\"B\\": [\\"A\\"], \\"C\\": [\\"B\\"], \\"A\\": [\\"C\\"]} >>> n = 1 >>> try: ... schedule_tasks(tasks, durations, dependencies, n) ... assert False, \\"Expected ValueError for cyclic dependencies\\" ... except ValueError: ... pass pass","solution":"from typing import List, Dict from collections import deque, defaultdict def topological_sort(tasks: List[str], dependencies: Dict[str, List[str]]) -> List[str]: # Building adjacency list and in-degree counts adj_list = defaultdict(list) in_degree = {task: 0 for task in tasks} for task, deps in dependencies.items(): for dep in deps: adj_list[dep].append(task) in_degree[task] += 1 # Collect tasks with no dependencies queue = deque([task for task in tasks if in_degree[task] == 0]) sorted_tasks = [] while queue: task = queue.popleft() sorted_tasks.append(task) for neighbor in adj_list[task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(sorted_tasks) == len(tasks): return sorted_tasks else: raise ValueError(\\"A cycle was detected in the task dependencies.\\") def schedule_tasks(tasks: List[str], durations: Dict[str, int], dependencies: Dict[str, List[str]], n: int) -> List[str]: sorted_tasks = topological_sort(tasks, dependencies) task_finished_at = {} current_time = 0 in_progress = [] task_execution_order = [] for task in sorted_tasks: while len(in_progress) >= n: # Find the task that will complete the earliest earliest_finish = min(task_finished_at[task] for task in in_progress) current_time = earliest_finish in_progress = [task for task in in_progress if task_finished_at[task] > current_time] task_start_time = max(current_time, max((task_finished_at[dep] for dep in dependencies.get(task, [])), default=current_time)) task_finished_at[task] = task_start_time + durations[task] current_time = task_start_time in_progress.append(task) task_execution_order.append(task) return task_execution_order"},{"question":"def generate_combinations(s: str) -> list[str]: Generate all possible combinations of the given string using backtracking. >>> generate_combinations(\\"abc\\") [\\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"ac\\", \\"bc\\", \\"abc\\"] >>> generate_combinations(\\"\\") [] >>> generate_combinations(\\"a\\") [\\"a\\"] >>> generate_combinations(\\"ab\\") [\\"a\\", \\"b\\", \\"ab\\"] >>> generate_combinations(\\"abcd\\") [ \\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"ab\\", \\"ac\\", \\"ad\\", \\"bc\\", \\"bd\\", \\"cd\\", \\"abc\\", \\"abd\\", \\"acd\\", \\"bcd\\", \\"abcd\\" ]","solution":"def generate_combinations(s: str) -> list[str]: Generate all possible combinations of the given string using backtracking. result = [] def backtrack(start, path): # If path is not empty, append it to the result if path: result.append(\\"\\".join(path)) # Generate combinations by including one character at a time for i in range(start, len(s)): # Add the character to the current combination path.append(s[i]) # Recur with next starting index backtrack(i + 1, path) # Backtrack by removing the last character path.pop() # Start backtracking from the beginning of the string backtrack(0, []) return result"},{"question":"from heapq import heappush, heappop from typing import List, Optional class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: Merge k sorted linked lists and return it as one sorted linked list. >>> list1 = ListNode(1, ListNode(4, ListNode(5))) >>> list2 = ListNode(1, ListNode(3, ListNode(4))) >>> list3 = ListNode(2, ListNode(6)) >>> lists = [list1, list2, list3] >>> merged_head = merge_k_sorted_lists(lists) >>> print_list(merged_head) [1, 1, 2, 3, 4, 4, 5, 6] >>> print_list(merge_k_sorted_lists([])) [] >>> print_list(merge_k_sorted_lists([None, None])) [] pass def print_list(node): Helper function to convert linked list to python list for easy comparison in tests result = [] while node: result.append(node.val) node = node.next return result","solution":"from heapq import heappush, heappop from typing import List, Optional class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: if not lists: return None heap = [] # Push the head node of each list into the heap for i, node in enumerate(lists): if node: heappush(heap, (node.val, i, node)) # Dummy node to keep track of the head of merged list dummy = ListNode(0) current = dummy # Extract nodes from heap and build the final sorted linked list while heap: val, i, node = heappop(heap) current.next = ListNode(val) current = current.next node = node.next if node: heappush(heap, (node.val, i, node)) return dummy.next"},{"question":"[Completion Task in Python] class StringCompressor: def compress_string(self, input_string): Compresses the string using counts of repeated characters. :param input_string: The original string to be compressed. :return: The compressed string or the original string if compression does not reduce the size. if not input_string: return input_string compressed = [] count_consecutive = 0 for i in range(len(input_string)): count_consecutive += 1 # If next character is different than current, append this char to result if i + 1 >= len(input_string) or input_string[i] != input_string[i + 1]: compressed.append(f'{input_string[i]}{count_consecutive}') count_consecutive = 0 compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(input_string) else input_string from solution import StringCompressor def test_compress_string(): sc = StringCompressor() # Test case with repeated characters assert sc.compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" # Test case with no repeated characters assert sc.compress_string(\\"abcdef\\") == \\"abcdef\\" # Test case with an empty string assert sc.compress_string(\\"\\") == \\"\\" # Test case with one character string assert sc.compress_string(\\"a\\") == \\"a\\" # Test case with repeated characters but compression same length as original assert sc.compress_string(\\"aabbcc\\") == \\"aabbcc\\" # Test case with all the same characters assert sc.compress_string(\\"aaaaaa\\") == \\"a6\\" # Additional test case with multiple groups of repeated characters assert sc.compress_string(\\"aaabbbccc\\") == \\"a3b3c3\\" # Test case where compression reduces size but not significantly assert sc.compress_string(\\"aabb\\") == \\"aabb\\" # Test with longer strings to ensure efficiency long_input_string = \\"a\\" * 1000 + \\"b\\" * 1000 long_expected_output = \\"a1000b1000\\" assert sc.compress_string(long_input_string) == long_expected_output","solution":"class StringCompressor: def compress_string(self, input_string): Compresses the string using counts of repeated characters. :param input_string: The original string to be compressed. :return: The compressed string or the original string if compression does not reduce the size. if not input_string: return input_string compressed = [] count_consecutive = 0 for i in range(len(input_string)): count_consecutive += 1 # If next character is different than current, append this char to result if i + 1 >= len(input_string) or input_string[i] != input_string[i + 1]: compressed.append(f'{input_string[i]}{count_consecutive}') count_consecutive = 0 compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(input_string) else input_string"},{"question":"def longest_consecutive_sequence(nums: List[int]) -> int: Returns the length of the longest consecutive elements sequence in the given array. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) 9 >>> longest_consecutive_sequence([]) 0 from typing import List def test_example_cases(): assert longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) == 4 assert longest_consecutive_sequence([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) == 9 assert longest_consecutive_sequence([]) == 0 def test_one_element(): assert longest_consecutive_sequence([10]) == 1 def test_all_duplicates(): assert longest_consecutive_sequence([5, 5, 5, 5]) == 1 def test_multiple_sequences(): assert longest_consecutive_sequence([1, 2, 0, 1]) == 3 assert longest_consecutive_sequence([1, 9, 3, 10, 4, 20, 2]) == 4 def test_large_numbers(): assert longest_consecutive_sequence([1000000000, 999999999, 1000000001]) == 3 def test_mixed_numbers(): assert longest_consecutive_sequence([-1, 0, 1]) == 3 assert longest_consecutive_sequence([-2, -1, -3, 1, 2, 3, 5, 6]) == 3 def test_no_consecutive(): assert longest_consecutive_sequence([-10, 0, 10, 20]) == 1","solution":"def longest_consecutive_sequence(nums): if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: if num - 1 not in nums_set: current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from typing import List def lcm_multiple(nums: List[int]) -> int: Determine the Least Common Multiple (LCM) of a list of integers. The least common multiple (LCM) of two or more integers is the smallest positive integer that is divisible by each of them. Args: nums (List[int]): List of integers. Returns: int: LCM of the list. Constraints: The list \`nums\` will contain between 2 and 100 integers. Each integer in \`nums\` will be between 1 and 10^6 inclusive. Example Usage: >>> lcm_multiple([4, 6]) 12 >>> lcm_multiple([1, 2, 3, 4, 5]) 60 >>> lcm_multiple([5, 10, 15]) 30 >>> lcm_multiple([10, 20, 30, 40]) 120","solution":"from math import gcd from functools import reduce from typing import List def lcm(a: int, b: int) -> int: Helper function to calculate the least common multiple (LCM) of two numbers a and b. return abs(a * b) // gcd(a, b) def lcm_multiple(nums: List[int]) -> int: Returns the least common multiple (LCM) of a list of integers. return reduce(lcm, nums)"},{"question":"from collections import deque from typing import List, Optional class QueueStack: def __init__(self): Initialize the stack using two queues. pass def push(self, x: int): Push element x onto the stack. pass def pop(self) -> Optional[int]: Remove the element on top of the stack and return it. pass def top(self) -> Optional[int]: Get the top element of the stack without removing it. pass def is_empty(self) -> bool: Return True if the stack is empty, False otherwise. pass def process_operations(operations: List[str]) -> List[str]: Process a list of operations on the QueueStack and return a list of results. >>> operations = [ >>> \\"push 10\\", >>> \\"push 20\\", >>> \\"top\\", >>> \\"pop\\", >>> \\"is_empty\\", >>> \\"push 30\\", >>> \\"pop\\", >>> \\"pop\\", >>> \\"is_empty\\", >>> \\"exit\\" >>> ] >>> results = process_operations(operations) >>> print(results) ['20', '20', 'False', '30', '10', 'True'] pass","solution":"from collections import deque from typing import List, Optional class QueueStack: def __init__(self): self.queue1 = deque() self.queue2 = deque() def push(self, x: int): self.queue1.append(x) def pop(self) -> Optional[int]: if self.is_empty(): return None while len(self.queue1) > 1: self.queue2.append(self.queue1.popleft()) popped_element = self.queue1.popleft() self.queue1, self.queue2 = self.queue2, self.queue1 return popped_element def top(self) -> Optional[int]: if self.is_empty(): return None while len(self.queue1) > 1: self.queue2.append(self.queue1.popleft()) top_element = self.queue1[0] self.queue2.append(self.queue1.popleft()) self.queue1, self.queue2 = self.queue2, self.queue1 return top_element def is_empty(self) -> bool: return not self.queue1 def process_operations(operations: List[str]) -> List[str]: result = [] qs = QueueStack() for op in operations: if 'push' in op: _, num = op.split() qs.push(int(num)) elif op == 'pop': result.append(str(qs.pop())) elif op == 'top': result.append(str(qs.top())) elif op == 'is_empty': result.append(str(qs.is_empty())) elif op == 'exit': break return result"},{"question":"from typing import Optional class LibrarySystem: Library management system to manage book borrowings. Methods: - borrow(book: str, member: str) -> None : Borrow a book for a member - return_book(book: str) -> None : Return a borrowed book - is_borrowed(book: str) -> Optional[str] : Check if a book is currently borrowed and by whom Examples: >>> library = LibrarySystem() >>> library.borrow(\\"The Great Gatsby\\", \\"Alice\\") >>> library.is_borrowed(\\"The Great Gatsby\\") \\"Alice\\" >>> library.return_book(\\"The Great Gatsby\\") >>> library.is_borrowed(\\"The Great Gatsby\\") None >>> library.borrow(\\"1984\\", \\"Bob\\") >>> library.is_borrowed(\\"1984\\") \\"Bob\\" def borrow(self, book: str, member: str) -> None: pass def return_book(self, book: str) -> None: pass def is_borrowed(self, book: str) -> Optional[str]: pass # Unit Tests def test_borrow_book(): library = LibrarySystem() library.borrow(\\"The Great Gatsby\\", \\"Alice\\") assert library.is_borrowed(\\"The Great Gatsby\\") == \\"Alice\\" def test_return_book(): library = LibrarySystem() library.borrow(\\"The Great Gatsby\\", \\"Alice\\") library.return_book(\\"The Great Gatsby\\") assert library.is_borrowed(\\"The Great Gatsby\\") is None def test_double_borrow(): library = LibrarySystem() library.borrow(\\"The Great Gatsby\\", \\"Alice\\") library.borrow(\\"The Great Gatsby\\", \\"Bob\\") assert library.is_borrowed(\\"The Great Gatsby\\") == \\"Alice\\" # Bob's borrow should be ignored def test_return_non_borrowed_book(): library = LibrarySystem() library.return_book(\\"Non-existent Book\\") # Should not raise an error assert library.is_borrowed(\\"Non-existent Book\\") is None def test_is_borrowed_for_non_existent_book(): library = LibrarySystem() assert library.is_borrowed(\\"Non-existent Book\\") is None def test_borrow_after_return(): library = LibrarySystem() library.borrow(\\"The Great Gatsby\\", \\"Alice\\") library.return_book(\\"The Great Gatsby\\") library.borrow(\\"The Great Gatsby\\", \\"Charlie\\") assert library.is_borrowed(\\"The Great Gatsby\\") == \\"Charlie\\"","solution":"from typing import Optional class LibrarySystem: def __init__(self): self.borrowed_books = {} def borrow(self, book: str, member: str) -> None: if book not in self.borrowed_books: self.borrowed_books[book] = member def return_book(self, book: str) -> None: if book in self.borrowed_books: del self.borrowed_books[book] def is_borrowed(self, book: str) -> Optional[str]: return self.borrowed_books.get(book, None)"},{"question":"from typing import List, Tuple def top_rated_books(books: List[Tuple[str, List[int]]], N: int) -> List[str]: Write a function \`top_rated_books\` that processes a list of books with their ratings and returns the top N books with the highest average ratings. If two or more books have the same average rating, they should be sorted alphabetically by title. Parameters: 1. books (List[Tuple[str, List[int]]]): A list of tuples where each tuple contains: - a string representing the book title. - a list of integers representing the ratings for that book. 2. N (int): The number of top-rated books to return. Returns: List[str]: A list of strings representing the titles of the top N books with the highest average ratings. If N is greater than the number of books, return the titles of all the books sorted by average rating. Raises: ValueError: If N is less than or equal to zero or if the books list is empty. >>> books = [ (\\"Book A\\", [5, 4, 4]), (\\"Book B\\", [5, 5, 4]), (\\"Book C\\", [4, 4, 5]), (\\"Book D\\", [5, 5, 5]) ] >>> top_rated_books(books, 2) ['Book D', 'Book B'] >>> books = [ (\\"Learn Python\\", [5, 4, 3]), (\\"Advanced Python\\", [4, 4, 4]), (\\"Python Algorithms\\", [5, 5]) ] >>> top_rated_books(books, 3) ['Python Algorithms', 'Advanced Python', 'Learn Python'] >>> books = [(\\"One Book\\", [3])] >>> top_rated_books(books, 1) ['One Book'] >>> books = [ (\\"Book A\\", [4, 4, 4]), (\\"Book B\\", [5, 5, 5]) ] >>> try: ... top_rated_books(books, 0) ... except ValueError as e: ... print(e) N must be positive. >>> try: ... top_rated_books([], 1) ... except ValueError as e: ... print(e) Book list cannot be empty.","solution":"from typing import List, Tuple def top_rated_books(books: List[Tuple[str, List[int]]], N: int) -> List[str]: if N <= 0: raise ValueError(\\"N must be positive.\\") if not books: raise ValueError(\\"Book list cannot be empty.\\") # Calculate the average rating for each book avg_ratings = [ (title, sum(ratings) / len(ratings)) for title, ratings in books ] # Sort the books first by average rating (descending) and then by title (alphabetically) sorted_books = sorted(avg_ratings, key=lambda x: (-x[1], x[0])) # Extract the titles of the top N books top_books = [title for title, rating in sorted_books[:N]] return top_books"},{"question":"def find_max_average(nums: List[int], k: int) -> Optional[float]: Calculate the maximum average value of any contiguous subarray of length k. Args: nums (List[int]): Array of integers. k (int): Length of the subarray. Returns: Optional[float]: Maximum average of any contiguous subarray of length k, rounded to five decimal places, or None if no such subarray exists. Examples: >>> find_max_average([1, 12, -5, -6, 50, 3], 4) 12.75000 >>> find_max_average([5, 5, 5, 5], 3) 5.00000 >>> find_max_average([8], 1) 8.00000 >>> find_max_average([], 1) None >>> find_max_average([1, 2], 3) None pass from typing import List, Optional def test_find_max_average_basic(): assert find_max_average([1,12,-5,-6,50,3], 4) == 12.75000 def test_find_max_average_all_equal(): assert find_max_average([5,5,5,5], 3) == 5.00000 def test_find_max_average_single_element(): assert find_max_average([8], 1) == 8.00000 def test_find_max_average_empty_array(): assert find_max_average([], 1) == None def test_find_max_average_k_greater_than_array_length(): assert find_max_average([1,2], 3) == None def test_find_max_average_k_equals_length(): assert find_max_average([4,2,1,7,8], 5) == 4.40000 def test_find_max_average_negative_numbers(): assert find_max_average([-1, -12, 5, -6, 50], 3) == 16.33333","solution":"def find_max_average(nums, k): if len(nums) < k: return None max_sum = sum(nums[:k]) current_sum = max_sum for i in range(k, len(nums)): current_sum = current_sum - nums[i - k] + nums[i] if current_sum > max_sum: max_sum = current_sum max_average = max_sum / k return round(max_average, 5)"},{"question":"def validate_and_parse_phone_number(phone_number: str) -> dict: Validates and parses a phone number that follows the North American Numbering Plan (NANP). A valid phone number should be in the format: XXX-XXX-XXXX. Args: phone_number (str): The phone number string. Returns: dict: A dictionary with 'area_code' and 'local_number' if valid, else None. >>> validate_and_parse_phone_number(\\"123-456-7890\\") == {'area_code': '123', 'local_number': '4567890'} >>> validate_and_parse_phone_number(\\"234-567-8901\\") == {'area_code': '234', 'local_number': '5678901'} >>> validate_and_parse_phone_number(\\"invalid-number\\") == None >>> validate_and_parse_phone_number(\\" 345-678-9012 \\") == {'area_code': '345', 'local_number': '6789012'} >>> validate_and_parse_phone_number(\\"1234567890\\") == None","solution":"import re def validate_and_parse_phone_number(phone_number: str) -> dict: Validates and parses a phone number that follows the North American Numbering Plan (NANP). A valid phone number should be in the format: XXX-XXX-XXXX. Args: phone_number (str): The phone number string. Returns: dict: A dictionary with 'area_code' and 'local_number' if valid, else None. # Trim any leading or trailing whitespaces phone_number = phone_number.strip() # Regular expression to match the NANP format pattern = re.compile(r\\"^(d{3})-(d{3})-(d{4})\\") match = pattern.match(phone_number) if match: return { 'area_code': match.group(1), 'local_number': match.group(2) + match.group(3) } else: return None"},{"question":"class MovieRatingSystem: Movie Rating System allows users to submit their ratings for various movies and calculates the average rating for each movie. Ratings should be between 0 and 5 (inclusive). Methods: - add_rating(movie: str, rating: float) -> None: Adds a rating for the given movie. - get_average_rating(movie: str) -> float: Returns the average rating for the given movie. If the movie has no ratings, return None. def __init__(self): # Initialize the data structure to store ratings pass def add_rating(self, movie: str, rating: float) -> None: Adds a rating for the given movie. Parameters: - movie: str - Movie title - rating: float - Rating value between 0 and 5 (inclusive) Invalid ratings should be ignored, and an appropriate message should be logged or printed. pass def get_average_rating(self, movie: str) -> float: Returns the average rating for the given movie. Parameters: - movie: str - Movie title Returns: - float: The average rating for the given movie. If the movie has no ratings, return None. pass # Sample Usage movie_system = MovieRatingSystem() movie_system.add_rating(\\"Inception\\", 4.5) movie_system.add_rating(\\"Inception\\", 5.0) average = movie_system.get_average_rating(\\"Inception\\") print(f\\"Average rating for Inception: {average}\\") movie_system.add_rating(\\"Titanic\\", 3.0) average = movie_system.get_average_rating(\\"Titanic\\") print(f\\"Average rating for Titanic: {average}\\") # Invalid rating movie_system.add_rating(\\"Avatar\\", 10) average = movie_system.get_average_rating(\\"Avatar\\") print(f\\"Average rating for Avatar: {average}\\") # Should handle invalid rating gracefully # Unit Tests def test_add_and_get_average_rating(): movie_system = MovieRatingSystem() movie_system.add_rating(\\"Inception\\", 4.5) movie_system.add_rating(\\"Inception\\", 5.0) assert movie_system.get_average_rating(\\"Inception\\") == 4.75 def test_get_average_rating_no_ratings(): movie_system = MovieRatingSystem() assert movie_system.get_average_rating(\\"NonExistentMovie\\") == None def test_add_invalid_rating(): movie_system = MovieRatingSystem() movie_system.add_rating(\\"Avatar\\", 10) assert movie_system.get_average_rating(\\"Avatar\\") == None def test_add_rating_boundary_values(): movie_system = MovieRatingSystem() movie_system.add_rating(\\"Interstellar\\", 0) movie_system.add_rating(\\"Interstellar\\", 5) assert movie_system.get_average_rating(\\"Interstellar\\") == 2.5 def test_add_multiple_ratings(): movie_system = MovieRatingSystem() ratings = [1, 2, 3, 4, 5] for rating in ratings: movie_system.add_rating(\\"Matrix\\", rating) assert movie_system.get_average_rating(\\"Matrix\\") == 3.0","solution":"class MovieRatingSystem: def __init__(self): self.ratings = {} def add_rating(self, movie: str, rating: float) -> None: if 0 <= rating <= 5: if movie not in self.ratings: self.ratings[movie] = [] self.ratings[movie].append(rating) else: print(f\\"Invalid rating of {rating} for movie: {movie}. Rating should be between 0 and 5.\\") def get_average_rating(self, movie: str) -> float: if movie in self.ratings and self.ratings[movie]: return sum(self.ratings[movie]) / len(self.ratings[movie]) return None"},{"question":"def two_sum(nums: list[int], target: int) -> bool: Determine if there are two distinct indices i and j in nums such that nums[i] + nums[j] == target. >>> two_sum([2, 7, 11, 15], 9) == True >>> two_sum([3, 2, 4], 6) == True >>> two_sum([3, 3], 6) == True >>> two_sum([1, 2, 3, 4], 8) == False","solution":"def two_sum(nums: list[int], target: int) -> bool: Determine if there are two distinct indices i and j in nums such that nums[i] + nums[j] == target. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return True seen[num] = i return False"},{"question":"def find_scc(graph: dict[int, list[int]]) -> list[set[int]]: Find strongly connected components in the given directed graph using Tarjan's algorithm. Parameters: graph (dict[int, list[int]]): A dictionary representing the directed graph where the keys are node identifiers and the values are lists of integers representing directed edges from the key node. Returns: list[set[int]]: A list of sets, each containing the node identifiers that form a strongly connected component. >>> find_scc({ ... 0: [1], ... 1: [2, 3], ... 2: [0], ... 3: [4], ... 4: [5], ... 5: [3] ... }) [{0, 1, 2}, {3, 4, 5}] >>> find_scc({ ... 0: [1], ... 1: [2], ... 2: [0], ... 3: [4, 5], ... 4: [5], ... 5: [] ... }) [{0, 1, 2}, {3}, {4}, {5}]","solution":"def find_scc(graph): Find strongly connected components in the given directed graph using Tarjan's algorithm. Parameters: graph (dict[int, list[int]]): A dictionary representing the directed graph where the keys are node identifiers and the values are lists of integers representing directed edges from the key node. Returns: list[set[int]]: A list of sets, each containing the node identifiers that form a strongly connected component. index = [0] # Single item list to act as a static variable stack = [] indices = {} lowlinks = {} on_stack = set() sccs = [] def strongconnect(node): indices[node] = index[0] lowlinks[node] = index[0] index[0] += 1 stack.append(node) on_stack.add(node) for neighbor in graph.get(node, []): if neighbor not in indices: strongconnect(neighbor) lowlinks[node] = min(lowlinks[node], lowlinks[neighbor]) elif neighbor in on_stack: lowlinks[node] = min(lowlinks[node], indices[neighbor]) if lowlinks[node] == indices[node]: scc = set() while True: current = stack.pop() on_stack.remove(current) scc.add(current) if current == node: break sccs.append(scc) for node in graph: if node not in indices: strongconnect(node) return sccs"},{"question":"def word_frequencies(text: str) -> dict: Returns a dictionary representing the frequency of each unique word in the text. >>> word_frequencies(\\"hello world\\") {'hello': 1, 'world': 1} >>> word_frequencies(\\"this is a test this is only a test\\") { 'this': 2, 'is': 2, 'a': 2, 'test': 2, 'only': 1 } >>> word_frequencies(\\"the quick brown fox jumps over the lazy dog the dog barks\\") { 'the': 3, 'quick': 1, 'brown': 1, 'fox': 1, 'jumps': 1, 'over': 1, 'lazy': 1, 'dog': 2, 'barks': 1 } pass","solution":"def word_frequencies(text: str) -> dict: Returns a dictionary representing the frequency of each unique word in the text. words = text.split() frequency = {} for word in words: if word in frequency: frequency[word] += 1 else: frequency[word] = 1 return frequency"},{"question":"def merge_sort(arr): Perform merge sort on the input list and return the sorted list. :param arr: List of integers or floats to be sorted :return: Sorted list of numbers >>> merge_sort([12, 11, 13, 5, 6, 7]) [5, 6, 7, 11, 12, 13] >>> merge_sort([]) [] >>> merge_sort([42]) [42] >>> merge_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> merge_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> merge_sort([-10**7, 10**7, 0, 123456, -654321]) [-10000000, -654321, 0, 123456, 10000000] >>> import random >>> data = [random.randint(-10**7, 10**7) for _ in range(10**6)] >>> merge_sort(data) == sorted(data) True >>> merge_sort([4, 1, 3, 4, 2, 4]) [1, 2, 3, 4, 4, 4] >>> merge_sort([3.2, 1.1, 4.4, 2.2, 5.5]) [1.1, 2.2, 3.2, 4.4, 5.5] >>> arr = [(0, 'a'), (2, 'b'), (1, 'c'), (2, 'd'), (1, 'e')] >>> sorted_arr = merge_sort(arr) >>> sorted_arr == [(0, 'a'), (1, 'c'), (1, 'e'), (2, 'b'), (2, 'd')] True >>> sorted_arr[1][1] == 'c' # Ensure stability True >>> sorted_arr[3][1] == 'b' # Ensure stability True","solution":"def merge_sort(arr): Perform merge sort on the input list and return the sorted list. if len(arr) <= 1: return arr def merge(left, right): Merge two sorted subarrays into a single sorted array in a stable manner. merged = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 merged.extend(left[i:]) merged.extend(right[j:]) return merged def merge_sort_recursive(sublist): if len(sublist) <= 10: # Use insertion sort for small sublists to improve performance return insertion_sort(sublist) mid = len(sublist) // 2 left_half = merge_sort_recursive(sublist[:mid]) right_half = merge_sort_recursive(sublist[mid:]) return merge(left_half, right_half) def insertion_sort(sublist): for i in range(1, len(sublist)): key = sublist[i] j = i - 1 while j >= 0 and key < sublist[j]: sublist[j + 1] = sublist[j] j -= 1 sublist[j + 1] = key return sublist return merge_sort_recursive(arr)"},{"question":"def sort_students(students: list[dict]) -> list[dict]: Sorts a list of student records based on their grades in descending order. If grades are the same, sorts by name in alphabetical order. If both grades and names are the same, sorts by ID in ascending order. :param students: list of dictionaries, each dictionary represents a student record. :return: list of dictionaries sorted based on the described criteria.","solution":"def sort_students(students): Sorts a list of student records based on their grades in descending order. If grades are the same, sorts by name in alphabetical order. If both grades and names are the same, sorts by ID in ascending order. :param students: list of dictionaries, each dictionary represents a student record. :return: list of dictionaries sorted based on the described criteria. return sorted(students, key=lambda x: (-x['grade'], x['name'], x['id']))"},{"question":"class SparseVector: SparseVector provides efficient operations for vector addition, dot product, and retrieval of non-zero elements. >>> vector1 = SparseVector(5) >>> vector2 = SparseVector(5) >>> vector1.set_value(0, 1) >>> vector1.set_value(2, 3) >>> vector2.set_value(1, 4) >>> vector2.set_value(2, 5) >>> vector1.get_value(0) 1 >>> vector1.get_value(1) 0 >>> vector2.get_value(1) 4 >>> result_vector = vector1.vector_add(vector2) >>> result_vector.retrieve_non_zero() [(0, 1), (1, 4), (2, 8)] >>> vector1.dot_product(vector2) 15 def __init__(self, size: int) -> None: Initializes a sparse vector of a given size. pass def set_value(self, index: int, value: int) -> None: Sets the element at \`index\` to \`value\`. Args: index: The position in the vector. value: The value to be assigned at the specified index. pass def get_value(self, index: int) -> int: Retrieves the value at \`index\`. Args: index: The position in the vector. Returns: The value at the specified index. pass def vector_add(self, other: 'SparseVector') -> 'SparseVector': Adds the current vector instance with another \`SparseVector\` and returns the result as a new \`SparseVector\`. Args: other: A \`SparseVector\` to add to the current vector. Returns: A new \`SparseVector\` representing the sum of the two vectors. pass def dot_product(self, other: 'SparseVector') -> int: Computes the dot product of the current vector instance with another \`SparseVector\`. Args: other: A \`SparseVector\` to compute the dot product with. Returns: An integer representing the dot product of the two vectors. pass def retrieve_non_zero(self) -> list: Retrieves a list of tuples where each tuple contains an index and its corresponding non-zero value in the vector. Returns: A list of non-zero elements as (index, value) pairs. pass","solution":"class SparseVector: def __init__(self, size: int) -> None: self.size = size self.values = {} def set_value(self, index: int, value: int) -> None: if index < 0 or index >= self.size: raise ValueError(\\"Index out of bounds\\") if value != 0: self.values[index] = value elif index in self.values: del self.values[index] def get_value(self, index: int) -> int: if index < 0 or index >= self.size: raise ValueError(\\"Index out of bounds\\") return self.values.get(index, 0) def vector_add(self, other: 'SparseVector') -> 'SparseVector': if self.size != other.size: raise ValueError(\\"Vectors must be of the same size\\") result = SparseVector(self.size) for index, value in self.values.items(): result.set_value(index, value + other.get_value(index)) for index, value in other.values.items(): if index not in self.values: result.set_value(index, value) return result def dot_product(self, other: 'SparseVector') -> int: if self.size != other.size: raise ValueError(\\"Vectors must be of the same size\\") product_sum = 0 for index, value in self.values.items(): product_sum += value * other.get_value(index) return product_sum def retrieve_non_zero(self) -> list: return list(self.values.items())"},{"question":"def is_valid_move(piece: str, start_pos: str, end_pos: str) -> bool: Validates if a move for a given piece from start_pos to end_pos is valid according to standard chess rules. >>> is_valid_move(\\"pawn\\", \\"e2\\", \\"e4\\") True >>> is_valid_move(\\"rook\\", \\"a1\\", \\"a8\\") True >>> is_valid_move(\\"knight\\", \\"g1\\", \\"f3\\") True >>> is_valid_move(\\"bishop\\", \\"c1\\", \\"e3\\") False >>> is_valid_move(\\"queen\\", \\"d1\\", \\"h5\\") True >>> is_valid_move(\\"king\\", \\"e1\\", \\"e2\\") True","solution":"def is_valid_move(piece: str, start_pos: str, end_pos: str) -> bool: Validates if a move for a given piece from start_pos to end_pos is valid according to standard chess rules. start_col, start_row = ord(start_pos[0]), int(start_pos[1]) end_col, end_row = ord(end_pos[0]), int(end_pos[1]) if piece == \\"pawn\\": if start_col == end_col: if start_row == 2 and end_row == 4: return True if end_row == start_row + 1: return True elif abs(start_col - end_col) == 1 and end_row == start_row + 1: return True return False if piece == \\"rook\\": return start_col == end_col or start_row == end_row if piece == \\"knight\\": return (abs(start_col - end_col), abs(start_row - end_row)) in [(2, 1), (1, 2)] if piece == \\"bishop\\": return abs(start_col - end_col) == abs(start_row - end_row) if piece == \\"queen\\": return (start_col == end_col or start_row == end_row or abs(start_col - end_col) == abs(start_row - end_row)) if piece == \\"king\\": return max(abs(start_col - end_col), abs(start_row - end_row)) == 1 return False"},{"question":"def min_remove_to_make_valid(s: str) -> str: Determine the minimum number of parentheses to remove to make the string valid. >>> min_remove_to_make_valid(\\"lee(t(c)o)de)\\") == \\"lee(t(c)o)de\\" >>> min_remove_to_make_valid(\\"a)b(c)d\\") == \\"ab(c)d\\" >>> min_remove_to_make_valid(\\"))((\\") == \\"\\"","solution":"def min_remove_to_make_valid(s: str) -> str: Returns a string with the minimum number of parentheses removed to make it valid. stack = [] to_remove = set() for i, char in enumerate(s): if char == '(': stack.append(i) elif char == ')': if stack: stack.pop() else: to_remove.add(i) # Add all indices from stack to to_remove as they are unmatched '(' to_remove = to_remove.union(set(stack)) result = [] for i, char in enumerate(s): if i not in to_remove: result.append(char) return ''.join(result)"},{"question":"def convert_temperature(value: float, input_unit: str, output_unit: str) -> float: Converts the given temperature value from one unit to another. Args: value (float): The temperature value to be converted. input_unit (str): The unit of the input temperature. Can be 'C', 'F', or 'K'. output_unit (str): The unit of the output temperature. Can be 'C', 'F', or 'K'. Returns: float: The converted temperature value. Raises: ValueError: If input_unit or output_unit is not valid. >>> convert_temperature(100, 'C', 'F') 212.0 >>> convert_temperature(32, 'F', 'C') 0.0 >>> convert_temperature(0, 'C', 'K') 273.15 >>> pytest.approx(convert_temperature(32, 'F', 'K'), 0.01) == 273.15 >>> convert_temperature(100, 'X', 'C') Traceback (most recent call last): ... ValueError: Invalid input unit >>> convert_temperature(100, 'C', 'Y') Traceback (most recent call last): ... ValueError: Invalid output unit import pytest def test_convert_temperature(): assert convert_temperature(100, 'C', 'F') == 212.0 assert convert_temperature(32, 'F', 'C') == 0.0 assert convert_temperature(0, 'C', 'K') == 273.15 assert convert_temperature(300, 'K', 'F') == 80.33000000000004 assert convert_temperature(273.15, 'K', 'C') == 0.0 assert pytest.approx(convert_temperature(32, 'F', 'K'), 0.01) == 273.15 with pytest.raises(ValueError, match=\\"Invalid input unit\\"): convert_temperature(100, 'X', 'C') with pytest.raises(ValueError, match=\\"Invalid output unit\\"): convert_temperature(100, 'C', 'Y')","solution":"def convert_temperature(value: float, input_unit: str, output_unit: str) -> float: Converts the given temperature value from one unit to another. Args: value (float): The temperature value to be converted. input_unit (str): The unit of the input temperature. Can be 'C', 'F', or 'K'. output_unit (str): The unit of the output temperature. Can be 'C', 'F', or 'K'. Returns: float: The converted temperature value. Raises: ValueError: If input_unit or output_unit is not valid. # Check for valid units valid_units = {'C', 'F', 'K'} if input_unit not in valid_units: raise ValueError(\\"Invalid input unit\\") if output_unit not in valid_units: raise ValueError(\\"Invalid output unit\\") # Conversion logic temp_in_celsius = value if input_unit == 'F': temp_in_celsius = (value - 32) / 1.8 elif input_unit == 'K': temp_in_celsius = value - 273.15 if output_unit == 'C': return temp_in_celsius elif output_unit == 'F': return temp_in_celsius * 1.8 + 32 elif output_unit == 'K': return temp_in_celsius + 273.15"},{"question":"def matrix_transpose(matrix): Returns the transpose of the input matrix. >>> matrix_transpose([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> matrix_transpose([[1]]) [[1]] >>> matrix_transpose([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] def matrix_multiply(matrix_a, matrix_b): Returns the product of two input matrices. >>> matrix_multiply([[1, 2, 3], [4, 5, 6]], [[7, 8], [9, 10], [11, 12]]) [[58, 64], [139, 154]] >>> matrix_multiply([[1, 2]], [[3], [4]]) [[11]] >>> matrix_multiply([[1, 2]], [[1, 2], [3, 4], [5, 6]]) Traceback (most recent call last): ... ValueError: Matrices cannot be multiplied. Invalid matrix dimensions.","solution":"def matrix_transpose(matrix): Returns the transpose of the input matrix. if not matrix or not all(len(row) == len(matrix[0]) for row in matrix): raise ValueError(\\"Invalid matrix: non-rectangular or empty matrix provided.\\") return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))] def matrix_multiply(matrix_a, matrix_b): Returns the product of two input matrices. if not matrix_a or not matrix_b or not all(len(row) == len(matrix_a[0]) for row in matrix_a) or not all(len(row) == len(matrix_b[0]) for row in matrix_b): raise ValueError(\\"Invalid matrix: non-rectangular or empty matrices provided.\\") if len(matrix_a[0]) != len(matrix_b): raise ValueError(\\"Matrices cannot be multiplied. Invalid matrix dimensions.\\") rows_a, cols_a = len(matrix_a), len(matrix_a[0]) cols_b = len(matrix_b[0]) product_matrix = [[0] * cols_b for _ in range(rows_a)] for i in range(rows_a): for j in range(cols_b): for k in range(cols_a): product_matrix[i][j] += matrix_a[i][k] * matrix_b[k][j] return product_matrix"},{"question":"class RecommendationSystem: def __init__(self, user_item_matrix, item_popularity): Initializes the RecommendationSystem with user-item interaction matrix and item popularity. self.user_item_matrix = user_item_matrix self.item_popularity = item_popularity def diversify_recommendations(self, recommendations, user_id, top_n): Adjust the recommendation scores to ensure diversity and return top_n recommended items. Args: recommendations (dict): A dictionary where keys are item IDs and values are their recommendation scores. user_id (str): The ID of the user for whom the recommendations are. top_n (int): The number of top recommendations to return. Returns: list: Top n item IDs that are both relevant and diverse. pass # Example usage def example_usage(): recommendations = { \\"item1\\": 0.9, \\"item2\\": 0.85, \\"item3\\": 0.8, \\"item4\\": 0.75, \\"item5\\": 0.7 } user_id = \\"user123\\" top_n = 3 rec_sys = RecommendationSystem({}, {\\"item1\\": 10, \\"item2\\": 20, \\"item3\\": 1, \\"item4\\": 5, \\"item5\\": 50}) diverse_recommendations = rec_sys.diversify_recommendations(recommendations, user_id, top_n) print(diverse_recommendations) # Output should be a list of 3 item IDs that are relevant to user123 and diverse in nature. # Unit Test def test_diversify_recommendations(): rec_sys = RecommendationSystem({}, {\\"item1\\": 10, \\"item2\\": 20, \\"item3\\": 1, \\"item4\\": 5, \\"item5\\": 50}) recommendations = {\\"item1\\": 0.9, \\"item2\\": 0.85, \\"item3\\": 0.8, \\"item4\\": 0.75, \\"item5\\": 0.7} user_id = \\"user123\\" top_n = 3 diverse_recommendations = rec_sys.diversify_recommendations(recommendations, user_id, top_n) assert len(diverse_recommendations) == 3 assert \\"item3\\" in diverse_recommendations if __name__ == \\"__main__\\": example_usage() test_diversify_recommendations()","solution":"class RecommendationSystem: def __init__(self, user_item_matrix, item_popularity): Initializes the RecommendationSystem with user-item interaction matrix and item popularity. self.user_item_matrix = user_item_matrix self.item_popularity = item_popularity def diversify_recommendations(self, recommendations, user_id, top_n): Adjust the recommendation scores to ensure diversity and return top_n recommended items. Args: recommendations (dict): A dictionary where keys are item IDs and values are their recommendation scores. user_id (str): The ID of the user for whom the recommendations are. top_n (int): The number of top recommendations to return. Returns: list: Top n item IDs that are both relevant and diverse. # Incorporate diversity by scaling scores down based on item popularity. adjusted_scores = { item: score / (1 + self.item_popularity.get(item, 0)) for item, score in recommendations.items() } # Sort by adjusted scores in descending order and take the top_n sorted_items = sorted(adjusted_scores.items(), key=lambda x: x[1], reverse=True) top_items = [item for item, score in sorted_items[:top_n]] return top_items"},{"question":"def longest_palindromic_permutation(s: str) -> str: Analyze a given string to find the longest substring which forms a palindromic permutation. A palindromic permutation is a string that can be rearranged to form a palindrome. Args: s (str): The input string. Returns: str: The longest substring that can be permuted to form a palindrome. Examples: >>> longest_palindromic_permutation(\\"abacab\\") in {\\"bacab\\", \\"ababa\\"} True >>> longest_palindromic_permutation(\\"abcd\\") in {\\"a\\", \\"b\\", \\"c\\", \\"d\\"} True >>> longest_palindromic_permutation(\\"\\") \\"\\" >>> longest_palindromic_permutation(\\"aabbccddeeffgghh\\") \\"aabbccddeeffgghh\\" >>> longest_palindromic_permutation(\\"!a!b!a!\\") \\"!a!b!a!\\" pass # Unit tests def test_empty_string(): assert longest_palindromic_permutation(\\"\\") == \\"\\" def test_single_character_string(): assert longest_palindromic_permutation(\\"a\\") == \\"a\\" def test_all_unique_characters(): result = longest_palindromic_permutation(\\"abcd\\") assert result in {\\"a\\", \\"b\\", \\"c\\", \\"d\\"} def test_simple_palindrome(): result = longest_palindromic_permutation(\\"abacab\\") assert result in {\\"bacab\\", \\"ababa\\"} def test_no_single_palindromic_permutation(): result = longest_palindromic_permutation(\\"abcdefgh\\") assert result == \\"a\\" def test_long_palindromic_permutation(): s = \\"aabbccddeeffgghh\\" result = longest_palindromic_permutation(s) assert result == s def test_mixed_characters(): s = \\"aabbccddeeff\\" result = longest_palindromic_permutation(s) assert result == s def test_multiple_same_length(): result = longest_palindromic_permutation(\\"abccba\\") assert result == \\"abccba\\" def test_with_spaces(): result = longest_palindromic_permutation(\\"ab c ba\\") assert result == \\"ab c ba\\" def test_with_special_characters(): result = longest_palindromic_permutation(\\"!a!b!a!\\") assert result == \\"!a!b!a!\\"","solution":"def can_form_palindrome(s: str) -> bool: from collections import Counter counts = Counter(s) odd_count = sum(1 for count in counts.values() if count % 2 != 0) return odd_count <= 1 def longest_palindromic_permutation(s: str) -> str: n = len(s) if n == 0: return \\"\\" max_len = 0 longest_substr = \\"\\" for i in range(n): for j in range(i, n): substring = s[i:j+1] if can_form_palindrome(substring): if j - i + 1 > max_len: max_len = j - i + 1 longest_substr = substring return longest_substr"},{"question":"def is_numeric_palindrome(s: str) -> bool: Determine if the numeric part of the string forms a palindrome. Args: s (str): the input string containing digits, letters, and special characters. Returns: bool: True if the numeric part of the string is a palindrome, False otherwise. Examples: >>> is_numeric_palindrome(\\"ab1cd2dc1ba\\") True >>> is_numeric_palindrome(\\"a1b2c3d4e5\\") False >>> is_numeric_palindrome(\\"12321\\") True >>> is_numeric_palindrome(\\"abc\\") True >>> is_numeric_palindrome(\\"1a2b3c2b1a\\") False","solution":"def is_numeric_palindrome(s: str) -> bool: Given a string, determine if the numeric part of the string forms a palindrome. Args: s (str): the input string containing digits, letters, and special characters. Returns: bool: True if the numeric part of the string is a palindrome, False otherwise. # Extract the digits from the string digits = [char for char in s if char.isdigit()] # Check if the list of digits is the same forwards and backwards return digits == digits[::-1]"},{"question":"from typing import List def next_permutation(nums: List[int]) -> None: Modifies the list 'nums' in place to the next lexicographical permutation. If such a permutation is not possible, it rearranges the list to the lowest possible order (sorted in ascending order). >>> nums = [1, 2, 3] >>> next_permutation(nums) >>> nums [1, 3, 2] >>> nums = [3, 2, 1] >>> next_permutation(nums) >>> nums [1, 2, 3] >>> nums = [1, 1, 5] >>> next_permutation(nums) >>> nums [1, 5, 1]","solution":"def next_permutation(nums): Modifies the list 'nums' in place to the next lexicographical permutation. If such a permutation is not possible, it rearranges the list to the lowest possible order (sorted in ascending order). # Step 1: Find the largest index k such that nums[k] < nums[k + 1]. k = len(nums) - 2 while k >= 0 and nums[k] >= nums[k + 1]: k -= 1 if k == -1: # No such index found, list is in descending order, reverse it to ascending nums.reverse() return # Step 2: Find the largest index l greater than k such that nums[k] < nums[l] l = len(nums) - 1 while nums[l] <= nums[k]: l -= 1 # Step 3: Swap the value of nums[k] with that of nums[l] nums[k], nums[l] = nums[l], nums[k] # Step 4: Reverse the sequence from nums[k + 1] to the end of the list nums[k + 1:] = reversed(nums[k + 1:])"},{"question":"def kth_smallest(arr: list, k: int) -> int: Implements the median of medians method to find the k-th smallest element in the array. :param arr: List of integers :param k: An integer representing the position of the smallest element to find (1-based index) :return: The k-th smallest element in the array :raises ValueError: If k is out of the bounds of the array >>> kth_smallest([3, 6, 2, 7, 5, 1, 4], 4) 4 >>> kth_smallest([10], 1) 10 >>> kth_smallest([7, 10, 4, 3, 20, 15], 1) 3 >>> kth_smallest([7, 10, 4, 3, 20, 15], 6) 20 >>> kth_smallest([7, 10, 4, 3, 20, 15], 3) 7 >>> kth_smallest([3, 3, 3, 3, 3, 3, 4, 4, 4], 5) 3 import pytest def test_kth_smallest_examples(): assert kth_smallest([3, 6, 2, 7, 5, 1, 4], 4) == 4 def test_kth_smallest_single_element(): assert kth_smallest([10], 1) == 10 def test_kth_smallest_first_element(): assert kth_smallest([7, 10, 4, 3, 20, 15], 1) == 3 def test_kth_smallest_last_element(): assert kth_smallest([7, 10, 4, 3, 20, 15], 6) == 20 def test_kth_smallest_middle_element(): assert kth_smallest([7, 10, 4, 3, 20, 15], 3) == 7 def test_kth_smallest_with_duplicates(): assert kth_smallest([3, 3, 3, 3, 3, 3, 4, 4, 4], 5) == 3 def test_kth_smallest_out_of_bounds(): with pytest.raises(ValueError): kth_smallest([1, 2, 3], 0) with pytest.raises(ValueError): kth_smallest([1, 2, 3], 4) def test_kth_smallest_large_k(): arr = list(range(100)) assert kth_smallest(arr, 99) == 98 def test_kth_smallest_large_input(): arr = list(range(10000, 0, -1)) assert kth_smallest(arr, 5000) == 5000","solution":"def partition(arr, low, high, pivot_index): pivot = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] store_index = low for i in range(low, high): if arr[i] < pivot: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[store_index], arr[high] = arr[high], arr[store_index] return store_index def median_of_medians(arr, low, high): n = high - low + 1 if n < 10: sorted_arr = sorted(arr[low:high+1]) return sorted_arr[n // 2] medians = [] for i in range(low, high+1, 5): group = arr[i:i+5] sorted_group = sorted(group) medians.append(sorted_group[len(sorted_group) // 2]) median_of_medians_value = median_of_medians(medians, 0, len(medians) - 1) return median_of_medians_value def select(arr, low, high, k): while low <= high: pivot_index = low if high - low + 1 > 5: pivot_index = arr.index(median_of_medians(arr, low, high)) pivot_index = partition(arr, low, high, pivot_index) if pivot_index == k: return arr[pivot_index] elif pivot_index > k: high = pivot_index - 1 else: low = pivot_index + 1 def kth_smallest(arr, k): if k < 1 or k > len(arr): raise ValueError(\\"k is out of the bounds of the array\\") return select(arr, 0, len(arr) - 1, k - 1)"},{"question":"def is_valid_path(n: int, m: int, grid: list[list[int]]) -> bool: Verify if there exists a valid path from the top-left corner to the bottom-right corner of a grid. The grid is represented as a list of lists where 0 indicates an open space and 1 indicates a wall. Only up, down, left, and right movements are allowed. >>> n, m = 3, 3 >>> grid = [ ... [0, 1, 0], ... [0, 0, 0], ... [1, 1, 0] ... ] >>> is_valid_path(n, m, grid) True >>> n, m = 3, 3 >>> grid = [ ... [0, 1, 0], ... [1, 1, 0], ... [1, 1, 0] ... ] >>> is_valid_path(n, m, grid) False >>> n, m = 2, 2 >>> grid = [ ... [1, 0], ... [0, 0] ... ] >>> is_valid_path(n, m, grid) False >>> n, m = 2, 2 >>> grid = [ ... [0, 0], ... [0, 1] ... ] >>> is_valid_path(n, m, grid) False >>> n, m = 5, 5 >>> grid = [ ... [0, 1, 0, 1, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 0, 1, 0] ... ] >>> is_valid_path(n, m, grid) True >>> n, m = 5, 5 >>> grid = [ ... [0, 1, 0, 1, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 1, 1, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 0, 1, 0] ... ] >>> is_valid_path(n, m, grid) False >>> n, m = 1, 1 >>> grid = [ ... [0] ... ] >>> is_valid_path(n, m, grid) True >>> n, m = 1, 5 >>> grid = [ ... [0, 0, 0, 0, 0] ... ] >>> is_valid_path(n, m, grid) True >>> n, m = 1, 5 >>> grid = [ ... [0, 1, 0, 0, 0] ... ] >>> is_valid_path(n, m, grid) False pass","solution":"from collections import deque def is_valid_path(n: int, m: int, grid: list[list[int]]) -> bool: if grid[0][0] == 1 or grid[n-1][m-1] == 1: return False directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # Down, Right, Up, Left queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n-1, m-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False"},{"question":"def find_basin(grid): Identify the lowest elevation basin in a 2D grid. Given a 2D grid of integers representing elevations, find the lowest elevation basin(s). A basin is defined as a local minimum which is lower than or equal to its neighboring cells (up, down, left, right). Args: grid (list of list of int): A 2D list where each inner list represents a row of the grid. Returns: tuple: The coordinates (row, column) of the basin(s) with the lowest elevation. If there are multiple basins with the same lowest elevation, return all of them in a list of tuples. Examples: >>> find_basin([ ... [9, 8, 7], ... [6, 5, 4], ... [3, 2, 1] ... ]) [(2, 2)] >>> find_basin([ ... [1, 2, 3], ... [2, 1, 2], ... [3, 2, 1] ... ]) [(0, 0), (1, 1), (2, 2)] >>> find_basin([ ... [2, 2, 2], ... [2, 1, 2], ... [2, 2, 2] ... ]) [(1, 1)] >>> find_basin([[42]]) [(0, 0)] >>> find_basin([ ... [1, 2, 3, 4], ... [2, 1, 2, 3], ... [3, 2, 1, 2], ... [4, 3, 2, 1] ... ]) [(0, 0), (1, 1), (2, 2), (3, 3)]","solution":"def find_basin(grid): assert isinstance(grid, list) and all(isinstance(row, list) for row in grid), \\"Invalid grid format.\\" m, n = len(grid), len(grid[0]) lowest_basins = [] lowest_elevation = float('inf') for i in range(m): for j in range(n): current_elevation = grid[i][j] neighbors = [] if i > 0: neighbors.append(grid[i-1][j]) if i < m-1: neighbors.append(grid[i+1][j]) if j > 0: neighbors.append(grid[i][j-1]) if j < n-1: neighbors.append(grid[i][j+1]) if current_elevation <= min(neighbors, default=current_elevation): if current_elevation < lowest_elevation: lowest_elevation = current_elevation lowest_basins = [(i, j)] elif current_elevation == lowest_elevation: lowest_basins.append((i, j)) return lowest_basins"},{"question":"def smallest_multiple(limit: int) -> int: Find the smallest positive integer that is evenly divisible by all the numbers from 1 to a given limit. >>> smallest_multiple(10) == 2520 >>> smallest_multiple(15) == 360360 >>> smallest_multiple(20) == 232792560 >>> smallest_multiple(1) == 1 >>> smallest_multiple(5) == 60 >>> smallest_multiple(30) == 2329089562800","solution":"import math def lcm(a, b): return abs(a * b) // math.gcd(a, b) def smallest_multiple(limit: int) -> int: result = 1 for i in range(1, limit + 1): result = lcm(result, i) return result"},{"question":"def gcd(a: int, b: int) -> int: Compute the greatest common divisor of two integers a and b. >>> gcd(24, 40) 8 >>> gcd(11, 37) 1 >>> gcd(27, 18) 9 >>> gcd(0, 5) 5 >>> gcd(5, 0) 5 >>> gcd(0, 0) 0 >>> gcd(-24, 40) 8 >>> gcd(24, -40) 8 >>> gcd(-24, -40) 8 def lcm(a: int, b: int) -> int: Compute the least common multiple of two integers a and b. >>> lcm(24, 40) 120 >>> lcm(11, 37) 407 >>> lcm(27, 18) 54 >>> lcm(0, 5) 0 >>> lcm(5, 0) 0 >>> lcm(0, 0) 0 >>> lcm(-24, 40) 120 >>> lcm(24, -40) 120 >>> lcm(-24, -40) 120","solution":"def gcd(a: int, b: int) -> int: Compute the greatest common divisor of a and b using the Euclidean algorithm. while b: a, b = b, a % b return abs(a) def lcm(a: int, b: int) -> int: Compute the least common multiple of a and b. if a == 0 or b == 0: return 0 return abs(a * b) // gcd(a, b)"},{"question":"def apply_discount_codes(total_codes: int, attempts: list[str]) -> list[str]: Apply the discount codes from the attempts list, respecting the total number of allowed uses. :param total_codes: Total number of discount codes available. :param attempts: List of strings representing user attempts to apply discount codes. :return: List of strings indicating whether each attempt is a success or failure. >>> apply_discount_codes(3, [\\"DISCOUNT-1\\", \\"DISCOUNT-2\\", \\"DISCOUNT-3\\", \\"DISCOUNT-1\\", \\"SALE-1\\"]) ['SUCCESS: DISCOUNT-1', 'SUCCESS: DISCOUNT-2', 'SUCCESS: DISCOUNT-3', 'FAILURE: DISCOUNT-1', 'SUCCESS: SALE-1'] >>> apply_discount_codes(2, [\\"OFFER-1\\", \\"OFFER-2\\", \\"OFFER-3\\"]) ['SUCCESS: OFFER-1', 'SUCCESS: OFFER-2', 'FAILURE: OFFER-3'] >>> apply_discount_codes(1, [\\"PROMO-1\\", \\"PROMO-2\\", \\"PROMO-3\\", \\"PROMO-1\\"]) ['SUCCESS: PROMO-1', 'FAILURE: PROMO-2', 'FAILURE: PROMO-3', 'FAILURE: PROMO-1'] >>> apply_discount_codes(4, [\\"CODE-1\\", \\"CODE-2\\", \\"CODE-3\\", \\"CODE-4\\", \\"CODE-5\\"]) ['SUCCESS: CODE-1', 'SUCCESS: CODE-2', 'SUCCESS: CODE-3', 'SUCCESS: CODE-4', 'FAILURE: CODE-5']","solution":"def apply_discount_codes(total_codes: int, attempts: list[str]) -> list[str]: Apply the discount codes from the attempts list, respecting the total number of allowed uses. :param total_codes: Total number of discount codes available. :param attempts: List of strings representing user attempts to apply discount codes. :return: List of strings indicating whether each attempt is a success or failure. code_usage = {} results = [] successful_applications = 0 for attempt in attempts: code = attempt.split('-')[0] if code_usage.get(code, 0) < total_codes: code_usage[code] = code_usage.get(code, 0) + 1 results.append(f'SUCCESS: {attempt}') successful_applications += 1 else: results.append(f'FAILURE: {attempt}') return results"},{"question":"def smallest_substring_with_all_chars(s: str) -> str: Find the smallest substring in a given string \`s\` that contains all the distinct characters in \`s\`. >>> smallest_substring_with_all_chars(\\"abcda\\") in [\\"abcd\\", \\"bcda\\"] True >>> smallest_substring_with_all_chars(\\"abac\\") in [\\"abac\\", \\"bac\\"] True >>> smallest_substring_with_all_chars(\\"a\\") \\"a\\" >>> smallest_substring_with_all_chars(\\"abcdefgh\\") \\"abcdefgh\\" >>> smallest_substring_with_all_chars(\\"aabbcc\\") in [\\"abbc\\", \\"bbcc\\", \\"aabbcc\\"] True >>> smallest_substring_with_all_chars(\\"xyyzyzyx\\") in [\\"zyx\\", \\"xzy\\"] True >>> smallest_substring_with_all_chars(\\"\\") \\"\\" >>> smallest_substring_with_all_chars(\\"aaaaa\\") \\"a\\"","solution":"def smallest_substring_with_all_chars(s: str) -> str: from collections import defaultdict, Counter # Find all distinct characters in the input string distinct_chars = set(s) num_distinct = len(distinct_chars) # Use a sliding window approach left = 0 min_len = float('inf') min_substring = \\"\\" char_count = defaultdict(int) formed = 0 # Expand the window by extending the right boundary for right in range(len(s)): char_count[s[right]] += 1 if char_count[s[right]] == 1: formed += 1 # Try to contract the window from the left until it is no longer valid while formed == num_distinct: # Update the answer if this window is smaller if (right - left + 1) < min_len: min_len = right - left + 1 min_substring = s[left:right + 1] # Contract from the left char_count[s[left]] -= 1 if char_count[s[left]] == 0: formed -= 1 left += 1 return min_substring"},{"question":"import gzip import os def compress_file(file_path): Compresses a text file using gzip. Args: file_path (str): Path to the text file to be compressed. Output: None (side effect of saving the compressed file). >>> import os >>> compress_file('test.txt') >>> os.path.exists('test.txt.gz') True pass # Implementation here def decompress_file(file_path): Decompresses a gzip file. Args: file_path (str): Path to the gzip file to be decompressed. Output: None (side effect of saving the decompressed file). >>> decompress_file('test.txt.gz') >>> os.path.exists('test.txt') True pass # Implementation here","solution":"import gzip import os def compress_file(file_path): Compresses a text file using gzip. Args: file_path (str): Path to the text file to be compressed. Output: None (side effect of saving the compressed file). try: with open(file_path, 'rb') as f_in: with gzip.open(file_path + '.gz', 'wb') as f_out: f_out.writelines(f_in) except Exception as e: print(f\\"An error occurred while compressing the file: {e}\\") def decompress_file(file_path): Decompresses a gzip file. Args: file_path (str): Path to the gzip file to be decompressed. Output: None (side effect of saving the decompressed file). try: output_file_path = file_path.rstrip('.gz') with gzip.open(file_path, 'rb') as f_in: with open(output_file_path, 'wb') as f_out: f_out.writelines(f_in) except Exception as e: print(f\\"An error occurred while decompressing the file: {e}\\")"},{"question":"def is_pangram(s: str) -> bool: Determines if the string contains all the letters from 'a' to 'z'. The function ignores case and non-alphabetical characters. Parameters: - s (str): The input string. Returns: - bool: True if the string is a pangram, False otherwise. Example: >>> is_pangram(\\"The quick brown fox jumps over the lazy dog.\\") == True >>> is_pangram(\\"Pack my box with five dozen liquor jugs.\\") == True >>> is_pangram(\\"Hello World!\\") == False >>> is_pangram(\\"\\") == False >>> is_pangram(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\") == True","solution":"def is_pangram(s: str) -> bool: Determines if the string contains all the letters from 'a' to 'z'. The function ignores case and non-alphabetical characters. Parameters: - s (str): The input string. Returns: - bool: True if the string is a pangram, False otherwise. # Use a set to track the unique alphabetical characters in the string alphabet_set = set() # Loop through each character in the string for char in s: # Convert the character to lowercase lower_char = char.lower() # If the character is a letter, add it to the set if 'a' <= lower_char <= 'z': alphabet_set.add(lower_char) # If we have collected all 26 letters, return True if len(alphabet_set) == 26: return True # If we finish the loop without finding all letters, return False return False"},{"question":"class PriorityQueue: Design a class \`PriorityQueue\` that implements a priority queue using a min-heap. The class should support the following operations: - insert(key, value): Inserts an element with the specified key and value into the priority queue. - extract_min(): Removes and returns the element with the smallest key. If the priority queue is empty, return None. - decrease_key(value, new_key): Decreases the key of the specified value to the new key. If the new key is greater than the current key of the specified value, do nothing. - is_empty(): Returns True if the priority queue is empty, False otherwise. - size(): Returns the number of elements in the priority queue. Example: >>> pq = PriorityQueue() >>> pq.insert(4, 'task 1') >>> pq.insert(2, 'task 2') >>> pq.insert(5, 'task 3') >>> pq.extract_min() (2, 'task 2') >>> pq.is_empty() False >>> pq.size() 2 >>> pq.decrease_key('task 1', 1) >>> pq.extract_min() (1, 'task 1') >>> pq.size() 1 >>> pq.is_empty() False >>> pq.extract_min() (5, 'task 3') >>> pq.is_empty() True def __init__(self): pass def insert(self, key: int, value: any) -> None: Insert an element with the specified key and value. pass def extract_min(self) -> tuple: Remove and return the element with the smallest key. pass def decrease_key(self, value: any, new_key: int) -> None: Decrease the key of the specified value to the new key. pass def is_empty(self) -> bool: Return True if the priority queue is empty, False otherwise. pass def size(self) -> int: Return the number of elements in the priority queue. pass # Unit Tests def test_insert_and_extract_min(): pq = PriorityQueue() pq.insert(4, 'task 1') pq.insert(2, 'task 2') pq.insert(5, 'task 3') assert pq.extract_min() == (2, 'task 2') assert pq.extract_min() == (4, 'task 1') assert pq.extract_min() == (5, 'task 3') assert pq.extract_min() is None def test_decrease_key(): pq = PriorityQueue() pq.insert(4, 'task 1') pq.insert(2, 'task 2') pq.insert(5, 'task 3') pq.decrease_key('task 1', 1) assert pq.extract_min() == (1, 'task 1') assert pq.extract_min() == (2, 'task 2') assert pq.extract_min() == (5, 'task 3') def test_is_empty(): pq = PriorityQueue() assert pq.is_empty() == True pq.insert(4, 'task 1') assert pq.is_empty() == False pq.extract_min() assert pq.is_empty() == True def test_size(): pq = PriorityQueue() assert pq.size() == 0 pq.insert(4, 'task 1') assert pq.size() == 1 pq.insert(2, 'task 2') assert pq.size() == 2 pq.extract_min() assert pq.size() == 1 pq.extract_min() assert pq.size() == 0","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.entry_finder = {} self.counter = 0 def insert(self, key: int, value: any) -> None: entry = [key, self.counter, value] self.counter += 1 self.entry_finder[value] = entry heapq.heappush(self.heap, entry) def extract_min(self) -> tuple: while self.heap: key, count, value = heapq.heappop(self.heap) if value is not None: del self.entry_finder[value] return (key, value) return None def decrease_key(self, value: any, new_key: int) -> None: if value in self.entry_finder: entry = self.entry_finder[value] if new_key < entry[0]: entry[0] = new_key heapq.heapify(self.heap) def is_empty(self) -> bool: return not bool(self.size()) def size(self) -> int: return len(self.entry_finder)"},{"question":"from typing import Optional from dataclasses import dataclass @dataclass class Node: value: int left: Optional['Node'] = None right: Optional['Node'] = None def min_depth(root: Optional[Node]) -> int: Find the minimum depth of the binary tree. Args: root (Optional[Node]): The root node of the binary tree. Returns: int: The minimum depth of the binary tree. >>> root = Node(3) >>> root.left = Node(9) >>> root.right = Node(20) >>> root.right.left = Node(15) >>> root.right.right = Node(7) >>> min_depth(root) 2 >>> min_depth(None) 0 >>> root = Node(1) >>> root.left = Node(2) >>> min_depth(root) 2","solution":"from typing import Optional from dataclasses import dataclass @dataclass class Node: value: int left: Optional['Node'] = None right: Optional['Node'] = None def min_depth(root: Optional[Node]) -> int: if not root: return 0 # Initialize the queue for BFS queue = [(root, 1)] # The node and its depth while queue: current, depth = queue.pop(0) # Check if we reach a leaf node if not current.left and not current.right: return depth # Add children to the queue with their respective depths if current.left: queue.append((current.left, depth + 1)) if current.right: queue.append((current.right, depth + 1))"},{"question":"class RangeSumQuery: A data structure that allows for dynamic updates of the array and can efficiently handle range sum queries. def __init__(self, nums: List[int]): Initializes the object with the array nums. pass def update(self, index: int, val: int): Updates the element of the array at index index to be val. pass def sumRange(self, left: int, right: int) -> int: Returns the sum of the elements between indices left and right inclusive. pass # Example test cases def test_sum_range_initial(): obj = RangeSumQuery([1, 3, 5]) assert obj.sumRange(0, 2) == 9, \\"Failed sumRange initial test\\" def test_update(): obj = RangeSumQuery([1, 3, 5]) obj.update(1, 2) assert obj.sumRange(0, 2) == 8, \\"Failed update test\\" def test_sum_range_after_update(): obj = RangeSumQuery([-2, 0, 3, -5, 2, -1]) assert obj.sumRange(0, 2) == 1, \\"Failed sumRange after update test 1\\" assert obj.sumRange(2, 5) == -1, \\"Failed sumRange after update test 2\\" obj.update(5, 3) assert obj.sumRange(2, 5) == 3, \\"Failed sumRange after update test 3\\" def test_update_multiple_and_sum(): obj = RangeSumQuery([1, 3, 5, 7, 9, 11]) obj.update(2, 6) obj.update(4, 10) assert obj.sumRange(0, 5) == 38, \\"Failed multiple update test 1\\" assert obj.sumRange(0, 2) == 10, \\"Failed multiple update test 2\\" assert obj.sumRange(3, 5) == 28, \\"Failed multiple update test 3\\" def test_large_input_handling(): nums = list(range(10000)) obj = RangeSumQuery(nums) assert obj.sumRange(0, 9999) == sum(range(10000)), \\"Failed large input handling test 1\\" obj.update(9999, 10000) assert obj.sumRange(0, 9999) == sum(range(9999)) + 10000, \\"Failed large input handling test 2\\"","solution":"class RangeSumQuery: def __init__(self, nums): Initializes the object with the array nums. self.n = len(nums) self.nums = nums self.tree = [0] * (self.n + 1) for i in range(self.n): self._init_update(i, nums[i]) def _init_update(self, index, val): index += 1 while index <= self.n: self.tree[index] += val index += index & -index def update(self, index, val): Updates the element of the array at index index to be val. delta = val - self.nums[index] self.nums[index] = val index += 1 while index <= self.n: self.tree[index] += delta index += index & -index def sumRange(self, left, right): Returns the sum of the elements between indices left and right inclusive. return self._prefix_sum(right) - self._prefix_sum(left - 1) def _prefix_sum(self, index): summation = 0 index += 1 while index > 0: summation += self.tree[index] index -= index & -index return summation"},{"question":"def triangle_area(side_a: float, side_b: float, side_c: float) -> float: Calculate the area of a triangle using Heron's formula. Parameters: side_a (float): Length of the first side of the triangle. side_b (float): Length of the second side of the triangle. side_c (float): Length of the third side of the triangle. Returns: float: The area of the triangle. Raises: ValueError: If the side lengths are not positive or do not meet the triangle inequality. Examples: >>> triangle_area(3.0, 4.0, 5.0) 6.0 >>> triangle_area(7.0, 10.0, 5.0) 16.24807680927192 >>> triangle_area(3.0, 4.0, -5.0) Traceback (most recent call last): ... ValueError: All side lengths must be positive >>> triangle_area(1.0, 1.0, 3.0) Traceback (most recent call last): ... ValueError: The sides do not satisfy the triangle inequality import math # Begin your solution here def test_triangle_area_valid_inputs(): assert math.isclose(triangle_area(3.0, 4.0, 5.0), 6.0, rel_tol=1e-9) assert math.isclose(triangle_area(7.0, 10.0, 5.0), 16.24807680927192, rel_tol=1e-9) assert math.isclose(triangle_area(6.0, 8.0, 10.0), 24.0, rel_tol=1e-9) def test_triangle_area_invalid_positive_sides(): try: triangle_area(-3.0, 4.0, 5.0) except ValueError as e: assert str(e) == \\"All side lengths must be positive\\" try: triangle_area(3.0, -4.0, 5.0) except ValueError as e: assert str(e) == \\"All side lengths must be positive\\" try: triangle_area(3.0, 4.0, -5.0) except ValueError as e: assert str(e) == \\"All side lengths must be positive\\" def test_triangle_area_inequality(): try: triangle_area(1.0, 1.0, 3.0) except ValueError as e: assert str(e) == \\"The sides do not satisfy the triangle inequality\\" try: triangle_area(1.0, 2.0, 8.0) except ValueError as e: assert str(e) == \\"The sides do not satisfy the triangle inequality\\" try: triangle_area(7.0, 3.0, 3.0) except ValueError as e: assert str(e) == \\"The sides do not satisfy the triangle inequality\\" def test_triangle_area_edge_cases(): assert math.isclose(triangle_area(1.0, 1.0, 1.0), 0.4330127018922193, rel_tol=1e-9) assert math.isclose(triangle_area(2.0, 2.0, 3.0), 1.984313483298443, rel_tol=1e-9) import math # Using pytest's main. if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"import math def triangle_area(side_a, side_b, side_c): Calculate the area of a triangle using Heron's formula. Parameters: side_a (float): Length of the first side of the triangle. side_b (float): Length of the second side of the triangle. side_c (float): Length of the third side of the triangle. Returns: float: The area of the triangle. Raises: ValueError: If the side lengths are not positive or do not meet the triangle inequality. # Validate the input if side_a <= 0 or side_b <= 0 or side_c <= 0: raise ValueError(\\"All side lengths must be positive\\") if side_a + side_b <= side_c or side_a + side_c <= side_b or side_b + side_c <= side_a: raise ValueError(\\"The sides do not satisfy the triangle inequality\\") # Calculate the semi-perimeter s = (side_a + side_b + side_c) / 2 # Calculate the area using Heron's formula area = math.sqrt(s * (s - side_a) * (s - side_b) * (s - side_c)) return area"},{"question":"def shortest_path(graph: list[list[int]], src: int, dest: int) -> int: Returns the shortest path distance from the source vertex to the destination vertex in a directed graph. >>> graph = [ >>> [0, 10, 0, 30, 100], >>> [0, 0, 50, 0, 0], >>> [0, 0, 0, 0, 10], >>> [0, 0, 20, 0, 60], >>> [0, 0, 0, 0, 0] >>> ] >>> shortest_path(graph, 0, 4) 60 >>> graph = [ >>> [0, 1, 0, 0], >>> [0, 0, 1, 0], >>> [0, 0, 0, 1], >>> [0, 0, 0, 0] >>> ] >>> shortest_path(graph, 0, 3) 3 >>> graph = [ >>> [0, 0, 0], >>> [0, 0, 0], >>> [0, 0, 0] >>> ] >>> shortest_path(graph, 0, 2) -1","solution":"import heapq def shortest_path(graph: list[list[int]], src: int, dest: int) -> int: Returns the shortest path distance from the source vertex to the destination vertex in a directed graph. n = len(graph) distances = [float('inf')] * n distances[src] = 0 priority_queue = [(0, src)] # (distance, vertex) while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # Early exit if we reach the destination if current_vertex == dest: return current_distance if current_distance > distances[current_vertex]: continue for neighbor in range(n): weight = graph[current_vertex][neighbor] if weight > 0: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return -1 if distances[dest] == float('inf') else distances[dest]"},{"question":"def are_anagrams(s1: str, s2: str) -> bool: Check whether two strings are anagrams of each other. Args: s1 (str): First string. s2 (str): Second string. Returns: bool: True if the strings are anagrams, False otherwise. >>> are_anagrams(\\"Listen\\", \\"Silent\\") True >>> are_anagrams(\\"Triangle\\", \\"Integral\\") True >>> are_anagrams(\\"Apple\\", \\"Pabble\\") False >>> are_anagrams(\\"A gentleman\\", \\"Elegant man\\") True","solution":"def are_anagrams(s1: str, s2: str) -> bool: Check whether two strings are anagrams of each other. Args: s1 (str): First string. s2 (str): Second string. Returns: bool: True if the strings are anagrams, False otherwise. # Remove spaces and lower the case s1 = s1.replace(\\" \\", \\"\\").lower() s2 = s2.replace(\\" \\", \\"\\").lower() # Check if sorted characters of both strings are equal return sorted(s1) == sorted(s2)"},{"question":"from typing import List def count_common_elements(lists: List[List[int]]) -> int: Determines the number of distinct integers present in all of the given lists. >>> count_common_elements([[1, 2, 3], [3, 4, 5], [3, 6, 7]]) 1 >>> count_common_elements([[5, 10, 15], [10, 20, 30], [5, 10, 25]]) 1 >>> count_common_elements([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 0 def test_count_common_elements(): assert count_common_elements([[1, 2, 3]]) == 3 assert count_common_elements([[1, 2, 3], [4, 5, 6]]) == 0 assert count_common_elements([[1, 2, 3], [3, 4, 5]]) == 1 assert count_common_elements([[1, 2, 3], [3, 4, 5], [3, 6, 7]]) == 1 assert count_common_elements([[5, 10, 15], [10, 20, 30], [5, 10, 25]]) == 1 assert count_common_elements([[1, 2, 3, 4], [2, 3, 4], [2, 3, 5, 6], [2, 3]]) == 2 assert count_common_elements([]) == 0 assert count_common_elements([[-1000, -999, -998], [-999, -1000], [-1000, -999, 800]]) == 2 assert count_common_elements([[-5, -10, -15], [-10, -20, -30], [-5, -10, -25]]) == 1","solution":"from typing import List def count_common_elements(lists: List[List[int]]) -> int: if not lists: return 0 # Convert each list into a set to eliminate duplicates sets_of_numbers = [set(lst) for lst in lists] # Find the intersection of all these sets common_elements = set.intersection(*sets_of_numbers) # Return the count of these common elements return len(common_elements)"},{"question":"def reverse_strings(input_list: List[str]) -> List[str]: Receives a list of strings and returns a new list with each string reversed while maintaining their respective positions. Args: input_list (List[str]): A list of strings. Returns: List[str]: A list where each string is reversed. Raises: ValueError: If the input is not a list of strings. Examples: >>> reverse_strings([\\"hello\\", \\"world\\"]) ['olleh', 'dlrow'] >>> reverse_strings([\\"Python\\", \\"is\\", \\"fun!\\"]) ['nohtyP', 'si', '!nuf'] >>> reverse_strings([\\"madam\\", \\"racecar\\", \\"deified\\"]) ['madam', 'racecar', 'deified'] >>> reverse_strings([\\"12345\\", \\"Hi There!\\"]) ['54321', '!erehT iH']","solution":"from typing import List def reverse_strings(input_list: List[str]) -> List[str]: Receives a list of strings and returns a new list with each string reversed while maintaining their respective positions. Args: input_list (List[str]): A list of strings. Returns: List[str]: A list where each string is reversed. Raises: ValueError: If the input is not a list of strings. if not isinstance(input_list, list): raise ValueError(f\\"Expected a list but got {type(input_list).__name__}\\") for item in input_list: if not isinstance(item, str): raise ValueError(f\\"Expected all elements in the list to be strings but found {type(item).__name__}\\") return [item[::-1] for item in input_list]"},{"question":"def trap_rain_water(heights: list[int]) -> int: Calculate the total volume of water that can be trapped after raining given a list of block heights. :param heights: List of non-negative integers representing the heights of blocks :return: An integer representing the total volume of trapped water >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) 9 >>> trap_rain_water([]) 0 >>> trap_rain_water([1, 2, 3, 4, 5]) 0 >>> trap_rain_water([3, 3, 3, 3]) 0 >>> trap_rain_water([0, 5, 0]) 0 >>> trap_rain_water([3, 0, 3]) 3 >>> trap_rain_water([2, 1, 0, 1, 3]) 4","solution":"def trap_rain_water(heights: list[int]) -> int: Calculates the total volume of water that can be trapped after raining given a list of block heights. :param heights: List of non-negative integers representing the heights of blocks :return: An integer representing the total volume of trapped water if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n trapped_water = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate trapped water for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"from typing import List def merge_sorted_arrays(arrays: List[List[int]]) -> List[int]: Merges k sorted arrays into a single sorted array. :param arrays: A list of k sorted arrays. Each individual array is sorted in ascending order. :return: A single sorted array containing all the elements from the input arrays in ascending order. >>> merge_sorted_arrays([ ... [1, 4, 5], ... [1, 3, 4], ... [2, 6] ... ]) == [1, 1, 2, 3, 4, 4, 5, 6] >>> merge_sorted_arrays([ ... [], ... [], ... [] ... ]) == [] >>> merge_sorted_arrays([ ... [10], ... [5], ... [2] ... ]) == [2, 5, 10] >>> merge_sorted_arrays([ ... [], ... [3, 4, 5], ... [] ... ]) == [3, 4, 5] >>> merge_sorted_arrays([ ... [-1000000000, -1, 0], ... [1, 1000000000] ... ]) == [-1000000000, -1, 0, 1, 1000000000] >>> merge_sorted_arrays([ ... [2, 2, 2], ... [2, 2], ... [2] ... ]) == [2, 2, 2, 2, 2, 2] >>> merge_sorted_arrays([ ... [] ... ]) == [] >>> merge_sorted_arrays([ ... list(range(1000)), ... list(range(1000, 2000)), ... list(range(2000, 3000)) ... ]) == list(range(3000)) pass","solution":"from typing import List import heapq def merge_sorted_arrays(arrays: List[List[int]]) -> List[int]: Merges k sorted arrays into a single sorted array. :param arrays: A list of k sorted arrays. Each individual array is sorted in ascending order. :return: A single sorted array containing all the elements from the input arrays in ascending order. merged_array = [] heap = [] # Initialize the min heap with the first element from each array for i, array in enumerate(arrays): if array: heapq.heappush(heap, (array[0], i, 0)) # (value, array_index, element_index) while heap: value, array_index, element_index = heapq.heappop(heap) merged_array.append(value) # If there is a next element in the same array, push it to the heap if element_index + 1 < len(arrays[array_index]): next_value = arrays[array_index][element_index + 1] heapq.heappush(heap, (next_value, array_index, element_index + 1)) return merged_array"},{"question":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: Given an \`n x n\` grid where each cell has a non-negative integer representing the cost of passing through that cell, returns the minimum path sum from the top-left corner to the bottom-right corner. You can only move down or right at any point in time. >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) # Outputs: 7 >>> min_path_sum([ ... [1, 2, 3], ... [4, 5, 6] ... ]) # Outputs: 12 def test_example_1(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_path_sum(grid) == 7 def test_example_2(): grid = [ [1, 2, 3], [4, 5, 6] ] assert min_path_sum(grid) == 12 def test_single_element_grid(): grid = [ [5] ] assert min_path_sum(grid) == 5 def test_single_row_grid(): grid = [ [1, 2, 5] ] assert min_path_sum(grid) == 8 def test_single_column_grid(): grid = [ [2], [3], [4] ] assert min_path_sum(grid) == 9 def test_minimal_grid(): grid = [ [0, 0], [0, 0] ] assert min_path_sum(grid) == 0 def test_large_values_grid(): grid = [ [100, 100], [100, 100] ] assert min_path_sum(grid) == 300 def test_large_grid(): grid = [ [1] * 100 for _ in range(100) ] assert min_path_sum(grid) == 199","solution":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: Given a 2D grid of non-negative integers representing the cost of passing through cells, returns the minimum path sum from the top-left corner to the bottom-right corner. You can only move down or right at any point in time. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Create a 2D dp array with the same dimensions as grid dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] # Initialize the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill up the dp array for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"class Inventory: def __init__(self): self.items = {} def add_item(self, item_name, quantity): Add a specified quantity of an item to the inventory. Args: item_name: str - The name of the item to add. quantity: int - The quantity of the item to add. Must be non-negative. Returns: None pass def remove_item(self, item_name, quantity): Remove a specified quantity of an item from the inventory. Args: item_name: str - The name of the item to remove. quantity: int - The quantity to remove. Must be non-negative. Returns: str - A message notifying the result of the removal operation. pass def search_item(self, item_name): Search for an item by its name and return its quantity. Args: item_name: str - The name of the item to search. Returns: int or str - The quantity of the item if found, or a message if the item does not exist. pass def list_items(self): List all items currently in the inventory with their respective quantities. Returns: list - A list of tuples containing all items and their quantities. pass # Unit Test: import pytest from solution import Inventory def test_add_item(): inventory = Inventory() inventory.add_item(\\"Apple\\", 50) assert inventory.search_item(\\"Apple\\") == 50 inventory.add_item(\\"Apple\\", 25) assert inventory.search_item(\\"Apple\\") == 75 def test_remove_item(): inventory = Inventory() inventory.add_item(\\"Apple\\", 50) inventory.remove_item(\\"Apple\\", 20) assert inventory.search_item(\\"Apple\\") == 30 result = inventory.remove_item(\\"Apple\\", 30) assert result == \\"All Apples have been removed\\" assert inventory.search_item(\\"Apple\\") == \\"Item Apple not found\\" def test_remove_non_existent_item(): inventory = Inventory() result = inventory.remove_item(\\"Orange\\", 10) assert result == \\"Item Orange does not exist in the inventory\\" def test_search_item(): inventory = Inventory() inventory.add_item(\\"Banana\\", 100) assert inventory.search_item(\\"Banana\\") == 100 assert inventory.search_item(\\"Grapes\\") == \\"Item Grapes not found\\" def test_non_negative_quantity(): inventory = Inventory() result = inventory.add_item(\\"Peach\\", -5) assert result == \\"Quantity must be a non-negative integer\\" result = inventory.remove_item(\\"Peach\\", -5) assert result == \\"Quantity must be a non-negative integer\\" def test_list_items(): inventory = Inventory() inventory.add_item(\\"Apple\\", 50) inventory.add_item(\\"Banana\\", 100) result = inventory.list_items() assert result == [(\\"Apple\\", 50), (\\"Banana\\", 100)]","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, item_name, quantity): if quantity < 0: return \\"Quantity must be a non-negative integer\\" if item_name in self.items: self.items[item_name] += quantity else: self.items[item_name] = quantity def remove_item(self, item_name, quantity): if quantity < 0: return \\"Quantity must be a non-negative integer\\" if item_name in self.items: if self.items[item_name] > quantity: self.items[item_name] -= quantity elif self.items[item_name] <= quantity: self.items.pop(item_name) # Remove the item completely if quantity is zero or below return f\\"All {item_name}s have been removed\\" else: return f\\"Item {item_name} does not exist in the inventory\\" def search_item(self, item_name): if item_name in self.items: return self.items[item_name] else: return f\\"Item {item_name} not found\\" def list_items(self): return list(self.items.items())"},{"question":"class CircularQueue: Circular Queue Implementation This class is a circular queue that allows enqueue and dequeue operations in a circular fashion. Methods: - __init__: Initializes the queue with a given capacity. - enqueue: Adds an item to the queue. - dequeue: Removes and returns the front item from the queue. - peek: Returns the front item without removing it. - is_empty: Checks if the queue is empty. - is_full: Checks if the queue is full. - display: Prints the current items in the queue from front to rear. >>> queue = CircularQueue(3) >>> queue.is_empty() True >>> queue.enqueue(10) >>> queue.enqueue(20) >>> queue.enqueue(30) >>> queue.display() [10, 20, 30] >>> queue.is_full() True >>> try: ... queue.enqueue(40) ... except OverflowError: ... print(\\"Queue is full\\") Queue is full >>> queue.dequeue() 10 >>> queue.display() [20, 30] >>> queue.peek() 20 >>> queue.display() [20, 30] >>> queue.enqueue(40) >>> queue.display() [20, 30, 40] >>> queue.is_full() True def __init__(self, capacity): pass def enqueue(self, item): pass def dequeue(self): pass def peek(self): pass def is_empty(self): pass def is_full(self): pass def display(self): pass import pytest def test_initialization(): with pytest.raises(ValueError): queue = CircularQueue(0) with pytest.raises(ValueError): queue = CircularQueue(-1) queue = CircularQueue(3) assert queue.is_empty() == True assert queue.is_full() == False def test_enqueue(): queue = CircularQueue(3) queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) assert queue.is_full() == True with pytest.raises(OverflowError): queue.enqueue(4) queue.display() # Expected output: [1, 2, 3] def test_dequeue(): queue = CircularQueue(3) queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) assert queue.dequeue() == 1 queue.display() # Expected output: [2, 3] assert queue.dequeue() == 2 queue.display() # Expected output: [3] assert queue.dequeue() == 3 queue.display() # Expected output: [] with pytest.raises(IndexError): queue.dequeue() def test_peek(): queue = CircularQueue(3) assert queue.peek() == None queue.enqueue(1) assert queue.peek() == 1 queue.enqueue(2) assert queue.peek() == 1 queue.enqueue(3) assert queue.dequeue() == 1 assert queue.peek() == 2 def test_is_empty(): queue = CircularQueue(3) assert queue.is_empty() == True queue.enqueue(1) assert queue.is_empty() == False def test_is_full(): queue = CircularQueue(3) assert queue.is_full() == False queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) assert queue.is_full() == True def test_display(): queue = CircularQueue(3) queue.display() # Expected output: [] queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) queue.display() # Expected output: [1, 2, 3] queue.dequeue() queue.display() # Expected output: [2, 3]","solution":"class CircularQueue: def __init__(self, capacity): if capacity <= 0: raise ValueError(\\"Capacity must be a positive integer\\") self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.count = 0 def enqueue(self, item): if self.is_full(): raise OverflowError(\\"Queue is full\\") self.queue[self.rear] = item self.rear = (self.rear + 1) % self.capacity self.count += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") item = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.count -= 1 return item def peek(self): if self.is_empty(): return None return self.queue[self.front] def is_empty(self): return self.count == 0 def is_full(self): return self.count == self.capacity def display(self): if self.is_empty(): print(\\"[]\\") return items = [] for i in range(self.count): items.append(self.queue[(self.front + i) % self.capacity]) print(items)"},{"question":"def rotate_list(array: list[int], k: int) -> list[int]: Rotates the list to the right by k positions. :param array: List of integers to rotate. :param k: Number of positions to rotate the list to the right. :return: The list after rotating it to the right by k positions. Examples: >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([10, 20, 30, 40], 1) [40, 10, 20, 30] >>> rotate_list([7, 7, 7, 7], 3) [7, 7, 7, 7] >>> rotate_list([1, 2, 3], 3) [1, 2, 3] >>> rotate_list([], 2) [] def test_rotate_list(): assert rotate_list([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_list([10, 20, 30, 40], 1) == [40, 10, 20, 30] assert rotate_list([7, 7, 7, 7], 3) == [7, 7, 7, 7] assert rotate_list([1, 2, 3], 3) == [1, 2, 3] assert rotate_list([], 2) == [] assert rotate_list([1, 2, 3, 4, 5], 7) == [4, 5, 1, 2, 3] assert rotate_list([], 0) == [] assert rotate_list([4, 5, 6, 7], 10) == [6, 7, 4, 5]","solution":"def rotate_list(array: list[int], k: int) -> list[int]: Rotates the list to the right by k positions. if not array: return [] k = k % len(array) # Handle cases where k is larger than len(array) return array[-k:] + array[:-k] if k != 0 else array"},{"question":"def max_non_overlapping_events(events: list[tuple[int, int]]) -> int: Determine the maximum number of non-overlapping events that can be attended in a single day. >>> max_non_overlapping_events([(1, 3), (2, 5), (6, 9), (8, 10)]) == 2 >>> max_non_overlapping_events([(0, 30), (31, 60), (60, 90)]) == 3 >>> max_non_overlapping_events([(0, 10), (15, 20), (10, 15), (25, 30)]) == 4 >>> max_non_overlapping_events([(5, 10), (10, 15), (15, 20), (20, 25)]) == 4 >>> max_non_overlapping_events([]) == 0","solution":"def max_non_overlapping_events(events): Returns the maximum number of non-overlapping events that can be attended. if not events: return 0 # Sort events by their ending times events.sort(key=lambda x: x[1]) count = 0 end_time = 0 # Iterate over the sorted events for start, end in events: if start >= end_time: # If the event does not overlap, attend it count += 1 end_time = end return count"},{"question":"from typing import List, Dict def top_selling_products(sales_data: List[Dict[str, float]], top_n: int) -> List[str]: Returns the top N selling products by total revenue. Parameters: sales_data (List[Dict[str, float]]): A list of dictionaries each containing a product ID and revenue. top_n (int): The number of top selling products to return. Returns: List[str]: A list of product IDs of the top N selling products based on total revenue. pass def test_example_case(): sales_data = [ {\\"product_id\\": \\"A123\\", \\"revenue\\": 500.0}, {\\"product_id\\": \\"B456\\", \\"revenue\\": 300.0}, {\\"product_id\\": \\"A123\\", \\"revenue\\": 700.0}, {\\"product_id\\": \\"C789\\", \\"revenue\\": 300.0}, {\\"product_id\\": \\"B456\\", \\"revenue\\": 200.0} ] assert top_selling_products(sales_data, 2) == [\\"A123\\", \\"B456\\"] def test_tie_case(): sales_data = [ {\\"product_id\\": \\"A123\\", \\"revenue\\": 300.0}, {\\"product_id\\": \\"B456\\", \\"revenue\\": 300.0}, {\\"product_id\\": \\"C789\\", \\"revenue\\": 300.0}, {\\"product_id\\": \\"D012\\", \\"revenue\\": 300.0} ] assert top_selling_products(sales_data, 2) == [\\"A123\\", \\"B456\\"] def test_all_same_revenue_case(): sales_data = [ {\\"product_id\\": \\"A123\\", \\"revenue\\": 100.0}, {\\"product_id\\": \\"B456\\", \\"revenue\\": 100.0}, {\\"product_id\\": \\"C789\\", \\"revenue\\": 100.0} ] assert top_selling_products(sales_data, 3) == [\\"A123\\", \\"B456\\", \\"C789\\"] def test_large_data_case(): sales_data = [{\\"product_id\\": str(i), \\"revenue\\": float(i)} for i in range(10000)] assert top_selling_products(sales_data, 5) == [\\"9999\\", \\"9998\\", \\"9997\\", \\"9996\\", \\"9995\\"] def test_single_product_case(): sales_data = [{\\"product_id\\": \\"A123\\", \\"revenue\\": 1000.0}] assert top_selling_products(sales_data, 1) == [\\"A123\\"] def test_zero_revenue_case(): sales_data = [ {\\"product_id\\": \\"A123\\", \\"revenue\\": 0.0}, {\\"product_id\\": \\"B456\\", \\"revenue\\": 0.0}, {\\"product_id\\": \\"C789\\", \\"revenue\\": 0.0} ] assert top_selling_products(sales_data, 2) == [\\"A123\\", \\"B456\\"]","solution":"from typing import List, Dict def top_selling_products(sales_data: List[Dict[str, float]], top_n: int) -> List[str]: Returns the top N selling products by total revenue. Parameters: sales_data (List[Dict[str, float]]): A list of dictionaries each containing a product ID and revenue. top_n (int): The number of top selling products to return. Returns: List[str]: A list of product IDs of the top N selling products based on total revenue. from collections import defaultdict # Dictionary to store total revenue for each product ID total_revenue = defaultdict(float) for sale in sales_data: product_id = sale['product_id'] revenue = sale['revenue'] total_revenue[product_id] += revenue # Sort products based on total revenue (descending) and product_id (lexicographically) sorted_products = sorted( total_revenue.items(), key=lambda x: (-x[1], x[0]) ) # Extract the top N product IDs top_products = [product_id for product_id, _ in sorted_products[:top_n]] return top_products"},{"question":"from typing import List, Tuple def is_valid_graph(edges: List[Tuple[int, int]]) -> bool: Determine if the given edges form a valid undirected graph. Args: edges (List[Tuple[int, int]]): A list of edges represented as tuples of two integers. Returns: bool: True if the edges form a valid undirected graph, False otherwise. Examples: >>> is_valid_graph([(0, 1), (1, 2), (2, 0)]) True >>> is_valid_graph([(0, 1), (1, 2), (2, 1), (0, 1)]) False >>> is_valid_graph([(0, 0), (1, 2)]) False >>> is_valid_graph([(0, 1), (2, 3)]) False","solution":"from typing import List, Tuple from collections import defaultdict, deque def is_valid_graph(edges: List[Tuple[int, int]]) -> bool: if not edges: return True graph = defaultdict(list) nodes = set() for u, v in edges: if u == v: return False # check for duplicate edges if v in graph[u] or u in graph[v]: return False graph[u].append(v) graph[v].append(u) nodes.add(u) nodes.add(v) # check if the graph is connected start_node = next(iter(nodes)) visited = set() queue = deque([start_node]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return len(visited) == len(nodes)"},{"question":"from typing import List def binary_search(arr: List[int], target: int) -> int: Perform a binary search to find the index of the target in the sorted list. Args: arr (List[int]): The sorted list of integers. target (int): The integer to find in the array. Returns: int: The index of the target in the array if found, otherwise -1. >>> binary_search([1, 2, 3, 4, 5, 6], 4) 3 >>> binary_search([1, 2, 3, 4, 5, 6], 6) 5 >>> binary_search([1, 2, 3, 4, 5, 6], 1) 0 >>> binary_search([1, 2, 3, 4, 5, 6], 7) -1 >>> binary_search([], 1) -1 pass def linear_search(arr: List[int], target: int) -> int: Perform a linear search to find the index of the target in the list. Args: arr (List[int]): The list of integers. target (int): The integer to find in the array. Returns: int: The index of the target in the array if found, otherwise -1. >>> linear_search([1, 2, 3, 4, 5, 6], 4) 3 >>> linear_search([1, 2, 3, 4, 5, 6], 6) 5 >>> linear_search([1, 2, 3, 4, 5, 6], 1) 0 >>> linear_search([1, 2, 3, 4, 5, 6], 7) -1 >>> linear_search([], 1) -1 pass import time def compare_search_performance(arr: List[int], target: int): Compare the performance of binary search and linear search. Args: arr (List[int]): The sorted list of integers. target (int): The integer to find in the array. start_time = time.time() binary_search_result = binary_search(arr, target) binary_search_time = time.time() - start_time start_time = time.time() linear_search_result = linear_search(arr, target) linear_search_time = time.time() - start_time print(f\\"Binary Search Result: {binary_search_result}, Time: {binary_search_time}\\") print(f\\"Linear Search Result: {linear_search_result}, Time: {linear_search_time}\\") # Unit Tests def test_binary_search(): assert binary_search([1, 2, 3, 4, 5, 6], 4) == 3 assert binary_search([1, 2, 3, 4, 5, 6], 6) == 5 assert binary_search([1, 2, 3, 4, 5, 6], 1) == 0 assert binary_search([1, 2, 3, 4, 5, 6], 7) == -1 assert binary_search([], 1) == -1 def test_linear_search(): assert linear_search([1, 2, 3, 4, 5, 6], 4) == 3 assert linear_search([1, 2, 3, 4, 5, 6], 6) == 5 assert linear_search([1, 2, 3, 4, 5, 6], 1) == 0 assert linear_search([1, 2, 3, 4, 5, 6], 7) == -1 assert linear_search([], 1) == -1 def test_compare_search_performance(): arr = list(range(1000)) target = 500 print(\\"Testing performance comparisonn\\") compare_search_performance(arr, target) test_binary_search() test_linear_search() test_compare_search_performance()","solution":"from typing import List def binary_search(arr: List[int], target: int) -> int: Perform a binary search to find the index of the target in the sorted list. Args: arr (List[int]): The sorted list of integers. target (int): The integer to find in the array. Returns: int: The index of the target in the array if found, otherwise -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1 def linear_search(arr: List[int], target: int) -> int: Perform a linear search to find the index of the target in the list. Args: arr (List[int]): The list of integers. target (int): The integer to find in the array. Returns: int: The index of the target in the array if found, otherwise -1. for index, value in enumerate(arr): if value == target: return index return -1 import time def compare_search_performance(arr: List[int], target: int): Compare the performance of binary search and linear search. Args: arr (List[int]): The sorted list of integers. target (int): The integer to find in the array. start_time = time.time() binary_search_result = binary_search(arr, target) binary_search_time = time.time() - start_time start_time = time.time() linear_search_result = linear_search(arr, target) linear_search_time = time.time() - start_time print(f\\"Binary Search Result: {binary_search_result}, Time: {binary_search_time}\\") print(f\\"Linear Search Result: {linear_search_result}, Time: {linear_search_time}\\")"},{"question":"from typing import List def find_pattern_occurrences(text: str, pattern: str) -> List[int]: Finds and returns the starting indices of all the substrings in the text that match the pattern. Args: text (str): The text string where to search for the pattern. pattern (str): The pattern string to match. Returns: List[int]: A list of starting indices where the pattern is found in the text. >>> find_pattern_occurrences(\\"abracadabra\\", \\"abra\\") [0, 7] >>> find_pattern_occurrences(\\"aaaaa\\", \\"aa\\") [0, 1, 2, 3] >>> find_pattern_occurrences(\\"mississippi\\", \\"issi\\") [1, 4] pass","solution":"from typing import List def find_pattern_occurrences(text: str, pattern: str) -> List[int]: Finds and returns the starting indices of all the substrings in the text that match the pattern. Args: text (str): The text string where to search for the pattern. pattern (str): The pattern string to match. Returns: List[int]: A list of starting indices where the pattern is found in the text. if not text or not pattern: return [] pattern_length = len(pattern) results = [] for i in range(len(text) - pattern_length + 1): if text[i:i+pattern_length] == pattern: results.append(i) return results"},{"question":"class TextProcessor: def __init__(self, text: str): self.text = text def word_count(self) -> dict: Return a dictionary with words as keys and their count of occurrences as values. >>> TextProcessor(\\"hello world hello\\").word_count() {'hello': 2, 'world': 1} >>> TextProcessor(\\"\\").word_count() {} >>> TextProcessor(\\"a a a b b c\\").word_count() {'a': 3, 'b': 2, 'c': 1} pass def longest_word(self) -> str: Return the longest word in the text. If multiple words are found with the same length, return the first found. >>> TextProcessor(\\"a abc abcde\\").longest_word() 'abcde' >>> TextProcessor(\\"this is a test longestword\\").longest_word() 'longestword' >>> TextProcessor(\\"\\").longest_word() '' pass def most_common_char(self) -> str: Return the most common character in the text ignoring spaces. In case of a tie, return the alphabetically first character. >>> TextProcessor(\\"hello world\\").most_common_char() 'l' >>> TextProcessor(\\"abc abc\\").most_common_char() 'a' >>> TextProcessor(\\"\\").most_common_char() '' pass","solution":"class TextProcessor: def __init__(self, text: str): self.text = text def word_count(self) -> dict: Return a dictionary with words as keys and their count of occurrences as values. words = self.text.split() word_count_dict = {} for word in words: word_count_dict[word] = word_count_dict.get(word, 0) + 1 return word_count_dict def longest_word(self) -> str: Return the longest word in the text. If multiple words are found with the same length, return the first found. words = self.text.split() if not words: return \\"\\" longest = words[0] for word in words: if len(word) > len(longest): longest = word return longest def most_common_char(self) -> str: Return the most common character in the text ignoring spaces. In case of a tie, return the alphabetically first character. from collections import Counter text_without_spaces = self.text.replace(\\" \\", \\"\\") if not text_without_spaces: return \\"\\" char_count = Counter(text_without_spaces) most_common = min(char_count.items(), key=lambda item: (-item[1], item[0])) return most_common[0]"},{"question":"from typing import List def largest_sum_non_adjacent(nums: List[int]) -> int: Given an array of integers, find the largest sum of non-adjacent numbers. >>> largest_sum_non_adjacent([3, 2, 5, 10, 7]) 15 >>> largest_sum_non_adjacent([-2, 1, 3, -4, 5]) 8 >>> largest_sum_non_adjacent([]) 0 >>> largest_sum_non_adjacent([5]) 5 >>> largest_sum_non_adjacent([-5]) 0 >>> largest_sum_non_adjacent([2, 4, 6, 2, 5]) 13 >>> largest_sum_non_adjacent([5, -1, 5, -1, 5]) 15 pass","solution":"from typing import List def largest_sum_non_adjacent(nums: List[int]) -> int: if not nums: return 0 if len(nums) == 1: return max(0, nums[0]) include = 0 exclude = 0 for num in nums: new_exclude = max(include, exclude) include = exclude + num exclude = new_exclude return max(include, exclude)"},{"question":"from collections import defaultdict class StockSystem: def __init__(self): Initialize your data structure here. def add_stock_price(self, company_name: str, time: int, price: int) -> None: Adds a stock price for the given company at the specified time. :param company_name: The name of the company. :param time: The time the stock price was recorded. :param price: The stock price at the given time. def get_latest_price(self, company_name: str) -> int: Returns the latest stock price for the specified company. :param company_name: The name of the company. :return: The latest stock price or -1 if no data present. >>> stock_system = StockSystem() >>> stock_system.add_stock_price(\\"ABC\\", 10, 100) >>> stock_system.get_latest_price(\\"ABC\\") 100 >>> stock_system.get_latest_price(\\"XYZ\\") -1 def get_maximum_price(self, company_name: str, start_time: int, end_time: int) -> int: Returns the highest stock price for the specified company within the given time range. :param company_name: The name of the company. :param start_time: The start of the time range. :param end_time: The end of the time range. :return: The highest stock price or -1 if no data present. >>> stock_system = StockSystem() >>> stock_system.add_stock_price(\\"ABC\\", 10, 100) >>> stock_system.add_stock_price(\\"ABC\\", 15, 200) >>> stock_system.get_maximum_price(\\"ABC\\", 10, 20) 200 >>> stock_system.get_maximum_price(\\"XYZ\\", 10, 20) -1 def get_minimum_price(self, company_name: str, start_time: int, end_time: int) -> int: Returns the lowest stock price for the specified company within the given time range. :param company_name: The name of the company. :param start_time: The start of the time range. :param end_time: The end of the time range. :return: The lowest stock price or -1 if no data present. >>> stock_system = StockSystem() >>> stock_system.add_stock_price(\\"ABC\\", 10, 100) >>> stock_system.add_stock_price(\\"ABC\\", 15, 200) >>> stock_system.get_minimum_price(\\"ABC\\", 10, 20) 100 >>> stock_system.get_minimum_price(\\"XYZ\\", 10, 20) -1","solution":"from collections import defaultdict class StockSystem: def __init__(self): self.stocks = defaultdict(list) def add_stock_price(self, company_name: str, time: int, price: int) -> None: self.stocks[company_name].append((time, price)) def get_latest_price(self, company_name: str) -> int: if company_name in self.stocks and self.stocks[company_name]: return self.stocks[company_name][-1][1] return -1 def get_maximum_price(self, company_name: str, start_time: int, end_time: int) -> int: if company_name not in self.stocks: return -1 max_price = -1 for time, price in self.stocks[company_name]: if start_time <= time <= end_time: max_price = max(max_price, price) return max_price def get_minimum_price(self, company_name: str, start_time: int, end_time: int) -> int: if company_name not in self.stocks: return -1 filtered_prices = [price for time, price in self.stocks[company_name] if start_time <= time <= end_time] if not filtered_prices: return -1 return min(filtered_prices)"},{"question":"def int_to_roman(num: int) -> str: Converts an integer to its Roman numeral representation. >>> int_to_roman(1) 'I' >>> int_to_roman(4) 'IV' >>> int_to_roman(9) 'IX' >>> int_to_roman(58) 'LVIII' >>> int_to_roman(1994) 'MCMXCIV' >>> int_to_roman(3999) 'MMMCMXCIX'","solution":"def int_to_roman(num: int) -> str: lookup = [ (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I'), ] roman_numeral = [] for value, symbol in lookup: while num >= value: roman_numeral.append(symbol) num -= value return ''.join(roman_numeral)"},{"question":"import re from typing import List, Dict, Any def validate_transaction_id(transaction_id: str) -> bool: Validate if a transaction ID follows the specified format: starts with a letter followed by 5 alphanumeric characters. :param transaction_id: str - transaction ID to validate :return: bool - True if valid, False otherwise >>> validate_transaction_id(\\"A1B2C3\\") True >>> validate_transaction_id(\\"12345B\\") False # [Write your code here] def calculate_total_amount(transactions: List[Dict[str, Any]]) -> float: Calculate the total amount for a list of transactions. :param transactions: List[Dict[str, Any]] - a list of dictionaries with 'id' (str) and 'amount' (float) :return: float - total amount of all transactions >>> calculate_total_amount([{'id': 'A1B2C3', 'amount': 250.0}, {'id': 'D4E5F6', 'amount': 750.0}]) 1000.0 >>> calculate_total_amount([{'id': 'A1B2C3', 'amount': 0.0}, {'id': 'D4E5F6', 'amount': -50.0}, {'id': 'G7H8I9', 'amount': 50.0}]) 0.0 # [Write your code here] def classify_transaction(transaction: Dict[str, Any]) -> str: Classify a transaction based on its amount. :param transaction: Dict[str, Any] - a dictionary with 'id' (str) and 'amount' (float) :return: str - transaction type ('small', 'medium', 'large') >>> classify_transaction({'id': 'A1B2C3', 'amount': 50.0}) 'small' >>> classify_transaction({'id': 'D4E5F6', 'amount': 500.0}) 'medium' >>> classify_transaction({'id': 'G7H8I9', 'amount': 1500.0}) 'large' # [Write your code here]","solution":"import re def validate_transaction_id(transaction_id): Validate if a transaction ID follows the specified format: starts with a letter followed by 5 alphanumeric characters. pattern = r'^[A-Za-z][A-Za-z0-9]{5}' return bool(re.match(pattern, transaction_id)) def calculate_total_amount(transactions): Calculate the total amount for a list of transactions. :param transactions: List[Dict[str, Any]] - a list of dictionaries with 'id' (str) and 'amount' (float) :return: float - total amount of all transactions return sum(transaction['amount'] for transaction in transactions) def classify_transaction(transaction): Classify a transaction based on its amount. :param transaction: Dict[str, Any] - a dictionary with 'id' (str) and 'amount' (float) :return: str - transaction type ('small', 'medium', 'large') amount = transaction['amount'] if amount < 100: return 'small' elif 100 <= amount < 1000: return 'medium' else: return 'large'"},{"question":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_consecutive_path(root: Node | None) -> int: Find the length of the longest consecutive path in a binary tree. The path can be either increasing or decreasing, and must be parent-child nodes. >>> root = Node(2, Node(3, Node(4)), Node(1, Node(0), Node(2))) >>> longest_consecutive_path(root) 3 >>> root = Node(1) >>> longest_consecutive_path(root) 1 >>> root = Node(1, Node(3), Node(5)) >>> longest_consecutive_path(root) 1 def test_empty_tree(): assert longest_consecutive_path(None) == 0 def test_single_node(): root = Node(1) assert longest_consecutive_path(root) == 1 def test_consecutive_increasing_path(): # Tree: # 1 # # 2 # # 3 root = Node(1, None, Node(2, None, Node(3))) assert longest_consecutive_path(root) == 3 def test_consecutive_decreasing_path(): # Tree: # 3 # / # 2 # # 1 root = Node(3, Node(2, None, Node(1))) assert longest_consecutive_path(root) == 3 def test_mixed_path(): # Tree: # 2 # / # 3 1 # / / # 4 0 2 root = Node(2, Node(3, Node(4)), Node(1, Node(0), Node(2))) assert longest_consecutive_path(root) == 3 def test_no_consecutive_path(): # Tree: # 1 # / # 3 5 root = Node(1, Node(3), Node(5)) assert longest_consecutive_path(root) == 1 def test_large_mixed_tree(): # Tree with various consecutive and non-consecutive paths root = Node(2) root.left = Node(3) root.left.left = Node(4) root.right = Node(1) root.right.left = Node(0) root.right.right = Node(2) root.right.right.right = Node(4) root.right.right.right.left = Node(3) root.right.right.right.left.left = Node(2) assert longest_consecutive_path(root) == 3","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_consecutive_path(root: Node) -> int: def longest_path(node): if not node: return (0, 0, 0) # (increasing, decreasing, max_length) left_inc, left_dec, left_max = longest_path(node.left) right_inc, right_dec, right_max = longest_path(node.right) inc = dec = 1 if node.left: if node.value + 1 == node.left.value: inc = left_inc + 1 elif node.value == node.left.value + 1: dec = left_dec + 1 if node.right: if node.value + 1 == node.right.value: inc = max(inc, right_inc + 1) elif node.value == node.right.value + 1: dec = max(dec, right_dec + 1) max_length = max(left_max, right_max, inc, dec) return inc, dec, max_length _, _, max_length = longest_path(root) return max_length"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def depth_sum(root: Optional[TreeNode]) -> List[int]: Given a binary tree, compute the sum of the values of all nodes at each depth level. The root node is considered to be at depth 0, its children are at depth 1, their children are at depth 2, and so on. >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) >>> depth_sum(root) [1, 5, 22] >>> root = TreeNode(7, TreeNode(0), TreeNode(-2, None, TreeNode(3))) >>> depth_sum(root) [7, -2, 3] >>> depth_sum(None) [] >>> root = TreeNode(1) >>> depth_sum(root) [1]","solution":"from typing import List, Optional from collections import deque, defaultdict class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def depth_sum(root: Optional[TreeNode]) -> List[int]: if not root: return [] level_sum = [] queue = deque([(root, 0)]) while queue: node, depth = queue.popleft() if len(level_sum) <= depth: level_sum.append(0) level_sum[depth] += node.val if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return level_sum"},{"question":"from typing import List def process_flash_sale(available_items: int, orders: List[int]) -> List[int]: Process flash sale orders to ensure fairness and return the actual number of items successfully purchased for each order. Args: available_items (int): The number of items available for the flash sale. orders (List[int]): A list of integers where each element represents the number of items requested in the order. Returns: List[int]: A list of integers representing the number of items purchased for each order, in the same sequence as the input list. Example: >>> process_flash_sale(50, [10, 20, 30, 40]) [10, 20, 20, 0] >>> process_flash_sale(100, [20, 15, 80, 5]) [20, 15, 65, 0] pass","solution":"from typing import List def process_flash_sale(available_items: int, orders: List[int]) -> List[int]: result = [] for order in orders: if available_items >= order: result.append(order) available_items -= order else: result.append(available_items) available_items = 0 return result"},{"question":"class ExpressionEvaluator: ExpressionEvaluator class to parse and compute the result of mathematical expressions. Methods: - evaluate(expression: str) -> float: Computes and returns the result of the given mathematical expression. Examples: >>> evaluator = ExpressionEvaluator() >>> evaluator.evaluate(\\"3+5\\") 8.0 >>> evaluator.evaluate(\\"3*5\\") 15.0 >>> evaluator.evaluate(\\"3+5*2\\") 13.0 >>> evaluator.evaluate(\\"(3+5)*2\\") 16.0 >>> evaluator.evaluate(\\" 3 + 5 * 2 \\") 13.0 >>> evaluator.evaluate(\\"((3+5)*2)/(2-3)\\") -16.0 def __init__(self): ... def evaluate(self, expression: str) -> float: ... def test_simple_addition(): evaluator = ExpressionEvaluator() assert evaluator.evaluate(\\"3+5\\") == 8.0 def test_simple_multiplication(): evaluator = ExpressionEvaluator() assert evaluator.evaluate(\\"3*5\\") == 15.0 def test_combined_operations(): evaluator = ExpressionEvaluator() assert evaluator.evaluate(\\"3+5*2\\") == 13.0 def test_parentheses(): evaluator = ExpressionEvaluator() assert evaluator.evaluate(\\"(3+5)*2\\") == 16.0 def test_with_spaces(): evaluator = ExpressionEvaluator() assert evaluator.evaluate(\\" 3 + 5 * 2 \\") == 13.0 def test_complex_expression(): evaluator = ExpressionEvaluator() assert evaluator.evaluate(\\"((3+5)*2)/(2-3)\\") == -16.0 def test_division(): evaluator = ExpressionEvaluator() assert evaluator.evaluate(\\"10/5\\") == 2.0 def test_nested_parentheses(): evaluator = ExpressionEvaluator() assert evaluator.evaluate(\\"2*(3+(4*5))\\") == 46.0 def test_subtraction(): evaluator = ExpressionEvaluator() assert evaluator.evaluate(\\"10-3\\") == 7.0 def test_negative_result(): evaluator = ExpressionEvaluator() assert evaluator.evaluate(\\"5-10\\") == -5.0","solution":"class ExpressionEvaluator: def __init__(self): pass def evaluate(self, expression: str) -> float: def get_number(): nonlocal i num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 return num def get_term(): nonlocal i num = get_factor() while i < len(expression) and expression[i] in \\"*/\\": if expression[i] == '*': i += 1 num *= get_factor() elif expression[i] == '/': i += 1 num //= get_factor() return num def get_factor(): nonlocal i if expression[i] == '(': i += 1 num = get_expression() i += 1 # skip closing parenthesis return num else: return get_number() def get_expression(): nonlocal i num = get_term() while i < len(expression) and expression[i] in \\"+-\\": if expression[i] == '+': i += 1 num += get_term() elif expression[i] == '-': i += 1 num -= get_term() return num i = 0 expression = expression.replace(' ', '') return get_expression()"},{"question":"def is_valid_brackets(s: str) -> bool: Validate if a given string containing only brackets ( '()', '{}', '[]' ) is valid. A string is considered valid if brackets are closed in the correct order with correct nesting. >>> is_valid_brackets(\\"()\\") True >>> is_valid_brackets(\\"()[]{}\\") True >>> is_valid_brackets(\\"(]\\") False >>> is_valid_brackets(\\"([)]\\") False >>> is_valid_brackets(\\"{[]}\\") True def test_valid_simple(): assert is_valid_brackets(\\"()\\") == True assert is_valid_brackets(\\"()[]{}\\") == True assert is_valid_brackets(\\"{[]}\\") == True def test_invalid_simple(): assert is_valid_brackets(\\"(]\\") == False assert is_valid_brackets(\\"([)]\\") == False def test_edge_cases(): assert is_valid_brackets(\\"\\") == True # Empty string is valid assert is_valid_brackets(\\"[\\") == False # Single unclosed bracket assert is_valid_brackets(\\"]\\") == False # Single unopened bracket def test_nested_brackets(): assert is_valid_brackets(\\"{[()]}\\") == True assert is_valid_brackets(\\"{[(])}\\") == False def test_multiple_same_brackets(): assert is_valid_brackets(\\"((()))\\") == True assert is_valid_brackets(\\"(()\\") == False def test_invalid_order(): assert is_valid_brackets(\\"}{\\") == False assert is_valid_brackets(\\"({[}])\\") == False","solution":"def is_valid_brackets(s: str) -> bool: Returns True if the input string s containing only brackets ( '()', '{}', '[]' ) is valid. A string is valid if brackets are closed in the correct order. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def total_series_resistance(resistances: list) -> float: Calculates the total resistance of resistors connected in series. Parameters: resistances (list of float): List of resistances in Ohms Returns: float: Total resistance in Ohms >>> total_series_resistance([3.0, 4.5, 6.2]) 13.7 >>> total_series_resistance([10.0]) 10.0 >>> total_series_resistance([1.1, 2.2, 3.3, 4.4]) 11.0","solution":"def total_series_resistance(resistances: list) -> float: Calculates the total resistance of resistors connected in series. Parameters: resistances (list of float): List of resistances in Ohms Returns: float: Total resistance in Ohms for resistance in resistances: if not isinstance(resistance, (int, float)) or resistance < 0: raise ValueError(\\"All resistances should be non-negative numbers\\") return sum(resistances)"},{"question":"from math import comb def generate_pascals_row(k: int) -> list: Generate the k-th row of Pascal's Triangle. :param k: int: the index of the row to generate :return: list: the k-th row of Pascal's Triangle >>> generate_pascals_row(0) [1] >>> generate_pascals_row(3) [1, 3, 3, 1] >>> generate_pascals_row(5) [1, 5, 10, 10, 5, 1]","solution":"from math import comb def generate_pascals_row(k: int) -> list: Generate the k-th row of Pascal's Triangle. :param k: int: the index of the row to generate :return: list: the k-th row of Pascal's Triangle return [comb(k, i) for i in range(k + 1)]"},{"question":"def serialize_tree(tree: str) -> str: Serializes a binary tree from its level-order traversal string representation. Args: tree (str): The string representation of a binary tree in level-order. Returns: str: The serialized level-order representation of the binary tree. Examples: >>> serialize_tree(\\"1,2,3,null,null,4,5\\") \\"1,2,3,null,null,4,5\\" >>> serialize_tree(\\"\\") \\"\\" >>> serialize_tree(\\"1\\") \\"1\\" >>> serialize_tree(\\"1,null,2,null,3,null,4\\") \\"1,null,2,null,3,null,4\\" >>> serialize_tree(\\"3,9,20,null,null,15,7\\") \\"3,9,20,null,null,15,7\\" >>> serialize_tree(\\"1,2,null,3,null,4,null,5\\") \\"1,2,null,3,null,4,null,5\\" >>> serialize_tree(\\"null,null,null\\") \\"null,null,null\\" pass","solution":"def serialize_tree(tree: str) -> str: Serializes a binary tree from its level-order traversal string representation. Args: tree (str): The string representation of a binary tree in level-order. Returns: str: The serialized level-order representation of the binary tree. # Simply return the input string, since the desired output is the same as the input return tree"},{"question":"from typing import List def num_combinations(prices: List[int], total_amount: int) -> int: Given a list of integers representing the prices of books and an integer representing the total amount of money, return the number of unique combinations of prices that sum up to the total amount. >>> num_combinations([1, 2, 3], 4) 4 >>> num_combinations([2, 3, 6, 7], 7) 2 >>> num_combinations([2, 4, 6], 5) 0 >>> num_combinations([3, 5, 7], 8) 1","solution":"from typing import List def num_combinations(prices: List[int], total_amount: int) -> int: Given a list of integers representing the prices of books and an integer representing the total amount of money, return the number of unique combinations of prices that sum up to the total amount. dp = [0] * (total_amount + 1) dp[0] = 1 # There's one way to make 0 total amount, by choosing no books for price in prices: for amount in range(price, total_amount + 1): dp[amount] += dp[amount - price] return dp[total_amount]"},{"question":"from typing import List def match_pattern(strings: List[str], pattern: str) -> List[str]: Match strings with the given pattern. :param strings: List[str] - A list of strings to match against the pattern. :param pattern: str - The pattern consisting of characters and the wildcard character '?'. :return: List[str] - A list of strings from the input list that match the pattern. >>> match_pattern([\\"test\\", \\"tent\\", \\"text\\", \\"team\\"], \\"te?t\\") [\\"test\\", \\"tent\\", \\"text\\"] >>> match_pattern([\\"apple\\", \\"apply\\", \\"apdle\\", \\"apcle\\"], \\"ap?le\\") [\\"apple\\", \\"apdle\\", \\"apcle\\"]","solution":"from typing import List def match_pattern(strings: List[str], pattern: str) -> List[str]: matched_strings = [] def is_match(s: str, p: str) -> bool: return len(s) == len(p) and all(sc == pc or pc == '?' for sc, pc in zip(s, p)) for s in strings: if is_match(s, pattern): matched_strings.append(s) return matched_strings"},{"question":"from typing import List def word_frequency(text: str, stop_words: List[str]) -> None: Read a block of text, process it to exclude predefined stop words, and compute the frequency of the remaining words. The function then prints the words and their corresponding counts in descending order of frequency. >>> text = \\"This is a sample text. This text is a simple example of text processing with stop words.\\" >>> stop_words = [\\"is\\", \\"a\\", \\"of\\", \\"with\\"] >>> word_frequency(text, stop_words) text: 3 this: 2 example: 1 processing: 1 sample: 1 simple: 1 stop: 1 words: 1 # your code here","solution":"import re from collections import Counter from typing import List def word_frequency(text: str, stop_words: List[str]) -> None: # Normalize text to lowercase and remove punctuation text = text.lower() text = re.sub(r'[^ws]', '', text) # Split text into words words = text.split() # Filter out stop words stop_words_set = set(stop_words) filtered_words = [word for word in words if word not in stop_words_set] # Count word frequencies word_counts = Counter(filtered_words) # Sort words by frequency and then lexicographically sorted_word_counts = sorted(word_counts.items(), key=lambda x: (-x[1], x[0])) # Print the results for word, count in sorted_word_counts: print(f\\"{word}: {count}\\")"},{"question":"def is_zigzag(nums: List[int]) -> bool: Check if the given list of integers is a zigzag list. Args: - nums (List[int]): The input list of integers. Returns: - bool: True if the list is a zigzag, False otherwise. >>> is_zigzag([1, 3, 2, 4, 3]) True >>> is_zigzag([3, 3, 3, 3]) False >>> is_zigzag([7, 6, 5, 4]) False >>> is_zigzag([1]) True >>> is_zigzag([]) True","solution":"from typing import List def is_zigzag(nums: List[int]) -> bool: if len(nums) < 2: return True for i in range(1, len(nums)-1): if not ((nums[i-1] < nums[i] > nums[i+1]) or (nums[i-1] > nums[i] < nums[i+1])): return False return True"},{"question":"class Matrix: def __init__(self, rows: int, columns: int) -> None: Initialize a matrix with given dimensions and initialize all elements to zero. pass def set_value(self, row: int, column: int, value: int) -> None: Set the value at the specific cell. pass def get_value(self, row: int, column: int) -> int: Get the value at the specific cell. pass def transpose(self) -> 'Matrix': Return the transposed matrix without modifying the original matrix. >>> m = Matrix(2, 3) >>> m.set_value(0, 0, 1) >>> m.set_value(0, 1, 2) >>> m.set_value(0, 2, 3) >>> m.set_value(1, 0, 4) >>> m.set_value(1, 1, 5) >>> m.set_value(1, 2, 6) >>> t = m.transpose() >>> t.get_value(0, 0) 1 >>> t.get_value(1, 0) 2 >>> t.get_value(2, 0) 3 >>> t.get_value(0, 1) 4 >>> t.get_value(1, 1) 5 >>> t.get_value(2, 1) 6 pass Test cases: def test_matrix_initialization(): m = Matrix(2, 3) assert m.rows == 2 assert m.columns == 3 assert m.get_value(0, 0) == 0 assert m.get_value(1, 2) == 0 def test_set_and_get_value(): m = Matrix(2, 3) m.set_value(0, 0, 10) m.set_value(1, 2, 20) assert m.get_value(0, 0) == 10 assert m.get_value(1, 2) == 20 m.set_value(1, 2, 30) assert m.get_value(1, 2) == 30 def test_transpose(): m = Matrix(2, 3) m.set_value(0, 0, 1) m.set_value(0, 1, 2) m.set_value(0, 2, 3) m.set_value(1, 0, 4) m.set_value(1, 1, 5) m.set_value(1, 2, 6) t = m.transpose() assert t.rows == 3 assert t.columns == 2 assert t.get_value(0, 0) == 1 assert t.get_value(1, 0) == 2 assert t.get_value(2, 0) == 3 assert t.get_value(0, 1) == 4 assert t.get_value(1, 1) == 5 assert t.get_value(2, 1) == 6 def test_transpose_single_column(): m = Matrix(3, 1) m.set_value(0, 0, 7) m.set_value(1, 0, 8) m.set_value(2, 0, 9) t = m.transpose() assert t.rows == 1 assert t.columns == 3 assert t.get_value(0, 0) == 7 assert t.get_value(0, 1) == 8 assert t.get_value(0, 2) == 9 def test_transpose_single_row(): m = Matrix(1, 3) m.set_value(0, 0, 5) m.set_value(0, 1, 6) m.set_value(0, 2, 7) t = m.transpose() assert t.rows == 3 assert t.columns == 1 assert t.get_value(0, 0) == 5 assert t.get_value(1, 0) == 6 assert t.get_value(2, 0) == 7","solution":"class Matrix: def __init__(self, rows: int, columns: int) -> None: self.rows = rows self.columns = columns self.data = [[0] * columns for _ in range(rows)] def set_value(self, row: int, column: int, value: int) -> None: self.data[row][column] = value def get_value(self, row: int, column: int) -> int: return self.data[row][column] def transpose(self) -> 'Matrix': transposed = Matrix(self.columns, self.rows) # Transpose matrix will have swapped rows and columns for i in range(self.rows): for j in range(self.columns): transposed.set_value(j, i, self.get_value(i, j)) return transposed"},{"question":"def clean_and_sort_records(records: list[tuple]) -> list[tuple]: Sort the records and remove duplicates. Args: records: A list of tuples where each tuple contains multiple elements of various types (integers, strings, etc.). Returns: A list of sorted tuples with duplicates removed. The sorting should be ascending and based on the standard tuple comparison. def test_clean_and_sort_records(): records = [(2, \\"apple\\"), (1, \\"banana\\"), (3, \\"apple\\"), (1, \\"banana\\"), (2, \\"apple\\")] expected = [(1, \\"banana\\"), (2, \\"apple\\"), (3, \\"apple\\")] assert clean_and_sort_records(records) == expected records = [(3, \\"pear\\"), (1, \\"orange\\"), (2, \\"kiwi\\")] expected = [(1, \\"orange\\"), (2, \\"kiwi\\"), (3, \\"pear\\")] assert clean_and_sort_records(records) == expected records = [] expected = [] assert clean_and_sort_records(records) == expected records = [(1, \\"banana\\")] expected = [(1, \\"banana\\")] assert clean_and_sort_records(records) == expected records = [(2, \\"apple\\"), (1, 3.14), (3, \\"banana\\"), (1, 3.14)] expected = [(1, 3.14), (2, \\"apple\\"), (3, \\"banana\\")] assert clean_and_sort_records(records) == expected","solution":"def clean_and_sort_records(records: list[tuple]) -> list[tuple]: Args: records: A list of tuples where each tuple contains multiple elements of various types (integers, strings, etc.). Returns: A list of sorted tuples with duplicates removed. The sorting should be ascending and based on the standard tuple comparison. # Use a set to remove duplicates, then convert back to a list unique_records = list(set(records)) # Sort the list of unique records unique_records.sort() return unique_records"},{"question":"def check_sentences(text: str) -> bool: Determines if all sentences in the input text are well-formed. A well-formed sentence starts with an uppercase letter and ends with a period. >>> check_sentences(\\"This is a well-formed sentence. This is another one.\\") == True >>> check_sentences(\\"this is not well-formed. This is.\\") == False >>> check_sentences(\\" \\") == True >>> check_sentences(\\"Correctly formatted. Unformatted\\") == False >>> check_sentences(\\"Well-formed. Another well-formed.\\") == True import re # Split text using regex to capture sentences sentences = re.split(r'(?<=[.])s+', text) for sentence in sentences: sentence = sentence.strip() if sentence: # Ignore empty or whitespace-only sentences if not (sentence[0].isupper() and sentence[-1] == '.'): return False return True","solution":"def check_sentences(text: str) -> bool: Determines if all sentences in the input text are well-formed. A well-formed sentence starts with an uppercase letter and ends with a period. import re # Split text using regex to capture sentences sentences = re.split(r'(?<=[.])s+', text) for sentence in sentences: sentence = sentence.strip() if sentence: # Ignore empty or whitespace-only sentences if not (sentence[0].isupper() and sentence[-1] == '.'): return False return True"},{"question":"from typing import Sequence def longest_distinct_subarray(nums: Sequence[int]) -> int: Returns the length of the longest subarray that contains distinct elements. >>> longest_distinct_subarray([1, 2, 3, 1, 2, 3]) 3 >>> longest_distinct_subarray([1, 2, 2, 3, 4, 5]) 4 >>> longest_distinct_subarray([0, -1, -2, 1, 2]) 5 def test_example_cases(): assert longest_distinct_subarray([1, 2, 3, 1, 2, 3]) == 3 assert longest_distinct_subarray([1, 2, 2, 3, 4, 5]) == 4 assert longest_distinct_subarray([0, -1, -2, 1, 2]) == 5 def test_empty_array(): assert longest_distinct_subarray([]) == 0 def test_single_element(): assert longest_distinct_subarray([1]) == 1 assert longest_distinct_subarray([100]) == 1 def test_all_same_elements(): assert longest_distinct_subarray([1, 1, 1, 1, 1]) == 1 def test_all_distinct_elements(): assert longest_distinct_subarray([1, 2, 3, 4, 5]) == 5 assert longest_distinct_subarray([10, 20, 30, 40, 50]) == 5 def test_large_input(): assert longest_distinct_subarray( list(range(100000)) + [99999] ) == 100000","solution":"from typing import Sequence def longest_distinct_subarray(nums: Sequence[int]) -> int: Returns the length of the longest subarray that contains distinct elements. element_index_map = {} max_length = 0 start = 0 for end, value in enumerate(nums): if value in element_index_map: start = max(start, element_index_map[value] + 1) element_index_map[value] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List def find_ceiling(nums: List[int], target: int) -> int: Find the smallest element in the sorted list \`nums\` that is greater than or equal to the \`target\`. If no such element exists, return -1. >>> find_ceiling([1, 3, 5, 6, 8, 10], 7) 8 >>> find_ceiling([1, 3, 5, 6, 8, 10], 10) 10 >>> find_ceiling([1, 3, 5, 6, 8, 10], 11) -1 # Your implementation here pass","solution":"from typing import List def find_ceiling(nums: List[int], target: int) -> int: Find the smallest element in the sorted list \`nums\` that is greater than or equal to the \`target\`. If no such element exists, return -1. left, right = 0, len(nums) - 1 result = -1 while left <= right: mid = (left + right) // 2 if nums[mid] >= target: result = nums[mid] right = mid - 1 else: left = mid + 1 return result"},{"question":"from typing import List, Tuple def find_connected_components(friendships: List[Tuple[int, int]]) -> int: Determine the number of connected components in the social network. :param friendships: List of tuples where each tuple (a, b) represents a friendship relationship between user a and user b. :return: int, the total number of connected components in the network. >>> find_connected_components([(1, 2), (2, 3), (4, 5)]) 2 >>> find_connected_components([(1, 2), (2, 3)]) 1 >>> find_connected_components([]) 0 >>> find_connected_components([(1, 2), (3, 4), (5, 6)]) 3 >>> find_connected_components([(1, 2), (2, 3), (3, 1), (4, 5)]) 2","solution":"from typing import List, Tuple def find_connected_components(friendships: List[Tuple[int, int]]) -> int: def bfs(node): queue = [node] visited.add(node) while queue: current = queue.pop(0) for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) if not friendships: return 0 graph = {} for a, b in friendships: if a not in graph: graph[a] = [] if b not in graph: graph[b] = [] graph[a].append(b) graph[b].append(a) visited = set() count = 0 for node in graph: if node not in visited: count += 1 bfs(node) return count"},{"question":"class Node: def __init__(self, val: int): Initializes a node with a given value and sets the next node to None. self.val = val self.next = None class LinkedList: def __init__(self): Initializes an empty linked list. self.head = None def insert_at_head(self, val: int) -> None: Insert a new node with the value val at the beginning of the list. def insert_at_end(self, val: int) -> None: Insert a new node with the value val at the end of the list. def insert_at_position(self, pos: int, val: int) -> bool: Insert a new node with the value val at the position pos (0-based index). Return True if the node was successfully inserted, return False otherwise. def delete_by_value(self, val: int) -> bool: Delete the first occurrence of a node with the value val from the list. Return True if a node with the value val was found and deleted, return False otherwise. def __str__(self) -> str: Define the string representation of the linked list for easier visualization. # Unit Tests: def test_insert_at_head(): linked_list = LinkedList() linked_list.insert_at_head(10) assert str(linked_list) == \\"10\\" linked_list.insert_at_head(20) assert str(linked_list) == \\"20 -> 10\\" def test_insert_at_end(): linked_list = LinkedList() linked_list.insert_at_end(10) assert str(linked_list) == \\"10\\" linked_list.insert_at_end(20) assert str(linked_list) == \\"10 -> 20\\" def test_insert_at_position(): linked_list = LinkedList() assert linked_list.insert_at_position(0, 10) == True assert str(linked_list) == \\"10\\" assert linked_list.insert_at_position(1, 20) == True assert str(linked_list) == \\"10 -> 20\\" assert linked_list.insert_at_position(1, 15) == True assert str(linked_list) == \\"10 -> 15 -> 20\\" assert linked_list.insert_at_position(5, 25) == False assert str(linked_list) == \\"10 -> 15 -> 20\\" def test_delete_by_value(): linked_list = LinkedList() linked_list.insert_at_head(10) linked_list.insert_at_end(20) linked_list.insert_at_end(30) assert linked_list.delete_by_value(20) == True assert str(linked_list) == \\"10 -> 30\\" assert linked_list.delete_by_value(10) == True assert str(linked_list) == \\"30\\" assert linked_list.delete_by_value(40) == False assert str(linked_list) == \\"30\\" assert linked_list.delete_by_value(30) == True assert str(linked_list) == \\"\\" def test_empty_list_operations(): linked_list = LinkedList() assert linked_list.delete_by_value(10) == False assert linked_list.insert_at_position(1, 20) == False # Running the tests if __name__ == \\"__main__\\": test_insert_at_head() test_insert_at_end() test_insert_at_position() test_delete_by_value() test_empty_list_operations() print(\\"All tests passed!\\")","solution":"class Node: def __init__(self, val: int): Initializes a node with a given value and sets the next node to None. self.val = val self.next = None class LinkedList: def __init__(self): Initializes an empty linked list. self.head = None def insert_at_head(self, val: int) -> None: Insert a new node with the value val at the beginning of the list. new_node = Node(val) new_node.next = self.head self.head = new_node def insert_at_end(self, val: int) -> None: Insert a new node with the value val at the end of the list. new_node = Node(val) if self.head is None: self.head = new_node else: current = self.head while current.next is not None: current = current.next current.next = new_node def insert_at_position(self, pos: int, val: int) -> bool: Insert a new node with the value val at the position pos (0-based index). Return True if the node was successfully inserted, return False otherwise. if pos < 0: return False new_node = Node(val) if pos == 0: new_node.next = self.head self.head = new_node return True current = self.head index = 0 while current is not None and index < pos - 1: current = current.next index += 1 if current is None: return False new_node.next = current.next current.next = new_node return True def delete_by_value(self, val: int) -> bool: Delete the first occurrence of a node with the value val from the list. Return True if a node with the value val was found and deleted, return False otherwise. current = self.head previous = None while current is not None: if current.val == val: if previous is None: self.head = current.next else: previous.next = current.next return True previous = current current = current.next return False def __str__(self) -> str: Define the string representation of the linked list for easier visualization. values = [] current = self.head while current is not None: values.append(str(current.val)) current = current.next return \\" -> \\".join(values)"},{"question":"class AutoCorrect: A simple text autocorrect system. Methods: learn(word: str): Adds a word to the system's dictionary. If the word already exists, no action is taken. get_candidates(prefix: str) -> List[str]: Returns a list of words from the system's dictionary that start with a given prefix. The list should be sorted alphabetically and contain at most 5 words. Examples: >>> auto_correct = AutoCorrect() >>> auto_correct.learn(\\"hello\\") >>> auto_correct.learn(\\"help\\") >>> auto_correct.learn(\\"helium\\") >>> auto_correct.learn(\\"helicopter\\") >>> auto_correct.learn(\\"hero\\") >>> auto_correct.learn(\\"herald\\") >>> auto_correct.get_candidates(\\"he\\") ['helicopter', 'helium', 'hello', 'help', 'herald'] >>> auto_correct.get_candidates(\\"hel\\") ['helicopter', 'helium', 'hello', 'help'] >>> auto_correct.get_candidates(\\"her\\") ['herald', 'hero'] >>> auto_correct.get_candidates(\\"hi\\") [] def __init__(self): # Initialize the AutoCorrect class with an empty dictionary. def learn(self, word: str) -> None: # Learn the word, adding it to the dictionary if it is not already present. def get_candidates(self, prefix: str) -> List[str]: # Return up to 5 dictionary words that start with the given prefix, sorted alphabetically.","solution":"class AutoCorrect: def __init__(self): self.dictionary = set() def learn(self, word: str) -> None: # Add the word to the dictionary self.dictionary.add(word.lower()) def get_candidates(self, prefix: str): # Filter and sort the candidates starting with the given prefix prefix = prefix.lower() candidates = sorted( [word for word in self.dictionary if word.startswith(prefix)] )[:5] return candidates"},{"question":"def run_length_encode(s): Compresses the string using run-length encoding. :param s: The input string to be compressed. :return: Run-length encoded string. :raises TypeError: If the input is not a string. >>> run_length_encode(\\"aabccc\\") 'a2b1c3' >>> run_length_encode(\\"abcd\\") 'a1b1c1d1' >>> run_length_encode(\\"\\") '' >>> run_length_encode(12345) Traceback (most recent call last): ... TypeError: Input must be a string","solution":"def run_length_encode(s): Compresses the string using run-length encoding. :param s: The input string to be compressed. :return: Run-length encoded string. :raises TypeError: If the input is not a string. if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") if not s: return \\"\\" encoded_string = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: encoded_string.append(f\\"{current_char}{count}\\") current_char = char count = 1 encoded_string.append(f\\"{current_char}{count}\\") return \\"\\".join(encoded_string)"},{"question":"def anagram_ranking(word1: str, word2: str) -> (bool, int): Checks if two given strings are anagrams and calculates the lexical rank of the second string among all possible anagrams of the first string. >>> is_anagram, rank = anagram_ranking(\\"listen\\", \\"silent\\") >>> is_anagram True >>> rank > 0 True >>> is_anagram, rank = anagram_ranking(\\"hello\\", \\"world\\") >>> is_anagram False >>> rank -1 >>> is_anagram, rank = anagram_ranking(\\"abc\\", \\"abc\\") >>> is_anagram True >>> rank 1 >>> is_anagram, rank = anagram_ranking(\\"abcd\\", \\"dcba\\") >>> is_anagram True >>> rank > 0 True >>> is_anagram, rank = anagram_ranking(\\"aabbcc\\", \\"ccbbaa\\") >>> is_anagram True >>> rank > 0 True","solution":"from itertools import permutations def anagram_ranking(word1: str, word2: str) -> (bool, int): # Check if the two words are anagrams if sorted(word1) != sorted(word2): return False, -1 # Generate all unique anagrams of word1 unique_anagrams = sorted(set(permutations(word1))) # Convert the anagrams from tuple back to strings anagrams_str = [''.join(anagram) for anagram in unique_anagrams] # Find the rank of word2 among the sorted anagrams rank = anagrams_str.index(word2) + 1 return True, rank"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def get_intersection_node(headA, headB): Determines the node at which the intersection of two singly linked lists begins. headA : ListNode, the head node of the first linked list. headB : ListNode, the head node of the second linked list. Returns the ListNode where the intersection starts or None if there is no intersection. >>> # Creating two intersecting linked lists: >>> a1 = ListNode(1) >>> a2 = ListNode(2) >>> c1 = ListNode(3) >>> c2 = ListNode(4) >>> c3 = ListNode(5) >>> b1 = ListNode(6) >>> b2 = ListNode(7) >>> b3 = ListNode(8) >>> a1.next = a2 >>> a2.next = c1 >>> c1.next = c2 >>> c2.next = c3 >>> b1.next = b2 >>> b2.next = b3 >>> b3.next = c1 >>> get_intersection_node(a1, b1) <__main__.ListNode object at 0x...> # The intersection node with value 3","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def get_intersection_node(headA, headB): Determines the node at which the intersection of two singly linked lists begins. :param headA: ListNode, the head node of the first linked list. :param headB: ListNode, the head node of the second linked list. :return: ListNode where the intersection starts or None if there is no intersection. if not headA or not headB: return None pointerA, pointerB = headA, headB # Traverse both lists. When reaching the end of a list, start at the head of the other list. while pointerA is not pointerB: pointerA = pointerA.next if pointerA else headB pointerB = pointerB.next if pointerB else headA return pointerA # Can be None or the intersection node"},{"question":"def single_number(nums: list[int]) -> int: Identify the integer in a list which appears exactly one time, while every other integer appears exactly three times. >>> single_number([2, 2, 3, 2]) 3 >>> single_number([0, 1, 0, 1, 0, 1, 99]) 99 >>> single_number([-2, -2, 1, -2]) 1 >>> single_number([30000, 500, 100, 30000, 100, 30000, 100]) 500","solution":"def single_number(nums: list[int]) -> int: Identify the integer in a list which appears exactly one time, while every other integer appears exactly three times. seen_once = seen_twice = 0 for num in nums: # first appearance: add num to seen_once # second appearance: remove num from seen_once and add to seen_twice # third appearance: remove num from seen_twice seen_once = ~seen_twice & (seen_once ^ num) seen_twice = ~seen_once & (seen_twice ^ num) return seen_once"},{"question":"[Completion Task in Python] import csv import statistics from collections import Counter import math def compute_statistics(csv_file: str, column_name: str) -> dict: Computes the mean, median, and mode for a specified column in a CSV file. Args: csv_file (str): The path to the CSV file. column_name (str): The name of the column for which statistics are to be computed. Returns: dict: A dictionary containing the mean, median, and mode of the specified column. values = [] try: with open(csv_file, mode='r', encoding='utf-8') as file: reader = csv.DictReader(file) if column_name not in reader.fieldnames: raise ValueError(f\\"Column '{column_name}' does not exist in the CSV file.\\") for row in reader: try: value = float(row[column_name]) if not math.isnan(value): values.append(value) except (ValueError, KeyError): continue if not values: raise ValueError(f\\"No valid data found for column '{column_name}'.\\") mean = statistics.mean(values) median = statistics.median(values) mode = statistics.mode(values) return {'mean': mean, 'median': median, 'mode': mode} except FileNotFoundError: raise FileNotFoundError(f\\"File '{csv_file}' not found.\\") except Exception as e: raise e","solution":"import csv import statistics from collections import Counter import math def compute_statistics(csv_file: str, column_name: str) -> dict: Computes the mean, median, and mode for a specified column in a CSV file. Args: csv_file (str): The path to the CSV file. column_name (str): The name of the column for which statistics are to be computed. Returns: dict: A dictionary containing the mean, median, and mode of the specified column. values = [] try: with open(csv_file, mode='r', encoding='utf-8') as file: reader = csv.DictReader(file) if column_name not in reader.fieldnames: raise ValueError(f\\"Column '{column_name}' does not exist in the CSV file.\\") for row in reader: try: value = float(row[column_name]) if not math.isnan(value): values.append(value) except (ValueError, KeyError): continue if not values: raise ValueError(f\\"No valid data found for column '{column_name}'.\\") mean = statistics.mean(values) median = statistics.median(values) mode = statistics.mode(values) return {'mean': mean, 'median': median, 'mode': mode} except FileNotFoundError: raise FileNotFoundError(f\\"File '{csv_file}' not found.\\") except Exception as e: raise e"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The solution must be provided without using division and should have a time complexity of O(n). >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0]","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: length = len(nums) answer = [1] * length left_product = 1 for i in range(length): answer[i] = left_product left_product *= nums[i] right_product = 1 for i in range(length - 1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"def min_operations_to_balance(s: str) -> int: Determines the minimum number of operations required to make the string balanced. A string is considered balanced if every opening parenthesis '(' can find a corresponding closing parenthesis ')' to form pairs. Args: s (str): A string of parentheses. Returns: int: The minimum number of operations required to make the string balanced. Examples: >>> min_operations_to_balance(\\"(()\\") == 1 >>> min_operations_to_balance(\\"())(\\") == 2 >>> min_operations_to_balance(\\"(((\\") == 3 >>> min_operations_to_balance(\\"()\\") == 0 >>> min_operations_to_balance(\\"(()))(()()(\\") == 3 >>> min_operations_to_balance(\\"\\") == 0 >>> min_operations_to_balance(\\"(((((((\\") == 7 >>> min_operations_to_balance(\\")))))))\\") == 7 >>> min_operations_to_balance(\\"())(()()))(\\") == 3 >>> min_operations_to_balance(\\")(()())(\\") == 2","solution":"def min_operations_to_balance(s: str) -> int: Determines the minimum number of operations required to make the string balanced. left_unmatched = 0 operations = 0 for char in s: if char == '(': left_unmatched += 1 else: if left_unmatched > 0: left_unmatched -= 1 else: operations += 1 operations += left_unmatched return operations"},{"question":"from typing import List def num_enclaves(grid: List[List[int]]) -> int: Count the number of land cells in all enclaves in the grid. An enclave is a land cell that is not connected to the border of the grid. Args: grid: A two-dimensional binary matrix where 0 represents water and 1 represents land. Returns: The number of land cells in all enclaves. Example: >>> num_enclaves([ [0, 0, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0] ]) 3 >>> num_enclaves([ [0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 0, 0] ]) 0 pass # Unit tests def test_num_enclaves_1(): grid = [ [0, 0, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0] ] assert num_enclaves(grid) == 3 def test_num_enclaves_2(): grid = [ [0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 0, 0] ] assert num_enclaves(grid) == 0 def test_num_enclaves_all_land(): grid = [ [1, 1], [1, 1] ] assert num_enclaves(grid) == 0 def test_num_enclaves_all_water(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert num_enclaves(grid) == 0 def test_num_enclaves_single_enclave(): grid = [ [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] assert num_enclaves(grid) == 8","solution":"from typing import List def num_enclaves(grid: List[List[int]]) -> int: rows, cols = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or y < 0 or x >= rows or y >= cols or grid[x][y] == 0: return grid[x][y] = 0 # Sink the land to water directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dx, dy in directions: dfs(x + dx, y + dy) # Flood fill all land connected to borders for r in range(rows): for c in range(cols): if grid[r][c] == 1 and (r in {0, rows-1} or c in {0, cols-1}): dfs(r, c) # Count remaining land cells enclaves = sum(grid[r][c] == 1 for r in range(rows) for c in range(cols)) return enclaves"},{"question":"class SimpleFileSystem: def __init__(self): Initializes the SimpleFileSystem with an empty dictionary to store files and records. pass def create_record(self, file_name: str, key: str, value: str) -> None: Creates a new record in the specified file with the given key and value. If the file does not exist, it should be created. If the key already exists in the file, it should raise a ValueError with the message \\"Duplicate key\\". Args: file_name (str): The name of the file. key (str): The unique key for the record. value (str): The value associated with the key. pass def retrieve_record(self, file_name: str, key: str) -> str: Retrieves the value associated with the given key in the specified file. If the file or the key does not exist, it should raise a KeyError with the message \\"Record not found\\". Args: file_name (str): The name of the file. key (str): The unique key for the record. Returns: str: The value associated with the key. pass # Tests if __name__ == \\"__main__\\": fs = SimpleFileSystem() # Test creating and retrieving records fs.create_record(\\"file1.txt\\", \\"key1\\", \\"value1\\") assert fs.retrieve_record(\\"file1.txt\\", \\"key1\\") == \\"value1\\" fs.create_record(\\"file1.txt\\", \\"key2\\", \\"value2\\") assert fs.retrieve_record(\\"file1.txt\\", \\"key2\\") == \\"value2\\" # Test creating duplicate key try: fs.create_record(\\"file1.txt\\", \\"key1\\", \\"value3\\") except ValueError as e: assert str(e) == \\"Duplicate key\\" # Test retrieving non-existent record try: fs.retrieve_record(\\"file1.txt\\", \\"key3\\") except KeyError as e: assert str(e) == \\"Record not found\\" # Test retrieving from non-existent file try: fs.retrieve_record(\\"file2.txt\\", \\"key1\\") except KeyError as e: assert str(e) == \\"Record not found\\"","solution":"class SimpleFileSystem: def __init__(self): self.files = {} def create_record(self, file_name: str, key: str, value: str) -> None: if file_name not in self.files: self.files[file_name] = {} if key in self.files[file_name]: raise ValueError(\\"Duplicate key\\") self.files[file_name][key] = value def retrieve_record(self, file_name: str, key: str) -> str: if file_name not in self.files or key not in self.files[file_name]: raise KeyError(\\"Record not found\\") return self.files[file_name][key]"},{"question":"import heapq def dijkstra(graph: dict, start: int) -> dict: Implements Dijkstra's algorithm to find the shortest path from start node to all other nodes in a weighted, directed graph. Parameters: graph (dict): A dictionary where keys are integers representing nodes, and values are dictionaries with neighboring nodes as keys and edge weights as values. start (int): The starting node. Returns: dict: A dictionary where keys are nodes and values are the shortest travel time from the start node to the respective node. Examples: >>> dijkstra({ ... 0: {1: 2, 2: 5}, ... 1: {0: 2, 2: 1, 3: 4}, ... 2: {0: 5, 1: 1, 3: 7}, ... 3: {1: 4, 2: 7} ... }, 0) {0: 0, 1: 2, 2: 3, 3: 6} >>> dijkstra({ ... 1: {2: 1, 3: 4}, ... 2: {1: 1, 3: 2, 4: 5}, ... 3: {1: 4, 2: 2, 4: 1}, ... 4: {2: 5, 3: 1} ... }, 1) {1: 0, 2: 1, 3: 3, 4: 4}","solution":"import heapq def dijkstra(graph, start): Implements Dijkstra's algorithm to find the shortest path from start node to all other nodes. Parameters: graph (dict): A dictionary where keys are integers representing nodes, and values are dictionaries with neighboring nodes as keys and edge weights as values. start (int): The starting node. Returns: dict: A dictionary where keys are nodes and values are the shortest travel time from the start node to the respective node. # Initial distances to all nodes set to infinity distances = {node: float('infinity') for node in graph} distances[start] = 0 # Distance to the start node is 0 # Priority queue priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # This check is crucial to avoid outdated queue entries if current_distance > distances[current_node]: continue # Explore the neighbors for neighbor, weight in graph[current_node].items(): distance = current_distance + weight # Only consider this new path if it's better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"def reverse_words(s: str) -> str: Reverse the order of words in a given string. :param s: Input string to reverse words in. :return: A new string with words in reversed order. >>> reverse_words(\\"hello world\\") == \\"world hello\\" >>> reverse_words(\\"The quick brown fox\\") == \\"fox brown quick The\\" >>> reverse_words(\\"Python is fun\\") == \\"fun is Python\\" >>> reverse_words(\\"a b c d\\") == \\"d c b a\\" >>> reverse_words(\\"\\") == \\"\\" >>> reverse_words(\\"singleword\\") == \\"singleword\\"","solution":"def reverse_words(s: str) -> str: Reverse the order of words in a given string. :param s: Input string to reverse words in. :return: A new string with words in reversed order. # Split the string into words words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words into a new string return ' '.join(reversed_words)"},{"question":"from typing import List, Tuple def sort_tuples(data: List[Tuple[int, str]]) -> List[Tuple[int, str]]: Sort a list of tuples first by string in alphabetical order, and then by integer in ascending order if the strings are the same. >>> sort_tuples([(10, 'apple'), (5, 'banana'), (10, 'banana'), (8, 'apple'), (3, 'cherry')]) [(8, 'apple'), (10, 'apple'), (5, 'banana'), (10, 'banana'), (3, 'cherry')] >>> sort_tuples([(3, 'apple'), (1, 'apple'), (2, 'apple')]) [(1, 'apple'), (2, 'apple'), (3, 'apple')] >>> sort_tuples([]) [] >>> sort_tuples([(1, 'apple')]) [(1, 'apple')]","solution":"def sort_tuples(data): Sort a list of tuples first by string in alphabetical order, and then by integer in ascending order if the strings are the same. return sorted(data, key=lambda x: (x[1], x[0]))"},{"question":"def is_happy_number(number: int) -> bool: Determines if the given number is a happy number. >>> is_happy_number(19) True >>> is_happy_number(2) False >>> is_happy_number(7) True >>> is_happy_number(20) False","solution":"def is_happy_number(number: int) -> bool: Determines if the given number is a happy number. Parameters: number (int): The number to check for happiness. Returns: bool: True if the number is happy, False otherwise. def sum_of_squares(n: int) -> int: Helper function to calculate the sum of the squares of digits of n. return sum(int(digit) ** 2 for digit in str(n)) if not isinstance(number, int) or number <= 0: raise ValueError(\\"Input must be a positive integer\\") seen = set() while number != 1 and number not in seen: seen.add(number) number = sum_of_squares(number) return number == 1"},{"question":"class Queue: def __init__(self): Initializes an empty queue. def enqueue(self, element: int) -> None: Adds the element to the end of the queue. :param element: Integer to be added to the queue. def dequeue(self) -> int | None: Removes and returns the element at the front of the queue. :return: Integer at the front of the queue or None if the queue is empty. def size(self) -> int: Returns the number of elements in the queue. :return: The size of the queue. def front(self) -> int | None: Returns the element at the front of the queue without removing it. :return: Integer at the front of the queue or None if the queue is empty. # Example usage of the Queue class queue = Queue() queue.enqueue(1) queue.enqueue(2) print(queue.size()) # Output: 2 print(queue.front()) # Output: 1 print(queue.dequeue()) # Output: 1 print(queue.size()) # Output: 1 print(queue.front()) # Output: 2 print(queue.dequeue()) # Output: 2 print(queue.dequeue()) # Output: None import pytest def test_enqueue(): q = Queue() q.enqueue(1) q.enqueue(2) assert q.size() == 2 def test_dequeue(): q = Queue() q.enqueue(1) q.enqueue(2) assert q.dequeue() == 1 assert q.dequeue() == 2 assert q.dequeue() == None def test_size(): q = Queue() assert q.size() == 0 q.enqueue(1) assert q.size() == 1 q.dequeue() assert q.size() == 0 def test_front(): q = Queue() assert q.front() == None q.enqueue(1) assert q.front() == 1 q.enqueue(2) assert q.front() == 1 q.dequeue() assert q.front() == 2 q.dequeue() assert q.front() == None","solution":"class Queue: def __init__(self): Initializes an empty queue. self.queue = [] def enqueue(self, element: int) -> None: Adds the element to the end of the queue. :param element: Integer to be added to the queue. self.queue.append(element) def dequeue(self) -> int | None: Removes and returns the element at the front of the queue. :return: Integer at the front of the queue or None if the queue is empty. if not self.queue: return None return self.queue.pop(0) def size(self) -> int: Returns the number of elements in the queue. :return: The size of the queue. return len(self.queue) def front(self) -> int | None: Returns the element at the front of the queue without removing it. :return: Integer at the front of the queue or None if the queue is empty. if not self.queue: return None return self.queue[0]"},{"question":"def analyze_log(file_path: str) -> dict: Analyzes a web server log file and returns a summary report. Args: file_path (str): The path to the log file to be analyzed. Returns: dict: A dictionary containing the summary report with keys: 'total_requests', 'successful_requests', 'client_errors', 'server_errors'. Example: >>> report = analyze_log(\\"server.log\\") >>> print(report) { \\"total_requests\\": 10000, \\"successful_requests\\": 8000, \\"client_errors\\": 1500, \\"server_errors\\": 500, } pass import pytest def test_analyze_log(): log_content = ( \\"127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] \\"GET /apache_pb.gif HTTP/1.0\\" 200 2326n\\" \\"127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] \\"GET /apache_pb.gif HTTP/1.0\\" 404 2326n\\" \\"127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] \\"GET /apache_pb.gif HTTP/1.0\\" 500 2326n\\" \\"127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] \\"GET /apache_pb.gif HTTP/1.0\\" 503 2326n\\" \\"127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] \\"GET /apache_pb.gif HTTP/1.0\\" 403 2326n\\" \\"127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] \\"GET /apache_pb.gif HTTP/1.0\\" 200 2326n\\" ) file_path = 'test_log.txt' # Write log content to file with open(file_path, 'w') as file: file.write(log_content) # Analyze the log report = analyze_log(file_path) # Assertions assert report[\\"total_requests\\"] == 6 assert report[\\"successful_requests\\"] == 2 assert report[\\"client_errors\\"] == 2 assert report[\\"server_errors\\"] == 2 def test_analyze_log_empty_file(): file_path = 'empty_log.txt' # Write empty content to file with open(file_path, 'w') as file: file.write('') # Analyze the log report = analyze_log(file_path) # Assertions assert report[\\"total_requests\\"] == 0 assert report[\\"successful_requests\\"] == 0 assert report[\\"client_errors\\"] == 0 assert report[\\"server_errors\\"] == 0 def test_analyze_log_malformed_lines(): log_content = ( \\"127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] \\"GET /apache_pb.gif HTTP/1.0\\" 200 2326n\\" \\"MALFORMED LINEn\\" \\"127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] \\"GET /apache_pb.gif HTTP/1.0\\" 500 2326n\\" ) file_path = 'malformed_log.txt' # Write log content to file with open(file_path, 'w') as file: file.write(log_content) # Analyze the log report = analyze_log(file_path) # Assertions assert report[\\"total_requests\\"] == 3 assert report[\\"successful_requests\\"] == 1 assert report[\\"client_errors\\"] == 0 assert report[\\"server_errors\\"] == 1","solution":"def analyze_log(file_path: str) -> dict: Analyzes a web server log file and returns a summary report. Args: file_path (str): The path to the log file to be analyzed. Returns: dict: A dictionary containing the summary report with keys: 'total_requests', 'successful_requests', 'client_errors', 'server_errors'. # Initialize counters total_requests = 0 successful_requests = 0 client_errors = 0 server_errors = 0 # Read the file line by line with open(file_path, 'r') as file: for line in file: total_requests += 1 parts = line.split() if len(parts) > 8: status_code = parts[8] if status_code.isdigit(): status_code = int(status_code) if 200 <= status_code < 300: successful_requests += 1 elif 400 <= status_code < 500: client_errors += 1 elif 500 <= status_code < 600: server_errors += 1 # Return the summary report return { \\"total_requests\\": total_requests, \\"successful_requests\\": successful_requests, \\"client_errors\\": client_errors, \\"server_errors\\": server_errors, }"},{"question":"def is_valid_float(s: str) -> bool: This function determines if the provided string is a valid floating-point number representation. Args: s (str): The string to evaluate. Returns: bool: True if the string is a valid floating-point number, False otherwise. Examples: >>> is_valid_float(\\"3.14\\") True >>> is_valid_float(\\"-4.2E10\\") True >>> is_valid_float(\\"+6.022e23\\") True >>> is_valid_float(\\"12e-2\\") True >>> is_valid_float(\\"5.67.89\\") False >>> is_valid_float(\\"abc\\") False >>> is_valid_float(\\"1..2\\") False # Your implementation here","solution":"def is_valid_float(s: str) -> bool: This function determines if the provided string is a valid floating-point number representation. Args: s (str): The string to evaluate. Returns: bool: True if the string is a valid floating-point number, False otherwise. import re # Regular expression pattern for a valid floating-point number float_pattern = re.compile(r'^[-+]?(?:(?:d*.d+)|(?:d+.?d*))([eE][-+]?d+)?') # Check if the string matches the floating-point number pattern return bool(re.match(float_pattern, s))"},{"question":"import math from typing import Tuple def initial_velocity(velocity: float, angle: float) -> Tuple[float, float]: Calculate the initial vertical and horizontal velocity components of a projectile. The initial vertical and horizontal components of the velocity are determined by the formulas: V_{0_y} = V_0 * sin(angle) V_{0_x} = V_0 * cos(angle) The function properly handles input validation and rounds the results to two decimal places. Args: velocity (float): Initial velocity V_0 in meters per second. Must be positive. angle (float): Launch angle θ in degrees. Returns: Tuple[float, float]: A tuple containing two floats—the vertical and horizontal components of the initial velocity, respectively, rounded to two decimal places. Raises: ValueError: If the initial velocity is not positive. Examples: >>> initial_velocity(30.0, 45) (21.21, 21.21) >>> initial_velocity(20.0, 30) (10.00, 17.32) >>> initial_velocity(25.0, 60) (21.65, 12.50) >>> initial_velocity(50.0, 90) (50.00, 0.00) >>> initial_velocity(30.0, 0) (0.00, 30.00) >>> initial_velocity(0, 45) Traceback (most recent call last): ... ValueError: Initial velocity must be positive. >>> initial_velocity(-10, 45) Traceback (most recent call last): ... ValueError: Initial velocity must be positive.","solution":"import math from typing import Tuple def initial_velocity(velocity: float, angle: float) -> Tuple[float, float]: if velocity <= 0: raise ValueError(\\"Initial velocity must be positive.\\") angle_radians = math.radians(angle) v0_y = round(velocity * math.sin(angle_radians), 2) v0_x = round(velocity * math.cos(angle_radians), 2) return v0_y, v0_x"},{"question":"from typing import Dict, List, Tuple, Callable def a_star_shortest_path(graph: Dict[str, List[Tuple[str, int]]], start: str, goal: str, heuristic: Callable[[str, str], int]) -> List[str]: Finds the shortest path in a weighted directed graph using a simplified A* algorithm. :param graph: A dictionary representing the graph, where keys are node identifiers and values are lists of tuples. Each tuple contains a neighboring node and the weight of the edge connecting to it. :param start: The starting node identifier. :param goal: The goal node identifier. :param heuristic: A callable function that estimates the cost from a given node to the goal node. :return: A list of node identifiers representing the shortest path from start to goal. >>> graph = { ... 'A': [('B', 1), ('C', 4)], ... 'B': [('A', 1), ('C', 2), ('D', 5)], ... 'C': [('A', 4), ('B', 2), ('D', 1)], ... 'D': [('B', 5), ('C', 1)] ... } >>> heuristic_fn = lambda x, y: 1 if x != y else 0 >>> a_star_shortest_path(graph, 'A', 'D', heuristic_fn) ['A', 'B', 'C', 'D'] >>> graph = { ... 'A': [('B', 1)], ... 'B': [('A', 1)], ... 'C': [('D', 1)], ... 'D': [('C', 1)] ... } >>> a_star_shortest_path(graph, 'A', 'D', heuristic_fn) [] pass def heuristic(x, y): return 1 if x != y else 0 def test_simple_path(): graph = { 'A': [('B', 1), ('C', 4)], 'B': [('A', 1), ('C', 2), ('D', 5)], 'C': [('A', 4), ('B', 2), ('D', 1)], 'D': [('B', 5), ('C', 1)] } assert a_star_shortest_path(graph, 'A', 'D', heuristic) == ['A', 'B', 'C', 'D'] def test_no_path(): graph = { 'A': [('B', 1)], 'B': [('A', 1)], 'C': [('D', 1)], 'D': [('C', 1)] } assert a_star_shortest_path(graph, 'A', 'D', heuristic) == [] def test_direct_path(): graph = { 'A': [('B', 1)], 'B': [('C', 2)], 'C': [('D', 1)], 'D': [('E', 3)], } assert a_star_shortest_path(graph, 'A', 'E', heuristic) == ['A', 'B', 'C', 'D', 'E'] def test_already_at_goal(): graph = { 'A': [('B', 1), ('C', 4)], } assert a_star_shortest_path(graph, 'A', 'A', heuristic) == ['A'] def test_complex_graph(): graph = { 'A': [('B', 2), ('C', 5)], 'B': [('A', 2), ('C', 3), ('D', 1)], 'C': [('A', 5), ('B', 3), ('D', 3)], 'D': [('B', 1), ('C', 3)] } assert a_star_shortest_path(graph, 'A', 'D', heuristic) == ['A', 'B', 'D']","solution":"from typing import Dict, List, Tuple, Callable import heapq def a_star_shortest_path(graph: Dict[str, List[Tuple[str, int]]], start: str, goal: str, heuristic: Callable[[str, str], int]) -> List[str]: Finds the shortest path in a weighted directed graph using a simplified A* algorithm. :param graph: A dictionary representing the graph, where keys are node identifiers and values are lists of tuples. Each tuple contains a neighboring node and the weight of the edge connecting to it. :param start: The starting node identifier. :param goal: The goal node identifier. :param heuristic: A callable function that estimates the cost from a given node to the goal node. :return: A list of node identifiers representing the shortest path from start to goal. # Priority queue to store (cost, current_node) open_set = [(0 + heuristic(start, goal), 0, start)] heapq.heapify(open_set) # Dictionary to store the cost to reach each node g_score = {start: 0} # Dictionary to store the path taken to reach each node came_from = {} while open_set: current_f_score, current_cost, current_node = heapq.heappop(open_set) # If we reached the goal, reconstruct the path and return it if current_node == goal: path = [] while current_node in came_from: path.append(current_node) current_node = came_from[current_node] path.append(start) return path[::-1] for neighbor, weight in graph.get(current_node, []): tentative_g_score = g_score[current_node] + weight # If this path to the neighbor is better, record it if tentative_g_score < g_score.get(neighbor, float('inf')): came_from[neighbor] = current_node g_score[neighbor] = tentative_g_score f_score = tentative_g_score + heuristic(neighbor, goal) heapq.heappush(open_set, (f_score, tentative_g_score, neighbor)) return []"},{"question":"class OptimizedDataStructure: def __init__(self): Initializes the data structure. pass def add(self, item: int) -> None: Adds an integer item to the data structure. pass def remove(self, item: int) -> None: Removes an integer item from the data structure. pass def get_max(self) -> int: Retrieves the maximum integer present in the data structure. pass def contains(self, item: int) -> bool: Checks if the integer item is in the data structure. pass # Example Usage if __name__ == \\"__main__\\": ods = OptimizedDataStructure() ods.add(3) ods.add(5) ods.add(1) print(ods.get_max()) # Expected output: 5 print(ods.contains(3)) # Expected output: True print(ods.contains(4)) # Expected output: False ods.remove(5) print(ods.get_max()) # Expected output: 3 # Test cases def test_add_and_get_max(): ods = OptimizedDataStructure() ods.add(3) ods.add(5) ods.add(1) assert ods.get_max() == 5 def test_contains(): ods = OptimizedDataStructure() ods.add(3) ods.add(5) ods.add(1) assert ods.contains(3) == True assert ods.contains(4) == False def test_remove_and_get_max(): ods = OptimizedDataStructure() ods.add(3) ods.add(5) ods.add(1) assert ods.get_max() == 5 ods.remove(5) assert ods.get_max() == 3 def test_remove_and_contains(): ods = OptimizedDataStructure() ods.add(3) ods.add(5) ods.add(1) ods.remove(5) assert ods.contains(5) == False def test_get_max_after_all_removed(): ods = OptimizedDataStructure() ods.add(3) ods.add(5) ods.add(1) ods.remove(1) ods.remove(3) ods.remove(5) assert ods.get_max() == None","solution":"import heapq class OptimizedDataStructure: def __init__(self): self.data = [] self.max_heap = [] self.entry_finder = {} def add(self, item: int) -> None: if item not in self.entry_finder: heapq.heappush(self.data, item) heapq.heappush(self.max_heap, -item) self.entry_finder[item] = True def remove(self, item: int) -> None: if item in self.entry_finder: self.entry_finder.pop(item) def get_max(self) -> int: while self.max_heap and -self.max_heap[0] not in self.entry_finder: heapq.heappop(self.max_heap) return -self.max_heap[0] if self.max_heap else None def contains(self, item: int) -> bool: return item in self.entry_finder"},{"question":"def check_temperature_readings(readings, min_threshold, max_threshold): Returns a list of indices where the temperature readings fall outside the comfortable range. Parameters: readings (list of float): The list of temperature readings in Celsius. min_threshold (float): The minimum comfortable temperature in Celsius. max_threshold (float): The maximum comfortable temperature in Celsius. Returns: list of int: Indices where the readings fall outside the comfortable range. >>> check_temperature_readings([22.5, 25.6, 19.8, 28.1, 30.0], 20.0, 26.0) [2, 3, 4] >>> check_temperature_readings([21.0, 22.5, 23.0, 24.0, 25.5], 20.0, 26.0) [] >>> check_temperature_readings([15.0, 35.0, 10.0, 40.0], 20.0, 30.0) [0, 1, 2, 3] import pytest def test_all_readings_in_range(): readings = [21.0, 22.5, 23.0, 24.0, 25.5] assert check_temperature_readings(readings, 20.0, 26.0) == [] def test_all_readings_out_of_range(): readings = [15.0, 35.0, 10.0, 40.0] assert check_temperature_readings(readings, 20.0, 30.0) == [0, 1, 2, 3] def test_some_readings_out_of_range(): readings = [18.5, 22.0, 26.5, 20.0, 30.0] assert check_temperature_readings(readings, 20.0, 26.0) == [0, 2, 4] def test_edge_values(): readings = [20.0, 26.0, 25.9, 20.1, 19.9] assert check_temperature_readings(readings, 20.0, 26.0) == [4] def test_empty_readings_list(): readings = [] with pytest.raises(ValueError, match=\\"The readings list cannot be empty.\\"): check_temperature_readings(readings, 20.0, 26.0) def test_invalid_thresholds(): readings = [22.5, 23.0] with pytest.raises(ValueError, match=\\"min_threshold cannot be greater than max_threshold.\\"): check_temperature_readings(readings, 26.0, 20.0) def test_min_equals_max_threshold(): readings = [20.0, 21.0, 20.0] assert check_temperature_readings(readings, 20.0, 20.0) == [1]","solution":"def check_temperature_readings(readings, min_threshold, max_threshold): Returns a list of indices where the temperature readings fall outside the comfortable range. Parameters: readings (list of float): The list of temperature readings in Celsius. min_threshold (float): The minimum comfortable temperature in Celsius. max_threshold (float): The maximum comfortable temperature in Celsius. Returns: list of int: Indices where the readings fall outside the comfortable range. if not readings: raise ValueError(\\"The readings list cannot be empty.\\") if min_threshold > max_threshold: raise ValueError(\\"min_threshold cannot be greater than max_threshold.\\") out_of_range_indices = [] for idx, temp in enumerate(readings): if temp < min_threshold or temp > max_threshold: out_of_range_indices.append(idx) return out_of_range_indices"},{"question":"def rearrange_alternately(arr: List[int]) -> List[int]: Rearrange a sorted array alternately such that the pattern is: - max, min, 2nd max, 2nd min, and so on. Parameters: - arr (List[int]): A sorted list of positive integers. Returns: - List[int]: The rearranged list of integers. Example: >>> rearrange_alternately([1, 2, 3, 4, 5, 6, 7, 8, 9]) [9, 1, 8, 2, 7, 3, 6, 4, 5] >>> rearrange_alternately([10, 20, 30, 40, 50]) [50, 10, 40, 20, 30]","solution":"def rearrange_alternately(arr): Rearrange a sorted array alternately such that the pattern is: - max, min, 2nd max, 2nd min, and so on. Parameters: - arr (List[int]): A sorted list of positive integers. Returns: - List[int]: The rearranged list of integers. n = len(arr) result = [0] * n # Pointers for max and min elements max_idx = n - 1 min_idx = 0 # Use flag to switch between max and min flag = True for i in range(n): if flag: result[i] = arr[max_idx] max_idx -= 1 else: result[i] = arr[min_idx] min_idx += 1 flag = not flag return result"},{"question":"from typing import List def find_duplicates(nums: List[int]) -> List[int]: Find duplicates in a list of integers. Given a list of integers, return a list of duplicates in the order they first appear in the list. Each duplicate should only appear once in the output list. Examples: >>> find_duplicates([1, 2, 3, 1, 2, 4, 5, 6, 1]) [1, 2] >>> find_duplicates([-1, -2, -3, -1, -2, -3, -4, -5]) [-1, -2, -3] >>> find_duplicates([10, 20, 30, 40, 50, 30, 20, 60, 10]) [10, 20, 30] >>> find_duplicates([7]) []","solution":"from typing import List def find_duplicates(nums: List[int]) -> List[int]: seen = set() duplicates = set() result = [] for num in nums: if num in seen: if num not in duplicates: duplicates.add(num) result.append(num) else: seen.add(num) return result"},{"question":"class StringReverser: Custom String Reverser with Undo Operation. Supports the following operations: - append(val: str) -> None: Adds a string to the end. - reversestr(start: int, end: int) -> None: Reverses the substring from index start to end (both inclusive). - undo() -> None: Undoes the last reversestr operation. - is_empty() -> bool: Checks if the string is empty. - __repr__() -> str: Returns a string representation of the current state of the string. Example: >>> sr = StringReverser(\\"hello\\") >>> sr.append(\\" world\\") >>> print(sr) 'hello world' >>> sr.reversestr(6, 10) >>> print(sr) 'hello dlrow' >>> sr.undo() >>> print(sr) 'hello world' >>> print(sr.is_empty()) False def __init__(self: StringReverser, initial_string: str = \\"\\") -> None: pass def append(self: StringReverser, val: str) -> None: pass def reversestr(self: StringReverser, start: int, end: int) -> None: pass def undo(self: StringReverser) -> None: pass def is_empty(self: StringReverser) -> bool: pass def __repr__(self: StringReverser) -> str: pass # Unit Tests def test_append(): sr = StringReverser(\\"hello\\") sr.append(\\" world\\") assert str(sr) == \\"hello world\\" def test_reversestr_valid_range(): sr = StringReverser(\\"hello world\\") sr.reversestr(6, 10) assert str(sr) == \\"hello dlrow\\" def test_reversestr_invalid_range(): sr = StringReverser(\\"hello world\\") try: sr.reversestr(-1, 5) except ValueError: assert str(sr) == \\"hello world\\" try: sr.reversestr(11, 5) except ValueError: assert str(sr) == \\"hello world\\" try: sr.reversestr(6, 15) except ValueError: assert str(sr) == \\"hello world\\" def test_undo(): sr = StringReverser(\\"hello world\\") sr.reversestr(6, 10) sr.undo() assert str(sr) == \\"hello world\\" def test_is_empty(): sr = StringReverser(\\"\\") assert sr.is_empty() == True sr.append(\\"test\\") assert sr.is_empty() == False def test_repr(): sr = StringReverser(\\"hello\\") assert sr.__repr__() == \\"hello\\"","solution":"class StringReverser: def __init__(self, initial_string: str = \\"\\") -> None: self._string = initial_string self._history = [] def append(self, val: str) -> None: self._string += val def reversestr(self, start: int, end: int) -> None: if start < 0 or end >= len(self._string) or start > end: raise ValueError(\\"Invalid start or end index\\") self._history.append((start, end, self._string[start:end+1])) substr_reversed = self._string[start:end+1][::-1] self._string = self._string[:start] + substr_reversed + self._string[end+1:] def undo(self) -> None: if self._history: start, end, original_substring = self._history.pop() self._string = self._string[:start] + original_substring + self._string[end+1:] def is_empty(self) -> bool: return len(self._string) == 0 def __repr__(self) -> str: return self._string"},{"question":"def brew_potion(recipe: dict, ingredients: dict) -> bool: Determines if a potion can be successfully brewed given the available ingredients and their quantities. >>> brew_potion({\\"unicorn_horn\\": 3, \\"fairy_dust\\": 5}, {\\"unicorn_horn\\": 3, \\"fairy_dust\\": 5, \\"troll_eye\\": 2}) True >>> brew_potion({\\"unicorn_horn\\": 4, \\"fairy_dust\\": 5}, {\\"unicorn_horn\\": 3, \\"fairy_dust\\": 5, \\"troll_eye\\": 2}) False >>> brew_potion({\\"unicorn_horn\\": 2, \\"fairy_dust\\": 3, \\"phoenix_feather\\": 1}, {\\"unicorn_horn\\": 2, \\"fairy_dust\\": 3, \\"phoenix_feather\\": 1}) True >>> brew_potion({\\"unicorn_horn\\": 3, \\"fairy_dust\\": 5, \\"troll_eye\\": 2}, {\\"unicorn_horn\\": 3, \\"fairy_dust\\": 5, \\"phoenix_feather\\": 1}) False >>> brew_potion({\\"unicorn_horn\\": 1}, {\\"unicorn_horn\\": 1}) True pass","solution":"def brew_potion(recipe, ingredients): Determines if a potion can be successfully brewed given the available ingredients and their quantities. :param recipe: Dictionary where keys are ingredient names and values are the required quantities. :param ingredients: Dictionary where keys are ingredient names and values are the available quantities. :return: True if the potion can be brewed with the available ingredients, False otherwise. for ingredient, required_quantity in recipe.items(): if ingredient not in ingredients or ingredients[ingredient] < required_quantity: return False return True"},{"question":"def find_missing_items(inventory_list: list[str], shipped_list: list[str]) -> list[str]: Returns the items in the inventory list that are not present in the shipped list. >>> find_missing_items([\\"item1\\", \\"item2\\", \\"item3\\"], [\\"item2\\", \\"item3\\"]) [\\"item1\\"] >>> find_missing_items([\\"apple\\", \\"banana\\", \\"orange\\"], [\\"banana\\", \\"orange\\"]) [\\"apple\\"] >>> find_missing_items([\\"box\\", \\"bottle\\", \\"can\\", \\"tray\\"], [\\"box\\", \\"bottle\\", \\"tray\\"]) [\\"can\\"] >>> find_missing_items([\\"pen\\", \\"pencil\\", \\"eraser\\"], [\\"pen\\", \\"pencil\\", \\"eraser\\"]) [] >>> find_missing_items([\\"laptop\\", \\"mouse\\"], []) [\\"laptop\\", \\"mouse\\"]","solution":"def find_missing_items(inventory_list: list[str], shipped_list: list[str]) -> list[str]: Returns the items in the inventory_list that are not present in the shipped_list. Parameters: inventory_list (list[str]): The list of items intended to be shipped. shipped_list (list[str]): The list of items that were actually shipped. Returns: list[str]: The list of items that are in the inventory_list but not in the shipped_list. inventory_set = set(inventory_list) shipped_set = set(shipped_list) missing_items = list(inventory_set - shipped_set) return missing_items"},{"question":"class KeyValueStore: A simplified version of an in-memory key-value store that supports basic operations and a transaction feature allowing a set of operations to be committed atomically. Example Usage: >>> kv_store = KeyValueStore() >>> kv_store.set_key(\\"name\\", \\"Alice\\") >>> print(kv_store.get_value(\\"name\\")) # Output: \\"Alice\\" >>> kv_store.begin_transaction() >>> kv_store.set_key(\\"name\\", \\"Bob\\") >>> print(kv_store.get_value(\\"name\\")) # Output: \\"Bob\\" >>> kv_store.rollback_transaction() >>> print(kv_store.get_value(\\"name\\")) # Output: \\"Alice\\" >>> kv_store.begin_transaction() >>> kv_store.delete_key(\\"name\\") >>> print(kv_store.get_value(\\"name\\")) # Output: None >>> kv_store.commit_transaction() >>> print(kv_store.get_value(\\"name\\")) # Output: None def __init__(self): pass def set_key(self, key, value): pass def get_value(self, key): pass def delete_key(self, key): pass def begin_transaction(self): pass def commit_transaction(self): pass def rollback_transaction(self): pass","solution":"class KeyValueStore: def __init__(self): self.store = {} self.transactions = [] def set_key(self, key, value): if self.transactions: self.transactions[-1][key] = value else: self.store[key] = value def get_value(self, key): if self.transactions: for transaction in reversed(self.transactions): if key in transaction: return transaction[key] return self.store.get(key) def delete_key(self, key): if self.transactions: self.transactions[-1][key] = None elif key in self.store: del self.store[key] def begin_transaction(self): self.transactions.append({}) def commit_transaction(self): if self.transactions: transaction = self.transactions.pop() for key, value in transaction.items(): if value is None: if key in self.store: del self.store[key] else: self.store[key] = value def rollback_transaction(self): if self.transactions: self.transactions.pop()"},{"question":"def diagonal_sums(matrix: list[list[int]]) -> dict: Calculate the sum of both the primary and secondary diagonals of a square matrix. >>> diagonal_sums([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) {'primary_diagonal': 15, 'secondary_diagonal': 15} >>> diagonal_sums([[2]]) {'primary_diagonal': 2, 'secondary_diagonal': 2} >>> diagonal_sums([[7, 8, 9], [6, 5, 4], [3, 2, 1]]) {'primary_diagonal': 13, 'secondary_diagonal': 17}","solution":"def diagonal_sums(matrix: list[list[int]]) -> dict: primary_sum = 0 secondary_sum = 0 n = len(matrix) for i in range(n): primary_sum += matrix[i][i] secondary_sum += matrix[i][n - 1 - i] return { 'primary_diagonal': primary_sum, 'secondary_diagonal': secondary_sum }"},{"question":"def is_trending(prices: list[int], trend: str) -> bool: Checks if the list of prices has the specified trend - either increasing or decreasing. Args: prices (list of int): A list of stock prices. trend (str): A string specifying the trend, either \\"increasing\\" or \\"decreasing\\". Returns: bool: True if the prices exhibit the specified trend, otherwise False. Examples: >>> is_trending([1, 2, 3, 4, 5], \\"increasing\\") True >>> is_trending([5, 4, 3, 2, 1], \\"decreasing\\") True >>> is_trending([1, 3, 2, 4, 5], \\"increasing\\") False >>> is_trending([5, 5, 4, 3, 2], \\"decreasing\\") True >>> is_trending([2, 2, 2, 2], \\"increasing\\") False >>> is_trending([10, 9, 8, 7], \\"increasing\\") False # Test cases def test_is_trending_increasing(): assert is_trending([1, 2, 3, 4, 5], \\"increasing\\") == True assert is_trending([10, 20, 30, 40], \\"increasing\\") == True assert is_trending([1, 3, 2, 4, 5], \\"increasing\\") == False assert is_trending([5, 6, 7, 8, 7], \\"increasing\\") == False def test_is_trending_decreasing(): assert is_trending([5, 4, 3, 2, 1], \\"decreasing\\") == True assert is_trending([40, 30, 20, 10], \\"decreasing\\") == True assert is_trending([5, 4, 5, 3, 2], \\"decreasing\\") == False assert is_trending([10, 9, 8, 7, 8], \\"decreasing\\") == False def test_is_trending_edge_cases(): assert is_trending([10], \\"increasing\\") == True assert is_trending([10], \\"decreasing\\") == True assert is_trending([10, 10], \\"increasing\\") == True assert is_trending([10, 10], \\"decreasing\\") == True assert is_trending([10, 10, 10, 10], \\"increasing\\") == True assert is_trending([10, 10, 10, 10], \\"decreasing\\") == True","solution":"def is_trending(prices: list[int], trend: str) -> bool: Checks if the list of prices has the specified trend - either increasing or decreasing. Args: prices (list of int): A list of stock prices. trend (str): A string specifying the trend, either \\"increasing\\" or \\"decreasing\\". Returns: bool: True if the prices exhibit the specified trend, otherwise False. if trend == \\"increasing\\": for i in range(1, len(prices)): if prices[i] < prices[i-1]: return False return True elif trend == \\"decreasing\\": for i in range(1, len(prices)): if prices[i] > prices[i-1]: return False return True else: # This case is technically unnecessary due to the problem constraints return False"},{"question":"class BinarySearchTreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self, values: list): self.root = None for value in values: self.insert(value) def insert(self, value: int) -> None: if not self.root: self.root = BinarySearchTreeNode(value) else: self._insert(self.root, value) def _insert(self, node: BinarySearchTreeNode, value: int) -> None: if value < node.value: if node.left: self._insert(node.left, value) else: node.left = BinarySearchTreeNode(value) else: if node.right: self._insert(node.right, value) else: node.right = BinarySearchTreeNode(value) def closest_value(self, target: float) -> int: Find the value in BST that is closest to the target value. Parameters: target (float): The target value to find the closest node to. Returns: int: The value of the node that is closest to the target value. Examples: >>> bst = BinarySearchTree([10, 5, 3, 7, 15, 13, 18]) >>> bst.closest_value(8.4) 7 >>> bst = BinarySearchTree([4, 2, 5, 1, 3]) >>> bst.closest_value(3.714286) 4","solution":"class BinarySearchTreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self, values: list): self.root = None for value in values: self.insert(value) def insert(self, value: int) -> None: if not self.root: self.root = BinarySearchTreeNode(value) else: self._insert(self.root, value) def _insert(self, node: BinarySearchTreeNode, value: int) -> None: if value < node.value: if node.left: self._insert(node.left, value) else: node.left = BinarySearchTreeNode(value) else: if node.right: self._insert(node.right, value) else: node.right = BinarySearchTreeNode(value) def closest_value(self, target: float) -> int: return self._closest_value(self.root, target, float('inf')) def _closest_value(self, node: BinarySearchTreeNode, target: float, closest: int) -> int: if not node: return closest if abs(target - node.value) < abs(target - closest): closest = node.value if target < node.value and node.left: return self._closest_value(node.left, target, closest) elif target > node.value and node.right: return self._closest_value(node.right, target, closest) else: return closest"},{"question":"from typing import Dict def analyze_log_file(file_path: str) -> Dict[str, int]: Reads a log file and returns a dictionary with the frequencies of each log level. Args: file_path (str): The path to the log file. Returns: Dict[str, int]: A dictionary with log levels as keys and their frequencies as values. >>> analyze_log_file(\\"test_log_basic.txt\\") {'INFO': 2, 'ERROR': 1, 'WARNING': 1} >>> analyze_log_file(\\"test_log_all_infos.txt\\") {'INFO': 3, 'ERROR': 0, 'WARNING': 0} def test_analyze_log_file_basic(): file_path = \\"test_log_basic.txt\\" with open(file_path, 'w') as f: f.write(\\"2023-10-01T12:34:56Z INFO User login successfuln\\") f.write(\\"2023-10-01T12:35:01Z ERROR File not foundn\\") f.write(\\"2023-10-01T12:36:22Z WARNING Disk space lown\\") f.write(\\"2023-10-01T12:37:10Z INFO Page accessedn\\") result = analyze_log_file(file_path) assert result == {\\"INFO\\": 2, \\"ERROR\\": 1, \\"WARNING\\": 1} def test_analyze_log_file_all_infos(): file_path = \\"test_log_all_infos.txt\\" with open(file_path, 'w') as f: f.write(\\"2023-10-01T12:34:56Z INFO User login successfuln\\") f.write(\\"2023-10-01T12:35:01Z INFO User logoutn\\") f.write(\\"2023-10-01T12:36:22Z INFO Page accessedn\\") result = analyze_log_file(file_path) assert result == {\\"INFO\\": 3, \\"ERROR\\": 0, \\"WARNING\\": 0} def test_analyze_log_file_no_logs(): file_path = \\"test_log_no_logs.txt\\" with open(file_path, 'w') as f: f.write(\\"\\") result = analyze_log_file(file_path) assert result == {\\"INFO\\": 0, \\"ERROR\\": 0, \\"WARNING\\": 0} def test_analyze_log_file_mixed_logs(): file_path = \\"test_log_mixed_logs.txt\\" with open(file_path, 'w') as f: f.write(\\"2023-10-01T12:34:56Z INFO User login successfuln\\") f.write(\\"2023-10-01T12:35:01Z INFO Page accessedn\\") f.write(\\"2023-10-01T12:36:22Z WARNING Disk space lown\\") f.write(\\"2023-10-01T12:37:10Z ERROR File not foundn\\") f.write(\\"2023-10-01T12:38:35Z WARNING Performance issue detectedn\\") result = analyze_log_file(file_path) assert result == {\\"INFO\\": 2, \\"ERROR\\": 1, \\"WARNING\\": 2}","solution":"from typing import Dict def analyze_log_file(file_path: str) -> Dict[str, int]: Reads a log file and returns a dictionary with the frequencies of each log level. Args: file_path (str): The path to the log file. Returns: Dict[str, int]: A dictionary with log levels as keys and their frequencies as values. log_levels = {\\"INFO\\": 0, \\"ERROR\\": 0, \\"WARNING\\": 0} with open(file_path, 'r') as file: for line in file: parts = line.split(' ') if len(parts) > 1: log_level = parts[1] if log_level in log_levels: log_levels[log_level] += 1 return log_levels"},{"question":"def can_construct(words: list[str], target: list[str]) -> bool: Check whether a given list of strings (target) can be constructed by concatenating elements of another list of strings (words), where each string can be used any number of times. >>> can_construct(['a', 'b', 'ab'], ['ab', 'ab']) True >>> can_construct(['a', 'b', 'c'], ['abc', 'a']) True >>> can_construct(['a', 'b'], ['ab', 'c']) False >>> can_construct(['abc'], ['ab', 'c']) False","solution":"def can_construct(words, target): def can_form(word, memo): if word in memo: return memo[word] if word == \\"\\": return True for prefix in words: if word.startswith(prefix): if can_form(word[len(prefix):], memo): memo[word] = True return True memo[word] = False return False memo = {} for t in target: if not can_form(t, memo): return False return True"},{"question":"import hashlib def verify_checksum(data: bytes, provided_checksum: str) -> bool: Compute the checksum using SHA-256 and compare it with the provided checksum. Params: data (bytes): The input data for checksum computation. provided_checksum (str): The checksum to compare against. Returns: bool: True if the computed checksum matches the provided checksum, False otherwise. pass import unittest class TestVerifyChecksum(unittest.TestCase): def test_empty_data(self): data = b'' provided_checksum = hashlib.sha256(data).hexdigest() self.assertTrue(verify_checksum(data, provided_checksum)) def test_small_data(self): data = b'hello' provided_checksum = hashlib.sha256(data).hexdigest() self.assertTrue(verify_checksum(data, provided_checksum)) def test_large_data(self): data = b'a' * 10**6 # 1MB of data provided_checksum = hashlib.sha256(data).hexdigest() self.assertTrue(verify_checksum(data, provided_checksum)) def test_incorrect_checksum(self): data = b'test' provided_checksum = hashlib.sha256(b'wrong').hexdigest() self.assertFalse(verify_checksum(data, provided_checksum)) def test_non_matching_checksums(self): data = b'checksum test' provided_checksum = hashlib.sha256(data).hexdigest() self.assertFalse(verify_checksum(data, hashlib.sha256(b'wrong data').hexdigest())) if __name__ == '__main__': unittest.main()","solution":"import hashlib def verify_checksum(data: bytes, provided_checksum: str) -> bool: Compute the checksum using SHA-256 and compare it with the provided checksum. Params: data (bytes): The input data for checksum computation. provided_checksum (str): The checksum to compare against. Returns: bool: True if the computed checksum matches the provided checksum, False otherwise. # Compute the checksum using SHA-256 computed_checksum = hashlib.sha256(data).hexdigest() # Verify if the computed checksum matches the provided checksum return computed_checksum == provided_checksum"},{"question":"import heapq class PriorityQueue: A priority queue implemented using a binary heap. Supports both min-heap and max-heap configurations. def __init__(self, heap_type='min'): Initialize a priority queue. :param heap_type: 'min' for a min-heap, 'max' for a max-heap def insert(self, value, priority): Insert an element into the priority queue with the associated priority. :param value: The value to insert :param priority: The priority of the value def extract(self): Remove and return the element with the highest priority. :return: The element with the highest priority def peek(self): Return the element with the highest priority without removing it from the queue. :return: The element with the highest priority @property def size(self): Return the number of elements currently in the queue. :return: Number of elements in the queue return # Example unit tests def test_min_heap_insert_and_extract(): pq = PriorityQueue('min') pq.insert('apple', 5) pq.insert('banana', 2) pq.insert('cherry', 8) assert pq.extract() == 'banana' assert pq.extract() == 'apple' assert pq.extract() == 'cherry' assert pq.extract() is None def test_max_heap_insert_and_extract(): pq = PriorityQueue('max') pq.insert('apple', 5) pq.insert('banana', 2) pq.insert('cherry', 8) assert pq.extract() == 'cherry' assert pq.extract() == 'apple' assert pq.extract() == 'banana' assert pq.extract() is None def test_peek(): pq = PriorityQueue('min') pq.insert('apple', 5) pq.insert('banana', 2) pq.insert('cherry', 8) assert pq.peek() == 'banana' pq.extract() assert pq.peek() == 'apple' pq.extract() assert pq.peek() == 'cherry' pq.extract() assert pq.peek() is None def test_size_property(): pq = PriorityQueue('min') assert pq.size == 0 pq.insert('apple', 5) assert pq.size == 1 pq.insert('banana', 2) assert pq.size == 2 pq.extract() assert pq.size == 1 pq.extract() assert pq.size == 0 pq.extract() assert pq.size == 0","solution":"import heapq class PriorityQueue: def __init__(self, heap_type='min'): Initialize a priority queue. :param heap_type: 'min' for a min-heap, 'max' for a max-heap self.heap = [] self.heap_type = heap_type self.size = 0 def insert(self, value, priority): Insert an element into the priority queue with the associated priority. :param value: The value to insert :param priority: The priority of the value if self.heap_type == 'max': priority = -priority # Inverting the priority for max-heap heapq.heappush(self.heap, (priority, value)) self.size += 1 def extract(self): Remove and return the element with the highest priority. :return: The element with the highest priority if self.size == 0: return None self.size -= 1 return heapq.heappop(self.heap)[1] def peek(self): Return the element with the highest priority without removing it from the queue. :return: The element with the highest priority if self.size == 0: return None return self.heap[0][1] @property def size(self): Return the number of elements currently in the queue. :return: Number of elements in the queue return self._size @size.setter def size(self, value): self._size = value"},{"question":"import heapq class MedianFinder: Your MedianFinder object will be instantiated and called as such: obj = MedianFinder() obj.addNum(num) param_2 = obj.findMedian() def __init__(self): Initialize the MedianFinder with two heaps: - A max-heap to store the lower half of numbers - A min-heap to store the upper half of numbers pass def addNum(self, num: int): Add a number into the data structure. pass def findMedian(self) -> float: Retrieve the median of all numbers. pass # Example Usage mf = MedianFinder() mf.addNum(1) mf.addNum(2) assert mf.findMedian() == 1.5 mf.addNum(3) assert mf.findMedian() == 2 mf_2 = MedianFinder() mf_2.addNum(-1) mf_2.addNum(-2) mf_2.addNum(-3) assert mf_2.findMedian() == -2 mf_2.addNum(-4) mf_2.addNum(1) assert mf_2.findMedian() == -2","solution":"import heapq class MedianFinder: def __init__(self): Initialize the MedianFinder with two heaps: - A max-heap to store the lower half of numbers - A min-heap to store the upper half of numbers self.lower_half = [] # Max heap self.upper_half = [] # Min heap def addNum(self, num: int): Add a number into the data structure. if not self.lower_half or num <= -self.lower_half[0]: heapq.heappush(self.lower_half, -num) else: heapq.heappush(self.upper_half, num) # Balance the heaps if len(self.lower_half) > len(self.upper_half) + 1: heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) elif len(self.upper_half) > len(self.lower_half): heapq.heappush(self.lower_half, -heapq.heappop(self.upper_half)) def findMedian(self) -> float: Retrieve the median of all numbers. if len(self.lower_half) == len(self.upper_half): return (-self.lower_half[0] + self.upper_half[0]) / 2.0 else: return float(-self.lower_half[0])"},{"question":"from typing import List, Dict, Union def analyze_sequence(sequence: List[int]) -> Dict[str, Union[int, bool]]: Analyze a sequence of integers and determine various properties. Args: sequence (List[int]): A list of integers. Returns: Dict[str, Union[int, bool]]: A dictionary with the following keys: - 'length': The length of the sequence. - 'max_value': The maximum value in the sequence. - 'min_value': The minimum value in the sequence. - 'is_increasing': A boolean indicating if the sequence is strictly increasing. - 'is_decreasing': A boolean indicating if the sequence is strictly decreasing. Example: >>> analyze_sequence([1, 2, 3, 4, 5]) {'length': 5, 'max_value': 5, 'min_value': 1, 'is_increasing': True, 'is_decreasing': False} >>> analyze_sequence([5, 5, 5, 5, 5]) {'length': 5, 'max_value': 5, 'min_value': 5, 'is_increasing': False, 'is_decreasing': False} >>> analyze_sequence([5, 4, 3, 2, 1]) {'length': 5, 'max_value': 5, 'min_value': 1, 'is_increasing': False, 'is_decreasing': True} >>> analyze_sequence([3, 1, 4, 1, 5, 9, 2, 6, 5]) {'length': 9, 'max_value': 9, 'min_value': 1, 'is_increasing': False, 'is_decreasing': False} >>> analyze_sequence([42]) {'length': 1, 'max_value': 42, 'min_value': 42, 'is_increasing': True, 'is_decreasing': True}","solution":"from typing import List, Dict, Union def analyze_sequence(sequence: List[int]) -> Dict[str, Union[int, bool]]: length = len(sequence) max_value = max(sequence) min_value = min(sequence) is_increasing = all(x < y for x, y in zip(sequence, sequence[1:])) is_decreasing = all(x > y for x, y in zip(sequence, sequence[1:])) return { 'length': length, 'max_value': max_value, 'min_value': min_value, 'is_increasing': is_increasing, 'is_decreasing': is_decreasing }"},{"question":"from typing import List def build_segment_tree(arr: List[int]) -> List[int]: Build a Segment Tree from the given array and return the tree. The segment tree is used to perform efficient range minimum queries. >>> build_segment_tree([4, 2, 5, 1, 6, 3, 2]) [0, 1, 1, 1, 2, 3, 2, 4, 2, 5, 1, 6, 3, 2] >>> build_segment_tree([7, 3, 8, 6]) [0, 3, 3, 6, 7, 3, 8, 6] pass def range_min_query(segment_tree: List[int], start: int, end: int, n: int) -> int: Perform a range minimum query on the Segment Tree. >>> segment_tree = build_segment_tree([4, 2, 5, 1, 6, 3, 2]) >>> range_min_query(segment_tree, 1, 4, 7) 1 >>> segment_tree = build_segment_tree([7, 3, 8, 6]) >>> range_min_query(segment_tree, 0, 2, 4) 3 pass","solution":"def build_segment_tree(arr): Build a Segment Tree from the given array and return the tree if not arr: return [] n = len(arr) segment_tree = [0] * (2 * n) # Initialize leaves of segment tree for i in range(n): segment_tree[n + i] = arr[i] # Build the segment tree by calculating parents for i in range(n - 1, 0, -1): segment_tree[i] = min(segment_tree[2 * i], segment_tree[2 * i + 1]) return segment_tree def range_min_query(segment_tree, start, end, n): Perform a range minimum query on the Segment Tree if not segment_tree or start < 0 or end >= n or start > end: return float('inf') # Translate range to leaf indices start += n end += n min_val = float('inf') while start <= end: if start % 2 == 1: min_val = min(min_val, segment_tree[start]) start += 1 if end % 2 == 0: min_val = min(min_val, segment_tree[end]) end -= 1 start //= 2 end //= 2 return min_val"},{"question":"def max_package_value(grid: list[list[int]]) -> int: Returns the maximum package value a delivery driver can collect on their route from the top-left to the bottom-right corner of the grid by only moving right or down. >>> max_package_value([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_package_value([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 pass # Test cases def test_max_package_value_simple_case(): assert max_package_value([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 12 def test_max_package_value_all_ones(): assert max_package_value([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 5 def test_max_package_value_larger_case(): assert max_package_value([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 29 def test_max_package_value_single_cell(): assert max_package_value([[7]]) == 7 def test_max_package_value_single_row(): assert max_package_value([[1, 2, 3, 4, 5]]) == 15 def test_max_package_value_single_column(): assert max_package_value([[1], [2], [3], [4], [5]]) == 15 def test_max_package_value_zeros(): assert max_package_value([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 def test_max_package_value_mixed_values(): assert max_package_value([[1, -2, 3], [4, 5, -6], [7, 8, 9]]) == 29 def test_max_package_value_no_path(): assert max_package_value([]) == 0 assert max_package_value([[]]) == 0","solution":"def max_package_value(grid): Returns the maximum package value a delivery driver can collect on their route from the top-left to the bottom-right corner of the grid by only moving right or down. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a DP table with the same dimensions as the grid dp = [[0] * n for _ in range(m)] # Initialize the first cell with the grid's first cell value dp[0][0] = grid[0][0] # Fill in the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill in the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"import time import logging from functools import wraps logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s') def performance_logger(context: str = \\"\\"): Decorator for logging performance metrics of function calls. Parameters: context (str): Optional message to be added to logs for context. Decorates: A function whose performance metrics need to be logged. def decorator(func): pass return decorator # Example function that simulates some processing @performance_logger(\\"Processing Task\\") def some_function(x): if x == 0: raise ValueError(\\"Invalid value for x\\") time.sleep(x) return x * 2 # Call the example function with valid and invalid inputs try: print(some_function(2)) except Exception as e: print(f\\"Error occurred: {e}\\") try: print(some_function(0)) except Exception as e: print(f\\"Error occurred: {e}\\") # Tests import pytest @pytest.fixture def log_cap(caplog): caplog.set_level(logging.INFO) return caplog def test_performance_logger_basic(log_cap): @performance_logger(\\"Test Function\\") def add(a, b): time.sleep(0.1) return a + b result = add(2, 3) assert result == 5 assert \\"Test Function - Function 'add' executed in\\" in log_cap.text assert \\"Test Function - Function 'add' called 1 times.\\" in log_cap.text def test_performance_logger_exception_handling(log_cap): @performance_logger(\\"Test Exception\\") def raise_error(): time.sleep(0.1) raise ValueError(\\"Test error\\") with pytest.raises(ValueError): raise_error() assert \\"Test Exception - An error occurred in function 'raise_error': Test error\\" in log_cap.text assert \\"Test Exception - Function 'raise_error' called 1 times.\\" in log_cap.text def test_performance_logger_multiple_calls(log_cap): @performance_logger(\\"Test Multiple Calls\\") def add(a, b): time.sleep(0.1) return a + b add(1, 1) add(2, 2) assert \\"Test Multiple Calls - Function 'add' called 2 times.\\" in log_cap.text","solution":"import time import logging from functools import wraps # Configure logging logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s') def performance_logger(context: str = \\"\\"): Decorator for logging performance metrics of function calls. Parameters: context (str): Optional message to be added to logs for context. Decorates: A function whose performance metrics need to be logged. def decorator(func): call_count = 0 @wraps(func) def wrapper(*args, **kwargs): nonlocal call_count call_count += 1 start_time = time.time() try: result = func(*args, **kwargs) execution_time = time.time() - start_time logging.info(f\\"{context} - Function '{func.__name__}' executed in {execution_time:.4f} seconds.\\") logging.info(f\\"{context} - Function '{func.__name__}' called {call_count} times.\\") return result except Exception as e: logging.error(f\\"{context} - An error occurred in function '{func.__name__}': {e}\\") logging.info(f\\"{context} - Function '{func.__name__}' called {call_count} times.\\") # Propagate the exception raise return wrapper return decorator"},{"question":"from collections import deque class DataStreamProcessor: A class to process a stream of numbers and maintain a running average of the most recent 'n' elements and the maximum value encountered in the stream. >>> dsp = DataStreamProcessor(3) >>> dsp.get_running_average() == 0.0 True >>> dsp.process(10) >>> dsp.process(20) >>> dsp.process(30) >>> dsp.get_running_average() == 20.0 True >>> dsp.process(40) >>> dsp.get_running_average() == 30.0 True >>> dsp.get_maximum() == 40 True >>> dsp.update_window_size(2) >>> dsp.process(50) >>> dsp.get_running_average() == 45.0 True >>> dsp.get_maximum() == 50 True def __init__(self, window_size: int): Initialize the DataStreamProcessor with a designated window size. Args: - window_size (int): The number of elements to use for the running average calculation. pass def process(self, value: float) -> None: Process the incoming value and update the stream with it. Args: - value (float): The new data value to process. pass def get_running_average(self) -> float: Return the current running average of the most recent \`window_size\` elements. Returns: - float: The running average of the current data window. pass def get_maximum(self) -> float: Return the maximum value encountered so far in the data stream. Returns: - float: The maximum value seen in the stream. pass def update_window_size(self, new_size: int) -> None: Update the window size for running average calculations. Args: - new_size (int): The new window size. pass","solution":"from collections import deque class DataStreamProcessor: def __init__(self, window_size: int): Initialize the DataStreamProcessor with a designated window size. Args: - window_size (int): The number of elements to use for the running average calculation. self.window_size = window_size self.data_window = deque(maxlen=window_size) self.current_sum = 0 self.current_max = float('-inf') def process(self, value: float) -> None: Process the incoming value and update the stream with it. Args: - value (float): The new data value to process. if len(self.data_window) == self.data_window.maxlen: # Subtract the value that is going to be removed from the window self.current_sum -= self.data_window[0] self.data_window.append(value) self.current_sum += value if value > self.current_max: self.current_max = value def get_running_average(self) -> float: Return the current running average of the most recent \`window_size\` elements. Returns: - float: The running average of the current data window. if len(self.data_window) == 0: return 0.0 return self.current_sum / len(self.data_window) def get_maximum(self) -> float: Return the maximum value encountered so far in the data stream. Returns: - float: The maximum value seen in the stream. return self.current_max def update_window_size(self, new_size: int) -> None: Update the window size for running average calculations. Args: - new_size (int): The new window size. self.window_size = new_size # Create a new deque with the new size new_data_window = deque(self.data_window, maxlen=new_size) self.current_sum = sum(new_data_window) self.data_window = new_data_window"},{"question":"from typing import List def generate_primes_basic(n: int) -> List[int]: Generates the first n prime numbers using basic iteration. >>> generate_primes_basic(1) [2] >>> generate_primes_basic(5) [2, 3, 5, 7, 11] >>> generate_primes_basic(0) Traceback (most recent call last): ... ValueError: The input must be a positive integer. >>> generate_primes_basic(-5) Traceback (most recent call last): ... ValueError: The input must be a positive integer. def generate_primes_sieve(n: int) -> List[int]: Generates the first n prime numbers using the Sieve of Eratosthenes method. >>> generate_primes_sieve(1) [2] >>> generate_primes_sieve(5) [2, 3, 5, 7, 11] >>> generate_primes_sieve(0) Traceback (most recent call last): ... ValueError: The input must be a positive integer. >>> generate_primes_sieve(-5) Traceback (most recent call last): ... ValueError: The input must be a positive integer.","solution":"def generate_primes_basic(n: int) -> list: Generates the first n prime numbers using basic iteration. if n <= 0: raise ValueError(\\"The input must be a positive integer.\\") primes = [] candidate = 2 while len(primes) < n: is_prime = True for divisor in range(2, int(candidate ** 0.5) + 1): if candidate % divisor == 0: is_prime = False break if is_prime: primes.append(candidate) candidate += 1 return primes def generate_primes_sieve(n: int) -> list: Generates the first n prime numbers using the Sieve of Eratosthenes method. if n <= 0: raise ValueError(\\"The input must be a positive integer.\\") limit = n * (n + 10) # Rough estimate to find at least n primes, increase if necessary sieve = [True] * limit sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(limit ** 0.5) + 1): if sieve[start]: for i in range(start * start, limit, start): sieve[i] = False primes = [num for num, is_prime in enumerate(sieve) if is_prime] return primes[:n]"},{"question":"def int_to_binary(n: int) -> str: Converts a non-negative integer to its binary representation. >>> int_to_binary(0) == '0' >>> int_to_binary(1) == '1' >>> int_to_binary(2) == '10' >>> int_to_binary(9) == '1001' >>> int_to_binary(14) == '1110' >>> int_to_binary(255) == '11111111' def hamming_weight(binary_str: str) -> int: Determines the Hamming weight (number of 1s) in a binary string representation of an integer. >>> hamming_weight('0') == 0 >>> hamming_weight('1') == 1 >>> hamming_weight('10') == 1 >>> hamming_weight('1001') == 2 >>> hamming_weight('1110') == 3 >>> hamming_weight('11111111') == 8","solution":"def int_to_binary(n: int) -> str: Converts a non-negative integer to its binary representation. Parameters: n (int): A non-negative integer. Returns: str: The binary representation of the integer. return bin(n)[2:] def hamming_weight(binary_str: str) -> int: Determines the Hamming weight (number of 1s) in a binary string representation of an integer. Parameters: binary_str (str): A binary string representation of an integer. Returns: int: The Hamming weight of the binary string. return binary_str.count('1')"},{"question":"from typing import Optional, List class TreeNode: def __init__(self, val: int = 0, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None): self.val = val self.left = left self.right = right def inorder_traversal(root: Optional[TreeNode]) -> List[int]: Perform in-order traversal of a binary tree and return the values in a list. >>> tree1 = TreeNode(1, None, TreeNode(2, TreeNode(3))) >>> inorder_traversal(tree1) [1, 3, 2] >>> tree2 = None >>> inorder_traversal(tree2) [] >>> tree3 = TreeNode(1) >>> inorder_traversal(tree3) [1]","solution":"from typing import Optional, List class TreeNode: def __init__(self, val: int = 0, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None): self.val = val self.left = left self.right = right def inorder_traversal(root: Optional[TreeNode]) -> List[int]: Perform in-order traversal of a binary tree and return the values in a list. result = [] stack = [] current = root while current is not None or stack: # Reach the leftmost Node of the current Node while current is not None: stack.append(current) current = current.left # Current must be None at this point current = stack.pop() result.append(current.val) # We have visited the node and its left subtree. Now, it's right subtree's turn current = current.right return result"},{"question":"from typing import List, Tuple class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, data): new_node = Node(data) if not self.head: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def delete(self, data): temp = self.head if temp is not None: if temp.data == data: self.head = temp.next temp = None return while temp is not None: if temp.data == data: break prev = temp temp = temp.next if temp == None: return prev.next = temp.next temp = None def to_list(self): elements = [] current = self.head while current: elements.append(current.data) current = current.next return elements def process_linked_list_operations(operations: List[Tuple[str, int]]) -> List[int]: Manage a series of insert and delete operations on a linked list. >>> process_linked_list_operations([(\\"insert\\", 5), (\\"insert\\", 10), (\\"insert\\", 15)]) [5, 10, 15] >>> process_linked_list_operations([(\\"insert\\", 5), (\\"insert\\", 10), (\\"insert\\", 15), (\\"delete\\", 10)]) [5, 15] >>> process_linked_list_operations([(\\"insert\\", 5), (\\"insert\\", 10), (\\"delete\\", 5), (\\"insert\\", 15), (\\"delete\\", 10)]) [15] >>> process_linked_list_operations([(\\"insert\\", 5), (\\"insert\\", 10), (\\"delete\\", 20)]) [5, 10] >>> process_linked_list_operations([(\\"insert\\", 5), (\\"insert\\", 10), (\\"insert\\", 15), (\\"delete\\", 5)]) [10, 15] >>> process_linked_list_operations([(\\"insert\\", 5), (\\"insert\\", 10), (\\"insert\\", 15), (\\"delete\\", 15)]) [5, 10]","solution":"from typing import List, Tuple class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, data): new_node = Node(data) if not self.head: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def delete(self, data): temp = self.head if temp is not None: if temp.data == data: self.head = temp.next temp = None return while temp is not None: if temp.data == data: break prev = temp temp = temp.next if temp == None: return prev.next = temp.next temp = None def to_list(self): elements = [] current = self.head while current: elements.append(current.data) current = current.next return elements def process_linked_list_operations(operations: List[Tuple[str, int]]) -> List[int]: linked_list = LinkedList() for operation, value in operations: if operation == \\"insert\\": linked_list.insert(value) elif operation == \\"delete\\": linked_list.delete(value) return linked_list.to_list()"},{"question":"from typing import Dict, List def bfs(graph: Dict[int, List[int]], start_node: int) -> List[int]: Perform BFS on the given directed graph starting from the specified node. :param graph: A dictionary representing the adjacency list of the directed graph. :param start_node: An integer representing the starting node for the BFS traversal. :return: A list of integers representing the nodes visited in BFS order. Example Usage: >>> graph = {0: [1, 2], 1: [2], 2: [0, 3], 3: [3]} >>> start_node = 2 >>> bfs(graph, start_node) [2, 0, 3, 1] >>> graph = {0: [1, 2], 1: [3], 2: [3], 3: []} >>> start_node = 0 >>> bfs(graph, start_node) [0, 1, 2, 3] pass # Implement the BFS algorithm here def test_bfs_with_cycles(): graph = { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3] } assert bfs(graph, 2) == [2, 0, 3, 1] def test_bfs_without_cycles(): graph = { 0: [1, 2], 1: [3], 2: [3], 3: [] } assert bfs(graph, 0) == [0, 1, 2, 3] def test_bfs_start_node_no_edges(): graph = { 0: [1], 1: [2], 2: [] } assert bfs(graph, 2) == [2] def test_bfs_all_nodes_isolated(): graph = { 0: [], 1: [], 2: [] } assert bfs(graph, 1) == [1] def test_bfs_with_empty_graph(): graph = {} assert bfs(graph, 0) == [0]","solution":"from collections import deque from typing import Dict, List def bfs(graph: Dict[int, List[int]], start_node: int) -> List[int]: Perform BFS on the given directed graph starting from the specified node. :param graph: A dictionary representing the adjacency list of the directed graph. :param start_node: An integer representing the starting node for the BFS traversal. :return: A list of integers representing the nodes visited in BFS order. visited = set() queue = deque([start_node]) result = [] while queue: current_node = queue.popleft() if current_node not in visited: result.append(current_node) visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor not in visited: queue.append(neighbor) return result"},{"question":"class MemoryAllocator: A custom memory allocator that manages a fixed-size memory pool. Args: size (int): Initializes the memory pool with the given size. Methods: allocate(block_size: int, block_id: str) -> int: Allocates a memory block of the given size and returns its starting address. deallocate(block_id: str) -> bool: Deallocates the memory block identified by the given block_id. Example: >>> allocator = MemoryAllocator(1000) >>> allocator.allocate(100, 'block1') 0 >>> allocator.allocate(200, 'block2') 100 >>> allocator.deallocate('block1') True >>> allocator.allocate(50, 'block3') 0 def __init__(self, size: int): pass def allocate(self, block_size: int, block_id: str) -> int: pass def deallocate(self, block_id: str) -> bool: pass from solution import MemoryAllocator def test_memory_allocator_initial_allocation(): allocator = MemoryAllocator(1000) assert allocator.allocate(100, 'block1') == 0 assert allocator.allocate(200, 'block2') == 100 def test_memory_allocator_deallocation(): allocator = MemoryAllocator(1000) allocator.allocate(100, 'block1') assert allocator.deallocate('block1') == True assert allocator.deallocate('block1') == False # Trying to deallocate already deallocated block def test_memory_allocator_reallocation(): allocator = MemoryAllocator(1000) allocator.allocate(100, 'block1') allocator.deallocate('block1') assert allocator.allocate(50, 'block3') == 0 def test_memory_allocator_insufficient_space(): allocator = MemoryAllocator(100) assert allocator.allocate(150, 'block1') == None def test_memory_allocator_allocate_after_fragmentation(): allocator = MemoryAllocator(1000) allocator.allocate(100, 'block1') allocator.allocate(200, 'block2') allocator.deallocate('block1') assert allocator.allocate(50, 'block3') == 0 assert allocator.allocate(50, 'block4') == 50 assert allocator.allocate(300, 'block5') == 300 def test_memory_allocator_invalid_deallocation(): allocator = MemoryAllocator(1000) assert allocator.deallocate('non_existent_block') == False","solution":"class MemoryAllocator: def __init__(self, size): self.size = size self.memory_pool = [None] * size self.allocations = {} # Dictionary to keep track of allocations def allocate(self, block_size, block_id): free_start = None free_length = 0 for i in range(self.size): if self.memory_pool[i] is None: if free_start is None: free_start = i free_length += 1 if free_length == block_size: break else: free_start = None free_length = 0 if free_length >= block_size: for j in range(free_start, free_start + block_size): self.memory_pool[j] = block_id self.allocations[block_id] = (free_start, block_size) return free_start else: return None def deallocate(self, block_id): if block_id not in self.allocations: return False start, size = self.allocations[block_id] for i in range(start, start + size): self.memory_pool[i] = None del self.allocations[block_id] return True"},{"question":"from typing import List class RangeSumQuery: def __init__(self, nums: List[int]): Initialize your data structure here. :param nums: List of integers to initialize the data structure with. def update(self, index: int, val: int) -> None: Update the value of the element at index to val. :param index: The index of the element to update. :param val: The new value of the element. def sumRange(self, left: int, right: int) -> int: Return the sum of elements nums[left..right] inclusive. :param left: The left index of the range. :param right: The right index of the range. :return: The sum of elements in the specified range. # Example of usage nums = [1, 3, 5] obj = RangeSumQuery(nums) assert obj.sumRange(0, 2) == 9 # sum of [1, 3, 5] obj.update(1, 2) # nums becomes [1, 2, 5] assert obj.sumRange(0, 2) == 8 # sum of [1, 2, 5] import pytest def test_initial_sum_range(): nums = [1, 3, 5] obj = RangeSumQuery(nums) assert obj.sumRange(0, 2) == 9 # sum of [1, 3, 5] def test_update_and_sum_range(): nums = [1, 3, 5] obj = RangeSumQuery(nums) obj.update(1, 2) # nums becomes [1, 2, 5] assert obj.sumRange(0, 2) == 8 # sum of [1, 2, 5] def test_large_update(): nums = [1, 3, 5] obj = RangeSumQuery(nums) obj.update(1, 100) assert obj.sumRange(0, 2) == 106 # sum of [1, 100, 5] def test_prefix_sum(): nums = [1, 2, 3, 4, 5] obj = RangeSumQuery(nums) assert obj.sumRange(0, 1) == 3 # sum of [1, 2] assert obj.sumRange(0, 2) == 6 # sum of [1, 2, 3] assert obj.sumRange(0, 3) == 10 # sum of [1, 2, 3, 4] assert obj.sumRange(0, 4) == 15 # sum of [1, 2, 3, 4, 5] def test_edge_cases(): nums = [1] obj = RangeSumQuery(nums) assert obj.sumRange(0, 0) == 1 # sum of [1] obj.update(0, 2) assert obj.sumRange(0, 0) == 2 # sum of [2] nums = [1, 1, 1, 1] obj = RangeSumQuery(nums) assert obj.sumRange(0, 3) == 4 # sum of [1, 1, 1, 1] obj.update(3, 100) assert obj.sumRange(0, 3) == 103 # sum of [1, 1, 1, 100] if __name__ == \\"__main__\\": pytest.main()","solution":"class RangeSumQuery: def __init__(self, nums): Initialize your data structure here. :param nums: List of integers to initialize the data structure with. self.nums = nums self.size = len(nums) self.tree = [0] * (self.size + 1) for i in range(self.size): self._increment(i + 1, nums[i]) def _increment(self, index, delta): while index <= self.size: self.tree[index] += delta index += index & -index def update(self, index, val): Update the value of the element at index to val. :param index: The index of the element to update. :param val: The new value of the element. delta = val - self.nums[index] self.nums[index] = val self._increment(index + 1, delta) def _prefix_sum(self, index): sum = 0 while index > 0: sum += self.tree[index] index -= index & -index return sum def sumRange(self, left, right): Return the sum of elements nums[left..right] inclusive. :param left: The left index of the range. :param right: The right index of the range. :return: The sum of elements in the specified range. return self._prefix_sum(right + 1) - self._prefix_sum(left)"},{"question":"def extract_valid_ip_addresses(s: str) -> list: Extract and return all valid IP addresses found within a given string. >>> extract_valid_ip_addresses(\\"The IPs are 192.168.1.1 and 10.0.0.1.\\") ['192.168.1.1', '10.0.0.1'] >>> extract_valid_ip_addresses(\\"Invalid IPs: 256.100.50.25, 192.168.1.999\\") [] >>> extract_valid_ip_addresses(\\"Some IPs: 172.16.254.1, 123.456.78.90, 0.0.0.0\\") ['172.16.254.1', '0.0.0.0'] >>> extract_valid_ip_addresses(\\"IP: 1.2.3.4, more IPs: 12.34.56.78\\") ['1.2.3.4', '12.34.56.78']","solution":"import re def extract_valid_ip_addresses(s: str) -> list: Extracts and returns all valid IP addresses found in the input string. # Regular expression to match potential IP addresses (not yet validated) potential_ips = re.findall(r'b(?:d{1,3}.){3}d{1,3}b', s) valid_ips = [] for ip in potential_ips: octets = ip.split('.') # Validate each octet if all(is_valid_octet(octet) for octet in octets): valid_ips.append(ip) return valid_ips def is_valid_octet(octet): Helper function to check if an octet is valid: - Should be a number between 0 and 255 - Should not have leading zeros except for 0 itself if not octet.isdigit(): return False num = int(octet) # Check range and leading zero conditions if num > 255 or (octet[0] == '0' and octet != '0'): return False return True"},{"question":"def check_password_complexity(password: str) -> bool: Validate the complexity of the given password. It should satisfy the following rules: 1. The password must be at least 8 characters long. 2. It must contain at least one uppercase letter. 3. It must contain at least one lowercase letter. 4. It must contain at least one digit. 5. It must contain at least one special character from the set: !@#%^&*()-_=+[]{}|;:',<.>/?. Args: password (str): The password string to be validated. Returns: bool: True if the password meets the complexity requirements, otherwise False. >>> check_password_complexity(\\"Password123!\\") True >>> check_password_complexity(\\"pass\\") False >>> check_password_complexity(\\"Password!\\") False >>> check_password_complexity(\\"password123!\\") False >>> check_password_complexity(\\"PASSWORD123!\\") False pass","solution":"import re def check_password_complexity(password: str) -> bool: Validate the complexity of the given password. Args: password (str): The password string to be validated. Returns: bool: True if the password meets the complexity requirements, otherwise False. if len(password) < 8: return False if not re.search(r'[A-Z]', password): return False if not re.search(r'[a-z]', password): return False if not re.search(r'[0-9]', password): return False if not re.search(r'[!@#%^&*()-_=+[]{}|;:'\\",<.>/?]', password): return False return True"},{"question":"import heapq def dijkstra(graph: dict[str, list[tuple[str, int]]], start: str) -> dict[str, float]: Implement Dijkstra's algorithm to find the shortest path from the start node to all other nodes in a directed graph represented by an adjacency list. Example: >>> graph = {'A': [('B', 1), ('C', 4)], 'B': [('C', 2), ('D', 5)], 'C': [('D', 1)], 'D': []} >>> start = 'A' >>> dijkstra(graph, start) {'A': 0, 'B': 1, 'C': 3, 'D': 4} >>> graph = {'A': [('B', 1)], 'B': [('C', 2)], 'C': [], 'D': [('A', 10)]} >>> start = 'A' >>> dijkstra(graph, start) {'A': 0, 'B': 1, 'C': 3, 'D': float('inf')}","solution":"import heapq def dijkstra(graph, start): Implement Dijkstra's algorithm to find the shortest path from the start node to all other nodes in a directed graph represented by an adjacency list. # Initialize the minimum distances dictionary distances = {vertex: float('inf') for vertex in graph} distances[start] = 0 # Priority queue to manage the min heap for the current shortest paths priority_queue = [(0, start)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # If the distance is greater than the recorded distance, continue if current_distance > distances[current_vertex]: continue # Explore the neighbors of the current vertex for neighbor, weight in graph[current_vertex]: distance = current_distance + weight # If a shorter path is found if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"def is_power_of_two(n: int) -> bool: Check if an integer is a power of two using bit manipulation. Parameters: n (int): The integer to check Returns: bool: True if the integer is a power of two, False otherwise Examples: >>> is_power_of_two(1) True >>> is_power_of_two(2) True >>> is_power_of_two(3) False >>> is_power_of_two(4) True >>> is_power_of_two(16) True >>> is_power_of_two(18) False pass # Test cases assert is_power_of_two(1) == True, \\"Test case 1 failed\\" assert is_power_of_two(2) == True, \\"Test case 2 failed\\" assert is_power_of_two(3) == False, \\"Test case 3 failed\\" assert is_power_of_two(4) == True, \\"Test case 4 failed\\" assert is_power_of_two(16) == True, \\"Test case 5 failed\\" assert is_power_of_two(18) == False, \\"Test case 6 failed\\" assert is_power_of_two(0) == False, \\"Test case 7 failed\\" assert is_power_of_two(-2) == False, \\"Test case 8 failed\\" print(\\"All test cases pass\\")","solution":"def is_power_of_two(n: int) -> bool: Check if an integer is a power of two using bit manipulation. Parameters: n (int): The integer to check Returns: bool: True if the integer is a power of two, False otherwise Examples: >>> is_power_of_two(1) True >>> is_power_of_two(2) True >>> is_power_of_two(3) False >>> is_power_of_two(4) True >>> is_power_of_two(16) True >>> is_power_of_two(18) False return n > 0 and (n & (n - 1)) == 0"},{"question":"def is_point_inside_polygon(polygon: List[Tuple[int, int]], point: Tuple[int, int]) -> bool: Determine if a point is inside a given polygon. Args: polygon (List[Tuple[int, int]]): List of tuples representing the vertices of the polygon. point (Tuple[int, int]): Tuple representing the point to check. Returns: bool: True if the point is inside the polygon, False otherwise. Examples: >>> is_point_inside_polygon([(0, 0), (4, 0), (4, 4), (0, 4)], (2, 2)) True >>> is_point_inside_polygon([(0, 0), (4, 0), (4, 4), (0, 4)], (5, 5)) False","solution":"def is_point_inside_polygon(polygon, point): Determine if a point is inside a given polygon. Args: polygon (List[Tuple[int, int]]): List of tuples representing the vertices of the polygon. point (Tuple[int, int]): Tuple representing the point to check. Returns: bool: True if the point is inside the polygon, False otherwise. x, y = point n = len(polygon) inside = False p1x, p1y = polygon[0] for i in range(n + 1): p2x, p2y = polygon[i % n] if y > min(p1y, p2y): if y <= max(p1y, p2y): if x <= max(p1x, p2x): if p1y != p2y: xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x if p1x == p2x or x <= xinters: inside = not inside p1x, p1y = p2x, p2y return inside"},{"question":"from typing import List def check_winner(board: List[List[str]]) -> str: Determine the winner of a Tic-Tac-Toe game based on the current state of the 3x3 game board. >>> check_winner([ ... ['X', 'X', 'X'], ... ['O', 'O', ' '], ... [' ', ' ', ' '] ... ]) 'X' >>> check_winner([ ... ['O', 'X', 'X'], ... ['O', 'O', 'X'], ... ['X', 'O', 'O'] ... ]) 'O' >>> check_winner([ ... ['X', 'O', 'X'], ... ['X', 'O', 'O'], ... ['O', 'X', 'X'] ... ]) 'Draw' >>> check_winner([ ... ['X', 'O', ' '], ... ['X', ' ', 'O'], ... ['O', 'X', ' '] ... ]) 'Pending'","solution":"from typing import List def check_winner(board: List[List[str]]) -> str: # Check rows for row in board: if row[0] == row[1] == row[2] and row[0] != ' ': return row[0] # Check columns for col in range(3): if board[0][col] == board[1][col] == board[2][col] and board[0][col] != ' ': return board[0][col] # Check diagonals if board[0][0] == board[1][1] == board[2][2] and board[0][0] != ' ': return board[0][0] if board[0][2] == board[1][1] == board[2][0] and board[0][2] != ' ': return board[0][2] # Check for a draw or pending for row in board: if ' ' in row: return 'Pending' return 'Draw'"},{"question":"def first_unique_character(s: str) -> int: Return the index of the first non-repeating character in a string. >>> first_unique_character(\\"leetcode\\") 0 >>> first_unique_character(\\"loveleetcode\\") 2 >>> first_unique_character(\\"aabb\\") -1 >>> first_unique_character(\\"cc\\") -1 >>> first_unique_character(\\"abcd\\") 0","solution":"def first_unique_character(s: str) -> int: Return the index of the first non-repeating character in a string. >>> first_unique_character(\\"leetcode\\") 0 >>> first_unique_character(\\"loveleetcode\\") 2 >>> first_unique_character(\\"aabb\\") -1 >>> first_unique_character(\\"cc\\") -1 >>> first_unique_character(\\"abcd\\") 0 from collections import Counter count = Counter(s) for index, char in enumerate(s): if count[char] == 1: return index return -1"},{"question":"import pytest from datetime import datetime, timedelta def convert_ddmmyyyy_to_mmddyyyy(date_str: str) -> str: Convert a date from DD-MM-YYYY format to MM-DD-YYYY format. Args: date_str (str): Date string in DD-MM-YYYY format. Returns: str: Date in MM-DD-YYYY format. >>> convert_ddmmyyyy_to_mmddyyyy(\\"31-12-2020\\") == \\"12-31-2020\\" >>> convert_ddmmyyyy_to_mmddyyyy(\\"01-01-2021\\") == \\"01-01-2021\\" pass # Implement the function here def days_between_dates(start_date: str, end_date: str) -> int: Calculate the number of days between two dates. Args: start_date (str): Start date in YYYY-MM-DD format. end_date (str): End date in YYYY-MM-DD format. The end date must be on or after the start date. Returns: int: The number of days between start_date and end_date. >>> days_between_dates(\\"2020-01-01\\", \\"2020-01-31\\") == 30 >>> days_between_dates(\\"2020-01-01\\", \\"2020-01-01\\") == 0 >>> days_between_dates(\\"2020-02-28\\", \\"2020-03-01\\") == 2 pass # Implement the function here def add_days_to_date(date_str: str, days: int) -> str: Add a specified number of days to a date and return the resulting date. Args: date_str (str): Initial date in YYYY-MM-DD format. days (int): Number of days to add (can be positive or negative). Returns: str: The resulting date after adding/subtracting days, in YYYY-MM-DD format. >>> add_days_to_date(\\"2020-01-01\\", 30) == \\"2020-01-31\\" >>> add_days_to_date(\\"2020-01-01\\", 0) == \\"2020-01-01\\" >>> add_days_to_date(\\"2020-01-31\\", -30) == \\"2020-01-01\\" pass # Implement the function here # Unit tests def test_convert_ddmmyyyy_to_mmddyyyy_valid(): assert convert_ddmmyyyy_to_mmddyyyy(\\"31-12-2020\\") == \\"12-31-2020\\" assert convert_ddmmyyyy_to_mmddyyyy(\\"01-01-2021\\") == \\"01-01-2021\\" def test_convert_ddmmyyyy_to_mmddyyyy_invalid_format(): with pytest.raises(ValueError): convert_ddmmyyyy_to_mmddyyyy(\\"31-12-20\\") with pytest.raises(ValueError): convert_ddmmyyyy_to_mmddyyyy(\\"2020-12-31\\") def test_convert_ddmmyyyy_to_mmddyyyy_invalid_date(): with pytest.raises(ValueError): convert_ddmmyyyy_to_mmddyyyy(\\"31-02-2020\\") with pytest.raises(ValueError): convert_ddmmyyyy_to_mmddyyyy(\\"32-01-2020\\") def test_days_between_dates_valid(): assert days_between_dates(\\"2020-01-01\\", \\"2020-01-31\\") == 30 assert days_between_dates(\\"2020-01-01\\", \\"2020-01-01\\") == 0 assert days_between_dates(\\"2020-02-28\\", \\"2020-03-01\\") == 2 def test_days_between_dates_invalid_format(): with pytest.raises(ValueError): days_between_dates(\\"2020-01-01\\", \\"31-01-2020\\") with pytest.raises(ValueError): days_between_dates(\\"01-01-2020\\", \\"2020-01-31\\") def test_days_between_dates_invalid_date(): with pytest.raises(ValueError): days_between_dates(\\"2020-02-30\\", \\"2020-03-01\\") def test_days_between_dates_end_before_start(): with pytest.raises(ValueError): days_between_dates(\\"2020-01-31\\", \\"2020-01-01\\") def test_add_days_to_date_valid(): assert add_days_to_date(\\"2020-01-01\\", 30) == \\"2020-01-31\\" assert add_days_to_date(\\"2020-01-01\\", 0) == \\"2020-01-01\\" assert add_days_to_date(\\"2020-01-31\\", -30) == \\"2020-01-01\\" def test_add_days_to_date_invalid_format(): with pytest.raises(ValueError): add_days_to_date(\\"31-01-2020\\", 30) with pytest.raises(ValueError): add_days_to_date(\\"2020/01/01\\", 30) def test_add_days_to_date_invalid_date(): with pytest.raises(ValueError): add_days_to_date(\\"2020-02-30\\", 1)","solution":"from datetime import datetime, timedelta def convert_ddmmyyyy_to_mmddyyyy(date_str): try: date = datetime.strptime(date_str, '%d-%m-%Y') return date.strftime('%m-%d-%Y') except ValueError: raise ValueError(\\"Invalid date format or date\\") def days_between_dates(start_date, end_date): try: start = datetime.strptime(start_date, '%Y-%m-%d') end = datetime.strptime(end_date, '%Y-%m-%d') if end < start: raise ValueError(\\"End date must be on or after the start date\\") delta = end - start return delta.days except ValueError: raise ValueError(\\"Invalid date format or date\\") def add_days_to_date(date_str, days): try: date = datetime.strptime(date_str, '%Y-%m-%d') new_date = date + timedelta(days=days) return new_date.strftime('%Y-%m-%d') except ValueError: raise ValueError(\\"Invalid date format or date\\")"},{"question":"inventory = {} def add_book(isbn: str, title: str, author: str, quantity: int) -> None: Add a single book to the inventory. Each book is represented as a dictionary containing: * ISBN number (string, unique identifier). * Title (string). * Author (string). * Quantity (integer). pass def remove_book(isbn: str, quantity: int) -> None: Remove a specified quantity of a book using its ISBN number. If the quantity to be removed exceeds the available quantity, the book should be removed completely. pass def search_book(isbn: str) -> dict: Search for a book by its ISBN number. It should return the book details if found, otherwise return None. pass def bulk_add_books(books: list[dict]) -> None: Handle bulk addition of books. The bulk operations should accept a list of books and process them in the same order as they appear in the list. pass def bulk_remove_books(removals: list[tuple[str, int]]) -> None: Handle bulk removal of books. The bulk operations should accept a list of removal requests and process them in the same order as they appear in the list. pass # Unit tests def setup_function(): inventory.clear() def test_add_book(): setup_function() add_book(\\"978-3-16-148410-0\\", \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 30) assert inventory[\\"978-3-16-148410-0\\"]['quantity'] == 30 add_book(\\"978-3-16-148410-0\\", \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 20) assert inventory[\\"978-3-16-148410-0\\"]['quantity'] == 50 def test_remove_book(): setup_function() add_book(\\"978-3-16-148410-0\\", \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 30) remove_book(\\"978-3-16-148410-0\\", 10) assert inventory[\\"978-3-16-148410-0\\"]['quantity'] == 20 remove_book(\\"978-3-16-148410-0\\", 20) assert \\"978-3-16-148410-0\\" not in inventory def test_search_book(): setup_function() add_book(\\"978-3-16-148410-0\\", \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 30) book = search_book(\\"978-3-16-148410-0\\") assert book == {'isbn': \\"978-3-16-148410-0\\", 'title': \\"The Great Gatsby\\", 'author': \\"F. Scott Fitzgerald\\", 'quantity': 30} assert search_book(\\"978-1-2345-6789-0\\") is None def test_bulk_add_books(): setup_function() books = [ {\\"isbn\\": \\"978-3-16-148410-0\\", \\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"quantity\\": 30}, {\\"isbn\\": \\"978-0-14-017739-8\\", \\"title\\": \\"Of Mice and Men\\", \\"author\\": \\"John Steinbeck\\", \\"quantity\\": 50}, {\\"isbn\\": \\"978-0-7432-7356-5\\", \\"title\\": \\"The Da Vinci Code\\", \\"author\\": \\"Dan Brown\\", \\"quantity\\": 40} ] bulk_add_books(books) assert inventory[\\"978-3-16-148410-0\\"]['quantity'] == 30 assert inventory[\\"978-0-14-017739-8\\"]['quantity'] == 50 assert inventory[\\"978-0-7432-7356-5\\"]['quantity'] == 40 def test_bulk_remove_books(): setup_function() books = [ {\\"isbn\\": \\"978-3-16-148410-0\\", \\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"quantity\\": 30}, {\\"isbn\\": \\"978-0-14-017739-8\\", \\"title\\": \\"Of Mice and Men\\", \\"author\\": \\"John Steinbeck\\", \\"quantity\\": 50}, {\\"isbn\\": \\"978-0-7432-7356-5\\", \\"title\\": \\"The Da Vinci Code\\", \\"author\\": \\"Dan Brown\\", \\"quantity\\": 40} ] bulk_add_books(books) removals = [ (\\"978-3-16-148410-0\\", 5), (\\"978-0-14-017739-8\\", 25), (\\"978-0-7432-7356-5\\", 50) ] bulk_remove_books(removals) assert inventory[\\"978-3-16-148410-0\\"]['quantity'] == 25 assert inventory[\\"978-0-14-017739-8\\"]['quantity'] == 25 assert \\"978-0-7432-7356-5\\" not in inventory","solution":"inventory = {} def add_book(isbn: str, title: str, author: str, quantity: int) -> None: if isbn not in inventory: inventory[isbn] = {'title': title, 'author': author, 'quantity': quantity} else: inventory[isbn]['quantity'] += quantity def remove_book(isbn: str, quantity: int) -> None: if isbn in inventory: if inventory[isbn]['quantity'] <= quantity: del inventory[isbn] else: inventory[isbn]['quantity'] -= quantity def search_book(isbn: str) -> dict: if isbn in inventory: return { 'isbn': isbn, 'title': inventory[isbn]['title'], 'author': inventory[isbn]['author'], 'quantity': inventory[isbn]['quantity'] } return None def bulk_add_books(books: list) -> None: for book in books: add_book(book['isbn'], book['title'], book['author'], book['quantity']) def bulk_remove_books(removals: list) -> None: for isbn, quantity in removals: remove_book(isbn, quantity)"},{"question":"def can_form_palindrome(s: str) -> bool: Check if any permutation of the input string can form a palindrome. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"Aibohphobia\\") True >>> can_form_palindrome(\\"No 'x' in Nixon\\") True >>> can_form_palindrome(\\"Was it a car or a cat I saw?\\") True >>> can_form_palindrome(\\"Random String\\") False","solution":"def can_form_palindrome(s: str) -> bool: from collections import Counter # Convert string to lower case and filter only alphabetic characters cleaned_s = [char.lower() for char in s if char.isalpha()] char_counter = Counter(cleaned_s) # Count characters with an odd frequency odd_counts = sum(count % 2 for count in char_counter.values()) # Return True if at most one character has an odd frequency return odd_counts <= 1"},{"question":"def hybrid_sort(arr: list, k: int) -> list: Implement a hybrid sorting algorithm that combines Merge Sort and Insertion Sort. Uses Merge Sort for larger portions of the array and switches to Insertion Sort for sub-arrays of size k or smaller. >>> hybrid_sort([], 3) == [] >>> hybrid_sort([1], 3) == [1] >>> hybrid_sort([12, 11, 13, 5, 6, 7], 3) == [5, 6, 7, 11, 12, 13] >>> hybrid_sort([3, 0, 2, 5, -1, 4, 1], 4) == [-1, 0, 1, 2, 3, 4, 5] >>> hybrid_sort([1, 2, 3, 4, 5], 3) == [1, 2, 3, 4, 5] >>> hybrid_sort([5, 4, 3, 2, 1], 3) == [1, 2, 3, 4, 5]","solution":"def insertion_sort(arr, left, right): for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def merge(arr, left, mid, right): n1 = mid - left + 1 n2 = right - mid L = arr[left:mid + 1] R = arr[mid + 1:right + 1] i = j = 0 k = left while i < n1 and j < n2: if L[i] <= R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i < n1: arr[k] = L[i] i += 1 k += 1 while j < n2: arr[k] = R[j] j += 1 k += 1 def hybrid_sort_recursive(arr, left, right, k): if left < right: if (right - left + 1) <= k: insertion_sort(arr, left, right) else: mid = (left + right) // 2 hybrid_sort_recursive(arr, left, mid, k) hybrid_sort_recursive(arr, mid + 1, right, k) merge(arr, left, mid, right) def hybrid_sort(arr, k): if len(arr) <= 1: return arr hybrid_sort_recursive(arr, 0, len(arr) - 1, k) return arr"},{"question":"def are_anagrams(string1: str, string2: str) -> bool: Check if two strings are anagrams. Parameters: string1 (str): The first string to compare. string2 (str): The second string to compare. Returns: bool: True if the strings are anagrams, False otherwise. Raises: TypeError: If any of the inputs is not a string. pass def test_are_anagrams_positive_cases(): assert are_anagrams(\\"Listen\\", \\"Silent\\") assert are_anagrams(\\"Triangle\\", \\"Integral\\") assert are_anagrams(\\"The eyes\\", \\"They see\\") assert are_anagrams(\\"Astronomer\\", \\"Moon starer\\") assert are_anagrams(\\"School master\\", \\"The classroom\\") def test_are_anagrams_negative_cases(): assert not are_anagrams(\\"Hello\\", \\"Ole H\\") assert not are_anagrams(\\"Astronomer\\", \\"Moonstare\\") assert not are_anagrams(\\"Astronomer\\", \\"123\\") def test_are_anagrams_type_errors(): import pytest with pytest.raises(TypeError): are_anagrams(\\"Astronomer\\", 123) with pytest.raises(TypeError): are_anagrams(123, \\"Moonstare\\") with pytest.raises(TypeError): are_anagrams(True, False)","solution":"def are_anagrams(string1: str, string2: str) -> bool: Check if two strings are anagrams. Parameters: string1 (str): The first string to compare. string2 (str): The second string to compare. Returns: bool: True if the strings are anagrams, False otherwise. Raises: TypeError: If any of the inputs is not a string. if not isinstance(string1, str) or not isinstance(string2, str): raise TypeError(\\"Both inputs must be strings\\") normalized_str1 = ''.join(filter(str.isalnum, string1)).lower() normalized_str2 = ''.join(filter(str.isalnum, string2)).lower() return sorted(normalized_str1) == sorted(normalized_str2)"},{"question":"import os import asyncio async def directory_size(path: str, extension_filter: list[str]) -> int: Calculate the total size of files in a directory, with the ability to filter by file extension. Args: path (str): The directory path for which to calculate the total size. extension_filter (list of str): A list of file extensions to include in the size calculation. If empty, include all file types. Returns: int: The total size of files in bytes. Example: >>> asyncio.run(directory_size(\\"/path/to/dir\\", [\\"txt\\", \\"pdf\\"])) 300 >>> asyncio.run(directory_size(\\"/path/to/anotherdir\\", [])) 600 # Your implementation here def create_test_files(base_dir): os.makedirs(base_dir, exist_ok=True) test_files = [ (\\"file1.txt\\", 100), (\\"file2.pdf\\", 200), (\\"file3.jpg\\", 300), ] for filename, size in test_files: with open(os.path.join(base_dir, filename), 'wb') as f: f.write(b'0' * size) def remove_test_files(base_dir): for root, dirs, files in os.walk(base_dir, topdown=False): for name in files: os.remove(os.path.join(root, name)) for name in dirs: os.rmdir(os.path.join(root, name)) os.rmdir(base_dir) def test_directory_size(): test_dir = \\"test_dir\\" create_test_files(test_dir) async def run_test(): assert await directory_size(test_dir, []) == 600 assert await directory_size(test_dir, ['txt']) == 100 assert await directory_size(test_dir, ['pdf']) == 200 assert await directory_size(test_dir, ['jpg']) == 300 assert await directory_size(test_dir, ['txt', 'pdf']) == 300 try: asyncio.run(run_test()) finally: remove_test_files(test_dir)","solution":"import os import asyncio import logging async def file_size(file_path): try: return os.path.getsize(file_path) except Exception as e: logging.error(f\\"Error reading file {file_path}: {e}\\") return 0 async def directory_size(path: str, extension_filter: list[str]) -> int: total_size = 0 tasks = [] for root, dirs, files in os.walk(path): for file in files: if not extension_filter or file.split('.')[-1] in extension_filter: file_path = os.path.join(root, file) tasks.append(file_size(file_path)) sizes = await asyncio.gather(*tasks) total_size = sum(sizes) return total_size"},{"question":"from collections import deque, defaultdict from typing import List, Tuple def topological_sort(n: int, m: int, edges: List[Tuple[int, int]]) -> List[int]: Perform topological sorting on a directed acyclic graph using Kahn's algorithm. Args: n (int): Number of vertices in the graph. m (int): Number of edges in the graph. edges (List[Tuple[int, int]]): List of directed edges described by tuples (u, v). Returns: List[int]: A list of vertices in topologically sorted order. >>> topological_sort(6, 6, [(5, 2), (5, 0), (4, 0), (4, 1), (2, 3), (3, 1)]) [4, 5, 0, 2, 3, 1] pass def parse_input(input_string: str) -> Tuple[int, int, List[Tuple[int, int]]]: Parse input string to extract number of vertices, edges, and the list of edges. Args: input_string (str): Input string containing graph description. Returns: Tuple[int, int, List[Tuple[int, int]]]: A tuple containing number of vertices, number of edges, and list of edges. >>> parse_input(\\"6 6n5 2n5 0n4 0n4 1n2 3n3 1\\") (6, 6, [(5, 2), (5, 0), (4, 0), (4, 1), (2, 3), (3, 1)]) pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"from collections import deque, defaultdict def topological_sort(n, m, edges): in_degree = [0] * n adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) in_degree[v] += 1 queue = deque([i for i in range(n) if in_degree[i] == 0]) topological_order = [] while queue: node = queue.popleft() topological_order.append(node) for neighbor in adj_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return topological_order def parse_input(input_string): lines = input_string.strip().split('n') n, m = map(int, lines[0].split()) edges = [list(map(int, line.split())) for line in lines[1:]] return n, m, edges"},{"question":"import re def is_valid_filesize(filesize: str) -> bool: Check if the given string is a valid human-readable file size. >>> is_valid_filesize(\\"1024 B\\") True >>> is_valid_filesize(\\"1.5 KB\\") True >>> is_valid_filesize(\\"100 MB\\") True >>> is_valid_filesize(\\"1.23 GB\\") True >>> is_valid_filesize(\\"0.45 TB\\") True >>> is_valid_filesize(\\"10.123 MB\\") False >>> is_valid_filesize(\\"1000MB\\") False >>> is_valid_filesize(\\"1.5 kB\\") False >>> is_valid_filesize(\\"MB 100\\") False >>> is_valid_filesize(\\"100..00 B\\") False >>> is_valid_filesize(\\"100 B B\\") False >>> is_valid_filesize(\\"G1.23B\\") False >>> is_valid_filesize(\\" 100 MB\\") False >>> is_valid_filesize(\\"100 MB\\") False >>> is_valid_filesize(\\"100 MB \\") False","solution":"import re def is_valid_filesize(filesize: str) -> bool: Check if the given string is a valid human-readable file size. :param filesize: The string to check. :return: True if the string is a valid file size, otherwise False. # Regular expression pattern for validating file size pattern = re.compile(r'^d+(.d{1,2})? (B|KB|MB|GB|TB)') return bool(pattern.match(filesize))"},{"question":"# Problem Statement You are given an unordered list of integers representing a set of weights. Write a function that finds the minimum difference between the sum of elements in any two non-empty subsets of the list. from typing import List def minimum_subset_difference(weights: List[int]) -> int: Finds the minimum difference between the sum of elements in any two non-empty subsets. total_weight = sum(weights) n = len(weights) dp = [[False] * (total_weight // 2 + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(total_weight // 2 + 1): if j >= weights[i - 1]: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - weights[i - 1]] else: dp[i][j] = dp[i - 1][j] min_diff = float('inf') for j in range(total_weight // 2 + 1): if dp[n][j]: min_diff = min(min_diff, total_weight - 2 * j) return min_diff","solution":"from typing import List def minimum_subset_difference(weights: List[int]) -> int: Finds the minimum difference between the sum of elements in any two non-empty subsets. total_weight = sum(weights) n = len(weights) dp = [[False] * (total_weight // 2 + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(total_weight // 2 + 1): if j >= weights[i - 1]: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - weights[i - 1]] else: dp[i][j] = dp[i - 1][j] min_diff = float('inf') for j in range(total_weight // 2 + 1): if dp[n][j]: min_diff = min(min_diff, total_weight - 2 * j) return min_diff"},{"question":"def format_email_template(template: str, values: dict) -> str: Replace placeholders in the template string with corresponding dictionary values. >>> template = \\"Dear {name},nnWe are pleased to inform you that your application for {position} has been {status}. Please contact {contact_person} for further details.nnBest regards,n{company}\\" >>> values = { ... \\"name\\": \\"John Doe\\", ... \\"position\\": \\"Software Developer\\", ... \\"status\\": \\"accepted\\", ... \\"contact_person\\": \\"Jane Smith\\", ... \\"company\\": \\"Tech Corp\\" ... } >>> format_email_template(template, values) 'Dear John Doe,nnWe are pleased to inform you that your application for Software Developer has been accepted. Please contact Jane Smith for further details.nnBest regards,nTech Corp' >>> template = \\"Dear {name},nnWelcome to {company}. We are excited to have you join as {position}.\\" >>> values = { ... \\"name\\": \\"Alice\\", ... \\"company\\": \\"Acme Corp\\" ... } >>> format_email_template(template, values) 'Dear Alice,nnWelcome to Acme Corp. We are excited to have you join as {position}.' def test_format_email_template_with_all_placeholders(): template = ( \\"Dear {name},nn\\" \\"We are pleased to inform you that your application for {position} has been {status}. \\" \\"Please contact {contact_person} for further details.nn\\" \\"Best regards,n{company}\\" ) values = { \\"name\\": \\"John Doe\\", \\"position\\": \\"Software Developer\\", \\"status\\": \\"accepted\\", \\"contact_person\\": \\"Jane Smith\\", \\"company\\": \\"Tech Corp\\" } expected_output = ( \\"Dear John Doe,nn\\" \\"We are pleased to inform you that your application for Software Developer has been accepted. \\" \\"Please contact Jane Smith for further details.nn\\" \\"Best regards,nTech Corp\\" ) assert format_email_template(template, values) == expected_output def test_format_email_template_with_missing_placeholders(): template = ( \\"Dear {name},nn\\" \\"Welcome to {company}. We are excited to have you join as {position}.\\" ) values = { \\"name\\": \\"Alice\\", \\"company\\": \\"Acme Corp\\" } expected_output = ( \\"Dear Alice,nn\\" \\"Welcome to Acme Corp. We are excited to have you join as {position}.\\" ) assert format_email_template(template, values) == expected_output def test_format_email_template_with_no_placeholders(): template = ( \\"Hello,nn\\" \\"Thank you for your interest.nn\\" \\"Best regards,nSupport Team\\" ) values = { \\"name\\": \\"Alice\\", \\"company\\": \\"Acme Corp\\" } expected_output = ( \\"Hello,nn\\" \\"Thank you for your interest.nn\\" \\"Best regards,nSupport Team\\" ) assert format_email_template(template, values) == expected_output def test_format_email_template_with_extra_values(): template = ( \\"Hi {name},n\\" \\"Your role at {company} is {position}.n\\" ) values = { \\"name\\": \\"Bob\\", \\"company\\": \\"Widgets Inc\\", \\"position\\": \\"Manager\\", \\"extra\\": \\"Not used\\" } expected_output = ( \\"Hi Bob,n\\" \\"Your role at Widgets Inc is Manager.n\\" ) assert format_email_template(template, values) == expected_output def test_format_email_template_empty_template(): template = \\"\\" values = { \\"name\\": \\"Alice\\" } expected_output = \\"\\" assert format_email_template(template, values) == expected_output def test_format_email_template_empty_values(): template = ( \\"Dear {name},nn\\" \\"Welcome to {company}. We are excited to have you join as {position}.\\" ) values = {} expected_output = ( \\"Dear {name},nn\\" \\"Welcome to {company}. We are excited to have you join as {position}.\\" ) assert format_email_template(template, values) == expected_output","solution":"def format_email_template(template: str, values: dict) -> str: Replace placeholders in the template string with corresponding dictionary values. formatted_template = template for key, value in values.items(): formatted_template = formatted_template.replace(f\\"{{{key}}}\\", value) return formatted_template"},{"question":"def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Rotates a given square matrix by 90 degrees clockwise. Args: matrix (list[list[int]]): A 2-D list representing the matrix. Returns: list[list[int]]: The rotated matrix. Examples: >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix([[1]]) [[1]] pass def print_matrix(matrix: list[list[int]]) -> None: Prints a given matrix in a formatted manner. Args: matrix (list[list[int]]): A 2-D list representing the matrix. Examples: >>> print_matrix([[7, 4, 1], [8, 5, 2], [9, 6, 3]]) 7 4 1 8 5 2 9 6 3 pass","solution":"def rotate_matrix(matrix): Rotates a given square matrix by 90 degrees clockwise. Args: matrix (list[list[int]]): A 2-D list representing the matrix. Returns: list[list[int]]: The rotated matrix. if not matrix or not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"Input must be a non-empty square matrix.\\") n = len(matrix) rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - i - 1] = matrix[i][j] return rotated def print_matrix(matrix): Prints a given matrix in a formatted manner. Args: matrix (list[list[int]]): A 2-D list representing the matrix. for row in matrix: print(\\" \\".join(map(str, row))) # Helper function for creating test matrices def create_matrix(n): return [[j + i * n for j in range(1, n + 1)] for i in range(n)]"},{"question":"def bellman_ford(vertices: int, edges: list[tuple[int, int, int]], source: int) -> list[int]: Calculate the shortest path from a given source vertex to all other vertices in a directed weighted graph. Detects negative weight cycles. Args: vertices (int): The number of vertices in the graph, labeled from 0 to vertices - 1. edges (list of tuples): A list where each tuple (u, v, w) represents an edge from vertex u to vertex v with weight w. source (int): The starting vertex for calculating the shortest paths. Returns: list[int]: A list of integers where the value at index i is the shortest distance from the source vertex to vertex i. Raises: ValueError: If the graph contains a negative weight cycle reachable from the source. Examples: >>> vertices = 5 >>> edges = [(0, 1, -1), (0, 2, 4), (1, 2, 3), (1, 3, 2), (1, 4, 2), (3, 2, 5), (3, 1, 1), (4, 3, -3)] >>> source = 0 >>> bellman_ford(vertices, edges, source) [0, -1, 2, -2, 1] >>> vertices = 3 >>> edges = [(0, 1, 4), (1, 2, -10), (2, 0, 3)] >>> source = 0 >>> bellman_ford(vertices, edges, source) Traceback (most recent call last): ... ValueError >>> vertices = 4 >>> edges = [(0, 1, 1), (1, 2, 3), (2, 3, 2), (3, 1, -8)] >>> source = 0 >>> bellman_ford(vertices, edges, source) Traceback (most recent call last): ... ValueError","solution":"def bellman_ford(vertices: int, edges: list[tuple[int, int, int]], source: int) -> list[int]: # Initialize the distance to all vertices as infinity except the source distance = [float('inf')] * vertices distance[source] = 0 # Relax edges repeatedly for _ in range(vertices - 1): for u, v, w in edges: if distance[u] != float('inf') and distance[u] + w < distance[v]: distance[v] = distance[u] + w # Check for negative-weight cycles for u, v, w in edges: if distance[u] != float('inf') and distance[u] + w < distance[v]: raise ValueError(\\"Graph contains a negative weight cycle\\") return distance"},{"question":"from typing import List from collections import Counter def most_active_user(log: str) -> str: Given a string representing a server log where each line contains a user ID, this function returns the user ID of the most active user (i.e. the user with the highest number of events recorded). >>> most_active_user(\\"user_1nuser_2nuser_1nuser_3nuser_1nuser_2n\\") 'user_1' >>> most_active_user(\\"user_2nuser_2nuser_2nuser_1nuser_3nuser_1n\\") 'user_2' pass","solution":"def most_active_user(log: str) -> str: Given a string representing a server log where each line contains a user ID, this function returns the user ID of the most active user (i.e. the user with the highest number of events recorded). from collections import Counter # Split the log string into individual lines (user IDs) user_ids = log.strip().split('n') # Count the occurrences of each user ID user_count = Counter(user_ids) # Find the user ID with the maximum count most_active = max(user_count, key=user_count.get) return most_active"},{"question":"import json from typing import List, Dict def load_destination_data(file_path: str) -> Dict: Load the data of a destination from a JSON file. with open(file_path, 'r') as file: return json.load(file) def calculate_score(destination: Dict, criteria: Dict, user_target: Dict) -> int: Calculate the score for a destination based on the given criteria. score = 0 if 'temperature' in criteria and user_target['temperature'] is not None: score -= abs(destination['average_temperature'] - user_target['temperature']) if 'rainfall' in criteria and user_target['rainfall'] is not None: score -= destination['average_rainfall'] if 'attractions' in criteria and user_target['attractions'] is not None: score += destination['number_of_attractions'] return score def find_best_vacation_destination(file_paths: List[str], criteria: Dict) -> str: Find the best vacation destination based on user-specified criteria. >>> find_best_vacation_destination(['paris.json', 'london.json', 'new_york.json'], {'temperature': 25, 'rainfall': None, 'attractions': None}) \\"New York\\" best_destination = None best_score = float('-inf') for file_path in file_paths: destination = load_destination_data(file_path) score = calculate_score(destination, criteria, criteria) if score > best_score: best_score = score best_destination = destination['name'] return best_destination import pytest @pytest.fixture def setup_test_environment(tmpdir): files = { 'paris.json': '{\\"name\\": \\"Paris\\", \\"average_temperature\\": 20, \\"average_rainfall\\": 50, \\"number_of_attractions\\": 100}', 'london.json': '{\\"name\\": \\"London\\", \\"average_temperature\\": 15, \\"average_rainfall\\": 70, \\"number_of_attractions\\": 120}', 'new_york.json': '{\\"name\\": \\"New York\\", \\"average_temperature\\": 25, \\"average_rainfall\\": 60, \\"number_of_attractions\\": 110}' } file_paths = [] for file_name, file_content in files.items(): file_path = tmpdir.join(file_name) file_path.write(file_content) file_paths.append(str(file_path)) return file_paths def test_best_destination_by_temperature(setup_test_environment): file_paths = setup_test_environment criteria = {'temperature': 25, 'rainfall': None, 'attractions': None} assert find_best_vacation_destination(file_paths, criteria) == \\"New York\\" def test_best_destination_by_rainfall(setup_test_environment): file_paths = setup_test_environment criteria = {'temperature': None, 'rainfall': True, 'attractions': None} assert find_best_vacation_destination(file_paths, criteria) == \\"Paris\\" def test_best_destination_by_attractions(setup_test_environment): file_paths = setup_test_environment criteria = {'temperature': None, 'rainfall': None, 'attractions': True} assert find_best_vacation_destination(file_paths, criteria) == \\"London\\" def test_best_destination_by_temperature_and_rainfall(setup_test_environment): file_paths = setup_test_environment criteria = {'temperature': 18, 'rainfall': True, 'attractions': None} assert find_best_vacation_destination(file_paths, criteria) == \\"Paris\\" def test_best_destination_by_all_criteria(setup_test_environment): file_paths = setup_test_environment criteria = {'temperature': 20, 'rainfall': True, 'attractions': True} assert find_best_vacation_destination(file_paths, criteria) == \\"Paris\\"","solution":"import json def load_destination_data(file_path): with open(file_path, 'r') as file: return json.load(file) def calculate_score(destination, criteria, user_target): score = 0 if 'temperature' in criteria and user_target['temperature'] is not None: score -= abs(destination['average_temperature'] - user_target['temperature']) if 'rainfall' in criteria and user_target['rainfall'] is not None: score -= destination['average_rainfall'] if 'attractions' in criteria and user_target['attractions'] is not None: score += destination['number_of_attractions'] return score def find_best_vacation_destination(file_paths, criteria): best_destination = None best_score = float('-inf') for file_path in file_paths: destination = load_destination_data(file_path) score = calculate_score(destination, criteria, criteria) if score > best_score: best_score = score best_destination = destination['name'] return best_destination"},{"question":"class MinStack: MinStack data structure that supports the following operations in constant time: - push(x): Push the element x onto the stack. - pop(): Removes the element on top of the stack. - top(): Get the top element. - getMin(): Retrieve the minimum element in the stack. def __init__(self): # Initialize the MinStack with required properties. def push(self, x: int) -> None: # Push the element x onto the stack. def pop(self) -> None: # Remove the element on top of the stack. def top(self) -> int: # Get the top element. def getMin(self) -> int: # Retrieve the minimum element in the stack. # Example usage: minStack = MinStack() minStack.push(-2) # Stack: [-2] minStack.push(0) # Stack: [-2, 0] minStack.push(-3) # Stack: [-2, 0, -3] print(minStack.getMin()) # returns -3 (minimum element is -3) minStack.pop() # removes -3 (Stack: [-2, 0]) print(minStack.top()) # returns 0 (top element is 0) print(minStack.getMin()) # returns -2 (minimum element is -2)","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: if self.stack: top_element = self.stack.pop() if top_element == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] return None def getMin(self) -> int: if self.min_stack: return self.min_stack[-1] return None"},{"question":"import math def calculate_distance(p1: tuple, p2: tuple) -> float: Calculate the Euclidean distance between two points in 3D space. >>> calculate_distance((0, 0, 0), (1, 1, 1)) 1.73205 >>> calculate_distance((1, 2, 3), (4, 5, 6)) 5.19615 >>> calculate_distance((0.5, 0.5, 0.5), (1.5, 1.5, 1.5)) 1.73205","solution":"import math def calculate_distance(p1: tuple, p2: tuple) -> float: Calculate the Euclidean distance between two points in 3D space. :param p1: A tuple containing three floats representing the first point (x1, y1, z1). :param p2: A tuple containing three floats representing the second point (x2, y2, z2). :return: A float representing the Euclidean distance between the two points. x1, y1, z1 = p1 x2, y2, z2 = p2 distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2 + (z2 - z1)**2) return distance"},{"question":"def rotate_matrix_90_clockwise(matrix): Rotates the given n x n matrix 90 degrees clockwise in place. >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotate_matrix_90_clockwise(matrix) >>> matrix [[3, 1], [4, 2]] >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix_90_clockwise(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ] >>> rotate_matrix_90_clockwise(matrix) >>> matrix [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] >>> matrix = [[1]] >>> rotate_matrix_90_clockwise(matrix) >>> matrix [[1]]","solution":"def rotate_matrix_90_clockwise(matrix): Rotates the given n x n matrix 90 degrees clockwise in place. n = len(matrix) # First step: transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Second step: reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def trap_rain_water(height: list[int]) -> int: Calculate the total volume of trapped water using an O(N) algorithm. >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) 9 >>> trap_rain_water([]) 0 >>> trap_rain_water([3, 3, 3, 3]) 0 from solution import trap_rain_water def test_trap_rain_water_example_1(): assert trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 def test_trap_rain_water_example_2(): assert trap_rain_water([4, 2, 0, 3, 2, 5]) == 9 def test_trap_rain_water_empty(): assert trap_rain_water([]) == 0 def test_trap_rain_water_flat(): assert trap_rain_water([3, 3, 3, 3]) == 0 def test_trap_rain_water_single_element(): assert trap_rain_water([4]) == 0 def test_trap_rain_water_two_elements(): assert trap_rain_water([4, 1]) == 0 def test_trap_rain_water_all_increasing(): assert trap_rain_water([1, 2, 3, 4, 5]) == 0 def test_trap_rain_water_all_decreasing(): assert trap_rain_water([5, 4, 3, 2, 1]) == 0 def test_trap_rain_water_peak_valley_pattern(): assert trap_rain_water([1, 0, 1]) == 1 assert trap_rain_water([2, 0, 2]) == 2 def test_trap_rain_water_multiple_valleys(): assert trap_rain_water([0, 3, 0, 2, 0, 4]) == 7","solution":"def trap_rain_water(height: list[int]) -> int: if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) # Fill right_max array right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) # Calculate the total trapped water total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - height[i] return total_water"},{"question":"import json def csv_to_json(csv_data: str) -> str: Convert CSV formatted data into a JSON formatted string. Args: csv_data (str): A string containing CSV formatted data. Returns: str: A JSON formatted string representing the CSV data. Raises: ValueError: If the input CSV data is not properly formatted. pass # Implement this function # Unit Tests def test_basic_conversion(): assert csv_to_json('name,age,citynAlice,30,New YorknBob,25,Boston') == '[{\\"name\\": \\"Alice\\", \\"age\\": \\"30\\", \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": \\"25\\", \\"city\\": \\"Boston\\"}]' def test_single_row(): assert csv_to_json('name,age,citynEmily,29,Seattle') == '[{\\"name\\": \\"Emily\\", \\"age\\": \\"29\\", \\"city\\": \\"Seattle\\"}]' def test_varied_data(): assert csv_to_json('id,product,pricen1,T-shirt,20.5n2,Jeans,40.0n3,Shoes,60.75') == '[{\\"id\\": \\"1\\", \\"product\\": \\"T-shirt\\", \\"price\\": \\"20.5\\"}, {\\"id\\": \\"2\\", \\"product\\": \\"Jeans\\", \\"price\\": \\"40.0\\"}, {\\"id\\": \\"3\\", \\"product\\": \\"Shoes\\", \\"price\\": \\"60.75\\"}]' def test_inconsistent_columns(): try: csv_to_json('name,age,citynFrank,32') except ValueError as e: assert str(e) == \\"CSV data is invalid: Rows have inconsistent number of columns.\\" def test_no_rows(): assert csv_to_json('name,age,cityn') == '[]' assert csv_to_json('') == '[]' # Edge case with empty input def test_extra_whitespace(): assert csv_to_json(' name , age , city n Alice , 30 , New York n Bob , 25 , Boston ') == '[{\\"name\\": \\"Alice\\", \\"age\\": \\"30\\", \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": \\"25\\", \\"city\\": \\"Boston\\"}]'","solution":"import json def csv_to_json(csv_data: str) -> str: Convert CSV formatted data into a JSON formatted string. Args: csv_data (str): A string containing CSV formatted data. Returns: str: A JSON formatted string representing the CSV data. Raises: ValueError: If the input CSV data is not properly formatted. # Split the input into lines lines = csv_data.strip().split('n') if len(lines) <= 1: return \\"[]\\" # Get the keys from the first line keys = [key.strip() for key in lines[0].split(',')] # Initialize list to hold the dictionary representation of each row json_list = [] # Process each row for row in lines[1:]: values = [value.strip() for value in row.split(',')] if len(values) != len(keys): raise ValueError(\\"CSV data is invalid: Rows have inconsistent number of columns.\\") # Create a dictionary for the current row row_dict = dict(zip(keys, values)) json_list.append(row_dict) return json.dumps(json_list)"},{"question":"def sort_product_listings(product_listings: list) -> list: Sorts a list of product listings based on alphabetical order of names. If two products have the same name, they are sorted based on their price in ascending order. Args: product_listings (list of str): List of product listings in the format name,price Returns: list of str: Sorted list of product listings based on the rules. Examples: >>> sort_product_listings([\\"banana,1.50\\", \\"apple,2.00\\", \\"apple,1.75\\", \\"banana,2.25\\"]) ['apple,1.75', 'apple,2.00', 'banana,1.50', 'banana,2.25'] >>> sort_product_listings([\\"brush,5.00\\", \\"apple,2.00\\", \\"brush,2.50\\", \\"apple,1.50\\"]) ['apple,1.50', 'apple,2.00', 'brush,2.50', 'brush,5.00'] pass from solution import sort_product_listings def test_single_product_listing(): assert sort_product_listings([\\"apple,1.00\\"]) == [\\"apple,1.00\\"] def test_multiple_product_listings_different_names(): assert sort_product_listings([\\"banana,1.50\\", \\"apple,2.00\\"]) == [\\"apple,2.00\\", \\"banana,1.50\\"] def test_multiple_product_listings_same_name(): assert sort_product_listings([\\"apple,2.00\\", \\"apple,1.75\\"]) == [\\"apple,1.75\\", \\"apple,2.00\\"] def test_multiple_product_listings_mixed(): input_list = [\\"banana,1.50\\", \\"apple,2.00\\", \\"apple,1.75\\", \\"banana,2.25\\"] output_list = [\\"apple,1.75\\", \\"apple,2.00\\", \\"banana,1.50\\", \\"banana,2.25\\"] assert sort_product_listings(input_list) == output_list def test_case_insensitivity(): input_list = [\\"Banana,1.50\\", \\"apple,2.00\\", \\"Apple,1.75\\", \\"banana,2.25\\"] output_list = [\\"Apple,1.75\\", \\"apple,2.00\\", \\"Banana,1.50\\", \\"banana,2.25\\"] assert sort_product_listings(input_list) == output_list","solution":"def sort_product_listings(product_listings): Sorts a list of product listings based on alphabetical order of names. If two products have the same name, they are sorted based on their price in ascending order. Args: product_listings (list of str): List of product listings in the format name,price Returns: list of str: Sorted list of product listings based on the rules. # Split each listing into a tuple of (name, price). products = [] for listing in product_listings: name, price = listing.split(',') products.append((name.lower(), float(price), listing)) # Sort the products based on the (name, then price). products.sort(key=lambda p: (p[0], p[1])) # Extract the original listings from the sorted tuples. sorted_listings = [p[2] for p in products] return sorted_listings"},{"question":"from typing import List def flexible_series(start: int, end: int, rule: str) -> List[int]: Generate a series of numbers between start and end (inclusive) based on the specified rule. The rule can be \\"prime\\" (only include prime numbers), \\"even\\" (only include even numbers), or \\"odd\\" (only include odd numbers). >>> flexible_series(1, 10, \\"prime\\") [2, 3, 5, 7] >>> flexible_series(1, 10, \\"even\\") [2, 4, 6, 8, 10] >>> flexible_series(1, 10, \\"odd\\") [1, 3, 5, 7, 9] >>> flexible_series(10, 5, \\"even\\") Traceback (most recent call last): ... ValueError: Start must be less than or equal to End. >>> flexible_series(1, 10, \\"fibonacci\\") Traceback (most recent call last): ... ValueError: Invalid rule provided.","solution":"from typing import List def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def flexible_series(start: int, end: int, rule: str) -> List[int]: if start > end: raise ValueError(\\"Start must be less than or equal to End.\\") if rule not in {\\"prime\\", \\"even\\", \\"odd\\"}: raise ValueError(\\"Invalid rule provided.\\") if rule == \\"prime\\": return [i for i in range(start, end + 1) if is_prime(i)] if rule == \\"even\\": return [i for i in range(start, end + 1) if i % 2 == 0] if rule == \\"odd\\": return [i for i in range(start, end + 1) if i % 2 != 0]"},{"question":"from typing import List class Book: def __init__(self, title: str, author: str): self.title = title self.author = author class Inventory: def __init__(self): self.books = [] def add_book(self, book: Book) -> None: Add a book to the inventory pass def remove_book(self, title: str) -> bool: Removes a book by title from the inventory. Returns True if the book was successfully removed and False if the book was not found. pass def search_by_title(self, title: str) -> List[Book]: Returns a list of books that match the given title (case-insensitive). pass def search_by_author(self, author: str) -> List[Book]: Returns a list of books that match the given author (case-insensitive). pass def is_available(self, title: str) -> bool: Checks if a book with the given title is available in the inventory. pass # Example Usage inventory = Inventory() book1 = Book('The Great Gatsby', 'F. Scott Fitzgerald') book2 = Book('To Kill a Mockingbird', 'Harper Lee') book3 = Book('1984', 'George Orwell') inventory.add_book(book1) inventory.add_book(book2) inventory.add_book(book3) assert inventory.remove_book('The Great Gatsby') == True assert inventory.remove_book('The Catcher in the Rye') == False assert inventory.search_by_title('1984') == [book3] assert inventory.search_by_author('Harper Lee') == [book2] assert inventory.is_available('To Kill a Mockingbird') == True","solution":"from typing import List class Book: def __init__(self, title: str, author: str): self.title = title self.author = author def __eq__(self, other): return (self.title.lower() == other.title.lower() and self.author.lower() == other.author.lower()) class Inventory: def __init__(self): self.books = [] def add_book(self, book: Book) -> None: # Assuming each book added is unique by title, case-insensitive if not self.is_available(book.title): self.books.append(book) def remove_book(self, title: str) -> bool: for book in self.books: if book.title.lower() == title.lower(): self.books.remove(book) return True return False def search_by_title(self, title: str) -> List[Book]: return [book for book in self.books if title.lower() in book.title.lower()] def search_by_author(self, author: str) -> List[Book]: return [book for book in self.books if author.lower() in book.author.lower()] def is_available(self, title: str) -> bool: return any(book.title.lower() == title.lower() for book in self.books)"},{"question":"from typing import List def longest_consecutive(nums: List[int]) -> int: Find the length of the longest consecutive elements sequence from an unsorted array of integers. The algorithm should run in O(n) time complexity. Args: nums (List[int]): An unsorted array of integers. Returns: int: The length of the longest sequence of consecutive numbers. Examples: >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([1]) 1 >>> longest_consecutive([]) 0 >>> longest_consecutive([10, 5, 100]) 1 >>> longest_consecutive([1, 2, 3, 4, 5]) 5 >>> longest_consecutive([10, 4, 20, 1, 3, 2, 5]) 5 >>> longest_consecutive([1000000, 999999, 1000002, 1000001]) 4 # Your implementation goes here pass","solution":"from typing import List def longest_consecutive(nums: List[int]) -> int: if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: # Only start counting if \`num\` is the start of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def user_engagement_analyzer( train_dates: list, train_users: list, train_events: list, analyze_date: int, threshold: float = 0.05 ) -> tuple: Analyzes user engagement by evaluating event participation rates using provided historical data. Determines the percentage of users participating in events and evaluates the stability of user engagement. >>> user_engagement_analyzer([1, 2, 3, 4], [100, 150, 120, 130], [40, 60, 50, 55], 3) ([0.4, 0.4, 0.4166666666666667, 0.4230769230769231], True) >>> user_engagement_analyzer([1, 2, 3, 4], [100, 0, 120, 130], [40, 0, 50, 55], 3) ([0.4, 0, 0.4166666666666667, 0.4230769230769231], False) >>> user_engagement_analyzer([1, 2, 3, 4], [100, 150, 120, 130], [40, 60, 50, 55], 3, 0.1) ([0.4, 0.4, 0.4166666666666667, 0.4230769230769231], True) >>> user_engagement_analyzer([1, 2, 3, 4], [100, 150, 120, 130], [40, 60, 50, 55], 3, 0.01) ([0.4, 0.4, 0.4166666666666667, 0.4230769230769231], False)","solution":"def user_engagement_analyzer(train_dates, train_users, train_events, analyze_date, threshold=0.05): # Calculate the engagement percentages engagement_percentages = [ events / users if users != 0 else 0 for users, events in zip(train_users, train_events) ] # Calculate the average engagement avg_engagement = sum(engagement_percentages) / len(engagement_percentages) # Find the index of the analyze_date date_index = train_dates.index(analyze_date) # Determine the stability of engagement stable = all( abs(engagement - avg_engagement) <= threshold for i, engagement in enumerate(engagement_percentages) if i != date_index # Exclude the analyze date itself ) return engagement_percentages, stable"},{"question":"class CompleteBinaryTree: def __init__(self, num_nodes: int): Initializes the binary tree with the given number of nodes, arranged in a complete binary tree fashion. pass def add_node(self, index: int, value: int): Adds a node with the given value at the specified index in the tree. Raises a \`ValueError\` for invalid indices or if the index is already occupied. pass def sum_of_nodes(self) -> int: Returns the sum of all node values in the binary tree. pass # Example test cases def test_complete_binary_tree(): cbt = CompleteBinaryTree(7) cbt.add_node(0, 10) cbt.add_node(1, 20) cbt.add_node(2, 30) cbt.add_node(3, 40) cbt.add_node(4, 50) cbt.add_node(5, 60) cbt.add_node(6, 70) assert cbt.sum_of_nodes() == 280 def test_single_node_tree(): cbt = CompleteBinaryTree(1) cbt.add_node(0, 10) assert cbt.sum_of_nodes() == 10 def test_empty_tree(): cbt = CompleteBinaryTree(0) assert cbt.sum_of_nodes() == 0 def test_invalid_add_node_index(): cbt = CompleteBinaryTree(5) try: cbt.add_node(-1, 10) assert False, \\"Expected ValueError for negative index\\" except ValueError: pass try: cbt.add_node(5, 10) assert False, \\"Expected ValueError for index out of range\\" except ValueError: pass def test_add_node_to_occupied_index(): cbt = CompleteBinaryTree(3) cbt.add_node(0, 10) try: cbt.add_node(0, 20) assert False, \\"Expected ValueError for adding to an occupied index\\" except ValueError: pass","solution":"class CompleteBinaryTree: def __init__(self, num_nodes: int): self.num_nodes = num_nodes self.tree = [None] * num_nodes def add_node(self, index: int, value: int): if index < 0 or index >= self.num_nodes: raise ValueError(f\\"Index {index} is out of the valid range 0 to {self.num_nodes - 1}\\") if self.tree[index] is not None: raise ValueError(f\\"Index {index} is already occupied\\") self.tree[index] = value def sum_of_nodes(self) -> int: return sum(value for value in self.tree if value is not None)"},{"question":"def rotate_array(arr: list, k: int) -> None: Rotates the elements of an array in place to the right by a given number of positions. >>> arr = [1, 2, 3, 4, 5] >>> rotate_array(arr, 2) >>> arr [4, 5, 1, 2, 3] >>> arr = [0, 1, 2, 3, 4, 5] >>> rotate_array(arr, 3) >>> arr [3, 4, 5, 0, 1, 2] >>> arr = [1.1, 2.2, 3.3] >>> rotate_array(arr, 1) >>> arr [3.3, 1.1, 2.2] >>> arr = [4, 5, 6] >>> rotate_array(arr, 4) >>> arr [6, 4, 5]","solution":"def rotate_array(arr: list, k: int) -> None: Rotates the elements of arr to the right by k positions in place. n = len(arr) if n == 0: return k = k % n # Normalize k to be within the range of array length if k == 0: return # Reverse the entire array arr.reverse() # Reverse first k elements arr[:k] = reversed(arr[:k]) # Reverse the remaining elements arr[k:] = reversed(arr[k:])"},{"question":"def partition(arr, left, right, pivot_index): pass def quickselect(arr, left, right, k): pass def find_kth_smallest_unsorted(arr, k): Find the k-th smallest element in an unsorted array. >>> find_kth_smallest_unsorted([3, 1, 2, 4, 5], 2) 2 >>> find_kth_smallest_unsorted([7, 10, 4, 3, 20, 15], 3) 7 >>> find_kth_smallest_unsorted([100, 90, 80, 70], 4) 100 pass","solution":"def partition(arr, left, right, pivot_index): pivot_value = arr[pivot_index] # Move pivot to the end arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left # Move all elements smaller than pivot_value to the left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 # Move pivot to its final place arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def quickselect(arr, left, right, k): if left == right: # If the list contains only one element return arr[left] # Select a random pivot_index pivot_index = (left + right) // 2 pivot_index = partition(arr, left, right, pivot_index) # The pivot is in its final sorted position if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(arr, left, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, right, k) def find_kth_smallest_unsorted(arr, k): Find the k-th smallest element in an unsorted array. return quickselect(arr, 0, len(arr) - 1, k - 1)"},{"question":"from typing import List def levenshtein_distance(word1: str, word2: str) -> int: Computes the Levenshtein distance between two words. >>> levenshtein_distance(\\"kitten\\", \\"sitting\\") == 3 >>> levenshtein_distance(\\"flaw\\", \\"lawn\\") == 2 >>> levenshtein_distance(\\"algorithm\\", \\"altruistic\\") == 6 pass def find_closest_word(word: str, dictionary: List[str]) -> str: Finds the closest word in the dictionary to the given word based on Levenshtein distance. pass def spell_check(input_text: str, dictionary: List[str]) -> str: Checks the spelling of words in the input_text and corrects misspelled words. >>> spell_check('thes quikc brownn foxx', ['the', 'quick', 'brown', 'fox']) == 'the quick brown fox' >>> spell_check('the quick brown fox', ['the', 'quick', 'brown', 'fox']) == 'the quick brown fox' >>> spell_check('thee quuick brwn', ['the', 'quick', 'brown', 'fox']) == 'the quick brown' pass def update_dictionary(word: str, dictionary: List[str]) -> List[str]: Adds a new word to the dictionary if it does not already exist. >>> update_dictionary('jumps', ['the', 'quick', 'brown', 'fox']) == ['the', 'quick', 'brown', 'fox', 'jumps'] >>> update_dictionary('fox', ['the', 'quick', 'brown', 'fox']) == ['the', 'quick', 'brown', 'fox'] pass","solution":"def levenshtein_distance(word1, word2): Computes the Levenshtein distance between two words. len1, len2 = len(word1), len(word2) if len1 < len2: return levenshtein_distance(word2, word1) # len1 >= len2 previous_row = range(len2 + 1) for i, c1 in enumerate(word1): current_row = [i + 1] for j, c2 in enumerate(word2): insertions = previous_row[j + 1] + 1 deletions = current_row[j] + 1 substitutions = previous_row[j] + (c1 != c2) current_row.append(min(insertions, deletions, substitutions)) previous_row = current_row return previous_row[-1] def find_closest_word(word, dictionary): Finds the closest word in the dictionary to the given word based on Levenshtein distance. closest_word = None min_distance = float('inf') for dict_word in dictionary: distance = levenshtein_distance(word, dict_word) if distance < min_distance: min_distance = distance closest_word = dict_word return closest_word def spell_check(input_text, dictionary): Checks the spelling of words in the input_text and corrects misspelled words. words = input_text.split() corrected_words = [find_closest_word(word, dictionary) for word in words] corrected_text = ' '.join(corrected_words) return corrected_text def update_dictionary(word, dictionary): Adds a new word to the dictionary if it does not already exist. if word not in dictionary: dictionary.append(word) return dictionary"},{"question":"from typing import List def auto_correct(sentences: List[List[str]], dictionary: List[str]) -> List[List[str]]: Replace misspelled words in sentences with the closest matching word from the dictionary using Levenshtein distance. If multiple words have the same minimal distance, replace with the lexicographically smallest one. >>> sentences = [['speling', 'mistake', 'in', 'thes', 'sentense'], ['orrect', 'this', 'plea']] >>> dictionary = ['spelling', 'mistake', 'in', 'the', 'sentence', 'correct', 'this', 'please'] >>> auto_correct(sentences, dictionary) == [['spelling', 'mistake', 'in', 'the', 'sentence'], ['correct', 'this', 'please']] True >>> sentences = [['speling'], ['incorrectt'], ['missppelled']] >>> dictionary = ['spelling', 'incorrect', 'misspelled'] >>> auto_correct(sentences, dictionary) == [['spelling'], ['incorrect'], ['misspelled']] True >>> sentences = [['thes']] >>> dictionary = ['the', 'those', 'this'] >>> auto_correct(sentences, dictionary) == [['the']] True >>> sentences = [['this', 'sentence', 'is', 'correct']] >>> dictionary = ['this', 'sentence', 'is', 'correct'] >>> auto_correct(sentences, dictionary) == [['this', 'sentence', 'is', 'correct']] True >>> sentences = [['speling', 'mistake'] * 500] >>> dictionary = ['spelling', 'mistake', 'in', 'the', 'sentence', 'correct', 'this', 'please'] >>> auto_correct(sentences, dictionary) == [['spelling', 'mistake'] * 500] True pass","solution":"from typing import List from functools import lru_cache def levenshtein_distance(word1: str, word2: str) -> int: Calculate the Levenshtein distance between two words. @lru_cache(None) def distance(i, j): if i == 0: return j if j == 0: return i if word1[i - 1] == word2[j - 1]: return distance(i - 1, j - 1) return min(distance(i - 1, j) + 1, distance(i, j - 1) + 1, distance(i - 1, j - 1) + 1) return distance(len(word1), len(word2)) def auto_correct(sentences: List[List[str]], dictionary: List[str]) -> List[List[str]]: Replace misspelled words in sentences with the closest matching word from the dictionary using Levenshtein distance. If multiple words have the same minimal distance, replace with the lexicographically smallest one. corrected_sentences = [] for sentence in sentences: corrected_sentence = [] for word in sentence: min_distance = float('inf') correction = \\"\\" for dict_word in dictionary: dist = levenshtein_distance(word, dict_word) if dist < min_distance or (dist == min_distance and dict_word < correction): min_distance = dist correction = dict_word corrected_sentence.append(correction) corrected_sentences.append(corrected_sentence) return corrected_sentences"},{"question":"class Node: def __init__(self, key, left=None, right=None): self.key = key self.left = left self.right = right class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert_rec(self.root, key) def _insert_rec(self, node, key): if key < node.key: if node.left is None: node.left = Node(key) else: self._insert_rec(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert_rec(node.right, key) def find_minimum(self): Find the node with the minimum key in the Binary Search Tree. >>> bst = BinarySearchTree() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(1) >>> bst.insert(15) >>> bst.insert(12) >>> bst.find_minimum().key # Output should be the smallest key 1 >>> empty_bst = BinarySearchTree() >>> empty_bst.find_minimum() # Output should be None None pass # Your implementation goes here","solution":"class Node: def __init__(self, key, left=None, right=None): self.key = key self.left = left self.right = right class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert_rec(self.root, key) def _insert_rec(self, node, key): if key < node.key: if node.left is None: node.left = Node(key) else: self._insert_rec(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert_rec(node.right, key) def find_minimum(self): if self.root is None: return None current_node = self.root while current_node.left is not None: current_node = current_node.left return current_node"},{"question":"import threading from collections import deque class BoundedBlockingQueue: def __init__(self, capacity: int) -> None: Initialize your data structure here. - capacity : The maximum capacity of the queue. pass def enqueue(self, item: int) -> None: Add an item to the queue. If the queue is full, block until space becomes available. - item : Integer value to add to the queue. pass def dequeue(self) -> int: Remove and return an item from the queue. If the queue is empty, block until an item becomes available. - returns : Integer value removed from the queue. pass import threading import time def test_enqueue_dequeue(): bbq = BoundedBlockingQueue(2) bbq.enqueue(1) bbq.enqueue(2) assert bbq.dequeue() == 1 assert bbq.dequeue() == 2 def test_blocking_enqueue(): bbq = BoundedBlockingQueue(1) def producer(): bbq.enqueue(1) bbq.enqueue(2) def consumer(): time.sleep(1) assert bbq.dequeue() == 1 assert bbq.dequeue() == 2 prod_thread = threading.Thread(target=producer) cons_thread = threading.Thread(target=consumer) prod_thread.start() cons_thread.start() prod_thread.join() cons_thread.join() def test_blocking_dequeue(): bbq = BoundedBlockingQueue(1) def producer(): time.sleep(1) bbq.enqueue(1) def consumer(): assert bbq.dequeue() == 1 cons_thread = threading.Thread(target=consumer) prod_thread = threading.Thread(target=producer) cons_thread.start() prod_thread.start() cons_thread.join() prod_thread.join() def test_multiple_producers_consumers(): bbq = BoundedBlockingQueue(10) def producer(id): for i in range(5): bbq.enqueue(id * 10 + i) def consumer(): results = [] for _ in range(5): results.append(bbq.dequeue()) return results producers = [threading.Thread(target=producer, args=(i,)) for i in range(2)] consumers = [threading.Thread(target=consumer) for _ in range(2)] for p in producers: p.start() for c in consumers: c.start() for p in producers: p.join() for c in consumers: c.join() assert len(bbq.queue) == 0 # All consumed def test_thread_safety(): bbq = BoundedBlockingQueue(10) def producer(id): for i in range(100): bbq.enqueue(id * 100 + i) def consumer(): for _ in range(100): bbq.dequeue() producers = [threading.Thread(target=producer, args=(i,)) for i in range(10)] consumers = [threading.Thread(target=consumer) for _ in range(10)] for p in producers: p.start() for c in consumers: c.start() for p in producers: p.join() for c in consumers: c.join() assert len(bbq.queue) == 0 # All consumed","solution":"import threading from collections import deque class BoundedBlockingQueue: def __init__(self, capacity: int) -> None: self.capacity = capacity self.queue = deque() self.lock = threading.Lock() self.not_full = threading.Condition(self.lock) self.not_empty = threading.Condition(self.lock) def enqueue(self, item: int) -> None: with self.not_full: while len(self.queue) == self.capacity: self.not_full.wait() self.queue.append(item) self.not_empty.notify() def dequeue(self) -> int: with self.not_empty: while not self.queue: self.not_empty.wait() item = self.queue.popleft() self.not_full.notify() return item"},{"question":"def reformat_date(date: str) -> str: Reformat a date from \\"Day Month Year\\" to \\"YYYY-MM-DD\\". >>> reformat_date(\\"4 Jul 2021\\") \\"2021-07-04\\" >>> reformat_date(\\"12 Sep 1995\\") \\"1995-09-12\\" >>> reformat_date(\\"2 Jan 2000\\") \\"2000-01-02\\" >>> reformat_date(\\"31 Dec 1999\\") \\"1999-12-31\\" >>> reformat_date(\\"1 Mar 2010\\") \\"2010-03-01\\" >>> reformat_date(\\"9 Feb 1985\\") \\"1985-02-09\\" >>> reformat_date(\\"7 Aug 2020\\") \\"2020-08-07\\" >>> reformat_date(\\"10 Oct 2000\\") \\"2000-10-10\\" >>> reformat_date(\\"25 Dec 2025\\") \\"2025-12-25\\"","solution":"def reformat_date(date: str) -> str: Reformat a date from \\"Day Month Year\\" to \\"YYYY-MM-DD\\". month_mapping = { \\"Jan\\": \\"01\\", \\"Feb\\": \\"02\\", \\"Mar\\": \\"03\\", \\"Apr\\": \\"04\\", \\"May\\": \\"05\\", \\"Jun\\": \\"06\\", \\"Jul\\": \\"07\\", \\"Aug\\": \\"08\\", \\"Sep\\": \\"09\\", \\"Oct\\": \\"10\\", \\"Nov\\": \\"11\\", \\"Dec\\": \\"12\\" } day, month, year = date.split() day = day.zfill(2) month = month_mapping[month] return f\\"{year}-{month}-{day}\\""},{"question":"def calculate_difference(image1, image2): Calculate the total absolute pixel intensity difference between two images. Args: image1 (list of list of int): The first image. image2 (list of list of int): The second image. Returns: int: The total absolute pixel intensity difference. def find_closest_image(image_set, target_image): Find the image from the set that has the smallest difference to the target image. Args: image_set (list of list of list of int): Set of images. target_image (list of list of int): The target image. Returns: int: Index of the image in the image_set which is the closest match to the target image. # Examples of usage and expected results def example_usage(): image_set = [ [[0, 1, 2], [3, 4, 5], [6, 7, 8]], [[9, 10, 11], [12, 13, 14], [15, 16, 17]], [[18, 19, 20], [21, 22, 23], [24, 25, 26]] ] target_image = [[10, 10, 10], [10, 10, 10], [10, 10, 10]] closest_index = find_closest_image(image_set, target_image) print(closest_index) # Expected output: 1","solution":"def calculate_difference(image1, image2): Calculate the total absolute pixel intensity difference between two images. Args: image1 (list of list of int): The first image. image2 (list of list of int): The second image. Returns: int: The total absolute pixel intensity difference. difference = 0 for i in range(len(image1)): for j in range(len(image1[0])): difference += abs(image1[i][j] - image2[i][j]) return difference def find_closest_image(image_set, target_image): Find the image from the set that has the smallest difference to the target image. Args: image_set (list of list of list of int): Set of images. target_image (list of list of int): The target image. Returns: int: Index of the image in the image_set which is the closest match to the target image. min_difference = float('inf') min_index = -1 for index, image in enumerate(image_set): difference = calculate_difference(image, target_image) if difference < min_difference: min_difference = difference min_index = index return min_index"},{"question":"import heapq def dijkstra(num_nodes: int, edges: list[tuple[int, int, int]], start_node: int) -> list[int]: Calculate the shortest path in a directional weighted graph using Dijkstra's algorithm. Args: num_nodes (int): Number of nodes in the graph. edges (list of tuples): List of tuples (u, v, weight) representing directed edges. start_node (int): The starting node. Returns: list of int: List of shortest distances from the start_node to each node. Example: >>> dijkstra(5, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (3, 4, 7), (2, 5, 5)], 1) [0, 2, 3, 10, 7] >>> dijkstra(3, [(1, 2, 1), (2, 3, 2)], 1) [0, 1, 3] >>> dijkstra(4, [(1, 2, 1), (2, 3, 2), (3, 4, 3)], 2) [float('inf'), 0, 2, 5] pass def test_dijkstra_basic(): assert dijkstra(5, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (3, 4, 7), (2, 5, 5)], 1) == [0, 2, 3, 10, 7] assert dijkstra(3, [(1, 2, 1), (2, 3, 2)], 1) == [0, 1, 3] assert dijkstra(4, [(1, 2, 1), (2, 3, 2), (3, 4, 3)], 2) == [float('inf'), 0, 2, 5] def test_dijkstra_no_edges(): assert dijkstra(5, [], 1) == [0, float('inf'), float('inf'), float('inf'), float('inf')] def test_dijkstra_single_node(): assert dijkstra(1, [], 1) == [0] def test_dijkstra_disconnected(): assert dijkstra(4, [(1, 2, 4), (2, 3, 5)], 1) == [0, 4, 9, float('inf')] assert dijkstra(5, [(1, 2, 10), (2, 3, 25), (4, 5, 60)], 1) == [0, 10, 35, float('inf'), float('inf')] def test_dijkstra_large_weights(): assert dijkstra(3, [(1, 2, 10000000), (2, 3, 10000000)], 1) == [0, 10000000, 20000000] def test_dijkstra_zero_weights(): assert dijkstra(3, [(1, 2, 0), (2, 3, 0)], 1) == [0, 0, 0] assert dijkstra(3, [(1, 2, 1), (2, 3, 0)], 1) == [0, 1, 1]","solution":"import heapq def dijkstra(num_nodes: int, edges: list[tuple[int, int, int]], start_node: int) -> list[int]: Returns the list of shortest distances from the start_node to each node. # Initialize adjacency list adj_list = [[] for _ in range(num_nodes + 1)] for u, v, weight in edges: adj_list[u].append((v, weight)) # Initialize distances and priority queue distances = [float('inf')] * (num_nodes + 1) distances[start_node] = 0 priority_queue = [(0, start_node)] # (distance, node) while priority_queue: current_dist, current_node = heapq.heappop(priority_queue) if current_dist > distances[current_node]: continue for neighbor, weight in adj_list[current_node]: distance = current_dist + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) # Ignore index 0 as nodes are 1 based indexing return distances[1:]"},{"question":"class TreeNode: def __init__(self, value: int = 0, left: 'TreeNode' = None, right: 'TreeNode' = None): self.value = value self.left = left self.right = right from typing import List, Optional def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Performs level-order traversal on a binary tree. :param root: the root node of the binary tree. :return: a list of lists, each containing the values of the nodes at that level.","solution":"class TreeNode: def __init__(self, value: int = 0, left: 'TreeNode' = None, right: 'TreeNode' = None): self.value = value self.left = left self.right = right from typing import List, Optional from collections import deque def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"def word_break(s: str, wordDict: List[str]) -> bool: Check if a string can be segmented into words from a given dictionary. >>> word_break(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False >>> word_break(\\"cars\\", [\\"car\\", \\"ca\\", \\"rs\\"]) True >>> word_break(\\"apple\\", [\\"a\\", \\"b\\", \\"c\\"]) False","solution":"from typing import List def word_break(s: str, wordDict: List[str]) -> bool: dp = [False] * (len(s) + 1) dp[0] = True # Base case: an empty string can always be segmented for i in range(1, len(s) + 1): for word in wordDict: if dp[i - len(word)] and s[i - len(word):i] == word: dp[i] = True return dp[-1]"},{"question":"def has_balanced_triplets(s: str) -> bool: Checks if the string contains balanced triplets of parentheses (), braces {}, and brackets []. Parameters: s (str): The input string Returns: bool: True if the string contains balanced triplets, else False Raises: ValueError: If the input is not a string Examples: >>> has_balanced_triplets(\\"([{}])\\") True >>> has_balanced_triplets(\\"(([]){})\\") True >>> has_balanced_triplets(\\"([]){}\\") True >>> has_balanced_triplets(\\"(([]){}})\\") False >>> has_balanced_triplets(\\"(){}[]\\") True >>> has_balanced_triplets(\\"((){[[]]})\\") True >>> has_balanced_triplets(\\"([)]\\") False >>> has_balanced_triplets(\\"(({}[)\\") False >>> has_balanced_triplets(\\"()\\") False >>> has_balanced_triplets(\\"\\") False # Implement the function to check for balanced triplets def test_has_balanced_triplets_valid(): assert has_balanced_triplets(\\"([{}])\\") == True assert has_balanced_triplets(\\"(([]){})\\") == True assert has_balanced_triplets(\\"([]){}\\") == True assert has_balanced_triplets(\\"(){}[]\\") == True assert has_balanced_triplets(\\"((){[[]]})\\") == True def test_has_balanced_triplets_invalid(): assert has_balanced_triplets(\\"(([]){}})\\") == False assert has_balanced_triplets(\\"([)]\\") == False assert has_balanced_triplets(\\"(({}[)\\") == False assert has_balanced_triplets(\\"()\\") == False assert has_balanced_triplets(\\"\\") == False def test_invalid_input(): try: has_balanced_triplets(None) except ValueError as e: assert str(e) == \\"Input must be a string\\" try: has_balanced_triplets(100) except ValueError as e: assert str(e) == \\"Input must be a string\\" try: has_balanced_triplets([\\"[{}]\\"]) except ValueError as e: assert str(e) == \\"Input must be a string\\"","solution":"def has_balanced_triplets(s: str) -> bool: Checks if the string contains balanced triplets of parentheses (), braces {}, and brackets []. Parameters: s (str): The input string Returns: bool: True if the string contains balanced triplets, else False Raises: ValueError: If the input is not a string if not isinstance(s, str): raise ValueError(\\"Input must be a string\\") if len(s) < 6: # Minimum length to form one complete balanced set of triplets is 6. return False stack = [] pairs = {'(': ')', '[': ']', '{': '}'} open_brackets = set(pairs.keys()) close_brackets = set(pairs.values()) for char in s: if char in open_brackets: stack.append(char) elif char in close_brackets: if stack and pairs[stack[-1]] == char: stack.pop() else: return False # Check if the stack is empty and reduced to valid triplets length. return len(stack) == 0"},{"question":"class LinkedList: @classmethod def merge_sorted_linked_lists(cls, l1: 'LinkedList', l2: 'LinkedList') -> 'LinkedList': Merge two sorted linked lists into one sorted linked list. >>> l1 = LinkedList([1, 3, 5]) >>> l2 = LinkedList([2, 4, 6]) >>> result = LinkedList.merge_sorted_linked_lists(l1, l2) >>> tuple(result) (1, 2, 3, 4, 5, 6) >>> str(result) '1 -> 2 -> 3 -> 4 -> 5 -> 6' >>> l1 = LinkedList([1, 2, 3]) >>> l2 = LinkedList([4, 5, 6]) >>> result = LinkedList.merge_sorted_linked_lists(l1, l2) >>> tuple(result) (1, 2, 3, 4, 5, 6) >>> str(result) '1 -> 2 -> 3 -> 4 -> 5 -> 6' pass","solution":"class Node: def __init__(self, data=None): self.data = data self.next = None class LinkedList: def __init__(self, values=[]): self.head = None for value in values: self.append(value) def append(self, data): new_node = Node(data) if not self.head: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def __iter__(self): current = self.head while current: yield current.data current = current.next def __str__(self): return ' -> '.join(map(str, self)) @classmethod def merge_sorted_linked_lists(cls, l1, l2): dummy = Node() tail = dummy p1, p2 = l1.head, l2.head while p1 and p2: if p1.data < p2.data: tail.next = p1 p1 = p1.next else: tail.next = p2 p2 = p2.next tail = tail.next if p1: tail.next = p1 if p2: tail.next = p2 merged = cls() merged.head = dummy.next return merged"},{"question":"def book_room(bookings: dict, room_number: int, start_time: int, end_time: int) -> bool: Book a room for a specified time period if the time slot is available. Args: bookings (dict): A dictionary where keys are room numbers (integers) and values are lists of tuples, each tuple containing two integers representing the start and end times of a booking. room_number (int): An integer representing the room to be booked. start_time (int): An integer representing the starting hour of booking (24-hour format). end_time (int): An integer representing the ending hour of booking (24-hour format). Returns: bool: True if the room was successfully booked, else False. Example: >>> bookings = {} >>> book_room(bookings, 101, 10, 12) True >>> bookings {101: [(10, 12)]} >>> book_room(bookings, 101, 11, 13) False >>> bookings {101: [(10, 12)]} >>> book_room(bookings, 102, 15, 18) True >>> bookings {101: [(10, 12)], 102: [(15, 18)]} # Implement the function here...","solution":"def book_room(bookings: dict, room_number: int, start_time: int, end_time: int) -> bool: Function to book a room for a specified time period. The room should not be booked if the time slot overlaps with any existing booking. :param bookings: Dictionary with room numbers as keys and lists of (start_time, end_time) tuples as values. :param room_number: Integer representing the room to be booked. :param start_time: Integer representing the starting hour of the booking (24-hour format). :param end_time: Integer representing the ending hour of the booking (24-hour format). :return: True if the room was successfully booked, otherwise False. if start_time >= end_time: return False # Invalid time range # Initialize room booking list if it doesn't exist if room_number not in bookings: bookings[room_number] = [] # Check for overlapping bookings for (existing_start, existing_end) in bookings[room_number]: if not (end_time <= existing_start or start_time >= existing_end): return False # No overlapping bookings, so we can book the room bookings[room_number].append((start_time, end_time)) return True"},{"question":"def reverse_string(input_string, case_sensitive=True, check_palindrome=False): Reverse the given string with additional features and error handling. :param input_string: str: The string to be reversed :param case_sensitive: bool: If False, the function should ignore case and return result in lowercase :param check_palindrome: bool: If True, the function should also return whether the input is a palindrome :return: str or tuple of (str, bool): The reversed string, and optionally a boolean palindrome indicator >>> reverse_string(\\"Hello\\") \\"olleH\\" >>> reverse_string(\\"AbBa\\", case_sensitive=False) \\"abba\\" >>> reverse_string(\\"Madam\\", check_palindrome=True) (\\"madaM\\", False) >>> reverse_string(\\"Redder\\", check_palindrome=True) (\\"reddeR\\", True) >>> reverse_string(123) Traceback (most recent call last): ... TypeError: Invalid input: Input must be a string # Your implementation here","solution":"def reverse_string(input_string, case_sensitive=True, check_palindrome=False): Reverse the given string with additional features and error handling. :param input_string: str: The string to be reversed :param case_sensitive: bool: If False, the function should ignore case and return result in lowercase :param check_palindrome: bool: If True, the function should also return whether the input is a palindrome :return: str or tuple of (str, bool): The reversed string, and optionally a boolean palindrome indicator :raises TypeError: If the input is not a string if not isinstance(input_string, str): raise TypeError(\\"Invalid input: Input must be a string\\") reversed_string = input_string[::-1] if not case_sensitive: reversed_string = reversed_string.lower() input_string = input_string.lower() if check_palindrome: is_palindrome = (input_string == reversed_string) return reversed_string, is_palindrome return reversed_string"},{"question":"def quick_sort(nums: list[int]) -> list[int]: Sort a list of integers in ascending order using the QuickSort algorithm :param nums: List of integers to be sorted :return: Sorted list of integers Example: >>> quick_sort([3, 6, 8, 10, 1, 2, 1]) [1, 1, 2, 3, 6, 8, 10] >>> quick_sort([1, 9, 8, 7, 6, 5, 4, 3, 2, 1]) [1, 1, 2, 3, 4, 5, 6, 7, 8, 9]","solution":"def quick_sort(nums: list[int]) -> list[int]: Sort a list of integers in ascending order using the QuickSort algorithm :param nums: List of integers to be sorted :return: Sorted list of integers if len(nums) <= 1: return nums pivot = nums[len(nums) // 2] left = [x for x in nums if x < pivot] middle = [x for x in nums if x == pivot] right = [x for x in nums if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"Using two given sorted lists of integers, find the k-th smallest element in their combined sorted array. def find_kth_element(nums1: list[int], nums2: list[int], k: int) -> int: Find the k-th smallest element in the merged sorted array of two given sorted arrays. Args: nums1 (list[int]): A list of integers in non-decreasing order. nums2 (list[int]): A list of integers in non-decreasing order. k (int): An integer representing the index of the k-th smallest element in the merged array. Returns: int: The k-th smallest element in the merged array. if len(nums1) > len(nums2): return find_kth_element(nums2, nums1, k) if not nums1: return nums2[k-1] if k == 1: return min(nums1[0], nums2[0]) i = min(len(nums1), k // 2) j = min(len(nums2), k // 2) if nums1[i - 1] > nums2[j - 1]: return find_kth_element(nums1, nums2[j:], k - j) else: return find_kth_element(nums1[i:], nums2, k - i) # Unit Test from solution import find_kth_element def test_find_kth_element(): assert find_kth_element([1, 3, 5], [2, 4, 6], 4) == 4 assert find_kth_element([1, 2], [3, 4], 2) == 2 assert find_kth_element([0, 0], [0, 0], 3) == 0 assert find_kth_element([], [1], 1) == 1 assert find_kth_element([-1000], [1000], 2) == 1000 assert find_kth_element([-5, 3, 6], [-10, -3, 2], 5) == 3 assert find_kth_element([1, 2, 3, 4, 5, 6], [7, 8, 9, 10], 7) == 7 assert find_kth_element([1, 3, 5, 7, 9], [2, 4, 6, 8, 10], 10) == 10 assert find_kth_element([1, 1, 2, 2], [1, 1, 2, 2], 5) == 2 assert find_kth_element([2], [1, 3, 4, 5, 6], 3) == 3 assert find_kth_element([1, 2, 3], [4, 5, 6, 7, 8, 9, 10], 8) == 8 assert find_kth_element([10, 20, 30], [15, 25, 35, 45, 55, 65, 75], 5) == 30 assert find_kth_element([1], [1], 2) == 1","solution":"def find_kth_element(nums1: list[int], nums2: list[int], k: int) -> int: if len(nums1) > len(nums2): return find_kth_element(nums2, nums1, k) if not nums1: return nums2[k-1] if k == 1: return min(nums1[0], nums2[0]) i = min(len(nums1), k // 2) j = min(len(nums2), k // 2) if nums1[i - 1] > nums2[j - 1]: return find_kth_element(nums1, nums2[j:], k - j) else: return find_kth_element(nums1[i:], nums2, k - i)"},{"question":"from typing import List, Tuple, Dict def calculate_office_time(records: List[Tuple[int, str, str]]) -> Dict[int, int]: Calculate the total amount of time each employee spent in the office for a given day. >>> records = [ ... (1, \\"09:00\\", \\"arrive\\"), ... (1, \\"12:00\\", \\"depart\\"), ... (2, \\"09:30\\", \\"arrive\\"), ... (2, \\"17:00\\", \\"depart\\"), ... (1, \\"13:00\\", \\"arrive\\"), ... (1, \\"15:00\\", \\"depart\\"), ... (3, \\"10:00\\", \\"arrive\\"), ... (3, \\"11:30\\", \\"depart\\"), ... ] >>> calculate_office_time(records) {1: 300, 2: 450, 3: 90} pass def test_calculate_office_time(): records = [ (1, \\"09:00\\", \\"arrive\\"), (1, \\"12:00\\", \\"depart\\"), (2, \\"09:30\\", \\"arrive\\"), (2, \\"17:00\\", \\"depart\\"), (1, \\"13:00\\", \\"arrive\\"), (1, \\"15:00\\", \\"depart\\"), (3, \\"10:00\\", \\"arrive\\"), (3, \\"11:30\\", \\"depart\\"), ] result = calculate_office_time(records) expected = { 1: 300, # 180 minutes (09:00-12:00) + 120 minutes (13:00-15:00) 2: 450, # 450 minutes (09:30-17:00) 3: 90 # 90 minutes (10:00-11:30) } assert result == expected def test_calculate_office_time_single_record(): records = [ (1, \\"09:00\\", \\"arrive\\"), (1, \\"12:00\\", \\"depart\\"), ] result = calculate_office_time(records) expected = { 1: 180 # 180 minutes (09:00-12:00) } assert result == expected def test_calculate_office_time_multiple_employees(): records = [ (1, \\"09:00\\", \\"arrive\\"), (1, \\"12:00\\", \\"depart\\"), (2, \\"09:00\\", \\"arrive\\"), (2, \\"12:00\\", \\"depart\\"), (3, \\"09:00\\", \\"arrive\\"), (3, \\"12:00\\", \\"depart\\"), ] result = calculate_office_time(records) expected = { 1: 180, 2: 180, 3: 180, } assert result == expected def test_calculate_office_time_back_to_back_records(): records = [ (1, \\"09:00\\", \\"arrive\\"), (1, \\"11:00\\", \\"depart\\"), (1, \\"13:00\\", \\"arrive\\"), (1, \\"15:00\\", \\"depart\\"), (1, \\"16:00\\", \\"arrive\\"), (1, \\"18:00\\", \\"depart\\"), ] result = calculate_office_time(records) expected = { 1: 360, # 120 minutes (09:00-11:00) + 120 minutes (13:00-15:00) + 120 minutes (16:00-18:00) } assert result == expected","solution":"def calculate_office_time(records): from collections import defaultdict def to_minutes(timestamp): hours, minutes = map(int, timestamp.split(\\":\\")) return hours * 60 + minutes employee_time = defaultdict(int) last_arrival = {} for employee_id, timestamp, action in records: if action == \\"arrive\\": last_arrival[employee_id] = to_minutes(timestamp) elif action == \\"depart\\": if employee_id in last_arrival: duration = to_minutes(timestamp) - last_arrival[employee_id] employee_time[employee_id] += duration del last_arrival[employee_id] return dict(employee_time)"},{"question":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_sum(root: Optional[TreeNode]) -> int: Calculates the sum of all values of nodes using an in-order traversal of a binary tree. >>> root1 = TreeNode(1, None, TreeNode(2, TreeNode(3), None)) >>> inorder_sum(root1) 6 >>> root2 = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6, TreeNode(5), TreeNode(7))) >>> inorder_sum(root2) 28 >>> root3 = None >>> inorder_sum(root3) 0 >>> root4 = TreeNode(10) >>> inorder_sum(root4) 10 >>> root5 = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4)))) >>> inorder_sum(root5) 10 >>> root6 = TreeNode(1, None, TreeNode(2, None, TreeNode(3, None, TreeNode(4)))) >>> inorder_sum(root6) 10","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_sum(root: Optional[TreeNode]) -> int: Calculates the sum of all values of nodes using an in-order traversal of a binary tree. def inorder(node): if node is None: return 0 return inorder(node.left) + node.val + inorder(node.right) return inorder(root)"},{"question":"class GridPathCalculator: This class calculates the number of unique paths in an m x n grid. def __init__(self): pass def unique_paths(self, m: int, n: int) -> int: Calculate the number of unique paths from top-left to bottom-right in an m x n grid. >>> calculator = GridPathCalculator() >>> calculator.unique_paths(3, 7) # Output: 28 >>> calculator.unique_paths(3, 3) # Output: 6 >>> calculator.unique_paths(1, 1) # Output: 1","solution":"class GridPathCalculator: def __init__(self): pass def unique_paths(self, m: int, n: int) -> int: # Initialize a 2D list to store the number of paths to each cell dp = [[1] * n for _ in range(m)] for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def has_unique_characters(s: str) -> bool: Determines if all characters in the given string \`s\` are unique. Parameters: s (str): The input string containing only lowercase alphabetic characters. Returns: bool: True if all characters in \`s\` are unique, otherwise False. Examples: >>> has_unique_characters(\\"abcdef\\") True >>> has_unique_characters(\\"hello\\") False >>> has_unique_characters(\\"world\\") True >>> has_unique_characters(\\"character\\") False","solution":"def has_unique_characters(s: str) -> bool: Determines if all characters in the given string \`s\` are unique. Parameters: s (str): The input string containing only lowercase alphabetic characters. Returns: bool: True if all characters in \`s\` are unique, otherwise False. char_set = set() for char in s: if char in char_set: return False char_set.add(char) return True"},{"question":"def sort_dictionary_list(dict_list: list[dict], sort_key: str, reverse: bool = False) -> list[dict]: Sort a list of dictionaries based on a specified key. Args: dict_list (list[dict]): A list of dictionaries. sort_key (str): A string representing the key name to sort by. reverse (bool, optional): Boolean indicating if the sort should be in descending order. Defaults to False. Returns: list[dict]: A list of dictionaries sorted based on the values associated with sort_key. Raises: KeyError: If the sort_key is not found in any dictionary. >>> sort_dictionary_list([{\\"name\\": \\"Alice\\", \\"age\\": 25}, {\\"name\\": \\"Bob\\", \\"age\\": 30}, {\\"name\\": \\"Charlie\\", \\"age\\": 20}], \\"age\\") [{'name': 'Charlie', 'age': 20}, {'name': 'Alice', 'age': 25}, {'name': 'Bob', 'age': 30}] >>> sort_dictionary_list([{\\"name\\": \\"Alice\\", \\"age\\": 25}, {\\"name\\": \\"Bob\\", \\"age\\": 30}, {\\"name\\": \\"Charlie\\", \\"age\\": 20}], \\"name\\", True) [{'name': 'Charlie', 'age': 20}, {'name': 'Bob', 'age': 30}, {'name': 'Alice', 'age': 25}] >>> sort_dictionary_list([{\\"name\\": \\"Apple\\", \\"points\\": 10}, {\\"name\\": \\"Banana\\", \\"points\\": 5}, {\\"name\\": \\"Cherry\\", \\"points\\": 15}], \\"points\\") [{'name': 'Banana', 'points': 5}, {'name': 'Apple', 'points': 10}, {'name': 'Cherry', 'points': 15}] >>> sort_dictionary_list([{\\"name\\": \\"A\\", \\"value\\": 2}, {\\"name\\": \\"B\\", \\"value\\": 1}], \\"weight\\") Traceback (most recent call last): ... KeyError: 'Key not found in one or more dictionaries' >>> sort_dictionary_list([], \\"age\\") []","solution":"def sort_dictionary_list(dict_list: list[dict], sort_key: str, reverse: bool = False) -> list[dict]: Sorts a list of dictionaries based on a specified key. Args: dict_list (list of dict): The list of dictionaries to be sorted. sort_key (str): The key by which to sort the dictionaries. reverse (bool, optional): If True, sorts in descending order. Defaults to False. Returns: list of dict: The sorted list of dictionaries. Raises: KeyError: If the sort_key is not found in any of the dictionaries. # Check for the presence of the sort_key in each dictionary for d in dict_list: if sort_key not in d: raise KeyError(\\"Key not found in one or more dictionaries\\") # Sort the list of dictionaries by the specified key return sorted(dict_list, key=lambda x: x[sort_key], reverse=reverse)"},{"question":"def max_non_overlapping_appointments(appointments): Determine the maximum number of non-overlapping appointments. Parameters: appointments (list of tuples): A list where each tuple contains two integers representing the start and end times of an appointment. Returns: int: Maximum number of non-overlapping appointments that can be scheduled. # Sort appointments based on their end times appointments.sort(key=lambda x: x[1]) max_appointments = 0 last_end_time = -1 for start, end in appointments: if start >= last_end_time: max_appointments += 1 last_end_time = end return max_non_overlapping_appointments","solution":"def max_non_overlapping_appointments(appointments): Determine the maximum number of non-overlapping appointments. Parameters: appointments (list of tuples): A list where each tuple contains two integers representing the start and end times of an appointment. Returns: int: Maximum number of non-overlapping appointments that can be scheduled. # Sort appointments based on their end times appointments.sort(key=lambda x: x[1]) max_appointments = 0 last_end_time = -1 for start, end in appointments: if start >= last_end_time: max_appointments += 1 last_end_time = end return max_appointments"},{"question":"import json from datetime import datetime from typing import Optional, List, Dict class ToDoList: def __init__(self, file_path: str): Initialize the ToDoList with the path to the JSON file for persisting tasks. :param file_path: Path to the file where tasks will be saved and loaded from pass def add_task(self, description: str, due_date: Optional[str] = None) -> None: Add a new task with the given description and optional due date. :param description: Task description :param due_date: Optional due date for the task (format: \\"YYYY-MM-DD\\") pass def remove_task(self, task_id: int) -> None: Remove a task by its identifier. :param task_id: Unique identifier of the task to remove pass def list_tasks(self, filter_due_date: Optional[str] = None, filter_completed: Optional[bool] = None) -> List[Dict]: List all tasks, optionally filtering by due date or completion status. :param filter_due_date: Optional due date filter (format: \\"YYYY-MM-DD\\") :param filter_completed: Optional filter to list only completed or not completed tasks :return: A list of dictionaries, each representing a task pass def mark_task_completed(self, task_id: int) -> None: Mark a specific task as completed. :param task_id: Unique identifier of the task to mark as completed pass def save_tasks(self) -> None: Save tasks to the JSON file for persistence. pass def load_tasks(self) -> None: Load tasks from the JSON file. pass","solution":"import json from datetime import datetime from typing import Optional, List, Dict class ToDoList: def __init__(self, file_path: str): self.file_path = file_path self.tasks = [] self.load_tasks() def add_task(self, description: str, due_date: Optional[str] = None) -> None: new_task = { 'id': len(self.tasks) + 1, 'description': description, 'due_date': due_date, 'completed': False } self.tasks.append(new_task) self.save_tasks() def remove_task(self, task_id: int) -> None: self.tasks = [task for task in self.tasks if task['id'] != task_id] self.save_tasks() def list_tasks(self, filter_due_date: Optional[str] = None, filter_completed: Optional[bool] = None) -> List[Dict]: filtered_tasks = self.tasks if filter_due_date: filtered_tasks = [task for task in filtered_tasks if task['due_date'] == filter_due_date] if filter_completed is not None: filtered_tasks = [task for task in filtered_tasks if task['completed'] == filter_completed] return filtered_tasks def mark_task_completed(self, task_id: int) -> None: for task in self.tasks: if task['id'] == task_id: task['completed'] = True self.save_tasks() def save_tasks(self) -> None: with open(self.file_path, 'w') as file: json.dump(self.tasks, file) def load_tasks(self) -> None: try: with open(self.file_path, 'r') as file: self.tasks = json.load(file) except FileNotFoundError: self.tasks = []"},{"question":"from typing import List def sorted_permutations(s: str) -> list: Generates and returns a sorted list of all permutations of the input string. >>> sorted_permutations(\\"abc\\") [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> sorted_permutations(\\"a\\") [\\"a\\"] >>> sorted_permutations(\\"ab\\") [\\"ab\\", \\"ba\\"] >>> sorted_permutations(\\"aba\\") [\\"aab\\", \\"aba\\", \\"baa\\"] >>> sorted_permutations(\\"xyz\\") [\\"xyz\\", \\"xzy\\", \\"yxz\\", \\"yzx\\", \\"zxy\\", \\"zyx\\"]","solution":"from itertools import permutations def sorted_permutations(s: str) -> list: Generates and returns a sorted list of all permutations of the input string. Args: s (str): A string consisting of lowercase English letters. (1 <= len(s) <= 8) Returns: list: A list of all permutations of the input string \`s\`, sorted in lexicographical order. all_permutations = set(permutations(s)) sorted_perm_list = sorted(''.join(p) for p in all_permutations) return sorted_perm_list"},{"question":"from typing import List def rotated_binary_search(nums: List[int], target: int) -> int: Searches for a target value within a rotated sorted array and returns the position (index) of the target if found, otherwise -1. >>> rotated_binary_search([4, 5, 6, 7, 0, 1, 2], 0) == 4 >>> rotated_binary_search([4, 5, 6, 7, 0, 1, 2], 3) == -1 >>> rotated_binary_search([1], 0) == -1 >>> rotated_binary_search([1], 1) == 0 >>> rotated_binary_search([5, 6, 7, 8, 9, 1, 2, 3], 6) == 1 pass","solution":"from typing import List def rotated_binary_search(nums: List[int], target: int) -> int: Searches for a target value within a rotated sorted array and returns the position (index) of the target if found, otherwise -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid # Identify the sorted part of the array if nums[left] <= nums[mid]: # Left part is sorted if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # Right part is sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def get_pascals_triangle_row(k: int) -> list: Given a non-negative integer \`k\`, generate the \`k-th\` (0-based) row of Pascal's Triangle. >>> get_pascals_triangle_row(0) [1] >>> get_pascals_triangle_row(3) [1, 3, 3, 1] >>> get_pascals_triangle_row(5) [1, 5, 10, 10, 5, 1] from solution import get_pascals_triangle_row def test_row_zero(): assert get_pascals_triangle_row(0) == [1] def test_row_one(): assert get_pascals_triangle_row(1) == [1, 1] def test_row_two(): assert get_pascals_triangle_row(2) == [1, 2, 1] def test_row_three(): assert get_pascals_triangle_row(3) == [1, 3, 3, 1] def test_row_four(): assert get_pascals_triangle_row(4) == [1, 4, 6, 4, 1] def test_row_five(): assert get_pascals_triangle_row(5) == [1, 5, 10, 10, 5, 1] def test_max_row(): assert get_pascals_triangle_row(33) == [1, 33, 528, 5456, 40920, 237336, 1107568, 4272048, 13884156, 38567100, 92561040, 193536720, 354817320, 573166440, 818809200, 1037158320, 1166803110, 1166803110, 1037158320, 818809200, 573166440, 354817320, 193536720, 92561040, 38567100, 13884156, 4272048, 1107568, 237336, 40920, 5456, 528, 33, 1]","solution":"def get_pascals_triangle_row(k: int) -> list: Returns the k-th row of Pascal's Triangle. if k == 0: return [1] row = [1] for i in range(1, k + 1): row.append(row[-1] * (k - i + 1) // i) return row"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def binary_tree_to_doubly_linked_list(root: TreeNode) -> TreeNode: Convert the binary tree rooted at 'root' to a double-linked list in-place. Return the head of the double-linked list. >>> tree = TreeNode(4) >>> tree.left = TreeNode(2) >>> tree.right = TreeNode(5) >>> tree.left.left = TreeNode(1) >>> tree.left.right = TreeNode(3) >>> head = binary_tree_to_doubly_linked_list(tree) >>> current = head >>> while current: ... print(current.value, end=\\" <-> \\" if current.right else \\"n\\") ... current = current.right 1 <-> 2 <-> 3 <-> 4 <-> 5","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def binary_tree_to_doubly_linked_list(root: TreeNode) -> TreeNode: Convert the binary tree rooted at 'root' to a double-linked list in-place. Return the head of the double-linked list. if not root: return None # Helper function to perform in-order traversal and link nodes def convert(node): nonlocal prev, head if not node: return # Left convert(node.left) # Node if prev: prev.right = node node.left = prev else: head = node prev = node # Right convert(node.right) prev, head = None, None convert(root) return head"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def binary_tree_traversal(root): Perform Inorder, Preorder, and Postorder traversal on a binary tree. Given the root node of a binary tree, returns three lists representing the Inorder, Preorder, and Postorder traversal sequences of the tree. >>> root = TreeNode(1) ... root.left = TreeNode(2) ... root.right = TreeNode(3) ... root.left.left = TreeNode(4) ... root.left.right = TreeNode(5) ... ... inorder_list, preorder_list, postorder_list = binary_tree_traversal(root) >>> assert inorder_list == [4, 2, 5, 1, 3] >>> assert preorder_list == [1, 2, 4, 5, 3] >>> assert postorder_list == [4, 5, 2, 3, 1] # Your implementation goes here pass","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def binary_tree_traversal(root): def inorder(node): return inorder(node.left) + [node.val] + inorder(node.right) if node else [] def preorder(node): return [node.val] + preorder(node.left) + preorder(node.right) if node else [] def postorder(node): return postorder(node.left) + postorder(node.right) + [node.val] if node else [] return (inorder(root), preorder(root), postorder(root))"},{"question":"def validate_parentheses(s: str) -> bool: Validates if a string of parentheses is properly balanced. Parameters: - s: A string containing only the characters '(' and ')'. Returns: - A boolean indicating whether the string is balanced. >>> validate_parentheses(\\"()\\") == True >>> validate_parentheses(\\"(())\\") == True >>> validate_parentheses(\\"(()\\") == False >>> validate_parentheses(\\")(\\") == False >>> validate_parentheses(\\"((()))\\") == True >>> validate_parentheses(\\"\\") == True >>> validate_parentheses(\\"(\\") == False >>> validate_parentheses(\\")\\") == False >>> validate_parentheses(\\"()()\\") == True >>> validate_parentheses(\\"(())()\\") == True >>> validate_parentheses(\\"((())\\") == False >>> validate_parentheses(\\"(()))\\") == False >>> validate_parentheses(\\"((((()))))\\") == True >>> validate_parentheses(\\"(((((()))\\") == False >>> validate_parentheses(\\"(()))(()\\") == False","solution":"def validate_parentheses(s: str) -> bool: Validates if a string of parentheses is properly balanced. Parameters: - s: A string containing only the characters '(' and ')'. Returns: - A boolean indicating whether the string is balanced. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return not stack"},{"question":"import os import shutil from pathlib import Path def sync_directories(source: str, target: str) -> dict: Synchronize the contents of the target directory with the source directory. Parameters: source (str): the source directory path. target (str): the target directory path. Returns: dict[str, str]: a dictionary with file paths as keys and messages indicating the result of the sync operation. >>> sync_directories(\\"/path/to/source_dir\\", \\"/path/to/target_dir\\") {\\"file1.txt\\": \\"Copied\\", \\"file2.txt\\": \\"Updated\\", \\"file3.txt\\": \\"Removed\\", \\"new_file.txt\\": \\"Copied\\"} pass","solution":"import os import shutil from pathlib import Path def sync_directories(source: str, target: str) -> dict: Synchronize the contents of the target directory with the source directory. Parameters: source (str): the source directory path. target (str): the target directory path. Returns: dict[str, str]: a dictionary with file paths as keys and messages indicating the result of the sync operation. result = {} # Collect all files in the source directory source_files = {} for dirpath, _, filenames in os.walk(source): for file in filenames: full_path = os.path.join(dirpath, file) rel_path = os.path.relpath(full_path, source) source_files[rel_path] = full_path # Collect all files in the target directory target_files = {} for dirpath, _, filenames in os.walk(target): for file in filenames: full_path = os.path.join(dirpath, file) rel_path = os.path.relpath(full_path, target) target_files[rel_path] = full_path # Synchronize files from source to target for rel_path, source_file in source_files.items(): target_file = os.path.join(target, rel_path) if not os.path.exists(target_file): # Copy new file os.makedirs(os.path.dirname(target_file), exist_ok=True) shutil.copy2(source_file, target_file) result[rel_path] = \\"Copied\\" else: # Compare modification times src_mtime = os.path.getmtime(source_file) tgt_mtime = os.path.getmtime(target_file) if src_mtime > tgt_mtime: # Update file shutil.copy2(source_file, target_file) result[rel_path] = \\"Updated\\" # Remove files from target that are not present in source for rel_path in target_files.keys(): if rel_path not in source_files: os.remove(target_files[rel_path]) result[rel_path] = \\"Removed\\" return result"},{"question":"from typing import List def rotate_array(nums: List[int], k: int) -> None: Rotates the array nums to the right by k steps in place. Parameters: nums (List[int]): A list of integers. k (int): A non-negative integer representing the number of steps to rotate the array. Example Usage: >>> nums = [1, 2, 3, 4, 5, 6, 7] >>> rotate_array(nums, 3) >>> print(nums) [5, 6, 7, 1, 2, 3, 4] >>> nums = [-1, -100, 3, 99] >>> rotate_array(nums, 2) >>> print(nums) [3, 99, -1, -100]","solution":"from typing import List def rotate_array(nums: List[int], k: int) -> None: Rotates the array nums to the right by k steps in place. n = len(nums) k = k % n # Handle cases where k is larger than the length of nums def reverse(start: int, end: int) -> None: Reverse the elements of nums between start and end inclusive. while start < end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1 # When k is 0, no need to rotate if k == 0: return # Reverse the whole array reverse(0, n - 1) # Reverse the first k elements reverse(0, k - 1) # Reverse the elements from k to the end of the array reverse(k, n - 1)"},{"question":"def shortest_path_avoiding_obstacles( start: tuple[int, int], end: tuple[int, int], obstacles: list[tuple[int, int]] ) -> list[tuple[int, int]]: Calculate the shortest path between two points on a 2D grid while avoiding static obstacles. Args: - start (tuple): Starting coordinates (x, y). - end (tuple): Ending coordinates (x, y). - obstacles (list): List of tuples representing static obstacle coordinates (x, y). Returns: - list: List of tuples representing the coordinates of the shortest path from start to end, inclusive. If no path exists, returns an empty list. >>> shortest_path_avoiding_obstacles((0, 0), (2, 2), [(1, 1)]) [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)] >>> shortest_path_avoiding_obstacles((0, 0), (2, 2), [(0, 1), (1, 0), (1, 1)]) [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)] >>> shortest_path_avoiding_obstacles((0, 0), (1, 1), [(0, 1), (1, 0), (1, 1)]) [] pass from solution import shortest_path_avoiding_obstacles def test_no_obstacles(): assert shortest_path_avoiding_obstacles((0, 0), (2, 2), []) == [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)] def test_with_obstacles_blocking_straight_path(): assert shortest_path_avoiding_obstacles((0, 0), (2, 2), [(1, 1)]) == [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)] def test_no_path_due_to_obstacles(): assert shortest_path_avoiding_obstacles((0, 0), (1, 1), [(0, 1), (1, 0), (1, 1)]) == [] def test_start_equal_end(): assert shortest_path_avoiding_obstacles((0, 0), (0, 0), []) == [(0, 0)] def test_end_at_obstacle(): assert shortest_path_avoiding_obstacles((0, 0), (1, 1), [(1, 1)]) == [] def test_complex_path(): assert shortest_path_avoiding_obstacles((0, 0), (2, 0), [(1, 0)]) == [(0, 0), (0, 1), (1, 1), (2, 1), (2, 0)]","solution":"from collections import deque def shortest_path_avoiding_obstacles(start, end, obstacles): Calculates the shortest path from start to end on a 2D grid avoiding static obstacles. Args: - start (tuple): Starting coordinates (x, y). - end (tuple): Ending coordinates (x, y). - obstacles (list): List of tuples representing static obstacle coordinates (x, y). Returns: - list: List of tuples representing the shortest path from start to end, inclusive. If no path exists, returns an empty list. if start == end: return [start] obstacles_set = set(obstacles) if start in obstacles_set or end in obstacles_set: return [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # (up, right, down, left) visited = set() queue = deque([(start, [start])]) while queue: (current, path) = queue.popleft() for direction in directions: neighbor = (current[0] + direction[0], current[1] + direction[1]) if neighbor == end: return path + [end] if neighbor not in obstacles_set and neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return []"},{"question":"def round_off(x: float) -> int: Custom round-off function to round a float to the nearest integer. If the fractional part is exactly 0.5, it rounds to the nearest even integer. Examples: >>> round_off(1.1) 1 >>> round_off(1.5) 2 >>> round_off(2.5) 2 >>> round_off(-1.1) -1 >>> round_off(-1.5) -2 >>> round_off(1.0) 1 >>> round_off(-1.0) -1 >>> round_off(0.0) 0 >>> round_off(1000000000.5) 1000000000 # Unit tests to test your implementation def test_positive_non_half_fraction(): assert round_off(1.1) == 1 def test_negative_non_half_fraction(): assert round_off(-1.1) == -1 def test_positive_half_fraction(): assert round_off(1.5) == 2 def test_negative_half_fraction(): assert round_off(-1.5) == -2 def test_positive_even_half_fraction(): assert round_off(2.5) == 2 def test_negative_even_half_fraction(): assert round_off(-2.5) == -2 def test_zero(): assert round_off(0.0) == 0 def test_positive_whole_number(): assert round_off(1.0) == 1 def test_negative_whole_number(): assert round_off(-1.0) == -1 def test_large_number_with_half_fraction(): assert round_off(1_000_000_000.5) == 1_000_000_000 def test_small_positive_number(): assert round_off(0.0001) == 0 def test_large_positive_number(): assert round_off(123456789.9) == 123456790 def test_edge_case_just_below_half(): assert round_off(2.499999999) == 2 def test_edge_case_negative_just_below_half(): assert round_off(-2.499999999) == -2","solution":"def round_off(x: float) -> int: Custom round-off function to round a float to the nearest integer. If the fractional part is exactly 0.5, it rounds to the nearest even integer. integer_part = int(x) fractional_part = x - integer_part if fractional_part > 0.5 or (fractional_part == 0.5 and integer_part % 2 != 0): return integer_part + 1 elif fractional_part < -0.5 or (fractional_part == -0.5 and integer_part % 2 != 0): return integer_part - 1 else: return integer_part"},{"question":"from typing import Dict, List def has_cycle(graph: Dict[int, List[int]]) -> bool: Detect if there is a cycle in an undirected graph represented using an adjacency list. >>> has_cycle({ ... 0: [1, 2], ... 1: [0, 2], ... 2: [0, 1, 3], ... 3: [2, 4], ... 4: [3] ... }) True >>> has_cycle({ ... 0: [1], ... 1: [0, 2], ... 2: [1, 3], ... 3: [2, 4], ... 4: [3] ... }) False def test_has_cycle(): graph1 = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2, 4], 4: [3] } assert has_cycle(graph1) == True def test_no_cycle(): graph2 = { 0: [1], 1: [0, 2], 2: [1, 3], 3: [2, 4], 4: [3] } assert has_cycle(graph2) == False def test_disconnected_graph_cycle(): graph3 = { 0: [1], 1: [0], 2: [3, 4], 3: [2, 4], 4: [2, 3] } assert has_cycle(graph3) == True def test_single_node_no_cycle(): graph4 = { 0: [] } assert has_cycle(graph4) == False def test_single_edge_no_cycle(): graph5 = { 0: [1], 1: [0] } assert has_cycle(graph5) == False def test_empty_graph(): graph6 = {} assert has_cycle(graph6) == False def test_complex_graph_with_cycle(): graph7 = { 0: [1, 3], 1: [0, 2], 2: [1, 3, 4], 3: [0, 2], 4: [2, 5], 5: [4] } assert has_cycle(graph7) == True def test_complex_graph_without_cycle(): graph8 = { 0: [1, 3], 1: [0, 2], 2: [1, 4], 3: [0], 4: [2, 5], 5: [4] } assert has_cycle(graph8) == False","solution":"from typing import Dict, List def has_cycle(graph: Dict[int, List[int]]) -> bool: def dfs(node, parent): visited.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor, node): return True elif parent != neighbor: return True return False visited = set() for node in graph: if node not in visited: if dfs(node, -1): return True return False"},{"question":"def validate_iban(iban: str) -> bool: Validates an IBAN according to the ISO 13616 standard. Parameters: iban (str): The IBAN number as a string. Returns: bool: True if the IBAN is valid, False otherwise. Examples: >>> validate_iban(\\"GB82WEST12345698765432\\") True >>> validate_iban(\\"DE89370400440532013000\\") True >>> validate_iban(\\"GB82TEST12345698765432\\") False","solution":"def validate_iban(iban: str) -> bool: Validates an IBAN according to the ISO 13616 standard. Parameters: iban (str): The IBAN number as a string. Returns: bool: True if the IBAN is valid, False otherwise. # Move the first four characters to the end of the iban rearranged = iban[4:] + iban[:4] # Replace each letter in the rearranged IBAN with two digits expanded_iban = '' for char in rearranged: if char.isdigit(): expanded_iban += char else: expanded_iban += str(ord(char) - 55) # 'A' is 65 in ASCII, so 'A' -> 10, 'B' -> 11, ..., 'Z' -> 35 # Convert the expanded IBAN into an integer iban_as_int = int(expanded_iban) # Perform the modulo 97 operation return iban_as_int % 97 == 1"},{"question":"def is_seat_available(layout, row, col): Check if the seat at the specified row and column is available. :param layout: 2D list representing the seating layout :param row: Row index of the seat :param col: Column index of the seat :return: True if the seat is available, False otherwise pass def book_seat(layout, row, col): Book the seat at the specified row and column if it is available. :param layout: 2D list representing the seating layout :param row: Row index of the seat :param col: Column index of the seat :return: True if the seat was successfully booked, False otherwise pass def test_is_seat_available(): layout = [[0, 1, 0], [1, 0, 0], [0, 0, 1]] assert is_seat_available(layout, 0, 2) == True assert is_seat_available(layout, 1, 0) == False assert is_seat_available(layout, 2, 1) == True assert is_seat_available(layout, 2, 2) == False def test_book_seat(): layout = [[0, 1, 0], [1, 0, 0], [0, 0, 1]] assert book_seat(layout, 2, 0) == True assert layout[2][0] == 1 # Ensure the seat is now booked assert book_seat(layout, 1, 0) == False assert book_seat(layout, 2, 2) == False assert book_seat(layout, 1, 1) == True assert layout[1][1] == 1 # Ensure the seat is now booked # Run the tests test_is_seat_available() test_book_seat()","solution":"def is_seat_available(layout, row, col): Check if the seat at the specified row and column is available. :param layout: 2D list representing the seating layout :param row: Row index of the seat :param col: Column index of the seat :return: True if the seat is available, False otherwise if layout[row][col] == 0: return True return False def book_seat(layout, row, col): Book the seat at the specified row and column if it is available. :param layout: 2D list representing the seating layout :param row: Row index of the seat :param col: Column index of the seat :return: True if the seat was successfully booked, False otherwise if layout[row][col] == 0: layout[row][col] = 1 return True return False"},{"question":"def track_attendance(log: list, new_entry: tuple) -> dict: Adds new attendance entry to the log and generates a summary report. Parameters: - log (list): The existing log of attendance entries. Each entry is a tuple containing: (student_id (int), course_id (int), is_present (bool)) - new_entry (tuple): A new entry to be added to the log. It is structured in the same format as log entries. Returns: - dict: A summary report of attendance containing: - student_id: Total number of days present across all courses.","solution":"def track_attendance(log: list, new_entry: tuple) -> dict: Adds new attendance entry to the log and generates a summary report. Parameters: - log (list): The existing log of attendance entries. Each entry is a tuple containing: (student_id (int), course_id (int), is_present (bool)) - new_entry (tuple): A new entry to be added to the log. It is structured in the same format as log entries. Returns: - dict: A summary report of attendance containing: - student_id: Total number of days present across all courses. # Basic validity checks if (not isinstance(new_entry, tuple) or len(new_entry) != 3): raise ValueError(\\"new_entry must be a tuple containing (student_id, course_id, is_present)\\") student_id, course_id, is_present = new_entry if (not isinstance(student_id, int) or not isinstance(course_id, int) or student_id <= 0 or course_id <= 0): raise ValueError(\\"student_id and course_id must be positive integers.\\") if not isinstance(is_present, bool): raise ValueError(\\"is_present must be a boolean value.\\") # Add the new entry to the log log.append(new_entry) # Create a summary report summary = {} for entry in log: student_id, _, is_present = entry if student_id not in summary: summary[student_id] = 0 if is_present: summary[student_id] += 1 return summary"},{"question":"import requests def fetch_crypto_prices(api_url: str, retries: int=3) -> dict: Fetches cryptocurrency prices from an alternative API with retry mechanism. Args: - api_url (str): The URL of the API to fetch data from. - retries (int): The number of retries for failed requests. Returns: - dict: A dictionary containing the cryptocurrency prices and historical data. pass def calculate_average_price(prices: list) -> float: Calculates the average price given a list of price data with timestamps. Args: - prices (list): A list of dictionaries with 'timestamp' and 'price' keys. Returns: - float: The average price. pass def display_prices(api_url: str): Displays the current and historical average prices of cryptocurrencies. Args: - api_url (str): The URL of the API to fetch data from. pass # Example usage # The actual URL and structure of the response should conform to the chosen alternative API api_url = \\"https://alternative-api.com/cryptocurrencies\\" display_prices(api_url)","solution":"import requests from datetime import datetime, timedelta def fetch_crypto_prices(api_url, retries=3): Fetches cryptocurrency prices from an alternative API with retry mechanism. Args: - api_url (str): The URL of the API to fetch data from. - retries (int): The number of retries for failed requests. Returns: - dict: A dictionary containing the cryptocurrency prices and historical data. attempt = 0 while attempt < retries: try: response = requests.get(api_url) response.raise_for_status() return response.json() except requests.RequestException as e: print(f\\"Request failed: {e}, attempt {attempt + 1} of {retries}\\") attempt += 1 raise Exception(\\"Failed to fetch data after multiple attempts\\") def calculate_average_price(prices): Calculates the average price given a list of price data with timestamps. Args: - prices (list): A list of dictionaries with 'timestamp' and 'price' keys. Returns: - float: The average price. if not prices: return 0.0 total_price = 0 count = 0 for data in prices: total_price += data.get('price', 0) count += 1 return total_price / count if count else 0 def display_prices(api_url): Displays the current and historical average prices of cryptocurrencies. Args: - api_url (str): The URL of the API to fetch data from. try: data = fetch_crypto_prices(api_url) if 'cryptocurrencies' not in data: raise ValueError(\\"Invalid data format received from API\\") for crypto in data['cryptocurrencies']: name = crypto.get('name', 'N/A') current_price = crypto.get('current_price', 'N/A') historical_prices = crypto.get('historical_prices', []) avg_price = calculate_average_price(historical_prices) print(f\\"Name: {name}\\") print(f\\"Current Price: {current_price}\\") print(f\\"Average Historical Price: {avg_price}\\") print(\\"-\\" * 30) except Exception as e: print(f\\"Error displaying prices: {e}\\") # Example usage # The actual URL and structure of the response should conform to the chosen alternative API api_url = \\"https://alternative-api.com/cryptocurrencies\\" display_prices(api_url)"},{"question":"def sum_odd_indexed_elements(lst: list[int]) -> int: Calculate the sum of elements that are located at odd indices in the given list. :param lst: The list of integers. :return: The sum of integers at odd indices. >>> sum_odd_indexed_elements([1, 2, 3, 4, 5]) 6 >>> sum_odd_indexed_elements([10]) 0 >>> sum_odd_indexed_elements([0, -1, 3, -2, 5]) -3 >>> sum_odd_indexed_elements([]) 0","solution":"def sum_odd_indexed_elements(lst: list[int]) -> int: Calculate the sum of elements that are located at odd indices in the given list. :param lst: The list of integers. :return: The sum of integers at odd indices. return sum(lst[i] for i in range(1, len(lst), 2))"},{"question":"def is_prime(n: int) -> bool: Determines if a number n is prime. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(13) True >>> is_prime(15) False pass def primes_in_range(lower_bound: int, upper_bound: int) -> list[int]: Returns all prime numbers within the specified range in descending order. >>> primes_in_range(10, 50) [47, 43, 41, 37, 31, 29, 23, 19, 17, 13, 11] >>> primes_in_range(50, 10) [] >>> primes_in_range(1, 10) [7, 5, 3, 2] >>> primes_in_range(20, 22) [] >>> primes_in_range(17, 17) [17] pass","solution":"def is_prime(n: int) -> bool: Determines if a number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def primes_in_range(lower_bound: int, upper_bound: int) -> list[int]: Returns all prime numbers within the specified range in descending order. if lower_bound > upper_bound: return [] primes = [] for num in range(lower_bound, upper_bound + 1): if is_prime(num): primes.append(num) return primes[::-1]"},{"question":"A company is developing a new app and you have been tasked with implementing one of its functionalities. The app manages a list of tasks, where each task has a unique \`ID\` and \`priority\`. The \`priority\` of a task is an integer that indicates its importance, with a lower number indicating higher priority. You need to create a system that can perform the following operations efficiently: 1. Add a new task. 2. Delete a task by its \`ID\`. 3. Retrieve the task with the highest priority (the lowest priority value). 4. List all tasks sorted by priority. Implement the functionality as described in the following input format. It is guaranteed that all task IDs are unique. Input The first line contains an integer \`n\` (1 ≤ n ≤ 100,000) — the number of operations. Each of the following \`n\` lines describes an operation in one of the following formats: - \`ADD id priority\` — add a new task with the given \`id\` and \`priority\`. - \`DELETE id\` — delete the task with the given \`id\`. - \`GET\` — retrieve the task with the highest priority, and print its \`id\`. If there are multiple tasks with the same highest priority, print the \`id\` of any one of them. If there are no tasks, print \\"None\\". - \`LIST\` — list all tasks sorted by priority from highest to lowest. Print each task's \`id\` and \`priority\` separated by a space on a new line. Output For each \`GET\` operation, print the \`id\` of the task with the highest priority, or \\"None\\" if there are no tasks. For each \`LIST\` operation, print the list of tasks sorted by priority from highest to lowest. Each task should be printed on a new line as \`id priority\`. Example Input 8 ADD 1 2 ADD 2 1 ADD 3 3 GET LIST DELETE 2 GET LIST Output 2 2 1 1 2 3 3 1 1 2 3 3 Explanation Initially, three tasks are added with the priorities in the order: \`(2: 1)\`, \`(1: 2)\`, and \`(3: 3)\`. 1. The first \`GET\` operation returns the \`id\` of the task with the highest priority (2). 2. The \`LIST\` operation prints the tasks sorted by their priorities: Task \`2 (priority 1)\`, Task \`1 (priority 2)\`, and Task \`3 (priority 3)\`. 3. After deleting the task with \`id 2\`, the second \`GET\` operation returns task \`1\` (the new highest priority task with priority 2). 4. The final \`LIST\` operation prints the remaining tasks: Task \`1 (priority 2)\` and Task \`3 (priority 3)\`. Implement the functionality that reads the input, processes the operations, and produces the required output.","solution":"import heapq class TaskManager: def __init__(self): self.tasks = {} self.priority_queue = [] def add_task(self, task_id, priority): if task_id not in self.tasks: self.tasks[task_id] = priority heapq.heappush(self.priority_queue, (priority, task_id)) def delete_task(self, task_id): if task_id in self.tasks: del self.tasks[task_id] def get_highest_priority(self): while self.priority_queue: priority, task_id = self.priority_queue[0] if task_id in self.tasks and self.tasks[task_id] == priority: return task_id heapq.heappop(self.priority_queue) return \\"None\\" def list_tasks(self): sorted_tasks = sorted(self.tasks.items(), key=lambda x: (x[1], x[0])) return sorted_tasks # Example function to process a list of operations def process_operations(operations): manager = TaskManager() results = [] for operation in operations: parts = operation.split() op = parts[0] if op == \\"ADD\\": task_id = int(parts[1]) priority = int(parts[2]) manager.add_task(task_id, priority) elif op == \\"DELETE\\": task_id = int(parts[1]) manager.delete_task(task_id) elif op == \\"GET\\": result = manager.get_highest_priority() results.append(result) elif op == \\"LIST\\": task_list = manager.list_tasks() task_lines = [f\\"{task_id} {priority}\\" for task_id, priority in task_list] results.extend(task_lines) return results"},{"question":"Given a sequence \`arr\` of \`n\` integers which can be either positive, negative or zero. Your task is to rearrange the order of the numbers in the sequence so that all the negative numbers come before all the non-negative numbers while maintaining the relative order of the negative numbers amongst themselves and the non-negative numbers amongst themselves. Input Specification: - The first line contains an integer \`n\` (1 ≤ n ≤ 10^5) — the length of the sequence. - The second line contains \`n\` space-separated integers \`arr1, arr2, ..., arrn\` (|arr_i| ≤ 10^9) — the elements of the sequence. Output Specification: - Print the sequence after the required rearrangement. Examples: Input: 5 1 -2 -3 4 -5 Output: -2 -3 -5 1 4 Input: 7 0 -1 2 -3 4 -5 6 Output: -1 -3 -5 0 2 4 6 Note: In the first example, the negative elements [-2, -3, -5] are moved to the front while keeping their respective order and [1, 4] follow them in their original order. In the second example, the rearranged sequence will have [-1, -3, -5] first, preserving their order and the non-negative numbers [0, 2, 4, 6] come afterwards in their original sequence.","solution":"def rearrange_sequence(n, arr): Rearranges the sequence so that all negative numbers come before all non-negative numbers while maintaining the relative order of both. :param n: Length of the sequence :param arr: List of integers :return: List of integers rearranged as per the stated condition negative = [x for x in arr if x < 0] non_negative = [x for x in arr if x >= 0] return negative + non_negative"},{"question":"An alien species exhibits a unique pattern of population growth. Each mature member of the species follows this lifecycle: - In the first year, a new individual does not reproduce (juvenile). - In the second year, the individual produces one offspring and then does not reproduce for the remainder of its life (mature). Initially, in the 0th year, there is only 1 juvenile alien. Using this lifecycle, calculate the total population at the end of the Nth year. Input Format: - The input consists of a single integer N, the year for which the population is to be calculated. Output Format: - The output should consist of a single integer, the total population at the end of the Nth year. Sample Input 1: \`\`\` 5 \`\`\` Sample Output 1: \`\`\` 5 \`\`\` Sample Input 2: \`\`\` 10 \`\`\` Sample Output 2: \`\`\` 45 \`\`\` Explanation: At year 0, there is 1 juvenile. At year 1, there is 1 mature (it does not reproduce this year). At year 2, the mature produces 1 offspring. Continuing this pattern, the population grows exponentially based on maturity. Your task is to write a program to find out the total population at the end of the Nth year given this lifecycle.","solution":"def alien_population(N): Calculate the total alien population at the end of the Nth year. :param N: int, year to calculate the population for :return: int, total population at the end of year N if N == 0: return 1 # Initial juvenile if N == 1: return 1 # Still just the initial alien, now mature population = [0] * (N + 1) # Create an array to store population per year population[0] = 1 # Initial juvenile for year in range(1, N + 1): if year > 1: population[year] = population[year - 1] + population[year - 2] else: population[year] = population[year - 1] return population[N]"},{"question":"Lina loves working with strings and considers herself a palindrome enthusiast. She defines a \\"single-edit palindrome\\" as a string which can be transformed into a palindrome by performing at most one of the following operations: 1. Removing one character from the string. 2. Replacing one character in the string with any other character. Given a string s consisting of uppercase and lowercase English letters, help Lina determine if it is possible to convert the string into a palindrome by performing at most one of the defined operations. Input The first and only line contains a non-empty string s (1 ≤ |s| ≤ 2·105), which consists of uppercase and lowercase English letters. Output Print \\"YES\\" if the string can be transformed into a palindrome using at most one of the defined operations. Otherwise, print \\"NO\\". Examples Input abccdba Output YES Explanation: By removing one 'c', the string becomes \\"abcdba\\", which is a palindrome. Input racecar Output YES Explanation: The string is already a palindrome, so no operations are needed. Input abccda Output NO Explanation: Even after removing or replacing one character, the string cannot form a palindrome.","solution":"def can_be_single_edit_palindrome(s): def is_palindrome_range(i, j): return all(s[k] == s[j-k+i] for k in range(i, j//2 + 1)) n = len(s) if n <= 1: return \\"YES\\" left, right = 0, n - 1 while left < right: if s[left] != s[right]: return \\"YES\\" if is_palindrome_range(left+1, right) or is_palindrome_range(left, right-1) else \\"NO\\" left += 1 right -= 1 return \\"YES\\" if __name__ == \\"__main__\\": import sys input = sys.stdin.read s = input().strip() print(can_be_single_edit_palindrome(s))"},{"question":"In a game, a player can move in a 2D grid of size \`n x n\` starting from the top-left corner (0, 0) to the bottom-right corner (n-1, n-1). The player can move in four possible directions: up, down, left, or right as long as they stay within the grid. Some of the cells in the grid contain obstacles, represented by \`1\`, and the player cannot move into these cells. The cells that the player can move into are represented by \`0\`. The player must find the number of distinct paths from the starting cell (0, 0) to the destination cell (n-1, n-1) without entering any obstacle cells. Two paths are considered distinct if the sequence of cells visited in the two paths is different. Write a function \`distinct_paths(grid: List[List[int]]) -> int\` that takes in an \`n x n\` grid of integers and returns the number of distinct paths from the top-left corner to the bottom-right corner while avoiding obstacles. Constraints: - \`1 <= n <= 10\` - \`grid[i][j]\` is either \`0\` or \`1\` # Input - A 2D integer array \`grid\` of size \`n x n\`. # Output - An integer representing the number of distinct paths from the top-left to the bottom-right. # Example Example 1: \`\`\` Input: [[0, 0, 0], [0, 1, 0], [0, 0, 0]] Output: 2 Explanation: There are two distinct paths: right -> right -> down -> down, and down -> down -> right -> right. \`\`\` Example 2: \`\`\` Input: [[0, 1], [0, 0]] Output: 1 Explanation: There is only one distinct path: down -> right. \`\`\` Example 3: \`\`\` Input: [[0, 1], [1, 0]] Output: 0 Explanation: There is no possible path from the top-left to the bottom-right due to obstacles. \`\`\`","solution":"def distinct_paths(grid): n = len(grid) if grid[0][0] == 1 or grid[n-1][n-1] == 1: return 0 dp = [[0 for _ in range(n)] for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == 0: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][n-1]"},{"question":"Two friends, Alex and Brenda, are avid gamers who regularly compete in online multiplayer games. Recently, they discovered a game in which the main objective is to collect as many unique artifacts as possible by traveling through various interconnected zones. Each zone contains some artifacts and may have one or more pathways leading to other neighboring zones. The game has the following rules: - Alex and Brenda start from the same zone. - They can travel between zones through the given pathways, and the time taken to travel between any two zones is the same. - They can visit each zone only once to collect artifacts. Your task is to help them determine the maximum number of unique artifacts they can collect in total if they choose their paths optimally. Input The first line contains two integers, Z (1 ≤ Z ≤ 1000) and P (1 ≤ P ≤ 5000), representing the number of zones and the number of pathways, respectively. The second line contains Z integers, where the i-th integer represents the number of artifacts in the i-th zone (1 ≤ number of artifacts ≤ 100). The next P lines contain pairs of integers Ai Bi (1 ≤ Ai, Bi ≤ Z), indicating that there is a pathway connecting zones Ai and Bi. The pathways are bidirectional. Output Output a single integer that represents the maximum number of unique artifacts Alex and Brenda can collect. Example Input 5 6 3 2 4 1 5 1 2 1 3 2 4 3 4 4 5 2 5 Output 15 Explanation Alex and Brenda will start from zone 1 with 3 artifacts. They can then move optimally to visit each zone only once and collect all available artifacts. One possible path is 1->2->5->4->3 to collect all the artifacts. Another valid path could be 1->3->4->2->5, resulting in the same outcome. Note They collect all artifacts from the visited zones and return a total of 15.","solution":"from collections import deque, defaultdict def max_artifacts(Z, P, artifacts, pathways): # Create the adjacency list for the graph adj_list = defaultdict(list) for A, B in pathways: adj_list[A-1].append(B-1) adj_list[B-1].append(A-1) def bfs_collect_artifacts(): visited = [False] * Z queue = deque([0]) visited[0] = True total_artifacts = 0 while queue: zone = queue.popleft() total_artifacts += artifacts[zone] for neighbor in adj_list[zone]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return total_artifacts return bfs_collect_artifacts()"},{"question":"In a faraway kingdom, there is a town that is famous for its neatly organized libraries. Each library has rows of bookshelves, and all books in each row are sorted by height. Librarians are very meticulous and they maintain records that help them ensure the books are sorted as needed. One day, a new librarian accidentally knocked over several books, and they are now scattered. The librarian managed to restore some order but needs help in determining if the resulting collection of books in each row is sorted by height in non-decreasing order. Given the number of rows and the heights of books in each row, help the librarian determine if each row is properly sorted. Input The first line contains a single integer r (1 ≤ r ≤ 100), the number of rows. Each of the next r lines contains a list of integers separated by spaces. The first number in each line is c (1 ≤ c ≤ 100), the number of books in that row, followed by c integers denoting the heights of the books in that row. Output For each row, print \\"YES\\" if the books in the row are sorted by height in non-decreasing order, otherwise print \\"NO\\". Examples Input 3 5 1 2 2 4 5 4 4 3 2 1 3 1 2 3 Output YES NO YES Input 2 3 1 2 3 6 5 5 6 6 7 8 Output YES YES Note In the first example: - The first row has books in heights 1, 2, 2, 4, 5 which is properly sorted. - The second row has books in heights 4, 3, 2, 1 which is not sorted. - The third row has books in heights 1, 2, 3 which is sorted. In the second example, both rows have books sorted by height.","solution":"def check_sorted_books(rows): Determines if each row of books is sorted by height in non-decreasing order. :param rows: list of lists, each inner list contains the number of books followed by the heights of the books :return: list of strings \\"YES\\" or \\"NO\\" for each row, indicating whether the row is sorted results = [] for row in rows: # Extract heights from the row (skip the first element which is the count of books) heights = row[1:] # Check if the heights list is sorted if heights == sorted(heights): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"You are given a list of n integers. Your task is to perform a series of operations to reduce the list to a single integer. In each operation, you can choose any two integers from the list, say a and b, and replace them with a new integer defined as a ⊕ b + (a & b), where ⊕ is the bitwise XOR operator and & is the bitwise AND operator. You need to determine the minimum possible value of the final integer after performing these operations. Input The first line contains a single integer n (2 ≤ n ≤ 105) — the number of integers in the list. The second line contains n integers, each between 1 and 10000 inclusive. Output Print a single integer — the minimum possible value of the final integer. Examples Input 4 1 2 3 4 Output 7 Input 3 7 14 3 Output 14 Note For the first example, one of the ways to perform the operations is as follows: - Choose 1 and 2: 1 ⊕ 2 + (1 & 2) = 3 + 0 = 3. The list becomes [3, 3, 4] - Choose 3 and 3: 3 ⊕ 3 + (3 & 3) = 0 + 3 = 3. The list becomes [3, 4] - Choose 3 and 4: 3 ⊕ 4 + (3 & 4) = 7 + 0 = 7. The list becomes [7] For the second example: - Choose 7 and 3: 7 ⊕ 3 + (7 & 3) = 4 + 3 = 7. The list becomes [7, 14] - Choose 7 and 14: 7 ⊕ 14 + (7 & 14) = 9 + 6 = 15. The list becomes [15]","solution":"def min_possible_final_integer(n, arr): Given n integers, this function performs a series of operations to reduce the list to a single integer using the given operation and returns the minimum possible value of the final integer. result = arr[0] for num in arr: result |= num return result"},{"question":"You are given a large text document composed of lowercase English letters and a list of several words. You need to preprocess this text document to support multiple queries efficiently. Each query will ask for the count of occurrences of a specific word in the text document. To make the queries efficient, you need to build a preprocessed data structure. Ensure that each query is answered in O(1) time after preprocessing. Implement the following functions: 1. \`preprocess(text: str, words: List[str]) -> None\`: This function will preprocess the given text document. You may use any data structures needed to support the queries efficiently. 2. \`query(word: str) -> int\`: This function will return the number of occurrences of the given word in the text document that was preprocessed using the \`preprocess\` function. Input - text (1 ≤ |text| ≤ 10^{5}): A string representing the text document. - words (1 ≤ len(words) ≤ 10^{3}): A list of words to process. - Each word in words (1 ≤ |word| ≤ 10) represents the words for which the queries will be performed. Output - For each \`query\` function call, output the count of the occurrences of the word in the text document preprocessed by the previous call to \`preprocess\`. Examples Input: \`\`\` preprocess(\\"hellohelloworld\\", [\\"hello\\", \\"world\\"]) print(query(\\"hello\\")) print(query(\\"world\\")) \`\`\` Output: \`\`\` 2 1 \`\`\` Input: \`\`\` preprocess(\\"ababababab\\", [\\"ab\\", \\"ba\\"]) print(query(\\"ab\\")) print(query(\\"ba\\")) \`\`\` Output: \`\`\` 5 4 \`\`\` Note: - You should call \`preprocess\` with the initial text and list of words to set up the data structure. - Each subsequent call to \`query\` should return the cached or preprocessed count of the specified word within the text.","solution":"from typing import List # Dictionary to store the count of each word word_count_dict = {} def preprocess(text: str, words: List[str]) -> None: Function to preprocess the given text document to support efficient queries. Args: text (str): The text document composed of lowercase English letters. words (List[str]): A list of words for which queries will be performed. global word_count_dict word_count_dict.clear() # Clear the dictionary before starting the preprocessing for word in words: word_count_dict[word] = text.count(word) def query(word: str) -> int: Function to return the number of occurrences of the given word in the preprocessed text. Args: word (str): The word to query. Returns: int: The count of occurrences of the given word in the preprocessed text. return word_count_dict.get(word, 0)"},{"question":"You are given a sequence of n integers a1, a2, ..., an. You can perform an unlimited number of operations, where in each operation, you can choose any two adjacent elements of the sequence and either add their sum to the first element or replace the first element by their sum. Your task is to determine the minimum possible value of the sequence after performing any number of operations. Input The first line contains an integer n (1 ≤ n ≤ 105) — the number of elements in the sequence. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 109). Output Output a single integer — the minimum possible value of the sequence after performing any number of operations. Examples Input: 4 4 2 1 3 Output: 10 Input: 3 10 20 30 Output: 60 Note In the first example, you can perform the operations as follows: Add a1 and a2 to get [6, 1, 3] Add a1 and a2 again to get [7, 3]. Finally, add a1 and a2 to get [10]. Thus, the minimum possible value of the sequence is 10. In the second example, the optimal strategy is to keep summing the adjacent elements starting from the leftmost elements.","solution":"def minimum_possible_value(n, sequence): Returns the minimum possible value of the sequence after performing the operations. if n == 1: return sequence[0] return sum(sequence)"},{"question":"You are given a string s consisting of lowercase English letters. A substring of a string is defined as a contiguous sequence of characters within the string. We say that a string t is a k-repeated substring of the string s if t occurs at least k times in s as a substring. Write a program to find the length of the longest k-repeated substring in s. Input The first line of input contains a single integer k (1 ≤ k ≤ |s|), the minimum number of times the substring should occur. The second line contains the string s (1 ≤ |s| ≤ 105), the string in which we are looking for the k-repeated substring. Output Print the length of the longest k-repeated substring in s on the only line of output. If no such substring exists, print 0. Examples Input 2 banana Output 3 Input 3 abcdef Output 0 Note In the first example, \\"ana\\" is the longest substring that appears at least 2 times in \\"banana\\". Thus, the answer is 3. In the second example, no substring repeats 3 times, so the answer is 0.","solution":"def longest_k_repeated_substring(k, s): Finds the length of the longest substring that is repeated at least k times within the string s. from collections import defaultdict def has_k_repeated_substrings(length): Returns True if there is any substring of the given length that repeats at least k times. substr_count = defaultdict(int) for i in range(len(s) - length + 1): substr = s[i:i + length] substr_count[substr] += 1 if substr_count[substr] >= k: return True return False left, right = 1, len(s) result = 0 while left <= right: mid = (left + right) // 2 if has_k_repeated_substrings(mid): result = mid left = mid + 1 else: right = mid - 1 return result # Example usage # print(longest_k_repeated_substring(2, 'banana')) # Output should be 3 # print(longest_k_repeated_substring(3, 'abcdef')) # Output should be 0"},{"question":"A delivery company has a fleet of vehicles that carry packages between cities. The company maintains a record of each delivery, specifying the origin city, destination city, and the number of packages delivered. They want to analyze how well the deliveries are distributed across the cities. Your task is to determine the city with the highest imbalance in delivery, where imbalance is defined as the absolute difference between the number of packages sent from the city and the number of packages received by the city. Input The first line of the input contains an integer n (1 ≤ n ≤ 100), the number of cities. The second line contains an integer m (1 ≤ m ≤ 1000), the number of deliveries. Each of the next m lines contains three integers u, v, w (1 ≤ u, v ≤ n, 1 ≤ w ≤ 100), indicating a delivery of w packages from city u to city v. Output Print the number of the city with the highest imbalance. If there are multiple cities with the same highest imbalance, print the smallest city number among them. Examples Input 4 5 1 2 10 1 3 5 2 4 12 4 1 6 3 2 7 Output 1 Input 3 3 1 2 15 2 3 20 3 1 10 Output 3 Explanation In the first example, the imbalance for cities is as follows: - City 1: Sent 15 packages, received 6 packages, imbalance is |15 - 6| = 9. - City 2: Sent 12 packages, received 17 packages, imbalance is |12 - 17| = 5. - City 3: Sent 7 packages, received 5 packages, imbalance is |7 - 5| = 2. - City 4: Sent 6 packages, received 12 packages, imbalance is |6 - 12| = 6. City 1 has the highest imbalance. In the second example, the imbalance for cities is as follows: - City 1: Sent 15 packages, received 10 packages, imbalance is |15 - 10| = 5. - City 2: Sent 20 packages, received 15 packages, imbalance is |20 - 15| = 5. - City 3: Sent 10 packages, received 20 packages, imbalance is |10 - 20| = 10. City 3 has the highest imbalance.","solution":"def find_city_with_highest_imbalance(n, m, deliveries): sent = [0] * (n + 1) received = [0] * (n + 1) for (u, v, w) in deliveries: sent[u] += w received[v] += w max_imbalance = -1 city_with_max_imbalance = -1 for city in range(1, n + 1): imbalance = abs(sent[city] - received[city]) if imbalance > max_imbalance or (imbalance == max_imbalance and city < city_with_max_imbalance): max_imbalance = imbalance city_with_max_imbalance = city return city_with_max_imbalance"},{"question":"City Zoo is creating a new exhibit for a rare species of animals. To keep track of the total lifespan of the animals in the new exhibit, the zookeepers decided to implement a new tracking system. The system needs a special mechanism to calculate the sum of the lifespans of animals within a certain range. Each animal's lifespan is recorded as a positive integer in a database. However, the system only considers a range valid if the sum of the lifespans within the range is a prime number. Write a program to help zookeepers determine if the sum of the lifespans in given ranges is a prime number or not. INPUT The first line contains a single integer T, the number of test cases. Each of the next T lines contains three integers N, L, R. N is the number of animals, and L, R are the start and end indices (1-based) representing the range within which to calculate the sum of the lifespans. Following this, there is a line with N space-separated integers representing the lifespans of the animals. OUTPUT For each test case, output \\"VALID\\" if the sum of the lifespans in the range is a prime number, and \\"INVALID\\" otherwise. Constraints 1 ≤ T ≤ 10 1 ≤ N ≤ 100000 1 ≤ Lifespan of each animal ≤ 1000 1 ≤ L, R ≤ N SAMPLE INPUT 2 5 1 3 2 3 5 7 11 6 2 5 3 5 7 11 13 17 SAMPLE OUTPUT VALID INVALID Explanation [1] In the first test case, the lifespans of the animals are [2, 3, 5, 7, 11]. The sum of lifespans from index 1 to 3 is 2 + 3 + 5 = 10, which is not a prime number. Hence the output is \\"INVALID\\". [2] In the second test case, the lifespans of the animals are [3, 5, 7, 11, 13, 17]. The sum of lifespans from index 2 to 5 is 5 + 7 + 11 + 13 = 36, which is not a prime number. Hence the output is \\"INVALID\\".","solution":"def is_prime(num): Helper function to determine if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def get_lifespan_status(T, test_cases): results = [] for i in range(T): N, L, R = test_cases[i][:3] lifespans = test_cases[i][3] sum_lifespan = sum(lifespans[L-1:R]) if is_prime(sum_lifespan): results.append(\\"VALID\\") else: results.append(\\"INVALID\\") return results # Parsing function to handle input data def parse_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) idx = 1 test_cases = [] for _ in range(T): N, L, R = map(int, lines[idx].split()) lifespans = list(map(int, lines[idx + 1].split())) test_cases.append((N, L, R, lifespans)) idx += 2 return T, test_cases # Main function to be called with input data as a string def main(input_data): T, test_cases = parse_input(input_data) return get_lifespan_status(T, test_cases)"},{"question":"Given an array of integers A of length N and a target sum S, determine the number of distinct non-empty subsequences of A whose sum is equal to S. Input The first line contains T, the number of test cases. Each test case consists of N and S in one line, followed by the array A in the next line. Output For each test case, print the required answer in one line. Constraints 1 ≤ T ≤ 10 1 ≤ N ≤ 20 1 ≤ S, Ai ≤ 100 Example Input: 2 4 5 1 2 3 4 3 6 2 4 2 Output: 2 2 Explanation For the first test case, the subsequences {1, 4} and {2, 3} sum up to 5. For the second test case, the subsequences {2, 4} and {2, 4} (the second one from another occurrence) sum up to 6. The answer is 2 for both since there are two ways to achieve the target sum. Additional Notes - The input array may contain repeated elements. - Subsequences are not required to be contiguous within the original array.","solution":"def count_subsequences(A, S): Returns the number of distinct non-empty subsequences of A whose sum is equal to S. from itertools import combinations count = 0 N = len(A) # Iterate over all possible lengths of subsequences (1 to N) for r in range(1, N + 1): for comb in combinations(A, r): if sum(comb) == S: count += 1 return count def solve(test_cases): results = [] for N, S, A in test_cases: results.append(count_subsequences(A, S)) return results"},{"question":"You are given a list of \`n\` integers. Your task is to form a maximum-length subsequence from these integers such that the sum of elements in the subsequence is divisible by a given integer \`d\`. A subsequence is a sequence derived from the list of integers by deleting some or none of the elements without changing the order of the remaining elements. Write a function that returns the length of this maximum-length subsequence. Input The function takes two arguments: - \`arr\`: a list of \`n\` integers. - \`d\`: an integer by which the sum of the subsequence should be divisible. Output Return an integer indicating the maximum length of the subsequence meeting the criteria. Example Input arr = [3, 1, 4, 1, 2] d = 3 Output 4 Explanation: The maximum-length subsequence whose sum is divisible by 3 is [3, 1, 4, 1]. The sum is 3 + 1 + 4 + 1 = 9 and 9 % 3 == 0. Input arr = [1, 2, 3, 4, 5] d = 5 Output 5 Explanation: The maximum-length subsequence whose sum is divisible by 5 is [1, 2, 3, 4, 5]. The sum is 1 + 2 + 3 + 4 + 5 = 15 and 15 % 5 == 0. Note - If there is no subsequence that meets the criteria, return 0. - Subsequence might consist of all elements in the original array.","solution":"def max_length_subsequence_divisible_by_d(arr, d): n = len(arr) # dp will store the maximum length subsequence sum % d dp = [-1] * d dp[0] = 0 for num in arr: # Iterate over a snapshot of the dp array current_dp = dp[:] for i in range(d): if current_dp[i] != -1: new_index = (i + num) % d dp[new_index] = max(dp[new_index], current_dp[i] + 1) return dp[0] # Returning maximum length for sum % d == 0"},{"question":"You are developing a software for a spaceship that needs to determine the shortest possible time to send commands from the main control to various rooms on the spaceship. The spaceship is modeled as a connected graph with n rooms and m bidirectional corridors. Each corridor connects two rooms and has an associated travel time. Given the n rooms and m corridors, you need to determine the shortest time required to transmit a command from the main control (room 1) to each of the other rooms. If any room cannot be reached from the main control, output -1 for that room. Input The first line contains two space-separated integers n (2 ≤ n ≤ 100) and m (1 ≤ m ≤ 10^5), the number of rooms and corridors respectively. The next m lines each contain three space-separated integers u, v, w (1 ≤ u, v ≤ n, u ≠ v, 1 ≤ w ≤ 10^9), denoting a corridor between room u and room v with a travel time of w nanoseconds. Output Print n-1 integers where the i-th integer is the shortest time required to send a command from room 1 to room i+1. If room i+1 cannot be reached from room 1, output -1. Examples Input 5 6 1 2 2 1 3 4 2 3 1 3 4 3 2 5 5 4 5 1 Output 2 3 6 7 Input 3 1 1 2 3 Output 3 -1 Note In the first example, the shortest time to reach each room from room 1 is as follows: - Room 2: 2 nanoseconds - Room 3: 3 nanoseconds (via room 2) - Room 4: 6 nanoseconds (via rooms 2 and 3) - Room 5: 7 nanoseconds (via rooms 2, 3, and 4) In the second example, room 2 can be reached in 3 nanoseconds from room 1, but room 3 cannot be reached from room 1. Hence, the output for room 3 is -1.","solution":"import heapq def shortest_transmission_time(n, m, corridors): graph = {i: [] for i in range(1, n + 1)} for u, v, w in corridors: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm to find shortest paths from room 1 min_heap = [(0, 1)] # (travel_time, room) shortest_path = {i: float('inf') for i in range(1, n + 1)} shortest_path[1] = 0 while min_heap: current_time, u = heapq.heappop(min_heap) if current_time > shortest_path[u]: continue for v, w in graph[u]: time = current_time + w if time < shortest_path[v]: shortest_path[v] = time heapq.heappush(min_heap, (time, v)) result = [] for i in range(2, n + 1): result.append(shortest_path[i] if shortest_path[i] != float('inf') else -1) return result"},{"question":"Lisa is given a list of integers, and she is interested in finding the length of the longest subsequence that is strictly increasing. She is not very good at programming and needs your help to solve this problem. Given a list of integers, return the length of the longest strictly increasing subsequence in the list. # INPUT: - The first line of input contains a single integer n, the number of integers in the list. - The second line contains n space-separated integers representing the list. # OUTPUT: - Output a single integer representing the length of the longest strictly increasing subsequence. # CONSTRAINTS: - 1 ≤ n ≤ 10^3 - -10^6 ≤ list[i] ≤ 10^6, where list[i] is the ith integer in the list. # EXAMPLE INPUT: 6 10 9 2 5 3 7 101 18 OUTPUT: 4 INPUT: 5 0 1 0 3 2 3 OUTPUT: 4","solution":"def longest_increasing_subsequence_length(arr): Returns the length of the longest strictly increasing subsequence. if not arr: return 0 n = len(arr) dp = [1] * n # dp[i] will be the length of the longest increasing subsequence that ends with arr[i] for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Milena just learned about palindromic numbers and is fascinated by them. She wants you to help her find the nearest palindromic number to a given number. The nearest palindromic number is either the closest smaller or the closest larger palindromic number. In case of ties, the smaller number is preferred. A palindromic number reads the same backward as forward, such as 121 or 555. You are given 'T' test cases, with each test case containing a single positive integer 'N'. INPUT The first line of input will be 'T', the number of test cases, followed by 'T' lines each containing a single number 'N'. OUTPUT For each test case, print the nearest palindromic number to 'N'. SAMPLE INPUT 3 123 4567 1000 SAMPLE OUTPUT 121 4554 999 Explanation For the first test case, the nearest palindromic number to 123 is 121. For the second test case, the nearest palindromic number to 4567 is 4554. For the third test case, the nearest palindromic number to 1000 is 999. Note: In case of ties, prefer the smaller number as in the first sample input where both 121 and 131 are close to 123, but 121 is smaller.","solution":"def nearest_palindromic(N): Returns the nearest palindromic number to N. In case of ties, the smaller number is preferred. def is_palindrome(num): return str(num) == str(num)[::-1] if N < 0: return None lower = N - 1 upper = N + 1 while True: if is_palindrome(lower): return lower if is_palindrome(upper): return upper lower -= 1 upper += 1 def find_nearest_palindromes(test_cases): results = [] for N in test_cases: results.append(nearest_palindromic(N)) return results # Example usage: # T = 3 # test_cases = [123, 4567, 1000] # print(find_nearest_palindromes(test_cases)) # Output: [121, 4554, 999]"},{"question":"Alex works as a network administrator at a company that maintains a dedicated network of servers. Each server connects to a certain number of other servers through direct one-way communication links. The network is represented as a directed graph where each node corresponds to a server and each directed edge corresponds to a direct communication link between servers. Alex wants to optimize the paths between servers in such a way that it's possible to send a message from any server to any other server either directly or through intermediate servers. Given the current list of direct communication links, determine the minimum number of new direct links that need to be added to make the network strongly connected (i.e., there is a path from any server to any other server for all pairs of servers). Input The first line contains two integers, n and m, where 1 ≤ n ≤ 1000 represents the number of servers and 0 ≤ m ≤ n*(n-1) represents the number of direct communication links between servers. Each of the next m lines contains two integers, u and v (0 ≤ u, v < n), indicating a one-way communication link from server u to server v. Output Output one integer, the minimum number of new direct links required to make the network strongly connected. Example Input 4 2 0 1 2 3 Output 2 Explanation The network can be visualized as follows: \`\`\` 0 -> 1 2 -> 3 \`\`\` To make the network strongly connected, one of the possible solutions is to add the links (1 -> 2) and (3 -> 0). Hence, the output is 2.","solution":"from collections import defaultdict def find_scc(graph, n): Find Strongly Connected Components (SCC) using Kosaraju's Algorithm. def dfs(v, graph, visited, stack): visited[v] = True for u in graph[v]: if not visited[u]: dfs(u, graph, visited, stack) stack.append(v) def reverse_graph(graph): reversed_g = defaultdict(list) for v in graph: for u in graph[v]: reversed_g[u].append(v) return reversed_g def fill_order(graph, n): visited = [False] * n stack = [] for i in range(n): if not visited[i]: dfs(i, graph, visited, stack) return stack def get_sccs(graph, n): stack = fill_order(graph, n) reversed_g = reverse_graph(graph) visited = [False] * n sccs = [] while stack: v = stack.pop() if not visited[v]: scc_stack = [] dfs(v, reversed_g, visited, scc_stack) sccs.append(scc_stack) return sccs return get_sccs(graph, n) def min_new_links_to_strongly_connect(n, m, links): if n == 1: return 0 graph = defaultdict(list) for u, v in links: graph[u].append(v) sccs = find_scc(graph, n) num_scc = len(sccs) if num_scc == 1: return 0 reversed_graph = reverse_graph(graph) out_degree = [0] * num_scc in_degree = [0] * num_scc scc_index = {} for i, scc in enumerate(sccs): for node in scc: scc_index[node] = i for u in range(n): for v in graph[u]: if scc_index[u] != scc_index[v]: out_degree[scc_index[u]] += 1 in_degree[scc_index[v]] += 1 zero_in = sum(1 for i in range(num_scc) if in_degree[i] == 0) zero_out = sum(1 for i in range(num_scc) if out_degree[i] == 0) return max(zero_in, zero_out) # Function for reverse graph def reverse_graph(graph): reversed_g = defaultdict(list) for u in graph: for v in graph[u]: reversed_g[v].append(u) return reversed_g"},{"question":"# Problem Description You are given a matrix of size n × m filled with integers. The matrix represents different altitudes of a terrain. Your task is to find a path from the top-left corner to the bottom-right corner of the matrix with the minimum possible altitude change. The movement is restricted to the four possible directions: left, right, up, or down. The altitude change is defined as the absolute difference between the altitudes of the adjacent cells along the path. Write a function that computes the minimum altitude change required to move from the top-left corner to the bottom-right corner of the matrix. # Input - The first line contains two integers, n and m (1 ≤ n, m ≤ 100) — the number of rows and columns of the matrix. - The next n lines each contain m integers, representing the elements of the matrix. Each integer value a_ij (0 ≤ a_ij ≤ 10^6) specifies the altitude of the cell in the i-th row and j-th column. # Output Print a single integer representing the minimum altitude change required to move from the top-left corner to the bottom-right corner of the matrix. # Examples Example 1 **Input:** \`\`\` 3 3 1 3 2 4 5 8 6 7 9 \`\`\` **Output:** \`\`\` 2 \`\`\` **Explanation:** The minimum path is 1 -> 3 -> 2 -> 8 -> 9 with altitude changes of 2, 1, 6, and 1. Hence, the minimum altitude change is 1. Example 2 **Input:** \`\`\` 2 2 5 3 2 1 \`\`\` **Output:** \`\`\` 2 \`\`\` **Explanation:** The minimum path is 5 -> 3 -> 1 with altitude changes of 2 and 2. Hence, the minimum altitude change is 2.","solution":"import heapq def min_altitude_change(matrix): n, m = len(matrix), len(matrix[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def in_bounds(x, y): return 0 <= x < n and 0 <= y < m heap = [(0, 0, 0)] # (change, row, col) seen = [[False] * m for _ in range(n)] max_change = 0 while heap: change, x, y = heapq.heappop(heap) max_change = max(max_change, change) if x == n-1 and y == m-1: return max_change if seen[x][y]: continue seen[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if in_bounds(nx, ny) and not seen[nx][ny]: altitude_change = abs(matrix[nx][ny] - matrix[x][y]) heapq.heappush(heap, (altitude_change, nx, ny)) return max_change"},{"question":"You are given a matrix with N rows and N columns where each cell represents the cost to travel between two towns. The matrix is symmetric and the diagonal consists of zeros (meaning there is no cost to travel from a town to itself). A merchant wants to traverse all towns starting and ending at the same town while minimizing the total cost of travel. You need to calculate the minimum travel cost for such a round trip. Input The first line contains a single integer N (2 ≤ N ≤ 15) — the number of towns. The next N lines contain N integers each. The j-th integer in the i-th line (0 ≤ i, j < N) represents the cost to travel from town i to town j. It is guaranteed that the matrix is symmetric and the diagonal elements are zero. Output Output a single integer — the minimum cost of a round trip that visits all towns exactly once and returns to the starting town. Examples Input 4 0 10 15 20 10 0 35 25 15 35 0 30 20 25 30 0 Output 80 Input 3 0 12 10 12 0 15 10 15 0 Output 37","solution":"from itertools import permutations def min_travel_cost(matrix): This function calculates the minimum travel cost to visit all towns starting and ending at the same town. N = len(matrix) towns = range(N) min_cost = float('inf') for perm in permutations(towns[1:]): current_cost = 0 current_cost += matrix[0][perm[0]] # from the start town to the first town in permutation for i in range(len(perm) - 1): current_cost += matrix[perm[i]][perm[i + 1]] current_cost += matrix[perm[-1]][0] # from the last town in permutation back to the start town min_cost = min(min_cost, current_cost) return min_cost def parse_input(input_string): Parses the input string into an integer matrix. lines = input_string.strip().split('n') N = int(lines[0]) matrix = [list(map(int, line.split())) for line in lines[1:]] return matrix def main(input_string): Main function to parse the input and return the minimal travel cost. matrix = parse_input(input_string) return min_travel_cost(matrix)"},{"question":"You are given a rectangular grid of size N x M. Each cell in the grid contains a lowercase English letter. Your task is to find the length of the longest path on the grid such that all the characters on the path are distinct. From each cell, you can move to one of the four adjacent cells (left, right, up, or down) but you cannot move diagonally. Input The first line of input contains two integers, N and M, denoting the dimensions of the grid respectively. The following N lines contain M characters each representing the grid. Output Output a single integer, the length of the longest path that can be formed such that all characters on the path are distinct. Constraints 1 ≤ N, M ≤ 20 Example Input: 3 4 abcd efgh ijkl Output: 12 Description: The possible longest path in the given example is of length 12 and one such path is 'abcdefghijkl' starting from cell (1, 1) to (3, 4).","solution":"def longest_unique_path(grid): Find the length of the longest path with distinct characters in a rectangular grid. :param grid: List[List[str]] - the grid of lowercase letters. :return: int - the length of the longest path. if not grid or not grid[0]: return 0 N = len(grid) M = len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_path_len = 0 def dfs(x, y, visited): nonlocal max_path_len max_path_len = max(max_path_len, len(visited)) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] not in visited: dfs(nx, ny, visited + grid[nx][ny]) for i in range(N): for j in range(M): dfs(i, j, grid[i][j]) return max_path_len"},{"question":"Alice and Bob are having a friendly yet competitive game involving sets and arrays. Alice claims to be better with arrays, while Bob argues he is better with sets. To settle this, they come up with a challenge that incorporates both. They have designed an interesting game summarized as follows: They start with an empty array and an empty set. The game consists of a series of commands, and their task is to perform various operations based on these commands. You need to assist them in executing these commands efficiently. There are multiple types of commands you need to handle: 1. Add the number X to the array. This is represented by the command: \`0 X\`. 2. Add the number X to the set. This is represented by the command: \`1 X\`. 3. Check if the number X is present in the array. This is represented by the command: \`2 X\`. 4. Check if the number X is present in the set. This is represented by the command: \`3 X\`. Your task is to help Alice and Bob by processing these commands and providing the correct output for each query operation. Input: The first line contains an integer Q, the number of commands. Each of the next Q lines contain one of the commands as described above. Output: For each query command (type 2 or 3), output a single line containing \\"Yes\\" or \\"No\\" depending on whether the number X is present in the array or set respectively. Constraints: - 1 ≤ Q ≤ 100 - 1 ≤ X ≤ 100 SAMPLE INPUT 6 0 5 1 5 2 5 2 10 3 5 3 10 SAMPLE OUTPUT Yes No Yes No","solution":"def process_commands(commands): Processes a list of commands to manipulate an array and a set, and returns the results for check commands. array = [] num_set = set() results = [] for command in commands: parts = command.split() cmd_type = int(parts[0]) x = int(parts[1]) if cmd_type == 0: array.append(x) elif cmd_type == 1: num_set.add(x) elif cmd_type == 2: if x in array: results.append(\\"Yes\\") else: results.append(\\"No\\") elif cmd_type == 3: if x in num_set: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"Readville is a bustling town with a unique road network. The Mayor has proposed to measure the accessibility of important locations in the town through the buses routes. The town has N bus stops and M bus routes. Some routes are direct, while others require hopping through multiple stops on the way. A bus route between two stops is bidirectional. The Mayor wants to find out the longest direct bus route between any two bus stops, and how many stops are on this route, including both endpoints. Can you help the Mayor develop a program to find this information? Input N M u1 v1 u2 v2 . . . uM vM The first line contains two integers N and M (1 ≤ N ≤ 1000, 0 ≤ M ≤ 10000) representing the number of bus stops and bus routes respectively. Each of the next M lines contains two integers ui and vi (1 ≤ ui, vi ≤ N) representing a bidirectional bus route between bus stops ui and vi. Output Print two integers: the number of stops on the longest direct bus route and the length of this route. Examples Input 6 7 1 2 2 3 3 4 4 5 5 1 2 5 3 6 Output 5 4 Input 4 2 1 2 3 4 Output 2 1 Input 5 0 Output 1 0","solution":"def longest_direct_bus_route(N, M, routes): Returns the number of stops and the length of the longest direct bus route. if M == 0: # No routes are available return 1, 0 from collections import defaultdict # Creating adjacency list graph = defaultdict(list) for u, v in routes: graph[u].append(v) graph[v].append(u) longest_route = -1 nodes_in_longest_route = 0 for node in range(1, N + 1): for neighbor in graph[node]: route_length = abs(node - neighbor) if route_length > longest_route: longest_route = route_length nodes_in_longest_route = 2 # since it's a direct route if longest_route == -1: return 1, 0 return nodes_in_longest_route, longest_route"},{"question":"You are given a list of n integers. Your task is to answer q queries. Each query will contain two integers l and r (1 ≤ l ≤ r ≤ n), and you need to determine the maximum GCD (Greatest Common Divisor) of any subarray that includes all elements from the l-th to the r-th element in the list. Input The first line of input contains two integers n and q (1 ≤ n, q ≤ 10^5), the number of integers in the list and the number of queries, respectively. The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 10^6), the elements of the list. Each of the next q lines contains two integers l and r (1 ≤ l ≤ r ≤ n), the bounds of the query. Output For each query, output the maximum GCD of any subarray that includes all elements from the l-th to the r-th element in the list. Example Input 6 3 5 10 15 20 25 30 1 3 2 4 3 6 Output 5 10 5 Note For the first query, the subarray [5, 10, 15] has the largest GCD which is 5. For the second query, the subarray [10, 15, 20] has the largest GCD which is 10. For the third query, the subarray [15, 20, 25, 30] has the largest GCD which is 5.","solution":"import math from functools import reduce def gcd(a, b): while b: a, b = b, a % b return a def compute_max_gcd_in_subarray(arr, l, r): Function to compute the max GCD of any subarray that includes all elements from index l to r in the given list. subarray = arr[l-1:r] return reduce(gcd, subarray) def solve(arr, queries): results = [] for l, r in queries: max_gcd = compute_max_gcd_in_subarray(arr, l, r) results.append(max_gcd) return results"},{"question":"In a city, there are multiple routes connecting different bus stops. Each route has a specific bus stop as its start and another specific bus stop as its end. Some bus stops may have routes that form cycles, meaning it's possible to go from a bus stop back to itself by following a sequence of one or more routes. Your task is to determine if there's a cycle in the given city's bus stop routes, and if so, find at least one cycle and print the bus stops involved in that cycle in the order they appear. If there are no cycles, print \\"No cycle\\" (without the quotes). Input The first line contains two integers n (1 ≤ n ≤ 1000) — the number of bus stops and m (1 ≤ m ≤ 2000) — the number of routes. Each of the next m lines contains two integers u and v (1 ≤ u, v ≤ n) — bus stop u and bus stop v indicating a route from bus stop u to bus stop v. Output If there is a cycle, print \\"Cycle Found:\\" followed by the bus stops involved in one of the cycles in the order they appear. If there are no cycles, print \\"No cycle\\". Examples Input 4 4 1 2 2 3 3 4 4 2 Output Cycle Found: 2 3 4 2 Input 3 2 1 2 2 3 Output No cycle","solution":"def find_cycle(n, m, routes): from collections import defaultdict, deque def dfs(v): state[v] = 1 # visited stack.append(v) for u in graph[v]: if state[u] == 1: # found a back edge, indicating a cycle cycle = stack[stack.index(u):] cycle.append(u) return cycle if state[u] == 0: result = dfs(u) if result: return result state[v] = 2 # fully processed stack.pop() return None graph = defaultdict(list) for u, v in routes: graph[u].append(v) state = [0] * (n + 1) # 0: unvisited, 1: visiting, 2: visited stack = [] for i in range(1, n + 1): if state[i] == 0: cycle = dfs(i) if cycle: return \\"Cycle Found: \\" + ' '.join(map(str, cycle)) return \\"No cycle\\""},{"question":"You are given a rooted tree with n nodes. The tree is rooted at node 1. Each node has a value assigned to it, and the value of node i is denoted by a_i. Your task is to answer q queries of the following type: For each query, given a node u and an integer k, find the k-th ancestor of node u. The k-th ancestor of node u is defined as the node that is k edges away from u on the path from u to the root. If there is no such ancestor, return -1. Input The first line of the input contains two integers n (1 ≤ n ≤ 10^5) and q (1 ≤ q ≤ 10^5) - the number of nodes in the tree and the number of queries, respectively. The second line contains n integers, the values a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9), where a_i represents the value associated with the i-th node. The next n-1 lines each contain two integers u and v (1 ≤ u, v ≤ n), representing an edge between nodes u and v. Each of the next q lines contains two integers u and k (1 ≤ u ≤ n, 0 ≤ k ≤ n), where u is the node and k is the distance to the ancestor that needs to be found. Output For each query, print the value of the k-th ancestor of node u. If there is no such ancestor, print -1 instead. Example Input 7 6 1 2 3 4 5 6 7 1 2 1 3 2 4 2 5 3 6 3 7 4 1 4 2 4 3 7 2 6 1 1 0 Output 2 1 -1 1 3 1 Note In this example, the tree looks like: 1 / 2 3 / / 4 5 6 7 The queries and their results are as follows: 1. The 1st ancestor of node 4 is node 2 with value 2. 2. The 2nd ancestor of node 4 is node 1 with value 1. 3. Node 4 does not have a 3rd ancestor, so we return -1. 4. The 2nd ancestor of node 7 is node 1 with value 1. 5. The 1st ancestor of node 6 is node 3 with value 3. 6. The 0th ancestor of node 1 is node 1 with value 1.","solution":"from collections import defaultdict, deque def build_tree(n, edges): tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) return tree def preprocess_ancestors(n, tree): parent = [-1] * (n + 1) depth = [0] * (n + 1) log = 1 while (1 << log) <= n: log += 1 up = [[-1] * (log + 1) for _ in range(n + 1)] def dfs(v, p, dep): parent[v] = p depth[v] = dep up[v][0] = p for i in range(1, log + 1): if up[v][i - 1] != -1: up[v][i] = up[up[v][i - 1]][i - 1] for neighbor in tree[v]: if neighbor != p: dfs(neighbor, v, dep + 1) dfs(1, -1, 0) return up, depth def find_kth_ancestor(n, up, depth, u, k): if depth[u] < k: return -1 for i in range(len(up[0])): if (k >> i) & 1: u = up[u][i] if u == -1: return -1 return u def solve(n, values, edges, queries): tree = build_tree(n, edges) up, depth = preprocess_ancestors(n, tree) results = [] for u, k in queries: kth_ancestor = find_kth_ancestor(n, up, depth, u, k) results.append(values[kth_ancestor - 1] if kth_ancestor != -1 else -1) return results"},{"question":"An online bookstore system is being developed to manage book inventories and assist customers with their purchases. As part of the inventory management, the system needs to track the stock levels of different book titles and handle customers' buying requests. Your task is to write a program that updates the stock levels based on customer requests and reports when a book goes out of stock. INPUT: - First line contains an integer n, the number of different book titles in the inventory. - Next n lines contain the book title and its initial stock separated by a space. - After the inventory setup, the following line contains an integer m, the number of customer buy requests. - Next m lines contain a book title and the quantity to be purchased. OUTPUT: For each customer buy request, print \\"Request Approved: <Book Title>\\" if the request can be fulfilled, and update the stock level accordingly. Print \\"Stock Depleted: <Book Title>\\" if the request cannot be approved because the book is out of stock. After processing all requests, output the remaining stock levels for all book titles in the format \\"<Book Title>: <Remaining Stock>\\". Note: - The book titles are case-sensitive. - If multiple requests come in for the same book, they should be processed in the order they are received. SAMPLE INPUT 3 \\"Moby Dick\\" 10 \\"1984\\" 5 \\"The Catcher in the Rye\\" 3 4 \\"Moby Dick\\" 3 \\"1984\\" 1 \\"The Catcher in the Rye\\" 4 \\"Moby Dick\\" 8 SAMPLE OUTPUT Request Approved: Moby Dick Request Approved: 1984 Stock Depleted: The Catcher in the Rye Stock Depleted: Moby Dick Moby Dick: 7 1984: 4 The Catcher in the Rye: 3","solution":"def manage_inventory(input_lines): from collections import defaultdict index = 0 # Read number of books in inventory n = int(input_lines[index].strip()) index += 1 # Read the inventory inventory = {} for _ in range(n): line = input_lines[index].strip().rsplit(\\" \\", 1) book_title = line[0].strip('\\"') initial_stock = int(line[1]) inventory[book_title] = initial_stock index += 1 # Read number of customer buy requests m = int(input_lines[index].strip()) index += 1 # Process each buy request results = [] for _ in range(m): line = input_lines[index].strip().rsplit(\\" \\", 1) book_title = line[0].strip('\\"') quantity = int(line[1]) if book_title in inventory and inventory[book_title] >= quantity: inventory[book_title] -= quantity results.append(f\\"Request Approved: {book_title}\\") else: results.append(f\\"Stock Depleted: {book_title}\\") index += 1 # Output remaining stock levels for book_title, remaining_stock in inventory.items(): results.append(f\\"{book_title}: {remaining_stock}\\") return results"},{"question":"Alice and Bob love playing games that involve numbers. Recently, they have come up with a new game that involves prime factors. The rules are simple: given two numbers \`A\` and \`B\`, they need to find the sum of all distinct prime factors of \`A^B\`. For example, if \`A\` is 12 and \`B\` is 2, then \`A^B = 12^2 = 144\`. The prime factors of 144 are 2 and 3, and their sum is 2 + 3 = 5. Write a program that takes multiple test cases, each with two numbers \`A\` and \`B\`, and for each test case, calculates the sum of all distinct prime factors of \`A^B\`. Input: The first line contains an integer \`T\` - the total number of test cases. \`T\` lines follow. Each line contains two integers \`A\` and \`B\`. Output: For each test case, print the sum of all distinct prime factors of \`A^B\` on a new line. Constraints: 1 ≤ T ≤ 100 1 ≤ A, B ≤ 10^5 SAMPLE INPUT 3 12 2 15 3 7 1 SAMPLE OUTPUT 5 8 7 Explanation For the 1st test case: 12^2 = 144 → prime factors are {2, 3}. Their sum is 2 + 3 = 5. For the 2nd test case: 15^3 = 3375 → prime factors are {3, 5}. Their sum is 3 + 5 = 8. For the 3rd test case: 7^1 = 7 → prime factor is {7}. The sum is 7.","solution":"def prime_factors(n): Return the set of distinct prime factors of n. i = 2 factors = set() while i * i <= n: while (n % i) == 0: factors.add(i) n //= i i += 1 if n > 1: factors.add(n) return factors def sum_of_distinct_prime_factors(A, B): Return the sum of all distinct prime factors of A^B. # For large powers, instead of computing A^B directly, # we get the prime factors of A. factors = prime_factors(A) # Distinct prime factors of A^B are the same as those of A return sum(factors) def games_sum_prime_factors(T, test_cases): results = [] for a, b in test_cases: results.append(sum_of_distinct_prime_factors(a, b)) return results if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() T = int(data[0]) test_cases = [(int(data[i * 2 + 1]), int(data[i * 2 + 2])) for i in range(T)] results = games_sum_prime_factors(T, test_cases) for result in results: print(result)"},{"question":"You are given a compressed string where occurrences of the same character are represented in the format \\"character count\\". For example, \\"a2b1c5a3\\" is the compressed form of the string \\"aabcccccaaa\\". Your task is to decompress such strings. However, there are a few constraints: 1. The compressed string might not always be valid (meaning the number won't necessarily follow a character). For instance, \\"a10bc3\\" is invalid as it doesn't follow the format \\"character count\\". 2. Characters in the compressed string are always lowercase alphabets. 3. The expanded decompressed string will always be less than or equal to 10^6 characters long. Input: The input consists of T test cases. The first line contains an integer T, the number of test cases. Each of the next T lines contains a compressed string. Output: For each test case, print the decompressed string if it's valid; otherwise, print \\"INVALID\\". Constraints: 1 ≤ T ≤ 1000 1 ≤ length of compressed string ≤ 10000 SAMPLE INPUT 3 a2b1c5a3 a10bc3 x1y2 SAMPLE OUTPUT aabcccccaaa INVALID xyy Note: - For the second input, \\"a10bc3\\", there's no number following \\"b\\" so it is invalid. - The third input expands correctly to \\"xyy\\".","solution":"import re def decompress_string(compressed_str): Decompresses a string where characters are followed by their counts. Returns the decompressed string if valid, otherwise returns \\"INVALID\\". pattern = re.compile(r'([a-z])(d+)') decompressed_str = \\"\\" position = 0 while position < len(compressed_str): match = pattern.match(compressed_str, position) if not match: return \\"INVALID\\" char, count = match.groups() decompressed_str += char * int(count) position = match.end() return decompressed_str def decompress_multiple_strings(T, compressed_strings): results = [] for compressed_str in compressed_strings: decompressed = decompress_string(compressed_str) if len(decompressed) > 10**6: results.append(\\"INVALID\\") else: results.append(decompressed) return results"},{"question":"The kingdom of Farland has n cities connected by m two-way roads. The king wants to know if it's possible to travel between any two cities using the existing roads. He needs your help to determine if the road network is connected. A road network is considered connected if there is a path between any two cities, either directly or indirectly, using the available roads. Input The first line contains two integers n (2 ≤ n ≤ 1000) and m (0 ≤ m ≤ 1000) – the number of cities and the number of roads, respectively. Each of the next m lines contains two integers a and b (1 ≤ a, b ≤ n, a ≠ b) – representing a road between city a and city b. Output Output \\"YES\\" if it is possible to travel between any two cities using the existing roads; otherwise, output \\"NO\\". Example Input 5 4 1 2 2 3 3 4 4 5 4 1 1 2 3 4 1 3 2 5 Output YES NO","solution":"def is_connected(n, m, roads): from collections import defaultdict, deque if m == 0: return \\"NO\\" # Creating adjacency list for the graph adj_list = defaultdict(list) for a, b in roads: adj_list[a].append(b) adj_list[b].append(a) def bfs(start): visited = set() queue = deque([start]) while queue: city = queue.popleft() if city not in visited: visited.add(city) for neighbor in adj_list[city]: if neighbor not in visited: queue.append(neighbor) return visited # Perform BFS from the first city visited_cities = bfs(1) # Check if all cities are visited for city in range(1, n + 1): if city not in visited_cities: return \\"NO\\" return \\"YES\\""},{"question":"You are given a rectangular grid of size \`n x m\` filled with integers. Your task is to find the maximum sum you can obtain by moving only right or down, starting from the top-left corner of the grid (cell \`(1, 1)\`) to the bottom-right corner of the grid (cell \`(n, m)\`). Write a program that reads the dimensions of the grid \`n\` and \`m\`, followed by the \`n x m\` matrix of integers. Your output should be the maximum sum possible along any path from the top-left to the bottom-right corner. Input The input consists of a single dataset. The first line contains two integers \`n\` and \`m\` (1 ≤ n, m ≤ 100), representing the dimensions of the grid. The next \`n\` lines each contain \`m\` integers, representing the grid cells. Each integer in the grid is between \`-1000\` and \`1000\`. Output Print a single integer, the maximum sum possible along any path from the top-left to the bottom-right corner of the grid. Example Input 3 3 1 2 3 4 5 6 7 8 9 Output 29","solution":"def max_path_sum(n, m, grid): Returns the maximum sum by moving only right or down from the top-left to the bottom-right corner of the grid. # Create a dp array to store the maximum sums dp = [[0] * m for _ in range(n)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1] # Example usage: n, m = 3, 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(max_path_sum(n, m, grid)) # Output: 29"},{"question":"Balanced Parentheses Alice is working with an editor that highlights blocks of code with proper indentation and parenthesis balancing. She needs a helper function to verify that all the parentheses in a given string are balanced, meaning every opening parenthesis '(' has a corresponding closing parenthesis ')'. Write a function that determines if the parentheses in the input string are balanced. Input First line consists of a string containing characters including '(', ')', and other alphanumeric characters. Output Print \\"Balanced\\" if the parentheses are balanced, otherwise print \\"Unbalanced\\". Example Input: (a + b) * (c + d) Output: Balanced Input: ((a + b) * c) + d) Output: Unbalanced","solution":"def check_balanced_parentheses(s): Returns \\"Balanced\\" if the parentheses in the input string are balanced, otherwise returns \\"Unbalanced\\". stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return \\"Unbalanced\\" stack.pop() return \\"Balanced\\" if not stack else \\"Unbalanced\\""},{"question":"Write a function that takes an integer \`n\` as input and returns the sum of its digits raised to consecutive powers starting from 1. For example, if the input number is \`n\` = 123, then the output should be calculated as: 1^1 + 2^2 + 3^3 = 1 + 4 + 27 = 32 Function Signature: \`\`\`python def sum_of_powered_digits(n: int) -> int: # your code here \`\`\` Input: - An integer \`n\` (1 ≤ n ≤ 10^9) Output: - A single integer which is the sum of the digits of \`n\`, each raised to the power of its positional order starting from 1. Examples: Input \`\`\` 123 \`\`\` Output \`\`\` 32 \`\`\` Input \`\`\` 456 \`\`\` Output \`\`\` 341 \`\`\` Note: - Consider the digits of the number from left to right. - The first digit should be raised to the power of 1, the second digit to the power of 2, and so on. - You can assume that the input will always be a positive integer.","solution":"def sum_of_powered_digits(n: int) -> int: Returns the sum of the digits of n each raised to the power of its positional order starting from 1. Parameters: n (int): A positive integer Returns: int: Sum of the digits of n each raised to the power of its positional order str_n = str(n) total = 0 for i, digit in enumerate(str_n): total += int(digit) ** (i + 1) return total"},{"question":"Alice loves playing with binary strings. One day, she came across an interesting problem and needs your help to solve it. Given a binary string, she wants to convert it into a string of all zeros with the minimum number of operations. In each operation, she can choose a non-empty contiguous subsequence of the string that consists of all 1's and flip all those bits to 0's. Write a function that returns the minimum number of operations required to convert the given binary string to a string of all zeros. # Input - The input consists of a single line containing a binary string \`s\` (1 ≤ |s| ≤ 10^6). # Output - Print a single integer — the minimum number of operations required to convert \`s\` to a string of all zeros. # Examples Input \`\`\` 010101 \`\`\` Output \`\`\` 3 \`\`\` Input \`\`\` 111000 \`\`\` Output \`\`\` 1 \`\`\` Input \`\`\` 00000 \`\`\` Output \`\`\` 0 \`\`\` Input \`\`\` 1001 \`\`\` Output \`\`\` 2 \`\`\` # Note In the first example, Alice can perform the following operations: - Flip the first 1 bit: 010101 -> 000101 - Flip the next contiguous 1 bit: 000101 -> 000001 - Flip the last contiguous 1 bit: 000001 -> 000000 A total of 3 operations are required. In the second example, all 1 bits are already contiguous, so only 1 operation is required: 111000 -> 000000. In the third example, there are no 1 bits, so no operation is needed.","solution":"def min_operations_to_zero(binary_string): Returns the minimum number of operations required to convert the given binary string to a string of all zeros. if '1' not in binary_string: return 0 count = 0 i = 0 n = len(binary_string) while i < n: if binary_string[i] == '1': count += 1 while i < n and binary_string[i] == '1': i += 1 i += 1 return count"},{"question":"Anna has a special keyboard with only four keys: 'A', 'C', 'V', and 'P'. When Anna presses the 'A' key, it appends the character 'x' to the end of a string. The 'C' key copies the entire current string to the clipboard. The 'V' key pastes the content of the clipboard to the end of the current string. The 'P' key prints the current string to the display. Anna wants to know the minimum number of key presses required to print a string of length n consisting of the character 'x'. Given the constraints, help Anna determine the minimum key presses needed. Input: On the first line, an integer n (1 ≤ n ≤ 100) representing the desired length of the string. Output: Print a single integer — the minimum number of key presses required to obtain a string of length n and print it. Examples: Input 5 Output 5 Input 6 Output 6 Note In the first example, Anna needs to press 'A' five times. In the second example, Anna can press 'A' six times to achieve the desired string.","solution":"def min_key_presses(n): Determines the minimum number of key presses required to print a string of length n consisting of the character 'x'. return n"},{"question":"You find yourself helping a friend with a coding problem for an upcoming contest. The task is to generate a specific sequence of numbers based on given rules and inputs. A sequence is defined where each element is generated based on the sum of a subset of previous elements. Here's how the sequence is defined: - The sequence starts with a single element, 1. - The second element is 1. - From the third element onwards, the n-th element is the sum of the previous k elements in the sequence (k is also an input). For example, if k = 2: - The third element is the sum of the 1st and 2nd elements. - The fourth element is the sum of the 2nd and 3rd elements, and so on. Given two integers m (1 ≤ m ≤ 30) and k (1 ≤ k ≤ 10), you need to generate the first m elements of the sequence. Input The first line contains the integers m and k. Output Print the first m elements of this specific sequence on one line separated by spaces. Examples Input 5 2 Output 1 1 2 3 5 Input 6 3 Output 1 1 2 4 7 13","solution":"def generate_sequence(m, k): Generates a sequence where each element is based on the sum of the previous k elements. :param m: Total number of elements in the sequence to generate. :param k: Number of previous elements to sum for the next element in the sequence. :return: A list containing the first m elements of the sequence. if m == 1: return [1] sequence = [1, 1] for i in range(2, m): next_element = sum(sequence[-k:]) sequence.append(next_element) return sequence[:m]"},{"question":"Alice is working on a new text-based adventure game. In this game, she needs to keep track of the players' items and manage their inventory efficiently. Players can perform various actions such as adding items, removing items, and listing all items in their inventory. The game will receive a series of commands that dictate these actions, and Alice needs to ensure that the correct actions are performed and output as expected. Your task is to create a program that simulates this inventory management system. The program should take the following inputs: 1. An integer \`n\` which represents the number of commands. 2. \`n\` commands, with each command being one of the following: - \`ADD item_name\`: Adds \`item_name\` to the inventory. If the item already exists, do nothing. - \`REMOVE item_name\`: Removes \`item_name\` from the inventory. If the item does not exist, do nothing. - \`LIST\`: Lists all items in the inventory in alphabetical order, separated by commas. The program should output the results of the \`LIST\` commands as they are executed. **Input:** \`\`\` n command1 command2 ... commandn \`\`\` **Output:** The output should consist of the results of the \`LIST\` commands, each on a new line. **Example:** **Input:** \`\`\` 6 ADD sword ADD shield LIST REMOVE shield ADD potion LIST \`\`\` **Output:** \`\`\` shield,sword potion,sword \`\`\` **Explanation:** 1. The first command \`ADD sword\` adds \\"sword\\" to the inventory. 2. The second command \`ADD shield\` adds \\"shield\\" to the inventory. 3. The third command \`LIST\` outputs the list of items in alphabetical order: \\"shield,sword\\". 4. The fourth command \`REMOVE shield\` removes \\"shield\\" from the inventory. 5. The fifth command \`ADD potion\` adds \\"potion\\" to the inventory. 6. The sixth command \`LIST\` outputs the list of items in alphabetical order: \\"potion,sword\\".","solution":"def inventory_management(n, commands): inventory = set() results = [] for command in commands: action = command.split()[0] if action == \\"ADD\\": item = command.split()[1] inventory.add(item) elif action == \\"REMOVE\\": item = command.split()[1] inventory.discard(item) elif action == \\"LIST\\": results.append(\\",\\".join(sorted(inventory))) return results"},{"question":"Problem Description You have recently come across an ancient lock that can only be opened with a special numerical code. The code is a sequence of integers that needs to satisfy a specific pattern. Given an integer N, you need to determine if it is possible to generate a sequence of length N such that: - The sequence consists of distinct integers. - The sum of all integers in the sequence is zero. - The absolute difference between any two consecutive integers in the sequence is at least 2. If such a sequence can be generated, print the sequence. If it is not possible, print \\"impossible\\". Input The first line contains a single integer T, denoting the number of test cases. Each of the next T lines contains a single integer N, denoting the length of the sequence for that test case. Output For each test case, output a single line containing the sequence of integers if it is possible, otherwise print the string \\"impossible\\". Constraints 1 ≤ T ≤ 100 1 ≤ N ≤ 1000 Example Input: 4 3 4 1 5 Output: -1 0 1 -2 -1 1 2 impossible -2 -1 0 1 2 Note: - The sequence must be distinct and the sum must be zero. - The absolute difference between any two consecutive integers must be at least 2.","solution":"def generate_sequence(N): Generates a sequence of length N that satisfies the given conditions. If it is not possible, returns the string \\"impossible\\". if N == 1: return \\"impossible\\" elif N % 2 == 0: # Generate a sequence of N even numbers half_n = N // 2 sequence = list(range(-half_n, 0)) + list(range(1, half_n + 1)) else: # Generate a sequence of N odd numbers including zero half_n = N // 2 sequence = list(range(-half_n, half_n + 1)) return sequence def generate_sequences_for_cases(T, cases): results = [] for N in cases: result = generate_sequence(N) if result == \\"impossible\\": results.append(result) else: results.append(\\" \\".join(map(str, result))) return results"},{"question":"A cryptographer is trying to create a cipher where each letter of the alphabet is mapped to another letter. However, they want their cipher to follow a specific pattern: the letters should be rearranged in such a way that no letter maps to itself. For instance, 'A' should not map to 'A', 'B' should not map to 'B', and so on. Your task is to develop a program that, given an ASCII string consisting of uppercase letters only, generates a new string where each letter is substituted according to the described cipher pattern. Additionally, multiple valid ciphers may exist for a given input, but any valid cipher is acceptable for the output. **Input** The input consists of a single line which is a string \`plaintext\` having only uppercase letters. The length of \`plaintext\` is between 1 and 100 inclusive. **Output** Output a single line which is the encoded message where no letter maps to itself according to the rules specified above. **Example** Input \`\`\` HELLO \`\`\` Output \`\`\` IFMMN \`\`\` Input \`\`\` ABCDEFG \`\`\` Output \`\`\` HBCDEFA \`\`\` Note: The provided output is just an example of one possible valid solution. Your solution might produce a different valid output which satisfies the given conditions.","solution":"import random def generate_cipher(plaintext): Generates a cipher mapping for the given plaintext such that no letter maps to itself. alphabet = list('ABCDEFGHIJKLMNOPQRSTUVWXYZ') shuffled_alphabet = alphabet[:] # Keep shuffling until no letter maps to itself while True: random.shuffle(shuffled_alphabet) if all(a != b for a, b in zip(alphabet, shuffled_alphabet)): break # Create a dictionary to map letters according to the shuffled alphabet cipher_mapping = dict(zip(alphabet, shuffled_alphabet)) # Encode the plaintext using the generated mapping encoded_message = ''.join(cipher_mapping[char] for char in plaintext) return encoded_message"},{"question":"Given an integer \`n\`, write a function to find the number of trailing zeroes in \`n!\` (n factorial). # Function Signature \`\`\`python def count_trailing_zeroes(n: int) -> int: \`\`\` # Input An integer \`n\` such that \`0 ≤ n ≤ 10^9\`. # Output Return an integer representing the number of trailing zeroes in the factorial of \`n\`. # Examples \`\`\`python count_trailing_zeroes(5) # Output: 1 count_trailing_zeroes(10) # Output: 2 count_trailing_zeroes(0) # Output: 0 count_trailing_zeroes(25) # Output: 6 \`\`\` # Note To calculate the number of trailing zeroes in the factorial of \`n\`, you need to determine how many times \`10\` is a factor in the numbers from \`1\` to \`n\`. Since \`10 = 2 * 5\` and there are usually more factors of \`2\` than \`5\`, counting the number of times \`5\` is a factor in these numbers will give the count of trailing zeroes in \`n!\`.","solution":"def count_trailing_zeroes(n: int) -> int: Count the number of trailing zeroes in n!. Args: n (int): The input integer. Returns: int: The number of trailing zeroes in n!. count = 0 while n >= 5: n //= 5 count += n return count"},{"question":"Professor Oak has a new assignment for all trainers. He wants to test their understanding of evolutionary biology in Pokémon by making them work with sequences of numbers. The challenge is based on evolutionary sequences where each number represents a stage of evolution. A Pokémon can evolve from stage i to stage j if and only if stage j is exactly double the stage i (i.e., j = 2 * i). Given an initial stage of evolution, Professor Oak needs you to find out how many unique stages a Pokémon can evolve to in exactly n steps. You are given two numbers: an initial stage s, and the number of evolutionary steps n. You need to determine the number of unique stages after exactly n steps. Input: The first line contains an integer \\"t\\", denoting the number of test cases. Each of the following t lines contains two integers, \\"s\\" and \\"n\\" separated by a space. Output: For each test case, print the number of unique stages in a new line. Constraints: 1 ≤ t ≤ 100,000 1 ≤ s ≤ 10^6 1 ≤ n ≤ 20 SAMPLE INPUT: 3 1 2 2 3 10 1 SAMPLE OUTPUT: 4 8 1 Explanation: For the first test case: s = 1, n = 2 Stages could be: 1 -> 2 -> 4, 1 -> 2 -> 8, 1 -> 4 -> 8, 1 -> 4 -> 16 There are 4 unique stages after 2 steps: 4, 8, 4, 16. So, the answer is 4. For the second test case: s = 2, n = 3 Stages could be: 2 -> 4 -> 8 -> 16, 2 -> 4 -> 8 -> 32, 2 -> 4 -> 16 -> 32, 2 -> 8 -> 16 -> 32 There are 8 unique stages after 3 steps: 16, 32, 64, 128, 16, 32, 32, 128. So, the answer is 8. For the third test case: s = 10, n = 1 Stages could be: 10 -> 20 There is 1 unique stage after 1 step: 20. So, the answer is 1.","solution":"def count_unique_evolution_stages(s, n): Calculates the number of unique stages a Pokémon can evolve to in exactly n steps starting at stage s. stages = {s} for _ in range(n): stages = {2 * stage for stage in stages} return len(stages) def solve_evolution_problem(test_cases): results = [] for s, n in test_cases: results.append(count_unique_evolution_stages(s, n)) return results # Example usage within the solution def main(input_data): lines = input_data.strip().split('n') t = int(lines[0]) test_cases = [tuple(map(int, line.split())) for line in lines[1:t + 1]] results = solve_evolution_problem(test_cases) return \\"n\\".join(map(str, results))"},{"question":"Berland is looking to modernize its postal service. They want to install a new system that will efficiently distribute messages between cities. The messages will be distributed via several postal routes. The objective is to ensure that any city can communicate with any other city either directly through a postal route or indirectly through a series of routes. You are tasked with determining whether the proposed system allows for full communication among all cities. Input The first line contains two integers n and m (1 ≤ n ≤ 100, 0 ≤ m ≤ 100) — the number of cities and the number of proposed postal routes. The next m lines contain two integers ai and bi (1 ≤ ai, bi ≤ n) indicating that there is a direct postal route between city ai and city bi. Output Output \\"YES\\" if every city can communicate with every other city; otherwise, output \\"NO\\". Examples Input 4 4 1 2 2 3 3 4 4 1 Output YES Input 4 2 1 2 3 4 Output NO Input 5 4 1 2 2 3 3 4 4 5 Output YES Input 3 0 Output NO Note In the first example, all cities can communicate with each other through a combination of the given routes. In the second example, there are two separate subsets of cities that cannot communicate with each other. In the third example, a route system from 1 to 2 to 3 to 4 to 5 ensures that all cities can communicate indirectly. In the fourth example, there are no postal routes, thus the cities cannot communicate with each other.","solution":"def can_all_cities_communicate(n, m, routes): from collections import defaultdict, deque if n == 1: return \\"YES\\" if m == 0: return \\"NO\\" graph = defaultdict(list) for a, b in routes: graph[a].append(b) graph[b].append(a) visited = set() def bfs(start): queue = deque([start]) visited.add(start) while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # Start BFS from the first city bfs(1) if len(visited) == n: return \\"YES\\" return \\"NO\\""},{"question":"A company has decided to implement a new password policy that checks for the strength of a password. According to the policy, a password is considered strong if it satisfies the following criteria: 1. It has at least 8 characters. 2. It contains at least one uppercase letter. 3. It contains at least one lowercase letter. 4. It contains at least one digit. 5. It contains at least one special character from the set: \`!@#%^&*()-+=\`. Given a password, your task is to check whether it meets the above criteria. If it does, output \\"Strong\\", otherwise output the first criteria it fails to meet. The criteria should be checked in the order they are listed above. Input The input consists of a single line containing the password. Output Print \\"Strong\\" if the password meets all the criteria, otherwise print the first criteria it fails. Examples Input Passw0rd! Output Strong Input passw0rd Output It lacks an uppercase letter Input PASSWORD1 Output It lacks a lowercase letter Input Passwo! Output It has less than 8 characters Input Password! Output It lacks a digit","solution":"def check_password_strength(password): if len(password) < 8: return \\"It has less than 8 characters\\" if not any(c.isupper() for c in password): return \\"It lacks an uppercase letter\\" if not any(c.islower() for c in password): return \\"It lacks a lowercase letter\\" if not any(c.isdigit() for c in password): return \\"It lacks a digit\\" if not any(c in '!@#%^&*()-+=' for c in password): return \\"It lacks a special character from the set: !@#%^&*()-+=\\" return \\"Strong\\""},{"question":"Transforming Points Given a set of points on a 2D Cartesian plane, your task is to determine the minimum number of operations required to make all points collinear (placed in a straight line). (Operations): In one operation, you can move any single point to any other point on the plane. Points are represented by their coordinates (x, y) and it is guaranteed that no three points are initially collinear. Input The first line of the input contains an integer n (1 ≤ n ≤ 200), representing the number of points. The following n lines each contain two integers x and y (-1000 ≤ x, y ≤ 1000), representing the coordinates of a point. Output For each test case, output the minimum number of operations required to make all points collinear. If no operations are needed, output \`0\`. Sample Input 1 3 0 0 1 1 2 3 Sample Output 1 1 Sample Input 2 4 1 2 3 5 6 6 7 7 Sample Output 2 2 Explanation: In the eerste sample case, one possible solution is to move the point (2,3) to (2,2), making the points with coordinates (0,0), (1,1), and (2,2) collinear. In the second sample case, a possible solution is to move points (3,5) to (2,4) and (6,6) to (4,5), making the points (1,2), (2,4), and (4,5) collinear with 2 operations.","solution":"from itertools import combinations def min_operations_to_make_collinear(points): n = len(points) if n <= 2: return 0 def are_collinear(p1, p2, p3): # Calculate the area of the triangle formed by the points # If the area is zero, then the points are collinear return (p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])) == 0 min_operations = float('inf') for p1, p2 in combinations(points, 2): current_operations = 0 for p in points: if not are_collinear(p1, p2, p): current_operations += 1 min_operations = min(min_operations, current_operations) return min_operations def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) points = [] for i in range(n): x = int(data[2 * i + 1]) y = int(data[2 * i + 2]) points.append((x, y)) print(min_operations_to_make_collinear(points))"},{"question":"You are given an integer matrix of dimensions N x M (1 ≤ N, M ≤ 100), where each element is either 0 or 1. Your task is to find the largest square sub-matrix that consists entirely of 1s. Input - An integer N denoting the number of rows. - An integer M denoting the number of columns. - A 2D list of integers where each integer is either 0 or 1. Output Print the side length of the largest square sub-matrix that contains all 1s. If no such sub-matrix exists, print 0. Examples Input 4 5 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 Output 2 Input 3 3 0 0 0 0 0 0 0 0 0 Output 0","solution":"def largest_square_submatrix(matrix): if not matrix: return 0 N = len(matrix) M = len(matrix[0]) dp = [[0] * M for _ in range(N)] max_side = 0 # Initialize the matrix with original matrix values for i in range(N): for j in range(M): if matrix[i][j] == 1: dp[i][j] = 1 max_side = 1 # Process the matrix for i in range(1, N): for j in range(1, M): if matrix[i][j] == 1: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"Given a programming language, you need to write an interpreter that processes a sequence of commands to manipulate an integer variable, initially set to zero. The commands are as follows: - \\"increment\\": Increases the value of the integer variable by 1. - \\"decrement\\": Decreases the value of the integer variable by 1. - \\"double\\": Multiplies the value of the integer variable by 2. - \\"halve\\": Divides the value of the integer variable by 2 using integer division (i.e., the result is rounded down). The commands will be provided in a sequence, and you need to process them in the given order. Additionally, after processing all the commands, you need to provide the final value of the integer variable. # Input The input is given in the following format: - The first line contains an integer \`N\` (1 ≤ N ≤ 1000), which represents the number of commands. - The next \`N\` lines each contain one of the four commands as described above. # Output Output the final value of the integer variable after all commands have been processed. # Example Input: \`\`\` 5 increment increment double decrement halve \`\`\` Output: \`\`\` 1 \`\`\` Explanation: 1. Initial value: 0 2. First command is increment: 0 + 1 = 1 3. Second command is increment: 1 + 1 = 2 4. Third command is double: 2 * 2 = 4 5. Fourth command is decrement: 4 - 1 = 3 6. Fifth command is halve: 3 // 2 = 1 Final value: 1","solution":"def process_commands(commands): Process a sequence of commands to manipulate an integer variable. Args: commands: List of strings where each string is a command. Returns: int: The final value of the integer variable after processing all commands. value = 0 for command in commands: if command == \\"increment\\": value += 1 elif command == \\"decrement\\": value -= 1 elif command == \\"double\\": value *= 2 elif command == \\"halve\\": value //= 2 return value # Example usage: # N = 5 # commands = [\\"increment\\", \\"increment\\", \\"double\\", \\"decrement\\", \\"halve\\"] # print(process_commands(commands))"},{"question":"You are given an array of n positive integers. A subarray is defined as a contiguous block of elements from the original array. We define the beauty of a subarray as the difference between the maximum and minimum element in that subarray. Your task is to find the maximum possible beauty of any subarray of the array. Input The first line of input contains a single integer n (1 ≤ n ≤ 10^5), representing the number of elements in the array. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 10^9), representing the elements of the array. Output Output a single integer representing the maximum beauty of any subarray in the array. Example Input 5 1 3 5 9 7 Output 8 Input 7 4 4 4 4 4 4 4 Output 0 Input 6 1 2 3 1 2 3 Output 2 Note In the first sample, the subarray [1, 3, 5, 9] has the maximum beauty of 9 - 1 = 8. In the second sample, all elements are the same, so the beauty of any subarray is 0. In the third sample, the subarray [1, 3] or [3, 1] has the maximum beauty of 2.","solution":"def max_beauty_of_subarray(n, arr): Returns the maximum beauty of any subarray in the given array. The beauty of a subarray is defined as the difference between the maximum and minimum elements in that subarray. if n <= 1: return 0 max_beauty = 0 min_element = arr[0] max_element = arr[0] for num in arr: if num < min_element: min_element = num if num > max_element: max_element = num current_beauty = max_element - min_element if current_beauty > max_beauty: max_beauty = current_beauty return max_beauty"},{"question":"You are tasked with developing a warehouse management system to help organize the inventory on the shelves. The items in the warehouse are identified by unique product codes which are strings consisting of alphanumeric characters. Since multiple shipments can arrive, and orders can deplete the supply, the system needs to maintain a current list of items in stock, and ensure they are always sorted. Your task is to write a function that receives batches of product codes from multiple test cases and maintains them sorted. For each test case, print the product codes in lexicographical order. Input: There are multiple test cases. Each test case consists of an integer N indicating the number of product codes. Followed by N lines, each having a single product code. The input terminates with an integer 0, which should not be processed. Output: For each test case, print the lexicographically sorted product codes, each on a new line. Separate results of different test cases with a blank line. Constraints: 1 ≤ T ≤ 100 1 ≤ N ≤ 100000 SAMPLE INPUT 5 apple banana apricot kiwi pear 3 zebra antelope monkey 0 SAMPLE OUTPUT apple apricot banana kiwi pear antelope monkey zebra","solution":"def process_batches(batches): Processes the given test cases to print product codes in lexicographical order for each batch. Parameters: batches (list of list of str): A list of batches, where each batch is a list of product codes. results = [] for batch in batches: sorted_batch = sorted(batch) results.append('n'.join(sorted_batch)) return 'nn'.join(results) def parse_input(input_string): Parses the input string into batches of product codes. Parameters: input_string (str): The input string containing multiple batches of product codes. Returns: list of list of str: Parsed batches of product codes. lines = input_string.strip().split('n') batches = [] i = 0 while i < len(lines): n = int(lines[i]) if n == 0: break i += 1 batch = [] for _ in range(n): batch.append(lines[i]) i += 1 batches.append(batch) return batches def main(input_string): Main function to drive the processing and output. Parameters: input_string (str): The input string containing multiple batches of product codes. Returns: str: Formatted output containing lexicographically sorted product codes. batches = parse_input(input_string) return process_batches(batches) # Example usage: # input_string = '''5 # apple # banana # apricot # kiwi # pear # 3 # zebra # antelope # monkey # 0''' # print(main(input_string))"},{"question":"Shila is a hardware enthusiast and enjoys tinkering with various electronic components. She recently developed a robotic arm controlled by a software that she wrote herself. The arm can perform a number of basic operations, such as picking up objects, placing them down, moving in different directions, and rotating at specific angles. To test the capabilities of her robotic arm, she devised a series of operations that need to be executed efficiently. The operations are given in a sequence and each operation has a time cost associated with it. Shila wants to optimize the sequence of operations to minimize the overall cost. You are given a list of operations, where each operation can be of the following types: \\"pick\\", \\"place\\", \\"move\\", \\"rotate\\". Each type of operation has a specific time cost, and moving to a new position has an additional distance-based cost. Write a program to compute the minimum total time required to execute the given sequence of operations. Input The first line of the input file contains four integers tp, tpl, tm, tr — the time cost for \\"pick\\", \\"place\\", \\"move\\", and \\"rotate\\" operations respectively. The second line contains an integer n (1 ≤ n ≤ 100) — the number of operations. The following n lines describe the operations in the sequence they are to be performed. Each operation is described by its type and necessary parameters. For \\"pick\\" and \\"place,\\" no additional parameters are needed. For \\"move,\\" two integers x and y are provided representing the coordinates (in meters) to which the arm should move. For \\"rotate,\\" one integer θ (in degrees) is provided indicating the angle to rotate. Output Output a single integer — the minimum total time required to execute the given sequence of operations. Example Input 2 3 1 4 5 move 3 4 pick rotate 90 move 6 8 place Output 29 Explanation: 1. \\"move 3 4\\": Cost = 1 * (3^2 + 4^2)^(1/2) + tm = 1 * 5 + 1 = 6 2. \\"pick\\": Cost = tp = 2 3. \\"rotate 90\\": Cost = tr = 4 4. \\"move 6 8\\": Cost = 1 * (3^2 + 4^2)^(1/2) + tm = 1 * 5 + 1 = 6 5. \\"place\\": Cost = tpl = 3 Total cost = 6 + 2 + 4 + 6 + 3 = 21","solution":"import math def calculate_total_time(tp, tpl, tm, tr, operations): total_time = 0 current_position = (0, 0) for operation in operations: if operation[0] == \\"pick\\": total_time += tp elif operation[0] == \\"place\\": total_time += tpl elif operation[0] == \\"move\\": x, y = int(operation[1]), int(operation[2]) distance = math.sqrt((x - current_position[0]) ** 2 + (y - current_position[1]) ** 2) total_time += tm + distance current_position = (x, y) elif operation[0] == \\"rotate\\": total_time += tr return int(total_time)"},{"question":"For a given array of integers, determine the length of the longest subsequence that is non-decreasing. Constraints * 1 ≤ n ≤ 1000 * -10000 ≤ ai ≤ 10000 Input The entire input looks like: t (the number of test cases) 1st test case 2nd test case ... tth test case Each test case consists of an integer n (the number of elements in the array) followed by n integers ai (the elements of the array). Output For each test case, print the length of the longest non-decreasing subsequence. Example Input 2 5 1 3 2 3 4 6 3 1 2 1 3 4 Output 4 4","solution":"def longest_non_decreasing_subsequence(arr): Returns the length of the longest non-decreasing subsequence. n = len(arr) if n == 0: return 0 # Initialize the dp array with 1 as each element is a subsequence of length 1 dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] >= arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def find_longest_subsequence(test_cases): results = [] for case in test_cases: n, *arr = case results.append(longest_non_decreasing_subsequence(arr)) return results"},{"question":"You are given a list of integers and you need to find the maximum sum of a contiguous subarray. This problem is known as the \\"Maximum Subarray Problem\\" and can be solved using a variety of techniques ranging from brute force to more optimized algorithms like Kadane's algorithm. Input The first line of the input contains an integer n (1 ≤ n ≤ 10^5) — the length of the array. The second line contains n integers separated by spaces representing the array elements. Each element of the array is a number between -10^4 and 10^4. Output Output a single integer representing the maximum sum of a contiguous subarray. Examples Input 9 -2 1 -3 4 -1 2 1 -5 4 Output 6 Note In the given example the contiguous subarray with the largest sum is [4, -1, 2, 1], which has a sum of 6.","solution":"def max_subarray_sum(nums): Returns the maximum sum of a contiguous subarray. max_ending_here = max_so_far = nums[0] for num in nums[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"You are given an unbalanced tree where each node has a value, and the tree may have an arbitrary number of child nodes. Your task is to find the sum of the values of all nodes at the maximum depth of the tree. Write a program that computes this sum. Input: A tree is provided in the JSON format where each node is represented by an object containing the \`value\` of the node and a list of \`children\`, which are themselves nodes formatted in the same manner. Output: Print the sum of the values of all nodes at the maximum depth of the tree. Example: Input: { \\"value\\": 1, \\"children\\": [ { \\"value\\": 2, \\"children\\": [ { \\"value\\": 4, \\"children\\": [] }, { \\"value\\": 5, \\"children\\": [] } ] }, { \\"value\\": 3, \\"children\\": [ { \\"value\\": 6, \\"children\\": [ { \\"value\\": 7, \\"children\\": [] } ] } ] } ] } Output: 12","solution":"def sum_at_max_depth(tree): if not tree: return 0 from collections import deque queue = deque([(tree, 0)]) # (node, depth) max_depth = -1 depth_sum = 0 while queue: node, depth = queue.popleft() if depth > max_depth: max_depth = depth depth_sum = node['value'] elif depth == max_depth: depth_sum += node['value'] for child in node['children']: queue.append((child, depth + 1)) return depth_sum # Test Tree Structure tree = { \\"value\\": 1, \\"children\\": [ { \\"value\\": 2, \\"children\\": [ { \\"value\\": 4, \\"children\\": [] }, { \\"value\\": 5, \\"children\\": [] } ] }, { \\"value\\": 3, \\"children\\": [ { \\"value\\": 6, \\"children\\": [ { \\"value\\": 7, \\"children\\": [] } ] } ] } ] } # Example usage: print(sum_at_max_depth(tree)) # Output: 12"},{"question":"Stacy loves patterns and is very fond of the Fibonacci sequence. After learning about it, she started creating her own variations of it. One day she came up with an idea to create a sequence based on two specific starting integers and a unique rule for generating the next element in the sequence: Given two starting integers \`a\` and \`b\`, the next element in the sequence is determined by the sum of the squares of the previous two elements. Formally, the sequence S is defined as: - S[1] = a - S[2] = b - S[n] = S[n-1]^2 + S[n-2]^2 for n > 2 Your task is to write a program that generates the first \`n\` elements of this sequence. Input The first line contains a single integer n (2 ≤ n ≤ 30) — the number of elements in the sequence. The second line contains two integers a and b (1 ≤ a, b ≤ 300) — the starting integers of the sequence. Output Print exactly n integers — the first n elements of the sequence. Examples Input 5 1 2 Output 1 2 5 29 866 Input 3 2 3 Output 2 3 13 Note In the first example, the sequence is formed as follows: - S[1] = 1 - S[2] = 2 - S[3] = 1^2 + 2^2 = 1 + 4 = 5 - S[4] = 2^2 + 5^2 = 4 + 25 = 29 - S[5] = 5^2 + 29^2 = 25 + 841 = 866 In the second example, the sequence is formed as follows: - S[1] = 2 - S[2] = 3 - S[3] = 2^2 + 3^2 = 4 + 9 = 13","solution":"def generate_sequence(n, a, b): Generate a sequence based on the given rules. :param n: int, the number of elements in the sequence :param a: int, first starting integer :param b: int, second starting integer :return: list of first n elements of the sequence sequence = [a, b] for i in range(2, n): next_element = sequence[-1]**2 + sequence[-2]**2 sequence.append(next_element) return sequence"},{"question":"Willem wants to create a new sign for his shop. He took a large wooden plank and wrote a string \`s\` of lowercase English letters on it. While working, he accidentally made a mistake and now some letters are taller than others. To fix this, Grick gave Willem several instructions to change the height of letters on the plank. Willem needs to follow \`m\` operations, each operation has three parameters \`l\`, \`r\`, \`h\` which means that all the letters in the range \`[l, r]\` (from l-th to r-th, including l and r) need to be set to height \`h\`. Grick wants to know the final heights of all letters on the plank after performing the \`m\` operations. Input The first line contains two integers \`n\` and \`m\` (1 ≤ n, m ≤ 100). The second line contains a string \`s\` of length \`n\`, consisting of lowercase English letters. The third line contains \`n\` integers representing the initial heights of the letters in the string \`s\`. Each of the next \`m\` lines contains three parameters \`l\`, \`r\`, \`h\` (1 ≤ l ≤ r ≤ n, 1 ≤ h ≤ 100), separated by space. Output Output a single line of \`n\` integers representing the final heights of the letters on the plank after performing all \`m\` operations. Examples Input 5 2 abcde 1 2 3 4 5 1 3 10 2 4 20 Output 10 20 20 20 5 Input 4 1 xyzw 5 5 5 5 1 4 15 Output 15 15 15 15 Note For the first example: - After the first operation, the heights are [10, 10, 10, 4, 5]. - After the second operation, the heights are [10, 20, 20, 20, 5]. For the second example: - After the operation, the heights of all the letters are set to 15.","solution":"def update_heights(n, m, s, initial_heights, operations): Update the heights of the letters on the plank after performing the given operations. Args: n (int): The length of the string. m (int): The number of operations. s (str): The string of lowercase English letters on the plank. initial_heights (list of int): Initial heights of the letters. operations (list of tuples): List containing m operations, each given as (l, r, h). Returns: list of int: Final heights of the letters on the plank. heights = initial_heights.copy() for l, r, h in operations: for i in range(l - 1, r): heights[i] = h return heights"},{"question":"A large company has a network of employees that can be represented as a tree structure. The company wants to host a party and invite as many employees as possible, but it must follow a particular rule: if an employee is invited, none of their direct subordinates can be invited. Each employee has a happiness value indicating how happy they would be if invited to the party. The company's objective is to maximize the sum of the happiness values of the invited employees while adhering to the invitation rule. Input The first line contains an integer n (1 ≤ n ≤ 10^5) — the number of employees. The second line contains n integers h_1, h_2, ..., h_n (1 ≤ h_i ≤ 10^4), where h_i represents the happiness value of the i-th employee. The following n - 1 lines each contain two integers u and v (1 ≤ u, v ≤ n), denoting that employee u is a direct subordinate of employee v, or vice versa. Output Print one integer — the maximum possible happiness value sum of the invited employees. Example Input 5 1 2 3 4 5 1 2 1 3 3 4 3 5 Output 11 Explanation In this example, the optimal set of invited employees is {2, 4, 5} since inviting employees 1 or 3 would prevent inviting their subordinates. The maximum happiness value sum is 2 + 4 + 5 = 11.","solution":"def max_happiness(n, happiness, relations): from collections import defaultdict, deque tree = defaultdict(list) for u, v in relations: tree[u-1].append(v-1) tree[v-1].append(u-1) dp = [[0, 0] for _ in range(n)] def dfs(node, parent): dp[node][1] = happiness[node] for child in tree[node]: if child == parent: continue dfs(child, node) dp[node][0] += max(dp[child][0], dp[child][1]) dp[node][1] += dp[child][0] dfs(0, -1) return max(dp[0][0], dp[0][1])"},{"question":"You are given a connected undirected graph with \`n\` nodes and \`m\` edges. The goal is to remove some of the edges such that the remaining graph has exactly \`k\` connected components. Your task is to determine the minimum number of edges that need to be removed in order to achieve exactly \`k\` connected components. If it's not possible to achieve exactly \`k\` connected components by removing edges, print \`-1\`. Input: - The first line contains three integers \`n\` (2 ≤ n ≤ 100), \`m\` (1 ≤ m ≤ 200), and \`k\` (1 ≤ k ≤ n). - The next \`m\` lines each contain two integers \`u\` and \`v\` (1 ≤ u, v ≤ n), representing an undirected edge between node \`u\` and node \`v\`. Output: - Print a single integer representing the minimum number of edges to be removed to get exactly \`k\` connected components, or \`-1\` if it is not possible to achieve exactly \`k\` connected components. Example: Input: \`\`\` 5 5 3 1 2 1 3 2 3 3 4 4 5 \`\`\` Output: \`\`\` 2 \`\`\` Note: In the example, - Initially, the graph has 1 connected component. - If you remove the edges (3,4) and (4,5), you will have exactly 3 connected components: {1, 2, 3}, {4}, and {5}. - Therefore, the minimum number of edges to remove is 2.","solution":"def find_min_edges_to_remove(n, m, k, edges): if k > n: return -1 from collections import defaultdict, deque graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def bfs(node, visited): queue = deque([node]) visited.add(node) while queue: u = queue.popleft() for v in graph[u]: if v not in visited: visited.add(v) queue.append(v) # Find initial number of components visited = set() initial_components = 0 for node in range(1, n + 1): if node not in visited: bfs(node, visited) initial_components += 1 # If initial number of components is greater than k, it's impossible to achieve k components if initial_components > k: return -1 # Minimum number of edges to remove is the difference between initial and desired number of components return k - initial_components # Example usage: n = 5 m = 5 k = 3 edges = [(1, 2), (1, 3), (2, 3), (3, 4), (4, 5)] print(find_min_edges_to_remove(n, m, k, edges)) # Output should be 2"},{"question":"David is organizing his bookshelf and wants to sort his books based on the number of pages, but with an interesting twist. For a given number of books, he has to achieve the following specifics: if two books have the same number of pages, he wants the book that was initially earlier in his unsorted list to come first in his sorted list. Furthermore, David decides that he will categorize books into \\"niche\\" if their number of pages starts with the digit '1'. Your task is to help David sort his books while considering these conditions. Books are represented with their page counts in an array. Write a function \`sort_books\` that takes a list of integers representing the number of pages of each book and sorts them in descending order while maintaining the original order for books that have the same number of pages. **Input** - The first line contains a single integer \`N\` (1 ≤ N ≤ 100000), the number of books. - The second line contains \`N\` integers \`P1, P2, ..., PN\` (1 ≤ Pi ≤ 100000), representing the number of pages of each book. **Output** - Print the sorted list of books respecting the above constraints. **Example** _Input:_ 5 121 32 105 123 17 _Output:_ [32, 123, 121, 17, 105] _Input:_ 6 10 123 110 15 15 123 _Output:_ [15, 15, 123, 123, 110, 10] **Explanation** In the first example, the sorted list \`32, 123, 121, 17, 105\` puts books with the same number of pages maintaining their original order. In the second example, both occurrences of \`15\` appear before \`10\` and \`123\` entries are adjacent reflecting the original order they appeared. **Note** To solve this problem, you may need to consider: - A stable sorting algorithm to maintain the relative order of duplicate items. - Custom sorting criteria where sorting priorities supersede in the specific order. Write the function \`sort_books\` as follows: \`\`\`python def sort_books(N, P): # Your code here # The function should print the sorted list of page numbers \`\`\`","solution":"def sort_books(N, P): Sorts a list of book page counts in descending order while maintaining the original order for books that have the same number of pages. # Using a key function that returns a tuple needed to sort by values (descending) # while maintaining original order for ties. sorted_books = sorted(P, key=lambda x: (-x, P.index(x))) return sorted_books"},{"question":"You are given an array of integers and need to perform a series of operations on it. In each operation, you can choose any two elements of the array, replace them with their sum, and then append this sum back to the array. The goal is to minimize the number of distinct integers in the array after performing any number of such operations. Write a function that takes an array of integers and returns the minimum number of distinct integers that can remain in the array after any number of the described operations. Constraints * 1 leq arr.length leq 10^5 * 1 leq arr[i] leq 10^9 Input Input is given from Standard Input in the following format: n arr_1 arr_2 ... arr_n Output Print the minimum number of distinct integers that can remain in the array after performing the operations. Examples Input 5 1 2 2 3 3 Output 1 Input 6 4 5 6 7 8 9 Output 6","solution":"def min_distinct_integers(arr): Returns the minimum number of distinct integers that can remain in the array after any number of the described operations. # The minimum number of distinct integers is always 1 # Why? Because we can always sum everything into a single number return 1"},{"question":"David is an enthusiastic gardener. He has a piece of land split into n square plots arranged in a single row. Each plot can be either empty or planted with a type of flower. The types of flowers are numbered from 1 to k. David wants to plant flowers in a way that maximizes the beauty of his garden. The beauty of the garden is defined as the total number of different types of flowers present in the most beautiful segment of the land. A segment is any contiguous subarray of the land's plots. David needs your help to find the optimal planting strategy. You are required to determine the maximum beauty value for the entire row of plots. Input The first line of input contains two integers n and k (1 ≤ n ≤ 100, 1 ≤ k ≤ 100) — the number of plots and the number of types of flowers. The second line contains n integers, where the i-th integer represents the type of flower in the i-th plot (a 0 indicates an empty plot). All numbers are between 0 and k (both inclusive). Output Print a single integer — the maximum beauty value for the entire row of plots. Examples Input 7 3 1 2 0 2 1 3 0 Output 3 Input 5 2 1 0 1 0 2 Output 2 Input 8 4 0 0 0 0 1 2 3 4 Output 4 Note In the first example, the most beautiful segment is [2, 1, 3], which contains all the three flower types (1, 2, and 3). Hence, the maximum beauty value is 3. In the second example, the segments [1, 0, 1] and [1, 2] both have the maximum beauty value of 2, as flower types 1 and 2 are present. In the third example, the segment [1, 2, 3, 4] contains all four flower types, making the maximum beauty value 4.","solution":"def max_beauty(n, k, garden): Returns the maximum beauty value for the entire row of plots. Parameters: n (int): The number of plots. k (int): The number of types of flowers. garden (list of int): The types of flowers in the plots (0 indicates an empty plot). Returns: int: The maximum beauty value. max_beauty = 0 for start in range(n): different_flowers = set() for end in range(start, n): if garden[end] != 0: different_flowers.add(garden[end]) max_beauty = max(max_beauty, len(different_flowers)) return max_beauty"},{"question":"On a distant planet, there are n types of raw materials used to create various products. The planetary scientists have devised a method to predict the yield from each raw material type over time. Each type of raw material regenerates at a fixed quantity every day. To plan for future production, the scientists need to determine the total yield they can expect after d days for the combined raw materials. Your task is to help them with this calculation. The input consists of: - A single integer n (1 ≤ n ≤ 100), the number of types of raw materials. - A sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 1000), where ai is the daily yield of the i-th raw material type. - A single integer d (1 ≤ d ≤ 1000), representing the number of days. Output the total yield of raw materials after d days. Input The first line contains a single integer n. The second line contains n space-separated integers a1, a2, ..., an. The third line contains a single integer d. Output Output a single integer — the total yield of all raw materials after d days. Examples Input 3 5 8 6 10 Output 190 Input 2 7 3 4 Output 40 Input 1 12 7 Output 84","solution":"def total_yield(n, yields, d): Calculate the total yield of all raw materials after d days. :param n: int, number of types of raw materials :param yields: list of int, daily yield of each type of raw material :param d: int, number of days :return: int, total yield after d days return sum(yields) * d"},{"question":"A bookstore offers a multiple book discount. If you buy 3 or more books at once, you will get a 20% discount on the total price of the books. If you buy fewer than 3 books, you will not get any discount. Given the price of each book you want to buy, determine the final total price you will have to pay after applying the discount if applicable. Constraints: - 1 leq N leq 100 - 1 leq Price of each book leq 1000 - N represents the number of books. - All prices are integers. Input The input is given from Standard Input in the following format: \`\`\` N price_1 price_2 ... price_N \`\`\` Output Print the final total price after applying the discount, rounded down to the nearest integer. Examples Input \`\`\` 2 500 300 \`\`\` Output \`\`\` 800 \`\`\` Input \`\`\` 3 200 150 100 \`\`\` Output \`\`\` 360 \`\`\` Input \`\`\` 4 100 200 300 400 \`\`\` Output \`\`\` 800 \`\`\`","solution":"def calculate_final_price(N, prices): Calculates the final price after applying discounts if applicable. :param N: int, number of books :param prices: list of int, prices of the books :return: int, final price rounded down to the nearest integer total_price = sum(prices) if N >= 3: total_price *= 0.8 return int(total_price)"},{"question":"You are given two strings, S and T, each of length N. Your task is to count the minimum number of character substitutions required to make string S equal to string T. You can replace any character in S with any other character. Constraints * 1 ≤ N ≤ 10^5 * S and T consist only of lowercase English letters (a-z). Input Input is given from Standard Input in the following format: \`\`\` N S T \`\`\` Output Print the minimum number of substitutions required to make S equal to T. Examples Input \`\`\` 5 abcde bcdef \`\`\` Output \`\`\` 5 \`\`\` Input \`\`\` 5 abcde abxyz \`\`\` Output \`\`\` 3 \`\`\`","solution":"def count_substitutions(N, S, T): Returns the minimum number of character substitutions required to make string S equal to string T. substitutions_count = 0 for i in range(N): if S[i] != T[i]: substitutions_count += 1 return substitutions_count"},{"question":"Given a string \`s\` consisting of lowercase English letters, your task is to determine if the string is a \\"balanced string.\\" A string is considered balanced if it contains either: - Exactly one unique character, or - Exactly two unique characters that occur the same number of times. For example, the strings \\"aaaa\\", \\"aabb\\", and \\"ccddccdd\\" are all balanced, but \\"aabbcc\\", \\"abccc\\", and \\"abcd\\" are not. Input - The first line contains the integer \`t\` (1 ≤ t ≤ 50) — the number of test cases. - The following \`t\` lines each contain a string \`s\` (1 ≤ |s| ≤ 100), consisting of lowercase English letters. Output - For each test case, output \\"YES\\" (without quotes) if the string is balanced, otherwise print \\"NO\\" (without quotes). Examples Input \`\`\` 4 aaaa aabb ccddccdd abcd \`\`\` Output \`\`\` YES YES YES NO \`\`\` Input \`\`\` 3 abc aaaabbbb xyzxyz \`\`\` Output \`\`\` NO YES NO \`\`\` Note In the first example: - \\"aaaa\\" contains only one unique character. - \\"aabb\\" contains two unique characters 'a' and 'b', both occurring twice. - \\"ccddccdd\\" contains two unique characters 'c' and 'd', both occurring four times. - \\"abcd\\" contains four unique characters, so it is not balanced. In the second example: - \\"abc\\" contains three unique characters. - \\"aaaabbbb\\" contains two unique characters 'a' and 'b', both occurring four times. - \\"xyzxyz\\" contains three unique characters.","solution":"def is_balanced_string(s): from collections import Counter count = Counter(s) unique_chars = len(count) if unique_chars == 1: return \\"YES\\" elif unique_chars == 2: frequencies = list(count.values()) if frequencies[0] == frequencies[1]: return \\"YES\\" return \\"NO\\" def check_balanced_strings(test_cases): results = [] for case in test_cases: results.append(is_balanced_string(case)) return results"},{"question":"Alice and Bob are fond of solving puzzles and playing games. One day, Bob challenges Alice to a game involving a numbered grid. The grid has M rows and N columns, where each cell contains a number. Alice needs to find out the total sum of numbers from the top-left corner (1,1) to a given cell (i, j) repeatedly for multiple queries. Input: The first line contains M and N, the dimensions of the grid. The next M lines contain N space-separated integers each, representing the grid. The following line contains Q, the number of queries. Q lines follow, each containing two space-separated integers i and j, representing the row and column indices (1-indexed) for which Alice needs to calculate the sum. Output: For each query, output the sum of the numbers in the sub-grid from the top-left corner (1,1) to (i,j). Constraints: 1 ≤ M, N ≤ 1000 1 ≤ Grid values ≤ 100 1 ≤ Q ≤ 1000 1 ≤ i ≤ M 1 ≤ j ≤ N SAMPLE INPUT 3 3 1 2 3 4 5 6 7 8 9 2 1 1 3 3 SAMPLE OUTPUT 1 45","solution":"def precompute_sums(grid, M, N): Precomputes the prefix sums for the grid to allow quick sum calculation for any sub-grid. prefix_sums = [[0] * (N + 1) for _ in range(M + 1)] for i in range(1, M + 1): for j in range(1, N + 1): prefix_sums[i][j] = grid[i-1][j-1] + prefix_sums[i-1][j] + prefix_sums[i][j-1] - prefix_sums[i-1][j-1] return prefix_sums def query_sum(prefix_sums, i, j): Returns the sum of the sub-grid from (1,1) to (i,j) using the precomputed prefix sums. return prefix_sums[i][j] def main(M, N, grid, queries): Main function to handle the input, process the grid and queries, and output the results. prefix_sums = precompute_sums(grid, M, N) results = [] for query in queries: i, j = query results.append(query_sum(prefix_sums, i, j)) return results"},{"question":"Given an array of N integers, you need to perform Q query operations on it. Each query consists of two integers L and R (1 <= L <= R <= N), and returns the sum of the array elements from the L-th to the R-th position (both inclusive). Implement the function that processes the queries efficiently. Input The first line contains the number N and Q. The second line contains the N integers of the array. The following Q lines contain two integers each, L and R, representing the query range. Output For each query, output the sum of the elements of the array from index L to R in a new line. Constraints 1 <= N <= 10^5 1 <= Q <= 10^5 -10^9 <= Ai <= 10^9 Example Input: 5 3 1 2 3 4 5 1 3 2 4 1 5 Output: 6 9 15","solution":"def process_queries(N, Q, array, queries): Process queries on array to return sum of subarray elements. Parameters: N (int): Number of elements in the array. Q (int): Number of queries. array (list): List of N integers. queries (list): List of Q queries, each query is a tuple (L, R). Returns: list: List of sum results for each query. # Compute prefix sums prefix_sums = [0] * (N + 1) for i in range(1, N + 1): prefix_sums[i] = prefix_sums[i - 1] + array[i - 1] # Process each query using the prefix sums results = [] for L, R in queries: sum_subarray = prefix_sums[R] - prefix_sums[L - 1] results.append(sum_subarray) return results"},{"question":"Sam is a software developer and he's working on implementing a new feature. He needs to analyze prices of certain software products. The prices are given as an array of integers, where each integer represents the price of one product. Sam wants to find the longest contiguous subarray where the difference between the maximum and minimum prices in that subarray is less than or equal to a given integer K. Given an array of integers and the integer K, help Sam by writing a function that returns the length of the longest such subarray. Input The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases. The first line of each test case contains two integers n (1 ≤ n ≤ 10^5) — the number of elements in the array and K (0 ≤ K ≤ 10^9). The second line contains n integers representing the array of prices. It is guaranteed that the sum of n over all test cases does not exceed 10^5. Output For each test case, print a single integer — the length of the longest subarray where the difference between the maximum and minimum prices is less than or equal to K. Example Input 3 5 2 1 3 2 4 2 6 5 7 3 5 1 8 10 4 0 5 5 5 5 Output 4 3 4 Explanation In the first test case, the longest subarray that meets the condition is [1, 3, 2, 2] where the difference between the maximum (3) and minimum (1) prices is exactly 2. In the second test case, the longest subarray that meets the condition is [7, 3, 5] where the difference between the maximum (7) and minimum (3) prices is 4, which is less than 5. In the third test case, all elements are the same so the condition is met for all subarrays; hence, the length of the longest subarray is 4.","solution":"def longest_subarray_with_price_difference(prices, k): from collections import deque min_deque = deque() max_deque = deque() left = 0 result = 0 for right in range(len(prices)): while min_deque and prices[min_deque[-1]] > prices[right]: min_deque.pop() while max_deque and prices[max_deque[-1]] < prices[right]: max_deque.pop() min_deque.append(right) max_deque.append(right) while prices[max_deque[0]] - prices[min_deque[0]] > k: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() result = max(result, right - left + 1) return result def process_test_cases(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][0] prices = test_cases[i][1] results.append(longest_subarray_with_price_difference(prices, k)) return results"},{"question":"Problem Description Elena has been given a challenge by her math professor to calculate the sum of all prime numbers less than or equal to a given integer. She needs to find the solution quickly using an efficient algorithm due to the time constraints. Help Elena by writing a program that accomplishes this task. # Input The input consists of a single integer N. # Output The output should be a single integer representing the sum of all prime numbers less than or equal to N. # Constraints 1 ≤ N ≤ 10,000 # Example Input: 10 Output: 17 (Note: Prime numbers <= 10 are 2, 3, 5, 7 and their sum is 17)","solution":"def sum_of_primes(N): Returns the sum of all prime numbers less than or equal to N using the Sieve of Eratosthenes algorithm. if N < 2: return 0 sieve = [True] * (N + 1) sieve[0], sieve[1] = False, False for i in range(2, int(N**0.5) + 1): if sieve[i]: for j in range(i * i, N + 1, i): sieve[j] = False return sum(i for i, is_prime in enumerate(sieve) if is_prime)"},{"question":"A forest ranger is working on a project to assess the health of different tree species in the forest. There are M species of trees, and for each species, the ranger records the heights of N trees. A tree species is categorized as \\"uniform\\" if the difference in height between the tallest and shortest tree in that species is not more than K units. Write a program to determine how many tree species are classified as \\"uniform.\\" Input: The first line consists of M and K, representing the number of species and the maximum height difference, respectively. For each of the next M lines, the first number is N, followed by the heights of N trees of that species. Output: Print the number of species that are classified as \\"uniform.\\" Constraints: 1 ≤ M ≤ 100 1 ≤ K ≤ 100 1 ≤ N ≤ 100 1 ≤ Height of each tree ≤ 1000 SAMPLE INPUT 3 10 5 10 15 20 25 30 4 12 12 14 15 3 50 60 70 SAMPLE OUTPUT 1 Explanation: - For the first species, the heights are 10, 15, 20, 25, and 30. The difference between the tallest and shortest tree is 20, which is greater than K (10), so this species is not classified as \\"uniform.\\" - For the second species, the heights are 12, 12, 14, and 15. The difference between the tallest and shortest tree is 3, which is less than or equal to K (10), so this species is classified as \\"uniform.\\" - For the third species, the heights are 50, 60, and 70. The difference between the tallest and shortest tree is 20, which is greater than K (10), so this species is not classified as \\"uniform.\\"","solution":"def count_uniform_species(M, K, species_details): Returns the number of tree species classified as 'uniform'. :param M: Number of species :param K: Maximum allowed height difference :param species_details: List of lists where each sublist contains the heights of trees in that species uniform_count = 0 for species in species_details: max_height = max(species) min_height = min(species) if (max_height - min_height) <= K: uniform_count += 1 return uniform_count # Example usage: # M = 3 # K = 10 # species_details = [ # [10, 15, 20, 25, 30], # [12, 12, 14, 15], # [50, 60, 70] # ] # print(count_uniform_species(M, K, species_details)) # Output: 1"},{"question":"A village consists of a straight line street with n houses, where n is a positive integer. Each house has a certain number of candies. The i-th house from the left has candies[i] candies (0-based index). A thief wants to steal candies and make a run with the maximum amount, but he can't steal from two consecutive houses as the house alarms will trigger if adjacent houses are robbed. Write a function to determine the maximum amount of candies the thief can steal. Input - The first line contains an integer t, the number of test cases (1 ≤ t ≤ 10^4). - The next lines contain the description of the test cases. - For each test case: - The first line contains an integer n (1 ≤ n ≤ 10^5) representing the number of houses. - The second line contains n space-separated integers candies[i] (0 ≤ candies[i] ≤ 10^4). Output - For each test case, print the maximum number of candies the thief can steal. Example Input 3 6 5 3 4 11 2 8 3 4 1 1 4 3 2 2 3 Output 24 5 6 Explanation - In the first test case, the thief can steal from house 0, house 3, and house 5 for a total of 5 + 11 + 8 = 24. - In the second test case, the thief can steal from house 0 and house 2 for a total of 4 + 1 = 5. - In the third test case, the thief can steal from house 0 and house 3 for a total of 3 + 3 = 6.","solution":"def max_candies(t, test_cases): results = [] for case in test_cases: n, candies = case if n == 0: results.append(0) continue if n == 1: results.append(candies[0]) continue dp = [0] * n dp[0] = candies[0] if n > 1: dp[1] = max(candies[0], candies[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + candies[i]) results.append(max(dp)) return results def parse_input(input_data): data = input_data.split() t = int(data[0]) index = 1 test_cases = [] for _ in range(t): n = int(data[index]) index += 1 candies = list(map(int, data[index:index + n])) index += n test_cases.append((n, candies)) return t, test_cases def format_result(results): return 'n'.join(map(str, results))"},{"question":"Determine if a string of parentheses is balanced. A string of parentheses is considered balanced if every opening parenthesis has a corresponding closing parenthesis and the pairs are properly nested. Write a program that reads a string containing only the characters '(', ')', '{', '}', '[' and ']', and determines if the string is balanced. INPUT A single line of input containing a string with up to 1000 characters. OUTPUT Output \\"YES\\" if the string is balanced, otherwise output \\"NO\\". CONSTRAINTS - The input string will only consist of '(', ')', '{', '}', '[' and ']'. - The length of the input string will not exceed 1000 characters. SAMPLE INPUT 1 [()]{}{[()()]()} SAMPLE OUTPUT 1 YES SAMPLE INPUT 2 [(]) SAMPLE OUTPUT 2 NO","solution":"def is_balanced_parentheses(s): Determines if the input string of parentheses is balanced. Args: s (str): A string containing only '(', ')', '{', '}', '[' and ']'. Returns: str: \\"YES\\" if the string is balanced, otherwise \\"NO\\". stack = [] matching_parentheses = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_parentheses.values(): stack.append(char) elif char in matching_parentheses.keys(): if not stack or stack.pop() != matching_parentheses[char]: return \\"NO\\" return \\"YES\\" if not stack else \\"NO\\""},{"question":"You are provided with an initially empty set S and need to execute a series of operations on it. The operations are as follows: 1. 1 X - Add number X to the set S. 2. 2 X - Remove number X from the set S. If X is not present in the set, print \\"-1\\" without the quotes. 3. 3 - Print the number of elements currently in the set S. If the set is empty, print \\"0\\" without the quotes. 4. 4 - Check whether number X is present in the set S. Print \\"Yes\\" if present, otherwise print \\"No\\". Input: The first line contains the integer Q. Each of the next Q lines contains one of the four types of operations as described. Output: For each operation of type 2, 3, and 4, print the result as specified. Constraints: 1 ≤ Q ≤ 100000 1 ≤ X ≤ 100000 (for operations involving X) SAMPLE INPUT 6 1 7 1 3 3 4 5 4 7 2 7 SAMPLE OUTPUT 2 No Yes Explanation There are 6 queries. Query 1 - 7 is added to the set. Query 2 - 3 is added to the set. Query 3 - The number of elements in the set is 2. Query 4 - Number 5 is not in the set, so the output is \\"No\\". Query 5 - Number 7 is in the set, so the output is \\"Yes\\". Query 6 - Number 7 is removed from the set.","solution":"def execute_operations(operations): S = set() result = [] for op in operations: if op[0] == '1': S.add(int(op[1])) elif op[0] == '2': if int(op[1]) in S: S.remove(int(op[1])) else: result.append(\\"-1\\") elif op[0] == '3': result.append(str(len(S))) elif op[0] == '4': if int(op[1]) in S: result.append(\\"Yes\\") else: result.append(\\"No\\") return result"},{"question":"Given a matrix of size n × n filled with random integers, you are required to find the diagonal sum difference. The diagonal sum difference is the absolute difference between the sum of the main diagonal and the sum of the secondary diagonal in the matrix. The main diagonal of a matrix runs from the top-left to the bottom-right, while the secondary diagonal runs from the top-right to the bottom-left. Your task is to write a program that reads a square matrix and computes the diagonal sum difference. # Input - The first line contains a single integer n (1 ≤ n ≤ 1000), the size of the matrix. - The next n lines each contain n integers (−10^9 ≤ matrix[i][j] ≤ 10^9), the elements of the matrix. # Output - Print a single integer, the absolute difference between the sum of the main diagonal and the sum of the secondary diagonal. # Example Input: \`\`\` 3 11 2 4 4 5 6 10 8 -12 \`\`\` Output: \`\`\` 15 \`\`\` Input: \`\`\` 4 5 2 3 4 1 6 1 8 9 1 7 3 0 4 2 6 \`\`\` Output: \`\`\` 2 \`\`\` # Note In the first example, the sums of the diagonals are: - Main diagonal (11, 5, -12): 11 + 5 - 12 = 4 - Secondary diagonal (4, 5, 10): 4 + 5 + 10 = 19 Thus, the absolute difference is |4 - 19| = 15. In the second example, the sums of the diagonals are: - Main diagonal (5, 6, 7, 6): 5 + 6 + 7 + 6 = 24 - Secondary diagonal (4, 1, 1, 0): 4 + 1 + 1 + 0 = 6 Thus, the absolute difference is |24 - 6| = 18.","solution":"def diagonal_sum_difference(matrix): Takes a square matrix and calculates the absolute difference between the sum of its main diagonal and its secondary diagonal. :param matrix: List[List[int]] :return: int n = len(matrix) main_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(n): main_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n - 1 - i] difference = abs(main_diagonal_sum - secondary_diagonal_sum) return difference"},{"question":"Given a binary string \`s\`, you need to count the number of non-empty substrings which have the same number of continuous '1's and '0's. The substrings should be composed entirely of contiguous '1's followed by contiguous '0's or vice versa. For example, in the binary string \\"00110011\\", substrings \\"0011\\", \\"01\\", \\"1100\\", \\"10\\", \\"0011\\", \\"01\\" meet the criteria. Your task is to complete the function \`countBinarySubstrings\`, which takes the binary string \`s\` as input and returns the count of such substrings. # Function Signature \`\`\`python def countBinarySubstrings(s: str) -> int: \`\`\` # Input - A single string \`s\` with length \`1 <= len(s) <= 50_000\`. The string consists only of '0's and '1's. # Output - An integer representing the number of such substrings in \`s\`. # Example \`\`\`python print(countBinarySubstrings(\\"00110011\\")) # Output: 6 \`\`\` # Explanation In the example given, six substrings can be found which satisfy the criteria. - \\"0011\\" from (0, 1, 1, 0) - \\"01\\" from (0, 1) - \\"1100\\" from (1, 0, 0, 1) - \\"10\\" from (1, 0) - \\"0011\\" from (0, 1, 1, 0) - \\"01\\" from (0, 1) Note multiple counts of the same substring are valid as they occur at different positions in the string. # Constraints - The input string \`s\` will always contain at least one '0' and one '1'.","solution":"def countBinarySubstrings(s: str) -> int: groups = [] count = 1 # Group the lengths of consecutive '0's or '1's for i in range(1, len(s)): if s[i] != s[i-1]: groups.append(count) count = 1 else: count += 1 groups.append(count) # Now count valid substrings based on the group sizes result = 0 for i in range(1, len(groups)): result += min(groups[i-1], groups[i]) return result"},{"question":"You are given a list of integers and a target sum. Your task is to find all unique quadruplets in the list which give the sum of the target. Note that the solution set must not contain duplicate quadruplets. Write a function \`findQuadruplets(nums: List[int], target: int) -> List[List[int]]\` that takes in a list of integers and a target integer and returns a list of lists, where each inner list is a quadruplet of integers that add up to the target sum. The quadruplets should be listed in ascending order of their constituent integers, and the list of quadruplets should also be in ascending order. Example: Input: nums = [1, 0, -1, 0, -2, 2] target = 0 Output: [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] Constraints: - The input list may contain positive and negative integers. - The length of the list will be in the range [0, 200]. - Each integer in the list is in the range of [-10^9, 10^9].","solution":"from typing import List def findQuadruplets(nums: List[int], target: int) -> List[List[int]]: nums.sort() quadruplets = [] n = len(nums) for i in range(n - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, n - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left, right = j + 1, n - 1 while left < right: sum_of_four = nums[i] + nums[j] + nums[left] + nums[right] if sum_of_four == target: quadruplets.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif sum_of_four < target: left += 1 else: right -= 1 return quadruplets"},{"question":"Given a list of integers, find the maximum sum of non-adjacent elements. You can think of this problem as robbing houses along a street where the constraint is that you cannot rob two consecutive houses. Constraints * 1 ≤ n ≤ 10000 * -10000 ≤ ai ≤ 10000 Input n a1 a2 a3 ... an In the first line, an integer n represents the number of elements in the list. In the second line, n integers representing the elements of the list are given. Output A single integer representing the maximum sum of non-adjacent elements. Examples Input 6 5 1 1 5 3 7 Output 17 Input 4 3 2 5 10 Output 13","solution":"def max_sum_non_adjacent(nums): Returns the maximum sum of non-adjacent elements in the list nums. if not nums: return 0 n = len(nums) if n == 1: return max(0, nums[0]) # Initialization for two base cases prev2 = 0 prev1 = max(0, nums[0]) for i in range(1, n): current = max(prev1, prev2 + nums[i]) prev2 = prev1 prev1 = current return prev1"},{"question":"In an enchanted forest, there are n magical creatures. Each pair of magical creatures has a unique friendship strength represented by an integer. You are tasked with finding pairs of magical creatures that maintain the balance of the forest. A pair of magical creatures (a, b) is said to maintain the balance if their friendship strength is greater than or equal to a given threshold t. The forest keeper, Hagrid, introduces some new magical creatures with their friendship strengths. You need to determine the number of balanced pairs after the introduction of each new magical creature. A new creature can be friends with all existing creatures and the friendship strength is provided. Formally, you are given an initial set of n magical creatures and m pairs of integers (a, b, s) where a and b are two different creatures (1 ≤ a, b ≤ n) and s is their friendship strength. You are also given a threshold t to identify the balanced pairs. After the initial setup, q new magical creatures are introduced. For each new creature j, you are given two integers k (the index of an existing creature it becomes friends with) and s (the friendship strength). You need to update your count of balanced pairs after each new friendship is formed. Input First line contains three integers n (1 ≤ n ≤ 1000), m (0 ≤ m ≤ n*(n-1)/2), and t (1 ≤ t ≤ 106). Each of the next m lines contains three space separated integers a, b, s (1 ≤ a, b ≤ n, a ≠ b, 1 ≤ s ≤ 106), indicating a pair of creatures and their friendship strength. Next line contains an integer q (1 ≤ q ≤ 1000), the number of new magical creatures introduced. Each of the next q lines contains two space separated integers k (1 ≤ k ≤ n) and s representing the index of an existing creature that the new creature (indexed as n+1, n+2, etc.) becomes friends with and their friendship strength. Output In the first line print the value for the number of balanced pairs for the initial set of creatures. After that print q lines, a single integer each containing the value for the number of balanced pairs after the addition of each new creature. Examples Input 4 4 10 1 2 12 1 3 14 2 4 7 3 4 15 3 1 11 2 9 1 13 Output 3 4 4 5 Input 3 2 20 1 2 15 2 3 30 2 1 25 3 18 Output 1 2 2 Note In the first sample case, the initial three balanced pairs are: (1, 2), (1, 3), and (3, 4) with friendship strengths 12, 14, and 15 respectively. After the first addition (1, 11), new balance pairs are (1, 2), (1, 3), (3, 4), and (1, new creature) with friendship strengths 12, 14, 15, and 11 respectively. In the second addition (2, 9), no new balanced pairs are formed since friendship strength 9 < threshold 10. In the third addition (1, 13), a new balance pair is (1, new creature) with friendship strength 13 bringing the total to 4.","solution":"def count_balanced_pairs(n, m, t, initial_friendships, q, new_creatures): # Calculating the initial number of balanced pairs balanced_pairs = 0 for a, b, s in initial_friendships: if s >= t: balanced_pairs += 1 results = [balanced_pairs] # Process the introduction of each new magical creature for k, s in new_creatures: if s >= t: balanced_pairs += 1 results.append(balanced_pairs) return results"},{"question":"You are given an array of n integers, and you need to select exactly k of them (1 ≤ k ≤ n). The task is to find the minimum possible difference between the maximum and minimum values of the selected integers. Input The first line of the input contains two integers n and k (1 ≤ k ≤ n ≤ 10^5), representing the number of integers in the array and the number of integers to select, respectively. The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 10^9), representing the array. Output Print a single integer representing the minimum difference between the maximum and minimum values of the selected k integers. Examples Input 7 3 10 100 300 200 1000 20 30 Output 20 Input 5 2 1 1 1 1 1 Output 0 Input 10 4 1 2 3 4 10 20 30 40 100 200 Output 3 Explanation In the first example, selecting 10, 20, and 30 gives the minimum difference of 20 (30 - 10). In the second example, all numbers are the same, so the minimum difference is 0. In the third example, selecting 1, 2, 3, and 4 results in the minimum difference of 3 (4 - 1).","solution":"def min_difference(n, k, arr): Returns the minimum possible difference between the maximum and minimum values of k selected integers from the array. arr.sort() min_diff = float('inf') for i in range(n - k + 1): diff = arr[i + k - 1] - arr[i] if diff < min_diff: min_diff = diff return min_diff # Example usage: # n, k = 7, 3 # arr = [10, 100, 300, 200, 1000, 20, 30] # print(min_difference(n, k, arr)) # Output: 20"},{"question":"Problem You are given a string containing only 'a', 'b', and 'c'. You need to determine the minimum number of replacements required to make the string balanced. A string is considered balanced if no two adjacent characters are the same. Constraints The input satisfies the following conditions: * 1 ≤ length of the string ≤ 105 Input The input is given in the following format: s The string s is given on the first and only line. Output Print the minimum number of replacements required to make the string balanced. Examples Input aabcc Output 2 Input abcabc Output 0 Explanation In the first example, you can replace the second 'a' with 'c' and the third 'c' with 'b' to get the string 'acbcc' or 'acabcc', both of which are balanced. Thus, the minimum number of replacements required is 2. In the second example, the string is already balanced, so no replacements are needed, and the output is 0.","solution":"def min_replacements_to_make_balanced(s): Returns the minimum number of replacements required to make the string balanced such that no two adjacent characters are the same. count = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: # If the current character is the same as the previous one count += 1 return count"},{"question":"In a small village, there is a unique type of crop field represented as a 2D grid with dimensions n x m. Each cell in the grid contains a certain number of crops (an integer). The villagers have devised a game where they perform the following operation repeatedly: choose two cells and swap their crop counts. The objective is to evenly distribute the crop counts over the grid as much as possible. However, since the villagers can only swap crop counts, it's not always possible to achieve a perfectly even distribution. Your task is to find the minimum possible maximum crop count in any cell after any number of swaps. Input The first line contains two integers n and m (1 ≤ n, m ≤ 100) — the number of rows and columns in the grid. Each of the next n lines contains m integers. The j-th integer in the i-th line represents the number of crops in the cell located at row i and column j (0 ≤ crop count ≤ 10^6). Output Print a single integer — the minimum possible maximum crop count in any cell after any number of swaps. Examples Input 2 2 10 20 30 40 Output 25 Input 3 3 1 1 1 1 0 1 1 1 1 Output 1 Note In the first sample, the total number of crops is 100, and there are 4 cells. The best even distribution would ideally have each cell containing 25 crops. Hence, the minimum possible maximum crop count in any cell is 25. In the second sample, it is already possible to make all cells contain a crop count of 1, which is the minimum possible maximum crop count.","solution":"def min_max_crop_count(n, m, crops): total_crops = sum(map(sum, crops)) num_cells = n * m min_max_count = total_crops // num_cells if total_crops % num_cells != 0: min_max_count += 1 return min_max_count"},{"question":"In a town, a new delivery service is planning to set up automated delivery robots. These robots need to traverse through the town's grid of streets to deliver packages to various locations. The town's grid is represented as a matrix where some cells may contain obstacles (indicated by 1), while others may be free paths (indicated by 0). The robots can only move up, down, left, or right, but cannot cross or pass through obstacles. You are required to write a program that calculates the minimum number of time units a robot needs to reach from a starting position to a target delivery location. Each move from one cell to an adjacent cell takes exactly one time unit. Input The first line contains two integers, n and m (1 ≤ n, m ≤ 500), representing the number of rows and columns of the grid, respectively. The next n lines each contain m integers (either 0 or 1), representing the grid. The following line contains four integers, sx, sy, tx, and ty (0 ≤ sx, sy, tx, ty < n, m). These represent the starting cell (sx, sy) and the target cell (tx, ty). The input is guaranteed always to have a path from the starting cell to the target cell. Output Print a single integer, representing the minimum time units required for the robot to reach the target cell. Example Input 5 5 0 0 1 0 0 0 0 0 0 0 0 0 1 0 1 1 0 1 0 0 0 0 0 0 0 0 0 4 4 Output 8","solution":"from collections import deque def min_time_to_reach_target(n, m, grid, sx, sy, tx, ty): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == 0 queue = deque([(sx, sy, 0)]) visited = set((sx, sy)) while queue: x, y, time = queue.popleft() if (x, y) == (tx, ty): return time for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, time + 1))"},{"question":"You are given an integer N and an array of N integers. Find the minimum value among the sum of every two consecutive elements in the array. If the array has fewer than 2 elements, return 0. Constraints * 1 leq N leq 1000 * -1000 leq array[i] leq 1000 (0 leq i < N) * All values in input are integers. Input Input is given from Standard Input in the following format: N array[0] array[1] ... array[N-1] Output Print the minimum value among the sum of every two consecutive elements in the array. If the array has fewer than 2 elements, return 0. Examples Input 4 1 2 3 4 Output 3 Input 2 -5 5 Output 0 Input 1 7 Output 0","solution":"def minimum_consecutive_sum(N, arr): Finds the minimum value among the sum of every two consecutive elements in the array. If the array has fewer than 2 elements, return 0. if N < 2: return 0 min_sum = float('inf') for i in range(N - 1): current_sum = arr[i] + arr[i + 1] if current_sum < min_sum: min_sum = current_sum return min_sum"},{"question":"You are given an array of n integers and an integer k. Your task is to process q queries of the following types: * The format of the query: 1 l r. In response to this query, you need to reverse the segment of the array that starts at index l and ends at index r (both inclusive). * The format of the query: 2 l r. In reply to this query, you should print the k-th smallest element in the segment of the array that starts at index l and ends at index r (both inclusive). Indices in the queries are 1-based. Input The first line contains two integers n and k (1 ≤ n, k ≤ 100000) — the length of the array and the value of k. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 10^9) — the elements of the array. The third line contains an integer q (1 ≤ q ≤ 100000) — the number of queries. The following q lines describe the queries, each query consisting of an integer type and two integers l and r (1 ≤ l ≤ r ≤ n). Output For each query of the second type, print the k-th smallest element in the segment of the array, on a separate line. Examples Input 5 2 1 5 2 4 3 3 1 2 4 2 1 5 2 2 4 Output 4 2 Explanation Initially, the array is [1, 5, 2, 4, 3]. After the first query (reversing the segment from index 2 to 4), the array becomes [1, 4, 2, 5, 3]. In the second query, we need to find the 2nd smallest element in the entire array which is 2. In the third query, we need to find the 2nd smallest element in the segment [4, 2, 5] which is 4.","solution":"def process_queries(n, k, array, queries): Process the queries on the given array and return results for queries of the second type. :param n: Length of the array :param k: The k-th position for the queries of the second type :param array: List of integers representing the array :param queries: List of queries to be processed :return: List of results for the second type queries results = [] for query in queries: q_type, l, r = query if q_type == 1: array[l-1:r] = array[l-1:r][::-1] elif q_type == 2: segment = sorted(array[l-1:r]) results.append(segment[k-1]) return results"},{"question":"Input The input contains an integer n (1 ≤ n ≤ 10^18). Output Output the sum of all digits of n. Examples Input 12345 Output 15 Input 9876543210 Output 45 Input 1000000000000000000 Output 1","solution":"def sum_of_digits(n): Returns the sum of all digits of the given integer n. return sum(int(digit) for digit in str(n))"},{"question":"Afonso needs to decide whether to water his garden today. He currently checks the weather forecast for the day. If the forecast indicates that the chance of rain is at least 50%, he won't water the garden. Otherwise, he will water it. You are given the probability, p, that it will rain today (in percentage). Print \`NO\` if Afonso won't water the garden, and \`YES\` if he will. Constraints * 0 ≦ p ≦ 100 * p is an integer. Input The input is given from Standard Input in the following format: p Output Print the answer. Examples Input 30 Output YES Input 50 Output NO","solution":"def should_water_garden(probability): Determines if Afonso should water his garden based on the probability of rain. Args: probability (int): The probability that it will rain today (0 ≦ p ≦ 100). Returns: str: 'YES' if Afonso should water his garden, 'NO' otherwise. if probability >= 50: return 'NO' else: return 'YES'"},{"question":"You are given a binary tree with \`N\` nodes, each with a value. The value of each node is unique and ranges from 1 to N. Your task is to find the maximum distance between any two nodes in the tree. The distance between two nodes is defined as the number of edges on the shortest path between them. # Input Input is given from Standard Input in the following format: \`\`\` N u1 v1 u2 v2 ... u(N-1) v(N-1) values \`\`\` Where: - \`N\` (1 ≤ N ≤ 1000) is the number of nodes in the tree. - Each of the next \`N-1\` lines contains two integers \`ui\` and \`vi\` (1 ≤ ui, vi ≤ N), denoting an edge between nodes \`ui\` and \`vi\`. - The last line contains \`N\` integers \`v1 v2 ... vN\`, where \`vi\` represents the value of the i-th node. # Output Print the maximum distance between any two nodes in the tree. # Examples Input \`\`\` 5 1 2 1 3 2 4 2 5 5 1 4 2 3 \`\`\` Output \`\`\` 3 \`\`\` Input \`\`\` 3 1 2 1 3 3 1 2 \`\`\` Output \`\`\` 2 \`\`\`","solution":"from collections import deque, defaultdict def max_distance(N, edges, values): if N == 1: return 0 # Construct the tree as an adjacency list tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Function to perform BFS and return the farthest node and its distance def bfs(start): visited = [-1] * (N + 1) q = deque([start]) visited[start] = 0 farthest_node, max_dist = start, 0 while q: node = q.popleft() dist = visited[node] for neighbor in tree[node]: if visited[neighbor] == -1: visited[neighbor] = dist + 1 q.append(neighbor) if visited[neighbor] > max_dist: farthest_node, max_dist = neighbor, visited[neighbor] return farthest_node, max_dist # Get the farthest node from an arbitrary start (node 1) node_A, _ = bfs(1) # Get the farthest node from node_A _, max_distance = bfs(node_A) return max_distance # Example of using the function with input parsing def parse_and_solve(): import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) edges = [(int(data[i]), int(data[i+1])) for i in range(1, 2*N-2, 2)] values = list(map(int, data[-N:])) result = max_distance(N, edges, values) print(result)"},{"question":"In a magical kingdom, there is a river running from the north to the south. The kingdom is divided into several cities located on either the east or west side of the river. There are bridges that connect cities from the east side to the west side. The king wants to prepare a report for his advisor on the maximum number of non-crossing bridges that can be built. Two bridges are defined as crossing if both both ends of one bridge are either above or below the other bridge. In other words, bridges (a, b) and (c, d) cross each other if and only if a < c < b < d or c < a < d < b. The challenge is to build as many non-crossing bridges as possible. You are given a list of pairs representing the location of the cities and the possible bridges that can be built. Each pair contains two integers, where the first integer represents the position of the city on the west side and the second integer represents the position is the city of the east side. Write a function that returns the maximum number of non-crossing bridges that can be constructed. Input The first line contains an integer n (1 ≤ n ≤ 1000) - the number of possible bridges. Each of the next n lines contains a pair of integers x and y (1 ≤ x, y ≤ 1000), representing a possible bridge between city x on the west side and city y on the east side. Output Print a single integer - the maximum number of non-crossing bridges. Examples Input 5 1 5 2 6 3 4 4 7 5 8 Output 4 Input 3 1 2 2 3 3 4 Output 3 Input 3 1 2 3 2 2 3 Output 2","solution":"def max_non_crossing_bridges(n, bridges): Returns the maximum number of non-crossing bridges. Parameters: n (int): the number of possible bridges bridges (List[Tuple[int, int]]): a list of tuples representing the location of the cities on the west and east sides. Returns: int: the maximum number of non-crossing bridges that can be built. # Sort bridges by the cities on the west side bridges.sort() # Extract the east side cities to find the longest increasing subsequence east_cities = [y for x, y in bridges] # Initialize DP array to find the LIS lis = [1] * n # Calculate the LIS on the east side cities for i in range(1, n): for j in range(i): if east_cities[i] > east_cities[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis) # Read input input_lines = [ \\"5\\", \\"1 5\\", \\"2 6\\", \\"3 4\\", \\"4 7\\", \\"5 8\\" ] n = int(input_lines[0]) bridges = [tuple(map(int, line.split())) for line in input_lines[1:]] print(max_non_crossing_bridges(n, bridges)) # Expected Output: 4"},{"question":"Given a list of integers, sort the list such that all prime numbers come before non-prime numbers, and within each group (prime and non-prime), the numbers are sorted in ascending order. Input The first line contains integer n (1 ≤ n ≤ 100) — the number of elements in the list. The second line contains n integers (1 ≤ ai ≤ 1000) — the elements of the list. Output Output a single line containing the sorted list with prime numbers first in ascending order followed by non-prime numbers in ascending order. Examples Input 5 4 3 2 7 6 Output 2 3 7 4 6 Input 3 10 5 8 Output 5 8 10 Note In the first example, the prime numbers are 2, 3, and 7; the non-prime numbers are 4 and 6. Primes are sorted as [2, 3, 7] and placed before non-primes sorted as [4, 6], resulting in [2, 3, 7, 4, 6]. In the second example, the prime numbers are 5; the non-prime numbers are 10 and 8. Primes are sorted as [5] and placed before non-primes sorted as [8, 10], resulting in [5, 8, 10].","solution":"def is_prime(num): Check if a number is a prime number. if num <= 1: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def sort_numbers_with_primes_first(n, numbers): Sorts the list of numbers such that primes come before non-primes, both sorted in ascending order. primes = sorted([x for x in numbers if is_prime(x)]) non_primes = sorted([x for x in numbers if not is_prime(x)]) return primes + non_primes"},{"question":"Given a list of n distinct integers in any random order, you need to sort them into a special order. The special order is defined as follows: - All the prime numbers in the list should appear first and they should be sorted in ascending order. - All the composite numbers in the list should appear next and they should be sorted in descending order. - All the single numbers (1) in the list should appear last. You need to process t test cases. Input The first line contains one integer t (1 ≤ t ≤ 100) — the number of test cases. The first line of each test case contains one integer n (1 ≤ n ≤ 10^5) — the total number of integers in the list. The second line of each test case contains n distinct integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9). Output For each test case, print the list of integers in the special order as described above. Example Input 3 7 3 15 2 1 9 4 7 5 10 11 13 1 18 3 2 1 3 Output 2 3 7 15 9 4 1 11 13 10 18 1 2 3 1 Note In the first test case, the prime numbers [2, 3, 7] come first in ascending order, followed by the composite numbers [15, 9, 4] in descending order, and the number 1 comes last. In the second test case, the prime numbers [11, 13] come first in ascending order, followed by the composite numbers [18, 10] in descending order, and the number 1 comes last. In the third test case, the prime numbers [2, 3] come first in ascending order, followed by no composite numbers, and the number 1 comes last.","solution":"def is_prime(num): Check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def special_sort(n, arr): Return the array sorted in special order. primes = [] composites = [] ones = [] for num in arr: if num == 1: ones.append(num) elif is_prime(num): primes.append(num) else: composites.append(num) primes.sort() composites.sort(reverse=True) return primes + composites + ones def process_test_cases(t, test_cases): Process multiple test cases. results = [] for i in range(t): n, arr = test_cases[i] results.append(special_sort(n, arr)) return results"},{"question":"Consider that you are organizing a charity event where you will auction baskets of goodies. Each basket contains exactly \`n\` unique items. During the event, a few baskets get mixed up, and some of the items fall out of their respective baskets into a big pile on the floor. You are tasked with collecting and organizing the items back into their respective baskets. Fortunately, each item has a unique identifier from 1 to \`n\`. Your challenge now is to determine if each identified item can be placed back into exactly one of the given baskets without any duplicates, and none should be missing. Write a program to help organize the items back into the baskets correctly. Input Format: - \`t\`: Number of test cases - For each test case: - \`n\`: Number of items per basket - \`items\`: Space-separated integers representing the items that have fallen into the pile Output Format: For each test case, output \\"YES\\" if all items can be exactly placed back into the baskets correctly, otherwise output \\"NO\\". Constraints: - 1 ≤ t ≤ 100 - 1 ≤ n ≤ 1000 - The number of items in the pile will be exactly \`n\` SAMPLE INPUT 3 3 1 2 3 4 1 2 3 4 5 4 2 5 1 3 SAMPLE OUTPUT YES YES YES Explanation: In each test case, you'll check if all unique items from 1 to \`n\` are present exactly once in the given items list. For the first test case, the items 1, 2, and 3 exactly match the basket requirement. For the second test case, the items 1, 2, 3, and 4 exactly match the basket requirement. For the third test case, the items 1, 2, 3, 4, and 5 exactly match the basket requirement.","solution":"def can_organize_baskets(t, test_cases): Determines if all baskets can be correctly filled with their unique items. Parameters: t (int): Number of test cases test_cases (list of tuples): Each tuple contains: - n (int): Number of items per basket - items (list of int): Items that need to be organized into baskets Returns: list of str: \\"YES\\" or \\"NO\\" for each test case. results = [] for case in test_cases: n, items = case if sorted(items) == list(range(1, n+1)): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"You are designing a game for a simulated environment where players can navigate a grid of cells. Each cell has a certain cost associated with entering it, and some cells are 'blocked' making them impassable. You need to write a function to find the minimum cost required for a player to travel from the top-left corner of the grid to the bottom-right corner. The player can move in four directions: up, down, left, or right. However, they can only move to an adjacent cell that is not blocked. If a path does not exist, the function should return -1. Implement a function \`minCostPath(grid: List[List[int]]) -> int\` that takes in a grid (NxM matrix) and returns the minimum cost to reach the bottom-right corner from the top-left corner, or -1 if no such path exists. # Constraints: - 2 ≤ N, M ≤ 100 (N is the number of rows, and M is the number of columns in the grid). - The cost is represented by non-negative integers in each cell. - A \`-1\` in the grid represents a blocked cell which cannot be traversed. # Input Format: The function receives a 2D list representing the grid. # Output Format: Return an integer representing the minimum cost, or -1 if no viable path exists. # Example Input: \`\`\`python grid = [ [1, 3, 1], [1, -1, 1], [4, 2, 1] ] \`\`\` # Example Output: \`\`\`python 7 \`\`\` # Explanation: The minimum cost path to navigate from the top-left to the bottom-right in the given grid is: (1 → 3 → 1 → 1 → 1). The total cost is 7.","solution":"from typing import List import heapq def minCostPath(grid: List[List[int]]) -> int: if not grid or not grid[0]: return -1 n, m = len(grid), len(grid[0]) # Directions for moving in the grid: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Min-Heap to keep track of the minimum cost paths heap = [(grid[0][0], 0, 0)] visited = set() while heap: cost, x, y = heapq.heappop(heap) # If we reached the bottom-right corner, return the cost if (x, y) == (n-1, m-1): return cost if (x, y) in visited: continue visited.add((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] != -1: heapq.heappush(heap, (cost + grid[nx][ny], nx, ny)) return -1"},{"question":"Lena has a collection of coins and she wants to make exactly a certain amount of money using the fewest number of coins possible. Each coin has a specific value. She may have unlimited copies of any type of coin. You are given a list of coin values and a target amount of money Lena wants to make. Your task is to determine the minimum number of coins needed to make exactly that amount. If it's not possible to make that amount with the given coins, return -1. Input The first line of input contains two integers n and m (1 ≤ n ≤ 100, 1 ≤ m ≤ 1000) — the number of different coin types and the target amount of money, respectively. The second line of input contains n integers c_1, c_2,..., c_n (1 ≤ c_i ≤ 1000), where c_i is the value of the i-th type of coin. Output Print one integer — the minimum number of coins needed to make exactly m amount of money. If it is not possible to make m amount with the given coins, print -1. Examples Input 3 11 1 5 7 Output 3 Input 3 7 2 4 6 Output -1 Note In the first example, Lena can make 11 units of money using one coin of value 1 and two coins of value 5, for a total of 3 coins. In the second example, it is not possible to make 7 units of money with coins of values 2, 4, and 6, so the output is -1.","solution":"def min_coins(coins, amount): Returns the minimum number of coins needed to make exactly the given amount of money. If it's not possible to make the amount with the given coins, returns -1. dp = [float('inf')] * (amount + 1) dp[0] = 0 for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) if dp[amount] == float('inf'): return -1 else: return dp[amount]"},{"question":"Write a function that takes two parameters: a list of integers and a target integer. The function should return the number of distinct pairs in the list that sum up to the target integer. Each pair should only be counted once, and the order of elements in the pairs does not matter. Example Input \`\`\`python nums = [1, 3, 2, 2, 4, 5, 6] target = 5 \`\`\` Output \`\`\`python 2 \`\`\` Explanation - The distinct pairs that sum up to 5 are (1, 4) and (3, 2). - Note: (2, 3) is considered the same as (3, 2). Function signature: \`\`\`python def count_pairs(nums: list[int], target: int) -> int: pass \`\`\`","solution":"def count_pairs(nums: list[int], target: int) -> int: Returns the number of distinct pairs in the list that sum up to the target integer. Each pair should only be counted once, and the order of elements in the pairs does not matter. :param nums: List of integers :param target: Target integer for pair sum :return: Number of distinct pairs that sum up to target seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"You are given a sequence of integers of length n. In one operation, you can choose any non-empty subsequence of the sequence and replace each of its elements by their greatest common divisor (GCD). What is the minimum possible sum of elements in the sequence that you can achieve after applying any number of operations? Input The first line contains a single integer n (1 ≤ n ≤ 100 000) — the length of the sequence. The second line contains n integers a1, a2, …, an (1 ≤ ai ≤ 10^9) — the elements of the sequence. Output Output a single integer — the minimum possible sum of elements in the sequence after applying the operations. Example Input 5 2 4 6 8 10 Output 5","solution":"import math from functools import reduce def minimum_possible_sum(n, arr): Returns the minimum possible sum of the sequence after applying the GCD replacement operations. sequence_gcd = reduce(math.gcd, arr) return sequence_gcd * n"},{"question":"In a computer game, there is a grid with m rows and n columns. Each cell in the grid can either be empty or contain an obstacle. The player can move in four possible directions: up, down, left, or right, but cannot move into a cell with an obstacle. The objective of the game is to move from the top-left corner of the grid to the bottom-right corner. Write a program to determine the number of distinct paths that the player can take to reach the destination. Note that m and n are at least 1. Input The first line contains two integers, m and n (1 ≤ m, n ≤ 100) — the number of rows and columns in the grid, respectively. The next m lines each contain n characters, where each character is either '.' (denoting an empty cell) or '#' (denoting an obstacle). Output Print a single integer — the number of distinct paths from the top-left corner to the bottom-right corner. Examples Input 3 3 ... .#. ... Output 2 Input 2 2 .. .. Output 2 Input 3 3 ..# .#. ... Output 1 Note For the first example, the possible paths are: 1. Right -> Right -> Down -> Down 2. Down -> Down -> Right -> Right","solution":"def num_distinct_paths(m, n, grid): # Handle edge cases if grid[0][0] == '#' or grid[m-1][n-1] == '#': return 0 # Initialize a 2D dp array with 0's. dp = [[0 for _ in range(n)] for _ in range(m)] # Starting point dp[0][0] = 1 # Fill the dynamic programming table for i in range(m): for j in range(n): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1] # Example usage: m, n = 3, 3 grid = [ \\"...n\\", \\".#.n\\", \\"...n\\" ] print(num_distinct_paths(m, n, grid)) # Output: 2"},{"question":"Input 4 EAST NORTH WEST SOUTH Output Joe","solution":"def determine_final_direction(moves): Determines Joe's final direction based on a series of cardinal directions. Args: moves (list): A list of strings representing the directions Joe turns to. Returns: str: The final cardinal direction Joe is facing. directions = [\\"NORTH\\", \\"EAST\\", \\"SOUTH\\", \\"WEST\\"] initial_position = 0 # Assuming Joe starts facing \\"NORTH\\" which is at index 0 for move in moves: if move in directions: initial_position = directions.index(move) return directions[initial_position]"},{"question":"Liam is fascinated with symmetric properties of strings. He finds a string beautiful if it can be rearranged to form a palindrome. Recall that a palindrome is a string that reads the same forward and backward. Liam wonders how many of the strings in a given list are beautiful. Input The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of strings in the list. Each of the next t lines contains a string s_i (1 ≤ |s_i| ≤ 10^5): it means that the i-th string in the list to be checked if it can be rearranged to form a palindrome. The total length of all strings does not exceed 10^6 characters. Output For each string, print YES if it is beautiful and NO otherwise (case insensitive). Example Input 5 civic ivicc random madam aabbc Output YES YES NO YES YES Note In the example, the strings \\"civic\\", \\"ivicc\\", and \\"madam\\" are already palindromes or can be rearranged to form a palindrome. The string \\"random\\" cannot be rearranged to form a palindrome. The string \\"aabbc\\" can be rearranged to form the palindrome \\"abcba\\".","solution":"def can_form_palindrome(s): Determine if a string can be rearranged to form a palindrome. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 == 1) return odd_count <= 1 def check_beautiful_strings(strings): For each string in the input list, return 'YES' if it is beautiful (can be rearranged to form a palindrome), and 'NO' otherwise. results = [] for s in strings: if can_form_palindrome(s): results.append('YES') else: results.append('NO') return results"},{"question":"You have been hired by an amusement park to develop a simulation for one of their new attractions: a robotic boat ride. The ride consists of a rectangular grid of cells, where each cell represents a distinct position in the water. At the start of the ride, the boat is positioned at the top-left cell of the grid (cell (1, 1)). The boat must navigate to the bottom-right cell of the grid (cell (N, M)) by following a series of commands. The commands for the boat's movement are represented by a string consisting of the characters 'R' (move right) and 'D' (move down). The boat can only follow one command per move, and the boat can only move within the bounds of the grid. The amusement park wants to calculate the number of ways the boat can move from the starting cell to the destination cell by following exactly (N-1) 'D' moves and (M-1) 'R' moves. Write a function to compute the number of distinct paths the boat can take. Input The first line contains an integer T, the number of test cases. Each test case contains two integers N and M, representing the dimensions of the grid. Output For each test case, output the number of distinct paths modulo 10^9 + 7. Constraints 1 ≤ T ≤ 100 1 ≤ N, M ≤ 1000 SAMPLE INPUT 2 2 2 3 2 SAMPLE OUTPUT 2 3 Explanation In the first test case, grid is 2x2. The boat can follow these paths: - \\"RD\\" (Right, Down) - \\"DR\\" (Down, Right) Hence, there are 2 distinct paths. In the second test case, grid is 3x2. The boat can follow these paths: - \\"RRDD\\" - \\"RDRD\\" - \\"RDDR\\" Hence, there are 3 distinct paths.","solution":"def mod_comb(n, k, mod=10**9 + 7): Calculate n choose k (nCk) modulo mod. if k > n - k: k = n - k num = 1 den = 1 for i in range(k): num = num * (n - i) % mod den = den * (i + 1) % mod return num * pow(den, mod - 2, mod) % mod def number_of_paths(N, M): Calculate the number of distinct paths from (1, 1) to (N, M) on a N x M grid. return mod_comb(N + M - 2, N - 1) def process_test_cases(test_cases): results = [] for N, M in test_cases: results.append(number_of_paths(N, M)) return results"},{"question":"You are given a rectangular grid with n rows and m columns. Each cell in the grid contains an integer representing the height of the terrain at that point. You need to find the maximum difference in height between any two adjacent cells in the grid, where two cells are considered adjacent if they share a common edge. Input The first line of the input contains two integers n (1 ≤ n ≤ 100) and m (1 ≤ m ≤ 100) — the number of rows and columns in the grid, respectively. The following n lines contain m integers each, which describe the grid. The j-th integer in the i-th line represents the height a_ij (1 ≤ a_ij ≤ 1000) of the cell in the i-th row and j-th column. Output Print a single integer — the maximum difference in height between any two adjacent cells in the grid. Example Input 3 4 1 2 3 4 5 6 7 8 9 10 11 12 Output 4 Note In the given example, the maximum height difference between any two adjacent cells is 4, which occurs between cells (1, 4) with height 4 and (2, 4) with height 8.","solution":"def max_height_difference(n, m, grid): Returns the maximum difference in height between any two adjacent cells in the grid. max_diff = 0 for i in range(n): for j in range(m): if i > 0: max_diff = max(max_diff, abs(grid[i][j] - grid[i-1][j])) if i < n-1: max_diff = max(max_diff, abs(grid[i][j] - grid[i+1][j])) if j > 0: max_diff = max(max_diff, abs(grid[i][j] - grid[i][j-1])) if j < m-1: max_diff = max(max_diff, abs(grid[i][j] - grid[i][j+1])) return max_diff # Example usage: n = 3 m = 4 grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] print(max_height_difference(n, m, grid)) # Output 4"},{"question":"You are given an array of integers where each element appears twice except for one. Your task is to find the element that appears only once. You must solve the problem with a linear runtime complexity and using only constant extra space. Input - The input starts with an integer n, which represents the number of elements in the array (1 <= n <= 10^5). It is guaranteed that n is odd, implying there is exactly one element that appears once, and all other elements appear exactly twice. - The second line contains n integers, the elements of the array. Each integer in the array is between 1 and 10^9. Output - Output the element that appears only once. Example Input: 7 4 3 2 4 2 3 1 Output: 1 Note: In the given example, the array is [4, 3, 2, 4, 2, 3, 1]. The element that appears only once is 1. To achieve the desired time and space complexity, consider utilizing bitwise operations such as XOR.","solution":"def find_single_element(arr): Finds the element that appears only once in an array where all other elements appear twice. :param arr: List[int] - List of integers with exactly one unique element :return: int - The element that appears only once result = 0 for number in arr: result ^= number return result"},{"question":"Implement a function that takes a string representing a mathematical expression and evaluates it. The expression can contain integers, the '+' and '*' operators, and parentheses. The expression should be evaluated following the normal operator precedence rules: parentheses first, then multiplication, and then addition. Your task is to write the function \`evaluate_expression(expression: str) -> int\` that takes a string expression and returns the integer result of evaluating that expression. Input - A single string \`expression\` (1 ≤ len(expression) ≤ 1000) representing a valid mathematical expression. Output - A single integer which is the result of evaluating the expression. Example Input \`\`\` 3+(2*2) \`\`\` Output \`\`\` 7 \`\`\` Input \`\`\` 2*(3+4) \`\`\` Output \`\`\` 14 \`\`\` Input \`\`\` 1+(1+(1+1)*(1+1)) \`\`\` Output \`\`\` 5 \`\`\` Note In the first example, the expression evaluates as 3 + (2 * 2) = 3 + 4 = 7. In the second example, the expression evaluates as 2 * (3 + 4) = 2 * 7 = 14. In the third example, the expression evaluates as 1 + (1 + (1 + 1) * (1 + 1)) = 1 + (1 + 2 * 2) = 1 + (1 + 4) = 1 + 5 = 6.","solution":"def evaluate_expression(expression: str) -> int: Evaluates a string mathematical expression containing integers, '+', '*', and parentheses. Returns the integer result. try: result = eval(expression) return result except Exception as e: raise ValueError(\\"Invalid expression\\") # Test cases print(evaluate_expression(\\"3+(2*2)\\")) # Expected output: 7 print(evaluate_expression(\\"2*(3+4)\\")) # Expected output: 14 print(evaluate_expression(\\"1+(1+(1+1)*(1+1))\\")) # Expected output: 6"}]`),I={name:"App",components:{PoemCard:E},data(){return{searchQuery:"",visibleCount:4,poemsData:R,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},F={class:"search-container"},C={class:"card-container"},S={key:0,class:"empty-state"},D=["disabled"],z={key:0},j={key:1};function O(i,e,l,f,n,a){const m=h("PoemCard");return r(),s("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",F,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>n.searchQuery=o),placeholder:"Search..."},null,512),[[b,n.searchQuery]]),n.searchQuery?(r(),s("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>n.searchQuery="")}," ✕ ")):d("",!0)]),t("div",C,[(r(!0),s(y,null,v(a.displayedPoems,(o,p)=>(r(),w(m,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(r(),s("div",S,' No results found for "'+u(n.searchQuery)+'". ',1)):d("",!0)]),a.hasMorePoems?(r(),s("button",{key:0,class:"load-more-button",disabled:n.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[n.isLoading?(r(),s("span",j,"Loading...")):(r(),s("span",z,"See more"))],8,D)):d("",!0)])}const P=_(I,[["render",O],["__scopeId","data-v-5375588f"]]),V=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"chatai/64.md","filePath":"chatai/64.md"}'),B={name:"chatai/64.md"},U=Object.assign(B,{setup(i){return(e,l)=>(r(),s("div",null,[x(P)]))}});export{V as __pageData,U as default};
