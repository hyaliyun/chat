import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as y,U as _,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},N={class:"review-content"};function E(r,e,l,p,a,s){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const A=c(k,[["render",E],["__scopeId","data-v-dde6006f"]]),S=JSON.parse('[{"question":"You are tasked with writing a function to compute the number of ways to choose `r` items from `n` items without regard to the order. Referred to as `nCr` or combinations, this is a fundamental concept in combinatorics often represented by the binomial coefficient. To evaluate your understanding, you need to write two versions of the function: 1. A recursive version without any optimization. 2. A memoized version that optimizes calculation by storing intermediate results. Function Signature ```python def combination(n: int, r: int) -> int: Calculate nCr (number of ways to choose r items from n items). Uses a straightforward recursive approach. :param n: Total number of items. :param r: Number of items to choose. :return: The number of ways to choose r items from n items. pass def combination_memo(n: int, r: int) -> int: Calculate nCr using a memoized recursive approach. :param n: Total number of items. :param r: Number of items to choose. :return: The number of ways to choose r items from n items. pass ``` # Input Constraints * 0 <= `n` <= 100 * 0 <= `r` <= `n` # Output The function should return an integer representing the number of combinations. # Examples: * `combination(5, 2) # Output: 10` * `combination_memo(5, 2) # Output: 10` * `combination(10, 0) # Output: 1` * `combination_memo(10, 10) # Output: 1` # Performance Requirements The non-memoized solution is expected to work correctly for small inputs but may not be efficient for larger inputs. The memoized version should handle the upper constraint efficiently due to reduced overlapping subproblem calculations. Scenario You are building a combinatorics calculator for a mathematical application. This function will help users calculate how many ways they can choose subsets of items from a given set. Ensure that your implementation can handle edge cases and large values within the constraints.","solution":"def combination(n: int, r: int) -> int: Calculate nCr (number of ways to choose r items from n items). Uses a straightforward recursive approach. :param n: Total number of items. :param r: Number of items to choose. :return: The number of ways to choose r items from n items. # Base cases if r == 0 or r == n: return 1 # Recursive cases return combination(n-1, r-1) + combination(n-1, r) def combination_memo(n: int, r: int) -> int: Calculate nCr using a memoized recursive approach. :param n: Total number of items. :param r: Number of items to choose. :return: The number of ways to choose r items from n items. memo = [[-1 for _ in range(r+1)] for _ in range(n+1)] def helper(n, r): # Base cases if r == 0 or r == n: return 1 # Check memo if memo[n][r] != -1: return memo[n][r] # Calculate and store in memo memo[n][r] = helper(n-1, r-1) + helper(n-1, r) return memo[n][r] return helper(n, r)"},{"question":"Given the following scenario, design and implement a class that calculates the moving average of a stream of integers with a fixed-size sliding window. Scenario You are tasked with developing a software system that monitors real-time sensor data in an industrial setting. Sensors provide readings at regular intervals, and you need to process these readings to calculate the moving average over a fixed window size. This average helps in signal smoothing and provides insights into recent trends. Requirements * Implement a class named `SensorMovingAverage` with the following methods: * `__init__(self, size: int)`: Initializes the class with a specified window size. * `add_reading(self, val: int) -> float`: Adds a sensor reading and returns the current moving average of the readings in the sliding window. Input and Output Formats * **Input**: * The `__init__` method will be called with an integer `size` representing the window size. * The `add_reading` method will be called repeatedly with integer readings from the sensor. * **Output**: * The `add_reading` method should return a floating-point number representing the current moving average of the values in the sliding window. Constraints * The input integer `size` will be at least 1. * The stream of integers provided to `add_reading` can be positive, negative, or zero. * Your implementation should ensure O(1) time complexity for adding a new reading and calculating the moving average. Example ```python # Initialize the moving average with a window size of 3 sma = SensorMovingAverage(3) # Add sensor readings and get the moving average print(sma.add_reading(1)) # Output: 1.0 print(sma.add_reading(10)) # Output: 5.5 print(sma.add_reading(3)) # Output: 4.6666... print(sma.add_reading(5)) # Output: 6.0 ``` Implement the `SensorMovingAverage` class below.","solution":"from collections import deque class SensorMovingAverage: def __init__(self, size: int): self.size = size self.window = deque() self.sum = 0 def add_reading(self, val: int) -> float: if len(self.window) == self.size: self.sum -= self.window.popleft() self.window.append(val) self.sum += val return self.sum / len(self.window)"},{"question":"You are provided with a simplified nearest neighbor algorithm that finds the vector in a training set closest to a given input vector. The specific task is to extend the functionality of this basic implementation to handle a k-nearest neighbors (k-NN) algorithm, taking the k nearest neighbors into account and returning the most frequent class among them. # Task Implement a function `k_nearest_neighbors(x, tSet, k)` which extends the nearest neighbor approach to the k-nearest neighbors algorithm. - `x` is a tuple representing the input vector. - `tSet` is a dictionary where keys are tuples representing vectors and values are the respective class labels. - `k` is an integer denoting the number of nearest neighbors to consider. # Requirements 1. The function should use the Euclidean distance for measuring distance between vectors. 2. The function should handle edge cases, such as vectors of different lengths and empty training sets. 3. Ensure that ties in the most frequent class calculation (when two or more classes have the same frequency) are broken arbitrarily but consistently. # Expected Function Signature ```python def k_nearest_neighbors(x: tuple, tSet: dict, k: int) -> Any: pass ``` # Example ```python training_set = { (1, 2): \'ClassA\', (3, 4): \'ClassB\', (1, 1): \'ClassA\', (2, 2): \'ClassC\', (6, 6): \'ClassB\' } x = (1, 3) k = 3 # Expected output could be \'ClassA\', as it is the most frequent class among the 3 nearest vectors. print(k_nearest_neighbors(x, training_set, k)) ``` # Constraints * Vectors in the training set and the input vector are non-empty and of the same length up to 1000 dimensions. * The training set contains up to 100,000 vectors. * `k` is a positive integer not greater than the number of vectors in the training set. # Notes - Performance is key for larger values of `k` and larger datasets. Aim to write efficient and readable code. - You need to import any necessary modules and handle any possible edge cases in your implementation.","solution":"import math from collections import Counter from typing import Any, Dict, Tuple def euclidean_distance(v1: Tuple[float], v2: Tuple[float]) -> float: Calculate the Euclidean distance between two vectors. return math.sqrt(sum((a - b) ** 2 for a, b in zip(v1, v2))) def k_nearest_neighbors(x: Tuple[float], tSet: Dict[Tuple[float], Any], k: int) -> Any: k-NN algorithm to classify the input vector x based on the k nearest neighbors in the training set tSet. # Handle edge cases if not tSet or k <= 0: raise ValueError(\\"Training set cannot be empty and k must be positive.\\") if any(len(x) != len(vector) for vector in tSet.keys()): raise ValueError(\\"All vectors must have the same length.\\") # Calculate distances from x to all vectors in the training set distances = [(euclidean_distance(x, vector), label) for vector, label in tSet.items()] # Sort by distance and select the k closest neighbors nearest = sorted(distances, key=lambda pair: pair[0])[:k] # Get the most frequent class among the k nearest neighbors counter = Counter(label for _, label in nearest) most_common = counter.most_common(1) return most_common[0][0]"},{"question":"Problem Description You are given an array of integers and a target integer value. Your task is to implement a function that searches for the target value in the array and returns its index if found. If the target value is not in the array, the function should return -1. Implement the search using the linear search algorithm described below. Function Signature ```python def linear_search(array: list[int], query: int) -> int: pass ``` Input * `array`: A list of integers. The array can be empty or contain up to 10^6 integers. * `query`: An integer, the target value to search for in the array. Output * An integer, the index of the target value in the array. If the target is not found, return -1. Constraints 1. The array can have duplicate values, but the function should return the index of the first occurrence of the target value. 2. Implement the solution using the linear search algorithm. 3. Do not use any built-in functions or methods that directly perform search operations. Examples ```python # Example 1 array = [10, 23, 45, 9, 33] query = 23 print(linear_search(array, query)) # Output: 1 # Example 2 array = [1, 2, 3, 4, 5, 6, 7] query = 5 print(linear_search(array, query)) # Output: 4 # Example 3 array = [8, 6, 7, 5, 3, 0, 9] query = 10 print(linear_search(array, query)) # Output: -1 ``` Edge Cases to Consider 1. The array is empty. 2. The target element is at the first or the last position of the array. 3. The array contains multiple instances of the target element.","solution":"def linear_search(array: list[int], query: int) -> int: Perform a linear search to find the index of the query in the array. Return the index of the first occurrence of the query, or -1 if not found. for index, value in enumerate(array): if value == query: return index return -1"},{"question":"Context: You are tasked to work on a text processing tool that identifies specific patterns (symbols) within a set of given words and highlights them. The highlight involves surrounding the matched symbol within the word with square brackets `[ ]`. If a word matches multiple symbols, the longest matching symbol should be chosen. Problem Statement: Write a function `highlight_symbols` that takes in two lists: - `words`: a list of strings containing the words to be processed. - `symbols`: a list of strings containing the symbols to be highlighted. Your function should return a list of words where each word is modified such that any part of it matching a symbol from the list is surrounded by square brackets. If a word matches multiple symbols, use the longest symbol. Function Signature: ```python def highlight_symbols(words: List[str], symbols: List[str]) -> List[str]: ``` Input: - `words`: A list of strings containing 1 to 10000 words of length up to 100 characters each. - `symbols`: A list of strings containing 1 to 100 symbols of length up to 10 characters each. Output: - A list of strings where the symbols in the words are highlighted with square brackets. Example: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] # Output should be: # [Am]azon, Mi[cro]soft, Goog[le] highlight_symbols(words, symbols) # should return [\\"[Am]azon\\", \\"Mi[cro]soft\\", \\"Goog[le]\\"] ``` Constraints and Notes: - If a word contains multiple matches of different symbols, only the longest match should be enclosed in brackets. - If no symbols match a word, the word should remain unchanged. - Assume no overlapping symbols and words initially.","solution":"from typing import List def highlight_symbols(words: List[str], symbols: List[str]) -> List[str]: def get_longest_symbol(word, symbols): longest = \\"\\" for symbol in symbols: if symbol in word and len(symbol) > len(longest): longest = symbol return longest highlighted_words = [] for word in words: longest_symbol = get_longest_symbol(word, symbols) if longest_symbol: word = word.replace(longest_symbol, f\\"[{longest_symbol}]\\") highlighted_words.append(word) return highlighted_words"},{"question":"You are given two variants of Heap Sort algorithms, one using a Max Heap and the other using a Min Heap. A **Heap Sort algorithm** sorts an array by leveraging the properties of heap data structures. Your task is to implement the variant of the Heap Sort that uses a **Min Heap** data structure. The implementation should conform to these requirements: # Function Signature ```python def min_heap_sort(arr: List[int], simulation: bool=False) -> List[int]: ``` # Input 1. **arr (List[int])**: An unsorted list of integers that need to be sorted, with length ( n ). 2. **simulation (bool)**: A boolean flag that, if set to `True`, should print iterative states of the array being sorted. # Output - **sorted_arr (List[int])**: Return a new list of integers which is the sorted version of the input list `arr` in ascending order. # Constraints 1. ( 0 leq n leq 10^5 ) 2. Each element of `arr` is an integer that fits within the standard integer range (`-2^31` to `2^31-1`). # Performance Requirements - The algorithm should run with a time complexity of O(n log n). - The space complexity should be O(1) considering in-place sorting (excluding the space required for the output list if a new list is to be returned). # Example ```python arr = [3, 1, 5, 2, 4] sorted_arr = min_heap_sort(arr) print(sorted_arr) # Output: [1, 2, 3, 4, 5] ``` # Implementation Note The key function, `min_heap_sort`, should internally call a helper function, `min_heapify`, similar to the one provided. The `simulation` parameter, when set to `True`, shall print each iteration of the array transformation if detailed debugging is needed. **Edge Cases**: - Consider input lists that are already sorted. - Handle cases where the input list is empty.","solution":"from typing import List def min_heapify(arr: List[int], n: int, i: int): smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] < arr[smallest]: smallest = left if right < n and arr[right] < arr[smallest]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] min_heapify(arr, n, smallest) def min_heap_sort(arr: List[int], simulation: bool=False) -> List[int]: n = len(arr) # Build the Min Heap for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i) if simulation: print(\\"Initial Min-Heap:\\", arr) # One by one extract elements for i in range(n - 1, 0, -1): # Swap arr[i], arr[0] = arr[0], arr[i] # Call heapify on the reduced heap min_heapify(arr, i, 0) if simulation: print(f\\"After extracting {i} elements:\\", arr) return arr[::-1] # Since it is a min-heap, we need to reverse it to get sorted order"},{"question":"# Question: Implement an Enhanced Moving Average Implement an enhanced version of the MovingAverage class that optimizes the time complexity to O(1) per call to `next`. Instead of recalculating the sum every time a new element is added, maintain a running sum. Your class should be designed using the following structure: ```python class MovingAverage: def __init__(self, size: int): Initialize your data structure here. :type size: int pass def next(self, val: int) -> float: :type val: int :rtype: float pass ``` # Requirements: * **Input Format**: * The `__init__` method receives an integer `size`, the size of the moving window. * The `next` method receives an integer `val`, which is the next value in the stream of integers. * **Output Format**: * The `next` method should return the moving average as a float. * **Constraints**: * `1 <= size <= 10^4` * `-10^5 <= val <= 10^5` * **Performance Requirements**: * The `next` method should run in O(1) time per new integer added. # Example: ```python m = MovingAverage(3) print(m.next(1)) # returns 1.0 print(m.next(10)) # returns 5.5 print(m.next(3)) # returns 4.67 print(m.next(5)) # returns 6.0 ``` # Edge Cases: 1. Handling very large window sizes and ensuring that it doesn\'t exceed memory limits. 2. Correctly computing the moving average for the first few calls when the number of elements is less than the window size. # Scenario: Let\'s consider a scenario where we are receiving temperature sensor data every minute. To smooth out short-term fluctuations and monitor general trends, you decide to implement a moving average of the last 5 readings. You will extend this concept to handle other similar streams of data efficiently. Implement the class with the above specifications and ensure it is tested with various edge cases and performance conditions.","solution":"class MovingAverage: def __init__(self, size: int): Initialize your data structure here. :type size: int self.size = size self.queue = [] self.sum = 0.0 def next(self, val: int) -> float: :type val: int :rtype: float if len(self.queue) == self.size: self.sum -= self.queue.pop(0) self.queue.append(val) self.sum += val return self.sum / len(self.queue)"},{"question":"Coding Assessment Question # Context You have been given two functions that calculate the factorial of a given non-negative integer, `n`. One implementation uses an iterative approach while the other uses a recursive approach. Both functions also support calculating the factorial modulo some integer value to keep the result within specific bounds. # Task Write a function to calculate factorial iteratively and recursively with additional requirements: 1. If `n` is greater than 10,000, use the iterative approach to avoid stack overflow. 2. If `mod` is provided, return the factorial modulo `mod`. 3. Inputs should be checked for validity: * `n` must be a non-negative integer. * `mod` must be a positive integer. 4. The function should use efficient error handling and return appropriate error messages for invalid inputs. # Function Signature ```python def compute_factorial(n, mod=None): This function will calculate factorial of \'n\'. If \'n\' > 10,000, use the iterative approach. If \'mod\' is provided, compute n! % mod. :param n: (int) The non-negative integer for which we want to compute the factorial. :param mod: (Optional[int]) The modulus value for the factorial computation. :returns: (int) The factorial of \'n\', either directly or modulo \'mod\'. ``` # Input Constraints * `0 <= n <= 100,000` * `mod` is a positive integer if provided. # Example Usage ```python print(compute_factorial(5)) # Output: 120 print(compute_factorial(5, 3)) # Output: 0 print(compute_factorial(10001)) # Output: (factorial of 10001 using iterative approach) try: compute_factorial(-1) # Raises ValueError: \\"\'n\' must be a non-negative integer.\\" except ValueError as e: print(e) try: compute_factorial(\'a\') # Raises ValueError: \\"\'n\' must be a non-negative integer.\\" except ValueError as e: print(e) ``` # Requirements 1. **Performance**: * Function must handle `n` up to 100,000 efficiently. * Properly handle and return results for large factorial numbers. 2. **Edge Cases**: * Handle `n=0` correctly. * Handle large values without stack overflow by switching to iterative approach.","solution":"def compute_factorial(n, mod=None): This function will calculate factorial of \'n\'. If \'n\' > 10,000, use the iterative approach. If \'mod\' is provided, compute n! % mod. :param n: (int) The non-negative integer for which we want to compute the factorial. :param mod: (Optional[int]) The modulus value for the factorial computation. :returns: (int) The factorial of \'n\', either directly or modulo \'mod\'. if not isinstance(n, int) or n < 0: raise ValueError(\\"\'n\' must be a non-negative integer.\\") if mod is not None: if not isinstance(mod, int) or mod <= 0: raise ValueError(\\"\'mod\' must be a positive integer.\\") if n == 0 or n == 1: return 1 if n > 10000: return compute_factorial_iter(n, mod) else: return compute_factorial_recur(n, mod) def compute_factorial_iter(n, mod): result = 1 for i in range(2, n + 1): result *= i if mod: result %= mod return result def compute_factorial_recur(n, mod): if n == 0 or n == 1: return 1 if mod: return (n * compute_factorial_recur(n - 1, mod)) % mod else: return n * compute_factorial_recur(n - 1, mod)"},{"question":"Context: You are working on developing a digital circuit simulator that requires precise control over binary data representations. One of your tasks is to implement functions that can insert single or multiple bits into specific positions in a binary number. Objective: Implement two functions `insert_one_bit` and `insert_mult_bits` that insert one or multiple bits into a given binary number at the specified positions. # Function 1: Insert One Bit **Function Signature**: ```python def insert_one_bit(num: int, bit: int, i: int) -> int: pass ``` **Input**: * `num` (int): The binary number in which the bit will be inserted. * `bit` (int): The single bit to insert (0 or 1). * `i` (int): The position at which to insert the bit. **Output**: * (int): The resulting binary number after insertion. **Example**: ```python insert_one_bit(21, 1, 2) => 45 # 10101 -> 101101 insert_one_bit(21, 0, 2) => 41 # 10101 -> 101001 insert_one_bit(21, 1, 5) => 53 # 10101 -> 110101 ``` # Function 2: Insert Multiple Bits **Function Signature**: ```python def insert_mult_bits(num: int, bits: int, length: int, i: int) -> int: pass ``` **Input**: * `num` (int): The binary number in which multiple bits will be inserted. * `bits` (int): The bits to insert. * `length` (int): The number of bits in `bits`. * `i` (int): The position at which to insert the bits. **Output**: * (int): The resulting binary number after insertion. **Example**: ```python insert_mult_bits(5, 7, 3, 1) => 47 # 101 -> 101111 insert_mult_bits(5, 7, 3, 0) => 47 # 101 -> 101111 insert_mult_bits(5, 7, 3, 3) => 61 # 101 -> 111101 ``` **Constraints**: * `0 <= num <= 10^9` * `0 <= bit <= 1` * `0 <= bits <= 2^length - 1` * `0 <= length <= 30` * `0 <= i <= 30` **Performance Requirement**: Your functions should have O(n) time complexity where n is the number of bits in the number `num`. Notes: * Ensure you handle edge cases such as inserting bits at the very beginning or at the end of the number. * Keep in mind possible performance improvements for repeated operations by optimizing your mask creation. Good luck!","solution":"def insert_one_bit(num: int, bit: int, i: int) -> int: Inserts a single bit into a binary number at the specified position. Args: num (int): Binary number. bit (int): Bit to insert (0 or 1). i (int): Position to insert the bit. Returns: int: Resulting binary number after insertion. left = num >> i right = num & ((1 << i) - 1) result = (left << (i + 1)) | (bit << i) | right return result def insert_mult_bits(num: int, bits: int, length: int, i: int) -> int: Inserts multiple bits into a binary number at the specified position. Args: num (int): Binary number. bits (int): Bits to insert. length (int): Number of bits in `bits`. i (int): Position to insert the bits. Returns: int: Resulting binary number after insertion. left = num >> i right = num & ((1 << i) - 1) result = (left << (i + length)) | (bits << i) | right return result"},{"question":"# Task You are given an unsorted array `nums`. Your task is to reorder the array so that it follows a \\"wiggle\\" pattern, where `nums[0] < nums[1] > nums[2] < nums[3]...`. In other words, the even-indexed elements should be less than their subsequent odd-indexed elements, and those odd-indexed elements should be greater than the elements that follow. # Input * An unsorted list `nums`, where `1 <= len(nums) <= 10^4` and `-10^4 <= nums[i] <= 10^4`. # Output * The re-ordered list `nums` that follows the \\"wiggle\\" pattern. # Example Input ```python nums = [3, 5, 2, 1, 6, 4] ``` Output ```python [3, 5, 1, 6, 2, 4] ``` # Constraints * You should not use extra space for another array; the reordering must be done in place. * Try to achieve this with a time complexity of O(n). # Scenario Imagine you are a data scientist working on a preprocessing step for a machine learning pipeline where the input features need to exhibit non-monotonic patterns within their short-term segments. Implement the function `wiggle_sort` to achieve this. ```python def wiggle_sort(nums): Reorder the elements of nums in a single pass to fulfill nums[0] < nums[1] > nums[2] < nums[3]... for i in range(len(nums)): if (i % 2 == 1) == (nums[i-1] > nums[i]): nums[i-1], nums[i] = nums[i], nums[i-1] # Example usage: if __name__ == \\"__main__\\": array = [3, 5, 2, 1, 6, 4] print(\\"Before wiggle sort:\\", array) wiggle_sort(array) print(\\"After wiggle sort:\\", array) ```","solution":"def wiggle_sort(nums): Reorder the elements of nums in a single pass to fulfill nums[0] < nums[1] > nums[2] < nums[3]... for i in range(1, len(nums)): if (i % 2 == 1 and nums[i-1] > nums[i]) or (i % 2 == 0 and nums[i-1] < nums[i]): nums[i-1], nums[i] = nums[i], nums[i-1] return nums"},{"question":"# Question: First Occurrence in a Sorted Array You are given a sorted array of integers (sorted in increasing order) and a target value. Implement a function `first_occurrence` that finds and returns the index of the first occurrence of the given target value in the array using binary search. If the target value is not found, return `None`. Function Signature ```python def first_occurrence(array: List[int], query: int) -> int: # your code here ``` Input - `array`: A list of integers sorted in increasing order (e.g., `[1, 2, 4, 4, 5, 6, 8]`). - `query`: An integer target value to search for in the array. Output - Returns the index of the first occurrence of the target value in the array. - If the target value is not found, return `None`. Constraints - The array length does not exceed 10^6. - The array elements are within the range `-10^9` to `10^9`. - The target value is an integer within the same range. Examples ```python # Examples assert first_occurrence([1, 2, 2, 4, 4, 5, 6, 8], 4) == 3 assert first_occurrence([1, 2, 2, 4, 4, 5, 6, 8], 2) == 1 assert first_occurrence([1, 2, 2, 4, 4, 5, 6, 8], 8) == 7 assert first_occurrence([1, 2, 2, 4, 4, 5, 6, 8], 3) == None assert first_occurrence([], 4) == None ``` # Note - Make sure to handle empty arrays and cases where the target is not present in the array. - Ensure the implementation maintains a logarithmic time complexity.","solution":"from typing import List, Optional def first_occurrence(array: List[int], query: int) -> Optional[int]: Finds the first occurrence of the target value in the sorted array using binary search. Args: array: A list of integers sorted in increasing order. query: An integer target value to search for in the array. Returns: The index of the first occurrence of the target value in the array. If the target value is not found, returns None. left, right = 0, len(array) - 1 result = None while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid right = mid - 1 # continue searching in the left subarray elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Pancake Sort Implementation and Analysis You are required to implement the Pancake Sort algorithm without referencing any code examples. Pancake Sort is inspired by the process of sorting a stack of pancakes using a spatula to flip the stack. The goal is to sort the given array by performing a series of prefix reversals. # Scenario You are given an array of integers that represents pancake sizes, where each integer signifies the size of a pancake. Your task is to sort this array in ascending order using the Pancake Sort algorithm. # Detailed Description 1. Find the maximum element in the subarray that extends from the start to the current unsorted portion. 2. Flip the subarray ending at the maximum element to bring this maximum element to the front. 3. Flip the entire unsorted portion to move the maximum element to its correct position at the end. 4. Repeat this process for the remaining unsorted portion until the entire array is sorted. # Requirements * Implement the function: ```python def pancake_sort(arr: List[int]) -> List[int]: ``` * **Input**: A list of integers `arr` with the constraints: - 0 ≤ len(arr) ≤ 100 - -10^9 ≤ arr[i] ≤ 10^9 (where i is a valid index within the array) * **Output**: A list of integers sorted in ascending order. * This function must sort the list in-place and return the sorted list. # Constraints 1. Your solution must work for various inputs, including edge cases like empty and single-element arrays. 2. You should aim for a correct and efficient implementation with a focus on in-place operations. # Example ```python assert pancake_sort([3, 2, 4, 1]) == [1, 2, 3, 4] assert pancake_sort([10, -1, 0, 5, 3]) == [-1, 0, 3, 5, 10] assert pancake_sort([1]) == [1] assert pancake_sort([]) == [] ``` # Performance Considerations - Ensure the time complexity adheres to the O(N^2) requirement. - Aim to achieve space efficiency with in-place sorting.","solution":"from typing import List def flip(arr: List[int], k: int) -> None: Reverses the order of the first k elements in the array. arr[:k] = arr[:k][::-1] def find_max_index(arr: List[int], n: int) -> int: Finds the index of the maximum element in the first n elements of the array. max_idx = 0 for i in range(1, n): if arr[i] > arr[max_idx]: max_idx = i return max_idx def pancake_sort(arr: List[int]) -> List[int]: Sorts the array using the Pancake Sort algorithm. curr_size = len(arr) while curr_size > 1: # Find the index of the maximum element in the first curr_size elements max_idx = find_max_index(arr, curr_size) # Move the maximum element to the end of the current stack if max_idx != curr_size - 1: # Flip the maximum element to the front if it\'s not already there if max_idx != 0: flip(arr, max_idx + 1) # Flip the maximum element to its sorted position flip(arr, curr_size) # Reduce the size of the current stack curr_size -= 1 return arr"},{"question":"# Primitive Root Finder You are given a number `n`, and your task is to find all primitive roots of this number. In modular arithmetic, a primitive root of a prime `n` is an integer `g` such that every number between 1 and `n-1` can be expressed as `g^k` mod `n` for some integer `k`. To achieve this, you need to implement two core functions: 1. `find_order(a, n)` which computes the order of the integer `a` modulo `n`. 2. `find_primitive_root(n)` which utilizes `find_order` and `euler_totient` to find all primitive roots of `n`. Function Signature ```python def find_order(a: int, n: int) -> int: ... def find_primitive_root(n: int) -> List[int]: ... ``` # Requirements * The `find_order` function should return the smallest positive integer `k` such that ( a^k equiv 1 pmod{n} ). If no such ( k ) exists (i.e., `gcd(a, n) != 1`), return `-1`. * The `find_primitive_root` function should return a list of all integers between `1` and `n-1` that are primitive roots of `n`. # Example Input ```plaintext n = 10 ``` Output ```plaintext [3, 7] ``` Explanation 1. For `n = 10`, the Euler\'s Totient function ( ϕ(10) = 4 ). 2. The primitive roots are `3` and `7` because: - ( 3^1 equiv 3, 3^2 equiv 9, 3^3 equiv 27, 3^4 equiv 1 pmod{10} ) gives order 4. - ( 7^1 equiv 7, 7^2 equiv 49, 7^3 equiv 343, 7^4 equiv 2401, 7^5 equiv 16807, 7^6 equiv 117649, 7^7 equiv 823543, 7^8 equiv 5764801, 7^9 equiv 40353607, 7^{10} equiv 282475249, 7^{11} equiv 1977326743, 7^{12} equiv 13841287201, 7^{13} equiv 96889010407, 7^{14} equiv 678223072849, 7^{15} equiv 4747561509943, 7^{16} equiv 33232930569601, 7^{17} equiv 232630513987207, 7^{18} equiv 162841359791 ) and in the end a mod operation returns 1. # Constraints * Assume `1 <= n <= 10^5`.","solution":"from math import gcd from typing import List def euler_totient(n: int) -> int: result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def find_order(a: int, n: int) -> int: if gcd(a, n) != 1: return -1 order = 1 current = a % n while current != 1: current = (current * a) % n order += 1 return order def find_primitive_root(n: int) -> List[int]: if n < 2: return [] phi = euler_totient(n) primitive_roots = [] for g in range(1, n): if find_order(g, n) == phi: primitive_roots.append(g) return primitive_roots"},{"question":"FizzBuzz Encoding with Custom Rules # # Problem Description You are required to implement a function using an algorithm similar to the classic Fizz Buzz. Instead of replacing numbers divisible by 3 with \'Fizz\', numbers divisible by 5 with \'Buzz\', and numbers divisible by both 3 and 5 with \'FizzBuzz\', we have some customized rules. Given two integers `a` and `b` along with a range `N`, your task is to create a list from 1 to N where: 1. Replace numbers divisible by `a` with the string \'A\'. 2. Replace numbers divisible by `b` with the string \'B\'. 3. Replace numbers divisible by both `a` and `b` with the string \'AB\'. Write a function `custom_fizzbuzz(a, b, n)` that returns this list. # Input Format - `a` (integer): a positive integer that will be the first divisor. - `b` (integer): a positive integer that will be the second divisor. - `n` (integer): a positive integer defining the range of numbers from 1 to N. # Output Format - A list of integers and strings as per the rules defined. # Constraints - `1 <= a, b, n <= 10^4` - `a` and `b` will be coprime numbers (i.e., the greatest common divisor between them is 1). # Example ```python custom_fizzbuzz(2, 3, 10) ``` Should return: ```python [1, \'A\', \'B\', \'A\', 5, \'AB\', 7, \'A\', \'B\', \'A\'] ``` # Notes - Do not assume that a, b, and n will always be valid positive integers. - Validate the inputs and handle invalid cases appropriately. # Submission Implement the `custom_fizzbuzz` function in Python. Don\'t use any external libraries except for standard Python libraries. ```python def custom_fizzbuzz(a, b, n): # Your implementation here pass ```","solution":"def custom_fizzbuzz(a, b, n): Generate a FizzBuzz-like list based on custom rules. :param a: Divisor to replace with \'A\' :param b: Divisor to replace with \'B\' :param n: Range of numbers from 1 to `n` :return: List of integers and strings based on rules result = [] for i in range(1, n + 1): if i % a == 0 and i % b == 0: result.append(\'AB\') elif i % a == 0: result.append(\'A\') elif i % b == 0: result.append(\'B\') else: result.append(i) return result"},{"question":"**Scenario**: You are developing a software tool that requires users to input their license keys in a format that’s easy to read. These license keys are a combination of letters and numbers separated by dashes. However, the dashes may be inconsistently placed by the users, and your task is to reformat these keys into a consistent format. **Task**: Write a function `format_license_key(key: str, k: int) -> str` which takes a string `key` and an integer `k` and returns the formatted license key. The formatted license key should: 1. Ignore all dashes in the input string. 2. Group the characters from the right end in groups of `k` and insert dashes between these groups. 3. All letters in the returned string should be in uppercase. **Input**: - `key`: (string) The original license key which may contain dashes. - `k`: (integer) The number of characters in each group. **Output**: - A string representing the reformatted license key. **Constraints**: - The function should handle strings up to length 10^4. - All letters in the output must be converted to uppercase. - The function should handle empty strings as well. **Examples**: ```python assert format_license_key(\\"2-4A0r7-4k\\", 4) == \\"24A0-R74K\\" assert format_license_key(\\"2-4A0r7-4k\\", 3) == \\"24-A0R-74K\\" assert format_license_key(\\"--a-a-a-a--\\", 2) == \\"AA-AA\\" assert format_license_key(\\"\\", 3) == \\"\\" ``` **Explanation**: 1. For `format_license_key(\\"2-4A0r7-4k\\", 4)`, we first convert the string to \\"24A0R74K\\" and then group it into 4 like \\"24A0-R74K\\". 2. For `format_license_key(\\"2-4A0r7-4k\\", 3)`, we first convert the string to \\"24A0R74K\\" and then group it into 3 like \\"24-A0R-74K\\". 3. For `format_license_key(\\"--a-a-a-a--\\", 2)`, we first convert the string to \\"AAAA\\" and then group it into 2 like \\"AA-AA\\". 4. For `format_license_key(\\"\\", 3)`, since the string is empty, the output is also an empty string. **Note**: Ensure your code is efficient and handles edge cases properly.","solution":"def format_license_key(key: str, k: int) -> str: # Remove all dashes and convert to uppercase clean_key = key.replace(\'-\', \'\').upper() # The length of the first group first_group_length = len(clean_key) % k or k # Split the cleaned key into groups groups = [clean_key[:first_group_length]] for i in range(first_group_length, len(clean_key), k): groups.append(clean_key[i:i + k]) # Join groups with dashes and return the result return \'-\'.join(groups)"},{"question":"**Scenario**: You are developing a software module for a database system that needs to efficiently sort large datasets of non-negative integers. To achieve this, you decide to implement Radix Sort due to its efficient handling of integer data. # Task Implement the function `radix_sort_with_optimization` that takes a list of non-negative integers and returns the sorted list. Your implementation should also handle lists with negative integers by modifying the basic Radix Sort algorithm. # Function Signature ```python def radix_sort_with_optimization(arr: List[int]) -> List[int]: pass ``` # Input * A list of integers `arr` where -10^9 <= arr[i] <= 10^9. The list can be empty. # Output * A sorted list of integers in non-decreasing order. # Constraints * Do not use Python\'s in-built sort methods. * Optimize your algorithm to minimize time and space complexity. * Consider handling negative integers effectively within your implementation. # Example ```python assert radix_sort_with_optimization([170, -12, 45, 75, -90, 802, 24, 2, 66]) == [-90, -12, 2, 24, 45, 66, 75, 170, 802] assert radix_sort_with_optimization([-5, -10, 0, 5, -3, 8, 4, -1]) == [-10, -5, -3, -1, 0, 4, 5, 8] assert radix_sort_with_optimization([]) == [] assert radix_sort_with_optimization([3, 3, 3, -3, -3, -3, 0]) == [-3, -3, -3, 0, 3, 3, 3] ``` # Notes The provided function should sort the list of mixed integers efficiently, taking into consideration the sign of integers and optimizing the Radix Sort algorithm where necessary.","solution":"from typing import List def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = abs(arr[i]) // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = abs(arr[i]) // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 for i in range(n): arr[i] = output[i] def radix_sort(arr): max_num = max(arr, key=abs) exp = 1 while max_num // exp > 0: counting_sort(arr, exp) exp *= 10 def radix_sort_with_optimization(arr: List[int]) -> List[int]: if not arr: return arr non_negatives = [num for num in arr if num >= 0] negatives = [-num for num in arr if num < 0] if non_negatives: radix_sort(non_negatives) if negatives: radix_sort(negatives) negatives = [-num for num in reversed(negatives)] return negatives + non_negatives"},{"question":"Tarjan\'s Algorithm to Identify Strongly Connected Components Implement Tarjan\'s Algorithm to find all strongly connected components in a given directed graph. Your implementation should ensure an efficient processing of the graph to identify all SCCs correctly. # Function Signature ```python def find_scc(graph: Dict[int, List[int]]) -> List[List[int]]: pass ``` # Input - A directed graph represented as a dictionary where keys are node labels (integers) and values are lists of adjacent nodes. # Output - A list of lists, where each sublist contains the nodes in one strongly connected component, sorted in ascending order. # Constraints - The graph will have at most 10^4 nodes. - Node labels are unique integers. - The graph edges are given as adjacency lists, with no duplicate edges within the lists. - The graph can be disconnected. # Example ```python graph = { 0: [1], 1: [2, 3, 4], 2: [0], 3: [4], 4: [] } print(find_scc(graph)) ``` # Expected Output ```text [ [0, 1, 2], [3], [4] ] ``` # Notes - Ensure to handle nodes with no outgoing edges and isolated nodes correctly. - The output sublists should be sorted to facilitate easy reading and matching during testing. - Ensure your implementation handles the maximum constraints efficiently. # Evaluation Criteria - Correctness: Does the function correctly identify all SCCs? - Efficiency: Does the function run within permissible time limits for large graphs? - Handling Edge Cases: Does it handle isolated, disconnected, and single-node components correctly?","solution":"def find_scc(graph): Returns the list of strongly connected components in the given directed graph as per Tarjan\'s Algorithm. index = 0 # to hold the index of nodes stack = [] indices = {} lowlinks = {} on_stack = set() sccs = [] def strongconnect(node): nonlocal index # Set the depth index for this node indices[node] = index lowlinks[node] = index index += 1 stack.append(node) on_stack.add(node) # Consider successors of the node for neighbor in graph.get(node, []): if neighbor not in indices: # Successor has not yet been visited; recurse on it strongconnect(neighbor) lowlinks[node] = min(lowlinks[node], lowlinks[neighbor]) elif neighbor in on_stack: # The successor is in the stack and hence in the current SCC lowlinks[node] = min(lowlinks[node], indices[neighbor]) # If node is a root node, pop the stack and generate an SCC if lowlinks[node] == indices[node]: scc = [] while True: w = stack.pop() on_stack.remove(w) scc.append(w) if w == node: break sccs.append(sorted(scc)) for node in graph: if node not in indices: strongconnect(node) return sorted(sccs) # Sample graph for testing graph = { 0: [1], 1: [2, 3, 4], 2: [0], 3: [4], 4: [] } print(find_scc(graph)) # Expected: [[0, 1, 2], [3], [4]]"},{"question":"# Radix Sort with Digits in Array Given an array of non-negative integers, implement an optimized version of the radix sort algorithm. The goal is to sort the array in ascending order based on individual digits, processing from least significant to most significant digits. The given implementation must respect space efficiency while maintaining sorting stability. Function Signature ```python def optimized_radix_sort(arr): pass ``` Input * `arr`: A list of non-negative integers `arr` (0 ≤ arr[i] ≤ 10^9, 1 ≤ len(arr) ≤ 10^5) Output * Returns the sorted list of integers in ascending order. Constraints * The function should handle large arrays efficiently. * Minimize additional space usage wherever possible. Example ```python arr = [170, 45, 75, 90, 802, 24, 2, 66] print(optimized_radix_sort(arr)) # Output: [2, 24, 45, 66, 75, 90, 170, 802] arr = [5, 3, 8, 6, 2, 7] print(optimized_radix_sort(arr)) # Output: [2, 3, 5, 6, 7, 8] ``` Performance Note The implementation should run in O(nk) time complexity where n is the length of the array and k is the number of digits in the largest number (logarithmic base 10). Hint Consider using counting sort for the digit-level sorting to maintain stability and efficiency.","solution":"def counting_sort(arr, exp): A helper function to perform counting sort based on the digit represented by exp. n = len(arr) output = [0] * n # output array that will have sorted arr count = [0] * 10 # since digits are from 0-9 # Store count of occurrences in count[] for i in range(n): index = arr[i] // exp count[index % 10] += 1 # Change count[i] so that count[i] now contains actual # position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 # Copy the output array to arr[], so that arr now # contains sorted numbers according to current digit for i in range(n): arr[i] = output[i] def optimized_radix_sort(arr): Function to do Radix Sort # Find the maximum number to know the number of digits max1 = max(arr) # Do counting sort for every digit. Note that instead # of passing digit number, exp is passed. exp is 10^i # where i is the current digit number exp = 1 while max1 // exp > 0: counting_sort(arr, exp) exp *= 10 return arr"},{"question":"# QuickSort with Random Pivot **Scenario**: Imagine you are managing a web service that sorts a large dataset of integers. Due to the size of the dataset and its varied nature, you want to optimize the sorting process. QuickSort is a fast sorting algorithm on average, but its performance may degrade on certain inputs. To counteract this, you decide to implement a version of QuickSort that selects a random pivot instead of the last element. **Task**: Write a Python function `quick_sort_random` that implements QuickSort using a random element as the pivot. Ensure the function handles edge cases efficiently and optimizes performance as much as possible. You should not modify the input array directly; rather, return a new sorted list. **Function Signature**: ```python def quick_sort_random(arr: List[int], simulation: bool=False) -> List[int]: # Your implementation here ``` **Input**: * `arr` (List[int]): A list of integers that need to be sorted. * `simulation` (bool): If `True`, print the list in its state after each partition, including which iteration it is on; defaults to `False`. **Output**: * Returns a new sorted list of integers. **Constraints**: * The length of the list (n) will be in the range 0 ≤ n ≤ 10000. * Each integer in the list can be in the range of -10^5 ≤ arr[i] ≤ 10^5. **Examples**: ```python # Example 1: input: [4,2,7,3,1] output: [1,2,3,4,7] # Example 2: input: [10, 5, 2, 3, 7, 8, 6] output: [2, 3, 5, 6, 7, 8, 10] ``` **Performance Requirements**: * Ensure each partitioning decision is efficient. * Handle edge cases gracefully.","solution":"from typing import List import random def quick_sort_random(arr: List[int], simulation: bool=False) -> List[int]: A function that implements QuickSort using a random pivot strategy. Parameters: arr (List[int]): A list of integers to be sorted. simulation (bool): If True, prints the list in its state after each partition. Returns: List[int]: A new sorted list of integers. if len(arr) <= 1: return arr # already sorted def partition(a, low, high): pivot_index = random.randint(low, high) a[low], a[pivot_index] = a[pivot_index], a[low] pivot = a[low] left_marker = low + 1 right_marker = high done = False while not done: while left_marker <= right_marker and a[left_marker] <= pivot: left_marker += 1 while a[right_marker] >= pivot and right_marker >= left_marker: right_marker -= 1 if right_marker < left_marker: done = True else: a[left_marker], a[right_marker] = a[right_marker], a[left_marker] a[low], a[right_marker] = a[right_marker], a[low] if simulation: print(f\\"Pivot index {right_marker}, Pivot {pivot}, Array state: {a}\\") return right_marker def quick_sort_helper(a, low, high): if low < high: split_point = partition(a, low, high) quick_sort_helper(a, low, split_point - 1) quick_sort_helper(a, split_point + 1, high) result = arr[:] quick_sort_helper(result, 0, len(result) - 1) return result"},{"question":"# Assignment: Implement a Secure Diffie-Hellman Key Exchange **Problem Statement**: Alice and Bob want to securely share a secret key over an insecure network using the Diffie-Hellman Key Exchange method. You need to implement the key components of this protocol to ensure they exchange keys securely. **Function Specifications**: 1. **alice_private_key(p)**: - **Input**: A prime number ( p ). - **Output**: Alice\'s private key as a random integer within the range ([1, p-1]). 2. **alice_public_key(a_pr_k, a, p)**: - **Input**: Alice\'s private key ( a_pr_k ), a primitive root ( a ) of ( p ), and the prime number ( p ). - **Output**: Alice\'s public key. 3. **bob_private_key(p)**: - **Input**: A prime number ( p ). - **Output**: Bob\'s private key as a random integer within the range ([1, p-1]). 4. **bob_public_key(b_pr_k, a, p)**: - **Input**: Bob\'s private key ( b_pr_k ), a primitive root ( a ) of ( p ), and the prime number ( p ). - **Output**: Bob\'s public key. 5. **alice_shared_key(b_pu_k, a_pr_k, p)**: - **Input**: Bob\'s public key ( b_pu_k ), Alice\'s private key ( a_pr_k ), and the prime number ( p ). - **Output**: The shared secret key computed by Alice. 6. **bob_shared_key(a_pu_k, b_pr_k, p)**: - **Input**: Alice\'s public key ( a_pu_k ), Bob\'s private key ( b_pr_k ), and the prime number ( p ). - **Output**: The shared secret key computed by Bob. 7. **diffie_hellman_key_exchange(a, p)**: - **Input**: A primitive root ( a ) of prime ( p ), and the prime number ( p ). - **Output**: Returns `True` if Alice and Bob successfully compute the same shared secret key, otherwise `False`. **Constraints**: - ( p ) must be a prime number. - ( a ) must be a primitive root of ( p ). **Example**: ```python prime_number = 23 primitive_root = 5 success = diffie_hellman_key_exchange(primitive_root, prime_number) ``` **Expected Output**: Ensure your function handles all necessary checks and edge cases, and both Alice and Bob should derive the same shared key if the inputs are correct.","solution":"import random def alice_private_key(p): Returns Alice\'s private key as a random integer within the range [1, p-1]. return random.randint(1, p-1) def alice_public_key(a_pr_k, a, p): Returns Alice\'s public key. return pow(a, a_pr_k, p) def bob_private_key(p): Returns Bob\'s private key as a random integer within the range [1, p-1]. return random.randint(1, p-1) def bob_public_key(b_pr_k, a, p): Returns Bob\'s public key. return pow(a, b_pr_k, p) def alice_shared_key(b_pu_k, a_pr_k, p): Returns the shared secret key computed by Alice. return pow(b_pu_k, a_pr_k, p) def bob_shared_key(a_pu_k, b_pr_k, p): Returns the shared secret key computed by Bob. return pow(a_pu_k, b_pr_k, p) def diffie_hellman_key_exchange(a, p): Returns True if Alice and Bob successfully compute the same shared secret key, otherwise False. # Generate Alice\'s keys alice_private = alice_private_key(p) alice_public = alice_public_key(alice_private, a, p) # Generate Bob\'s keys bob_private = bob_private_key(p) bob_public = bob_public_key(bob_private, a, p) # Generate shared keys alice_shared = alice_shared_key(bob_public, alice_private, p) bob_shared = bob_shared_key(alice_public, bob_private, p) return alice_shared == bob_shared"},{"question":"# Trie Implementation and Usage in Auto-Completion **Objective**: You are tasked with implementing a Trie data structure to support auto-completion functionality for a text search engine. **Problem Statement**: Implement a `Trie` with the following methods: 1. `insert(word: str) -> None`: Adds a word to the Trie. 2. `search(word: str) -> bool`: Searches for an exact match of the word in the Trie. Returns `True` if the word exists, `False` otherwise. 3. `starts_with(prefix: str) -> bool`: Checks if there is any word in the Trie that starts with the given prefix. Returns `True` if such a prefix exists, `False` otherwise. 4. `suggest(prefix: str) -> List[str]`: Returns a list of all words in the Trie that start with the given prefix. **Constraints**: - All words consist of lowercase letters (a-z). - No duplicate words to be inserted. **Input/Output Format**: - `insert`: Takes a single argument `word` (string) and returns `None`. - `search`: Takes a single argument `word` (string) and returns a boolean. - `starts_with`: Takes a single argument `prefix` (string) and returns a boolean. - `suggest`: Takes a single argument `prefix` (string) and returns a list of strings. **Example**: ```python trie = Trie() trie.insert(\\"hello\\") trie.insert(\\"helium\\") assert trie.search(\\"hello\\") == True assert trie.search(\\"helix\\") == False assert trie.starts_with(\\"hel\\") == True assert trie.starts_with(\\"hey\\") == False assert set(trie.suggest(\\"hel\\")) == {\\"hello\\", \\"helium\\"} assert trie.suggest(\\"hey\\") == [] ``` **Note**: - You are required to implement the Trie and its methods completely. - The suggestions should be returned in any order.","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def suggest(self, prefix: str) -> list: def dfs(node, path, suggestions): if node.end_of_word: suggestions.append(\'\'.join(path)) for char, next_node in node.children.items(): path.append(char) dfs(next_node, path, suggestions) path.pop() node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] suggestions = [] dfs(node, list(prefix), suggestions) return suggestions"},{"question":"You are given a directed, weighted acyclic graph representing a series of stations, where you need to determine the minimum cost path from the initial station (station 0) to the final station (station N-1). The costs are provided as a N x N matrix, where `cost[i][j]` represents the cost of moving from station `i` to station `j` for `i < j`. Entries where `i > j` or unreachable stations are represented by `-1` or `INF`. # Function Signature ```python def min_cost_path(cost: List[List[int]]) -> int: ``` # Input * `cost`: A 2D integer list (N x N), where: - `1 <= N <= 100` - `cost[i][j]` is a non-negative integer if `i < j`, and represents the cost from station `i` to station `j`. - `cost[i][j]` for `i > j` is `-1` or `INF`. - `cost[i][i]` is always `0`. # Output * Returns an integer indicating the minimum cost to reach the final station (station N-1) from the initial station (station 0). If the final station is unreachable, return `-1`. # Constraints - You must implement a solution with a time complexity of at most (O(n^2)). - Only use (O(n)) additional space. # Example ```python cost = [ [0, 15, 80, 90], [-1, 0, 40, 50], [-1, -1, 0, 70], [-1, -1, -1, 0] ] assert min_cost_path(cost) == 65 ``` In the example above, the minimum cost path is `0 -> 1 -> 3` with a total cost of `65`. # Notes 1. Handle edge cases like a trivial graph with only one node. 2. Consider scenarios where all paths might be unreachable due to high `INF` costs. 3. Optimize for performance to handle up to the constraint limits efficiently.","solution":"from typing import List import sys def min_cost_path(cost: List[List[int]]) -> int: N = len(cost) dp = [sys.maxsize] * N dp[0] = 0 for i in range(1, N): for j in range(i): if cost[j][i] != -1: dp[i] = min(dp[i], dp[j] + cost[j][i]) return dp[N-1] if dp[N-1] != sys.maxsize else -1"},{"question":"# Stutter Stack Values Objective Implement a function `stutter_stack` that takes a stack and replaces every value in the stack with two occurrences of that value. This exercise helps in understanding stack manipulations and differences in auxiliary data structure usage (stack vs. queue). Input and Output Formats - **Input**: A list of integers representing a stack where the last element of the list is the top of the stack. - **Output**: A list with the same elements duplicated in the correct stack order, where the last element is the top of the stack. Constraints - The stack can contain 0 or more integers. - The integers can be positive, negative, or zero. - The function should be efficient to handle up to 10^5 elements. Performance The function should have O(n) time complexity and use efficient space management to handle the size constraints. Context You are tasked with implementing stutterStack function in two variations based on the usage of auxiliary data structures (stack or queue): 1. `def first_stutter(stack: List[int]) -> List[int]:` 2. `def second_stutter(stack: List[int]) -> List[int]:` Example ```python # Stacks are represented as lists where the last element is the top of the stack. input_stack = [3, 7, 1, 14, 9] # Calling both functions should return: first_stutter(input_stack) => [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] second_stutter(input_stack) => [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` Implement the following functions to test this behavior: ```python from typing import List import collections def first_stutter(stack: List[int]) -> List[int]: # Add your implementation storage_stack = [] for i in range(len(stack)): storage_stack.append(stack.pop()) for i in range(len(storage_stack)): val = storage_stack.pop() stack.append(val) stack.append(val) return stack def second_stutter(stack: List[int]) -> List[int]: # Add your implementation q = collections.deque() for i in range(len(stack)): q.append(stack.pop()) for i in range(len(q)): stack.append(q.pop()) for i in range(len(stack)): q.append(stack.pop()) for i in range(len(q)): val = q.pop() stack.append(val) stack.append(val) return stack ``` Test both function implementations against various input cases to ensure correctness and efficiency.","solution":"from typing import List import collections def first_stutter(stack: List[int]) -> List[int]: This function doubles each element in the given stack using another auxiliary stack. storage_stack = [] while stack: storage_stack.append(stack.pop()) while storage_stack: val = storage_stack.pop() stack.append(val) stack.append(val) return stack def second_stutter(stack: List[int]) -> List[int]: This function doubles each element in the given stack using a queue. q = collections.deque() while stack: q.append(stack.pop()) while q: val = q.pop() stack.append(val) while stack: q.append(stack.pop()) while q: val = q.pop() stack.append(val) stack.append(val) return stack"},{"question":"**Objective**: Demonstrate your understanding of tree traversal, recursion, and linked list formation by implementing a function that converts a binary search tree (BST) into a sorted doubly linked list. Problem Statement Write a function `convert_bst_to_doubly_linked_list(root)` that takes the root of a binary search tree and converts it into a sorted doubly linked list **in place**. Specifically, for each node in the tree: - Its left pointer should point to the previous node in the list. - Its right pointer should point to the next node in the list. Your function should return the head of the doubly linked list. Input Format - `root`: The root node of the BST. Each node is an instance of the `TreeNode` class. Output Format - The function should return the head of the resultant doubly linked list (the node with the smallest value). Constraints - The number of nodes in the tree is in the range [0, 10^4]. - Node values lie between -10^5 and 10^5. - The BST property holds for every node (left children are less, right children are greater). Example Given the BST: ``` 4 / 2 5 / 1 3 ``` The function should return a sorted doubly linked list as: ``` 1 <-> 2 <-> 3 <-> 4 <-> 5 ``` Implementation Details - You may use the provided `TreeNode` class for node definition. - Ensure your implementation handles edge cases effectively (e.g., empty tree, single node tree). - Aim for an efficient solution with respect to time and space complexity. ```python # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def convert_bst_to_doubly_linked_list(root: TreeNode) -> TreeNode: # Write your solution here. pass ``` **End of Question.** Additional Guidelines - Do not alter the function signature. - Your implementation will be evaluated on correctness, efficiency, and handling of edge cases.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def convert_bst_to_doubly_linked_list(root: TreeNode) -> TreeNode: if not root: return None def inorder_traversal(node): nonlocal last, head if not node: return inorder_traversal(node.left) if last: last.right = node node.left = last else: head = node last = node inorder_traversal(node.right) last, head = None, None inorder_traversal(root) return head"},{"question":"# Problem Description You have been tasked to implement a search function that returns the indices of all occurrences of a given target in an array. This will require a variant of the linear search algorithm. Your function should handle both sorted and unsorted arrays and return a list of indices where the target appears. # Function Signature ```python def find_all_indices(array: list, target: int) -> list: :param array: List of integers. :param target: Integer to search for. :return: List of indices where the target is located. Returns an empty list if the target is not found. ``` # Input * array: A list of integers (1 ≤ len(array) ≤ 10^5, 0 ≤ array[i] ≤ 10^9) * target: An integer (0 ≤ target ≤ 10^9) # Output * A list of integers representing the indices of all occurrences of the target in the array. Return an empty list if the target is not found. # Constraints 1. The array can be either sorted or unsorted. 2. The target integer can appear multiple times in the array or not at all. 3. Your implementation should run in O(n) time complexity where n is the size of the array. 4. The solution should operate with O(1) additional space (excluding the space required for the output list). # Example Input ```python array = [1, 3, 7, 8, 7, 5, 6, 7] target = 7 ``` Output ```python [2, 4, 7] ``` Input ```python array = [1, 2, 3, 4, 5] target = 6 ``` Output ```python [] ``` # Additional Notes * Ensure that your solution correctly handles edge cases like an empty array or when the target is not present. * Focus on writing clean and efficient code. Good luck!","solution":"def find_all_indices(array, target): Returns the indices of all occurrences of the target in the array. return [index for index, value in enumerate(array) if value == target]"},{"question":"# Binary Search Task You are provided with a sorted array of integers. Implement a function `enhanced_binary_search` that takes the array and a target value as input and returns the index of the target value if it is present in the array. If it is not present, your function should return -1. Additionally, your implementation should handle edge cases such as: * An empty array. * Multiple occurrences of the target value and should return the first occurrence. * Ensure that the function can handle negative numbers and non-integer values gracefully. **Function Specification**: ```python def enhanced_binary_search(array, target): Performs a binary search to find the index of target in the sorted array. Parameters: array (list): A sorted list of integers. target (int): The target value to search for. Returns: int: The index of target if present; otherwise, -1. # Your code here ``` **Input Constraints**: * `array` will be a list containing elements from -10^6 to 10^6. * `target` will be an integer value between -10^6 and 10^6. * The length of `array` will not exceed 10^6 elements. **Example**: ```python print(enhanced_binary_search([1, 2, 3, 4, 5], 3)) # Output: 2 print(enhanced_binary_search([1, 2, 3, 4, 5], 6)) # Output: -1 print(enhanced_binary_search([], 3)) # Output: -1 print(enhanced_binary_search([-5, -3, -1, 0, 2], -1)) # Output: 2 ``` Implement the function to correctly return the index of the target value, considering all the edge cases mentioned above.","solution":"def enhanced_binary_search(array, target): Performs a binary search to find the index of target in the sorted array. Parameters: array (list): A sorted list of integers. target (int): The target value to search for. Returns: int: The index of target if present; otherwise, -1. left, right = 0, len(array) - 1 first_occurrence = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == target: first_occurrence = mid right = mid - 1 # Keep searching in the left half for the first occurrence elif array[mid] < target: left = mid + 1 else: right = mid - 1 return first_occurrence"},{"question":"Histogram Enhanced You have been given a list of integers, and you need to compute the frequency distribution of each element in the list as done previously with the `get_histogram` function. However, to better understand how this frequency is spread, you\'ll write a function that not only returns the histogram (frequency dictionary) but also includes the following additional metrics: 1. **Mode**: The element(s) that appear most frequently in the list. 2. **Count**: Total number of elements in the input list. Write a function `enhanced_histogram(input_list: list) -> tuple` that returns a tuple consisting of: - A dictionary representing the histogram (frequency of elements). - A list of the mode(s). - An integer representing the total count of elements. # Input - A list of integers where each integer can be positive, negative, or zero. - The number of elements in the list will be at most 10^5. # Output - A tuple where: - The first element is a dictionary representing the histogram. - The second element is a list of integers (mode(s)). - The third element is an integer representing the total count of elements. # Example Input: ```python [2, 3, 5, 5, 5, 6, 4, 3, 7] ``` Output: ```python ({2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1}, [5], 9) ``` # Constraints 1. The input list will have integers ranging from -10^6 to 10^6. 2. The input list length will be at most 10^5. # Function Signature ```python def enhanced_histogram(input_list: list) -> tuple: ``` # Additional Information - When there are multiple mode values, return all of them in the list. - If the input list is empty, return an empty dictionary for the histogram, an empty list for the mode, and zero for the count.","solution":"from collections import defaultdict def enhanced_histogram(input_list: list) -> tuple: Computes the frequency distribution of each element in the list and also returns the mode(s) and the total count of elements. Args: input_list (list): A list of integers. Returns: tuple: A tuple containing: - A dictionary representing the histogram. - A list of integers representing the mode(s). - An integer representing the total count of elements. if not input_list: return {}, [], 0 histogram = defaultdict(int) for num in input_list: histogram[num] += 1 max_frequency = max(histogram.values()) modes = [num for num, freq in histogram.items() if freq == max_frequency] return dict(histogram), modes, len(input_list)"},{"question":"Context: You are working with a system that handles large numbers stored in arrays of digits. Given an array where each element represents a digit of a large number (with the most significant digit at the head of the list), you need to implement an algorithm that adds one to this number. Problem: Implement a function to increment a large number represented as an array of digits by one. The result should handle carries over correctly and efficiently. Function Signature: ```python def plus_one(digits: List[int]) -> List[int]: pass ``` Input: - A list of integers `digits`, where (1 leq len(digits) leq 10^4) and each integer (0 leq digit leq 9). Output: - A list of integers representing the incremented number. Constraints: - The digit array represents a non-negative integer without leading zeros (except for the number zero itself). Example: ```python assert plus_one([1, 2, 3]) == [1, 2, 4] assert plus_one([4, 3, 2, 1]) == [4, 3, 2, 2] assert plus_one([0]) == [1] assert plus_one([9, 9, 9]) == [1, 0, 0, 0] ``` Performance Requirements: - The implemented solution must operate with a time complexity of (O(n)) and space complexity of (O(1)). Additional Notes: - Students should consider edge cases such as the number containing all 9s, leading to an increased digit length in the result. - It is recommended to use in-place operations and avoid unnecessary use of extra space to optimize performance. Evaluate the implementation on the clarity, correctness, and adherence to the provided constraints and performance requirements.","solution":"from typing import List def plus_one(digits: List[int]) -> List[int]: Increment the large number represented by the list of digits by one. n = len(digits) # Traverse the digits starting from the end for i in range(n - 1, -1, -1): if digits[i] == 9: digits[i] = 0 else: digits[i] += 1 return digits # If all digits were 9, we need an extra digit in the result return [1] + [0] * n"},{"question":"# Transitive Closure with Optimized Search **Scenario**: You are tasked with analyzing the reachability of nodes in a directed graph, such as a social network graph where nodes represent users and edges represent follower relationships. Your objective is to implement an optimized version of the transitive closure algorithm using DFS as well as alternative approaches to ensure efficiency. **Task**: Implement a function `compute_transitive_closure(V, edges)` that computes the transitive closure matrix of a graph. 1. **Function Definition**: ```python def compute_transitive_closure(V, edges): Computes the transitive closure matrix using DFS. :param V: An integer representing the number of vertices. :param edges: A list of tuples (source, target) representing directed edges. :return: A 2D list representing the transitive closure matrix. ``` 2. **Input**: * `V` - The number of vertices in the graph (1 <= V <= 100). * `edges` - A list of tuples, where each tuple (source, target) represents a directed edge from `source` to `target`. (0 <= source, target < V) 3. **Output**: * A list of lists representing the transitive closure matrix of size VxV. `matrix[i][j]` should be 1 if there is a path from vertex `i` to vertex `j`, and 0 otherwise. 4. **Constraints**: * Self-loops are possible. * Ensure the solution is efficient for the given constraints. 5. **Example**: ```python V = 4 edges = [(0, 1), (1, 2), (2, 3)] print(compute_transitive_closure(V, edges)) # Output: [[1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1]] ``` 6. **Performance**: * Ensure your solution runs efficiently for the given constraints. **Hint**: Leverage a custom DFS function and consider optimizing your search approach to prevent redundant computations.","solution":"def compute_transitive_closure(V, edges): Computes the transitive closure matrix using DFS. :param V: An integer representing the number of vertices. :param edges: A list of tuples (source, target) representing directed edges. :return: A 2D list representing the transitive closure matrix. # Initialize the transitive closure matrix with 0s tc = [[0] * V for _ in range(V)] # Create adjacency list adj_list = [[] for _ in range(V)] for src, tgt in edges: adj_list[src].append(tgt) # A utility function to perform DFS from a given vertex and mark reachability def dfs(start, v): # Mark reachability in the transitive closure matrix if tc[start][v] == 0: # to avoid redundant work tc[start][v] = 1 # Recur for all the vertices adjacent to this vertex for neighbor in adj_list[v]: dfs(start, neighbor) # Perform DFS for each vertex to find its reachability for i in range(V): dfs(i, i) return tc"},{"question":"You are given an unsorted array of integers, and your task is to find the length of the longest increasing subsequence (LIS) in that array. Implement the most efficient algorithm you can for this task, taking into consideration the constraints given below. # Input Format: - A list of integers `sequence` containing n elements, where 1 <= n <= 10^5. - The elements can be any integer within the range of 32-bit signed integers. # Output Format: - Return an integer that represents the length of the longest increasing subsequence. # Constraints: - Your solution should be performant both in terms of time (preferably O(n log n)) and space (preferably O(n)). # Scenario: Consider a scenario in financial analysis where you need to identify the longest period of increasing stock prices from historical data. # Example: ```plaintext Input: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], thus its length is 4. ``` # Edge Cases: 1. Edge cases include arrays where all elements are the same, e.g., [5, 5, 5, 5]. 2. Arrays with sorted elements in decreasing order. 3. Empty arrays or arrays with only one element. Your algorithm should handle the above mentioned edge cases and return the correct length of the LIS accordingly. # Instructions: 1. Implement the function `longest_increasing_subsequence(sequence)` based on dynamic programming and/or other advanced data structures you find suitable. 2. Consider performance in terms of both time and space. 3. Describe any assumptions or design decisions in your comments. # Function Signature: ```python def longest_increasing_subsequence(sequence: List[int]) -> int: ``` # Hints: - Consider using arrays or segment trees for efficient range queries and updates. - Think about how you can utilize sorting and deduplication to simplify the problem.","solution":"from bisect import bisect_left def longest_increasing_subsequence(sequence): Returns the length of the longest increasing subsequence in the given sequence. The function uses a dynamic programming approach with binary search for efficiency. The time complexity is O(n log n), where n is the length of the sequence. if not sequence: return 0 # List to store the smallest ending element of all increasing subsequences # with length i+1 at index i lis = [] for num in sequence: # Find the position where this number can be placed pos = bisect_left(lis, num) # If pos is equal to the length of lis, it means num is larger than all elements in lis if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"# Magic Number Recognition and Sum-Digit Algorithm Scenario You are developing a numerical validation system for a magical game where specific numbers termed \\"Magic Numbers\\" have special significance. A number is defined as a Magic Number if repeating the sum of its digits eventually equates to `1`. Task Write a function `is_magic_number(number: int) -> bool` that: * Takes an integer `number` as input. * Returns `True` if it is a Magic Number. * Returns `False` otherwise. # Input Format * An integer `number` (1 <= number <= 10^9). # Output Format * A boolean value `True` or `False`. # Constraints * The input will always be a non-negative integer. * Maximum input range ensures handling up to one billion. # Examples ```python assert is_magic_number(50113) == True assert is_magic_number(1234) == True assert is_magic_number(199) == True assert is_magic_number(111) == False ``` # Requirements * Implement the function efficiently with respect to both time and space.","solution":"def is_magic_number(number: int) -> bool: def sum_of_digits(n: int) -> int: return sum(int(digit) for digit in str(n)) while number >= 10: number = sum_of_digits(number) return number == 1"},{"question":"You are tasked with determining if a robot\'s movements, represented by a string of characters, result in the robot returning to its original starting position at (0,0). --- # Function Signature ```python def is_robot_back_to_origin(moves: str) -> bool: ``` # Input * `moves` (str): A string representing the robot\'s sequence of moves. The string may only contain the characters \'U\' (up), \'D\' (down), \'L\' (left), and \'R\' (right). # Output * `bool`: A boolean value (`True` or `False`). Return `True` if the robot returns to the starting position (0,0) after executing all the moves. Otherwise, return `False`. # Constraints * The length of `moves` will be in the range [0, 10,000]. # Examples 1. **Example 1** * Input: `\\"UD\\"` * Output: `True` * Explanation: The robot moves up once and down once, returning to the original position. 2. **Example 2** * Input: `\\"LL\\"` * Output: `False` * Explanation: The robot moves left twice, which doesn\'t bring it back to the starting position. # Edge Cases to Consider * An empty string should return `True`. * Strings with sequential balancing moves should return `True`, e.g., `\\"UUDDLRLR\\"`. * Strings with unbalanced moves should return `False`, e.g., `\\"UDLRUD\\"`. --- Implement the function `is_robot_back_to_origin` in Python: ```python def is_robot_back_to_origin(moves: str) -> bool: # Your code here ``` # Function Description * Keep track of the robot\'s position on a 2D grid. * Iterate through each move in the input string. * Adjust the x and y coordinates based on the move \'R\' (right, x increase), \'L\' (left, x decrease), \'U\' (up, y increase), and \'D\' (down, y decrease). * After processing all moves, check if the final coordinates are (0,0).","solution":"def is_robot_back_to_origin(moves: str) -> bool: x, y = 0, 0 for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"# Maximum Flow Evaluation Context: You are managing a water distribution network for a city, represented as a directed graph. Each vertex in the graph represents a junction point, and each directed edge represents a water pipeline with a specific capacity indicating the maximum volume of water that can flow through it. Problem Statement: Given the vertex count, a two-dimensional array representing the capacity matrix, a source vertex, and a sink vertex, determine the maximum flow from the source to the sink using Dinic\'s algorithm. Function Signature: ```python def maximum_flow_dinic(vertex_count, capacity_matrix, source, sink): :param vertex_count: int - Number of vertices in the graph. :param capacity_matrix: List[List[int]] - Matrix where capacity_matrix[i][j] represents capacity of edge from vertex i to vertex j. :param source: int - The source vertex. :param sink: int - The sink vertex. :return: int - Maximum flow from source to sink. ``` Input: 1. `vertex_count`: The number of vertices (1 ≤ vertex_count ≤ 500). 2. `capacity_matrix`: A 2D list of non-negative integers of dimensions vertex_count x vertex_count representing capacities (0 if no direct edge). 3. `source`: An integer representing the source vertex. 4. `sink`: An integer representing the sink vertex. Output: - An integer representing the maximum flow from the source to the sink. Constraints: - Ensure you handle graphs with no augmenting paths effectively. - Use Dinic’s algorithm to solve for maximum flow. Example: ```python vertex_count = 4 capacity_matrix = [ [0, 10, 10, 0], [0, 0, 5, 10], [0, 0, 0, 10], [0, 0, 0, 0] ] source = 0 sink = 3 # Expected Output: 20 print(maximum_flow_dinic(vertex_count, capacity_matrix, source, sink)) ``` Notes: - Perform thorough testing with explicit edge cases such as disconnected graphs, and graphs with zero capacity edges. - Aim for a clean, efficient implementation focusing on clarity and avoiding unnecessary computations.","solution":"from collections import deque def bfs(level_graph, source, sink, level): Perform BFS to construct level graph and update level of vertices. q = deque([source]) level[source] = 0 while q: u = q.popleft() for v in range(len(level_graph)): if level[v] < 0 and level_graph[u][v] > 0: level[v] = level[u] + 1 q.append(v) return level[sink] >= 0 def dfs(level_graph, u, sink, flow, level, start): Perform DFS to find the blocking flow in the constructed level graph. if u == sink: return flow while start[u] < len(level_graph): v = start[u] if level[v] == level[u] + 1 and level_graph[u][v] > 0: curr_flow = min(flow, level_graph[u][v]) temp_flow = dfs(level_graph, v, sink, curr_flow, level, start) if temp_flow > 0: level_graph[u][v] -= temp_flow level_graph[v][u] += temp_flow return temp_flow start[u] += 1 return 0 def maximum_flow_dinic(vertex_count, capacity_matrix, source, sink): Dinic\'s algorithm to find the maximum flow from source to sink in a flow network. if source == sink: return 0 level_graph = [row[:] for row in capacity_matrix] max_flow = 0 while True: level = [-1] * vertex_count if not bfs(level_graph, source, sink, level): break start = [0] * vertex_count while True: flow = dfs(level_graph, source, sink, float(\'Inf\'), level, start) if flow == 0: break max_flow += flow return max_flow"},{"question":"You are given an array of non-negative numbers. Your task is to implement a sorting function using the Bucket Sort algorithm. The inner sorting of each bucket will be handled using a specific function that you may choose to implement. # Function Signature ```python def bucket_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`: A list of non-negative integers. # Output * A list of integers sorted in ascending order. # Constraints * 0 ≤ len(arr) ≤ 10^5 * 0 ≤ arr[i] ≤ 10^6 for 0 ≤ i < len(arr) * If the input is an empty list, the function should return an empty list. # Requirements - Your solution must demonstrate an understanding of the Bucket Sort algorithm. - You can choose an alternative internal sorting algorithm instead of the provided Insertion Sort. # Example ```python >>> bucket_sort([9, 4, 1, 7, 9, 1]) [1, 1, 4, 7, 9, 9] >>> bucket_sort([]) [] >>> bucket_sort([2]) [2] ``` # Notes - Consider edge cases such as empty input array, arrays with repeated elements, and arrays with a single element. - Be mindful of the complexity analysis and scalability of your solution.","solution":"from typing import List def insertion_sort(bucket: List[int]) -> List[int]: Performs insertion sort on a given list (bucket). for i in range(1, len(bucket)): key = bucket[i] j = i - 1 while j >= 0 and key < bucket[j]: bucket[j + 1] = bucket[j] j -= 1 bucket[j + 1] = key return bucket def bucket_sort(arr: List[int]) -> List[int]: Performs bucket sort on a given list. if not arr: return [] min_value = min(arr) max_value = max(arr) bucket_range = (max_value - min_value) / len(arr) + 1 # Scale factor for buckets buckets = [[] for _ in range(len(arr))] for num in arr: bucket_idx = int((num - min_value) / bucket_range) buckets[bucket_idx].append(num) sorted_arr = [] for bucket in buckets: sorted_arr.extend(insertion_sort(bucket)) return sorted_arr"},{"question":"# Scenario You are working on an inventory system for a small retail business. Each item in the inventory is represented by a unique identifier stored in an array. To manage operations effectively, you often need to find the index of an item given its identifier. You decide to use a linear search algorithm because the inventory size isn\'t very large and the simplicity of the algorithm suits your needs. # Task Write a function called `find_item_index` that performs a linear search to find the index of a given item identifier in the array. If the identifier is not found, the function should return -1. # Implementation Function Signature ```python def find_item_index(inventory: list, item_id: int) -> int: ``` Input - `inventory` (list): An array of integers representing item identifiers. - `item_id` (int): The identifier of the item you need to find. Output - Returns the index of `item_id` in the `inventory` array, or -1 if the item is not found. Constraints - The length of `inventory` (n) can be in the range [0, 10^5]. - The item identifiers are guaranteed to be integers. # Example ```python assert find_item_index([101, 205, 309, 412], 309) == 2 assert find_item_index([1, 3, 5, 7, 9], 4) == -1 assert find_item_index([], 1) == -1 assert find_item_index([100], 100) == 0 ```","solution":"def find_item_index(inventory: list, item_id: int) -> int: Returns the index of the item_id in the inventory list using linear search. If the item_id is not found, returns -1. Parameters: inventory (list): An array of integers representing item identifiers. item_id (int): The identifier of the item to be found. Returns: int: The index of the item_id in the inventory or -1 if not found. for index, item in enumerate(inventory): if item == item_id: return index return -1"},{"question":"# Cosine Similarity Function Implementation **Context**: Cosine similarity is a measure often used in machine learning and information retrieval to determine the similarity between two vectors. This is particularly useful in scenarios such as document comparison, recommendation systems, and clustering algorithms. **Task**: Write a function `cosine_similarity(vec1, vec2)` that computes the cosine similarity between two given 1-dimensional lists of numeric values. Your function should handle edge cases such as vectors containing zeroes and different lengths appropriately. **Input**: - `vec1`: A list of floats/integers representing the first vector. - `vec2`: A list of floats/integers representing the second vector. **Output**: - A float representing the cosine similarity between the two vectors. **Constraints**: - The two vectors must be of the same length. - The function should handle vectors containing zeroes appropriately. - Both vectors must contain at least one non-zero element to avoid division by zero errors. **Examples**: ``` cosine_similarity([1, 1, 1], [1, 2, -1]) # Output : 0.47140452079103173 cosine_similarity([0, 0, 1], [0, 0, 1]) # Output : 1.0 cosine_similarity([1, 2, 3], [0, 0, 0]) # Throws an error cosine_similarity([3, 4, 0], [3, 4, 0]) # Output : 1.0 ``` **Requirements**: - Handle invalid inputs such as vectors of different lengths by raising appropriate errors. - Prevent division by zero by asserting that at least one non-zero element exists in each vector. **Expected Solution**: Write a function within the following template: ```python import math def _l2_distance(vec): Helper function to calculate the L2 norm of a vector. # Ensure this function is correctly implemented. pass def cosine_similarity(vec1, vec2): Calculate cosine similarity between two vectors. # Implement the function following the provided guidelines. pass ```","solution":"import math def _l2_distance(vec): Helper function to calculate the L2 norm of a vector. return math.sqrt(sum(x ** 2 for x in vec)) def cosine_similarity(vec1, vec2): Calculate cosine similarity between two vectors. if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length\\") l2_vec1 = _l2_distance(vec1) l2_vec2 = _l2_distance(vec2) if l2_vec1 == 0 or l2_vec2 == 0: raise ValueError(\\"Vectors must contain at least one non-zero element\\") dot_product = sum(x * y for x, y in zip(vec1, vec2)) return dot_product / (l2_vec1 * l2_vec2)"},{"question":"# Missing Ranges Finder Objective Write a Python function that finds the missing ranges within a given sorted array and specified lower and upper bounds. Function Signature ```python def missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: pass ``` Input * `arr` (List[int]): A sorted list of integers representing the existing elements in the range. * `lo` (int): The lower bound of the range. * `hi` (int): The upper bound of the range. Note: The input list `arr` is guaranteed to be sorted. Output * Returns a list of tuples, where each tuple represents a range (inclusive) of missing numbers. Constraints * `1 <= len(arr) <= 10^5` * `-10^6 <= lo <= hi <= 10^6` * Each element in `arr` will be in the range `[lo, hi]`. * The elements in `arr` are distinct. Example ```python arr = [3, 5] lo = 1 hi = 10 missing_ranges(arr, lo, hi) # Output: [(1, 2), (4, 4), (6, 10)] ``` Scenario You are a software engineer tasked with identifying all the gaps in a sequence of booked appointment slot IDs for a clinic, ensuring complete coverage of IDs from `lo` to `hi`. You need to identify and return all ranges of missing appointment slot IDs given the list of booked slots in sorted order. Performance Requirements The function should be optimized to run within a linear time complexity, O(n), given the constraints.","solution":"from typing import List, Tuple def missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: Finds the missing ranges within a given sorted array and specified lower and upper bounds. missing_ranges = [] # Add a virtual boundary outside the hi to handle end cases arr = [lo - 1] + arr + [hi + 1] for i in range(1, len(arr)): if arr[i] - arr[i - 1] > 1: missing_ranges.append((arr[i - 1] + 1, arr[i] - 1)) return missing_ranges"},{"question":"You are given two non-empty lists `v1` and `v2` of integers. You need to design a `ZigzagIterator` class that alternates between elements of `v1` and `v2` sequentially. Once all elements from one list are exhausted, it continues outputting elements from the other list. Implement the following methods: 1. **`__init__(self, v1, v2)`**: Constructor which initializes the iterator with two lists. 2. **`next(self)`**: Returns the next element in the zigzag order. 3. **`has_next(self)`**: Returns `True` if there are any elements left to return, `False` otherwise. Additionally, implement an external function to demonstrate the usage of `ZigzagIterator`: * **`zigzag_order(l1, l2)`**: This function should take two lists and return a new list containing elements in the zigzag order. You should make use of the `ZigzagIterator` class for achieving the zigzag pattern. Constraints * You can assume that the elements of both lists are integers. * Both lists can be of different lengths. * You may not use additional external libraries; rely on standard Python data structures. Example ```python l1 = [1, 2] l2 = [3, 4, 5, 6] it = ZigzagIterator(l1, l2) output = [] while it.has_next(): output.append(it.next()) print(output) # Output: [1, 3, 2, 4, 5, 6] # Using the zigzag_order function print(zigzag_order([1, 2], [3, 4, 5, 6])) # Output: [1, 3, 2, 4, 5, 6] ``` You have to ensure your implementation is efficient and handles all edge cases effectively.","solution":"class ZigzagIterator: def __init__(self, v1, v2): self.queue = [] if v1: self.queue.append((v1, 0)) if v2: self.queue.append((v2, 0)) def next(self): if self.has_next(): v, idx = self.queue.pop(0) if idx + 1 < len(v): self.queue.append((v, idx + 1)) return v[idx] def has_next(self): return bool(self.queue) def zigzag_order(v1, v2): it = ZigzagIterator(v1, v2) result = [] while it.has_next(): result.append(it.next()) return result"},{"question":"# Scenario You\'re tasked with optimizing an existing algorithm that removes duplicates from a list. The current implementation is inefficient for large data sets, leading to sluggish performance. Your goal is to revamp the function to handle larger inputs more efficiently without changing the existing order of elements. # Problem Statement Implement an optimized version of `remove_duplicates` that removes duplicates from an array while maintaining order. # Definition ```python def remove_duplicates(array): # Your code here ``` # Input * `array`: A list of integers, strings, booleans, or a mix, with a length potentially up to 100,000 elements. # Output * Returns a new list with duplicates removed. # Constraints * Do not use any built-in functions except set operations. * Maintain the order of first occurrences in the input list. * Ensure the solution is efficient with time complexity O(n). # Example ```python assert remove_duplicates([1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True]) == [1, 2, 3, 4, \\"hey\\", \\"hello\\", True] assert remove_duplicates([]) == [] assert remove_duplicates([\\"a\\", \\"b\\", \\"a\\", \\"c\\", \\"b\\", \\"d\\"]) == [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] assert remove_duplicates([1, 2, 3, 1, 2, 3, 4]) == [1, 2, 3, 4] ``` # Notes * Consider edge cases such as empty arrays and arrays with all identical elements. * Optimize performance to handle the upper limit of input size efficiently.","solution":"def remove_duplicates(array): Removes duplicates from an array while maintaining order. :param array: List of elements which may have duplicates. :return: A new list with duplicates removed. seen = set() result = [] for item in array: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Run-Length Encoding and Decoding Run-Length Encoding (RLE) is a form of lossless data compression in which consecutive occurrences of the same data value are represented as a single data value and a count. For example, the string \\"AAABBBCCDAA\\" would be encoded as \\"3A3B2C1D2A\\". Your task is to implement two functions: 1. `encode_rle(input: str) -> str`: Compress a string using run-length encoding. 2. `decode_rle(input: str) -> str`: Decompress a string encoded using run-length encoding. Function Descriptions * **Function**: `encode_rle(input: str) -> str` - **Input**: A string to be encoded. - **Output**: The run-length encoded string. - **Constraints**: - The input string will only contain ASCII characters. - The input string length will not exceed 1000 characters. * **Function**: `decode_rle(input: str) -> str` - **Input**: A run-length encoded string. - **Output**: The original uncompressed string. - **Constraints**: - The encoded string will follow the correct encoding format and will not contain digits larger than 9. - The length of the encoded string will not exceed 1000 characters. # Examples 1. **Encoding Example**: ```text Input: \\"AAABBBCCDAA\\" Output: \\"3A3B2C1D2A\\" ``` 2. **Decoding Example**: ```text Input: \\"3A3B2C1D2A\\" Output: \\"AAABBBCCDAA\\" ``` Requirements * Implement the `encode_rle` function that converts an input string to its run-length encoded format. * Implement the `decode_rle` function that converts a run-length encoded input string back to its original uncompressed form. Ensure to handle all possible edge cases including inputs with no repeating characters and empty strings. Performance should be efficient within the constraints provided.","solution":"def encode_rle(input: str) -> str: Compress a string using run-length encoding. if not input: return \\"\\" encoded = [] last_char = input[0] count = 1 for char in input[1:]: if char == last_char: count += 1 else: encoded.append(f\\"{count}{last_char}\\") last_char = char count = 1 encoded.append(f\\"{count}{last_char}\\") return \\"\\".join(encoded) def decode_rle(input: str) -> str: Decompress a string encoded using run-length encoding. i = 0 decoded = [] while i < len(input): count = int(input[i]) char = input[i + 1] decoded.append(char * count) i += 2 return \\"\\".join(decoded)"},{"question":"# Symmetric Binary Trees (Challenging) Given a binary tree, determine if it is symmetric around its center. Input: - A binary tree represented by its root node, where each node contains an integer value and pointers to left and right children. Output: - A boolean value `True` if the tree is symmetric around its center, and `False` otherwise. Constraints: - The number of nodes in the tree can be up to 10^4. - The tree nodes\' values are given as integers. Performance Requirements: - The solution should have a time complexity of O(n) and a space complexity of O(n). # Examples: 1. Symmetric: ``` 1 / 2 2 / / 3 4 4 3 ``` Input: `[1,2,2,3,4,4,3]` Output: `True` 2. Not Symmetric: ``` 1 / 2 2 3 3 ``` Input: `[1,2,2,null,3,null,3]` Output: `False` # Implementation: Write a function `is_symmetric(root)` that: - Takes the root node of a binary tree as input. - Returns `True` if the tree is symmetric, `False` otherwise. **Bonus:** Also, implement an iterative solution in the function `is_symmetric_iterative(root)` that achieves the same result using an explicit stack. ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_symmetric(root: TreeNode) -> bool: # Implement your solution here pass def is_symmetric_iterative(root: TreeNode) -> bool: # Implement your iterative solution here pass ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_symmetric(root: TreeNode) -> bool: def is_mirror(t1: TreeNode, t2: TreeNode) -> bool: if t1 is None and t2 is None: return True if t1 is None or t2 is None: return False return (t1.val == t2.val) and is_mirror(t1.right, t2.left) and is_mirror(t1.left, t2.right) return is_mirror(root, root) def is_symmetric_iterative(root: TreeNode) -> bool: if root is None: return True queue = [(root, root)] while queue: t1, t2 = queue.pop(0) if t1 is None and t2 is None: continue if t1 is None or t2 is None: return False if t1.val != t2.val: return False queue.append((t1.left, t2.right)) queue.append((t1.right, t2.left)) return True"},{"question":"# Prime Number Verification and Sum Calculations Problem Statement Given the provided `prime_check(n)` function, implement a new function `prime_sum(limit)` that calculates the sum of all prime numbers less than or equal to a given integer `limit`. You will then extend `prime_sum(limit)` to another function `prime_subsequence_sum(arr)` that takes a list of integers `arr` and returns the sum of those numbers in the list that are prime according to the `prime_check` function. # Function Descriptions: 1. **prime_sum(limit)**: - **Input**: An integer `limit` where `1 ≤ limit ≤ 10^6`. - **Output**: An integer which is the sum of all prime numbers less than or equal to `limit`. 2. **prime_subsequence_sum(arr)**: - **Input**: A list of integers `arr` with `1 ≤ len(arr) ≤ 10^5` and each element in `arr` within the range `1 ≤ arr[i] ≤ 10^6`. - **Output**: An integer which is the sum of those numbers in `arr` that are prime. # Example ```python prime_sum(10) # Output should be 17 because primes ≤ 10 are 2, 3, 5, 7 prime_subsequence_sum([3, 4, 7, 10, 11]) # Output should be 21 because primes in the list are 3, 7, 11 ``` # Constraints - You should make use of the provided `prime_check` function for checking the primality of numbers. - Your implementation should be efficient in terms of both time and space complexity. Use these guidelines to ensure your functions are robust and performant.","solution":"def prime_check(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_sum(limit): Returns the sum of all prime numbers less than or equal to limit. sum_of_primes = 0 for number in range(2, limit + 1): if prime_check(number): sum_of_primes += number return sum_of_primes def prime_subsequence_sum(arr): Returns the sum of prime numbers within the list arr. return sum(number for number in arr if prime_check(number))"},{"question":"# Question: Incrementing an Array Represented Number You are given a non-negative integer represented as an array of digits, where the most significant digit is at the head of the list. Your task is to write a function that adds one to this number. Function Signature ```python def increment_number(digits: List[int]) -> List[int]: ``` Input - `digits`: A list of integers where each integer is a digit (0-9), with no leading zeroes except in the case of the number zero itself. - Example: `[1, 2, 3]` for the number 123. - Example: `[0]` for the number 0. Output - A list of integers representing the incremented number. - Example: Incrementing `[1, 2, 3]` should give `[1, 2, 4]`. - Example: Incrementing `[9]` should give `[1, 0]`. Constraints - The input list will contain at least one digit. - The size of the list will not exceed 10^4. Example ```python assert increment_number([1, 2, 3]) == [1, 2, 4] assert increment_number([9, 9, 9]) == [1, 0, 0, 0] assert increment_number([0]) == [1] ``` Requirements - The solution should be efficient, with a time complexity of O(N) where N is the number of digits in the list. - Space complexity should consider in-place operations when possible. You are encouraged to handle all edge cases, especially the carry operations across multiple digits.","solution":"from typing import List def increment_number(digits: List[int]) -> List[int]: Increments a number represented by a list of digits. n = len(digits) # Traverse the digits from the end towards the start. for i in range(n-1, -1, -1): if digits[i] == 9: digits[i] = 0 else: digits[i] += 1 return digits # If we have not returned earlier, it means all the digits were 9. # So we need to append a 1 at the beginning. return [1] + digits"},{"question":"# Trimmed Mean Calculation You are tasked with implementing a function that computes the trimmed mean of a list of numbers. The trimmed mean is calculated by removing a specified percentage of the smallest and largest values from the list, and then computing the mean of the remaining values. Function Signature ```python def trimmed_mean(arr: List[float], per: float) -> float: ``` # Parameters - `arr` (List[float]): A list of floating-point numbers from which to calculate the trimmed mean. - `per` (float): The percentage of values to be removed from both ends (smallest and largest) before calculating the mean. # Returns - `float`: The trimmed mean of the remaining values after removing the specified percentage of the smallest and largest values. # Constraints - 0 <= per < 100 - The list `arr` will contain at least one element. - The percentage `per` will be a valid float representing a positive percentage reduction. - The length of `arr` will be such that the number of elements to remove from both ends can be calculated without leaving an empty list. # Example ```python print(trimmed_mean([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 20)) # Output: 5.5 ``` # Explanation Given a list `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` and a percentage `20`, we remove the smallest 10% (1 and 2) and the largest 10% (9 and 10) of values. The remaining list is `[3, 4, 5, 6, 7, 8]`. The mean of these values is `(3 + 4 + 5 + 6 + 7 + 8) / 6 = 5.5`. Note - Consider edge cases such as when the list is very small or when the trimming percentage would remove too many elements. Good luck!","solution":"from typing import List def trimmed_mean(arr: List[float], per: float) -> float: Calculate the trimmed mean of the list of numbers. :param arr: List of floating-point numbers :param per: Percentage of values to remove from both ends :return: Trimmed mean of the remaining values if not arr: return 0.0 n = len(arr) remove_count = int(n * (per / 100)) if 2 * remove_count >= n: raise ValueError(\\"The percentage is too high, resulting in an empty or almost empty list after trimming.\\") sorted_arr = sorted(arr) trimmed_arr = sorted_arr[remove_count:n-remove_count] return sum(trimmed_arr) / len(trimmed_arr) print(trimmed_mean([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 20)) # Output: 5.5"},{"question":"# Question: **Problem Statement: Greatest Common Divisor Using Advanced Methods** Your task is to implement the following functions using the described algorithms and constraints: 1. **gcd_optimized(a: int, b: int) -> int**: - Calculate the greatest common divisor of `a` and `b` using Euclid\'s algorithm. Ensure negative integers are appropriately handled and return meaningful error messages for non-integer or zero inputs. 2. **lcm_optimized(a: int, b: int) -> int**: - Calculate the least common multiple using the previously defined `gcd_optimized` function. 3. **gcd_bitwise(a: int, b: int) -> int**: - Implement the greatest common divisor calculation using bitwise operations as described. **Input/Output Format**: - Input: - `a` and `b`: non-negative integers for all functions. - Output: - For `gcd_optimized` and `gcd_bitwise`: an integer representing the greatest common divisor of `a` and `b`. - For `lcm_optimized`: an integer representing the least common multiple of `a` and `b`. **Constraints**: - 0 ≤ `a`, `b` ≤ 10^6 - Ensure error handling for invalid inputs (non-integer, zero where necessary). **Exercise Example**: ``` python # gcd_optimized Tests assert gcd_optimized(48, 18) == 6 assert gcd_optimized(-48, -18) == 6 assert gcd_optimized(0, 18) # Should raise ValueError for zero input # lcm_optimized Tests assert lcm_optimized(21, 6) == 42 assert lcm_optimized(0, 5) # Should raise ValueError for zero input # gcd_bitwise Tests assert gcd_bitwise(48, 18) == 6 assert gcd_bitwise(7, 0) == 7 # 0 handling assert gcd_bitwise(0, 0) # Should raise ValueError for zero input ``` **Important Considerations**: - Carefully handle edge cases. - Ensure that your functions are efficiently implemented. - Test your functions against a variety of cases to verify correctness and performance.","solution":"def gcd_optimized(a, b): Returns the greatest common divisor of a and b using Euclid\'s algorithm. Raises ValueError for non-integer or zero inputs. if not isinstance(a, int) or not isinstance(b, int): raise ValueError(\\"Inputs must be integers.\\") a, b = abs(a), abs(b) if a == 0 or b == 0: raise ValueError(\\"Inputs must be non-zero integers.\\") while b: a, b = b, a % b return a def lcm_optimized(a, b): Returns the least common multiple of a and b. Raises ValueError for non-integer or zero inputs. if not isinstance(a, int) or not isinstance(b, int): raise ValueError(\\"Inputs must be integers.\\") a, b = abs(a), abs(b) if a == 0 or b == 0: raise ValueError(\\"Inputs must be non-zero integers.\\") return abs(a * b) // gcd_optimized(a, b) def gcd_bitwise(a, b): Returns the greatest common divisor of a and b using Stein\'s algorithm (binary GCD algorithm). Raises ValueError for non-integer or zero inputs. if not isinstance(a, int) or not isinstance(b, int): raise ValueError(\\"Inputs must be integers.\\") a, b = abs(a), abs(b) if a == 0 or b == 0: raise ValueError(\\"Inputs must be non-zero integers.\\") if a == b: return a if a == 0: return b if b == 0: return a if not a & 1: # a is even if b & 1: # b is odd return gcd_bitwise(a >> 1, b) else: # both a and b are even return gcd_bitwise(a >> 1, b >> 1) << 1 if not b & 1: # b is even, a is odd return gcd_bitwise(a, b >> 1) # both a and b are odd, a must be bigger if a > b: return gcd_bitwise((a - b) >> 1, b) return gcd_bitwise((b - a) >> 1, a)"},{"question":"# Pathfinding with Weighted Graphs Scenario: You are working on a navigation system that needs to compute the optimal route between locations on a weighted graph. Each location is a node, and each route between locations has a specific travel cost. The goal is to find not only a path but the most cost-effective path between two locations. Task: Implement the `find_lowest_cost_path` function that determines the path with the lowest travel cost. ```python def find_lowest_cost_path(graph, start, end): Find the path with the lowest total cost between two nodes in a weighted graph. Parameters: graph: dict A dictionary representation of a weighted graph where keys are nodes and values are lists of tuples (neighbor, cost). start: str The starting node. end: str The target node. Returns: list A list of nodes representing the path with the lowest total cost from start to end. If no path exists, return None. pass ``` Input: * `graph`: Dictionary where keys are node identifiers and values are lists of tuples `(neighbor, cost)`. * `start`: Starting node identifier. * `end`: Target node identifier. Output: * Return a list of node identifiers representing the path with the lowest total cost from `start` to `end`. * If no path exists, return `None`. Constraints: * The graph is connected. * There are no negative weights. * Paths should be computed efficiently for larger graphs. Performance Requirements: * The solution should handle graphs with up to 10,000 nodes and 50,000 edges efficiently. Example: ```python graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': [] } start = \'A\' end = \'D\' print(find_lowest_cost_path(graph, start, end)) # Output: [\'A\', \'B\', \'C\', \'D\'] ``` Use Dijkstra’s algorithm to solve this problem effectively.","solution":"import heapq def find_lowest_cost_path(graph, start, end): Find the path with the lowest total cost between two nodes in a weighted graph. Parameters: graph: dict A dictionary representation of a weighted graph where keys are nodes and values are lists of tuples (neighbor, cost). start: str The starting node. end: str The target node. Returns: list A list of nodes representing the path with the lowest total cost from start to end. If no path exists, return None. # Priority queue for Dijkstra\'s algorithm priority_queue = [(0, start, [])] visited = set() while priority_queue: (cost, node, path) = heapq.heappop(priority_queue) if node in visited: continue path = path + [node] if node == end: return path visited.add(node) for neighbor, edge_cost in graph.get(node, []): if neighbor not in visited: heapq.heappush(priority_queue, (cost + edge_cost, neighbor, path)) return None"},{"question":"# Wiggle Sort Implementation Context A sports league assigns player matches in a manner such that the intensity alternates, avoiding consecutive high-intensity matches. This can be achieved by reordering a list of player skill levels so that it fits a \\"wiggle\\" pattern: nums[0] < nums[1] > nums[2] < nums[3]... Task Implement a function `wiggle_sort` that accepts a list of integers and reorders it as mentioned above. Function Signature ```python def wiggle_sort(nums: List[int]) -> None: ``` * **Input**: `nums`, a list of integers of arbitrary length `n` (0 <= n <= 10^5). * It can be empty or contain up to 100,000 integers. * **Output**: The function should modify the list `nums` in-place such that the wiggle property (nums[0] < nums[1] > nums[2] < nums[3]...) holds. The function does not return any value. Constraints * The list should be modified in-place; no extra space other than variables is allowed. * The solution should handle typical edge cases, including empty lists, lists with one element, and lists with repeated numbers. Example ```python nums = [3, 5, 2, 1, 6, 4] wiggle_sort(nums) print(nums) # Expected output might be [3, 5, 1, 6, 2, 4] # Other valid outputs satisfying the condition would also be correct. ```","solution":"from typing import List def wiggle_sort(nums: List[int]) -> None: Reorders `nums` such that it follows the wiggle property. nums[0] < nums[1] > nums[2] < nums[3]... The function modifies nums in-place and does not return anything. for i in range(len(nums) - 1): if i % 2 == 0: if nums[i] > nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i] else: if nums[i] < nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i]"},{"question":"# Path Sum in Binary Tree Given a binary tree and an integer `target_sum`, your task is to write a function to find all root-to-leaf paths where each path\'s sum equals the `target_sum`. The tree is represented by a class `TreeNode` where each node has an integer value and a left and right child. # Function Signature ```python def find_path_sums(root: TreeNode, target_sum: int) -> List[List[int]]: ``` # Input - `root`: The root node of the binary tree. The node has attributes `val`, `left`, and `right`. - `target_sum`: An integer representing the target sum of the paths. # Output - Return a list of all root-to-leaf paths where the sum of the values in the path equals the `target_sum`. # Constraints - Assume an integer range of inputs for node values and target sums. - The tree can have between 0 and 1000 nodes. - The value of a node can range between -1000 and 1000. # Performance - Your solution should be efficient enough to handle large trees and should appropriately handle edge cases. # Scenario You are given a binary tree representing paths of planets and a target sum representing the energy required for a spaceship to travel from the root planet to a leaf planet. You need to find all possible travel paths that match the energy requirement. Use the following class definition for the binary tree nodes: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` # Example Given the following binary tree: ``` 5 / 4 8 / / 11 13 4 / / 7 2 5 1 ``` And `target_sum = 22`, your function should return: ``` [ [5, 4, 11, 2], [5, 8, 4, 5] ] ``` # Note - The order of paths in the answer does not matter. - Ensure your function handles edge cases like a tree without nodes and trees with only single or no path meeting the sum.","solution":"from typing import List class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_path_sums(root: TreeNode, target_sum: int) -> List[List[int]]: def dfs(node, current_sum, path, results): if not node: return path.append(node.val) current_sum += node.val # Check if it\'s a leaf node and the path sum equals target_sum if not node.left and not node.right and current_sum == target_sum: results.append(path[:]) # Traverse the left and right subtree if node.left: dfs(node.left, current_sum, path, results) if node.right: dfs(node.right, current_sum, path, results) # Backtrack path.pop() results = [] dfs(root, 0, [], results) return results"},{"question":"Write a function `num_trees(n: int) -> int` that computes the number of structurally unique Binary Search Trees (BSTs) which can store values from 1 to `n`. # Input - A single integer `n` (0 <= n <= 15) representing the number of nodes. # Output - A single integer representing the number of unique BSTs that can be constructed using `n` nodes. # Constraints - The input value of `n` will not exceed 15, ensuring the algorithm completes within a reasonable time frame. # Examples Example 1: ``` Input: n = 3 Output: 5 ``` Example 2: ``` Input: n = 1 Output: 1 ``` # Explanation To achieve the expected functionality: 1. Use a dynamic programming approach to store results of subproblems. 2. Initialize a dp array where `dp[i]` represents the number of unique BSTs with `i` nodes. 3. Implement the recurrence relation to build the solution iteratively. # Instructions 1. Implement the given function so that it adheres to the input-output requirements. 2. Handle edge cases appropriately, such as `n=0` and `n=1`. 3. Optimize the function wherever possible, keeping in mind the constraints provided.","solution":"def num_trees(n): Returns the number of structurally unique binary search trees (BSTs) that can be formed with n nodes. if n == 0 or n == 1: return 1 # Initialize the dp array where dp[i] will store the number of unique BSTs with i nodes dp = [0] * (n + 1) # There is exactly one unique BST with 0 or 1 node dp[0] = 1 dp[1] = 1 # Fill the dp array using the recursive relation for i in range(2, n + 1): total = 0 for j in range(1, i + 1): left = dp[j - 1] right = dp[i - j] total += left * right dp[i] = total return dp[n]"},{"question":"# Polynomial Arithmetic Implementation Context You are given two classes: `Monomial` and `Polynomial` that models mathematical monomials and polynomials respectively. The classes support basic arithmetic operations including addition, subtraction, multiplication, and division of monomials and polynomials. The task involves enhancing these classes to include additional functionality and implementing test cases to validate the new functionalities. Problem Statement 1. **Enhancement**: Implement a method named `__pow__` in both `Monomial` and `Polynomial` classes to support exponentiation. This method should correctly compute the power of a monomial or polynomial for a given integer exponent. 2. **Test Case Implementation**: Write test cases to validate the implementation of exponentiation for both `Monomial` and `Polynomial` classes in the following scenarios: * Positive integer exponents. * Zero exponent (result should be 1 for polynomial with non-zero constant term, and 0 if the polynomial is zero). # Expected Input and Output ```python class Monomial: # Existing code... def __pow__(self, exponent: int) -> Monomial: # To be implemented pass class Polynomial: # Existing code... def __pow__(self, exponent: int) -> Polynomial: # To be implemented pass ``` # Constraints and Requirements * The method should validate that the exponent is a non-negative integer. * The method should handle the special case where the exponent is zero correctly. * The method should not modify the instance it is called on, but should return a new instance of `Monomial` or `Polynomial` representing the result. Example Test Case ```python def test_monomial_exponentiation(): # Case: Positive exponent monomial = Monomial({1: 2}, 3) result = monomial**3 # (3 * (a_1)^2)^3 = 27 * (a_1)^6 assert result.variables == {1: 6} assert result.coeff == Fraction(27, 1) # Case: Zero exponent result = monomial**0 # Any monomial to 0 exponent = 1 assert result.variables == {} assert result.coeff == Fraction(1, 1) def test_polynomial_exponentiation(): # Case: Positive exponent polynomial = Polynomial([Monomial({1: 1}, 2), Monomial({0: 0}, 3)]) # 2a1 + 3 result = polynomial**2 # (2a1 + 3)^2 = (2a1)^2 + 2*(2a1)*(3) + 3^2 = 4a1^2 + 12a1 + 9 assert len(result.monomials) == 3 assert Monomial({1: 2}, 4) in result.monomials assert Monomial({1: 1}, 12) in result.monomials assert Monomial({}, 9) in result.monomials # Case: Zero exponent result = polynomial**0 # Any polynomial to 0 exponent = 1 assert len(result.monomials) == 1 assert Monomial({}, 1) in result.monomials ```","solution":"from fractions import Fraction class Monomial: def __init__(self, variables: dict, coeff: Fraction): self.variables = variables self.coeff = coeff def __pow__(self, exponent: int): if exponent < 0: raise ValueError(\\"Exponent must be a non-negative integer.\\") if exponent == 0: return Monomial({}, Fraction(1)) new_variables = {var: exp * exponent for var, exp in self.variables.items()} new_coeff = self.coeff**exponent return Monomial(new_variables, new_coeff) def __eq__(self, other): return self.variables == other.variables and self.coeff == other.coeff class Polynomial: def __init__(self, monomials: list): self.monomials = monomials def __pow__(self, exponent: int): if exponent < 0: raise ValueError(\\"Exponent must be a non-negative integer.\\") if exponent == 0: return Polynomial([Monomial({}, Fraction(1))]) result = Polynomial([Monomial({}, Fraction(1))]) for _ in range(exponent): result = result.multiply(self) return result def multiply(self, other): result = [] for mon1 in self.monomials: for mon2 in other.monomials: new_vars = mon1.variables.copy() for var, exp in mon2.variables.items(): if var in new_vars: new_vars[var] += exp else: new_vars[var] = exp new_coeff = mon1.coeff * mon2.coeff result.append(Monomial(new_vars, new_coeff)) combined = {} for mon in result: key = frozenset(mon.variables.items()) if key in combined: combined[key].coeff += mon.coeff else: combined[key] = mon return Polynomial(list(combined.values())) def __eq__(self, other): return set(self.monomials) == set(other.monomials)"},{"question":"You are a data analyst and you need to compute a reliable mean of a dataset after removing outliers. Your task is to implement a function `trimmean(arr, per)` that calculates the trimmed mean of an array of integers. The trimmed mean is the mean of the array after removing a certain percentage of the highest and lowest values. # Function Signature ```python def trimmean(arr: List[int], per: float) -> float: ``` # Input: - `arr`: A list of integers, which can also include negative values. The list contains at least one element and at most (10^6) elements. - `per`: A floating-point number, representing the percentage of values to be trimmed from both ends of the sorted array. The percentage is between 0 and 100 (inclusive). # Output: - The function should return a float, which is the mean of the values remaining after trimming the specified percentage of the highest and lowest values. # Constraints: - If trimming results in an empty list, return `0.0`. - The implementation should ensure accuracy up to four decimal places. # Example: ```python assert trimmean([1, 2, 3, 4, 5], 40) == 3.0 # 40% removal means trimming 2 highest and 2 lowest, mean of [3] is 3.0 assert trimmean([1, 1, 1, 1, 1], 20) == 1.0 # Removing 20% from both ends means trimming 1 highest and 1 lowest, mean of [1, 1, 1] is 1.0 ``` # Note: 1. You need to handle edge cases where the number of elements to be trimmed is not an integer, by flooring the value. 2. Evaluate performance considerations due to sorting for very large input arrays.","solution":"from typing import List def trimmean(arr: List[int], per: float) -> float: Calculate the trimmed mean of an array after removing a certain percentage of the highest and lowest values. The percentage is evenly split between the highest and lowest values. Args: arr (List[int]): A list of integers. per (float): The percentage of values to be trimmed from both ends. Returns: float: The trimmed mean of the array. if not arr: return 0.0 n = len(arr) k = int((per / 100.0) * n) # Sort the array to easily remove the largest and smallest elements sorted_arr = sorted(arr) # Determine the trimmed array. trimmed_arr = sorted_arr[k:n-k] # If after trimming the array becomes empty, return 0.0 if not trimmed_arr: return 0.0 # Calculate the mean of the trimmed array trimmed_mean = sum(trimmed_arr) / len(trimmed_arr) # Return trimmed mean rounded to 4 decimal places for accuracy return round(trimmed_mean, 4)"},{"question":"# Kruskal\'s Minimal Spanning Forest Problem Statement You are given a connected, undirected, weighted graph with ( V ) vertices and ( E ) edges. Write a function `find_MST_weight` that computes the weight of the Minimum Spanning Tree (MST) for the graph using Kruskal\'s algorithm. # Function Signature ```python def find_MST_weight(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: pass ``` # Input * `vertex_count`: `int` - The number of vertices ( V ) in the graph. * `edges`: `List[Tuple[int, int, int]]` - A list of tuples where each tuple consists of three integers representing an edge: - `source`: `int` - Index of the starting vertex of the edge. - `target`: `int` - Index of the ending vertex of the edge. - `weight`: `int` - Weight of the edge. # Output * `int` - The total weight of the MST. # Constraints * ( 1 leq V leq 1000 ) * ( V-1 leq E leq 50000 ) * ( 1 leq text{weight} leq 10000 ) # Examples ```python # Example 1 vertex_count = 4 edges = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)] print(find_MST_weight(vertex_count, edges)) # Output: 19 # Example 2 vertex_count = 5 edges = [(0, 1, 2), (0, 2, 3), (0, 3, 6), (1, 3, 8), (1, 4, 5), (2, 4, 7)] print(find_MST_weight(vertex_count, edges)) # Output: 16 ``` # Notes * The input vertex indices are zero-based. * The MST will be composed of ( V-1 ) edges. * Assume the input graph is connected and thus an MST always exists.","solution":"from typing import List, Tuple def find_MST_weight(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: # Union-Find data structure to manage disjoint sets parent = list(range(vertex_count)) rank = [0] * vertex_count def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 # Sort edges by their weights edges.sort(key=lambda x: x[2]) mst_weight = 0 edge_count = 0 for u, v, weight in edges: if find(u) != find(v): union(u, v) mst_weight += weight edge_count += 1 if edge_count == vertex_count - 1: break return mst_weight"},{"question":"Objective Write a function `unique_subsets` that generates all unique subsets of a given set of distinct integers. The function should efficiently generate subsets using bitwise operations as demonstrated in the provided example. Input * A list of distinct integers `nums` (1 ≤ len(nums) ≤ 20). Output * A set containing tuples. Each tuple represents a unique subset of the input list. The order of subsets does not matter. Constraints * The solution set must not contain duplicate subsets. * Avoid using recursive approaches. Requirements * Your implementation should consider potential edge cases, such as an empty input list or a list with a single element. * The implementation should demonstrate efficient use of bit manipulation to solve the problem. Example ```python Input: nums = [1, 2, 3] Output: { (1,), (2,), (3,), (1, 2,), (1, 3,), (2, 3,), (1, 2, 3,), () } Input: nums = [4, 5] Output: {(), (4,), (5,), (4, 5,)} ``` Python Function Signature: ```python def unique_subsets(nums): :param nums: List[int] :return: Set[tuple] ``` # Instructions 1. Implement the function `unique_subsets` according to the above specifications. 2. Test your implementation with the provided examples and additional test cases. Additional Test Case ```python Input: nums = [1, 2, 3, 4] Output: { (1,), (2,), (3,), (4,), (1, 2,), (1, 3,), (1, 4,), (2, 3,), (2, 4,), (3, 4,), (1, 2, 3,), (1, 2, 4,), (1, 3, 4,), (2, 3, 4,), (1, 2, 3, 4,), () } ```","solution":"def unique_subsets(nums): Generates all unique subsets of a given list of distinct integers. :param nums: List[int] :return: Set[tuple] nums_len = len(nums) subsets = set() # Total number of subsets is 2^n (n is length of nums) for i in range(1 << nums_len): subset = tuple(nums[j] for j in range(nums_len) if i & (1 << j)) subsets.add(subset) return subsets"},{"question":"# Scenario Imagine you are a software engineer tasked with developing a feature for a text-processing application. One of the requirements is to determine whether a given string is a rotated version of another string. This feature will be used to detect rotated phrases in a document search functionality. # Task Write a Python function `is_rotated(s1, s2)` that checks if string `s2` is a rotated version of string `s1`. For example, \\"hello\\" and \\"llohe\\" are rotations of each other, while \\"hello\\" and \\"helol\\" are not. # Function Signature ```python def is_rotated(s1: str, s2: str) -> bool: ``` # Input - A string `s1` (1 <= len(s1) <= 100) - A string `s2` (1 <= len(s2) <= 100) # Output - Return a boolean value `True` if `s2` is a rotated version of `s1`, otherwise return `False`. # Constraints - Both strings are case-sensitive. - You should aim to optimize the function for better performance. # Example ```python assert is_rotated(\\"hello\\", \\"llohe\\") == True assert is_rotated(\\"hello\\", \\"helol\\") == False assert is_rotated(\\"abcde\\", \\"deabc\\") == True assert is_rotated(\\"abcde\\", \\"edbca\\") == False assert is_rotated(\\"abcd\\", \\"dabc\\") == True assert is_rotated(\\"abcd\\", \\"abcd\\") == True assert is_rotated(\\"a\\", \\"a\\") == True ``` **Note**: You should avoid brute force methods and aim for an efficient solution. # Requirement Your implementation should run efficiently within the provided constraints.","solution":"def is_rotated(s1: str, s2: str) -> bool: Checks if s2 is a rotated version of s1. if len(s1) != len(s2): return False # Concatenate s1 with itself doubled_s1 = s1 + s1 # If s2 is a substring of doubled_s1, then s2 is a rotated version of s1 return s2 in doubled_s1"},{"question":"# Context: Networking protocols and file systems often require data to be stored or transmitted in a standard byte order. Two common byte orders are big-endian and little-endian. It\'s crucial for software engineers to convert between integer values and their byte representations correctly, considering the specified byte order. # Task: You are required to implement two functions that convert integers to their byte representations and vice versa, for both big-endian and little-endian formats. # Function Definitions: 1. `def custom_int_to_bytes_big_endian(num: int) -> bytes:` 2. `def custom_int_to_bytes_little_endian(num: int) -> bytes:` 3. `def custom_bytes_big_endian_to_int(bytestr: bytes) -> int:` 4. `def custom_bytes_little_endian_to_int(bytestr: bytes) -> int:` # Expected Input and Output Formats: 1. `def custom_int_to_bytes_big_endian(num: int) -> bytes` - Input: An integer `num` (0 <= num <= 2^64 - 1) - Output: A byte array in big-endian format 2. `def custom_int_to_bytes_little_endian(num: int) -> bytes` - Input: An integer `num` (0 <= num <= 2^64 - 1) - Output: A byte array in little-endian format 3. `def custom_bytes_big_endian_to_int(bytestr: bytes) -> int` - Input: A byte array `bytestr` in big-endian format - Output: An integer representing the converted byte array value 4. `def custom_bytes_little_endian_to_int(bytestr: bytes) -> int` - Input: A byte array `bytestr` in little-endian format - Output: An integer representing the converted byte array value # Constraints: - You may assume that the input integers are within the range of 0 to `2^64 - 1`. - Byte arrays will not contain more than 8 bytes. # Example: ```python assert custom_int_to_bytes_big_endian(305419896) == b\'x12x34x56x78\' assert custom_int_to_bytes_little_endian(305419896) == b\'x78x56x34x12\' assert custom_bytes_big_endian_to_int(b\'x12x34x56x78\') == 305419896 assert custom_bytes_little_endian_to_int(b\'x78x56x34x12\') == 305419896 ``` # Performance Requirements: - The functions should efficiently handle typical use cases such as converting numbers and byte arrays within the specified range. # Additional Information: - Ensure the correctness of handling special cases like the integer zero. - Test your solution with various inputs to validate its robustness.","solution":"def custom_int_to_bytes_big_endian(num: int) -> bytes: Convert an integer to a big-endian byte array. return num.to_bytes((num.bit_length() + 7) // 8 or 1, \'big\') def custom_int_to_bytes_little_endian(num: int) -> bytes: Convert an integer to a little-endian byte array. return num.to_bytes((num.bit_length() + 7) // 8 or 1, \'little\') def custom_bytes_big_endian_to_int(bytestr: bytes) -> int: Convert a big-endian byte array to an integer. return int.from_bytes(bytestr, \'big\') def custom_bytes_little_endian_to_int(bytestr: bytes) -> int: Convert a little-endian byte array to an integer. return int.from_bytes(bytestr, \'little\')"},{"question":"# Coding Assessment: Find All Non-trivial Primitive Roots of a Number Objective Write a function to determine all non-trivial primitive roots of a given positive integer n, excluding 1 and n-1. A primitive root g of n is an integer such that the powers of g modulo n generate all integers coprime to n from 1 to n-1 (inclusive). Function Signature ```python def find_non_trivial_primitive_roots(n: int) -> list: pass ``` Input - An integer n (2 <= n <= 10^5) Output - A list of integers representing all non-trivial primitive roots of n in ascending order. If no non-trivial primitive roots exist, return an empty list. Constraints - The solution must compute results within a reasonable time for any n in the given range. - Avoid using standard library functions if they directly solve the problem. Performance Requirements - Aim for an optimized solution that runs efficiently with respect to time complexity. Example ```python >>> find_non_trivial_primitive_roots(7) [3, 5] >>> find_non_trivial_primitive_roots(10) [] >>> find_non_trivial_primitive_roots(17) [3, 5, 6, 7, 10, 11, 12, 14] ``` Description * Each integer g that is a candidate for being a primitive root should satisfy the conditions of having an appropriate order determined by Euler\'s totient function. * Ensure to avoid trivial roots (1 and n-1) as they are generally not considered in cryptographic applications. Provide a robust, optimized implementation that efficiently finds and returns all the non-trivial primitive roots of a given number n.","solution":"def gcd(a, b): while b: a, b = b, a % b return a def find_non_trivial_primitive_roots(n): if n < 2: return [] def euler_totient(m): result = m p = 2 while p * p <= m: if m % p == 0: while m % p == 0: m //= p result -= result // p p += 1 if m > 1: result -= result // m return result def is_primitive_root(g, n, required_set): actual_set = set() for i in range(1, n): actual_set.add(pow(g, i, n)) if len(actual_set) != i: return False return required_set == actual_set required_set = set(range(1, n)) primitive_roots = [ g for g in range(2, n) if is_primitive_root(g, n, required_set) ] return [g for g in primitive_roots if g != 1 and g != n-1]"},{"question":"**Mode Calculation Challenge** You have been tasked to write a function which identifies the most frequently occurring element(s) in a given list of integers. The function should return a list of the most frequent elements. If there are multiple elements with the same highest frequency, your function should include all of them in the result list. # Function Signature ```python def find_modes(arr: List[int]) -> List[int]: pass ``` # Input * `arr`: A list of integers. # Output * A list of integers representing the mode(s) of the input list. # Constraints 1. Array size can range from 0 to 10^6. 2. Each integer in the array can range from -10^6 to 10^6. # Performance Requirements * Your solution should run efficiently with O(n) time complexity where n is the size of the array. # Examples ```python assert find_modes([1, 1, 2, 2, 3, 4]) == [1, 2] assert find_modes([1, 1, 1, 2, 2, 3, 4, 4, 4]) == [1, 4] assert find_modes([]) == [] assert find_modes([5, 6, 7, 8, 9, 9, 8, 7, 7, 8]) == [7, 8] ``` # Description 1. Your function should first create a dictionary to count the occurrences of each element in the input list. 2. Determine the maximum count from the dictionary. 3. Collect all elements that have this maximum count. 4. Return the list of these elements.","solution":"from typing import List from collections import Counter def find_modes(arr: List[int]) -> List[int]: if not arr: return [] frequency = Counter(arr) max_count = max(frequency.values()) return [num for num, count in frequency.items() if count == max_count]"},{"question":"# Path Joiner Function Problem Statement Given two strings representing parts of a path, write a function `join_path(base, suffix)` that joins them using a single slash `/` as the divider. Ensure that: - There are no redundant slashes between `base` and `suffix`. - The resulting path is correctly formatted for both file system paths and URLs. Input - `base` (str): The base path, which may or may not end with a slash. - `suffix` (str): The suffix path, which may or may not start with a slash. Output - `str`: The correctly joined path. Constraints - `base` and `suffix` are non-null strings with a maximum length of 1000 characters. - `suffix` should be treated as a relative path. If `suffix` is an absolute path, ignore any leading slashes. Example 1. `join_path(\\"path/to/dir\\", \\"file\\")` should return `\\"path/to/dir/file\\"` 2. `join_path(\\"path/to/dir/\\", \\"file\\")` should return `\\"path/to/dir/file\\"` 3. `join_path(\\"http://example.com/\\", \\"part\\")` should return `\\"http://example.com/part\\"` 4. `join_path(\\"http://example.com\\", \\"/part\\")` should return `\\"http://example.com/part\\"` 5. `join_path(\\"base//\\", \\"//suffix\\")` should return `\\"base/suffix\\"` Edge Cases - Both `base` and `suffix` are empty. - `suffix` is an absolute path but should be treated as relative. Function Signature ```python def join_path(base: str, suffix: str) -> str: # Write your code here ``` Performance Requirements - Ensure the function runs efficiently with a time complexity of O(n) where n is the combined length of base and suffix.","solution":"def join_path(base: str, suffix: str) -> str: Joins the base and suffix paths with a single slash, ensuring no redundant slashes. # Remove any trailing slashes from the base base = base.rstrip(\'/\') # Remove any leading slashes from the suffix suffix = suffix.lstrip(\'/\') # Combine the base and suffix with exactly one slash return f\\"{base}/{suffix}\\""},{"question":"**Objective**: Implement an in-place sorting function using the Cycle Sort algorithm. **Task**: Write a function `cycle_sort(arr)` that takes a list of integers and sorts them in non-decreasing order using the Cycle Sort algorithm. **Constraints**: * The input list can contain up to (10^3) elements. * Each element of the array can range from (-10^6) to (10^6). * The solution must sort the list in-place (i.e., with constant additional space). * The worst-case time complexity should be (O(N^2)). **Input Format**: * A list of integers `arr`. **Output Format**: * A sorted list of integers in non-decreasing order. **Function Signature**: ```python def cycle_sort(arr: List[int]) -> List[int]: pass ``` **Example**: 1. Input: `[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]` Output: `[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]` 2. Input: `[7, 2, 5, 3, 7, 4, 6, 2]` Output: `[2, 2, 3, 4, 5, 6, 7, 7]` 3. Input: `[-1, -5, 3, 4, 1, 2]` Output: `[-5, -1, 1, 2, 3, 4]` **Explanation**: The function should sort the input list using the Cycle Sort algorithm, ensuring that the elements are placed in their correct positions through cyclic rotations. **Edge Cases**: * Empty list should return an empty list. * Single-element list should return the list unchanged (e.g., `[1]` returns `[1]`). * Duplicates should be correctly placed (Note: handling duplicates carefully to avoid infinite loops). **Assumptions**: * The input list will not contain invalid values; all inputs are valid integers. **Performance Considerations**: Since Cycle Sort has O(N^2) complexity, it is feasible for the given constraint (up to (10^3) elements).","solution":"def cycle_sort(arr): n = len(arr) for cycle_start in range(0, n - 1): item = arr[cycle_start] pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 if pos == cycle_start: continue while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"# Understanding and Implementing an Atbash Cipher The Atbash Cipher is a simple substitution cipher originally used for the Hebrew alphabet but applicable to any alphabet. Your task is to implement the Atbash Cipher in Python. # Detailed Requirements: Function Signature: ```python def atbash(s: str) -> str: ``` Input: * `s` (str): A string that needs to be obfuscated using the Atbash cipher. The string can contain any printable ASCII characters including letters, digits, punctuation, and whitespace. Output: * (str): The obfuscated string produced by applying the Atbash cipher to the input string. Constraints: * The input string length will not exceed 10^3 characters. Performance Requirements: * The solution should run in linear time relative to the size of the input string, i.e., O(n) where n is the length of the string. # Examples: 1. Input: `Attack at dawn` Output: `Zggzxp zg wzdm` 2. Input: `Hello, World!` Output: `Svool, Dliow!` 3. Input: `` Output: `` Scenario: This simple cipher transformation, while easy to break today, introduces learners to basic principles of text manipulation and forms the basis for understanding more complex cryptographic techniques. # Additional Notes: 1. Preserve the case of the letters. 2. Non-alphabet characters should remain unchanged. # Guidelines: 1. Consider a helper function to map a single character to its Atbash cipher equivalent. 2. Pay attention to edge cases such as empty strings and strings with non-alphabetic characters. Implement the function `atbash` to accomplish this task.","solution":"def atbash(s: str) -> str: def atbash_char(c): if \'A\' <= c <= \'Z\': return chr(ord(\'Z\') - ord(c) + ord(\'A\')) elif \'a\' <= c <= \'z\': return chr(ord(\'z\') - ord(c) + ord(\'a\')) else: return c return \'\'.join(atbash_char(c) for c in s)"},{"question":"# Question You are tasked with writing a function that simplifies an absolute Unix-style file path. The function signature is as follows: ```python def simplify_path(path: str) -> str: Simplifies the given Unix-style path. :param path: A string representing the absolute path. :return: A simplified absolute path as a string. ``` Input and Output Format: - **Input**: A single string `path` representing the absolute Unix-style path. - **Output**: A single string representing the simplified absolute path. Constraints: - The input `path` always starts with a single forward slash (\'/\'). - Redundant slashes (\'//\') in the path should be ignored. - A dot (\'.\') represents the current directory, which should be ignored. - Two dots (\'..\') represent moving up to the parent directory, where possible. - The result should begin with a forward slash (\'/\') and should not end with a slash unless it is the root directory. Examples: 1. `simplify_path(\\"/home/\\")` should return `\\"/home\\"`. 2. `simplify_path(\\"/a/./b/../../c/\\")` should return `\\"/c\\"`. 3. `simplify_path(\\"/../\\")` should return `\\"/\\"`. 4. `simplify_path(\\"/home//foo/\\")` should return `\\"/home/foo\\"`. Scenario: Imagine you are developing a file explorer application that needs to simplify paths entered by users before performing any file operations. This ensures that the paths are in a canonical form which facilitates easier path matching and file systems calls. # Hints: 1. Use a stack to keep track of valid directory names. 2. Split the path by \'/\' and process each part sequentially. 3. Handle special components (`\'.\'` and `\'..\'`) appropriately.","solution":"def simplify_path(path: str) -> str: Simplifies the given Unix-style path. :param path: A string representing the absolute path. :return: A simplified absolute path as a string. stack = [] components = path.split(\'/\') for component in components: if component == \'\' or component == \'.\': continue elif component == \'..\': if stack: stack.pop() else: stack.append(component) return \'/\' + \'/\'.join(stack)"},{"question":"# Prime Number Validator with Dynamic Range You are tasked with implementing an efficient prime number validation function as part of a cryptographic program. The program needs to verify the primality of multiple numbers in a dynamic range efficiently. **Function Signature**: ```python def validate_primes(numbers: List[int]) -> List[bool]: Given a list of integers, return a list of boolean values corresponding to the primality of each integer in the input list. :param numbers: List[int] - A list containing multiple integers. :return: List[bool] - A list containing boolean values where True means the number at that position is prime and False otherwise. ``` Input Format - A list of integers `numbers` where ( 2 leq |numbers| leq 10^5 ) and ( 1 leq text{numbers[i]} leq 10^7 ). Output Format - A list of boolean values, each indicating the primality of corresponding integers from the input list. Constraints - Your solution should aim to operate within ( O(n sqrt{m}) ) complexity where ( n ) is the length of the list, and ( m ) is the maximum value in the list. - Use the provided `prime_check` function to verify individual primality to ensure consistency. Example ```python validate_primes([1, 2, 3, 4, 5, 15, 17]) # Should return [False, True, True, False, True, False, True] ``` Notes - Ensure your function handles bulk queries efficiently. - Consider edge cases such as exceptionally large or small integers within the allowed range.","solution":"from typing import List def is_prime(n: int) -> bool: Helper function to determine if a given number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def validate_primes(numbers: List[int]) -> List[bool]: Given a list of integers, return a list of boolean values corresponding to the primality of each integer in the input list. :param numbers: List[int] - A list containing multiple integers. :return: List[bool] - A list containing boolean values where True means the number at that position is prime and False otherwise. return [is_prime(num) for num in numbers]"},{"question":"# Bit Manipulation Functions **Context**: You are working on a low-level data processing system where the need to efficiently manipulate individual bits in integers frequently arises. Your task is to implement several fundamental bit manipulation functions to support this system. **Requirements**: Implement the following four functions: 1. **get_bit(num, i)**: - **Input**: An integer `num`, an integer index `i`. - **Output**: Boolean indicating whether the bit at index `i` is 1. - **Example**: `get_bit(10, 1)` should return `True` (binary `1010`). 2. **set_bit(num, i)**: - **Input**: An integer `num`, an integer index `i`. - **Output**: Integer representing `num` with the bit at index `i` set to 1. - **Example**: `set_bit(10, 2)` should return `14` (binary `1110`). 3. **clear_bit(num, i)**: - **Input**: An integer `num`, an integer index `i`). - **Output**: Integer representing `num` with the bit at index `i` cleared to 0. - **Example**: `clear_bit(10, 3)` should return `2` (binary `0010`). 4. **update_bit(num, i, bit)**: - **Input**: An integer `num`, an integer index `i`, and a boolean value `bit` (only `0` or `1`). - **Output**: Integer representing `num` with the bit at index `i` updated to the given `bit`. - **Example**: `update_bit(10, 1, 0)` should return `8` (binary `1000`). **Constraints**: - Indices `i` will be within the 0 to 31 range for 32-bit integers. - Input `num` can be any valid integer within the 32-bit signed integer range. - The provided bit value for `update_bit` will always be either `0` or `1`. ```python def get_bit(num, i): # Your code here pass def set_bit(num, i): # Your code here pass def clear_bit(num, i): # Your code here pass def update_bit(num, i, bit): # Your code here pass ``` **Objective**: Ensure that your implementations are clean, efficient, and handle the given constraints effectively. Test your functions with different edge cases and typical values to verify correctness.","solution":"def get_bit(num, i): Returns whether the bit at index i is 1 in the integer num. return (num & (1 << i)) != 0 def set_bit(num, i): Sets the bit at index i to 1 in the integer num and returns the new integer. return num | (1 << i) def clear_bit(num, i): Clears the bit at index i to 0 in the integer num and returns the new integer. return num & ~(1 << i) def update_bit(num, i, bit): Updates the bit at index i to the given bit (0 or 1) in the integer num and returns the new integer. mask = ~(1 << i) return (num & mask) | (bit << i)"},{"question":"You are given two strings `word1` and `word2`. The task is to find the minimum number of operations required to make `word1` and `word2` the same where an allowed operation is deletion of any character in either string. Write a function `min_deletions_to_match(word1, word2)` that takes in the two strings and returns an integer which is the minimum number of deletions required. Input: * `word1` (1 <= len(word1) <= 1000): a string consisting of lowercase English letters. * `word2` (1 <= len(word2) <= 1000): a string consisting of lowercase English letters. Output: * The function should return an integer representing the minimum number of deletions needed. # Example: ```python assert min_deletions_to_match(\\"sea\\", \\"eat\\") == 2 assert min_deletions_to_match(\\"abc\\", \\"def\\") == 6 assert min_deletions_to_match(\\"\\", \\"abc\\") == 3 assert min_deletions_to_match(\\"abcdef\\", \\"\\") == 6 ``` # Constraints: * The input strings contain only lowercase English letters. * Ensure your solution handles large inputs efficiently and runs in (O(m times n)) time complexity, where `m` and `n` are the lengths of `word1` and `word2` respectively. # Notes: 1. Use the dynamic programming approach to tackle this problem. 2. You may use auxiliary functions if necessary for clarity and breakdown of the process.","solution":"def min_deletions_to_match(word1, word2): Find the minimum number of deletions required to make word1 and word2 the same. m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs_length = dp[m][n] return m + n - 2 * lcs_length"},{"question":"Bipartite Graph Verification **Scenario**: You are working on a project that involves verifying whether certain graphs are bipartite. A bipartite graph is one where you can split the set of vertices into two disjoint sets such that no two vertices within the same set are adjacent. You must implement a function that checks whether a given graph is bipartite. **Function Specification**: ```python def is_bipartite_graph(adj_matrix: List[List[int]]) -> bool: Determine if the given graph is bipartite. Args: adj_matrix : List[List[int]] : The adjacency matrix representing the graph, where adj_matrix[i][j] is 1 if there is an edge between vertex i and vertex j, and 0 otherwise. Returns: bool : True if the graph is bipartite, False otherwise. pass ``` **Input**: - `adj_matrix`: A 2D list representing the adjacency matrix of the graph. `adj_matrix[i][j]` is 1 if there is an edge between vertex `i` and `j`; otherwise, it is 0. **Output**: - A boolean value: `True` if the graph is bipartite, `False` otherwise. **Constraints**: - All vertices are numbered from 0 to n-1. - The graph does not contain parallel edges and is undirected (`adj_matrix[i][j]` is equal to `adj_matrix[j][i]`). **Examples**: ```python assert is_bipartite_graph([ [0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 0], [0, 1, 0, 0] ]) == True assert is_bipartite_graph([ [0, 1, 0], [1, 0, 1], [0, 1, 0] ]) == True assert is_bipartite_graph([ [0, 1, 1], [1, 0, 1], [1, 1, 0] ]) == False ``` **Note**: In the adjacency matrix, `0` indicates no edge, and `1` indicates the presence of an edge. Self-loops (`adj_matrix[i][i]` being `1`) should result in `False`. **Performance Requirements**: Ensure that the function performs efficiently and handles up to 1000 vertices and edges.","solution":"from typing import List from collections import deque def is_bipartite_graph(adj_matrix: List[List[int]]) -> bool: Determine if the given graph is bipartite. Args: adj_matrix : List[List[int]] : The adjacency matrix representing the graph, where adj_matrix[i][j] is 1 if there is an edge between vertex i and vertex j, and 0 otherwise. Returns: bool : True if the graph is bipartite, False otherwise. n = len(adj_matrix) colors = [-1] * n # -1 means uncolored, 0 and 1 will be the two colors for start in range(n): if colors[start] == -1: # Not colored yet queue = deque([start]) colors[start] = 0 # Start coloring the start vertex with color 0 while queue: node = queue.popleft() current_color = colors[node] for neighbor in range(n): if adj_matrix[node][neighbor] == 1: # There is an edge if colors[neighbor] == -1: # If not colored, color with alternate color colors[neighbor] = 1 - current_color queue.append(neighbor) elif colors[neighbor] == current_color: # If the neighbor has the same color, not bipartite return False return True"},{"question":"# Question: You are tasked to implement the `cocktail_shaker_sort` function that sorts an array of integers in ascending order using the principles of Cocktail Shaker Sort. Understanding its bi-directional approach, ensure that you maintain the integrity of the algorithm while attempting to handle potential edge cases effectively. Function Signature: ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` Input Format: - A list `arr` of integers where (1 leq len(arr) leq 10^4). Output Format: - Returns a new list of integers sorted in ascending order. # Constraints: - The elements of `arr` are in the range (-10^6 leq arr[i] leq 10^6). # Performance Requirements: - Ensure the function runs efficiently within the constraints provided. - Avoid unnecessary passes through the array if it becomes sorted prematurely. # Example: ```python assert cocktail_shaker_sort([3, 2, 1, 5, 4]) == [1, 2, 3, 4, 5] assert cocktail_shaker_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert cocktail_shaker_sort([5, 3, 1, 4, 2]) == [1, 2, 3, 4, 5] assert cocktail_shaker_sort([1]) == [1] assert cocktail_shaker_sort([]) == [] ``` # Scenario/Context: Imagine you are developing a feature for a small application that deals with user-provided datasets. The user might input lists that are usually small and nearly sorted due to the nature of how they were generated. Your algorithm should efficiently sort these lists while handling edge cases seamlessly.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Sort the input list using the Cocktail Shaker Sort algorithm. if not arr: return arr n = len(arr) swapped = True start = 0 end = n - 1 while swapped: swapped = False # Traverse the array from left to right like a bubble sort for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If no elements were swapped, then the array is sorted if not swapped: break # Reset the swapped flag so we can check if any element was swapped in this inner loop swapped = False # Move the end point back by one, because the last element is now sorted end -= 1 # Traverse the array from right to left, doing the same comparison as above for i in range(end - 1, start - 1, -1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # Move the start point forward by one, because the first element is now sorted start += 1 return arr"},{"question":"Regular Expression Matching You are required to implement a function that determines if a given text string matches a given pattern string using the regular expression matching rules provided below. Problem Statement The matching rules are defined as follows: * `.` matches any single character. * `*` matches zero or more of the preceding element. * The matching should cover the entire input string (not partial). Function Signature ```python def is_match(s: str, p: str) -> bool: pass ``` Input and Output * **Input**: * `s`: A string representing the text. * `p`: A string representing the pattern. * **Output**: * Returns a boolean which is `True` if `s` matches the pattern `p`, and `False` otherwise. Constraints * `0 <= len(s), len(p) <= 1000` * `s` and `p` consist of only lowercase English letters, \'.\', and \'*\'. Requirements * Implement the `is_match` function. Your solution should handle complex patterns efficiently while ensuring correctness for edge cases. * Consider edge cases such as empty strings, patterns with multiple `*` characters, and patterns that can match any string or no string at all. Examples Your implementation should pass the following test cases: ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` Use dynamic programming principles to store intermediate results, ensuring that your function runs efficiently even for larger input sizes.","solution":"def is_match(s: str, p: str) -> bool: # dp[i][j] will be True if s[:i] matches p[:j] else False dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # Empty pattern can only match empty string dp[0][0] = True # Handle patterns like a*, a*b*, a*b*c* etc. for j in range(2, len(p) + 1): if p[j-1] == \'*\': dp[0][j] = dp[0][j-2] for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j-1] == s[i-1] or p[j-1] == \'.\': dp[i][j] = dp[i-1][j-1] elif p[j-1] == \'*\': dp[i][j] = dp[i][j-2] # Ignore the \'*\' and the preceding element if p[j-2] == s[i-1] or p[j-2] == \'.\': dp[i][j] = dp[i][j] or dp[i-1][j] return dp[len(s)][len(p)]"},{"question":"You are tasked to create a robust function `full_path` which computes the absolute path for a given file. The input to the function is a string representing a file path which may contain references to the user\'s home directory (`~`). The function should return the absolute path of this file while gracefully handling invalid inputs. **Function Signature** ```python def full_path(file: str) -> str: pass ``` # Input and Output - **Input**: A single string `file`, representing a file path. The path can be relative, absolute, or contain references to the user\'s home directory using `~`. - **Output**: A single string representing the full absolute path of the input file. # Constraints - The input string will be non-null and can be empty. - The function should handle invalid paths gracefully by returning a predefined error message `\\"Invalid file path\\"` for paths that fail conversion. # Performance Requirements - The solution should perform efficiently with time complexity O(n), where `n` is the length of the input path. # Example ```python print(full_path(\\"~/.local/bin\\")) # Possible Output: \\"/home/username/.local/bin\\" or C:Users<username>.localbin depending on the operating system. print(full_path(\\"../../Documents\\")) # Output: Absolute path from the current working directory. print(full_path(\\"\\")) # Output: \\"Invalid file path\\" ``` # Task Implement the `full_path` function using your understanding of path manipulations and error handling.","solution":"import os def full_path(file: str) -> str: Returns the absolute path for a given file. Handles paths with \'~\' and provides an error message for invalid paths. if not file: return \\"Invalid file path\\" try: absolute_path = os.path.abspath(os.path.expanduser(file)) return absolute_path except Exception as e: return \\"Invalid file path\\""},{"question":"# Cycle Detection in Dependency Graphs Context You are a software engineer working on a build system that needs to manage dependencies between various software packages. Each package can depend on one or more packages, forming a directed graph. Your task is to write a function that determines whether the dependency graph contains any cycles. A cycle in the dependency graph indicates circular dependencies, which would lead to build failures. Task Write a function to detect cycles in a directed graph using Depth-First Search with state tracking. The graph is represented as an adjacency list. Function Signature ```python def has_cycle(graph: dict) -> bool: pass ``` Input * `graph`: A dictionary where keys are package names (strings), and values are lists of package names that the key depends on. For example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } ``` Output * Returns `True` if there is a cycle in the graph, otherwise returns `False`. Constraints * The graph will contain at least one vertex. * Package names are unique. * Properly handle a single vertex graph scenario. * Graph can be disconnected. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(has_cycle(graph)) # Output: True graph = { \'X\': [\'Y\'], \'Y\': [\'Z\'], \'Z\': [] } print(has_cycle(graph)) # Output: False graph = {\'A\': []} print(has_cycle(graph)) # Output: False graph = {\'A\': [\'A\']} print(has_cycle(graph)) # Output: True ``` Tips * Implement the function using an auxiliary state array/dictionary to keep track of the states (WHITE, GRAY, BLACK) of each vertex. * Consider early termination if a cycle is detected during DFS traversal.","solution":"def has_cycle(graph: dict) -> bool: Determine if the graph has a cycle. :param graph: dictionary representing the adjacency list of the graph :return: True if there\'s a cycle, False otherwise WHITE, GRAY, BLACK = 0, 1, 2 color = {node: WHITE for node in graph} def dfs(node): if color[node] == GRAY: return True if color[node] == BLACK: return False color[node] = GRAY for neighbor in graph[node]: if dfs(neighbor): return True color[node] = BLACK return False for node in graph: if color[node] == WHITE: if dfs(node): return True return False"},{"question":"You need to implement two functions: `encode` and `decode` for encoding a list of strings into a single string and then decoding that string back into the original list. These methods will help in efficiently transmitting a list of strings over a network. Function Definitions ```python def encode(strs): Encodes a list of strings to a single string. :param strs: List[str] - The input list of strings to encode. :return: str - The encoded string which represents the list of strings. pass def decode(s): Decodes a single string into a list of strings. :param s: str - The encoded string. :return: List[str] - The original list of strings. pass ``` # Example ```python # Example usage: original_list = [\\"we\\", \\"say\\", \\":\\", \\"yes\\"] encoded_string = encode(original_list) print(encoded_string) # Output might be \\"2:we3:say1::3:yes\\" decoded_list = decode(encoded_string) print(decoded_list) # Output: [\\"we\\", \\"say\\", \\":\\", \\"yes\\"] ``` # Constraints 1. The input list `strs` can contain up to 10^4 strings, and each string has a length between 0 and 1000. 2. Strings can contain any printable ASCII characters, including spaces and special characters. Requirements * **Efficiency**: Both encoding and decoding should operate in linear time relative to the total number of characters. * **Correctness**: Handle edge cases such as empty strings, empty lists, and strings with colons or the length prefix format within them.","solution":"def encode(strs): Encodes a list of strings to a single string. :param strs: List[str] - The input list of strings to encode. :return: str - The encoded string which represents the list of strings. return \'\'.join(\'{}:{}\'.format(len(s), s) for s in strs) def decode(s): Decodes a single string into a list of strings. :param s: str - The encoded string. :return: List[str] - The original list of strings. i, n = 0, len(s) result = [] while i < n: j = s.find(\':\', i) length = int(s[i:j]) i = j + 1 + length result.append(s[j + 1:i]) return result"},{"question":"# Segment Tree Implementation for Range Sum Queries Context: You are required to implement a segment tree to handle range sum queries on a given array of integers. Each node in the segment tree will store the sum of its children. Task: Write a class `RangeSumSegmentTree` which supports the following operations: 1. **Building the Tree**: Create the segment tree from a given array of integers. 2. **Range Query**: Return the sum of elements between two given indices (inclusive). 3. **Update**: Update the value of an element in the array and propagate the changes up the tree. Specifications: - Initialize the tree with an array of integers. - Implement a method to build the segment tree. - Implement a method `query(L, R)` to return the sum between indices `L` and `R`. - Implement a method `update(pos, value)` to update the element at index `pos` to `value` and update the tree correspondingly. Function Signatures: ```python class RangeSumSegmentTree: def __init__(self, arr: List[int]): pass def build_tree(self, i: int, l: int, r: int): pass def query(self, L: int, R: int) -> int: pass def update(self, pos: int, value: int): pass ``` Input Format: - The constructor `RangeSumSegmentTree(List[int] arr)` initializes the tree with the array `arr`. - The `query(int L, int R)` method takes two integers `L` and `R` and returns the sum of the elements between indices L and R. - The `update(int pos, int value)` method takes an index `pos` and a new `value`, updates the element, and adjusts the segment tree. Constraints: - The input array will have at most `10^5` elements. - The values in the array and the values to update will be in the range `[-10^6, 10^6]`. - Queries and updates will be called multiple times and should be optimized for performance. Example: ```python # Initialize the segment tree with an array tree = RangeSumSegmentTree([1, 2, 3, 4, 5]) # Perform queries assert tree.query(1, 3) == 9 # 2 + 3 + 4 assert tree.query(0, 4) == 15 # 1 + 2 + 3 + 4 + 5 # Perform updates tree.update(2, 10) # Update position 2 to value 10 # Perform queries after update assert tree.query(1, 3) == 16 # 2 + 10 + 4 assert tree.query(0, 4) == 22 # 1 + 2 + 10 + 4 + 5 ``` Implement the segment tree to handle efficient range queries and updates, ensuring optimal performance.","solution":"class RangeSumSegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (2 * self.n) # segment tree self.build_tree(arr) def build_tree(self, arr): # Place original array elements in the second half of the tree array for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the segment tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, pos, value): # Update the value at the leaf node pos += self.n self.tree[pos] = value # Propagate the changes up while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def query(self, L, R): # Query in the range [L, R] L += self.n R += self.n summation = 0 while L <= R: if L % 2 == 1: summation += self.tree[L] L += 1 if R % 2 == 0: summation += self.tree[R] R -= 1 L //= 2 R //= 2 return summation"},{"question":"# Question You are provided with a grid representing a map of open areas (0) and buildings (1). Your task is to implement a function to determine the minimum distance from each open area to the nearest building. The function should use either the Breadth-First Search (BFS) or Depth-First Search (DFS) traversal algorithm effectively. Function Signature ```python def min_distance_to_building(grid: List[List[int]]) -> List[List[int]]: pass ``` # Input - `grid`: A 2D list of integers representing the grid, where `grid[i][j]` can be: - `0`: an open area - `1`: a building - The dimensions of the grid are m x n, where 1 ≤ m, n ≤ 300. # Output - Returns a 2D list of the same dimensions, where each element represents the minimum distance from that open area to the nearest building. If it is a building (1), the value remains 0. # Constraints - The grid will have at least one building. # Example ```python grid = [ [0, 1, 0], [1, 0, 1], [0, 0, 0] ] Output: [ [1, 0, 1], [0, 1, 0], [1, 2, 1] ] Explanation: - For the open area at position (0, 0), the nearest building is at (0, 1). - For the open area at position (0, 2), the nearest building is at (0, 1). - For the open area at position (2, 1), the nearest building is at (1, 1). ``` Guidelines 1. Clearly mention the algorithm (BFS or DFS) you are using and why. 2. Ensure to handle edge cases such as cells with no path to a building. 3. Optimize for both time and space complexity.","solution":"from collections import deque from typing import List def min_distance_to_building(grid: List[List[int]]) -> List[List[int]]: Function to determine the minimum distance from each open area to the nearest building. Uses BFS to calculate the distance. # Dimensions of the grid m, n = len(grid), len(grid[0]) # Initialize the result grid with large values (representing infinity) dist = [[float(\'inf\')] * n for _ in range(m)] # Queue for BFS queue = deque() # Collecting all building locations for row in range(m): for col in range(n): if grid[row][col] == 1: dist[row][col] = 0 queue.append((row, col, 0)) # Append the building locations with distance 0 # Possible directions for moving in the grid directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Process queue while queue: x, y, d = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and dist[nx][ny] == float(\'inf\'): dist[nx][ny] = d + 1 # Update distance queue.append((nx, ny, d + 1)) return dist"},{"question":"**Binary Search Enhanced** Binary search is a powerful search algorithm that efficiently finds the position of a target value in a sorted array. Given an array of integers that are sorted in ascending order and a target value, your task is to implement a binary search function and handle specific conditions beyond the typical use case. # Problem Statement Implement an enhanced binary search function that: 1. **Finds the position** of the target value if it exists in the array. 2. **Returns -1** if the target value is not in the array. 3. Handles cases where the array might be empty. 4. Handles multiple occurrences of the target by returning the index of the **first occurrence**. # Function Signature ```python def binary_search_enhanced(array: list, query: int) -> int: pass ``` # Input - `array` (list): A list of integers sorted in ascending order. The array can be empty. - `query` (int): The target value that you need to find in the array. # Output - (int): The index of the first occurrence of the target value if found in the array; otherwise, -1. # Constraints - The function should aim to have a time complexity of O(log n). - The function should employ an iterative approach. # Example ```python assert binary_search_enhanced([1, 2, 3, 4, 4, 4, 5, 6], 4) == 3 assert binary_search_enhanced([1, 2, 3, 4, 5, 6, 7], 8) == -1 assert binary_search_enhanced([], 1) == -1 assert binary_search_enhanced([5], 5) == 0 ``` # Guidance 1. Consider all edge cases, such as empty arrays, arrays with one element, and arrays where the target value is not present. 2. Ensure your mid calculation avoids overflow. 3. Test your implementation thoroughly to verify correctness and efficiency.","solution":"def binary_search_enhanced(array: list, query: int) -> int: left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: result = mid # found the target, save the index right = mid - 1 # continue to search in the left half to find the first occurrence elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"Inorder Traversal of Binary Trees # Context Binary Trees are fundamental in computer science, and inorder traversal is a common way to visit all the nodes of such a tree. Given the standard definition of a binary tree where each node has at most two children (a left and a right child), we often need to visit all nodes to perform operations such as sorting or expression evaluation. # Problem You are required to implement two versions of the inorder traversal: 1. **Iterative Approach** using a stack. 2. **Recursive Approach** using function calls. # Input * A binary tree represented by the root node of type `Node`. # Output * A list of integers representing the values of nodes in inorder sequence. # Function Signatures ```python def inorder(root: Node) -> List[int]: pass def inorder_rec(root: Node) -> List[int]: pass ``` # Constraints * Node values are unique integers. * The number of nodes in the tree is between 0 and 1000. * You must not modify the tree during traversal. # Example For the tree shown below: ``` 100 / 50 150 / / 25 75 125 175 ``` * The iterative or recursive traversal should output: `[25, 50, 75, 100, 125, 150, 175]`. # Notes * Ensure you handle edge cases like empty trees (where root is `None`). * Be mindful of the space complexity for large trees and the limitations of recursion depth.","solution":"from typing import Optional, List class Node: def __init__(self, data: int, left: \'Node\' = None, right: \'Node\' = None): self.data = data self.left = left self.right = right def inorder(root: Optional[Node]) -> List[int]: Iterative inorder traversal using a stack. stack = [] current = root result = [] while current is not None or stack: while current is not None: stack.append(current) current = current.left current = stack.pop() result.append(current.data) current = current.right return result def inorder_rec(root: Optional[Node]) -> List[int]: Recursive inorder traversal. result = [] def helper(node: Optional[Node]): if node is None: return helper(node.left) result.append(node.data) helper(node.right) helper(root) return result"},{"question":"# Task Create a function to generate all possible abbreviations for a given word using the provided backtracking technique, and verify its correctness through rigorous testing. # Function Signature ```python def generate_abbreviations(word: str) -> List[str]: ``` # Input * **word**: A string of length ( n ) (1 <= ( n ) <= 30), consisting of lowercase English letters. # Output * A list of strings, each representing a valid abbreviation of the input word. # Constraints * Ensure the function avoids duplicate abbreviations. * Handle edge cases efficiently, such as empty strings and single characters. * Minimize unnecessary computations to improve performance. # Context The function `generate_abbreviations` is helpful in scenarios where words need to be comprehensively abbreviated to create unique identifiers, like QR code generation or auto-suggestion systems. # Example ```python assert generate_abbreviations(\\"word\\") == [ \\"word\\", \\"wor1\\", \\"wo1d\\", \\"wo2\\", \\"w1rd\\", \\"w1r1\\", \\"w2d\\", \\"w3\\", \\"1ord\\", \\"1or1\\", \\"1o1d\\", \\"1o2\\", \\"2rd\\", \\"2r1\\", \\"3d\\", \\"4\\" ] ``` # Explanation The function generates all abbreviations by recursively including/excluding characters and counting omitted sequences, ensuring no duplicates and considering all combinations.","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: def backtrack(pos, cur, count): if pos == len(word): result.append(cur + (str(count) if count > 0 else \'\')) else: # Abbreviate this position backtrack(pos + 1, cur, count + 1) # Keep this position backtrack(pos + 1, cur + (str(count) if count > 0 else \'\') + word[pos], 0) result = [] backtrack(0, \'\', 0) return result"},{"question":"**Scenario**: You have been hired by a software company which maintains large datasets of hierarchical information. Recently, the company encountered issues with tree height calculation algorithms being inefficient due to badly implemented BST manipulations. To address this, you are tasked with implementing a function that calculates the height of any given binary search tree. **Task**: Write a function `height` that calculates and returns the height of a binary search tree. The height of the tree is the number of levels, with: - An empty tree having height 0. - A tree with one node having height 1. - A root node with one or two leaves as children having height 2, and so on. Use the following definitions: - A class `Node` representing each node in the BST. - The BST operations already provided (insert). **Input Format**: The `height` function accepts a parameter: - `root`: The root node of the binary search tree. **Output Format**: The function should return an integer representing the height of the tree. **Constraints**: - The tree can contain between 0 and 10,000 nodes. - Node values are unique integers. **Example**: Consider the following tree: ```plaintext 9 / 6 12 / / 3 8 10 15 / 7 18 ``` Calling `height` on the root of this tree should return `4`. # Function Signature ```python def height(root): if root is None: return 0 else: return 1 + max(height(root.left), height(root.right)) ``` **Unit Testing**: A `unittest` class `TestSuite` is provided to ensure the correctness of your implementation. ```python import unittest from bst import Node, bst class TestSuite(unittest.TestCase): def setUp(self): self.tree = bst() self.tree.insert(9) self.tree.insert(6) self.tree.insert(12) self.tree.insert(3) self.tree.insert(8) self.tree.insert(10) self.tree.insert(15) self.tree.insert(7) self.tree.insert(18) def test_height(self): self.assertEqual(4, height(self.tree.root)) if __name__ == \'__main__\': unittest.main() ``` In this setup, `bst` class and `Node` class should be defined to handle insertion and tree structure appropriately.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def insert(root, key): if root is None: return Node(key) else: if root.val < key: root.right = insert(root.right, key) else: root.left = insert(root.left, key) return root def height(root): if root is None: return 0 else: return 1 + max(height(root.left), height(root.right))"},{"question":"# Question **Problem Statement**: Given a string, write a program to find the length of the longest substring without repeating characters and return both the length and the substring itself. **Function Signature**: ```python def longest_substring_without_repeating_chars(s: str) -> tuple: :param s: str: Input string :return: tuple: A tuple containing the length of the longest substring without repeating characters and the actual substring pass ``` **Input Format**: - A single string `s`. **Output Format**: - A tuple containing two elements: - An integer representing the length of the longest substring without repeating characters. - The actual substring. **Constraints**: - The input string `s` will only contain printable ASCII characters. - `0 <= len(s) <= 10^4`. **Examples**: Example 1: ```plaintext Input: \\"abcabcbb\\" Output: (3, \\"abc\\") ``` Example 2: ```plaintext Input: \\"bbbbb\\" Output: (1, \\"b\\") ``` Example 3: ```plaintext Input: \\"pwwkew\\" Output: (3, \\"wke\\") ``` Example 4: ```plaintext Input: \\"\\" Output: (0, \\"\\") ``` **Notes**: - The answer must be a substring, \\"pwke\\" is a subsequence and not a substring. **Question Context**: Imagine you are working on a text editor. Your task is to implement a function that helps in identifying the longest phrase in the document without repeating characters. This functionality can be particularly useful in various text analysis and processing tools.","solution":"def longest_substring_without_repeating_chars(s: str) -> tuple: Finds the length of the longest substring without repeating characters and returns both the length and the substring. n = len(s) if n == 0: return 0, \\"\\" char_index = {} max_len = 0 start = 0 max_substring = \\"\\" for end in range(n): char = s[end] if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = end current_len = end - start + 1 if current_len > max_len: max_len = current_len max_substring = s[start:end+1] return max_len, max_substring"},{"question":"# Scenario As a software engineer at a company that specializes in creating high-performance in-memory databases, you are tasked with implementing a hash table that handles frequent and massive insert operations efficiently. The current implementation uses a simple hash table with linear probing. However, the load on the hash table is expected to increase over time, so a dynamic resizing mechanism is required to ensure consistent performance. # Task Implement a hash table with dynamic resizing. Ensure the table resizes correctly when the load factor exceeds 2/3 to maintain O(1) average case complexity for insertion, deletion, and search. The table should adjust its size appropriately to handle up to 1,000,000 key-value pairs efficiently. # Requirements 1. **Input**: - `put(key: int, value: Any)`: Insert a key-value pair. - `get(key: int) -> Any`: Retrieve value by key. Return `None` if key is not present. - `del_(key: int)`: Delete key-value pair by key. - `__len__() -> int`: Return the number of key-value pairs in the hash table. 2. **Output**: - Methods should operate correctly and ensure the hash table resizes as per the load factor threshold. # Constraints - The hash table should start with an initial size of 11. - The load factor threshold is 2/3, beyond which the size should double. - Handle up to 1,000,000 key-value pairs efficiently. # Example ```python ht = ResizableHashTable() ht.put(1, \\"value1\\") ht.put(2, \\"value2\\") print(ht.get(1)) # Output: \\"value1\\" print(len(ht)) # Output: 2 ht.del_(1) print(ht.get(1)) # Output: None print(len(ht)) # Output: 1 ``` Implement the `ResizableHashTable` class to satisfy the requirements.","solution":"class ResizableHashTable: def __init__(self): self.initial_size = 11 self.size = self.initial_size self.count = 0 self.table = [None] * self.size self.load_factor_threshold = 2 / 3 def put(self, key, value): if self.count / self.size > self.load_factor_threshold: self._resize() index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = (key, value) return index = (index + 1) % self.size self.table[index] = (key, value) self.count += 1 def get(self, key): index = self._hash(key) original_index = index while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.size if index == original_index: break return None def del_(self, key): index = self._hash(key) original_index = index while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.count -= 1 self._rehash() return index = (index + 1) % self.size if index == original_index: break def __len__(self): return self.count def _hash(self, key): return key % self.size def _resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for item in old_table: if item is not None: self.put(item[0], item[1]) def _rehash(self): old_table = self.table self.table = [None] * self.size self.count = 0 for item in old_table: if item is not None: self.put(item[0], item[1])"},{"question":"# Coding Task: Implement Bitonic Sort Without Size Limitation Scenario You work for a software company that deals with large amounts of streaming data. You need an efficient sorting algorithm capable of leveraging parallel processing capabilities. As part of this requirement, you are tasked to modify the Bitonic Sort algorithm to handle arrays of arbitrary size (not restricted to power-of-two) and optimize its performance as much as possible. Objective Revamp the implementation of `bitonic_sort` to: 1. Accept arrays of arbitrary size. 2. Leverage parallel processing capabilities wherever possible. 3. Maintain a clear and efficient approach. Requirements 1. **Input**: - An array `arr` of integers (can be of any size). - An optional boolean `reverse` to specify sorting order (default is `False` for ascending). 2. **Output**: - A sorted array of integers in the specified order. 3. **Constraints**: - The input array may not be of size power of two. - Utilize Python\'s `concurrent.futures` for parallel processing. - Implement the comparison and merge steps in separate helper functions. Function Signature ```python def bitonic_sort(arr: list, reverse: bool = False) -> list: pass ``` Performance Requirements - Efficiently handle large datasets. - Ensure the modified algorithm performs parallel sorting. Example: ```python Example Input: arr = [34, 7, 23, 32, 5, 62] print(bitonic_sort(arr, reverse=False)) Example Output: [5, 7, 23, 32, 34, 62] ```","solution":"from concurrent.futures import ThreadPoolExecutor def merge_bitonic(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): if (direction == (arr[i] > arr[i + k])): arr[i], arr[i + k] = arr[i + k], arr[i] merge_bitonic(arr, low, k, direction) merge_bitonic(arr, low + k, k, direction) def bitonic_sort_recursive(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort_recursive(arr, low, k, True) bitonic_sort_recursive(arr, low + k, k, False) merge_bitonic(arr, low, cnt, direction) def bitonic_sort(arr, reverse=False): n = len(arr) # Extend the array to the next power of 2 # to use bitonic sorting m = 1 while m < n: m <<= 1 extended_arr = arr + [float(\'inf\')] * (m - n) bitonic_sort_recursive(extended_arr, 0, m, not reverse) sorted_arr = [x for x in extended_arr if x != float(\'inf\')] return sorted_arr"},{"question":"**Problem Description**: You are working on a text editing application. One of the features you need to implement is the ability to undo and redo text operations. To assist with this functionality, you have decided to use a doubly linked list to store the history of text changes. Each node in this doubly linked list will represent a state of the text at a particular time. **Task**: Implement a `TextHistory` class with the following methods: 1. `append_state(text: str)`: Adds a new state to the history. 2. `undo() -> str`: Moves one step back in history and returns the previous state. 3. `redo() -> str`: Moves one step forward in history and returns the next state. **Constraints**: - Initially, there is no history (i.e., both undo and redo operations should handle empty states appropriately). - The `undo` operation cannot move beyond the first state. - The `redo` operation cannot move beyond the latest appended state. **Input and Output**: - `append_state(text: str)`: where `text` is a string representing the new state of the text. - `undo() -> str`: returns a string representing the current state after undoing one operation. - `redo() -> str`: returns a string representing the current state after redoing one operation. **Performance Requirements**: - All operations should be implemented to run in O(1) time. **Implementation Skeleton**: ```python class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class TextHistory: def __init__(self): self.head = None self.tail = None self.current = None def append_state(self, text: str): # Implement the append_state method def undo(self) -> str: # Implement the undo method def redo(self) -> str: # Implement the redo method ```","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class TextHistory: def __init__(self): self.head = None self.tail = None self.current = None def append_state(self, text: str): new_node = DoublyLinkedListNode(text) if not self.head: self.head = self.tail = self.current = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node self.current = new_node def undo(self) -> str: if self.current and self.current.prev: self.current = self.current.prev return self.current.value if self.current else \\"\\" def redo(self) -> str: if self.current and self.current.next: self.current = self.current.next return self.current.value if self.current else \\"\\""},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification * **Algorithm/Data Structure**: This algorithm constructs a full binary tree from given preorder and postorder traversal arrays. It then prints the inorder traversal of the constructed tree. * **Complexity**: * **Time Complexity**: O(n^2) in the worst case, where n is the number of nodes. This comes from the nested loop used to find elements in the postorder array. * **Space Complexity**: O(n) due to the recursive stack and the storage for the tree nodes. * **Principles**: The algorithm works by: 1. Using the first element of the preorder array as the current root. 2. Finding this element in the postorder array to determine the boundary of the left and right subtrees. 3. Recursively applying this process to construct the left and right subtrees. 4. Finally, printing the inorder traversal of the constructed tree. Characteristics & Applications * **Properties**: Ensures the tree constructed is full (either 0 or 2 children for each node). Uses preorder traversal to determine the structure of the tree and postorder traversal to constrain the search space for left and right subtrees. * **Common Use Cases**: Reconstructing trees from traversal data, useful in recovering tree structures in computer algorithms, compilers, and data storage mechanisms. * **Strengths/Limitations**: * **Strengths**: Efficiently reconstructs the tree from two traversals. * **Limitations**: High time complexity due to repeated searches in the postorder array. Implementation Challenges * **Edge Cases**: * When preorder or postorder arrays are empty or of different lengths. * When the arrays contain repeating elements. * **Performance Bottlenecks**: * The while loop to find the root in the postorder array is a bottleneck especially for larger trees (O(n)). * **Error Scenarios**: * Incorrect handling of array indices leading to wrong tree construction. * Recursion depth can hit limits for very large trees. * **Optimization Points**: * Use a hashmap to store elements of the postorder array to achieve O(1) search time, reducing overall time complexity. <|Analysis End|> <|Question Begin|> # Question: Construct Binary Tree from Preorder and Postorder Traversals Problem Statement Given two arrays `preorder` and `postorder`, representing the preorder and postorder traversals of a full binary tree, write a function to reconstruct the tree and return the inorder traversal of the tree. Function Signature ```python def construct_inorder(preorder: List[int], postorder: List[int]) -> List[int]: pass ``` Input * `preorder` (List[int]): A list of integers representing the preorder traversal of the tree. * `postorder` (List[int]): A list of integers representing the postorder traversal of the tree. Output * List[int]: A list of integers representing the inorder traversal of the reconstructed tree. Constraints * The lengths of `preorder` and `postorder` will be equal. * The values in the tree are unique positive integers. * The tree represented by the traversals is a full binary tree. Example **Input:** ```python preorder = [1, 2, 4, 8, 9, 5, 3, 6, 7] postorder = [8, 9, 4, 5, 2, 6, 7, 3, 1] ``` **Output:** ```python [8, 4, 9, 2, 5, 1, 6, 3, 7] ``` Explanation: The constructed tree is: ``` 1 / 2 3 / / 4 5 6 7 / 8 9 ``` The inorder traversal of the tree is `[8, 4, 9, 2, 5, 1, 6, 3, 7]`. Requirements: - Implement function `construct_inorder` that satisfies the requirements. - Ensure the solution is efficient in terms of time and space complexity.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int): self.val = val self.left: Optional[TreeNode] = None self.right: Optional[TreeNode] = None def construct_inorder(preorder: List[int], postorder: List[int]) -> List[int]: if not preorder or not postorder: return [] postorder_index_map = {value: idx for idx, value in enumerate(postorder)} def build(preorder_start: int, preorder_end: int, postorder_start: int, postorder_end: int) -> Optional[TreeNode]: if preorder_start > preorder_end or postorder_start > postorder_end: return None root_value = preorder[preorder_start] root = TreeNode(root_value) if preorder_start == preorder_end: return root left_root_value = preorder[preorder_start + 1] left_root_idx = postorder_index_map[left_root_value] left_size = left_root_idx - postorder_start + 1 root.left = build(preorder_start + 1, preorder_start + left_size, postorder_start, left_root_idx) root.right = build(preorder_start + left_size + 1, preorder_end, left_root_idx + 1, postorder_end - 1) return root def inorder_traversal(root: Optional[TreeNode], result: List[int]): if root: inorder_traversal(root.left, result) result.append(root.val) inorder_traversal(root.right, result) n = len(preorder) tree_root = build(0, n - 1, 0, n - 1) result = [] inorder_traversal(tree_root, result) return result"},{"question":"Scenario/Context: You are tasked with implementing a function to detect the starting node of a cycle in a singly linked list. A singly linked list is a data structure where each node points to the next node via a `next` pointer. Your goal is to identify the first node that starts the cycle if a cycle exists within the linked list. Problem Statement: Implement the function `find_cycle_start_node(head)` that detects the first node where a cycle begins in a given singly linked list. Return the node if a cycle exists; otherwise, return `None`. Function Signature: ```python class Node: def __init__(self, x): self.val = x self.next = None def find_cycle_start_node(head: Node) -> Node: pass ``` Input: - `head` of the singly linked list, where `head` is an instance of the `Node` class. Output: - The first node where the cycle begins if a cycle exists. - `None` if there is no cycle in the linked list. Constraints: - Answer the question within O(n) time complexity and O(1) space complexity. Example: ```python # Create a linked list => A -> B -> C -> D -> E -> C head = Node(\'A\') head.next = Node(\'B\') curr = head.next cyclic_node = Node(\'C\') curr.next = cyclic_node curr = curr.next curr.next = Node(\'D\') curr = curr.next curr.next = Node(\'E\') curr = curr.next curr.next = cyclic_node # Function call result = find_cycle_start_node(head) # Output value of result.val should be \'C\' ``` Additional Information: Perform thorough testing, considering edge cases such as: - An empty linked list. - A linked list with no cycle. - A linked list where the cycle starts at the head node.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def find_cycle_start_node(head: Node) -> Node: if not head or not head.next: return None slow = head fast = head # Detect cycle using Floyd\'s Tortoise and Hare algorithm while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If there is no cycle if not fast or not fast.next: return None # Find the entry point of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Task Write a function `text_justify(words, max_width)` that takes an array of words and an integer `max_width`, and returns the array of strings where each string is a fully justified line with exactly `max_width` characters. # Input - `words`: A list of strings representing the words to be justified. - `max_width`: An integer representing the maximum width of each line. # Output - Return a list of strings, where each string represents a line of text that is fully justified. # Constraints - Each word\'s length is guaranteed to be greater than 0 and not exceed `max_width`. - The input array `words` contains at least one word. - You must not modify the input array. # Example ```python words = [\\"What\\", \\"must\\", \\"be\\", \\"acknowledgment\\", \\"shall\\", \\"be\\"] max_width = 16 output = [ \\"What must be\\", \\"acknowledgment \\", \\"shall be \\" ] ``` # Scenario You are developing a text editor that requires precise formatting of text. You need to justify the text both left and right to make the content look neat and aligned. This function will help you achieve such formatting in the editor. # Guidelines 1. Pack words into each line using the provided `max_width` constraint. 2. Ensure spaces are evenly distributed for full justification. 3. Handle special conditions such as a single word on a line and ensure the last line is left-justified. 4. Thoroughly test your function to handle different types and lengths of inputs. **Tip**: Consider edge cases like minimum and maximum word lengths relative to `max_width`, number of words in a line, and handling of the last line differently than others. ```python def text_justify(words, max_width): \'\'\' :type words: list :type max_width: int :rtype: list \'\'\' ret = [] # return value row_len = 0 # current length of strs in a row row_words = [] # current words in a row index = 0 # the index of current word in words is_first_word = True # is current word the first in a row while index < len(words): while row_len <= max_width and index < len(words): if len(words[index]) > max_width: raise ValueError(\\"There exists word whose length is larger than max_width\\") tmp = row_len row_words.append(words[index]) tmp += len(words[index]) if not is_first_word: tmp += 1 # except for the first word, each word should have at least a \' \' before it. if tmp > max_width: row_words.pop() break row_len = tmp index += 1 is_first_word = False # here we have already got a row of str , then we should supplement enough \' \' to make sure the length is max_width. row = \\"\\" # if the row is the last if index == len(words): for word in row_words: row += (word + \' \') row = row[:-1] row += \' \' * (max_width - len(row)) # not the last row and more than one word elif len(row_words) != 1: space_num = max_width - row_len space_num_of_each_interval = space_num // (len(row_words) - 1) space_num_rest = space_num - space_num_of_each_interval * (len(row_words) - 1) for j in range(len(row_words)): row += row_words[j] if j != len(row_words) - 1: row += \' \' * (1 + space_num_of_each_interval) if space_num_rest > 0: row += \' \' space_num_rest -= 1 # row with only one word else: row += row_words[0] row += \' \' * (max_width - len(row)) ret.append(row) # after a row , reset those value row_len = 0 row_words = [] is_first_word = True return ret ```","solution":"def text_justify(words, max_width): \'\'\' :type words: list :type max_width: int :rtype: list \'\'\' ret = [] # return value row_len = 0 # current length of strs in a row row_words = [] # current words in a row index = 0 # the index of current word in words is_first_word = True # is current word the first in a row while index < len(words): while row_len <= max_width and index < len(words): if len(words[index]) > max_width: raise ValueError(\\"There exists word whose length is larger than max_width\\") tmp = row_len row_words.append(words[index]) tmp += len(words[index]) if not is_first_word: tmp += 1 # except for the first word, each word should have at least a \' \' before it. if tmp > max_width: row_words.pop() break row_len = tmp index += 1 is_first_word = False # here we have already got a row of str , then we should supplement enough \' \' to make sure the length is max_width. row = \\"\\" # if the row is the last if index == len(words): for word in row_words: row += (word + \' \') row = row[:-1] row += \' \' * (max_width - len(row)) # not the last row and more than one word elif len(row_words) != 1: space_num = max_width - row_len space_num_of_each_interval = space_num // (len(row_words) - 1) space_num_rest = space_num - space_num_of_each_interval * (len(row_words) - 1) for j in range(len(row_words)): row += row_words[j] if j != len(row_words) - 1: row += \' \' * (1 + space_num_of_each_interval) if space_num_rest > 0: row += \' \' space_num_rest -= 1 # row with only one word else: row += row_words[0] row += \' \' * (max_width - len(row)) ret.append(row) # after a row , reset those value row_len = 0 row_words = [] is_first_word = True return ret"},{"question":"# Scenario You are tasked with managing a dynamic set of integer values for a hotel\'s booking system. The data structure should be able to support fast lookups to check if a booking value exists, and efficient insertions and deletions as bookings are made or canceled. # Task Implement a Binary Search Tree (BST) class with the following functionalities: 1. **Insert**: Insert a new integer into the BST. 2. **Delete**: Delete an integer from the BST. 3. **Search**: Search for an integer in the BST. # Function Signatures ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: pass def delete(self, val: int) -> None: pass def search(self, val: int) -> bool: pass ``` # Requirements 1. `insert(val: int)` - Inserts `val` into the BST. 2. `delete(val: int)` - Deletes `val` from the BST if it exists. 3. `search(val: int) -> bool` - Returns `True` if `val` is present in the BST, otherwise `False`. # Constraints * The BST should manage the integers between -10^9 and 10^9. * Implement your own BST; do not use existing libraries. # Example ```python bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) assert bst.search(10) == True assert bst.search(7) == False bst.delete(10) assert bst.search(10) == False ```","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: self.root = self._insert(self.root, val) def _insert(self, node, val): if node is None: return TreeNode(val) if val < node.val: node.left = self._insert(node.left, val) else: node.right = self._insert(node.right, val) return node def delete(self, val: int) -> None: self.root = self._delete(self.root, val) def _delete(self, node, val): if node is None: return node if val < node.val: node.left = self._delete(node.left, val) elif val > node.val: node.right = self._delete(node.right, val) else: if node.left is None: return node.right elif node.right is None: return node.left temp_val = self._min_value_node(node.right) node.val = temp_val.val node.right = self._delete(node.right, temp_val.val) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def search(self, val: int) -> bool: return self._search(self.root, val) def _search(self, node, val): if node is None: return False if node.val == val: return True elif val < node.val: return self._search(node.left, val) else: return self._search(node.right, val)"},{"question":"# Problem: Number of Distinct Sets in a Grid Description You are given a 2D grid initialization as an R x C matrix filled with water (0s) and a sequence of positions where land (1s) is formed. Each position represents an adjacent land forming an island. Your task is to process these positions one by one and determine the total number of distinct islands after each land addition. An island is a group of adjacent lands (1s) connected vertically or horizontally. Initially, the whole grid is filled with water (0s). You need to implement the function `num_islands(positions)`, which accepts a list of positions where land is added and returns a list of integers indicating the number of islands after each operation. Input * `positions`: A list of tuples, where each tuple represents the position (r, c) of new land being added. Output * A list of integers, where each integer is the number of islands after each respective operation. Constraints * 1 <= R, C <= 10^3 * 1 <= Number of positions <= 10^4 Example ```python positions = [(0, 0), (0, 1), (1, 2), (2, 1)] print(num_islands(positions)) # Output: [1, 1, 2, 3] ```","solution":"def num_islands(positions): Computes the number of distinct islands after each land addition. :param positions: List of tuples representing positions where land is added. :return: List of integers representing the number of islands after each addition. if not positions: return [] R = C = 1000 parent = {} rank = {} def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] grid = [[0] * C for _ in range(R)] num_islands = 0 result = [] for (r, c) in positions: if grid[r][c] == 1: result.append(num_islands) continue grid[r][c] = 1 parent[(r, c)] = (r, c) rank[(r, c)] = 0 num_islands += 1 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] == 1: if find((r, c)) != find((nr, nc)): union((r, c), (nr, nc)) num_islands -= 1 result.append(num_islands) return result"},{"question":"# Question: Hailstone Sequence Length Given the starting point `n` of a hailstone sequence as described in the algorithm, implement a function `hailstone_length(n)` that returns the length of the hailstone sequence (including the initial `n` and the final `1`). Function Signature ```python def hailstone_length(n: int) -> int: # Your code here ``` Input/Output Formats * **Input**: An integer `n` (1 ≤ n ≤ 10^6) * You can assume that `n` will always be a positive integer greater than or equal to 1. * **Output**: An integer representing the length of the hailstone sequence from `n` to 1. Example 1. Input: `n = 5` Output: `6` Explanation: The sequence is `[5, 16, 8, 4, 2, 1]` which has length 6. 2. Input: `n = 7` Output: `17` Explanation: The sequence is `[7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]` which has length 17. Constraints * Your solution must handle the input size efficiently, optimizing for both time and space complexity. * Consider scenarios where `n` can take its maximum input size, and ensure the function remains performant.","solution":"def hailstone_length(n: int) -> int: Computes the length of the hailstone sequence starting at n and ending at 1. length = 1 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 length += 1 return length"},{"question":"Using the principles from the provided hailstone sequence algorithm, implement a function that not only generates the sequence but also returns the length of the sequence and the maximum value encountered during the sequence. # Function Signature ```python def hailstone_analysis(n: int) -> (list, int, int): Generate the hailstone sequence starting from n and return the sequence, the length of the sequence, and the maximum value encountered. Parameters: n (int): Starting point of the hailstone sequence Returns: sequence (list): Hailstone sequence from n to 1 length (int): The length of the sequence max_value (int): The maximum value encountered during the sequence ``` # Input and Output * **Input**: An integer `n` where `1 <= n <= 10^6` * **Output**: - A list of integers representing the hailstone sequence starting from n and ending at 1. - An integer representing the length of the sequence. - An integer representing the maximum value encountered in the sequence. # Constraints * The function should handle values up to 10^6 efficiently. * Intermediate values within the sequence can be large; ensure your implementation is robust for large integers. # Example ```python result = hailstone_analysis(6) print(result) # Output: ([6, 3, 10, 5, 16, 8, 4, 2, 1], 9, 16) ``` # Requirements * Your function should be optimized for performance to handle the constraints efficiently. * You need to ensure correctness and handle edge cases as identified in the analysis. Remember to include error checking and consider edge cases in your solution.","solution":"def hailstone_analysis(n: int) -> (list, int, int): Generate the hailstone sequence starting from n and return the sequence, the length of the sequence, and the maximum value encountered. Parameters: n (int): Starting point of the hailstone sequence Returns: sequence (list): Hailstone sequence from n to 1 length (int): The length of the sequence max_value (int): The maximum value encountered during the sequence if n <= 0: raise ValueError(\\"Input must be a positive integer\\") sequence = [] max_value = n while n != 1: sequence.append(n) if n % 2 == 0: n //= 2 else: n = 3 * n + 1 if n > max_value: max_value = n sequence.append(1) # append the last element which is always 1 return sequence, len(sequence), max_value"},{"question":"# Anagram Verification Function You are tasked with implementing a function to verify if two given strings are anagrams of each other. This is a common problem in text processing where the goal is to determine if one string is simply a rearrangement of another. Function Signature ```python def anagram_check(str1: str, str2: str) -> bool: ``` Input - `str1`: A string of lowercase English letters (1 ≤ len(str1) ≤ 10^5). - `str2`: A string of lowercase English letters (1 ≤ len(str2) ≤ 10^5). Output - Returns `True` if `str1` and `str2` are anagrams. - Returns `False` otherwise. Constraints - The input strings will contain only lowercase English letters. - You cannot use the sorting method or any in-built collections such as `Counter`. Example ```python print(anagram_check(\\"listen\\", \\"silent\\")) # True print(anagram_check(\\"hello\\", \\"billion\\")) # False print(anagram_check(\\"triangle\\", \\"integral\\")) # True print(anagram_check(\\"apple\\", \\"elppa\\")) # True ``` Scenario Imagine you are working on a text editor that supports encrypting messages by rearranging their letters. To decrypt and check validity, you need a function that determines if the decrypted message forms a valid word by checking potential anagrams. Hints 1. Utilize a fixed-size array to count the occurrence of each letter. 2. Verify if both strings have identical character distributions by comparing the arrays. Performance Note Given the constraints, ensure your solution runs efficiently within O(n) time complexity and O(1) additional space complexity (excluding input).","solution":"def anagram_check(str1: str, str2: str) -> bool: Check if two given strings are anagrams of each other. if len(str1) != len(str2): return False # Create a fixed size array for counting character occurrences char_count = [0] * 26 for char in str1: char_count[ord(char) - ord(\'a\')] += 1 for char in str2: char_count[ord(char) - ord(\'a\')] -= 1 for count in char_count: if count != 0: return False return True"},{"question":"# Counting Set Bits in an Unsigned Integer Objective: Write a function that accurately counts the number of set bits (also known as \'1\' bits) in the binary representation of an unsigned integer using Brian Kernighan\'s algorithm. Required Function Signature: ```python def count_set_bits(n: int) -> int: Returns the number of \'1\' bits in the binary representation of the given integer. :param n: An unsigned integer. :return: The count of \'1\' bits in the binary representation of n. ``` Constraints: - You must use Brian Kernighan\'s Algorithm. - Your implementation should be efficient and handle large integers smoothly. - Implement the function in an iterative manner (not recursive) to avoid potential stack overflow issues. Input: - An unsigned integer, `n`. Output: - An integer representing the count of \'1\' bits in the binary representation of the input integer. Example: ```python assert count_set_bits(11) == 3 # 11 in binary is 00000000000000000000000000001011, which has 3 \'1\' bits. assert count_set_bits(0) == 0 # 0 in binary is 00000000000000000000000000000000, which has no \'1\' bits. assert count_set_bits(7) == 3 # 7 in binary is 00000000000000000000000000000111, which has 3 \'1\' bits. ``` Hint: You can use the bitwise AND operation `n &= (n-1)` to turn off the rightmost 1-bit of `n` and continue counting until `n` becomes zero.","solution":"def count_set_bits(n: int) -> int: Returns the number of \'1\' bits in the binary representation of the given integer. :param n: An unsigned integer. :return: The count of \'1\' bits in the binary representation of n. count = 0 while n: n &= (n - 1) count += 1 return count"},{"question":"# Factorial Calculation with Additional Functionalities Objective Implement a function called `factorial_prime_factors` that computes the factorial of a given non-negative integer `n` and also returns the list of prime factors of the factorial result. The function should optionally take a modulus `mod` to return the factorial modulo `mod`. Function Signature ```python def factorial_prime_factors(n: int, mod: int = None) -> (int, List[int]): pass ``` Input - `n`: A non-negative integer (`0 <= n <= 100`). - `mod`: An optional positive integer (`1 <= mod`). Output - A tuple containing: 1. An integer which is the factorial of `n`, optionally modulo `mod`. 2. A list of integers representing the prime factors of the computed factorial. Constraints - If `mod` is provided, the function should return `(n! % mod)`. - Both `n` and `mod` should be valid inputs (non-negative integer and positive integer respectively). - You may assume the `n` value will not lead to factorial results larger than what can be practically computed with given machine constraints (factorial up to 100). Example ```python factorial_prime_factors(5) # Output: (120, [2, 2, 2, 3, 5]) factorial_prime_factors(5, mod=100) # Output: (20, [2, 2, 2, 3, 5]) ``` Notes - Prime factors of a number are the prime numbers that divide the number exactly, without leaving a remainder. - Ensure efficient calculation of prime factors even if the factorial is very large. Hints - You might want to build a helper function to extract prime factors. - Consider modular arithmetic optimizations where applicable to avoid large number computations. - Thoroughly validate inputs and handle edge cases.","solution":"from typing import List, Tuple from math import factorial from sympy import primerange def prime_factors(n: int) -> List[int]: i = 2 factors = [] while i * i <= n: while (n % i) == 0: factors.append(i) n //= i i += 1 if n > 1: factors.append(n) return factors def factorial_prime_factors(n: int, mod: int = None) -> Tuple[int, List[int]]: # Calculate the factorial result = factorial(n) # Apply modulus if provided if mod: result = result % mod # Get prime factors of the factorial result factors = prime_factors(factorial(n)) return result, factors"},{"question":"You are given two strings `str_a` and `str_b`. You need to write a function `min_edit_distance(str_a, str_b)` that calculates and returns the minimum number of operations required to transform string `str_a` into string `str_b`. The allowed operations are: 1. Insertion of a character. 2. Deletion of a character. 3. Substitution of a character. # Function Signature ```python def min_edit_distance(str_a: str, str_b: str) -> int: ``` # Input - `str_a` (1 <= len(str_a) <= 1000): A string consisting of lower case letters. - `str_b` (1 <= len(str_b) <= 1000): A string consisting of lower case letters. # Output - Returns an integer representing the minimum edit distance between the two strings. # Constraints - The input strings will contain only lower case letters. # Example ```python assert min_edit_distance(\\"food\\", \\"money\\") == 4 assert min_edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert min_edit_distance(\\"abc\\", \\"yabc\\") == 1 assert min_edit_distance(\\"a\\", \\"a\\") == 0 ``` # Additional Notes - Your solution should demonstrate the ability to handle edge cases such as empty strings or completely different strings efficiently. - Aim to create a space-optimized solution using two 1D arrays instead of a 2D matrix to achieve a better space complexity.","solution":"def min_edit_distance(str_a: str, str_b: str) -> int: Calculate the minimum number of operations required to convert str_a into str_b. :param str_a: The source string. :param str_b: The target string. :return: The minimum edit distance between str_a and str_b. len_a = len(str_a) len_b = len(str_b) # Initialize a 2D DP table dp = [[0] * (len_b + 1) for _ in range(len_a + 1)] # Initialize the base case for i in range(len_a + 1): for j in range(len_b + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif str_a[i - 1] == str_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) return dp[len_a][len_b]"},{"question":"Given a string `s` and a pattern `p`, implement a function `is_match` to determine if `s` matches `p`. The pattern `p` may contain the characters `\'.\'` and `\'*\'`, where: * `\'.\'` matches any single character. * `\'*\'` matches zero or more of the preceding element. The matching should cover the entire input string (not partial matches). # Function Signature ```python def is_match(s: str, p: str) -> bool: ``` # Input * `s`: A string consisting of lowercase letters (1 ≤ length ≤ 200). * `p`: A string consisting of lowercase letters, `.` and `*` (1 ≤ length ≤ 200). # Output * Return `True` if `s` matches `p`, otherwise return `False`. # Example Example 1 ```python s = \\"aa\\" p = \\"a\\" is_match(s, p) # returns False (as \\"a\\" does not match \\"aa\\") s = \\"aa\\" p = \\"aa\\" is_match(s, p) # returns True (as \\"aa\\" matches perfectly with \\"aa\\") s = \\"aaa\\" p = \\"aa\\" is_match(s, p) # returns False (as the length of \\"aaa\\" and \\"aa\\" are different) s = \\"aa\\" p = \\"a*\\" is_match(s, p) # returns True (as \'*\' matches zero or more preceding \'a\') s = \\"aa\\" p = \\".*\\" is_match(s, p) # returns True (as \'.\' matches any character and \'*\' matches zero or more characters) s = \\"ab\\" p = \\".*\\" is_match(s, p) # returns True (as \\".*\\" matches any sequence) s = \\"aab\\" p = \\"c*a*b\\" is_match(s, p) # returns True (as \'c*\' can be ignored and \\"a*a*b\\" perfectly matches \\"aab\\") ``` # Constraints * Your algorithm should run in (O(n times m)) time complexity. * You should handle all edge cases, including empty strings and patterns. # Hints * Use a 2D DP table where the state `dp[i][j]` indicates whether the first `i` characters of `s` match the first `j` characters of `p`. * Carefully manage transitions knowing that `.` and `*` are special characters with specific rules.","solution":"def is_match(s: str, p: str) -> bool: Determines if the input string `s` matches the pattern `p`. Pattern `p` may contain: - \'.\' which matches any single character. - \'*\' which matches zero or more of the preceding element. # DP table where dp[i][j] will be True if s[:i] matches p[:j], else False dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # Empty string and empty pattern are a match dp[0][0] = True # Fill the DP table for j in range(1, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # \'*\' can eliminate the preceding element and itself for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] # \'*\' can eliminate the preceding element and itself if p[j - 2] == s[i - 1] or p[j - 2] == \'.\': dp[i][j] = dp[i][j] or dp[i - 1][j] return dp[len(s)][len(p)]"},{"question":"Question: Implement Enhanced Radix Sort Radix Sort can efficiently sort arrays of non-negative integers. However, the basic implementation doesn’t handle arrays containing negative numbers. Your task is to modify the existing Radix Sort algorithm to correctly sort arrays that can contain both negative and non-negative integers. # Function Signature ```python def enhanced_radix_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr`: List of integers where the length is up to 10^6 and the values range between -10^9 and 10^9. # Output * Return the sorted list of integers in non-decreasing order. # Constraints * You must handle large arrays efficiently. * Ensure the space complexity does not exceed O(n). # Example ```python assert enhanced_radix_sort([170, -45, 90, 802, 24, 2, 66, -3]) == [-45, -3, 2, 24, 66, 90, 170, 802] assert enhanced_radix_sort([5, -3, 0, -1, -2, 3, 2, 1, -4]) == [-4, -3, -2, -1, 0, 1, 2, 3, 5] assert enhanced_radix_sort([-999999, -1000000, 1000000, 999999]) == [-1000000, -999999, 999999, 1000000] ``` # Notes 1. Negative integers can be handled separately: you may sort the absolute values of negative integers and then invert their signs after sorting. 2. Consider dividing the array into non-negative and negative parts, sorting each part, and then combining appropriately. 3. Aim for an O(nk) runtime where possible. Happy coding!","solution":"from typing import List def counting_sort_for_radix(arr: List[int], exp: int) -> None: n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[(index % 10)] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = arr[i] // exp output[count[(index % 10)] - 1] = arr[i] count[(index % 10)] -= 1 i -= 1 for i in range(n): arr[i] = output[i] def radix_sort(arr: List[int]) -> None: max1 = max(arr) exp = 1 while max1 // exp > 0: counting_sort_for_radix(arr, exp) exp *= 10 def enhanced_radix_sort(arr: List[int]) -> List[int]: if not arr: return arr positives = [num for num in arr if num >= 0] negatives = [-num for num in arr if num < 0] if positives: radix_sort(positives) if negatives: radix_sort(negatives) negatives = [-num for num in reversed(negatives)] return negatives + positives"},{"question":"**Background**: In cryptography and coding theory, determining whether two strings are anagrams is a common task. **Task**: Write a function to determine if two given strings are anagrams of each other. Two strings are anagrams if and only if they both contain the same characters with identical frequencies. # Function Signature ```python def are_anagrams(s: str, t: str) -> bool: ``` # Input * `s` and `t` - Two strings containing only lowercase alphabets. # Output * Return `True` if `t` is an anagram of `s`, otherwise return `False`. # Constraints * The lengths of `s` and `t` can be up to 10^5. # Example ```python assert are_anagrams(\\"listen\\", \\"silent\\") == True assert are_anagrams(\\"hello\\", \\"bello\\") == False assert are_anagrams(\\"\\", \\"\\") == True # Considering empty string a valid anagram of itself assert are_anagrams(\\"a\\", \\"a\\") == True assert are_anagrams(\\"ab\\", \\"a\\") == False ``` # Notes - Consider using efficient data structures to handle character frequency counting. - Optimize to handle large inputs efficiently within the given constraints.","solution":"def are_anagrams(s: str, t: str) -> bool: Determines if two strings are anagrams of each other. Args: s (str): First string. t (str): Second string. Returns: bool: True if t is an anagram of s, False otherwise. if len(s) != len(t): return False from collections import Counter return Counter(s) == Counter(t)"},{"question":"**Scenario:** Alice is developing a system that needs to identify one unique item from a list of duplicates. Each item in the list appears exactly twice except for one unique item which appears only once. Alice needs an efficient function to find that unique item without using any additional memory. Can you help her by implementing the function? **Task:** Implement a function called `find_unique_number(nums)` that takes a list of integers `nums` and returns the integer that appears exactly once, while all other integers appear twice. Ensure your function runs in linear time and uses constant extra space. **Function Signature:** ```python def find_unique_number(nums: List[int]) -> int: ``` **Input:** * `nums`: List of integers (1 ≤ len(nums) ≤ 3 * 10^4) where every element appears twice except for one. **Output:** * Returns the single integer that appears once. **Constraints:** * Numbers can be positive, negative, or zero. * There is exactly one unique number. **Examples:** 1. `find_unique_number([2, 2, 1])` should return `1`. 2. `find_unique_number([4, 1, 2, 1, 2])` should return `4`. 3. `find_unique_number([1])` should return `1`. **Explanation:** * In the first example, every number appears twice except `1`. * In the second example, every number appears twice except `4`. * In the third example, there is only one number `1`, appearing once. **Notes:** * Do not use sort, additional arrays, or any data structures that consume extra memory. **Hint**: Think about how the XOR operation works and how it can be utilized to solve this problem efficiently.","solution":"def find_unique_number(nums): Find the unique number in the list where every element except one appears twice. Args: nums (List[int]): List of integers where each element appears exactly twice except for one unique element. Returns: int: The unique integer that appears once. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Question: Implement and Analyze an Optimized Sorting Algorithm Context: You are given a list of integers that need to be sorted in ascending order. Gnome Sort is one approach to accomplish this, but its inefficiency on larger, unsorted datasets can be a hindrance. To remedy this, you must implement and analyze the performance of Gnome Sort alongside an optimized sorting algorithm of your choice. Task: 1. Implement the given `gnome_sort` function. 2. Write a new function `optimized_sort` that uses a more efficient sorting algorithm (e.g., QuickSort, MergeSort). 3. Write a function to compare and analyze the performance of both sorting algorithms. Requirements: * Both sorting functions (`gnome_sort` and `optimized_sort`) must take a list of integers as input and return a sorted list of integers. * Implement a function `compare_sorting_performance` that takes a large unsorted list of integers, applies both sorting algorithms to it, and prints out the time taken by each. * The `compare_sorting_performance` should handle edge cases like empty lists and lists with repeated integers. Constraints: * Input List Size: Up to 1,000,000 elements. * Accepted Libraries/Functions: You may use the `time` module for timing comparisons but avoid using Python’s built-in `sort` function. Example Input/Output: ```python def gnome_sort(arr): # Provided function # Your existing gnome_sort implementation def optimized_sort(arr): # Your new optimized sorting algorithm implementation # Implement a more efficient sorting algorithm here def compare_sorting_performance(arr): # Implement functionality to measure and compare the performance of the above sorting functions Example input_arr = [5, 3, 1, 6, 4, 2] optimized_sorted = optimized_sort(input_arr[:]) gnome_sorted = gnome_sort(input_arr[:]) print(compare_sorting_performance(input_arr)) # Output should include the time taken by both sorting algorithms ```","solution":"import time def gnome_sort(arr): Gnome Sort Algorithm. index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr def optimized_sort(arr): Merge Sort Algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left = optimized_sort(arr[:mid]) right = optimized_sort(arr[mid:]) return merge(left, right) def merge(left, right): Helper function to merge two sorted lists. merged = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 merged.extend(left[i:]) merged.extend(right[j:]) return merged def compare_sorting_performance(arr): Compare performance of Gnome Sort and Optimized Sort on the given list. start_time = time.time() gnome_sorted = gnome_sort(arr[:]) gnome_time = time.time() - start_time start_time = time.time() optimized_sorted = optimized_sort(arr[:]) optimized_time = time.time() - start_time print(f\\"Gnome Sort time: {gnome_time:.5f} seconds\\") print(f\\"Optimized Sort time: {optimized_time:.5f} seconds\\") return gnome_sorted, optimized_sorted"},{"question":"# Graph Traversal Challenge Given an unweighted, undirected graph represented as an adjacency list, write functions to perform both Depth First Search (DFS) and Breadth First Search (BFS) traversals. Your solutions should account for common edge cases such as cycles and disconnected graphs. Objectives: 1. Implement the `dfs_recursive(graph: dict, start: int) -> set` function that performs a depth-first search recursively and returns the set of visited nodes. 2. Implement the `dfs_iterative(graph: dict, start: int) -> set` function that performs a depth-first search iteratively using a stack and returns the set of visited nodes. 3. Implement the `bfs(graph: dict, start: int) -> set` function that performs a breadth-first search using a queue and returns the set of visited nodes. Constraints: * The graph is represented as an adjacency list, where `graph[node]` is a list of nodes connected to `node`. * The graph might contain cycles and/or separate components. * Node identifiers are unique integers starting from 0. * The functions should handle an empty graph gracefully. Example: ```python graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0], 3: [1], 4: [1, 5], 5: [4] } # DFS Traversal Recursively assert dfs_recursive(graph, 0) == {0, 1, 2, 3, 4, 5} # DFS Traversal Iteratively assert dfs_iterative(graph, 0) == {0, 1, 2, 3, 4, 5} # BFS Traversal assert bfs(graph, 0) == {0, 1, 2, 3, 4, 5} ``` Notes: * The order of traversal in BFS and DFS may vary, but the set of visited nodes should be the same. * Consider using helper functions if necessary to maintain code clarity and reusability.","solution":"def dfs_recursive(graph, start, visited=None): Performs a recursive depth-first search (DFS) on a graph :param graph: The adjacency list of the graph :param start: The starting node for DFS :param visited: The set of visited nodes :return: The set of visited nodes if visited is None: visited = set() visited.add(start) for neighbor in graph.get(start, []): if neighbor not in visited: dfs_recursive(graph, neighbor, visited) return visited def dfs_iterative(graph, start): Performs an iterative depth-first search (DFS) on a graph using a stack :param graph: The adjacency list of the graph :param start: The starting node for DFS :return: The set of visited nodes visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) stack.extend(neighbor for neighbor in graph.get(node, []) if neighbor not in visited) return visited def bfs(graph, start): Performs a breadth-first search (BFS) on a graph using a queue :param graph: The adjacency list of the graph :param start: The starting node for BFS :return: The set of visited nodes visited = set() queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) queue.extend(neighbor for neighbor in graph.get(node, []) if neighbor not in visited) return visited"},{"question":"Problem Statement You are tasked with creating a function that modifies a given stack by swapping successive pairs of elements, starting from the bottom. Implement two versions of this function: one using an auxiliary stack and another using a queue. If there is an odd number of elements in the stack, the top-most element remains in its original position. Function Signatures - `def first_switch_pairs(stack):` - `def second_switch_pairs(stack):` Expected Input and Output - **Input**: A list of integers representing a stack. For example, `[3, 8, 17, 9, 1, 10]`. - **Output**: The list with successive pairs of elements swapped. For an even number of elements, `[8, 3, 9, 17, 10, 1]`. For an odd number, `[8, 3, 9, 17, 1]`. Constraints - The stack can have up to 10^6 elements. - Elements in the stack are integers within the range [-10^9, 10^9]. Scenario Suppose you are working on a library function for a stack manipulation toolkit. This specific function will be used to prepare stacks of batch-processed data by pairing adjacent elements for comparison or parallel processing steps. Requirements 1. Implement the function `first_switch_pairs` using only another stack for auxiliary storage. 2. Implement the function `second_switch_pairs` using a queue for auxiliary storage. Examples 1. For the input stack `[3, 8, 17, 9, 1, 10]`: - `first_switch_pairs([3, 8, 17, 9, 1, 10])` should return `[8, 3, 9, 17, 10, 1]`. - `second_switch_pairs([3, 8, 17, 9, 1, 10])` should return `[8, 3, 9, 17, 10, 1]`. 2. For the input stack `[3, 8, 17, 9, 1]`: - `first_switch_pairs([3, 8, 17, 9, 1])` should return `[8, 3, 9, 17, 1]`. - `second_switch_pairs([3, 8, 17, 9, 1])` should return `[8, 3, 9, 17, 1]`.","solution":"def first_switch_pairs(stack): Switches successive pairs of elements in the given stack, using an auxiliary stack. if len(stack) <= 1: return stack aux_stack = [] while stack: aux_stack.append(stack.pop()) while aux_stack: first = aux_stack.pop() if aux_stack: second = aux_stack.pop() stack.append(second) stack.append(first) else: stack.append(first) return stack from collections import deque def second_switch_pairs(stack): Switches successive pairs of elements in the given stack, using a queue for auxiliary storage. if len(stack) <= 1: return stack queue = deque() while stack: queue.appendleft(stack.pop()) while queue: first = queue.popleft() if queue: second = queue.popleft() stack.append(second) stack.append(first) else: stack.append(first) return stack"},{"question":"# **Coding Assessment Question: RSA Encryption Implementation** Scenario Imagine you are tasked with securing a communication channel between a client and a server using RSA encryption. Your job is to implement the functions required to generate RSA keys, encrypt, and decrypt messages. The client will use the public key to encrypt the message and the server will use its private key to decrypt the message securely. # Task You need to implement three functions: 1. `generate_key(k)`: This function will generate and return the RSA modulus `n`, the public exponent `e`, and the private exponent `d` for a given bit length `k`. 2. `encrypt(data, e, n)`: This function will encrypt the given data using the public key values `e` and `n`. 3. `decrypt(data, d, n)`: This function will decrypt the given encrypted data using the private key value `d` and `n`. # Input and Output Formats 1. `generate_key(k)`: * **Input**: `k` (an integer) representing the bit length for the modulus `n`. * **Output**: `(n, e, d)`, where `n`, `e`, and `d` are integers. 2. `encrypt(data, e, n)`: * **Input**: - `data` (an integer) representing the plaintext message. - `e` (an integer) representing the public exponent. - `n` (an integer) representing the modulus. * **Output**: The encrypted data as an integer. 3. `decrypt(data, d, n)`: * **Input**: - `data` (an integer) representing the encrypted message. - `d` (an integer) representing the private exponent. - `n` (an integer) representing the modulus. * **Output**: The decrypted data as an integer (original plaintext). # Constraints * Ensure `n` is the product of two large distinct prime numbers. * `k` is typically chosen such that `2**(k-1) <= n < 2**k`. * Ensure generated primes `p` and `q` are strong to avoid easy factorization. * Optimize the prime generation process to avoid performance issues. Performance Requirements * The implementation should handle at least up to 1024-bit length securely and efficiently. * The `encrypt` and `decrypt` operations should be optimized for large integers. Provide the implementation for the following skeleton functions: ```python def generate_key(k): # Your code here pass def encrypt(data, e, n): # Your code here pass def decrypt(data, d, n): # Your code here pass # Example Usage: # n,e,d = generate_key(1024) # data = 12345678 # encrypted = encrypt(data, e, n) # decrypted = decrypt(encrypted, d, n) # assert decrypted == data ```","solution":"import random from sympy import isprime, mod_inverse def generate_large_prime(bits): while True: p = random.getrandbits(bits) if isprime(p): return p def generate_key(k): Generate RSA keys with a modulus of bit length k. Parameters: k (int): Bit length for the modulus n. Returns: tuple: A tuple containing (n, e, d) p = generate_large_prime(k // 2) q = generate_large_prime(k // 2) n = p * q phi = (p - 1) * (q - 1) e = 65537 # Common choice for e d = mod_inverse(e, phi) return n, e, d def encrypt(data, e, n): Encrypt the given data using the public key (e, n). Parameters: data (int): Plaintext message. e (int): Public exponent. n (int): Modulus. Returns: int: Encrypted data. return pow(data, e, n) def decrypt(data, d, n): Decrypt the given encrypted data using the private key (d, n). Parameters: data (int): Encrypted message. d (int): Private exponent. n (int): Modulus. Returns: int: Decrypted data (original plaintext). return pow(data, d, n)"},{"question":"# Word Dictionary with Trie Data Structure Design and implement a Word Dictionary that supports adding new words and searching for words where the search can be a literal word or a regular expression string containing dots (\'.\'). A dot(\'.\') means it can represent any letter. Requirements: 1. Implement the `WordDictionary` class: - `addWord(word: str) -> None`: Adds a word into the data structure. - `search(word: str) -> bool`: Returns true if the word is in the data structure. A word could contain the dot character \'.\' to represent any one letter. Constraints: - All inputs are in lowercase letters \'a\' to \'z\'. - The maximum number of calls to `addWord` and `search` methods combined does not exceed 10^4. - The length of any word will be in the range [1, 20]. Example: ```python wordDictionary = WordDictionary() wordDictionary.addWord(\\"bad\\") wordDictionary.addWord(\\"dad\\") wordDictionary.addWord(\\"mad\\") print(wordDictionary.search(\\"pad\\")) # returns False print(wordDictionary.search(\\"bad\\")) # returns True print(wordDictionary.search(\\".ad\\")) # returns True print(wordDictionary.search(\\"b..\\")) # returns True ``` Implement the `WordDictionary` class based on these specifications. Ensure that your implementation is optimized for both time and space. Consider edge cases and discuss any potential performance influences in your implementation.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def addWord(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': for x in node.children.values(): if search_in_node(word[i+1:], x): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word return search_in_node(word, self.root)"},{"question":"Problem Statement # Array Rotation Given an array of `n` elements, rotate the array to the right by `k` steps. The rotation should be done in-place unless otherwise specified. # Function Signature ```python def rotate_array(array: list[int], k: int) -> None: Rotates the array \'k\' steps to the right. :param array: List of integers to be rotated :param k: The number of steps to rotate the list by :rtype: None. The function modifies the array in-place. pass ``` # Input * `array`: A list of integers `array` (0 <= len(array) <= 10^5) * `k`: An integer `k` (0 <= k <= 10^5) # Output The function should modify the array in-place and should not return anything. # Constraints - You should implement the function with O(n) time complexity and O(1) additional space complexity. - The array should be modified in-place. - You cannot use extra space (like creating slices). # Example ```python # Example 1 arr = [1, 2, 3, 4, 5, 6, 7] rotate_array(arr, 3) # arr should now be [5, 6, 7, 1, 2, 3, 4] # Example 2 arr = [-1, -100, 3, 99] rotate_array(arr, 2) # arr should now be [3, 99, -1, -100] ``` # Edge Cases - If the array is empty, the function should handle it and simply return. - If k is 0, the array should remain unchanged. - If k is greater than the length of the array, use `k % len(array)` as the effective number of rotations. # Guidelines - Use an in-place approach (like reversing parts of the array). - Handle edge cases and constraints as described. - Be efficient with time and space.","solution":"def rotate_array(array: list[int], k: int) -> None: Rotates the array \'k\' steps to the right. :param array: List of integers to be rotated :param k: The number of steps to rotate the list by :rtype: None. The function modifies the array in-place. n = len(array) if n == 0 or k == 0: return k %= n def reverse(arr, start, end): while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 # Reverse the whole array reverse(array, 0, n - 1) # Reverse the first k elements reverse(array, 0, k - 1) # Reverse the remaining elements reverse(array, k, n - 1)"},{"question":"# Encoding Message Decoding You are given a message encoded using the following mapping for letters A-Z: ``` \'A\' -> 1 \'B\' -> 2 ... \'Z\' -> 26 ``` Your task is to write a function that determines the total number of ways to decode a given encoded message made up of digits. # Function Signature ```python def num_decodings(encoded_message: str) -> int: ``` # Input * `encoded_message` (str): A string consisting of digits only (`0-9`), 1 ≤ length ≤ 100. # Output * (int): The total number of ways to decode the message. Return 0 if the message cannot be decoded. # Constraints * A leading \'0\' in the encoded message makes it invalid. * The characters \'0\' in the encoded message must only appear in valid two-character encodings like \'10\' or \'20\'. * The function should run in O(n) time complexity and O(1) space complexity. # Example ```python assert num_decodings(\\"12\\") == 2 # \\"AB\\" (1, 2) or \\"L\\" (12) assert num_decodings(\\"226\\") == 3 # \\"BZ\\" (2, 26) or \\"VF\\" (22, 6) or \\"BBF\\" (2, 2, 6) assert num_decodings(\\"0\\") == 0 # Invalid message assert num_decodings(\\"06\\") == 0 # Invalid message ``` # Explanation: 1. `\\"12\\"` can be decoded as: 1. \\"AB\\" (\\"1\\", \\"2\\") 2. \\"L\\" (\\"12\\") 2. `\\"226\\"` can be decoded as: 1. \\"BZ\\" (\\"2\\", \\"26\\") 2. \\"VF\\" (\\"22\\", \\"6\\") 3. \\"BBF\\" (\\"2\\", \\"2\\", \\"6\\") 3. `\\"0\\"` is invalid as no character can map to \'0\'. 4. `\\"06\\"` is invalid as no character can map to \'0\' and \'6\' alone. Develop this `num_decodings` function ensuring optimal and correct handling of edge cases as stated.","solution":"def num_decodings(encoded_message: str) -> int: if not encoded_message or encoded_message[0] == \'0\': return 0 n = len(encoded_message) prev = 1 # This will keep (i-2)\'s value curr = 1 # This will keep (i-1)\'s value for i in range(1, n): temp = curr if encoded_message[i] == \'0\': if encoded_message[i-1] == \'1\' or encoded_message[i-1] == \'2\': curr = prev else: return 0 elif 10 <= int(encoded_message[i-1:i+1]) <= 26: curr += prev prev = temp return curr"},{"question":"**Scenario:** You are working on a data management system for a large e-commerce platform where product IDs need to be sorted efficiently. The IDs are large integers, and the sorting must be stable to maintain the initial order of products with identical IDs. Your task is to implement an efficient sorting mechanism using the Radix Sort algorithm. # Requirements: 1. **Function Signature:** `def efficient_radix_sort(arr: List[int]) -> List[int]:` 2. **Input:** A list of non-negative integers representing product IDs. 3. **Output:** A list of integers sorted in ascending order. 4. **Constraints:** * 0 <= len(arr) <= 10^5 * 0 <= arr[i] <= 10^9 5. **Performance Requirement:** The implementation should have optimal time and space complexity suitable for the given constraints. # Example: ```python # Example usage product_ids = [170, 45, 75, 90, 802, 24, 2, 66] sorted_ids = efficient_radix_sort(product_ids) print(sorted_ids) # Output should be [2, 24, 45, 66, 75, 90, 170, 802] ```","solution":"from typing import List def counting_sort(arr: List[int], exp: int) -> List[int]: n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 for i in range(n): arr[i] = output[i] return arr def efficient_radix_sort(arr: List[int]) -> List[int]: if not arr: return arr max1 = max(arr) exp = 1 while max1 // exp > 0: arr = counting_sort(arr, exp) exp *= 10 return arr"},{"question":"# Nearest Neighbor Classification Task You are tasked with creating a Nearest Neighbor classifier function. The function will take in an input vector and a training set represented as a dictionary of labeled vectors. Your function should return the label associated with the vector in the training set that is the closest to the input vector. Function Signature ```python def nearest_neighbor(x: tuple, tSet: dict) -> any: ``` Input - `x`: a tuple representing the input vector. - `tSet`: a dictionary where keys are tuples representing vectors, and values are the associated labels. Output - The function should return the label of the closest vector in the training set to the input vector. Constraints - The input vector `x` and the keys in `tSet` will always be tuples of the same length. - The training set `tSet` contains at least one vector. - Vectors will have dimensions between 1 to 1000. Performance Requirements - Aim to achieve a time complexity of linear scale with respect to the number of vectors in the training set. Example ```python tSet = {(1.0, 2.0): \'A\', (2.0, 3.0): \'B\', (3.0, 1.0): \'C\'} x = (2.5, 2.5) print(nearest_neighbor(x, tSet)) # Output: \'B\' ``` Ensure your implementation is efficient and handles different edge cases appropriately.","solution":"def nearest_neighbor(x: tuple, tSet: dict) -> any: Finds the label of the nearest neighbor in the training set to the input vector x. Parameters: x (tuple): The input vector. tSet (dict): Training set where keys are tuples representing vectors and values are labels. Returns: any: The label of the nearest neighbor to x. def euclidean_distance(vec1, vec2): return sum((a - b) ** 2 for a, b in zip(vec1, vec2)) ** 0.5 nearest_dist = float(\'inf\') nearest_label = None for vec, label in tSet.items(): dist = euclidean_distance(x, vec) if dist < nearest_dist: nearest_dist = dist nearest_label = label return nearest_label"},{"question":"# Coding Challenge: Implement a Max Binary Heap Based on the min binary heap structure and operations provided, implement a **Max Binary Heap** class. A max binary heap is similar to a min binary heap except that each parent node is greater than or equal to its children. Your implementation should consist of the following methods: - `insert(val)`: Inserts a new value into the max heap. - `remove_max()`: Removes and returns the maximum element from the heap. # Requirements: - **Insertion Complexity**: O(log N) - **Removal Complexity**: O(log N) - **Python List Representation**: Use a list for the underlying implementation, starting from index 1. # Function Signatures: ```python class MaxBinaryHeap: def insert(self, val: int) -> None: pass def remove_max(self) -> int: pass ``` # Constraints: - Assume all input values will be valid integers. - For `remove_max`, if the heap is empty, return `None`. # Example Usage: ```python heap = MaxBinaryHeap() heap.insert(10) heap.insert(20) heap.insert(5) print(heap.remove_max()) # Output: 20 print(heap.remove_max()) # Output: 10 print(heap.remove_max()) # Output: 5 print(heap.remove_max()) # Output: None ``` # Instructions: 1. Implement the `insert` method to add a value while maintaining the max-heap property. 2. Implement the `remove_max` method to remove and return the maximum value, also maintaining the max-heap property. 3. Ensure to handle edge cases such as removing from an empty heap.","solution":"class MaxBinaryHeap: def __init__(self): self.heap = [None] # Initialize heap with \'None\' at index 0 to simplify parent/child indexing def insert(self, val: int) -> None: Inserts a new value into the max heap. # Add the new value to the end of the list self.heap.append(val) self._sift_up(len(self.heap) - 1) def remove_max(self) -> int: Removes and returns the maximum element from the heap. If the heap is empty, returns None. if len(self.heap) == 1: return None # Heap is empty if len(self.heap) == 2: return self.heap.pop() # Heap has only one element max_val = self.heap[1] # Move the last element to the top self.heap[1] = self.heap.pop() self._sift_down(1) return max_val def _sift_up(self, idx): Moves the element at index \'idx\' up to maintain the max-heap property. parent = idx // 2 if parent > 0 and self.heap[idx] > self.heap[parent]: self.heap[idx], self.heap[parent] = self.heap[parent], self.heap[idx] self._sift_up(parent) def _sift_down(self, idx): Moves the element at index \'idx\' down to maintain the max-heap property. left = idx * 2 right = idx * 2 + 1 largest = idx if left < len(self.heap) and self.heap[left] > self.heap[largest]: largest = left if right < len(self.heap) and self.heap[right] > self.heap[largest]: largest = right if largest != idx: self.heap[idx], self.heap[largest] = self.heap[largest], self.heap[idx] self._sift_down(largest)"},{"question":"**Problem Statement** You are given a sorted array of integers in ascending order and a target integer. Your task is to implement an efficient algorithm to find the element in the array. Implement both an iterative and a recursive version of the Binary Search algorithm. If the element is found, return its index, otherwise, return -1. **Function Signatures** 1. `def binary_search_iterative(array: List[int], target: int) -> int:` 2. `def binary_search_recursive(array: List[int], low: int, high: int, target: int) -> int:` **Input** * `array`: List of integers, sorted in ascending order. * `target`: Integer to be searched in the array. **Output** * Return the index of `target` if found, otherwise return -1. **Constraints** * The length of the array will not exceed 10^6. * Elements in the array and the target will be in the range of `-10^9` to `10^9`. **Examples** ```python # Example 1 array = [1, 2, 3, 4, 5, 6, 7, 8, 9] target = 5 # output should be: 4 (since array[4] == 5) # Example 2 array = [1, 3, 5, 7, 9] target = 6 # output should be: -1 (6 is not in the array) # Example 3 array = [] target = 1 # output should be: -1 (array is empty) ``` Note: Ensure your code handles edge cases such as empty arrays and large input sizes efficiently.","solution":"from typing import List def binary_search_iterative(array: List[int], target: int) -> int: Returns the index of the target in a sorted array using an iterative binary search. If the target is not found, returns -1. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: low = mid + 1 else: high = mid - 1 return -1 def binary_search_recursive(array: List[int], low: int, high: int, target: int) -> int: Returns the index of the target in a sorted array using a recursive binary search. If the target is not found, returns -1. if low > high: return -1 mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: return binary_search_recursive(array, mid + 1, high, target) else: return binary_search_recursive(array, low, mid - 1, target)"},{"question":"# Polynomial Operations and Evaluation As a mathematics enthusiast, you\'ve come across an intriguing library implementing polynomial operations. Your task is to extend its capabilities with some additional essential functionalities. Implement the following methods in the Polynomial class: 1. `degree()` - Calculate the degree of the polynomial, which is the highest power of any variable in any monomial. 2. `derivative(var: int)` - Compute the derivative of the polynomial with respect to a particular variable (given by its identifier). Method Specifications: 1. **`degree()`**: * **Input**: None * **Output**: returns an integer representing the polynomial\'s degree. * **Constraints**: Assume all monomial variables have non-negative integer powers. * **Example**: ```python p = Polynomial([ Monomial({1:2}, 2), # 2(a_1)^2 Monomial({2:3, 1:1}, -1), # -a_2^3 * a_1 Monomial({}, 5) # 5 ]) print(p.degree()) # Output: 4 ``` 2. **`derivative(var: int)`**: * **Input**: var: int - variable with respect to which the derivative is calculated. * **Output**: returns a new Polynomial object representing the derivative with respect to the given variable. * **Constraints**: Derivatives for constants and variables with zero power should be handled correctly. * **Example**: ```python p = Polynomial([ Monomial({1:2}, 2), # 2(a_1)^2 Monomial({2:3, 1:1}, -1) # -a_2^3 * a_1 ]) dp_da1 = p.derivative(1) # Output Polynomial for derivative w.r.t a_1 dp_da2 = p.derivative(2) # Output Polynomial for derivative w.r.t a_2 ``` Expectations: * Implement the `degree()` method to identify the polynomial\'s highest degree term. * For the `derivative()` method, ensure correct differentiation rules: - The power of the target variable decreases by 1. - Multiply the coefficient by the original power of the target variable.","solution":"class Monomial: def __init__(self, powers, coefficient): self.powers = powers # Dictionary with variable ID as key and power as value, e.g., {1:2, 2:3} self.coefficient = coefficient # Coefficient of the monomial def degree(self): return sum(self.powers.values()) def derivative(self, var): if var not in self.powers or self.powers[var] == 0: return None # Derivative of the monomial with respect to var is zero new_powers = self.powers.copy() new_coefficient = self.coefficient * new_powers[var] if new_powers[var] == 1: del new_powers[var] # Remove the variable if its power becomes zero else: new_powers[var] -= 1 return Monomial(new_powers, new_coefficient) class Polynomial: def __init__(self, monomials): self.monomials = monomials def degree(self): if not self.monomials: return 0 return max(m.degree() for m in self.monomials) def derivative(self, var): derived_monomials = [] for monomial in self.monomials: derivative_monomial = monomial.derivative(var) if derivative_monomial is not None: derived_monomials.append(derivative_monomial) return Polynomial(derived_monomials)"},{"question":"# Question: Implement a Text Search Algorithm You are to implement a function using the Rabin-Karp algorithm to find all occurrences of a given word in a larger text. Function Signature ```python def find_all_occurrences(word: str, text: str) -> list: Finds all starting indices of occurrences of word within text using Rabin-Karp algorithm. :param word: A substring to find in the given text :param text: The larger text where the substring is to be found :return: A list of starting indices of every match of the word within the text pass ``` Input - `word` (str): The substring to be searched in the `text`. - `text` (str): The large string where the search is to be performed. Output - List[int]: A list of starting indices where `word` is found within `text`. Return an empty list if `word` is not found. Constraints - The function should handle edge cases such as empty `word`, empty `text`, or `word` longer than `text`. - Optimize your solution to handle large input efficiently. Example ```python print(find_all_occurrences(\\"abc\\", \\"ababcabc\\")) # Output: [2, 5] print(find_all_occurrences(\\"a\\", \\"aaaa\\")) # Output: [0, 1, 2, 3] print(find_all_occurrences(\\"abcd\\", \\"xyz\\")) # Output: [] print(find_all_occurrences(\\"xyz\\", \\"\\")) # Output: [] ``` Implement the `find_all_occurrences` function to demonstrate your understanding of the Rabin-Karp algorithm, ensuring to account for efficiency and edge cases.","solution":"def find_all_occurrences(word: str, text: str) -> list: Finds all starting indices of occurrences of word within text using the Rabin-Karp algorithm. :param word: A substring to find in the given text :param text: The larger text where the substring is to be found :return: A list of starting indices of every match of the word within the text if not word: return [] word_len = len(word) text_len = len(text) if word_len > text_len: return [] # Hash function and mod value base = 256 mod = 101 # Initial hash values word_hash = 0 text_hash = 0 # Precompute base^(word_len-1) % mod (used later for removing leading digit) h = 1 for _ in range(word_len - 1): h = (h * base) % mod # Compute the hash value of the word and the first window of the text for i in range(word_len): word_hash = (base * word_hash + ord(word[i])) % mod text_hash = (base * text_hash + ord(text[i])) % mod indices = [] # Slide the pattern over text one character at a time for i in range(text_len - word_len + 1): # If the hash values match, then only check for characters one by one if word_hash == text_hash: if text[i:i + word_len] == word: indices.append(i) # Compute hash value for the next window of text # Remove leading digit and add trailing digit if i < text_len - word_len: text_hash = (text_hash - h * ord(text[i])) % mod text_hash = (text_hash * base + ord(text[i + word_len])) % mod text_hash = (text_hash + mod) % mod # Ensure positive hash value return indices"},{"question":"# Stuttering Stack Elements You are given a stack that contains integers. Your task is to write a function `stutter_stack` that replaces every value in the stack with two occurrences of that value. The function should operate in the following way: * For a given stack, it should replace each element with two of the same element, maintaining the order from bottom to top. Consider the following elements in stack (bottom [3, 7, 1, 14, 9] top): - The resulting stack should be (bottom [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] top). # Input - A list of integers representing a stack (topmost element is the last element in the list). # Output - A list of integers representing the modified stack with each element replaced by two occurrences of itself. # Constraints - Do not use any additional data structures except for a single stack or queue for auxiliary storage. - Aim to optimize for time complexity O(n) and space complexity O(n). - The input stack can have any integer values (positive, negative, or zero). # Example 1. **Input**: `[3, 7, 1, 14, 9]` **Output**: `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]` 2. **Input**: `[5, 10]` **Output**: `[5, 5, 10, 10]` 3. **Input**: `[1]` **Output**: `[1, 1]` 4. **Input**: `[]` **Output**: `[]` Function Signature: ```python def stutter_stack(stack: list) -> list: pass ``` Develop a function that correctly manipulates the stack as specified, considering edge cases and implementing using either an auxiliary stack or queue for temporary storage.","solution":"def stutter_stack(stack): Replaces every value in the stack with two occurrences of that value. :param stack: List of integers representing the stack (top element is last in the list) :return: Modified stack with each element replaced by two occurrences of itself temp_stack = [] # Move all elements to a temporary stack while stack: temp_stack.append(stack.pop()) # Move back the elements to the original stack with duplication while temp_stack: val = temp_stack.pop() stack.append(val) stack.append(val) return stack"},{"question":"# Bogo Sort Variation Challenge **Background**: While Bogo Sort is a highly inefficient sorting algorithm, it serves as an interesting case study in understanding the limitations and behavior of brute-force algorithms. In this task, you will extend the Bogo Sort algorithm to handle additional features to demonstrate understanding of algorithm improvement and handling edge cases. **Objective**: Extend the Bogo Sort algorithm to: 1. Handle and return informative values when encountering special cases like an empty array or an array with all identical elements. 2. Count and return the number of iterations taken to sort the array. 3. Introduce a cut-off limit for the maximum number of shuffling attempts to prevent infinite looping. **Task**: Implement the function `enhanced_bogo_sort(arr, max_attempts)` that: 1. Checks if the array is empty and returns immediately with 0 iterations. 2. Checks if all elements in the array are identical, if so, returns the array with 0 iterations. 3. Sorts the array using an improved version of Bogo Sort with the criteria mentioned above. 4. If the maximum number of shuffles (`max_attempts`) is reached, return a tuple with the array in its current state and the number of iterations performed. **Function Signature**: ```python def enhanced_bogo_sort(arr: list, max_attempts: int) -> tuple: pass ``` **Input**: - `arr`: A list of integers (0 ≤ arr.length ≤ 100, -10^5 ≤ arr[i] ≤ 10^5) - `max_attempts`: An integer representing the maximum number of shuffling attempts allowed. **Output**: - A tuple `(sorted_array, iterations)` representing the sorted array (or the last state of the array if the maximum attempts are reached) and the number of iterations performed. **Examples**: ``` enhanced_bogo_sort([], 10) Output: ([], 0) enhanced_bogo_sort([1, 1, 1], 10) Output: ([1, 1, 1], 0) enhanced_bogo_sort([3, 2, 1], 100000) Output: ([1, 2, 3], number_of_iterations) enhanced_bogo_sort([3, 2, 1], 1) Output: ([random_shuffle_state_of_array], 1) ``` **Constraints**: - The function should handle edge cases to ensure no infinite looping. - The number of iterations should be counted correctly and should not exceed `max_attempts`. **Performance Requirements**: - While infinite loops are wired into Bogo Sort\'s nature, the function must safeguard against it by utilizing `max_attempts`. - The solution should be well-constructed to handle any array size within the given constraints gracefully.","solution":"import random def is_sorted(arr): return all(arr[i] <= arr[i+1] for i in range(len(arr)-1)) def enhanced_bogo_sort(arr: list, max_attempts: int) -> tuple: if not arr: return (arr, 0) if all(x == arr[0] for x in arr): return (arr, 0) attempts = 0 while not is_sorted(arr) and attempts < max_attempts: random.shuffle(arr) attempts += 1 return (arr, attempts)"},{"question":"# Generate Abbreviations for a Given Word Context In certain applications such as text compression or game identifier generation, it is handy to have all possible abbreviations of a given word. You are asked to write a function that generates all possible abbreviations of an input string using a backtracking approach. Problem Statement Write a function `generate_abbreviations(word: str) -> List[str]` that takes a single string `word` and returns a list of all possible abbreviations of that word. **Input**: * A single string `word` (1 ≤ |word| ≤ 20) consisting of lowercase English letters. **Output**: * A list of strings, each being a possible abbreviation of `word`. Examples ``` generate_abbreviations(\\"word\\") # Expected output: [\\"word\\", \\"wor1\\", \\"wo1d\\", \\"wo2\\", \\"w1rd\\", \\"w1r1\\", \\"w2d\\", \\"w3\\", \\"1ord\\", \\"1or1\\", \\"1o1d\\", \\"1o2\\", \\"2rd\\", \\"2r1\\", \\"3d\\", \\"4\\"] generate_abbreviations(\\"a\\") # Expected output: [\\"a\\", \\"1\\"] generate_abbreviations(\\"\\") # Expected output: [] ``` Constraints * The function should handle input strings up to length 20 efficiently. * Pay special attention to edge cases such as single and empty strings. Notes 1. Do not import any additional libraries. 2. Think carefully about the recursive case: include the current character or replace it with a count. 3. Structuring your traversals with a helper function and managing backtracking correctly are key to solving this problem.","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: def backtrack(index: int, current: str, count: int): if index == len(word): if count > 0: current += str(count) res.append(current) return # Abbreviate the current character backtrack(index + 1, current, count + 1) # Keep the current character if count > 0: current += str(count) backtrack(index + 1, current + word[index], 0) res = [] backtrack(0, \'\', 0) return res"},{"question":"# Min Heap Implementation and Extended Functionality Context A min heap is a complete binary tree in which the value of each node is smaller than or equal to the values of its children. This property makes it a useful data structure for implementing priority queues, where the smallest element needs to be efficiently accessed and removed. You are provided with a `BinaryHeap` class in which the basic heap operations are defined. The task is to extend the functionality of this heap to answer additional queries efficiently. Task Implement a function `kth_smallest` that, given an integer `k`, returns the k-th smallest element in the heap. The heap will always contain at least `k` elements. **Input and Output** - Input to your function: * Integer `k` (1 ≤ k ≤ N), where `N` is the number of elements in the heap. - Output from your function: * Integer representing the k-th smallest element in the heap. Constraints 1. All the heap operations maintain the min-heap property. 2. The heap will not be modified outside of the operations you implement. 3. The default operations of the heap (`insert`, `remove_min`) work as intended. Example Suppose the heap contains the following elements: `[1, 3, 5, 7, 9, 11, 15, 20]`. ```python # BinaryHeap should already have `insert` and `remove_min` implemented. heap = BinaryHeap() elements = [1, 3, 5, 7, 9, 11, 15, 20] for elem in elements: heap.insert(elem) k = 3 print(heap.kth_smallest(k)) # Output should be 5 ``` Implementation Details 1. You may introduce any additional helper methods to the `BinaryHeap` class if needed. 2. Ensure the main operations in the heap such as `insert` and `remove_min` are not disrupted. 3. Aim for an efficient implementation with little overhead.","solution":"class BinaryHeap: def __init__(self): self.heap = [] def insert(self, elem): self.heap.append(elem) self._bubble_up(len(self.heap) - 1) def remove_min(self): if not self.heap: return None if len(self.heap) == 1: return self.heap.pop() min_elem = self.heap[0] self.heap[0] = self.heap.pop() self._bubble_down(0) return min_elem def _bubble_up(self, index): parent = (index - 1) // 2 while index > 0 and self.heap[index] < self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] index = parent parent = (index - 1) // 2 def _bubble_down(self, index): child = 2 * index + 1 while child < len(self.heap): if child + 1 < len(self.heap) and self.heap[child + 1] < self.heap[child]: child += 1 if self.heap[index] <= self.heap[child]: break self.heap[index], self.heap[child] = self.heap[child], self.heap[index] index = child child = 2 * index + 1 def kth_smallest(self, k): temp_heap = BinaryHeap() temp_heap.heap = self.heap[:] for _ in range(k - 1): temp_heap.remove_min() return temp_heap.remove_min()"},{"question":"# Question: Unique Character String Generator You are to write a function named `unique_characters` that takes a single string as input and returns a new string containing only the first occurrence of each character from the input string, in the order they first appear. * **Function Signature**: `def unique_characters(string: str) -> str` * **Input**: - A single string `string` which consists of characters (0 <= len(string) <= 10^6). * **Output**: - A string containing only the first occurrence of each character from the input string. # Constraints - The function should handle both uppercase and lowercase characters as distinct characters. - The function must execute in O(n) time and use O(n) additional space. # Examples ```python assert unique_characters(\\"programming\\") == \\"progamin\\" assert unique_characters(\\"aabbcc\\") == \\"abc\\" assert unique_characters(\\"Hello World!\\") == \\"Helo Wrd!\\" assert unique_characters(\\"ABCDEABCDE\\") == \\"ABCDE\\" assert unique_characters(\\"\\") == \\"\\" ``` # Notes - If the input string is empty, the output should also be an empty string. - Ensure your implementation efficiently handles strings up to length 10^6. Test edge cases such as strings with all unique characters, all duplicates, mixed-case characters, and all identical characters.","solution":"def unique_characters(string: str) -> str: Returns a new string containing only the first occurrence of each character from the input string, in the order they first appear. seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Problem Description You have been tasked to implement a function for measuring the similarity between two users\' preferences based on their activities. Each user\'s preferences are represented as a vector of activity counts, and you need to determine how similar these vectors are using cosine similarity. Objective Write a function `cosine_similarity(vec1, vec2)` that calculates the cosine similarity between two 1D lists `vec1` and `vec2`. Function Signature ```python def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: pass ``` Input and Output * **Inputs**: * `vec1`: List of floats representing the first vector. * `vec2`: List of floats representing the second vector. * **Output**: * Returns a float value which is the cosine similarity between the two vectors. Constraints: * Both vectors will be non-empty lists of the same length containing at least one element. * Each element in the vectors will be a float. Performance Requirements: Your implementation should efficiently handle vectors of up to (10^6) elements in length. Example ```python cosine_similarity([1, 1, 1], [1, 2, -1]) # output: 0.47140452079103173 cosine_similarity([4, 3, 0], [3, 7, 5]) # output: 0.6804138174397717 cosine_similarity([1, 2], [2, 4]) # output: 1.0 ``` Edge Cases 1. Implement handling for cases where the computed norms might be zero, leading to a division by zero. 2. The function should raise an error if the input vectors are not of the same length.","solution":"import math from typing import List def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length\\") dot_product = sum(x * y for x, y in zip(vec1, vec2)) norm_vec1 = math.sqrt(sum(x ** 2 for x in vec1)) norm_vec2 = math.sqrt(sum(y ** 2 for y in vec2)) if norm_vec1 == 0 or norm_vec2 == 0: raise ValueError(\\"One of the vectors has all zero values\\") return dot_product / (norm_vec1 * norm_vec2)"},{"question":"# Two Sum Problem Scenario Steve, a financial analyst, wants to write a program that helps him identify two transactions from different days that sum up to a specified target amount, allowing him to pinpoint the exact days of these transactions for auditing purposes. Objective Your task is to implement a function `two_sum` that takes an array of integers (`transactions`) and an integer (`target`) and returns the indices of two elements in the array that sum up to the target value. Each input is guaranteed to have exactly one solution, and you are not allowed to use the same element twice. Function Signature ```python def two_sum(transactions: List[int], target: int) -> Tuple[int, int]: ``` Inputs * `transactions` - a list of integers where each integer represents a transaction amount. * `target` - an integer representing the sum that we want to find from the array. Outputs * A tuple of two integers, representing the indices of the two elements in the transactions list that sum up to the target. Constraints * The function should run in O(n) time complexity. * The function should not use more than O(n) additional space. * Each element in the array is guaranteed to have one unique solution that sums to the target. Examples 1. `transactions = [2, 7, 11, 15]`, `target = 9` Output: `(0, 1)` 2. `transactions = [3, 2, 4]`, `target = 6` Output: `(1, 2)` 3. `transactions = [-1, -2, -3, -4, -5]`, `target = -8` Output: `(2, 4)` Edge Cases * `transactions = []`, `target = 0` - Expected to return `None` since there are no elements. * `transactions = [1]`, `target = 1` - Expected to return `None` since there must be at least two elements. Note Ensure to handle various edge cases and consider negative numbers and zero in your solution effectively.","solution":"from typing import List, Tuple, Optional def two_sum(transactions: List[int], target: int) -> Optional[Tuple[int, int]]: Find two indices in the transactions list such that their values sum up to the target. Args: transactions (List[int]): List of transaction amounts. target (int): The target sum to find in the transactions. Returns: Optional[Tuple[int, int]]: A tuple containing the indices of the two elements that sum up to the target, or None if no such indices exist. index_map = {} for i, num in enumerate(transactions): complement = target - num if complement in index_map: return (index_map[complement], i) index_map[num] = i return None"},{"question":"Scenario: You are tasked with writing a function to sort a list of integers using Selection Sort. Your implementation must also handle edge cases robustly and allow optional simulation of the sorting process for debugging and educational purposes. Objective: Implement a function `selection_sort` that sorts a given list of integers in ascending order using the Selection Sort algorithm. Additionally, if a parameter `simulation` is set to `True`, the function should print the array\'s state after each outer loop iteration, showing the progress of the sorting. Function Signature: ```python def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` Input: * `arr`: List of integers to be sorted. * `simulation`: Boolean flag indicating whether to simulate the sorting process by printing the array status. Output: * Returns a new list of sorted integers in ascending order. Constraints: * The input list size `n` can range from `0` to `1000`. * The integer values of the list elements will be in the range `-10^6` to `10^6`. Performance Requirements: * Time Complexity should be kept as O(n^2). * Space Complexity should be O(1), i.e., the algorithm should perform sorting in-place, although you\'re expected to return the list. Example: ```python arr = [64, 25, 12, 22, 11] sorted_arr = selection_sort(arr) print(sorted_arr) # Output should be: [11, 12, 22, 25, 64] # With simulation enabled: arr = [64, 25, 12, 22, 11] sorted_arr = selection_sort(arr, simulation=True) # Console Output: # iteration 0 : 11 25 12 22 64 # iteration 1 : 11 12 25 22 64 # iteration 2 : 11 12 22 25 64 # iteration 3 : 11 12 22 25 64 # iteration 4 : 11 12 22 25 64 print(sorted_arr) # Output should be: [11, 12, 22, 25, 64] ```","solution":"from typing import List def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: n = len(arr) for i in range(n): min_index = i for j in range(i+1, n): if arr[j] < arr[min_index]: min_index = j arr[i], arr[min_index] = arr[min_index], arr[i] if simulation: print(f\\"iteration {i} :\\", \\" \\".join(map(str, arr))) return arr"},{"question":"# Problem: You have been given an array of integers that need sorting. Write an efficient function to sort the array using the Comb Sort algorithm. The function should follow the principles and steps of Comb Sort as analyzed above. # Function Signature: ```python def comb_sort(arr: List[int]) -> List[int]: ``` # Input: * A list of integers `arr` where `1 <= len(arr) <= 10^5` * Integer elements in the array: `-10^9 <= arr[i] <= 10^9` # Output: * Return the list sorted in non-decreasing order. # Constraints: * Aim for a solution with O(n log n) average time complexity and O(1) space complexity. * Ensure that the implementation does not use additional space for another list or use built-in sort functions. # Scenario: You are assigned to work on a module for a system that processes large datasets for analytical purposes. The module deals with data arrays that need to be processed and analyzed in a specific order. The current Bubble Sort implementation is not efficient enough for the size of the datasets. Your task is to replace it with a more efficient sorting algorithm, Comb Sort, to improve the overall performance. # Example: ```python assert comb_sort([4, 3, 2, 5, 1]) == [1, 2, 3, 4, 5] assert comb_sort([10, 10, 1, 1, 10, 1]) == [1, 1, 1, 10, 10, 10] assert comb_sort([]) == [] assert comb_sort([5]) == [5] assert comb_sort([-1, -2, -3, -4, -5]) == [-5, -4, -3, -2, -1] ```","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts the array using the Comb Sort algorithm. def get_next_gap(gap): gap = (gap * 10) // 13 return max(1, gap) n = len(arr) gap = n swapped = True while gap > 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"You are tasked with designing an application that validates if a given string adheres to a specified pattern. The pattern is a string that consists of lowercase letters, and the input string consists of words separated by single spaces. The key requirement is that there should be a one-to-one mapping between letters in the pattern and the words in the input string. # Problem Statement Write a function `validate_word_pattern(pattern, text)` to check if the provided text follows the provided pattern. A bijection must exist between a letter in the pattern and a non-empty word in the text for it to be valid. Input Format * `pattern`: A string consisting only of lowercase letters. * `text`: A string of words separated by a single space, consisting only of lowercase letters. Output Format * Return `True` if the text follows the pattern. * Return `False` otherwise. Constraints * The pattern string consists of only lowercase letters (`a`-`z`). * The text string consists of lowercase words separated by single spaces. # Function Signature ```python def validate_word_pattern(pattern: str, text: str) -> bool: pass ``` # Example Scenarios **Example 1:** ```python pattern = \\"abba\\" text = \\"dog cat cat dog\\" print(validate_word_pattern(pattern, text)) # Output: True ``` **Example 2:** ```python pattern = \\"abba\\" text = \\"dog cat cat fish\\" print(validate_word_pattern(pattern, text)) # Output: False ``` **Example 3:** ```python pattern = \\"aaaa\\" text = \\"dog cat cat dog\\" print(validate_word_pattern(pattern, text)) # Output: False ``` **Example 4:** ```python pattern = \\"abba\\" text = \\"dog dog dog dog\\" print(validate_word_pattern(pattern, text)) # Output: False ``` # Notes * A pattern cannot map to the same word more than once. * Ensure that the lengths of the pattern and the list of words match before attempting to create any mappings. # Implementation Tips * Use a dictionary to keep a mapping of pattern characters to words. * Use a set to track already mapped words to ensure the bijection property is maintained.","solution":"def validate_word_pattern(pattern: str, text: str) -> bool: Returns True if text follows the given pattern, otherwise False. words = text.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for p_char, word in zip(pattern, words): if p_char in char_to_word: if char_to_word[p_char] != word: return False else: if word in word_to_char: if word_to_char[word] != p_char: return False char_to_word[p_char] = word word_to_char[word] = p_char return True"},{"question":"# Bucket Sort Challenge **Context**: You are given a sequence of numbers that needs to be sorted. To efficiently handle a uniformly distributed dataset, you decide to use the bucket sort algorithm. However, the bucket sort implementation must be flexible enough to handle different internal sorting mechanisms. **Problem Statement**: Implement a function `bucket_sort` that sorts a given list of integers using the bucket sort algorithm and `insertion_sort` as an inner sorting mechanism for the individual buckets. **Function Signature**: ```python def bucket_sort(arr: List[int]) -> List[int]: ``` **Input**: * `arr` - A list of non-negative integers. (0 <= len(arr) <= 10^4). Values in arr will not exceed 10^4. **Output**: * Returns a list of sorted non-negative integers. **Constraints**: * You should handle empty input correctly. * Optimize the sorting mechanism inside the buckets as needed. **Key Points**: 1. Divide the list into several buckets. 2. Distribute elements into these buckets based on their value. 3. Sort each bucket using insertion sort. 4. Concatenate sorted buckets to form the final sorted list. Provide a solution that is well-commented and efficient under the given constraints. Consider various edge cases and performance improvements where applicable. Here is a template: ```python from typing import List def bucket_sort(arr: List[int]) -> List[int]: # Steps: # 1. Setup buckets # 2. Distribute elements to buckets # 3. Sort each bucket using insertion_sort # 4. Concatenate sorted buckets and return the result num_buckets = len(arr) if num_buckets <= 1: return arr max_val = max(arr) min_val = min(arr) bucket_range = max_val - min_val + 1 buckets = [[] for _ in range(num_buckets)] for value in arr: index = (value - min_val) * num_buckets // bucket_range buckets[index].append(value) def insertion_sort(arr: List[int]) -> List[int]: for i in range(1, len(arr)): j = i - 1 key = arr[i] while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr sorted_arr = [] for bucket in buckets: sorted_arr.extend(insertion_sort(bucket)) return sorted_arr ``` Test the function with several edge cases including empty arrays, arrays with a single element, identical elements, and naturally sorted arrays.","solution":"from typing import List def bucket_sort(arr: List[int]) -> List[int]: Perform bucket sort on a list of non-negative integers using insertion sort for individual buckets. if len(arr) == 0: return arr # Determine minimum and maximum values min_value = min(arr) max_value = max(arr) # Number of buckets bucket_count = len(arr) if bucket_count == 1: return arr # Create buckets buckets = [[] for _ in range(bucket_count)] # Spread elements into buckets interval = (max_value - min_value) / bucket_count for value in arr: index = int((value - min_value) // (interval + 1e-6)) # Avoid rounding issues buckets[index].append(value) # Sort each bucket using insertion sort def insertion_sort(bucket: List[int]) -> List[int]: for i in range(1, len(bucket)): key = bucket[i] j = i - 1 while j >= 0 and bucket[j] > key: bucket[j + 1] = bucket[j] j -= 1 bucket[j + 1] = key return bucket sorted_arr = [] for bucket in buckets: sorted_arr.extend(insertion_sort(bucket)) return sorted_arr"},{"question":"# Flattening Nested Arrays You are given a multi-dimensional array which may contain nested arrays up to infinite depth. Your task is to write a function `flatten_array` that flattens the nested array structure into a single-dimensional list. Function Signature: ```python def flatten_array(input_arr: List[Any]) -> List[Any]: pass ``` # Input: - `input_arr`: A list which can contain nested lists. # Output: - A list containing all elements from the input array, in a flat structure. # Example: **Input**: ```python input_arr = [1, [2, 3, [4, 5]], 6, [7, [8, [9, 10]]]] ``` **Output**: ```python [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ``` # Constraints: - Elements within the lists are non-iterable data types (integers, strings, etc.) or nested lists. - Lists can be nested to an arbitrary depth. # Additional Requirements: - Your implementation should handle deeply nested structures gracefully. - Avoid hitting the maximum recursion depth in Python; consider alternative approaches. # Hints: - Consider using an iterative solution with a stack or queue to avoid recursion depth limits. # Testing: Make sure your function is tested on: 1. Shallowly nested arrays. 2. Deeply nested arrays. 3. Edge cases like empty arrays or arrays with single elements. 4. Arrays containing different data types (integers, strings). Good luck!","solution":"from typing import List, Any def flatten_array(input_arr: List[Any]) -> List[Any]: result = [] stack = [input_arr] while stack: current = stack.pop() if isinstance(current, list): stack.extend(current[::-1]) else: result.append(current) return result"},{"question":"**Merge k Sorted Linked Lists** # Context You are working on a large-scale data processing system where multiple data streams provide sorted datasets. You must merge these sorted datasets into one single sorted list for further processing. # Task Write a function to merge k sorted linked lists and return the resulting sorted linked list. Each linked list is sorted in ascending order. # Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists: List[ListNode]) -> ListNode: ``` # Input - `lists`: A list of `k` sorted linked lists represented by their head nodes. Each linked list is of class `ListNode`. # Output - The head node of the merged sorted linked list. # Examples ```python # Example 1: list1 = ListNode(1, ListNode(4, ListNode(5))) list2 = ListNode(1, ListNode(3, ListNode(4))) list3 = ListNode(2, ListNode(6)) lists = [list1, list2, list3] # Expected Output: 1->1->2->3->4->4->5->6 merged_head = merge_k_lists(lists) ``` ```python # Example 2: lists = [] # Expected Output: None (or equivalent empty list representation) merged_head = merge_k_lists(lists) ``` ```python # Example 3: lists = [None] # Expected Output: None (or equivalent empty list representation) merged_head = merge_k_lists(lists) ``` # Constraints * The number of linked lists `k` is in the range [0, 10^4]. * The total number of nodes across all linked lists is in the range [0, 10^5]. * Each linked list is already sorted in ascending order. * The ListNode class is provided and should not be modified. # Performance Requirements * Your solution should be optimized for both time and space complexity, especially considering the high upper bounds for k and the total number of nodes. Guidelines: - Use a priority queue (or min-heap) for efficient merging. - Handle edge cases, such as empty lists or lists with only one element. Good luck, and make sure to test thoroughly!","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: min_heap = [] # Initialize the heap with the head nodes of each linked list for i, node in enumerate(lists): if node: heapq.heappush(min_heap, (node.val, i, node)) # Create a dummy head for the merged linked list dummy = ListNode() current = dummy # Extract the smallest element from the heap and add the next node from that list to the heap while min_heap: val, i, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, i, node.next)) return dummy.next"},{"question":"Subsets Generation Problem Statement: Given a list of distinct integers, `nums`, write a function that returns all possible subsets (the power set). The solution set must not contain duplicate subsets. The order of subsets within the solution does not matter, but the order of elements within each subset must be in non-descending order. Function Signature: ```python def subsets(nums: List[int]) -> List[List[int]]: ``` Input: * A list `nums` of distinct integers (`1 <= len(nums) <= 10`, `-10 <= nums[i] <= 10`). Output: * A list of lists, where each list is a subset of `nums`. Example: ```python Input: nums = [1, 2, 3] Output: [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] ``` Constraints: 1. The returned subsets must not contain duplicates. 2. Subsets should be sorted in non-descending order internally. Notes: * You can use either a backtracking approach or an iterative approach for implementation. * Ensure to handle edge cases, such as an empty input list. Performance Requirements: The implementation should aim to have a time complexity of O(2^n) and space complexity optimized according to the chosen approach.","solution":"from typing import List def subsets(nums: List[int]) -> List[List[int]]: Returns all possible subsets of a list of distinct integers. nums.sort() result = [] def backtrack(start: int, path: List[int]): result.append(path[:]) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() backtrack(0, []) return result"},{"question":"# Generate All Possible Subsets You are given a set of distinct integers. Your task is to write a Python function that returns all possible subsets of the given set. The solution set must not contain duplicate subsets, and the order of subsets does not matter. Function Signature ```python def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: pass ``` Input * `nums`: A list of distinct integers `1 <= len(nums) <= 15`. Output * A set of tuples representing all possible subsets. Each subset must be represented as a tuple sorted in ascending order. Constraints * The elements within subsets should be sorted in ascending order. * The empty subset must be included in the output. Scenario Imagine you are developing a feature for a combinatorial analysis tool. The tool needs to consider all possible combinations (subsets) of a given set of integers to analyze trends and patterns. Example ```python # Example 1 nums = [1, 2, 3] output = { (), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3) } # Example 2 nums = [4, 5] output = { (), (4,), (5,), (4, 5) } ``` Note The function should aim to be efficient with respect to both time and space complexity, considering the constraint on `n`.","solution":"from typing import List, Set, Tuple from itertools import combinations def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: Generates all possible subsets of a given list of integers. Args: nums: A list of distinct integers. Returns: A set of tuples, each tuple representing a subset of the input list. subsets = set() # Iterate over all possible lengths of subsets from 0 to len(nums) for subset_len in range(len(nums) + 1): for subset in combinations(nums, subset_len): subsets.add(tuple(sorted(subset))) return subsets"},{"question":"# Nearest Neighbor Classification In machine learning, the nearest neighbor algorithm is a simple, yet effective, method for classifying objects. This problem will test your understanding and implementation of the nearest neighbor classification algorithm. # Task Write a function `improved_nearest_neighbor(x, tSet)` that classifies a given vector `x` by finding the nearest vector in the training set `tSet` using the Manhattan distance instead of the Euclidean distance. # Definitions * The **Manhattan distance** between two vectors ( x ) and ( y ) of dimension ( n ) is defined as: [ D_{text{Manhattan}}(x, y) = sum_{i=1}^{n} |x_i - y_i| ] # Input * `x` : A tuple of numerical values representing the input vector. * `tSet` : A dictionary where the keys are tuples (each representing a vector) and the values are the labels/classes corresponding to these vectors. # Output * The function should return the label of the nearest neighbor as per the Manhattan distance. # Constraints * Each vector in `tSet` and the input vector `x` will have the same length. * Vector lengths will be between 1 and 1000 inclusive. * The training set `tSet` will contain at least one vector and can have up to 10,000 vectors. * Components of the vectors are real numbers. # Example ```python def improved_nearest_neighbor(x, tSet): # Your code here x = (1, 2) tSet = { (2, 3): \'A\', (4, 5): \'B\', (1, 1): \'C\' } print(improved_nearest_neighbor(x, tSet)) # Output: \'C\' ``` # Explanation In the given example, calculating the Manhattan distance between the input vector `x = (1, 2)` and each vector in `tSet` yields: * Distance to (2, 3) is `1 + 1 = 2` * Distance to (4, 5) is `3 + 3 = 6` * Distance to (1, 1) is `0 + 1 = 1` Thus, the nearest neighbor is (1, 1) with the label \'C\'.","solution":"def improved_nearest_neighbor(x, tSet): Given a vector x and a training set tSet, classify x by finding the nearest vector using the Manhattan distance. Parameters: x (tuple): The input vector to classify. tSet (dict): The training set with vectors as keys and their corresponding labels as values. Returns: str: The label of the nearest neighbor in the training set. def manhattan_distance(a, b): return sum(abs(ai - bi) for ai, bi in zip(a, b)) nearest_neighbor = None minimum_distance = float(\'inf\') for vector, label in tSet.items(): distance = manhattan_distance(x, vector) if distance < minimum_distance: minimum_distance = distance nearest_neighbor = label return nearest_neighbor"},{"question":"# Nearest Neighbor Classifier Implementation You are tasked with implementing a nearest neighbor classifier. The classifier should be capable of determining the nearest neighbor from a training dataset based on the Euclidean distance metric and returning the label associated with the nearest neighbor. Your solution should handle edge cases and perform efficiently for reasonably sized datasets. Function Signature ```python def nearest_neighbor_classifier(x: Tuple[float, ...], training_set: Dict[Tuple[float, ...], int]) -> int: Given an input vector `x`, and a training set represented as a dictionary with vectors as keys and their corresponding classification labels as values, return the label of the nearest neighbor. Args: x: Tuple[float, ...] - An input vector. training_set: Dict[Tuple[float, ...], int] - A dictionary where the keys are vectors (Tuples of floats) and the values are labels (integers). Returns: int - The label of the nearest neighbor. ``` Input - `x`: A tuple of floats representing an input vector. - `training_set`: A dictionary where keys are tuples of floats (vectors) and values are associated integer labels. Output - An integer which is the label of the vector in the training set that is closest to `x` based on the Euclidean distance. Constraints - The length of `x` will match the length of each key in the training set. - All values in the vectors are floating-point numbers. - The training set size will be between 1 and 10,000 vectors. Requirements - Handle edge cases such as empty training sets and ensure robust error handling. - The implementation should have a time complexity of O(n * m) where n is the number of training vectors and m is the dimensionality of the vectors. Example ```python x = (1.0, 2.0) training_set = { (0.0, 0.0): 0, (1.0, 2.5): 1, (2.0, 2.0): 2 } assert nearest_neighbor_classifier(x, training_set) == 1 ```","solution":"from typing import Tuple, Dict import math def euclidean_distance(v1: Tuple[float, ...], v2: Tuple[float, ...]) -> float: Calculate the Euclidean distance between two vectors. return math.sqrt(sum((a - b) ** 2 for a, b in zip(v1, v2))) def nearest_neighbor_classifier(x: Tuple[float, ...], training_set: Dict[Tuple[float, ...], int]) -> int: if not training_set: raise ValueError(\\"The training set is empty.\\") nearest_label = None min_distance = float(\'inf\') for vector, label in training_set.items(): distance = euclidean_distance(x, vector) if distance < min_distance: min_distance = distance nearest_label = label return nearest_label"},{"question":"# Question: Custom String-based Multiplication Given two non-negative integers `num1` and `num2` represented as strings, implement a function to return the product of `num1` and `num2` as a string. You must not use any built-in BigInteger libraries or convert the inputs to integers directly. Expected Input and Output - **Input**: - Two strings `num1` and `num2` representing non-negative integers. - Conditions: The length of both strings is less than 110 digits and they do not contain any leading zeros. - **Output**: - A string representing the product of `num1` and `num2`. Example ```python multiply(\\"123\\", \\"456\\") # should return \\"56088\\" multiply(\\"2\\", \\"3\\") # should return \\"6\\" multiply(\\"0\\", \\"10\\") # should return \\"0\\" ``` Constraints: - The input strings contain only the digits 0-9. - Neither inputs have leading zeros except when the input is \\"0\\". Performance Requirements - Your solution should not exceed O(n * m) in time complexity. - Keep space usage optimal, but sufficient to handle interim calculations. Scenario: Imagine building a calculator application where multiplication needs to be handled securely and independently without leveraging high-level language features or libraries that abstract away underlying operations. This function is critical in ensuring your application can handle large numbers precisely in such a scenario. Implement your function below: ```python def multiply(num1: str, num2: str) -> str: # Implement your code here ```","solution":"def multiply(num1: str, num2: str) -> str: # Initialize a result list with zeros. n, m = len(num1), len(num2) result = [0] * (n + m) # Reverse the input strings to facilitate the multiplication. num1, num2 = num1[::-1], num2[::-1] # Multiply each digit and add the results to the final result. for i in range(n): for j in range(m): result[i + j] += int(num1[i]) * int(num2[j]) # Carry to the next position. result[i + j + 1] += result[i + j] // 10 result[i + j] %= 10 # Remove leading zeros and convert the result list to a string. while len(result) > 1 and result[-1] == 0: result.pop() return \'\'.join(map(str, result[::-1]))"},{"question":"Question: As part of your role at a software testing firm, you are tasked with verifying the integrity and order of task sequences maintained on a stack. Your task is to implement a function `are_tasks_sorted` that checks if the tasks (represented as integers) in a stack are sorted in ascending order from bottom to top. Function Specification: ```python def are_tasks_sorted(stack) -> bool: This function takes a stack as input and returns True if the tasks in the stack are sorted in ascending order from bottom to top, otherwise returns False. ``` Input: * A list representing an integer stack `stack`. The stack\'s top is the last element in the list. - **Example**: `[1, 2, 3, 4, 5]` represents a stack with `1` at the bottom and `5` at the top. Output: * A boolean value: - `True` if the elements are sorted in ascending order from bottom to top. - `False` otherwise. Constraints: * The input list (stack) will contain no more than 10^4 elements. * Each element will be an integer in the range of -10^6 to 10^6. Additional Requirements: * The function should have a time complexity of O(n) and space complexity of O(n), where n is the number of elements in the stack. * Preserve the original order and elements of the input stack. Example: ```python tasks1 = [1, 2, 3, 4, 5] print(are_tasks_sorted(tasks1)) # Output: True tasks2 = [5, 1, 3, 4, 2] print(are_tasks_sorted(tasks2)) # Output: False ``` Note: When testing, ensure that the original stack provided as input to the function remains unchanged after execution.","solution":"def are_tasks_sorted(stack) -> bool: This function takes a stack as input and returns True if the tasks in the stack are sorted in ascending order from bottom to top, otherwise returns False. # Create a copy of the stack to preserve the original stack order stack_copy = stack[:] while len(stack_copy) > 1: top = stack_copy.pop() if top < stack_copy[-1]: return False return True"},{"question":"# Red-Black Tree Insertion and Fixup Implement a function to insert a node into a Red-Black Tree and fix any property violations to maintain the tree\'s balance and properties. Function Signature ```python class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red class RBTree: def __init__(self): self.root = None def insert(self, value: int) -> None: Inserts a value into the Red-Black Tree and fixes any violations. Parameters: value (int): The value to be inserted into the tree. Returns: None # Your code here # Complete the other necessary methods and use them in the insert method. ``` Input - A single integer `value` which is the value of the new node to be inserted. Output - This function does not need to return anything. It should modify the tree structure to insert the new node and ensure the tree maintains its Red-Black properties. Constraints - Implement the Red-Black Tree insertion mentioned in the provided code. - After insertion, the new node should be inserted while preserving the Red-Black Tree properties. Example 1. Create an instance of RBTree. 2. Insert values [11, 2, 14, 1, 7, 15, 5, 8, 4]. 3. Perform an in-order traversal of the tree to check if the values are as expected and the Red-Black properties are maintained. Example Execution ```python rb = RBTree() values = [11, 2, 14, 1, 7, 15, 5, 8, 4] for value in values: rb.insert(value) assert rb.inorder() == expected_inorder ``` You should validate the tree\'s in-order traversal result to ensure the Red-Black Tree properties are preserved.","solution":"class RBNode: def __init__(self, val, is_red=True, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red # True for red, False for black class RBTree: def __init__(self): self.TNULL = RBNode(0, is_red=False) # Sentinel node self.root = self.TNULL def insert(self, value: int) -> None: new_node = RBNode(value) new_node.left = self.TNULL new_node.right = self.TNULL y = None x = self.root while x != self.TNULL: y = x if new_node.val < x.val: x = x.left else: x = x.right new_node.parent = y if y is None: self.root = new_node elif new_node.val < y.val: y.left = new_node else: y.right = new_node if new_node.parent == None: new_node.color = False return if new_node.parent.parent == None: return self.fix_insert(new_node) def fix_insert(self, k): while k != self.root and k.parent.color: if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color: u.color = False k.parent.color = False k.parent.parent.color = True k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = False k.parent.parent.color = True self.left_rotate(k.parent.parent) else: u = k.parent.parent.right if u.color: u.color = False k.parent.color = False k.parent.parent.color = True k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = False k.parent.parent.color = True self.right_rotate(k.parent.parent) if k == self.root: break self.root.color = False def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def inorder_helper(self, node, res): if node != self.TNULL: self.inorder_helper(node.left, res) res.append(node.val) self.inorder_helper(node.right, res) def inorder(self): res = [] self.inorder_helper(self.root, res) return res"},{"question":"# Question: Binary Tree In-order Traversal with Level Information Given a binary tree, write a function `inorder_with_level(root)` to perform an in-order traversal of the tree. Unlike standard in-order traversal, this function should also return the depth level of each node. # Function Signature: ```python def inorder_with_level(root): # your code here ``` # Input: * `root` - The root node of a binary tree, where each node is an instance of the class `Node` provided below. # Output: * A list of tuples, where each tuple has two elements: * The value of the node. * The depth level of the node (root node being at depth 0). # Constraints: * Depth might be large, so an iterative solution is preferred to avoid stack overflow. # Example: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder_with_level(root): # your code here if __name__ == \'__main__\': n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 result = inorder_with_level(n1) print(result) ``` Given the tree in the example, the output should be: ``` [(25, 2), (50, 1), (75, 2), (100, 0), (125, 2), (150, 1), (175, 2)] ``` # Note: * Please handle edge cases such as an empty tree or a single-node tree. * Optimize your code to avoid any potential performance bottlenecks.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder_with_level(root): Perform an in-order traversal of the binary tree and return the node values with their corresponding depth level. if root is None: return [] result = [] stack = [(root, 0)] while stack: node, level = stack.pop() if node: if node.right: stack.append((node.right, level + 1)) stack.append((node, level)) # Add the node back to process its value later stack.append((None, level)) # Add a placeholder for the left node if node.left: stack.append((node.left, level + 1)) else: node, level = stack.pop() # Pop again to get the original node result.append((node.val, level)) return result"},{"question":"# Objective Write a function to compute the height of a binary tree. The height of the tree is defined as the number of levels or the depth of the deepest node. The provided tree will always be a Binary Search Tree (BST). # Function Signature ```python def height(root): ``` # Input * `root`: The root node of a Binary Search Tree (BST). # Output * Returns an integer representing the height of the tree. # Constraints * The tree is composed of nodes with integer values. * It is guaranteed that the tree will not contain cycles (i.e., it is a well-formed BST). # Performance Requirements * Time Complexity: O(n), where n is the number of nodes in the tree. * Space Complexity: O(h), where h is the height of the tree (this corresponds to the depth of the recursive call stack). # Example Given the BST: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` The function should return `4` because the longest path from the root node to any leaf node (9->12->15->18) has 4 levels. # Implementation Details - Ensure your function handles the base case of an empty tree by returning `0`. - Implement the solution using a recursive approach as illustrated in the code snippets provided in the prompt. # Unit Tests Implement unit tests to verify your function with different tree structures, including edge cases such as an empty tree, single node tree, and fully balanced tree. ```python import unittest class TestHeightFunction(unittest.TestCase): def setUp(self): self.tree = bst() self.tree.insert(9) self.tree.insert(6) self.tree.insert(12) self.tree.insert(3) self.tree.insert(8) self.tree.insert(10) self.tree.insert(15) self.tree.insert(7) self.tree.insert(18) def test_height(self): self.assertEqual(4, height(self.tree.root)) def test_empty_tree(self): empty_tree = bst() self.assertEqual(0, height(empty_tree.root)) def test_single_node(self): single_node_tree = bst() single_node_tree.insert(10) self.assertEqual(1, height(single_node_tree.root)) if __name__ == \'__main__\': unittest.main() ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def height(root): Return the height of a binary tree. :param root: TreeNode - root of the binary tree :return: int - height of the tree if not root: return 0 left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"# Question: Implement an Optimized Matrix Exponentiation Function You are given a function `matrix_exponentiation` that raises a square matrix to an integer power using repeated squaring, but it suffers in performance for very high powers due to redundant multiplications. Your task is to optimize the matrix exponentiation by implementing memoization to store intermediate results and avoid repeated calculations. Function Signature ```python def optimized_matrix_exponentiation(mat: list, n: int, memo: dict = None) -> list: Raises the matrix \'mat\' to the power \'n\' using optimized repeated squaring. Parameters: mat (list): A 2D list representing the matrix. n (int): The exponent to which the matrix is raised. memo (dict): A dictionary to store intermediate results for memoization. Defaults to None. Returns: list: The result matrix after exponentiation. pass ``` Input * `mat`: A 2D list of integers, representing an n x n matrix (1 <= n <= 100) * `n`: A non-negative integer (0 <= n <= 10^9) Output * A 2D list of integers representing the resulting matrix after raising `mat` to the power `n`. Constraints and Performance * Aim for a solution that leverages memoization to improve efficiency. * Handle large values of n effectively without redundant computations. * Ensure to handle the case where n is zero by returning an identity matrix of appropriate size. Example ```python # Example usage mat = [ [1, 2], [3, 4] ] n = 3 print(optimized_matrix_exponentiation(mat, n)) # Expected output (might vary based on the exact implementation): # [ # [37, 54], # [81, 118] # ] ``` Notes * You will find the `multiply` and `identity` functions defined previously useful for implementing this algorithm. * Ensure thorough validation and performance testing, especially for very high values of `n`.","solution":"def multiply(mat1, mat2): Multiplies two matrices mat1 and mat2. size = len(mat1) result = [[0] * size for _ in range(size)] for i in range(size): for j in range(size): for k in range(size): result[i][j] += mat1[i][k] * mat2[k][j] return result def identity(size): Returns an identity matrix of given size. return [[1 if i == j else 0 for j in range(size)] for i in range(size)] def optimized_matrix_exponentiation(mat, n, memo=None): Raises the matrix \'mat\' to the power \'n\' using optimized repeated squaring. Parameters: mat (list): A 2D list representing the matrix. n (int): The exponent to which the matrix is raised. memo (dict): A dictionary to store intermediate results for memoization. Defaults to None. Returns: list: The result matrix after exponentiation. if memo is None: memo = {} size = len(mat) if n == 0: return identity(size) if n == 1: return mat if n in memo: return memo[n] if n % 2 == 0: half_pow = optimized_matrix_exponentiation(mat, n // 2, memo) memo[n] = multiply(half_pow, half_pow) else: half_pow = optimized_matrix_exponentiation(mat, n // 2, memo) memo[n] = multiply(multiply(half_pow, half_pow), mat) return memo[n]"},{"question":"Context You are working with a program that processes a series of linked lists representing different data sets. One of your tasks is to ensure that each linked list contains unique values by removing any duplicates. Task Write a function `remove_duplicates_combined(head)` that removes duplicates from a singly linked list. The function should adapt dynamically: if the list contains fewer than 10 nodes, it should use the in-place removal method with O(1) space complexity. Otherwise, it should use the hash set based removal method to run in O(N) time. Function Signature: ```python def remove_duplicates_combined(head: Node) -> None: Remove duplicates from the linked list based on the list size. Parameters: head (Node): The head of the linked list Returns: None: Modifies the linked list in place. ``` Input - `head`: The head node of a singly linked list where each node contains a string value. Output - The function modifies the linked list in place to remove duplicates. It does not return any value. Constraints - Node values: Only uppercase alphabetic characters (\\"A\\" to \\"Z\\") - Node count: 0 <= number of nodes <= 1000 Example - Input: `A -> A -> B -> C -> D -> C -> F -> G` - Output: `A -> B -> C -> D -> F -> G` Notes - Aim to handle edge cases such as empty lists and lists with all identical elements. - Ensure the solution is efficient considering both time and space complexities.","solution":"class Node: def __init__(self, val: str): self.val = val self.next = None def remove_duplicates_combined(head: Node) -> None: Remove duplicates from the linked list based on the list size. Parameters: head (Node): The head of the linked list if not head: return # Calculate the length of the linked list length = 0 current = head while current: length += 1 current = current.next if length < 10: # Use in-place removal method with O(1) space complexity current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next else: # Use the hash set based removal method to run in O(N) time seen = set() current = head prev = None while current: if current.val in seen: prev.next = current.next else: seen.add(current.val) prev = current current = current.next"},{"question":"**Comb Sort Implementation and Optimization** You are required to implement and optimize the Comb Sort algorithm. Comb Sort is an enhancement over Bubble Sort which improves the sorting process by eliminating small values positioned towards the end of the list before starting more local, smaller gaps akin to Bubble Sort. Your Task 1. Implement the Comb Sort algorithm in Python using the provided skeleton. 2. Optimize the algorithm by dynamically adjusting the gap calculation based on initial disorder in the list. 3. Assess the performance improvement of your optimized sort compared to standard Comb Sort. Function Signature ```python def optimized_comb_sort(arr): # Your optimized code goes here pass ``` Input * A list of integers, `arr`, where (1 leq len(arr) leq 10^5). Output * The list of integers sorted in ascending order. Example ```python input: [5, 3, 7, 2, 8, 1, 4, 6] output: [1, 2, 3, 4, 5, 6, 7, 8] ``` Constraints * Your solution should not exceed (O(N^2)) in the worst case but should aim to be closer to (O(N log N)) in practice. * Utilize efficient gap calculation techniques to improve overall runtime. * Optimize the code for clarity and conciseness while maintaining readability.","solution":"def optimized_comb_sort(arr): Comb Sort algorithm which is an optimized version of Bubble Sort. It uses a gap sequence to reduce the overall comparisons. def get_next_gap(gap): # Shrinks the gap by the shrink factor gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: # Update the gap for the next comb gap = get_next_gap(gap) # Initialize swapped as false so that we can check if a swap happened or not swapped = False # Compare elements with a gap and swap if needed for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Question You are given an array of integers `arr`. Implement a function `custom_counting_sort(arr)` that sorts `arr` using the Counting Sort algorithm. The function should account for possible negative values and work efficiently. # Function Signature ```python def custom_counting_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: A list of integers (both positive and negative) including duplicates, with a maximum element `max(arr)` no greater than 10**6, and minimum element `min(arr)` no less than -10**6. # Output - A list of integers sorted in non-decreasing order. # Constraints - You may assume that `arr` has at least one element and the length of `arr` will not exceed 10^6. # Examples ```python assert custom_counting_sort([4, 2, -3, 0, 2, -5, 4]) == [-5, -3, 0, 2, 2, 4, 4] assert custom_counting_sort([3, 1, 2, 3, -1, -2, 0]) == [-2, -1, 0, 1, 2, 3, 3] assert custom_counting_sort([5]) == [5] ``` # Important Notes - Your implementation must handle negative numbers correctly. - Think about the edge cases mentioned in the analysis above. - It is expected that your solution will run in O(n+k) time complexity, where n is the number of elements in `arr` and k is the range of the input values.","solution":"from typing import List def custom_counting_sort(arr: List[int]) -> List[int]: if not arr: return [] # Find the minimum and maximum values in the array min_val = min(arr) max_val = max(arr) # Create the count array with a size based on the range of input values range_of_elements = max_val - min_val + 1 count = [0] * range_of_elements # Initialize the output array output = [0] * len(arr) # Store the count of each element in the count array for num in arr: count[num - min_val] += 1 # Modify the count array such that each element at each index # stores the sum of previous counts. This means count[i] now contains # the actual position of this element in the output array. for i in range(1, len(count)): count[i] += count[i - 1] # Build the output character array for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"**Scenario**: You\'ve been hired by a software company to improve the performance of their data processing pipeline. Currently, they are using a simple bubble sort algorithm, which has proven inefficient for some datasets. You have decided to implement the Cocktail Shaker Sort, which is a more optimized version for certain cases. **Task**: Write a function `cocktail_shaker_sort(arr)` that accepts a list of integers or floats and sorts it in ascending order using the Cocktail Shaker Sort algorithm. Your function should return the sorted list. Optimize your implementation to detect if the array becomes sorted early and minimize additional passes. **Function Signature**: ```python def cocktail_shaker_sort(arr: List[Union[int, float]]) -> List[Union[int, float]] ``` **Input/Output Description**: * **Input**: A list of integers or floats. Example: `arr = [3, 1, 2, 5, 4]` * **Output**: A sorted list in ascending order. Example: `[1, 2, 3, 4, 5]` **Constraints**: * Do not use built-in sorting functions. * The input list can contain negative numbers. * Ensure best possible performance within the given O(N^2) complexity. **Performance Requirements**: * Optimize to detect sorted arrays early and minimize unnecessary passes. * Ensure the function handles edge cases smoothly, like: * An empty list `[]`. * A list with a single element `[42]`. * Already sorted lists `[1, 2, 3, 4, 5]`. **Example**: ```python assert cocktail_shaker_sort([3, 1, 2, 5, 4]) == [1, 2, 3, 4, 5] assert cocktail_shaker_sort([10, -1, 4, 6, 3, -5]) == [-5, -1, 3, 4, 6, 10] assert cocktail_shaker_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert cocktail_shaker_sort([]) == [] assert cocktail_shaker_sort([42]) == [42] ``` Your task is to implement the function `cocktail_shaker_sort`.","solution":"def cocktail_shaker_sort(arr): Performs the cocktail shaker sort on the input list and returns the sorted list. if not arr: return arr n = len(arr) swapped = True start = 0 end = n - 1 while swapped: swapped = False # Traverse the array from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If nothing moved, then the array is sorted if not swapped: break # Otherwise, reset the swapped flag so we can track the next phase swapped = False # Move the end point back by one, since the last item is already sorted end -= 1 # Traverse the array from right to left for i in range(end - 1, start - 1, -1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # Move the start point forward by one, since the first item is in its right place start += 1 return arr"},{"question":"# Scenario Suppose you are tasked with analyzing the structure of various binary trees to understand better and document how they spread out in terms of left and right children. Such structure analysis may be crucial for optimizing tree-related algorithms or ensuring balanced tree operations. # Objective You need to implement a feature that counts all the nodes in a given binary tree that are left children of their parent nodes. # Function Signature ```python def count_left_node(root: Node) -> int: ``` # Input - A single argument `root`, which is the root node of a binary tree. # Output - An integer value representing the number of left children in the tree. # Constraints - The tree has at most (10^4) nodes. - Node values are integers, but the exact values do not affect the left count functionality. - The tree is well-formed and adheres to standard binary tree properties. # Example ```plaintext Tree: 9 / 6 12 / / 3 8 10 15 / 7 18 Expected Output: 4 ``` # Notes Focus on optimal traversal and efficient counting without modifying the tree structure or using excessive space. Handling the recursion stack delicately for deep trees is crucial. # Test Cases 1. A balanced tree with multiple levels of left children. 2. A skewed tree with only left children (a single line of nodes to the left). 3. A tree with equal nodes on both sides but none on the left children. 4. An empty tree (should return 0). 5. A single-node tree (should return 0). Your implementation should pass these provided unit tests to confirm its correctness. ```python import unittest from bst import Node, bst class TestSuite(unittest.TestCase): def setUp(self): self.tree = bst() self.tree.insert(9) self.tree.insert(6) self.tree.insert(12) self.tree.insert(3) self.tree.insert(8) self.tree.insert(10) self.tree.insert(15) self.tree.insert(7) self.tree.insert(18) def test_count_left_node(self): self.assertEqual(4, count_left_node(self.tree.root)) if __name__ == \'__main__\': unittest.main() ``` Begin your implementation by ensuring edge cases and the usual binary tree properties are covered.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def count_left_node(root: Node) -> int: Counts all the nodes in a given binary tree that are left children of their parent nodes. :param root: Root node of the binary tree. :return: Integer count of left children. if root is None: return 0 # Helper recursive function to count left children def count_left_helper(node: Node, is_left: bool) -> int: if node is None: return 0 left_count = count_left_helper(node.left, True) right_count = count_left_helper(node.right, False) # If this node is a left child, increment the count by 1 if is_left: return 1 + left_count + right_count else: return left_count + right_count # Root node is not a left child, starts with False return count_left_helper(root, False)"},{"question":"You are given a pattern string consisting of lowercase letters and a string of words separated by single spaces. Your task is to determine if the given string of words follows the pattern of the given pattern string. This means that there must be a one-to-one correspondence between the characters in the pattern and the words in the string. # Function Signature ```python def does_follow_pattern(pattern: str, string: str) -> bool: pass ``` # Input * `pattern`: a string consisting of lowercase letters (1 ≤ len(pattern) ≤ 100) * `string`: a string where words are separated by single spaces (1 ≤ len(string) ≤ 1000) # Output * Return `True` if the string follows the pattern, `False` otherwise. # Constraints * The length of `pattern` and the number of words in `string` should be the same for it to potentially follow the pattern. * Each character in the pattern should map to a unique word in the string. # Examples ```python assert does_follow_pattern(\\"abba\\", \\"dog cat cat dog\\") == True assert does_follow_pattern(\\"abba\\", \\"dog cat cat fish\\") == False assert does_follow_pattern(\\"aaaa\\", \\"dog cat cat dog\\") == False assert does_follow_pattern(\\"abba\\", \\"dog dog dog dog\\") == False assert does_follow_pattern(\\"abc\\", \\"b c a\\") == True ``` # Explanation of Examples 1. `\\"abba\\"`, `\\"dog cat cat dog\\"`: Matches the pattern `a -> dog`, `b -> cat`, `b -> cat`, `a -> dog`. 2. `\\"abba\\"`, `\\"dog cat cat fish\\"`: Pattern fails at the last word where `a` should map to `dog` but maps to `fish`. 3. `\\"aaaa\\"`, `\\"dog cat cat dog\\"`: All pattern characters are the same but map to different words. 4. `\\"abba\\"`, `\\"dog dog dog dog\\"`: All words are the same, but the pattern requires two distinct mappings. 5. `\\"abc\\"`, `\\"b c a\\"`: Matches the pattern `a -> b`, `b -> c`, `c -> a`.","solution":"def does_follow_pattern(pattern: str, string: str) -> bool: words = string.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for p, w in zip(pattern, words): if p in char_to_word: if char_to_word[p] != w: return False else: if w in word_to_char: return False char_to_word[p] = w word_to_char[w] = p return True"},{"question":"# Bit Flip Transformation **Scenario**: You are working on a software project that involves optimizing data transformation. Part of the task requires you to determine how many bit changes are needed to transform one data representation into another. **Task**: Write a function `count_flips_to_convert(a: int, b: int) -> int` that calculates the minimal number of bit flips required to convert integer `a` to integer `b`. **Input/Output**: * **Input**: Two integers `a` and `b`. - Constraints: (0 leq a, b leq 2^{31} - 1) (non-negative 32-bit integers) * **Output**: An integer representing the number of bits that need to be flipped. **Examples**: ```plaintext Input: 29, 15 Output: 2 Input: 7, 10 Output: 3 ``` **Explanation**: - For the first example, 29 (11101) converted to 15 (01111) requires flipping 2 bits. - For the second example, 7 (0111) converted to 10 (1010) requires flipping 3 bits. **Constraints**: * Aim to implement the function with an optimal time complexity. * Focus on accurate and efficient handling of bit manipulation. ```python def count_flips_to_convert(a: int, b: int) -> int: # Your code here pass ```","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the number of bit flips required to convert integer a to integer b. # XOR a and b to find differing bits xor_result = a ^ b # Count the number of 1s in the XOR result, which indicates the differing bits return bin(xor_result).count(\'1\')"},{"question":"Scenario You are working on a large application concerning a directory service that maintains a dynamically changing tree of user IDs. Each subtree must continue to behave as a sorted list such that each node’s left subtree contains IDs less than the node\'s ID and the right subtree contains IDs greater than the node\'s ID. To ensure the correctness of your application\'s directory service, you need to implement a function to validate whether a given tree structure is, indeed, a Binary Search Tree (BST). Task Write a function `is_bst(root)` that takes the root of a binary tree as its input and returns True if the binary tree is a valid binary search tree, and False otherwise. # Input and Output Format * **Input**: `root`, a TreeNode object where each TreeNode contains an integer value and pointers to its left and right children. * **Output**: A boolean indicating whether the tree is a valid BST. # Constraints * All node values in the tree are integers. * The left subtree of a node contains only nodes with keys **less than** the node\'s key. * The right subtree of a node contains only nodes with keys **greater than** the node\'s key. * Both left and right subtrees must themselves be BSTs. Performance Requirements * The function should have a time complexity of O(n) and a space complexity of O(h), where n is the number of nodes and h is the height of the tree. # Example ```plaintext Example 1: Input: [2, 1, 3] Output: True Example 2: Input: [1, 2, 3] Output: False ``` You are provided the structure of the TreeNode class. You should utilize this for creating instances and linking them appropriately. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Implement the function: ```python def is_bst(root): # Your implementation here ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_bst(root): def validate(node, low=float(\'-inf\'), high=float(\'inf\')): if not node: return True if not (low < node.val < high): return False return (validate(node.left, low, node.val) and validate(node.right, node.val, high)) return validate(root)"},{"question":"Context In an IoT monitoring system, we often need to process sensor data to extract readings within a specific range. For example, you might only be interested in temperature readings within a safe range for a given environment. Hence, you need a function that efficiently filters the data based on specified boundaries. Task Write a function `filter_range(arr, min_val=None, max_val=None)` that filters an array of integers based on provided minimum and maximum values. The function should return a new array that includes only the elements within the range [min_val, max_val]. If `min_val` or `max_val` is `None`, consider the range to be unbounded from that respective side. Requirements * **Input**: * `arr`: A list of integers (e.g., [3, 10, 4, 18, 5]). * `min_val`: An integer defining the lower bound of the range (inclusive). If `None`, treat it as no lower bound. * `max_val`: An integer defining the upper bound of the range (inclusive). If `None`, treat it as no upper bound. * **Output**: A list of integers that fall within the specified range. Constraints * The array length can be up to (10^6). * The values within the array can be between (-10^6) and (10^6). Performance Requirements Your solution should ensure a linear time complexity, O(n). Examples ```python assert filter_range([1, 15, 20, 3, 7], min_val=5, max_val=15) == [15, 7] assert filter_range([30, 5, 12, 23, 9], min_val=None, max_val=10) == [5, 9] assert filter_range([], min_val=0, max_val=10) == [] assert filter_range([1, 2, 3, 4, 5], min_val=None, max_val=None) == [1, 2, 3, 4, 5] ``` Write your implementation below: ```python def filter_range(arr, min_val=None, max_val=None): if len(arr) == 0: return arr if min_val is None: min_val = min(arr) if max_val is None: max_val = max(arr) return [x for x in arr if min_val <= x <= max_val] ```","solution":"def filter_range(arr, min_val=None, max_val=None): Filters the input array based on provided min_val and max_val. :param arr: List of integers to be filtered. :param min_val: Minimum value (inclusive) of the range. If None, no lower bound. :param max_val: Maximum value (inclusive) of the range. If None, no upper bound. :return: List of integers within the specified range. if min_val is None: min_val = float(\'-inf\') if max_val is None: max_val = float(\'inf\') return [x for x in arr if min_val <= x <= max_val]"},{"question":"You are tasked to implement a function that computes the greatest common divisor of two non-negative integers using an optimized algorithm leveraging bitwise operations and efficient trailing zero counting. # Function Signature ```python def optimized_gcd(a: int, b: int) -> int: pass ``` # Input * Two non-negative integers `a` and `b`. # Output * An integer representing the greatest common divisor of `a` and `b`. # Constraints * `0 <= a, b <= 10^9` # Performance Requirements * Your solution should not exceed O(log(min(a, b))) time complexity. * Space complexity should remain within O(1). # Example Scenarios 1. `optimized_gcd(48, 18)` should return `6` 2. `optimized_gcd(101, 10)` should return `1` 3. `optimized_gcd(0, 100)` should raise a `ValueError` since one of the inputs is zero. # Additional Notes 1. Consider edge cases where one of the integers is zero, since GCD is not defined in such cases. 2. Your solution should employ bitwise operations to optimize the GCD calculation.","solution":"def optimized_gcd(a: int, b: int) -> int: if a == 0 or b == 0: raise ValueError(\\"GCD is undefined for zero as one of the inputs.\\") # Use binary GCD algorithm (Stein\'s Algorithm) # Finding common factors of 2 shift = 0 while ((a | b) & 1) == 0: # both a and b are even a >>= 1 b >>= 1 shift += 1 while (a & 1) == 0: # make a odd a >>= 1 while b != 0: while (b & 1) == 0: # make b odd b >>= 1 if a > b: a, b = b, a # ensure a <= b b -= a # b is now even return a << shift # restore the common factors of 2"},{"question":"# Symmetric Binary Tree Check You are given the root of a binary tree. Your task is to write two functions: one to check if the tree is symmetric using a recursive approach, and another to achieve the same task using an iterative approach. Function Specifications: 1. **Recursive Approach**: * **Function Signature**: `def is_symmetric_recursive(root: Optional[TreeNode]) -> bool` * **Input**: The root node of a binary tree. * **Output**: Return `True` if the tree is symmetric, otherwise return `False`. 2. **Iterative Approach**: * **Function Signature**: `def is_symmetric_iterative(root: Optional[TreeNode]) -> bool` * **Input**: The root node of a binary tree. * **Output**: Return `True` if the tree is symmetric, otherwise return `False`. Constraints: - Each node in the binary tree contains an integer value. - The total number of nodes in the tree will not exceed 10^4. Performance Requirements: - The recursive approach should handle balanced trees efficiently with minimal stack depth. - The iterative approach should minimize memory usage while avoiding deep recursion issues. Example: **Input**: ``` 1 / 2 2 / / 3 4 4 3 ``` **Output**: `True` **Input**: ``` 1 / 2 2 3 3 ``` **Output**: `False` Notes: - Carefully consider edge cases such as trees with missing nodes or trees that are inherently unbalanced. - Ensure proper termination conditions in both approaches to avoid infinite loops or stack overflows. - Accurate and efficient node comparisons are crucial to avoid false results.","solution":"from typing import Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric_recursive(root: Optional[TreeNode]) -> bool: Check if a tree is symmetric using a recursive approach. if not root: return True def is_mirror(left: TreeNode, right: TreeNode) -> bool: if not left and not right: return True if not left or not right: return False return (left.val == right.val) and is_mirror(left.left, right.right) and is_mirror(left.right, right.left) return is_mirror(root.left, root.right) def is_symmetric_iterative(root: Optional[TreeNode]) -> bool: Check if a tree is symmetric using an iterative approach. if not root: return True queue = deque([(root.left, root.right)]) while queue: left, right = queue.popleft() if not left and not right: continue if not left or not right or left.val != right.val: return False queue.append((left.left, right.right)) queue.append((left.right, right.left)) return True"},{"question":"# Question: Mode Calculation from an Array You are required to implement a function called `compute_mode` that takes a list of integers as input and returns a list of the most frequent elements (mode) in the array. If there are multiple elements with the same maximum frequency, your function should return all of them. Function Signature ```python def compute_mode(arr: list) -> list: ``` Input * `arr`: A list of integers (e.g., [1, 1, 2, 2, 3, 4]) Output * A list of the most frequent elements in the array (e.g., [1, 2]) Constraints 1. The elements in the `arr` will be non-negative. 2. The length of `arr` will not exceed 10^5. Requirements * Your solution should have a time complexity of O(n). Example ```python assert compute_mode([1, 1, 2, 2, 3, 4]) == [1, 2] assert compute_mode([4, 4, 5, 5, 5, 6]) == [5] assert compute_mode([]) == [] assert compute_mode([7]) == [7] assert compute_mode([10, 10, 10, 20, 20, 30, 30, 30]) == [10, 30] ``` Notes * Handle edge cases, such as when the input list is empty or has only one element. * Ensure that your function is efficient and meets the specified time complexity. * Your function should return the modes in the order they first appear in the list.","solution":"def compute_mode(arr: list) -> list: from collections import Counter if not arr: return [] frequency = Counter(arr) max_freq = max(frequency.values()) return [key for key, value in frequency.items() if value == max_freq]"},{"question":"# Exponential Power Calculator Context You are developing a cryptographic application and need to compute large power values efficiently under a modulo. Implement an efficient algorithm to compute (a^n mod m) that can handle very large values of (n). Task Write a function to compute the power of a number using binary exponentiation. Your function should handle modular arithmetic and provide both iterative and recursive solutions. Function Signature ```python def power(a: int, n: int, mod: int = None): pass def power_recur(a: int, n: int, mod: int = None): pass ``` Input - `a` (int): Base integer. (1 ≤ a ≤ 10^9) - `n` (int): Exponent integer. (0 ≤ n ≤ 10^9) - `mod` (int, optional): Modulo integer. (2 ≤ mod ≤ 10^9). Defaults to None. Output - (int): Result of (a^n) if no `mod` is specified, otherwise (a^n mod mod). Constraints - Your solution should run in (O(log n)) time. - Optimize for both time and space where possible. Examples 1. `power(2, 10)` => 1024 2. `power(2, 10, 1000)` => 24 3. `power(3, 0)` => 1 4. `power(2, 20, 17)` => 16 Notes - Ensure to handle the base case where (n = 0), which should return 1. - Handle both the iterative and recursive versions of the power calculation.","solution":"def power(a: int, n: int, mod: int = None): Compute a^n using binary exponentiation, optionally with modulo. Iterative version. result = 1 base = a while n > 0: if n % 2 == 1: # If n is odd, multiply result by the base if mod: result = (result * base) % mod else: result *= base base *= base # Square the base if mod: base %= mod n //= 2 # Divide n by 2 return result def power_recur(a: int, n: int, mod: int = None): Compute a^n using binary exponentiation, optionally with modulo. Recursive version. # Base cases if n == 0: return 1 half_power = power_recur(a, n // 2, mod) half_power = (half_power * half_power) % mod if mod else half_power * half_power if n % 2 != 0: # If n is odd, include one more a half_power = (half_power * a) % mod if mod else half_power * a return half_power"},{"question":"# Bubble Sort Simplified Implementation Context: Bubble Sort is a simple sorting algorithm that orders the elements of an array in ascending order. It repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. Despite its simplicity, Bubble Sort is inefficient on large lists and is generally not used in practice for large datasets. Your task is to understand the provided implementation and write a simplified version that maintains the core functionality without additional features. Task: Write a function `simple_bubble_sort` that takes a list of integers as input and returns a sorted list in ascending order using the bubble sort algorithm. Do not include the optional simulation feature. # Function Signature: ```python def simple_bubble_sort(arr: List[int]) -> List[int]: ``` # Input: * `arr` (List[int]): A list of integers. The list can be empty. # Output: * (List[int]): A new list sorted in ascending order. # Constraints: * The input list can contain zero or more integers. * You can assume all integers fit in the standard 32-bit signed integer range. # Example: ```python input: [64, 34, 25, 12, 22, 11, 90] output: [11, 12, 22, 25, 34, 64, 90] input: [5, 1, 4, 2, 8] output: [1, 2, 4, 5, 8] input: [] output: [] input: [1] output: [1] ``` # Notes: 1. Avoid adding any print statements or simulation functionality; focus on the core sorting logic. 2. Ensure the function is optimized to stop early if the list is already sorted during any iteration.","solution":"from typing import List def simple_bubble_sort(arr: List[int]) -> List[int]: Sorts a list of integers in ascending order using the bubble sort algorithm. n = len(arr) for i in range(n): swapped = False for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if not swapped: break return arr"},{"question":"A singly linked list is a linear collection of nodes where each node points to the next node until the end of the list. Designing efficient algorithms for manipulating these lists is crucial. Task Write a function `delete_node(node)` that deletes a given node from a singly linked list. The provided node will not be the tail node but can be any other node in the list. # Function Signature ```python def delete_node(node: Node) -> None: pass ``` # Input * `node` - a `Node` object representing the node to be deleted from the linked list (won\'t be the tail node). * Each `Node` object has two fields: * `val` - an integer value of the node. * `next` - a reference to the next node in the linked list or `None` if it is the last node. # Output Your function should modify the linked list in place and does not need to return anything. # Constraints 1. `node` is guaranteed to not be `None`. 2. `node` is guaranteed to not be the tail node. # Example Suppose the linked list is initialized as follows: ```python class Node: def __init__(self, x): self.val = x self.next = None # Create linked list: 1 -> 2 -> 3 -> 4 head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = Node(4) node = head.next.next # Node with value 3 to be deleted delete_node(node) # Modified linked list: 1 -> 2 -> 4 ``` # Explanation Given a linked list `1 -> 2 -> 3 -> 4`, after calling `delete_node(node)` where `node` contains value `3`, the list should become `1 -> 2 -> 4`. The function should: 1. Replace the value of the node to be deleted with the value of the next node. 2. Redirect the `next` pointer of the node to skip the next node. # Performance Requirements * The function should run in constant time O(1). * The function should use constant additional space O(1). # Additional Notes * Handle all exceptions and edge cases properly, ensuring robust code.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node: Node) -> None: Deletes the given node (which is not the tail) from the linked list. if node is None or node.next is None: raise ValueError(\\"The node to be deleted cannot be None or the tail node\\") next_node = node.next node.val = next_node.val node.next = next_node.next next_node.next = None # Help with garbage collection"},{"question":"Search in a Row-wise and Column-wise Sorted Matrix Objective Write a function to search for a given key in a row-wise and column-wise sorted matrix and return its position if it exists, otherwise indicate that the key is not found. Function Signature ```python def search_in_sorted_matrix(matrix: List[List[int]], key: int) -> Optional[Tuple[int, int]]: pass ``` Input - `matrix` (List[List[int]]): A 2D list representing the matrix where each row and column is sorted in non-decreasing order. - `key` (int): The integer value that needs to be searched in the matrix. Output - The function should return a tuple `(i, j)` where `i` is the row index and `j` is the column index (0-based) if the key is found. - Return `None` if the key is not found. Constraints - The matrix will have at least 1 row and 1 column. - All elements in the matrix are distinct positive integers. - The matrix dimensions will not exceed 10^3 x 10^3. Scenario Context You are developing a feature for a data processing tool designed to manage a large, structured dataset in matrix form. Your task is to search quickly through the sorted matrix and find the coordinates of specific target values provided by users. Example ```python matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 assert search_in_sorted_matrix(matrix, key) == (1, 2) key = 6 assert search_in_sorted_matrix(matrix, key) is None ``` Explanation In the first example, the key `13` is found at row index `1` and column index `2`. In the second example, the key `6` is not found in the matrix, so the function returns `None`.","solution":"from typing import List, Optional, Tuple def search_in_sorted_matrix(matrix: List[List[int]], key: int) -> Optional[Tuple[int, int]]: if not matrix or not matrix[0]: return None rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner of the matrix i = 0 j = cols - 1 while i < rows and j >= 0: if matrix[i][j] == key: return (i, j) elif matrix[i][j] > key: j -= 1 # Move left else: i += 1 # Move down return None"},{"question":"# Question: Efficient GCD and LCM Computations Problem Statement You are given two non-negative integers, `x` and `y`. Your task is to implement two functions: 1. `efficient_gcd(x, y)` which computes the greatest common divisor (GCD) using: - Bitwise operations for performance efficiency. - Handling common edge cases. 2. `smallest_lcm(x, y)` which computes the least common multiple (LCM) of two integers using the GCD computed by `efficient_gcd`. You need to ensure that: - Performance is optimized for large integers. - Edge cases are properly handled, including cases where one or both integers are zero. Function Specifications 1. **Function `efficient_gcd(x, y)`** **Input:** - Two non-negative integers `x` and `y`. **Output:** - An integer which is the greatest common divisor of `x` and `y`. **Constraints:** - `0 <= x, y <= 10^18` - If both `x` and `y` are zero, return 0. 2. **Function `smallest_lcm(x, y)`** **Input:** - Two non-negative integers `x` and `y`. **Output:** - An integer which is the least common multiple of `x` and `y`. **Constraints:** - `0 <= x, y <= 10^18` - If one of the integers is zero, return 0. Example ```python # Given inputs x = 40 y = 100 # Function calls print(efficient_gcd(x, y)) # Output: 20 print(smallest_lcm(x, y)) # Output: 200 ``` Notes - Ensure that your solution handles large integers efficiently. - Validate your functions against possible edge cases: * Both integers being zero. * One integer being zero. * Large prime numbers.","solution":"def efficient_gcd(x, y): Returns the greatest common divisor (GCD) of x and y using the binary GCD algorithm. if x == 0: return y if y == 0: return x # From here on, x and y are guaranteed to be non-zero shift = 0 while ((x | y) & 1) == 0: x >>= 1 y >>= 1 shift += 1 while (x & 1) == 0: x >>= 1 while y != 0: while (y & 1) == 0: y >>= 1 if x > y: x, y = y, x y = y - x return x << shift def smallest_lcm(x, y): Returns the least common multiple (LCM) of x and y using the GCD calculated by efficient_gcd. if x == 0 or y == 0: return 0 gcd_val = efficient_gcd(x, y) return (x // gcd_val) * y"},{"question":"# Problem: String Pattern Matching using Knuth-Morris-Pratt Algorithm **Context**: You are developing a text processing tool for a document editor that needs to support several find operations. Users want to locate all occurrences of a specific word or phrase within their documents efficiently, especially for very large documents or logs. **Task**: Implement a function `knuth_morris_pratt(text: str, pattern: str) -> List[int]` that uses the Knuth-Morris-Pratt string matching algorithm to find all starting indices of the `pattern` in the `text`. **Input**: 1. `text` - a string representing the main text. 2. `pattern` - a string representing the word or phrase to search for within `text`. **Output**: 1. A list of integers representing starting indices where the pattern is found in the text. **Constraints**: 1. `text` and `pattern` are both non-empty strings. 2. The length of `text` is `N`, and the length of `pattern` is `M`. 3. It is guaranteed that 1 ≤ M ≤ N ≤ 10^6. **Performance Requirements**: * The algorithm should run in linear time, O(N + M). **Examples**: ```python assert knuth_morris_pratt(\'hello there hero!\', \'he\') == [0, 7, 12] assert knuth_morris_pratt(\'aaaaaaa\', \'aa\') == [0, 1, 2, 3, 4, 5] assert knuth_morris_pratt(\'ababcabcabababd\', \'ababd\') == [10] ``` **Explanation**: * For the input \'hello there hero!\' and \'he\', the output [0, 7, 12] signifies that the pattern \'he\' starts at indices 0, 7, and 12 in the text. **Guidelines**: 1. Preprocess the `pattern` to create the partial match table (pi table). 2. Use the pi table to perform efficient string matching on the `text`. 3. Ensure edge cases such as: * Empty text or pattern (handle as constraints say non-empty strings). * Patterns longer than text. * Repetitive patterns and text. Submit your implementation as a Python function: ```python from typing import List def knuth_morris_pratt(text: str, pattern: str) -> List[int]: # Your code here ```","solution":"from typing import List def knuth_morris_pratt(text: str, pattern: str) -> List[int]: # Compute the partial match table (pi table) for pattern def compute_pi_table(pattern): m = len(pattern) pi = [0] * m k = 0 for q in range(1, m): while k > 0 and pattern[k] != pattern[q]: k = pi[k - 1] if pattern[k] == pattern[q]: k += 1 pi[q] = k return pi # KMP search algorithm n = len(text) m = len(pattern) pi = compute_pi_table(pattern) q = 0 result = [] for i in range(n): while q > 0 and pattern[q] != text[i]: q = pi[q - 1] if pattern[q] == text[i]: q += 1 if q == m: result.append(i - m + 1) q = pi[q - 1] return result"},{"question":"You are tasked with writing a sorting function using the Comb Sort algorithm that sorts a list of integers in non-decreasing order. Your algorithm should demonstrate an in-depth understanding of the comb sort principles and handle various edge cases effectively. # Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: ``` # Input: * An unsorted list of integers `arr` with length `N` where `0 <= N <= 10^5`. # Output: * The input list `arr` sorted in non-decreasing order. # Constraints: * Your solution must be able to run efficiently for input arrays up to length `10^5`. * The function should work correctly for edge cases like an already sorted array, arrays with duplicate values, and very small arrays. # Performance Requirements: * Ensure the implementation is optimized for both time and space. * While Comb Sort is inherently less efficient on large datasets, aim for best achievable performance within the constraints. # Example: ```python comb_sort([5, 3, 8, 4, 2]) # Output: [2, 3, 4, 5, 8] comb_sort([20, 13, 15, 9, 6, 17, 1, 7]) # Output: [1, 6, 7, 9, 13, 15, 17, 20] comb_sort([]) # Output: [] ``` # Explanation: In each example, the function `comb_sort` correctly sorts the given list using the Comb Sort algorithm. # Notes: * Edge cases such as empty arrays and arrays with a single element should be handled properly. * Pay attention to the gap shrinkage mechanism and ensure no infinite loops.","solution":"def comb_sort(arr): Sorts a list of integers using the Comb Sort algorithm. Parameters: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list of integers. def get_next_gap(gap): # Shrink factor of 1.3 is commonly used in comb sort new_gap = (gap * 10) // 13 if new_gap < 1: return 1 return new_gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"Design a `RandomizedQueue` data structure that supports the following operations in average O(1) time: - `enqueue(val)`: Inserts an item `val` to the queue if it\'s not already present. - `dequeue()`: Removes and returns a random element from the queue. Each element must have the same probability of being returned. Requirements 1. Implement the class `RandomizedQueue` with the following methods: - `__init__()`: Initializes the data structure. - `enqueue(val)`: Adds `val` to the queue if it\'s not already present and returns True. Returns False otherwise. - `dequeue()`: Removes and returns a random element from the queue if not empty. If empty, raises an exception. 2. Ensure that the `dequeue` method handles empty queue scenarios properly. 3. Ensure that calling `enqueue` on a value already present in the queue does not add the value again. 4. Provide average O(1) time complexity for all operations. Example ```python # Example usage of the RandomizedQueue rq = RandomizedQueue() print(\\"enqueue 1: \\", rq.enqueue(1)) # True print(\\"enqueue 2: \\", rq.enqueue(2)) # True print(\\"enqueue 3: \\", rq.enqueue(3)) # True print(\\"enqueue 2: \\", rq.enqueue(2)) # False (already present) print(\\"dequeue: \\", rq.dequeue()) # random element from [1, 2, 3] print(\\"dequeue: \\", rq.dequeue()) # random element from remaining elements print(\\"dequeue: \\", rq.dequeue()) # random element from remaining elements or raises exception if empty ``` Constraints - Do not use any built-in set or dictionary methods optimized for uniqueness and random access. - Focus on implementing the methods as efficiently as possible. - Provide exception handling for scenarios where `dequeue` is called on an empty queue.","solution":"import random class RandomizedQueue: def __init__(self): self.queue = [] self.index_map = {} def enqueue(self, val): if val in self.index_map: return False self.queue.append(val) self.index_map[val] = len(self.queue) - 1 return True def dequeue(self): if not self.queue: raise Exception(\\"Queue is empty\\") # Randomly select an element to remove random_index = random.randint(0, len(self.queue) - 1) val = self.queue[random_index] # Move the last element to the place of the removed element last_element = self.queue[-1] self.queue[random_index] = last_element self.index_map[last_element] = random_index # Remove the last element self.queue.pop() del self.index_map[val] return val"},{"question":"# Scenario You are building a communication system where lists of strings need to be transmitted or stored as a single string. To ensure messages are correctly sent and received, you need to develop an efficient encoding and decoding mechanism that handles variable-length strings. # Task Write two functions, `encode` and `decode`, to encode a list of strings into a single string and decode it back to the original list of strings, respectively. # Requirements 1. **Function Names**: `encode`, `decode` 2. **Input and Output**: * `encode`: * Input: `List[str]` – A list of strings to encode. * Output: `str` – A single encoded string representing the list. * `decode`: * Input: `str` – An encoded string to decode. * Output: `List[str]` – The original list of strings. # Constraints 1. The length of each string in the list is between 1 and 1000. 2. Each string does not contain the \':\' character. # Performance Requirements * Time complexity for `encode` and `decode` should be linear with respect to the size of the input data. # Example ```python # Example usage: input_list = [\\"hello\\", \\"world\\"] encoded_string = encode(input_list) print(encoded_string) # Example output: \\"5:hello5:world\\" decoded_list = decode(encoded_string) print(decoded_list) # Example output: [\\"hello\\", \\"world\\"] ``` # Notes * Consider edge cases, such as an empty list of strings or strings with special characters, ensuring your solution is robust.","solution":"def encode(strings): Encodes a list of strings into a single string. return \'\'.join(f\'{len(s)}:{s}\' for s in strings) def decode(encoded_string): Decodes a single string back into a list of strings. i, n = 0, len(encoded_string) result = [] while i < n: # Find the delimiter j = i while encoded_string[j] != \':\': j += 1 length = int(encoded_string[i:j]) result.append(encoded_string[j+1:j+1+length]) i = j + 1 + length return result"},{"question":"# Question: Optimized Sorting with Early Termination Check You are working on improving the performance of a sorting algorithm for small lists. Given the inefficiency of the Exchange Sort for larger datasets, it\'s important to introduce optimizations for scenarios where the array might already be sorted or becomes sorted early during the process. Implement an optimized sorting function that enhances the basic Exchange Sort by adding an early termination check. This check should detect if the array is already sorted during any iteration and stop further execution to save unnecessary comparisons. Function Signature ```python def optimized_exchange_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr`: A list of integers of length `n` (0 <= n <= 10^4). Output * A list of integers sorted in non-decreasing order. Constraints * The algorithm should perform efficiently with an early termination check. * You should not use pre-built sorting functions from libraries. Example ```python assert (out := optimized_exchange_sort([4, 3, 2, 1])) == [1, 2, 3, 4] assert (out := optimized_exchange_sort([1, 2, 3, 4])) == [1, 2, 3, 4] assert (out := optimized_exchange_sort([4, 5, 1, 2, 3])) == [1, 2, 3, 4, 5] assert (out := optimized_exchange_sort([1])) == [1] assert (out := optimized_exchange_sort([])) == [] ``` Description 1. Modify the provided Exchange Sort algorithm to include an early termination mechanism: * During each main loop iteration, track whether any elements were swapped. * If no elements were swapped in an iteration, break the loop early as the array is already sorted. 2. Return the sorted array. Edge Cases * Empty array. * Single element array. * Arrays with duplicate elements. The goal of this problem is to assess the student\'s ability to optimize basic sorting algorithms and understand the importance of performance enhancements in practical scenarios.","solution":"from typing import List def optimized_exchange_sort(arr: List[int]) -> List[int]: Sorts the array using an optimized version of exchange sort with early termination check. n = len(arr) for i in range(n - 1): swapped = False for j in range(n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if not swapped: break return arr"},{"question":"Reverse a Singly Linked List **Context**: You are given a singly linked list where each node contains an integer value. The task is to reverse the order of the linked list elements, effectively turning the list head into the tail and vice versa. **Function Signature**: ```python def reverse_linked_list(head: ListNode) -> ListNode: pass ``` **Input**: - `head`: A ListNode object representing the head of a singly linked list. The list can contain 0 or more nodes. **Output**: - A ListNode object representing the new head of the reversed linked list. **Constraints**: - The function should handle lists with up to 10000 nodes efficiently. - Each node contains an integer value (`val`). - The `next` pointer of the last node in the reversed list should be `None`. **Performance Requirement**: - The solution must run in ( O(n) ) time complexity. - The function should use ( O(1) ) additional space for the iterative solution. A recursive solution using ( O(n) ) space is also acceptable. **Example**: ```plaintext Input: 1 -> 2 -> 3 -> 4 Output: 4 -> 3 -> 2 -> 1 Input: None Output: None ``` # Your task: 1. Implement the function `reverse_linked_list` iteratively. 2. (Optional) Implement an additional function `reverse_linked_list_recursive` to achieve the same result recursively. **Notes**: - Ensure that your solution handles edge cases like an empty list and a single-node list correctly. - The use of proper memory management and avoiding recursive stack overflow for large lists is crucial. - Include comments to explain the key steps in your implementation.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverse a singly linked list iteratively. :param head: ListNode :return: ListNode prev = None current = head while current is not None: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"You are given an array of integers where every element appears twice except for one element which appears exactly once. Your task is to find and return that single unique element. Implement this in linear runtime complexity and without using extra memory. # Function Signature ```python def single_number(nums: List[int]) -> int: ``` # Input - `nums`: List of integers, where all elements appear twice except for one element which appears exactly once. # Output - Returns the single element that appears only once in the array. - If all numbers appear twice and no single element exists, return 0. # Constraints - 1 <= len(nums) <= 10^5 - The array contains only integers. # Example ```python assert single_number([2, 2, 1]) == 1 assert single_number([4, 1, 2, 1, 2]) == 4 assert single_number([1]) == 1 ``` # Scenario A warehouse is equipped with a logging system to keep track of items checked in and out. However, there\'s a system quirk: every checked in item is logged twice except for a single item that was logged only once due to a system error. You need to determine which item this is to ensure inventory accuracy. # Hints 1. Use the properties of bitwise XOR to achieve the desired result. 2. Ensure your solution has linear time complexity. 3. Avoid using extra memory such as additional arrays or hash sets.","solution":"from typing import List def single_number(nums: List[int]) -> int: Returns the single element that appears exactly once in the array. Uses bitwise XOR to achieve linear time complexity and constant space complexity. unique = 0 for num in nums: unique ^= num return unique"},{"question":"You are tasked with extending the functionality of the integer base conversion algorithm provided in the code snippet. Your task is to write a function that converts a number from one base to another base directly. The function should leverage the two functions provided (`int_to_base` and `base_to_int`) to perform the conversion. # Function Signature ```python def base_conversion(number_str, from_base, to_base): :type number_str: str :type from_base: int :type to_base: int :rtype: str ``` # Input/Output * **Input**: - `number_str` (str) : A string representation of the number in `from_base`. - `from_base` (int): The base of the input number (2 <= from_base <= 36). - `to_base` (int): The desired base for the output number (2 <= to_base <= 36). * **Output**: - A string representing the converted number in the `to_base`. # Constraints * The input `number_str` will always be valid in the given `from_base`. * The `from_base` and `to_base` will always be between 2 and 36. # Examples ```python # Example 1 # Convert \\"101\\" from base 2 to base 10 result = base_conversion(\\"101\\", 2, 10) # Expected output: \\"5\\" # Example 2 # Convert \\"F\\" from base 16 to base 2 result = base_conversion(\\"F\\", 16, 2) # Expected output: \\"1111\\" # Example 3 # Convert \\"30\\" from base 10 to base 16 result = base_conversion(\\"30\\", 10, 16) # Expected output: \\"1E\\" ``` # Performance Requirements * Conversion should be efficiently handled within the constraints. * Perform input validations to ensure the function handles invalid bases/gracefully with appropriate error messages. # Implementation Steps 1. Use the `base_to_int` function to convert the `number_str` from `from_base` to an integer. 2. Use the `int_to_base` function to convert the resulting integer to the desired `to_base`. # Implementation Complete the function `base_conversion` based on the steps outlined above.","solution":"def base_conversion(number_str, from_base, to_base): Converts a number from one base to another base. :type number_str: str :type from_base: int :type to_base: int :rtype: str def base_to_int(number_str, base): Converts a number in a given base to an integer. :type number_str: str :type base: int :rtype: int return int(number_str, base) def int_to_base(number, base): Converts an integer to a string representation in a given base. :type number: int :type base: int :rtype: str alph = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" if number == 0: return \\"0\\" result = \\"\\" while number > 0: result = alph[number % base] + result number //= base return result intermediate_int = base_to_int(number_str, from_base) return int_to_base(intermediate_int, to_base)"},{"question":"# Question You are tasked with developing an efficient algorithm to encapsulate matching symbols within words from a given list with square brackets. Your algorithm should ensure that the symbol with the longest match is selected if multiple symbols can be matched within a word. # Function Signature ```python def replace_symbols_in_words(words: List[str], symbols: List[str]) -> List[str]: pass ``` # Input - `words` (List[str]): A list of words. Each word is a string containing only uppercase and lowercase Latin letters. - `symbols` (List[str]): A list of symbol strings. Each symbol is a string containing only uppercase and lowercase Latin letters. # Output - Returns a list of words where each word has the longest matching symbol from the symbols list encapsulated in square brackets. If no symbols match, the word should be returned as is. # Constraints - Words and symbols can be empty strings or contain at most 1000 characters. - Lists can have at most 1000 words or symbols. - The replacements are case-sensitive. # Example Input ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] ``` Output ```python [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Notes - The function should be implemented with a focus on efficiency and correctness. - Optimal solution should consider the space and time complexities discussed in the analysis. # Additional Edge Cases 1. Words matching with multiple symbols of the same length. 2. Words having no matching symbols. 3. Symbols that are substrings of each other. Implement the function `replace_symbols_in_words` ensuring it adheres to the described specifications and efficiently handles edge cases.","solution":"from typing import List def replace_symbols_in_words(words: List[str], symbols: List[str]) -> List[str]: result = [] for word in words: longest_match = \\"\\" longest_match_start = -1 for symbol in symbols: start = word.find(symbol) if start != -1: if len(symbol) > len(longest_match): longest_match = symbol longest_match_start = start if longest_match: end = longest_match_start + len(longest_match) result.append(word[:longest_match_start] + \\"[\\" + longest_match + \\"]\\" + word[end:]) else: result.append(word) return result"},{"question":"# Coding Challenge Objective: Write a function to swap every pair of adjacent bits in an integer. This means you will swap bit 0 with bit 1, bit 2 with bit 3, and so on. Function Signature: ```python def swap_pair(num: int) -> int: ``` Input: - **num**: A non-negative integer (`0 <= num <= 2^32 - 1`). Output: - Returns the integer result after swapping every pair of adjacent bits. Constraints: - You must achieve this with O(1) time complexity. - The solution should be efficient and utilize bitwise operations exclusively. Example: ```python assert swap_pair(22) == 41 # 22 in binary is 010110, swapping pairs we get 101001 which is 41 assert swap_pair(10) == 5 # 10 in binary is 1010, swapping pairs we get 0101 which is 5 ``` Explanation: To swap the bits: 1. Isolate and shift the odd bits (using a mask of `0xAAAAAAAA` which in binary is `10101010101010101010101010101010`). 2. Isolate and shift the even bits (using a mask of `0x55555555` which in binary is `01010101010101010101010101010101`). 3. Combine the results using a bitwise OR. Ensure that your solution handles edge cases correctly. You may assume the input number will always fit within a 32-bit unsigned integer.","solution":"def swap_pair(num: int) -> int: Swap every pair of adjacent bits in a given integer. # Masks to isolate even and odd bits even_mask = 0xAAAAAAAA # binary: 10101010101010101010101010101010 odd_mask = 0x55555555 # binary: 01010101010101010101010101010101 # Isolate even bits and shift them right even_bits = (num & even_mask) >> 1 # Isolate odd bits and shift them left odd_bits = (num & odd_mask) << 1 # Combine the shifted bits swapped_num = even_bits | odd_bits return swapped_num"},{"question":"# Coding Challenge Scenario: You are working on a data preprocessing task where you need to filter out values from an input list of integers based on given minimum and maximum bounds. The goal is to keep only the elements that lie within the specified range, inclusive of the bounds. If one or both bounds are not provided, the missing bound should be ignored in the filtering process (treated as a limitless range in that direction). Task: Implement the function `limit(arr, min_lim, max_lim)` that filters the given array according to the specified minimum and maximum bounds. Function Signature: ```python def limit(arr: List[int], min_lim: Optional[int], max_lim: Optional[int]) -> List[int]: ``` Input: * `arr` (List[int]): A list of integers (0 <= len(arr) <= 10^6). * `min_lim` (Optional[int]): An integer or `None` representing the minimum bound (inclusive). * `max_lim` (Optional[int]): An integer or `None` representing the maximum bound (inclusive). Output: * Returns a list of integers containing only the values within the specified range `[min_lim, max_lim]`. Constraints: * If `min_lim` is `None`, consider it as unbounded negatively. * If `max_lim` is `None`, consider it as unbounded positively. Example: ```python # Example 1 arr = [1, 2, 3, 4, 5] min_lim = None max_lim = 3 print(limit(arr, min_lim, max_lim)) # Output: [1, 2, 3] # Example 2 arr = [15, 3, 20, 7, 40] min_lim = 10 max_lim = None print(limit(arr, min_lim, max_lim)) # Output: [15, 20, 40] # Example 3 arr = [8, -3, 10, 5, -1, 7] min_lim = 0 max_lim = 10 print(limit(arr, min_lim, max_lim)) # Output: [8, 10, 5, 7] # Example 4 arr = [] min_lim = 0 max_lim = 100 print(limit(arr, min_lim, max_lim)) # Output: [] ``` Note: Ensure that your solution is efficient enough to handle large input sizes within reasonable time limits.","solution":"from typing import List, Optional def limit(arr: List[int], min_lim: Optional[int], max_lim: Optional[int]) -> List[int]: Filter the array according to the given min and max bounds. Parameters: arr (List[int]): A list of integers. min_lim (Optional[int]): The minimum bound (inclusive), or None if unbounded. max_lim (Optional[int]): The maximum bound (inclusive), or None if unbounded. Returns: List[int]: Filtered list of integers within the specified range. if min_lim is None and max_lim is None: return arr elif min_lim is None: return [x for x in arr if x <= max_lim] elif max_lim is None: return [x for x in arr if x >= min_lim] else: return [x for x in arr if x >= min_lim and x <= max_lim]"},{"question":"# Hailstone Sequence Length and Maximum Value The Hailstone Sequence (or Collatz Conjecture) is defined as follows: Starting with any positive integer `n`, the next term is obtained from the current term `n` as follows: * If `n` is 1, stop. * If `n` is even, the next term is `n/2`. * If `n` is odd, the next term is `3n + 1`. The sequence ends once it reaches the number 1. For example, starting with `n = 5`, the sequence is: ``` 5 -> 16 -> 8 -> 4 -> 2 -> 1 ``` which has length 6. Write a function `hailstone_length_and_max(n)` that takes a positive integer `n` and returns a tuple containing: 1. The length of the Hailstone sequence starting at `n`. 2. The maximum value encountered in the Hailstone sequence starting at `n`. Function Signature ```python def hailstone_length_and_max(n: int) -> (int, int): pass ``` Input * A single integer `n` (1 ≤ `n` ≤ 10^6). Output * A tuple `(length, max_value)` where `length` is the number of terms in the Hailstone sequence and `max_value` is the highest value encountered in the sequence. Constraints * Assume the input is always a positive integer within the given range. * Performance is important for large values of `n` up to 10^6. Example ```python print(hailstone_length_and_max(5)) # Output: (6, 16) print(hailstone_length_and_max(1)) # Output: (1, 1) print(hailstone_length_and_max(10)) # Output: (7, 16) ```","solution":"def hailstone_length_and_max(n: int) -> (int, int): Calculate the length of the Hailstone sequence and the maximum value encountered for a given starting integer n. Parameters: n (int): The starting integer of the Hailstone sequence. Returns: (int, int): A tuple of the length of the Hailstone sequence and the maximum value encountered. length = 1 max_value = n while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 length += 1 if n > max_value: max_value = n return length, max_value"},{"question":"Given a list of integers `lst` and an integer `N`, write a function `filter_list(lst, N)` that produces a new list which contains each number from the original list at most `N` times, while preserving the original order of elements. Function Signature ```python def filter_list(lst: List[int], N: int) -> List[int]: ``` Input - `lst`: A list of integers (1 <= len(lst) <= 10^5), where each integer can be between (-10^5) and (10^5). - `N`: An integer (0 leq N leq 10^5). Output - A new list that includes integers from `lst` such that each integer appears at most `N` times, preserving the original order. Constraints and Performance Requirements - The solution should be efficient, ideally (O(n)) time complexity, where (n) is the length of the input list. - The space complexity should accommodate additional data structures if necessary. Examples - Example 1: - Input: `lst = [1, 2, 3, 1, 2, 1, 2, 3]`, `N = 2` - Output: `[1, 2, 3, 1, 2, 3]` - Example 2: - Input: `lst = [1, 1, 1, 1]`, `N = 2` - Output: `[1, 1]` - Example 3: - Input: `lst = [1, 2, 3, 1, 2, 1, 2, 3]`, `N = 0` - Output: `[]` Edge Cases - If `lst` is empty, return an empty list. - If `N` is 0, return an empty list regardless of the list\'s content. - `lst` contains large integers. Your task is to implement the `filter_list` function as described above.","solution":"from typing import List def filter_list(lst: List[int], N: int) -> List[int]: Returns a new list with elements of lst appearing at most N times, preserving the original order. if N == 0: return [] element_count = {} filtered_list = [] for num in lst: if num not in element_count: element_count[num] = 0 if element_count[num] < N: filtered_list.append(num) element_count[num] += 1 return filtered_list"},{"question":"# Connected Components in an Undirected Graph Context You are tasked with implementing an algorithm to count the number of connected components in an undirected graph. This will help in analyzing the structure and connectivity of various networks such as social networks, computer networks, and more. Problem Statement Write a function that, given an undirected graph represented as an adjacency list, returns the number of connected components in the graph. Input - An integer `n` representing the number of nodes (1 ≤ n ≤ 10^5). - An integer `m` representing the number of edges (0 ≤ m ≤ 10^5). - A list of `m` pairs of integers where each pair (u, v) represents an undirected edge connecting nodes `u` and `v`. Output - An integer representing the number of connected components in the graph. Constraints - The node indices are 1-based. - Self-loops and parallel edges are not allowed. - The graph can be disconnected. Example ```python # Example input: n = 7 m = 5 edges = [ (1, 2), (2, 4), (2, 6), (4, 5), (3, 7) ] # Example output: 2 # Explanation: # The graph has two connected components: # 1-2-4-5-6 and 3-7. ``` Function Signature ```python def count_components(n: int, m: int, edges: List[Tuple[int, int]]) -> int: pass ``` Requirements - Implement `count_components(n: int, m: int, edges: List[Tuple[int, int]]) -> int` which should return the correct count of connected components. - The solution should handle edge cases, large inputs efficiently, and ensure a time complexity of O(V + E).","solution":"from typing import List, Tuple def count_components(n: int, m: int, edges: List[Tuple[int, int]]) -> int: def dfs(node, visited, adj_list): stack = [node] while stack: current = stack.pop() if not visited[current]: visited[current] = True for neighbor in adj_list[current]: if not visited[neighbor]: stack.append(neighbor) # Create adjacency list representation of the graph adj_list = {i: [] for i in range(1, n + 1)} for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) visited = {i: False for i in range(1, n + 1)} connected_components = 0 for node in range(1, n + 1): if not visited[node]: dfs(node, visited, adj_list) connected_components += 1 return connected_components"},{"question":"Context: You have been provided with functions to duplicate each element in a stack using auxiliary storage structures. Your task is to further manipulate a stack with combinations of these duplication operations and apply additional constraints. Problem Statement: You need to write a function `combine_stutter_operations(stack)` which will apply a combination of the `first_stutter` and `second_stutter` operations. Specifically, the function should: 1. Apply `second_stutter` first. 2. Followed by an immediate application of `first_stutter`. Given a stack, the final result should be that each element in the original stack is duplicated four times in the same order. You are provided with the implementations of `first_stutter` and `second_stutter`. **Function Signature**: ```python def combine_stutter_operations(stack: list) -> list: # implement this function pass ``` **Input**: - `stack`: A list representing the stack (with the element at index 0 being the bottom of the stack and the element at the last index being the top of the stack). **Output**: - Return the modified stack such that each element from the original stack appears four times consecutively. **Constraints**: - The stack will only contain integers. - The stack may be empty. - The maximum size of the stack will be `10^4`. **Example**: ```python stack = [3, 7, 1, 14, 9] combine_stutter_operations(stack) # Returns: [3, 3, 3, 3, 7, 7, 7, 7, 1, 1, 1, 1, 14, 14, 14, 14, 9, 9, 9, 9] ```","solution":"def first_stutter(stack): This function takes a stack and duplicates each element in the stack. aux = [] while stack: value = stack.pop() aux.append(value) aux.append(value) while aux: stack.append(aux.pop()) def second_stutter(stack): This function takes a stack and duplicates each element in the stack. aux = [] while stack: value = stack.pop() aux.append(value) aux.append(value) while aux: stack.append(aux.pop()) def combine_stutter_operations(stack): This function applies second_stutter first and then first_stutter on the stack. Args: stack (list): A list representing a stack (where the element at index 0 is the bottom and the element at the last index is the top). Returns: list: The modified stack such that each element appears four times consecutively. second_stutter(stack) first_stutter(stack) return stack"},{"question":"Problem Statement You are given an array of integers and an integer target value. You need to find all unique sets of `n` elements in the array that sum up to the target. Implement a function that solves this generalized **n-sum problem** and returns the results as a list of lists. Function Signature ```python def n_sum(n, nums, target, **kv): Finds all unique sets of n elements in the array that sum up to the target. Parameters: - n : int : The number of elements in each set. - nums : list : A list of integers. - target : int : The sum target for each set. - sum_closure : function, optional : Function to calculate the sum of two elements; defaults to addition. - compare_closure : function, optional : Function to compare calculated sum with target; defaults to subtracting target from sum. - same_closure : function, optional : Function to compare elements; defaults to equality. Returns: - list of lists : A list of the unique sets that sum up to the target. pass ``` Input - `n` (int): The number of elements in each set (`2 <= n <= len(nums)`). - `nums` (list of integers): The list of integers to search through. - `target` (int): The sum target for each set. - **Optional context**: - `sum_closure` (function): A custom function to compute the sum of two elements. Default is a + b. - `compare_closure` (function): A custom function to compare a number to the target. Default is comparison of the sum with the target. - `same_closure` (function): A custom function to check equality of two elements. Default is checking if two elements are the same. Output - A list of lists containing unique sets of `n` elements from the input list that sum up to the target. Constraints - Each set must be unique. - Ensure each combination is in non-descending order within the set. - Avoid using extra space beyond necessary storage for results and the recursion stack. Example Cases **Case 1:** ```python n = 4 nums = [1, 0, -1, 0, -2, 2] target = 0 ``` **Expected Output:** ```python [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] ``` **Case 2:** ```python n = 2 nums = [[-3, 0], [-2, 1], [2, 2], [3, 3], [8, 4], [-9, 5]] target = -5 def sum(a, b): return [a[0] + b[1], a[1] + b[0]] def compare(num, target): if num[0] < target: return -1 elif num[0] > target: return 1 else: return 0 ``` **Expected Output:** ```python [[-9, 5], [8, 4]] ``` Implement the function `n_sum` to satisfy the above requirements.","solution":"def n_sum(n, nums, target, sum_closure=None, compare_closure=None, same_closure=None): if sum_closure is None: sum_closure = lambda a, b: a + b if compare_closure is None: compare_closure = lambda s, t: s - t if same_closure is None: same_closure = lambda a, b: a == b def find_n_sum(nums, target, n, result, results): if len(nums) < n or n < 2: return # Two-pointer approach for 2-sum if n == 2: left, right = 0, len(nums) - 1 while left < right: total_sum = sum_closure(nums[left], nums[right]) comparison = compare_closure(total_sum, target) if comparison == 0: results.append(result + [nums[left], nums[right]]) left += 1 right -= 1 while left < right and same_closure(nums[left], nums[left - 1]): left += 1 while left < right and same_closure(nums[right], nums[right + 1]): right -= 1 elif comparison < 0: left += 1 else: right -= 1 return # Recursively reduce n for i in range(len(nums) - n + 1): if i == 0 or not same_closure(nums[i - 1], nums[i]): find_n_sum(nums[i + 1:], target - nums[i], n - 1, result + [nums[i]], results) nums.sort() results = [] find_n_sum(nums, target, n, [], results) return results"},{"question":"# Subset Generation Using Bit Manipulation Problem Statement You have been given a list of distinct integers `nums`. Your task is to write a function `custom_subsets(nums: List[int]) -> List[Set[int]]` that returns all possible subsets (the power set) of the given list. The solution set must not contain duplicate subsets. The subsets should be returned in lexicographical order. Function Signature ```python def custom_subsets(nums: List[int]) -> List[Set[int]]: pass ``` Input - A list of distinct integers `nums` where `0 <= len(nums) <= 20`. Output - A list of sets, each set representing a unique subset of `nums`. Constraints - The input list will only contain distinct integers. - Elements within a subset should be ordered as in the original list. - The order of subsets in the result list should follow lexicographical order based on the input list. Example ```python assert custom_subsets([1,2,3]) == [{}, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}] assert custom_subsets([]) == [{}] assert custom_subsets([4]) == [{}, {4}] ``` Additional Notes - Ensure consideration of edge cases like an empty input list or a single element list. - Validate performance, keeping in mind the O(n * 2^n) complexity and how it scales with input size.","solution":"from typing import List, Set def custom_subsets(nums: List[int]) -> List[Set[int]]: Generate all possible subsets (the power set) of the list of distinct integers `nums`. Subsets should be returned in lexicographical order. nums.sort() # Ensuring input is sorted for lexicographical order n = len(nums) result = [] for i in range(2 ** n): subset = set() for j in range(n): if i & (1 << j): subset.add(nums[j]) result.append(subset) return sorted(result, key=lambda s: (len(s), [nums.index(x) for x in s]))"},{"question":"*** You are given a list of integers `lst` and an integer `n`. Write a function `filter_by_frequency(lst, n)` that returns a new list containing each element from `lst` at most `n` times, without reordering the elements. # Input: * `lst`: List of integers (1 <= len(lst) <= 10^5, -10^9 <= lst[i] <= 10^9) * `n`: Integer, representing the maximum frequency allowed for any element (0 <= n <= len(lst)) # Output: * A new list of integers filtered based on the conditions described. # Example: * Input: `lst = [1, 2, 3, 1, 2, 1, 2, 3]`, `n = 2` * Output: `[1, 2, 3, 1, 2, 3]` * Input: `lst = [5, 5, 5, 5, 5]`, `n = 1` * Output: `[5]` # Constraints * Ensure the solution has a time complexity of O(n) due to input size limitations. * Handle edge cases where `lst` is empty or `n` is zero, in which case the output should also be an empty list. * Consider using hash tables or similar data structures to maintain element frequency counts efficiently. # Solution Template: ```python def filter_by_frequency(lst, n): # Your implementation here pass ``` Your function will be tested with the provided test cases and additional edge cases to ensure robustness.","solution":"def filter_by_frequency(lst, n): Return a list where each element appears at most \'n\' times. Args: lst (List[int]): List of integers. n (int): Maximum allowed frequency of any element. Returns: List[int]: New list with each element appearing at most \'n\' times. if n == 0: return [] from collections import defaultdict frequency = defaultdict(int) result = [] for item in lst: if frequency[item] < n: result.append(item) frequency[item] += 1 return result"},{"question":"# Question: Implement Enhanced Selection Sort **Context**: You are a software engineer improving an existing codebase. The current `selection_sort` algorithm is employed to sort arrays, but it does not handle some practical scenarios effectively. For example, arrays can contain duplicate elements, and sometimes we want to sort the elements in descending order. Also, the function should provide a more detailed simulation log. **Task**: Implement an enhanced version of the `selection_sort` function. The new function should: 1. Support both ascending and descending sorting orders via an additional argument. 2. Provide detailed simulation logs, printing each swap operation in addition to the intermediate states. 3. Handle arrays with duplicate elements correctly. **Function Signature**: ```python def enhanced_selection_sort(arr: list, order: str = \'asc\', simulation: bool = False) -> list: ``` **Input**: * `arr` (list of integers): The list to be sorted. * `order` (str): Sorting order, \'asc\' for ascending and \'desc\' for descending. Default is \'asc\'. * `simulation` (bool): If True, prints the detailed simulation logs. Default is False. **Output**: * Returns the sorted list. **Constraints**: * The given list `arr` can be empty. * Elements of `arr` are integers, which can be positive, negative, or zero. * The `order` parameter must be either \'asc\' or \'desc\'. **Example**: ```python print(enhanced_selection_sort([5, 3, 8, 4, 2], \'asc\', True)) # Expected simulation output: # Iteration 0: [5, 3, 8, 4, 2] # Swap index 0 with 4: [2, 3, 8, 4, 5] # Iteration 1: [2, 3, 8, 4, 5] # Swap index 1 with 1: [2, 3, 8, 4, 5] # Iteration 2: [2, 3, 8, 4, 5] # Swap index 2 with 3: [2, 3, 4, 8, 5] # Iteration 3: [2, 3, 4, 8, 5] # Swap index 3 with 4: [2, 3, 4, 5, 8] # Iteration 4: [2, 3, 4, 5, 8] # Final sorted array: [2, 3, 4, 5, 8] print(enhanced_selection_sort([10, 7, -5, 3, -1], \'desc\', False)) # Output: [10, 7, 3, -1, -5] ``` **Note**: * Ensure that your function adheres strictly to the function signature provided. * Carefully consider the sorting order and handle any edge cases adequately. * Pay attention to the clarity of simulation logs to align with the expected output format.","solution":"def enhanced_selection_sort(arr: list, order: str = \'asc\', simulation: bool = False) -> list: Sorts the list using an enhanced selection sort algorithm. Parameters: arr (list): List of integers to sort. order (str): Either \'asc\' for ascending or \'desc\' for descending order. simulation (bool): If True, prints detailed simulation logs. Returns: list: Sorted list of integers. def compare(a, b): if order == \'asc\': return a < b return a > b n = len(arr) for i in range(n): min_max_idx = i for j in range(i + 1, n): if compare(arr[j], arr[min_max_idx]): min_max_idx = j if min_max_idx != i: arr[i], arr[min_max_idx] = arr[min_max_idx], arr[i] if simulation: print(f\'Swap index {i} with {min_max_idx}: {arr}\') elif simulation: print(f\'No swap needed at index {i}: {arr}\') return arr"},{"question":"Scenario You have been tasked with implementing a stream processing system that needs to identify if there is a unique non-negative integer that remains uncanceled by the end of the stream. This unique number is termed as 1-sparse. Task Implement a function `one_sparse(array)` that accepts a stream of tuples, each containing a non-negative integer and a sign (`\'+\'` or `\'-\'`). Your goal is to determine if the stream is 1-sparse and return the unique number if it exists, or `None` otherwise. Input - `array`: A list of tuples `(n, sign)` where `n` is a non-negative integer and `sign` is either `\'+\'` or `\'-\'`. Output - If the stream is 1-sparse, return the unique number. - If the stream is not 1-sparse, return `None`. Constraints - All integers in the tuples are non-negative. - The length of the `array` is in the range [1, 10^5]. - The integers are within the range [0, 10^9]. Function Signature ```python def one_sparse(array: List[Tuple[int, str]]) -> Optional[int]: ``` Examples ```python # Example 1 # Input: [(4,\'+\'), (2,\'+\'),(2,\'-\'),(4,\'+\'),(3,\'+\'),(3,\'-\')] # Output: 4 # Explanation: Numbers 2 and 3 cancel out, leaving only 4 as the unique number. # Example 2 # Input: [(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\')] # Output: 2 # Explanation: Only the number 2 is present, making it 1-sparse. # Example 3 # Input: [(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(1,\'+\')] # Output: None # Explanation: Multiple distinct numbers present, hence not 1-sparse. ``` Your implementation should reflect a sound understanding of bit-sum manipulations and stream processing concepts. Thoroughly test your solution with various edge cases to ensure correctness.","solution":"def one_sparse(array): num_count = {} for num, sign in array: if sign == \'+\': if num in num_count: num_count[num] += 1 else: num_count[num] = 1 elif sign == \'-\': if num in num_count: num_count[num] -= 1 if num_count[num] == 0: del num_count[num] if len(num_count) == 1: return list(num_count.keys())[0] else: return None"},{"question":"# Unique Character Extraction with Custom Case Sensitivity Problem Statement You are given a string as input and you need to remove any recurring characters, returning a new string with only the first occurrence of each character preserved. Additionally, you are required to handle strings with case sensitivity per a given parameter. Function Signature ```python def unique_characters(string: str, case_sensitive: bool) -> str: pass ``` Input * A string `string` (with up to (10^5) characters). * A boolean `case_sensitive` that specifies whether character comparison should be case-sensitive: * `True`: Treat uppercase and lowercase letters as distinct characters. * `False`: Treat uppercase and lowercase letters as the same character. # Output * Returns a new string containing only the first occurrence of each character from the input string, considering the case sensitivity. Constraints * The function should run with ( O(n) ) time complexity. * The function should handle edge cases efficiently. # Examples ```python # Example 1 (Case Sensitive) assert unique_characters(\\"Programming\\", True) == \\"Progamin\\" # Example 2 (Case Insensitive) assert unique_characters(\\"Programming\\", False) == \\"Progamin\\" # Example 3 (Empty String) assert unique_characters(\\"\\", True) == \\"\\" # Example 4 (Case Sensitive with Repeated Characters) assert unique_characters(\\"aAaA\\", True) == \\"aA\\" # Example 5 (Case Insensitive with Repeated Characters) assert unique_characters(\\"aAaA\\", False) == \\"a\\" ```","solution":"def unique_characters(string: str, case_sensitive: bool) -> str: Returns a new string containing only the first occurrence of each character from the input string, considering the case sensitivity. :param string: Input string :param case_sensitive: Boolean flag for case sensitivity :return: String with unique characters seen = set() result = [] for char in string: check_char = char if case_sensitive else char.lower() if check_char not in seen: seen.add(check_char) result.append(char) return \'\'.join(result)"},{"question":"You are given a number, and you need to find the next higher number that can be formed using the exact same set of digits as the original number. If no such number exists, return `-1`. # Function Signature ```python def next_bigger(num: int) -> int: ``` # Input - `num` (int): A positive integer. # Output - `int`: The next higher number formed with the same digits, or `-1` if no such number exists. # Constraints - The input number will be within the range of a 32-bit integer. - You must not use any additional libraries apart from standard Python libraries. # Examples ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(54321) == -1 assert next_bigger(5) == -1 assert next_bigger(99999) == -1 ``` # Brief Context Imagine you are working on a text-based puzzle game where players rearrange digits to form the lexicographically next larger permutation. Your task is to implement an efficient function to solve this problem automatically for any given number. # Notes - Ensure that your implementation handles edge cases effectively. - Consider performance implications for very large numbers with multiple digits.","solution":"def next_bigger(num: int) -> int: Returns the next higher number that can be formed using the exact same set of digits as the original number. If no such number exists, returns -1. num_str = list(str(num)) n = len(num_str) # Step 1: Find the first digit that can be made bigger by swapping i = n - 2 while i >= 0 and num_str[i] >= num_str[i + 1]: i -= 1 if i == -1: return -1 # No larger number can be formed # Step 2: Find the smallest digit on the right side of (i) which is bigger than num_str[i] j = n - 1 while num_str[j] <= num_str[i]: j -= 1 # Step 3: Swap the found digits i and j num_str[i], num_str[j] = num_str[j], num_str[i] # Step 4: Sort the digits after the (i)-th position num_str = num_str[:i + 1] + sorted(num_str[i + 1:]) return int(\'\'.join(num_str))"},{"question":"Scenario A local bookstore needs to sort their inventory of books based on the ascending order of book IDs to streamline the search process. They have implemented a basic version of Merge Sort but realized their inventory size can be quite large, leading to high space usage. Your task is to implement an improved version of Merge Sort that minimizes additional space usage. Task Implement the `merge_sort` function that sorts a given list of book IDs in ascending order using an optimized version of Merge Sort that minimizes additional space complexity. Requirements 1. **Function Name**: `merge_sort_optimized` 2. **Input**: A list of integers, `book_ids`, representing the book IDs. 3. **Output**: A sorted list of integers in ascending order. 4. **Constraints**: - The length of the list, `n`, will be in the range [0, 10^5]. - The elements in the list will be integers. Evaluation Criteria - Correctness: The function should correctly sort the list. - Efficiency: The function should run within the time complexity of O(n log n). - Minimal additional space usage compared to standard Merge Sort. Example ```python def merge_sort_optimized(book_ids): # Your implementation here # Example usage book_ids = [101, 25, 82, 5, 210, 107] sorted_books = merge_sort_optimized(book_ids) print(sorted_books) # Output: [5, 25, 82, 101, 107, 210] ``` Your solution should be efficient and handle potential edge cases, such as empty input lists and lists with only one element.","solution":"def merge_sort_optimized(book_ids): Sorts a list of book IDs in ascending order using an optimized version of merge sort that minimizes additional space complexity. if len(book_ids) <= 1: return book_ids temp_array = [0] * len(book_ids) _merge_sort(book_ids, temp_array, 0, len(book_ids) - 1) return book_ids def _merge_sort(arr, temp_array, left, right): if left < right: middle = (left + right) // 2 _merge_sort(arr, temp_array, left, middle) _merge_sort(arr, temp_array, middle + 1, right) _merge(arr, temp_array, left, middle, right) def _merge(arr, temp_array, left, middle, right): for i in range(left, right + 1): temp_array[i] = arr[i] i = left j = middle + 1 k = left while i <= middle and j <= right: if temp_array[i] <= temp_array[j]: arr[k] = temp_array[i] i += 1 else: arr[k] = temp_array[j] j += 1 k += 1 while i <= middle: arr[k] = temp_array[i] i += 1 k += 1 while j <= right: arr[k] = temp_array[j] j += 1 k += 1 # Example usage book_ids = [101, 25, 82, 5, 210, 107] sorted_books = merge_sort_optimized(book_ids) print(sorted_books) # Output: [5, 25, 82, 101, 107, 210]"},{"question":"# Question: You are tasked with verifying whether the elements in a given stack are in non-decreasing order, from the bottom to the top. **Function Signature:** ```python def is_sorted(stack: list) -> bool: ``` **Input:** * A list `stack` of integers representing the stack, where `stack[0]` is the bottom of the stack and `stack[-1]` is the top. **Output:** * Return `True` if the stack elements are in non-decreasing order from bottom to top, otherwise return `False`. # Constraints: * The stack may contain up to 10^5 elements. * Values of elements range from `-10^6` to `10^6`. # Performance Requirements: Your solution should maintain a time complexity of O(n) and space complexity of O(n). # Examples: ```python assert is_sorted([6, 3, 5, 1, 2, 4]) == False assert is_sorted([1, 2, 3, 4, 5, 6]) == True assert is_sorted([1, 1, 1, 1]) == True assert is_sorted([]) == True assert is_sorted([2]) == True ``` # Scenario: Imagine you\'re developing a tool that processes a batch of data logs. Each log is stored in a stack, and you need to ensure that the timestamps (represented as integers) increase from the oldest at the bottom to the most recent at the top. This function determines if a log stack is correctly ordered without altering its structure. # Hints: - Carefully handle edge cases such as empty stacks or stacks with a single element. - Ensure any auxiliary structures used to verify the order don\'t modify the input stack. Write the function `is_sorted` that performs this check efficiently.","solution":"def is_sorted(stack: list) -> bool: Returns True if the stack elements are in non-decreasing order from bottom to top, otherwise False. for i in range(1, len(stack)): if stack[i] < stack[i - 1]: return False return True"},{"question":"# Coding Challenge: Implementing Optimized Merge Sort Context: You are tasked with implementing an optimized version of merge sort that reduces the memory overhead usually associated with this algorithm. Traditional merge sort implementations use additional arrays to manage sorting during the merge phase. Your goal is to refactor merge sort to work in-place to save space. Problem Statement: Write a function `merge_sort_in_place(arr, start, end)` that sorts the input list `arr` in ascending order in-place using the merge sort algorithm. You need to avoid using additional arrays for merging if possible. Function Signature: ```python def merge_sort_in_place(arr, start, end): pass ``` Constraints: - The function should sort the array `arr` in-place, i.e., it should not create new arrays during the merge step. - Use the helper function `merge_in_place(arr, start, mid, end)` to merge two contiguous subarrays in-place. - The input list can contain up to `10^5` elements. Input: - `arr`: A list of integers, `len(arr)` ≤ 10^5 - `start`: The starting index of the section to be sorted - `end`: The ending index of the section to be sorted Output: - The function should return `None`. The input list itself should be modified to reflect the sorted order. Example: ```python arr = [38, 27, 43, 3, 9, 82, 10] merge_sort_in_place(arr, 0, len(arr) - 1) print(arr) # Output should be [3, 9, 10, 27, 38, 43, 82] ``` Implementation Details: 1. **Recursive Divide Step**: Recursively split the array until subarrays have size one. 2. **In-Place Merge Step**: Use the `merge_in_place` helper to merge sorted subarrays: ```python def merge_in_place(arr, start, mid, end): start2 = mid + 1 if arr[mid] <= arr[start2]: return while start <= mid and start2 <= end: if arr[start] <= arr[start2]: start += 1 else: value = arr[start2] index = start2 while index != start: arr[index] = arr[index-1] index -= 1 arr[start] = value start += 1 mid += 1 start2 += 1 ``` 3. **Recursive Sort Function**: Implement the `merge_sort_in_place` function to manage the recursive division and in-place merging: ```python def merge_sort_in_place(arr, start, end): if start < end: mid = start + (end - start) // 2 merge_sort_in_place(arr, start, mid) merge_sort_in_place(arr, mid + 1, end) merge_in_place(arr, start, mid, end) ``` Ensure that your implementation adheres to the constraints and correctly sorts the array in-place.","solution":"def merge_in_place(arr, start, mid, end): start2 = mid + 1 if arr[mid] <= arr[start2]: return while start <= mid and start2 <= end: if arr[start] <= arr[start2]: start += 1 else: value = arr[start2] index = start2 while index != start: arr[index] = arr[index - 1] index -= 1 arr[start] = value start += 1 mid += 1 start2 += 1 def merge_sort_in_place(arr, start, end): if start < end: mid = start + (end - start) // 2 merge_sort_in_place(arr, start, mid) merge_sort_in_place(arr, mid + 1, end) merge_in_place(arr, start, mid, end)"},{"question":"You need to implement a data structure that supports adding words and searching with the ability to use a wildcard character \'.\' which can match any letter. Your implementation should create two different solutions: one using a Trie and one using a Hashmap. # Requirements 1. Implement the `WordDictionary` class with the following methods: - `add_word(String word)`: Adds a word to the data structure. - `search(String word)`: Returns `True` if the word (including \'.\' as any letter) is in the data structure, else returns `False`. # Constraints - Words are non-empty and consist only of lowercase letters (\'a\' to \'z\'). - Each method call of `add_word` and `search` will have at most `1000` operations. # Input/Output Format - **Input**: Series of operations; each operation is formatted as a string according to the method name and argument, e.g., `add_word(\\"word\\")` or `search(\\"w.rd\\")`. - **Output**: For `search`, return `True` or `False`; no output for `add_word`. # Example ```plaintext operations = [ (\\"add_word\\", \\"bad\\"), (\\"add_word\\", \\"dad\\"), (\\"add_word\\", \\"mad\\"), (\\"search\\", \\"pad\\"), # False (\\"search\\", \\"bad\\"), # True (\\"search\\", \\".ad\\"), # True (\\"search\\", \\"b..\\") # True ] ``` # Expectations Your solution should demonstrate a solid understanding of Trie and Hashmap usage and performance considerations in the context of string search operations.","solution":"class WordDictionaryTrie: def __init__(self): self.trie = {} def add_word(self, word): node = self.trie for char in word: node = node.setdefault(char, {}) node[\'#\'] = True # End of word marker def search(self, word): def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': return any(search_in_node(word[i + 1:], node[x]) for x in node if x != \'#\') if char not in node: return False node = node[char] return \'#\' in node return search_in_node(word, self.trie) class WordDictionaryHashMap: def __init__(self): self.word_dict = {} def add_word(self, word): length = len(word) if length not in self.word_dict: self.word_dict[length] = [] self.word_dict[length].append(word) def search(self, word): length = len(word) if length not in self.word_dict: return False for candidate in self.word_dict[length]: if all(candidate[i] == word[i] or word[i] == \'.\' for i in range(length)): return True return False"},{"question":"# Coding Problem: Find the Modular Order Scenario In modern cryptographic schemes, finding the order of numbers under modular arithmetic is a frequent and important operation. The *order* of a number \'a\' modulo \'n\' is the smallest positive integer k such that (a^k equiv 1 (text{mod } n)). Here, we explore the computational approach to determine this order given that the numbers are coprime. Task Write a function `find_order(a: int, n: int) -> int` that finds the smallest positive integer k such that (a^k equiv 1 (text{mod } n)), given a and n are coprime numbers. If no such k exists, return -1. Function Signature ```python def find_order(a: int, n: int) -> int: pass ``` Input - An integer `a` (1 <= a <= 10^6): The base number. - An integer `n` (1 <= n <= 10^6): The modulus. Output - An integer representing the order of `a modulo n`. If no such order exists, return -1. Constraints - Ensure that `gcd(a, n) = 1`; otherwise, return -1 immediately. Example ```python assert find_order(2, 5) == 4 assert find_order(2, 6) == -1 # gcd(2, 6) != 1 assert find_order(3, 7) == 6 ``` Hints: - Use Python\'s built-in `pow` function for efficient exponentiation. - Consider edge cases where n or a equals to 1. Performance Requirements: Your solution should handle inputs up to the maximum constraints efficiently.","solution":"import math def find_order(a: int, n: int) -> int: Finds the smallest positive integer k such that a^k ≡ 1 (mod n). If no such k exists, returns -1. # Check if gcd(a, n) is 1 if math.gcd(a, n) != 1: return -1 # Initialize k and a_mod k = 1 a_mod = a % n # Check for the order while k < n: if a_mod == 1: return k a_mod = (a_mod * a) % n k += 1 return -1"},{"question":"# Question Objective Implement the Bubble Sort algorithm in Python with the following requirements: 1. **Function Signature** ```python def bubble_sort(arr: list[int], simulation: bool=False) -> list[int]: ``` 2. **Input**: * `arr`: A list of integers (1 ≤ len(arr) ≤ 10000). * `simulation`: A boolean flag to enable/disable simulation output (Default: False). 3. **Output**: * Return a sorted list of integers in non-decreasing order. 4. **Constraints**: * The algorithm should handle empty lists and lists with all identical elements. * The algorithm should print each intermediate step when `simulation` is set to `True`. 5. **Performance Requirements**: * Optimize the algorithm to exit early if the list becomes sorted before completing all passes. Example ```python print(bubble_sort([3, 2, 1], simulation=True)) # Expected Output: # iteration 0 : 3 2 1 # iteration 1 : 2 3 1 # iteration 2 : 2 1 3 # iteration 3 : 1 2 3 # [1, 2, 3] print(bubble_sort([], simulation=True)) # Expected Output: # [] ``` Description This implementation should simulate the sorting process by printing the intermediate steps if the `simulation` parameter is set to `True`, showing the state of the list after each swap operation. The output follows the format shown in the example. Write a function to implement Bubble Sort adhering to the above constraints and ensuring the performance is optimized by terminating early if no more swaps are needed in a pass.","solution":"def bubble_sort(arr: list[int], simulation: bool=False) -> list[int]: Sorts an array using the bubble sort algorithm. Optionally prints each intermediate step. Parameters: arr (list[int]): the list of integers to sort. simulation (bool): if set to True, prints the list after each iteration and swap. Returns: list[int]: the sorted list of integers. n = len(arr) for i in range(n): swapped = False if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") for j in range(n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if simulation: print(f\\"swapped {arr[j]} and {arr[j+1]}: {\' \'.join(map(str, arr))}\\") if not swapped: break # Exit if no elements were swapped during the inner loop return arr"},{"question":"You are required to implement the `max_sliding_window(nums, k)` function that returns the maximum element from each sliding window of size `k` in the given array `nums`. Function Signature ```python def max_sliding_window(nums: List[int], k: int) -> List[int]: pass ``` # Input - `nums`: A list of integers representing an array. - `k`: An integer representing the size of the sliding window. # Output - A list of integers representing the maximum elements from each sliding window. # Constraints - The length of `nums` will be in the range `[0, 10^5]`. - `k` will be in the range `[1, len(nums)]`. # Example ```python Input: nums = [1, 3, -1, -3, 5, 3, 6, 7] k = 3 Output: [3, 3, 5, 5, 6, 7] ``` # Performance Requirements Your solution should run in O(n) time where n is the length of the input array `nums`. # Edge Cases to Consider - An empty array. - A window size `k` that equals the length of `nums`. - Sequential and repeated numbers in the array. # Notes - It\'s important to update the sliding window efficiently without re-calculating the maximum for each window by iterating the window each time. # Context Imagine that you are analyzing a series of stock prices to find the maximum price in any given period. Here you use a fixed size window that moves along the time series of prices to find the maximum value within that period.","solution":"from typing import List from collections import deque def max_sliding_window(nums: List[int], k: int) -> List[int]: if not nums or k == 0: return [] result = [] deq = deque() # will store indices of elements, elements are in decreasing order for i in range(len(nums)): # Remove indices that are out of bound if deq and deq[0] == i - k: deq.popleft() # Remove elements from deq that are smaller than current element nums[i] while deq and nums[deq[-1]] < nums[i]: deq.pop() # Add current element at the end of the deque deq.append(i) # Start recording the result from the index i >= k-1 if i >= k-1: result.append(nums[deq[0]]) return result"},{"question":"# Atbash Cipher Implementation **Objective**: Write a function that applies the Atbash cipher to a given input string. **Scenario**: You are tasked with developing a simple encryption mechanism for a text-based game. The requirement is to apply the Atbash cipher to all messages that will be communicated within the game. # Function Signature ```python def atbash(s: str) -> str: pass ``` # Input - `s` (string): A text string which can contain alphabetical characters (both upper and lower case) and non-alphabetical characters such as punctuation and spaces. # Output - (string): The input string encrypted with the Atbash cipher. # Example ```python assert atbash(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert atbash(\\"Hello, World!\\") == \\"Svool, Dliow!\\" assert atbash(\\"\\") == \\"\\" ``` # Constraints - The input string `s` will have a length between 1 and 10^5 characters. - The function should return the resulting string in a reasonable amount of time. # Notes - Ensure that non-alphabetic characters remain unchanged. - Handle both upper case and lower case letters appropriately.","solution":"def atbash(s: str) -> str: def cipher(c): if \'a\' <= c <= \'z\': return chr(ord(\'z\') - (ord(c) - ord(\'a\'))) if \'A\' <= c <= \'Z\': return chr(ord(\'Z\') - (ord(c) - ord(\'A\'))) return c return \'\'.join(cipher(c) for c in s)"},{"question":"# Topological Sort Implementation Problem: You are provided with a directed graph represented as an adjacency list. Your task is to write a function `top_sort_recursive` and a function `top_sort_iterative` to perform a topological sort of the nodes in this graph using both recursive and iterative methodologies. If the graph contains a cycle, the function should raise a `ValueError` with the message \\"cycle\\". Input: - `graph`: A dictionary where keys are node identifiers and values are lists of nodes that the key node points to directly. Output: - A list of nodes in topologically sorted order. Constraints: - The graph is a Directed Acyclic Graph (DAG), meaning it has no cycles. - Node identifiers can be any hashable type. - If graph contains a cycle, raise a `ValueError` with the message \\"cycle\\". Example: **Input:** ```python graph = { \\"a\\": [\\"c\\"], \\"b\\": [\\"c\\", \\"d\\"], \\"c\\": [\\"e\\"], \\"d\\": [\\"f\\"], \\"e\\": [\\"h\\", \\"f\\"], \\"f\\": [\\"g\\"], \\"h\\": [], \\"g\\": [] } ``` **Output:** ```python [\'a\', \'b\', \'c\', \'d\', \'e\', \'h\', \'f\', \'g\'] ``` Notes: - Multiple valid topological orders may exist depending on the structure of the graph. - Ensure your solution handles large graphs efficiently. - Consider all edge cases like empty graphs, graphs with single nodes, and chains of nodes. Task: Implement the below functions: ```python def top_sort_recursive(graph): Implement topological sort using recursive approach def top_sort_iterative(graph): Implement topological sort using iterative approach ```","solution":"def top_sort_recursive(graph): Implement topological sort using recursive DFS approach. def dfs(node, visited, temp_mark, result): if node in temp_mark: raise ValueError(\\"cycle\\") if node not in visited: temp_mark.add(node) for neighbour in graph.get(node, []): dfs(neighbour, visited, temp_mark, result) temp_mark.remove(node) visited.add(node) result.insert(0, node) visited = set() temp_mark = set() result = [] for node in graph: if node not in visited: dfs(node, visited, temp_mark, result) return result def top_sort_iterative(graph): Implement topological sort using iterative approach with Kahn\'s algorithm. from collections import deque def find_indegrees(graph): indegrees = {node: 0 for node in graph} for edges in graph.values(): for node in edges: if node in indegrees: indegrees[node] += 1 else: indegrees[node] = 1 return indegrees indegrees = find_indegrees(graph) queue = deque([node for node in graph if indegrees[node] == 0]) result = [] while queue: node = queue.popleft() result.append(node) for neighbour in graph.get(node, []): indegrees[neighbour] -= 1 if indegrees[neighbour] == 0: queue.append(neighbour) if len(result) != len(graph): raise ValueError(\\"cycle\\") return result"},{"question":"You are tasked with implementing a function that computes the GCD of two non-negative integers a and b using an optimized algorithm that combines both the traditional Euclidean algorithm and bitwise operations. Your function should handle common edge cases and potential pitfalls. You are also required to implement a function that computes the LCM of two non-negative integers using the GCD function you implement. # Function Signatures: 1. `def optimized_gcd(a: int, b: int) -> int:` 2. `def optimized_lcm(a: int, b: int) -> int:` # Input - Two non-negative integers `a` and `b` in the range [0, 10^9]. # Output - For `optimized_gcd(a, b)`: An integer, the greatest common divisor of `a` and `b`. - For `optimized_lcm(a, b)`: An integer, the least common multiple of `a` and `b`. # Constraints - You must use bitwise operations to optimize the GCD calculation. - Your solution should handle edge cases such as zero values properly. - The functions should be efficient and use O(1) additional memory. # Examples ```python assert optimized_gcd(48, 18) == 6 assert optimized_gcd(0, 34) == 34 assert optimized_lcm(5, 10) == 10 assert optimized_lcm(0, 10) == 0 ``` # Notes - Remember that the LCM of any number with zero is zero. - Handle negative integers by taking their absolute values before processing. # Explanation 1. **GCD Calculation**: Use a combination of the Euclidean algorithm and bitwise operations to optimize the process. 2. **LCM Calculation**: Calculate the LCM using the formula `LCM(a, b) = abs(a * b) / GCD(a, b)`.","solution":"def optimized_gcd(a: int, b: int) -> int: Compute the greatest common divisor (GCD) of two non-negative integers a and b using a combination of the Euclidean algorithm and bitwise operations. if a == 0: return b if b == 0: return a # Finding the largest power of 2 that divides both a and b using bitwise operations shift = 0 while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b = b - a return a << shift def optimized_lcm(a: int, b: int) -> int: Compute the least common multiple (LCM) of two non-negative integers a and b using the GCD function. if a == 0 or b == 0: return 0 gcd = optimized_gcd(a, b) return (a // gcd) * b"},{"question":"# Question Context You are required to implement a function to manipulate a stack by switching successive pairs of elements, keeping the same order for the elements in relation to pairs reversed starting from the bottom. Problem Statement Write a function `switch_pairs_using_stack` that takes a stack (represented as a list in Python) and switches successive pairs of elements, starting from the bottom of the stack. If the stack contains an odd number of elements, the element at the top of the stack should remain in place. Function Signature ```python def switch_pairs_using_stack(stack: list) -> list: pass ``` Input - `stack`: A list of integers representing the stack. The last element of the list is considered the top of the stack. Output - Return a list of integers representing the stack after switching pairs. Constraints - The number of elements in the stack is `n` where (0 leq n leq 10^4). - All elements in the stack are unique integers. Examples ```python # Example 1 input_stack = [3, 8, 17, 9, 1, 10] output_stack = switch_pairs_using_stack(input_stack) print(output_stack) # [8, 3, 9, 17, 10, 1] # Example 2 input_stack = [3, 8, 17, 9, 1] output_stack = switch_pairs_using_stack(input_stack) print(output_stack) # [8, 3, 9, 17, 1] # Example 3 input_stack = [] output_stack = switch_pairs_using_stack(input_stack) print(output_stack) # [] ``` Notes 1. Your implementation should only use a single auxiliary stack as additional storage. 2. Perform proper error checks for edge cases like an empty stack and an odd number of elements. 3. Avoid using additional data structures like queues unless it helps to optimize the solution.","solution":"def switch_pairs_using_stack(stack: list) -> list: Switches successive pairs of elements in the stack, starting from the bottom. If the stack has an odd number of elements, the top element remains in place. Args: stack (list): The stack represented as a list. Returns: list: The stack after switching pairs. n = len(stack) aux_stack = [] # Move all elements to auxiliary stack while stack: aux_stack.append(stack.pop()) # Process pairs and put them back in the original stack while aux_stack: # Pop one element elem1 = aux_stack.pop() if aux_stack: # Pop second element if exists elem2 = aux_stack.pop() # Push pair in reverse order to original stack stack.append(elem2) stack.append(elem1) else: # Push the last single element if the count is odd stack.append(elem1) return stack"},{"question":"Objective Design a function called `fast_fib` to efficiently compute the n-th Fibonacci number. This function should focus on minimizing time complexity and space usage. Task You are expected to write a function `fast_fib(n: int) -> int` that adheres to the following requirements: * **Input**: * `n` (integer) - a non-negative integer where 0 ≤ n ≤ 10^6. * **Output**: * Returns the n-th Fibonacci number. * **Constraints**: * The solution should efficiently handle the upper limit of `n = 10^6`. * Aim for O(n) time complexity with optimized space usage closer to O(1). * **Performance**: * Ensure the implementation does not use excessive memory even for large values of `n`. Example 1. Example 1: ```python fast_fib(0) ``` Output: ```python 0 ``` 2. Example 2: ```python fast_fib(1) ``` Output: ```python 1 ``` 3. Example 3: ```python fast_fib(10) ``` Output: ```python 55 ``` 4. Example 4: ```python fast_fib(255) ``` Output: ```python 34787592015866493875 ``` Constraints * Input Integer `n` such that 0 ≤ n ≤ 10^6.","solution":"def fast_fib(n: int) -> int: Computes the n-th Fibonacci number using an iterative approach with an optimized space usage. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Quick Sort Implementation with Optimization Problem Statement You are required to implement an optimized version of the Quick Sort algorithm. Your task is to handle large arrays efficiently, minimize the risk of the worst-case performance, and improve the average-case performance by implementing a pivot selection strategy. Specifically, use the median-of-three method to choose the pivot. Input Format * An unsorted list of integers `arr` (length (1 leq n leq 10^5)). Output Format * The sorted list of integers. Constraints * All integers in the list are within the range (-10^9 leq text{arr[i]} leq 10^9). Performance Requirements * The implementation should ensure average-case performance of (O(n log n)) and should handle edge cases like already sorted arrays efficiently. Example ```python Input: arr = [3, 6, 8, 10, 1, 2, 1] Output: [1, 1, 2, 3, 6, 8, 10] ``` Implementation Details Implement the function `optimized_quick_sort(arr)` which takes an unsorted list of integers `arr` and returns the sorted list. # Additional Notes Ensure you handle edge cases like: * Empty arrays. * Arrays with a single element. * Arrays with all identical elements. * Very large arrays. * Arrays that are already sorted in ascending or descending order.","solution":"def median_of_three(arr, low, high): mid = (low + high) // 2 a, b, c = arr[low], arr[mid], arr[high] if a > b: if a < c: median = low elif b > c: median = mid else: median = high else: if a > c: median = low elif b < c: median = mid else: median = high return median def partition(arr, low, high): pivot_index = median_of_three(arr, low, high) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort_recursive(arr, low, high): if low < high: pi = partition(arr, low, high) quick_sort_recursive(arr, low, pi - 1) quick_sort_recursive(arr, pi + 1, high) def optimized_quick_sort(arr): Perform an optimized QuickSort on the array with median-of-three pivot selection. Returns the sorted array. if len(arr) <= 1: return arr quick_sort_recursive(arr, 0, len(arr) - 1) return arr"},{"question":"You are given a number, and your task is to determine if the number is prime. Implement the function `is_prime` to accurately check for the primality of a given integer `n`. # Function Signature ```python def is_prime(n: int) -> bool: ``` # Input - `n` (integer): The number to check for primality. The value of `n` can range from ( -10^9 ) to ( 10^9 ). # Output - Returns `True` if `n` is a prime number, otherwise returns `False`. # Constraints - If `n` <= 1, the function should return `False`. - The code should efficiently handle values up to ( 10^9 ). # Examples ```python assert is_prime(29) == True assert is_prime(15) == False assert is_prime(1) == False assert is_prime(2) == True assert is_prime(7919) == True assert is_prime(-17) == False ``` # Performance Requirements Your solution must be efficient and able to handle large values of `n` within reasonable time limits. Aim for a time complexity around ( O(sqrt{n}) ). # Additional Context Prime numbers are hightly important in various fields, including cryptography and number theory. Ensuring efficient and accurate checking helps in developing robust systems that rely on prime number properties. **Implement the `is_prime` function below:** ```python def is_prime(n): # Your code here ```","solution":"def is_prime(n: int) -> bool: Checks if a given number n is prime. Returns True if n is prime, else False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"Using the provided `Monomial` and `Polynomial` classes, your task is to implement a function that computes the derivative of a given polynomial with respect to a specific variable. # Background A derivative of a polynomial with respect to a variable reflects the rate of change of the polynomial with respect to that variable. For a monomial (a_i^j), the derivative with respect to (a_i) is (j cdot a_i^{j-1}). # Function Signature ```python def compute_derivative(poly: Polynomial, variable_index: int) -> Polynomial: pass ``` # Input - A `Polynomial` object `poly`. - An integer `variable_index`, representing the variable with respect to which the derivative is to be computed, ranging from 1 to n (corresponding to (a_1, a_2, ldots)). # Output - A `Polynomial` object representing the derivative of the input polynomial with respect to `variable_index`. # Constraints - Each variable index is a positive integer. - Handle polynomials consisting of multiple monomials. - Coefficients can be integers, fractions, or floating numbers. # Example Input ```python poly = Polynomial([Monomial({1: 2}, 3), Monomial({2: 1}, 4)]) variable_index = 1 ``` Output ```python result = compute_derivative(poly, 1) print(result) # Should print Polynomial([Monomial({1: 1}, 6)]) ``` # Notes - Ensure your implementation simplifies the polynomial by removing zero terms. - Pay attention to the edge cases where the variables might not be present in some monomials.","solution":"class Monomial: def __init__(self, powers, coefficient): self.powers = powers self.coefficient = coefficient def derivative(self, variable_index): if variable_index in self.powers and self.powers[variable_index] > 0: new_powers = self.powers.copy() new_coefficient = self.coefficient * new_powers[variable_index] new_powers[variable_index] -= 1 if new_powers[variable_index] == 0: del new_powers[variable_index] return Monomial(new_powers, new_coefficient) else: return Monomial({}, 0) def __eq__(self, other): return self.powers == other.powers and self.coefficient == other.coefficient def __repr__(self): return f\\"Monomial(powers={self.powers}, coefficient={self.coefficient})\\" class Polynomial: def __init__(self, monomials): self.monomials = monomials def __repr__(self): return f\\"Polynomial(monomials={self.monomials})\\" def __eq__(self, other): return sorted(self.monomials, key=lambda m: (m.powers, m.coefficient)) == sorted(other.monomials, key=lambda m: (m.powers, m.coefficient)) def compute_derivative(poly, variable_index): derivative_monomials = [] for monomial in poly.monomials: derivative_monomial = monomial.derivative(variable_index) if derivative_monomial.coefficient != 0: derivative_monomials.append(derivative_monomial) return Polynomial(derivative_monomials)"},{"question":"**Scenario**: In a message preprocessing system, you need to filter out repeated characters from the messages to ensure that each character appears only once in the output while preserving their first occurrence order. **Task**: Write a function `delete_reoccurring_characters_modified` that processes a string to remove reoccurring characters while maintaining the first appearance order. **Function Signature**: ```python def delete_reoccurring_characters_modified(s: str) -> str: pass ``` **Input**: - `s`: A string `0 <= len(s) <= 10^5` consisting of ASCII characters. The string can be empty. **Output**: - A string with all reoccurring characters removed while keeping only their first occurrences. **Constraints**: - You should aim for linear time complexity. - You should not use additional data structures beyond what is necessary for the efficiency. **Performance Requirements**: - The function should efficiently handle strings up to (10^5) characters in length within acceptable time limits. **Example**: ```python assert delete_reoccurring_characters_modified(\\"programming\\") == \\"progamin\\" assert delete_reoccurring_characters_modified(\\"abcdabc\\") == \\"abcd\\" assert delete_reoccurring_characters_modified(\\"\\") == \\"\\" assert delete_reoccurring_characters_modified(\\"aabbccdd\\") == \\"abcd\\" ```","solution":"def delete_reoccurring_characters_modified(s: str) -> str: Processes a string to remove reoccurring characters while maintaining the first appearance order. Args: - s (str): The input string consisting of ASCII characters. Returns: - str: A string with all reoccurring characters removed while keeping only their first occurrence. seen = set() result = [] for char in s: if char not in seen: result.append(char) seen.add(char) return \'\'.join(result)"},{"question":"# Question: Determine if a Number is a Power of Two **Context**: You are tasked with developing a function for a memory allocator within an operating system. One step of this function requires you to check whether a given integer is a power of two. This check helps in optimizing address allocation which depends heavily on power-of-two sizes. Your objective is to implement the function efficiently. **Function Specification**: Write a function `is_power_of_two` that determines if a given integer is a power of two. **Input**: - A single integer `n`. **Output**: - Return `True` if `n` is a power of two, otherwise return `False`. **Constraints**: - The integer can be positive, zero, or negative. - You must aim for an optimal solution in terms of time and space complexity. **Example**: ```python assert is_power_of_two(1) == True # 1 is 2^0 assert is_power_of_two(16) == True # 16 is 2^4 assert is_power_of_two(18) == False # 18 is not a power of two assert is_power_of_two(0) == False # 0 is not a power of two assert is_power_of_two(-8) == False # Negative numbers are not powers of two ``` **Edge Cases**: - Ensure zero is correctly identified as not a power of two. - Ensure negative numbers are correctly identified as not a power of two. - Ensure valid handling and checking of large integers. Implement the function with the aforementioned specifications. Your solution should be concise, efficient, and handle the edge cases effectively.","solution":"def is_power_of_two(n): Determines if the given integer is a power of two. :param n: Integer to be checked :return: True if n is a power of two, otherwise False if n <= 0: return False return (n & (n - 1)) == 0"},{"question":"# Reversing a String **Objective**: You are to implement a function to reverse a given string while examining different algorithmic approaches. **Instructions**: Write a Python function `reverse_string(s: str) -> str` that takes a string `s` as input and returns the reversed string. You must compare different implemented approaches and comment on their time complexity, space complexity, and real-world efficiency. **Constraints**: - The input string `s` will have a length `0 <= len(s) <= 10^6`. - Handle both empty and very large strings efficiently. **Function Signature**: ```python def reverse_string(s: str) -> str: pass ``` **Detailed Description**: 1. **Recursive Approach**: - Implement a recursive approach to reverse a string as described. - Analyze its time and space complexity. 2. **Iterative Approach**: - Implement an iterative approach to reverse a string by swapping elements. - Analyze its time and space complexity. 3. **Pythonic Approach**: - Implement a Pythonic approach using built-in functions to reverse a string. - Analyze its time and space complexity. 4. **Ultra-Pythonic Approach**: - Implement a more direct Pythonic approach using slicing to reverse a string. - Analyze its time and space complexity. **Your Task**: Implement all the above approaches in the `reverse_string` function, compare them, and decide which one you\'d use in a real-world application. After selecting your final approach, provide an explanation of your choice focusing on performance, readability, and real-world constraints. **Example**: ```python print(reverse_string(\\"hello\\")) # Output: \\"olleh\\" print(reverse_string(\\"A man, a plan, a canal, Panama\\")) # Output: \\"amanaP ,lanac a ,nalp a ,nam A\\" print(reverse_string(\\"\\")) # Output: \\"\\" ``` **Note**: - You are required to detail your final approach in terms of why it\'s the best in terms of efficiency and readability. - Ensure to handle edge cases.","solution":"def reverse_string(s: str) -> str: Reverses the input string using slicing. This approach is chosen for its simplicity and efficiency in both time and space. return s[::-1]"},{"question":"You need to implement an efficient task management system where tasks have different priority levels. The system should always be able to provide the highest-priority task efficiently. **Scenario**: You are managing a task scheduler where tasks are assigned integer priorities. Lower integer values signify higher priorities (e.g., priority 1 is higher than priority 4). **Task**: You need to implement a class `TaskScheduler` using a Binary Heap. The `TaskScheduler` class should support the following operations: 1. **add_task(priority: int)**: Adds a new task with the given priority to the scheduler. 2. **get_next_task() -> int**: Returns and removes the task with the highest priority (minimum priority value) from the scheduler. If no tasks are in the scheduler, return `None`. # Constraints: * The number of tasks added will be at most 10^5. * The priority values are integers between 1 and 10^6. # Performance Requirements: * These operations (`add_task` and `get_next_task`) should be efficient with a time complexity of O(log N) in the worst case. # Input and Output Format * **add_task** has the input parameter `priority` which is an integer. * **get_next_task** returns an integer which is the priority of the highest-priority task, or `None` if no task exists. # Example ```python # Example usage: ts = TaskScheduler() ts.add_task(5) ts.add_task(3) ts.add_task(7) print(ts.get_next_task()) # Should return 3 print(ts.get_next_task()) # Should return 5 print(ts.get_next_task()) # Should return 7 print(ts.get_next_task()) # Should return None ``` # Implementation: Implement the `TaskScheduler` class by extending the `BinaryHeap` class provided in the initial code snippet. You should not modify the existing methods in the `BinaryHeap` class but instead use them as a base to implement the required functionalities in `TaskScheduler`.","solution":"import heapq class TaskScheduler: def __init__(self): self.heap = [] def add_task(self, priority: int): Adds a new task with the given priority to the scheduler. :param priority: int heapq.heappush(self.heap, priority) def get_next_task(self) -> int: Returns and removes the task with the highest priority (minimum priority value) from the scheduler. If no tasks are in the scheduler, return None. :return: int or None if not self.heap: return None return heapq.heappop(self.heap)"},{"question":"You have been tasked with implementing a sorting function using the Comb Sort algorithm. Your implementation should sort an array of integers in ascending order. Pay close attention to edge cases and ensure optimal performance where possible. # Task Write a Python function `comb_sort(arr)` that implements the Comb Sort algorithm. # Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr`: A list of integers. The list can contain negative numbers, duplicate values, and may be empty. # Output - Returns a list of integers sorted in ascending order. # Constraints - The length of the array `n` can range from `0` to `10^6`. - The elements of the array `arr[i]` can range from `-10^6` to `10^6`. # Performance Requirements - Aim for an average time complexity of O(n log n). - Space complexity should remain O(1). # Example ```python assert comb_sort([]) == [] assert comb_sort([3]) == [3] assert comb_sort([4, 3, 2, 1]) == [1, 2, 3, 4] assert comb_sort([1, 4, 2, 3, -1, -1]) == [-1, -1, 1, 2, 3, 4] ``` Use the provided assertions to test your implementation.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts an array using the comb sort algorithm. if len(arr) < 2: return arr gap = len(arr) shrink = 1.3 sorted = False while not sorted: gap = int(gap / shrink) if gap <= 1: gap = 1 sorted = True i = 0 while i + gap < len(arr): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False i += 1 return arr"},{"question":"You are given an initially empty array that can perform dynamic prefix sum queries and update operations efficiently. Implement the `Fenwick_Tree` class with the following methods: 1. **Constructor**: Initialize the Fenwick Tree with an empty array. 2. **update(i: int, value: int)**: Update the tree by adding `value` to element at index `i`. 3. **query(i: int) -> int**: Compute the prefix sum from the start of the array to index `i`. 4. **construct_from_list(freq: List[int])**: Construct the Fenwick Tree using an initial array `freq`. You need to implement the class such that each update and query operation runs in (O(log n)), where (n) is the number of elements in the array. # Input - **Construct from List**: A list of integers `freq` representing the initial values. - **Update Operation**: An integer `i` (index) and an integer `value` to be added to `arr[i]`. - **Query Operation**: An integer `i` representing the index up to which the prefix sum is needed. # Output - The result of each query operation will be an integer representing the prefix sum up to index `i`. # Constraints - Updates and queries are intermittent and in no particular order. - The size of the array and the number of operations satisfy (1 leq n, text{operations} leq 10^5). # Example ```python # Initialize the tree with the given frequency list ft = Fenwick_Tree() ft.construct_from_list([3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3]) # Output should be 8, because the sum of elements up to index 3 [3, 2, -1, 6] is 10 print(ft.query(3)) # Output: 10 # Update the element at index 3 by adding 6 to it ft.update(3, 6) # Output should be 16, because now the sum of elements up to index 3 [3, 2, -1, 12] is 16 print(ft.query(3)) # Output: 16 ```","solution":"class Fenwick_Tree: def __init__(self): Initialize the Fenwick Tree with an empty array. self.size = 0 self.tree = [] def construct_from_list(self, freq): Construct the Fenwick Tree using an initial array `freq`. self.size = len(freq) self.tree = [0] * (self.size + 1) for i in range(self.size): self.update(i, freq[i]) def update(self, i, value): Update the tree by adding `value` to element at index `i`. i += 1 # Fenwick Tree is 1-indexed while i <= self.size: self.tree[i] += value i += i & -i def query(self, i): Compute the prefix sum from the start of the array to index `i`. sum_ = 0 i += 1 # Fenwick Tree is 1-indexed while i > 0: sum_ += self.tree[i] i -= i & -i return sum_"},{"question":"# Combination Calculation You are required to implement a function that calculates the combination (nCr), which represents the number of ways to choose `r` items from `n` items without regard to the order of selection. You will use dynamic programming to achieve an efficient calculation. Implement a function `combination_dp(n: int, r: int) -> int` that: - Takes two integers `n` and `r` representing the total number of items and the number of items to choose respectively. - Returns an integer, the number of combinations (nCr). # Input - `n` (1 ≤ n ≤ 1000): Total number of items. - `r` (0 ≤ r ≤ n): Number of items to be chosen. # Output Return the number of ways to choose `r` items from `n` items. # Constraints - You need to ensure the implementation is optimal and runs efficiently for the upper limits of input size. - The values of n and r will always ensure that `r <= n`. # Example ```python assert combination_dp(5, 2) == 10 # 5C2 = 10 assert combination_dp(10, 5) == 252 # 10C5 = 252 assert combination_dp(6, 0) == 1 # 6C0 = 1 assert combination_dp(20, 10) == 184756 # 20C10 = 184756 ``` # Explanation For example, to choose 2 items out of 5: ``` 5C2 = 5! / (3! * 2!) = 120 / (6 * 2) = 10 ``` Where `!` denotes factorial. # Notes - Use dynamic programming to avoid the exponential time complexity of the recursive approach. - Ensure that the function handles large inputs efficiently within the given constraints.","solution":"def combination_dp(n: int, r: int) -> int: Calculate the combination (nCr) using dynamic programming. # Early return for edge cases if r == 0 or r == n: return 1 if r > n: return 0 # Create a 2D DP table with all zeros dp = [[0 for _ in range(r + 1)] for _ in range(n + 1)] # Fill the table according to the combination formula for i in range(n + 1): for j in range(min(i, r) + 1): if j == 0 or j == i: dp[i][j] = 1 else: dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] return dp[n][r]"},{"question":"# Bucket Sort Implementation with Optimized Bucketing You are given an array of positive integers ranging from 0 to `k`. Implement an optimized version of the Bucket Sort algorithm. The insertion sort is currently used for sorting individual buckets, but you are required to enhance the sorting mechanism for the buckets. Function Signature ```python def optimized_bucket_sort(arr: List[int], k: int) -> List[int]: ``` Input - `arr`: A list of positive integers. - `k`: An integer representing the known maximum value in the array `arr`. * Constraints: - All integers in the array are between 0 and `k` inclusive. - 1 <= len(arr) <= 10^6 - 0 <= k <= 10^9 Output - A sorted list of integers in ascending order. Requirements - Demonstrate the use of bucket sorting with dynamic bucketing based on the input range. - Optimize the sorting within buckets using an efficient sorting algorithm like QuickSort or MergeSort. # Example ```python # Input arr = [78, 45, 96, 12, 56] k = 100 # Output [12, 45, 56, 78, 96] ``` # Performance Considerations Your solution should handle large input efficiently and gracefully manage edge cases mentioned in the analysis.","solution":"from typing import List def optimized_bucket_sort(arr: List[int], k: int) -> List[int]: Sorts an array of positive integers ranging from 0 to k using bucket sort. The sorting within the buckets is optimized using Python\'s built-in Timsort. if len(arr) == 0: return arr # Number of buckets bucket_count = len(arr) max_value = k + 1 # Create buckets buckets = [[] for _ in range(bucket_count)] # Distribute the array items into the buckets for num in arr: index = num * bucket_count // max_value buckets[index].append(num) # Sort each bucket using Python\'s built-in sort function which is Timsort (O(n log n)) sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"You are given an array of integers, and you need to sort the array using the Counting Sort algorithm. Implement a function `counting_sort(arr)` that takes an array of integers as input and returns a sorted array. # Input: - A single list of integers `arr` with length `n` (1 <= n <= 10^6). - The elements of the array can be negative or positive integers. # Output: - A list of integers, which is the sorted version of the input array. # Constraints: - The integers in the array are within the range -10^6 to 10^6. # Example: ```python assert counting_sort([4, 2, -3, 6, 1, -2, 0]) == [-3, -2, 0, 1, 2, 4, 6] ``` # Requirements: 1. Ensure your implementation handles negative numbers. 2. Optimize for time and space efficiency within the constraints provided. # Function Signature: ```python def counting_sort(arr: List[int]) -> List[int]: # Your code here ``` # Hints: - Consider how you would handle the negative numbers to use the Counting Sort effectively. - Pay attention to the range of the numbers while creating the count array.","solution":"from typing import List def counting_sort(arr: List[int]) -> List[int]: Performs Counting Sort on the input array. Parameters: arr (List[int]): The array of integers to be sorted. Returns: List[int]: The sorted array. if not arr: return arr # Find the min and max values in the array min_value = min(arr) max_value = max(arr) # Create the count array with length equal to the range of the numbers range_of_elements = max_value - min_value + 1 count = [0] * range_of_elements # Store the count of each element for num in arr: count[num - min_value] += 1 # Store the cumulative count for i in range(1, range_of_elements): count[i] += count[i - 1] # Find the index of each element of the original array in the count array # and place the elements in the output array output = [0] * len(arr) for num in reversed(arr): output[count[num - min_value] - 1] = num count[num - min_value] -= 1 return output"},{"question":"Find Two Unique Numbers **Context**: You are given an integer array `nums` where exactly two elements appear only once and all other elements appear exactly twice. Your task is to find the two elements that only appear once. Given the constraint that the solution should have a time complexity of O(N) and a space complexity of O(1), devise an efficient algorithm to achieve this. **Function Signature**: ```python def find_two_unique(nums: List[int]) -> List[int]: pass ``` **Input**: - `nums`: A list of integers `[int, ...]` with length `N` where 2 ≤ N ≤ 30,000. The list contains exactly two elements that appear once, and all other elements appear exactly twice. **Output**: - A list of two integers that appear only once in the input list. The order of the returned integers does not matter. **Constraints**: - Time complexity must be O(N). - Space complexity must be O(1). **Example**: ```python find_two_unique([1, 2, 1, 3, 2, 5]) # Output: [3, 5] or [5, 3] find_two_unique([4, 1, 2, 1, 2, 5]) # Output: [4, 5] or [5, 4] ``` **Notes**: - Use XOR operations to isolate the two unique numbers. - Ensure your solution handles the scenario where every element (except the two unique ones) appears exactly twice. **Hint**: Consider how the properties of XOR can be used to cancel out pairs and isolate the outliers.","solution":"def find_two_unique(nums): Function to find the two unique numbers in the list where every other number appears exactly twice. # Step 1: XOR all the numbers. The result will be the XOR of the two unique numbers. xor_result = 0 for num in nums: xor_result ^= num # Step 2: Find a set bit (rightmost set bit) in xor_result. # This helps to divide the numbers into two groups. rightmost_set_bit = xor_result & -xor_result # Step 3: Initialize the two unique numbers. num1 = 0 num2 = 0 # Step 4: Divide the numbers into two groups and XOR separately for num in nums: if (num & rightmost_set_bit) != 0: num1 ^= num else: num2 ^= num # The two unique numbers are num1 and num2 return [num1, num2]"},{"question":"# Binary Search: Last Occurrence Finder You are given a sorted array of integers in increasing order. Your task is to implement a function that finds the index of the last occurrence of a given integer (query) in this array using binary search. Function Signature ```python def last_occurrence(array: List[int], query: int) -> int: # Your code here ``` Input * `array`: a list of integers sorted in increasing order. * `query`: an integer to find the last occurrence of. Output * Returns an integer representing the index of the last occurrence of `query` in `array`. * If the `query` does not exist in the array, return `-1`. Constraints * The array length will be between 0 and (10^5). * The elements in the array will be integers between (-10^9) and (10^9). Example ```python # Sample Input array = [1, 2, 2, 2, 3, 4, 5] query = 2 # Sample Output 3 # Sample Input array = [1, 2, 3, 4, 5] query = 6 # Sample Output -1 ``` Explanation For the first example, the last occurrence of `2` is at index `3`. For the second example, `6` does not exist in the array, hence return `-1`.","solution":"from typing import List def last_occurrence(array: List[int], query: int) -> int: Returns the index of the last occurrence of query in the sorted array. If query is not in the array, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: result = mid left = mid + 1 # Keep searching in the right subarray elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Gnome Sort Optimization Challenge Context You are part of a software engineering team working on sorting algorithms for an educational tool. Your task is to implement an optimized version of the Gnome Sort algorithm. Problem Statement Given an array of integers, implement a function `optimized_gnome_sort` that sorts the array in non-decreasing order using an optimized version of the Gnome Sort algorithm. Your goal is to reduce the total number of swaps required without affecting the correctness of the sorting process. Specifications * **Function Signature**: ```python def optimized_gnome_sort(arr: List[int]) -> List[int]: ``` * **Input**: A list of integers, `arr` (1 ≤ len(arr) ≤ 10^4, -10^6 ≤ arr[i] ≤ 10^6). * **Output**: A sorted list of integers in non-decreasing order. * **Constraints**: * You should use the Gnome Sort\'s basic idea but optimize where possible. * Your implementation should aim to minimize the total number of swaps. Example ```python # Example 1 arr = [34, 2, 23, -4, 55, 3] print(optimized_gnome_sort(arr)) # Output: [-4, 2, 3, 23, 34, 55] # Example 2 arr = [5, 3, 2, 6, 4, 1] print(optimized_gnome_sort(arr)) # Output: [1, 2, 3, 4, 5, 6] # Example 3 arr = [1, 1, 1, 1, 1] print(optimized_gnome_sort(arr)) # Output: [1, 1, 1, 1, 1] ``` Notes * Consider edge cases such as an empty array and arrays with identical elements. * Focus on optimizing the swap mechanism to enhance performance. Good luck, and happy coding!","solution":"from typing import List def optimized_gnome_sort(arr: List[int]) -> List[int]: This function sorts an array of integers using an optimized version of the Gnome Sort algorithm. n = len(arr) index = 0 while index < n: # Move forward if already in correct order or at the beginning if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: # Swap to move the smaller element left arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Problem Context You work as a software developer, building state-maintaining applications that often require data duplication within stack-based structures. You are particularly interested in ensuring that each value in a stack appears twice consecutively. # Task Design a function `stutter_stack` that duplicates each occurrence of elements in a stack such that every value appears twice in sequence. You can choose either a single stack (extra storage stack) or a queue (extra storage queue) to achieve the solution. Ensure your function works efficiently even when challenged by large stacks. # Function Specification * **Function Name**: `stutter_stack` * **Arguments**: * `stack`: A list representing the stack where the last element is considered the top of the stack. * **Returns**: * A list representing the stack with each element duplicated. # Constraints * The stack will contain up to `10^4` elements. * Each element in the stack will be an integer in the range [-100, 100]. # Requirements 1. Ensure the function handles empty and single-element stacks correctly. 2. Optimize the function for both time and space complexities. # Performance Requirements * The function should maintain an efficiency of O(n) in time and space complexity. # Example ```python stack = [3, 7, 1, 14, 9] print(stutter_stack(stack)) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] stack = [5] print(stutter_stack(stack)) # Output: [5, 5] stack = [] print(stutter_stack(stack)) # Output: [] ``` # Implementation Tips 1. Consider the choice between using an auxiliary stack or queue. 2. Ensure proper handling of stack operations to maintain integer values in the correct sequence as per stack\'s LIFO principle.","solution":"def stutter_stack(stack): Duplicates each element in the stack such that each value appears twice in sequence. extra_stack = [] # Move elements to an extra stack to reverse the order to access from bottom to top while stack: extra_stack.append(stack.pop()) # Move elements back to the original stack, duplicating each element while extra_stack: element = extra_stack.pop() stack.append(element) stack.append(element) return stack"},{"question":"# Task: Improved Linear Search **Objective**: You are tasked with improving the linear search implementation to handle an additional constraint. The function should now find the last occurrence of the target element in the array. # Function Signature ```python def improved_linear_search(array: List[int], query: int) -> int: Find the index of the last occurrence of the given element in the array. If the element couldn\'t be found, returns -1. pass ``` # Input: * `array` (List[int]): A list of integers. * `query` (int): An integer representing the target element to find. # Output: * (int): The index of the last occurrence of `query` in `array`. If it\'s not found, return -1. # Constraints: * The function should have O(n) time complexity. * Avoid using any additional data structures like another array or list. # Performance Requirement: * The function should correctly identify and return the index of the last occurrence of `query` with minimal overhead. # Examples: ```python assert improved_linear_search([4, 2, 1, 2, 5], 2) == 3 assert improved_linear_search([1, 2, 3, 4, 5], 6) == -1 assert improved_linear_search([], 1) == -1 assert improved_linear_search([2, 4, 2, 4, 2], 2) == 4 assert improved_linear_search([1, 1, 1, 1], 1) == 3 ```","solution":"def improved_linear_search(array, query): Find the index of the last occurrence of the given element in the array. If the element couldn\'t be found, returns -1. last_index = -1 for i in range(len(array)): if array[i] == query: last_index = i return last_index"},{"question":"# Crout Matrix Decomposition You are required to implement a function `crout_matrix_decomposition(A)` which takes a square matrix ( A ) and returns two matrices ( L ) and ( U ) such that ( A = L times U ). In this decomposition, ( L ) is a lower triangular matrix with non-zero elements on and below the diagonal, while ( U ) is an upper triangular matrix with non-zero values only on the diagonal and above. # Input - A square matrix ( A ) of size ( n times n ) represented as a list of lists. All matrix elements are floating-point numbers. # Output - A tuple containing two matrices ( L ) and ( U ), each of size ( n times n ) represented as lists of lists. # Constraints - The input matrix ( A ) will always be a square matrix. - The matrix elements will be valid floating-point numbers. # Example ```python # Input: A = [ [1, 2, 3], [3, 4, 5], [6, 7, 8] ] # Expected Output: L = [ [1.0, 0.0, 0.0], [3.0, -2.0, 0.0], [6.0, -5.0, 0.0] ] U = [ [1.0, 2.0, 3.0], [0.0, 1.0, 2.0], [0.0, 0.0, 1.0] ] L, U = crout_matrix_decomposition(A) print(\\"L:\\", L) print(\\"U:\\", U) # L should be as expected # U should be as expected ``` Write a function `crout_matrix_decomposition(A)`: ```python def crout_matrix_decomposition(A): n = len(A) L = [[0.0] * n for _ in range(n)] U = [[0.0] * n for _ in range(n)] for j in range(n): U[j][j] = 1.0 for i in range(j, n): alpha = float(A[i][j]) for k in range(j): alpha -= L[i][k] * U[k][j] L[i][j] = float(alpha) for i in range(j+1, n): tempU = float(A[j][i]) for k in range(j): tempU -= float(L[j][k] * U[k][i]) if int(L[j][j]) == 0: L[j][j] = float(0.1**40) U[j][i] = float(tempU / L[j][j]) return (L, U) ``` Write a complete solution that adheres to the input and output specifications. Ensure your solution handles potential edge cases such as division by zero or matrices with zero on the diagonal appropriately.","solution":"def crout_matrix_decomposition(A): Performs Crout matrix decomposition on the square matrix A such that A = L * U. Where L is a lower triangular matrix and U is an upper triangular matrix with diagonal elements 1. Parameters: A (list of list of floats): The square matrix to decompose. Returns: tuple: A tuple containing L and U matrices. n = len(A) # Initialize L and U matrices L = [[0.0] * n for _ in range(n)] U = [[0.0] * n for _ in range(n)] for j in range(n): U[j][j] = 1.0 for i in range(j, n): sum_lower = 0.0 for k in range(j): sum_lower += L[i][k] * U[k][j] L[i][j] = A[i][j] - sum_lower for i in range(j+1, n): sum_upper = 0.0 for k in range(j): sum_upper += L[j][k] * U[k][i] if L[j][j] == 0: raise ZeroDivisionError(\\"Matrix is singular and cannot be decomposed\\") U[j][i] = (A[j][i] - sum_upper) / L[j][j] return L, U"},{"question":"# Linked List Partitioning **Objective**: Write a function that partitions a linked list around a value `x`. **Function Signature**: ```python def partition(head: Node, x: int) -> Node: ``` **Input Format**: * A linked list `head` where each node contains an integer value. * An integer `x` representing the pivot value for partitioning. **Output Format**: * The head of the modified linked list after partitioning. **Constraints**: * The linked list elements and `x` will be of integer type. **Examples**: 1. Given the linked list: ``` 3 -> 5 -> 8 -> 5 -> 10 -> 2 -> 1 ``` After partition with `x = 5`, one possible output: ``` 3 -> 2 -> 1 -> 5 -> 8 -> 5 -> 10 ``` 2. Given the linked list: ``` 1 -> 4 -> 3 -> 2 -> 5 -> 2 ``` After partition with `x = 3`, one possible output: ``` 1 -> 2 -> 2 -> 4 -> 3 -> 5 ``` **Scenario/Context**: Imagine you\'re reorganizing list items to cluster around a specific pivot value, which can aid in certain traversal or sorting tasks without completely rearranging the internal state. This linked list operation is fundamental and highly useful in various algorithmic challenges addressing ordering and segmentation of data. **Task**: Complete the function to correctly partition the linked list around the provided pivot, ensuring no other element order violations within the defined criteria. **Note**: 1. Pay special attention to edge cases like an empty list or when all values are less than or greater than `x`. 2. Ensure that the space complexity remains O(1), maintaining optimal usage of memory.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def partition(head: Node, x: int) -> Node: if not head: return None # Create two dummy nodes to act as placeholders for the start of two lists before_head = Node(0) after_head = Node(0) # Pointers to the current last elements of before list and after list before = before_head after = after_head # Traverse the original list current = head while current: if current.value < x: before.next = current before = before.next else: after.next = current after = after.next current = current.next # Finalize the lists after.next = None # important to prevent cycle before.next = after_head.next return before_head.next"},{"question":"# Binary Search Tree Implementation Suppose you are a software developer tasked with creating a library for a binary search tree (BST). You need to implement the core functionalities: inserting a new value, deleting a value, and searching for a value in the tree. Function Signatures - Insert: `def insert(root: TreeNode, val: int) -> TreeNode` - Delete: `def delete(root: TreeNode, val: int) -> TreeNode` - Search: `def search(root: TreeNode, val: int) -> bool` Expected Input and Output Formats ```python # Insert Function # Input: root (TreeNode representing the root of the BST), val (integer value to insert in the BST) # Output: TreeNode (new root of the BST after insertion) # Delete Function # Input: root (TreeNode representing the root of the BST), val (integer value to delete from the BST) # Output: TreeNode (new root of the BST after deletion) # Search Function # Input: root (TreeNode representing the root of the BST), val (integer value to search for in the BST) # Output: bool (True if the value exists in the BST, False otherwise) ``` Scenario Your task is to implement three functions for the binary search tree: 1. **Insert**: This allows adding a value to the BST. New values should be inserted in a way that keeps the BST properties intact. 2. **Delete**: This allows removal of a value from the BST. The function must handle all cases of node deletion, ensuring that the tree remains a valid BST. 3. **Search**: This checks whether a specified value exists in the BST. Constraints and Requirements - **TreeNode Class**: ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None ``` - **Performance**: Aim to have average-case time complexity of O(log n) for insertions, deletions, and searches. - **Validations**: Make sure to handle edge cases like empty trees, deleting non-existent elements, etc. You must provide a robust solution that demonstrates a clear understanding of the BST structure and is tested against various edge cases.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def insert(root: TreeNode, val: int) -> TreeNode: if not root: return TreeNode(val) if val < root.val: root.left = insert(root.left, val) else: root.right = insert(root.right, val) return root def delete(root: TreeNode, val: int) -> TreeNode: if not root: return root if val < root.val: root.left = delete(root.left, val) elif val > root.val: root.right = delete(root.right, val) else: if not root.left: return root.right if not root.right: return root.left temp = find_min(root.right) root.val = temp.val root.right = delete(root.right, root.val) return root def find_min(root: TreeNode) -> TreeNode: while root.left: root = root.left return root def search(root: TreeNode, val: int) -> bool: if not root: return False if val == root.val: return True elif val < root.val: return search(root.left, val) else: return search(root.right, val)"},{"question":"You have been provided with a sorted array and a target value. Your task is to efficiently find the index at which this target value should be inserted to maintain the order of the array. If the target value already exists in the array, simply return the index of the existing element. Write a function `find_insert_position(array, val)` that: * Receives a sorted list of integers `array` and an integer `val`. * Returns the insertion index if the `val` is not present. If the `val` is present, returns the index where `val` is located. Requirements: * Your solution should have a time complexity of O(log n) and a space complexity of O(1). * Ensure to handle edge cases appropriately (e.g., empty array, single-element array). Input: * `array` - List of sorted integers where duplicate values are allowed, but the list itself is sorted. * `val` - The integer value that you want to find the insert position for. Output: * Return an integer representing the index position where `val` should be inserted to keep the array sorted. Example: ```python assert find_insert_position([1, 3, 5, 6], 5) == 2 assert find_insert_position([1, 3, 5, 6], 2) == 1 assert find_insert_position([1, 3, 5, 6], 7) == 4 assert find_insert_position([1, 3, 5, 6], 0) == 0 ``` Constraints: * The list `array` can contain up to 10^5 elements. * Each element in `array` is an integer within the range [-10^5, 10^5]. * The integer `val` is within the range [-10^5, 10^5]. Good luck and make sure to handle all the edge cases for accurate results!","solution":"def find_insert_position(array, val): Returns the index at which val should be inserted to maintain the order of the sorted array, or the index of val if it exists in the array. left, right = 0, len(array) - 1 while left <= right: mid = left + (right - left) // 2 if array[mid] == val: return mid elif array[mid] < val: left = mid + 1 else: right = mid - 1 return left"},{"question":"# Radix Sort Implementation Challenge You\'ve just learned about a sorting algorithm called Radix Sort, which sorts a list of non-negative integers efficiently by processing individual digits from the least significant to the most significant. The algorithm uses buckets to collect numbers based on their digit values and iterates through multiple passes to achieve a sorted list. Your task is to implement the `radix_sort` function that performs Radix Sort on a given list of non-negative integers. Make sure to consider edge cases and optimize where possible. # Function Signature ```python def radix_sort(arr): pass ``` # Input - `arr`: A list of non-negative integers ([int, ...]). (0 leq len(arr) leq 10^6), (0 leq arr[i] leq 10^9). # Output - Return a sorted list of integers ([int, ...]). # Constraints - Do not use built-in sort functions (like `sorted()` or `sort()` from standard libraries). - The function should work efficiently for large lists up to (10^6) elements and account for large integer values up to (10^9). # Performance Requirements - Target Time Complexity: (O(nk) ) - Target Space Complexity: (O(n + k) ) # Example ```python assert radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] assert radix_sort([3, 3, 3, 3]) == [3, 3, 3, 3] assert radix_sort([]) == [] assert radix_sort([123, 4, 11111, 45, 345]) == [4, 45, 123, 345, 11111] ``` # Context The algorithm needs to sort large datasets efficiently and ensure that sorting remains stable and accurate even with large numbers. Keep edge cases and constraints in mind while implementing the function.","solution":"def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 for i in range(n): arr[i] = output[i] def radix_sort(arr): if len(arr) == 0: return arr max1 = max(arr) exp = 1 while max1 // exp > 0: counting_sort(arr, exp) exp *= 10 return arr"},{"question":"As a software engineer for a genomic research lab, you are tasked with implementing a substring search algorithm to identify specific DNA sequences within large genomic texts efficiently. Your solution should be based on the Rabin-Karp algorithm provided. # Requirements Implement a function `find_sequence(dna_sequence: str, genome: str) -> int` that searches for the first occurrence of the `dna_sequence` within the `genome`. If the sequence is found, return the starting index; otherwise, return -1. Constraints * The `dna_sequence` and `genome` will consist only of characters \'A\', \'T\', \'C\', \'G\'. * The length of `dna_sequence` ( m ) and `genome` ( n ) will both be ( 1 leq m leq 10^6 ). * Optimize for average-case performance. Function Signature ```python def find_sequence(dna_sequence: str, genome: str) -> int: pass ``` Example ```python sequence = \\"ATG\\" genome = \\"GATTACAAGATGCGT\\" result = find_sequence(sequence, genome) print(result) # Output: 9 ``` Notes * An empty `dna_sequence` or `genome` should return -1. * If the `dna_sequence` length exceeds the `genome` length, return -1. You are required to use the same rolling hash and algorithm principles as given in the Rabin-Karp implementation provided. Ensure that you handle edge cases and maintain efficiency.","solution":"def find_sequence(dna_sequence: str, genome: str) -> int: if not dna_sequence or not genome or len(dna_sequence) > len(genome): return -1 m, n = len(dna_sequence), len(genome) base = 256 # number of characters in the input alphabet prime = 101 # A prime number # Initialize hash values for dna_sequence and genome dna_hash = 0 genome_hash = 0 h = 1 # The value of base^(m-1) % prime for i in range(m - 1): h = (h * base) % prime # Calculate the hash value of dna_sequence and first window of genome for i in range(m): dna_hash = (base * dna_hash + ord(dna_sequence[i])) % prime genome_hash = (base * genome_hash + ord(genome[i])) % prime # Slide the window over genome one by one for i in range(n - m + 1): # Check the hash values of current window of genome and dna_sequence if dna_hash == genome_hash: # Check for characters one by one if hashes match if genome[i:i + m] == dna_sequence: return i # Calculate hash value for next window of genome if i < n - m: genome_hash = (base * (genome_hash - ord(genome[i]) * h) + ord(genome[i + m])) % prime # We might get negative values of genome_hash, convert it to positive if genome_hash < 0: genome_hash += prime return -1"},{"question":"**Context**: You are working as a developer at a combinatorial mathematics software company. Your task is to implement a function for calculating the binomial coefficient using recursion. Your implementation should be optimized to handle relatively large inputs efficiently. **Objective**: Write a Python function `optimized_recursive_binomial_coefficient(n, k)` that computes the binomial coefficient ( C(n, k) ). **Requirements**: 1. The function should use the recursive approach but improve upon the provided snippet by handling large inputs efficiently. 2. Use memoization to store previously computed results and avoid redundant calculations. **Input**: - Two integers `n` (0 ≤ n ≤ 500) and `k` (0 ≤ k ≤ n). **Output**: - A single integer representing the binomial coefficient ( C(n, k) ). **Constraints**: - ( n ) and ( k ) will be non-negative integers where ( n geq k ). **Performance Requirements**: - Your function should handle the largest possible inputs within reasonable time limits (a few seconds). **Example**: ```python assert optimized_recursive_binomial_coefficient(5, 0) == 1 assert optimized_recursive_binomial_coefficient(8, 2) == 28 assert optimized_recursive_binomial_coefficient(500, 300) == 5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640 ``` Complete the implementation of `optimized_recursive_binomial_coefficient(n, k)` below: ```python def optimized_recursive_binomial_coefficient(n, k, memo=None): Computes the binomial coefficient C(n, k) using optimized recursion with memoization. if memo is None: memo = {} if k > n: raise ValueError(\'Invalid Inputs, ensure that n >= k\') if k == 0 or n == k: return 1 if k > n // 2: k = n - k if (n, k) in memo: return memo[(n, k)] memo[(n, k)] = (n // k) * optimized_recursive_binomial_coefficient(n - 1, k - 1, memo) return memo[(n, k)] ``` Respond with optimized and thoroughly tested code that handles the entire range of inputs effectively.","solution":"def optimized_recursive_binomial_coefficient(n, k, memo=None): Computes the binomial coefficient C(n, k) using optimized recursion with memoization. if memo is None: memo = {} if k > n: raise ValueError(\'Invalid Inputs, ensure that n >= k\') if k == 0 or n == k: return 1 if k > n // 2: k = n - k if (n, k) in memo: return memo[(n, k)] memo[(n, k)] = optimized_recursive_binomial_coefficient(n - 1, k - 1, memo) + optimized_recursive_binomial_coefficient(n - 1, k, memo) return memo[(n, k)]"},{"question":"# Scenario You\'re developing software for an embedded system where memory usage is critical, and you need to manipulate individual bits within configuration registers to toggle various features on and off. # Task Implement a Python class `BitManipulator` with the following methods: * `get_bit(num: int, i: int) -> bool`: Returns `True` if the `i`-th bit of `num` is 1, `False` otherwise. * `set_bit(num: int, i: int) -> int`: Sets the `i`-th bit of `num` to 1 and returns the new integer. * `clear_bit(num: int, i: int) -> int`: Clears the `i`-th bit of `num` (sets it to 0) and returns the new integer. * `update_bit(num: int, i: int, bit: int) -> int`: Updates the `i`-th bit of `num` with the value `bit` (either 0 or 1) and returns the new integer. Input and Output * For `get_bit`: * **Input**: An integer `num`, an integer `i` (index of the bit). * **Output**: Boolean value indicating the bit status. * For `set_bit` and `clear_bit`: * **Input**: An integer `num`, an integer `i` (index of the bit). * **Output**: An integer with the specified bit modified. * For `update_bit`: * **Input**: An integer `num`, an integer `i`, and an integer `bit` (0 or 1). * **Output**: An integer with the `i`-th bit set to the value of `bit`. Constraints * Assume `num` is a 32-bit integer. * `0 <= i < 32` * `bit` is either `0` or `1`. Example ```python bm = BitManipulator() assert bm.get_bit(10, 1) == True # 10 in binary is 1010, bit at position 1 is 1 assert bm.set_bit(10, 2) == 14 # 10 in binary is 1010, setting bit at position 2 makes it 1110 (14) assert bm.clear_bit(10, 1) == 8 # 10 in binary is 1010, clearing bit at position 1 makes it 1000 (8) assert bm.update_bit(10, 1, 0) == 8 # 10 in binary is 1010, updating bit at position 1 to 0 makes it 1000 (8) assert bm.update_bit(10, 1, 1) == 10 # 10 in binary is 1010, bit at position 1 is already 1 ```","solution":"class BitManipulator: @staticmethod def get_bit(num: int, i: int) -> bool: Returns True if the i-th bit of num is 1, False otherwise. return (num & (1 << i)) != 0 @staticmethod def set_bit(num: int, i: int) -> int: Sets the i-th bit of num to 1. return num | (1 << i) @staticmethod def clear_bit(num: int, i: int) -> int: Clears the i-th bit of num (sets it to 0). return num & ~(1 << i) @staticmethod def update_bit(num: int, i: int, bit: int) -> int: Updates the i-th bit of num with the value bit. mask = ~(1 << i) return (num & mask) | (bit << i)"},{"question":"**Context**: You are working on a software module where you need to repeatedly search for objects in an array. The provided implementation is a simple linear search, which is suitable for smaller data sets but needs improvement when dealing with larger arrays. Your task is to enhance the efficiency of the search process by implementing different search algorithms in given scenarios. # Task Implement an improved search algorithm given that: 1. The input array is unsorted for the first case. 2. The input array is sorted for the second case, which allows more efficient searching methods. Requirements # Case 1: Unsorted Array - **Function**: `linear_search(array, query)` - **Input Format**: - `array` (List[int]): A list of integers where the search will be performed. - `query` (int): The integer value to find in the array. - **Output Format**: - (int): The index of the query in the array if found, otherwise -1. - **Performance Requirements**: O(n) time complexity. # Case 2: Sorted Array - **Function**: `binary_search(array, query)` - **Input Format**: - `array` (List[int]): A sorted list of integers where the search will be performed. - `query` (int): The integer value to find in the array. - **Output Format**: - (int): The index of the query in the array if found, otherwise -1. - **Performance Requirements**: O(log n) time complexity. Constraints - Assume the array elements and query are all integers. - The size of the array will not exceed 10^6 elements. - The array for the binary search function will be sorted in non-decreasing order. Edge Cases - The array could be empty. - The query could be present at the beginning, middle, or end of the array. - The array might contain duplicate elements. Example Usage ```python # For linear search assert linear_search([1, 3, 5, 7, 9], 5) == 2 assert linear_search([1, 3, 5, 7, 9], 2) == -1 # For binary search assert binary_search([1, 3, 5, 7, 9], 5) == 2 assert binary_search([1, 3, 5, 7, 9], 2) == -1 ```","solution":"def linear_search(array, query): Performs a linear search to find the query in an unsorted array. Parameters: array (List[int]): An unsorted list of integers to search within. query (int): The integer value to find. Returns: int: The index of the query in the array if found, otherwise -1. for index, element in enumerate(array): if element == query: return index return -1 def binary_search(array, query): Performs a binary search to find the query in a sorted array. Parameters: array (List[int]): A sorted list of integers to search within. query (int): The integer value to find. Returns: int: The index of the query in the array if found, otherwise -1. left, right = 0, len(array) - 1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: return mid elif array[mid] < query: left = mid + 1 else: right = mid - 1 return -1"},{"question":"You are tasked with implementing a function that processes a given string by removing any recurring characters while preserving the order of their first appearance. This function should demonstrate your understanding of string manipulation and efficient data handling in Python. # Function Signature ```python def remove_duplicates(input_string: str) -> str: pass ``` # Input - `input_string` (str): A string consisting of alphanumeric characters and punctuation. The length of the input string is up to 10^6. # Output - Returns a string with all recurring characters removed, keeping only the first occurrence of each character in their original order. # Constraints - The function must run in O(n) time complexity. - The solution must not use additional libraries beyond Python\'s standard set. - Space complexity should also be considered, aiming to use O(n) additional space where n is the length of the input string. # Example ```python assert remove_duplicates(\\"google\\") == \\"gole\\" assert remove_duplicates(\\"apple\\") == \\"aple\\" assert remove_duplicates(\\"\\") == \\"\\" assert remove_duplicates(\\"abcabc\\") == \\"abc\\" ``` # Your Task Implement the function `remove_duplicates` to pass the provided examples and handle potential edge cases. Ensure optimal performance and adhere to the constraints.","solution":"def remove_duplicates(input_string: str) -> str: Removes any recurring characters from the input string while preserving the order of their first appearance. Parameters: input_string (str): The input string from which duplicates need to be removed. Returns: str: A string with duplicate characters removed. seen = set() result = [] for char in input_string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Euler\'s Totient Function: Optimized Implementation and Applications Context: Euler\'s Totient function, ϕ(n), or the phi function, is an important function in number theory that counts integers up to n that are coprime with n. This function is particularly prominent in fields such as cryptography and modular arithmetic. Task: Your task is to implement an efficient version of the Euler\'s Totient function and then apply this function to solve a range of problems. # Part 1: Implementing Euler\'s Totient Function Write a function `euler_totient(n: int) -> int` that computes the totient of a given integer n using the most optimized approach possible. **Function Signature:** ```python def euler_totient(n: int) -> int: ``` Input: - `n`: an integer (1 ≤ n ≤ 10^6) Output: - An integer representing the number of positive integers up to n that are coprime with n. # Part 2: Application of Euler\'s Totient Function Using your implemented `euler_totient` function, solve the following problem: Given two integers `a` (1 ≤ a ≤ 10^6) and `b` (1 ≤ b ≤ 10^6), find the totient of the greatest common divisor (GCD) of a and b. **Constraints**: The solution should be optimized beyond brute force approaches given the large constraints on n. **Function Signature:** ```python def gcd_totient(a: int, b: int) -> int: ``` Input: - `a`: first integer - `b`: second integer Output: - An integer representing the totient of gcd(a, b). **Example:** ```python # Given Implementations def gcd(a, b): while b: a, b = b, a % b return a # Example usage print(euler_totient(10)) # Output: 4 print(gcd_totient(10, 15)) # Output: 2 (GCD is 5, totient(5) = 4) ``` Ensure that your solution is optimized for large values of a and b.","solution":"# Optimized Euler\'s Totient function def euler_totient(n: int) -> int: result = n p = 2 while p ** 2 <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result # Helper function to compute the GCD def gcd(a: int, b: int) -> int: while b: a, b = b, a % b return a # Function to compute the totient of the GCD of a and b def gcd_totient(a: int, b: int) -> int: return euler_totient(gcd(a, b))"},{"question":"# Decode String Situation: You are working on a data compression application that uses a custom encoding method to reduce the size of repeated sequences in strings. Your task is to write a function that decodes these strings back into their original form. Function Specification: Write a function `decode_string(s)` that decodes an encoded string based on given rules. Input: - `s`: A string where: - Encoded substrings follow the format `k[encoded_string]`, where `k` is a positive integer and `encoded_string` is the string within the brackets that needs to be repeated `k` times. - The input string does not contain any digits other than those for repetition counts. - Brackets are well-formed, with no mismatched or unpaired brackets. - No extra whitespace is present. Output: - A decoded string which is the expanded form of the encoded input. Examples: ```python # Example 1: s = \\"3[a]2[bc]\\" # Output: \\"aaabcbc\\" # Example 2: s = \\"3[a2[c]]\\" # Output: \\"accaccacc\\" # Example 3: s = \\"2[abc]3[cd]ef\\" # Output: \\"abcabccdcdcdef\\" ``` Constraints: - The length of `s` will be in the range [1, 30]. - The string `s` consists only of lowercase English letters, digits, and brackets `[]`. Performance Expectations: - Your function should handle strings of varying lengths efficiently, with consideration of both time and space complexities. # Function Signature: ```python def decode_string(s: str) -> str: ... ``` Implement the function `decode_string` that handles the decoding as described above. Ensure you properly manage stacks to handle nested and sequential encoded patterns.","solution":"def decode_string(s: str) -> str: Decodes the encoded input string s according to the specified rules. stack = [] current_num = 0 current_string = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif char == \']\': last_string, num = stack.pop() current_string = last_string + current_string * num else: current_string += char return current_string"},{"question":"You are assigned the task of designing a utility function for a numerical application. To ensure robust formatting and handling of input events, you need to write a function that calculates the number of digits in any given integer, both positive and negative. Zero should be considered as having one digit. Additionally, your implementation should maintain O(1) time complexity. # Function Signature ```python def num_digits(n: int) -> int: ``` # Input * An integer `n` which can be positive, negative, or zero. # Output * An integer representing the number of digits in the absolute value of `n`. # Example ```python assert num_digits(12345) == 5 assert num_digits(-789) == 3 assert num_digits(0) == 1 ``` # Constraints * Ensure the function runs in constant time with O(1) complexity. * Handle negative integers by considering their absolute values. * Zero has exactly one digit. # Notes * You might need to use mathematical functions to achieve constant time complexity. * Do not use string conversions (e.g., `str(n)`) to solve this problem as it does not meet the O(1) time complexity requirement.","solution":"import math def num_digits(n: int) -> int: Calculate the number of digits in the absolute value of an integer. Args: n (int): An integer which can be positive, negative, or zero. Returns: int: The number of digits in the absolute value of the integer. if n == 0: return 1 return math.floor(math.log10(abs(n))) + 1"},{"question":"Path Detection in Directed Graph Scenario Imagine you are building a map application where you need to determine if there\'s a direct or indirect route between various landmarks represented as nodes on the map. Task Using the directed graph class provided, implement a function `is_reachable` that determines if there\'s a path from a source node to a target node using Depth-First Search (DFS). # Function Signature ```python def is_reachable(graph: Graph, source: int, target: int) -> bool: Determine if there is a path from source to target in the given directed graph. :param: graph: The directed graph instance of class Graph. :param: source: The starting node for the path. :param: target: The destination node for the path. :returns: True if there is a path from source to target, False otherwise. pass ``` # Constraints * Nodes are represented by integers from `0` to `V-1` (where V is the number of vertices). * You may assume that all input nodes exist in the graph. * The graph could have cycles or be disconnected. * Implement DFS iteratively to handle deep recursion limitations. # Example ```python # Example usage graph = Graph(5) graph.add_edge(0, 1) graph.add_edge(0, 2) graph.add_edge(1, 2) graph.add_edge(2, 0) graph.add_edge(2, 3) graph.add_edge(3, 3) # Testing reachability assert is_reachable(graph, 1, 3) == True assert is_reachable(graph, 3, 1) == False ```","solution":"class Graph: def __init__(self, vertices): self.V = vertices self.graph = [[] for _ in range(vertices)] def add_edge(self, u, v): self.graph[u].append(v) def is_reachable(graph, source, target): Determine if there is a path from source to target in the given directed graph. :param graph: The directed graph instance of class Graph. :param source: The starting node for the path. :param target: The destination node for the path. :returns: True if there is a path from source to target, False otherwise. # To keep track of visited nodes visited = [False] * graph.V # Stack for DFS stack = [source] while stack: node = stack.pop() if node == target: return True if not visited[node]: visited[node] = True for neighbor in graph.graph[node]: if not visited[neighbor]: stack.append(neighbor) return False"},{"question":"You are tasked with implementing a function that sorts an array using a max heap sort algorithm. Additionally, you should track the internal states of the array at each iteration of the heapify process for observational purposes. # Function Signature ```python def max_heap_sort(arr, simulation=False) -> list: ``` # Input - `arr` (list): A list of integers to be sorted. - `simulation` (bool, optional): If set to `True`, the function should print the state of the array after each iteration of the heapify process. Default is `False`. # Output - The function should return the sorted list of integers in ascending order. # Example Input ```python arr = [4, 10, 3, 5, 1] simulation = True ``` Output ``` iteration 0 : 4 10 3 5 1 iteration 1 : 4 5 3 1 10 iteration 2 : 3 1 4 5 10 iteration 3 : 1 3 4 5 10 [1, 3, 4, 5, 10] ``` # Constraints - The input list will contain at most (10^5) elements. - Each element in the input list will be within the range (-10^9) to (10^9). # Notes - The implementation should correctly modify the input list to produce a sorted list. - If the `simulation` flag is set, the function should output the state of the array at each iteration where the heapify process changes the array. - Consider efficiency both in terms of time and space complexity.","solution":"def max_heap_sort(arr, simulation=False): Sorts an array using the max heap sort algorithm and returns the sorted array. Tracks the internal state at each iteration if simulation is True. def heapify(arr, n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap heapify(arr, n, largest) n = len(arr) # Build max heap for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") # Extract elements from heap one by one for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap heapify(arr, i, 0) if simulation: print(f\\"iteration {n-i} : {\' \'.join(map(str, arr))}\\") return arr"},{"question":"# Scenario As part of a software for managing resources where the efficiency of allocation matters, you are tasked with augmenting the sorting functionality to visualize the sorting process better and to extend functionality by handling edge cases more gracefully. # Problem Statement You are asked to implement and expand the `selection_sort` function so that the sorted output and intermediate steps (if simulation is enabled) are printed. Additionally, you need to extend the functionality to handle cases with `None` (null values) by placing them at the end of the sorted list. Write a function `enhanced_selection_sort` that sorts an array of integers and `None` values. `None` values should appear at the end of the array in the sorted order. The function should also handle optional simulation to print the array at each iteration. Function Signature ```python def enhanced_selection_sort(arr, simulation=False): pass ``` Input - `arr`: A list of integers and `None` values. Example: `[3, 1, 4, 1, None, 5, 9, None, 2]` - `simulation`: A boolean value that determines whether to print the array at each iteration. Default is `False`. Output - Prints the array at each iteration if `simulation=True`. - Returns the sorted array with `None` values at the end. # Examples 1. Example 1: ```python enhanced_selection_sort([3, 1, 4, 1, None, 5, 9, None, 2], simulation=True) ``` Output: ``` iteration 0: [1, 3, 4, 1, None, 5, 9, None, 2] iteration 1: [1, 1, 4, 3, None, 5, 9, None, 2] iteration 2: [1, 1, 2, 3, None, 5, 9, None, 4] iteration 3: [1, 1, 2, 3, None, 5, 9, None, 4] iteration 4: [1, 1, 2, 3, 4, 5, 9, None, None] iteration 5: [1, 1, 2, 3, 4, 5, 9, None, None] iteration 6: [1, 1, 2, 3, 4, 5, 9, None, None] iteration 7: [1, 1, 2, 3, 4, 5, 9, None, None] iteration 8: [1, 1, 2, 3, 4, 5, 9, None, None] ``` 2. Example 2: ```python print(enhanced_selection_sort([None, 2, 7, 3, 5], simulation=False)) ``` Output: ``` [2, 3, 5, 7, None] ``` # Constraints * The function should handle arrays with integer and `None` values only. * The array length is at most 1000 elements.","solution":"def enhanced_selection_sort(arr, simulation=False): Sorts an array of integers and None values using the selection sort algorithm. None values are placed at the end of the array. If simulation is True, prints the array at each iteration of the outer loop. Parameters: arr (list): List of integers and None values. simulation (bool): Whether to print the array at each iteration. Returns: list: The sorted array with None values at the end. n = len(arr) # Remove None values to sort the rest of the integers non_none_values = [x for x in arr if x is not None] length_of_non_none_values = len(non_none_values) # Perform selection sort on non-None values for i in range(length_of_non_none_values): min_index = i for j in range(i + 1, length_of_non_none_values): if non_none_values[j] < non_none_values[min_index]: min_index = j # Swap the found minimum element with the first element of the unsorted part non_none_values[i], non_none_values[min_index] = non_none_values[min_index], non_none_values[i] if simulation: print(f\\"iteration {i}: {non_none_values + [None] * (n - length_of_non_none_values)}\\") # Adding None values at the end sorted_arr = non_none_values + [None] * (n - length_of_non_none_values) return sorted_arr"},{"question":"Data Histogram Analysis **Problem Statement:** You are tasked with writing a function that reads a list of unordered integers and returns a histogram representation of these integers. The histogram should be a dictionary where the keys are the unique integers from the list, and the values are the counts of how many times each integer appeared in the list. **Function Signature:** ```python def get_histogram(input_list: list) -> dict: Get histogram representation. :param input_list: List[int] - List with different and unordered integer values :return: Dict[int, int] - Dictionary with the histogram of the input list ``` **Input:** - A list of integers, `input_list`, which can contain both positive and negative integers as well as zeros. - Length of the list can be anywhere from 0 to 10^6. **Output:** - A dictionary representing the histogram of the input list. Each key is a unique integer from the input list, and each value is the count of its appearances in the list. **Constraints:** - The elements in the list are guaranteed to be hashable. - The elements in the list fit into the memory. **Performance Requirements:** - The function should run in O(n) time complexity. - The space complexity should be O(n). # Example: ```python # Example 1 input_list = [3, 3, 2, 1] # Expected output: {1: 1, 2: 1, 3: 2} # Example 2 input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] # Expected output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} # Example 3 input_list = [] # Expected output: {} ``` # Additional Scenarios: 1. **Edge Case 1:** List containing only one element multiple times. ```python input_list = [1, 1, 1, 1, 1] # Expected output: {1: 5} ``` 2. **Edge Case 2:** List containing negative numbers and zero. ```python input_list = [0, -1, -1, -2, 0, 3] # Expected output: {0: 2, -1: 2, -2: 1, 3: 1} ``` 3. **Edge Case 3:** List containing large numbers. ```python input_list = [1000000, 1000000, 1000000, -1000000, 0] # Expected output: {1000000: 3, -1000000: 1, 0: 1} ``` Your task is to implement the given function considering all the required constraints and edge cases.","solution":"def get_histogram(input_list): Get histogram representation. :param input_list: List[int] - List with different and unordered integer values :return: Dict[int, int] - Dictionary with the histogram of the input list histogram = {} for number in input_list: if number in histogram: histogram[number] += 1 else: histogram[number] = 1 return histogram"},{"question":"Absolute Path Resolution You are working on a utility script that requires consistently resolving file paths to their absolute equivalents. This is crucial in ensuring that all file operations are performed on correctly identified files regardless of the current working directory or user-specific shortcuts in the paths. Task Implement a function `resolve_absolute_path(file_path: str) -> str` which takes a string `file_path` representing a file path and returns its absolute path. The function should appropriately handle: 1. User directory shortcuts like `~`. 2. Relative paths. Input - `file_path` (str): A string representing the relative or shortcut incorporated path. Output - (str): The absolute path where all user shortcuts and relative paths are resolved. Constraints - Assume that the provided file path can be empty. - The function should not check for the existence of the file or directory; it should only resolve the path. - The lengths of the paths are reasonably bounded. Example ```python resolve_absolute_path(\\"~/documents/file.txt\\") # On a Unix-like system, this might output: \\"/home/username/documents/file.txt\\" resolve_absolute_path(\\"../folder/file.txt\\") # Assuming the current directory is `/home/username/projects/`, the output might be: \\"/home/username/folder/file.txt\\" resolve_absolute_path(\\"\\") # Expected output should be an absolute path of the current directory, `/home/username`. ``` Additional Requirements - Validate your input paths properly. - Ensure cross-platform compatibility (i.e., it should work seamlessly on Windows, Linux, macOS). Guidelines - Use the `os.path` module for path manipulations. - Think about edge cases like empty string inputs or unusual paths.","solution":"import os def resolve_absolute_path(file_path: str) -> str: Resolves a file path to its absolute path, handling user shortcuts and relative paths. Args: file_path (str): A string representing the relative or shortcut incorporated path. Returns: str: The absolute path where all user shortcuts and relative paths are resolved. if not file_path: return os.path.abspath(\'\') return os.path.abspath(os.path.expanduser(file_path))"},{"question":"Implement Extended Jump Search Given a sorted array of unique integers, write a function `extended_jump_search` that returns the index of a target value. However, this function should extend the capabilities of the basic Jump Search algorithm by: 1. Allowing for both ascending and descending sorted arrays. 2. Supporting searches for multiple target values efficiently. * **Function Signature**: ```python def extended_jump_search(arr: List[int], targets: List[int]) -> Dict[int, int]: ``` * **Input**: * `arr`: A sorted list of unique integers (which could be in either ascending or descending order). * `targets`: A list of integer values that need to be searched in `arr`. * **Output**: * A dictionary where each key is a target value from `targets` and its corresponding value is the index of that target within `arr`, or `-1` if the target is not found. * **Constraints**: * Each element in `arr` is unique. * No specific order is guaranteed within `targets`. * `arr` can have up to 10^6 elements. * `targets` can have up to 10^5 elements. * Must handle both large and small arrays efficiently. Example: ```python # Example input in ascending order arr = [1, 3, 5, 7, 9, 11, 13, 15] targets = [3, 10, 13] print(extended_jump_search(arr, targets)) # Expected output: {3: 1, 10: -1, 13: 6} # Example input in descending order arr = [15, 13, 11, 9, 7, 5, 3, 1] targets = [3, 10, 13] print(extended_jump_search(arr, targets)) # Expected output: {3: 6, 10: -1, 13: 1} ``` * **Note**: The primary challenge is extending the basic Jump Search to handle different orderings of the sorted array without compromising the algorithm\'s efficiency. Consider edge cases such as an empty array, an array with a single element, and targets that are outside the range of array values.","solution":"from typing import List, Dict import math def extended_jump_search(arr: List[int], targets: List[int]) -> Dict[int, int]: Perform an extended jump search on a sorted array to find the indices of multiple target values. Handles both ascending and descending ordered arrays. def jump_search(sorted_arr, target, step): n = len(sorted_arr) prev = 0 while prev < n and sorted_arr[min(step, n) - 1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 while prev < min(step, n): if sorted_arr[prev] == target: return prev prev += 1 return -1 if not arr: return {target: -1 for target in targets} # Determine if the array is ascending or descending ascending_order = arr[0] < arr[-1] results = {} step = int(math.sqrt(len(arr))) for target in targets: if ascending_order: results[target] = jump_search(arr, target, step) else: # For descending order, reverse the array and search for the target index = jump_search(arr[::-1], target, step) if index != -1: index = len(arr) - 1 - index results[target] = index return results"},{"question":"# Coding Challenge: Generate Unique Subsets **Scenario**: You are building a feature in a data analysis application that generates all possible groups of selected features (subsets) from a dataset. To avoid redundancy, the application must ensure that no duplicate groups are generated even if the original feature list contains duplicate entries. **Task**: Implement a function that takes a list of integers (which may contain duplicates) and returns all possible unique subsets. **Function Signature**: ```python def generate_unique_subsets(nums: List[int]) -> List[List[int]]: pass ``` **Input**: * `nums`: A list of `n` integers where (0 leq n leq 10). **Output**: * A list of lists where each list is a unique subset of `nums`. **Constraints**: * Subsets can be returned in any order. * The solution set must not contain duplicate subsets. **Example**: ```python nums = [1, 2, 2] Output = [ [], [1], [2], [1,2], [2,2], [1,2,2] ] ``` Note: The order of subsets in the output does not matter. The focus is on removing duplicate subsets. **Performance Requirements**: * Ensure your solution efficiently handles the edge case of duplicate elements in the list. * Aim to minimize memory usage without compromising the correctness of the solution.","solution":"from typing import List def generate_unique_subsets(nums: List[int]) -> List[List[int]]: Generate all possible unique subsets of the given list of integers. Args: nums: List of integers which may contain duplicates. Returns: A list of unique subsets. def backtrack(start, path): subsets.append(path) for i in range(start, len(nums)): if i > start and nums[i] == nums[i-1]: continue backtrack(i + 1, path + [nums[i]]) nums.sort() subsets = [] backtrack(0, []) return subsets"},{"question":"Scenario You are a part of a rescue team responding to an emergency situation in a building. The building is represented as a grid where: - `-1` indicates walls or obstacles blocking passage. - `0` indicates gates that are entry points for the rescue team. - `INF` (2^31 - 1) indicates empty rooms that need to be evaluated. Your task is to compute the shortest distance from each empty room to its nearest gate and fill in the grid with these distances. If an empty room cannot reach any gate, leave it as `INF`. Function Signature ```python def walls_and_gates(rooms: List[List[int]]) -> None: ``` Input - `rooms`: a 2D list of integers representing the grid. Output - The function should modify the `rooms` grid in-place to fill each empty room with the minimum distance to any gate. Constraints 1. `1 <= m, n <= 250` where `m` is the number of rows and `n` is the number of columns. 2. The value at each cell is either `-1`, `0`, or `2147483647` (representing `INF`). Example ```python rooms = [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] walls_and_gates(rooms) # Expected Output: # [ # [3, -1, 0, 1], # [2, 2, 1, -1], # [1, -1, 2, -1], # [0, -1, 3, 4] # ] ``` Additional Notes - Ensure the function modifies the grid in-place. - Optimize for both time and space complexity as feasible. - Consider using BFS to efficiently handle the grid traversal.","solution":"from typing import List from collections import deque def walls_and_gates(rooms: List[List[int]]) -> None: Modify rooms grid in-place to fill empty rooms with the minimum distance to any gate. if not rooms: return rows, cols = len(rooms), len(rooms[0]) INF = 2147483647 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque() # Initialize the queue with all gates for r in range(rows): for c in range(cols): if rooms[r][c] == 0: queue.append((r, c)) # BFS to find the shortest distance to a gate while queue: r, c = queue.popleft() for dr, dc in directions: new_r, new_c = r + dr, c + dc if 0 <= new_r < rows and 0 <= new_c < cols and rooms[new_r][new_c] == INF: rooms[new_r][new_c] = rooms[r][c] + 1 queue.append((new_r, new_c))"},{"question":"# Question: Serialize and Deserialize N-ary Tree Given an N-ary tree, write two functions: 1. `serialize(root: Node) -> str`: This function takes the root of an N-ary tree and returns a string representation of the tree. 2. `deserialize(data: str) -> Node`: This function takes a string representation of an N-ary tree and reconstructs the tree, returning its root. Input/Output Format - **Node class**: ```python class Node: def __init__(self, val, children=None): self.val = val self.children = children if children is not None else [] ``` - **Provided Functions**: ```python def serialize(root: Node) -> str: # Your code here def deserialize(data: str) -> Node: # Your code here ``` Example: ```python # Serialized format: \\"1 2 3 4 # 5 # 6 # #\\" root = Node(1, [Node(2), Node(3, [Node(4)]), Node(5, []), Node(6)]) serialized = serialize(root) print(serialized) # Output: \\"1 2 # 3 4 # # 5 # 6 # #\\" root = deserialize(\\"1 2 # 3 4 # # 5 # 6 # #\\") print(root.val) # Output: 1 print(root.children[0].val) # Output: 2 print(root.children[1].val) # Output: 3 print(root.children[1].children[0].val) # Output: 4 ``` Constraints and Limitations - The tree will have at most 10^4 nodes. - The values of node integers lie within the range [-10^5, 10^5]. - Nodes may have multiple children, and each node can have up to 1000 children. - Handle edge cases like empty trees or trees with only one node. Performance Requirements - The functions should perform with a linear time complexity in relation to the number of nodes in the tree. - Aim to minimize the space complexity where possible, while ensuring accurate serialization/deserialization. # You should: - Implement both functions in the provided format. - Ensure your solution handles all edge cases effectively. - Write clear and efficient code.","solution":"class Node: def __init__(self, val, children=None): self.val = val self.children = children if children is not None else [] def serialize(root: Node) -> str: if not root: return \\"\\" serialized_data = [] def _serialize(node): if node: serialized_data.append(str(node.val)) for child in node.children: _serialize(child) serialized_data.append(\\"#\\") _serialize(root) return \\" \\".join(serialized_data) def deserialize(data: str) -> Node: if not data: return None tokens = data.split() root = Node(int(tokens[0])) stack = [root] for token in tokens[1:]: if token == \\"#\\": stack.pop() else: new_node = Node(int(token)) stack[-1].children.append(new_node) stack.append(new_node) return root"},{"question":"# Bit Flipping Conversion You are working on a project related to error detection using Hamming distance. One part of this project requires you to determine the minimal number of bits that need to be flipped to convert one integer into another. Given this context, write a function that efficiently calculates the number of bit flips required. Function Signature ```python def count_flips_to_convert(a: int, b: int) -> int: ``` Input - `a` (int): A non-negative integer. - `b` (int): A non-negative integer. Output - Returns the minimal number of bit flips required to convert `a` into `b`. Example ```python assert count_flips_to_convert(29, 15) == 2 # Binary: 11101 -> 01111 assert count_flips_to_convert(0, 0) == 0 # Binary: 00000 -> 00000 assert count_flips_to_convert(31, 14) == 2 # Binary: 11111 -> 01110 assert count_flips_to_convert(25, 30) == 3 # Binary: 11001 -> 11110 ``` # Constraints - `0 <= a, b <= 2**31 - 1` (non-negative integers within 32-bit integer range). # Notes - You should ensure the function runs efficiently within the given constraints. - Focus on correct handling of the XOR operation and counting set bits as described above.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Determines the minimal number of bits that need to be flipped to convert integer a into integer b. # XOR between a and b will give a number with bits set at positions where a and b differ xor = a ^ b # Count the number of set bits in the result (this gives the number of differing bits) count = 0 while xor: count += xor & 1 # Increment count if the last bit is 1 xor >>= 1 # Shift right to check the next bit return count"},{"question":"# Coding Assessment: Stack Stuttering Implementation Scenario You are tasked with duplicating every element in a stack such that each element appears twice in succession. This task assesses your understanding of stack operations and auxiliary data structures. Task Write a function `duplicate_elements(stack)` that takes a stack (represented as a list in Python) and replaces every element with two occurrences of that element, preserving the original order. Constraints * You must not use a stack or queue from any standard library. * Your solution should demonstrate distinct approaches: one using a stack and another using a queue. Function Signature ```python def duplicate_elements(stack): # Your code here # Example usage: # stack = [3, 7, 1, 14, 9] # duplicate_elements(stack) # Output should be: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` Input and Output * **Input**: A list of integers representing a stack (top of the stack is the last element of the list). * **Output**: Modify the input stack in place to contain each element duplicated. Performance Requirements * Time Complexity: O(n) * Space Complexity: O(n) Example Scenarios 1. `stack = [3, 7, 1, 14, 9]` should result in `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]`. 2. `stack = []` should result in `[]`. 3. `stack = [13]` should result in `[13, 13]`. Function Hints 1. **First Approach (Using a Stack)** * Use an auxiliary stack to temporarily hold the elements while reversing their order. * Duplicate each element and push them back onto the original stack. 2. **Second Approach (Using a Queue)** * Use an auxiliary queue to reverse the stack order. * Duplicate each element and push them back onto the original stack. Notes * Write clean and readable code. * Pay special attention to edge cases. * Provide comments explaining your approach.","solution":"def duplicate_elements(stack): Duplicate each element in the stack such that each element appears twice in succession. # Using an auxiliary stack to hold elements temporarily aux_stack = [] # Step 1: Pop elements from the original stack and push them onto the auxiliary stack while stack: element = stack.pop() aux_stack.append(element) # Step 2: Pop elements from the auxiliary stack, duplicate them, and push back to the original stack while aux_stack: element = aux_stack.pop() stack.append(element) stack.append(element) # Example usage: # stack = [3, 7, 1, 14, 9] # duplicate_elements(stack) # Output should be: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9]"},{"question":"# Priority Queue Optimization Challenge You are given a priority queue implemented using a linear array. While the current implementation works fine for smaller datasets, it suffers from performance issues with larger inputs. We need you to optimize this priority queue for better performance. Implement the priority queue using a **binary heap** which improves the insertion and extraction operations. # Function Definitions You need to implement the following methods: - **`__init__(self, items=None, priorities=None)`**: Initializes an empty priority queue. If `items` and `priorities` are provided, initialize the priority queue with these items. - **`push(self, item, priority=None)`**: Inserts an item into the priority queue with the given priority. If no priority is given, set the priority to the value of the item. - **`pop(self)`**: Removes and returns the item with the highest priority (the smallest value). # Input and Output Format - **`__init__`:** `items` and `priorities` are optional lists of equal length. Each item in `items` has a corresponding priority in `priorities`. - **`push`:** Takes an `item` and an optional `priority` as input. - **`pop`:** Returns the `item` with the highest priority in the queue. # Constraints - Maximum number of items in the priority queue: (10^6) - Item values and priorities are integer values. # Example ```python # Initialize the priority queue with items and priorities pq = PriorityQueue(items=[10, 20, 30], priorities=[3, 2, 1]) # Adding element without specifying priority sets priority as the item value pq.push(5) # Extracting minimum assert pq.pop() == 5 # `5` has the highest priority (smallest value) # Extracting the next minimum assert pq.pop() == 30 # followed by `30` having priority `1` ``` # Performance Requirements - The average time complexity for both `push` and `pop` operations should be (O(log n)). Now, implement the priority queue using a binary heap.","solution":"import heapq class PriorityQueue: def __init__(self, items=None, priorities=None): self.heap = [] if items and priorities: for item, priority in zip(items, priorities): heapq.heappush(self.heap, (priority, item)) def push(self, item, priority=None): if priority is None: priority = item heapq.heappush(self.heap, (priority, item)) def pop(self): if self.heap: _, item = heapq.heappop(self.heap) return item raise IndexError(\\"pop from empty priority queue\\")"},{"question":"**Forest Fire Suppression** Context Imagine you are in charge of a forest fire simulation where the forest is represented as a 2D grid of `m x n`. Each cell can either contain a tree (represented by 1) or be empty (represented by 0). Initially, all cells are empty. You will have a series of operations to plant trees or manage the burning of the forest. Two adjacent cells are considered part of the same forest if they are connected vertically or horizontally, but not diagonally. We need to manage the connected components of the forest and determine the number of separate forests at each step after a planting operation. A \\"forest\\" is a connected component of trees. Task Write a function `forest_fire_suppression(grid_size: Tuple[int, int], operations: List[Tuple[int, int]]) -> List[int]` that simulates the planting of trees and returns a list with the number of separate forests after each planting operation. Input - `grid_size`: A tuple of two integers (m, n) representing the dimensions of the 2D forest grid. - `operations`: A list of tuples (i, j) where each tuple represents a position in the grid where a tree is to be planted. Output - A list of integers where the k-th integer represents the number of separate forests after the k-th planting operation. Constraints - 1 <= m, n <= 10^3 - 1 <= len(operations) <= min(10^4, m * n) - Each tree planting operation `(i, j)` is valid, i.e., `0 <= i < m` and `0 <= j < n` Example Input: ```python grid_size = (3, 3) operations = [(0, 0), (0, 1), (1, 2), (2, 1)] ``` Output: ```python [1, 1, 2, 3] ``` Explanation The grid transformations follow: - After `(0, 0)`: 1 forest - After `(0, 1)`: 1 forest (since `(0, 0)` and `(0, 1)` connect) - After `(1, 2)`: 2 forests - After `(2, 1)`: 3 forests Function Signature ```python from typing import List, Tuple def forest_fire_suppression(grid_size: Tuple[int, int], operations: List[Tuple[int, int]]) -> List[int]: # Your implementation here ```","solution":"from typing import List, Tuple def forest_fire_suppression(grid_size: Tuple[int, int], operations: List[Tuple[int, int]]) -> List[int]: m, n = grid_size parent = {} rank = {} def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def position_to_id(i, j): return i * n + j def neighbors(i, j): for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and (ni, nj) in parent: yield ni, nj result = [] forests = 0 for i, j in operations: if (i, j) not in parent: id = position_to_id(i, j) parent[(i, j)] = (i, j) rank[(i, j)] = 0 forests += 1 for ni, nj in neighbors(i, j): if find((i, j)) != find((ni, nj)): union((i, j), (ni, nj)) forests -= 1 result.append(forests) return result"},{"question":"# Increment a Number Represented by Digits You are given a non-negative number represented as a list of digits. Each element in the list contains a single digit. The digits are stored in such a way that the most significant digit is at the head of the list. Your task is to write a function that adds one to this number and returns the resulting list of digits. # Function Signature ```python def plus_one(digits: List[int]) -> List[int]: ``` # Input: * A list of non-negative digits representing a number. The list will have at least one element and all elements are between 0 and 9. # Output: * The resulting list of digits after adding one to the number. # Examples: ```python assert plus_one([1, 2, 3]) == [1, 2, 4] assert plus_one([4, 3, 2, 1]) == [4, 3, 2, 2] assert plus_one([9, 9, 9]) == [1, 0, 0, 0] ``` # Constraints: * The input list is guaranteed to represent a non-negative integer without leading zeros (except the number 0 itself). # Requirements: 1. You are not allowed to use any direct conversion of the list to string or integer for manipulation. 2. The solution should be performant with a linear time complexity relative to the number of digits. # Scenario: Imagine you\'re working on improving the financial system of a banking application where these large numbers might represent account balances that frequently need to be incremented by 1 due to transactions. Your function will make sure the balance updates correctly regardless of its size.","solution":"def plus_one(digits): Adds one to a number represented by a list of digits. Args: digits: List[int] - A list of non-negative digits representing the number. Returns: List[int] - The resulting list of digits after adding one to the number. n = len(digits) # Traverse the digits from the end towards the beginning for i in range(n - 1, -1, -1): if digits[i] == 9: digits[i] = 0 else: digits[i] += 1 return digits # If all the digits were 9, we need an extra place for 1 at the start return [1] + digits"},{"question":"# Calculate Number of Combinations with Constraints Objective: You need to implement a function that calculates the number of ways to choose `r` items from `n` items using a dynamic programming approach to ensure efficiency. Function Signature: ```python def combination_dp(n: int, r: int) -> int: pass ``` Input: - `n` (int): the total number of items. (1 ≤ n ≤ 1000) - `r` (int): the number of items to choose. (0 ≤ r ≤ n) Output: - Returns an integer which is the number of combinations (nCr). Constraints: - For large `n`, the algorithm should handle efficiently to avoid excessive computation time or memory usage. - Your implementation must handle invalid inputs gracefully, such as when `r > n` or if `n` or `r` are negative. Example: ```python print(combination_dp(5, 2)) # Output: 10 print(combination_dp(10, 3)) # Output: 120 print(combination_dp(10, 0)) # Output: 1 print(combination_dp(0, 0)) # Output: 1 print(combination_dp(5, 6)) # Output: 0 (invalid case) ``` Note: Do not use predefined functions for calculating combinations (like math.comb in Python 3.8+) or import any external libraries. Implement the logic using dynamic programming principles yourself.","solution":"def combination_dp(n: int, r: int) -> int: Returns the number of ways to choose r items from n items using dynamic programming. # Handle invalid inputs if r > n or n < 0 or r < 0: return 0 # Initial DP table, dp[x][y] will hold C(x, y) dp = [[0] * (r + 1) for _ in range(n + 1)] # Base cases for i in range(n + 1): dp[i][0] = 1 # C(i, 0) is 1 for all i for i in range(r + 1): dp[i][i] = 1 # C(i, i) is 1 for all i <= n # Fill DP table for i in range(1, n + 1): for j in range(1, min(i, r) + 1): dp[i][j] = dp[i-1][j-1] + dp[i-1][j] return dp[n][r]"},{"question":"Sum of Digits Powers You are tasked to find numbers within a specified range where the sum of its digits each raised to the power of their respective positions equals the number itself. Below is the function specification: Function Specification **Function Name**: `sum_dig_pow` * **Input**: * `low` (int): The lower bound of the range (inclusive). * `high` (int): The upper bound of the range (inclusive). * **Output**: * A list of integers that meet the self-power sum condition within the specified range. Constraints: * 1 <= low <= high <= 10^4. Example: ```python assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] ``` **Performance Requirements**: * The solution should efficiently handle ranges up to 10,000. **Scenario**: Imagine you are analyzing a sequence of numbers to identify special numbers that can be represented by a mathematical curiosity where each digit\'s power sum is equal to the number itself. This property is interesting in the study of numbers and can be useful in various theoretical and practical applications, such as cryptography, validation checks, and more. Write the function `sum_dig_pow` to find and return such numbers within the given range from `low` to `high` inclusive.","solution":"def sum_dig_pow(low, high): Finds numbers within the range [low, high] such that the sum of their digits each raised to the power of their respective positions equals the number itself. def is_eureka_number(num): digits = [int(d) for d in str(num)] return num == sum(d ** (i + 1) for i, d in enumerate(digits)) return [num for num in range(low, high + 1) if is_eureka_number(num)]"},{"question":"# Problem Description: You are tasked with developing a data structure called `WordDictionary` that is capable of storing words and performing searches using literal and pattern matching (where `.` can represent any character). You need to choose the appropriate underlying data structure and implement the necessary methods based on your understanding of the complexities and characteristics of the Trie and Dictionary-based search mechanisms. # Required Methods: 1. **add_word(self, word: str) -> None**: Adds the word to the WordDictionary. 2. **search(self, word: str) -> bool**: Returns `True` if there is any word in the WordDictionary that matches the given word or pattern, otherwise returns `False`. # Constraints: - The word\'s length will be between 1 and 50 characters. - The number of words added will not exceed `10^4`. # Example: ```python wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") print(wd.search(\\"pad\\")) # Output: False print(wd.search(\\"bad\\")) # Output: True print(wd.search(\\".ad\\")) # Output: True print(wd.search(\\"b..\\")) # Output: True ``` # Implementation Requirements: - Implement `add_word` to add words efficiently. - Implement `search` to handle both exact word matches and pattern matches using `.`. - Consider edge cases such as pattern searches with multiple `.` and empty strings. - Ensure memory usage is optimal and the search performance is efficient. You are required to write only these two methods in a class called `WordDictionary`.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): Initialize WordDictionary with root as TrieNode. self.root = TrieNode() def add_word(self, word: str) -> None: Adds a word into the WordDictionary. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: Returns if the word is in the WordDictionary. A word could contain the dot character \'.\' to represent any one letter. return self._search(word, 0, self.root) def _search(self, word: str, index: int, node: TrieNode) -> bool: if index == len(word): return node.is_end_of_word char = word[index] if char == \'.\': for child in node.children.values(): if self._search(word, index + 1, child): return True return False else: if char not in node.children: return False return self._search(word, index + 1, node.children[char])"},{"question":"# Scenario You are tasked with designing an algorithm for a basic text processing application that involves repeating characters in a stack. Considering the limited resources and the need for maintaining order, choose an appropriate approach for duplicating values within a stack. # Problem Statement Write a function `stutter_stack(stack: list) -> list` that takes a stack represented by a list of integers and duplicates each value in the stack, preserving original order. Implement two solutions: 1. **First Solution**: Using another stack for auxiliary storage. 2. **Second Solution**: Using a queue for auxiliary storage. # Requirements - **Function signatures**: ```python def stutter_stack_with_stack(stack: list) -> list: pass def stutter_stack_with_queue(stack: list) -> list: pass ``` - **Input**: - `stack`: List of integers representing a stack (e.g., `[3, 7, 1, 14, 9]`). - **Output**: - A list representing new stack with each value duplicated. - Example: Input: `[3, 7, 1, 14, 9]` should produce `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]`. # Constraints - The stack can have up to `1000` elements. - Values in the stack are integers between `-1000` and `1000`. # Performance Requirements - The implementation should complete within a reasonable time frame, and must not exceed `O(n)` time and `O(n)` space complexity. # Instructions 1. Implement the first solution (`stutter_stack_with_stack`) using an auxiliary stack, ensuring the duplicated elements maintain the original order. 2. Implement the second solution (`stutter_stack_with_queue`) using an auxiliary queue, ensuring the duplicated elements maintain the original order. 3. Handle edge cases such as an empty stack and single-element stack. 4. Ensure the solution is efficient and does not use excessive memory or processing time.","solution":"def stutter_stack_with_stack(stack: list) -> list: Duplicates each element in the stack using another stack for auxiliary storage. auxiliary_stack = [] while stack: element = stack.pop() auxiliary_stack.append(element) auxiliary_stack.append(element) while auxiliary_stack: stack.append(auxiliary_stack.pop()) return stack def stutter_stack_with_queue(stack: list) -> list: Duplicates each element in the stack using a queue for auxiliary storage. from collections import deque queue = deque() while stack: element = stack.pop() queue.appendleft(element) queue.appendleft(element) while queue: stack.append(queue.popleft()) return stack"},{"question":"# Question You need to implement a function using the Sieve of Eratosthenes algorithm to find all prime numbers less than a given number (n). To optimize the algorithm, avoid checking even numbers (except 2) and use a sieve array approximately half the size of (n). Function Signature ```python def get_primes(n: int) -> List[int]: Return a list of all prime numbers less than n. Parameters: n (int): The upper limit (exclusive) for generating prime numbers. Returns: List[int]: A list of prime numbers less than n. Raises: ValueError: If \'n\' is not a positive integer. ``` Input * `n` (int): An integer (n) where (n geq 2). Output * Returns a list of integers, which are the prime numbers less than (n). Constraints * (2 leq n leq 10^6). Example ```python print(get_primes(10)) # Output: [2, 3, 5, 7] print(get_primes(20)) # Output: [2, 3, 5, 7, 11, 13, 17, 19] ``` Notes Students should focus on implementing an efficient solution using the optimized sieve mechanism described. Handle edge cases where (n) is very small or invalid. Ensure the algorithm\'s performance is acceptable within the given constraints (both in terms of time and space).","solution":"from typing import List def get_primes(n: int) -> List[int]: Return a list of all prime numbers less than n. Parameters: n (int): The upper limit (exclusive) for generating prime numbers. Returns: List[int]: A list of prime numbers less than n. Raises: ValueError: If \'n\' is not a positive integer. if n <= 1: raise ValueError(\\"Input must be greater than 1\\") if n <= 2: return [] sieve = [True] * (n // 2) sieve[0] = False # 1 is not a prime number result = [2] for i in range(1, (n // 2)): if sieve[i]: prime = 2 * i + 1 result.append(prime) for j in range(2 * i * (i + 1), n // 2, prime): sieve[j] = False return result"},{"question":"Enhanced Heap Sort Scenario As a software developer for a financial analytics company, you\'re tasked with efficiently sorting vast amounts of financial data. Due to memory constraints, you must implement an in-place ascending sort while maintaining an average-case time complexity of O(n log(n)). Your team has decided to use a hybrid approach utilizing both max heap sort and min heap sort, depending on the data\'s initial characteristics. Problem Statement Implement the function `hybrid_heap_sort(arr)`, which takes an array of integers `arr` and sorts it in ascending order. The function should choose between max heap sort and min heap sort based on the following criteria: - If the median of the array, when included with the first and last elements, is closer to the first element, use max heap sort. - Otherwise, use min heap sort. **Function Signature**: ```python def hybrid_heap_sort(arr: List[int]) -> List[int]: pass ``` **Input**: - `arr` (List[int]): An unsorted array of integers, with length at most `10^6`. **Output**: - List[int]: The array sorted in ascending order. Constraints: 1. The array length (`len(arr)`) is at most `10^6`. 2. The numbers in the array can be both negative and positive, and within the range of 32-bit integers. Example: ```python assert hybrid_heap_sort([3, 1, -1, 0, 2]) == [-1, 0, 1, 2, 3] assert hybrid_heap_sort([8, 5, 3, 2, 6, 7]) == [2, 3, 5, 6, 7, 8] ``` Performance Requirements - The time complexity should be O(n log(n)). - The space complexity should be O(1) (in-place sorting). Notes 1. Ensure the implementation correctly determines which heap sort to use by computing the median of the first, middle, and last elements of the array. 2. Handle edge cases such as empty arrays or arrays with a single element. **Hint**: You can make use of the functions `max_heap_sort` and `min_heap_sort` provided in the code snippet with modifications to fit this hybrid sorting function.","solution":"from typing import List def hybrid_heap_sort(arr: List[int]) -> List[int]: def max_heapify(arr, n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[i] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] max_heapify(arr, n, largest) def min_heapify(arr, n, i): smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[i] > arr[left]: smallest = left if right < n and arr[smallest] > arr[right]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] min_heapify(arr, n, smallest) def max_heap_sort(arr): n = len(arr) for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] max_heapify(arr, i, 0) def min_heap_sort(arr): n = len(arr) for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] min_heapify(arr, i, 0) arr.reverse() if len(arr) <= 1: return arr first, middle, last = arr[0], arr[len(arr) // 2], arr[-1] median = sorted([first, middle, last])[1] if abs(median - first) <= abs(median - last): max_heap_sort(arr) else: min_heap_sort(arr) return arr"},{"question":"You are to implement functions to simulate a Markov Chain system. The goal is to ensure the system can handle random state transitions based on provided probabilities. # Functions to Implement 1. `def add_state_transition(chain, state, next_states):` - **Description**: This function should add a new state and its corresponding transitions to the Markov chain. - **Input**: - `chain` (dict): The current Markov chain dictionary. - `state` (str): The state to add. - `next_states` (dict): A dictionary with potential next states and their probabilities. - **Output**: None 2. `def validate_chain(chain):` - **Description**: Validate the entire Markov chain ensuring all probabilities for each state sum up to 100%. - **Input**: - `chain` (dict): The Markov chain dictionary. - **Output**: - `valid` (bool): Whether the Markov chain is valid or not. - `errors` (list): List of error messages indicating states with incorrect probabilities. 3. `def simulate_states(chain, initial_state, num_iterations):` - **Description**: Generate a sequence of states starting from an initial state based on the Markov chain for a given number of iterations. - **Input**: - `chain` (dict): The Markov chain dictionary. - `initial_state` (str): The starting state for the simulation. - `num_iterations` (int): The number of states to generate. - **Output**: list of states # Constraints - The transition probabilities in `next_states` dictionary for each state must sum to 1.0. - Assume there are no circular dependencies in state transitions. - The function `add_state_transition` should check for and raise an `ValueError` if the probabilities do not sum to 1.0. # Example ```python # Initialize an empty chain markov_chain = {} # Add states to the chain add_state_transition(markov_chain, \'A\', {\'A\': 0.6, \'B\': 0.4}) add_state_transition(markov_chain, \'B\', {\'A\': 0.3, \'B\': 0.7}) # Validate the chain valid, errors = validate_chain(markov_chain) print(valid) # Expected output: True # Simulate states sequence = simulate_states(markov_chain, \'A\', 10) print(sequence) # Expected output: A list of 10 states starting from \'A\' ```","solution":"import random def add_state_transition(chain, state, next_states): Adds a new state and its corresponding transitions to the Markov chain. :param chain: dict - The current Markov chain dictionary. :param state: str - The state to add. :param next_states: dict - A dictionary with potential next states and their probabilities. :raises ValueError: If the probabilities do not sum to 1.0. if not isinstance(chain, dict) or not isinstance(next_states, dict): raise TypeError(\\"Both chain and next_states should be dictionaries\\") total_probability = sum(next_states.values()) if not (0.999 <= total_probability <= 1.001): # Allow minor floating point inaccuracy raise ValueError(\\"The probabilities for next_states must sum to 1.0\\") chain[state] = next_states def validate_chain(chain): Validate the entire Markov chain ensuring all probabilities for each state sum up to 100%. :param chain: dict - The Markov chain dictionary. :return: (boolean, list) - Whether the chain is valid and a list of error messages. valid = True errors = [] for state, transitions in chain.items(): total_probability = sum(transitions.values()) if not (0.999 <= total_probability <= 1.001): # Allow minor floating point inaccuracy valid = False errors.append(f\\"State {state} probabilities do not sum to 1.0\\") return valid, errors def simulate_states(chain, initial_state, num_iterations): Generate a sequence of states starting from an initial state based on the Markov chain for a given number of iterations. :param chain: dict - The Markov chain dictionary. :param initial_state: str - The starting state for the simulation. :param num_iterations: int - The number of states to generate. :return: list - A list of states. if initial_state not in chain: raise ValueError(f\\"The initial state {initial_state} is not in the chain\\") current_state = initial_state states_sequence = [current_state] for _ in range(num_iterations - 1): next_states = list(chain[current_state].keys()) probabilities = list(chain[current_state].values()) current_state = random.choices(next_states, weights=probabilities, k=1)[0] states_sequence.append(current_state) return states_sequence"},{"question":"# Question: File Path Normalization and Validation You are tasked with writing a function that not only computes the absolute path of a given file but also validates whether the path exists in the filesystem. Your function should handle paths containing `~`, `..`, and relative paths correctly and return `None` if the file does not exist. Function Signature ```python def validate_and_normalize_path(file: str) -> str: pass ``` # Input - `file` - a string representing a file path, which could be relative, absolute, or contain user home shortcuts (`~`). # Output - The absolute path as a string if the file exists, otherwise `None`. # Constraints - You are restricted from using any third-party libraries; only the standard `os` library is allowed. - File paths can have a maximum length of 4096 characters. # Example ```python # If the file exists at the resolved path. print(validate_and_normalize_path(\\"~/Documents/my_file.txt\\")) # Output: \\"/home/username/Documents/my_file.txt\\" # If the file does not exist at the resolved path. print(validate_and_normalize_path(\\"/non/existent/path.txt\\")) # Output: None ```","solution":"import os def validate_and_normalize_path(file: str) -> str: Returns the absolute path if the file exists, otherwise None. # Expand the user home directory symbol ~ file = os.path.expanduser(file) # Get the absolute path absolute_path = os.path.abspath(file) # Check if the file exists if os.path.exists(absolute_path): return absolute_path else: return None"},{"question":"# Path Normalization Function Implementation Objective: Write a function `normalize_path` that normalizes a file path by converting it to its absolute form and expanding any user-specific components (e.g., `~`). Function Signature: ```python def normalize_path(file_path: str) -> str: ``` Input: - `file_path` (str): A file path that may be absolute, relative, or user-relative (containing `~`). Output: - `out_path` (str): The absolute, user-expanded form of the input file path. Example: ```python assert normalize_path(\\"~/documents/project\\") == \\"/home/username/documents/project\\" # Use your corresponding user path during testing. assert normalize_path(\\"file.txt\\") == \\"/current/working/directory/file.txt\\" # Where \'/current/working/directory\' is the working directory where the script is executed. ``` Constraints: - Do not assume the input file path exists on the file system. - The implementation should handle paths of reasonable length (up to 4096 characters). Requirements: - Time complexity should be O(N) where N is the length of the file path. - Space complexity should be O(N) accordingly. - Handle edge cases such as empty strings, paths with multiple `..` and `.` components, and paths with no user-specific part. Context: You are working on a script that requires robust handling of file paths to ensure all paths provided by the user or generated by the application are normalized to their absolute form. This ensures consistency and reliability in subsequent file operations. Good luck, and write clean, efficient code!","solution":"import os def normalize_path(file_path: str) -> str: Normalizes a file path by converting it to its absolute form and expanding any user-specific components (e.g., ~). return os.path.abspath(os.path.expanduser(file_path))"},{"question":"# One Edit Distance Checker Scenario A company implementing a version control system wants to ensure that each new version of a document (string) is exactly one modification away from the previous version. The modification can be an insertion, deletion, or substitution of a single character. Task Write a function `is_one_edit_away(s: str, t: str) -> bool` to determine if two input strings `s` and `t` are exactly one edit distance apart. Function Signature ```python def is_one_edit_away(s: str, t: str) -> bool: ``` Input * `s` (string): The first string (0 <= len(s) <= 10^4) * `t` (string): The second string (0 <= len(t) <= 10^4) Output * Return `True` if the strings are one edit distance apart, otherwise return `False`. Constraints * The function should run in O(n) time complexity, where n is the length of the shorter string. * Only one edit (insert, delete, or substitute a character) is allowed to make the strings equal. Performance Requirements Your solution should be efficient with respect to time and space, adhering to the specified limits above. Examples 1. `is_one_edit_away(\\"abc\\", \\"ab\\")` → `True` (one deletion) 2. `is_one_edit_away(\\"abc\\", \\"adc\\")` → `True` (one substitution) 3. `is_one_edit_away(\\"abc\\", \\"abcd\\")` → `True` (one insertion) 4. `is_one_edit_away(\\"abc\\", \\"abcde\\")` → `False` (more than one edit) Additional Notes Consider edge cases involving empty strings, identical strings, strings differing by more than one character, and whether the function generalizes well to non-alphabetic characters.","solution":"def is_one_edit_away(s: str, t: str) -> bool: Function to check if two strings are exactly one edit distance away. m, n = len(s), len(t) if abs(m - n) > 1: return False if m > n: # Ensure s is the shorter one return is_one_edit_away(t, s) i, j, edit = 0, 0, 0 while i < m and j < n: if s[i] != t[j]: if edit == 1: return False edit += 1 if m == n: i += 1 # If not the same length move only in the longer string else: i += 1 j += 1 # If one char left in the longer string return edit == 1 or m != n"},{"question":"You are provided with a stack of integers. Your task is to write a function `stutter_stack` that replaces every value in this stack with two occurrences of that value in the correct order, ensuring that the element replication maintains the original order. Here are the definitions of the two methods you need to implement: 1. `stutter_stack_single_aux(stack: List[int]) -> List[int]`: This method should use a single stack as auxiliary storage. 2. `stutter_stack_with_queue(stack: List[int]) -> List[int]`: This method should use a single queue as auxiliary storage. # Input and Output Formats **Input**: - A single stack is represented as a list of integers where the first element is the bottom of the stack and the last element is the top. **Output**: - A modified stack with each value replaced by two occurrences of that value in the correct order. # Constraints: - The stack contains at most (10^5) integers. - Each integer in the stack is between (-10^9) and (10^9). # Example Given a stack represented as: `[3, 7, 1, 14, 9]`: The output after using `stutter_stack_single_aux` should be `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]`. The output after using `stutter_stack_with_queue` should be `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]`. # Implementation Details Please ensure your implementation adheres to the following: * **Performance Requirements**: Both methods should run efficiently with a time complexity of O(n). * **Edge Cases**: Handle edge cases such as empty stacks and stacks with single elements. * **Error Scenarios**: Ensure no elements are lost and the duplication is done in the correct order. Here are function definitions to get you started: ```python def stutter_stack_single_aux(stack: List[int]) -> List[int]: # Your implementation here pass def stutter_stack_with_queue(stack: List[int]) -> List[int]: # Your implementation here pass ```","solution":"from typing import List def stutter_stack_single_aux(stack: List[int]) -> List[int]: aux_stack = [] while stack: value = stack.pop() aux_stack.append(value) aux_stack.append(value) # Need to reverse the aux_stack to maintain the original order while aux_stack: stack.append(aux_stack.pop()) result = [] while stack: result.append(stack.pop()) # Reverse the result stack to get the expected order return result[::-1] def stutter_stack_with_queue(stack: List[int]) -> List[int]: from collections import deque queue = deque() while stack: value = stack.pop() queue.appendleft(value) queue.appendleft(value) result = [] while queue: result.append(queue.pop()) return result[::-1]"},{"question":"# Context You are provided with a sorted array of unique integers. Your task is to implement a search algorithm that efficiently finds the position of a specified search key. The data is uniformly distributed, making it suitable for interpolation search. # Problem Statement Implement the function `optimized_interpolation_search(array: List[int], target: int) -> int` that finds the position of the `target` in the `array` using an optimized approach of interpolation search. If the `target` is not found, the function should return -1. Handle edge cases thoughtfully. # Input and Output Formats * **Input**: * `array`: A list of sorted unique integers ((1 leq size leq 10^6)). * `target`: The integer to search for in the array. * **Output**: * Return the index of `target` in `array` if found, otherwise return -1. # Constraints * The array is sorted in increasing order. * Elements in the array are unique. * Consider edge cases such as `target` being out of range and identical elements. # Performance Requirements * Aim for (O(log log n)) time complexity for average scenarios. * The function should operate in (O(1)) space complexity. # Function Signature ```python from typing import List def optimized_interpolation_search(array: List[int], target: int) -> int: pass ``` # Example ```python assert optimized_interpolation_search([10, 20, 30, 40, 50], 30) == 2 assert optimized_interpolation_search([10, 20, 30, 40, 50], 25) == -1 assert optimized_interpolation_search([-10, -3, 0, 5, 9, 12], -3) == 1 assert optimized_interpolation_search([1, 3, 5, 7, 9, 11, 13], 0) == -1 assert optimized_interpolation_search([2, 4, 6, 8, 10], 8) == 3 ``` # Considerations * Ensure bounds check to handle dividing by zero situations. * Ensure `pos` calculation prevents out-of-bound access.","solution":"from typing import List def optimized_interpolation_search(array: List[int], target: int) -> int: lo, hi = 0, len(array) - 1 while lo <= hi and array[lo] <= target <= array[hi]: if lo == hi: if array[lo] == target: return lo return -1 pos = lo + ((target - array[lo]) * (hi - lo) // (array[hi] - array[lo])) if pos < lo or pos > hi: return -1 if array[pos] == target: return pos if array[pos] < target: lo = pos + 1 else: hi = pos - 1 return -1"},{"question":"# Problem Description You are provided with an algorithm to solve the 2-SAT problem using Kosaraju\'s algorithm to find strongly connected components (SCCs). The challenge is to modify the given code to handle additional constraints and ensure optimized performance for larger datasets. Specifically, you need to implement a function that checks if an extended logical formula remains satisfiable after adding new constraints. # Function Signature ```python def is_satisfiable_with_constraints(formula: List[Tuple[Tuple[str, bool], Tuple[str, bool]]], constraints: List[Tuple[Tuple[str, bool], Tuple[str, bool]]]) -> bool: pass ``` # Input * `formula`: List of tuples representing a 2-CNF formula. Each tuple contains two literals, where each literal is represented by a tuple `(name, is_neg)`: - `name`: a string representing the variable identifier. - `is_neg`: a boolean where `True` means the variable is negated. * `constraints`: Additional list of tuples similar to the formula, representing extra logical constraints to check against the original formula. # Output * Return `True` if the formula remains satisfiable after adding the new constraints. Otherwise, return `False`. # Constraints * 2 ≤ number of variables ≤ 1000 * 1 ≤ number of clauses in the formula + constraints ≤ 10^5 # Example Usage ```python formula = [((\'x\', False), (\'y\', False)), ((\'y\', True), (\'y\', True)), ((\'a\', False), (\'b\', False)), ((\'a\', True), (\'c\', True)), ((\'c\', False), (\'b\', True))] constraints = [((\'x\', True), (\'a\', False)), ((\'b\', False), (\'c\', True))] print(is_satisfiable_with_constraints(formula, constraints)) # Output: False ``` # Explanation This function first builds upon the existing 2-SAT solver to incorporate additional constraints presented by the truth values. Using the same steps to validate the satisfiability, the function should ensure extended constraints do not violate the original formula\'s consistency.","solution":"from typing import List, Tuple, Dict def is_satisfiable_with_constraints(formula: List[Tuple[Tuple[str, bool], Tuple[str, bool]]], constraints: List[Tuple[Tuple[str, bool], Tuple[str, bool]]]) -> bool: def add_clause(graph: Dict[str, List[str]], u: str, v: str): if u not in graph: graph[u] = [] graph[u].append(v) def dfs(graph, node, visited, stack): visited.add(node) if node in graph: for neighbour in graph[node]: if neighbour not in visited: dfs(graph, neighbour, visited, stack) stack.append(node) def kosaraju_scc(graph, reversed_graph): stack = [] visited = set() for node in graph: if node not in visited: dfs(graph, node, visited, stack) scc = {} visited = set() while stack: node = stack.pop() if node not in visited: component = [] dfs(reversed_graph, node, visited, component) for n in component: scc[n] = component return scc def build_implication_graph(clauses): graph = {} reversed_graph = {} for (x1, x1neg), (x2, x2neg) in clauses: u = (f\\"!{x1}\\" if x1neg else x1) v = (f\\"!{x2}\\" if x2neg else x2) add_clause(graph, u, v) add_clause(graph, v, u) add_clause(reversed_graph, v, u) add_clause(reversed_graph, u, v) return graph, reversed_graph combined_clauses = formula + constraints graph, reversed_graph = build_implication_graph(combined_clauses) scc = kosaraju_scc(graph, reversed_graph) for variable in graph: positive = variable.lstrip(\'!\') negated = f\\"!{positive}\\" if positive in scc and negated in scc and scc[positive] == scc[negated]: return False return True"},{"question":"# License Number Formatter You are provided with an alphanumeric string which may include dashes (`-`). Our task is to reformat this string so that it groups characters into segments of size `k`, separated by dashes. The first group might contain fewer characters if necessary, but each subsequent group must contain exactly `k` characters. The groups are to be formed from right to left. # Input * A string `key`: a combination of alphanumeric characters and dashes. * An integer `k`: the segment size. # Output * A reformatted string according to the above specifications. # Function Signature ```python def license_number(key: str, k: int) -> str: ... ``` # Constraints * The string `key` contains only alphanumeric characters and dashes (`-`). * The integer `k` is a positive integer. # Examples ```python license_number(\\"2-4A0r7-4k\\", 3) # Expected Output: \\"24-A0R-74K\\" license_number(\\"2-4A0r7-4k\\", 4) # Expected Output: \\"24A0-R74K\\" ``` # Scenario Imagine you\'re designing a software that generates license activation codes for a product, and these codes need to be human-readable. The codes should be formatted into segments of equal length, except possibly the first segment. This formatting eases error-free typing by end users.","solution":"def license_number(key: str, k: int) -> str: Reformats the input string key to group the characters into segments of size k, separated by dashes. The first group might be shorter. # Removing existing dashes and converting all to uppercase clean_key = key.replace(\'-\', \'\').upper() # Determining the length of the first group first_group_len = len(clean_key) % k or k # Initializing the result with the first group result = clean_key[:first_group_len] # Grouping the remaining characters in segments of size k for i in range(first_group_len, len(clean_key), k): result += \'-\' + clean_key[i:i+k] return result"},{"question":"# Array Rotation Challenge Implement a function to rotate an array to the right by a given number of steps using the optimal algorithms provided in the description. You must consider edge cases and strive for efficient solutions both in terms of time and space complexity. Function Signature: ```python def rotate(array: List[int], k: int) -> List[int]: # Your code here ``` Input: - `array`: A list of integers (1 <= len(array) <= 10^5) - `k`: An integer representing the number of steps to rotate the array (0 <= k <= 10^9) Output: - The function should return a new list of integers that is a rotated version of `array`. Constraints: - Must handle cases where `k` is larger than the length of the array efficiently. - Aim for O(n) time complexity and O(1) space complexity if possible. - You should not use any in-built array rotation functions or methods. Example: ```python assert rotate([1,2,3,4,5,6,7], 3) == [5,6,7,1,2,3,4] assert rotate([1,2,3,4,5,6,7], 10) == [5,6,7,1,2,3,4] assert rotate([], 3) == [] assert rotate([1,2], 0) == [1,2] assert rotate([1,2], 2) == [1,2] ``` Note: Write your implementation that efficiently utilizes the techniques discussed in the analysis, paying particular attention to edge cases.","solution":"def rotate(array, k): Rotates the array to the right by k steps. n = len(array) if n == 0: return array k = k % n if k == 0: return array # Split array into two parts and then combine them in reversed order return array[-k:] + array[:-k]"},{"question":"**Scenario**: You are involved in designing a cost-efficient network connecting multiple campuses of a university. Each campus is modeled as a node, and each direct connection between campuses has an associated cost. To minimize the overall setup cost, you need to find the minimum spanning tree of the network graph. **Problem Description**: Write a function that uses Prim\'s Algorithm to find the weight of the minimum spanning tree (MST) of a given connected graph. The graph is represented as a dictionary where keys are node labels, and values are lists of [weight, adjacent_node] pairs. **Function Signature**: ```python def prims_minimum_spanning(graph: dict) -> int: pass ``` # Input: * A dictionary `graph`, where each key is a node, and the corresponding value is a list of pairs `[weight, adjacent_node]`. The graph is guaranteed to be connected. # Output: * An integer representing the total weight of the MST. # Constraints: * The graph will have at least one node and at most 1000 nodes. * Weights of the edges will be non-negative integers not exceeding 1000. * The graph will be connected and undirected. # Example: ```python graph = { \'a\': [[3, \'b\'], [8, \'c\']], \'b\': [[3, \'a\'], [5, \'d\']], \'c\': [[8, \'a\'], [2, \'d\'], [4, \'e\']], \'d\': [[5, \'b\'], [2, \'c\'], [6, \'e\']], \'e\': [[4, \'c\'], [6, \'d\']] } assert prims_minimum_spanning(graph) == 14 ``` # Explanation: The minimum spanning tree for the given graph includes the edges with weights [3, 2, 4, 5], which sums up to 14. # Notes: * Consider edge cases such as single-node graphs. * Ensure to maintain the priority queue efficiently to uphold the time complexity.","solution":"import heapq def prims_minimum_spanning(graph): Returns the weight of the minimum spanning tree of a given graph using Prim\'s Algorithm. Parameters: graph (dict): A dictionary where each key is a node and values are lists of [weight, adjacent_node] pairs. Returns: int: The total weight of the minimum spanning tree. if not graph: return 0 # Start from an arbitrary node start_node = next(iter(graph)) # Priority queue to store the edges with minimum weights first min_heap = [(0, start_node)] total_weight = 0 visited = set() while min_heap: weight, node = heapq.heappop(min_heap) if node in visited: continue visited.add(node) total_weight += weight for edge in graph[node]: edge_weight, adjacent_node = edge if adjacent_node not in visited: heapq.heappush(min_heap, (edge_weight, adjacent_node)) return total_weight"},{"question":"# Context: You are working on a text editor with search functionality. The documents are stored as arrays of words, and you need to implement a search feature that locates a specific word within the document. Your task is to implement the search in the most straightforward but effective way. # Task: Write a function `enhanced_linear_search` that searches for a word in an array of words (a document) and returns the index of the first occurrence of the word. If the word is not found, the function should return -1. # Function Signature: ```python def enhanced_linear_search(document: List[str], word: str) -> int: ``` # Input: - `document` (List[str]): An array of words representing the document. Each element is a non-empty string. - `word` (str): The word to search for in the document. # Output: - (int): The index of the first occurrence of the word in the document, or -1 if the word isn\'t found. # Example: ```python document = [\\"the\\", \\"quick\\", \\"brown\\", \\"fox\\", \\"jumps\\", \\"over\\", \\"the\\", \\"lazy\\", \\"dog\\"] word = \\"fox\\" assert enhanced_linear_search(document, word) == 3 document = [\\"the\\", \\"quick\\", \\"brown\\", \\"fox\\", \\"jumps\\", \\"over\\", \\"the\\", \\"lazy\\", \\"dog\\"] word = \\"elephant\\" assert enhanced_linear_search(document, word) == -1 ``` # Constraints: - The document will contain at most 10^5 words. - Each word in the document will have a length between 1 and 20. - The function should execute in O(n) time, where n is the number of words in the document. Good luck!","solution":"def enhanced_linear_search(document, word): Searches for a word in an array of words (a document) and returns the index of the first occurrence of the word. If the word is not found, the function returns -1. for index, current_word in enumerate(document): if current_word == word: return index return -1"},{"question":"Implement an efficient solution for matrix exponentiation utilizing the principles of repeated squaring. Given an integer `k` and an `n x n` matrix `mat`, return the matrix raised to the power `k`, i.e., `mat^k`. # Function Signature ```python def matrix_power(mat: list, k: int) -> list: pass ``` # Input * `mat` (list of list of integers): A square matrix `n x n` where `1 <= n <= 100`. * `k` (int): An integer indicating the power to which the matrix is to be raised (`0 <= k <= 10^9`). # Output * Returns a list of lists of integers representing the result of matrix `mat` raised to the power `k`. # Constraints * Ensure your implementation is efficient enough to handle large `k`. * The input matrix `mat` is always a square matrix. # Example ```python mat = [ [2, 0], [0, 2] ] k = 3 print(matrix_power(mat, k)) # Output: [[8, 0], [0, 8]] mat = [ [1, 1], [1, 0] ] k = 5 print(matrix_power(mat, k)) # Output: [[8, 5], [5, 3]] ``` # Additional Notes * You are required to utilize matrix multiplication and identity matrix construction as helper functions. * Handle edge cases such as 0 exponent correctly by returning the identity matrix.","solution":"def matrix_multiply(mat1, mat2): Multiplies two matrices mat1 and mat2. n = len(mat1) res = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): res[i][j] = sum(mat1[i][k] * mat2[k][j] for k in range(n)) return res def identity_matrix(n): Returns the n x n identity matrix. return [[1 if i == j else 0 for j in range(n)] for i in range(n)] def matrix_power(mat, k): Returns the matrix `mat` raised to the power `k`. if k == 0: return identity_matrix(len(mat)) if k == 1: return mat half_power = matrix_power(mat, k // 2) half_power_squared = matrix_multiply(half_power, half_power) if k % 2 == 0: return half_power_squared else: return matrix_multiply(half_power_squared, mat)"},{"question":"Context You are given an array with `n` objects, each object being colored red, white, or blue. Your task is to write a function that sorts these objects so that the same colored objects are adjacent to each other and in the order red (0), white (1), and blue (2) in terms of their respective numerical values. Problem Statement Write a function `sort_colors(nums: List[int]) -> None` that sorts an array of integers representing colors: * Integers: * 0 represents red. * 1 represents white. * 2 represents blue. The function must modify the array in-place without using any sort library functions. Input * An array `nums` of integers where each integer is either `0`, `1`, or `2`. Output * The function does not return anything. It modifies the input array `nums` in-place to sort the colors. Constraints * The array length `n` will be between 0 and 300 (inclusive). * Each integer in the array will be either `0`, `1`, or `2`. Examples ```python # Example 1: nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] # Example 2: nums = [2, 0, 1] sort_colors(nums) print(nums) # Output: [0, 1, 2] # Example 3: nums = [0] sort_colors(nums) print(nums) # Output: [0] # Example 4: nums = [1, 2, 0, 1] sort_colors(nums) print(nums) # Output: [0, 1, 1, 2] ``` Your solution should handle: - Different lengths of the array up to 300. - Various orderings of the integers 0, 1, and 2. - The task must be completed in one pass (linear time).","solution":"def sort_colors(nums): Sorts the colors in the list nums in place such that all 0s come first, followed by all 1s and then all 2s. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: # nums[mid] == 2 nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# **Coding Assessment Question: Remove Bit from Binary Representation** Problem Statement As part of a data compression algorithm, you need to remove a bit at a specific position from an integer\'s binary representation. Write a function `remove_bit(num: int, i: int) -> int` that takes two inputs: - `num`: A non-negative integer representing the binary number from which a bit will be removed. - `i`: A zero-based index indicating the position of the bit to remove, counting from the least significant bit (rightmost bit). The function should return a new integer that results from removing the specified bit from the binary representation of `num`. Example ```python assert remove_bit(21, 2) == 9 # Binary \'10101\' -> \'1001\' assert remove_bit(21, 4) == 5 # Binary \'10101\' -> \'101\' assert remove_bit(21, 0) == 10 # Binary \'10101\' -> \'1010\' ``` Constraints - The input integer `num` will be in the range of 0 to `10^9`. - The bit index `i` will be within the number of bits of `num`. Explanation of Example - For `remove_bit(21, 2)`: - The binary representation of 21 is \'10101\'. - Removing the bit at index 2 modifies the binary to \'1001\', which is 9 in decimal. # Implementation Ensure your implementation is optimized and consider the edge cases, such as removing the bit from the most significant or least significant positions. **Note**: You should not use any high-level functions specifically designed to manipulate bits or convert binary to decimal directly. Instead, use bitwise operations to solve the problem efficiently.","solution":"def remove_bit(num: int, i: int) -> int: Removes the bit at the i-th position from the binary representation of num. mask = (1 << i) - 1 # Mask of all 1s smaller than bit position i # Split the number lower_bits = num & mask upper_bits = num >> (i + 1) # Combine the upper and lower bits without the i-th bit return (upper_bits << i) | lower_bits"},{"question":"# Question: Implement a Range Query Function for B-Tree Scenario Your task is to extend the given B-Tree class with a method to perform range queries. A range query finds all the keys in the B-Tree that fall within a specified range [low, high] (inclusive). Core Requirements * **Function Name**: `range_query` * **Input**: - `low` (integer): The lower bound of the range. - `high` (integer): The upper bound of the range. * **Output**: - List of integers representing the keys that fall within the specified range. * **Constraints**: - The B-Tree should be balanced after all operations. - The function should handle edge cases such as an empty tree or ranges that don’t contain any keys smoothly. - You should not assume any specific size or ordering of the tree. Example ```python # Example BTree setup btree = BTree(t_val=2) for key in [10, 20, 5, 6, 12, 30, 7, 17]: btree.insert_key(key) # Performing the range query result = btree.range_query(6, 17) # Expected Output: [6, 7, 10, 12, 17] print(result) ``` Implementation Notes The range_query function should perform an in-order traversal of the B-Tree and collect all keys that fall within the specified [low, high] range.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, else False self.keys = [] # List of keys in the node self.children = [] # List of child pointers class BTree: def __init__(self, t): self.root = BTreeNode(t, leaf=True) self.t = t # Minimum degree def insert_key(self, k): root = self.root if len(root.keys) == (2 * self.t) - 1: temp = BTreeNode(self.t) self.root = temp temp.leaf = False temp.children.append(root) self._split_child(temp, 0) self._insert_non_full(temp, k) else: self._insert_non_full(root, k) def _insert_non_full(self, node, k): i = len(node.keys) - 1 if node.leaf: node.keys.append(None) while i >= 0 and k < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = k else: while i >= 0 and k < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t) - 1: self._split_child(node, i) if k > node.keys[i]: i += 1 self._insert_non_full(node.children[i], k) def _split_child(self, parent, i): t = self.t node_to_split = parent.children[i] new_node = BTreeNode(t, leaf=node_to_split.leaf) parent.children.insert(i + 1, new_node) parent.keys.insert(i, node_to_split.keys[t - 1]) new_node.keys = node_to_split.keys[t:(2 * t) - 1] node_to_split.keys = node_to_split.keys[0:t - 1] if not node_to_split.leaf: new_node.children = node_to_split.children[t:(2 * t)] node_to_split.children = node_to_split.children[0:t] def range_query(self, low, high): result = [] self._range_query(self.root, low, high, result) return result def _range_query(self, node, low, high, result): i = 0 while i < len(node.keys) and node.keys[i] < low: i += 1 while i < len(node.keys) and node.keys[i] <= high: if not node.leaf: self._range_query(node.children[i], low, high, result) result.append(node.keys[i]) i += 1 if not node.leaf: self._range_query(node.children[i], low, high, result)"},{"question":"# Binary Search Tree Balanced Insertion You are given the implementation of a Binary Search Tree (BST) with basic functionalities like insert, search, size, and traversal methods. This standard implementation does not maintain a balanced tree, which means in the worst-case scenario, the tree can become unbalanced, degrading to a linked list with O(N) time complexity for search and insert operations. Your Task: Modify the given BST implementation to maintain a balanced tree. Choose any algorithm to keep the tree balanced (such as AVL Tree, Red-Black Tree, or another self-balancing BST algorithm). Requirements: 1. **Implement Balancing**: Modify the `insert` method to include rebalancing logic to maintain tree balance after each insertion. 2. **Search Operation**: Ensure the search operation works correctly in the balanced tree. 3. **Size Operation**: Ensure the size operation remains efficient and accurate. 4. **Traversal Methods**: Ensure all traversal methods (preorder, inorder, postorder) work correctly irrespective of the balancing algorithm applied. Constraints: 1. **Value Range**: The data values in the nodes will be unique integers within the range `[-10^6, 10^6]`. Example: ```python # Initial tree (unbalanced) # 10 # / # 5 20 # # 8 25 # After balancing (example AVL tree) # 10 # / # 8 20 # / / # 5 15 25 bst = BalancedBST() bst.insert(10) bst.insert(5) bst.insert(20) bst.insert(8) bst.insert(25) # Should maintain balance by rebalancing the tree bst.search(8) # returns True bst.size() # returns 5 bst.inorder(bst.get_root()) # prints 5 8 10 20 25 ``` Note: - You are free to choose the balancing technique. However, provide a brief description in your code comments explaining your choice of balancing algorithm.","solution":"# Using AVL Tree balancing technique class AVLTreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class BalancedBST: def insert(self, root, key): if not root: return AVLTreeNode(key) if key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.getHeight(root.left), self.getHeight(root.right)) balance = self.getBalance(root) # Left Left if balance > 1 and key < root.left.key: return self.rightRotate(root) # Right Right if balance < -1 and key > root.right.key: return self.leftRotate(root) # Left Right if balance > 1 and key > root.left.key: root.left = self.leftRotate(root.left) return self.rightRotate(root) # Right Left if balance < -1 and key < root.right.key: root.right = self.rightRotate(root.right) return self.leftRotate(root) return root def delete(self, root, key): # This would be implemented similarly by first performing the normal BST deletion # followed by rebalancing the AVL Tree using the rotation methods as in insert pass def search(self, root, key): if root is None or root.key == key: return root is not None if key < root.key: return self.search(root.left, key) return self.search(root.right, key) def getHeight(self, root): if not root: return 0 return root.height def getBalance(self, root): if not root: return 0 return self.getHeight(root.left) - self.getHeight(root.right) def leftRotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) return y def rightRotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) return y def inorder(self, root): return self._inorder(root) def _inorder(self, root): result = [] if root: result = self._inorder(root.left) result.append(root.key) result = result + self._inorder(root.right) return result def size(self, root): if not root: return 0 return 1 + self.size(root.left) + self.size(root.right) def __init__(self): self.root = None def get_root(self): return self.root def insert_key(self, key): self.root = self.insert(self.root, key) def search_key(self, key): return self.search(self.root, key) def inorder_traversal(self): return self.inorder(self.root) def get_size(self): return self.size(self.root)"},{"question":"Context You are tasked with developing a class to manage a playlist in a music application. Songs need to be added, removed, and accessed efficiently. The playlist should support operations to navigate both forwards and backwards through the list of songs. Due to memory limitations on user devices, the implementation should consider the trade-offs related to memory usage and performance. Objective Implement a **DoublyLinkedList** class, managing songs in your playlist efficiently. Requirements 1. **Node Class**: Implement the `DoublyLinkedListNode` class. 2. **Linked List Class**: Implement the `DoublyLinkedList` class with the following methods: - `insert_at_head(value)`: Insert a song at the start of the playlist. - `insert_at_tail(value)`: Insert a song at the end of the playlist. - `delete_node(value)`: Remove a song from the playlist by value. - `find(value)`: Find and return the node containing a song by value. - `traverse_forward()`: Return list of songs from head to tail. - `traverse_backward()`: Return list of songs from tail to head. Input and Output Format ```python class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): pass def insert_at_tail(self, value): pass def delete_node(self, value): pass def find(self, value): pass def traverse_forward(self): pass def traverse_backward(self): pass ``` Constraints * The playlist can contain a maximum of 10,000 songs. * Each method should handle empty and non-empty states gracefully. Performance Requirements The methods should effectively manage the insertion, deletion, and traversal operations. Aim for O(1) insertion/deletion and traverse in O(n). Edge Cases to Consider: * Inserting into an empty list. * Deleting from an empty list. * Handling non-existent elements during deletion. * Traversing a list with a single element.","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): new_node = DoublyLinkedListNode(value) if self.head is None: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_at_tail(self, value): new_node = DoublyLinkedListNode(value) if self.tail is None: self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete_node(self, value): node = self.find(value) if node is None: return if node.prev: node.prev.next = node.next else: self.head = node.next if node.next: node.next.prev = node.prev else: self.tail = node.prev node.next = node.prev = None def find(self, value): current = self.head while current: if current.value == value: return current current = current.next return None def traverse_forward(self): result = [] current = self.head while current: result.append(current.value) current = current.next return result def traverse_backward(self): result = [] current = self.tail while current: result.append(current.value) current = current.prev return result"},{"question":"# Coding Challenge: Implement Max-Heap and Min-Heap Sorts You are required to implement two sorting algorithms: one based on the max-heap and the other on the min-heap structure. Both algorithms should sort an array of integers in ascending order and include a simulation mode that prints the array at each step. Function Signatures: - `def max_heap_sort(arr, simulation=False):` - `def min_heap_sort(arr, simulation=False):` Inputs: - `arr`: List of integers to sort. - `simulation`: Boolean flag indicating whether to print the array at each step. Outputs: - Should return the sorted list in ascending order. Constraints: - The array length `n` will not exceed 10^5. - The integers in the array will range from `-10^6` to `10^6`. Requirements: 1. **max_heap_sort**: Sort the array using a max-heap. - Include calls to a `max_heapify` function that constructs the max-heap. - If `simulation` is `True`, print the array after each iteration of the heapify and sort steps. 2. **min_heap_sort**: Sort the array using a min-heap. - Include calls to a `min_heapify` function that constructs the min-heap. - If `simulation` is `True`, print the array after each iteration of the heapify and sort steps. Example: For the array `[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]`: - `max_heap_sort(arr)` should return `[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]` - `min_heap_sort(arr)` should return `[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]` Edge Cases: - Empty array (`[]`) should return `[]`. - Array with one element (`[5]`) should return `[5]`.","solution":"def max_heapify(arr, n, i, simulation): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] if simulation: print(arr) max_heapify(arr, n, largest, simulation) def max_heap_sort(arr, simulation=False): n = len(arr) for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i, simulation) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulation: print(arr) max_heapify(arr, i, 0, simulation) return arr def min_heapify(arr, n, i, simulation): smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] < arr[smallest]: smallest = left if right < n and arr[right] < arr[smallest]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] if simulation: print(arr) min_heapify(arr, n, smallest, simulation) def min_heap_sort(arr, simulation=False): n = len(arr) for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i, simulation) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulation: print(arr) min_heapify(arr, i, 0, simulation) arr.reverse() return arr"},{"question":"**Context**: Imagine you are working with a filesystem represented as a binary tree. Each node in the binary tree represents a directory, and each leaf node represents a file. You need to determine all possible absolute paths from the root directory to the files. **Task**: Write a function `find_all_paths(root)` that returns a list of strings, where each string represents an absolute path from the root directory to a leaf file. Each path should be represented in the form \'dir1->dir2->...->file\'. **Function Signature**: ```python def find_all_paths(root: Optional[TreeNode]) -> List[str]: ``` **Input**: - `root` - the root of the binary tree (a node of class `TreeNode`). - The tree nodes are instances of a class `TreeNode` with attributes `val`, `left`, and `right`. **Output**: - A list of strings where each string represents a path from root to leaf. **Constraints**: - The number of nodes in the tree will be in the range [0, 1000]. - The value of each node is a non-negative integer. - The paths should be constructed using \'->\' as the delimiter. **Example**: ```python # Example Node class class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example: # Input: # 1 # / # 2 3 # # 5 # Output: [\\"1->2->5\\", \\"1->3\\"] root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) print(find_all_paths(root)) # Output: [\\"1->2->5\\", \\"1->3\\"] ``` **Notes**: - Make sure to handle all edge cases, including an empty tree. - Ensure your solution is efficient in terms of both time and space.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_all_paths(root: Optional[TreeNode]) -> List[str]: if not root: return [] def dfs(node, path, paths): if not node.left and not node.right: paths.append(path) return if node.left: dfs(node.left, path + \\"->\\" + str(node.left.val), paths) if node.right: dfs(node.right, path + \\"->\\" + str(node.right.val), paths) paths = [] dfs(root, str(root.val), paths) return paths"},{"question":"# Comb Sort Implementation and Extension You have been tasked to implement the **Comb Sort** algorithm as part of a new sorting utility library. The Comb Sort algorithm is designed to improve on the performance of bubble sort by using a gap sequence between compared elements. Task 1. Implement the `comb_sort` function that sorts a given list of integers. 2. Extend your implementation to work efficiently with a specific constraint: - Modify the `comb_sort` function to stop early if the list gets sorted before completing all gap reductions. Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: ``` Input Format - A list of integers `arr` where ( 1 leq text{len(arr)} leq 10^6 ). - Each integer ( arr[i] ) where ( vert arr[i] vert leq 10^6 ). Output Format - Return the sorted list. Constraints - Your algorithm should have a time complexity of at most O(N log N) on average. - You should not use built-in sorting functions. Example ```python assert comb_sort([5, 3, 8, 4, 2]) == [2, 3, 4, 5, 8] assert comb_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert comb_sort([8, 2, 5, 3, 9]) == [2, 3, 5, 8, 9] ``` Performance Constraints - Implement the function to handle edge cases smoothly such as already sorted arrays and arrays with identical elements. Context The provided comb sort implementation works by swapping elements that are far apart and reducing the gap over iterations. When the gap reduces to 1, it functions similarly to a bubble sort. This hybrid strategy often provides better performance than bubble sort for larger datasets.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: def get_next_gap(gap): Calculate the next gap size using the shrink factor 1.3. gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n sorted = False while gap != 1 or not sorted: gap = get_next_gap(gap) # Calculate gap for the current phase sorted = True # Assume the array is sorted for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False # We found an element out of order return arr"},{"question":"**Crout Matrix Decomposition Evaluation** You\'re provided with a function `crout_matrix_decomposition(A)` that performs Crout\'s matrix decomposition on a given square matrix ( A ). Enhance the function to improve its robustness against numerical instability due to zero or near-zero pivot elements. Additionally, implement a method to verify the decomposition by reconstructing the original matrix from ( L ) and ( U ), and compute the error between the reconstructed matrix and ( A ). # Instructions: - **Function Signature**: `def enhanced_crout_matrix_decomposition(A):` - **Input**: ( A ) (a list of lists of floats, representing a ( n times n ) matrix). - **Output**: A tuple ((L, U, error)) where: * ( L ) is the lower triangular matrix. * ( U ) is the upper triangular matrix. * ( error ) is the Frobenius norm of the difference between the reconstructed matrix (from ( L ) and ( U )) and ( A ). # Constraints: - The matrix should be square with ( 1 leq n leq 100 ). - The elements of ( A ) are real numbers. - Handle numerical stability with pivot elements appropriately. # Example: ```python A = [ [1, 2, 3], [3, 4, 5], [6, 7, 8] ] L, U, error = enhanced_crout_matrix_decomposition(A) # L and U should be returned in the appropriate lower and upper triangular forms. # The `error` should be a small value close to 0 indicating the accuracy of the decomposition. ``` # Evaluation Criteria: - Correctness of matrix decomposition. - Numerical stability and error management. - Calculation of reconstruction error. **Note**: Remember to check your results by reconstructing ( A ) from ( L ) and ( U ), then compute the Frobenius norm ( |A - LU| ). Good luck!","solution":"import numpy as np def enhanced_crout_matrix_decomposition(A): Performs Crout\'s matrix decomposition on a given square matrix A with numerical stability enhancements. Returns L, U, and the Frobenius norm of the error from reconstructing A using L and U. A = np.array(A, dtype=np.float64) n = A.shape[0] L = np.zeros((n, n)) U = np.zeros((n, n)) for i in range(n): # Upper Triangular Matrix for k in range(i, n): sum1 = sum(L[i][j] * U[j][k] for j in range(i)) U[i][k] = A[i][k] - sum1 # Lower Triangular Matrix for k in range(i, n): if i == k: L[i][i] = 1.0 else: sum2 = sum(L[k][j] * U[j][i] for j in range(i)) if np.abs(U[i][i]) < 1e-10: # Handle numerical stability raise ValueError(f\\"Near-zero pivot element encountered at index {i}\\") L[k][i] = (A[k][i] - sum2) / U[i][i] # Reconstruct A from L and U A_reconstructed = np.dot(L, U) # Calculate the error using Frobenius norm error = np.linalg.norm(A - A_reconstructed, ord=\'fro\') return L.tolist(), U.tolist(), error"},{"question":"# Diffie-Hellman Key Exchange Implementation Challenge You are tasked with implementing a simplified version of the Diffie-Hellman key exchange algorithm. This exercise will help assess your understanding of modular arithmetic and cryptographic protocols. Problem Statement Implement a function `diffie_hellman_key_exchange(a: int, p: int) -> bool` as well as supporting functions to perform the following steps: 1. **Prime Check**: Verify if ( p ) is a prime number. 2. **Primitive Root Check**: Ensure ( a ) is a primitive root modulo ( p ). 3. **Private Key Generation**: Generate private keys for Alice and Bob within the range (1) to (p-1). 4. **Public Key Computation**: Compute the public keys for both parties using their private keys. 5. **Shared Secret Computation**: Alice and Bob use their private keys and the other\'s public key to derive the shared secret. Return a boolean True if both shared secrets match, otherwise False. Function Definitions ```python def prime_check(num: int) -> bool: Returns True if `num` is a prime number. Else returns False. pass def find_primitive_root(n: int) -> list[int]: Returns all primitive roots of n. pass def diffie_hellman_key_exchange(a: int, p: int) -> bool: Perform the Diffie-Hellman key exchange. Returns True if both shared secrets match, else returns False. pass ``` Constraints - (2 leq p leq 10^9) - (1 leq a < p) - (a) must be a primitive root of ( p ) - (p) must be a prime number Example ```python # Example usage assert diffie_hellman_key_exchange(5, 23) == True ``` Hints - Use helper functions to modular exponentiation, greatest common divisor (GCD), and Euler\'s totient function. - Efficiently generate random numbers for private keys. - Modular arithmetic properties will be crucial.","solution":"import random def prime_check(num: int) -> bool: Returns True if `num` is a prime number. Else returns False. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def gcd(a: int, b: int) -> int: while b != 0: a, b = b, a % b return a def find_primitive_root(n: int) -> list[int]: if n == 2: return [1] phi = n - 1 factors = set() i = 2 while i * i <= phi: if phi % i == 0: factors.add(i) while phi % i == 0: phi //= i i += 1 if phi > 1: factors.add(phi) primitive_roots = [] for r in range(2, n): flag = True for factor in factors: if pow(r, (n - 1) // factor, n) == 1: flag = False break if flag: primitive_roots.append(r) return primitive_roots def diffie_hellman_key_exchange(a: int, p: int) -> bool: Perform the Diffie-Hellman key exchange. Returns True if both shared secrets match, else returns False. if not prime_check(p): raise ValueError(\\"p must be a prime number\\") if a not in find_primitive_root(p): raise ValueError(\\"a must be a primitive root modulo p\\") # Generate private keys alice_private_key = random.randint(1, p-1) bob_private_key = random.randint(1, p-1) # Compute public keys alice_public_key = pow(a, alice_private_key, p) bob_public_key = pow(a, bob_private_key, p) # Compute shared secrets alice_shared_secret = pow(bob_public_key, alice_private_key, p) bob_shared_secret = pow(alice_public_key, bob_private_key, p) return alice_shared_secret == bob_shared_secret"},{"question":"# Question: You are required to implement a Separate Chaining Hash Table with the ability to dynamically resize itself when certain load factors are reached. Requirements: 1. Implement the complete hash table with resizing capability. 2. The hash table should resize (double the size) when the load factor exceeds 0.75 and halve the size when the load factor drops below 0.25. 3. Ensure that all key-value pairs are rehashed correctly during the resizing process. Function Signatures: * `put(self, key, value)`: Insert or update the key-value pair into the hash table. * `get(self, key)`: Retrieve the value associated with the key. * `del_(self, key)`: Remove the key-value pair from the hash table. * `resize(self, new_size)`: Resize the hash table to a new size. Input Format: * Each method will utilize keys and values as given in typical use cases. * The initial size of the hash table is 11 buckets. Output Format: * Return values will be as specified by the function signatures. Example: ```python # Example usage: table = SeparateChainingHashTable() table.put(\'a\', 1) table.put(\'b\', 2) table.put(\'c\', 3) print(table.get(\'a\')) # Output: 1 print(len(table)) # Output: 3 table.del_(\'a\') print(table.get(\'a\')) # Output: None ```","solution":"class SeparateChainingHashTable: def __init__(self): self.initial_size = 11 self.table = [[] for _ in range(self.initial_size)] self.num_elements = 0 def _hash(self, key): return hash(key) % len(self.table) def put(self, key, value): index = self._hash(key) for i, (k, v) in enumerate(self.table[index]): if k == key: self.table[index][i] = (key, value) return self.table[index].append((key, value)) self.num_elements += 1 if self.load_factor() > 0.75: self.resize(len(self.table) * 2) def get(self, key): index = self._hash(key) for k, v in self.table[index]: if k == key: return v return None def del_(self, key): index = self._hash(key) for i, (k, v) in enumerate(self.table[index]): if k == key: del self.table[index][i] self.num_elements -= 1 if self.load_factor() < 0.25 and len(self.table) > self.initial_size: self.resize(len(self.table) // 2) return def resize(self, new_size): old_table = self.table self.table = [[] for _ in range(new_size)] self.num_elements = 0 for bucket in old_table: for k, v in bucket: self.put(k, v) def load_factor(self): return self.num_elements / len(self.table) def __len__(self): return self.num_elements"},{"question":"Given two strings `str1` and `str2`, determine the minimum number of deletions required to make `str1` and `str2` identical. In each step, you can delete one character from either of the strings. Function Signature ```python def min_deletions_to_make_identical(str1: str, str2: str) -> int: ``` Example ``` Input: \\"sea\\", \\"eat\\" Output: 2 Explanation: You need one step to make \\"sea\\" to \\"ea\\" and another step to make \\"eat\\" to \\"ea\\". ``` Requirements 1. **Input Constraints**: - `str1` and `str2` consist of lowercase English letters. - Length of `str1` and `str2` will not exceed 500. 2. **Output**: - Return the minimum number of deletions required. 3. **Performance**: - Aim for a Dynamic Programming approach to ensure efficiency. Hints - Reduce the problem to finding the Longest Common Subsequence (LCS). - Use a 2D array for dynamic programming to store the lengths of the longest common subsequences for subproblems. - The solution involves calculating the lengths and leveraging them to get the minimum deletions. Additional Considerations - Ensure the solution is robust against edge cases (e.g., empty strings). - Provide an optimized solution for large inputs within the constraints.","solution":"def min_deletions_to_make_identical(str1: str, str2: str) -> int: def longest_common_subsequence(s1: str, s2: str) -> int: m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] lcs_length = longest_common_subsequence(str1, str2) return (len(str1) - lcs_length) + (len(str2) - lcs_length)"},{"question":"# Priority Task Scheduler You are a software engineer at a company that handles task scheduling. You are given a collection of tasks and their respective priorities. Implement a priority queue using a linear array where you can add tasks with their priorities and retrieve the tasks with the lowest priority for execution. Function to Implement: ```python class PriorityQueue: # Constructor that initializes the empty queue def __init__(self): pass # Method to add a task with a given priority def push(self, task: str, priority: int) -> None: pass # Method to remove and return the task with the lowest priority def pop(self) -> str: pass # Method to return the size of the priority queue def size(self) -> int: pass # Method to get the current state of the priority queue def __repr__(self): pass ``` Input and Output Formats: - **push(task: str, priority: int)**: Takes in a string task and an integer priority, and inserts the task into the queue based on its priority. - **pop() -> str**: Removes and returns the string task with the lowest priority in the queue. If the queue is empty, it returns \'Queue is empty\'. - **size() -> int**: Returns the integer number of tasks in the queue. - **__repr__() -> str**: Returns the string representation of the tasks in the queue in priority order. Constraints: 1. Priorities are integers where a lower number means higher priority. 2. Tasks are non-empty strings. 3. Assume no two tasks will have the same string value with different priorities. Example: ```python pq = PriorityQueue() pq.push(\\"Task A\\", 2) pq.push(\\"Task B\\", 1) pq.push(\\"Task C\\", 3) print(pq) # Expected Output: \\"PriorityQueue([\'Task C: 3\', \'Task A: 2\', \'Task B: 1\'])\\" print(pq.pop()) # Expected Output: \'Task B\' print(pq.pop()) # Expected Output: \'Task A\' print(pq.size()) # Expected Output: 1 print(pq.pop()) # Expected Output: \'Task C\' print(pq.pop()) # Expected Output: \'Queue is empty\' ``` Implement your solution ensuring efficiency and correctness.","solution":"class PriorityQueue: def __init__(self): self.queue = [] def push(self, task: str, priority: int) -> None: self.queue.append((task, priority)) self.queue.sort(key=lambda x: x[1]) def pop(self) -> str: if not self.queue: return \'Queue is empty\' return self.queue.pop(0)[0] def size(self) -> int: return len(self.queue) def __repr__(self): return \\"PriorityQueue([\\" + \\", \\".join([f\\"\'{task}: {priority}\'\\" for task, priority in self.queue]) + \\"])\\""},{"question":"You are given a list `lst` of integers and a positive integer `N`. Write a function `limit_occurrences(lst, N)` that returns a new list containing each number from `lst` at most `N` times without reordering. Your function should implement the optimized algorithm leveraging dictionaries for efficient tracking of element counts. Aim for a time complexity of O(n) and a space complexity of O(n). # Input Format * `lst`: A list of integers (1 ≤ len(lst) ≤ 10^6). * `N`: A positive integer (1 ≤ N ≤ 10^6). # Output Format * A list of integers satisfying the constraint of no element appearing more than N times. # Examples 1. **Input**: `lst = [1, 2, 3, 1, 2, 1, 2, 3]`, `N = 2` **Output**: `[1, 2, 3, 1, 2, 3]` 2. **Input**: `lst = [1, 1, 1, 1]`, `N = 2` **Output**: `[1, 1]` 3. **Input**: `lst = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2]`, `N = 1` **Output**: `[1, 2, 3]` # Constraints * The function should run efficiently for large input sizes (up to 10^6 elements). # Function Signature ```python def limit_occurrences(lst: list[int], n: int) -> list[int]: # Your implementation here pass ``` To help you get started, we have provided a code snippet showing both a naive and an optimized solution to a similar problem. Please focus on implementing the optimized approach in your solution.","solution":"def limit_occurrences(lst: list[int], N: int) -> list[int]: Returns a new list containing each number from `lst` at most `N` times without reordering. counts = {} result = [] for number in lst: if counts.get(number, 0) < N: result.append(number) counts[number] = counts.get(number, 0) + 1 return result"},{"question":"# Palindrome Permutation Checker You are given a string `s`. Check if any permutation of the string can form a palindrome. Your function should efficiently determine whether any permutation of `s` has the potential to be a palindrome. Input * A string `s`, of length `1 ≤ |s| ≤ 10000`. Output * Return `True` if any permutation of `s` can form a palindrome; otherwise, return `False`. # Function Signature ```python def can_form_palindrome(s: str) -> bool: ... ``` # Example ```python print(can_form_palindrome(\\"aabb\\")) # Output: True (palindrome \\"abba\\", \\"baab\\") print(can_form_palindrome(\\"abc\\")) # Output: False print(can_form_palindrome(\\"carrace\\")) # Output: True (\\"racecar\\", \\"carrace\\") print(can_form_palindrome(\\"x\\")) # Output: True (single character is trivially a palindrome) ``` # Constraints * Ignore spaces and consider only alphanumeric characters. * Function should be case-insensitive. # Explanation * To form a palindrome, at most one character of the string can have an odd count (for the center of odd-length palindromes). All other characters must have even counts since they have to be mirrored around the center. * Use collections to effectively count and evaluate character frequencies for a linear time solution. # Notes * You may assume the input string contains only printable ASCII characters. * Consider the algorithm’s performance for strings close to the upper constraint.","solution":"def can_form_palindrome(s: str) -> bool: from collections import Counter # Normalize the string to ignore spaces and case sensitivity normalized_str = \'\'.join(c.lower() for c in s if c.isalnum()) # Count the frequency of each character freq = Counter(normalized_str) # Check the number of characters that have an odd count odd_count = sum(1 for count in freq.values() if count % 2 == 1) # A string can form a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"**Rabin-Miller Probabilistic Primality Test** Given the algorithm\'s description and complexity, implement the `is_prime` function that uses the Rabin-Miller Primality Test to determine the primality of a given number ( n ). # Function Signature ```python def is_prime(n: int, k: int) -> bool: pass ``` # Input * `n` (integer): The number to be tested for primality. * `k` (integer): The certainty factor. A higher ( k ) increases the test\'s confidence. # Output * (boolean): Returns `True` if ( n ) is probably prime, otherwise `False`. # Constraints * ( n ) will be less than ( 10^{18} ). * ( k ) will be less than ( 100 ). # Performance Requirements * The test should be efficient enough to handle the provided constraints. Your implementation should aim to run within a reasonable time frame for large values of ( n ). # Example ```python assert is_prime(29, 5) == True # 29 is a prime number assert is_prime(15, 5) == False # 15 is not a prime number ``` # Notes * You must consider edge cases such as very small values of ( n ) and ( n ) being even. * Ensure that your implementation makes good use of random witness selection and modular arithmetic to avoid common pitfalls.","solution":"import random def is_prime(n: int, k: int) -> bool: Uses the Rabin-Miller Primality Test to determine if a number n is prime. The certainty factor k determines the accuracy of the test. if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Write n-1 as 2^r * d r, d = 0, n - 1 while d % 2 == 0: d //= 2 r += 1 def miller_rabin_test(a): x = pow(a, d, n) if x == 1 or x == n - 1: return True for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return True return False for _ in range(k): a = random.randrange(2, n - 1) if not miller_rabin_test(a): return False return True"},{"question":"Coding Assessment Question # Scenario You are tasked with developing a utility function for a digital library application that needs to quickly find specific digits within a large sequence of concatenated natural numbers. This functionality is essential for efficiently indexing and data retrieval operations within the application. # Problem Statement Write a function `find_nth_digit(n: int) -> int` that returns the nth digit in the infinite sequence of natural numbers concatenated together (i.e., \\"12345678910111213...\\"). # Input - A single integer `n` (1 ≤ n ≤ 2 * 10^9) representing the position in the sequence. # Output - Return an integer which is the nth digit in the concatenated sequence. # Constraints - The value of `n` represents a position starting from 1. - The function should be optimized for both time and space. # Example ```python def find_nth_digit(n): length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n-1) // length s = str(start) return int(s[(n-1) % length]) # Sample Usage print(find_nth_digit(3)) # Output: 3 print(find_nth_digit(11)) # Output: 0 ``` # Explanation - For `n = 3`, the sequence looks like this: `1, 2, 3, ...` so the 3rd digit is `3`. - For `n = 11`, the sequence is `12345678910...` where the 11th digit is `0`. **Note**: Ensure to handle boundary conditions effectively and optimize using logarithmic insights on the digit ranges to maintain time efficiency within constraints.","solution":"def find_nth_digit(n): Returns the nth digit in the infinite sequence of natural numbers concatenated together. length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"# Run-Length Encoding and Decoding **Problem Statement**: Run-length encoding (RLE) is a simple form of data compression where consecutive duplicates of data elements are replaced by the count of duplicates followed by that single data value. This approach is useful for data that contain many such repetitive elements. You are required to write two functions: `encode_rle` and `decode_rle`. 1. `encode_rle(input_str: str) -> str`: This function should take a string `input_str` and return its run-length encoded form. 2. `decode_rle(encoded_str: str) -> str`: This function should take a run-length encoded string `encoded_str` and return its decoded (original) form. **Function Definitions**: ```python def encode_rle(input_str: str) -> str: pass def decode_rle(encoded_str: str) -> str: pass ``` **Example**: ```python assert encode_rle(\\"aaabbcca\\") == \\"3a2b2c1a\\" assert decode_rle(\\"3a2b2c1a\\") == \\"aaabbcca\\" ``` **Input Constraints**: * The input strings for encoding and decoding will only contain lowercase alphabets. * The length of the strings will not exceed 10^5 characters. **Notes**: * Ensure the encoding function handles edge cases such as an empty input string. * The decoding function should appropriately handle scenarios with erroneous encoded strings (although such encoded strings will not be provided as input in this problem). Write a function that correctly implements the run-length encoding and decoding.","solution":"def encode_rle(input_str: str) -> str: if not input_str: return \\"\\" encoded_str = [] count = 1 for i in range(1, len(input_str)): if input_str[i] == input_str[i - 1]: count += 1 else: encoded_str.append(f\\"{count}{input_str[i - 1]}\\") count = 1 encoded_str.append(f\\"{count}{input_str[-1]}\\") return \'\'.join(encoded_str) def decode_rle(encoded_str: str) -> str: if not encoded_str: return \\"\\" decoded_str = [] count = \\"\\" for char in encoded_str: if char.isdigit(): count += char else: decoded_str.append(char * int(count)) count = \\"\\" return \'\'.join(decoded_str)"},{"question":"You are tasked to write a function `get_histogram_v2` that extends the functionality of the given `get_histogram` function by allowing it to handle a list of integers and provide the histogram in a sorted order by keys. The new function should take a list of integers as input and return a dictionary where keys are the unique integers from the list and values are their respective counts, sorted in ascending order of keys. Input: - A list of integers, `input_list`, where each integer can be positive, negative, or zero. Output: - A dictionary where keys are the unique integers from the list and values are their respective counts, sorted by keys in ascending order. Constraints: - The size of the list `input_list` can be between 0 and 10^5. - Each integer in `input_list` can range from -10^9 to 10^9. Example: ```python input_list_1 = [3, 3, 2, 1] output_1 = get_histogram_v2(input_list_1) # Output: {1: 1, 2: 1, 3: 2} input_list_2 = [2, 3, 5, 5, 5, 6, 4, 3, 7] output_2 = get_histogram_v2(input_list_2) # Output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} input_list_3 = [-2, -3, 5, 5, 5, -6, 4, -3, 7] output_3 = get_histogram_v2(input_list_3) # Output: {-6: 1, -3: 2, -2: 1, 4: 1, 5: 3, 7: 1} input_list_4 = [] output_4 = get_histogram_v2(input_list_4) # Output: {} ``` Write the function `get_histogram_v2` with the specified input and output format.","solution":"def get_histogram_v2(input_list): Returns the histogram of the input list as a sorted dictionary. Args: input_list (list): A list of integers. Returns: dict: A dictionary where keys are unique integers from the list and values are their counts, sorted in ascending order of keys. histogram = {} for num in input_list: if num in histogram: histogram[num] += 1 else: histogram[num] = 1 return dict(sorted(histogram.items()))"},{"question":"# Problem: Implementing Basic BST Operations Scenario You are the lead developer at a systems software company and have been tasked with implementing a Binary Search Tree (BST) class to efficiently manage a dynamic set of integer values. Your class should support insertion, deletion, and searching of nodes, ensuring that the tree maintains BST properties. Task Implement the `BinarySearchTree` class with methods to insert, delete, and search for nodes. Function Signatures 1. `def insert(self, root: TreeNode, val: int) -> TreeNode` 2. `def delete(self, root: TreeNode, val: int) -> TreeNode` 3. `def search(self, root: TreeNode, val: int) -> TreeNode` Input/output Descriptions - **Input**: - `root`: The root node of the BST, or None if it is empty. - `val`: The integer value to be inserted, deleted, or searched. - **Output**: - For `insert` and `delete`: Return the root node of the modified BST. - For `search`: Return the TreeNode containing the searched value, or None if the value is not found. Constraints - The values to be inserted or deleted will be integers within the range -10^4 to 10^4. - Assume no duplicate values will be inserted into the BST. - Each operation (insert, delete, search) should be completed within reasonable time limits for inputs up to 10^5 nodes. Examples ```plaintext # Example 1: BST = BinarySearchTree() root = None root = BST.insert(root, 5) root = BST.insert(root, 3) root = BST.insert(root, 7) assert BST.search(root, 3) is not None # Node with value 3 exists root = BST.delete(root, 3) assert BST.search(root, 3) is None # Node with value 3 should be deleted # Example 2: BST = BinarySearchTree() root = None values_to_insert = [15, 10, 20, 8, 12, 17, 25] for value in values_to_insert: root = BST.insert(root, value) assert BST.search(root, 15) is not None # Node with value 15 exists assert BST.search(root, 9) is None # Node with value 9 does not exist root = BST.delete(root, 15) assert BST.search(root, 15) is None # Node with value 15 should be deleted ``` Requirements - Ensure the BST properties are maintained after each insertion and deletion. - Handle edge cases like inserting into an empty tree, deleting a node which is not present, or searching for a missing value. - Aim for the most efficient implementation possible.","solution":"class TreeNode: def __init__(self, key: int): self.left = None self.right = None self.val = key class BinarySearchTree: def insert(self, root: TreeNode, val: int) -> TreeNode: if root is None: return TreeNode(val) if val < root.val: root.left = self.insert(root.left, val) else: root.right = self.insert(root.right, val) return root def delete(self, root: TreeNode, val: int) -> TreeNode: if root is None: return root if val < root.val: root.left = self.delete(root.left, val) elif val > root.val: root.right = self.delete(root.right, val) else: if root.left is None: return root.right elif root.right is None: return root.left temp = self.min_value_node(root.right) root.val = temp.val root.right = self.delete(root.right, temp.val) return root def search(self, root: TreeNode, val: int) -> TreeNode: if root is None or root.val == val: return root if val < root.val: return self.search(root.left, val) return self.search(root.right, val) def min_value_node(self, node: TreeNode) -> TreeNode: current = node while current.left is not None: current = current.left return current"},{"question":"You are tasked with implementing a function that sorts an array of integers using the Cocktail Shaker Sort algorithm. The function should take as input a list of integers and return the sorted list. The Cocktail Shaker Sort is a mutation of the Bubble Sort, providing bidirectional sorting within the same pass. However, it still retains a worst-case time complexity of O(N^2). # Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` # Input - `arr` (List[int]): A list consisting of `n` integers where `0 <= n <= 10^5`. The integers can be positive, negative, or zero. # Output - Returns a list of integers sorted in ascending order. # Constraints - The function should handle edge cases where the list is empty. - The list can contain duplicates. - Performance requirements are not strict but ensure the implementation handles lists of up to 100,000 elements within acceptable time limits. # Example ```python input: [3, 0, -2, 1, 3, 5, -1, 4] output: [-2, -1, 0, 1, 3, 3, 4, 5] input: [] output: [] input: [1, 2, 3, 4, 5] output: [1, 2, 3, 4, 5] ``` # Notes - Think about edge cases such as empty arrays, arrays with a single element, arrays that are already sorted, and arrays with all duplicate elements. - Optimization is not the primary focus since Cocktail Shaker Sort is not optimal for large datasets.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Cocktail Shaker Sort algorithm. Parameters: arr (List[int]): The list of integers to sort. Returns: List[int]: The sorted list. n = len(arr) if n <= 1: return arr start = 0 end = n - 1 while start <= end: sorted_flag = True # Traverse from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] sorted_flag = False # If no elements were swapped, break the loop if sorted_flag: break # Reset the flag for the next phase sorted_flag = True # Move the end point back by one end -= 1 # Traverse from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] sorted_flag = False # Move the start point forward by one start += 1 return arr"},{"question":"You are working on a software application that requires managing a collection of items using a stack data structure. You already have the two classes `ArrayStack` and `LinkedListStack` implemented, but you need to determine which one is more efficient for a particular scenario. Function Specification Write a method called `minimum_operations_stack` that takes as input a list of operations and decides whether to use `ArrayStack` or `LinkedListStack` to minimize the operations\' cost. Input Format - The function will receive a list of tuples as operations which can either be a push operation with an integer value or a pop operation. - Example: `[(\\"push\\", 10), (\\"push\\", 20), (\\"pop\\",), (\\"push\\", 30), (\\"pop\\",)]`. Output Format - The function should return the type of class to be used, either `\\"ArrayStack\\"` or `\\"LinkedListStack\\"` after simulating the operations given in the input and calculating the minimum cost. Constraints - You may assume the list of operations will have at least one element. - Operations count will not exceed 10^6. - The integer values in push operations will be within the range [1, 10^4]. Performance Requirements - Ensure that the average time complexity remains efficient even for the edge cases containing maximum operations. - Memory utilization should be considered, especially for large lists of operations. # Sample Input ```python input_operations = [(\\"push\\", 10), (\\"push\\", 20), (\\"pop\\",), (\\"push\\", 30), (\\"pop\\",)] ``` # Sample Output ```python \\"LinkedListStack\\" ``` Function Signature ```python def minimum_operations_stack(operations): pass ``` # Notes - The goal is to determine which stack implementation suits the given operations better in terms of efficiency. - The actual implementation of the two stack classes and their methods are provided above.","solution":"class ArrayStack: def __init__(self): self.array = [] def push(self, value): self.array.append(value) def pop(self): if not self.array: return None return self.array.pop() class LinkedListStack: class Node: def __init__(self, value, next_node): self.value = value self.next = next_node def __init__(self): self.head = None def push(self, value): new_node = self.Node(value, self.head) self.head = new_node def pop(self): if self.head is None: return None value = self.head.value self.head = self.head.next return value def minimum_operations_stack(operations): array_stack = ArrayStack() linked_list_stack = LinkedListStack() array_operations_time = 0 linked_list_operations_time = 0 for operation in operations: if operation[0] == \\"push\\": # For push operation value = operation[1] array_operations_time += 1 # O(1) for array append linked_list_operations_time += 1 # O(1) for linked list push array_stack.push(value) linked_list_stack.push(value) elif operation[0] == \\"pop\\": array_operations_time += 1 # O(1) for array pop linked_list_operations_time += 1 # O(1) for linked list pop array_stack.pop() linked_list_stack.pop() if array_operations_time < linked_list_operations_time: return \\"ArrayStack\\" else: return \\"LinkedListStack\\""},{"question":"# Question: Word Pattern Matching **Context**: You are developing a software tool for linguists, which helps in analyzing repeating patterns in written language. One of the functionalities includes checking if a given text follows a certain pattern. **Task**: Write a function `word_pattern(pattern: str, text: str) -> bool` that takes a pattern and a string `text`, and returns `True` if `text` follows the same pattern, otherwise returns `False`. **Input**: - `pattern`: A string containing only lowercase letters. - `text`: A string containing lowercase words separated by a single space. **Output**: - `True`: If `text` follows the pattern (with a bijection). - `False`: Otherwise. **Constraints**: - The pattern and text will contain at most 1000 characters. **Examples**: 1. **Input**: pattern = \\"abba\\", text = \\"dog cat cat dog\\" **Output**: `True` 2. **Input**: pattern = \\"abba\\", text = \\"dog cat cat fish\\" **Output**: `False` 3. **Input**: pattern = \\"aaaa\\", text = \\"dog cat cat dog\\" **Output**: `False` 4. **Input**: pattern = \\"abba\\", text = \\"dog dog dog dog\\" **Output**: `False` 5. **Input**: pattern = \\"abc\\", text = \\"one two one\\" **Output**: `False` **Explanation**: - In the first example, the pattern \\"abba\\" corresponds to \\"dog\\", \\"cat\\", \\"cat\\", \\"dog\\" respectively. - In the second example, \\"dog\\", \\"cat\\", \\"cat\\", \\"fish\\" does not match the given pattern due to the last word. - In the third example, \\"aaaa\\" implies all identical, but \\"dog\\", \\"cat\\" are not identical. - In the fourth example, \\"abba\\" implies two distinct words mapping to \'a\' and \'b\', but \\"dog\\" is repeated. - In the fifth example, the pattern \\"abc\\" requires three distinct words, but \\"one\\" is repeated. Write your function implementation to solve this problem. ```python def word_pattern(pattern: str, text: str) -> bool: pass # Your implementation here ```","solution":"def word_pattern(pattern: str, text: str) -> bool: words = text.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: if word in word_to_char: return False char_to_word[char] = word word_to_char[word] = char return True"},{"question":"Scenario A robot is placed in a 2D plane at the origin (0, 0). The robot can move in four directions: U (up), D (down), L (left), and R (right). Given a string `moves` representing the sequence of the robot\'s moves, determine whether the robot returns to the origin after executing all moves. Task Write a function `does_robot_return_to_origin(moves: str) -> bool` that takes a string of moves and returns `True` if after executing all moves, the robot returns to the start (0, 0), otherwise returns `False`. Input and Output Formats * **Input**: * `moves` - A string consisting only of characters \'U\', \'D\', \'L\', \'R\' (1 <= len(moves) <= 10^4). * **Output**: * A boolean value `True` if the robot returns to the origin, otherwise `False`. Constraints * The sequence will only consist of the valid moves \'U\', \'D\', \'L\', and \'R\'. Example *Example 1*: ``` Input: \\"UD\\" Output: True Explanation: The robot moves up once and down once. It returns to the original position. ``` *Example 2*: ``` Input: \\"LL\\" Output: False Explanation: The robot moves left twice. It does not return to the original position. ``` *Example 3*: ``` Input: \\"UDLR\\" Output: True Explanation: The robot moves up, down, left, and right. It returns to the original position. ```","solution":"def does_robot_return_to_origin(moves: str) -> bool: Returns True if the robot returns to the origin (0, 0) after executing all moves, otherwise False. `moves` consists only of \'U\', \'D\', \'L\', \'R\'. # Initialize position x, y = 0, 0 # Process each move for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 # Check if we are back at the origin return x == 0 and y == 0"},{"question":"# Coding Challenge: Pacific Atlantic Water Flow You are provided with a matrix of non-negative integers representing heights of cells in a continent. The matrix dimensions are m x n. The Pacific ocean touches the left and top edges of the matrix, and the Atlantic ocean touches the right and bottom edges. Water can only flow from a cell to another cell with an equal or lower height. Your task is to find all the matrix coordinates where water can flow to both the Pacific and Atlantic oceans. # Constraints: * The matrix dimensions are such that m, n < 150 * The matrix contains only non-negative integers. # Input: * A 2D list `matrix` of integers representing the height of each unit cell: ```python matrix = [[int]] ``` # Output: * A list of lists `res` of grid coordinates [i, j] where water can flow to both the Pacific and Atlantic oceans: ```python res = [[int, int]] ``` # Example: Given the following 5x5 matrix: ``` 1 2 2 3 5 3 2 3 4 4 2 4 5 3 1 6 7 1 4 5 5 1 1 2 4 ``` Water flows from the cell [0, 4] down to both the Pacific and Atlantic oceans. The expected output for this example would be: ``` [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] ``` # Task: Write a function `pacific_atlantic(matrix)` that solves this problem. You should implement depth-first search (DFS) to achieve this. # Hint: * You can use two boolean matrices to keep track of the cells visited by water flow from the Pacific and Atlantic oceans respectively. * Start DFS from all border cells adjacent to the Pacific and Atlantic and mark cells as reachable. ```python def pacific_atlantic(matrix): :type matrix: List[List[int]] :rtype: List[List[int]] # Your code goes here ```","solution":"def pacific_atlantic(matrix): if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) pacific_reachable = [[False for _ in range(n)] for _ in range(m)] atlantic_reachable = [[False for _ in range(n)] for _ in range(m)] def dfs(matrix, reachable, i, j): reachable[i][j] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for direction in directions: x, y = i + direction[0], j + direction[1] if 0 <= x < m and 0 <= y < n and not reachable[x][y] and matrix[x][y] >= matrix[i][j]: dfs(matrix, reachable, x, y) for i in range(m): dfs(matrix, pacific_reachable, i, 0) dfs(matrix, atlantic_reachable, i, n - 1) for j in range(n): dfs(matrix, pacific_reachable, 0, j) dfs(matrix, atlantic_reachable, m - 1, j) result = [] for i in range(m): for j in range(n): if pacific_reachable[i][j] and atlantic_reachable[i][j]: result.append([i, j]) return result"},{"question":"# Linear Search Optimization Challenge Scenario Imagine you are tasked with searching for specific elements in a large dataset repeatedly. You recognize that a linear search is less efficient with increased data size, prompting the need to search for a more optimal approach. Objective While implementing a complete search optimization might demand complex structures, you’re required to show your understanding of linear search through the following task. Task Design a function that takes an array of integers and another array of search queries. For each query, find the index of its first occurrence in the integer array, similar to the linear search approach. However, to demonstrate understanding and efficiency: 1. Reuse previous results if queries repeat. 2. Optimize edge cases where no element is found quickly. 3. Implement an efficient lookup strategy for the result of a search to avoid redundant searches. # Function Signature ```python def search_in_dataset(data: List[int], queries: List[int]) -> List[int]: :param data: List of integers where the search is to be performed. :param queries: List of integers which need to be searched in the data. :return: List of indices corresponding to each query in the queries array. If an element isn\'t found, return -1 for that query. ``` # Example ```python data = [5, 3, 7, 1, 3, 9, 2] queries = [3, 7, 5, 10] # The results would be: # 3 is first found at index 1. # 7 is found at index 2. # 5 is present at index 0. # 10 is not in the array, hence return -1. assert search_in_dataset(data, queries) == [1, 2, 0, -1] ``` # Constraints - Dataset length (n): 1 <= n <= 10^6 - Queries length (m): 1 <= m <= 10^5 - Elements in data and queries are within the range of signed 32-bit integers. # Requirements - Ensure your implementation is efficient concerning time complexity. - Consider potential optimizations discussed in the analysis. - Handle edge cases as mentioned.","solution":"from typing import List def search_in_dataset(data: List[int], queries: List[int]) -> List[int]: Returns the indices of the first occurrence of each query in the data list. If a query is not found in data, returns -1 for that query. # Cache to store the results of previous queries query_cache = {} result = [] for query in queries: if query in query_cache: result.append(query_cache[query]) else: try: index = data.index(query) except ValueError: index = -1 query_cache[query] = index result.append(index) return result"},{"question":"**Linked List Deduplication** # Context: You\'ve been given the task to help clean up some data. The data, structured as a singly linked list, may contain duplicate values that need to be removed. There are two ways to accomplish this: 1. Using an auxiliary data structure (a set in this context). 2. Without using any additional data structure. # Task: Write a function that removes duplicates from a singly linked list using an algorithm that you think is the most appropriate considering the context. # Function Signature: ```python def remove_duplicates(head: Node) -> Node: # implement your solution here ``` # Input: - `head`: A reference to the head node of the singly linked list, where each node contains: - `val`: The value stored in the node. - `next`: A reference to the next node in the list or `None` if it is the last node. # Output: - The head node of the modified linked list. # Constraints: - The linked list may be empty (i.e., head is None). - The values in the nodes are not necessarily sorted. - You may not use a Python set or dictionary. # Performance Requirements: - Aim for a solution with a good balance between space and time complexity. Justify your choice of the algorithm in comments. # Example: Given the linked list A -> A -> B -> C -> D -> C -> F -> G After removing duplicates, the linked list should be: A -> B -> C -> D -> F -> G # Additional Requirements: - Verify your solution with multiple test cases covering different edge cases like empty lists, lists with all unique elements, and lists with non-consecutive duplicates.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head: Node) -> Node: Remove duplicates from an unsorted singly linked list without using additional data structures. Args: head (Node): The head node of the linked list. Returns: Node: The head node of the modified linked list with duplicates removed. if not head: return head current = head while current: runner = current while runner.next: if runner.next.val == current.val: # Skip the duplicate node runner.next = runner.next.next else: runner = runner.next current = current.next return head"},{"question":"# Task: Optimize Duplicate Removal You are given an array which can contain various types of objects (integers, strings, booleans, etc.) and may have duplicate entries. Your task is to optimize the algorithm to remove duplicates such that each unique value appears only once, while retaining the order of their first appearance. # Function Signature ```python def remove_duplicates(array: list) -> list: pass ``` # Input * `array`: A list containing elements of various types (`int`, `bool`, `str`, etc.). # Output * Returns a list with duplicates removed, retaining the order of first occurrences. # Constraints * Expected to handle arrays with up to 10^5 elements efficiently. # Examples ```python remove_duplicates([1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True]) # Output: [1, 2, 3, 4, \\"hey\\", \\"hello\\"] remove_duplicates([1, 2, 3]) # Output: [1, 2, 3] remove_duplicates([\\"a\\", \\"b\\", \\"a\\", \\"c\\", \\"b\\"]) # Output: [\\"a\\", \\"b\\", \\"c\\"] ``` # Hints * Consider using additional data structures to optimize the performance of the duplicate check.","solution":"def remove_duplicates(array): Removes duplicates from the array, retaining the order of first appearance. seen = set() result = [] for item in array: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"Objective You are asked to implement and compare two algorithms to solve the Set Cover problem. The goal is to understand the trade-offs between exact and approximate approaches. Problem Statement Given a universal set and a collection of its subsets each with an associated cost, your task is to implement two algorithms to find a minimum cost subcollection that covers all elements of the universal set. Algorithms to Implement 1. **Exact Algorithm**: As described using the power set approach. 2. **Greedy Algorithm**: As described using the approximate greedy approach. Function Signatures ```python def optimal_set_cover(universe, subsets, costs): Args: universe (set): Universal set of elements. subsets (dict): Dictionary of subsets where key is a subset name and value is a set of elements. costs (dict): Dictionary where key is a subset name and value is the cost of the subset. Returns: set: The optimal set cover with minimal cost. pass def greedy_set_cover(universe, subsets, costs): Args: universe (set): Universal set of elements. subsets (dict): Dictionary of subsets where key is a subset name and value is a set of elements. costs (dict): Dictionary where key is a subset name and value is the cost of the subset. Returns: set: The greedy set cover with the most optimal coverage based on cost. pass ``` Input & Output * **Input**: - `universe`: A set of n elements `{e1, e2, ..., en}`. - `subsets`: A dictionary where keys are subset identifiers and values are subsets of `universe`. - `costs`: A dictionary mapping each subset identifier to its cost. * **Output**: - A set of subset identifiers that form the minimum cost cover. Example ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} optimal_cover = optimal_set_cover(universe, subsets, costs) # Expected: {\'S2\', \'S3\'} optimal_cost = sum(costs[s] for s in optimal_cover) # Expected: 13 greedy_cover = greedy_set_cover(universe, subsets, costs) # Possible Output: {\'S2\', \'S3\'} greedy_cost = sum(costs[s] for s in greedy_cover) # Possible Output: 13 print(\'Optimal Set Cover:\', optimal_cover) print(\'Cost =\', optimal_cost) print(\'Greedy Set Cover:\', greedy_cover) print(\'Cost =\', greedy_cost) ``` Constraints * Assume all inputs are valid (no empty sets and all subsets are subsets of the universe). * The number of subsets should not exceed 20 for the exact solution due to exponential complexity. * For the greedy solution, assume a large number of subsets can be used.","solution":"from itertools import chain, combinations def optimal_set_cover(universe, subsets, costs): Args: universe (set): Universal set of elements. subsets (dict): Dictionary of subsets where key is a subset name and value is a set of elements. costs (dict): Dictionary where key is a subset name and value is the cost of the subset. Returns: set: The optimal set cover with minimal cost. def all_subsets(subsets): Returns all combinations of subsets (the power set). sets = list(subsets.keys()) return chain.from_iterable(combinations(sets, r) for r in range(len(sets) + 1)) min_cost = float(\'inf\') optimal_cover = None for subset_combination in all_subsets(subsets): combined_set = set(chain.from_iterable(subsets[s] for s in subset_combination)) if combined_set == universe: cost = sum(costs[s] for s in subset_combination) if cost < min_cost: min_cost = cost optimal_cover = subset_combination return set(optimal_cover) def greedy_set_cover(universe, subsets, costs): Args: universe (set): Universal set of elements. subsets (dict): Dictionary of subsets where key is a subset name and value is a set of elements. costs (dict): Dictionary where key is a subset name and value is the cost of the subset. Returns: set: The greedy set cover with the most optimal coverage based on cost. uncovered = universe.copy() cover = set() while uncovered: best_subset = None best_cost_effectiveness = float(\'inf\') for subset, elements in subsets.items(): covered_elements = len(uncovered & elements) if covered_elements > 0: cost_effectiveness = costs[subset] / covered_elements if cost_effectiveness < best_cost_effectiveness: best_cost_effectiveness = cost_effectiveness best_subset = subset cover.add(best_subset) uncovered -= subsets[best_subset] return cover"},{"question":"Count Islands in an MxN Grid You are given a grid with dimensions \'M x N\', initially filled with water. You also have a sequence of operations that add land to specific grid positions. An island is formed by connecting adjacent lands horizontally or vertically. Write a function `count_islands(M: int, N: int, positions: List[Tuple[int, int]]) -> List[int]` that counts the number of islands after each land addition operation and returns a list of island counts. # Function Signature: ```python def count_islands(M: int, N: int, positions: List[Tuple[int, int]]) -> List[int]: ``` # Input: - `M` (1 <= M <= 1000): The number of rows in the grid. - `N` (1 <= N <= 1000): The number of columns in the grid. - `positions` (1 <= len(positions) <= M*N): A list of positions where each position is represented by a tuple of integers `(r, c)` (0 <= r < M, 0 <= c < N). # Output: - A list of integers of length len(positions), where each integer represents the number of islands after each corresponding land addition. # Constraints: - All positions in the `positions` list are guaranteed to be unique within the context of each test case. # Example: **Input:** ```python count_islands(3, 3, [(0, 0), (0, 1), (1, 2), (2, 1)]) ``` **Output:** ```python [1, 1, 2, 3] ``` In this example: 1. After `(0, 0)` is turned to land, grid becomes: ``` 1 0 0 0 0 0 0 0 0 Number of islands = 1 ``` 2. After `(0, 1)` is turned to land, grid becomes: ``` 1 1 0 0 0 0 0 0 0 Number of islands = 1 ``` 3. After `(1, 2)` is turned to land, grid becomes: ``` 1 1 0 0 0 1 0 0 0 Number of islands = 2 ``` 4. After `(2, 1)` is turned to land, grid becomes: ``` 1 1 0 0 0 1 0 1 0 Number of islands = 3 ``` # Note: - Please use the Union-Find data structure to optimize the solution. - Ensure that you handle edge cases properly, such as when merging already connected components or isolated components.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size self.count = 0 # Number of connected components def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def count_islands(M: int, N: int, positions: List[Tuple[int, int]]) -> List[int]: def get_index(r, c): return r * N + c grid = [[0] * N for _ in range(M)] uf = UnionFind(M * N) results = [] directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for pos in positions: r, c = pos index = get_index(r, c) if grid[r][c] == 1: results.append(uf.count) continue grid[r][c] = 1 uf.count += 1 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < M and 0 <= nc < N and grid[nr][nc] == 1: uf.union(index, get_index(nr, nc)) results.append(uf.count) return results"},{"question":"# Counting Sort Algorithm **Scenario**: You have a list of integers where the minimum and maximum values are known. Your task is to sort the list efficiently by implementing the Counting Sort algorithm. **Problem Statement**: Write a function `counting_sort(arr, min_val, max_val)` that sorts an array of integers using the Counting Sort algorithm. The function takes the following parameters: - `arr`: a list of integers to be sorted. - `min_val`: the minimum integer value in the list. - `max_val`: the maximum integer value in the list. **Constraints**: - The range of integers (from `min_val` to `max_val`) is not excessively large relative to the number of elements in the list. - The array can contain negative integers. - You should handle empty arrays gracefully. **Input**: - A list of integers `arr`. - Two integers `min_val` and `max_val` representing the minimum and maximum values in the array respectively. **Output**: - A new list containing the sorted integers. ```python def counting_sort(arr, min_val, max_val): Sorts a list of integers using Counting Sort algorithm. Parameters: arr (list of int): The array to be sorted. min_val (int): The minimum value in the array. max_val (int): The maximum value in the array. Returns: list of int: The sorted array. # Your code here pass ``` **Examples**: ```python assert counting_sort([4, 2, 2, 8, 3, 3, 1], 1, 8) == [1, 2, 2, 3, 3, 4, 8] assert counting_sort([-5, 4, 2, 0, -1, 3, -2], -5, 4) == [-5, -2, -1, 0, 2, 3, 4] assert counting_sort([], 0, 0) == [] assert counting_sort([5], 5, 5) == [5] ``` Remember: - Handle edge cases like empty arrays and arrays containing negative numbers. - Time and space efficiency should be considered for the function implementation.","solution":"def counting_sort(arr, min_val, max_val): Sorts a list of integers using Counting Sort algorithm. Parameters: arr (list of int): The array to be sorted. min_val (int): The minimum value in the array. max_val (int): The maximum value in the array. Returns: list of int: The sorted array. if not arr: return [] # Initialize count array range_size = max_val - min_val + 1 count = [0] * range_size # Store the count of each element in the count array for num in arr: count[num - min_val] += 1 # Build the sorted array sorted_arr = [] for i in range(range_size): sorted_arr.extend([i + min_val] * count[i]) return sorted_arr"},{"question":"# Problem: Enhanced Search in a Matrix Given a `2D` matrix of integers, implement a function to find the position of a given target value. The matrix does not have any particular order, so a linear search through each row is required. The function should return the first encountered (row_index, col_index) pair where the element is found or `(-1, -1)` if the element does not exist in the matrix. Function Signature ```python def matrix_search(matrix: List[List[int]], target: int) -> Tuple[int, int]: pass ``` Input * `matrix`: A list of lists of integers representing the matrix. Each sublist represents a row in the matrix. * `target`: An integer value you need to find in the matrix. Output * Returns a tuple `(row_index, col_index)` representing the first occurrence of the target element in the matrix. * Returns `(-1, -1)` if the element is not found. Constraints * The matrix can have a variable number of rows and columns. * Matrix and target values will be integers. * Optimize for readability and clear logic. Example ```python matrix = [ [10, 20, 30], [40, 50, 60], [70, 80, 90] ] target = 50 # Expected output: (1, 1) since matrix[1][1] == 50 ``` ```python matrix = [ [7, 8, 9], [4, 2, 1], [0, 5, 6] ] target = 10 # Expected output: (-1, -1) since 10 is not in the matrix ``` Note - Your solution should iterate through the matrix in a straightforward manner. - Avoid advanced optimizations and focus on correct implementation. - Consider edge cases such as an empty matrix or the target not being present.","solution":"from typing import List, Tuple def matrix_search(matrix: List[List[int]], target: int) -> Tuple[int, int]: This function searches for a target value in a given 2D matrix and returns the position as a tuple (row_index, col_index). If the target is not found, it returns (-1, -1). for row_index, row in enumerate(matrix): for col_index, value in enumerate(row): if value == target: return (row_index, col_index) return (-1, -1)"},{"question":"# Longest Increasing Subsequence Challenge Scenario You are a software engineer at a company that specializes in data analysis, and you have been tasked with developing a component to find the longest increasing subsequence from various data samples. You need to implement this efficiently given the large size of the datasets. Task Write a function `find_longest_increasing_subsequence` that takes in a list of integers and returns the length of the longest strictly increasing subsequence. # Function Signature ```python def find_longest_increasing_subsequence(arr: list) -> int: pass ``` # Input - A list of integers `arr` where (1 leq text{len(arr)} leq 10^5). - The elements in the array can range from (-10^9) to (10^9). # Output - An integer representing the length of the longest strictly increasing subsequence. # Examples Example 1: ```python input: [10, 9, 2, 5, 3, 7, 101, 18] output: 4 ``` Explanation: The longest increasing subsequence is [2, 3, 7, 101]. Example 2: ```python input: [0, 1, 0, 3, 2, 3] output: 4 ``` Explanation: The longest increasing subsequence is [0, 1, 2, 3]. Example 3: ```python input: [7, 7, 7, 7, 7, 7, 7] output: 1 ``` Explanation: The longest increasing subsequence is any of the [7]s. # Constraints - Performance should be optimal in terms of both time and space. - The function should handle edge cases effectively. # Notes - Consider using dynamic programming approaches combined with appropriate data structures like segment trees for an optimized solution.","solution":"import bisect def find_longest_increasing_subsequence(arr: list) -> int: Returns the length of the longest strictly increasing subsequence. if not arr: return 0 subseq = [] for num in arr: pos = bisect.bisect_left(subseq, num) if pos == len(subseq): subseq.append(num) else: subseq[pos] = num return len(subseq)"},{"question":"# Stooge Sort: Recursive Comparison Algorithm You are tasked with implementing the Stooge Sort algorithm to sort an array of integers. Stooge Sort is a highly inefficient, yet fascinating recursive sorting algorithm. Your objective is to write a function that accepts an integer array and its starting and ending indices, then sorts the array in-place using the Stooge Sort method. Function Signature ```python def stoogesort(arr, l, h): # your code here ``` # Detailed Instructions 1. If the starting index `l` is greater than or equal to the ending index `h`, do nothing. 2. If the element at the starting index is greater than the element at the ending index, swap them. 3. If the length of the subarray represented by the current indices is more than 2: - Find the value of `t`, which is one-third of the length of the subarray. - Recursively sort the first two-thirds of the subarray. - Recursively sort the last two-thirds of the subarray. - Recursively sort the first two-thirds again to confirm the sort order. # Constraints - The input array can contain between 0 and 1000 integers. - Elements of the array are in the range -1000 to 1000. # Input Format - A list `arr` containing integers. - Two integers `l` and `h` representing the starting and ending index of the array to be sorted. # Output Format - The function should modify the list in place, with no explicit return value. # Example - Input: `arr = [5, 3, 2, 6, 4, 1]`, `l = 0`, `h = 5` - Process: Stooge sort these elements. - Output: The array will be sorted in place, resulting in `[1, 2, 3, 4, 5, 6]`. # Additional Notes - You can assume the function will be called such that `l = 0` and `h = len(arr) - 1`. - Illustrate your understanding by implementing the Stooge Sort algorithm properly, considering the edge cases and potential inefficiencies. - You do not need to handle input/output operations; focus on the function implementation.","solution":"def stoogesort(arr, l, h): Sorts an array in-place using the Stooge Sort algorithm. Parameters ---------- arr : list of int The array of integers to be sorted. l : int The starting index of the portion of the array to be sorted. h : int The ending index of the portion of the array to be sorted. if l >= h: return # If the element at the beginning is greater than the element at the end, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the array if h - l + 1 > 2: # Find the value of t, which is one-third of the length of the subarray t = (h - l + 1) // 3 # Recursively sort the first two-thirds of the subarray stoogesort(arr, l, h - t) # Recursively sort the last two-thirds of the subarray stoogesort(arr, l + t, h) # Recursively sort the first two-thirds again to confirm the sort order stoogesort(arr, l, h - t)"},{"question":"# Cosine Similarity and Text Document Similarity Measurement You are given a task to determine the similarity between text documents using cosine similarity. Implement a function `document_similarity` that calculates the cosine similarity between word frequency vectors of two documents. # Function Signature ```python def document_similarity(doc1: str, doc2: str) -> float: pass ``` # Parameters * `doc1`: A string representing the first document. * `doc2`: A string representing the second document. # Output * Returns a float value that indicates the cosine similarity between the two documents. # Constraints * The strings `doc1` and `doc2` will consist of English words separated by spaces. * The documents will contain at least one word and each word will consist of at most 100 characters. # Example Scenario Imagine we have the following documents: ```plaintext doc1 = \\"the quick brown fox jumps over the lazy dog\\" doc2 = \\"the quick brown dog jumps over the fox\\" ``` * Here, you should first convert the documents into word frequency vectors. * Then, compute the cosine similarity between these vectors. # Example Usage ```python similarity = document_similarity( \\"the quick brown fox jumps over the lazy dog\\", \\"the quick brown dog jumps over the fox\\" ) print(similarity) # Expected output: close to 1 ``` # Additional Notes * Use lower case for all words to ensure uniform comparison. * Exclude any non-alphabetic characters to ensure clean word frequency vectors. * Consider common edge cases such as completely disjoint documents and documents containing the exact same words but in different orders.","solution":"import re import math from collections import Counter def document_similarity(doc1: str, doc2: str) -> float: Calculates the cosine similarity between word frequency vectors of two documents. def preprocess(doc): # Convert to lowercase and remove non-alphabetical characters doc = re.sub(r\'[^a-zA-Zs]\', \'\', doc.lower()) # Create a word frequency vector return Counter(doc.split()) # Preprocess documents vec1 = preprocess(doc1) vec2 = preprocess(doc2) # Calculate dot product common_words = set(vec1) & set(vec2) dot_product = sum(vec1[word] * vec2[word] for word in common_words) # Calculate magnitudes mag1 = math.sqrt(sum(count ** 2 for count in vec1.values())) mag2 = math.sqrt(sum(count ** 2 for count in vec2.values())) if mag1 == 0 or mag2 == 0: return 0.0 # Calculate cosine similarity return dot_product / (mag1 * mag2)"},{"question":"# Remove Duplicate Characters from a String # Objective Write a function `delete_reoccurring_characters` that removes duplicate characters from a given string while maintaining the order of their first appearance. # Function Signature ```python def delete_reoccurring_characters(string: str) -> str: ``` # Input * `string` (str): A non-empty string containing any printable characters. # Output * (str): A new string with duplicate characters removed, maintaining the original order of first appearance. # Constraints 1. The input string will have a length between 0 and 10^6. 2. The function should have a time complexity of O(n), where n is the length of the input string. 3. The function should be case sensitive (e.g., \'A\' and \'a\' are considered different characters). # Scenario You have a large text data that needs preprocessing for a text analysis project. Specifically, you want to ensure that within any text snippet, each character only appears once, maintaining the order of their first occurrence. This will help in reducing redundancy and simplifying subsequent analysis steps. # Examples ```python assert delete_reoccurring_characters(\\"abracadabra\\") == \\"abrcd\\" assert delete_reoccurring_characters(\\"google\\") == \\"gole\\" assert delete_reoccurring_characters(\\"AaBbCcDd\\") == \\"AaBbCcDd\\" assert delete_reoccurring_characters(\\"\\") == \\"\\" assert delete_reoccurring_characters(\\"a\\"*1000000) == \\"a\\" ``` # Detailed Requirements 1. Your function needs to efficiently handle large strings up to one million characters. 2. Consider possible optimizations to avoid performance bottlenecks related to string operations. 3. Ensure to handle edge cases like empty strings or strings with only one unique character. Happy coding!","solution":"def delete_reoccurring_characters(string: str) -> str: seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Scenario You have been tasked by a software company to implement an efficient sorting algorithm suitable for parallel processing environments. The company frequently deals with large datasets that require fast and reliable sorting using their high-performance computing clusters. # Coding Task Implement a function called `bitonic_sort_parallel` that sorts an array of integers using the Bitonic Sort algorithm optimized for parallel processing. Your implementation should make use of Python\'s `concurrent.futures` module to parallelize the sorting process. # Function Signature ```python def bitonic_sort_parallel(arr: List[int], reverse: bool = False) -> List[int]: ``` # Input - `arr`: A list of integers to be sorted. The size of the list will always be a power of two. - `reverse`: A boolean flag indicating whether to sort in descending order. By default, it is `False` (ascending order). # Output - A list of sorted integers in either ascending or descending order based on the `reverse` flag. # Constraints - The size of the list `arr` will be ( 2^k ) where ( k ) is a non-negative integer. - You must use parallel processing to optimize the sorting process. # Performance Requirements - Your solution should leverage parallel processing to significantly improve the sorting time compared to a purely sequential implementation. # Example ```python >>> bitonic_sort_parallel([3, 7, 2, 8, 1, 5, 6, 4], reverse=False) [1, 2, 3, 4, 5, 6, 7, 8] >>> bitonic_sort_parallel([3, 7, 2, 8, 1, 5, 6, 4], reverse=True) [8, 7, 6, 5, 4, 3, 2, 1] ``` # Notes - Ensure to handle the base case where the array is of length 1 or less. - Raise a `ValueError` if the size of the input array is not a power of two. - Use Python\'s `concurrent.futures` module to implement parallel processing for sorting.","solution":"from concurrent.futures import ThreadPoolExecutor, as_completed from typing import List def bitonic_merge(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): if (direction == (arr[i] > arr[i + k])): arr[i], arr[i + k] = arr[i + k], arr[i] bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort_recursive(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort_recursive(arr, low, k, True) bitonic_sort_recursive(arr, low + k, k, False) bitonic_merge(arr, low, cnt, direction) def bitonic_sort_parallel(arr: List[int], reverse: bool = False) -> List[int]: n = len(arr) if n & (n - 1) != 0: raise ValueError(\\"Size of the input array must be a power of two\\") executor = ThreadPoolExecutor(max_workers=4) future_to_segment = {executor.submit(bitonic_sort_recursive, arr, 0, n, not reverse): 0} for future in as_completed(future_to_segment): pass executor.shutdown(wait=True) return arr"},{"question":"# Question: Implement Additional Functionality in Binary Search Tree You are provided with a `BST` (Binary Search Tree) class that supports insertion, searching, size calculation, and traversal methods. Your task is to extend this class by implementing additional functionalities: 1. **Find Minimum and Maximum Value**: Methods to find the minimum and maximum value in the BST. 2. **Count Leaf Nodes**: A method to count the number of leaf (nodes without any children) nodes in the BST. 3. **Height of the Tree**: A method to determine the height (the number of edges on the longest path from the root to a leaf) of the tree. Method Signatures ```python class BST(object): # Your previous methods remain unchanged def find_min(self): Returns the minimum value in the BST. pass def find_max(self): Returns the maximum value in the BST. pass def count_leaf_nodes(self): Returns the number of leaf nodes in the BST. pass def height(self): Returns the height of the BST. pass ``` Example Scenario Given the BST created in the provided code with nodes inserted in that order: ``` 10 / 6 15 / / 4 9 12 24 / / 7 20 30 / 18 ``` - `find_min()` should return `4` - `find_max()` should return `30` - `count_leaf_nodes()` should return `5` (nodes `4`, `7`, `12`, `18`, `30`) - `height()` should return `4` Requirements - Implement additional methods as described. - Update the `TestSuite` class to include tests for the new methods. - Consider edge cases, such as an empty tree.","solution":"class BST: class Node: def __init__(self, key): self.key = key self.left = None self.right = None def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = self.Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.key: if node.left is None: node.left = self.Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = self.Node(key) else: self._insert(node.right, key) def find_min(self): if self.root is None: return None current = self.root while current.left is not None: current = current.left return current.key def find_max(self): if self.root is None: return None current = self.root while current.right is not None: current = current.right return current.key def count_leaf_nodes(self): return self._count_leaf_nodes(self.root) def _count_leaf_nodes(self, node): if node is None: return 0 if node.left is None and node.right is None: return 1 return self._count_leaf_nodes(node.left) + self._count_leaf_nodes(node.right) def height(self): return self._height(self.root) def _height(self, node): if node is None: return -1 # Considering height of an empty tree as -1 left_height = self._height(node.left) right_height = self._height(node.right) return 1 + max(left_height, right_height)"},{"question":"# Problem: Enhanced Anagram Checker Objective Write a function `is_anagram` that determines if two strings can be considered anagrams. The input strings may contain: - Uppercase and lowercase English letters. - Whitespace characters that should be ignored. - Special characters that should also be ignored. Input * `s1` (string): First input string. * `s2` (string): Second input string. Output * (boolean): Return `True` if `s1` and `s2` are anagrams after ignoring casing and non-alphabet characters, otherwise return `False`. Constraints * Strings can have a length up to 10^4. Performance Requirements * The solution should optimize for time and space complexity, ideally maintaining O(n) time. Example ```python is_anagram(\\"Astronomer\\", \\"Moon starer\\") # True is_anagram(\\"Hello, World!\\", \\"dlroW ,olleH\\") # True ``` Implementation Rules 1. Ignore casing, ignore whitespace, and ignore non-alphabetic characters. 2. Return `True` if the strings can be rearranged to form each other. Scenario You are building a text analysis tool that includes an anagram checker as one of its features. There’s a need to extend the basic anagram checking logic to handle a broader set of characters and ignore non-alphabetic parts. Your task is to update the anagram checker for this scenario.","solution":"import re def is_anagram(s1, s2): Determines if two given strings are anagrams, ignoring case, whitespace, and non-alphabetic characters. Parameters: s1 (str): The first input string. s2 (str): The second input string. Returns: bool: True if the strings are anagrams, False otherwise. # Create a function to clean and sort the string def clean_string(s): return \'\'.join(sorted(re.findall(r\'[a-z]\', s.lower()))) # Clean and compare both strings return clean_string(s1) == clean_string(s2)"},{"question":"# Path Splitter Function Background: You are working on a file-handling module for a software application that processes various URLs and file paths. As part of the functionality, you need to extract the directory path and file name from given path strings. Your task is to implement a function that can split these path strings appropriately. Task: Implement the function `split_path(path)`, which takes a string `path` as input and returns a list with two elements: 1. The directory path up to but not including the last separator (\'/\'). 2. The file name part after the last separator. Input: * A single string `path` which represents a URL or file path. Output: * A list of two strings `[directory_path, file_name]`. Constraints: * The input string `path` will contain only printable ASCII characters. * The list should contain exactly two elements even if the path does not contain a separator. Performance Requirements: * The function should operate in O(n) time complexity where n is the length of the path string. * The function should use O(n) additional space for storing the output. Examples: ```python assert split_path(\\"https://algorithms/unix/test.py\\") == [\\"https://algorithms/unix\\", \\"test.py\\"] assert split_path(\\"algorithms/unix/test.py\\") == [\\"algorithms/unix\\", \\"test.py\\"] assert split_path(\\"test.py\\") == [\\"\\", \\"test.py\\"] assert split_path(\\"folder/\\") == [\\"folder\\", \\"\\"] ``` # Implementation: Write your `split_path` function in Python to meet the above specifications.","solution":"def split_path(path): Splits the given path into a directory part and a file name part. Parameters: path (str): The path to be split. Returns: list: A list containing the directory part and the file name part. last_sep_index = path.rfind(\'/\') if last_sep_index == -1: return [\\"\\", path] else: directory_path = path[:last_sep_index] file_name = path[last_sep_index + 1:] return [directory_path, file_name]"},{"question":"# Context Antonia is working for a company that requires sorting a list of products based on their prices. She knows that for small lists, some simpler sorting algorithms can work effectively. # Task Implement a function `improved_selection_sort` in Python that sorts a list of integers using an improved version of Selection Sort. This version should stop the algorithm as soon as the array is sorted, and should also handle edge cases appropriately. Function Signature ```python def improved_selection_sort(arr: List[int]) -> List[int]: pass ``` Input The function takes a single parameter: - `arr`: A list of integers (`List[int]`) Output The function should return a list of integers sorted in ascending order (`List[int]`). Constraints - The length of `arr` will be between 0 and 10^4. - Each integer in `arr` will be between -10^6 and 10^6. Requirements - The function should terminate early if the array gets sorted before all passes complete. - You should handle empty arrays and arrays with one element efficiently. # Examples ```python # Example 1 arr = [64, 25, 12, 22, 11] print(improved_selection_sort(arr)) # Output: [11, 12, 22, 25, 64] # Example 2 arr = [29, 10, 14, 37, 13, 1] print(improved_selection_sort(arr)) # Output: [1, 10, 13, 14, 29, 37] # Example 3 arr = [] print(improved_selection_sort(arr)) # Output: [] # Example 4 arr = [2] print(improved_selection_sort(arr)) # Output: [2] ```","solution":"from typing import List def improved_selection_sort(arr: List[int]) -> List[int]: n = len(arr) for i in range(n): min_idx = i for j in range(i + 1, n): if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] # Check if the remainder of the array is already sorted already_sorted = True for k in range(i + 1, n - 1): if arr[k] > arr[k + 1]: already_sorted = False break if already_sorted: break return arr"},{"question":"# Longest Common Substring with Unique Character Constraint Problem Statement: You are given two strings, `s1` and `s2`. The string `s2` contains all distinct characters. Your task is to find the length of the longest substring of `s1` that matches a substring of `s2`. Additionally, you must ensure that your solution adheres to an O(n log n) time complexity requirement. Input Format: - A string `s1` (1 ≤ |s1| ≤ 10^5) consisting of lowercase and/or uppercase English letters. - A string `s2` (1 ≤ |s2| ≤ 10^5) consisting of lowercase and/or uppercase English letters with all unique characters. Output Format: - An integer which is the length of the longest common substring of `s1` that appears as a substring in `s2`. Constraints: - The strings can be very large, thus an efficient solution in terms of time complexity is required. - `s2` contains all unique characters. Examples: Example 1: ``` Input: s1 = \\"abcdefg\\" s2 = \\"xyzabc\\" Output: 3 ``` Explanation: The common substring \\"abc\\" has the maximum length 3. Example 2: ``` Input: s1 = \\"hijklmnop\\" s2 = \\"qrstuv\\" Output: 0 ``` Explanation: No common substring exists. Implementation Requirements: You are required to implement the following function: ```python def longest_common_substring_length(s1, s2): # Write your code here pass ``` Additional Hints: - Consider using a dictionary to map characters to their respective indices in `s2` for efficient look-up. - Ensure you handle special cases, such as non-overlapping characters or empty input strings.","solution":"def longest_common_substring_length(s1, s2): def search(mid): s2_substrings = set() for i in range(len(s2) - mid + 1): s2_substrings.add(s2[i:i+mid]) for j in range(len(s1) - mid + 1): if s1[j:j+mid] in s2_substrings: return True return False left, right = 0, min(len(s1), len(s2)) result = 0 while left <= right: mid = (left + right) // 2 if search(mid): result = mid left = mid + 1 else: right = mid - 1 return result"},{"question":"# Question: Strobogrammatic Number Drill Scenario: A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). For example, the numbers \\"69\\", \\"88\\", and \\"818\\" are strobogrammatic. You are asked to implement a function to check if a given number is strobogrammatic based on a given string representation of the number. Function Specification: Write a function `is_strobogrammatic(num: str) -> bool` that: * Takes a string `num` representing a number. * Returns `True` if the number is strobogrammatic, and `False` otherwise. Input: * A string `num` where `1 <= len(num) <= 10^4`. Output: * A boolean value indicating if the number is strobogrammatic. Constraints: * The input number will only contain digits (\'0\'-\'9\'). Example: ```python assert is_strobogrammatic(\\"69\\") == True assert is_strobogrammatic(\\"88\\") == True assert is_strobogrammatic(\\"962\\") == False assert is_strobogrammatic(\\"0\\") == True ``` Performance Requirement: * The solution should demonstrate a time complexity of O(n) and a space complexity of O(1), with n being the length of the string. Important Considerations: * Carefully handle invalid or edge case inputs. * Ensure that the solution is efficient and handles large inputs within reasonable time and space limits.","solution":"def is_strobogrammatic(num: str) -> bool: Checks if the given number string is strobogrammatic, meaning it looks the same when rotated 180 degrees. strobogrammatic_pairs = {\'0\': \'0\', \'1\': \'1\', \'8\': \'8\', \'6\': \'9\', \'9\': \'6\'} left, right = 0, len(num) - 1 while left <= right: if num[left] not in strobogrammatic_pairs or strobogrammatic_pairs[num[left]] != num[right]: return False left += 1 right -= 1 return True"},{"question":"Word Dictionary Implementation # Problem Statement Design and implement a `WordDictionary` data structure that allows addition and search of words with support for wildcard characters. # Requirements * Implement the `WordDictionary` class with the following methods: 1. **add_word(word: str) -> None**: * Add a word to the data structure. * Example usage: `word_dict.add_word(\\"apple\\")` 2. **search(word: str) -> bool**: * Searches for the word in the data structure. The word may contain the wildcard character `.` which can represent any single letter. * Example usage: `word_dict.search(\\"a.p.e\\")` # Input Constraints * Length of the word will be between 1 and 5000 characters. * Maximum number of words in the dictionary will be 100000. * Words will only contain lowercase letters and `.` wildcard character. # Output Format * The `search` method should return `True` if the word (including wildcards) is found, otherwise `False`. # Example ```python # Example usage: word_dict = WordDictionary() word_dict.add_word(\\"bad\\") word_dict.add_word(\\"dad\\") word_dict.add_word(\\"mad\\") print(word_dict.search(\\"pad\\")) # returns False print(word_dict.search(\\"bad\\")) # returns True print(word_dict.search(\\".ad\\")) # returns True print(word_dict.search(\\"b..\\")) # returns True ``` # Constraints and Performance * Ensure that your methods operate efficiently to handle the maximum constraints. * Pay attention to edge cases like empty string search or large numbers of wildcard search operations. # Submission * Ensure your implementation passes all provided test cases and any additional ones you create. * Write clean, modular code with proper comments and function documentation.","solution":"class WordDictionary: def __init__(self): Initialize the data structure here. self.words = [] def add_word(self, word: str) -> None: Adds a word into the data structure. self.words.append(word) def search(self, word: str) -> bool: Returns if the word is in the data structure. A word could contain the \'.\' character to represent any one letter. return any(self.match(word, w) for w in self.words) def match(self, pattern: str, word: str) -> bool: Helper function to check if a pattern matches a word including wildcards. if len(pattern) != len(word): return False for p, w in zip(pattern, word): if p != \'.\' and p != w: return False return True"},{"question":"# Preorder Traversal Implementation **Context**: You are working on a project that involves handling binary trees. One of the tasks requires you to traverse the tree in a specific order to process or analyze its nodes. The traversal method needed is \\"Preorder Traversal\\". **Problem Statement**: You need to write two functions to perform Preorder Traversal on a binary tree: one iteratively and one recursively. **Function Definitions**: 1. `preorder(root)` - **Input:** `root` - the root node of the binary tree. - **Output:** A list containing the values of nodes traversed in preorder. 2. `preorder_rec(root)` - **Input:** `root` - the root node of the binary tree. - **Output:** A list containing the values of nodes traversed in preorder. **Constraints**: - The number of nodes in the tree is in the range `[0, 10^4]`. - The values of the nodes are in the range `[-10^4, 10^4]`. # Examples: 1. **Example 1**: - **Input**: ```python root = Node(1, left=Node(2), right=Node(3)) ``` - **Output**: ```python preorder(root) # Output: [1, 2, 3] preorder_rec(root) # Output: [1, 2, 3] ``` 2. **Example 2**: - **Input**: ```python root = Node(1, left=Node(2, left=Node(4)), right=Node(3)) ``` - **Output**: ```python preorder(root) # Output: [1, 2, 4, 3] preorder_rec(root) # Output: [1, 2, 4, 3] ``` Write the complete definitions for both functions considering all edge cases and ensuring efficient performance.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def preorder(root): Perform preorder traversal iteratively and return the list of node values. if root is None: return [] stack = [root] result = [] while stack: node = stack.pop() if node: result.append(node.value) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result def preorder_rec(root): Perform preorder traversal recursively and return the list of node values. result = [] def helper(node): if node: result.append(node.value) helper(node.left) helper(node.right) helper(root) return result"},{"question":"# Question: Optimized Kth Smallest Element in an Array using Min-Heap You are given an unsorted array of integers. Your task is to find the k-th smallest element in the array in an optimized manner using a min-heap. # Function Signature: ```python def kth_smallest_element(arr: List[int], k: int) -> int: Find the k-th smallest element in the array using a min-heap. :param arr: List[int] - An unsorted array of integers. :param k: int - The k-th position to find (1-based index). :return: int - The k-th smallest element in the array. ``` # Input * `arr`: A list of integers [a1, a2, ..., an] (1 <= n <= 10^5) * `k`: An integer (1 <= k <= n) # Output * Return the k-th smallest element in the array. # Example ```python assert kth_smallest_element([3, 2, 1, 5, 4], 2) == 2 assert kth_smallest_element([7, 10, 4, 3, 20, 15], 3) == 7 ``` # Constraints * You should minimize the time complexity. * The space complexity should also be considered. * The algorithm should handle large arrays efficiently within the provided constraints. # Notes * You may use the provided `min_heap_sort` and `min_heapify` functions and adapt them to solve the k-th smallest element problem. * A naive solution using an in-built sort method might not be efficient enough for large inputs.","solution":"import heapq from typing import List def kth_smallest_element(arr: List[int], k: int) -> int: Find the k-th smallest element in the array using a min-heap. :param arr: List[int] - An unsorted array of integers. :param k: int - The k-th position to find (1-based index). :return: int - The k-th smallest element in the array. # Create a min-heap from the array heapq.heapify(arr) # Extract the smallest element k times for _ in range(k - 1): heapq.heappop(arr) # The k-th smallest element will be at the root of the heap return heapq.heappop(arr)"},{"question":"# Integer Decomposition Count Context In computational number theory, one common problem is determining how many different ways a positive integer can be decomposed into sums of other positive integers. For instance, the number 4 can be decomposed into sums in five different ways: `4`, `3+1`, `2+2`, `2+1+1`, and `1+1+1+1`. Task Given a positive integer `n`, write a function `count_decompositions(n)` to determine the number of possible decompositions of `n`. Function Signature ```python def count_decompositions(n: int) -> int: ``` Input - `n` (1 <= n <= 100): a positive integer Output - Returns an integer indicating the number of decompositions. Example **Example 1:** ```python assert count_decompositions(4) == 5 ``` **Example 2:** ```python assert count_decompositions(7) == 15 ``` Constraints - Ensure your solution runs efficiently within the time limitations given n can be as large as 100. # Performance Requirements - The solution should have a time complexity of O(n^2). - The space complexity should be O(n^2).","solution":"def count_decompositions(n: int) -> int: # Use dynamic programming to count the partitions dp = [[0] * (n + 1) for _ in range(n + 1)] # Base case: there is one way to decompose 0 (using no parts) for i in range(n + 1): dp[i][0] = 1 # Fill the DP table for i in range(1, n + 1): for j in range(1, n + 1): if j >= i: dp[i][j] = dp[i-1][j] + dp[i][j-i] else: dp[i][j] = dp[i-1][j] return dp[n][n]"},{"question":"# Problem Description You are tasked with implementing the Rabin-Karp algorithm to determine the starting index of the first occurrence of a substring within a larger string. If the substring is not present, the function should return -1. Implement the function `rabin_karp_substring_search` that utilizes a rolling hash mechanism for efficient string matching. # Function Signature ```python def rabin_karp_substring_search(word: str, text: str) -> int: pass ``` # Input * `word` (str): The pattern or substring to search for. It may contain only lowercase alphabetic characters. * `text` (str): The larger text within which to search. It may contain only lowercase alphabetic characters. # Output * Returns the integer index of the first occurrence of the substring `word` within the string `text`. Returns -1 if the substring is not found. # Constraints * The length of `word` and `text` will be between 0 and 10^6. * An empty `word` or `text` should return -1. # Example ```python assert rabin_karp_substring_search(\\"abc\\", \\"ababcabc\\") == 2 assert rabin_karp_substring_search(\\"abc\\", \\"abcabcabc\\") == 0 assert rabin_karp_substring_search(\\"aaa\\", \\"aaaaaa\\") == 0 assert rabin_karp_substring_search(\\"abc\\", \\"aaaaaa\\") == -1 assert rabin_karp_substring_search(\\"\\", \\"\\") == -1 ``` # Notes 1. The hash function should map the \'a\' to 1, \'b\' to 2, and so on for consistency. 2. Consider the rolling hash approach where the hash of the next window is derived from the hash of the current window to minimize re-computation. 3. Keep in mind edge cases, such as when `word` is longer than `text` or when `word` or `text` is an empty string.","solution":"def rabin_karp_substring_search(word: str, text: str) -> int: if not word or not text or len(word) > len(text): return -1 base = 26 prime_mod = 101 word_hash = 0 current_hash = 0 highest_base = 1 for i in range(len(word) - 1): highest_base = (highest_base * base) % prime_mod for i in range(len(word)): word_hash = (word_hash * base + ord(word[i])) % prime_mod current_hash = (current_hash * base + ord(text[i])) % prime_mod for i in range(len(text) - len(word) + 1): if word_hash == current_hash: if text[i:i + len(word)] == word: return i if i < len(text) - len(word): current_hash = (current_hash - ord(text[i]) * highest_base) % prime_mod current_hash = (current_hash * base + ord(text[i + len(word)])) % prime_mod current_hash = (current_hash + prime_mod) % prime_mod return -1"},{"question":"# Question: You are given a binary tree and need to perform certain operations on it concerning the depth and height calculations. Implement the following functions: 1. **min_depth**: This function should take a root node of a binary tree and return the minimum depth (the number of nodes along the shortest path from the root node down to the nearest leaf node). 2. **min_height**: This function should take a root node of a binary tree and return the minimum height (the number of nodes along the shortest path from the root node down to the nearest leaf node, consider it iterative approach). 3. **print_tree**: This function should take a root node of a binary tree and print all its nodes in pre-order traversal (Root-Left-Right). # Function Signatures: ```python from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_depth(root: Optional[TreeNode]) -> int: pass def min_height(root: Optional[TreeNode]) -> int: pass def print_tree(root: Optional[TreeNode]) -> None: pass ``` # Input: - Each function will accept a `root` node of a binary tree. - TreeNode class definition that can be used to create the tree is provided. # Output: - **min_depth**: Returns an integer representing the minimum depth of the tree. - **min_height**: Returns an integer representing the minimum height of the tree. - **print_tree**: Outputs the values of the tree nodes in pre-order traversal. # Constraints: - The number of nodes in the binary tree is within the range `[0, 10^4]`. - Node values are within the range `[-10^4, 10^4]`. # Examples: ```python # Example usage: tree = TreeNode(10) tree.left = TreeNode(12) tree.right = TreeNode(15) tree.left.left = TreeNode(25) tree.right.left = TreeNode(36) assert min_depth(tree) == 3 assert min_height(tree) == 3 print_tree(tree) # Output: # 10 # 12 # 25 # 15 # 36 ``` Make sure to handle edge cases such as an empty tree or skewed trees appropriately.","solution":"from typing import Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_depth(root: Optional[TreeNode]) -> int: if not root: return 0 queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) def min_height(root: Optional[TreeNode]) -> int: return min_depth(root) def print_tree(root: Optional[TreeNode]) -> None: def pre_order(node): if not node: return print(node.val) pre_order(node.left) pre_order(node.right) pre_order(root)"},{"question":"# Scenario You are working on a combinatorial problem related to counting partitions. A partition of a positive integer ( n ) is a way of writing ( n ) as a sum of positive integers. Two sums that differ only in the order of their addends are considered the same partition. You need to calculate the number of such partitions for a given positive integer. # Task Implement a function that determines the number of partitions of a given positive integer. # Function Signature ```python def count_partitions(n: int) -> int: ``` # Input - A single integer ( n ) (1 ≤ ( n ) ≤ 1000): The number for which the partitions are to be counted. # Output - An integer: The number of partitions of ( n ). # Examples Example 1 ```python assert count_partitions(4) == 5 ``` Explanation: There are 5 ways to partition 4: - 4 - 3 + 1 - 2 + 2 - 2 + 1 + 1 - 1 + 1 + 1 + 1 Example 2 ```python assert count_partitions(7) == 15 ``` Explanation: There are 15 ways to partition 7. # Constraints - Ensure your solution is efficient and runs within a reasonable time frame for the upper limit of ( n ).","solution":"def count_partitions(n: int) -> int: Calculate the number of partitions of a given positive integer n. # Initialize a list to store the number of partitions for each value up to n partitions = [0] * (n + 1) partitions[0] = 1 # Base case: There\'s one way to partition 0 # Use the dynamic programming approach to fill the partitions list for num in range(1, n + 1): for i in range(num, n + 1): partitions[i] += partitions[i - num] return partitions[n]"},{"question":"# Coding Problem: Insert Bits in a Binary Number You are given two functions `insert_one_bit` and `insert_mult_bits` that perform bit insertion in a specified binary number. The functions are designed to insert a single bit or multiple bits at specified positions. Your task is to implement and optimize these functions. # Function Definitions * **Function 1: Insert One Bit** ```python def insert_one_bit(num: int, bit: int, i: int) -> int: Inserts a single bit at the specified position in the binary representation of num. Parameters: num (int): The original binary number. bit (int): The bit (either 0 or 1) to insert. i (int): The position at which the bit is to be inserted. Returns: int: The new binary number with the specified bit inserted. pass ``` * **Function 2: Insert Multiple Bits** ```python def insert_mult_bits(num: int, bits: int, length: int, i: int) -> int: Inserts multiple bits at the specified position in the binary representation of num. Parameters: num (int): The original binary number. bits (int): The bits to insert. length (int): The number of bits to insert. i (int): The position at which the bits are to be inserted. Returns: int: The new binary number with the specified bits inserted. pass ``` # Example ```python # Inserting single bit print(insert_one_bit(21, 1, 2)) # Output: 45 print(insert_one_bit(21, 0, 2)) # Output: 41 #Inserting multiple bits print(insert_mult_bits(5, 7, 3, 1)) # Output: 47 print(insert_mult_bits(5, 7, 3, 0)) # Output: 47 print(insert_mult_bits(5, 7, 3, 3)) # Output: 61 ``` # Constraints 1. `num` is a non-negative integer. 2. `bit` is either 0 or 1. 3. `bits` is a non-negative integer and `length` is the number of bits in `bits`. 4. `0 <= i <= number of bits in num`. # Instructions 1. Implement both functions ensuring they handle edge cases. 2. Test your functions with different scenarios. 3. Optimize your code where possible without compromising readability.","solution":"def insert_one_bit(num: int, bit: int, i: int) -> int: Inserts a single bit at the specified position in the binary representation of num. Parameters: num (int): The original binary number. bit (int): The bit (either 0 or 1) to insert. i (int): The position at which the bit is to be inserted. Returns: int: The new binary number with the specified bit inserted. # Create mask for left part and right part left_part = num >> i right_part = num & ((1 << i) - 1) # Insert the bit at the specified position new_num = (left_part << 1 | bit) << i | right_part return new_num def insert_mult_bits(num: int, bits: int, length: int, i: int) -> int: Inserts multiple bits at the specified position in the binary representation of num. Parameters: num (int): The original binary number. bits (int): The bits to insert. length (int): The number of bits to insert. i (int): The position at which the bits are to be inserted. Returns: int: The new binary number with the specified bits inserted. # Create mask for left part and right part left_part = num >> i right_part = num & ((1 << i) - 1) # Insert the bits at the specified position new_num = (left_part << length | bits) << i | right_part return new_num"},{"question":"# Comb Sort Implementation **Objective**: Implement the `comb_sort` function which sorts an array of integers in ascending order using the Comb Sort algorithm. The function should modify the array in place and return it. # Input - A list of integers `arr` where `0 <= len(arr) <= 10^6` and `-10^6 <= arr[i] <= 10^6`. # Output - The function should return the sorted list of integers. # Constraints - The solution should be efficient enough to handle large inputs up to the given constraints. # Example **Input**: ```python arr = [5, 2, 9, 1, 5, 6] ``` **Output**: ```python [1, 2, 5, 5, 6, 9] ``` **Explanation**: The given list is sorted in ascending order using the Comb Sort algorithm. # Additional Information - Consider edge cases such as an empty array or a single-element array. - Ensure to apply the shrink factor correctly to efficiently reduce the gap. **Function Signature**: ```python def comb_sort(arr: list) -> list: # Your code here ```","solution":"def comb_sort(arr): Sorts an array of integers in ascending order using the Comb Sort algorithm. The function modifies the array in place and returns it. def get_next_gap(gap): # Shrink gap by a shrink factor of 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# RSA Encryption/Decryption Implementation As a cryptographic engineer, your task is to extend the existing RSA implementation with features for encryption and decryption of text messages. You are provided with a function to generate RSA keys, but you need to write functions to handle text encryption and decryption. # Requirements: 1. Implement a function `rsa_encrypt_message(message: str, e: int, n: int) -> list[int]` to encrypt a given message using the RSA encryption algorithm. The function should convert each character of the message to its ASCII value and then encrypt it. 2. Implement a function `rsa_decrypt_message(encrypted_message: list[int], d: int, n: int) -> str` to decrypt a list of integers (previously encrypted by `rsa_encrypt_message` function) back to the original message. # Input: * `message`: a string consisting of printable ASCII characters. * `encrypted_message`: a list of integers representing the encrypted message. * `e`: an integer, the public exponent. * `d`: an integer, the private exponent. * `n`: an integer, the modulus. # Output: * `rsa_encrypt_message` should return a list of integers representing the encrypted ASCII values. * `rsa_decrypt_message` should return the original (decrypted) message as a string. # Constraints: * (1 leq e, d, n leq 2^{1024}) * Message contains only printable ASCII characters (from character code 32 to 126). # Example: ```python # Example usage: n, e, d = generate_key(16) message = \\"hello\\" encrypted_message = rsa_encrypt_message(message, e, n) print(encrypted_message) # List of encrypted integers decrypted_message = rsa_decrypt_message(encrypted_message, d, n) print(decrypted_message) # Should print \\"hello\\" ``` # Notes: * Ensure proper conversion between characters and their ASCII values. * Consider edge cases where the message is empty or contains characters at the boundary of the ASCII printable range.","solution":"def rsa_encrypt_message(message, e, n): Encrypts a given message using the RSA encryption algorithm. Args: message (str): The message to be encrypted. e (int): The public exponent. n (int): The modulus. Returns: list[int]: The encrypted message as a list of integers. # Convert each character to its ASCII value and then encrypt it encrypted_message = [(ord(char) ** e) % n for char in message] return encrypted_message def rsa_decrypt_message(encrypted_message, d, n): Decrypts a given list of integers using the RSA encryption algorithm. Args: encrypted_message (list[int]): The encrypted message as a list of integers. d (int): The private exponent. n (int): The modulus. Returns: str: The original decrypted message. # Decrypt each value and convert it back to a character decrypted_message = \'\'.join([chr((value ** d) % n) for value in encrypted_message]) return decrypted_message"},{"question":"# Scenario You have been appointed as a software engineer at a text-processing company. One of your tasks is to efficiently find patterns in large chunks of text data. You have decided to implement the Knuth-Morris-Pratt (KMP) algorithm, which you know is efficient for this purpose. # Problem Write a function `knuth_morris_pratt_search(text: str, pattern: str) -> List[int]` that takes two strings: `text` and `pattern`, and returns a list of starting indices where the `pattern` is found in the `text`. While coding your solution, pay attention to: 1. Building the prefix table correctly to avoid unnecessary comparisons. 2. Efficiently handling potential edge cases. Function Signature ```python from typing import List def knuth_morris_pratt_search(text: str, pattern: str) -> List[int]: pass ``` Input * `text` (str): The string in which to search for the pattern. Will have at most length 10^6. * `pattern` (str): The string pattern to search for. Will have at most length 10^5. Output * A list of indices (integers) where the pattern starts in the text. If the pattern does not exist in the text, the list should be empty. Constraints * Both `text` and `pattern` are non-empty strings. * Time complexity of the solution should be O(N + M), where N is the length of `text` and M is the length of `pattern`. # Example ```python print(knuth_morris_pratt_search(\\"abcabcabc\\", \\"abc\\")) # Expected output: [0, 3, 6] print(knuth_morris_pratt_search(\\"aaaaa\\", \\"aa\\")) # Expected output: [0, 1, 2, 3] print(knuth_morris_pratt_search(\\"hello there hero!\\", \\"he\\")) # Expected output: [0, 7, 12] ```","solution":"from typing import List def knuth_morris_pratt_search(text: str, pattern: str) -> List[int]: Implements the KMP search algorithm to find all occurrences of the pattern in the text. def build_prefix_table(pattern: str) -> List[int]: Builds the prefix table (also known as the failure function) for the pattern. m = len(pattern) prefix_table = [0] * m j = 0 for i in range(1, m): while (j > 0 and pattern[i] != pattern[j]): j = prefix_table[j - 1] if pattern[i] == pattern[j]: j += 1 prefix_table[i] = j else: prefix_table[i] = 0 return prefix_table n = len(text) m = len(pattern) if m == 0: return [] prefix_table = build_prefix_table(pattern) result = [] j = 0 for i in range(n): while (j > 0 and text[i] != pattern[j]): j = prefix_table[j - 1] if text[i] == pattern[j]: j += 1 if j == m: result.append(i - m + 1) j = prefix_table[j - 1] return result"},{"question":"**Find the Single Number** **Problem Statement**: You are given an array of integers `nums` where every element appears exactly three times, except for one element which appears exactly once. Find and return the single element that does not appear three times. Your algorithm should run in linear runtime complexity and use only constant extra space. **Function Signature**: ```python def find_single_number(nums: List[int]) -> int: ``` **Input**: - `nums`: A list of integers where every integer except one appears exactly three times. **Output**: - An integer which is the single number appearing only once. **Constraints**: - The length of `nums` will be in the range [1, 3 * 10^4]. - `-2^31 <= nums[i] <= 2^31 - 1` - Guarantee that there is only one integer that appears exactly once. **Example**: ```python # Example 1 input: nums = [2, 2, 3, 2] output : 3 # Example 2 input: nums = [0, 1, 0, 1, 0, 1, 99] output: 99 ``` **Explanation**: In example 1, the number 3 appears exactly once while the number 2 appears exactly three times, so we return 3. In example 2, the number 99 appears exactly once while the numbers 0 and 1 each appear three times, so 99 is returned.","solution":"from typing import List def find_single_number(nums: List[int]) -> int: This function finds the single number in an array where every element appears exactly three times except for one element which appears exactly once. # Initialize variables to store bits ones, twos = 0, 0 for num in nums: # Add num to \'twos\' if it\'s already present in \'ones\' twos |= ones & num # XOR num with \'ones\' ones ^= num # Mask to determine bits that are set in both \'ones\' and \'twos\' common_mask = ones & twos # Remove common_mask bits from \'ones\' and \'twos\' ones &= ~common_mask twos &= ~common_mask return ones"},{"question":"# Question: Implement a Robust Cocktail Shaker Sort with Early Termination You are tasked with implementing an optimized version of the Cocktail Shaker Sort algorithm. Your implementation should handle edge cases carefully, ensure early termination if no swaps are detected, and perform efficiently within given constraints. Function Signature ```python def optimized_cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` Input * `arr` (List[int]): A list of integers to sort. The list may be empty or contain duplicate elements. Output * (List[int]): A sorted list in ascending order based on the input. Constraints * The number of elements (N) in `arr` will be between 0 and 10^4. * Each element in `arr` will be an integer within the range from -10^6 to 10^6. Performance Aim to minimize unnecessary comparisons and iterations to improve efficiency, particularly for nearly sorted or small lists. Example ```python # Example 1 print(optimized_cocktail_shaker_sort([3, 0, 2, 5, -1, 4, 1])) # Output: [-1, 0, 1, 2, 3, 4, 5] # Example 2 print(optimized_cocktail_shaker_sort([5, 3, 8, 6, 7, 2])) # Output: [2, 3, 5, 6, 7, 8] # Example 3 print(optimized_cocktail_shaker_sort([])) # Output: [] # Example 4 print(optimized_cocktail_shaker_sort([1,1,1])) # Output: [1, 1, 1] ``` Notes 1. Handle edge cases such as an empty list or a list with a single element. 2. Optimize for early termination if the list is already sorted. 3. Avoid unnecessary comparisons to enhance performance for nearly sorted data.","solution":"from typing import List def optimized_cocktail_shaker_sort(arr: List[int]) -> List[int]: Performs an optimized cocktail shaker sort on the input list, with early termination if no swaps are detected. :param arr: List of integers to sort. :return: Sorted list in ascending order. if not arr: return arr n = len(arr) start = 0 end = n - 1 swapped = True while swapped: swapped = False # Traverse the list from left to right similar to bubble sort for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If no elements were swapped, the list is sorted if not swapped: break swapped = False end = end - 1 # Traverse the list from right to left for i in range(end - 1, start - 1, -1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True start = start + 1 return arr"},{"question":"# Rabin-Karp Algorithm Improvement You are given a text and a pattern as input. Your goal is to find all the starting indices of the pattern in the text using an optimized version of the Rabin-Karp algorithm. You need to handle potential hash collisions effectively and improve the algorithm to support cases with a broader range of characters (not limited to \'a\' to \'z\'). Write a function `rabin_karp_improved(pattern: str, text: str) -> List[int]` that returns a list of all starting indices where the pattern is found in the text. Ensure your code handles edge cases like empty strings and handles characters beyond \'a\' to \'z\'. **Constraints:** - The pattern and text strings can include uppercase letters, lowercase letters, digits, and special characters. - If either the text or pattern is an empty string, return an empty list. - You must ensure the time complexity remains efficient (O(n + m)) in average cases. **Input and Output:** - **Input**: Two strings, `pattern` and `text`. - **Output**: A list of integers representing the starting indices of the pattern in the text. **Example:** ```python assert rabin_karp_improved(\\"abc\\", \\"abcabcabc\\") == [0, 3, 6] assert rabin_karp_improved(\\"a\\", \\"aaaaa\\") == [0, 1, 2, 3, 4] assert rabin_karp_improved(\\"\\", \\"abc\\") == [] assert rabin_karp_improved(\\"abc\\", \\"\\") == [] assert rabin_karp_improved(\\"x\\", \\"abc\\") == [] ``` **Hints:** - Consider using a rolling hash function with a larger base and modulo to handle a more extensive set of characters. - Use modular arithmetic to prevent integer overflow and keep hash values manageable.","solution":"def rabin_karp_improved(pattern: str, text: str): Optimized Rabin-Karp algorithm to find all the starting indices of the pattern in the text. Handles broader ranges of characters and potential hash collisions. if not pattern or not text or len(pattern) > len(text): return [] base = 256 mod = 101 m, n = len(pattern), len(text) pattern_hash = 0 text_hash = 0 h = 1 for i in range(m-1): h = (h * base) % mod for i in range(m): pattern_hash = (base * pattern_hash + ord(pattern[i])) % mod text_hash = (base * text_hash + ord(text[i])) % mod result = [] for i in range(n - m + 1): if pattern_hash == text_hash: if text[i:i+m] == pattern: result.append(i) if i < n - m: text_hash = (text_hash - ord(text[i]) * h) * base + ord(text[i + m]) text_hash = text_hash % mod if text_hash < 0: text_hash += mod return result"},{"question":"# Coding Challenge: Enhanced Word Search **Context**: You are given a 2D board of characters and a list of words. The challenge is to find all words from the list that can be constructed on the board by moving sequentially in adjacent cells (horizontally or vertically). The same cell may not be used more than once in a word. **Instructions**: Implement a function `findWords(board: List[List[str]], words: List[str]) -> List[str]` that takes in the 2D character board and the list of words, returning a list of all valid words found in the board. **Function Signature**: ```python def findWords(board: List[List[str]], words: List[str]) -> List[str]: # Your code here ``` **Input**: * `board`: List[List[str]] - A 2D list of characters where `1 <= len(board), len(board[0]) <= 12`. * `words`: List[str] - A list of words where `1 <= len(words) <= 3 * 10^4`. **Output**: * Returns a list of strings representing all words found, sorted in lexicographical order. **Example**: ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"] assert sorted(findWords(board, words)) == sorted([\\"eat\\",\\"oath\\"]) ``` **Constraints**: 1. You may reference each cell for each word at most once. 2. Words should not repeat in the result. **Notes**: * Optimize for efficiency. * Consider both time and space complexity. * Handle all possible edge cases, such as empty boards or word lists.","solution":"from typing import List def findWords(board: List[List[str]], words: List[str]) -> List[str]: def build_trie(): trie = {} for word in words: node = trie for char in word: node = node.setdefault(char, {}) node[\'#\'] = word return trie def dfs(board, node, x, y, result): char = board[x][y] curr_node = node[char] word_match = curr_node.pop(\'#\', False) if word_match: result.add(word_match) board[x][y] = \'@\' for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)): nx, ny = x + dx, y + dy if 0 <= nx < len(board) and 0 <= ny < len(board[0]) and board[nx][ny] in curr_node: dfs(board, curr_node, nx, ny, result) board[x][y] = char if not curr_node: node.pop(char) trie = build_trie() result = set() for i in range(len(board)): for j in range(len(board[0])): if board[i][j] in trie: dfs(board, trie, i, j, result) return sorted(result)"},{"question":"# Summary of Multiple Ranges in Sorted Integer Array **Scenario**: You are given a responsibility to design a logging summary for a sorted collection of integer data points typically collected from network packets over time sequences. The data points are collected in a sorted format without any duplicates, and your task is to provide a summary of the ranges, compactly representing the continuous sequences. **Problem Statement**: Write a function `summarize_ranges` that computes the summary ranges from a given sorted array of integers and returns a list of string representations of these ranges. **Function Signature**: ```python def summarize_ranges(array: List[int]) -> List[str]: pass ``` # Input: * `array` (List[int]): A sorted list of integers without duplicates. # Output: * List[str]: A list of strings, where each string represents a range in the format \\"start-end\\" for continuous sequences or just \\"start\\" if the range contains only a single element. # Constraints: * The length of the array `0 <= len(array) <= 10^4`. * All elements in the array are distinct integers and are sorted in non-decreasing order. # Example: ```python assert summarize_ranges([0, 1, 2, 4, 5, 7]) == [\\"0-2\\", \\"4-5\\", \\"7\\"] assert summarize_ranges([1, 3, 7, 8, 9, 15]) == [\\"1\\", \\"3\\", \\"7-9\\", \\"15\\"] assert summarize_ranges([]) == [] assert summarize_ranges([-3, -2, -1, 0, 1, 2, 4, 5, 7, 9, 10, 11, 12]) == [\\"-3-2\\", \\"4-5\\", \\"7\\", \\"9-12\\"] ``` # Additional Guidelines: * Ensure your function handles edge cases such as empty arrays and single-element arrays correctly. * Optimize for both clarity and efficiency. Consider the readability of your output format. * Do not assume the input is always valid, handle potential invalid inputs gracefully.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: Computes the summary ranges from a given sorted array of integers and returns a list of string representations of these ranges. if not array: return [] ranges = [] start = array[0] for i in range(1, len(array)): # If the current element is not consecutive if array[i] != array[i - 1] + 1: if start == array[i - 1]: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{array[i - 1]}\\") start = array[i] # Add the last range if start == array[-1]: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{array[-1]}\\") return ranges"},{"question":"You have been tasked with implementing a function that generates all unique permutations of a list of numbers that might contain duplicates. The goal is to write a function `unique_permutations(nums: List[int]) -> List[List[int]]` that returns all possible unique permutations of the input list. # Input and Output Formats * **Input**: - A list of integers `nums` where `1 <= len(nums) <= 8` and `-10 <= nums[i] <= 10`. * **Output**: - A list of lists, each containing a unique permutation of `nums`. # Constraints and Requirements * The function should handle lists containing duplicates efficiently without generating and then filtering duplicates. * The order of permutations in the output list does not matter. * Performance is crucial; ensure your solution is optimized for time and space. # Example Given the input: ```python nums = [1, 1, 2] ``` The expected output should be: ```python [ [1, 1, 2], [1, 2, 1], [2, 1, 1] ] ``` # Scenario Imagine you are developing a program that can schedule tasks in all possible unique ways. Given a list of task IDs, some of which might be duplicates, implement the function to find all unique sequences in which these tasks can be executed. # Edge Cases to Consider 1. Empty input list should return `[[]]`. 2. Input list with only unique elements, such as `[1, 2, 3]`. 3. Input list with all identical elements, such as `[2, 2, 2]`. Implement your solution in the function stub below: ```python from typing import List def unique_permutations(nums: List[int]) -> List[List[int]]: # Your code here pass ```","solution":"from typing import List from collections import Counter def unique_permutations(nums: List[int]) -> List[List[int]]: def backtrack(comb, counter): if len(comb) == n: results.append(list(comb)) return for num in counter: if counter[num] > 0: comb.append(num) counter[num] -= 1 backtrack(comb, counter) comb.pop() counter[num] += 1 results = [] n = len(nums) counter = Counter(nums) backtrack([], counter) return results"},{"question":"# Scenario and Context You are working as a software developer and one of your tasks involves optimizing linked list operations. In particular, you are tasked with ensuring that delete operations within a singly linked list are performed efficiently, as they are frequently required in a real-time application your company maintains. # Problem Statement Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. The function should modify the linked list in place and handle the potential issue of deleting the last node gracefully by raising an appropriate error. # Function Signature ```python def delete_node(node: \'Node\') -> None: ``` # Input * `node` (Node): The node to be deleted. It is guaranteed to be a valid node in a singly linked list that is not the tail. # Output * None, the linked list should be modified in place. # Constraints * The node to be deleted is neither the tail nor `None`. * The input type is properly constructed `Node`. # Example Example 1: Given the linked list: `1 -> 2 -> 3 -> 4` and the node `3`. After calling `delete_node(node)`, the linked list should be: `1 -> 2 -> 4`. # Performance Requirements The solution should run in constant time O(1). # Testing Your solution will be tested with a unit test similar to the following one: ```python import unittest class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node): if node is None or node.next is None: raise ValueError node.val = node.next.val node.next = node.next.next class TestSuite(unittest.TestCase): def test_delete_node(self): head = Node(1) curr = head for i in range(2, 6): curr.next = Node(i) curr = curr.next node3 = head.next.next delete_node(node3) curr = head self.assertEqual(1, curr.val) curr = curr.next self.assertEqual(2, curr.val) curr = curr.next self.assertEqual(4, curr.val) curr = curr.next self.assertEqual(5, curr.val) tail = curr self.assertIsNone(tail.next) self.assertRaises(ValueError, delete_node, tail) self.assertRaises(ValueError, delete_node, tail.next) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node: \'Node\') -> None: Deletes a node (except the tail) in a singly linked list, given only access to that node. if node is None or node.next is None: raise ValueError(\\"Cannot delete the tail node or a non-existent node.\\") node.val = node.next.val node.next = node.next.next"},{"question":"You are given a binary tree and a target sum. Your task is to write a function that determines if the tree has a root-to-leaf path in which the sum of all the node values equals the target sum. You need to implement this using an iterative Depth-First Search (DFS) approach. # Constraints: 1. The input tree can be empty. 2. Node values can be negative. 3. The function signature should be: ```python def has_path_sum_dfs_iter(root, target_sum): ``` 4. You are not allowed to use recursion. # Input: - `root`: The root node of the binary tree. You may assume a `TreeNode` class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - `target_sum`: An integer representing the target sum. # Output: - Return `True` if such a path exists, otherwise return `False`. # Example: ```python # Example tree: # 5 # / # 4 8 # / / # 11 13 4 # / # 7 2 1 root = TreeNode(5) root.left = TreeNode(4) root.right = TreeNode(8) root.left.left = TreeNode(11) root.left.left.left = TreeNode(7) root.left.left.right = TreeNode(2) root.right.left = TreeNode(13) root.right.right = TreeNode(4) root.right.right.right = TreeNode(1) target_sum = 22 print(has_path_sum_dfs_iter(root, target_sum)) # Output: True ``` # Note: - Your implementation should avoid recursion. - Carefully manage memory to handle large and deeply nested trees. - Consider edge cases like empty trees and trees with only a single node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum_dfs_iter(root, target_sum): if not root: return False stack = [(root, root.val)] while stack: current, val = stack.pop() # Check if it\'s a leaf node and the path sum equals target_sum if not current.left and not current.right and val == target_sum: return True # If there\'s a left child, add it to the stack with updated sum if current.left: stack.append((current.left, val + current.left.val)) # If there\'s a right child, add it to the stack with updated sum if current.right: stack.append((current.right, val + current.right.val)) return False"},{"question":"# Bit Manipulation Challenge Scenario: In many low-level system programming or algorithm challenges, it might be necessary to manipulate the binary representation of numbers to achieve desired results. One such operation involves inserting specific bits at specified positions. In this challenge, you are tasked with modifying the provided functions to handle more complex bit manipulation scenarios. Your goal is to implement the function `insert_and_shift_bits`, which should insert multiple bits at a specified position and shift the original bits accordingly. Function Signature: ```python def insert_and_shift_bits(num: int, bits: int, bits_length: int, pos: int) -> int: This function inserts a sequence of bits into the number at the specified position. :param num: The original integer number. :param bits: The binary sequence (given as an integer) to insert. :param bits_length: The length of the bit sequence to insert. :param pos: The position at which to insert the new bits. :return: The modified number after insertion. ``` Input: * `num` (int): The initial number (in its decimal form). * `bits` (int): The bits to be inserted (also in its decimal form). * `bits_length` (int): The length of `bits` in binary. * `pos` (int): The position at which to insert the bits (0-indexed from the right). Output: * An integer representing the new number after inserting the given bits at the specified position. Constraints: * Avoid using any in-built Python functions for direct binary manipulation. * Consider various edge cases, including inserting at the beginning or the end of the number, and accounting for overflow beyond typical integer ranges. Example: ```python # Example 1: # num = 21 (10101 in binary) # bits = 7 (111 in binary) # bits_length = 3 (111 has 3 bits) # pos = 2 # The function should insert the bits \'111\' starting at position 2. # The resulting binary would be 10111101, which is 189 in decimal. # insert_and_shift_bits(21, 7, 3, 2) should return 189. # Example 2: # num = 5 (101 in binary) # bits = 3 (11 in binary) # bits_length = 2 (bits contains 2 bits) # pos = 1 # The function should insert the bits \'11\' starting at position 1. # The resulting binary would be 10111, which is 23 in decimal. # insert_and_shift_bits(5, 3, 2, 1) should return 23. ```","solution":"def insert_and_shift_bits(num: int, bits: int, bits_length: int, pos: int) -> int: Inserts a sequence of bits into the number at the specified position and shifts the original bits accordingly. :param num: The original integer number. :param bits: The binary sequence (given as an integer) to insert. :param bits_length: The length of the bit sequence to insert. :param pos: The position at which to insert the new bits. :return: The modified number after insertion. # Create a mask to get the upper parts of the number. upper_mask = ~((1 << pos) - 1) upper_bits = num & upper_mask # Create mask to get the lower parts of the number. lower_mask = (1 << pos) - 1 lower_bits = num & lower_mask # Shift the upper bits left by bits_length to make space for the new bits. upper_bits_shifted = upper_bits << bits_length # Combine all components to form the new number. result = (upper_bits_shifted | (bits << pos) | lower_bits) return result"},{"question":"# Minimum Depth of Binary Tree Given the root of a binary tree, implement a function to find the minimum depth of the tree. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Function Signature ```python def minDepth(root: TreeNode) -> int: :param root: TreeNode, the root of the binary tree. :return: int, the minimum depth of the binary tree. ``` Input * `root`: The root node of a binary tree. Output * Return an integer representing the minimum depth of the binary tree. Constraints * The number of nodes in the tree is in the range `[0, 10^4]`. * `-1000 <= Node.val <= 1000` Example ```python # Example 1 # Given the following tree [3,9,20,None,None,15,7]: # 3 # / # 9 20 # / # 15 7 # The minimum depth is 2, since the shortest path to a leaf node is: # 3 -> 20 -> 15 or 3 -> 20 -> 7 root = TreeNode( 3, left=TreeNode(9), right=TreeNode(20, TreeNode(15), TreeNode(7)) ) print(minDepth(root)) # Output: 2 # Example 2 # Given the following tree [2,None,3,None,4,None,5,None,6]: # 2 # # 3 # # 4 # # 5 # # 6 # The minimum depth is 5, as the only path is from root to the rightmost leaf node. root = TreeNode( 2, right=TreeNode(3, right=TreeNode(4, right=TreeNode(5, right=TreeNode(6)))) ) print(minDepth(root)) # Output: 5 ``` Performance Requirements The solution should be optimal for a maximum of 10,000 nodes. Notes Consider edge cases, including an empty tree and highly unbalanced trees, ensuring your solution is efficient and robust.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def minDepth(root: TreeNode) -> int: Returns the minimum depth of the binary tree. :param root: TreeNode, the root of the binary tree. :return: int, the minimum depth of the binary tree. if not root: return 0 from collections import deque queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return 0 # Should never be reached due to the tree being non-empty."},{"question":"Problem Statement You are asked to implement an in-place version of the Merge Sort algorithm. Given an array of integers, you need to sort the array in ascending order using a divide-and-conquer strategy and merge the subarrays without using additional space for temporary arrays in the merging step. Function Signature ```python def in_place_merge_sort(arr: List[int]) -> List[int]: Sorts the input list of integers in ascending order using in-place merge sort. Parameters: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list. def in_place_merge(left: List[int], right: List[int], arr: List[int]) -> None: Merges two sorted subarrays in place into the original array. Parameters: left (List[int]): The left sorted subarray. right (List[int]): The right sorted subarray. arr (List[int]): The original array to store the merged sorted elements. pass ``` Input and Output * **Input**: A list of integers. * **Output**: The same list of integers, sorted in ascending order. Constraints * **Constraints**: * You cannot use extra space for temporary arrays during the merge process. * You are allowed to declare variables for pointers and counters only. Example ```python input_array = [38, 27, 43, 3, 9, 82, 10] sorted_array = in_place_merge_sort(input_array) print(sorted_array) # Output: [3, 9, 10, 27, 38, 43, 82] ``` Notes * Consider edge cases like an empty array, arrays with one element, and arrays with duplicate values while implementing your solution. * Ensure that the algorithm runs efficiently with an O(n log n) time complexity. * Modify the provided `merge_sort` and `merge` functions to achieve in-place merging.","solution":"from typing import List def in_place_merge_sort(arr: List[int]) -> List[int]: if len(arr) > 1: mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] in_place_merge_sort(left_half) in_place_merge_sort(right_half) # Merge the left and right halves in place i = j = k = 0 # Copy data to temp arrays L[] and R[] while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 # Checking if any element was left while i < len(left_half): arr[k] = left_half[i] i += 1 k += 1 while j < len(right_half): arr[k] = right_half[j] j += 1 k += 1 return arr"},{"question":"You are given a list of words and a list of symbols. Your task is to write a function `highlight_symbols` that takes these lists as input and outputs the words with the longest matching symbols surrounded by square brackets. If no symbol matches a word, the word should be left unchanged. # Input * `words`: List of strings. E.g., `[\'Amazon\', \'Microsoft\', \'Google\']` * `symbols`: List of strings. E.g., `[\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\']` # Output * A list of strings where each word has the longest matching symbol surrounded by square brackets. If a word does not contain any symbols, it should remain unchanged. # Constraints * The lengths of the `words` and `symbols` lists will not exceed 10,000. * Individual word and symbol lengths will not exceed 100 characters. * Symbols are case-sensitive. # Example Input: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] ``` Output: ```python [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Implementation Develop your solution using efficient algorithms and data structures to ensure optimal performance: * **Edge Cases**: Handle scenarios where words have no matching symbols. * **Performance Requirements**: Aim for an optimized solution with less-than-quadratic time complexity, ideally exploiting Tree or Trie data structures for efficient substring matching. ```python def highlight_symbols(words, symbols): class TreeNode: def __init__(self): self.children = {} self.symbol = None # Building the Trie/Tree from the symbols root = TreeNode() for symbol in symbols: node = root for char in symbol: if char not in node.children: node.children[char] = TreeNode() node = node.children[char] node.symbol = symbol def find_longest_match(word): node = root longest_match = None match_len = 0 for i in range(len(word)): curr = node j = i while j < len(word) and word[j] in curr.children: curr = curr.children[word[j]] if curr.symbol: if (j - i + 1) > match_len: longest_match = (i, j + 1, curr.symbol) match_len = j - i + 1 j += 1 return longest_match result = [] for word in words: match = find_longest_match(word) if match: start, end, symbol = match result.append(f\\"{word[:start]}[{symbol}]{word[end:]}\\") else: result.append(word) return result # Example Usage words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] print(highlight_symbols(words, symbols)) # Output should be: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ```","solution":"def highlight_symbols(words, symbols): class TreeNode: def __init__(self): self.children = {} self.symbol = None # Building the Trie/Tree from the symbols root = TreeNode() for symbol in symbols: node = root for char in symbol: if char not in node.children: node.children[char] = TreeNode() node = node.children[char] node.symbol = symbol def find_longest_match(word): node = root longest_match = None match_len = 0 for i in range(len(word)): curr = node j = i while j < len(word) and word[j] in curr.children: curr = curr.children[word[j]] if curr.symbol: if (j - i + 1) > match_len: longest_match = (i, j + 1, curr.symbol) match_len = j - i + 1 j += 1 return longest_match result = [] for word in words: match = find_longest_match(word) if match: start, end, symbol = match result.append(f\\"{word[:start]}[{symbol}]{word[end:]}\\") else: result.append(word) return result"},{"question":"**Scenario**: You are hired by a software company to solve a problem where two departments manage their project stages through linked lists. Each department\'s project stages are represented by a singly linked list where each node signifies a different stage. However, due to some collaborations, both lists might share a common subset of stages. Your task is to identify the first shared project stage, if any. **Problem Statement**: Write a function `get_intersection_node(headA: Node, headB: Node) -> Optional[Node]:`, which takes the heads of two singly linked lists and returns the node at which the two lists intersect. If the two linked lists have no intersection, return `None`. **Function Signature**: ```python def get_intersection_node(headA: Node, headB: Node) -> Optional[Node]: pass ``` * **Input**: - `headA`, `headB`: The heads of the two singly linked lists. * **Output**: - The node at which the intersection begins or `None`. **Constraints**: - Both linked lists are non-cyclic and their lengths are not known. - A linked list node is defined as: ```python class Node: def __init__(self, x): self.val = x self.next = None ``` - The `val` does not uniquely identify a node; comparisons must be based on node addresses. **Performance Requirements**: - Aim to achieve O(n + m) time complexity and O(1) space complexity. # Example You are given the following linked lists: ``` List A: 1 -> 3 -> 5 7 -> 9 -> 11 / List B: 2 -> 4 -> 6 ``` For this example, the function should return the node with the value 7. **Write your code below:** ```python class Node: def __init__(self, x): self.val = x self.next = None def get_intersection_node(headA: Node, headB: Node) -> Optional[Node]: # Implementation goes here pass ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def get_intersection_node(headA: Node, headB: Node) -> Node: if not headA or not headB: return None # Get the lengths of both linked lists def get_length(head): length = 0 current = head while current: length += 1 current = current.next return length lenA = get_length(headA) lenB = get_length(headB) # Align the start of the two linked lists curA, curB = headA, headB if lenA > lenB: for _ in range(lenA - lenB): curA = curA.next else: for _ in range(lenB - lenA): curB = curB.next # Move both pointers until we find the intersection or reach the end while curA and curB: if curA == curB: return curA curA = curA.next curB = curB.next return None"},{"question":"# Bitonic Sort Implementation and Extension You have been provided with an implementation of the Bitonic Sort algorithm. This algorithm is specially designed to work well with parallel processing and can handle sorting arrays in both increasing and decreasing order. However, it comes with some constraints and peculiarities, primarily the requirement for the array size to be a power of two. Task Write a Python function `bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]` that: 1. Sorts the input list `arr` using the Bitonic Sort algorithm. 2. Handles arrays of any size (not just powers of two) by extending them to the next power of two. Requirements 1. **Input**: * `arr` - List of integers to be sorted. * `reverse` - Boolean flag indicating the sorting order. If `True`, sort in ascending order; otherwise, sort in descending order. 2. **Output**: * A list of integers sorted based on the specified order. 3. **Constraints**: * Original array elements should be sorted correctly even if padding was needed. Implementation Details 1. Extend the input array to the next power of two if necessary using `inf` for ascending or `-inf` for descending order. 2. Call the provided bitonic sort algorithm to sort the extended array. 3. Return the sorted results without the padding elements. Example ```python input_array = [3, 1, 4, 1, 5, 9, 2] sorted_array = bitonic_sort(input_array, reverse=True) print(sorted_array) # Output should be: [1, 1, 2, 3, 4, 5, 9] ``` Hints: 1. Use the bitonic_sort function provided and focus on preprocessing the input to fit its constraints. 2. `math.ceil(math.log2(n))` can help determine the next power of two for a given size `n`.","solution":"from typing import List import math def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: def compare_and_swap(arr, i, j, dire): if dire == (arr[i] > arr[j]): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr, low, cnt, dire): if cnt > 1: k = cnt // 2 for i in range(low, low + k): compare_and_swap(arr, i, i + k, dire) bitonic_merge(arr, low, k, dire) bitonic_merge(arr, low + k, k, dire) def bitonic_sort_helper(arr, low, cnt, dire): if cnt > 1: k = cnt // 2 bitonic_sort_helper(arr, low, k, True) bitonic_sort_helper(arr, low + k, k, False) bitonic_merge(arr, low, cnt, dire) n = len(arr) if n == 0: return arr next_power_of_two = 1 << (n-1).bit_length() fake_inf = float(\'inf\') if not reverse else float(\'-inf\') padding = [fake_inf] * (next_power_of_two - n) padded_arr = arr + padding bitonic_sort_helper(padded_arr, 0, next_power_of_two, not reverse) sorted_arr = [x for x in padded_arr if x != fake_inf] return sorted_arr"},{"question":"# Meeting Attendance Checker You are developing a scheduling application to manage meeting times seamlessly. One of the features requires determining if a person can attend all of their scheduled meetings without any overlaps. Your task is to write a function `can_attend_meetings(intervals)` that takes a list of meeting intervals and returns a boolean value indicating whether a person can attend all meetings. # Input - An array of intervals `intervals`, where each interval is represented as a list of two integers `[start, end]` (with `start < end`). # Output - Return `True` if the person can attend all meetings, otherwise return `False`. # Constraints - The intervals are given as a list of lists. - The intervals may not be sorted. - Each interval is a valid time range with `0 <= start < end`. # Examples Example 1: Input: `[[0, 30], [5, 10], [15, 20]]` Output: `False` Explanation: Since meeting [0, 30] overlaps with [5, 10], it is not possible to attend all meetings. Example 2: Input: `[[7, 10], [2, 4]]` Output: `True` Explanation: The meetings [7, 10] and [2, 4] do not overlap with each other. # Additional Notes Consider potential edge cases where the list might be empty or contains intervals of the same time frame. Ensure your implementation handles these scenarios appropriately.","solution":"def can_attend_meetings(intervals): Determines if a person can attend all meetings without overlaps. Args: intervals (List[List[int]]): List of meeting time intervals [start, end]. Returns: bool: True if the person can attend all meetings, False otherwise. # Sort the intervals based on the start time intervals.sort(key=lambda x: x[0]) for i in range(1, len(intervals)): # Compare the current interval\'s start time with the previous interval\'s end time if intervals[i][0] < intervals[i-1][1]: return False return True"},{"question":"# Question: Implement and Analyze a Modified Caesar Cipher You are tasked with implementing a modified version of the Caesar cipher that can handle both encryption and decryption. Given a shift value `k` and a mode (`encrypt` or `decrypt`), your function should perform the appropriate operation on the given input string `s`. Function Signature ```python def modified_caesar_cipher(s: str, k: int, mode: str) -> str: Encrypts or decrypts the input string `s` using a Caesar cipher with shift `k`. :param s: The input string to be encrypted or decrypted. :param k: The shift value for the Caesar cipher. :param mode: Operation mode, either \'encrypt\' for encryption or \'decrypt\' for decryption. :return: The result string after encryption or decryption. ``` Input * `s` (string): The string to be encrypted or decrypted, containing letters and possibly other characters. * `k` (integer): The shift value for the Caesar cipher. Can be positive or negative. * `mode` (string): The operation mode, can be either \'encrypt\' or \'decrypt\'. Output * Return the resulting string after applying the Caesar cipher based on the specified mode. Constraints * 1 <= len(s) <= 10^5 * `0 <= |k| <= 100` Examples ```python assert modified_caesar_cipher(\\"abc\\", 3, \\"encrypt\\") == \\"def\\" assert modified_caesar_cipher(\\"def\\", 3, \\"decrypt\\") == \\"abc\\" assert modified_caesar_cipher(\\"xyz\\", 3, \\"encrypt\\") == \\"abc\\" assert modified_caesar_cipher(\\"abc\\", -3, \\"encrypt\\") == \\"xyz\\" assert modified_caesar_cipher(\\"nopqrstuvwxyz\\", 13, \\"encrypt\\") == \\"abcdefghijklm\\" assert modified_caesar_cipher(\\"nopqrstuvwxyz\\", 13, \\"decrypt\\") == \\"abcdefghijklm\\" ``` Notes * Ensure your function correctly wraps around the alphabet for both lowercase and uppercase letters. * Non-alphabetic characters should remain unchanged in the result. * Describe any edge cases your implementation considers and how they are handled.","solution":"def modified_caesar_cipher(s: str, k: int, mode: str) -> str: Encrypts or decrypts the input string `s` using a Caesar cipher with shift `k`. :param s: The input string to be encrypted or decrypted. :param k: The shift value for the Caesar cipher. :param mode: Operation mode, either \'encrypt\' for encryption or \'decrypt\' for decryption. :return: The result string after encryption or decryption. if mode not in [\'encrypt\', \'decrypt\']: raise ValueError(\\"Mode must be either \'encrypt\' or \'decrypt\'\\") if mode == \'decrypt\': k = -k result = [] for char in s: if char.isalpha(): a = ord(\'a\') if char.islower() else ord(\'A\') shifted_index = (ord(char) - a + k) % 26 result.append(chr(shifted_index + a)) else: result.append(char) return \'\'.join(result)"},{"question":"# Question You have been tasked to implement a modified version of the Comb Sort algorithm to address its performance issues by introducing a hybrid mechanism that reverts to Insertion Sort when the gap size shrinks below a certain threshold. This should improve the efficiency of sorting nearly sorted smaller subarrays. # Task Implement a function that performs a hybrid Comb Sort and Insertion Sort. Your function should: 1. Perform Comb Sort until the gap size reduced below a given threshold. 2. Switch to Insertion Sort to complete the sorting process once the gap is smaller than the threshold. # Function Signature ```python def hybrid_comb_sort(arr: List[int], threshold: int) -> List[int]: # your implementation here ``` # Input * **arr**: List of integers to be sorted. (1 <= len(arr) <= 10^5) * **threshold**: An integer representing the gap threshold below which the algorithm should switch to Insertion Sort. (threshold >= 1) # Output * **Return**: A list of integers sorted in non-decreasing order. # Constraints * The given list may contain repeated numbers. * The function should aim to achieve better performance than Comb Sort alone. * Do not use Python\'s built-in sort methods. # Example ```python assert hybrid_comb_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], 3) == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] assert hybrid_comb_sort([10, 2, -5, 3, 7, 8], 1) == [-5, 2, 3, 7, 8, 10] ``` # Notes * Consider the performance implications of switching to Insertion Sort, which has a time complexity of O(N^2) but works well on nearly sorted arrays. * Properly handle edge cases such as very small arrays where threshold becomes irrelevant.","solution":"def hybrid_comb_sort(arr, threshold): Perform a hybrid sorting algorithm that uses Comb Sort until the gap size is smaller than the threshold, then switches to Insertion Sort. Parameters: arr (List[int]): List of integers to be sorted. threshold (int): The gap threshold below which the algorithm should switch to Insertion Sort. Returns: List[int]: The sorted list in non-decreasing order. def comb_sort(arr, threshold): gap = len(arr) shrink = 1.3 sorted = False while gap > threshold or not sorted: gap = int(gap / shrink) if gap < 1: gap = 1 sorted = True for i in range(len(arr) - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False return arr def insertion_sort(arr): for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr arr = comb_sort(arr, threshold) arr = insertion_sort(arr) return arr"},{"question":"Context: You are part of a team developing a scheduling system where tasks have dependencies (i.e., one task must be completed before another can start). This system can be represented using a directed graph, where each task is a node and each dependency is a directed edge from the prerequisite task to the dependent task. Task: Implement a function, `find_all_paths(graph, start_node_name, end_node_name)`, that finds all possible paths in the directed graph from a given start node to a given end node. Function Signature: ```python def find_all_paths(graph: DirectedGraph, start_node_name: str, end_node_name: str) -> List[List[str]]: pass ``` Input: - `graph`: An instance of the `DirectedGraph` class. - `start_node_name`: The name of the starting node as a string. - `end_node_name`: The name of the ending node as a string. Output: - A list of lists, where each inner list represents a path from `start_node_name` to `end_node_name` by the names of the nodes (in the order they are visited). Constraints: - Each node name is unique. - The graph may be disconnected. - There may exist cycles in the graph. - Paths should not revisit nodes in the same path. Example: ```python # Graph definition: graph_data = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'D\'], \'D\': [\'E\'], \'E\': [] } graph = DirectedGraph(graph_data) # Find all paths from node \'A\' to node \'D\' result = find_all_paths(graph, \'A\', \'D\') print(result) # Expected output: [[\'A\', \'B\', \'D\'], [\'A\', \'C\', \'D\']] ``` Notes: - The function should use depth-first search (DFS) to explore all potential paths. - Ensure to handle cases where no path exists gracefully by returning an empty list.","solution":"from typing import List, Dict class DirectedGraph: def __init__(self, adjacency_list: Dict[str, List[str]]): self.adjacency_list = adjacency_list def find_all_paths(graph: DirectedGraph, start_node_name: str, end_node_name: str) -> List[List[str]]: def dfs(current_node, path): if current_node == end_node_name: paths.append(path[:]) return for neighbor in graph.adjacency_list.get(current_node, []): if neighbor not in path: # avoid cycles by ensuring we don\'t revisit nodes in the current path path.append(neighbor) dfs(neighbor, path) path.pop() paths = [] dfs(start_node_name, [start_node_name]) return paths"},{"question":"# Coding Challenge: Implement Extended Resizable Hash Table with Quadratic Probing Scenario You are enhancing an existing hash table implementation to improve its collision resolution strategy and incorporate more robust error handling. Specifically, you will be implementing quadratic probing for collision resolution and adding a method to handle hash table shrinkage when the number of elements falls below a threshold. This is crucial for efficiently managing memory usage and maintaining performance. Task Implement an extended version of the `ResizableHashTable` provided above with the following requirements: 1. **Quadratic Probing**: Replace linear probing with quadratic probing for collision resolution. 2. **Auto-Shrink**: Add functionality to shrink the hash table size by half when the number of elements <= 1/4 of the table size. The table should never shrink below the `MIN_SIZE`. 3. **Methods to Implement**: - Implement `put` with quadratic probing. - Implement resizing logic to handle both growth and shrinkage with `__resize`. Constraints - The hash table should handle integer keys. - Keys and values are limited to integers. - Avoid using Python\'s built-in dictionaries. - Ensure methods handle edge cases such as collisions and deletion properly. Input & Output - Implement a class `EnhancedHashTable` with the following methods: - `put(key: int, value: int) -> None`: Inserts the key-value pair. - `get(key: int) -> Union[int, None]`: Retrieves the value associated with the key. - `del_(key: int) -> None`: Deletes the key-value pair. - `len() -> int`: Returns the number of elements. - Use quadratic probing `hash_ = (hash(key) + step**2) % size` for collision resolution. Performance Requirements - Ensure average-case time complexity of O(1) for insertion, deletion, and retrieval operations. - Efficient resizing logic for O(n) time complexity during resizes. Example ```python hash_table = EnhancedHashTable() hash_table.put(1, \'A\') hash_table.put(2, \'B\') print(hash_table.get(1)) # Output: \'A\' print(hash_table.get(2)) # Output: \'B\' hash_table.del_(1) print(hash_table.get(1)) # Output: None print(len(hash_table)) # Output: 1 ```","solution":"class EnhancedHashTable: MIN_SIZE = 8 def __init__(self): self._size = self.MIN_SIZE self._count = 0 self._table = [None] * self._size def _hash(self, key): return key % self._size def _quadratic_probe(self, hash_, step): return (hash_ + step ** 2) % self._size def _resize(self, new_size): old_table = self._table self._size = new_size self._table = [None] * self._size self._count = 0 for item in old_table: if item is not None: self.put(item[0], item[1]) def put(self, key, value): if self._count >= self._size // 2: self._resize(self._size * 2) hash_ = self._hash(key) step = 0 while self._table[hash_] is not None and self._table[hash_][0] != key: step += 1 hash_ = self._quadratic_probe(hash_, step) if self._table[hash_] is None: self._count += 1 self._table[hash_] = (key, value) def get(self, key): hash_ = self._hash(key) step = 0 while self._table[hash_] is not None: if self._table[hash_][0] == key: return self._table[hash_][1] step += 1 hash_ = self._quadratic_probe(hash_, step) return None def del_(self, key): hash_ = self._hash(key) step = 0 while self._table[hash_] is not None: if self._table[hash_][0] == key: self._table[hash_] = None self._count -= 1 break step += 1 hash_ = self._quadratic_probe(hash_, step) if self._count <= self._size // 4 and self._size // 2 >= self.MIN_SIZE: self._resize(self._size // 2) def len(self): return self._count"},{"question":"# Pangram Check Enhancement **Context**: A pangram is a sentence that contains every letter of the alphabet at least once. This is important in fields like cryptography where completeness and unit tests for full character representation are essential. Your task is to write a function that not only confirms if a given string is a pangram but also lists which letters (if any) are missing from the string. This enhancement requires proper handling of different cases, avoid redundant checks, and optimizes performance. **Function Signature**: ```python def pangram_check(enhanced_input: str) -> (bool, list): :param enhanced_input: A string that needs to be checked :return: tuple (a boolean indicating if it is a pangram, a list of missing characters if any or an empty list) ``` **Input**: * `enhanced_input` (string): The string to check, containing printable ASCII characters. The length of the string is between 0 and 100,000. **Output**: * A tuple where the first element is a Boolean indicating if the provided string is a pangram and the second element is a list containing the alphabet characters that are missing from the input string (empty if the input is a pangram). The list of missing characters should be in alphabetical order. **Example**: ```python pangram_check(\\"The quick brown fox jumps over the lazy dog\\") # Returns: (True, []) pangram_check(\\"The quick brown fox jumps over the lazy\\") # Returns: (False, [\'d\', \'g\']) ``` **Constraints**: * The function should handle both uppercase and lowercase input equivalently. * Performance should be optimized for long strings.","solution":"def pangram_check(enhanced_input: str) -> (bool, list): import string alphabet_set = set(string.ascii_lowercase) input_set = set(enhanced_input.lower()) missing_characters = sorted(list(alphabet_set - input_set)) return (len(missing_characters) == 0, missing_characters)"},{"question":"You are provided a class implementation of a Fenwick Tree (also known as a Binary Indexed Tree) that allows for efficient prefix sum queries and updates on an array. You are tasked to extend this class with additional functionality to support range sum queries. Function to Implement In the `Fenwick_Tree` class, implement the method `range_sum`. This method should take two indices, `left` and `right`, and return the sum of elements in the array from index `left` to index `right` (inclusive). ```python def range_sum(self, bit_tree, left, right): Returns the sum of elements from index left to index right inclusive. :param bit_tree: The constructed binary indexed tree. :param left: Left index of the range (inclusive). :param right: Right index of the range (inclusive). :return: The sum of elements from index left to right. pass ``` Example ```python arr = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3] fenwick_tree = Fenwick_Tree(arr) bit_tree = fenwick_tree.construct() # Range sum from index 3 to 8 will be (6 + 5 + 4 + -3 + 3 + 7) = 22 print(fenwick_tree.range_sum(bit_tree, 3, 8)) # Output: 22 ``` Constraints & Notes 1. The indices, `left` and `right`, will be valid (0 <= left <= right < n). 2. Ensure the time complexity of the `range_sum` function remains efficient, leveraging the underlying Fenwick Tree structure. 3. You do not need to handle input/output, nor constructors - focus only on implementing the specified function.","solution":"class Fenwick_Tree: def __init__(self, arr): self.n = len(arr) self.arr = arr def construct(self): bit_tree = [0] * (self.n + 1) for i in range(self.n): self._update_internal(bit_tree, i, self.arr[i]) return bit_tree def _update_internal(self, bit_tree, index, value): index += 1 while index <= self.n: bit_tree[index] += value index += index & -index def _prefix_sum(self, bit_tree, index): sum = 0 index += 1 while index > 0: sum += bit_tree[index] index -= index & -index return sum def range_sum(self, bit_tree, left, right): Returns the sum of elements from index left to index right inclusive. :param bit_tree: The constructed binary indexed tree. :param left: Left index of the range (inclusive). :param right: Right index of the range (inclusive). :return: The sum of elements from index left to right. if left > 0: return self._prefix_sum(bit_tree, right) - self._prefix_sum(bit_tree, left - 1) else: return self._prefix_sum(bit_tree, right)"},{"question":"Implement a function `large_integer_increment(digits: List[int]) -> List[int]` that takes a list of integers representing a non-negative large integer, and returns a new list with the integer value incremented by one. Input and Output Format * **Input**: A list of non-negative integers where each element is a digit (0-9) of the number. For example, the input `[1, 2, 3]` represents the number 123. * **Output**: A list of integers where each element is a digit (0-9) representing the incremented number. For instance, the input `[1, 2, 3]` should return `[1, 2, 4]`. Constraints * Do not use any built-in arbitrary-precision arithmetic library. * The list will not be empty and will contain at least one digit with no leading zeros (except for the number zero itself). Performance requirements: * Your function should handle arrays with up to 10^5 digits efficiently. * Aim for a time complexity of O(n) and a space complexity of O(1) if feasible. Example ```python assert large_integer_increment([1, 2, 3]) == [1, 2, 4] assert large_integer_increment([9, 9, 9]) == [1, 0, 0, 0] ``` Instructions 1. Write the function `large_integer_increment` as specified. 2. Consider all edge cases and ensure your function handles them correctly. 3. Optimize for both time and space complexity where possible.","solution":"from typing import List def large_integer_increment(digits: List[int]) -> List[int]: Takes a list of integers representing a non-negative large integer, and returns a new list with the integer value incremented by one. n = len(digits) for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If all digits are 9, we need to add a 1 at the beginning return [1] + digits"},{"question":"You are given a theoretical infinite sequence of concatenated positive integers, \\"123456789101112131415...\\". Write a function to find and return the nth digit in this sequence. Function Signature ```python def find_nth_digit(n: int) -> int: :param n: an integer representing the position of the digit in the infinite sequence :return: the nth digit in the sequence ``` Input - An integer `n` (1 ≤ n ≤ 2 * 10^9). Output - An integer representing the nth digit in the infinite sequence. Example ```python print(find_nth_digit(3)) # Output: 3 print(find_nth_digit(11)) # Output: 0 print(find_nth_digit(459)) # Output: 9 ``` # Constraints and Performance Requirements - You must ensure that the solution is efficient and can handle the upper limit of `n` (2 billion) without exceeding time limits. This implies logarithmic time complexity is preferred. - Be mindful of integer precision when dealing with large numbers. - Ensure proper handling of edge cases, particularly at transitions between digit lengths (9 to 10, 99 to 100, etc.). # Scenario Imagine you are developing a unique numbering system for a digital art exhibition which uses this sequence to label art pieces. Your task is to implement the function `find_nth_digit` to automatically determine and return the nth digit in this sequence when queried by the exhibition management software.","solution":"def find_nth_digit(n): length = 1 # current length of numbers we\'re counting count = 9 # how many numbers of \'length\' there are start = 1 # starting number with \'length\' digits while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n - 1) // length result_str = str(start) return int(result_str[(n - 1) % length])"},{"question":"Scenario: You are working on a software that needs to efficiently handle querying relationships among elements stored in a Binary Search Tree (BST). Specifically, one feature requires finding the in-order successor of a given node in the tree. Given the properties of BSTs, you need to implement a function that returns the in-order successor of a specified node. Function to Implement: ```python def inorder_successor(root, node): Finds the in-order successor of a given node in a BST. Parameters: root (TreeNode): The root of the BST. node (TreeNode): The node whose in-order successor is to be found. Returns: TreeNode: The in-order successor node if it exists, otherwise None. pass ``` Input: - `root`: The root node of the binary search tree, which can be `None`. - `node`: A node in the binary search tree whose in-order successor needs to be found. Output: - Return the in-order successor node if it exists. - If the in-order successor does not exist, return `None`. Constraints: - Assume that the provided `node` exists in the binary search tree. - The tree nodes will have unique integer values. - The structure of the TreeNode is defined as follows: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` Examples: 1. **Example 1:** ```python root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(6) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.left.left.left = TreeNode(1) node = root.left # Node with value 3 result = inorder_successor(root, node) if result: print(result.val) # Expected Output: 4 else: print(None) ``` 2. **Example 2:** ```python root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(6) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.left.left.left = TreeNode(1) node = root.right # Node with value 6 result = inorder_successor(root, node) if result: print(result.val) # Expected Output: None else: print(None) ``` Notes: - You may assume `TreeNode` class is pre-defined. - Do not assume that the given `root` node is balanced or tree depth is optimized; handle and test for all edge cases.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def inorder_successor(root, node): Finds the in-order successor of a given node in a BST. Parameters: root (TreeNode): The root of the BST. node (TreeNode): The node whose in-order successor is to be found. Returns: TreeNode: The in-order successor node if it exists, otherwise None. successor = None # Case 1: Node has a right child if node.right: successor = node.right while successor.left: successor = successor.left return successor # Case 2: Node does not have a right child while root: if node.val < root.val: successor = root root = root.left elif node.val > root.val: root = root.right else: break return successor"},{"question":"Scenario As a software developer, you often work with binary data and need to perform efficient bit manipulation tasks. One common task is to count the number of \'1\' bits in the binary representation of an integer. This operation is frequently required in applications ranging from cryptography to data compression. Task Implement a function `count_set_bits(n)` that takes an unsigned integer `n` and returns the number of \'1\' bits present in its binary representation. ```python def count_set_bits(n: int) -> int: Count the number of \'1\' bits in the binary representation of an unsigned integer. Parameters: n (int): An unsigned integer. Returns: int: Number of \'1\' bits in the binary representation of `n`. # Your code here ``` Input * `n`: An unsigned 32-bit integer (0 ≤ n ≤ 2^32 - 1). Output * An integer representing the number of \'1\' bits in the binary representation of the input. Constraints * Your solution must have a time complexity of O(k), where `k` is the number of \'1\' bits in the binary representation of `n`. * Avoid using Python built-in functions such as `bin` or other string manipulation techniques. Examples * Example 1: * Input: `n = 11` * Output: `3` * Explanation: `11` in binary is `1011`, which has three \'1\' bits. * Example 2: * Input: `n = 128` * Output: `1` * Explanation: `128` in binary is `10000000`, which has one \'1\' bit. Performance Requirements * The function should efficiently handle inputs up to the maximum value of unsigned 32-bit integer without excessive memory usage. Good luck, and be sure to consider edge cases and optimize your solution for both time and space efficiency!","solution":"def count_set_bits(n: int) -> int: Count the number of \'1\' bits in the binary representation of an unsigned integer. Parameters: n (int): An unsigned integer. Returns: int: Number of \'1\' bits in the binary representation of `n`. count = 0 while n: count += n & 1 n >>= 1 return count"},{"question":"# Question: Implement K-th Smallest Element in a Modified Tree Structure Given a **modified BST** where each node additionally stores the count of nodes in its subtrees, implement a function to find the k-th smallest element efficiently. Requirements: * **Function Signature**: ```python class Node: def __init__(self, val, left=None, right=None, left_count=0): self.val = val self.left = left self.right = right self.left_count = left_count def kth_smallest(root, k): # Your code here ``` * **Input Format**: * `root` (Node): Root node of the BST. * `k` (int): The integer representing the k-th smallest element. * **Output Format**: * Return the value of the k-th smallest element. * **Constraints**: * 1 ≤ k ≤ number of nodes in the tree. * Each node in the tree has distinct values. * **Performance Requirements**: * The function should run in O(log N) average time complexity if the tree is balanced. Example: ```python if __name__ == \'__main__\': n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 n1.left_count, n2.left_count, n3.left_count = 3, 1, 1 # Example left subtree counts print(kth_smallest(n1, 2)) # Output: 50 print(kth_smallest(n1, 4)) # Output: 100 ``` **Explanation**: In the example, the additional `left_count` helps the algorithm to skip left subtrees or navigate knowing its position.","solution":"class Node: def __init__(self, val, left=None, right=None, left_count=0): self.val = val self.left = left self.right = right self.left_count = left_count def kth_smallest(root, k): Returns the k-th smallest element in the modified BST. Args: root (Node): The root of the BST. k (int): The k-th position (1-indexed). Returns: int: The value of the k-th smallest element. current = root while current: left_size = current.left_count if k == left_size + 1: return current.val elif k <= left_size: current = current.left else: k -= (left_size + 1) current = current.right raise ValueError(\\"k is out of the range of the number of nodes in the tree.\\")"},{"question":"# Binary Heap: Implementing a Median Finder **Scenario**: Given a stream of integers, you want to be able to find the median element efficiently at any time. Implement a class `MedianFinder` that manages this stream of integers using a combination of two binary heaps (a min heap for the higher half and a max heap for the lower half of the numbers). This will allow you to find the median in constant time. **Objective**: Write a Python class `MedianFinder` which supports the following operations: * `add_num(num: int)` - Adds a number to the data structure. * `find_median() -> float` - Returns the median of all numbers added so far. **Requirements**: * The `add_num` method should run in (O(log N)) time. * The `find_median` method should run in (O(1)) time. # Implementation Details 1. **Data Structures**: Use two binary heaps: * A max heap to store the lower half of the numbers (use Python\'s `heapq` module, which is a min heap, with negative values to simulate a max heap). * A min heap to store the upper half of the numbers (use Python\'s `heapq` module directly). 2. **Operations**: * **Insertion (`add_num`)**: Insert numbers into the appropriate heap and balance the heaps if their sizes differ by more than one. * **Median Calculation (`find_median`)**: * If the number of elements is odd, the median is the root of the heap with more elements. * If the number of elements is even, the median is the average of the roots of both heaps. # Constraints: * All integers are in the range `[-10^5, 10^5]`. * The number of operations will be in the range `[1, 10^5]`. # Example Usage: ```python mf = MedianFinder() mf.add_num(1) mf.add_num(2) print(mf.find_median()) # Output: 1.5 mf.add_num(3) print(mf.find_median()) # Output: 2 ``` # Template: ```python import heapq class MedianFinder: def __init__(self): self.min_heap = [] self.max_heap = [] def add_num(self, num: int): # Your implementation here pass def find_median(self) -> float: # Your implementation here pass ``` # Notes: * Ensure the class handles the insertion and balancing of heaps efficiently. * Consider edge cases, such as when no numbers have been added. * Include comments to explain the logic behind inserting and finding the median.","solution":"import heapq class MedianFinder: def __init__(self): # Min-heap to store the upper half of the numbers self.min_heap = [] # Max-heap to store the lower half of the numbers (we invert values to use as max-heap) self.max_heap = [] def add_num(self, num: int): # Add to max heap (inverted to simulate max heap) heapq.heappush(self.max_heap, -num) # Balance the heaps by ensuring that every item in max_heap is <= every item in min_heap if self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0]): val = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, val) # Ensure the sizes of the heaps differ at most by 1 to maintain balance if len(self.max_heap) > len(self.min_heap) + 1: val = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, val) if len(self.min_heap) > len(self.max_heap): val = heapq.heappop(self.min_heap) heapq.heappush(self.max_heap, -val) def find_median(self) -> float: if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] else: return (-self.max_heap[0] + self.min_heap[0]) / 2"},{"question":"# Scenario You are working on a pathfinding system for an automated warehouse. The warehouse layout is represented as a 2D grid where each cell can be empty, a wall, or a gate. Your task is to compute the shortest distance from each empty cell to the nearest gate. # Task Write a function `walls_and_gates(rooms)` that fills each empty cell in the grid with the distance to the nearest gate. If a cell cannot reach any gate (due to walls or obstructions), it should remain at its original value of infinity (INF). You may assume that the distance to any gate is less than 2147483647 (maximum value for 32-bit integer). # Function Signature ```python def walls_and_gates(rooms: List[List[int]]) -> None: ``` # Input - `rooms`: A list of lists of integers where each integer can be: - -1 representing a wall or obstacle. - 0 representing a gate. - `2147483647` (representing INF) depicting an empty room. # Output - The function should modify the grid in-place to update the distances. # Constraints - The number of rows and columns in the grid will not exceed 200. - Do not use any additional data structures beyond those necessary for handling the input and processing recursively or iteratively. # Example **Input:** ```python rooms = [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] ``` **Output (Modified `rooms` grid):** ```python [ [3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4] ] ``` # Performance Requirement - Implement an efficient solution with a time complexity of O(m * n) where m is the number of rows and n is the number of columns. **Note:** Students should consider edge cases and ensure efficient handling of large grids without causing stack overflow.","solution":"from collections import deque from typing import List def walls_and_gates(rooms: List[List[int]]) -> None: Modifies the input grid \'rooms\' in-place to fill each empty room with the distance to the nearest gate. If a cell cannot reach any gate, it should remain at its original value of infinity (2147483647). if not rooms or not rooms[0]: return n_rows, n_cols = len(rooms), len(rooms[0]) gates = deque() # Collect all gates (cells with value 0) for r in range(n_rows): for c in range(n_cols): if rooms[r][c] == 0: gates.append((r, c)) while gates: r, c = gates.popleft() for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)): nr, nc = r + dr, c + dc if 0 <= nr < n_rows and 0 <= nc < n_cols and rooms[nr][nc] == 2147483647: rooms[nr][nc] = rooms[r][c] + 1 gates.append((nr, nc))"},{"question":"You are tasked with writing a function that calculates the Hamming weight (number of \'1\' bits) of a given non-negative integer. The Hamming weight is the total count of \'1\' bits in the binary representation of the integer. Implement this using the Brian Kernighan\'s Algorithm, both recursively and iteratively. Function Signature: ```python def count_ones_recur(n: int) -> int: pass def count_ones_iter(n: int) -> int: pass ``` Input: - `n`: A non-negative integer (0 ≤ n ≤ 2^31 - 1) Output: - An integer representing the number of \'1\' bits in the binary representation of `n`. Constraints: - Your solution should be efficient, clocking in at O(k) time complexity, where k is the number of \'1\' bits. - Avoid excessive space use, especially in the recursive approach. # Examples: - Example 1: - Input: `n = 11` - Output: `3` - Explanation: Binary representation of 11 is `00000000000000000000000000001011`, which has three \'1\' bits. - Example 2: - Input: `n = 128` - Output: `1` - Explanation: Binary representation of 128 is `00000000000000000000000010000000`, which has one \'1\' bit. - Example 3: - Input: `n = 0` - Output: `0` - Explanation: Binary representation of 0 is `00000000000000000000000000000000`, which has zero \'1\' bits. Implementation Notes: - Test and ensure accurate results for edge cases such as n = 0 or n = highest 32-bit integer value. - Provide clear comments to explain the key steps and logic used within the functions.","solution":"def count_ones_recur(n: int) -> int: Recursively calculates the number of \'1\' bits in the binary representation of the given non-negative integer n. Uses Brian Kernighan\'s Algorithm. if n == 0: return 0 return 1 + count_ones_recur(n & (n - 1)) def count_ones_iter(n: int) -> int: Iteratively calculates the number of \'1\' bits in the binary representation of the given non-negative integer n. Uses Brian Kernighan\'s Algorithm. count = 0 while n != 0: n = n & (n - 1) count += 1 return count"},{"question":"# Scenario You are developing an application that handles large datasets sorted in a two-dimensional grid. Each row and each column of the grid are sorted in non-decreasing order. One common operation is to search for particular elements within this grid. Implement an efficient function to perform this search. # Function Description Write a function: ```python def search_in_sorted_matrix(matrix, key): ``` **Input**: - `matrix`: A list of lists representing a 2-dimensional grid of integers, where each row and each column is sorted in non-decreasing order. - `key`: An integer value to search for in the matrix. **Output**: - Return a tuple `(row_index, column_index)` where the key is located within the matrix. If the key is not present, return `(-1, -1)`. # Constraints - Size of the matrix (number of rows and columns) is between 1 and 1000. - Each element in the matrix is an integer within the range -10^6 and 10^6. - Matrix and rows are given non-decreasing order. # Example Consider the matrix: ```python matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] ``` **Example 1**: ```python key = 13 result = search_in_sorted_matrix(matrix, key) print(result) # Output: (1, 2) ``` **Example 2**: ```python key = 10 result = search_in_sorted_matrix(matrix, key) print(result) # Output: (-1, -1) ``` # Requirements - Ensure your implementation is efficient with a time complexity target of O(m + n). - Handle edge cases where the matrix might be empty. # Notes - Do not use any built-in search functions. Implement the logic as described. - Ensure your code handles out-of-bound indices and key not present scenarios.","solution":"def search_in_sorted_matrix(matrix, key): Efficiently searches for a key in a 2D matrix where each row and each column is sorted in non-decreasing order. Parameters: matrix (List[List[int]]): 2D list where each row and column is sorted. key (int): The value to search for. Returns: (int, int): Tuple containing the row and column index of the key if found, otherwise (-1, -1). if not matrix or not matrix[0]: return -1, -1 rows = len(matrix) cols = len(matrix[0]) row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == key: return row, col elif matrix[row][col] > key: col -= 1 else: row += 1 return -1, -1"},{"question":"# Question Transitive Closure Given a directed graph `G` with `V` vertices and `E` edges, write a Python function to compute the transitive closure of the graph. The transitive closure of a graph is a matrix `T` such that if there is a path from vertex `i` to vertex `j`, then `T[i][j]` is 1, otherwise `T[i][j]` is 0. Function Signature ```python def transitive_closure(vertices: int, edges: List[Tuple[int, int]]) -> List[List[int]]: pass ``` Input * An integer `vertices` representing the number of vertices in the graph. * A list `edges` of tuples where each tuple `(i, j)` represents a directed edge from vertex `i` to vertex `j`. Output * Return a 2D list `closure` representing the transitive closure matrix of the graph. Constraints * 1 <= vertices <= 1000 * 0 <= edges <= vertices*(vertices-1) Performance Requirements * The implementation should run efficiently for large input sizes, particularly for the maximum constraints. Example ```python vertices = 4 edges = [(0, 1), (1, 2), (2, 3)] print(transitive_closure(vertices, edges)) ``` Expected Output: ``` [ [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1] ] ``` Notes 1. Assume the graph vertices are labeled from 0 to `vertices-1`. 2. The expected time complexity is as optimized as possible given the constraints.","solution":"from typing import List, Tuple def transitive_closure(vertices: int, edges: List[Tuple[int, int]]) -> List[List[int]]: # Initialize closure matrix with 0s closure = [[0] * vertices for _ in range(vertices)] # Set self-loops for i in range(vertices): closure[i][i] = 1 # Set direct edges for (i, j) in edges: closure[i][j] = 1 # Compute transitive closure using Floyd Warshall algorithm for k in range(vertices): for i in range(vertices): for j in range(vertices): closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j]) return closure"},{"question":"Context: You are tasked with writing a sorting function for a small set of numerical data. The goal is to sort the provided array in ascending order using the Exchange Sort algorithm. Although this algorithm is not the most efficient, its simplicity makes it perfect for understanding the basics of sorting algorithms. Task: Implement the `exchange_sort(arr)` function, which sorts an array of integers in ascending order using the Exchange Sort algorithm and adheres to the following requirements: 1. **Input**: * A list of integers `arr` with length `arr_len` such that `0 <= arr_len <= 1000`. 2. **Output**: * The sorted list of integers in ascending order. Constraints: * You should sort the list in place, i.e., without using additional lists or arrays. * If `arr` is empty, return an empty list. * The provided list may contain duplicate elements. Performance Requirements: * Your implementation should strictly follow the Exchange Sort algorithm with a time complexity of O(n^2). * You should ensure that your solution is stable, i.e., it does not change the relative order of equal elements. Example: ```python assert exchange_sort([3, 1, 2]) == [1, 2, 3] assert exchange_sort([4, -1, 0, 4]) == [-1, 0, 4, 4] assert exchange_sort([]) == [] ``` Hint: Pay attention to edge cases such as an empty array or arrays with duplicate values. Complete the function below: ```python def exchange_sort(arr): Sorts the list \'arr\' using the Exchange Sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: The sorted list in ascending order. # Your code here ```","solution":"def exchange_sort(arr): Sorts the list \'arr\' using the Exchange Sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: The sorted list in ascending order. n = len(arr) for i in range(n): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Context Consider an array of integers that needs to be sorted in non-decreasing order. One of the simple algorithms to achieve this is Selection Sort. While the naive implementation works fine, one crucial aspect that\'s often missed is handling arrays with duplicate entries where stability might be a concern. # Task Write a function `stable_selection_sort` to sort an array of integers using the selection sort algorithm. However, unlike the standard implementation, your method should ensure that the relative positions of equal elements are maintained, effectively making it a stable sort. # Function Signature ```python def stable_selection_sort(arr: List[int]) -> List[int]: Sorts the array (arr) using stable selection sort and returns the sorted array. :param arr: List[int] - List of integers to be sorted. :return: List[int] - Sorted list in non-decreasing order. ``` # Input * A list of integers `arr` with length `n` (0 <= n <= 10^5) * Integer values within the list where each element `arr[i]` will have the range -10^6 <= arr[i] <= 10^6 # Output * A list of integers sorted in non-decreasing order. # Constraints * Your solution should adhere to O(n^2) time complexity. * It should not use any additional storage beyond constant space (in-place sorting). # Examples: ```python assert stable_selection_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64] assert stable_selection_sort([4, 5, 3, 8, 7, 1, 3, 3, 2]) == [1, 2, 3, 3, 3, 4, 5, 7, 8] assert stable_selection_sort([]) == [] assert stable_selection_sort([1]) == [1] assert stable_selection_sort([2, 2, 2, 2, 2]) == [2, 2, 2, 2, 2] ``` # Additional Challenge Implement the function such that minimal changes are required to transform the given `selection_sort` into `stable_selection_sort`.","solution":"def stable_selection_sort(arr): Sorts the array (arr) using stable selection sort and returns the sorted array. :param arr: List[int] - List of integers to be sorted. :return: List[int] - Sorted list in non-decreasing order. n = len(arr) for i in range(n): min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j # Instead of swapping, use stable placement key = arr[min_idx] while min_idx > i: arr[min_idx] = arr[min_idx - 1] min_idx -= 1 arr[i] = key return arr"},{"question":"# Run-Length Encoding and Decoding with Edge Case Handling You are required to implement two functions `encode_rle(input)` and `decode_rle(input)`, which perform run-length encoding and decoding respectively. Additionally, you will consider and handle edge cases better. The description of these functions is as follows: Function `encode_rle(input)` Given a string `input`, return the Run-Length Encoded (RLE) version of it. **Input**: * `input` (string): A string of characters to encode. **Output**: * (string): The encoded string in RLE format. **Constraints**: * The input string `input` will have a length of at most 10^6. * The characters will be printable ASCII characters. Function `decode_rle(input)` Given a string `input` that represents data in RLE format, return the original string. **Input**: * `input` (string): A string in RLE format. **Output**: * (string): The decoded original string. **Constraints**: * The input string `input` will have a length of at most 10^6. # Example ```python # Example of encoding print(encode_rle(\\"aaabbcccc\\")) # Output: \\"3a2b4c\\" print(encode_rle(\\"a\\")) # Output: \\"1a\\" # Example of decoding print(decode_rle(\\"3a2b4c\\")) # Output: \\"aaabbcccc\\" print(decode_rle(\\"1a\\")) # Output: \\"a\\" ``` # Implementation Notes: * Ensure your implementation correctly handles edge cases such as empty strings and strings with many unique characters. * Optimize for both time and space efficiency, given the constraints.","solution":"def encode_rle(s): Encodes the given string using Run-Length Encoding (RLE). Parameters: - s (str): The input string to encode. Returns: - str: The Run-Length Encoded string. if not s: return \\"\\" encoded_str = [] count = 1 prev_char = s[0] for char in s[1:]: if char == prev_char: count += 1 else: encoded_str.append(f\\"{count}{prev_char}\\") count = 1 prev_char = char # Append the last set of characters encoded_str.append(f\\"{count}{prev_char}\\") return \\"\\".join(encoded_str) def decode_rle(s): Decodes the given Run-Length Encoded (RLE) string. Parameters: - s (str): The RLE encoded string to decode. Returns: - str: The decoded original string. if not s: return \\"\\" import re decoded_str = [] parts = re.findall(r\'(d+)(D)\', s) for count, char in parts: decoded_str.append(char * int(count)) return \\"\\".join(decoded_str)"},{"question":"# Cocktail Shaker Sort Implementation Challenge You have been provided with an implementation of the **Cocktail Shaker Sort** algorithm, also known as Bidirectional Bubble Sort. This sorting algorithm is a variation of bubble sort that sorts the list in both directions on each pass through the list. Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: pass ``` Task Complete the function `cocktail_shaker_sort` which sorts a list of integers using the Cocktail Shaker Sort algorithm. The function must: - Take a list of integers `arr` as input. - Return the sorted list `arr` in ascending order. Constraints - The input list can have up to 10,000 elements. - Each element in the list can be an integer within the range of `-10^6` to `10^6`. - Time complexity for the worst case can be O(N^2). Examples ```python assert cocktail_shaker_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] assert cocktail_shaker_sort([10, -1, 2, 3, 4, 5]) == [-1, 2, 3, 4, 5, 10] assert cocktail_shaker_sort([]) == [] assert cocktail_shaker_sort([1]) == [1] assert cocktail_shaker_sort([2, 1]) == [1, 2] ``` Notes - Pay special attention to early exit conditions when no elements were swapped during a pass. - Handle edge cases efficiently, like empty arrays or arrays with a single element. - The implementation should maintain the stability of the sorting algorithm. ```python def cocktail_shaker_sort(arr): def swap(i, j): arr[i], arr[j] = arr[j], arr[i] n = len(arr) swapped = True while swapped: swapped = False for i in range(1, n): if arr[i - 1] > arr[i]: swap(i - 1, i) swapped = True if swapped == False: return arr swapped = False for i in range(n-1,0,-1): if arr[i - 1] > arr[i]: swap(i - 1, i) swapped = True return arr ```","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: def swap(i, j): arr[i], arr[j] = arr[j], arr[i] n = len(arr) swapped = True start = 0 end = n - 1 while swapped: swapped = False for i in range(start, end): if arr[i] > arr[i + 1]: swap(i, i + 1) swapped = True if not swapped: break swapped = False end -= 1 for i in range(end, start, -1): if arr[i] < arr[i - 1]: swap(i, i - 1) swapped = True start += 1 return arr"},{"question":"# Scenario You work at a company developing encryption software that requires efficient computation of large powers of numbers under a modulus. To ensure security and speed, you need to implement an efficient algorithm for modular exponentiation. Write a function that computes `a^n % mod` efficiently using binary exponentiation. If the `mod` is not provided, return just `a^n`. # Function Signature ```python def efficient_power(a: int, n: int, mod: int = None) -> int: ``` # Input and Output * **Input**: * `a` (int): The base number (0 <= a <= 10^9). * `n` (int): The exponent (0 <= n <= 10^9). * `mod` (int, optional): The modulo (if specified, 1 <= mod <= 10^9). * **Output**: * Returns `a^n % mod` if `mod` is specified, otherwise returns `a^n`. # Constraints * You may assume that `0^0` returns `1`. * Implementations should handle large numbers and use modular arithmetic where `mod` is specified to avoid overflow. # Examples ```python print(efficient_power(2, 10)) # Output: 1024 print(efficient_power(2, 10, 1000)) # Output: 24 print(efficient_power(3, 5)) # Output: 243 print(efficient_power(3, 5, 7)) # Output: 5 print(efficient_power(0, 0)) # Output: 1 ``` # Explanation 1. **Example 1**: `2^10 = 1024`. 2. **Example 2**: `2^10 = 1024 % 1000 = 24`. 3. **Example 3**: `3^5 = 243`. 4. **Example 4**: `3^5 = 243 % 7 = 5`. 5. **Example 5**: `0^0 = 1` by definition. # Performance Requirements Your solution should have a time complexity of O(log(n)) and should be able to handle the given constraints efficiently.","solution":"def efficient_power(a: int, n: int, mod: int = None) -> int: Computes a^n % mod efficiently using binary exponentiation. If mod is not provided, returns a^n. if mod is None: return pow(a, n) # Using built-in pow for base ** exp result = 1 a = a % mod # To handle the case when a >= mod while n > 0: if n % 2 == 1: result = (result * a) % mod n = n // 2 a = (a * a) % mod return result"},{"question":"Implement Enhanced Counting Sort Given an array of integers, both positive and negative, implement an enhanced counting sort function `enhanced_counting_sort(arr)` that correctly sorts the array. Ensure the algorithm can handle a mixture of positive, negative and zero values and maintains stable sorting. **Input**: * An array of integers `arr` where `-10^6 ≤ arr[i] ≤ 10^6`. * `1 ≤ len(arr) ≤ 10^6`. **Output**: * A sorted array of integers. **Example**: ```python >>> enhanced_counting_sort([4, 6, 3, -1, -3, -4, 2, 2, 0, -2, 5]) [-4, -3, -2, -1, 0, 2, 2, 3, 4, 5, 6] ``` **Constraints**: * The function must use the counting sort algorithm. * The solution should be well-optimized for both time and space given the constraints on input sizes and values. **Notes**: 1. Ensure your implementation is efficient and can handle both the positive and negative range of values. 2. Edge cases such as empty arrays and arrays with a single value must be handled correctly.","solution":"def enhanced_counting_sort(arr): Sorts the input array using an enhanced version of counting sort that handles both negative and positive integers. if not arr: return arr min_val = min(arr) max_val = max(arr) # Calculate the range of the array values range_of_elements = max_val - min_val + 1 # Initialize the count array with zeros count = [0] * range_of_elements output = [0] * len(arr) # Store the count of each element in the count array for num in arr: count[num - min_val] += 1 # Modify the count array by adding the previous counts (Cumulative Count) for i in range(1, len(count)): count[i] += count[i - 1] # Build the output array using the count array for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"# Prime Number Generator with Twisted Sieve You are tasked with implementing a function that finds all prime numbers less than a given integer `n` using an optimized version of the Sieve of Eratosthenes algorithm. Function Signature ```python def twisted_sieve(n: int) -> list: pass ``` Input * `n` (integer): A positive integer ( n geq 2 ). Output * (list): A list of all prime numbers less than `n`. Instructions 1. Your implementation must efficiently generate prime numbers using the provided variations of the Sieve of Eratosthenes. 2. Instead of generating a boolean array for all numbers, generate it for only odd numbers to save space. 3. Ensure your implementation is optimized both in terms of time and space complexity. Constraints * You may assume that input `n` is a positive integer. * Avoid using any libraries that directly solve the problem (like `sympy` or similar). Examples ```python assert twisted_sieve(10) == [2, 3, 5, 7] assert twisted_sieve(25) == [2, 3, 5, 7, 11, 13, 17, 19, 23] assert twisted_sieve(2) == [] assert twisted_sieve(3) == [2] ``` Performance Requirements * Your solution should run within time complexity O(n log log n) and use space complexity O(n). Explanation Implement an optimized sieve considering only odd integers, creating an efficient algorithm for generating primes less than a given integer `n`.","solution":"def twisted_sieve(n: int) -> list: if n <= 2: return [] sieve = [True] * ((n // 2) - 1) # half the elements to save space (sieve for odd numbers) for i in range(len(sieve)): if sieve[i]: prime = 2 * i + 3 for multiple in range(prime * prime, n, 2 * prime): sieve[(multiple - 3) // 2] = False primes = [2] + [2 * i + 3 for i, is_prime in enumerate(sieve) if is_prime] return primes"},{"question":"**Question**: Implement a function `find_all_paths(graph, start, end)` that computes all possible paths from a given `start` node to `end` node in a directed graph represented as an adjacency list. This will require an understanding of traversal techniques and path management in graph structures. # Function Signature ```python def find_all_paths(graph: Dict[int, List[int]], start: int, end: int) -> List[List[int]]: pass ``` # Input - `graph`: A dictionary where keys are node identifiers (integers), and values are lists of nodes reachable from the key node. - `start`: An integer representing the starting node. - `end`: An integer representing the destination node. # Output - A list of lists, where each sublist represents a distinct path from `start` to `end`. # Constraints - The graph may contain cycles. - The graph is directed, meaning [1, 2] does not imply [2, 1]. - There are no negative cycles. # Example ```python graph = { 1: [2, 3], 2: [3, 4], 3: [4], 4: [5], 5: [] } start = 1 end = 5 find_all_paths(graph, start, end) # Output: [[1, 2, 3, 4, 5], [1, 2, 4, 5], [1, 3, 4, 5]] ``` # Note Ensure to handle edge cases such as: - Graphs with no path from `start` to `end`. - Graphs where `start` equals `end`. - Handling cyclic paths efficiently.","solution":"def find_all_paths(graph, start, end): def dfs(current_node, path): if current_node == end: paths.append(list(path)) return for neighbor in graph.get(current_node, []): if neighbor not in path: # Avoid cycles path.append(neighbor) dfs(neighbor, path) path.pop() paths = [] dfs(start, [start]) return paths"},{"question":"Strongly Connected Components Detection Given a directed graph with `V` vertices and `E` edges, implement the Kosaraju\'s algorithm to detect and return all strongly connected components (SCCs) of the graph. A strongly connected component is a maximal subset of vertices such that for every pair (u, v) within the subset, there is a direct path from u to v and v to u. Input - The first line contains two integers `V` (number of vertices) and `E` (number of edges). - The next `E` lines each contain a pair of integers `u` and `v` representing a directed edge from vertex `u` to vertex `v`. Output - Output the number of SCCs followed by each SCC on a new line. Each SCC should list the vertices belonging to it, space-separated. - The order of vertices in the SCC does not matter but SCCs should be output in order of increasing smallest vertex in each SCC. Constraints - (1 leq V leq 10^4) - (0 leq E leq 10^5) - Vertices are numbered from 0 to V-1. Example **Input:** ``` 6 7 0 2 1 0 2 3 3 1 3 4 4 5 5 4 ``` **Output:** ``` 2 0 1 2 3 4 5 ``` **Explanation:** There are two SCCs in the graph: 1. {0, 1, 2, 3} 2. {4, 5} Notes - Ensure your code handles large graphs efficiently. - Consider all edge cases including graphs where vertices have no incoming or outgoing edges, or completely disconnected graphs. Implement the function `find_scc()` based on the provided skeleton: ```python class Kosaraju: def dfs(self, i, adj, visited, stk): # Implementation of the standard DFS function. ... def kosaraju(self, V, adj): # Your implementation here, separating SCC detection logic. ... def find_scc(): V, E = map(int, input().split()) adj = [[] for x in range(V)] for i in range(E): u, v = map(int, input().split()) adj[u].append(v) kosaraju_algo = Kosaraju() result = kosaraju_algo.kosaraju(V, adj) # format and output the result print(result) if __name__ == \'__main__\': find_scc() ``` Your task is to complete the `Kosaraju` class by implementing the `dfs()` and rearranging the `kosaraju()` method to provide the necessary outputs. The `find_scc()` function handles input/output but you can modify it for additional processing as needed.","solution":"class Kosaraju: def __init__(self): self.visited = [] self.stack = [] def dfs_first_pass(self, node, adj): self.visited[node] = True for neighbor in adj[node]: if not self.visited[neighbor]: self.dfs_first_pass(neighbor, adj) self.stack.append(node) def dfs_second_pass(self, node, reverse_adj, scc): self.visited[node] = True scc.append(node) for neighbor in reverse_adj[node]: if not self.visited[neighbor]: self.dfs_second_pass(neighbor, reverse_adj, scc) def kosaraju(self, V, adj): self.visited = [False] * V self.stack = [] # First pass: Order vertices by finish time in reverse for i in range(V): if not self.visited[i]: self.dfs_first_pass(i, adj) # Get the transpose of the graph reverse_adj = [[] for _ in range(V)] for i in range(V): for neighbor in adj[i]: reverse_adj[neighbor].append(i) # Second pass: Find strongly connected components self.visited = [False] * V sccs = [] while self.stack: node = self.stack.pop() if not self.visited[node]: scc = [] self.dfs_second_pass(node, reverse_adj, scc) sccs.append(sorted(scc)) sccs.sort(key=lambda x: x[0]) return sccs def find_scc(): import sys input = sys.stdin.read data = input().split() V = int(data[0]) E = int(data[1]) adj = [[] for _ in range(V)] index = 2 for _ in range(E): u = int(data[index]) v = int(data[index + 1]) adj[u].append(v) index += 2 kosaraju_algo = Kosaraju() sccs = kosaraju_algo.kosaraju(V, adj) print(len(sccs)) for scc in sccs: print(\\" \\".join(map(str, scc))) # This ensures the function runs only when executed directly, # and not when imported for testing. if __name__ == \'__main__\': find_scc()"},{"question":"# Binary Search Tree Implementation You are required to implement a Binary Search Tree (BST) which supports the following functionalities: 1. **Insert (Integer data)**: Insert an integer into the BST. 2. **Search (Integer data)**: Search for an integer in the BST and return True if found, False if not. 3. **Size()**: Return the number of elements in the BST. 4. **Traversal (String type)**: - \\"preorder\\": Return a list of elements using preorder traversal. - \\"inorder\\": Return a list of elements using inorder traversal. - \\"postorder\\": Return a list of elements using postorder traversal. Input and Output Formats - **Insert Function**: - Input: Integer data to insert into the BST. - Output: Boolean (`True` if insert was successful, `False` if data already exists in the BST). - **Search Function**: - Input: Integer data to search in the BST. - Output: Boolean (`True` if data is found, `False` otherwise). - **Size Function**: - Input: None - Output: Integer representing the number of elements in the BST. - **Traversal Function**: - Input: String type indicating traversal (\\"preorder\\", \\"inorder\\", \\"postorder\\"). - Output: List of integers representing the traversal order. Constraints - You can assume all inputs are valid integers or strings as per the function requirements. - The BST should not allow duplicate values. Performance Requirements - Ensure that insert and search operations are implemented with efficient time complexity. Example Usage ```python # Create a new BST instance tree = BST() # Insert elements assert tree.insert(10) == True assert tree.insert(15) == True assert tree.insert(10) == False # Duplicate value # Search elements assert tree.search(15) == True assert tree.search(5) == False # Get size assert tree.size() == 2 # Traversals assert tree.traversal(\\"preorder\\") == [10, 15] assert tree.traversal(\\"inorder\\") == [10, 15] assert tree.traversal(\\"postorder\\") == [15, 10] ```","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None self.node_count = 0 def insert(self, data): if self.root is None: self.root = TreeNode(data) self.node_count += 1 return True else: return self._insert_rec(self.root, data) def _insert_rec(self, node, data): if data == node.val: return False # duplicate value elif data < node.val: if node.left is None: node.left = TreeNode(data) self.node_count += 1 return True else: return self._insert_rec(node.left, data) else: # data > node.val if node.right is None: node.right = TreeNode(data) self.node_count += 1 return True else: return self._insert_rec(node.right, data) def search(self, data): return self._search(self.root, data) def _search(self, node, data): if node is None: return False if node.val == data: return True elif data < node.val: return self._search(node.left, data) else: return self._search(node.right, data) def size(self): return self.node_count def traversal(self, traversal_type): if traversal_type == \\"inorder\\": return self._inorder(self.root) elif traversal_type == \\"preorder\\": return self._preorder(self.root) elif traversal_type == \\"postorder\\": return self._postorder(self.root) else: raise ValueError(\\"Invalid traversal type\\") def _inorder(self, node): res = [] if node: res = self._inorder(node.left) res.append(node.val) res = res + self._inorder(node.right) return res def _preorder(self, node): res = [] if node: res.append(node.val) res = res + self._preorder(node.left) res = res + self._preorder(node.right) return res def _postorder(self, node): res = [] if node: res = self._postorder(node.left) res = res + self._postorder(node.right) res.append(node.val) return res"},{"question":"# Merge Sort with In-Place Merge You are tasked with implementing an enhanced version of the Merge Sort algorithm. The improvement you need to implement is an in-place merge operation that reduces the auxiliary space usage from O(n) to O(log n), which aligns with the depth of the recursion tree. Task Implement a function `merge_sort_inplace` that sorts an array of integers in ascending order using the Merge Sort algorithm. Your merge operation should be performed in-place to minimize additional space usage. Function Signature ```python def merge_sort_inplace(arr, left, right): Sorts the portion of the array from index left to index right (inclusive) using in-place merge sort. :param arr: List[int] - The list of integers to be sorted. :param left: int - The starting index of the portion of the array to sort. :param right: int - The ending index of the portion of the array to sort. :return: None - The function modifies the input list in-place. pass ``` Constraints * 1 <= len(arr) <= 10^5 * -10^9 <= arr[i] <= 10^9 Requirements * Implement merge sort with an in-place merging method. * The algorithm should have a time complexity of O(n log(n)). * The in-place merge should reduce space complexity to O(log(n)). Example Input: ```python arr = [12, 11, 13, 5, 6, 7] merge_sort_inplace(arr, 0, len(arr) - 1) ``` Output: ```python arr = [5, 6, 7, 11, 12, 13] ``` Additional Notes 1. Implement an efficient in-place merging technique within your solution. 2. No additional arrays should be used aside from the input array.","solution":"def merge_sort_inplace(arr, left, right): Sorts the portion of the array from index left to index right (inclusive) using in-place merge sort. :param arr: List[int] - The list of integers to be sorted. :param left: int - The starting index of the portion of the array to sort. :param right: int - The ending index of the portion of the array to sort. :return: None - The function modifies the input list in-place. if left < right: mid = (left + right) // 2 # Recursively sort first and second halves merge_sort_inplace(arr, left, mid) merge_sort_inplace(arr, mid + 1, right) # Merge the sorted halves in place merge(arr, left, mid, right) def merge(arr, left, mid, right): Merges two subarrays of arr[]. First subarray is arr[left..mid] Second subarray is arr[mid+1..right] if arr[mid] <= arr[mid + 1]: return # The arrays are already merged # Start indexes of the two subarrays to be merged i = left j = mid + 1 while i <= mid and j <= right: # If element 1 is in the right place if arr[i] <= arr[j]: i += 1 else: temp_val = arr[j] temp_idx = j # Shift all elements between the elements to be merged while temp_idx != i: arr[temp_idx] = arr[temp_idx - 1] temp_idx -= 1 arr[i] = temp_val # Update pointers i += 1 mid += 1 j += 1"},{"question":"Problem Description You are provided with a sorted array of integers in ascending order. Your task is to implement the `binary_search` function that searches a query element in the given array and returns the index of the element if it is present in the array. If the element is not present, the function should return -1. Function Signature ```python def binary_search(array: List[int], query: int) -> int: pass ``` Input * `array`: A list of integers sorted in ascending order. * `query`: An integer, the element to search for in the array. Output * Returns an integer representing the index of `query` in `array` if found, otherwise returns -1. Constraints * The array will have at most `10^5` elements. * Each element in the array will be an integer such that `-10^9 <= element <= 10^9`. * The query will be an integer such that `-10^9 <= query <= 10^9`. Example ```python array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] query = 7 binary_search(array, query) # Returns 6 array = [1, 3, 5, 7, 9, 11, 13] query = 4 binary_search(array, query) # Returns -1 ``` Notes * Implement the function using an iterative approach for optimal space complexity. * Ensure your function handles all edge cases effectively.","solution":"def binary_search(array, query): Perform a binary search to find the index of query in array. :param array: List of integers sorted in ascending order. :param query: An integer to search for in the array. :return: The index of query in the array if found, otherwise return -1. left = 0 right = len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == query: return mid elif array[mid] < query: left = mid + 1 else: right = mid - 1 return -1"},{"question":"Implement an Efficient Word Dictionary with Search Capability **Objective:** Design and implement a `WordDictionary` class using a trie structure. The class should support operations to add words and search for words including patterns where \\".\\" can be any letter. **Details:** 1. **Class Definition:** * `WordDictionary`: * Method `void add_word(String word)`: Add a word to the dictionary. * Method `bool search(String word)`: Search for a word or a pattern in the dictionary. * Both methods should handle typical edge cases gracefully and guarantee performance within stated constraints. 2. **Functionality:** * Adding Words: The trie should store the word character-by-character. * Searching Words: Support literal word matches as well as wildcard \\".\\" matches. * The search operation should work for cases where the word contains one or more \\".\\" characters, allowing variable letters in those positions. **Constraints:** 1. The input word consists only of lowercase letters \'a\' - \'z\' and the character \'.\'. 2. The add and search functions are called individually, primarily for standard and wildcard searches. 3. The solution should be optimized for both time and space efficiency. **Examples:** ```python word_dict = WordDictionary() word_dict.add_word(\\"bad\\") word_dict.add_word(\\"dad\\") word_dict.add_word(\\"mad\\") assert word_dict.search(\\"pad\\") == False # not added assert word_dict.search(\\"bad\\") == True # exact match assert word_dict.search(\\".ad\\") == True # \'.\' matches \'b\', \'d\', or \'m\' assert word_dict.search(\\"b..\\") == True # \'.\' matches any character ``` Implement the `WordDictionary` class with the specified methods ensuring optimal performance for both add and search operations. **Note:** Focus on leveraging the properties of the trie to keep the insert and search operations efficient, and consider edge cases such as empty strings and search patterns with multiple wildcards.","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.end_of_word = True def search(self, word: str) -> bool: return self._search_recursive(word, 0, self.root) def _search_recursive(self, word: str, index: int, node: TrieNode) -> bool: if index == len(word): return node.end_of_word char = word[index] if char == \'.\': for child in node.children.values(): if self._search_recursive(word, index + 1, child): return True return False else: if char not in node.children: return False return self._search_recursive(word, index + 1, node.children[char])"},{"question":"# Context You are tasked with implementing a priority scheduling system for a set of tasks, where the task with the smallest priority number should be executed first. You will use a Binary Min Heap to manage the task scheduling. # Problem Statement Implement a class `MinHeapScheduler` that uses a binary min heap to manage a set of tasks. Each task is represented by a tuple `(task_name, priority)`. The class should support the following operations: 1. `add_task(task_name, priority)`: Adds a new task to the scheduler. 2. `pop_task()`: Removes and returns the task with the smallest priority. If the heap is empty, return `None`. 3. `peek_task()`: Returns the task with the smallest priority without removing it. If the heap is empty, return `None`. # Task Implement the `MinHeapScheduler` class with the given methods: ```python class MinHeapScheduler: def __init__(self): pass def add_task(self, task_name: str, priority: int): pass def pop_task(self) -> tuple: pass def peek_task(self) -> tuple: pass ``` # Constraints - Task names are unique. - Priorities are integers. - Operations need to be efficient to handle a large number of tasks. # Examples ```python scheduler = MinHeapScheduler() scheduler.add_task(\\"Task1\\", 3) scheduler.add_task(\\"Task2\\", 1) scheduler.add_task(\\"Task3\\", 2) print(scheduler.peek_task()) # Output: (\\"Task2\\", 1) print(scheduler.pop_task()) # Output: (\\"Task2\\", 1) print(scheduler.pop_task()) # Output: (\\"Task3\\", 2) print(scheduler.pop_task()) # Output: (\\"Task1\\", 3) print(scheduler.pop_task()) # Output: None ``` # Explanation - After adding three tasks, `peek_task` should return the task with the smallest priority (\\"Task2\\"). - `pop_task` should remove and return tasks in ascending order of priority. - If there are no tasks left, `pop_task` should return `None`.","solution":"import heapq class MinHeapScheduler: def __init__(self): # Initialize a min heap self.heap = [] def add_task(self, task_name: str, priority: int): # Add the task to the heap heapq.heappush(self.heap, (priority, task_name)) def pop_task(self) -> tuple: # Remove and return the task with the smallest priority if self.heap: return heapq.heappop(self.heap) else: return None def peek_task(self) -> tuple: # Return the task with the smallest priority without removing it if self.heap: return self.heap[0] else: return None"},{"question":"You need to implement a function `find_inorder_predecessor` that finds the inorder predecessor of a given node in a Binary Search Tree (BST). Function Signature ```python def find_inorder_predecessor(root, node): pass ``` Input - `root`: The root node of a Binary Search Tree. It\'s guaranteed that the structure of tree is a valid BST. - `node`: A target node (which you assume exists in the tree) whose predecessor needs to be found. Output - Return the inorder predecessor node of the given node. If the predecessor does not exist, return `None`. Constraints 1. The nodes have a structure `TreeNode` defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` 2. You may assume that both `root` and `node` are not `None` and that the value of nodes are unique. 3. Your solution should run in ( O(h) ) time complexity where ( h ) is the height of the tree. Example Consider the BST: ``` 20 / 8 22 / 4 12 / 10 14 ``` 1. Input: `root` is the root of the above tree and `node` is the node with value `10`. Output: The node with value `8` (as it\'s the largest node smaller than 10). 2. Input: `root` is the root of the above tree and `node` is the node with value `14`. Output: The node with value `12`. Implement the `find_inorder_predecessor` function using the guidelines provided.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_inorder_predecessor(root, node): Finds the inorder predecessor of a given node in a BST. :param root: The root node of the BST. :param node: The target node whose predecessor needs to be found. :return: The inorder predecessor node or None if no predecessor exists. # Helper function to find the maximum value node in a subtree def find_max(node): current = node while current.right: current = current.right return current predecessor = None current = root while current: if node.val > current.val: predecessor = current current = current.right elif node.val < current.val: current = current.left else: if current.left: return find_max(current.left) break return predecessor"},{"question":"Scenario You have been hired to implement an efficient system to manage a dictionary of words for an auto-completion feature in a search application. The application should be able to store words, check if a word exists, and suggest words based on prefixes entered during user searches. Objective Implement the Trie data structure with the following functionalities: 1. `insert(word)`: Inserts the string `word` into the trie. 2. `search(word)`: Returns `true` if the string `word` is in the trie (exact match), and `false` otherwise. 3. `starts_with(prefix)`: Returns `true` if there is any word in the trie that starts with the string `prefix`, and `false` otherwise. # Input and Output Format Method Signatures: ```python class Trie: def __init__(self): # Initialize your data structure here pass def insert(self, word: str) -> None: # Inserts a word into the trie. pass def search(self, word: str) -> bool: # Returns true if the word is in the trie pass def starts_with(self, prefix: str) -> bool: # Returns true if there is any word in the trie that starts with the given prefix. pass ``` Constraints: * All inputs are lowercase English letters (\'a\' to \'z\'). * All strings have a length between 1 and 100. Example: ```python # Example Usage: trie = Trie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # returns True print(trie.search(\\"app\\")) # returns False print(trie.starts_with(\\"app\\")) # returns True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # returns True ``` # Performance Requirements The methods should operate efficiently within the constraints of input size. Time complexity of each method should match the analysis provided, targeting O(n) for insert and search operations with respect to the length of the word or prefix involved.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for letter in word: if letter not in node.children: node.children[letter] = TrieNode() node = node.children[letter] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for letter in word: if letter not in node.children: return False node = node.children[letter] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for letter in prefix: if letter not in node.children: return False node = node.children[letter] return True"},{"question":"Scenario: You have been given a binary tree and your task is to determine its minimum depth. The minimum depth is defined as the shortest path from the root node to any leaf node. You are required to implement and compare both recursive and iterative solutions to find this minimum depth and print the tree. Input: 1. A binary tree with `TreeNode` objects where each node contains an integer value and pointers to left and right child nodes, which are either `TreeNode` instances or `None`. Output: 1. An integer that represents the minimum depth of the binary tree. 2. A list of values representing the preorder traversal of the binary tree. Constraints: 1. Assume the maximum number of nodes in the binary tree is 10^5. 2. Tree nodes contain integer values. Function Signatures: 1. `def min_depth_recursive(root: TreeNode) -> int` 2. `def min_depth_iterative(root: TreeNode) -> int` 3. `def preorder_traversal(root: TreeNode) -> List[int]` Example: Given the binary tree: ``` 10 / 12 15 / 25 30 100 ``` **Input:** ``` python tree = TreeNode(10) tree.left = TreeNode(12) tree.right = TreeNode(15) tree.left.left = TreeNode(25) tree.left.left.right = TreeNode(100) tree.left.right = TreeNode(30) ``` **Output:** - `min_depth_recursive(tree) -> 2` - `min_depth_iterative(tree) -> 2` - `preorder_traversal(tree) -> [10, 12, 25, 100, 30, 15]` Instructions: Write the three functions as defined above so they fulfill the described behavior and meet the given constraints.","solution":"from typing import Optional, List from collections import deque class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def min_depth_recursive(root: Optional[TreeNode]) -> int: if not root: return 0 if not root.left and not root.right: return 1 elif not root.left: return min_depth_recursive(root.right) + 1 elif not root.right: return min_depth_recursive(root.left) + 1 else: return min( min_depth_recursive(root.left), min_depth_recursive(root.right) ) + 1 def min_depth_iterative(root: Optional[TreeNode]) -> int: if not root: return 0 queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) def preorder_traversal(root: Optional[TreeNode]) -> List[int]: result = [] def helper(node: Optional[TreeNode]): if node: result.append(node.val) helper(node.left) helper(node.right) helper(root) return result"},{"question":"# Crout Matrix Decomposition Problem Problem Statement You are given a square matrix ( A ) of size ( n times n ). Your task is to implement the Crout matrix decomposition which factorizes matrix ( A ) into a lower triangular matrix ( L ) and an upper triangular matrix ( U ) such that the product ( L * U = A ). The diagonal elements of ( U ) should be set to 1. You need to implement a function: ```python def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: pass ``` Input and Output * **Input** * `A` (List[List[float]]): The input is a 2D list of floats representing the ( n times n ) matrix. You can assume that `A` is always a square matrix. * **Output** * A tuple containing two 2D lists: * `L` (List[List[float]]): A lower triangular matrix where the non-zero elements are on and below the diagonal. * `U` (List[List[float]]): An upper triangular matrix where the non-zero elements are on and above the diagonal, and the diagonal elements are 1. Constraints * ( 1 leq n leq 100 ) * `A` will contain real numbers. * Ensure division by zero does not occur (consider very small positive values in such cases). Performance Requirements * The solution should run in ( O(n^3) ) time complexity. Example ```python A = [ [1, 2, 3], [3, 4, 5], [6, 7, 8] ] L, U = crout_matrix_decomposition(A) # L should be approximately: # [ # [1.0, 0.0, 0.0], # [3.0, -2.0, 0.0], # [6.0, -5.0, 0.0] # ] # U should be approximately: # [ # [1.0, 2.0, 3.0], # [0.0, 1.0, 2.0], # [0.0, 0.0, 1.0] # ] ``` Your task is to complete the `crout_matrix_decomposition` function to perform the above.","solution":"from typing import List, Tuple def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: n = len(A) L = [[0.0] * n for _ in range(n)] U = [[0.0] * n for _ in range(n)] for j in range(n): U[j][j] = 1.0 for i in range(j, n): L[i][j] = A[i][j] - sum(L[i][k] * U[k][j] for k in range(j)) for i in range(j + 1, n): U[j][i] = (A[j][i] - sum(L[j][k] * U[k][i] for k in range(j))) / L[j][j] return L, U"},{"question":"Context In cryptography and data compression, it is often necessary to determine if a string contains all possible characters from a set. For example, in one of the common tasks, we might need to check if a given string contains all letters of the English alphabet at least once (i.e., the string is a \\"pangram\\"). Problem Statement You are tasked to implement an optimized version of a function to check whether a given string is a pangram or not effectively. This function should perform in linear time and use additional space efficiently. Function Signature ```python def is_pangram(input_string: str) -> bool: This function checks if the input string is a pangram. Parameters: input_string (str): The string to be checked. Returns: bool: True if the string is a pangram, False otherwise. ``` Requirements 1. The function should use a set to keep track of the letters found in the input string to optimize the checks. 2. The input string may contain any characters, but only letters (both lowercase and uppercase) are considered for pangram checking. 3. The solution must handle edge cases such as an empty string or strings with no alphabetic characters. 4. The time complexity of your implementation must be O(N), where N is the length of the input string. 5. Optimize for space usage by avoiding storage of unnecessary information. Example ```python assert is_pangram(\\"The quick brown fox jumps over the lazy dog\\") == True assert is_pangram(\\"Hello, World!\\") == False ``` Edge Cases 1. Empty string input: `is_pangram(\\"\\") == False`. 2. String with all non-alphabet characters: `is_pangram(\\"1234567890!@#\\") == False`. 3. Mixed case sensitivity: `is_pangram(\\"ThE QuIcK BrOwN FoX jUmPs OvEr ThE LaZy DoG\\") == True`.","solution":"def is_pangram(input_string: str) -> bool: This function checks if the input string is a pangram. Parameters: input_string (str): The string to be checked. Returns: bool: True if the string is a pangram, False otherwise. # Set of all letters in the English alphabet alphabet = set(\'abcdefghijklmnopqrstuvwxyz\') # Set to keep track of letters found in input_string found_letters = set() for char in input_string: if char.isalpha(): # Check if the character is a letter found_letters.add(char.lower()) # Add the lowercase letter to the set # Check if the found letters cover all the letters in the alphabet return found_letters >= alphabet"},{"question":"Given the provided `ArrayStack` and `LinkedListStack` class implementations, your task is to create a subclass of `ArrayStack` called `MinArrayStack` that extends the functionality to support a method `get_min()` which will return the minimum element in the stack in constant time, O(1). You are required to maintain an auxiliary stack to keep track of the minimum elements. # Function Signature ```python class MinArrayStack(ArrayStack): def __init__(self, size=10): super().__init__(size) def push(self, value): # Implement this method def pop(self): # Implement this method def get_min(self): # Implement this method ``` # Expected Input/Output * **Input**: * For `push()`: A single integer value to be pushed onto the stack. * For `pop()`: No input. * For `get_min()`: No input. * **Output**: * For `push()`: None. * For `pop()`: The integer value that was removed from the stack. * For `get_min()`: The minimum integer present in the stack. # Constraints * All elements in the stack are integers. * Stack operations are valid following typical stack usage (i.e., `pop` is not called on an empty stack). * The `MinArrayStack` should handle at least 10^5 operations efficiently. # Example Usage ```python stack = MinArrayStack() stack.push(10) stack.push(5) stack.push(15) print(stack.get_min()) # Output: 5 stack.pop() print(stack.get_min()) # Output: 5 stack.pop() print(stack.get_min()) # Output: 10 ```","solution":"class ArrayStack: def __init__(self, size=10): self.stack = [] self.size = size def push(self, value): if len(self.stack) >= self.size: raise OverflowError(\\"Stack is full\\") self.stack.append(value) def pop(self): if not self.stack: raise IndexError(\\"Pop from an empty stack\\") return self.stack.pop() class MinArrayStack(ArrayStack): def __init__(self, size=10): super().__init__(size) self.min_stack = [] def push(self, value): super().push(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self): value = super().pop() if value == self.min_stack[-1]: self.min_stack.pop() return value def get_min(self): if not self.min_stack: raise ValueError(\\"MinArrayStack is empty\\") return self.min_stack[-1]"},{"question":"You are designing a robot navigation system on a grid. Initially, there is a robot at position (0, 0). Given a sequence of its moves, determine if this robot makes a circle, which means it moves back to the original place. The move sequence is represented by a string. Each move is represented by a character: * \'R\' for Right * \'L\' for Left * \'U\' for Up * \'D\' for Down Write a function `does_robot_make_circle(moves)`, that returns `True` if the robot makes a circle and `False` otherwise. **Function Signature**: ```python def does_robot_make_circle(moves: str) -> bool: pass ``` **Input**: * `moves` (string): A string of valid characters \'R\', \'L\', \'U\', \'D\' representing moves. **Output**: * `True` if the robot returns to the origin, `False` otherwise. **Examples**: ```python assert does_robot_make_circle(\\"UD\\") == True assert does_robot_make_circle(\\"LL\\") == False ``` **Constraints**: * The input string\'s length will be in the range [0, 10^4]. # Guidelines * The function should run in O(n) time complexity, where n is the length of the move sequence. * Space complexity should be O(1). # Additional Context Consider edge cases such as: * An empty move string which should return `True`. * Repeated moves that still result in a circle e.g., \\"LLRRUUDD\\". Implement the function `does_robot_make_circle` adhering to the above constraints and scenarios.","solution":"def does_robot_make_circle(moves: str) -> bool: Determines if the sequence of moves makes the robot return to the origin (0, 0). Parameters: moves (str): A string of valid characters \'R\', \'L\', \'U\', \'D\'. Returns: bool: True if the robot returns to the origin, False otherwise. x, y = 0, 0 for move in moves: if move == \'R\': x += 1 elif move == \'L\': x -= 1 elif move == \'U\': y += 1 elif move == \'D\': y -= 1 return x == 0 and y == 0"},{"question":"# Insertion into a Red-Black Tree and Verification **Context**: You are tasked with implementing a part of a red-black tree data structure that maintains balance on every insertion. The balancing is done through rotations and recoloring. Given this context, your task is to implement the insertion of a new node in this tree respecting the red-black properties. **Function Specification**: ```python class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red class RBTree: def __init__(self): self.root = None ``` **Task**: Implement the following two methods: 1. `insert(self, node)`: Inserts a new node into the Red-Black Tree. 2. `fix_insert(self, node)`: Ensures the tree remains balanced and fixes any violations of red-black properties after an insertion. **Input**: * `node`: An instance of `RBNode` that needs to be inserted into the tree. **Output**: * After the method `insert` is called, the new node should be properly positioned in the tree and any necessary rotations/recolorings should have been executed to maintain red-black tree properties. The tree’s root should always be black. **Constraints**: * The provided tree will have unique values. * The `node` provided for insertion will always be a valid `RBNode`. * The tree will not exceed 10^4 nodes during testing. **Example**: ```python rb = RBTree() nodes = [RBNode(val, 1) for val in [11, 2, 14, 1, 7, 15, 5, 8, 4]] for node in nodes: rb.insert(node) # After operations, verify the correct in-order traversal and properties of the tree result = rb.inorder() # Result should be in sorted order with correct colors as per red-black tree requirements print(result) # [{\'val\': 1, \'color\': 0}, {\'val\': 2, \'color\': 0}, ...] ``` **Notes**: * Pay particular attention to edge cases such as inserting into an empty tree or inserting nodes that require multiple rotations to balance the tree. * You may use helper methods for rotations and for checking and fixing violations of red-black properties during insertions.","solution":"class RBNode: def __init__(self, val, is_red=True, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red class RBTree: def __init__(self): self.TNULL = RBNode(0, is_red=False) self.root = self.TNULL def insert(self, key): node = RBNode(key) node.left = self.TNULL node.right = self.TNULL parent = None temp = self.root while temp != self.TNULL: parent = temp if node.val < temp.val: temp = temp.left else: temp = temp.right node.parent = parent if parent is None: self.root = node elif node.val < parent.val: parent.left = node else: parent.right = node if node.parent is None: node.color = False return if node.parent.parent is None: return self.fix_insert(node) def rotate_left(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def rotate_right(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def fix_insert(self, k): while k.parent.color == True: if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color == True: u.color = False k.parent.color = False k.parent.parent.color = True k = k.parent.parent else: if k == k.parent.left: k = k.parent self.rotate_right(k) k.parent.color = False k.parent.parent.color = True self.rotate_left(k.parent.parent) else: u = k.parent.parent.right if u.color == True: u.color = False k.parent.color = False k.parent.parent.color = True k = k.parent.parent else: if k == k.parent.right: k = k.parent self.rotate_left(k) k.parent.color = False k.parent.parent.color = True self.rotate_right(k.parent.parent) if k == self.root: break self.root.color = False def inorder_helper(self, node): res = [] if node != self.TNULL: res = self.inorder_helper(node.left) res.append({\'val\': node.val, \'color\': node.color}) res = res + self.inorder_helper(node.right) return res def inorder(self): return self.inorder_helper(self.root)"},{"question":"You are tasked with implementing a sorting algorithm called Pigeonhole Sort, which sorts an array of integers efficiently when the range of the elements is about the same as the number of elements. Below are the specific requirements and constraints you must follow. # Requirements - Implement the function `pigeonhole_sort(arr: List[int]) -> List[int]` - The function should sort the list `arr` using the pigeonhole sort algorithm and return the sorted list. # Input - A list of integers `arr` of length `n` (1 ≤ n ≤ 10^5) where each element is in the range [a, b] and `0 ≤ a < b ≤ 10^5`. # Output - A list of integers representing the sorted input list. # Constraints - Elements in the list can be positive, negative, or zero. - The algorithm should perform efficiently given the time complexity `O(n + Range)`. - You must not use any built-in sorting functions. # Example ```python Input: arr = [8, 3, 1, 5, 2] Output: [1, 2, 3, 5, 8] Input: arr = [-5, -10, 0, -3, 8, 5, -1, 10] Output: [-10, -5, -3, -1, 0, 5, 8, 10] ``` # Scenario Context You are designing an inventory system for a warehouse where products have serial numbers ranging from 1000 to 2000. When new products arrive, they need to be sorted into bins where the bin numbers are consecutive, much like a range. Using your implementation, you can efficiently place items into the correct bin and keep the warehouse organized. **Considerations** - Carefully handle arrays that contain duplicate, zero, and negative numbers. - Ensure your implementation is optimized for large inputs. Implement the `pigeonhole_sort` function as per the above requirements.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: if not arr: return arr min_val = min(arr) max_val = max(arr) range_size = max_val - min_val + 1 holes = [0] * range_size for number in arr: holes[number - min_val] += 1 sorted_arr = [] for i in range(range_size): while holes[i] > 0: sorted_arr.append(i + min_val) holes[i] -= 1 return sorted_arr"},{"question":"You are given the task of implementing a codec for serializing and deserializing a binary tree. The codec should be able to convert a binary tree into a string and then back into the original binary tree. Function Specifications: 1. **serialize(root: TreeNode) -> str**: * **Input**: The root of the binary tree you need to serialize. * **Output**: A string representation of the binary tree. 2. **deserialize(data: str) -> TreeNode**: * **Input**: The string representation of the serialized binary tree. * **Output**: The root of the deserialized binary tree. You should use pre-order traversal for both serialization and deserialization. Represent `None` (null) nodes as `#` in the serialized string. Constraints: * The number of nodes in the tree is in the range `[0, 1000]`. * The tree node values are integers and fall within the 32-bit signed integer range. Example: Consider the following tree: ``` 1 / 2 3 / 4 5 ``` Using your implemented functions: ```python root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) # Serializing the tree serialized_str = serialize(root) print(serialized_str) # Output: \\"1 2 # # 3 4 # # 5 # #\\" # Deserializing the string back to tree deserialized_root = deserialize(serialized_str) print(serialize(deserialized_root)) # Output should match the initial serialized string: \\"1 2 # # 3 4 # # 5 # #\\" ``` Your task is to implement both `serialize` and `deserialize` functions correctly.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): def helper(node): if node is None: return \\"#\\" return f\\"{node.val} {helper(node.left)} {helper(node.right)}\\" return helper(root) def deserialize(data): def helper(nodes): value = next(nodes) if value == \\"#\\": return None node = TreeNode(int(value)) node.left = helper(nodes) node.right = helper(nodes) return node node_iter = iter(data.split()) return helper(node_iter)"},{"question":"Problem Statement: You are given a list of integers where each integer can appear multiple times. Your task is to write a function `get_histogram` that takes this list as input and returns a dictionary representing the frequency distribution of each integer in the list. Your function should efficiently calculate the frequency of each unique integer, and you should consider handling different edge cases such as an empty list. Function Signature: ```python def get_histogram(input_list: list) -> dict: pass ``` Input: - A list of integers, where the list can be empty. Example format: - `input_list = [1, 2, 2, 3, 3, 3]` Output: - A dictionary where the keys are the integers from the input list, and the values are their respective frequencies. Example format: - `{1: 1, 2: 2, 3: 3}` Constraints: - The integers in the list can range from negative to positive infinity. - The length of the input list can be up to 10^6. Example: ```python assert get_histogram([3, 3, 2, 1]) == {1: 1, 2: 1, 3: 2} assert get_histogram([2, 3, 5, 5, 5, 6, 4, 3, 7]) == {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} assert get_histogram([]) == {} ``` Performance Considerations: - Ensure that your solution is efficient and can handle the upper constraint on the length of the list. - The implementation should have a time complexity of O(n).","solution":"def get_histogram(input_list: list) -> dict: Returns a dictionary representing the frequency distribution of each integer in the input list. histogram = {} for number in input_list: if number in histogram: histogram[number] += 1 else: histogram[number] = 1 return histogram"},{"question":"Scenario: Imagine you are writing a calculator tool to help students understand the Pythagorean theorem in geometry. Given two side lengths of a right-angled triangle, the tool should compute the third side length. To be user-friendly, the function should handle the inputs flexibly, where a question mark \\"?\\" indicates the side length to be determined, while the other two inputs represent known side lengths. Task: Write a Python function called `compute_side_length` that accomplishes this. Function Specification: * **Function Name**: `compute_side_length` * **Input Parameters**: * `side_a` (str or float): The length of the first triangle side, or \\"?\\" if it\'s unknown. * `side_b` (str or float): The length of the second triangle side, or \\"?\\" if it\'s unknown. * `side_c` (str or float): The length of the hypotenuse, or \\"?\\" if it\'s unknown. * **Returns**: A string indicating the calculated length of the unknown side, prefixed with the side\'s name. Constraints: * Only one side length will be provided as \\"?\\". * Non-hypotenuse sides will always be numerical values. * Input sides will be positive values. * Expect that the function will be tested on a variety of input formats, so type and value checks are essential. * Calculate the results to two decimal places. Example 1: ```python compute_side_length(\\"?\\", 4, 5) ``` * **Output**: `\\"Opposite = 3.00\\"` Example 2: ```python compute_side_length(3, \\"?\\", 5) ``` * **Output**: `\\"Adjacent = 4.00\\"` Example 3: ```python compute_side_length(3, 4, \\"?\\") ``` * **Output**: `\\"Hypotenuse = 5.00\\"`","solution":"import math def compute_side_length(side_a, side_b, side_c): Computes the length of the unknown side of a right-angled triangle. Parameters: - side_a (str or float): The length of the first triangle side, or \\"?\\" if it\'s unknown. - side_b (str or float): The length of the second triangle side, or \\"?\\" if it\'s unknown. - side_c (str or float): The length of the hypotenuse, or \\"?\\" if it\'s unknown. Returns: - str: A string indicating the calculated length of the unknown side, prefixed with the side\'s name. if side_a == \\"?\\": known_side = float(side_b) hypotenuse = float(side_c) unknown_side = math.sqrt(hypotenuse**2 - known_side**2) return f\\"Opposite = {unknown_side:.2f}\\" elif side_b == \\"?\\": known_side = float(side_a) hypotenuse = float(side_c) unknown_side = math.sqrt(hypotenuse**2 - known_side**2) return f\\"Adjacent = {unknown_side:.2f}\\" elif side_c == \\"?\\": side_1 = float(side_a) side_2 = float(side_b) unknown_side = math.sqrt(side_1**2 + side_2**2) return f\\"Hypotenuse = {unknown_side:.2f}\\""},{"question":"# Question Given a string `s` and an integer `k`, implement a function `rotate_string(s: str, k: int) -> str` that returns a string obtained by rotating `s` to the left `k` times. # Input * `s` (1 <= len(s) <= 1000): A non-empty string containing only lowercase English letters. * `k` (1 <= k <= 10^5): A non-negative integer representing the number of rotations. # Output * A rotated string after performing `k` left rotations. # Example ```python assert rotate_string(\\"hello\\", 2) == \\"llohe\\" assert rotate_string(\\"hello\\", 5) == \\"hello\\" assert rotate_string(\\"hello\\", 6) == \\"elloh\\" assert rotate_string(\\"hello\\", 7) == \\"llohe\\" assert rotate_string(\\"hello\\", 102) == \\"lohel\\" ``` # Constraints and Notes * The function should correctly handle cases where `k` is larger than the length of the string. * Optimize the function to efficiently handle large values of `k`. # Scenario Imagine you are designing a text-based editor where users can rotate the content of the text within a line by a certain number of characters to the left. This function will be a core utility in implementing the text rotation feature. # Tip Remember to handle the modulo operation to minimize unnecessary rotations and ensure your implementation is efficient both in terms of time and space.","solution":"def rotate_string(s: str, k: int) -> str: Returns a string which is rotated to the left `k` times. n = len(s) k = k % n # Reduce k if it\'s larger than the length of the string return s[k:] + s[:k]"},{"question":"# Graph Cloning **Objective**: Clone an undirected graph such that the clone contains the same structure and node values as the original graph. **Specifications**: * You need to implement a function `cloneGraph(node: UndirectedGraphNode) -> UndirectedGraphNode` that takes an `UndirectedGraphNode` representing the head of an undirected graph and returns the head node of a deep cloned graph. * The graph is connected, and each node contains a unique label and a list of neighboring nodes. **Class Definition**: ```python class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def shallow_copy(self): return UndirectedGraphNode(self.label) def add_neighbor(self, node): self.neighbors.append(node) ``` **Constraints**: * The number of nodes will be in the range [0, 10000]. * The graph structure is represented through nodes and their neighbors using OJ\'s undirected graph serialization. **Input/Output**: * Input: An instance of `UndirectedGraphNode`. Can be `None` if the graph is empty. * Output: A new `UndirectedGraphNode` which is a deep clone of the input graph. **Examples**: 1. **Input**: A graph with nodes labeled {0, 1, 2}, where node 0 is connected to nodes 1 and 2, node 1 is connected to node 2, and node 2 has a self-cycle. - Serialized: `{0,1,2#1,2#2,2}` **Output**: A deep clone of the graph with the same structure and serialized form as `{0,1,2#1,2#2,2}`. 2. **Input**: `None` (An empty graph). **Output**: `None` **Implementation Requirement**: - You must implement the solution using any of the traversal methods (BFS, iterative DFS, or recursive DFS) while maintaining efficiency both in time and space. - Ensure that the cloned graph maintains the exact labels and connections as the original graph.","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def cloneGraph(node: UndirectedGraphNode) -> UndirectedGraphNode: if node is None: return None def clone(node, node_map): if node in node_map: return node_map[node] copy = UndirectedGraphNode(node.label) node_map[node] = copy for neighbor in node.neighbors: copy.neighbors.append(clone(neighbor, node_map)) return copy return clone(node, {})"},{"question":"# Stack Implementation and Management Implement additional functionality for a stack that operates on integer values. Both the `ArrayStack` and `LinkedListStack` classes are provided. Task: 1. Implement a method called `reverse_stack` which takes a stack as an argument and returns a new stack with the elements in reversed order. 2. Implement a method called `sort_stack` which takes a stack as an argument and returns a new stack with the elements sorted in ascending order. Input and Output: 1. The `reverse_stack` method: - Input: A stack (either `ArrayStack` or `LinkedListStack`). - Output: A new stack with the elements reversed. ```python def reverse_stack(stack): # Your code here # Example usage: stack = ArrayStack() stack.push(1) stack.push(2) stack.push(3) new_stack = reverse_stack(stack) print(new_stack) # Expected Output: Top-> 1 2 3 stack = LinkedListStack() stack.push(1) stack.push(2) stack.push(3) new_stack = reverse_stack(stack) print(new_stack) # Expected Output: Top-> 1 2 3 ``` 2. The `sort_stack` method: - Input: A stack (either `ArrayStack` or `LinkedListStack`). - Output: A new stack with the elements sorted in ascending order. ```python def sort_stack(stack): # Your code here # Example usage: stack = ArrayStack() stack.push(3) stack.push(1) stack.push(2) new_stack = sort_stack(stack) print(new_stack) # Expected Output: Top-> 3 2 1 stack = LinkedListStack() stack.push(3) stack.push(1) stack.push(2) new_stack = sort_stack(stack) print(new_stack) # Expected Output: Top-> 3 2 1 ``` # Notes: - You are required to use the given stack implementations (either `ArrayStack` or `LinkedListStack`). You may assume that each stack contains integers and each stack does not need to be resized or optimized further. - Implement the methods in such a way that they can handle any type of stack passed to them (parameterized as `AbstractStack` can work for both).","solution":"class ArrayStack: def __init__(self): self.items = [] def is_empty(self): return len(self.items) == 0 def push(self, item): self.items.append(item) def pop(self): return self.items.pop() def peek(self): return self.items[-1] def __repr__(self): return \'Top-> \' + \' \'.join(map(str, reversed(self.items))) class LinkedListStack: class Node: def __init__(self, value, next=None): self.value = value self.next = next def __init__(self): self.head = None def is_empty(self): return self.head is None def push(self, item): new_node = self.Node(item, self.head) self.head = new_node def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") value = self.head.value self.head = self.head.next return value def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.head.value def __repr__(self): result = [] current = self.head while current is not None: result.append(current.value) current = current.next return \'Top-> \' + \' \'.join(map(str, result)) def reverse_stack(stack): if isinstance(stack, ArrayStack): reversed_items = stack.items[::-1] new_stack = ArrayStack() new_stack.items = reversed_items return new_stack elif isinstance(stack, LinkedListStack): new_stack = LinkedListStack() current = stack.head while current is not None: new_stack.push(current.value) current = current.next return new_stack else: raise TypeError(\\"Unsupported stack type\\") def sort_stack(stack): all_items = [] while not stack.is_empty(): all_items.append(stack.pop()) sorted_items = sorted(all_items) new_stack = stack.__class__() for item in sorted_items: new_stack.push(item) return new_stack"},{"question":"# Coding Challenge: Distance to Nearest Gate (Using BFS) You are given a m x n 2D grid initialized with these three possible values: - `-1`: A wall or an obstacle. - `0`: A gate. - `INF`: An empty room represented as 2147483647. Write a function `walls_and_gates` which updates each empty room (INF) with the distance to its nearest gate. If it is impossible to reach a gate, it should remain filled with INF. Input * `rooms`: A list of lists of integers representing the grid, where `rooms[i][j]` can be `-1`, `0`, or `2147483647`. Output * The function should modify the input grid in place. Constraints * The number of rows and columns of the grid are at most 200. Example Given the 2D grid: ``` INF -1 0 INF INF INF INF -1 INF -1 INF -1 0 -1 INF INF ``` After running your function, the grid should be: ``` 3 -1 0 1 2 2 1 -1 1 -1 2 -1 0 -1 3 4 ``` Performance Requirements * The algorithm should complete with a time complexity of O(m * n) and a space complexity of O(m * n). **Note:** You may assume that the distance to a gate is less than 2147483647. Question Implement the `walls_and_gates` function to update the grid as described above. Function Signature ```python def walls_and_gates(rooms: List[List[int]]) -> None: # Your implementation here ```","solution":"from collections import deque from typing import List def walls_and_gates(rooms: List[List[int]]) -> None: Updates each empty room (INF) with the distance to its nearest gate. If it is impossible to reach a gate, the room remains INF. if not rooms or not rooms[0]: return m, n = len(rooms), len(rooms[0]) INF = 2147483647 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque() # Initialize the queue with all gates\' positions for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) # Perform BFS from each gate while queue: row, col = queue.popleft() for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < m and 0 <= c < n and rooms[r][c] == INF: rooms[r][c] = rooms[row][col] + 1 queue.append((r, c))"},{"question":"Adding Two Numbers via Linked Lists Objective Given two linked lists representing two non-negative integers, where the digits are stored in reverse order, write a function that adds the two numbers and returns the sum as a new linked list. # Problem Statement You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, meaning that the 1\'s digit is at the head of the list. Each node contains a single digit. You need to add the two numbers and return the sum as a linked list in the same reverse order. You may assume the two numbers do not contain any leading zero, except the number 0 itself. # Function Signature ```python class Node: def __init__(self, x): self.val = x self.next = None def add_two_numbers(left: Node, right: Node) -> Node: ``` # Input - `left`: Node - A non-empty linked list representing the first non-negative integer. - `right`: Node - A non-empty linked list representing the second non-negative integer. # Output - Returns a Node which is the head of a new linked list representing the sum of the two integers. # Constraints - The number of nodes in each linked list is in the range `[1, 100]`. - Each linked list represents a number that will fit within the range of 32-bit signed integer (i.e., `[-2^31, 2^31 - 1]`). # Example ```python # Example 1: # Input: left = 2 -> 4 -> 3, right = 5 -> 6 -> 4 # Output: 7 -> 0 -> 8 # Explanation: 342 + 465 = 807 # Example 2: # Input: left = 0, right = 0 # Output: 0 # Explanation: 0 + 0 = 0 ``` # Notes - You are required to complete the function `add_two_numbers`. - You may use a helper function to handle intermediate steps if needed. - Ensure your code handles cases where one linked list is longer than the other.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def add_two_numbers(left: Node, right: Node) -> Node: dummy_head = Node(0) current = dummy_head carry = 0 while left is not None or right is not None: left_val = left.val if left else 0 right_val = right.val if right else 0 total = left_val + right_val + carry carry = total // 10 current.next = Node(total % 10) current = current.next if left: left = left.next if right: right = right.next if carry > 0: current.next = Node(carry) return dummy_head.next"},{"question":"# Scenario ACME Corp. has enlisted you to implement and verify a compression tool that uses Run-Length Encoding (RLE). The tool will help their system reduce the size of logs generated by their equipment in a more storage and bandwidth-efficient manner. While the current implementations for encoding and decoding provided by an intern seem to work, ACME Corp. is particularly interested in further verifying your understanding by implementing robust testing around these core functionalities. # Task Your task is to implement a function `test_rle()` that performs comprehensive testing of the existing `encode_rle` and `decode_rle` functions. Included should be a variety of test cases to cover common scenarios and edge cases. You should also identify any possible issues with the current implementation through your tests. # Constraints 1. The input strings will contain only printable ASCII characters. # function Documentation ```python def test_rle(): Performs comprehensive testing on RLE encoding and decoding. It should print the test results and identify any failures. pass ``` # Expected Input and Output The `test_rle` function does not take input but should print clear and concise information about each test case. Each test should include: * The input string. * The expected encoded string. * The expected decoded string after re-encoding to ensure the process is lossless. * Whether the encoding and decoding processes passed or failed. # Example Test Cases 1. Input: `\\"aaabbb\\"` * Expected Encoded: `\\"3a3b\\"` * Expected Decoded: `\\"aaabbb\\"` 2. Input: `\\"abcd\\"` * Expected Encoded: `\\"1a1b1c1d\\"` * Expected Decoded: `\\"abcd\\"` 3. Input: `\\"\\"` (empty string) * Expected Encoded: `\\"\\"` * Expected Decoded: `\\"\\"` 4. Input: `\\"aabbaaa\\"` * Expected Encoded: `\\"2a2b3a\\"` * Expected Decoded: `\\"aabbaaa\\"` Implementing `test_rle()` should provide you with a robust verification mechanism of the RLE compression functions.","solution":"def encode_rle(input_string): Encodes the input string using Run-Length Encoding (RLE). if not input_string: return \'\' encoded_string = \'\' count = 1 char = input_string[0] for next_char in input_string[1:]: if next_char == char: count += 1 else: encoded_string += str(count) + char char = next_char count = 1 encoded_string += str(count) + char return encoded_string def decode_rle(encoded_string): Decodes a Run-Length Encoded (RLE) string. if not encoded_string: return \'\' decoded_string = \'\' count = \'\' for char in encoded_string: if char.isdigit(): count += char else: decoded_string += int(count) * char count = \'\' return decoded_string"},{"question":"Given a string `s` and a list of words `wordDict`, implement a function `countSentences(s, wordDict)` that returns the number of ways the string can be segmented into sentences where each word is a valid word from `wordDict`. # Function Signature ```python def countSentences(s: str, wordDict: List[str]) -> int: ``` # Input - `s`: A non-empty string consisting of lowercase English letters. - `wordDict`: A list of non-empty strings which represent the dictionary words. # Output - Returns an integer representing the number of possible sentences that can be formed. # Example ```python assert countSentences(\\"appletablet\\", [\\"apple\\", \\"tablet\\", \\"table\\", \\"app\\", \\"let\\", \\"able\\", \\"t\\"]) == 4 assert countSentences(\\"applet\\", [\\"app\\", \\"let\\", \\"apple\\", \\"t\\", \\"applet\\"]) == 3 assert countSentences(\\"thing\\", [\\"thing\\"]) == 1 assert countSentences(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) == 3 ``` # Constraints - The input string `s` will have a length in the range `[1, 300]`. - All string lengths in `wordDict` will be in the range `[1, 50]`. - The input list `wordDict` will have a length in the range `[1, 5000]`. # Note You should strive for an optimized solution considering the potential large size of the data. Using dynamic programming for memoization will be a beneficial approach to avoid redundant computations and improve efficiency.","solution":"from typing import List def countSentences(s: str, wordDict: List[str]) -> int: word_set = set(wordDict) memo = {} def helper(start): if start in memo: return memo[start] if start == len(s): return 1 count = 0 for end in range(start + 1, len(s) + 1): if s[start:end] in word_set: count += helper(end) memo[start] = count return count return helper(0)"},{"question":"# Question: Implement a Custom String Reversal Function You are asked to implement a function to reverse a given string while considering some constraints and optimizations. Given a string `s`, write a function `custom_reverse(s: str) -> str` that reverses the string. Requirements: 1. Your solution should avoid using Python\'s built-in methods like `reversed()` or slicing (`[::-1]`). 2. The function must handle edge cases efficiently. 3. Aim for both time and space complexities to be linear, i.e., O(n). Input and Output Formats: - **Input**: A string `s` of length `0 <= len(s) <= 10^5` - **Output**: A string which is the reverse of `s` Example: ```python assert custom_reverse(\\"hello\\") == \\"olleh\\" assert custom_reverse(\\"A man, a plan, a canal, Panama\\") == \\"amanaP ,lanac a ,nalp a ,nam A\\" assert custom_reverse(\\"\\") == \\"\\" ``` Constraints: 1. Handle very long strings efficiently. 2. Consider edge cases like empty strings or strings with a single character. 3. Should not lead to a stack overflow or excessive memory usage. Implement the function in a way that takes advantage of Python\'s features while meeting the above constraints and requirements.","solution":"def custom_reverse(s: str) -> str: Reverses the given string without using in-built methods like reversed() or slicing. :param s: Input string to be reversed :return: Reversed string n = len(s) reversed_string = [\'\'] * n for i in range(n): reversed_string[i] = s[n-1-i] return \'\'.join(reversed_string)"},{"question":"**Question: Implement an Optimized Cocktail Shaker Sort** Cocktail Shaker Sort is a comparison-based sorting algorithm that traverses through a list alternately from left to right and right to left, moving the largest or smallest elements to their correct positions. Your task is to implement this sorting algorithm with optimizations to handle larger and more complex datasets effectively. # Function Signature ```python def optimized_cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` # Input - `arr` (List[int]): A list of integers to be sorted. The list may contain positive, negative, and duplicate integers. # Output - Returns a list of integers sorted in ascending order. # Constraints - The function should handle lists containing up to 10^5 elements. - The implementation should seek to minimize unnecessary comparisons and swaps for nearly sorted lists or lists with repetitive elements. # Example ```python assert optimized_cocktail_shaker_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3]) == [1, 1, 2, 3, 3, 4, 5, 5, 6, 9] assert optimized_cocktail_shaker_sort([10, 20, 30, 5, 15]) == [5, 10, 15, 20, 30] assert optimized_cocktail_shaker_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] ``` # Guidelines - Implement an optimized version of Cocktail Shaker Sort. - Include checks to exit early if the list becomes sorted before all passes are completed. - Minimize the number of comparisons and swaps by keeping track of the last swapped positions. - Consider and handle edge cases, including lists of zero or one element.","solution":"from typing import List def optimized_cocktail_shaker_sort(arr: List[int]) -> List[int]: Optimized Cocktail Shaker Sort that sorts an array in ascending order. n = len(arr) if n <= 1: return arr start = 0 end = n - 1 while start < end: new_end = start new_start = end # Traverse from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] new_end = i end = new_end if start >= end: break # Traverse from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] new_start = i start = new_start return arr"},{"question":"# Question: Enhanced Path Splitter You are to implement an improved version of a path-splitting function. This enhanced function should handle both UNIX-like file paths and URLs, consistently providing a base path and a filename. Additionally, the function should be able to handle cases where the path is empty or lacks any directory components (i.e., the path consists of only a filename). Function Signature ```python def enhanced_split(path: str) -> (str, str): ``` # Input * `path` (str): A string containing either a URL or a file path, which you want to split into a base path and a filename. # Output * Returns a tuple containing two strings: * Base path (str): The directory part of the path. If no directory part exists, it should return an empty string. * Filename (str): The filename part of the path. If no filename part exists, it should return an empty string. # Constraints * The input path can be a URL or file path that follows Unix conventions (i.e., using \'/\' as separator). * The input path will not contain white spaces. # Examples ```python # Example 1: input: \\"https://algorithms/unix/test.py\\" output: (\\"https://algorithms/unix\\", \\"test.py\\") # Example 2: input: \\"algorithms/unix/test.py\\" output: (\\"algorithms/unix\\", \\"test.py\\") # Example 3: input: \\"test.py\\" output: (\\"\\", \\"test.py\\") # Example 4: input: \\"\\" output: (\\"\\", \\"\\") ``` # Performance Requirements * The function should handle input strings up to length `10^6` efficiently, considering both time and space complexity.","solution":"def enhanced_split(path: str) -> (str, str): Splits the provided path into a base path and a filename. :param path: A string containing either a URL or a file path. :return: A tuple containing the base path and the filename. if not path: return \\"\\", \\"\\" last_slash_index = path.rfind(\'/\') if last_slash_index == -1: # No directory component, only filename return \\"\\", path base_path = path[:last_slash_index] filename = path[last_slash_index + 1:] return base_path, filename"},{"question":"**Scenario**: You are tasked with organizing guests in a queue for a special event. Each guest has certain requirements about their position in the queue based on their height and the number of taller or equally tall people in front of them. **Task**: Given a list of guests, where each guest is represented by a pair of integers `[h, k]`: - `h` is the height of the guest. - `k` is the number of people in front of this guest who have a height greater than or equal to `h`. Write a function `reconstruct_queue(people)` that reconstructs the queue and returns it in the correct order. **Input Format**: - A list of lists, where each sublist contains two integers `[h, k]`. The input list will have at most 1100 elements. **Output Format**: - A list of lists, where each sublist contains two integers `[h, k]`, representing the reconstructed queue. **Constraints**: - The number of people is less than 1100. **Example**: ```python # Example Input people = [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] # Example Output # The expected output is: # [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] def reconstruct_queue(people): :type people: List[List[int]] :rtype: List[List[int]] queue = [] people.sort(key=lambda x: (-x[0], x[1])) for h, k in people: queue.insert(k, [h, k]) return queue ``` **Performance Requirements**: - Ensure the solution is efficient enough to handle the upper limit of the input size (~1100 elements). **Additional Notes**: - Consider edge cases such as an empty list or a single person in the list. - Pay attention to the sorting step to avoid incorrect placements. **Coding Challenge**: Implement the function `reconstruct_queue(people)` as outlined above and ensure it meets the constraints and performs efficiently for the given input limitations.","solution":"def reconstruct_queue(people): Reconstructs the queue based on the given list of people with their height and the number of taller or equally tall people in front of them. :type people: List[List[int]] :rtype: List[List[int]] # Sort the people: # 1. By height in descending order # 2. By the number of people in front in ascending order people.sort(key=lambda x: (-x[0], x[1])) queue = [] # Place each person in the correct position based on their k value for person in people: queue.insert(person[1], person) return queue"},{"question":"# Unique Morse Code Words You are given a list of words where each word is written in lowercase English letters. Each letter is mapped to its corresponding Morse code representation based on the table provided. Your task is to write a function that converts each word to its Morse code representation and then returns the number of unique Morse code representations among the given list of words. Morse Code Table: ```plaintext \'a\':\\".-\\", \'b\':\\"-...\\", \'c\':\\"-.-.\\", \'d\':\\"-..\\", \'e\':\\".\\", \'f\':\\"..-.\\", \'g\':\\"--.\\", \'h\':\\"....\\", \'i\':\\"..\\", \'j\':\\".---\\", \'k\':\\"-.-\\", \'l\':\\".-..\\", \'m\':\\"--\\", \'n\':\\"-.\\", \'o\':\\"---\\", \'p\':\\".--.\\", \'q\':\\"--.-\\", \'r\':\\".-.\\", \'s\':\\"...\\", \'t\':\\"-\\", \'u\':\\"..-\\", \'v\':\\"...-\\", \'w\':\\".--\\", \'x\':\\"-..-\\", \'y\':\\"-.--\\", \'z\':\\"--..\\" ``` Task Write a function `unique_morse(words: List[str]) -> int` that will: 1. Convert each word to its Morse code representation. 2. Return the number of unique Morse code representations among the given list of words. Input * `words`: A list of strings with length between 1 and 100, each string consists of lowercase English alphabets and has a length between 1 and 12. Output * An integer representing the number of unique Morse code representations. Constraints * Each word consists only of lowercase English letters. * The length of the input list and the length of each word adheres to the given ranges. Example ```python words = [\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"] unique_morse(words) ``` *Expected Output*: 2 *Explanation*: The transformations of the words are: * \\"gin\\" -> \\"--...-.\\" * \\"zen\\" -> \\"--...-.\\" * \\"gig\\" -> \\"--...--.\\" * \\"msg\\" -> \\"--...--.\\" There are 2 unique transformations: \\"--...-.\\" and \\"--...--.\\". Function Signature ```python from typing import List def unique_morse(words: List[str]) -> int: pass ``` Your task is to implement the `unique_morse` function. Pay attention to optimizing the performance of checking for unique transformations.","solution":"from typing import List def unique_morse(words: List[str]) -> int: morse_code_map = { \'a\': \\".-\\", \'b\': \\"-...\\", \'c\': \\"-.-.\\", \'d\': \\"-..\\", \'e\': \\".\\", \'f\': \\"..-.\\", \'g\': \\"--.\\", \'h\': \\"....\\", \'i\': \\"..\\", \'j\': \\".---\\", \'k\': \\"-.-\\", \'l\': \\".-..\\", \'m\': \\"--\\", \'n\': \\"-.\\", \'o\': \\"---\\", \'p\': \\".--.\\", \'q\': \\"--.-\\", \'r\': \\".-.\\", \'s\': \\"...\\", \'t\': \\"-\\", \'u\': \\"..-\\", \'v\': \\"...-\\", \'w\': \\".--\\", \'x\': \\"-..-\\", \'y\': \\"-.--\\", \'z\': \\"--..\\" } unique_transformations = set() for word in words: morse_representation = \'\'.join(morse_code_map[char] for char in word) unique_transformations.add(morse_representation) return len(unique_transformations)"},{"question":"Heap Sort Enhanced: Multiple Array Segments # Background Heap Sort is a powerful sorting algorithm leveraging heaps to order elements. Two forms exist: max-heap sorts in ascending order, and min-heap sorts in descending order. Your task extends upon this foundation, applying heap sort across multiple independent segments of an array. # Objective Given multiple segments within an array, your task is to sort each segment independently using heap sort: * Implement a function to sort segments: ```python def sort_segments(arr, segments, sort_type): Sorts the segments within array \'arr\', where segments is a list of tuples defining the start and end indices of each segment. sort_type defines the heap type (\'max\' or \'min\'). Parameters: arr (List[int]): The array to be sorted. segments (List[Tuple[int, int]]): List of segment tuples (start, end) indices. sort_type (str): \'max\' for max-heap (ascending order), \'min\' for min-heap (descending order). Returns: List[int]: The array with each segment sorted independently. ``` # Input - `arr`: List of integers (1 <= len(arr) <= 10^5) - `segments`: List of tuples (1 <= len(segments) <= 100), where each tuple contains start and end indices (0 <= start < end < len(arr)). - `sort_type`: A string dictating the type of sort - \'max\' for max-heap and \'min\' for min-heap. # Output - The array with each defined segment sorted in place according to the specified heap type. # Example ```python arr = [3, 5, 1, 2, 4, 6, 9, 8, 7] segments = [(0, 3), (4, 6)] sort_type = \'max\' sort_segments(arr, segments, sort_type) # Output: [1, 2, 3, 5, 4, 6, 9, 8, 7] ``` # Constraints * The segments do not overlap. * The algorithm should run in O(n log n) per segment for efficiency. # Notes - Ensure proper error handling for edge cases (empty array, invalid segments). - Provide meaningful test cases to validate your solution.","solution":"def heapify(arr, n, i, sort_type): Maintain the heap property for a subtree rooted at index i assuming the whole array \'arr\' is a heap, except for possibly i itself. largest = smallest = i left = 2 * i + 1 right = 2 * i + 2 if sort_type == \\"max\\": if left < n and arr[i] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest, sort_type) elif sort_type == \\"min\\": if left < n and arr[i] > arr[left]: smallest = left if right < n and arr[smallest] > arr[right]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] heapify(arr, n, smallest, sort_type) def heap_sort_segment(segment, sort_type): In-place heap sort for a given segment of the array. n = len(segment) # Build heap for i in range(n // 2 - 1, -1, -1): heapify(segment, n, i, sort_type) # Extract elements one by one for i in range(n-1, 0, -1): segment[i], segment[0] = segment[0], segment[i] heapify(segment, i, 0, sort_type) def sort_segments(arr, segments, sort_type): Sorts the segments within array \'arr\', where segments is a list of tuples defining the start and end indices of each segment. sort_type defines the heap type (\'max\' or \'min\'). Parameters: arr (List[int]): The array to be sorted. segments (List[Tuple[int, int]]): List of segment tuples (start, end) indices. sort_type (str): \'max\' for max-heap (ascending order), \'min\' for min-heap (descending order). Returns: List[int]: The array with each segment sorted independently. for start, end in segments: segment = arr[start:end+1] heap_sort_segment(segment, sort_type) arr[start:end+1] = segment return arr"},{"question":"# Question: You are tasked to write a function that constructs valid paths by joining two parts, either for file systems or URLs, ensuring there are no redundant slashes at the join point. You need to implement the function `join_with_slash(base, suffix)`. # Description: - The function takes two strings: - `base` (a base path or URL string) - `suffix` (an additional part to be appended to the base) - Join the strings such that there is exactly one slash (\'/\') between the base and suffix. # Input: - `base`: a non-empty string representing the base path or URL. - `suffix`: a string representing the path or URL to append. # Output: - A string representing the joined path. # Constraints: - The combined length of `base` and `suffix` will not exceed 1000 characters. # Example: 1. `join_with_slash(\\"http://example.com\\", \\"path/to/resource\\")` returns `\\"http://example.com/path/to/resource\\"` 2. `join_with_slash(\\"path/to/dir/\\", \\"file\\")` returns `\\"path/to/dir/file\\"` 3. `join_with_slash(\\"http://example.com/\\", \\"/path/to/resource\\")` returns `\\"http://example.com/path/to/resource\\"` # Requirements: - Ensure there are no redundant slashes between `base` and `suffix`. - The slash patterns should be handled as described in the examples. # Implementation Notes: - You must not use any external libraries such as `os.path` or `urljoin`.","solution":"def join_with_slash(base, suffix): Joins the base and suffix strings with a single slash, ensuring no redundant slashes. if base.endswith(\'/\'): base = base.rstrip(\'/\') if suffix.startswith(\'/\'): suffix = suffix.lstrip(\'/\') return f\\"{base}/{suffix}\\""},{"question":"**Problem Statement** You are given a series of numbers, and you need to determine which of these numbers are powers of two. Write a function `find_powers_of_two(nums)` that takes a list of integers `nums` and returns a list of booleans where each boolean indicates whether the corresponding integer in `nums` is a power of two. **Function Signature:** ```python def find_powers_of_two(nums: List[int]) -> List[bool]: pass ``` **Input:** - `nums` (List[int]): A list of integers. **Output:** - List[bool]: A list of booleans. **Constraints:** 1. The length of `nums` will be at most 10^6. 2. Each integer in `nums` will be between -2^31 and 2^31 - 1. **Example:** ```python # Example Input: nums = [1, 2, 3, 4, 5, 16, 20, 64] # Example Output: [True, True, False, True, False, True, False, True] ``` **Explanation:** - `1` is a power of two (2^0). - `2` is a power of two (2^1). - `3` is not a power of two. - `4` is a power of two (2^2). - `5` is not a power of two. - `16` is a power of two (2^4). - `20` is not a power of two. - `64` is a power of two (2^6). **Note:** You should use bitwise operations to ensure that your solution runs efficiently even for the upper limits of input sizes.","solution":"from typing import List def find_powers_of_two(nums: List[int]) -> List[bool]: This function takes a list of integers and returns a list of booleans. Each boolean indicates whether the corresponding integer is a power of two. def is_power_of_two(n: int) -> bool: if n <= 0: return False return (n & (n - 1)) == 0 return [is_power_of_two(num) for num in nums]"},{"question":"Objective Implement a function to delete a given node in a singly linked list, provided direct access to that node, except when the node is the last one. The function should be efficient with constant time complexity. Problem Statement You are given a singly linked list where each node contains an integer value. You are also given direct access to a node within this list (excluding the tail node). Your task is to delete this node from the linked list in constant time. The head of the list is not provided. Function Signature ```python def delete_node(node: \'Node\') -> None: pass ``` Input - `node` (Node): A node within a singly linked list (except the tail node). Output - The function modifies the linked list in-place and does not return any value. Constraints - The given node is guaranteed to be valid and not the tail node. - All node values are integers. - The function should raise a `ValueError` if `node` is None or if it is the tail node. Example Suppose the linked list is `1 -> 2 -> 3 -> 4` and you are given the third node with value `3`. After calling your function, the linked list should become `1 -> 2 -> 4`. ```python # Example usage: class Node: def __init__(self, x): self.val = x # Value of the node self.next = None # Pointer to the next node # Create example linked list head = Node(1) second = Node(2) third = Node(3) fourth = Node(4) head.next = second second.next = third third.next = fourth # Apply the delete_node function delete_node(third) # The linked list should now be: 1 -> 2 -> 4 ``` Develop a function as described and test it against scenarios where direct access is given to non-tail nodes.","solution":"class Node: def __init__(self, x): self.val = x # Value of the node self.next = None # Pointer to the next node def delete_node(node: \'Node\') -> None: Deletes a node (except the tail) from a singly linked list by direct access. if node is None or node.next is None: raise ValueError(\\"Cannot delete the given node as it is None or the tail node\\") next_node = node.next node.val = next_node.val node.next = next_node.next next_node.next = None # Optional step to help with garbage collection"},{"question":"You are working on an e-commerce platform that frequently requires sorting product prices efficiently. Implement a function that sorts a list of product prices using Comb Sort. The algorithm should handle edge cases such as empty lists, lists with one item, and lists with many identical items. **Function Signature**: ```python def sort_product_prices(prices: List[float]) -> List[float]: pass ``` # Input - `prices` (List[float]): Each element represents a product price, and there can be any number of products (0 <= len(prices) <= 10^5). # Output - A sorted list of product prices in ascending order. # Constraints - The prices list can contain float values including 0, but not negative. - Performance should be efficient for larger lists, aiming for an average time complexity of O(N log N). - The function should not require additional memory beyond initial allocation of the list. # Example ```python # Example 1 prices = [23.99, 5.49, 12.30, 5.49, 100.0, 9.99] print(sort_product_prices(prices)) # Output: [5.49, 5.49, 9.99, 12.30, 23.99, 100.0] # Example 2 prices = [100.0, 99.99, 50.5, 25.25, 25.0] print(sort_product_prices(prices)) # Output: [25.0, 25.25, 50.5, 99.99, 100.0] # Example 3 prices = [100.0] print(sort_product_prices(prices)) # Output: [100.0] # Example 4 prices = [] print(sort_product_prices(prices)) # Output: [] ``` Given this problem, your task is to complete the function `sort_product_prices` to correctly implement Comb Sort and handle all the test cases effectively.","solution":"from typing import List def sort_product_prices(prices: List[float]) -> List[float]: def get_next_gap(gap): gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(prices) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(0, n - gap): if prices[i] > prices[i + gap]: prices[i], prices[i + gap] = prices[i + gap], prices[i] swapped = True return prices"},{"question":"# Context: You are given a singly linked list with potentially duplicate elements. Your task is to write a function that removes all duplicates from the list without using any additional data structures such as hash sets or arrays. # Instructions: Write a function `remove_duplicates(head: Node) -> None` that takes the head of a singly linked list and modifies the list in place to remove any duplicates. # Input Format: - A single argument `head`, the head of a singly linked list with `Node` elements, where each `Node` has an attribute `val` (containing the element\'s value) and `next` (pointing to the next `Node`). # Output Format: - The function should not return any value but should modify the linked list directly to remove duplicates. # Constraints: 1. The linked list will have a maximum length of `10^5`. 2. The values within the list are assumed to be hashable and may include any data type compatible with the Python `==` operator. # Example: Suppose we have the linked list represented as follows: - A -> A -> B -> C -> D -> C -> F -> G After calling `remove_duplicates(head)`, the linked list should be modified to: - A -> B -> C -> D -> F -> G # Performance Requirement: - Aim for a solution with a time complexity of `O(N^2)` and space complexity of `O(1)`. # Solution Template: ```python class Node(): def __init__(self, val=None): self.val = val self.next = None def remove_duplicates(head: Node) -> None: # TODO: Implement this function to remove duplicates in-place ```","solution":"class Node(): def __init__(self, val=None): self.val = val self.next = None def remove_duplicates(head: Node) -> None: current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"**Scenario**: An e-commerce company wants to implement a search function to quickly find specific product prices in its massive and sorted price list. Due to the regular updates and large size of the list, a fast and efficient search algorithm is necessary. The development team decides to use Jump Search to achieve this. **Task**: Implement the `jump_search` function to find the index of a target price in a sorted array of prices. If the target price is found, return its index; if the target price is not found, return -1. **Function Signature**: ```python def jump_search(arr: List[int], target: int) -> int: pass ``` **Input and Output Formats**: * The function accepts two parameters: - `arr`: A list of integers which are sorted in ascending order. (1 ≤ len(arr) ≤ 10^5) - `target`: An integer representing the price to search for. * The function outputs: - An integer representing the index of the target in the list, or `-1` if the target is not present. **Constraints and Considerations**: * The array will always be sorted. * The array elements and the target will be non-negative integers. * Think about the optimal block size based on the length of the array. * Ensure the function handles large arrays efficiently within time complexity O(√n). **Examples**: 1. `jump_search([1, 2, 3, 4, 5, 6], 4)` should return `3`. 2. `jump_search([1, 2, 3, 4, 5, 6], 7)` should return `-1`. 3. `jump_search([2, 4, 6, 8, 10, 12], 8)` should return `3`. Implement `jump_search` function to address the above requirements effectively.","solution":"from typing import List import math def jump_search(arr: List[int], target: int) -> int: Perform a jump search algorithm to find the index of \'target\' in the sorted list \'arr\'. Parameters: arr (List[int]): A list of sorted integers. target (int): The target integer to search for in the list \'arr\'. Returns: int: The index of \'target\' in \'arr\' if found, else -1. n = len(arr) step = int(math.sqrt(n)) # Optimal block size to be jumped prev = 0 # Jump the blocks while prev < n and arr[min(step, n) - 1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 # Do a linear search within the identified block for i in range(prev, min(step, n)): if arr[i] == target: return i return -1"},{"question":"You are given an n x n 2D matrix representing an image. Write a function `rotate(matrix)` that rotates the image by 90 degrees (clockwise) in-place. # Input * The matrix is a list of lists of integers, where each list represents a row of the matrix. * It is guaranteed that matrix is a square (n x n) matrix. # Output * The function should return the modified matrix rotated by 90 degrees clockwise. # Constraints * 1 <= n <= 10^3 * Elements of matrix are integers within range (-10^4, 10^4). # Example Input: ``` matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` Output (in-place modification): ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` # Note - Your solution should change the original matrix, and the output returned is the same matrix reference. # Edge Cases to Consider * An empty matrix should return an empty matrix. * If the matrix has only one element, the function should handle it and return as is. # Requirements * Your function should efficiently handle matrix sizes up to 1000 x 1000. * The function should perform the rotation in-place, i.e., without using extra space for another matrix.","solution":"def rotate(matrix): Rotates the given n x n matrix by 90 degrees clockwise in-place. n = len(matrix) # Step 1: Transpose the matrix in-place for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row in-place for i in range(n): matrix[i].reverse() return matrix"},{"question":"# Bubble Sort with Early Termination Enhancement Bubble sort is a simple, yet inefficient, comparison-based sorting algorithm. It repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. This process is repeated until the array is sorted. However, in its conventional form, bubble sort is very slow for large or mostly unsorted datasets due to its O(N^2) time complexity. In this task, you are required to implement an enhanced version of the bubble sort algorithm that builds upon the given classic bubble sort implementation. Your enhanced algorithm should include: 1. An early termination mechanism that detects when no swaps are made in a complete pass through the array, indicating that the array is already sorted. 2. Refine the number of passes through the array based on the last swap position to skip over sorted parts. Input - An unsorted list of integers, `arr`. Output - The sorted list of integers in ascending order. Constraints - 1 <= len(arr) <= 1000 - -10^6 <= arr[i] <= 10^6 for all i Implementation Requirements - Your implementation must handle the simulation mode, showing each iteration\'s state if the `simulation` parameter is set to `True`. - Optimize the sorting process as much as possible within the constraints provided. - Ensure the implementation covers edge cases, including already sorted arrays, reverse sorted arrays, and arrays with duplicate values. ```python def enhanced_bubble_sort(arr, simulation=False): Sorts an array using the enhanced version of bubble sort with detailed simulation. Args: arr (list): list of integers to sort simulation (bool): If True, print the array after each iteration Returns: list: Sorted list of integers # Write your implementation here # Example usage: # arr = [64, 34, 25, 12, 22, 11, 90] # print(enhanced_bubble_sort(arr, True)) ```","solution":"def enhanced_bubble_sort(arr, simulation=False): Sorts an array using the enhanced version of bubble sort with detailed simulation. Args: arr (list): list of integers to sort simulation (bool): If True, print the array after each iteration Returns: list: Sorted list of integers n = len(arr) for i in range(n): # Track if any swap has been made in this pass swapped = False # Optimized: only go up to the last unsorted element last_swapped_position = 0 for j in range(1, n - i): if arr[j - 1] > arr[j]: # Swap elements arr[j - 1], arr[j] = arr[j], arr[j - 1] swapped = True last_swapped_position = j # End the sorting early if there were no swaps made if not swapped: break if simulation: print(f\\"After pass {i + 1}: {arr}\\") return arr"},{"question":"# Invert a Binary Tree Given a binary tree, write a function to invert the binary tree such that the left and right children of every node are swapped. # Function Signature ```python def invert_tree(root: TreeNode) -> None: ``` # Input * The function takes in `root`, which is the root node of the binary tree. # Output * This function does not return anything, it should modify the tree in-place. # Constraints * The number of nodes in the tree is in the range [0, 1000]. # Example ```plaintext Input: 4 / 2 7 / / 1 3 6 9 Output: 4 / 7 2 / / 9 6 3 1 ``` # Notes * You may assume that all values in the tree are unique. * The input tree can be empty, and in that case, your function should do nothing (the tree remains None).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_tree(root: TreeNode) -> None: Function to invert a binary tree. :param root: TreeNode, the root node of the binary tree :return: None, modifies the tree in-place if root: # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert left and right subtrees invert_tree(root.left) invert_tree(root.right)"},{"question":"**Graph Traversal and Modification** You are working on a network monitoring system that uses graph data structures to represent network nodes and connections. Your task is to implement two functions for traversing and modifying the network represented as a graph. 1. **dfs_traverse(graph, start)**: This function performs a Depth First Search (DFS) traversal starting from a given node. 2. **bfs_traverse(graph, start)**: This function performs a Breadth First Search (BFS) traversal starting from a given node. Additionally, you need to implement a function that detects and removes cycles from the graph using a DFS approach. 3. **remove_cycles(graph)**: This function detects and removes cycles in the directed graph. It should return a new graph (with cycles removed) and a list of all edges that were removed to break the cycles. # Function Signatures ```python def dfs_traverse(graph, start): Perform Depth First Search (DFS) traversal starting from \'start\' node. :param graph: Dictionary representing adjacency list of the graph. :param start: Starting node for the DFS traversal. :return: Set of visited nodes in the order they were first visited. pass def bfs_traverse(graph, start): Perform Breadth First Search (BFS) traversal starting from \'start\' node. :param graph: Dictionary representing adjacency list of the graph. :param start: Starting node for the BFS traversal. :return: Set of visited nodes in the order they were first visited. pass def remove_cycles(graph): Detect and remove cycles in the graph using DFS approach. :param graph: Dictionary representing adjacency list of a directed graph. :return: A tuple containing: - The new graph with the cycles removed - A list of edges that were removed to break the cycles pass ``` # Input and Output Formats Example Input ```python graph = { \'A\': [\'B\', \'D\'], \'B\': [\'C\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'E\'], \'E\': [\'F\'], \'F\': [] } start = \'A\' ``` Expected Output ```python # Example outputs for the given input dfs_visited = dfs_traverse(graph, start) # {\'A\', \'B\', \'C\', \'E\', \'F\', \'D\'} bfs_visited = bfs_traverse(graph, start) # {\'A\', \'B\', \'D\', \'C\', \'E\', \'F\'} new_graph, removed_edges = remove_cycles(graph) # new_graph should no longer contain any cycles # removed_edges should list all edges that were removed to break the cycles, e.g., [(\'C\', \'A\')] ``` # Constraints 1. You may assume that the graph is directed and represented using an adjacency list. 2. The graph may contain cycles, and all nodes are represented by unique string identifiers. 3. The graph may contain 0 or more nodes and edges. # Performance Requirements 1. The graph traversal functions should operate with a time complexity of O(V + E). 2. The cycle detection and removal function should aim for an efficient solution, ideally within O(V + E) time complexity.","solution":"def dfs_traverse(graph, start): Perform Depth First Search (DFS) traversal starting from \'start\' node. :param graph: Dictionary representing adjacency list of the graph. :param start: Starting node for the DFS traversal. :return: List of visited nodes in the order they were first visited. visited = [] stack = [start] while stack: node = stack.pop() if node not in visited: visited.append(node) stack.extend(reversed(graph[node])) # Add neighbors in reverse to maintain left -> right traversal return visited def bfs_traverse(graph, start): Perform Breadth First Search (BFS) traversal starting from \'start\' node. :param graph: Dictionary representing adjacency list of the graph. :param start: Starting node for the BFS traversal. :return: List of visited nodes in the order they were first visited. visited = [] queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.append(node) queue.extend(graph[node]) return visited def remove_cycles(graph): Detect and remove cycles in the graph using DFS approach. :param graph: Dictionary representing adjacency list of a directed graph. :return: A tuple containing: - The new graph with the cycles removed - A list of edges that were removed to break the cycles new_graph = {node: [] for node in graph} removed_edges = [] visited = set() stack = set() def visit(node): if node in visited: return visited.add(node) stack.add(node) for neighbor in graph[node]: if neighbor in stack: removed_edges.append((node, neighbor)) else: new_graph[node].append(neighbor) visit(neighbor) stack.remove(node) for node in graph: if node not in visited: visit(node) return new_graph, removed_edges"},{"question":"# Problem Scenario You\'re designing a software application where recent events need to be managed and processed in a LIFO (Last In, First Out) manner. All events need to be logged, and users should have the ability to undo the most recent event. Given such requirements, the stack data structure presents a perfect fit. # Problem Statement Implement a `MinStack` class which supports the following operations: - `push(int val)`: Pushes the element `val` onto the stack. - `pop()`: Removes the element on the top of the stack. - `top() -> int`: Gets the top element of the stack. - `get_min() -> int`: Retrieves the minimum element in the stack in constant time. You need to implement the `MinStack` class using both an array-based stack (`ArrayMinStack`) and a linked-list-based stack (`LinkedListMinStack`). The `MinStack` implementation must make use of these underlying stack implementations to manage normal stack operations (push, pop, top) while ensuring `get_min` operates in constant time. # Requirements * **Input**: Sequence of stack operations. * **Output**: Result of `top` and `get_min` operations when called. # Constraints * All methods must operate in constant time (O(1)). * Use the implementations provided in the earlier code snippets for the underlying stack operations. # Example ```python # Example usage: # Using ArrayMinStack min_stack = ArrayMinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) print(min_stack.get_min()) # -> Returns -3 min_stack.pop() print(min_stack.top()) # -> Returns 0 print(min_stack.get_min()) # -> Returns -2 # Using LinkedListMinStack min_stack = LinkedListMinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) print(min_stack.get_min()) # -> Returns -3 min_stack.pop() print(min_stack.top()) # -> Returns 0 print(min_stack.get_min()) # -> Returns -2 ``` # Implementation Hint Use an additional stack data structure to keep track of the minimum values.","solution":"class ArrayMinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: val = self.stack.pop() if val == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] return None def get_min(self) -> int: if self.min_stack: return self.min_stack[-1] return None class LinkedListMinStack: class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def __init__(self): self.head = None self.min_stack = [] def push(self, val: int) -> None: new_node = self.Node(val, self.head) self.head = new_node if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.head: if self.head.value == self.min_stack[-1]: self.min_stack.pop() self.head = self.head.next def top(self) -> int: if self.head: return self.head.value return None def get_min(self) -> int: if self.min_stack: return self.min_stack[-1] return None"},{"question":"Interpolation Search Challenge # Scenario: You\'ve been hired to help develop a file indexing system to quickly locate specific files based on their unique IDs. The file IDs in your system are sorted and uniformly distributed. To optimize search performance, you decide to use the Interpolation Search algorithm. # Task: Implement a function `interpolation_search(array, search_key)` that employs the Interpolation Search algorithm to find the position of a `search_key` in a given sorted array `array`. # Function Signature: ```python def interpolation_search(array: List[int], search_key: int) -> int ``` # Input: 1. `array`: A list of integers sorted in ascending order and uniformly distributed. 2. `search_key`: An integer representing the key to be searched for in the `array`. # Output: - Returns the index of `search_key` in `array` if `search_key` is found. - Returns `-1` if `search_key` is not present in the array. # Constraints: - The array `array` will have between `1` and `10^5` elements. - The integers in the array will be between `-10^6` and `10^6`. - The `search_key` will be between `-10^6` and `10^6`. # Performance Requirements: - Your implementation should have an average case time complexity of `O(log2(log2 n))`. # Example: ```python # Example 1 assert interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) == 2 # Example 2 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) == -1 # Example 3 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) == -1 ``` # Implementation Instructions: - Ensure you handle the case where division by zero might occur due to `arr[low]` being equal to `arr[high]`. - Make sure to test your function with edge cases, such as the smallest and largest elements in the array, and empty arrays. - You may include any additional helper functions necessary to keep your code organized.","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: # When the array contains identical values, return low if the target is found if array[low] == array[high]: if array[low] == search_key: return low else: return -1 # Estimate the position of the search_key pos = low + ((search_key - array[low]) * (high - low)) // (array[high] - array[low]) # Check if the estimated position holds the search_key if array[pos] == search_key: return pos # If search_key is larger, search in the right subarray if array[pos] < search_key: low = pos + 1 # If search_key is smaller, search in the left subarray else: high = pos - 1 return -1"},{"question":"# Question: Detect Repeated Substring Pattern Context Given a non-empty string, determine if it can be constructed by repeatedly appending copies of one of its substrings. This verification requires your function to return a boolean value indicating whether the string can be decomposed in such a manner. Function Description Implement a function `can_be_constructed` which takes: * **Input**: A single string `s` of length `1 ≤ |s| ≤ 10000`, composed only of lowercase English letters. * **Output**: A boolean value indicating whether the string `s` can be constructed by repeating a substring. Example ```python def can_be_constructed(s: str) -> bool: # Your implementation here # Example 1 print(can_be_constructed(\\"abab\\")) # Output: True # Example 2 print(can_be_constructed(\\"aba\\")) # Output: False # Example 3 print(can_be_constructed(\\"abcabcabcabc\\")) # Output: True ``` Constraints * Ensure the function runs efficiently (preferably O(N) time complexity). * Handle edge cases such as strings with a single character and non-repeating patterns gracefully. Additional Information * Avoid using Python\'s built-in functions that directly solve the problem for overly trivial solutions. * Consider performance in terms of both time and space complexity.","solution":"def can_be_constructed(s: str) -> bool: Determines if the given string can be constructed by repeating a substring. Args: s (str): The input string. Returns: bool: True if the string can be constructed by repeating a substring, False otherwise. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: if s[:i] * (n // i) == s: return True return False"},{"question":"# Question: Binary Tree Balance Checker You are given the task of determining if a given binary tree is balanced. In a balanced binary tree, the depth (or height) of the two subtrees of every node never differ by more than 1. Write a function `is_balanced(root)` that checks whether the binary tree with the given root node is balanced or not. Your function should use a bottom-up approach and run in O(N) time complexity, where N is the number of nodes in the tree. Function Signature: ```python def is_balanced(root) -> bool: ``` Input: * `root` - The root node of the binary tree. The tree node is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output: * Returns `True` if the binary tree is balanced, `False` otherwise. Constraints: * The number of nodes in the tree is in the range [0, 10^4]. * The values of the nodes can be any integer. Example: **Example 1:** ``` Input: 3 / 9 20 / 15 7 Output: True ``` **Example 2:** ``` Input: 1 / 2 / 3 Output: False ``` Your implementation should account for various edge cases, such as an empty tree, single-node trees, and highly skewed trees. Ensure that the solution is optimized and adheres to the specified complexity constraints.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root) -> bool: def height_and_balance(node): if not node: return 0, True left_height, left_balanced = height_and_balance(node.left) right_height, right_balanced = height_and_balance(node.right) current_height = max(left_height, right_height) + 1 is_current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, is_current_balanced _, balanced = height_and_balance(root) return balanced"},{"question":"# Question Context: You are responsible for managing a scheduling system where multiple events are defined by their starting and ending times. Events might overlap, and you need to merge them into non-overlapping intervals for better visualization and conflict management. Task: Implement a function `merge_event_intervals(intervals)` that takes a list of intervals and merges all overlapping intervals into a single interval. Function Signature: ```python def merge_event_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass ``` Input: - `intervals`: A list of tuples, where each tuple contains exactly two integers `(start, end)` representing the start and end time of an interval. It can be assumed that `0 <= start < end`. Output: - A list of merged event intervals, each represented as a tuple of two integers `(start, end)`. The intervals should be sorted by the start time. Constraints: - 1 ≤ number of intervals ≤ 10^4 Example: ```python # Example 1: intervals = [(1, 3), (2, 4), (5, 7), (6, 8)] print(merge_event_intervals(intervals)) # Output: [(1, 4), (5, 8)] # Example 2: intervals = [(1, 5), (2, 3), (4, 6)] print(merge_event_intervals(intervals)) # Output: [(1, 6)] ``` Requirements: - Solve the task with a time complexity of `O(n log n)` due to sorting. - Ensure the solution passes all common edge cases.","solution":"from typing import List, Tuple def merge_event_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: if not intervals: return [] # First sort the intervals by the start time intervals.sort(key=lambda x: x[0]) # Initialize the merged list with the first interval merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: merged_intervals[-1] = (last_merged[0], max(last_merged[1], current[1])) else: merged_intervals.append(current) return merged_intervals"},{"question":"As a software engineer, you are tasked with building a feature for a scheduling application. This feature will handle merging of time intervals to optimize and consolidate bookings efficiently. # Problem You are required to write a Python function `merge_bookings(bookings)` that takes a list of booking intervals and merges all overlapping intervals. Each interval is represented by a tuple `(start, end)` where: - `start` and `end` are integers representing the beginning and end of a booking respectively (`start < end`). - The input list is unsorted. Function Signature ```python def merge_bookings(bookings: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass ``` Input - `bookings`: A list of tuples where each tuple contains two integers; `start` and `end` values of the intervals. Output - A list of merged intervals represented as tuples. Example ```python # Example 1 bookings = [(1, 3), (2, 6), (8, 10), (15, 18)] # Overlapping intervals (1, 3) and (2, 6) will be merged. # Expected Output: [(1, 6), (8, 10), (15, 18)] # Example 2 bookings = [(1, 4), (4, 5)] # Adjacent intervals (1, 4) and (4, 5) will be merged. # Expected Output: [(1, 5)] ``` Constraints - All bookings contain integers such that `0 <= start < end <= 10^5`. - Multiple intervals can be merged into a larger interval. # Performance Requirements Ensure that your solution can handle the case where the `bookings` list contains up to `10^4` intervals efficiently. Hints - Consider sorting the intervals first. - Check how you can merge intervals by iterating through the sorted list.","solution":"from typing import List, Tuple def merge_bookings(bookings: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges all overlapping booking intervals. Args: bookings (List[Tuple[int, int]]): The list of booking intervals. Returns: List[Tuple[int, int]]: The list of merged intervals. if not bookings: return [] # Sort bookings by start time bookings.sort(key=lambda x: x[0]) merged = [] current_start, current_end = bookings[0] for start, end in bookings[1:]: if start <= current_end: # Overlapping intervals current_end = max(current_end, end) else: merged.append((current_start, current_end)) current_start, current_end = start, end # Add the last interval merged.append((current_start, current_end)) return merged"},{"question":"Problem Statement You are tasked with implementing a function `fizzbuzz` that generates a sequence of numbers from 1 to N, but with a twist. The function should return an array where: * Each multiple of 3 is replaced by the string \\"Fizz.\\" * Each multiple of 5 is replaced by the string \\"Buzz.\\" * Each multiple of both 3 and 5 is replaced by the string \\"FizzBuzz.\\" * Other numbers remain as they are. If the input is less than 1, the function should raise a `ValueError`. If the input is not an integer, it should raise a `TypeError`. Function Signature ```python def fizzbuzz(n: int) -> list: pass ``` Input * `n` (int): An integer where (1 leq n leq 10^4) Output * `list`: A list of numbers and/or strings following the rules mentioned above. Examples ```python fizzbuzz(1) # Output: [1] fizzbuzz(3) # Output: [1, 2, \'Fizz\'] fizzbuzz(5) # Output: [1, 2, \'Fizz\', 4, \'Buzz\'] fizzbuzz(15) # Output: [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] ``` Notes * Ensure that the solution is efficient and correctly handles the edge cases, including non-integer input and out-of-bound values. # Additional Considerations * Handle errors gracefully using Python exceptions.","solution":"def fizzbuzz(n: int) -> list: if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n < 1: raise ValueError(\\"Input must be a positive integer greater than 0\\") result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(i) return result"},{"question":"The purpose of this exercise is to evaluate your understanding of dynamic programming and optimization using data structures like segment trees. You will be required to implement the function to find the length of the Longest Increasing Subsequence (LIS) in a given sequence of integers. # Problem Statement Given an unsorted array of integers, write a function `longest_increasing_subsequence` to find the length of the longest increasing subsequence. Function Signature ```python def longest_increasing_subsequence(sequence: List[int]) -> int: ``` Input - `sequence` (List[int]): A list of integers representing the sequence. Output - Returns an integer, the length of the longest increasing subsequence. Constraints - The sequence can be empty, in which case the function should return 0. - The sequence length will not exceed 10^4. - Integer values in the sequence can be as large as can fit in a signed 32-bit integer. Performance Requirements - Your function should aim for a time complexity of O(n log n), ensuring it handles large sequences efficiently. # Example ```python assert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 # Explanation: [2, 3, 7, 101] assert longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4 # Explanation: [0, 1, 2, 3] assert longest_increasing_subsequence([]) == 0 assert longest_increasing_subsequence([7]) == 1 ``` Implement the function that meets the requirements and passes all the example cases. Additional Notes Focus on writing clean, efficient, and well-documented code. Handle edge cases such as empty arrays or single-element arrays gracefully.","solution":"from typing import List import bisect def longest_increasing_subsequence(sequence: List[int]) -> int: Finds the length of the longest increasing subsequence in a list of integers. Parameters: sequence (List[int]): A list of integers. Returns: int: The length of the longest increasing subsequence. if not sequence: return 0 # List that maintains the ends of potential increasing subsequences lis = [] for num in sequence: # Find the index at which \'num\' should be inserted in \'lis\' pos = bisect.bisect_left(lis, num) # If \'pos\' is equal to the length of \'lis\', append \'num\' to \'lis\' if pos == len(lis): lis.append(num) else: # Otherwise, replace the element at \'pos\' with \'num\' lis[pos] = num return len(lis)"},{"question":"# Scenario You are enlisted to help optimize the sorting process of pancakes on a kitchen conveyor belt. Each pancake has a distinct size, and they need to be sorted from smallest to largest. The only operation allowed is to use a spatula to flip (reverse) the order of the top few pancakes. Implement the Pancake Sort algorithm to sort the given list of pancakes. # Instructions Given an array of positive integers representing pancake sizes, write a function to sort the array using the Pancake Sort algorithm. # Function Signature ```python def pancake_sort(pancakes: List[int]) -> List[int]: # your code here ``` # Input * `pancakes`: A list of positive integers representing the sizes of pancakes. (1 ≤ pancakes[i] ≤ 10^3 and 1 ≤ len(pancakes) ≤ 100) # Output * Returns a list of integers representing the sorted order of cakes. # Example Input ```python pancakes = [3, 2, 4, 1] ``` Output ```python [1, 2, 3, 4] ``` # Constraints * The function should operate in (O(N^2)) time complexity. * You are allowed to use only the `reverse()` method to flip the order of elements in the list. Implement the Pancake Sort function to solve this problem.","solution":"from typing import List def pancake_sort(pancakes: List[int]) -> List[int]: def flip(arr: List[int], k: int) -> None: Function to reverse the order of the first k elements of the array. arr[:k+1] = arr[:k+1][::-1] N = len(pancakes) for size in range(N, 1, -1): # Find the index of the largest pancake within the unsorted section max_index = max(range(size), key=lambda i: pancakes[i]) if max_index != size - 1: # Flip the largest pancake to the top flip(pancakes, max_index) # Flip the largest pancake to its correct position flip(pancakes, size - 1) return pancakes"},{"question":"You are tasked with implementing parts of the Diffie-Hellman key exchange system. Specifically, you need to create functions that perform the following: 1. Prime check for a given number. 2. Finding a primitive root for a given prime number `p`. 3. Completing the Diffie-Hellman key exchange given a prime `p` and its primitive root `a`, ensuring that Alice and Bob generate a shared secret key correctly. # Function Signatures Implement the following functions: ```python def is_prime(num: int) -> bool: Return True if num is a prime number, otherwise return False. pass def primitive_root(p: int) -> int: Return a primitive root of the prime number p. If no primitive root exists, return -1. pass def diffie_hellman_exchange(p: int, a: int) -> int: Perform the Diffie-Hellman key exchange using prime number p and its primitive root a. Return the shared secret key. pass ``` # Input * `num` in `is_prime(num)`: A positive integer to check for primality. * `p` in `primitive_root(p)`: A prime number to find its primitive root. * `p` and `a` in `diffie_hellman_exchange(p, a)`: `p` is a large prime number and `a` is its primitive root. # Output * Return a boolean value in `is_prime(num)`. * Return an integer in `primitive_root(p)`. * Return the shared secret key in `diffie_hellman_exchange(p, a)`. # Constraints 1. `1 ≤ num ≤ 10^6` 2. `1 ≤ p ≤ 10^6` 3. `1 ≤ a ≤ p-1` # Example ```python # Example 1: print(is_prime(11)) # True print(primitive_root(11)) # e.g., 2 print(diffie_hellman_exchange(23, 5)) # A consistent secret key generated by Diffie-Hellman # Example 2: print(is_prime(15)) # False print(primitive_root(15)) # -1 print(diffie_hellman_exchange(23, 4)) # False (4 is not a valid primitive root for 23) ``` # Explanation * The `is_prime` function verifies the primality of a number. * The `primitive_root` function finds the smallest positive primitive root of `p`. * The `diffie_hellman_exchange` function simulates their key exchange and calculates the shared secret key, returning it. **Note**: For testing purposes, avoiding print statements is recommended. Return the calculated output directly.","solution":"from math import gcd def is_prime(num: int) -> bool: Return True if num is a prime number, otherwise return False. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def primitive_root(p: int) -> int: Return a primitive root of the prime number p. If no primitive root exists, return -1. if not is_prime(p): return -1 def powmod(a, b, m): res = 1 a = a % m while b > 0: if (b % 2) == 1: res = (res * a) % m b = b >> 1 a = (a * a) % m return res required_set = set(num for num in range(1, p) if gcd(num, p) == 1) for g in range(2, p): actual_set = set(powmod(g, powers, p) for powers in range(1, p)) if required_set == actual_set: return g return -1 def diffie_hellman_exchange(p: int, a: int) -> int: Perform the Diffie-Hellman key exchange using prime number p and its primitive root a. Return the shared secret key. if not is_prime(p): return -1 if primitive_root(p) != a: return -1 private_key_alice = 6 # simulated private key for Alice private_key_bob = 15 # simulated private key for Bob A = pow(a, private_key_alice, p) B = pow(a, private_key_bob, p) shared_secret_key_a = pow(B, private_key_alice, p) shared_secret_key_b = pow(A, private_key_bob, p) assert shared_secret_key_a == shared_secret_key_b return shared_secret_key_a"},{"question":"Find the Nth Digit in an Infinite Sequence In an infinite sequence of integers where all positive numbers are concatenated together, find the nth digit of this sequence. # Example If the sequence looks like \\"1234567891011121314...\\", the digit positions would map as follows: * 1 → \'1\' * 2 → \'2\' * 10 → \'1\' (since sequence runs 12345678910...) * 11 → \'0\' # Input An integer `n` (1 ≤ n ≤ 2^31 -1). # Output An integer participating as the nth digit in the sequence. # Function Signature ```python def find_nth_digit(n: int) -> int: ``` # Constraints * The integer `n` ranges maximally within typical system handling but backed properly by conceptual operations. * Performance is crucial, hence O(log n) complexity must be aimed for. * Iterative and memory-efficient solutions desired to handle upper bounds constraints over typical edge cases.","solution":"def find_nth_digit(n: int) -> int: Find the nth digit in the infinite concatenated sequence of all positive integers. length = 1 # Current length of numbers being considered count = 9 # Count of numbers with the current length start = 1 # Starting number with the current length # Find the range that the nth digit falls into while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the exact number that contains the nth digit start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"# Knapsack Problem with Repeated Items Scenario In a warehouse management system for an online shopping platform, you need to maximize the total value of items loaded onto a delivery truck without exceeding its weight capacity. Each item has a distinct value and weight, and you can load multiple units of the same item. Your task is to write a function that determines the maximum value that can be achieved given the truck\'s capacity, leveraging the repeated item knapsack algorithm. Task Write a function `max_delivery_value(items, capacity)` where: * `items` is a list of tuples where each tuple contains two integers `(value, weight)` representing the value and weight of an item respectively. * `capacity` is an integer representing the maximum weight that the delivery truck can carry. The function should return an integer representing the maximum total value of items that can be loaded onto the truck without exceeding its weight capacity. Input Format * `items`: List of tuples, where each tuple (i) `(value_i, weight_i)` - `0 < value_i <= 1000` - `0 < weight_i <= 1000` * `capacity`: Integer (1 <= capacity <= 10^4) Output Format * Integer representing the maximum value that can be achieved. Constraints: * All item weights and the capacity are positive integers. * There are at most 100 items. Example ```python # Example 1: items = [(60, 5), (50, 3), (70, 4), (30, 2)] capacity = 5 # Explanation: Optimal items are (50, 3) and (30, 2) max_delivery_value(items, capacity) => 80 # Example 2: items = [(100, 1), (200, 2), (50, 1)] capacity = 2 # Explanation: Optimal items are (200, 2) max_delivery_value(items, capacity) => 200 # Example 3: items = [(100, 10)] capacity = 5 # Explanation: Not possible to fit the item max_delivery_value(items, capacity) => 0 ``` The solution should emphasize the correct use of dynamic programming, accurate handling of edge cases, and optimization techniques.","solution":"def max_delivery_value(items, capacity): Determines the maximum value that can be achieved with the given capacity. :param items: List of tuples where each tuple contains (value, weight) of an item :param capacity: Maximum weight the delivery truck can carry :return: Maximum total value of items # Initialize an array to store the maximum value for each capacity dp = [0] * (capacity + 1) # Update the dp array for each item for value, weight in items: for w in range(weight, capacity + 1): dp[w] = max(dp[w], dp[w - weight] + value) return dp[capacity]"},{"question":"You are given a list of non-negative integers representing a non-negative number, where each element in the array corresponds to a digit of the number in base 10. The digits are stored in big-endian order (most significant digit first). Your task is to write a function that adds one to this number and returns it as a new list of digits. # Function Signature ```python def add_one_to_digits(digits: List[int]) -> List[int]: ``` # Input - `digits`: A list of integers where each integer `digits[i]` is in the range [0, 9]. # Output - A list of integers representing the incremented number in the same format. # Constraints - The length of `digits` will be between 1 and 10^4. - The input list will not be empty. - All leading digits will be non-zero except in the case where the input is [0]. # Example ```python assert add_one_to_digits([1, 2, 3]) == [1, 2, 4] assert add_one_to_digits([9, 9, 9]) == [1, 0, 0, 0] assert add_one_to_digits([0]) == [1] assert add_one_to_digits([2, 9, 9]) == [3, 0, 0] ``` # Scenario Imagine you are designing a simple calculator that operates on very large numbers stored in an array format. One of the basic operations is to increment the number by one. Your task is to implement this operation efficiently, handling edge cases and carry propagation properly. # Requirements - Implement the function considering the edge cases discussed. - Ensure optimal performance, especially for large inputs. - Test your function with a variety of test cases to ensure correctness and reliability.","solution":"def add_one_to_digits(digits): Adds one to the given list of digits representing a number. Args: digits (List[int]): A list of integers where each integer is in the range [0, 9]. Returns: List[int]: A list of integers representing the incremented number. n = len(digits) # Start adding one from the last digit. for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If all digits were 9, at the end we have to add 1 at the beginning of the list. return [1] + [0] * n"},{"question":"# Problem Description You have been tasked with implementing a new feature for a data analysis application. This feature needs to efficiently handle a large number of range queries and updates on an array of data. Your job is to implement a `SegmentTree` class to support this functionality. The class should allow range queries and point updates efficiently using a commutative function provided during the tree\'s initialization. # Detailed Requirements: 1. **Initialization**: - The constructor should take two arguments - an input list `arr` and a function `fn`. - This function `fn` should be a commutative function used to aggregate the results (e.g., `max`, `sum`). 2. **Methods**: - `build_tree`: Internal method to construct the segment tree from the given input list. - `update(p, v)`: Update the value at index `p` to `v` and adjust the segment tree accordingly. - `query(l, r)`: Query the segment tree to get the aggregated result from index `l` to `r` using the provided function `fn`. # Function Signature: Here\'s the function signature for your implementation: ```python class SegmentTree: def __init__(self, arr, function): pass def build_tree(self): pass def update(self, p, v): pass def query(self, l, r): pass ``` # Constraints - `arr` will contain elements of a type that supports the provided function `fn`. - The length of `arr` will be at most `10^5`. - Query and update operations will be called multiple times (up to `10^5` calls each). # Example Usage ```python # Example 1 mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(2, 4)) # Expected Output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Expected Output: 6 # Example 2 mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(mytree.query(0, 6)) # Expected Output: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Expected Output: 52 # Example 3 mytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) print(mytree.query(0, 2)) # Expected Output: (9, 13) mytree.update(2, (-1, 2)) print(mytree.query(0, 2)) # Expected Output: (4, 10) ```","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.arr = arr self.fn = function self.tree = [None] * (2 * self.n) self.build_tree() def build_tree(self): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = self.arr[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.fn(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, p, v): # Update the value at the leaf p += self.n self.tree[p] = v # Update internal nodes while p > 1: self.tree[p // 2] = self.fn(self.tree[p], self.tree[p ^ 1]) p //= 2 def query(self, l, r): l += self.n r += self.n + 1 res = None while l < r: if l % 2: res = self.tree[l] if res is None else self.fn(res, self.tree[l]) l += 1 if r % 2: r -= 1 res = self.tree[r] if res is None else self.fn(res, self.tree[r]) l //= 2 r //= 2 return res"},{"question":"You are given a singly linked list, and your task is to write a function that reverses the list from a given position `m` to `n`. The positions are 1-based indices where 1 ≤ m ≤ n ≤ the length of the list. Your function should perform the reversal in-place and return the head of the modified list. # Function Signature: ```python def reverse_between(head: ListNode, m: int, n: int) -> ListNode: # your code here ``` # Input: 1. `head` (ListNode): The head of the singly linked list. 2. `m` (int): The starting position for the reversal. 3. `n` (int): The ending position for the reversal. # Output: - Returns the head of the singly linked list after reversing the nodes from position `m` to `n`. # Example: **Input:** ``` Linked List: 1 -> 2 -> 3 -> 4 -> 5 m = 2, n = 4 ``` **Output:** ``` 1 -> 4 -> 3 -> 2 -> 5 ``` # Constraints: - The length of the linked list is at least 1. - m and n are valid and within the bounds of the list\'s length. - Your solution should have a time complexity of O(n) and a space complexity of O(1). # Notes: - Consider edge cases, such as when m = n (no reversal needed), when the list is empty, or comprises a single node. - Modify the list in place without using extra space for another list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_between(head: ListNode, m: int, n: int) -> ListNode: if not head or m == n: return head dummy = ListNode(0) dummy.next = head prev = dummy for _ in range(m - 1): prev = prev.next reversal_tail = prev.next curr = reversal_tail.next for _ in range(n - m): reversal_tail.next = curr.next curr.next = prev.next prev.next = curr curr = reversal_tail.next return dummy.next"},{"question":"# RSA Encryption Algorithm Implementation and Enhancement In this task, you will implement and enhance an RSA encryption system. # Context For secure communication, you often need a secure way to encrypt messages so that only the intended recipient can decrypt them. RSA is a widely used encryption algorithm that relies on the computational difficulty of factoring large numbers. # Problem Statement 1. **Key Generation**: - Implement a function `generate_key(k, seed=None)` which generates public and private keys for RSA encryption, with **k** bits in the modulus n. - Ensure primes ( p ) and ( q ) are truly prime and ( k ) bits in size. 2. **Message Encryption**: - Write a function `encrypt(data, e, n)` that takes a plaintext message **data**, public key exponent **e**, and modulus **n** and returns the encrypted message. 3. **Message Decryption**: - Write a function `decrypt(encrypted, d, n)` that takes an encrypted message **encrypted**, private key exponent **d**, and modulus **n** and returns the decrypted plaintext. 4. **Enhanced Key Generation**: - Enhance the `generate_key` function to add optimizations. Use more efficient methods to generate larger primes and new techniques which help in secure key generation. # Function Signatures ```python def generate_key(k, seed=None): pass def encrypt(data, e, n): pass def decrypt(encrypted, d, n): pass ``` # Input Constraints - **k**: (32 <= k <= 1024) specifying the bit length of n. - **data**: an integer (0 <= data < n). # Output - **generate_key**: Should return a tuple (n, e, d) consisting of the modulus, encryption exponent, and decryption exponent. - **encrypt**: Should return an integer representing the encrypted message. - **decrypt**: Should return an integer representing the decrypted message. # Performance Requirements - Ensure efficient prime generation by using optimized primality tests. - Optimize modular arithmetic operations where necessary. # Edge Cases to Handle - Ensure primes ( p ) and ( q ) satisfy ( p neq q ) and ( p, q ) are sufficiently large. - Handle situation if data is zero or close to n. # Example ```python # Example usage n, e, d = generate_key(64) message = 12345 encrypted_msg = encrypt(message, e, n) decrypted_msg = decrypt(encrypted_msg, d, n) assert message == decrypted_msg ```","solution":"import random from sympy import isprime, mod_inverse def generate_prime_candidate(length): # Generate random bits and ensure the MSB and LSB are 1 p = random.getrandbits(length) p |= (1 << length - 1) | 1 return p def generate_prime_number(length): p = 4 while not isprime(p): p = generate_prime_candidate(length) return p def generate_key(k, seed=None): if seed is not None: random.seed(seed) # Ensure that the primes p and q are k//2 bits long p = generate_prime_number(k // 2) q = generate_prime_number(k // 2) while q == p: q = generate_prime_number(k // 2) n = p * q phi = (p - 1) * (q - 1) e = 65537 # Commonly used prime exponent d = mod_inverse(e, phi) return (n, e, d) def encrypt(data, e, n): return pow(data, e, n) def decrypt(encrypted, d, n): return pow(encrypted, d, n)"},{"question":"You are given a list of integers that you need to sort using the selection sort algorithm. You are asked to implement a modified version of this algorithm that sorts the array in descending order and outputs the intermediate states of the list after each iteration. # Task Write a function `selection_sort_desc(arr)` that takes a list of integers `arr` and sorts it in descending order using the selection sort algorithm. The function should print the state of the array after each complete pass through the list. # Input - A list of integers `arr` where 1 ≤ len(arr) ≤ 1000 and -10^6 ≤ arr[i] ≤ 10^6 for each integer `arr[i]`. # Output - The function should print the state of the array after each sorting pass through the list. # Example Input: ```python arr = [5, 3, 8, 4, 2] ``` Output: ``` iteration 0 : 8 3 5 4 2 iteration 1 : 8 5 3 4 2 iteration 2 : 8 5 4 3 2 iteration 3 : 8 5 4 3 2 iteration 4 : 8 5 4 3 2 ``` # Constraints - The function should sort the array in descending order. - The function should print the state of the array after each complete pass. - The function should work within the constraints without exceeding the time limit. # Note You should assume the initial step (iteration -1) doesn\'t need to be printed. # Function Signature ```python def selection_sort_desc(arr: List[int]) -> None: pass ```","solution":"def selection_sort_desc(arr): Sorts a list of integers in descending order using the selection sort algorithm. Prints the state of the array after each complete pass through the list. n = len(arr) for i in range(n): # Find the maximum element in the remaining unsorted array max_idx = i for j in range(i + 1, n): if arr[j] > arr[max_idx]: max_idx = j # Swap the found maximum element with the first element of the unsorted part arr[i], arr[max_idx] = arr[max_idx], arr[i] # Print the state of the array after each iteration print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\")"},{"question":"# Question: Implement Custom RLE Compressor and Decompressor Run-Length Encoding (RLE) is a data compression technique where sequences of the same data are stored as a single data value and a count. Your task is to implement an advanced version of RLE compression and decompression that allows for custom delimiters. Requirements: 1. Implement a function `custom_rle_encode(message: str, delimiter: str) -> str`: - **Input**: - `message` (string): The input message to be encoded. - `delimiter` (string): A single character used to separate counts from characters in the encoded string. - **Output**: A run-length encoded string. - **Constraints**: - The message will contain only alphanumeric characters (\'a-z\', \'A-Z\', \'0-9\'). - The delimiter will be a single, non-alphanumeric character. - The message length will be between 1 and 1000. 2. Implement a function `custom_rle_decode(encoded_message: str, delimiter: str) -> str`: - **Input**: - `encoded_message` (string): The input message to be decoded. - `delimiter` (string): The delimiter used in the encoded message. - **Output**: The original message before encoding. - **Constraints**: - The encoded message will contain only valid encoded characters as per the RLE format. - The delimiter will be a single, non-alphanumeric character. Example: ```python # Example Usage # Encoding msg = \\"aaabbccccd\\" delimiter = \\"-\\" encoded_msg = custom_rle_encode(msg, delimiter) # encoded_msg should be \\"3-a2-b4-c1-d\\" # Decoding decoded_msg = custom_rle_decode(encoded_msg, delimiter) # decoded_msg should be \\"aaabbccccd\\" ``` Make sure to handle edge cases, such as empty strings and strings without repetition of characters. Performance: - Ensure that your solution has a time complexity of O(n) and uses space efficiently for both encoding and decoding functions.","solution":"def custom_rle_encode(message: str, delimiter: str) -> str: Encodes the input message using the custom RLE method with the given delimiter. if not message: return \\"\\" encoded_message = [] count = 1 for i in range(1, len(message)): if message[i] == message[i-1]: count += 1 else: encoded_message.append(f\\"{count}{delimiter}{message[i-1]}\\") count = 1 # Append the last batch encoded_message.append(f\\"{count}{delimiter}{message[-1]}\\") return \'\'.join(encoded_message) def custom_rle_decode(encoded_message: str, delimiter: str) -> str: Decodes the encoded message using the custom RLE method with the given delimiter. if not encoded_message: return \\"\\" decoded_message = [] i = 0 length = len(encoded_message) while i < length: count_str = [] while i < length and encoded_message[i].isdigit(): count_str.append(encoded_message[i]) i += 1 count = int(\'\'.join(count_str)) i += 1 # skip the delimiter decoded_message.append(encoded_message[i] * count) i += 1 return \'\'.join(decoded_message)"},{"question":"Given the Fibonacci sequence defined by the recurrence relation: [ F_0 = 0, , F_1 = 1 ] [ F_n = F_{n-1} + F_{n-2} , text{for} , n > 1 ] Implement a Python function to compute the n-th Fibonacci number using an optimized approach. # Requirements: * Implement the function `fib_optimized(n: int) -> int` which computes the n-th Fibonacci number. * The function should handle large values of n efficiently. * **Constraints**: * Input ( n ) will be a non-negative integer. * The function should work for large values of n (e.g., up to 1,000,000). # Expected Function Signature: ```python def fib_optimized(n: int) -> int: pass ``` # Example: ```python assert fib_optimized(10) == 55 assert fib_optimized(50) == 12586269025 ``` # Explanation: * If ( n = 10 ), the function returns 55 because the 10th Fibonacci number is 55. * If ( n = 50 ), the function returns 12586269025 because the 50th Fibonacci number is 12586269025. # Additional Considerations: * Your implementation should not use excessive memory. * Consider edge cases such as ( n = 0 ) and ( n = 1 ). * Ensure the function handles very large values of ( n ) efficiently.","solution":"def fib_optimized(n: int) -> int: Computes the n-th Fibonacci number using an optimized approach. Parameters: n (int): The position of the Fibonacci sequence to compute. Returns: int: The n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Problem: Optimized Shell Sort You have been given an array of integers that you need to sort using the Shell Sort algorithm. The objective is to implement an optimized version of Shell Sort using an efficient gap sequence for improved performance. # Function Signature ```python def optimized_shell_sort(arr: List[int]) -> List[int]: # Your code here ``` # Input * `arr` : List[int] — A list of integers that need to be sorted. # Output * The function should return a newly sorted list of integers. # Constraints * The length of the array should be between 1 and 10^5. * Each element in the array can be between -10^9 and 10^9. # Performance Requirements * Aim to choose an efficient gap sequence to minimize the number of comparisons and swaps. * Your implementation should be capable of handling the worst-case scenario with respect to the given array length and element range. # Example ```python input_array = [12, 34, 54, 2, 3] output_array = optimized_shell_sort(input_array) # Expected output: [2, 3, 12, 34, 54] input_array = [88, -32, -9, 0, 5, 71, 1] output_array = optimized_shell_sort(input_array) # Expected output: [-32, -9, 0, 1, 5, 71, 88] ``` # Notes * Consider implementing the Hibbard or Sedgewick gap sequence to improve performance. * Ensure the function is well-documented with comments explaining the choice of gap and key steps in the algorithm.","solution":"from typing import List def optimized_shell_sort(arr: List[int]) -> List[int]: Sorts an array of integers using an optimized Shell Sort algorithm with Sedgewick gaps. def sedgewick_gaps(n): gaps = [] k = 0 gap1, gap2 = 1, 1 while True: gap1 = 9 * (4 ** k) - 9 * (2 ** k) + 1 gap2 = 4 ** (k + 2) - 3 * (2 ** (k + 2)) + 1 if gap1 < n: gaps.append(gap1) if gap2 < n: gaps.append(gap2) if gap1 >= n and gap2 >= n: break k += 1 gaps.sort(reverse=True) return gaps n = len(arr) gaps = sedgewick_gaps(n) for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Context You\'ve been employed to improve and implement a more efficient sorting mechanism for a company\'s internal data processing system. The data consists of large datasets with known bounds, including negative and positive integers. The goal is to use Counting Sort to handle ranges with potentially large data sets efficiently. # Problem Write a function `efficient_counting_sort(arr)` that: * Takes a list of integers `arr` (which can include both negative and positive integers). * Sorts the list using a mechanism based on the provided Counting Sort algorithm. # Requirements: 1. **Input**: A list `arr` of integers. 2. **Output**: A sorted list of integers. # Constraints: 1. The integers in `arr` can range between -10^6 and 10^6. 2. The length of `arr` will not exceed 10^5 elements. # Performance: The algorithm should aim for O(n + k) time complexity, where n is the number of elements in the array and k is the range of the input values. # Example: ```python input_arr = [-5, -10, 0, 5, 3, -1] output_arr = efficient_counting_sort(input_arr) print(output_arr) # Output should be: [-10, -5, -1, 0, 3, 5] ``` # Implementation: ```python def efficient_counting_sort(arr): # Your code here pass # Example usage input_arr = [-5, -10, 0, 5, 3, -1] output_arr = efficient_counting_sort(input_arr) print(output_arr) # Should output: [-10, -5, -1, 0, 3, 5] ```","solution":"def efficient_counting_sort(arr): if len(arr) == 0: return [] min_val = min(arr) max_val = max(arr) range_of_elements = max_val - min_val + 1 # Initialize count array count = [0] * range_of_elements output = [0] * len(arr) # Store count of each element for num in arr: count[num - min_val] += 1 # Store the cumulative count of each array for i in range(1, len(count)): count[i] += count[i - 1] # Place the elements in output array based on the cumulative count for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"# Question: Cholesky Decomposition Implementation and Utilization You need to implement a function to perform Cholesky decomposition on a given Hermitian positive-definite matrix, and then use it to solve a system of linear equations. A brief scenario is provided below. Problem Scenario: You are given a system of linear equations represented by a matrix A and a vector b. Your task is to first decompose matrix A using Cholesky decomposition and then solve the equation Ax = b for x. # Function Instructions: 1. **Function 1: cholesky_decomposition(A)** This function takes as input a square, Hermitian positive-definite matrix `A` and decomposes it. **Input:** * `A` (List[List[float]]): A Hermitian positive-definite matrix. **Output:** * Lower triangular matrix `V` (List[List[float]]) such that `A = VV*`. 2. **Function 2: solve_linear_equation(V, b)** This function takes the decomposed matrix `V` and a vector `b` to solve for `x` in the equation Ax = b. **Input:** * `V` (List[List[float]]): The lower triangular matrix from the Cholesky decomposition. * `b` (List[float]): A numeric vector representing the constants in the system of linear equations. **Output:** * Solution vector `x` (List[float]). # Constraints: * Matrix A will always be of size n x n with `2 <= n <= 100`. * The vector b will have length n. # Examples ```python # Example 1: A = [ [4, 12, -16], [12, 37, -43], [-16, -43, 98] ] b = [1, 2, 3] Expected output: [ [2.0, 0.0, 0.0], [6.0, 1.0, 0.0], [-8.0, 5.0, 3.0] ] Cholesky decomposed matrix result: [[2.0, 0.0, 0.0], [6.0, 1.0, 0.0], [-8.0, 5.0, 3.0]] Solution Vector `x` for Ax = b is: [...values of x...] ``` # Note: - The solution vector `x` should be calculated considering the numerical stability. - Mention any assumptions or notes if needed.","solution":"import math def cholesky_decomposition(A): Perform Cholesky decomposition on a given Hermitian positive-definite matrix A. :param A: List[List[float]], Hermitian positive-definite matrix. :return: V (List[List[float]]), Lower triangular matrix such that A = VV*. n = len(A) V = [[0.0]*n for _ in range(n)] for i in range(n): for j in range(i+1): if i == j: sum_val = sum(V[i][k] ** 2 for k in range(j)) V[i][j] = math.sqrt(A[i][i] - sum_val) else: sum_val = sum(V[i][k] * V[j][k] for k in range(j)) V[i][j] = (A[i][j] - sum_val) / V[j][j] return V def solve_linear_equation(V, b): Solve the system of equations Ax = b using the Cholesky decomposed matrix V. :param V: List[List[float]], Lower triangular matrix from Cholesky decomposition. :param b: List[float], representing the constants in the system of linear equations. :return: x (List[float]), Solution vector. n = len(V) # Forward substitution to solve V*y = b y = [0.0] * n for i in range(n): sum_val = sum(V[i][k] * y[k] for k in range(i)) y[i] = (b[i] - sum_val) / V[i][i] # Back substitution to solve V^T*x = y x = [0.0] * n for i in range(n-1, -1, -1): sum_val = sum(V[k][i] * x[k] for k in range(i+1, n)) x[i] = (y[i] - sum_val) / V[i][i] return x"},{"question":"You are given an undirected graph represented as an adjacency list. Your task is to implement three functions to find different paths between two nodes. The graph and nodes are represented in a dictionary where keys are node identifiers, and values are lists of adjacent nodes. # Functions to Implement: 1. **find_path(graph: dict, start: str, end: str) -> list**: * Finds any path from `start` to `end`. * If such a path exists, return it as a list of nodes. * If no path exists, return `None`. 2. **find_all_path(graph: dict, start: str, end: str) -> list**: * Finds all possible paths from `start` to `end`. * Return a list of lists, with each inner list representing a possible path. * If no paths exist, return an empty list. 3. **find_shortest_path(graph: dict, start: str, end: str) -> list**: * Finds the shortest path from `start` to `end`. * If such a path exists, return it as a list of nodes. * If no path exists, return `None`. Input Constraints: - The graph is connected and undirected. - Nodes are unique and given as strings. # Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } print(find_path(graph, \'A\', \'F\')) # Example output: [\'A\', \'C\', \'F\'] or [\'A\', \'B\', \'E\', \'F\'] print(find_all_path(graph, \'A\', \'F\')) # Example output: [[\'A\', \'C\', \'F\'], [\'A\', \'B\', \'E\', \'F\']] print(find_shortest_path(graph, \'A\', \'F\')) # Example output: [\'A\', \'C\', \'F\'] ``` # Notes: - You cannot use any external libraries for graph traversal. - Handle edge cases such as non-existent nodes or paths appropriately. - Ensure your code performs efficiently on larger graph sizes.","solution":"def find_path(graph, start, end, path=[]): path = path + [start] if start == end: return path if start not in graph: return None for node in graph[start]: if node not in path: new_path = find_path(graph, node, end, path) if new_path: return new_path return None def find_all_paths(graph, start, end, path=[]): path = path + [start] if start == end: return [path] if start not in graph: return [] paths = [] for node in graph[start]: if node not in path: newpaths = find_all_paths(graph, node, end, path) for newpath in newpaths: paths.append(newpath) return paths def find_shortest_path(graph, start, end): from collections import deque queue = deque([(start, [start])]) while queue: (vertex, path) = queue.popleft() for next in graph[vertex]: if next not in path: if next == end: return path + [next] else: queue.append((next, path + [next])) return None"},{"question":"Given a Binary Search Tree (BST) and an integer k, write a function `kth_largest` that returns the k-th largest element in the BST. You need to implement this function using an efficient approach both in terms of time and space complexity. # Input and Output Specifications 1. **Input Format**: * A root node `root` of the BST. * An integer `k` representing the position (1-indexed) of the element in the sorted order from the highest. 2. **Output Format**: * An integer representing the k-th largest element in the BST. # Constraints * 1 <= k <= Number of nodes in the BST. * Each node\'s value in the BST is distinct. # Example ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def kth_largest(root, k): # Your code here if __name__ == \'__main__\': n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 print(kth_largest(n1, 2)) # Should print 150 (2nd largest element) print(kth_largest(n1, 5)) # Should print 75 (5th largest element) ``` # Note Provide an efficient solution that avoids storing all the elements of the tree explicitly in way similar to the first code snippet focusing on time complexity O(H + k) and space complexity O(H).","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def kth_largest(root, k): Returns the k-th largest element in the BST. def reverse_inorder_traversal(node): if node is None: return yield from reverse_inorder_traversal(node.right) yield node.val yield from reverse_inorder_traversal(node.left) generator = reverse_inorder_traversal(root) kth_value = None for _ in range(k): kth_value = next(generator) return kth_value"},{"question":"**Scenario**: You are developing a feature for a gaming application that involves managing a collection of game objects. Players can add new game objects, remove existing ones, and a random game object can be selected as part of gameplay. You need to provide a data structure that supports these operations efficiently. # Task **Design and implement a data structure named `GameObjectSet` with the following methods:** * `add_object(obj_id: int) -> bool`: * Adds a unique game object identifier `obj_id` to the set if it is not already present. * Returns `True` if the object was successfully added, and `False` if the object was already present. * `remove_object(obj_id: int) -> bool`: * Removes the game object identifier `obj_id` from the set if it is present. * Returns `True` if the object was successfully removed, and `False` if the object was not present. * `get_random_object() -> int`: * Returns a random game object identifier from the current set of objects. * Each game object should have an equal probability of being selected. # Expected Input and Output Formats * **Input**: * Operations will be called in sequence on an instance of `GameObjectSet`. * `add_object(obj_id: int)` where `obj_id` is an integer representing a game object. * `remove_object(obj_id: int)` where `obj_id` is an integer representing a game object. * `get_random_object()`, no parameters. * **Output**: * `add_object(obj_id: int)` returns `True` or `False`. * `remove_object(obj_id: int)` returns `True` or `False`. * `get_random_object()` returns an integer representing a game object. # Constraints * Game object identifiers (`obj_id`) are guaranteed to be non-negative integers. * Operations are guaranteed to be called within the application\'s bounds, and performance is critical. # Example ```python gset = GameObjectSet() print(gset.add_object(1)) # True print(gset.add_object(2)) # True print(gset.add_object(3)) # True print(gset.add_object(1)) # False print(gset.remove_object(2)) # True print(gset.remove_object(2)) # False print(gset.get_random_object()) # Randomly returns 1 or 3 ``` # Implementation You should ensure the insert, remove, and get random operations are all handled in average O(1) time.","solution":"import random class GameObjectSet: def __init__(self): self.objects = {} self.object_list = [] def add_object(self, obj_id: int) -> bool: if obj_id in self.objects: return False self.objects[obj_id] = len(self.object_list) self.object_list.append(obj_id) return True def remove_object(self, obj_id: int) -> bool: if obj_id not in self.objects: return False # Move the last object to the place of the object to remove last_element = self.object_list[-1] index_to_remove = self.objects[obj_id] self.object_list[index_to_remove] = last_element self.objects[last_element] = index_to_remove # Remove the last element self.object_list.pop() del self.objects[obj_id] return True def get_random_object(self) -> int: if not self.object_list: raise ValueError(\\"The set is empty\\") return random.choice(self.object_list)"},{"question":"You are given an array of integers that you need to sort using an efficient sorting algorithm. Implement the `merge_sort` function that sorts an array in non-decreasing order using the Merge Sort algorithm. Follow the guidelines and constraints given below. # Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr` (list of int): A list of integers that you need to sort. * You can assume all integers will fit within the standard integer range and the length of the array will not exceed 10^5. # Output * Return a list of integers sorted in non-decreasing order. # Constraints 1. The input array can be empty. 2. The algorithm must have a time complexity of O(n log(n)). 3. The algorithm should be stable. 4. The space complexity should be O(n). # Examples ```python merge_sort([38, 27, 43, 3, 9, 82, 10]) # Output: [3, 9, 10, 27, 38, 43, 82] merge_sort([5, 1, 1, 2, 0, 0]) # Output: [0, 0, 1, 1, 2, 5] merge_sort([]) # Output: [] ``` # Explanation The `merge_sort` function should use the divide-and-conquer paradigm: 1. Divide the array into roughly two equal parts. 2. Recursively sort each part. 3. Merge the two sorted parts into a single sorted array. Make sure to handle edge cases like an empty array and arrays with duplicate values. The implementation should follow the stable sorting property, ensuring that the relative order of equal elements remains unchanged. # Additional Notes If you like, you may implement a helper function `merge` to handle the merging of two sorted arrays into one sorted array.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts an array in non-decreasing order using the Merge Sort algorithm. if len(arr) <= 1: return arr # Divide the array into two halves mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) # Merge the sorted halves return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted arrays into one sorted array. merged = [] left_index, right_index = 0, 0 # Merge while there are elements in both arrays while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: merged.append(left[left_index]) left_index += 1 else: merged.append(right[right_index]) right_index += 1 # If there are remaining elements in left or right, add them while left_index < len(left): merged.append(left[left_index]) left_index += 1 while right_index < len(right): merged.append(right[right_index]) right_index += 1 return merged"},{"question":"# Question: Implement and Optimize Search Operations Context: You are developing a module for a software application that deals with large datasets. Your task is to implement optimized search functionalities. The initial implementation should include a simple linear search. Additionally, you should extend the functionality to handle sorted datasets more efficiently, employing a binary search when appropriate. Requirements: 1. **Function 1: `linear_search`** * **Input:** A list of integers `array`, an integer `query`. * **Output:** The index of the `query` element if found, else return -1. * **Constraints:** The array is not necessarily sorted. Aim for an O(n) time complexity. 2. **Function 2: `binary_search`** * **Input:** A sorted list of integers `array`, an integer `query`. * **Output:** The index of the `query` element if found, else return -1. * **Constraints:** The array must be sorted for binary search. Aim for an O(log n) time complexity. Performance Requirements: * Ensure that the implementation handles large datasets efficiently. * Provide a brief explanation of the benefits and trade-offs of using each search algorithm in comments. # Example: ```python # Linear Search Implementation def linear_search(array, query): Find the index of the given element in the array. There are no restrictions on the order of the elements in the array. If the element couldn\'t be found, returns -1. for i, value in enumerate(array): if value == query: return i return -1 # Binary Search Implementation def binary_search(array, query): Find the index of the given element in the array. The array must be sorted. If the element couldn\'t be found, returns -1. left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 # Find the middle index if array[mid] == query: return mid elif array[mid] < query: left = mid + 1 else: right = mid - 1 return -1 # Example Usage: array_unsorted = [4, 2, 5, 1, 3] query = 5 print(linear_search(array_unsorted, query)) # Output: 2 print(linear_search(array_unsorted, 6)) # Output: -1 array_sorted = [1, 2, 3, 4, 5] query = 5 print(binary_search(array_sorted, query)) # Output: 4 print(binary_search(array_sorted, 6)) # Output: -1 ``` Explanation: * **Linear Search**: Useful for small or unsorted arrays, trades simplicity for performance. * **Binary Search**: Efficient for large, sorted arrays, reduces time complexity to O(log n) but requires pre-sorted data.","solution":"def linear_search(array, query): Find the index of the given element in the array. There are no restrictions on the order of the elements in the array. If the element couldn\'t be found, returns -1. for i, value in enumerate(array): if value == query: return i return -1 def binary_search(array, query): Find the index of the given element in the array. The array must be sorted. If the element couldn\'t be found, returns -1. left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 # Find the middle index if array[mid] == query: return mid elif array[mid] < query: left = mid + 1 else: right = mid - 1 return -1"},{"question":"Problem Statement: Circular Buffer Implementation of Queue You are required to implement a circular buffer version of the `ArrayQueue` class provided in the code snippet. The circular buffer should allow efficient utilization of the array space and prevent the need for resizing by wrapping around the indices when needed. # Function Specifications: 1. **enqueue(item)**: Adds a new item to the rear of the queue. If the queue is full, it should raise an exception `OverflowError`. 2. **dequeue()**: Removes and returns the front item from the queue. If the queue is empty, it should raise an exception `IndexError`. 3. **peek()**: Returns the front item without removing it. If the queue is empty, it should raise an exception `IndexError`. 4. **is_empty()**: Returns `True` if the queue is empty and `False` otherwise. 5. **size()**: Returns the number of items in the queue. 6. **is_full()**: Returns `True` if the queue is full and `False` otherwise. # Class Signature: ```python class CircularBufferQueue(AbstractQueue): def __init__(self, capacity=10): pass def __iter__(self): pass def enqueue(self, value): pass def dequeue(self): pass def peek(self): pass def is_full(self): pass ``` # Constraints: - You must not use any additional data structures. - Optimize for constant time `enqueue` and `dequeue` operations if possible. # Example: ```python queue = CircularBufferQueue(3) queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) print(queue.is_full()) # Should print True print(queue.dequeue()) # Should print 1 queue.enqueue(4) print(queue.peek()) # Should print 2 print(queue.dequeue()) # Should print 2 print(queue.dequeue()) # Should print 3 print(queue.dequeue()) # Should print 4 print(queue.is_empty()) # Should print True ``` # Performance: - **Time Complexity**: O(1) for all operations. - **Space Complexity**: O(capacity).","solution":"class CircularBufferQueue: def __init__(self, capacity=10): self.capacity = capacity self.buffer = [None] * capacity self.front = 0 self.rear = 0 self.size = 0 def enqueue(self, item): if self.is_full(): raise OverflowError(\\"Queue is full\\") self.buffer[self.rear] = item self.rear = (self.rear + 1) % self.capacity self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") item = self.buffer[self.front] self.buffer[self.front] = None # Clear the position self.front = (self.front + 1) % self.capacity self.size -= 1 return item def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.buffer[self.front] def is_empty(self): return self.size == 0 def is_full(self): return self.size == self.capacity"},{"question":"# Linked List Cycle Detection # Objective You are tasked to implement a function that detects the first node of a cycle in a linked list, if one exists. Use Floyd\'s Cycle Finding Algorithm (Tortoise and Hare) as the basis of your implementation. # Function Signature ```python def find_cycle_start(head): :type head: Node :rtype: Node ``` # Input and Output Formats * **Input**: * A reference to the head node of a singly linked list. * **Output**: * A reference to the first node of the cycle if it exists; otherwise, return `None`. # Constraints * The linked list may contain between 0 and 100,000 nodes. * Node values are unique except for the cycle point. * The cycle, if present, is guaranteed to be formed by the last node pointing back to one of the previous nodes. # Example ```python # Create linked list => 1 -> 2 -> 3 -> 4 -> 5 -> 2 (cycle starting from node with value 2) head = Node(1) second = Node(2) third = Node(3) fourth = Node(4) fifth = Node(5) head.next, second.next, third.next, fourth.next = second, third, fourth, fifth fifth.next = second assert find_cycle_start(head).val == 2 # Create linked list => 6 -> 7 -> 8 -> None (no cycle) head_no_cycle = Node(6) second_no_cycle = Node(7) third_no_cycle = Node(8) head_no_cycle.next = second_no_cycle second_no_cycle.next = third_no_cycle assert find_cycle_start(head_no_cycle) == None ``` # Notes * You must implement the node class `Node` yourself for testing purposes. * Use the provided `unittest` framework to ensure your function is working correctly. * Ensure the solution meets performance requirements even with the maximum input size.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def find_cycle_start(head): Detects the first node in a cycle in a linked list using Floyd\'s Tortoise and Hare algorithm. :type head: Node :rtype: Node if not head or not head.next: return None # Initialize slow and fast pointers slow = head fast = head # Move fast by two steps and slow by one step to find the meeting point while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break if not fast or not fast.next: return None # No cycle # Move slow to the head and keep fast at the meeting point # Each moves one step to find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"Scenario You are working on an application that deals with binary arrays representing some data status. To ensure maximum performance, you need to find a way to convert a binary sequence optimally to maximize the length of a continuous sequence of ones by flipping a single zero to one. Problem Statement Write a function `find_best_zero(arr: List[int]) -> int` that takes a binary array `arr` and returns the index of the zero that should be replaced with one to get the longest continuous sequence of ones. If there is no zero in the array, return -1. Input and Output **Input**: - A list of integers `arr` where each element is either 0 or 1. **Output**: - An integer representing the index of the zero to be replaced. If there is no zero in the array, return -1. Example ```python arr = [1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1] # Should return 3 because replacing element at index 3 gives # the longest continuous sequence of 1s. arr = [1, 1, 1, 1] # Should return -1 because there is no 0 to replace. ``` Constraints 1. The array length could range from 1 to 10^6. 2. The array contains only binary elements (0s and 1s). Requirements - The solution must have a time complexity of O(n). - The solution must use constant extra space, i.e., O(1) additional space. **Note**: Handle the edge cases appropriately, and provide a clear and efficient solution that adheres to the constraints.","solution":"from typing import List def find_best_zero(arr: List[int]) -> int: n = len(arr) if 0 not in arr: return -1 max_len = 0 # to keep track of the maximum length of 1s formed best_index = -1 # the index of the best 0 to flip prev_zero = -1 # the index of the previous 0 curr_len = 0 # the current length of continuous 1s and one flip to 1 for i in range(n): if arr[i] == 1: curr_len += 1 else: curr_len = i - prev_zero # length of 1s if this 0 is flipped prev_zero = i if curr_len > max_len: max_len = curr_len best_index = prev_zero return best_index"},{"question":"You are given a set of items, each with a weight and a value, and a maximum capacity for a knapsack. Write a function `get_maximum_value` that calculates the maximum total value that can be accommodated within the given capacity. The function should utilize the dynamic programming approach to minimize time and space complexity. # Input - A list of `Item` objects, where each `Item` has: - `value` (integer): The value of the item. - `weight` (integer): The weight of the item. - An integer `capacity` which is the maximum weight the knapsack can hold. # Output - An integer representing the maximum value achievable within the given capacity constraints. # Constraints - The number of items `n` is such that (1 leq n leq 1000). - The weight of each item and the capacity `m` is such that (1 leq text{weight}, text{capacity} leq 1000). - Values are positive integers. # Example ```python class Item: def __init__(self, value, weight): self.value = value self.weight = weight def get_maximum_value(items, capacity): # Implementation as discussed in the analysis. dp = [0] * (capacity + 1) for item in items: for cur_weight in reversed(range(item.weight, capacity+1)): dp[cur_weight] = max(dp[cur_weight], item.value + dp[cur_weight - item.weight]) return dp[capacity] # Example usage: items = [Item(60, 5), Item(50, 3), Item(70, 4), Item(30, 2)] capacity = 5 print(get_maximum_value(items, capacity)) # Output: 80 ``` # Additional Scenarios Consider edge cases such as: - Items with weights higher than the capacity. - A knapsack with zero capacity should return zero value. - Diverse item weight and value combinations to test the algorithm\'s robustness.","solution":"class Item: def __init__(self, value, weight): self.value = value self.weight = weight def get_maximum_value(items, capacity): Calculates the maximum total value that can be accommodated within a given capacity. Args: - items (list): A list of `Item` objects, each with a `value` and `weight`. - capacity (int): The maximum weight that the knapsack can hold. Returns: - int: The maximum value. dp = [0] * (capacity + 1) for item in items: for cur_weight in reversed(range(item.weight, capacity + 1)): dp[cur_weight] = max(dp[cur_weight], item.value + dp[cur_weight - item.weight]) return dp[capacity]"},{"question":"Regular Expression Matching Scenario You are tasked with implementing a function to determine if a given string matches a given pattern. The pattern may include wildcard characters: * `.` matches any single character. * `*` matches zero or more of the preceding element. The matching should consider the entire input string. Task Implement the function `is_match(s, p)` that takes two strings: `s` (the string) and `p` (the pattern), and returns a boolean indicating whether or not the string `s` matches the pattern `p`. Input * `s`: A string, 0 <= `len(s)` <= 1000. * `p`: A string containing lowercase letters, `.` and `*`, 0 <= `len(p)` <= 1000. Output * A boolean value - `True` if the string matches the pattern, `False` otherwise. Constraints * The input strings will only contain lowercase letters and the characters `.` and `*`. * The solution must efficiently handle up to the maximum lengths of `s` and `p`. Examples ```python print(is_match(\\"aa\\", \\"a\\")) # False print(is_match(\\"aa\\", \\"aa\\")) # True print(is_match(\\"aaa\\", \\"aa\\")) # False print(is_match(\\"aa\\", \\"a*\\")) # True print(is_match(\\"aa\\", \\".*\\")) # True print(is_match(\\"ab\\", \\".*\\")) # True print(is_match(\\"aab\\", \\"c*a*b\\")) # True ``` Implement the following function in Python: ```python def is_match(s: str, p: str) -> bool: # Your implementation here ```","solution":"def is_match(s: str, p: str) -> bool: m, n = len(s), len(p) # Create a DP table with default values False dp = [[False] * (n + 1) for _ in range(m + 1)] # Empty string matches with an empty pattern dp[0][0] = True # Only \'*\' can match with an empty string for j in range(1, n + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == \'.\')) else: dp[i][j] = dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == \'.\') return dp[m][n]"},{"question":"**Scenario:** Imagine you are working on a financial application that frequently operates on large non-negative integers. These integers are so large that they are represented as lists of individual digits, with the most significant digit at the head of the list (big-endian format). To assess your understanding of list operations and handling carry-overs, you are required to implement a function to add one to such a number. **Task:** Write a function `increment_number(digits: List[int]) -> List[int]` that takes a list of non-negative digits representing a number, and returns a new list representing that number incremented by one. **Input:** - `digits`: a list of integers where each integer is a digit (0-9). **Output:** - A list of integers representing the number obtained by incrementing the input number by one. **Constraints:** - The input list will not be empty. - The number will not contain leading zeros except for the number zero itself. **Example:** ```python # Example 1 print(increment_number([1, 2, 3])) # Output: [1, 2, 4] # Example 2 print(increment_number([9, 9, 9])) # Output: [1, 0, 0, 0] # Example 3 print(increment_number([0])) # Output: [1] ``` **Notes:** - Ensure your solution efficiently handles input lists of varying lengths without excessive use of extra space. - Consider all possible edge cases such as inputs with multiple 9s which require carry-over to the next significant digit.","solution":"def increment_number(digits): Increments the number represented by a list of digits by one. Parameters: digits (list): List of integers where each integer is a digit (0-9). Returns: list: A new list of integers representing the incremented number. n = len(digits) for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 return [1] + digits"},{"question":"# Problem: Optimized Dijkstra\'s Algorithm with Priority Queue You are required to implement a more efficient version of the Dijkstra\'s shortest path algorithm using a priority queue (min-heap). The graph will be represented using an adjacency list rather than an adjacency matrix to improve space complexity. # Function Signature ```python def dijkstra(graph, src): Calculate the shortest paths from the source vertex to all other vertices in the graph. Parameters: graph (dict): A dictionary where the keys are vertex identifiers and the values are lists of tuples (neighbor, weight). src (int): The source vertex identifier. Returns: dict: A dictionary where the keys are vertex identifiers and the values are the shortest distance from the source vertex to the respective vertex. ``` # Input * `graph`: A dictionary representing an adjacency list of the graph. The keys are integers representing vertex identifiers, and the values are lists of tuples where each tuple contains a neighbor vertex identifier and the edge weight (both integers). For example: ```python { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } ``` * `src`: An integer representing the source vertex. # Output * A dictionary where the keys are vertex identifiers and the values are the shortest distance from the source vertex to the respective vertex. For example: ```python {0: 0, 1: 3, 2: 1, 3: 4} ``` # Constraints * The graph does not contain any negative weight edges. * The graph is connected, so all vertices are reachable from the source vertex. * The number of vertices (V) and edges (E) will satisfy 1 ≤ V, E ≤ 10^5. # Performance Requirements * Your implementation should have a time complexity of O(V + E log V). # Example Given the following graph and source vertex: ```python graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } src = 0 ``` The function call `dijkstra(graph, src)` should return: ```python {0: 0, 1: 3, 2: 1, 3: 4} ``` # Additional Notes * Students should ensure their implementation efficiently handles large inputs and edge cases. * Consider edge cases such as when the source node has no outgoing edges.","solution":"import heapq def dijkstra(graph, src): Calculate the shortest paths from the source vertex to all other vertices in the graph. Parameters: graph (dict): A dictionary where the keys are vertex identifiers and the values are lists of tuples (neighbor, weight). src (int): The source vertex identifier. Returns: dict: A dictionary where the keys are vertex identifiers and the values are the shortest distance from the source vertex to the respective vertex. # Initialize the priority queue (min-heap) pq = [(0, src)] # Initialize the distances dictionary with \'infinity\' for all vertices except the source vertex dist = {vertex: float(\'inf\') for vertex in graph} dist[src] = 0 # Set of visited vertices to avoid processing a vertex multiple times visited = set() while pq: # Get the vertex with the smallest distance current_dist, u = heapq.heappop(pq) # If we have already visited this vertex, skip it if u in visited: continue # Mark this vertex as visited visited.add(u) # Process each neighbor of the current vertex for neighbor, weight in graph[u]: if neighbor in visited: continue new_dist = current_dist + weight if new_dist < dist[neighbor]: dist[neighbor] = new_dist heapq.heappush(pq, (new_dist, neighbor)) return dist"},{"question":"# Binary Exponentiation Exercise **Context**: In cryptographic operations and mathematical computations, calculating large powers efficiently is crucial. Binary Exponentiation helps in reducing the power computation time from linear to logarithmic time complexity. **Problem**: Write a function implementing the iterative version of Binary Exponentiation, which should handle large numbers efficiently using modulo operations. # Function Signature ```python def power(a: int, n: int, mod: int = None) -> int: Calculates a raised to the power n with optional modulo. :param a: An integer base. :param n: A non-negative integer exponent. :param mod: Optional modulus for modular exponentiation. :return: Result of (a^n) % mod if mod is provided, otherwise a^n. ``` # Constraints * `0 <= a <= 10^9` * `0 <= n <= 10^9` * `1 <= mod <= 10^9` (if provided) * Handle edge cases like a=0 or n=0 appropriately. # Example 1. `power(2, 10)` should return 1024. 2. `power(2, 10, 10000)` should return 1024 (no effect of mod as 1024 < 10000). 3. `power(2, 10, 1000)` should return 24 (1024 mod 1000). # Instructions 1. Implement the function as specified. 2. Ensure to handle edge cases like a=0 or n=0. 3. If modulus is provided, perform modular exponentiation to avoid overflow. # Notes * You must use the iterative approach. * Do not use Python’s built-in `pow` function or `**` operator for the implementation.","solution":"def power(a: int, n: int, mod: int = None) -> int: Calculates a raised to the power n with optional modulo. :param a: An integer base. :param n: A non-negative integer exponent. :param mod: Optional modulus for modular exponentiation. :return: Result of (a^n) % mod if mod is provided, otherwise a^n. result = 1 base = a if mod is None else a % mod while n > 0: if n % 2 == 1: result = (result * base) if mod is None else (result * base) % mod base = (base * base) if mod is None else (base * base) % mod n //= 2 return result"},{"question":"Problem Scenario You\'ve been tasked with developing a new feature for a network packet analysis tool. One of the core requirements is to efficiently compute the number of `1` bits in the binary representation of packet identifiers, which are represented as unsigned 32-bit integers. Task Write a function `count_one_bits` that takes an unsigned 32-bit integer and returns the number of `1` bits it contains. You will be implementing this function using both iterative and recursive approaches based on Brian Kernighan\'s Algorithm. Expected Function Signature ```python def count_one_bits_iter(n: int) -> int: pass def count_one_bits_recur(n: int) -> int: pass ``` Input and Output Format * **Input**: - An unsigned 32-bit integer `n`. * **Output**: - An integer representing the number of `1` bits in the binary representation of `n`. Constraints - Your solution should handle unsigned 32-bit integers in the range `[0, 2^32-1]`. - Do not use any built-in functions or library that directly performs this task. - Aim for a time complexity of O(k), where k is the number of `1` bits in the binary representation. Performance Requirement * Ensure the solution is optimized for time complexity and functions within the constraints provided, including large values of `n`. Example ```python assert count_one_bits_iter(11) == 3 # Binary: 00000000000000000000000000001011 assert count_one_bits_recur(11) == 3 assert count_one_bits_iter(128) == 1 # Binary: 00000000000000000000000010000000 assert count_one_bits_recur(128) == 1 assert count_one_bits_iter(4294967295) == 32 # Binary: 11111111111111111111111111111111 assert count_one_bits_recur(4294967295) == 32 ``` Description * **Iterative Approach Implementation**: - Use a loop to repeatedly clear the least significant `1` bit and increment a counter until the number becomes zero. * **Recursive Approach Implementation**: - Utilize a recursive function that counts the operations until the number becomes zero. Both functions should return the correct number of `1` bits for any valid 32-bit unsigned integer input.","solution":"def count_one_bits_iter(n: int) -> int: Returns the number of 1 bits in the binary representation of n using an iterative approach. count = 0 while n: count += 1 n = n & (n - 1) # Clear the least significant bit set return count def count_one_bits_recur(n: int) -> int: Returns the number of 1 bits in the binary representation of n using a recursive approach. if n == 0: return 0 # Each call reduces one `1` bit from the number return 1 + count_one_bits_recur(n & (n - 1))"},{"question":"# Problem: Right Rotation of a Linked List You are tasked with implementing a function that rotates a singly linked list to the right by `k` places. The function must handle edge cases, including scenarios with empty lists and `k` values larger than the list length. Function Signature ```python def rotate_right(head, k): Rotates a singly linked list to the right by k places. :param head: ListNode - The head of the singly linked list. :param k: int - The number of positions to rotate the list. :return: ListNode - The new head of the rotated list. ``` Input * `head` - The head node of a singly linked list (list might be empty or non-empty). * `k` - An integer (0 ≤ k ≤ 1000). Output * The new head of the rotated linked list. Constraints 1. The list is composed of `n` nodes, where `0 ≤ n ≤ 10^5`. 2. The values in the nodes are arbitrary integers. # Example Given a list: `1 -> 2 -> 3 -> 4 -> 5 -> None` and `k = 2`, the function should return the new head of the list which looks like `4 -> 5 -> 1 -> 2 -> 3 -> None`. **Explanation**: The original list has 5 elements. Rotating it 2 places to the right would move the last 2 elements (`4` and `5`) to the beginning of the list. Edge Cases 1. Empty List: If `head` is `None`, return `None`. 2. Single Node List: If the list has only one node, the rotation does not change the list. 3. If `k` is 0, the list should remain unchanged. 4. If `k` is a multiple of the list length, the list should remain unchanged due to the cyclic nature of the rotation. Implement the function ensuring it is both efficient and correctly handles all edge cases.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotate_right(head, k): if not head or k == 0: return head # Compute the length of the list and make the list a circular one length = 1 tail = head while tail.next: tail = tail.next length += 1 tail.next = head # Make it circular # Find the new head and tail k = k % length # Normalize k if k == 0: tail.next = None return head steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"# Scenario: Prime Validation Service Your task is to implement a function that leverages the prime-checking algorithm discussed above within a more extensive service that validates multiple numbers and returns a summary report. # Function Specification You must implement `validate_prime_numbers(numbers: List[int]) -> Dict[str, Union[List[int], int]]`. The function should take a list of integers and return a dictionary with the following structure: - `\\"primes\\"`: a list of prime numbers found in the input list. - `\\"non_primes\\"`: a list of non-prime numbers found in the input list. - `\\"prime_count\\"`: the count of prime numbers found. - `\\"non_prime_count\\"`: the count of non-prime numbers found. # Input Constraints - The input list `numbers` will contain up to 10,000 integers. - Each integer within the list will be between -10^9 and 10^9. # Output Format The function should return a dictionary structured as described above. # Example ```python validate_prime_numbers([2, 3, 4, 5, 16]) ``` **Expected Output**: ```python { \\"primes\\": [2, 3, 5], \\"non_primes\\": [4, 16], \\"prime_count\\": 3, \\"non_prime_count\\": 2 } ``` # Additional Guidelines - Use the provided `prime_check(n)` function to determine if numbers are prime. - Optimize your solution to handle the upper limits efficiently. - Ensure your solution handles negative numbers and zero correctly, categorizing them as non-prime.","solution":"from typing import List, Dict, Union def prime_check(n: int) -> bool: Check if the number is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def validate_prime_numbers(numbers: List[int]) -> Dict[str, Union[List[int], int]]: primes = [] non_primes = [] for number in numbers: if prime_check(number): primes.append(number) else: non_primes.append(number) result = { \\"primes\\": primes, \\"non_primes\\": non_primes, \\"prime_count\\": len(primes), \\"non_prime_count\\": len(non_primes) } return result"},{"question":"Context You are working on a predictive text model that uses a Markov Chain to suggest the next character in a sequence. The system models transitions between characters based on probabilities derived from historical text data. Your task is to implement functions to operate this Markov Chain model, enhancing its efficiency and robustness. Question Implement a Markov Chain-driven text generator. Your implementation should include: 1. A function to choose the next state based on transition probabilities. 2. Modifications to handle edge cases and improve selection efficiency. 3. Methods to validate and process the transition maps ensure correctness. # Functions to Implement 1. **`choose_next_state(state_map)`**: * **Input**: Dictionary representing possible transitions from the current state with their associated probabilities. * **Output**: The chosen next state based on given probabilities. * **Constraints**: Ensure the summed probabilities equal 1. 2. **`validate_transition_map(transition_map)`**: * **Input**: The transition map to validate. * **Output**: Boolean indicating whether the transition map is valid. * **Edge Cases**: Returns `False` for invalid maps (probabilities not summing to 1 or contain invalid probabilities). 3. **`markov_chain_generator(chain, initial_state)`**: * **Input**: Dictionary describing the whole Markov Chain, Initial state. * **Output**: Generator yielding an infinite sequence of states. * **Performance Considerations**: Efficiently determine the next state without redundant calculations. # Example ```python chain_example = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } # Example usage gen = markov_chain_generator(chain_example, \'A\') for _ in range(10): print(next(gen)) Expected Output: \'E\' \'A\' \'A\' ... ``` # Constraints - Use Python\'s built-in random module for randomness. - Ensure your solution can handle chains with up to 10,000 states without significant delay.","solution":"import random def choose_next_state(state_map): Given a dictionary state_map representing possible transitions from the current state with their associated probabilities, this function returns the chosen next state based on the given probabilities. states = list(state_map.keys()) probabilities = list(state_map.values()) next_state = random.choices(states, probabilities)[0] return next_state def validate_transition_map(transition_map): Given a transition_map, this function validates it. Returns True if the map is valid, else returns False. A valid transition map should have probabilities that sum up to 1 for each state. for state, transitions in transition_map.items(): total_probability = sum(transitions.values()) if not (0.999 <= total_probability <= 1.001): return False if any(prob < 0 for prob in transitions.values()): return False return True def markov_chain_generator(chain, initial_state): Given a Markov chain transition map and an initial state, this generator yields an infinite sequence of states based on the Markov Chain transitions. state = initial_state while True: yield state if state in chain: state = choose_next_state(chain[state]) else: break"},{"question":"# Question: Implement a Three-Category Sorting Algorithm Given an array with `n` elements colored red, white, or blue, your task is to sort them so that objects of the same color are adjacent, in the order of red, white, and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Implement the function `sort_three_colors` that sorts the array in-place. The function should have the following signature: ```python def sort_three_colors(nums: List[int]) -> None: ``` # Input Format * `nums`: A list of integers where each element is either 0, 1, or 2, representing the colors red, white, and blue respectively. # Output Format * The function should modify the `nums` list in-place, arranging the elements in the order of 0s first, followed by 1s, and then 2s. # Constraints * The algorithm should run in O(n) time complexity. * Use constant space complexity O(1) – sort the array in place. * Do not use the built-in sort function. # Example ```python nums = [0, 1, 2, 1, 2, 0, 0, 1] sort_three_colors(nums) print(nums) # Output: [0, 0, 0, 1, 1, 1, 2, 2] ``` # Explanation Your implementation should reorder the input array such that all 0s appear before all 1s, which, in turn, appear before all 2s. The function should not return any value; it should modify the input list directly. **Note**: Make sure to handle edge cases such as an empty array, an array with all elements being the same, and arrays that are already sorted.","solution":"from typing import List def sort_three_colors(nums: List[int]) -> None: Sorts the input list nums containing 0s, 1s, and 2s such that 0s come first, followed by 1s, and then 2s. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: # nums[mid] == 2 nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# Interpolation Search with Enhanced Capabilities **Problem Statement**: You are given an array of integers sorted in increasing order. Your task is to implement an enhanced version of the Interpolation Search algorithm that not only finds the position of a given search key but also returns the range of indices where the search key appears, if it appears multiple times. If the key is not found, return -1. **Function Signature**: ```python def enhanced_interpolation_search(array: List[int], search_key: int) -> Union[int, Tuple[int, int]]: ``` **Parameters**: * `array` (List[int]): A sorted list of integers. * `search_key` (int): The integer value to search for. **Returns**: * `int` if the search_key is not found. * `Tuple[int, int]` representing the range (start_index, end_index) where the search_key is found. **Examples**: ```python >>> enhanced_interpolation_search([5, 10, 10, 10, 20, 21], 10) (1, 3) >>> enhanced_interpolation_search([5, 10, 10, 10, 20, 21], 5) 0 >>> enhanced_interpolation_search([5, 10, 10, 10, 20, 21], 21) 5 >>> enhanced_interpolation_search([5, 10, 10, 10, 20, 21], 19) -1 ``` **Constraints**: 1. The input array will be sorted in increasing order. 2. Elements in the array and the search key are integers. 3. The array length will be between 1 and (10^5) inclusive. 4. The search_key will be within the range of the array elements. **Notes**: * Optimize your solution for both time and space. * Consider edge cases such as finding a value at the beginning, middle, and end of the array, or when the key is not found at all.","solution":"from typing import List, Union, Tuple def enhanced_interpolation_search(array: List[int], search_key: int) -> Union[int, Tuple[int, int]]: low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) if array[pos] == search_key: start = pos end = pos while start > low and array[start - 1] == search_key: start -= 1 while end < high and array[end + 1] == search_key: end += 1 if start == end: return start else: return (start, end) if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Stack Operations with Validation **Scenario**: You are tasked to fortify a stack data structure implementation with additional validation mechanisms. Implement both the ArrayStack and LinkedListStack classes with operations accordingly, and include a comprehensive validation routine that manages edge cases like performing actions on an empty stack or handling overflow for ArrayStack. Additionally, provide a method for dynamic resizing optimization in the ArrayStack. # Specifications: Your implementation should include the following: 1. **ArrayStack Validated Class**: Inherits from ArrayStack and adds: * Validation for `pop` and `peek` operations to handle empty stack scenarios. * Effective dynamic resizing mechanism for the array when overflow occurs. 2. **LinkedListStack Validated Class**: Inherits from LinkedListStack and includes validation for: * Handling empty stack scenarios in `pop` and `peek` operations. 3. Thorough test scenarios for edge cases: * Operations on an empty stack. * Array expansion during `push`. # Input and Output Format: * Implement `push(self, value: int) -> None`, `pop(self) -> int`, `peek(self) -> int`, and `is_empty(self) -> bool` methods. * Handle error cases with appropriate exceptions (e.g., IndexError for empty stack operations). * Ensure dynamic resizing in `ArrayStack` is optimized. Example Usage: ```python # Example for ArrayStack Validated stack = ArrayStackValidated(size=5) stack.push(10) stack.push(20) assert stack.pop() == 20 assert stack.peek() == 10 # Example for LinkedListStack Validated ll_stack = LinkedListStackValidated() ll_stack.push(30) ll_stack.push(40) assert ll_stack.pop() == 40 assert ll_stack.peek() == 30 ``` # Constraints: * Use Python standard library only. * Do not use built-in data structures (like `list`) directly to simulate stack. * ArrayStack initial size is provided, consider N <= 10^4 elements.","solution":"class ArrayStack: def __init__(self, initial_size=10): self.stack = [None] * initial_size self.top = -1 self.size = initial_size def push(self, value): if self.top == self.size - 1: self.resize() self.top += 1 self.stack[self.top] = value def pop(self): if self.is_empty(): raise IndexError(\\"Pop from empty stack\\") value = self.stack[self.top] self.top -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Peek from empty stack\\") return self.stack[self.top] def is_empty(self): return self.top == -1 def resize(self): new_size = self.size * 2 new_stack = [None] * new_size for i in range(self.size): new_stack[i] = self.stack[i] self.stack = new_stack self.size = new_size class LinkedListNode: def __init__(self, value, next_node=None): self.value = value self.next_node = next_node class LinkedListStack: def __init__(self): self.head = None def push(self, value): new_node = LinkedListNode(value, self.head) self.head = new_node def pop(self): if self.is_empty(): raise IndexError(\\"Pop from empty stack\\") value = self.head.value self.head = self.head.next_node return value def peek(self): if self.is_empty(): raise IndexError(\\"Peek from empty stack\\") return self.head.value def is_empty(self): return self.head is None class ArrayStackValidated(ArrayStack): def pop(self): return super().pop() def peek(self): return super().peek() class LinkedListStackValidated(LinkedListStack): def pop(self): return super().pop() def peek(self): return super().peek()"},{"question":"# Question: You are given a non-empty string and you need to determine if it can be constructed by taking a substring of it and repeating the substring multiple times. Implement a function `is_repeated_substring` that accepts a string and returns `True` if the string can be formed by repeating a substring, otherwise it returns `False`. Function Signature ```python def is_repeated_substring(s: str) -> bool: ``` Input - The input is a non-empty string `s` where ( 1 leq |s| leq 10^5 ). Output - The function should return a boolean value. Return `True` if the input string can be represented by repeating a substring, otherwise return `False`. Constraints - The function should be efficient to handle strings up to length ( 10^5 ). Examples - Example 1: - Input: `\\"abab\\"` - Output: `True` - Explanation: It\'s the substring \\"ab\\" twice. - Example 2: - Input: `\\"aba\\"` - Output: `False` - Explanation: It cannot be constructed by repeating any substring. - Example 3: - Input: `\\"abcabcabcabc\\"` - Output: `True` - Explanation: It\'s the substring \\"abc\\" four times. # Additional Notes - You need to handle edge cases such as single character strings or strings where the repetition is subtle. - The solution should be efficient enough to handle the upper constraint limits.","solution":"def is_repeated_substring(s: str) -> bool: Returns True if the string can be constructed by repeating a substring, otherwise False. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: if all(s[j] == s[j % i] for j in range(n)): return True return False"},{"question":"# Assessing Linked List Sort Validation Context You are working with linked lists and need to validate whether a given singly linked list is sorted in non-decreasing order. This is crucial for algorithms that rely on sorted data, such as search optimizations or merge operations. Task Write a function `is_sorted(head)` that checks whether a given singly linked list is sorted in non-decreasing order. If the list is empty or has one node, it should be considered sorted. You are required to traverse the list and compare node values to determine the result. Function Signature ```python def is_sorted(head): Check if the linked list is sorted in non-decreasing order. :param head: ListNode, the head node of the singly linked list :return: bool, True if the list is sorted, False otherwise ``` Input * `head`: The head node of a singly linked list. Each node contains an integer value and a reference to the next node (`None` if it is the last node). Output * Return a boolean value: * `True` if the list is sorted in non-decreasing order. * `False` otherwise. Constraints * You may not use additional data structures or libraries. * The function must have O(n) time complexity and O(1) space complexity. Examples ```python # Example 1: # Input: 1 -> 2 -> 3 -> 4 -> None # Output: True # Example 2: # Input: 1 -> 2 -> -1 -> 3 -> None # Output: False # Example 3: # Input: None # Output: True # Example 4: # Input: 5 -> None # Output: True ``` Notes 1. Pay attention to edge cases such as empty lists or lists with a single node. 2. Ensure that your implementation handles both positive and negative integer values in the nodes.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head): Check if the linked list is sorted in non-decreasing order. :param head: ListNode, the head node of the singly linked list :return: bool, True if the list is sorted, False otherwise if not head or not head.next: return True current = head while current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"# Single Number Finder Description **Context**: You are given a list of integers where each integer appears twice except for one which appears exactly once. Your task is to find and return the single number using an efficient algorithm. The algorithm should have linear time complexity and should not use any extra memory beyond a few integer variables. Task Implement the function `single_number(nums)` such that: - It takes a list of integers `nums` as input. - Returns the single integer that appears only once. Input - A list of integers: `nums` (0 <= len(nums) <= 10^6) - Each integer appears twice except for one. Output - The single integer that appears exactly once. - If the list is empty, return 0. Constraints - The list may contain integers ranging from -10^9 to 10^9. - Zero is also a valid element in the list. - Aim for an O(n) time complexity and O(1) space complexity. Example Example 1: ```python nums = [2, 2, 1] print(single_number(nums)) # Output: 1 ``` Example 2: ```python nums = [4, 1, 2, 1, 2] print(single_number(nums)) # Output: 4 ``` Example 3: ```python nums = [] print(single_number(nums)) # Output: 0 ``` ```python def single_number(nums): Returns single number, if found. Else if all numbers appear twice, returns 0. :type nums: List[int] :rtype: int i = 0 for num in nums: i ^= num return i ```","solution":"def single_number(nums): Returns the single integer that appears only once in the list. :type nums: List[int] :rtype: int single = 0 for num in nums: single ^= num return single"},{"question":"Generate All Subsets You are provided with a set of distinct integers. Your task is to write a function `generate_subsets` that returns all possible subsets of this set. The function should return the subsets in any order. Implement this function using both recursive backtracking and an iterative approach. # Function Signature ```python def generate_subsets(nums: List[int]) -> List[List[int]]: ``` # Input - `nums` (List[int]): A list of distinct integers `1 <= len(nums) <= 10`. # Output - `List[List[int]]`: A list of lists, where each list is a subset of the input list `nums`. # Constraints - The input list will contain distinct integers. - The function should exhibit a time complexity of O(2^n) and a space complexity of O(2^n). # Example Input: ```python nums = [1, 2, 3] ``` Output: ```python [ [], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3] ] ``` # Requirements 1. Do not use any built-in libraries or functions that directly solve the problem. 2. Include both recursive backtracking and iterative approaches in your solution.","solution":"from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: def backtrack(start=0, current=[]): result.append(current[:]) for i in range(start, len(nums)): current.append(nums[i]) backtrack(i + 1, current) current.pop() result = [] backtrack() return result def generate_subsets_iterative(nums: List[int]) -> List[List[int]]: result = [[]] for num in nums: result += [curr + [num] for curr in result] return result"},{"question":"# Balanced Binary Tree Checker Scenario You are working on a project that involves managing large datasets using binary trees. One crucial requirement is to ensure that the binary trees remain balanced to guarantee optimized data retrieval operations. Your task is to implement a function that verifies whether a given binary tree is balanced. Task Write a Python function `is_balanced(root)` that checks if a binary tree is height-balanced. In a height-balanced binary tree, the left and right subtrees of every node differ in height by no more than 1. Input - `root`: The root node of a binary tree. Each node is represented as an instance of a class `TreeNode` which has the following structure: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` Output - Return `True` if the tree is balanced, otherwise return `False`. Constraints - The number of nodes in the tree may be up to 10^4. - Node values are arbitrary but unique. Performance Requirements - Time complexity must be `O(N)`, where `N` is the number of nodes in the tree. - Space complexity should be managed effectively, ideally `O(H)`, where `H` is the height of the tree. Example ```python # Example creating a simple tree # Tree Structure: # 1 # / # 2 3 # / # 4 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) assert is_balanced(root) == False ``` In this example, the depth difference between the left and right subtrees of the root node (1) is greater than 1, hence the tree is not balanced. Write your `is_balanced` function below:","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_balanced(root): Checks if a binary tree is height-balanced. def check_height(node): if not node: return 0 left_height = check_height(node.left) right_height = check_height(node.right) if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return check_height(root) != -1"},{"question":"**Problem Statement**: You are given a list of integers. Your task is to implement a function, `top_1`, that returns the most frequent value(s) in the list. If there are multiple values with the same highest frequency, the function should return all these values in a list. If the input list is empty, the function should return an empty list. Function Signature: ```python def top_1(arr: List[int]) -> List[int]: pass ``` Input: - `arr`: A list of integers, where the length of the list can be from 0 up to 10^6. Output: - A list of integers containing the most frequent elements from the input list. - If there are multiple values with the same maximum frequency, return all such values. Constraints: - The input list can contain negative numbers, zero, and positive numbers. - The elements of the input list are not necessarily unique. Performance Requirements: - The function must run in O(n) time complexity, where n is the length of the input list. - The function must use O(n) additional space complexity where necessary. Examples: 1. `top_1([1, 1, 2, 2, 3, 4])` should return `[1, 2]`. 2. `top_1([4, 4, 4, 4, 4])` should return `[4]`. 3. `top_1([])` should return `[]`. 4. `top_1([1, 2, 3, 4, 5])` should return `[1, 2, 3, 4, 5]` (each element has a frequency of 1).","solution":"from typing import List from collections import Counter def top_1(arr: List[int]) -> List[int]: Returns the most frequent value(s) in the list. If there are multiple values with the same highest frequency, returns all these values in a list. If the input list is empty, returns an empty list. if not arr: return [] # Count the frequency of each number in the list count = Counter(arr) # Find the maximum frequency max_freq = max(count.values()) # Get all numbers with the maximum frequency result = [num for num, freq in count.items() if freq == max_freq] return result"},{"question":"You are given a linked list where a node might point back to a previous node creating a cycle. Implement a function `first_cyclic_node(head)` that detects the cycle and returns the node where the cycle begins. If there is no cycle, return `None`. Function Signature ```python def first_cyclic_node(head: Node) -> Node: pass ``` # Input * `head` (Node): The head node of the linked list. Each node in the list has the following attributes: * `val`: The value of the node (string type for this problem). * `next`: The next node in the list (or `None` if there is no next node). # Output * Node: The node where the cycle begins. If there is no cycle, return `None`. # Constraints * The linked list can contain up to 10^5 nodes. # Example Here is the structure of the data and an example: ```python # Define the Node class class Node: def __init__(self, x): self.val = x self.next = None # Create a linked list: A -> B -> C -> D -> E -> C head = Node(\'A\') head.next = Node(\'B\') cyclic_node = Node(\'C\') head.next.next = cyclic_node cyclic_node.next = Node(\'D\') cyclic_node.next.next = Node(\'E\') cyclic_node.next.next.next = cyclic_node # Call the function print(first_cyclic_node(head).val) # Output: \'C\' ``` # Note * Use the Floyd\'s cycle-finding algorithm to solve this problem. * You are not allowed to use extra space like sets or dictionaries to store the nodes. * Ensure your function handles edge cases effectively, such as when there is no cycle in the list or the list is empty. # Testing Ensure your implementation is tested with the following cases: 1. A cyclic linked list. 2. A non-cyclic linked list. 3. An empty linked list. 4. A linked list with one node, which does not form a cycle. 5. A linked list with multiple nodes where the last node points back to a middle node forming a cycle.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def first_cyclic_node(head: Node) -> Node: if not head or not head.next: return None slow = head fast = head # Detect cycle using Floyd\'s cycle-finding algorithm while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If no cycle is found, return None if not fast or not fast.next: return None # Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Crout Matrix Decomposition Given a square matrix (A), your task is to implement a function `crout_decomposition(A)` that performs Crout matrix decomposition to decompose (A) into a lower triangular matrix (L) and an upper triangular matrix (U) such that (L cdot U = A). # Input * A square matrix (A) of size (n times n) where (1 leq n leq 100). * Assume matrix (A) is non-singular. # Output * Two matrices (L) and (U): * (L) — a lower triangular matrix with non-zero elements only on the diagonal and below. * (U) — an upper triangular matrix with ones on the diagonal and non-zero elements only above. # Example Input: [A = begin{bmatrix} 1 & 2 & 3 3 & 4 & 5 6 & 7 & 8 end{bmatrix}] Output: [L = begin{bmatrix} 1.0 & 0.0 & 0.0 3.0 & -2.0 & 0.0 6.0 & -5.0 & 0.0 end{bmatrix}] [U = begin{bmatrix} 1.0 & 2.0 & 3.0 0.0 & 1.0 & 2.0 0.0 & 0.0 & 1.0 end{bmatrix}] # Constraints 1. The input matrix (A) will be a square matrix of size (n times n) with (1 leq n leq 100). 2. The matrix (A) is guaranteed to be non-singular to avoid division by zero scenarios. Implement the function `crout_decomposition(A)` in Python. Ensure that your solution is efficient with respect to both time and space complexity.","solution":"def crout_decomposition(A): Perform Crout decomposition of matrix A into lower triangular matrix L and upper triangular matrix U such that A = L * U. Args: A : 2D list or array (n x n) The input square matrix. Returns: L, U : tuple of 2D lists or arrays The lower triangular matrix L and upper triangular matrix U. import numpy as np n = len(A) L = np.zeros((n, n)) U = np.zeros((n, n)) # Initialize U to be an identity matrix for i in range(n): U[i][i] = 1.0 for j in range(n): for i in range(j, n): sum_k = sum(L[i][k] * U[k][j] for k in range(j)) L[i][j] = A[i][j] - sum_k for i in range(j+1, n): sum_k = sum(L[j][k] * U[k][i] for k in range(j)) U[j][i] = (A[j][i] - sum_k) / L[j][j] return L, U"},{"question":"# Sudoku Solver Challenge Problem Statement You are tasked with solving a standard 9x9 Sudoku puzzle using an efficient backtracking algorithm. The algorithm should start from cells with the fewest possible values to maximize the efficiency of the search process. Function Signature ```python def sudoku_solver(board: List[List[str]]) -> bool: pass ``` Input * `board` (List[List[str]]): A 2D list representing the 9x9 Sudoku grid. Each cell contains a digit from \'1\' to \'9\' or an empty cell represented by \'.\'. Output * (bool): Returns `True` if the puzzle was successfully solved, `False` otherwise. Additionally, modifies the board in-place to show the solution or partial solution. Constraints * The board will always be of size `9x9`. * Input board is partially filled and may contain \'.\' characters indicating empty cells. Edge Cases to Handle * Boards with conflicting initial values. * Boards solvable with minimal empty cells. * Boards with maximal empty cells requiring extensive backtracking. Expected Complexity * Aim to solve puzzles efficiently within practical constraints on typical puzzles. Performance should be well within acceptable limits. # Example ```python board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] sudoku_solver(board) # Expected output (in-place modification to the board): # [ # [\\"5\\",\\"3\\",\\"4\\",\\"6\\",\\"7\\",\\"8\\",\\"9\\",\\"1\\",\\"2\\"], # [\\"6\\",\\"7\\",\\"2\\",\\"1\\",\\"9\\",\\"5\\",\\"3\\",\\"4\\",\\"8\\"], # [\\"1\\",\\"9\\",\\"8\\",\\"3\\",\\"4\\",\\"2\\",\\"5\\",\\"6\\",\\"7\\"], # [\\"8\\",\\"5\\",\\"9\\",\\"7\\",\\"6\\",\\"1\\",\\"4\\",\\"2\\",\\"3\\"], # [\\"4\\",\\"2\\",\\"6\\",\\"8\\",\\"5\\",\\"3\\",\\"7\\",\\"9\\",\\"1\\"], # [\\"7\\",\\"1\\",\\"3\\",\\"9\\",\\"2\\",\\"4\\",\\"8\\",\\"5\\",\\"6\\"], # [\\"9\\",\\"6\\",\\"1\\",\\"5\\",\\"3\\",\\"7\\",\\"2\\",\\"8\\",\\"4\\"], # [\\"2\\",\\"8\\",\\"7\\",\\"4\\",\\"1\\",\\"9\\",\\"6\\",\\"3\\",\\"5\\"], # [\\"3\\",\\"4\\",\\"5\\",\\"2\\",\\"8\\",\\"6\\",\\"1\\",\\"7\\",\\"9\\"] # ] ``` Note While modifying the `sudoku_solver` function, ensure that the core principles of the backtracking algorithm, as highlighted in the analysis, are adhered to. Efficient management of possible values for each cell is crucial for reducing the problem\'s complexity.","solution":"from typing import List def sudoku_solver(board: List[List[str]]) -> bool: def is_valid(board, row, col, num): for i in range(9): if board[row][i] == num or board[i][col] == num: return False start_row = (row // 3) * 3 start_col = (col // 3) * 3 for i in range(start_row, start_row + 3): for j in range(start_col, start_col + 3): if board[i][j] == num: return False return True def find_empty(board): for i in range(9): for j in range(9): if board[i][j] == \'.\': return (i, j) return None def solve(board): empty_pos = find_empty(board) if not empty_pos: return True row, col = empty_pos for num in map(str, range(1, 10)): if is_valid(board, row, col, num): board[row][col] = num if solve(board): return True board[row][col] = \'.\' return False return solve(board)"},{"question":"Question Implement a function `is_match` that determines if a given input string `s` matches a pattern `p` which supports the wildcard characters `.` and `*`. # Requirements 1. The function should handle the entire input string. Partial matches are not acceptable. 2. `.` matches any single character. 3. `*` matches zero or more of the preceding element. # Function Signature ```python def is_match(s: str, p: str) -> bool: pass ``` # Constraints 1. `0 <= len(s), len(p) <= 1000` 2. Both `s` and `p` contain only lowercase English letters or the characters `.` and `*`. # Input - `s`: A string argument, the text to be matched. - `p`: A string argument, the pattern that may contain `.` and `*`. # Output - Returns `True` if the string matches the pattern, otherwise `False`. # Example Cases - Case 1: - Input: `s = \\"aa\\"`, `p = \\"a\\"` - Output: `False` - Case 2: - Input: `s = \\"aa\\"`, `p = \\"a*\\"` - Output: `True` - Case 3: - Input: `s = \\"ab\\"`, `p = \\".*\\"` - Output: `True` - Case 4: - Input: `s = \\"aab\\"`, `p = \\"c*a*b\\"` - Output: `True` # Explanation 1. For Case 1, the pattern `a` does not match the text `aa`. 2. For Case 2, `a*` can match `aa` since `*` allows zero or more of `a`. 3. For Case 3, `.*` can match any sequence of characters. 4. For Case 4, `c*` allows zero `c`s, `a*` matches `aa`, and `b` matches `b`. Ensure your implementation efficiently handles various edge cases and constraints.","solution":"def is_match(s: str, p: str) -> bool: dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True for j in range(1, len(p) + 1): if p[j-1] == \'*\': dp[0][j] = dp[0][j-2] for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j-1] == s[i-1] or p[j-1] == \'.\': dp[i][j] = dp[i-1][j-1] elif p[j-1] == \'*\': dp[i][j] = dp[i][j-2] if p[j-2] == s[i-1] or p[j-2] == \'.\': dp[i][j] = dp[i][j] or dp[i-1][j] return dp[len(s)][len(p)]"},{"question":"Objective: Implement a function that multiplies two positive integers using only bitwise operations. Scenario: You are working on a low-level programming task where you need to perform multiplication of two positive integers without using any of the traditional arithmetic operators (`*`, `/`, `+`, and `-`). Instead, you should use bitwise operations. This is especially useful in embedded systems or applications where minimal CPU instruction sets are preferable for performance and efficiency reasons. Requirements: * Implement a function `multiply_bitwise(x, y)` that takes two positive integers `x` and `y` as input and returns their product. * **Constraints**: * The input integers are non-negative and fit within the standard integer limits (e.g., 32-bit unsigned integer). * You cannot use `*`, `/`, `+`, or `-` operators. * Assume bitwise operations like `&`, `|`, `^`, `~`, and bit shifts (`<<`, `>>`) are allowed. Function Signature: ```python def multiply_bitwise(x: int, y: int) -> int: # Your implementation here ``` Examples: ```python multiply_bitwise(3, 4) # Expected Output: 12 multiply_bitwise(7, 5) # Expected Output: 35 multiply_bitwise(0, 9) # Expected Output: 0 multiply_bitwise(13, 13) # Expected Output: 169 ``` Explanation: * `multiply_bitwise(3, 4)` * Multiplying 3 and 4 should return 12 using only bitwise operations. * Carefully handle the carry and shifts to reproduce the multiplication process. Hints: * You may utilize the properties of binary numbers and bitwise shifts. * Consider breaking down the problem into summing shifted bits conditionally.","solution":"def multiply_bitwise(x, y): Multiplies two positive integers using only bitwise operations. result = 0 while y > 0: # If the least significant bit of y is set, add x to the result if y & 1: result = add_bitwise(result, x) # Double x and halve y x <<= 1 y >>= 1 return result def add_bitwise(a, b): Adds two numbers using bitwise operations. while b != 0: carry = a & b a = a ^ b b = carry << 1 return a"},{"question":"Scenario You are tasked with developing a system that can efficiently compute the shortest paths between any two locations in a city. To achieve this, you need to implement the Floyd-Warshall algorithm, which will allow you to find the shortest paths between all pairs of locations given the initial road distances. Task Write a function `all_pairs_shortest_path` that takes an `n x n` matrix `adjacency_matrix` as input, where `adjacency_matrix[i][j]` represents the distance from location `i` to location `j`. The function should return a new `n x n` matrix containing the shortest distances between each pair of locations. Input - `adjacency_matrix`: A 2D list of size `n x n` (0 ≤ n ≤ 100), where `adjacency_matrix[i][j]` represents the distance between location `i` and location `j`. Output - Return a 2D list of size `n x n` containing the shortest distances between each pair of locations. Constraints - The distances are non-negative floating-point numbers. - The distance from any location to itself is 0. Example ```python adjacency_matrix = [ [0 , 0.1 , 0.101, 0.142, 0.277], [0.465, 0 , 0.191, 0.192, 0.587], [0.245, 0.554, 0 , 0.333, 0.931], [1.032, 0.668, 0.656, 0 , 0.151], [0.867, 0.119, 0.352, 0.398, 0] ] result = all_pairs_shortest_path(adjacency_matrix) ``` Expected output: ```python [ [0 , 0.1 , 0.101, 0.142, 0.277], [0.436, 0 , 0.191, 0.192, 0.343], [0.245, 0.345, 0 , 0.333, 0.484], [0.706, 0.27 , 0.461, 0 , 0.151], [0.555, 0.119, 0.31 , 0.311, 0] ] ``` Function Signature ```python def all_pairs_shortest_path(adjacency_matrix: List[List[float]]) -> List[List[float]]: pass ```","solution":"def all_pairs_shortest_path(adjacency_matrix): Implement the Floyd-Warshall algorithm to find the shortest paths between all pairs of locations. n = len(adjacency_matrix) # Initialize the distance matrix with the adjacency matrix values dist = [[float(\'inf\')] * n for _ in range(n)] for i in range(n): for j in range(n): if i == j: dist[i][j] = 0 else: dist[i][j] = adjacency_matrix[i][j] # Floyd-Warshall algorithm for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist"},{"question":"# Power Checker Functions Implement a function that checks if a given number is a power of two. Additionally, write a function that checks if a given number is a power of three. 1. Power of Two Check: Write a function `is_power_of_two(n)` that takes an integer `n` and returns `True` if `n` is a power of two, otherwise `False`. # Input: * An integer `n`. # Output: * `True` if `n` is a power of two, `False` otherwise. # Constraints: * The integer can be positive, zero, or negative. Example: ```python is_power_of_two(1) # Returns True, as 2^0 = 1 is_power_of_two(16) # Returns True, as 2^4 = 16 is_power_of_two(18) # Returns False, as 18 is not a power of two is_power_of_two(-4) # Returns False, as negative numbers cannot be powers of two ``` 2. Power of Three Check: Write a function `is_power_of_three(n)` that takes an integer `n` and returns `True` if `n` is a power of three, otherwise `False`. # Input: * An integer `n`. # Output: * `True` if `n` is a power of three, `False` otherwise. # Constraints: * The integer can be positive, zero, or negative. # Performance Requirements: * The solution should be efficient with respect to both time and space. Example: ```python is_power_of_three(1) # Returns True, as 3^0 = 1 is_power_of_three(27) # Returns True, as 3^3 = 27 is_power_of_three(45) # Returns False, as 45 is not a power of three is_power_of_three(-9) # Returns False, as negative numbers cannot be powers of three ```","solution":"def is_power_of_two(n): Checks if the given number n is a power of two. if n <= 0: return False return (n & (n - 1)) == 0 def is_power_of_three(n): Checks if the given number n is a power of three. if n <= 0: return False while n % 3 == 0: n //= 3 return n == 1"},{"question":"You are provided with an array of integers and a non-negative integer k. Write a function `rotate_array(array, k)` that rotates the array to the right by k steps in the most optimal way in terms of time and space efficiency. # Input * `array` (List[int]): The input array of integers. The length of the array can range from 0 to 10^5. * `k` (int): The number of steps to rotate the array. k can range from 0 to 10^9. # Output * The function should return the rotated array. # Constraints * The function must handle large k by performing modulus operation, * The array must be modified in-place to ensure constant space complexity O(1), * The solution\'s time complexity should be O(n). # Example ```python rotate_array([1, 2, 3, 4, 5, 6, 7], 3) # Output: [5, 6, 7, 1, 2, 3, 4] rotate_array([1, 2, 3, 4, 5], 12) # Output: [4, 5, 1, 2, 3] rotate_array([], 1) # Output: [] rotate_array([1, 2, 3], 0) # Output: [1, 2, 3] ``` Feel free to write helper functions if needed and ensure the resulting code is readable and well commented.","solution":"def rotate_array(array, k): Rotates the given array to the right by k steps. Parameters: array (List[int]): The input array of integers. k (int): The number of steps to rotate the array. Returns: List[int]: The rotated array. n = len(array) if n == 0: return array k = k % n # Effective rotations needed # Reverse the elements of the entire array array.reverse() # Reverse the first k elements array[:k] = reversed(array[:k]) # Reverse the remaining n-k elements array[k:] = reversed(array[k:]) return array"},{"question":"Problem Statement You are given a list of tasks and dependencies among them. Each task is represented by a unique integer, and dependencies are given as a list of pairs [A, B] which indicates that task A must be performed before task B. Your objective is to determine the order in which to execute all the tasks such that all the dependencies are honored. If it\'s not possible to complete all tasks due to cyclic dependencies, output an appropriate message indicating the cycle. Implement a function `task_order(tasks: List[int], dependencies: List[List[int]]) -> List[int]` which returns the order of tasks or raises an exception if there is a cycle. # Input: - `tasks`: A list of integers representing the unique tasks. - `dependencies`: A list of pair lists where each pair [A, B] denotes a dependency that task A must be done before task B. # Output: - A list of integers representing the order of completing tasks. - Raise a `ValueError(\\"cycle detected\\")` if there is a cycle in the dependencies. # Constraints: - All task numbers are unique. - The graph representing the tasks and dependencies is a Directed Acyclic Graph (DAG). # Example: ```python tasks = [1, 2, 3, 4, 5, 6] dependencies = [[1, 2], [1, 3], [3, 4], [2, 5], [5, 6]] task_order(tasks, dependencies) # Output: [1, 3, 4, 2, 5, 6] or any other valid topological order ``` # Additional Notes: Ensure that the implemented solution handles edge cases such as: - Tasks with no dependencies. - Tasks that are already isolated (no dependencies both ways). - Tasks forming disconnected sub-graphs within the main graph.","solution":"from collections import defaultdict, deque from typing import List def task_order(tasks: List[int], dependencies: List[List[int]]) -> List[int]: # Initialize the graph structure graph = defaultdict(list) indegree = {task: 0 for task in tasks} # Build the graph and indegree count for pre, post in dependencies: graph[pre].append(post) indegree[post] += 1 # Find initial nodes with zero indegree zero_indegree_queue = deque([task for task in tasks if indegree[task] == 0]) order = [] while zero_indegree_queue: current_task = zero_indegree_queue.popleft() order.append(current_task) for neighbour in graph[current_task]: indegree[neighbour] -= 1 if indegree[neighbour] == 0: zero_indegree_queue.append(neighbour) # Check if we processed all tasks if len(order) == len(tasks): return order else: raise ValueError(\\"cycle detected\\")"},{"question":"Given a list of strings `words`, write a function `find_keyboard_row(words)` that returns a list containing words that can be typed using letters on only one row of the American keyboard. Your solution should check each word and determine if all its characters are confined to one of the three keyboard rows: - Top row: QWERTYUIOP - Middle row: ASDFGHJKL - Bottom row: ZXCVBNM # Input - `words`: List of strings representing words, with general constraints - Each word contains only alphabetic characters. - The list contains between 1 and 1000 words. - Words have lengths between 1 and 50 characters. # Output - A list of strings from the input list `words` that can be typed using a single row on the keyboard. # Example Input ```python words = [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] ``` Output ```python [\\"Alaska\\", \\"Dad\\"] ``` # Constraints - Solutions must handle words with mixed-case characters by treating them as lowercase. - Solutions should be efficient and consider both time complexity and space complexity. # Performance Requirements - Aim for an O(n * m) time complexity, where n is the number of words and m is the average length of the words. # Function Signature ```python def find_keyboard_row(words: List[str]) -> List[str]: pass ``` # Notes Ensure to handle edge cases, such as words that span multiple rows or an empty list.","solution":"def find_keyboard_row(words): Returns a list of words that can be typed using letters on only one row of the American keyboard. # Define keyboard rows top_row = set(\\"qwertyuiop\\") middle_row = set(\\"asdfghjkl\\") bottom_row = set(\\"zxcvbnm\\") result = [] for word in words: lower_word = set(word.lower()) if lower_word <= top_row or lower_word <= middle_row or lower_word <= bottom_row: result.append(word) return result"},{"question":"# Question: Advanced Pathfinding in Directed Graphs You are tasked with implementing pathfinding algorithms in a directed graph. Your goal is to write efficient functions for finding any path, all paths, and the shortest path between two nodes. The graph is represented as a dictionary where keys are node identifiers and values are lists of node identifiers directly accessible from the key node. Requirements: 1. **Function 1**: `find_path(graph, start, end)` - Should find any path between the `start` and `end` nodes. If no path exists, return `None`. 2. **Function 2**: `find_all_paths(graph, start, end)` - Should return a list of all paths between `start` and `end`. 3. **Function 3**: `find_shortest_path(graph, start, end)` - Should find the shortest path between `start` and `end` nodes. If no path exists, return `None`. Constraints: - The `graph` is a non-empty dictionary. - Nodes are represented as strings. - Circular dependencies may exist. - The graph can be disconnected. Inputs and Outputs - `graph`: Dictionary representing the graph. - `start`: String representing the starting node. - `end`: String representing the end node. Examples: # Example 1: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [\'C\'], \'E\': [\'F\'], \'F\': [\'C\'] } ``` - `find_path(graph, \'A\', \'D\')` might return `[\'A\', \'B\', \'D\']`. - `find_all_paths(graph, \'A\', \'D\')` should return `[[\'A\', \'B\', \'D\'], [\'A\', \'B\', \'C\', \'D\'], [\'A\', \'C\', \'D\']]`. - `find_shortest_path(graph, \'A\', \'D\')` should return `[\'A\', \'B\', \'D\']`. # Example 2: ```python graph = { \'X\': [\'Y\'], \'Y\': [\'Z\'], \'Z\': [] } ``` - `find_path(graph, \'X\', \'Z\')` might return `[\'X\', \'Y\', \'Z\']`. - `find_all_paths(graph, \'X\', \'Z\')` should return `[[\'X\', \'Y\', \'Z\']]`. - `find_shortest_path(graph, \'X\', \'Z\')` should return `[\'X\', \'Y\', \'Z\']`. Implement the required functions to fulfill the criteria above.","solution":"def find_path(graph, start, end, path=[]): Finds any path from start to end in the given graph. If no path exists, returns None. path = path + [start] if start == end: return path if start not in graph: return None for node in graph[start]: if node not in path: newpath = find_path(graph, node, end, path) if newpath: return newpath return None def find_all_paths(graph, start, end, path=[]): Finds all paths from start to end in the given graph. Returns a list of all paths. path = path + [start] if start == end: return [path] if start not in graph: return [] paths = [] for node in graph[start]: if node not in path: newpaths = find_all_paths(graph, node, end, path) for newpath in newpaths: paths.append(newpath) return paths def find_shortest_path(graph, start, end, path=[]): Finds the shortest path from start to end in the given graph. If no path exists, returns None. path = path + [start] if start == end: return path if start not in graph: return None shortest = None for node in graph[start]: if node not in path: newpath = find_shortest_path(graph, node, end, path) if newpath: if not shortest or len(newpath) < len(shortest): shortest = newpath return shortest"},{"question":"# Regular Expression Matching with Dynamic Programming Problem Statement You are required to implement a function `is_match` that determines if a given input string matches a pattern string, which includes the special characters \'.\' and \'*\'. * `.` Matches any single character. * `*` Matches zero or more of the preceding element. The matching should encompass the entire input string (i.e., not partial). Function Signature ```python def is_match(s: str, p: str) -> bool: Determines if the input string s matches the pattern p. Parameters: s (str): Input string consisting of lowercase letters. p (str): Pattern string consisting of lowercase letters, \'.\' and \'*\'. Returns: bool: True if the input string matches the pattern string, otherwise False. ``` Input and Output Format * **Input**: - `s`: A string (1 <= len(s) <= 30) consisting of lowercase letters. - `p`: A string (1 <= len(p) <= 30) consisting of lowercase letters, \'.\' and \'*\'. * **Output**: - Returns `True` if the input string matches the pattern string completely. - Returns `False` otherwise. Examples ```python print(is_match(\\"aa\\", \\"a\\")) # Output: False print(is_match(\\"aa\\", \\"aa\\")) # Output: True print(is_match(\\"aaa\\", \\"aa\\")) # Output: False print(is_match(\\"aa\\", \\"a*\\")) # Output: True print(is_match(\\"aa\\", \\".*\\")) # Output: True print(is_match(\\"ab\\", \\".*\\")) # Output: True print(is_match(\\"aab\\", \\"c*a*b\\")) # Output: True ``` Constraints and Limitations * The input strings and patterns will have a maximum length of 30 characters. * The pattern will only use lowercase letters, \'.\' and \'*\'. * Ensure the solution operates within O(m*n) time complexity. Points to Consider * Handle edge cases where the pattern string is empty or contains misplaced `*` characters. * Optimize memory usage when feasible by reducing the DP table size if possible.","solution":"def is_match(s: str, p: str) -> bool: Determines if the input string s matches the pattern p. dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True # Deals with patterns like a*, a*b*, a*b*c* that can match empty string for j in range(2, len(p) + 1, 2): dp[0][j] = dp[0][j-2] and p[j-1] == \'*\' for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j-1] == \'.\' or p[j-1] == s[i-1]: dp[i][j] = dp[i-1][j-1] elif p[j-1] == \'*\': dp[i][j] = dp[i][j-2] or (dp[i-1][j] and (p[j-2] == s[i-1] or p[j-2] == \'.\')) return dp[len(s)][len(p)]"},{"question":"# Graph Traversal and Pathfinding **Scenario**: You are tasked with developing a navigation system for a small robot that must traverse a grid-based environment. The robot needs to find a path from its starting position to a target position. The environment can be represented as a graph where each cell is a node and edges exist between adjacent cells (left, right, up, down), unless a cell is blocked. **Task**: Implement a function to find if there exists a path between the starting position and the target position using both DFS and BFS algorithms. **Function Signature**: ```python def find_path_dfs(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> bool: pass def find_path_bfs(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> bool: pass ``` **Input**: - `grid`: A 2D list of integers where `0` represents an open cell and `1` represents a blocked cell. - `start`: A tuple `(x, y)` representing the robot\'s starting coordinates. - `target`: A tuple `(x, y)` representing the target coordinates. **Output**: - Return `True` if there exists a path from `start` to `target`, otherwise `False`. **Constraints**: - The grid dimensions are between 1x1 and 100x100. - The start and target positions are within the grid bounds. **Example**: ```python grid = [ [0, 0, 0, 1], [1, 0, 1, 0], [0, 0, 0, 0], [1, 0, 1, 0] ] start = (0, 0) target = (2, 2) print(find_path_dfs(grid, start, target)) # Output: True print(find_path_bfs(grid, start, target)) # Output: True ``` **Notes**: 1. Ensure to handle edge cases like start or target being blocked or identical. 2. Implement the solution first using DFS (both iterative and recursive) and then with BFS. 3. Optimize for performance and handle large inputs efficiently.","solution":"from typing import List, Tuple def find_path_dfs(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> bool: def dfs(x, y): if not (0 <= x < len(grid) and 0 <= y < len(grid[0])) or grid[x][y] == 1: return False if (x, y) == target: return True grid[x][y] = 1 # Mark the cell as visited # Explore neighbors for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: if dfs(x + dx, y + dy): return True return False return dfs(start[0], start[1]) def find_path_bfs(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> bool: from collections import deque x_max, y_max = len(grid), len(grid[0]) queue = deque([start]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] if grid[start[0]][start[1]] == 1 or grid[target[0]][target[1]] == 1: return False while queue: x, y = queue.popleft() if (x, y) == target: return True if not (0 <= x < x_max and 0 <= y < y_max) or grid[x][y] == 1: continue grid[x][y] = 1 # Mark the cell as visited for dx, dy in directions: new_x, new_y = x + dx, y + dy if 0 <= new_x < x_max and 0 <= new_y < y_max and grid[new_x][new_y] == 0: queue.append((new_x, new_y)) return False"},{"question":"# Question: Implement and Enhance a Resizable HashTable As a software engineer, you have been tasked with implementing a more advanced hash table based on a provided skeleton. Your resizable hash table should support put, get, and delete operations efficiently, handling collisions and resizing automatically. Additionally, you need to implement a function that rehashes the table with quadratic probing to mitigate clustering issues. **Implementation Details**: 1. **Class**: `AdvancedHashTable` 2. **Inheritance**: Inherit from the given `HashTable` class, implementing necessary resizing and advanced collision resolution. 3. **Key Methods**: - `put(self, key, value)`: Inserts key-value pairs, resizing if needed. - `get(self, key)`: Retrieves the value for the given key. - `del_(self, key)`: Deletes the key-value pair. - `__resize(self)`: Resizes the table when reaching 2/3 capacity, using quadratic probing. **Additional Task**: Implement quadratic probing for collision resolution in the `AdvancedHashTable`. **Input/Output**: - Your implementation should allow usual dictionary-like operations, e.g., adding, accessing, and deleting items. - Ensure that the table resizes correctly and maintains performance. **Constraints**: - Handle edge cases, such as multiple keys mapping to the same initial hash index, deletions, and table resizing. # Example ```python ht = AdvancedHashTable() ht.put(1, \'one\') ht.put(2, \'two\') print(ht.get(1)) # Output: \'one\' print(len(ht)) # Output: 2 ht.del_(1) print(ht.get(1)) # Output: None ``` **Note**: You should not modify the core methods defined in `HashTable`. Only override where necessary and focus on the quadratic probing for rehashing.","solution":"class HashTable: def __init__(self, size=8): self.size = size self.table = [None] * size self.count = 0 def _hash(self, key): return hash(key) % self.size def put(self, key, value): index = self._hash(key) while self.table[index] is not None: # linear probing index = (index + 1) % self.size self.table[index] = (key, value) self.count += 1 def get(self, key): index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.size return None def del_(self, key): index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.count -= 1 return index = (index + 1) % self.size class AdvancedHashTable(HashTable): def put(self, key, value): if (self.count + 1) / self.size > 2/3: self.__resize() super().put(key, value) def _hash(self, key): return hash(key) % self.size def __resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for entry in old_table: if entry is not None: self.put(*entry) def _quadratic_probe(self, key, i): return (self._hash(key) + i**2) % self.size def put(self, key, value): if (self.count + 1) / self.size > 2 / 3: self.__resize() index = self._hash(key) i = 0 while self.table[index] is not None and self.table[index][0] != key: i += 1 index = self._quadratic_probe(key, i) if self.table[index] is None: self.count += 1 self.table[index] = (key, value) def get(self, key): index = self._hash(key) i = 0 while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] i += 1 index = self._quadratic_probe(key, i) return None def del_(self, key): index = self._hash(key) i = 0 while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.count -= 1 return i += 1 index = self._quadratic_probe(key, i)"},{"question":"# Question Imagine you are building a dynamic range query system for a competitive programming platform. The system needs to handle a dynamic array of integers, allowing efficient queries and updates. Given the following requirements: * Efficiently compute the sum of elements in a specific range. * Efficiently update an element at a specific position. # Task Implement a class `RangeQuerySystem` using segment trees. Your implementation should support the following methods: 1. `__init__(self, arr: List[int]) -> None`: Constructs the segment tree from the given list of integers. 2. `update(self, index: int, value: int) -> None`: Updates the element at the specified index to the new value. 3. `range_sum(self, left: int, right: int) -> int`: Returns the sum of the elements in the range ([left, right]). # Constraints * The initial array length: (1 leq N leq 10^5) * Element values: (-10^9 leq text{arr[i]} leq 10^9) * Number of queries: (1 leq Q leq 10^5) # Function Signature ```python class RangeQuerySystem: def __init__(self, arr: List[int]) -> None: pass def update(self, index: int, value: int) -> None: pass def range_sum(self, left: int, right: int) -> int: pass ``` # Examples ```python # Example 1 arr = [1, 3, 5] rq = RangeQuerySystem(arr) print(rq.range_sum(0, 2)) # Output: 9 rq.update(1, 2) print(rq.range_sum(0, 2)) # Output: 8 # Example 2 arr = [2, 4, 6, 8, 10] rq = RangeQuerySystem(arr) print(rq.range_sum(1, 3)) # Output: 18 rq.update(2, 7) print(rq.range_sum(1, 3)) # Output: 19 ```","solution":"from typing import List class RangeQuerySystem: def __init__(self, arr: List[int]) -> None: self.n = len(arr) self.seg_tree = [0] * (4 * self.n) self.arr = arr self._build(arr, 0, 0, self.n - 1) def _build(self, arr: List[int], node: int, start: int, end: int): if start == end: self.seg_tree[node] = arr[start] else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self._build(arr, left_child, start, mid) self._build(arr, right_child, mid + 1, end) self.seg_tree[node] = self.seg_tree[left_child] + self.seg_tree[right_child] def _update(self, node: int, start: int, end: int, idx: int, value: int): if start == end: self.arr[idx] = value self.seg_tree[node] = value else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 if start <= idx <= mid: self._update(left_child, start, mid, idx, value) else: self._update(right_child, mid + 1, end, idx, value) self.seg_tree[node] = self.seg_tree[left_child] + self.seg_tree[right_child] def update(self, index: int, value: int) -> None: self._update(0, 0, self.n - 1, index, value) def _range_sum(self, node: int, start: int, end: int, l: int, r: int) -> int: if r < start or end < l: return 0 if l <= start and end <= r: return self.seg_tree[node] mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 left_sum = self._range_sum(left_child, start, mid, l, r) right_sum = self._range_sum(right_child, mid + 1, end, l, r) return left_sum + right_sum def range_sum(self, left: int, right: int) -> int: return self._range_sum(0, 0, self.n - 1, left, right)"},{"question":"# Prime Pair Finder You are working on a cryptography application and need to find pairs of prime numbers that sum up as required pairs. Problem Statement Write a function: ```python def find_prime_pairs(n): Given a number n, return all unique pairs of prime numbers (p1, p2) such that p1 + p2 = n. Parameters: * n (int): The target sum of the prime pairs. Returns: * List[Tuple[int, int]]: A list of unique pairs of primes that sum up to n. pass ``` Input - An integer `n` (2 ≤ n ≤ 10^6) representing the target sum of prime pairs. Output - A list of tuples where each tuple `(p1, p2)` contains two prime numbers such that `p1 + p2 = n`. - Each pair should be listed in ascending order based on the first element of the tuple. - The primes `p1` and `p2` should also be ordered such that `p1 ≤ p2` to ensure uniqueness. Constraints - Prime numbers are natural numbers greater than 1 that are not divisible by any word other than 1 and itself. Example ```python assert find_prime_pairs(10) == [(3, 7), (5, 5)] assert find_prime_pairs(26) == [(3, 23), (7, 19), (13, 13)] ``` Performance Considerations should be made to ensure the function runs efficiently within the provided range of `n`.","solution":"from typing import List, Tuple def is_prime(n: int) -> bool: Check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False limit = int(n ** 0.5) for i in range(3, limit + 1, 2): if n % i == 0: return False return True def find_prime_pairs(n: int) -> List[Tuple[int, int]]: Given a number n, return all unique pairs of prime numbers (p1, p2) such that p1 + p2 = n. prime_pairs = [] for i in range(2, n // 2 + 1): if is_prime(i) and is_prime(n - i): prime_pairs.append((i, n - i)) return prime_pairs"},{"question":"# Question: Maximum Depth of Binary Tree You are given a binary tree and need to determine its maximum depth. The maximum depth is defined as the number of nodes along the longest path from the root node down to the farthest leaf node. # Function Signature ```python def max_depth(root: TreeNode) -> int: pass ``` # Input: - `root`: The root node of the binary tree (instance of `TreeNode`). # Output: - Return an integer representing the maximum depth of the binary tree. # Constraints: - The number of nodes in the tree is in the range `[0, 1000]`. - The value of each node is in the range `[1, 1000]`. # Examples: 1. Given the binary tree: ``` 3 / 9 20 / 15 7 ``` Output: `3` 2. Given the binary tree: ``` 1 2 3 4 5 ``` Output: `5` # Additional Information 1. Edge cases to consider include an empty tree where the root is `None` and a tree with only one node. 2. Ensure that your solution efficiently handles large and skewed trees within the given constraints.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root: TreeNode) -> int: if not root: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Question: Advanced GCD Algorithm Implementation Challenge Context: You are assigned to optimize a mathematical software\'s function library. One of the critical functions you need to enhance involves calculating the greatest common divisor (GCD) of large integers efficiently using bitwise operations and handling special error states. Task: Write a function `optimized_gcd(a: int, b: int) -> int` that: 1. Computes the greatest common divisor (GCD) of two non-negative integers `a` and `b` using bitwise operations. 2. Handles special cases where `a` or `b` is zero or negative, returning appropriate error messages. The function should raise a `ValueError` with the message `\\"Inputs must be non-negative integers\\"` if any of the inputs is negative. 3. If both integers are zero, raise a `ValueError` with the message `\\"Both inputs are zero\\"`. 4. Use efficient techniques, including but not limited to bitwise operations and avoiding repetitive calculations. Input: * Two non-negative integers, `a` and `b`. Output: * An integer representing the GCD of `a` and `b`. Constraints: * Time Complexity should be optimized for large values (upwards of 10^18). * Must handle edge cases involving zero and negative integers as mentioned. Requirements: 1. Function signature: `def optimized_gcd(a: int, b: int) -> int:` 2. Include proper error handling as described. 3. Optimize the implementation avoiding unnecessary operations. Example: 1. `optimized_gcd(48, 18) -> 6` 2. `optimized_gcd(0, 0) -> ValueError: \\"Both inputs are zero\\"` 3. `optimized_gcd(-1, 18) -> ValueError: \\"Inputs must be non-negative integers\\"`","solution":"def optimized_gcd(a: int, b: int) -> int: Computes the greatest common divisor (GCD) of two non-negative integers using bitwise operations. Raises ValueError for invalid inputs. if a < 0 or b < 0: raise ValueError(\\"Inputs must be non-negative integers\\") if a == 0 and b == 0: raise ValueError(\\"Both inputs are zero\\") if a == 0: return b if b == 0: return a # Greatest common divisor bitwise algorithm (Stein\'s Algorithm) shift = 0 while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b = b - a gcd = a << shift return gcd"},{"question":"# Single Number Finder Problem Statement: Given an integer array `nums` where every element appears twice except for one, write a function to find that single one. Implement the function `single_number(nums)` that: * Takes a list of integers `nums` as input. * Returns the integer that appears exactly once in the list. Ensure your solution demonstrates understanding of the XOR bitwise operation, meets the following constraints, and adheres to the performance requirement of linear runtime complexity and constant space complexity. Constraints: 1. The array `nums` will have a length in the range `[1, 10^5]`. 2. Each integer in `nums` is in the range `[-3 * 10^4, 3 * 10^4]`. Input: * `nums`: A list of integers of length between 1 and 100,000, with each integer between -30,000 and 30,000. Output: * An integer representing the single element that appears only once. Examples: ```python single_number([2,2,1]) # Output: 1 single_number([4,1,2,1,2]) # Output: 4 single_number([1]) # Output: 1 ``` Additional Notes: - You are encouraged to implement the solution using the bitwise XOR approach for optimal performance. - Consider edge cases such as an array with only one element.","solution":"def single_number(nums): Finds the single number in a list of integers where every element, except for one, appears twice. Uses XOR to find the single non-repeating element. single = 0 for num in nums: single ^= num return single"},{"question":"You are given an unsorted array consisting of integers. Your goal is to sort this array in ascending order using the **Pancake Sort** algorithm. This sorting algorithm sorts elements by repeatedly using a flip operation — flipping the order of elements in the array from position 0 to a given index. # Function Signature ```python def pancake_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`: A list of integers (at least one element and up to 1000 elements). # Output * Return a new list of integers sorted in ascending order. # Constraints * `1 <= len(arr) <= 1000` * Elements of `arr` are integers and can include negative numbers. # Performance Requirement * The solution should sort the array in O(N^2) time complexity. * The function should operate in-place, not using any additional data structures beyond the list to be sorted. # Example ```python assert pancake_sort([3, 2, 4, 1]) == [1, 2, 3, 4] assert pancake_sort([10, 3, 5, 2]) == [2, 3, 5, 10] assert pancake_sort([1, 2, 3]) == [1, 2, 3] ``` # Explanation You need to implement the `pancake_sort` function that performs the sorting by flipping subarrays within the given list. Your implementation should identify the maximum unsorted element, move it to the correct position, and continue this process until the entire array is sorted.","solution":"from typing import List def flip(arr: List[int], k: int) -> None: Function to reverse the array from start to k index. arr[:k+1] = arr[:k+1][::-1] def find_max_index(arr: List[int], n: int) -> int: Function to find the index of the maximum element in arr[:n+1] max_index = 0 for i in range(1, n + 1): if arr[i] > arr[max_index]: max_index = i return max_index def pancake_sort(arr: List[int]) -> List[int]: Function to sort an array using the Pancake Sort algorithm. curr_size = len(arr) while curr_size > 1: max_index = find_max_index(arr, curr_size - 1) if max_index != curr_size - 1: # Flip the maximum number to the front flip(arr, max_index) # Flip it to its correct position flip(arr, curr_size - 1) curr_size -= 1 return arr"},{"question":"You are given the task of implementing a function to compute the binomial coefficient, ( C(n, k) ), using recursion. The binomial coefficient ( C(n, k) ) is defined as the number of ways to choose ( k ) elements from a set of ( n ) elements. It\'s represented mathematically as: [ C(n, k) = begin{cases} 1 & text{if } k = 0 text{ or } k = n frac{n}{k} cdot C(n-1, k-1) & text{if } 0 < k < n end{cases} ] Your task is to complete the function `recursive_binomial_coefficient(n, k)` which computes ( C(n, k) ). # Function Signature ```python def recursive_binomial_coefficient(n, k): ``` # Input The function accepts two integers: * `n` (an integer, where ( n geq k )) * `k` (an integer, where ( 0 leq k leq n )) # Output * The function should return an integer representing the binomial coefficient ( C(n, k) ). # Constraints * You can assume that ( n ) and ( k ) are integers where ( n geq k geq 0 ). * The function should be efficient enough to handle large inputs, potentially up to ( n = 1000 ) and ( k = 500 ). # Example ```python >>> recursive_binomial_coefficient(5, 2) 10 >>> recursive_binomial_coefficient(8, 3) 56 ``` # Notes * You should consider optimization techniques such as using the relationship ( C(n, k) = C(n, n-k) ) to simplify the problem. * Make sure to handle edge cases such as when ( k = 0 ) or ( k = n ), and provide meaningful error messages or checks where necessary. Implement the function `recursive_binomial_coefficient` based on the description provided.","solution":"def recursive_binomial_coefficient(n, k): Compute the binomial coefficient C(n, k) recursively. if k == 0 or k == n: return 1 elif k > n: return 0 else: return recursive_binomial_coefficient(n - 1, k - 1) + recursive_binomial_coefficient(n - 1, k)"},{"question":"**Rotational Equivalence of Strings** Given two strings `s1` and `s2`, write a function `is_rotated` that determines if `s2` is a rotated version of `s1`. A string `s2` is considered a rotated version of `s1` if all the characters of `s1` can be shifted in a circular manner to match `s2`. Function Signature: ```python def is_rotated(s1: str, s2: str) -> bool: ``` Input: * `s1` (0 <= len(s1) <= 10^4): A string consisting of lowercase alphabets. * `s2` (0 <= len(s2) <= 10^4): A string consisting of lowercase alphabets. Output: * Return `True` if `s2` is a rotated version of `s1`, otherwise return `False`. Constraints: * Both strings contain only lowercase English letters. * Performance requirements: Aim for an efficient solution, preferably with linear time complexity. Examples: 1. `is_rotated(\\"hello\\", \\"llohe\\")` should return `True`. 2. `is_rotated(\\"hello\\", \\"helol\\")` should return `False`. 3. `is_rotated(\\"abcde\\", \\"cdeab\\")` should return `True`. 4. `is_rotated(\\"abcde\\", \\"abced\\")` should return `False`. 5. `is_rotated(\\"\\", \\"\\")` should return `True`. 6. `is_rotated(\\"a\\", \\"a\\")` should return `True`. 7. `is_rotated(\\"a\\", \\"\\")` should return `False`. Notes: * Optimize the function to handle large inputs efficiently. * Consider all possible edge cases. Example Solution: ```python def is_rotated(s1, s2): if len(s1) != len(s2): return False return s2 in s1 + s1 ``` Ensure that your implementation correctly handles all the provided example cases and adheres to the performance expectations.","solution":"def is_rotated(s1: str, s2: str) -> bool: Determines if s2 is a rotated version of s1. if len(s1) != len(s2): return False return s2 in s1 + s1"},{"question":"# Subset Generation Challenge **Context**: As part of a combinatorial optimization project, you need to explore all possible configurations of a set of distinct tasks represented as integers. Your task is to generate all possible subsets of given tasks. **Problem**: Write a function to generate all possible subsets from a given list of distinct integers. **Function Signature**: ```python def generate_all_subsets(nums: List[int]) -> List[List[int]]: pass ``` # Input - A list of distinct integers, `nums` (1 ≤ len(nums) ≤ 12). # Output - A list of lists representing all possible subsets of the input list. Each subset is a list of integers. # Performance Requirements - The solution must be able to handle the upper limit of input size efficiently, considering the exponential growth of subsets. # Example ```python # Example 1 input: [1, 2, 3] output: [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] # Example 2 input: [4, 5] output: [[], [4], [5], [4, 5]] ``` # Constraints - Input set will contain distinct integers. - Output should not contain any duplicate subsets. - Subsets can be returned in any order. **Additional Notes**: Make sure to handle edge cases like empty input list and single element list correctly.","solution":"from typing import List def generate_all_subsets(nums: List[int]) -> List[List[int]]: Generates all possible subsets of a given list of distinct integers. :param nums: List of distinct integers :return: List of lists, each representing a possible subset def backtrack(start, path): subsets.append(path) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) subsets = [] backtrack(0, []) return subsets"},{"question":"Context: You have been given the task of designing an exercise for a physical education class. This exercise involves climbing a staircase with a specific number of steps (a positive integer `steps`). Each time you move, you can choose to either climb 1 step or 2 steps. Your goal is to determine in how many distinct ways the students can reach the top of the staircase. Objective: Write a function `climb_stairs_optimized` that determines the number of distinct ways to reach the top of the staircase using an optimized approach for space complexity. Function Signature: ```python def climb_stairs_optimized(steps: int) -> int: :param steps: int - the total number of steps in the staircase :return: int - the number of distinct ways to reach the top ``` Input: - `steps`: A positive integer representing the total number of steps in the staircase. Output: - The function should return an integer representing the number of distinct ways to reach the top of the staircase. Constraints: - You must optimize the space complexity of your solution to O(1). - Assume steps will always be a positive integer (1 ≤ steps ≤ 10^6). Examples: 1. `climb_stairs_optimized(2)` should return `2` since there are two ways to reach the top: (1 step + 1 step) or (2 steps). 2. `climb_stairs_optimized(3)` should return `3` as there are three ways to reach the top: (1 step + 1 step + 1 step), (1 step + 2 steps), (2 steps + 1 step). Notes: - Think about how you can utilize previously computed results to minimize space usage. - Consider the iterative approach that leverages a minimal number of variables to keep track of results.","solution":"def climb_stairs_optimized(steps: int) -> int: Determines the number of distinct ways to reach the top of the staircase. :param steps: int - the total number of steps in the staircase :return: int - the number of distinct ways to reach the top if steps == 1: return 1 elif steps == 2: return 2 prev1, prev2 = 1, 2 for _ in range(3, steps + 1): current = prev1 + prev2 prev1, prev2 = prev2, current return prev2"},{"question":"# Context You are developing a segment tree that will allow you to perform efficient range queries and point updates on a sequence of numbers. This data structure will effectively handle operations with logarithmic complexity. # Task Implement the following functionalities in a class `SegmentTree`: 1. **Initialization**: Create a segment tree for a given list of elements using a commutative function. 2. **Query**: Return the result of the commutative function over a subrange of the list. 3. **Update**: Update a specific element in the list and adjust the segment tree accordingly. # Function Signatures ```python class SegmentTree: def __init__(self, arr: List[Any], function: Callable[[Any, Any], Any]): Initializes the segment tree with a given list of elements and a commutative function. Parameters: arr (List[Any]): The list of elements. function (Callable[[Any, Any], Any]): A commutative function. pass def update(self, p: int, v: Any): Update the element at index `p` to value `v` and adjust the segment tree. Parameters: p (int): Index in the original list to update. v (Any): New value for the element. pass def query(self, l: int, r: int) -> Any: Perform a range query from index `l` to `r` and return the result. Parameters: l (int): The start index of the query range. r (int): The end index of the query range. Returns: Any: The result of the commutative function over the range. pass ``` # Constraints - Ensure that `l` and `r` are within the array bounds: `0 <= l <= r < len(arr)` - The commutative function must handle the elements in the list type consistently. - Assume there can be multiple types of input elements as demonstrated: integers, tuples, etc. # Example ```python mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(2, 4)) # Output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Output: 6 mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(mytree.query(0, 6)) # Output: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Output: 52 mytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) print(mytree.query(0, 2)) # Output: (9, 13) mytree.update(2, (-1, 2)) print(mytree.query(0, 2)) # Output: (4, 10) ```","solution":"from typing import List, Any, Callable class SegmentTree: def __init__(self, arr: List[Any], function: Callable[[Any, Any], Any]): Initializes the segment tree with a given list of elements and a commutative function. Parameters: arr (List[Any]): The list of elements. function (Callable[[Any, Any], Any]): A commutative function. self.n = len(arr) self.function = function self.tree = [None] * (2 * self.n) # Initialize the segment tree with the given array # Initialize leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = function(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, p: int, v: Any): Update the element at index `p` to value `v` and adjust the segment tree. Parameters: p (int): Index in the original list to update. v (Any): New value for the element. # Set value at position p p += self.n self.tree[p] = v # Move upward and update while p > 1: p //= 2 self.tree[p] = self.function(self.tree[2 * p], self.tree[2 * p + 1]) def query(self, l: int, r: int) -> Any: Perform a range query from index `l` to `r` and return the result. Parameters: l (int): The start index of the query range. r (int): The end index of the query range. Returns: Any: The result of the commutative function over the range. res = None # Convert to the appropriate segment tree indices l += self.n r += self.n while l <= r: if l % 2 == 1: res = self.tree[l] if res is None else self.function(res, self.tree[l]) l += 1 if r % 2 == 0: res = self.tree[r] if res is None else self.function(res, self.tree[r]) r -= 1 l //= 2 r //= 2 return res"},{"question":"# Challenge: Word Segmentation Verification You are tasked with implementing a function that checks if a given word can be segmented into a space-separated sequence of one or more words from a provided dictionary. Function Signature ```python def can_segment(word: str, dictionary: List[str]) -> bool: ``` Input * `word` (str): A non-empty string to be checked for segmentability. * `dictionary` (List[str]): A list of non-empty words representing the dictionary. There are no duplicate words in the dictionary. Output * Returns `True` if the word can be segmented into a sequence of dictionary words, otherwise returns `False`. Constraints - The length of `word` will be in the range [1, 300]. - The total length of dictionary words will not exceed 10,000 characters. - Case sensitivity should be considered (e.g., \\"Apple\\" and \\"apple\\" are different). Performance Requirement - Your implementation should run in `O(N^2)` time complexity, where `N` is the length of the word. Example ```python word = \\"applepen\\" dictionary = [\\"apple\\", \\"pen\\"] # \\"applepen\\" can be segmented as \\"apple pen\\" result = can_segment(word, dictionary) print(result) # Output: True word = \\"catsanddog\\" dictionary = [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"] # \\"catsanddog\\" can be segmented as \\"cats and dog\\" result = can_segment(word, dictionary) print(result) # Output: True word = \\"applepie\\" dictionary = [\\"apple\\", \\"pear\\", \\"pier\\"] # \\"applepie\\" cannot be segmented using the provided dictionary result = can_segment(word, dictionary) print(result) # Output: False ``` Edge Cases to Consider 1. The word is an empty string. 2. The dictionary is empty. 3. The word contains characters not present in any dictionary word. 4. The word is comprised entirely of a single dictionary word repeated. Implement the function to correctly handle these edge cases and ensure optimal performance.","solution":"from typing import List def can_segment(word: str, dictionary: List[str]) -> bool: word_len = len(word) word_break = [False] * (word_len + 1) word_break[0] = True word_set = set(dictionary) for i in range(1, word_len + 1): for j in range(i): if word_break[j] and word[j:i] in word_set: word_break[i] = True break return word_break[word_len]"},{"question":"**Problem Statement** Given a positive integer `n`, write a function `countDecompositions(n)` that returns the number of ways to decompose `n` into sums of non-negative integers. The order of summands does not matter, and only non-negative integers are allowed. **Function Signature** ```python def countDecompositions(n: int) -> int: ``` **Input** * The input `n` is a positive integer ( 1 leq n leq 100 ). **Output** * The function should return an integer representing the number of ways to decompose `n`. **Examples** ```python assert countDecompositions(4) == 5 assert countDecompositions(7) == 15 ``` In the first example, the possible decompositions of 4 are: - 4 - 3 + 1 - 2 + 2 - 2 + 1 + 1 - 1 + 1 + 1 + 1 Thus, there are 5 ways to decompose the integer 4. In the second example, the possible decompositions of 7 include (but are not limited to): - 7 - 6 + 1 - 5 + 2 - 5 + 1 + 1 - 4 + 3 - 4 + 2 + 1 (and so on...) Thus, there are 15 ways to decompose the integer 7. **Constraints** * The solution should use dynamic programming to ensure optimal time complexity. * Aim for a time complexity of (O(n^2)) and a space complexity of (O(n^2)). * Ensure the function handles edge cases, such as `n = 1` effectively. **Notes** 1. Clearly outline the steps and logic in your code with appropriate comments. 2. Use meaningful variable names to enhance code readability. 3. You may not use any built-in functions that trivialize the decomposition process, like tools from combinatorics libraries.","solution":"def countDecompositions(n: int) -> int: Returns the number of ways to decompose n into sums of non-negative integers. # Create a 2D array dp where dp[i][j] means the number of ways to write j using the integers from 1 to i dp = [[0] * (n + 1) for _ in range(n + 1)] # Base Case: there is 1 way to form sum 0 i.e., using no integers for i in range(n + 1): dp[i][0] = 1 # Fill the dp table for i in range(1, n + 1): for j in range(1, n + 1): if j >= i: dp[i][j] = dp[i - 1][j] + dp[i][j - i] else: dp[i][j] = dp[i - 1][j] return dp[n][n]"},{"question":"Context: You have been hired to improve the task scheduler for a printing service. The current scheduler is based on a simple array, but it needs to handle dynamically growing tasks efficiently without causing performance issues. Additionally, it must ensure fair processing of tasks where the first submitted task is always handled first (FIFO order). Task: Implement a `CircularArrayQueue` class in Python, derived from the `AbstractQueue` class provided above. This implementation should use a circular buffer strategy for enqueuing and dequeuing operations to avoid frequent array resizing. This queue should have a fixed initial capacity, and a method to double the capacity when it becomes full. The queue should handle typical operations such as enqueue, dequeue, peek, and size. Requirements: 1. The `CircularArrayQueue` class must support the following methods: * `__init__(capacity=10)`: Initialize with a default capacity of 10. * `enqueue(value)`: Adds `value` to the queue. * `dequeue()`: Removes and returns the front element. * `peek()`: Returns the front element without removing it. * `is_empty()`: Checks if the queue is empty. * `__len__()`: Returns the number of items in the queue. * `_expand()`: Doubles the array capacity when the queue is full. 2. Ensure efficient O(1) time complexity for `enqueue`, `dequeue`, and `peek` operations in the average case. 3. Handle edge cases, such as attempting to dequeue or peek when the queue is empty. Example Usage: ```python queue = CircularArrayQueue(capacity=5) queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) queue.enqueue(4) queue.enqueue(5) print(queue.dequeue()) # Output: 1 print(queue.peek()) # Output: 2 print(len(queue)) # Output: 4 queue.enqueue(6) # Should trigger expansion print(len(queue)) # Output: 5 ``` Constraints: * Capacity expansion should occur in O(n) time complexity. * Ensure that all operations are efficient and handle edge cases appropriately. * The class must not use any built-in list methods that bypass the circular behavior requirement.","solution":"class CircularArrayQueue: def __init__(self, capacity=10): self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.size = 0 def enqueue(self, value): if self.size == self.capacity: self._expand() self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty queue\\") return self.queue[self.front] def is_empty(self): return self.size == 0 def __len__(self): return self.size def _expand(self): new_capacity = self.capacity * 2 new_queue = [None] * new_capacity for i in range(self.size): new_queue[i] = self.queue[(self.front + i) % self.capacity] self.queue = new_queue self.front = 0 self.rear = self.size self.capacity = new_capacity"},{"question":"# Context: You are teaching a class on sorting algorithms and want to illustrate the importance of algorithm selection by showcasing an extremely inefficient sorting method. You decide to use Bogo Sort for this task. # Problem: Implement the Bogo Sort algorithm which sorts an array by repeatedly shuffling it until it appears in sorted order. # Function Signature ```python def bogo_sort(arr: list) -> list: pass ``` # Input: * `arr` : A list of integers. (1 ≤ len(arr) ≤ 10) # Output: * Return a list of integers sorted in non-decreasing order. # Constraints: * The list can have duplicate elements. * The program should handle the worst-case scenario in practical time. * You need to ensure that handling and returning the sorted array is efficient in terms of space complexity, managing the in-place modifications effectively. # Performance Requirements: * Given the probabilistic nature of the algorithm, the implementation must internally keep track of the number of iterations it undergoes. If it exceeds a certain number of iterations (e.g., 10,000), forcefully return the closest sorted version of the list (just to prevent infinite loops in a classroom setting). # Example: ```python assert bogo_sort([3, 2, 1]) == [1, 2, 3] assert bogo_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] ```","solution":"import random def bogo_sort(arr: list) -> list: def is_sorted(arr): for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True max_iterations = 10000 iterations = 0 while not is_sorted(arr): if iterations >= max_iterations: print(\\"Max iterations reached, returning best effort sort.\\") arr.sort() return arr random.shuffle(arr) iterations += 1 return arr"},{"question":"Scenario You are tasked with cleaning a list of user data. One of the requirements is to ensure that no user has duplicate characters in their usernames. To achieve this, you need to write a function that accepts usernames and removes any recurring characters while preserving the order of their first appearance. Task Write a function `clean_username` that takes a list of usernames and returns a list of cleaned usernames, where all duplicate characters are removed. **Function Signature**: ```python def clean_username(usernames: List[str]) -> List[str]: pass ``` Input - `usernames`: A list of strings `usernames` where each string represents a username (1 ≤ len(usernames[i]) ≤ 10^4, 1 ≤ len(usernames) ≤ 10^2). Output - A list of strings, where each string has no recurring characters. Constraints - Case sensitivity matters; \'A\' and \'a\' are considered different characters. - Preserve the order of first appearance of characters within each username. Performance requirements The solution should be efficient with respect to time complexity, ideally O(n) per username. Example ```python usernames = [\\"google\\", \\"apple\\", \\"banana\\"] print(clean_username(usernames)) # [\\"gole\\", \\"aple\\", \\"ban\\"] ``` Note - For the username \\"google\\", \'g\' and \'o\' are recurring, so the cleaned username is \\"gole\\". - For \\"apple\\", \'p\' is recurring, resulting in \\"aple\\". - For \\"banana\\", \'a\' and \'n\' are recurring, resulting in \\"ban\\".","solution":"def clean_username(usernames): Takes a list of usernames and returns a list of cleaned usernames where all duplicate characters are removed but order is preserved. Args: usernames (List[str]): List of usernames. Returns: List[str]: List of cleaned usernames. def remove_duplicates(username): seen = set() cleaned = [] for char in username: if char not in seen: seen.add(char) cleaned.append(char) return \'\'.join(cleaned) return [remove_duplicates(username) for username in usernames]"},{"question":"# Problem: Modified Dijkstra\'s Algorithm for All-Pairs Shortest Path Given the implementation of Dijkstra\'s Single-Source Shortest Path Algorithm, your task is to modify it to find the shortest paths between all pairs of vertices in a weighted, directed graph. # Input 1. **vertex_count**: An integer representing the number of vertices in the graph (2 ≤ vertex_count ≤ 100). 2. **edges**: A list of tuples, where each tuple (u, v, w) represents an edge from vertex `u` to vertex `v` with weight `w` (1 ≤ u, v ≤ vertex_count and 1 ≤ w ≤ 10^4). # Output A 2D list `shortest_paths` such that `shortest_paths[u][v]` is the shortest distance from vertex `u` to vertex `v`. If there\'s no path from `u` to `v`, the value should be float(\\"inf\\"). # Function Signature ```python def all_pairs_shortest_path(vertex_count: int, edges: List[Tuple[int, int, int]]) -> List[List[float]]: pass ``` # Example Input ```python vertex_count = 4 edges = [(0, 1, 3), (0, 3, 7), (1, 2, 1), (2, 3, 2), (3, 2, 3)] ``` Output ```python [ [0, 3, 4, 6], [float(\'inf\'), 0, 1, 3], [float(\'inf\'), float(\'inf\'), 0, 2], [float(\'inf\'), float(\'inf\'), 3, 0] ] ``` # Constraints * Assume the graph is represented using a zero-based index for vertices. * Do not use any additional data structures that are not necessary for the problem. # Notes * Carefully handle disconnected nodes by initializing distances appropriately. * Ensure the core Dijkstra\'s function handles the shortest path calculation correctly without altering the provided weighted graph structure.","solution":"from typing import List, Tuple import heapq def dijkstra(vertex_count: int, graph: List[List[Tuple[int, int]]], start: int) -> List[float]: distances = [float(\'inf\')] * vertex_count distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def all_pairs_shortest_path(vertex_count: int, edges: List[Tuple[int, int, int]]) -> List[List[float]]: # Graph representation: adjacency list graph = [[] for _ in range(vertex_count)] for u, v, w in edges: graph[u].append((v, w)) shortest_paths = [] for i in range(vertex_count): shortest_paths.append(dijkstra(vertex_count, graph, i)) return shortest_paths"},{"question":"# Bit Manipulation Challenge **Objective**: Implement a function that processes an integer based on specific bit manipulation tasks and outputs the manipulated number. Function Signature ```python def bit_manipulation_processor(num: int, tasks: list) -> int: pass ``` Input 1. `num` (int): An integer number on which the bit manipulation tasks will be performed. 2. `tasks` (list of tuples): Each tuple has the format (\'operation\', index, value). The operations can be: * `\'get\'`: Retrieve the bit at a specific index (value is ignored). * `\'set\'`: Set the bit at a specific index to 1 (value may be ignored). * `\'clear\'`: Clear the bit at a specific index (value may be ignored). * `\'update\'`: Update the bit at a specific index to the given bit value (value will be 0 or 1). Output * An integer that represents the result after all the bit manipulation tasks have been carried out on the initial number. Constraints 1. Assume `num` is a 32-bit signed integer. 2. Tasks should be performed sequentially in the order given. 3. If the operation is `\'get\'`, the function should simply log the value instead of altering `num`; values should be displayed in the order they are retrieved. Example ```python # Example 1 num = 10 # Binary: 1010 tasks = [(\'set\', 0, None), (\'clear\', 1, None), (\'update\', 2, 0), (\'get\', 3, None)] # Task Breakdown: # 1. set bit at index 0 -> 1010 | 0001 = 1011 (11 in decimal) # 2. clear bit at index 1 -> 1011 & 1101 = 1001 (9 in decimal) # 3. update bit at index 2 to 0 -> 1001 | 0000 (remains 1001) # 4. get bit at index 3 -> 1 # Final Output: 9, with a log for the get operation: [1] print(bit_manipulation_processor(num, tasks)) # Output: 9, Log: [1] ``` Notes * Handle the index bounds properly and return the manipulated number as an integer. * Print the log of \'get\' operations separately if any.","solution":"def bit_manipulation_processor(num: int, tasks: list) -> int: Processes an integer based on specific bit manipulation tasks. Parameters: num (int): The integer to manipulate. tasks (list of tuples): Each tuple consists of (\'operation\', index, value). Returns: int: The manipulated integer after performing all tasks sequentially. log = [] for task in tasks: operation, index, value = task if operation == \'get\': bit_value = (num >> index) & 1 log.append(bit_value) elif operation == \'set\': num |= (1 << index) elif operation == \'clear\': num &= ~(1 << index) elif operation == \'update\': if value == 1: num |= (1 << index) else: num &= ~(1 << index) if log: # Print the log of \'get\' operations if any exist print(\\"Log:\\", log) return num"},{"question":"You are given an integer within the range [1, 3999]. Your task is to write a function that converts this integer to its corresponding Roman numeral representation. # Function Signature ```python def int_to_roman(num: int) -> str: :param num: An integer within the range [1, 3999]. :return: A string representing the Roman numeral of the given integer. ``` # Constraints - The input integer `num` is guaranteed to be within the range [1, 3999]. # Requirements - Implement the function without using any built-in library functions for the conversion. - Ensure your implementation has O(1) time complexity and O(1) space complexity. # Examples 1. Input: 3 - Output: \\"III\\" 2. Input: 4 - Output: \\"IV\\" 3. Input: 58 - Output: \\"LVIII\\" 4. Input: 1994 - Output: \\"MCMXCIV\\" # Hint Consider breaking the number into thousand, hundred, ten, and unit places. Map these places to their respective Roman numeral components and concatenate them. # Additional Note This problem tests your understanding of mapping numeric values to a symbolic, non-positional numeral system, requiring accurate breakdowns and combinations of components.","solution":"def int_to_roman(num: int) -> str: Convert an integer to its corresponding Roman numeral representation. :param num: An integer within the range [1, 3999]. :return: A string representing the Roman numeral of the given integer. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \\"\\" i = 0 while num > 0: for _ in range(num // val[i]): roman_numeral += syms[i] num -= val[i] i += 1 return roman_numeral"},{"question":"# Flatten Arrays Coding Challenge Objective Implement a function that flattens nested arrays into a single-level array. Description You need to write a function `flatten_nested_array` which takes a possibly multi-dimensional array of elements and returns a one-dimensional flattened array containing all the nested elements. Input - An array of elements which could include integers, strings, or other arrays. Output - A single-level array with all the nested elements. Constraints 1. The function should be recursive. 2. Handle both deeply nested arrays and large arrays. 3. Minimize additional memory usage. Example ```python input_arr = [1, [2, [3, 4], 5], 6, [7, [8, 9]]] output_arr = flatten_nested_array(input_arr) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` Function Signature ```python def flatten_nested_array(input_arr: list) -> list: pass ``` Requirements 1. Implement the function as described. 2. Provide test cases for the function with different edge scenarios processed. Scenario Your function will be used to preprocess data for a JSON parser that expects flat lists for certain operations.","solution":"def flatten_nested_array(input_arr: list) -> list: Flattens a nested array into a single-level array. Args: input_arr (list): A list, potentially containing nested lists. Returns: list: A single-level list containing all the nested elements. flattened = [] for element in input_arr: if isinstance(element, list): flattened.extend(flatten_nested_array(element)) else: flattened.append(element) return flattened"},{"question":"Given a positive integer `n`, write a function `int_partition(n)` that computes the number of unique ways to partition the integer. Each partition is a way of writing `n` as a sum of positive integers where order of summands does not matter. # Input * A single integer `n` (1 ≤ n ≤ 100). # Output * An integer representing the number of unique partitions of `n`. # Constraints * Your solution should have a time complexity of O(n^2) in order to handle the upper constraint effectively. # Example **Input** ```python 4 ``` **Output** ```python 5 ``` **Explanation** 4 can be partitioned in 5 ways: [4], [3, 1], [2, 2], [2, 1, 1], [1, 1, 1, 1]. # Implementation Challenge Consider edge cases and ensure your solution processes them correctly. Implement the algorithm using a dynamic programming approach based on the outlined analysis. # Starter Code ```python def int_partition(n): Compute the number of unique partitions of the integer n. # Initialize a 2D array to store partition results. arr = [[0 for _ in range(n + 1)] for _ in range(n + 1)] arr[1][1] = 1 for i in range(1, n + 1): for j in range(1, n + 1): if i < j: arr[i][j] = arr[i][i] elif i == j: arr[i][j] = 1 + arr[i][j - 1] else: arr[i][j] = arr[i][j - 1] + arr[i - j][j] return arr[n][n] # Test the function with sample inputs. print(int_partition(4)) # Output should be 5 print(int_partition(7)) # Output should be 15 ```","solution":"def int_partition(n): Compute the number of unique partitions of the integer n. # Initialize a 2D array to store the number of partitions for each subproblem dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)] # There\'s exactly one way to partition 0 (using no parts) dp[0][0] = 1 for i in range(1, n + 1): for j in range(n + 1): # Case when we don\'t use the number i in the partition dp[i][j] = dp[i-1][j] # Case when we use the number i in the partition if j >= i: dp[i][j] += dp[i][j-i] return dp[n][n]"},{"question":"Given the analysis of the Cocktail Shaker Sort algorithm, let\'s devise a challenging problem for you to solve. # Scenario You are tasked with optimizing a sorting system in an e-commerce application. The system regularly sorts product arrays, which are subject to frequent additions and updates while mainly remaining relatively sorted. The end goal is to create an efficient sorting function that can work seamlessly within these conditions. # Task Write a function `optimized_cocktail_shaker_sort` which accepts an array of integers and sorts it using an optimized version of the Cocktail Shaker Sort algorithm. The function should handle the following: * **Input**: A list of integers. * **Output**: A sorted list of integers. * **Constraints**: * The array length will not exceed 10^5. * The values are within the range -10^9 to 10^9. * **Optimization**: * The function should minimize unnecessary passes for mostly sorted or small arrays. * The function must handle edge cases such as empty arrays and uniformly identical elements effectively. # Function Signature ```python def optimized_cocktail_shaker_sort(arr: List[int]) -> List[int]: pass ``` # Example ```python # Example input/output print(optimized_cocktail_shaker_sort([3, 1, 2, 5, 4])) # Output: [1, 2, 3, 4, 5] print(optimized_cocktail_shaker_sort([])) # Output: [] print(optimized_cocktail_shaker_sort([10, 7, -1, 4, 3, 99])) # Output: [-1, 3, 4, 7, 10, 99] print(optimized_cocktail_shaker_sort([5, 5, 5, 5, 5])) # Output: [5, 5, 5, 5, 5] print(optimized_cocktail_shaker_sort([1])) # Output: [1] ``` # Notes 1. The function should handle early termination conditions effectively, especially detecting when the array is already sorted. 2. Ensure the function performs within reasonable time constraints given the input size limitations.","solution":"from typing import List def optimized_cocktail_shaker_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def cocktail_shaker_sort(arr): n = len(arr) swapped = True start = 0 end = n - 1 while swapped: swapped = False for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break swapped = False end -= 1 for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr return cocktail_shaker_sort(arr)"},{"question":"Given a sorted array of integers in increasing order, write a function `last_occurrence(array, query)` to find the index of the last occurrence of a given number in the array. If the number is not present, return -1. Input * `array` - A list of integers sorted in non-decreasing order. (1 ≤ size of array ≤ 10^5) * `query` - An integer to find in the array. Output * Return the index of the last occurrence of the query integer in the array. If the query does not exist in the array, return -1. Constraints * The algorithm should have a time complexity of O(log n). Example ```python array = [1, 2, 2, 2, 3, 4, 5] query = 2 assert last_occurrence(array, query) == 3 array = [1, 2, 2, 2, 3, 4, 5] query = 6 assert last_occurrence(array, query) == -1 array = [5, 5, 5, 5, 5] query = 5 assert last_occurrence(array, query) == 4 array = [1, 2, 3, 4, 5] query = 3 assert last_occurrence(array, query) == 2 ``` Function Signature ```python def last_occurrence(array: List[int], query: int) -> int: # implementation here ```","solution":"def last_occurrence(array, query): Finds the index of the last occurrence of the query in the sorted array. If the query is not found, return -1. :param array: List[int] - A list of sorted integers :param query: int - The integer to find :return: int - The index of the last occurrence of the query, or -1 if not found low, high = 0, len(array) - 1 result = -1 while low <= high: mid = (low + high) // 2 if array[mid] == query: result = mid # keep track of the last occurrence low = mid + 1 # search in the right half to find the last occurrence elif array[mid] < query: low = mid + 1 else: high = mid - 1 return result"},{"question":"# Stutter Stack Transformation Objective Write a program that processes a stack to duplicate every element in the stack using both stack and queue auxiliary structures. Instructions Implement two functions, `first_stutter()` and `second_stutter()`, that take a stack (represented as a list in Python) as a parameter and replace every value in the stack with two occurrences of that value. Example: ```python # Given stack stack = [3, 7, 1, 14, 9] # After transformation # stack should be: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` Requirements - Function `first_stutter(stack: List[int]) -> List[int]` should use a single stack as auxiliary storage. - Function `second_stutter(stack: List[int]) -> List[int]` should use a single queue (or deque) as auxiliary storage. Constraints - The input stack (list) may contain up to 10^5 elements. - Elements in the stack are integers. Detailed Specifications: 1. **Function:** `first_stutter()`: - **Input:** List of integers representing the stack. - **Output:** List of integers with each element duplicated. 2. **Function:** `second_stutter()`: - **Input:** List of integers representing the stack. - **Output:** List of integers with each element duplicated. Make sure your implementation handles edge cases like empty stacks and single-element stacks correctly. Demonstrate the function with at least two test cases, including edge cases. Example ```python stack = [3, 7, 1, 14, 9] print(first_stutter(stack[:])) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] print(second_stutter(stack[:])) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` Expected Performance Both functions should operate in O(n) time complexity and O(n) space complexity.","solution":"from collections import deque from typing import List def first_stutter(stack: List[int]) -> List[int]: aux_stack = [] while stack: elem = stack.pop() aux_stack.append(elem) aux_stack.append(elem) while aux_stack: stack.append(aux_stack.pop()) return stack def second_stutter(stack: List[int]) -> List[int]: aux_queue = deque() while stack: elem = stack.pop() aux_queue.appendleft(elem) aux_queue.appendleft(elem) while aux_queue: stack.append(aux_queue.popleft()) return stack"},{"question":"# Resizable Hash Table Implementation with Dual Hash Functions Description You are provided an implementation of a hash table that uses linear probing for collision resolution along with a basic resizing mechanism to handle table growth. Now your task is to implement an enhanced version of the hash table that utilizes double hashing for collision resolution. This will help minimize the clustering issue common with linear probing and maintain efficient look-ups. # Requirements 1. **Double Hashing**: Implement a secondary hash function to be used in resolving collisions. 2. **Resizable Table**: Implement the ability for the table to resize when it reaches a load factor of 2/3. 3. **Edge Case Handling**: Ensure correct handling when the table becomes full or upon deletion. # Function Interface 1. `put(key, value)`: Insert a key-value pair. 2. `get(key)`: Retrieve the value associated with a key. 3. `del_(key)`: Remove the key-value pair for given key. 4. `resize()`: Internal method to double the size of the table and rehash all existing entries. 5. `secondary_hash(key)`: Implement a suitable secondary hashing function. # Input and Output * **Input**: Operations in the form of method calls on the hash table object. * **Output**: Return values from `get` or `del_` as specified. # Constraints * Keys are non-negative integers. * Handle at least 1000 operations within a reasonable time limit. Example ```python htable = ResizableDoubleHashTable() htable.put(10, \'value10\') htable.put(22, \'value22\') print(htable.get(10)) # Output: \'value10\' htable.del_(10) print(htable.get(10)) # Output: None htable.put(36, \'value36\') print(htable.get(22)) # Output: \'value22\' ``` # Implementation Please implement the `ResizableDoubleHashTable` class with required methods and ensure it adheres to the functionality described.","solution":"class ResizableDoubleHashTable: def __init__(self, initial_capacity=8): self.capacity = initial_capacity self.size = 0 self.table = [None] * self.capacity def primary_hash(self, key): return key % self.capacity def secondary_hash(self, key): return 1 + (key % (self.capacity - 1)) def put(self, key, value): if self.size / self.capacity > 2/3: self.resize() hashed_key = self.primary_hash(key) step_size = self.secondary_hash(key) while self.table[hashed_key] is not None and self.table[hashed_key][0] != key: hashed_key = (hashed_key + step_size) % self.capacity if self.table[hashed_key] is None: self.size += 1 self.table[hashed_key] = (key, value) def get(self, key): hashed_key = self.primary_hash(key) step_size = self.secondary_hash(key) while self.table[hashed_key] is not None: if self.table[hashed_key][0] == key: return self.table[hashed_key][1] hashed_key = (hashed_key + step_size) % self.capacity return None def del_(self, key): hashed_key = self.primary_hash(key) step_size = self.secondary_hash(key) while self.table[hashed_key] is not None: if self.table[hashed_key][0] == key: value = self.table[hashed_key][1] self.table[hashed_key] = None self.size -= 1 self._rehash_from_index((hashed_key + step_size) % self.capacity) return value hashed_key = (hashed_key + step_size) % self.capacity return None def resize(self): old_table = self.table self.capacity *= 2 self.size = 0 self.table = [None] * self.capacity for entry in old_table: if entry is not None: self.put(entry[0], entry[1]) def _rehash_from_index(self, start_index): index = start_index while self.table[index] is not None: key, value = self.table[index] self.table[index] = None self.size -= 1 self.put(key, value) index = (index + 1) % self.capacity"},{"question":"You are required to implement a function for a Red-Black Tree that can rebalance the tree after multiple insertions and deletions. The task is to extend the given Red-Black Tree class to include the functionality of checking the tree and fixing any violations of the Red-Black properties after performing multiple insertions and deletions. # Function Signature ```python def rebalance_tree(rb_tree: RBTree): Rebalance the Red-Black Tree after multiple insertions and deletions. Parameters: rb_tree (RBTree): The Red-Black Tree object to be rebalanced. Returns: None: The function modifies the tree in place. ``` # Requirements 1. **Input Format**: A Red-Black Tree object that has performed multiple insertions/deletions. 2. **Output Format**: No output needed. The function should modify the tree in place to ensure it satisfies the Red-Black Tree properties. 3. **Constraints**: - The function will be called after multiple insertions and deletions. - The tree can have up to 100,000 nodes. # Example ```python if __name__ == \\"__main__\\": rb = RBTree() nodes_to_insert = [20, 15, 25, 10, 30, 35, 5] for value in nodes_to_insert: n = RBNode(value, 1) rb.insert(n) nodes_to_delete = [25, 30] for value in nodes_to_delete: node = rb.root while node and node.val != value: if value < node.val: node = node.left else: node = node.right if node: rb.delete(node) rebalance_tree(rb) print(rb.inorder()) ``` # Constraints 1. Nodes values will be distinct integers. 2. Insertion and deletion are assumed to be already implemented. 3. The tree will have at least 1 node before rebalancing. # Note Your task is to specifically work on checking and fixing violations of the Red-Black properties after an arbitrary number of insertions and deletions. Ensure your implementation correctly handles all the edge cases and maintains the self-balancing properties of the Red-Black Tree.","solution":"class RBNode: def __init__(self, val, color=1): # 1 for red, 0 for black self.val = val self.color = color self.left = None self.right = None self.parent = None class RBTree: def __init__(self): self.TNULL = RBNode(0) self.TNULL.color = 0 self.root = self.TNULL # Preorder traversal def preorder(self): self.__preorder_helper(self.root) def __preorder_helper(self, node): if node != self.TNULL: print(node.val, end=\\" \\") self.__preorder_helper(node.left) self.__preorder_helper(node.right) # Insert Node def insert(self, key): node = RBNode(key) node.parent = None node.val = key node.left = self.TNULL node.right = self.TNULL node.color = 1 # New node must be red parent = None current = self.root while current != self.TNULL: parent = current if node.val < current.val: current = current.left else: current = current.right node.parent = parent if parent is None: self.root = node elif node.val < parent.val: parent.left = node else: parent.right = node if node.parent is None: node.color = 0 return if node.parent.parent is None: return self.fix_insert(node) def delete(self, node): self.__delete_node_helper(self.root, node.val) def __delete_node_helper(self, node, key): z = self.TNULL while node != self.TNULL: if node.val == key: z = node if node.val <= key: node = node.right else: node = node.left if z == self.TNULL: print(\\"Cannot find key in the tree\\") return y = z y_original_color = y.color if z.left == self.TNULL: x = z.right self.__rb_transplant(z, z.right) elif (z.right == self.TNULL): x = z.left self.__rb_transplant(z, z.left) else: y = self.minimum(z.right) y_original_color = y.color x = y.right if y.parent == z: x.parent = y else: self.__rb_transplant(y, y.right) y.right = z.right y.right.parent = y self.__rb_transplant(z, y) y.left = z.left y.left.parent = y y.color = z.color if y_original_color == 0: self.fix_delete(x) def minimum(self, node): while node.left != self.TNULL: node = node.left return node def __rb_transplant(self, u, v): if u.parent == None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def fix_insert(self, k): while k.parent.color == 1: if k.parent == k.parent.parent.right: u = k.parent.parent.left # uncle if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.left_rotate(k.parent.parent) else: u = k.parent.parent.right # uncle if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.right_rotate(k.parent.parent) if k == self.root: break self.root.color = 0 def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def __inorder_helper(self, node, res): if node != self.TNULL: self.__inorder_helper(node.left, res) res.append(node.val) self.__inorder_helper(node.right, res) def inorder(self): res = [] self.__inorder_helper(self.root, res) return res def fix_delete(self, x): while x != self.root and x.color == 0: if x == x.parent.left: s = x.parent.right if s.color == 1: s.color = 0 x.parent.color = 1 self.left_rotate(x.parent) s = x.parent.right if s.left.color == 0 and s.right.color == 0: s.color = 1 x = x.parent else: if s.right.color == 0: s.left.color = 0 s.color = 1 self.right_rotate(s) s = x.parent.right s.color = x.parent.color x.parent.color = 0 s.right.color = 0 self.left_rotate(x.parent) x = self.root else: s = x.parent.left if s.color == 1: s.color = 0 x.parent.color = 1 self.right_rotate(x.parent) s = x.parent.left if s.left.color == 0 and s.right.color == 0: s.color = 1 x = x.parent else: if s.left.color == 0: s.right.color = 0 s.color = 1 self.left_rotate(s) s = x.parent.left s.color = x.parent.color x.parent.color = 0 s.left.color = 0 self.right_rotate(x.parent) x = self.root x.color = 0 def rebalance_tree(rb_tree: RBTree): Rebalance the Red-Black Tree after multiple insertions and deletions. Parameters: rb_tree (RBTree): The Red-Black Tree object to be rebalanced. Returns: None: The function modifies the tree in place. # Perform an inorder traversal of the tree, store results in a list def inorder_nodes(node): if node is None or node == rb_tree.TNULL: return [] return inorder_nodes(node.left) + [node] + inorder_nodes(node.right) # Get all nodes through inorder traversal nodes = inorder_nodes(rb_tree.root) # Reconstruct the tree using the nodes list for node in nodes: node.left = rb_tree.TNULL node.right = rb_tree.TNULL node.parent = None node.color = 1 # All nodes are first reset to red rb_tree.root = rb_tree.TNULL for node in nodes: rb_tree.insert(node.val)"},{"question":"# Postorder Traversal of a Binary Tree Given the Node class for a binary tree and an example of postorder traversal, define the `postorder` function iteratively and the `postorder_rec` function recursively to perform a postorder traversal of the given binary tree. # Input - The input is the root node of a binary tree. # Output - The output is a list of integers representing the values of nodes in postorder. # Constraints - The number of nodes in the tree is `1 <= n <= 10^5`. - Node values are unique integers. # Example Given the binary tree: ``` 1 / 2 3 / 4 5 ``` The postorder traversal should be `[4, 5, 2, 3, 1]`. # Task Implement the following two functions: 1. **postorder(root)** - Iterative implementation of the postorder traversal. 2. **postorder_rec(root)** - Recursive implementation of the postorder traversal. # Iterative (using stack) Implementation ```python def postorder(root): res_temp = [] res = [] if not root: return res stack = [] stack.append(root) while stack: root = stack.pop() res_temp.append(root.val) if root.left: stack.append(root.left) if root.right: stack.append(root.right) while res_temp: res.append(res_temp.pop()) return res ``` # Recursive Implementation ```python def postorder_rec(root, res=None): if root is None: return [] if res is None: res = [] postorder_rec(root.left, res) postorder_rec(root.right, res) res.append(root.val) return res ``` Your task is to implement these functions thoroughly considering edge cases and constraints.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def postorder(root): res_temp = [] res = [] if not root: return res stack = [] stack.append(root) while stack: root = stack.pop() res_temp.append(root.val) if root.left: stack.append(root.left) if root.right: stack.append(root.right) while res_temp: res.append(res_temp.pop()) return res def postorder_rec(root, res=None): if root is None: return [] if res is None: res = [] postorder_rec(root.left, res) postorder_rec(root.right, res) res.append(root.val) return res"},{"question":"You are given a description of a deterministic finite automaton (DFA) that is used to recognize whether an input string belongs to a particular regular language. Implement a function `is_accepted` to determine if an input string is accepted by the DFA. # Function Signature: ```python def is_accepted(transitions: dict, start: int, final: list, string: str) -> bool: Check if the given string is accepted by the DFA. :param transitions: Dictionary representation of the DFA transitions. Keys are states and values are dictionaries with characters as keys and resulting states as values. :param start: Integer representing the start state. :param final: List of integers representing the accepting states. :param string: String input to be checked against the DFA. :return: Boolean value, True if the string is accepted, False otherwise. pass ``` # Input Format: * `transitions` - A dictionary where each key is a state (integer) and the value is another dictionary representing the possible transitions from that state `{character: next_state}`. * `start` - An integer representing the start state of the DFA. * `final` - A list of integers representing the accepting states. * `string` - The input string to be checked. # Output Format: - The function should return `True` if the input string is accepted by the DFA, and `False` otherwise. # Constraints: - The states are represented by non-negative integers. - The input string consists of lowercase English letters only. - The DFA is well-defined, meaning there are no missing transitions unless explicitly set to `None`. # Example: ```python transitions = { 0: {\'a\': 1, \'b\': 0}, 1: {\'a\': 1, \'b\': 2}, 2: {\'a\': 2, \'b\': 2} } start = 0 final = [2] string = \\"ab\\" assert is_accepted(transitions, start, final, string) == True ``` # Explanation: The DFA transitions are: - From state 0 with \'a\' goes to state 1 - From state 0 with \'b\' goes back to state 0 - From state 1 with \'a\' remains in state 1 - From state 1 with \'b\' goes to state 2 - From state 2 with \'a\' and \'b\' remains in state 2 Starting at state 0, the string \\"ab\\" transitions the DFA through states 0 -> 1 -> 2, and state 2 is in the list of final states, so the string is accepted.","solution":"def is_accepted(transitions, start, final, string): Check if the given string is accepted by the DFA. :param transitions: Dictionary representation of the DFA transitions. Keys are states and values are dictionaries with characters as keys and resulting states as values. :param start: Integer representing the start state. :param final: List of integers representing the accepting states. :param string: String input to be checked against the DFA. :return: Boolean value, True if the string is accepted, False otherwise. current_state = start for char in string: if char in transitions[current_state]: current_state = transitions[current_state][char] else: return False return current_state in final"},{"question":"# Problem Description You have been tasked to assess students\' understanding of sorting algorithms by having them implement a variation of the Bogo Sort algorithm called **Constrained Bogo Sort**. The Constrained Bogo Sort will try to sort the list in a given number of maximum iterations. If the list is not sorted within these iterations, the function should return a message stating that the sort failed. # Function Specification `constrained_bogo_sort(arr: List[int], max_iterations: int) -> List[int] or str` * **Input**: - `arr`: A list of integers that needs to be sorted. (`1 ≤ len(arr) ≤ 10`) - `max_iterations`: An integer representing the maximum number of iterations to attempt sorting. (`1 ≤ max_iterations ≤ 1000`) * **Output**: - If sorting is successful within the given maximum iterations, return the sorted list. - If sorting is not successful within the given maximum iterations, return the string `\\"Sort failed\\". * **Constraints**: - The array may contain duplicate elements. - The function should handle empty arrays and arrays with a single element correctly. * **Performance**: - The function should not enter an infinite loop and should terminate gracefully after the specified number of iterations. * **Edge Cases**: - An array that is already sorted. - An array where all elements are the same. - Handling an empty array or array with a single element. # Example Example 1: ```python arr = [3, 2, 5, 1, 4] max_iterations = 100 constrained_bogo_sort(arr, max_iterations) ``` Expected Output: ```python > [1, 2, 3, 4, 5] ``` Example 2: ```python arr = [3, 2, 1] max_iterations = 2 constrained_bogo_sort(arr, max_iterations) ``` Expected Output: ```python > \\"Sort failed\\" ``` # Detailed Description Using the conceptual understanding of Bogo Sort provided: 1. Write a function `constrained_bogo_sort` that takes a list of integers and a maximum number of iterations as its parameters and attempts to sort the list using the Bogo Sort mechanism. 2. Randomly shuffle the list and check if it is sorted. 3. Repeat the process up to `max_iterations` times. 4. If the list is sorted within the given iterations, return the sorted list. 5. If the list is not sorted within the given iterations, return the string `\\"Sort failed\\"`. The goal is to test the student\'s comprehension of the Bogo Sort algorithm and their ability to implement conditional constraints.","solution":"import random from typing import List, Union def is_sorted(arr: List[int]) -> bool: Helper function to check if the list is sorted. return all(arr[i] <= arr[i+1] for i in range(len(arr)-1)) def constrained_bogo_sort(arr: List[int], max_iterations: int) -> Union[List[int], str]: Attempts to sort the list arr using Constrained Bogo Sort within max_iterations. If unsuccessful, return \\"Sort failed\\". for _ in range(max_iterations): if is_sorted(arr): return arr random.shuffle(arr) return \\"Sort failed\\""},{"question":"**Binary Search Recursive Implementation** **Scenario**: You are given a sorted array of integers. Your task is to find the position of a given target value in the array using a recursive binary search algorithm. If the target is not found, the function should return -1. **Function Signature**: ```python def binary_search_recursive(array, low, high, target): :param array: List[int] - a list of integers sorted in ascending order :param low: int - the starting index of the subarray to search :param high: int - the ending index of the subarray to search :param target: int - the value to search for :return: int - the index of the target if found, otherwise -1 ``` **Input/Output Formats**: - **Input**: - `array`: A list of integers sorted in ascending order. - `low`: The starting index of the subarray to search. - `high`: The ending index of the subarray to search. - `target`: The integer value to search for. - **Output**: - Return an integer representing the index of the target (if found) or -1 (if not found). **Constraints**: - The array length will be in the range [0, 10^6]. - The values of the elements in the array and the `target` will be in the range [-10^9, 10^9]. **Example**: ```python # Example 1: array = [1, 2, 3, 4, 5, 6, 7, 8, 9] target = 5 # Expected Output: 4 # Example 2: array = [1, 2, 3, 4, 5, 6, 7, 8, 9] target = 10 # Expected Output: -1 # Example 3: array = [] target = 1 # Expected Output: -1 ``` **Notes**: - You need to handle the edge case where the array is empty. - Ensure that your implementation is efficient and avoids unnecessary recursive calls. Write your solution in the function `binary_search_recursive` as specified.","solution":"def binary_search_recursive(array, low, high, target): :param array: List[int] - a list of integers sorted in ascending order :param low: int - the starting index of the subarray to search :param high: int - the ending index of the subarray to search :param target: int - the value to search for :return: int - the index of the target if found, otherwise -1 if low > high: return -1 mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] > target: return binary_search_recursive(array, low, mid - 1, target) else: return binary_search_recursive(array, mid + 1, high, target)"},{"question":"# Problem: Unique Integer Finder Given an array of integers where every element appears exactly three times except for one element which appears exactly once, write a function to find that single unique element. Your solution should have a linear runtime complexity and use constant extra space. # Function Signature: ```python def find_unique(nums: List[int]) -> int: pass ``` # Input: * An array of integers `nums`, which can contain both positive and negative integers. * The array `nums` will always have at least one element that appears exactly once while all the other elements appear exactly three times. # Output: * Return the integer that appears only once. # Constraints: * All elements in the array are integers (positive, negative or zero). * The size of the array will be within the range of a typical computing machine\'s memory capacity. # Performance Requirements: * Your algorithm must run in O(n) time complexity. * Your algorithm should not use more than O(1) extra space. # Example: ```python print(find_unique([2, 2, 3, 2])) # Output: 3 print(find_unique([0, 1, 0, 1, 0, 1, 99])) # Output: 99 ``` Note: 1. Carefully handle the bit manipulations to track elements appearing once and three times. 2. Consider edge cases such as arrays with minimal elements or where the unique element is at extreme positions.","solution":"from typing import List def find_unique(nums: List[int]) -> int: Find the unique integer in an array where every other integer appears exactly three times. :param nums: List of integers :return: The single unique integer ones, twos = 0, 0 for num in nums: # \'ones\' will store the bits of the numbers which have appeared exactly once # \'twos\' will store the bits of the numbers which have appeared exactly twice # For the current number, we update \'twos\' which have the given bits for the second time twos |= ones & num # Update \'ones\' which have the given bits for the first time ones ^= num # Get common bits in \'ones\' and \'twos\' common_mask = ones & twos # Remove common bits from \'ones\' and \'twos\' ones &= ~common_mask twos &= ~common_mask return ones"},{"question":"# Quick Sort with Pivot Optimization You have been provided a quick sort algorithm. The task is to improve this algorithm by implementing a median-of-three pivot selection strategy to enhance the average performance further. Requirements: 1. Implement the function `median_of_three(arr, first, last)` to: * Select the median value of the first, middle, and last elements of the sublist `arr[first:last+1]`. * Reorder these elements so the pivot ends up in the middle. 2. Modify the given `quick_sort` algorithm to use this new `median_of_three` pivot selection instead of directly selecting the last element as the pivot. 3. Ensure that all other functionalities of the original `quick_sort` remain the same, and handle the performance constraints efficiently. Input: * A list of integers `arr`. Output: * A new sorted list of integers. Constraints: * (1 leq text{len(arr)} leq 10^5) * (-10^9 leq text{arr[i]} leq 10^9) Function Signature: ```python def quick_sort(arr): # your code here ``` Example: ```python arr = [3, 6, 8, 10, 1, 2, 1] print(quick_sort(arr)) # Output: [1, 1, 2, 3, 6, 8, 10] arr = [10, 7, 8, 9, 1, 5] print(quick_sort(arr)) # Output: [1, 5, 7, 8, 9, 10] ```","solution":"def median_of_three(arr, first, last): Reorders the first, middle, and last elements of the array to choose the median as the pivot. mid = (first + last) // 2 if arr[first] > arr[mid]: arr[first], arr[mid] = arr[mid], arr[first] if arr[first] > arr[last]: arr[first], arr[last] = arr[last], arr[first] if arr[mid] > arr[last]: arr[mid], arr[last] = arr[last], arr[mid] # Move the median element to the last arr[mid], arr[last] = arr[last], arr[mid] return arr[last] def partition(arr, low, high): pivot = median_of_three(arr, low, high) i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort_recursive(arr, low, high): if low < high: pi = partition(arr, low, high) quick_sort_recursive(arr, low, pi - 1) quick_sort_recursive(arr, pi + 1, high) def quick_sort(arr): Sorts the list of integers using the quick sort algorithm with median-of-three pivot optimization. if arr: quick_sort_recursive(arr, 0, len(arr) - 1) return arr"},{"question":"# Question: Range-Based Array Filtering You are part of a data processing team that frequently receives datasets requiring specific filtering operations. One common task is to filter numeric arrays to include only elements within a specified range. Your task is to implement a function that performs this filtering. # Function Signature ```python def filter_by_range(arr: list[int], min_val: int = None, max_val: int = None) -> list[int]: pass ``` # Parameters - `arr`: A list of integers, which may include zero, positive, and negative numbers. - `min_val`: (Optional) An integer specifying the inclusive minimum boundary of the desired range. If not provided, there should be no lower limit. - `max_val`: (Optional) An integer specifying the inclusive maximum boundary of the desired range. If not provided, there should be no upper limit. # Returns - A list of integers containing only those elements from `arr` that fall within the specified range `[min_val, max_val]`. # Constraints - You may assume the input list `arr` contains at most (10^6) elements. - Without constraints, both `min_val` and `max_val` can be `None`. - If both `min_val` and `max_val` are `None`, return the entire array. - You should aim to implement this function with an efficient algorithm, ideally with linear time complexity in terms of the number of elements in the array. # Examples: 1. `filter_by_range([1, 2, 3, 4, 5], None, 3)` should return `[1, 2, 3]`. 2. `filter_by_range([10, 20, 30, 40, 50], 15, 35)` should return `[20, 30]`. 3. `filter_by_range([-5, -2, 0, 2, 5, 8], -3, 5)` should return `[-2, 0, 2, 5]`. 4. `filter_by_range([], 1, 100)` should return `[]`.","solution":"def filter_by_range(arr: list[int], min_val: int = None, max_val: int = None) -> list[int]: Filters the input list to include only elements within the specified range [min_val, max_val]. Parameters: arr (list[int]): List of integers to filter. min_val (int): Optional inclusive minimum boundary. If None, no lower limit is applied. max_val (int): Optional inclusive maximum boundary. If None, no upper limit is applied. Returns: list[int]: List of integers that fall within the specified range. if min_val is None and max_val is None: return arr result = [] for num in arr: if (min_val is None or num >= min_val) and (max_val is None or num <= max_val): result.append(num) return result"},{"question":"# Problem Given a singly linked list, rotate the list to the right by `k` places, where `k` is a non-negative integer. You are required to implement the function `rotate_right` to perform this operation. Function Signature ```python def rotate_right(head, k): :param head: ListNode :param k: int :return: ListNode ``` You are provided with the `ListNode` definition: ```python class ListNode: def __init__(self, x): self.val = x self.next = None ``` Input - `head`: The head of a singly linked list where each node contains an integer value. - `k`: A non-negative integer representing the number of places to rotate the list to the right. Output - Returns the head of the rotated linked list. Constraints - The input list can be empty. - The input list may contain up to 10,000 nodes. - The integer `k` is non-negative and can be very large (up to 10^9). Example ```python # Example 1: # Input: head = [1, 2, 3, 4, 5], k = 2 # Output: [4, 5, 1, 2, 3] # Example 2: # Input: head = [0, 1, 2], k = 4 # Output: [2, 0, 1] ``` Scenario Consider you are developing a scheduling application needing cyclic reordering of tasks. Each task is represented as a node in a linked list. The task list needs to be rotated based on user inputs. # Special Notes: - When `k` exceeds the length of the list, rotations should wrap around. For instance, rotating a list of size `n` by `k` places is effectively the same as rotating it by `k % n` places. Requirements - Optimize for large values of `k`. - Handle all edge cases, such as an empty list and very large `k`.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def rotate_right(head, k): if not head or k == 0: return head # First, find the length of the list length = 1 tail = head while tail.next: tail = tail.next length += 1 # Calculate the effective rotations needed k = k % length if k == 0: return head # Find the new tail: the (length - k - 1)th node new_tail = head for _ in range(length - k - 1): new_tail = new_tail.next # Find the new head: the (length - k)th node new_head = new_tail.next # Rotate the list new_tail.next = None tail.next = head return new_head"},{"question":"Your task is to implement two functions, `extended_gcd(a, b)` and `modular_inverse(a, m)`. Function 1: extended_gcd(a, b) This function calculates the greatest common divisor (GCD) of two integers a and b, and also finds two coefficients s and t such that the equation a * s + b * t = GCD(a, b) is satisfied. - **Input**: - `a` (integer): The first integer. - `b` (integer): The second integer. - **Output**: - A tuple of three integers: (s, t, GCD(a, b)). Function 2: modular_inverse(a, m) This function computes the modular inverse of a under modulo m, which is an integer x such that (a * x ≡ 1 mod m). - **Input**: - `a` (integer): The integer whose inverse is to be found. - `m` (integer): The modulus. - **Output**: - An integer x, where 0 <= x < m, which is the modular inverse of a under m. - **Constraints**: - `a` and `m` must be coprime (i.e., GCD(a, m) == 1). Example: ```python # Using the extended_gcd function result = extended_gcd(30, 20) print(result) # Output: (1, -1, 10) # Using the modular_inverse function inverse = modular_inverse(3, 11) print(inverse) # Output: 4 ``` # Constraints: - Large inputs should be handled efficiently. - Make sure to handle or raise appropriate exceptions for invalid inputs for `modular_inverse`. **Note**: Reuse the `extended_gcd` function to implement `modular_inverse`. # Detailed Requirements: Your implementation should demonstrate a clear understanding of how the Extended Euclidean Algorithm functions, and should be able to handle edge cases that include zero and negative inputs where appropriate. For the `modular_inverse` function, ensure that an exception is appropriately raised in non-coprime cases.","solution":"def extended_gcd(a, b): Returns the greatest common divisor (GCD) of integers a and b, as well as two coefficients s and t such that a * s + b * t = GCD(a, b). if b == 0: return (1, 0, a) else: s, t, gcd = extended_gcd(b, a % b) return (t, s - (a // b) * t, gcd) def modular_inverse(a, m): Returns the modular inverse of a under modulo m, which is an integer x such that (a * x ≡ 1 mod m). If a and m are not coprime, a ValueError is raised. s, t, gcd = extended_gcd(a, m) if gcd != 1: raise ValueError(f\\"No modular inverse for a={a} under modulo m={m} since they are not coprime.\\") else: return s % m"},{"question":"Word Dictionary with Trie Objective: You are asked to design an efficient data structure that allows you to add words and search for words in a dictionary. The search can be a literal word or a regular expression containing the character “.”, where “.” can represent any letter. Requirements: 1. **WordDictionary Class**: Implement this class with two main functions: - `add_word(word: str) -> None`: Adds a word into the data structure. - `search(word: str) -> bool`: Returns if the word (or regular expression with \\".\\") is in the data structure. 2. **Function Specifications**: * `add_word(word: str)`: * Input: A string `word` consisting of lowercase alphabets. * Output: None. * Complexity: The operation should be efficient with respect to size and length of words added. * `search(word: str)`: * Input: A string `word` that can contain lowercase alphabets and \\".\\". * Output: Boolean value; `True` if the word or pattern is found, `False` otherwise. * Complexity: Should efficiently handle search queries even with multiple wildcard characters. Constraints: - `1 <= word.length <= 100` - All words consist of lowercase English letters. - You will not add the same word multiple times. Performance Requirements: - Ensure to handle edge cases efficiently. - Aim to minimize memory usage and optimize for faster search times as described in the characteristics. Example Usage: ```python # Sample usage of the WordDictionary class word_dict = WordDictionary() word_dict.add_word(\\"bad\\") word_dict.add_word(\\"dad\\") word_dict.add_word(\\"mad\\") print(word_dict.search(\\"pad\\")) # Output: False print(word_dict.search(\\"bad\\")) # Output: True print(word_dict.search(\\".ad\\")) # Output: True print(word_dict.search(\\"b..\\")) # Output: True ``` Define the `WordDictionary` class with the required functionality. ```python class WordDictionary: def __init__(self): # Your initialization code here def add_word(self, word: str) -> None: # Your add_word code here def search(self, word: str) -> bool: # Your search code here ``` Provide the complete implementation where the `WordDictionary` performs precisely as described.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: return self._search_in_node(word, 0, self.root) def _search_in_node(self, word: str, index: int, node: TrieNode) -> bool: if index == len(word): return node.is_end_of_word char = word[index] if char == \'.\': for child in node.children.values(): if self._search_in_node(word, index + 1, child): return True elif char in node.children: return self._search_in_node(word, index + 1, node.children[char]) return False"},{"question":"# Scenario: You are developing a feature for a music player application that manages a playlist of songs. Each song in the playlist is represented as a node in a linked list. Implement a class that models the playlist using a doubly linked list, allowing efficient operations to navigate through songs, add new songs, and remove songs. # Task: Implement a `Playlist` class using a doubly linked list with the following methods: 1. `add_song(song_name: str) -> None`: Add the song to the end of the playlist. 2. `remove_song(song_name: str) -> bool`: Remove the first occurrence of the song from the playlist. Return `True` if the song was found and removed, `False` otherwise. 3. `next_song(current_song: str) -> Optional[str]`: Given the current song, return the next song in the playlist, or `None` if the current song is the last one or not found. 4. `previous_song(current_song: str) -> Optional[str]`: Given the current song, return the previous song in the playlist, or `None` if the current song is the first one or not found. 5. `get_playlist() -> List[str]`: Return a list of all songs in the playlist in the order they are currently in. # Constraints: * Assume all song names are unique strings. * The playlist initially starts empty. # Example: ```python playlist = Playlist() playlist.add_song(\\"Song A\\") playlist.add_song(\\"Song B\\") playlist.add_song(\\"Song C\\") print(playlist.get_playlist()) # Output: [\\"Song A\\", \\"Song B\\", \\"Song C\\"] print(playlist.next_song(\\"Song B\\")) # Output: \\"Song C\\" print(playlist.previous_song(\\"Song B\\")) # Output: \\"Song A\\" playlist.remove_song(\\"Song B\\") print(playlist.get_playlist()) # Output: [\\"Song A\\", \\"Song C\\"] ```","solution":"from typing import Optional, List class Node: def __init__(self, song_name: str): self.song_name = song_name self.next = None self.prev = None class Playlist: def __init__(self): self.head = None self.tail = None def add_song(self, song_name: str) -> None: new_node = Node(song_name) if self.tail is None: self.head = self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def remove_song(self, song_name: str) -> bool: current = self.head while current: if current.song_name == song_name: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next if current == self.tail: self.tail = current.prev return True current = current.next return False def next_song(self, current_song: str) -> Optional[str]: current = self.head while current: if current.song_name == current_song: return current.next.song_name if current.next else None current = current.next return None def previous_song(self, current_song: str) -> Optional[str]: current = self.head while current: if current.song_name == current_song: return current.prev.song_name if current.prev else None current = current.next return None def get_playlist(self) -> List[str]: songs = [] current = self.head while current: songs.append(current.song_name) current = current.next return songs"},{"question":"# Question: Implement a Min-Ordered Stack Scenario You have been tasked with creating a data structure that functions as a stack but with an additional constraint: it must maintain the elements in ascending order. This Ordered Stack should allow usual stack operations such as push, pop, and peek but always keep the elements sorted. This means when you push a new element, the stack should reorder itself to maintain the sorted structure. Requirements Write a class named `MinOrderedStack`, offering the same functionality as a regular stack but maintaining the elements in a sorted order (with the minimum element at the bottom). Class Methods * **`__init__(self)`**: Constructor to initialize an empty stack. * **`is_empty(self)`**: Method to check if the stack is empty. * **`push(self, item)`**: Method to add an element to the stack while maintaining the order. * **`pop(self)`**: Method to remove and return the top element from the stack. * **`peek(self)`**: Method to return the top element without removing it. * **`size(self)`**: Method to return the size of the stack. Implementation Notes * The stack should always maintain its order, even after multiple push and pop operations. * You are expected to handle the edge cases such as pushing to and popping from an empty stack properly. Input/Output Specification * The `push` method will receive a single integer value to be added to the stack. * The `pop` method should return an integer, the top element of the stack, or raise an `IndexError` if the stack is empty. * The `peek` method should return an integer, the top element of the stack without removing it. * The `is_empty` method should return a boolean indicating if the stack is empty. * The `size` method should return an integer representing the number of elements in the stack. Constraints * The stack will consist only of integers. * You must not use additional libraries or built-in sorting functions. Example ```python s = MinOrderedStack() s.push(3) s.push(1) s.push(2) print(s.peek()) # Output: 3 print(s.pop()) # Output: 3 print(s.pop()) # Output: 2 print(s.pop()) # Output: 1 print(s.is_empty()) # Output: True ```","solution":"class MinOrderedStack: def __init__(self): self.items = [] def is_empty(self): return len(self.items) == 0 def push(self, item): if self.is_empty(): self.items.append(item) else: # Use binary search to find the correct position to maintain sorted order low, high = 0, len(self.items) - 1 while low <= high: mid = (low + high) // 2 if self.items[mid] <= item: low = mid + 1 else: high = mid - 1 self.items.insert(low, item) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.items.pop() def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.items[-1] def size(self): return len(self.items)"},{"question":"# Scenario You are developing an optimized search feature for a sorting application. Specifically, you need to implement a function to find the last occurrence of a given number in a sorted list of integers. The list is guaranteed to be sorted in increasing order. # Task Implement a function `last_occurrence(array, query)` that takes two inputs: 1. `array` - a list of integers sorted in increasing order. 2. `query` - an integer, the number whose last occurrence index you need to find. # Function Signature ```python def last_occurrence(array: List[int], query: int) -> int: ``` # Input * `array`: A list of integers sorted in increasing order (0 ≤ len(array) ≤ 10^5) * `query`: An integer (-10^9 ≤ query ≤ 10^9) # Output * Returns the index (0-based) of the last occurrence of the `query` integer in the `array`. If `query` is not present in the array, return `-1`. # Constraints * The approach must have a time complexity of O(log n). * The `array` may contain duplicate elements. # Examples Example 1 ```python array = [1, 2, 2, 2, 3, 4, 5] query = 2 last_occurrence(array, query) # Output: 3 ``` Example 2 ```python array = [1, 3, 4, 5, 6, 7] query = 4 last_occurrence(array, query) # Output: 2 ``` Example 3 ```python array = [1, 2, 3, 4, 5, 6, 7] query = 8 last_occurrence(array, query) # Output: -1 ``` # Requirements Make sure to handle the edge cases such as single-element arrays and cases where the query element appears multiple times at the beginning or end of the list.","solution":"from typing import List def last_occurrence(array: List[int], query: int) -> int: Find the index of the last occurrence of \'query\' in a sorted \'array\'. :param array: List of sorted integers. :param query: The integer to find the last occurrence of. :return: Index of the last occurrence of \'query\', or -1 if \'query\' is not found. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: result = mid left = mid + 1 # Continue to search in the right half elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"Doubly Linked List Implementation Objective: Implement a doubly linked list with the basic functionality: inserting, deleting, and accessing elements. Scenario: You have been hired by a software company to extend the functionalities of their existing in-memory data structure manager. They want you to implement a doubly linked list that supports efficient insertion, deletion, and access operations. Requirements: 1. **Class Definition**: - **DoublyLinkedListNode** class with attributes `value`, `next`, and `prev`. - **DoublyLinkedList** class with methods described below. 2. **Method Implementations**: - `append(value)`: Add a node with the specified value at the end of the list. - `prepend(value)`: Add a node with the specified value at the beginning of the list. - `delete(value)`: Remove the first occurrence of the node with the specified value. - `find(value)`: Return the index of the first occurrence of the node with the specified value, or -1 if not found. - `display()`: Print the list elements in forward order. 3. **Input and Output Format**: - `append(value)`, `prepend(value)`, `delete(value)` should not return anything. - `find(value)` should return an integer index or -1. - `display()` should print the list in a list-like format (e.g., `[1, 2, 3]`). 4. **Constraints**: - Negative values or non-integer values should not be part of the list operations. - `find(value)` and `delete(value)` should operate in O(n) time complexity. Example Usage: ```python dll = DoublyLinkedList() dll.append(1) dll.append(2) dll.prepend(0) dll.delete(1) dll.display() # Output should be: [0, 2] index = dll.find(2) # Output should be: 1 index_not_found = dll.find(3) # Output should be: -1 ``` Remember to handle edge cases carefully, including operations on empty lists and removing non-existent values.","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value): new_node = DoublyLinkedListNode(value) if self.tail is None: self.head = self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def prepend(self, value): new_node = DoublyLinkedListNode(value) if self.head is None: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def delete(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next if current == self.tail: self.tail = current.prev return current = current.next def find(self, value): current = self.head index = 0 while current: if current.value == value: return index current = current.next index += 1 return -1 def display(self): elements = [] current = self.head while current: elements.append(current.value) current = current.next print(elements)"},{"question":"Context You\'re tasked with implementing a search feature for a data analytics platform which requires identifying the last occurrence of specific elements within sorted arrays. The data analytics often involves large datasets, so an efficient solution is crucial. Problem Statement Write a function to find the last occurrence of a specified element in a sorted (increasing order) array. Your function must handle various edge cases efficiently. Function Signature ```python def last_occurrence(array: List[int], query: int) -> int: Finds the last occurrence of query in a sorted array. Parameters: - array: List[int] : Sorted list of integers (non-decreasing order) - query: int : The integer to find the last occurrence of Returns: - int : The index of the last occurrence of the query element, or -1 if it doesn\'t exist # Implementation here ``` Input - `array` (List[int]): A list of integers sorted in non-decreasing order. - `query` (int): The integer value to be found. Output - Returns an integer representing the index of the last occurrence of the `query` element in the array. - If `query` does not exist in the array, return -1. Constraints 1. The length of `array` will be between 0 and 10^6. 2. Each element in `array` will be an integer within the range of -10^9 to 10^9. 3. The array may contain duplicate elements. Examples 1. Input: `last_occurrence([1, 2, 2, 3, 4, 4, 4, 5], 4)` Output: `6` 2. Input: `last_occurrence([1, 1, 1, 1, 1], 1)` Output: `4` 3. Input: `last_occurrence([1, 2, 3, 4, 5], 6)` Output: `-1` 4. Input: `last_occurrence([], 2)` Output: `-1` Notes - You must ensure that your solution runs in O(log n) time complexity. - Consider edge cases (e.g., an empty array, elements not present in the array).","solution":"from typing import List def last_occurrence(array: List[int], query: int) -> int: Finds the last occurrence of query in a sorted array. Parameters: - array: List[int] : Sorted list of integers (non-decreasing order) - query: int : The integer to find the last occurrence of Returns: - int : The index of the last occurrence of the query element, or -1 if it doesn\'t exist left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: result = mid left = mid + 1 # move to the right part to find the last occurrence elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"You are required to implement two versions of a function to compute the power of a number raised to another, optionally returning the result modulo a specified value. Your implementations should effectively handle large values of exponents using an efficient algorithm known as Binary Exponentiation. Function 1: Iterative Version Implement the function `power(a: int, n: int, mod: int = None) -> int` that calculates (a^n) iteratively. If `mod` is specified, return the result modulo `mod`. Function 2: Recursive Version Implement the function `power_recur(a: int, n: int, mod: int = None) -> int` that calculates (a^n) recursively using the same principles. # Input * `a`: an integer, base of the exponentiation (1 ≤ |a| ≤ 10^9) * `n`: a non-negative integer, exponent (0 ≤ n ≤ 10^18) * `mod`: an optional integer value, modulo (1 ≤ mod ≤ 10^9) (default is `None`) # Output * An integer representing the result of (a^n) or (a^n pmod{mod}) if `mod` is specified. # Constraints * You must implement the algorithm with a time complexity of O(log n) and an appropriate space complexity (O(1) for iterative, O(log n) for recursive). * Handle the edge cases where (n = 0). # Example ```python print(power(2, 10)) # Output: 1024 print(power(2, 10, 1000)) # Output: 24 print(power_recur(3, 13)) # Output: 1594323 print(power_recur(3, 13, 100)) # Output: 23 ``` # Note Make sure your implementation handles large input sizes efficiently. Consider using `mod` consistently to manage large intermediate results and avoid overflow.","solution":"def power(a, n, mod=None): Iterative version of calculating a^n % mod using Binary Exponentiation. result = 1 base = a while n > 0: if n % 2 == 1: result = (result * base) % mod if mod else result * base base = (base * base) % mod if mod else base * base n //= 2 return result if not mod else result % mod def power_recur(a, n, mod=None): Recursive version of calculating a^n % mod using Binary Exponentiation. if n == 0: return 1 half_power = power_recur(a, n // 2, mod) half_power = (half_power * half_power) % mod if mod else half_power * half_power if n % 2 != 0: half_power = (half_power * a) % mod if mod else half_power * a return half_power if not mod else half_power % mod"},{"question":"# Question: Anagram Checker Function You are given two strings consisting only of lowercase English letters. Your task is to write a function to determine if the two strings are anagrams of each other. Two strings are considered anagrams if they can be rearranged to form one another. Input - Two strings, `s1` and `s2`, where the length of each string is between 1 and 1000 characters. Output - Return `True` if `s1` and `s2` are anagrams, otherwise return `False`. Constraints 1. The strings will only contain lowercase English letters (\'a\' to \'z\'). 2. The solution must have a time complexity of O(n + m). 3. The solution must not use more than a fixed amount of additional space (constant space complexity). Example ```python anagram(\\"listen\\", \\"silent\\") -> True anagram(\\"triangle\\", \\"integral\\") -> True anagram(\\"apple\\", \\"pplea\\") -> True anagram(\\"rat\\", \\"car\\") -> False anagram(\\"hello\\", \\"billion\\") -> False ``` Performance Requirement Your implementation should be efficient with a time complexity of O(n + m) and use only a fixed amount of additional space beyond the input strings. Implement the function `anagram(s1, s2)` using the provided constraints and examples to verify the correctness.","solution":"def anagram(s1, s2): Determines if two strings are anagrams of each other. if len(s1) != len(s2): return False char_count = [0] * 26 # There are 26 lowercase English letters for char in s1: char_count[ord(char) - ord(\'a\')] += 1 for char in s2: char_count[ord(char) - ord(\'a\')] -= 1 for count in char_count: if count != 0: return False return True"},{"question":"**Scenarios**: You are developing software for a graphics application that involves multiple transformations represented mathematically by matrices. To perform a series of transformations on objects efficiently, you need to compute the result of multiplying several transformation matrices. Given this recurring necessity, you need a robust function to handle matrix multiplication. # Task You will implement a function `matrix_multiply` that receives two matrices and returns their product. The function should: 1. Verify that the matrices can be legally multiplied and raise an exception if they are not. 2. Compute the product of the input matrices using the standard matrix multiplication rules. 3. Return the resulting matrix. # Function Signature ```python def matrix_multiply(matrix1: list, matrix2: list) -> list: pass ``` # Input - `matrix1`: A list of lists where the inner lists represent rows of the first matrix. Each element in these lists is an integer. - `matrix2`: A list of lists where the inner lists represent rows of the second matrix. Each element in these lists is an integer. # Output - A list of lists representing the resulting matrix after multiplication. # Constraints - The matrices will only contain integers. - The dimensions of the matrices will be such that (0 leq len(matrix1) leq 100) and (0 leq len(matrix2) leq 100). - The number of columns in `matrix1` will be the same as the number of rows in `matrix2`. # Example ```python matrix1 = [ [1, 2, 3], [4, 5, 6] ] matrix2 = [ [7, 8], [9, 10], [11, 12] ] assert matrix_multiply(matrix1, matrix2) == [ [58, 64], [139, 154] ] ``` # Notes - You must handle the case where the matrices cannot be multiplied by raising an appropriate exception. - Consider performance and minimize unnecessary computations.","solution":"def matrix_multiply(matrix1, matrix2): Multiplies two matrices and returns the resulting matrix. Parameters: matrix1 (list of list of ints): The first matrix. matrix2 (list of list of ints): The second matrix. Returns: list of list of ints: The product of the two matrices. Raises: ValueError: If the matrices cannot be multiplied due to invalid dimensions. # Verify matrices can be multiplied num_rows1 = len(matrix1) num_cols1 = len(matrix1[0]) if matrix1 else 0 num_rows2 = len(matrix2) num_cols2 = len(matrix2[0]) if matrix2 else 0 if num_cols1 != num_rows2: raise ValueError(\\"Cannot multiply matrices: number of columns in first matrix does not equal number of rows in second matrix.\\") # Initialize result matrix with zeroes result = [[0] * num_cols2 for _ in range(num_rows1)] # Compute matrix multiplication for i in range(num_rows1): for j in range(num_cols2): for k in range(num_cols1): result[i][j] += matrix1[i][k] * matrix2[k][j] return result"},{"question":"# Stooge Sort Application **Objective**: You are given an array of integers that you need to sort using the Stooge Sort algorithm. **Function Signature**: ```python def stoogesort(arr: List[int]) -> List[int]: # Implement the stoogesort algorithm ``` **Input**: - A list of integers `arr` with length `n` where 0 < n <= 1000. **Output**: - A new list of integers sorted in ascending order. **Constraints**: - The function should handle edge cases such as empty arrays (`arr = []`), arrays with a single element, and arrays that are already sorted. **Performance Requirements**: - Although Stooge Sort is inefficient by nature, ensure your implementation adheres to the given input size constraints. **Scenario**: Imagine you are working on a small-scale embedded system where educational algorithms like Stooge Sort are used for learning purposes. Your task is to implement Stooge Sort in a way that you can demonstrate its behavior on various test cases. **Example**: ```python assert stoogesort([2, 4, 3, 1, 5]) == [1, 2, 3, 4, 5] assert stoogesort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert stoogesort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert stoogesort([]) == [] assert stoogesort([42]) == [42] ```","solution":"def stoogesort(arr): Sorts the array using the Stooge Sort algorithm. def stoogesort_helper(arr, l, h): if l >= h: return # If first element is greater than last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the array to be sorted if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort_helper(arr, l, h - t) stoogesort_helper(arr, l + t, h) stoogesort_helper(arr, l, h - t) stoogesort_helper(arr, 0, len(arr) - 1) return arr"},{"question":"As an aspiring software engineer, you are given the task of implementing a part of the insertion sort algorithm that ensures efficient positioning of elements within the sorted portion of the array. You need to write a function that leverages binary search to determine the correct insertion index. **Task**: Implement the `search_insert` function. # Function Specification ```python def search_insert(array, val): Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. Parameters: - array: List[int]: A sorted list of integers. - val: int: The target value to be inserted. Returns: - int: The index at which the target value should be inserted. # Your code here ``` # Input * `array` (List[int]): A sorted list of integers. * `val` (int): The target value to be inserted. # Output * `int`: The index at which the target value should be inserted. # Constraints * The length of `array` will be in the range [0, 10^5]. * The values in `array` and `val` will be in the range [-10^9, 10^9]. # Example ```python search_insert([1,3,5,6], 5) -> 2 search_insert([1,3,5,6], 2) -> 1 search_insert([1,3,5,6], 7) -> 4 search_insert([1,3,5,6], 0) -> 0 ``` # Performance Requirement Your function should run in O(log n) time complexity in order to efficiently find the insertion position in a sorted list. **Note**: You can assume that `array` is always sorted in ascending order. # Additional Notes Consider edge cases where the array might be empty, or the value to be inserted might be at the very beginning or end of the array.","solution":"def search_insert(array, val): Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. Parameters: - array: List[int]: A sorted list of integers. - val: int: The target value to be inserted. Returns: - int: The index at which the target value should be inserted. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == val: return mid elif array[mid] < val: low = mid + 1 else: high = mid - 1 return low"},{"question":"# Coding Challenge: Enhanced Selection Sort with Edge-Case Handling Context You are tasked with implementing and optimizing the Selection Sort algorithm for different use cases. The algorithm must handle various edge cases and provide a sorted result in ascending order. Task Write a function `enhanced_selection_sort(arr: list) -> list` that: 1. Sorts a given list of integers in ascending order using the Selection Sort algorithm. 2. Handles common edge cases effectively. 3. Optimizes the process where possible. Input * A list of integers `arr` where `1 <= len(arr) <= 10^4` * The integers within the list will be between `-10^6` and `10^6` Output * A new list with integers from `arr` sorted in ascending order. Constraints * The function should handle cases with an empty list or a single-element list without errors. * Time complexity requirements remain at O(n^2). Example ```python assert enhanced_selection_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] assert enhanced_selection_sort([]) == [] assert enhanced_selection_sort([42]) == [42] assert enhanced_selection_sort([4, 2, -3, 7, 0, -8]) == [-8, -3, 0, 2, 4, 7] ``` Performance Constraints * Ensure the implementation is not exceeding O(n^2) complexity in terms of time. * Maintain O(1) space complexity by not using additional data structures.","solution":"def enhanced_selection_sort(arr): Sorts a given list of integers in ascending order using the Selection Sort algorithm. Args: arr (list): List of integers to be sorted. Returns: list: New list with integers sorted in ascending order. n = len(arr) for i in range(n): min_index = i for j in range(i+1, n): if arr[j] < arr[min_index]: min_index = j # Swap the found minimum element with the first element of the unsorted part arr[i], arr[min_index] = arr[min_index], arr[i] return arr"},{"question":"You are given a partially filled 9x9 Sudoku grid filled with digits \'1\' to \'9\' and some empty cells marked as \'.\'. Your task is to write a function `solve_sudoku` that receives this grid and returns the grid fully solved. # Input * A list of lists representing a 9x9 grid. The grid contains digits \'1\' to \'9\' and empty cells represented by \'.\'. Example Input: ```python board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] ``` # Output * The function should modify the grid in-place to solve the Sudoku puzzle. # Constraints * The given Sudoku board will have exactly one solution. * The grid size will always be 9x9. # Function Signature ```python def solve_sudoku(board: List[List[str]]) -> None: pass ``` # Example Given the input above, the function should transform the board into: ```python [ [\\"5\\",\\"3\\",\\"4\\",\\"6\\",\\"7\\",\\"8\\",\\"9\\",\\"1\\",\\"2\\"], [\\"6\\",\\"7\\",\\"2\\",\\"1\\",\\"9\\",\\"5\\",\\"3\\",\\"4\\",\\"8\\"], [\\"1\\",\\"9\\",\\"8\\",\\"3\\",\\"4\\",\\"2\\",\\"5\\",\\"6\\",\\"7\\"], [\\"8\\",\\"5\\",\\"9\\",\\"7\\",\\"6\\",\\"1\\",\\"4\\",\\"2\\",\\"3\\"], [\\"4\\",\\"2\\",\\"6\\",\\"8\\",\\"5\\",\\"3\\",\\"7\\",\\"9\\",\\"1\\"], [\\"7\\",\\"1\\",\\"3\\",\\"9\\",\\"2\\",\\"4\\",\\"8\\",\\"5\\",\\"6\\"], [\\"9\\",\\"6\\",\\"1\\",\\"5\\",\\"3\\",\\"7\\",\\"2\\",\\"8\\",\\"4\\"], [\\"2\\",\\"8\\",\\"7\\",\\"4\\",\\"1\\",\\"9\\",\\"6\\",\\"3\\",\\"5\\"], [\\"3\\",\\"4\\",\\"5\\",\\"2\\",\\"8\\",\\"6\\",\\"1\\",\\"7\\",\\"9\\"] ] ``` # Explanation * Your implementation should adopt the backtracking approach used in the provided analysis. * First, calculate possible values for each empty cell. * Start solving from the cell with the fewest possible values. * Use recursion to attempt to fill the board and backtrack upon encountering any conflicts. * Properly handle edge cases to ensure the algorithm follows valid Sudoku rules. **Note**: Do not rely on any predefined example code; craft your implementation independently ensuring thorough understanding of the algorithm and its correctness.","solution":"from typing import List def solve_sudoku(board: List[List[str]]) -> None: def is_valid(board: List[List[str]], row: int, col: int, char: str) -> bool: for i in range(9): if board[row][i] == char or board[i][col] == char: return False if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == char: return False return True def solve(board: List[List[str]]) -> bool: for i in range(9): for j in range(9): if board[i][j] == \'.\': for char in \'123456789\': if is_valid(board, i, j, char): board[i][j] = char if solve(board): return True board[i][j] = \'.\' return False return True solve(board)"},{"question":"# Markov Chain Question The following question requires you to implement a function to find the likelihood of reaching a particular state within a fixed number of steps in a Markov Chain. # Context You are given a Markov Chain represented as a dictionary, where keys are states and values are dictionaries of transition probabilities to other states. Given the initial state, target state, and a maximum number of steps, your task is to determine the probability of reaching the target state within the allowed steps. # Function Signature ```python def probability_to_reach_state(chain: dict, start: str, target: str, steps: int) -> float: Calculates the probability of reaching the target state from the start state within a given number of steps in the given Markov Chain. :param chain: Dictionary representing the Markov Chain. :param start: Initial state. :param target: Target state we want to reach. :param steps: Maximum number of steps allowed. :return: Probability of reaching the target state within the given steps. ``` # Input - `chain`: Dictionary representing the Markov Chain. - `start`: Initial state as a string. - `target`: Target state as a string. - `steps`: Integer representing the maximum number of steps. # Output - Floating-point number representing the probability of reaching the target state within the allowed number of steps. # Constraints - The sum of transition probabilities for each state in the chain is 1. - The initial state and target state are keys in the chain. - The maximum number of steps is a non-negative integer (0 ≤ steps ≤ 50). # Example Considering the following Markov Chain: ```python chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } ``` Example 1: ```python start = \'A\' target = \'E\' steps = 1 probability_to_reach_state(chain, start, target, steps) == 0.4 ``` Example 2: ```python start = \'A\' target = \'A\' steps = 2 probability_to_reach_state(chain, start, target, steps) == 0.6 * 0.6 + 0.4 * 0.7 # 0.36 + 0.28 = 0.64 ``` # Notes 1. Consider edge cases such as when the number of steps is zero, ensuring that if the start state is the target state, the probability is 1. 2. Handle cases where transitions lead to substantial depths efficiently without exhausting memory. Provide a complete and efficient implementation for the function described.","solution":"def probability_to_reach_state(chain: dict, start: str, target: str, steps: int) -> float: Calculates the probability of reaching the target state from the start state within a given number of steps in the given Markov Chain. :param chain: Dictionary representing the Markov Chain. :param start: Initial state. :param target: Target state we want to reach. :param steps: Maximum number of steps allowed. :return: Probability of reaching the target state within the given steps. if steps == 0: return 1.0 if start == target else 0.0 # Initialize the dp array dp = [{state: 0.0 for state in chain} for _ in range(steps + 1)] dp[0][start] = 1.0 # Fill the dp array for step in range(1, steps + 1): for state in chain: for next_state, prob in chain[state].items(): dp[step][next_state] += dp[step - 1][state] * prob # Return the probability of reaching the target state within given steps return dp[steps][target]"},{"question":"# Question: Enhanced Insertion Sort with Custom Comparison You have been tasked with enhancing the provided insertion sort algorithm to support sorting based on a custom comparison function. This will allow the user to define their own criteria for ordering the elements in the list. Requirements: 1. **Function Signature**: ```python def enhanced_insertion_sort(arr, cmp, simulation=False): Sort the array with insertion sort algorithm using a custom comparison function. Parameters: arr (list): List of elements to be sorted cmp (function): Custom comparison function that takes two elements (x, y) and returns a negative value if x < y, zero if x == y, and a positive value if x > y. simulation (bool): If True, print each iteration of the algorithm. Default is False. ``` 2. **Input/Output**: - `arr`: A list of elements to be sorted. - `cmp`: A comparison function that takes two elements and returns a negative, zero, or positive value. - `simulation`: A boolean flag to print the array state at every iteration. The function should return the sorted list based on the custom comparison function. 3. **Constraints**: - The comparison function will be provided by the user and can handle any type of elements in the array with a comparison logic for those elements. - The algorithm should remain in-place and use O(1) extra space. 4. **Performance**: - Maintain the same time complexity as the standard insertion sort: O(n^2). Example: ```python def cmp_ascending(x, y): return x - y def cmp_descending(x, y): return y - x arr1 = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3] arr2 = [{\'value\': 10}, {\'value\': 20}, {\'value\': 15}] cmp_custom = lambda x, y: x[\'value\'] - y[\'value\'] print(enhanced_insertion_sort(arr1, cmp_ascending)) # Output: [1, 1, 2, 3, 3, 4, 5, 5, 6, 9] print(enhanced_insertion_sort(arr1, cmp_descending)) # Output: [9, 6, 5, 5, 4, 3, 3, 2, 1, 1] print(enhanced_insertion_sort(arr2, cmp_custom)) # Output: [{\'value\': 10}, {\'value\': 15}, {\'value\': 20}] ``` Note: Ensure to handle edge cases appropriately, including empty arrays, arrays with all identical elements, and elements of different data types.","solution":"def enhanced_insertion_sort(arr, cmp, simulation=False): Sort the array with insertion sort algorithm using a custom comparison function. Parameters: arr (list): List of elements to be sorted cmp (function): Custom comparison function that takes two elements (x, y) and returns a negative value if x < y, zero if x == y, and a positive value if x > y. simulation (bool): If True, print each iteration of the algorithm. Default is False. Returns: list: Sorted list of elements based on custom comparison function. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and cmp(arr[j], key) > 0: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(arr) return arr"},{"question":"Advanced Tree Traversal and Printing You are given a nested dictionary structure representing a tree. Each key-value pair in the dictionary can be one of the following: 1. String -> [mixed content] 2. String -> Integer Your task is to write a function `advanced_tree_print(tree: dict) -> None:` that prints the elements of this tree structure appropriately. The function should address the following: - Print each key. - If it encounters a string value, print it directly. - If it encounters an integer, print it on a new line with an additional indentation level. - Handle deeper nested dictionaries appropriately with increasing indentation levels. **Input:** - A dictionary `tree` representing the hierarchical data structure as described above. **Output:** - The function should print the structure of the dictionary tree as described, printing each element on its own line, with proper indentation to visually represent the hierarchical structure. **Constraints:** - You can assume the data structure does not contain cycles. - All dictionaries have string keys. - Values are either integers, strings, or nested dictionaries following the same rules. **Example:** Given the following input tree: ```python tree = { \'a\': [\'Adam\', {\'Book\': 4}], \'b\': {\'Bill\': [{ \'Computer\': 5 }, {\'TV\': 6}], \'Jill\': {\'Sports\': 1}}, \'c\': {\'Bill\': {\'Sports\': 3}}, \'d\': [\'Adam\', {\'Computer\': 3}, {\'Quin\': {\'Computer\': 3}}], \'e\': {\'Quin\': {\'Book\': 5, \'TV\': 2}}, \'f\': [\'Adam\', {\'Computer\': 7}] } ``` Your function should output: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 TV -> 6 Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 Quin -> Computer -> 3 e -> Quin -> Book -> 5 TV -> 2 f -> Adam -> Computer -> 7 ```","solution":"def advanced_tree_print(tree, level=0): indent = \' \' * level for key, value in tree.items(): if isinstance(value, dict): print(f\\"{indent}{key} ->\\") advanced_tree_print(value, level + 1) elif isinstance(value, list): print(f\\"{indent}{key} ->\\") for item in value: if isinstance(item, dict): advanced_tree_print(item, level + 1) else: print(f\\"{indent} {item} ->\\") else: print(f\\"{indent}{key} -> {value} \\")"},{"question":"# Shell Sort Implementation Task Scenario: You are a software engineer at a tech company that processes large datasets. One of your tasks is to optimize the sorting operations for medium-sized datasets in your workflow. To achieve this, you decide to implement the Shell Sort algorithm, given its good trade-off between complexity and performance for such datasets. Task: Implement the function `custom_shell_sort(arr)`, which sorts an array of integers using the Shell Sort algorithm with a gap sequence starting at `n//2` where `n` is the size of the array, and reducing the gap by half each iteration. Specifications: - **Input:** A list of integers, `arr`, where 0 <= len(arr) <= 10^5 and -10^9 <= arr[i] <= 10^9. - **Output:** A list of integers sorted in non-decreasing order. Requirements: 1. Your function should handle edge cases such as empty lists and lists with one element. 2. Performance should be optimized for the specified constraints. 3. Do not use any built-in sort functions. Function Signature: ```python def custom_shell_sort(arr: List[int]) -> List[int]: pass ``` Example: ```python assert custom_shell_sort([12, 34, 54, 2, 3]) == [2, 3, 12, 34, 54] assert custom_shell_sort([0, -1, 5, 100, 23]) == [-1, 0, 5, 23, 100] assert custom_shell_sort([]) == [] assert custom_shell_sort([1]) == [1] ``` Constraints: - Use a gap sequence starting at `n//2` and halving each time. - Aim for an efficient implementation regarding both time and space.","solution":"from typing import List def custom_shell_sort(arr: List[int]) -> List[int]: n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"# Context: You are tasked with managing an inventory system where items that are sold out should be replaced with new items having the highest priority based on urgency. You decide to develop this system based on a Min Heap to efficiently handle these priorities. # Problem: Implement a class `InventoryHeap` that extends the given `BinaryHeap` with additional methods to handle inventory specifics: 1. Maintain a `restock` queue where items to be restocked are added based on their priority. 2. Implement `restock_urgent_item` method which removes the most urgent item and adds it to the restock queue. # Requirements: 1. Extend `BinaryHeap` to `InventoryHeap`. 2. Implement the method `restock_urgent_item()` to remove and return the most urgent item (minimum element) from the heap and add it to the restock queue. 3. Provide a mechanism (`get_restock_queue()`) to retrieve the restock queue for inspection. # Function Specifications: **class InventoryHeap(BinaryHeap):** * **Method**: * `restock_urgent_item(self) -> int` * **Input**: None * **Output**: The item with the highest priority (minimum element) removed from the heap. * **Effect**: The removed item should be added to a restock queue. * `get_restock_queue(self) -> List[int]` * **Output**: Current state of the restock queue. Constraints: * Assume distinct priorities for each item. * Handle cases where `restock_urgent_item()` is called on an empty heap by returning `None`. * Items in the restock queue should remain in the order they were removed. # Example: ```python # Initialize inventory heap inventory = InventoryHeap() # Insert items with priorities inventory.insert(30) inventory.insert(10) inventory.insert(20) # Restock the most urgent item urgent_item = inventory.restock_urgent_item() # Should return and remove 10 # Get the restock queue restock_queue = inventory.get_restock_queue() # Should return [10] ```","solution":"import heapq class BinaryHeap: def __init__(self): self.heap = [] def insert(self, item): heapq.heappush(self.heap, item) def remove_min(self): if not self.heap: return None return heapq.heappop(self.heap) class InventoryHeap(BinaryHeap): def __init__(self): super().__init__() self.restock_queue = [] def restock_urgent_item(self): urgent_item = self.remove_min() if urgent_item is not None: self.restock_queue.append(urgent_item) return urgent_item def get_restock_queue(self): return self.restock_queue"},{"question":"# Question: Pangram Checker with Set-Based Optimization You are tasked with improving and implementing a function to determine if a given sentence is a pangram. An English pangram is a sentence that contains every letter of the alphabet at least once. The improved method should be optimized for performance. Function Signature ```python def is_pangram(sentence: str) -> bool: pass ``` Input - `sentence` (str): A sentence composed of English letters, spaces, digits, and punctuation. The length of the sentence is not more than 10^6 characters. Output - `bool`: Returns `True` if the sentence is a pangram, otherwise `False`. Constraints - The comparison should be case-insensitive. - The function should run efficiently even for maximum input size. Example ```python assert is_pangram(\\"The quick brown fox jumps over the lazy dog\\") == True assert is_pangram(\\"Hello World\\") == False ``` Notes - Consider using `set` operations for efficient membership testing. - Make sure to handle edge cases like sentences with punctuation and mixed casing.","solution":"def is_pangram(sentence: str) -> bool: Determines if a given sentence is a pangram. A pangram is a sentence that contains every letter of the alphabet at least once. # Define a set of all lowercase alphabetical characters. alphabet = set(\\"abcdefghijklmnopqrstuvwxyz\\") # Convert the sentence to lowercase and create a set of characters present in the sentence. sentence_characters = set(sentence.lower()) # Return if all characters in the alphabet set are in the sentence_characters set. return alphabet <= sentence_characters"},{"question":"# Question You are given a base implementation of `SinglyLinkedListNode` and `DoublyLinkedListNode` classes to represent the nodes in a singly linked list and a doubly linked list, respectively. Your task is to implement a `DoublyLinkedList` class with the following methods: 1. `insert_at_head(value)`: Insert a new node with the given value at the head of the list. 2. `insert_at_tail(value)`: Insert a new node with the given value at the tail of the list. 3. `delete_node(value)`: Delete the first node in the list with the given value. 4. `traverse_forward()`: Return a list of values by traversing the doubly linked list from head to tail. 5. `traverse_backward()`: Return a list of values by traversing the doubly linked list from tail to head. # Constraints 1. Each node contains an integer value. 2. The list should handle operations efficiently, with each method ideally operating within O(1) for insert and delete operations, given appropriate conditions (e.g., known nodes for delete). # Function Signature ```python class DoublyLinkedList: def __init__(self): # Initialize an empty list with head and tail pointers pass def insert_at_head(self, value): # Insert a node at the head of the list pass def insert_at_tail(self, value): # Insert a node at the tail of the list pass def delete_node(self, value): # Delete the first node with the specified value pass def traverse_forward(self): # Return a list of values from head to tail pass def traverse_backward(self): # Return a list of values from tail to head pass ``` # Example Usage ```python dll = DoublyLinkedList() dll.insert_at_head(5) dll.insert_at_tail(10) dll.insert_at_head(3) print(dll.traverse_forward()) # Output: [3, 5, 10] print(dll.traverse_backward()) # Output: [10, 5, 3] dll.delete_node(5) print(dll.traverse_forward()) # Output: [3, 10] print(dll.traverse_backward()) # Output: [10, 3] ```","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.prev = None self.next = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): new_node = DoublyLinkedListNode(value) if self.head is None: self.head = new_node self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_at_tail(self, value): new_node = DoublyLinkedListNode(value) if self.tail is None: self.head = new_node self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete_node(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return current = current.next def traverse_forward(self): result = [] current = self.head while current: result.append(current.value) current = current.next return result def traverse_backward(self): result = [] current = self.tail while current: result.append(current.value) current = current.prev return result"},{"question":"**Context**: You have been tasked with implementing a function that multiplies two non-negative integers represented as strings. This is a common problem in scenarios where numbers exceed the size limits of standard data types. **Requirements**: Write a function `multiply(num1: str, num2: str) -> str` that takes two non-negative integers in string format and returns their product, also in string format. # Constraints: 1. The input strings `num1` and `num2` will have lengths less than 110. 2. Both `num1` and `num2` will contain only digits 0-9. 3. Neither `num1` nor `num2` will contain any leading zeros. # Performance Expectations: 1. Expected time complexity is O(n * m), where n is the length of `num1` and m is the length of `num2`. 2. The space complexity should be minimized and operate within permissible limits of O(n + m). # Function Signature ```python def multiply(num1: str, num2: str) -> str: # Your implementation here ``` # Example **Input**: ```python num1 = \\"23\\" num2 = \\"45\\" ``` **Output**: ```python \\"1035\\" ``` **Explanation**: Multiplying 23 and 45 gives 1035, hence the function returns \\"1035\\". # Additional Considerations: 1. Ensure your solution handles edge cases such as multiplication involving zero. 2. Optimize your implementation to handle the largest input sizes within reasonable time. ```python # Example usage: print(multiply(\\"123\\", \\"456\\")) # Expected output: \\"56088\\" print(multiply(\\"9999\\", \\"9999\\")) # Expected output: \\"99980001\\" ``` # Detailed Explanation: The problem requires implementing the manual multiplication process of large numbers in string form. Instead of converting the strings to integers directly, you must manipulate the individual digits, simulate the placement of partial products, and then sum these products accurately to obtain the final result.","solution":"def multiply(num1: str, num2: str) -> str: if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" len1, len2 = len(num1), len(num2) result = [0] * (len1 + len2) for i in range(len1 - 1, -1, -1): for j in range(len2 - 1, -1, -1): mult = (ord(num1[i]) - ord(\'0\')) * (ord(num2[j]) - ord(\'0\')) p1, p2 = i + j, i + j + 1 sum_ = mult + result[p2] result[p2] = sum_ % 10 result[p1] += sum_ // 10 result_str = \'\'.join(map(str, result)) return result_str.lstrip(\'0\')"},{"question":"Enhanced Insertion Sort with Validation **Context:** You are given an array of integers and your task is to implement an enhanced version of the insertion sort algorithm that includes input validation and enhanced error handling. This enhanced version should: 1. Ensure that the input is not empty. 2. Validate that the input contains only integers. 3. Sort the array using the insertion sort algorithm provided, keeping the option for step-by-step simulation for educational purposes. **Function Signature:** ```python def enhanced_insertion_sort(arr, simulation=False): - arr: list of integers to be sorted. - simulation: boolean flag to enable step-by-step simulation. Returns: - A new list that is the sorted version of the input list. Raises: - ValueError: if the input list is empty. - TypeError: if the input list contains non-integer elements. ``` **Input Constraints:** * The array to be sorted: `arr` should contain between 1 and 1000 integer elements. * Each integer should be within the range: `-10^6` to `10^6`. * The simulation flag `simulation` is optional and defaults to `False`. **Output:** * The function should return a new list that is a sorted version of the input list `arr`. **Examples:** ```python enhanced_insertion_sort([34, 7, 23, 32, 5, 62]) # Returns: [5, 7, 23, 32, 34, 62] enhanced_insertion_sort([10, 7, 3, 1], simulation=True) # Output: Print each iteration of the sorting process (see provided snippet for simulation format) # Returns: [1, 3, 7, 10] enhanced_insertion_sort([], simulation=True) # Raises: ValueError: \\"The input list is empty.\\" enhanced_insertion_sort([10, \'7\', 3, 1]) # Raises: TypeError: \\"The input list must contain only integers.\\" ``` **Notes:** * You should not use any built-in sorting functions for this task. * Focus on handling edge cases and validating the input thoroughly.","solution":"def enhanced_insertion_sort(arr, simulation=False): - arr: list of integers to be sorted. - simulation: boolean flag to enable step-by-step simulation. Returns: - A new list that is the sorted version of the input list. Raises: - ValueError: if the input list is empty. - TypeError: if the input list contains non-integer elements. if not arr: raise ValueError(\\"The input list is empty.\\") if not all(isinstance(x, int) for x in arr): raise TypeError(\\"The input list must contain only integers.\\") sorted_arr = arr[:] # Create a copy of arr to avoid modifying the original list n = len(sorted_arr) for i in range(1, n): key = sorted_arr[i] j = i - 1 while j >= 0 and key < sorted_arr[j]: sorted_arr[j + 1] = sorted_arr[j] j -= 1 sorted_arr[j + 1] = key if simulation: print(f\\"Iteration {i}: {sorted_arr}\\") return sorted_arr"},{"question":"# Scenario: You are part of a development team creating a text-based game where certain commands are encoded to shorten their notation. Your task is to write a function that decodes these commands into their full representation so that the game can execute them correctly. # Task: Write a function `decode_string(s)` to decode the given encoded string. # Instructions: 1. The encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. 2. You may assume that the input string is always valid; i.e., no extra white spaces, and the square brackets are well-formed. 3. You may also assume that the original data does not contain any digits, and digits are only for those repeat numbers `k`. # Examples: * Input: `s = \\"3[a]2[bc]\\"` * Output: `\\"aaabcbc\\"` * Input: `s = \\"3[a2[c]]\\"` * Output: `\\"accaccacc\\"` * Input: `s = \\"2[abc]3[cd]ef\\"` * Output: `\\"abcabccdcdcdef\\"` # Function Signature: ```python def decode_string(s: str) -> str: Decodes a given encoded string as per the encoding rules. :param s: str : Encoded string :return: str : Decoded string ``` # Constraints: - String length `1 <= len(s) <= 30,000`. - You must achieve linear time complexity. # Performance Requirements: - Your solution should run in O(n) time and use O(n) space, where `n` is the length of the input string. Implement the function `decode_string` to effectively decode the given encoded string.","solution":"def decode_string(s: str) -> str: Decodes a given encoded string as per the encoding rules. :param s: str : Encoded string :return: str : Decoded string stack = [] curr_num = 0 curr_str = \'\' for char in s: if char.isdigit(): curr_num = curr_num * 10 + int(char) elif char == \'[\': # Push the current number and string onto the stack stack.append(curr_str) stack.append(curr_num) curr_str = \'\' curr_num = 0 elif char == \']\': # Pop the number and previous string from the stack num = stack.pop() prev_str = stack.pop() curr_str = prev_str + num * curr_str else: curr_str += char return curr_str"},{"question":"# Shell Sort Implementation Challenge You are tasked with implementing the Shell Sort algorithm. Your implementation should sort an array of integers in ascending order by utilizing the Shell Sort algorithm with an initially provided gap sequence. # Function Signature ```python def shell_sort(arr: List[int]) -> List[int]: pass ``` # Input * You will be provided with a single list `arr` of integers where: - (1 leq text{len(arr)} leq 10^4) - (-10^6 leq text{arr[i]} leq 10^6) for all valid indices (i). # Output * Return the sorted list in ascending order. # Constraints * You may assume that the built-in sort function of Python is not allowed. * The initial gap sequence to use is `gap = len(arr) // 2`, reducing by half for each subsequent iteration until it becomes zero. # Example ```python assert shell_sort([12, 34, 54, 2, 3]) == [2, 3, 12, 34, 54] assert shell_sort([4, 3, -1, -2, 0, 1]) == [-2, -1, 0, 1, 3, 4] ``` # Performance Requirements * Your solution should aim to handle the worst-case time complexity of (O(n^2)) efficiently. * Attempt to write clean and well-documented code. # Context In the context of a database indexing application, your goal is to efficiently sort record IDs to ensure faster lookup and retrieval processes. Correctly implementing the Shell Sort algorithm will guarantee an intermediate level of performance enhancement while maintaining low memory overheads.","solution":"from typing import List def shell_sort(arr: List[int]) -> List[int]: This function sorts a list of integers using the Shell Sort algorithm. n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"You are required to implement two functions: `encode` and `decode`. **Function 1: `encode(strs: List[str]) -> str`** * This function encodes a list of strings into a single string. * **Input**: A list of strings `strs` where each element is a non-empty string. * **Output**: A single encoded string. **Function 2: `decode(s: str) -> List[str]`** * This function decodes a single encoded string back into the original list of strings. * **Input**: A single encoded string `s`. * **Output**: A list of decoded strings. # Requirements 1. The encoded format should consist of each string’s length followed by a delimiter (\\":\\") and then the string itself. 2. The `encode` function should handle an empty list and return an appropriate encoded string. 3. The `decode` function should correctly reconstruct the original list of strings. 4. Assume the strings to be encoded do not contain the \\":\\" character to simplify the solution. # Example ```python # Example 1: input_strings = [\\"hello\\", \\"world\\"] encoded = encode(input_strings) # Returns \\"5:hello5:world\\" decoded = decode(encoded) # Returns [\\"hello\\", \\"world\\"] # Example 2: input_strings = [\\"a\\", \\"b\\", \\"c\\"] encoded = encode(input_strings) # Returns \\"1:a1:b1:c\\" decoded = decode(encoded) # Returns [\\"a\\", \\"b\\", \\"c\\"] # Example 3: input_strings = [\\"\\"] encoded = encode(input_strings) # Returns \\"0:\\" decoded = decode(encoded) # Returns [\\"\\"] ``` **Constraints**: - The input strings do not contain the \\":\\" character. - The total input size will not exceed 10^6 characters. **Note**: Ensure that your encoding and decoding handles edge cases such as empty strings or a mix of long and short strings.","solution":"def encode(strs): Encodes a list of strings to a single string. :param strs: List of strings to encode. :return: Encoded single string. encoded_string = \\"\\" for s in strs: encoded_string += str(len(s)) + \\":\\" + s return encoded_string def decode(s): Decodes a single encoded string back to the list of original strings. :param s: Encoded single string. :return: Decoded list of strings. decoded_strings = [] i = 0 while i < len(s): # Find the position of the delimiter \':\' j = s.find(\\":\\", i) # Extract the length of the next string length = int(s[i:j]) # Extract the string of the given length string = s[j + 1:j + 1 + length] decoded_strings.append(string) # Move the index to the next encoded string i = j + 1 + length return decoded_strings"},{"question":"Detect Cycle Starting Node in a Linked List Problem Statement Given a linked list, implement a function `detectCycleStart(head)` that finds the first node in the cycle if a cycle is present. The function should return the node where the cycle begins or `None` if there is no cycle. Function Signature ```python def detectCycleStart(head: Node) -> Node: pass ``` Input - `head`: The head node of the singly linked list. Output - The node where the cycle starts or `None` if there is no cycle. Constraints - The linked list may contain no nodes or may contain a large cycle. - Each node contains an integer value and a next pointer. Example ```plaintext List A: 1 -> 2 -> 3 -> 4 -> 5 -> 1 (cycle starts at node with value 1) List B: A -> B -> C -> D -> E -> C (cycle starts at node with value \'C\') For the first list, `detectCycleStart(head)` should return the node with value 1. For the second list, `detectCycleStart(head)` should return the node with value \'C\'. ``` Notes - Avoid using extra space for storing nodes. - Implement you algorithm with O(n) time complexity and O(1) space complexity. Writing Your Test Cases Ensure your implementation passes these test cases: 1. No cycle present (e.g., `1 -> 2 -> 3 -> 4`). 2. Cycle present at the first node (e.g., `1 -> 2 -> 3 -> 4 -> 1`). 3. Large linked list with a cycle in the middle.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def detectCycleStart(head: Node) -> Node: if not head or not head.next: return None slow = head fast = head # Detect if there is a cycle using two pointers while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: # If there\'s no cycle return None # Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Question: Double Stack Elements Given a stack, write a function `stutter` that duplicates every value in the stack. You are required to implement two different versions of the method: 1. **stutter_with_stack**: Use only an additional stack (no other data structures like lists or queues). 2. **stutter_with_queue**: Use a single queue, leveraging deque from the collections module to temporarily store and rearrange values. **Function Signatures**: ```python def stutter_with_stack(stack: List[int]) -> List[int]: pass def stutter_with_queue(stack: List[int]) -> List[int]: pass ``` **Input**: - A list of integers representing a stack (where the last element of the list is the top of the stack). **Output**: - The input list, modified in place, with each value duplicated. **Constraints**: * All stack element values can range between -10^9 to 10^9. * The number of elements in the stack `n` can range from 0 to 10^5. **Example**: ```python stack = [3, 7, 1, 14, 9] # After stutter_with_stack(stack) or stutter_with_queue(stack): # stack would be [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` **Requirements**: 1. Efficiency: - Ensure your solution runs efficiently within O(n) time complexity. 2. Correctness: - Consider edge cases like empty stacks and single-element stacks. Implement both functions, `stutter_with_stack` and `stutter_with_queue`.","solution":"def stutter_with_stack(stack): Duplicates each element in the stack using an additional stack. Input stack is modified in place. helper_stack = [] # Step 1: Transfer elements from original stack to helper_stack while stack: helper_stack.append(stack.pop()) # Step 2: Transfer elements back to original stack twice to duplicate while helper_stack: element = helper_stack.pop() stack.append(element) stack.append(element) def stutter_with_queue(stack): Duplicates each element in the stack using a queue (deque from collections). Input stack is modified in place. from collections import deque queue = deque() # Step 1: Transfer elements from stack to queue while stack: queue.append(stack.pop()) # Step 2: Transfer elements back to stack to reverse original order while queue: stack.append(queue.popleft()) # Step 3: Use the queue again to duplicate elements to the stack while stack: element = stack.pop() queue.append(element) queue.append(element) # Step 4: Finally transfer duplicated elements back to the stack while queue: stack.append(queue.popleft())"},{"question":"Custom Sorted Merging Given two individually sorted arrays, `arr1` and `arr2`, write a function `custom_sorted_merge(arr1, arr2)` to merge them into a single sorted array. You are required to use the merging technique from the Merge Sort algorithm but extended for merging two separately sorted arrays rather than arrays derived from a single large one. # Function Signature ```python def custom_sorted_merge(arr1, arr2): pass ``` # Input 1. `arr1` (List[int]): A sorted list of integers. 2. `arr2` (List[int]): Another sorted list of integers. # Output * Returns (List[int]): A new sorted list that merges the elements of `arr1` and `arr2`. # Constraints * The input arrays can have different lengths. * The input arrays may contain duplicate elements. * The function should be implemented with a time complexity of O(n + m), where n and m are the lengths of `arr1` and `arr2` respectively. * Additional space usage should be minimized. # Example ```python # Example 1 arr1 = [1, 4, 6] arr2 = [2, 5, 8] print(custom_sorted_merge(arr1, arr2)) # Output: [1, 2, 4, 5, 6, 8] # Example 2 arr1 = [0, 3, 7] arr2 = [] print(custom_sorted_merge(arr1, arr2)) # Output: [0, 3, 7] # Example 3 arr1 = [1, 1, 1] arr2 = [1, 1] print(custom_sorted_merge(arr1, arr2)) # Output: [1, 1, 1, 1, 1] # Example 4 arr1 = [5, 10, 15] arr2 = [3, 4, 9] print(custom_sorted_merge(arr1, arr2)) # Output: [3, 4, 5, 9, 10, 15] ``` In addition to implementing the function, explain the edge cases you covered and how your solution ensures efficient merging with respect to time and space complexity.","solution":"def custom_sorted_merge(arr1, arr2): Merges two sorted arrays into a single sorted array. n, m = len(arr1), len(arr2) merged_array = [] i, j = 0, 0 while i < n and j < m: if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Add remaining elements of arr1 (if any) while i < n: merged_array.append(arr1[i]) i += 1 # Add remaining elements of arr2 (if any) while j < m: merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"Optimizing Selection Sort for Specific Use Cases You are given the task of sorting an array using a selection sort algorithm. The array contains non-negative integers. However, due to the nature of the data, the array often contains multiple instances of the same number, and the number of unique elements in the array is significantly smaller than the length of the array. Under such constraints, it\'s possible to optimize the selection sort slightly. Task Write a function `optimized_selection_sort` that sorts an array of non-negative integers using a modified selection sort algorithm that takes advantage of the scenario with many duplicate elements. Input and Output Formats * Input: A list of non-negative integers `arr`. * Output: A list of the integers sorted in non-decreasing order. Constraints 1. The elements in the array `arr` are non-negative integers. 2. The array `arr` can have repeated elements. 3. Length of `arr` can be up to 10^4. Example ```python def optimized_selection_sort(arr): # Implement the optimized selection sort algorithm here pass # Example Usage arr = [4, 2, 2, 8, 3, 3, 1] print(optimized_selection_sort(arr)) # Output should be [1, 2, 2, 3, 3, 4, 8] ``` # Additional Requirements: 1. Optimize for the scenario where there are many repetitions, ensuring that unnecessary comparisons are minimized. 2. Ensure your solution runs in O(n^2) time complexity in the worst case, but aim for better average performance in the context of the constraints provided.","solution":"def optimized_selection_sort(arr): Sorts an array of non-negative integers using an optimized selection sort. if not arr: return arr unique_elements = list(set(arr)) # Extract unique elements unique_elements_sorted = sorted(unique_elements) # Sort them element_counts = {element: 0 for element in unique_elements} for element in arr: element_counts[element] += 1 # Count occurrences of each element sorted_arr = [] for element in unique_elements_sorted: sorted_arr.extend([element] * element_counts[element]) # Flatten the sorted, frequency counted elements return sorted_arr"},{"question":"You are given a singly linked list where each node contains an integer value. Write a function to remove duplicates from the linked list without using any additional data structures like sets or arrays. Ensure the order of nodes is retained. # Function Details: Implement a function `remove_duplicates(head)` where: - `head`: The head node of the singly linked list. # Input Format: - A linked list node structure `Node` is given, where each node has an integer value `val`. - You will be provided the head of a singly linked list. # Output Format: - The function should modify the linked list in place and return the head of the modified list. # Constraints: - The list length can be in the range [0, 10^4]. - The linked list values are integers within the range of [-10^4, 10^4]. # Example: ```python class Node: def __init__(self, val=None): self.val = val self.next = None def print_linked_list(head): while head: print(head.val, end=\\" -> \\" if head.next else \\"n\\") head = head.next # Example usage a1 = Node(1) a2 = Node(2) a3 = Node(1) a4 = Node(3) a1.next = a2 a2.next = a3 a3.next = a4 head = remove_duplicates(a1) print_linked_list(head) ``` # Expected Output: ``` 1 -> 2 -> 3 ``` # Notes: Handle edge cases such as: * Empty lists * Single-element lists * Lists with no duplicates * Lists with all identical elements Ensure your code is optimized for time and space complexity requirements as much as possible without using additional data structures.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates(head): if not head: return head current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next return head"},{"question":"# Coding Task: Implement a Reverse Polish Notation (RPN) Calculator Using Stacks Context Reverse Polish Notation (RPN) is a mathematical notation where operators follow their operands. It does not need any parentheses as long as each operator has a fixed number of operands. For example, the expression `3 4 +` evaluates to `7`, and `5 1 2 + 4 * + 3 -` evaluates to `14`. Task Use the stack data structures provided (ArrayStack or LinkedListStack) to implement an RPN calculator. Requirements 1. Implement a function `rpn_calculator(expression: List[str]) -> float` that evaluates an RPN expression. 2. Use either `ArrayStack` or `LinkedListStack` for managing the operands during the calculation. Input and Output Format * **Input**: * A list of strings representing the RPN expression (e.g., `[\\"5\\", \\"1\\", \\"2\\", \\"+\\", \\"4\\", \\"*\\", \\"+\\", \\"3\\", \\"-\\"]`). * **Output**: * A float representing the evaluated result of the RPN expression. * **Constraints**: * The input expression is a valid RPN expression. * Operators supported: `+`, `-`, `*`, `/`. Example ```python print(rpn_calculator([\\"3\\", \\"4\\", \\"+\\"])) # Output: 7.0 print(rpn_calculator([\\"5\\", \\"1\\", \\"2\\", \\"+\\", \\"4\\", \\"*\\", \\"+\\", \\"3\\", \\"-\\"])) # Output: 14.0 ``` Implementation Advice 1. Use the stack to store operands as they are encountered. 2. When an operator is encountered, pop the necessary operands from the stack, perform the operation, and push the result back onto the stack. 3. At the end of the expression, the stack should contain one element, which is the final result.","solution":"from typing import List def rpn_calculator(expression: List[str]) -> float: stack = [] for token in expression: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == \\"+\\": result = a + b elif token == \\"-\\": result = a - b elif token == \\"*\\": result = a * b elif token == \\"/\\": result = a / b stack.append(result) else: stack.append(float(token)) return stack.pop()"},{"question":"# Objective You are required to implement the Insertion Sort algorithm using a helper function that efficiently finds the correct insertion position using binary search. # Task Write a function `insertion_sort(array)` that sorts an array of integers in ascending order using the Insertion Sort algorithm. Utilize the `search_insert` method to find the index where each element should be placed. # Function Specifications - **Input**: - `array`: A list of integers. E.g., `[5, 4, 3, 8, 2]` - **Output**: - Return the sorted list. # Constraints - 0 ≤ len(array) ≤ 10^3 - -10^4 ≤ array[i] ≤ 10^4 # Example ```python def insertion_sort(array): pass print(insertion_sort([4, 3, 2, 10, 12, 1, 5, 6])) # Output: [1, 2, 3, 4, 5, 6, 10, 12] print(insertion_sort([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] print(insertion_sort([])) # Output: [] ``` # Note: - Use the provided `search_insert` function within your `insertion_sort` to determine where each new element should be placed. - Avoid using Python’s built-in sort functions. # Provided Code ```python def search_insert(array, val): low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low ```","solution":"def search_insert(array, val): low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low def insertion_sort(array): for i in range(1, len(array)): key = array[i] j = i - 1 insert_position = search_insert(array[:i], key) # Move all elements to the right to create the space for the key while j >= insert_position: array[j + 1] = array[j] j -= 1 array[insert_position] = key return array"},{"question":"# Context You are tasked with implementing a function to determine the height of a binary tree. This is a crucial step in various tree-related algorithms, particularly those that involve tree balancing or depth-related operations. # Objective Implement a function which computes the height of a binary tree. # Function Signature ```python def calculate_tree_height(root: Optional[Node]) -> int: pass ``` # Input and Output * **Input**: A binary tree root node (`root`), which is the root of a binary tree structure defined by class `Node`. * Note: The `Node` class has the attributes `left`, `right`, and `value`. * **Output**: An integer representing the height of the tree. # Constraints * The input tree can be empty, in which case the height should be 0. * The tree nodes are instances of the `Node` class defined as follows (for reference): ```python class Node: def __init__(self, value): self.value = value self.left = None self.right = None ``` # Requirements 1. Implement the function using recursion. 2. Ensure the function handles edge cases, such as an empty tree and a tree with only one node. 3. Avoid excessive stack usage for deep trees if possible. # Example ```python # Tree Example: # 1 # / # 2 3 # / # 4 5 # # The height of the given tree is 3 root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.right.right = Node(5) assert calculate_tree_height(root) == 3 ``` # Notes - Consider writing unit tests to validate your implementation using various tree structures.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None def calculate_tree_height(root): Computes the height of a binary tree. if root is None: return 0 else: left_height = calculate_tree_height(root.left) right_height = calculate_tree_height(root.right) return max(left_height, right_height) + 1"},{"question":"The provided functions manipulate 2D matrices through rotations and inversions. Given a square matrix, these functions perform the following operations: 1. `rotate_clockwise(matrix)`: Returns a new matrix rotated 90 degrees clockwise. 2. `rotate_counterclockwise(matrix)`: Returns a new matrix rotated 90 degrees counterclockwise. 3. `top_left_invert(matrix)`: Returns a new matrix inverted along the top-left to bottom-right axis. 4. `bottom_left_invert(matrix)`: Returns a new matrix inverted along the bottom-left to top-right axis. # Task Implement an additional function `rotate_180(matrix)` that rotates a given square matrix by 180 degrees. This function should return a new matrix representing the original matrix rotated by 180 degrees. # Function Signature ```python def rotate_180(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Input * `matrix` (List of List of ints): A square matrix of integers, where `1 <= len(matrix) <= 100` and `1 <= len(matrix[0]) <= 100`. # Output * Returns a List of List of ints: A new matrix representing the original matrix rotated by 180 degrees. # Constraints * The matrix is guaranteed to be a 2D list with equal number of rows and columns. # Example ```python # initial matrix matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # rotate_180(matrix) should return [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] ``` # Performance Requirements The function should aim for linear traversal of matrix elements, resulting in an efficient time complexity of O(n^2) and space complexity of O(n^2). # Scenario Your matrix processing system requires a functionality to effectively rotate the visual representation of matrices for reporting purposes. Implement `rotate_180(matrix)` to offer the complete set of rotation functionalities.","solution":"def rotate_180(matrix): Rotates a given square matrix by 180 degrees. Args: matrix (List[List[int]]): A square matrix of integers. Returns: List[List[int]]: A new matrix representing the original matrix rotated by 180 degrees. n = len(matrix) return [[matrix[n-1-i][n-1-j] for j in range(n)] for i in range(n)] # Example usage: # initial matrix matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # rotate_180(matrix) should return # [ # [9, 8, 7], # [6, 5, 4], # [3, 2, 1] # ] rotate_180(matrix)"},{"question":"# Context: You are working on a project that involves analyzing a large dataset of sorted integer values. As part of the project, you need to identify pairs of numbers that add up to a specific target value. Your task is to implement a solution that efficiently finds these pairs and returns their indices. These indices should be in a 1-based format (i.e., indexing starts from 1). # Task: Implement a function `find_two_sum()` that takes a sorted list of integers and a target integer, and returns a list containing the 1-based indices of the two numbers that add up to the target. It is guaranteed that there will be exactly one solution. # Function Signature: ```python def find_two_sum(numbers: List[int], target: int) -> List[int]: ``` # Input: - `numbers`: A list of integers sorted in ascending order. - `target`: An integer representing the target sum. # Output: - A list containing two integers representing the 1-based indices of the two numbers that add up to the target. # Constraints: - The input list may not contain any duplicates. - Each input will have exactly one solution. - Indices in the solution must be in ascending order. # Examples: ```python # Example 1 numbers = [2, 7, 11, 15] target = 9 # The pair 2 and 7 add up to 9, with 1-based indices 1 and 2. print(find_two_sum(numbers, target)) # Output: [1, 2] # Example 2 numbers = [1, 2, 3, 4, 4, 9, 56, 90] target = 8 # The pair 4 and 4 add up to 8, with 1-based indices 4 and 5. print(find_two_sum(numbers, target)) # Output: [4, 5] ``` # Notes: - Ensure your function efficiently handles the sorted nature of the list. - Optimize for both time and space complexity where possible.","solution":"from typing import List def find_two_sum(numbers: List[int], target: int) -> List[int]: Finds two indices of the numbers in a sorted list that add up to the target. The indices are returned as 1-based. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 return [] # Just a fallback, guaranteed there is exactly one solution."},{"question":"You are given an unordered list of integers. Your task is to write a function `get_weighted_histogram` that not only counts the frequency of each integer but also calculates a \\"weight\\" for each integer. The weight of an integer is defined as its frequency multiplied by the integer itself. The function should return a dictionary where the keys are the unique integers from the input list, and the values are tuples containing two elements: 1. The frequency of the integer. 2. The weight of the integer. # Function Signature ```python def get_weighted_histogram(input_list: list) -> dict: ``` # Input - `input_list` (List[int]): An unordered list of integers. # Output - `histogram` (Dict[int, Tuple[int, int]]): A dictionary where each key is an integer from `input_list`, and each value is a tuple where the first element is the frequency of the integer, and the second element is the weight of the integer. # Constraints - The input list may contain up to (10^5) elements. - Each integer in the input list is between (-10^6) and (10^6) (inclusive). # Example ```python input_list = [3, 3, 2, 1] # Output: {1: (1, 1), 2: (1, 2), 3: (2, 6)} input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] # Output: {2: (1, 2), 3: (2, 6), 4: (1, 4), 5: (3, 15), 6: (1, 6), 7: (1, 7)} ```","solution":"def get_weighted_histogram(input_list: list) -> dict: histogram = {} for num in input_list: if num in histogram: histogram[num] = (histogram[num][0] + 1, histogram[num][1] + num) else: histogram[num] = (1, num) return histogram"},{"question":"You are provided with two strings, `s1` and `s2`. String `s2` contains all unique characters. Write a function `max_common_subsequence(s1: str, s2: str) -> List[str]` that finds all the longest common subsequences between `s1` and `s2` and returns them as a list. If there is more than one subsequence of the maximum length, return all such subsequences. Your implementation should aim for a time complexity of O(n logn). # Input Format * `s1`: A string of length n (1 <= n <= 10^4). * `s2`: A string containing all distinct characters of length m (1 <= m <= 10^4). # Output Format Return a list of strings containing all longest common subsequences between `s1` and `s2`. # Constraints * `s2` contains all unique characters. * If there are multiple longest common subsequences, they all should be returned. # Example Input ```plaintext s1 = \\"abcdxyz\\" s2 = \\"xyzabcd\\" ``` Output ```python [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"x\\", \\"y\\", \\"z\\"] ``` # Explanation All characters in `s1` and `s2` are common and have length 1 in this case. Since they are the longest common subsequences, all characters are returned.","solution":"def max_common_subsequence(s1: str, s2: str) -> list: # Create a set of characters from s2 for quick lookup set_s2 = set(s2) # Find the intersection of s1 and s2 common_characters = [ch for ch in s1 if ch in set_s2] # Return the common characters as each is a subsequence of length 1, which is the longest return common_characters"},{"question":"Binary Search with Modification **Scenario**: You are a software engineer working on a search functionality for a sorted dataset. The dataset is an array of integers sorted in ascending order. However, you have an additional constraint: you need to find not just the position of a specific value, but also the count of how many times that value appears in the array. **Task**: Implement a function `count_occurrences(array, value)` that takes a sorted array `array` of integers and an integer `value`, and returns the count of occurrences of `value` in the array. Your solution should be efficient with respect to time complexity. **Function Signature**: ```python def count_occurrences(array: List[int], value: int) -> int: ``` **Input**: * `array` (List[int]): A list of integers sorted in ascending order. * `value` (int): The integer value to search for in the array. **Output**: * Returns an integer which is the count of occurrences of `value` in the array. **Constraints**: * The array length is between 0 and (10^6). * The values in the array and the target value are between (-10^9) and (10^9). **Example**: ```python assert count_occurrences([1, 2, 2, 2, 3, 4, 5], 2) == 3 assert count_occurrences([1, 2, 3, 4, 5], 6) == 0 assert count_occurrences([], 1) == 0 assert count_occurrences([2, 2, 2, 2, 2], 2) == 5 ``` **Notes**: - You must utilize binary search mechanism to ensure the solution remains efficient. - Consider edge cases like empty arrays and values not present in the array.","solution":"from typing import List def count_occurrences(array: List[int], value: int) -> int: def find_first_position(array, value): left, right = 0, len(array) - 1 first_pos = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == value: first_pos = mid right = mid - 1 elif array[mid] < value: left = mid + 1 else: right = mid - 1 return first_pos def find_last_position(array, value): left, right = 0, len(array) - 1 last_pos = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == value: last_pos = mid left = mid + 1 elif array[mid] < value: left = mid + 1 else: right = mid - 1 return last_pos first_pos = find_first_position(array, value) if first_pos == -1: return 0 last_pos = find_last_position(array, value) return last_pos - first_pos + 1"},{"question":"Given two arrays representing the preorder and postorder traversal of a full binary tree, your task is to construct the binary tree and return its inorder traversal. **Input:** - `pre` (list): A list of integers representing the preorder traversal of the full binary tree. - `post` (list): A list of integers representing the postorder traversal of the full binary tree. **Output:** - A list of integers representing the inorder traversal of the constructed binary tree. **Constraints:** - The lengths of `pre` and `post` are equal. - The tree is a full binary tree (i.e., every node has either 0 or 2 children). # Example ```python pre = [1, 2, 4, 8, 9, 5, 3, 6, 7] post = [8, 9, 4, 5, 2, 6, 7, 3, 1] # Expected Output [8, 4, 9, 2, 5, 1, 6, 3, 7] ``` # Explanation of Example ``` Given Preorder: 1, 2, 4, 8, 9, 5, 3, 6, 7 Given Postorder: 8, 9, 4, 5, 2, 6, 7, 3, 1 Constructed Binary Tree: 1 / 2 3 / / 4 5 6 7 / 8 9 Inorder Traversal: 8, 4, 9, 2, 5, 1, 6, 3, 7 ``` # Constraints - You need to solve this problem using a recursive approach. - Handle the entire input and transformation within a limited memory footprint, i.e., make sure that the space complexity is optimized.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(preorder, postorder): Constructs a full binary tree given its preorder and postorder traversals. :param preorder: List[int] :param postorder: List[int] :return: TreeNode (root of the constructed binary tree) if not preorder or not postorder: return None root = TreeNode(preorder[0]) if len(preorder) == 1: return root # Find the index of the left subtree root in postorder list L = postorder.index(preorder[1]) + 1 # Use this index to split preorder and postorder lists into left and right subtrees root.left = buildTree(preorder[1:L+1], postorder[:L]) root.right = buildTree(preorder[L+1:], postorder[L:-1]) return root def inorderTraversal(root): Returns the inorder traversal of a binary tree :param root: TreeNode :return: List[int] return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right) if root else [] def getInorderFromPrePost(pre, post): Given preorder and postorder traversal lists, construct the binary tree and return its inorder traversal list. :param pre: List[int] :param post: List[int] :return: List[int] root = buildTree(pre, post) return inorderTraversal(root)"},{"question":"**Problem Statement: Cocktail Shaker Sort Algorithm** Given an array of integers, implement Cocktail Shaker Sort to sort the array in ascending order. This sorting algorithm is a bidirectional version of Bubble Sort. Your task is to ensure that it correctly sorts various types of arrays, including edge cases. **Function Signature**: ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` **Input**: * `arr`: List of integers, with the constraint that `1 <= len(arr) <= 10^4` and `-10^6 <= arr[i] <= 10^6` for all valid i. **Output**: * A new list representing the sorted order of the input list. **Constraints**: * The function should modify the input array in place and return it. * Your implementation should handle empty arrays and arrays of arbitrary lengths as specified in the input constraints. **Examples**: 1. Input: `[5, 1, 4, 2, 8, 0, 2]` Output: `[0, 1, 2, 2, 4, 5, 8]` 2. Input: `[-3, -1, 0, -2, 2]` Output: `[-3, -2, -1, 0, 2]` 3. Input: `[3, 2, 1, 4, 6, 5, 9, 7]` Output: `[1, 2, 3, 4, 5, 6, 7, 9]` **Scenario**: Imagine you are sorting data from a sensor that reads temperature values periodically. These values need frequent sorting to analyze trends and detect anomalies. Use the Cocktail Shaker Sort to order the temperature readings efficiently. **Instructions**: 1. Implement the `cocktail_shaker_sort` function. 2. Ensure your function is efficient for the input constraints. 3. Write comprehensive test cases to validate your implementation, especially on edge cases and various data patterns.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts an array using the cocktail shaker sort algorithm. if not arr: return arr n = len(arr) start = 0 end = n - 1 swapped = True while swapped: swapped = False for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break swapped = False end -= 1 for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr"},{"question":"# Counting Sort Implementation Challenge Scenario Your company has tasked you with developing a report generator that processes large logs of integer data, representing different metrics collected over time. To ensure rapid report generation, the metrics must be sorted efficiently. You will use the Counting Sort algorithm to achieve this task. Objective Implement the Counting Sort algorithm given the constraints and guidelines below. Function Implementation Implement the function `counting_sort(arr: List[int]) -> List[int]` which takes a list of integers `arr` and returns a sorted list. Input * `arr` (List[int]): An array of integers which can include negative numbers. Output * Return a sorted list of integers. Constraints 1. **Range**: The integers in the array can be both positive and negative, and their absolute values do not exceed `1000`. 2. **Size**: The array can contain up to `10^6` integers. 3. **Performance**: The solution should maintain linear time complexity `O(n + k)`. Example * Example 1: * Input: `arr = [4, 2, -3, 6, 2, 4, -3]` * Output: `[-3, -3, 2, 2, 4, 4, 6]` * Example 2: * Input: `arr = [32, 1, -50, 16, 16, 1, -50]` * Output: `[-50, -50, 1, 1, 16, 16, 32]` Notes * Carefully handle negative values, making sure they do not break the algorithm. * Focus on achieving the given performance requirements and ensure correctness through edge case testing. Template ```python from typing import List def counting_sort(arr: List[int]) -> List[int]: # Implement the counting sort algorithm with consideration for negative numbers. pass ```","solution":"from typing import List def counting_sort(arr: List[int]) -> List[int]: if not arr: return [] max_val = max(arr) min_val = min(arr) range_of_elements = max_val - min_val + 1 # Initialize count array with all zeros count = [0] * range_of_elements output = [0] * len(arr) # Store count of each number for num in arr: count[num - min_val] += 1 # Change count[i] so that count[i] now contains actual position of this number in output array for i in range(1, len(count)): count[i] += count[i - 1] # Build the output array for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"You are given a matrix of `m x n` integer elements where every row and column is sorted in non-decreasing order. Write a function `find_element_in_sorted_matrix(matrix, key)` to determine if a given integer `key` is present in the matrix. If the key is found, return the tuple `(row, column)` indicating the position of the key in 1-indexed format. If the key is not found, return `None`. # Expected Input and Output Format * **Input**: - `matrix` - A 2D list of integers representing the matrix, where each row and column is sorted in non-decreasing order. - `key` - An integer to be searched within the matrix. * **Output**: - A tuple `(row, column)` if the key is found, otherwise `None`. # Input Constraints * The number of rows `m` and columns `n` will both be `>= 0` and `<= 10^3`. * The integers in the `matrix` can be in the range of `-10^9` to `10^9`. * No assumptions about the distinctness of elements in the matrix. # Performance Requirements Your solution should run within O(m + n) time complexity. # Example ```python def find_element_in_sorted_matrix(matrix, key): # Your implementation here # Example usage: matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 print(find_element_in_sorted_matrix(matrix, key)) # Output: (2, 3) key = 10 print(find_element_in_sorted_matrix(matrix, key)) # Output: None ``` # Notes * `matrix` can have 0 rows or 0 columns, in such cases, always return `None`. * Ensure that your function adheres to the performance constraints. * Make sure to handle edge cases and error scenarios as discussed.","solution":"def find_element_in_sorted_matrix(matrix, key): Searches for a key in a sorted matrix where each row and column is sorted in non-decreasing order. Args: matrix (list of list of int): The 2D sorted matrix. key (int): The integer to search for. Returns: tuple: A tuple (row, column) indicating the 1-indexed position of the key, None if key is not found. if not matrix or not matrix[0]: return None rows = len(matrix) cols = len(matrix[0]) # Start from top right corner row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == key: return (row + 1, col + 1) elif matrix[row][col] > key: col -= 1 else: row += 1 return None"},{"question":"# Coding Problem: Intersection of Two Linked Lists Problem Statement: You are given two singly linked lists headA and headB. Your task is to write a function `get_intersection_node(headA, headB)` that finds and returns the intersection node of the two linked lists, if it exists. If the two linked lists do not intersect, the function should return `None`. A linked list node is defined as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Input: - `headA`: The head node of the first singly linked list. - `headB`: The head node of the second singly linked list. Output: - Return the intersection node if the two linked lists intersect. - If the lists do not intersect, return `None`. Constraints: - The number of nodes in both lists will be between 0 and 10^4. - The linked lists must not have cycles. - Nodes are uniquely identified based on their address in memory, not by their value. Example: ```python # Suppose the lists have the following structure: # List A: 4 -> 1 -> 8 -> 4 -> 5 # List B: 5 -> 6 -> 1 -> 8 -> 4 -> 5 # The intersection node is at value 8. listA = ListNode(4) listA.next = ListNode(1) intersect = ListNode(8) listA.next.next = intersect intersect.next = ListNode(4) intersect.next.next = ListNode(5) listB = ListNode(5) listB.next = ListNode(6) listB.next.next = ListNode(1) listB.next.next.next = intersect assert get_intersection_node(listA, listB) == intersect assert get_intersection_node(listA, ListNode(3)) is None ``` Function Signature ```python def get_intersection_node(headA: ListNode, headB: ListNode) -> ListNode: ``` Good luck, and remember to handle edge cases efficiently!","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def get_intersection_node(headA: ListNode, headB: ListNode) -> ListNode: if not headA or not headB: return None pointerA, pointerB = headA, headB while pointerA is not pointerB: pointerA = pointerA.next if pointerA else headB pointerB = pointerB.next if pointerB else headA return pointerA"},{"question":"Coding Assessment Question: Pigeonhole Sort You are given a list of integers. Your task is to implement the **Pigeonhole Sort** algorithm to sort the list in non-decreasing order. # Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`: A list of integers with variable size. (1 <= len(arr) <= 10^5) * **Constraints**: * -10^6 <= arr[i] <= 10^6 for all 0 <= i < len(arr). # Output * Return a sorted list in non-decreasing order. # Example Example 1 **Input**: ```python arr = [8, 3, 2, 7, 4] ``` **Output**: ```python [2, 3, 4, 7, 8] ``` Example 2 **Input**: ```python arr = [9, 9, 8, 8, 7] ``` **Output**: ```python [7, 8, 8, 9, 9] ``` # Explanation The Pigeonhole Sort: 1. Determines the range of values (max - min + 1). 2. Creates an array of holes. 3. Distributes elements into these holes based on their value. 4. Collects sorted values from these holes back into the array. # Implementations Notes * Ensure that your implementation handles edge cases effectively, such as an empty array or all elements being the same. * Consider the memory usage of your solution, especially for large input sizes. Begin your implementation below:","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: if not arr: return [] min_value = min(arr) max_value = max(arr) size = max_value - min_value + 1 holes = [0] * size for number in arr: holes[number - min_value] += 1 sorted_arr = [] for i in range(size): while holes[i] > 0: sorted_arr.append(i + min_value) holes[i] -= 1 return sorted_arr"},{"question":"# Primitive Root Finder for Large Prime Moduli **Context**: In public-key cryptography, primitive roots play a crucial role. For a given large prime number `p`, the Diffie-Hellman Key Exchange uses a primitive root modulo `p`. Your task is to write an efficient Python function to find all primitive roots of a given prime number `p`. **Problem Statement**: Given a prime number `p`, you need to write a Python function `primitive_roots(p)` that returns a list of all primitive roots modulo `p`. **Function Signature**: ```python def primitive_roots(p: int) -> List[int]: ``` # Input: * A single integer `p` (a prime number, (2 leq p leq 10^6)). # Output: * A list of integers representing all the primitive roots modulo `p`. **Constraints**: 1. `p` is guaranteed to be a prime number. 2. The output list should be sorted in ascending order. 3. The solution should aim to be as efficient as possible. **Performance Requirements**: Your solution should ideally run in (O(p log p)) time complexity or better. **Example**: ```python assert primitive_roots(7) == [3, 5] assert primitive_roots(11) == [2, 6, 7, 8] ``` **Hints**: 1. Use efficient algorithms for finding orders and checking coprimeness. 2. Leverage properties of prime numbers and their coprimes. 3. Consider utilizing modular arithmetic techniques to optimize your solution.","solution":"def primitive_roots(p): from math import gcd def is_primitive_root(g, p): seen = set() current = 1 for _ in range(1, p): current = (current * g) % p if current in seen: return False seen.add(current) return len(seen) == p - 1 roots = [] for g in range(1, p): if gcd(g, p) == 1 and is_primitive_root(g, p): roots.append(g) return roots # Example usage: print(primitive_roots(7)) # [3, 5] print(primitive_roots(11)) # [2, 6, 7, 8]"},{"question":"# Question Context In geometric calculations, particularly those involving right-angled triangles, the Pythagorean Theorem is often utilized to find the length of one side when the lengths of the other two sides are known. This question focuses on implementing this theorem programmatically. Problem Statement You are to write a function called `find_missing_side` that leverages the Pythagorean theorem to determine the length of the missing side (if it is a valid right-angled triangle). The function will accept three arguments, where the unknown side is denoted by \\"?\\". Function Description ```python def find_missing_side(opposite: float, adjacent: float, hypotenuse: float) -> float: Given lengths of two sides of a right-angled triangle, this function returns the length of the third side. Parameters: opposite (float or str): Length of the opposite side, or \\"?\\" if unknown. adjacent (float or str): Length of the adjacent side, or \\"?\\" if unknown. hypotenuse (float or str): Length of the hypotenuse, or \\"?\\" if unknown. Returns: float: Length of the missing side. Raises: ValueError: If input is invalid or constructs an impossible triangle. ``` Input Format * `opposite`, `adjacent`, and `hypotenuse` can be either positive real numbers (float) or the string \\"?\\" indicating the unknown side length. * Note: Only one side can be unknown. Output Format * Return the length of the missing side as a float. Constraints * The known sides must be positive real numbers. * The function should raise a `ValueError` with an appropriate message for invalid or impossible triangles. Example ```python print(find_missing_side(3, 4, \\"?\\")) # Expected Output: 5.0 print(find_missing_side(\\"?\\", 4, 5)) # Expected Output: 3.0 print(find_missing_side(3, \\"?\\", 5)) # Expected Output: 4.0 print(find_missing_side(3, 4, 5)) # Expected Output: ValueError (because all sides are provided) print(find_missing_side(-3, \\"?\\", 5)) # Expected Output: ValueError (because -3 is invalid) ```","solution":"import math def find_missing_side(opposite, adjacent, hypotenuse): Given lengths of two sides of a right-angled triangle, this function returns the length of the third side. Parameters: opposite (float or str): Length of the opposite side, or \\"?\\" if unknown. adjacent (float or str): Length of the adjacent side, or \\"?\\" if unknown. hypotenuse (float or str): Length of the hypotenuse, or \\"?\\" if unknown. Returns: float: Length of the missing side. Raises: ValueError: If input is invalid or constructs an impossible triangle. sides = [opposite, adjacent, hypotenuse] if sides.count(\\"?\\") != 1: raise ValueError(\\"Exactly one parameter should be \'?\'.\\") try: known_sides = [float(side) for side in sides if side != \\"?\\"] except ValueError: raise ValueError(\\"The known sides should be positive real numbers.\\") if any(side <= 0 for side in known_sides): raise ValueError(\\"Side lengths must be positive.\\") if sides[2] == \\"?\\": # Hypotenuse is unknown opp, adj = known_sides hyp = math.sqrt(opp**2 + adj**2) return hyp elif sides[0] == \\"?\\": # Opposite is unknown adj, hyp = known_sides if hyp <= adj: raise ValueError(\\"The hypotenuse must be longer than the other sides.\\") opp = math.sqrt(hyp**2 - adj**2) return opp elif sides[1] == \\"?\\": # Adjacent is unknown opp, hyp = known_sides if hyp <= opp: raise ValueError(\\"The hypotenuse must be longer than the other sides.\\") adj = math.sqrt(hyp**2 - opp**2) return adj"},{"question":"You are tasked to implement a Markov Chain based sequence generator for a simple text-based predictive system. Given a sequence of words and their transition probabilities, you will implement a function that can generate the next word based on the current word with respect to these probabilities. Task Description: * Implement a function `generate_sequence` which: * Takes a Markov chain dictionary, an initial word, and the number of words to generate. * Returns a list containing the sequence of words. The Markov chain dictionary will use words as states, and each word will map to a dictionary of possible subsequent words with transition probabilities. You need to ensure: 1. If the current word has no transitions, the sequence terminates. 2. The sum of probabilities for the transitions from any word equals 1. Input: * `markov_chain` (dict): A dictionary representing the Markov chain. * `start_word` (str): The initial word to start the generation sequence. * `num_words` (int): Number of words to generate in the sequence. Output: * List of words representing the generated sequence. Example: ```python markov_chain = { \'hello\': {\'world\': 0.5, \'there\': 0.5}, \'world\': {\'hello\': 1.0}, \'there\': {\'world\': 1.0} } start_word = \'hello\' n = 5 sequence = generate_sequence(markov_chain, start_word, n) print(sequence) ``` Possible output: `[\'hello\', \'there\', \'world\', \'hello\', \'there\']` # Additional Constraints: * Assume that the `markov_chain` dictionary is well-formed and the sum of probabilities for each state transitions is 1. * The function should handle cases where the initial state has no outgoing transitions.","solution":"import random def generate_sequence(markov_chain, start_word, num_words): Generate a sequence of words using the provided Markov chain. :param markov_chain: dict, represents the Markov chain :param start_word: str, the initial word to start from :param num_words: int, the number of words to generate in the sequence :return: list of str, the generated sequence of words if num_words <= 0: return [] sequence = [start_word] current_word = start_word for _ in range(num_words - 1): if current_word not in markov_chain or not markov_chain[current_word]: break next_words = list(markov_chain[current_word].keys()) probabilities = list(markov_chain[current_word].values()) current_word = random.choices(next_words, weights=probabilities, k=1)[0] sequence.append(current_word) return sequence"},{"question":"# Coding Assessment You are required to implement a lossless data compression and decompression utility using the Huffman Coding technique. The following methods in the HuffmanCoding class need to be implemented: # Function 1: `encode_file` Write a method `encode_file` to compress the data from an input file and save the encoded data to an output file. ```python @staticmethod def encode_file(file_in_name: str, file_out_name: str): Compresses the input file using Huffman Coding and writes it to the output file. :param file_in_name: Path to the input file. :param file_out_name: Path to the output file. ``` # Function 2: `decode_file` Write a method `decode_file` to decode the compressed data from an encoded file and save it to a specified output file. ```python @staticmethod def decode_file(file_in_name: str, file_out_name: str): Decompresses the encoded file and writes the decompressed data to the output file. :param file_in_name: Path to the encoded file. :param file_out_name: Path to the output file. ``` # Input and Output Format * **Input**: Two file paths, one for the input file to be compressed and one for the output compressed file (for encoding). * **Output**: Compressed data saved to the output file specified. For decoding, the compressed file path and the decompressed output file path. * **Constraints**: Ensure efficient handling of file I/O operations within constraints of memory and proper bit manipulation during compression and decompression. # Your Task Implement the two methods described above. Ensure to handle edge cases such as: * Small files. * Files with repeated characters. * Files with a large number of distinct characters. # Performance Requirement Ensure that the encoding and decoding functions are optimized for both time and space to handle large files efficiently.","solution":"import heapq from collections import defaultdict, Counter import os import pickle class HuffmanCoding: # Builds the Huffman Tree and returns the root and Huffman codes @staticmethod def build_huffman_tree(data): frequency = Counter(data) heap = [[wt, [sym, \\"\\"]] for sym, wt in frequency.items()] heapq.heapify(heap) while len(heap) > 1: lo = heapq.heappop(heap) hi = heapq.heappop(heap) for pair in lo[1:]: pair[1] = \'0\' + pair[1] for pair in hi[1:]: pair[1] = \'1\' + pair[1] heapq.heappush(heap, [lo[0] + hi[0]] + lo[1:] + hi[1:]) huffman_codes = sorted(heapq.heappop(heap)[1:], key=lambda p: (len(p[-1]), p)) huffman_dict = {symbol: code for symbol, code in huffman_codes} return huffman_dict # Encodes data using Huffman Coding @staticmethod def encode_data(data, huffman_dict): encoded_data = \'\'.join(huffman_dict[char] for char in data) return encoded_data # Decodes data using Huffman Tree @staticmethod def decode_data(encoded_data, huffman_dict): reverse_dict = {v: k for k, v in huffman_dict.items()} current_code = \\"\\" decoded_data = [] for bit in encoded_data: current_code += bit if current_code in reverse_dict: decoded_data.append(reverse_dict[current_code]) current_code = \\"\\" return \'\'.join(decoded_data) # Method to compress the file @staticmethod def encode_file(file_in_name: str, file_out_name: str): with open(file_in_name, \'r\') as file: data = file.read() huffman_dict = HuffmanCoding.build_huffman_tree(data) encoded_data = HuffmanCoding.encode_data(data, huffman_dict) padding = 8 - (len(encoded_data) % 8) encoded_data += \'0\' * padding b = bytearray() for i in range(0, len(encoded_data), 8): byte = encoded_data[i:i + 8] b.append(int(byte, 2)) with open(file_out_name, \'wb\') as file: pickle.dump((huffman_dict, b, padding), file) # Method to decompress the file @staticmethod def decode_file(file_in_name: str, file_out_name: str): with open(file_in_name, \'rb\') as file: huffman_dict, b, padding = pickle.load(file) encoded_data = \\"\\" for byte in b: encoded_data += f\\"{byte:08b}\\" encoded_data = encoded_data[:-padding] decoded_data = HuffmanCoding.decode_data(encoded_data, huffman_dict) with open(file_out_name, \'w\') as file: file.write(decoded_data)"},{"question":"# Closest Value in Binary Search Tree Given a non-empty binary search tree (BST) and a target value (which is a floating point), write a function to find the value in the BST that is closest to the target. The function should efficiently traverse the BST, leveraging its properties to directly hone in on the closest value. Requirements * **Function Name**: `closest_value` * **Input**: * `root` - a `TreeNode`, representing the root of the binary search tree. * `target` - a float, the target value for which we need to find the closest node value. * **Output**: An integer, the value in the BST that is closest to the target. Constraints * The BST is non-empty and you are guaranteed to have only one unique value in the BST that is closest to the target. * The tree nodes have integer values. Edge Cases to Consider * The BST contains just one node. * The target value is lower or higher than all node values in the BST. * The target value exactly matches a node value. Performance Requirements Your solution should optimize search time using the properties of BST, aiming for logarithmic complexity for balanced trees. # Scenario Consider a BST representing stock prices on different days, where each node\'s value is the stock price for a day. Given a target price, the function should quickly determine the closest past day\'s stock price. # Example ```python # Example BST (BST nodes are usually defined like this): # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None # Example usage: # Given BST: # 10 # / # 5 15 # / # 2 7 20 root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(2) root.left.right = TreeNode(7) root.right.right = TreeNode(20) target = 13 # Expected output: 15 print(closest_value(root, target)) # Expected 15 ``` # Deliverable Implement the `closest_value` function as described above, ensuring it meets the constraints and efficiently finds the closest value to the target in the BST.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def closest_value(root, target): Finds the value in the BST that is closest to the target. :param root: TreeNode, the root of the binary search tree :param target: float, the target value :return: int, the value in the BST that is closest to the target closest = root.val current_node = root while current_node: if abs(current_node.val - target) < abs(closest - target): closest = current_node.val if target < current_node.val: current_node = current_node.left else: current_node = current_node.right return closest"},{"question":"You are given a dictionary representing a tree structure where each key is a parent node and its associated value is a list of child elements within the tree. The elements within this list could be strings representing further parent nodes or integers representing leaf nodes. Your task is to write a function that traverses this tree structure and prints it in a specific formatted manner. # Function Signature ```python def tree_print(tree: dict) -> None: pass ``` # Input Format * `tree`: A dictionary where each key is a string representing a parent node. The corresponding value is a list containing either strings (representing child nodes) or integers (representing leaves). # Output Format * The function prints the tree structure where each key-value pair is separated by \\" -> \\". If a child node list contains non-string elements, it prints those elements as part of the current line and starts a new line with indentations afterward. # Constraints * The tree dictionary may contain nested structures but will contain at most 10^3 elements. * String values in the tree have a maximum length of 100 characters. # Example Given the tree dictionary as below: ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } ``` The expected output should be: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` # Notes * Focus on minimizing repeated lookups for efficiency. * Ensure proper formatting for correct indentation and line breaks. # Additional Note Handling large tree structures should involve optimizing lookup efficiency and possibly adjusting the recursive strategy to an iterative approach for deeper trees.","solution":"def tree_print(tree: dict) -> None: def print_tree(prefix, elements): current_line = prefix for el in elements: if isinstance(el, int): current_line += f\\" -> {el}\\" print(current_line) current_line = prefix # reset line since it\'s a leaf node printing else: current_line += f\\" -> {el}\\" if elements and not isinstance(elements[-1], int): print(current_line) for key in tree: print_tree(key, tree[key])"},{"question":"# Decoding Nested Encoded Strings Problem Statement You are given an encoded string where parts of the string are repeated according to specified counts with the form `k[encoded_string]`, where `k` is a positive integer and `encoded_string` is a substring to be repeated `k` times. Your task is to decode the string and return its decoded version. The string you receive is guaranteed to be valid, with well-formed brackets and no white spaces except for repeat numbers. Input Format * A single string `s`, where `1 <= len(s) <= 30,000`. Output Format * Return a single string representing the decoded version of the input string. Constraints 1. `s` is a non-empty string that contains only lowercase English letters, digits, and square brackets (`\'[\'` and `\']\'`). 2. `s` is guaranteed to be a valid encoding, i.e., no digits in the original string, no extra white spaces, and properly nested brackets. Examples ```python decode_string(\\"3[a]2[bc]\\") # Returns \\"aaabcbc\\" decode_string(\\"3[a2[c]]\\") # Returns \\"accaccacc\\" decode_string(\\"2[abc]3[cd]ef\\") # Returns \\"abcabccdcdcdef\\" ``` Instructions Implement the function `decode_string(s)`: * `s` (string): the encoded input string. The function should return a string representing the decoded version.","solution":"def decode_string(s): Decodes a nested encoded string as described in the problem statement. Parameters: s (str): The encoded input string Returns: str: The decoded version of the input string stack = [] current_num = 0 current_string = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif char == \']\': last_string, num = stack.pop() current_string = last_string + num * current_string else: current_string += char return current_string"},{"question":"# Linked List Reordering and Verification You are given a singly linked list represented with a `Node` class. Your task is to implement two primary functions: 1. `is_sorted(head)`: This function should check if the linked list is sorted in ascending order. If the list is sorted, the function should return `True`, otherwise `False`. 2. `reorder_list(head)`: This function should reorder the linked list to alternate between the highest remaining and the lowest remaining elements. The reordered list should start with the smallest element. Example Consider the linked list represented with nodes: ``` 1 -> 2 -> 3 -> 4 ``` Calling `is_sorted(head)` should return `True`. For the same list, calling `reorder_list(head)` should return a list like: ``` 1 -> 4 -> 2 -> 3 ``` # Input Every node in the linked list is represented by a `Node` class defined as: ```python class Node: def __init__(self, val=0, next=None): self.val = val self.next = next ``` * `is_sorted(head)` takes the `head` of the linked list. * `reorder_list(head)` takes the `head` of the linked list and returns the `head` of the reordered list. # Output * `is_sorted(head)` should return a boolean value (`True` or `False`). * `reorder_list(head)` should return the reordered linked list. # Constraints * The number of nodes in the list will be in the range `[0, 1000]`. * Each node\'s value will be in the range `[-1000, 1000]`. # Performance * The `is_sorted` function should run in O(n) time complexity. * The `reorder_list` function should run efficiently considering both average and worst-case scenarios. # Additional Notes * Pay attention to edge cases such as an empty list, a list with a single node, and lists where all elements are the same. * You may assume the input linked list is well-formed and properly terminated. Implement these functions in Python.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head): Check if the linked list is sorted in ascending order. current = head while current and current.next: if current.val > current.next.val: return False current = current.next return True def reorder_list(head): Reorder list to alternate between the highest remaining and the lowest remaining elements starting with the lowest element. if not head or not head.next: return head # Convert linked list to array elements = [] current = head while current: elements.append(current.val) current = current.next # Sort the elements elements.sort() # Reorder list using a two-pointer technique i, j = 0, len(elements) - 1 current = Node(elements[i]) new_head = current i += 1 add_low = False while i <= j: if add_low: current.next = Node(elements[i]) i += 1 else: current.next = Node(elements[j]) j -= 1 add_low = not add_low current = current.next return new_head"},{"question":"# Question: Intersection Node in Two Linked Lists You are given two singly-linked lists. Write a function to find the node at which the two lists intersect and return that node. If the two linked lists have no intersection, return `None`. Function Signature: ```python def find_intersection(head1: Node, head2: Node) -> Optional[Node]: ``` Input: - `head1`: The head node of the first linked list. - `head2`: The head node of the second linked list. Output: - Return the node at which the two linked lists intersect, or `None` if they do not intersect. Constraints: - All nodes are instances of the `Node` class, where: ```python class Node: def __init__(self, value: int, next_node: Optional[Node] = None): self.value = value self.next = next_node ``` - The linked lists must be non-cyclical. - The node itself acts as an identifier, not the value it holds. # Examples: Example 1: Given the linked lists: List 1: 1 -> 3 -> 5 7 -> 9 -> 11 / List 2: 2 -> 4 -> 6 - Calling `find_intersection(list1_head, list2_head)` should return the node with value `7`. Example 2: Given the linked lists: List 1: 1 -> 2 List 2: 3 -> 4 - Calling `find_intersection(list1_head, list2_head)` should return `None` since the lists do not intersect. # Notes: - Consider edge cases like empty lists, lists with only one node, and lists that intersect at the very first node. - Aim for a solution with linear time complexity and constant space complexity.","solution":"class Node: def __init__(self, value: int, next_node: \'Node\' = None): self.value = value self.next = next_node def find_intersection(head1: Node, head2: Node) -> \'Node\': This function finds the intersection node between two singly linked lists. if not head1 or not head2: return None # Calculate the lengths of both linked lists def get_length(head: Node) -> int: length = 0 current = head while current: length += 1 current = current.next return length length1 = get_length(head1) length2 = get_length(head2) # Align both lists to the same starting point longer = head1 if length1 > length2 else head2 shorter = head1 if length1 <= length2 else head2 for _ in range(abs(length1 - length2)): longer = longer.next # Traverse both lists together and find the intersection point while longer and shorter: if longer == shorter: return longer longer = longer.next shorter = shorter.next return None"},{"question":"You are given an unsorted array of integers. Your task is to write a Python function that takes this array and returns the sorted array using the Insertion Sort algorithm. Additionally, you need to implement a simulation feature that prints the array at each iteration of the sorting process. # Function Signature ```python def insertion_sort(arr: List[int], simulation: bool=False) -> List[int]: ``` # Input * `arr` (List[int]): A list of integers that needs to be sorted. * `simulation` (bool): A boolean flag. If set to `True`, the function should print the state of the array at each iteration. Default value is `False`. # Output * Returns a sorted list of integers. # Constraints * The input array can contain up to 1000 integers. * Each integer in the array can be between `-10^3` and `10^3`. # Performance Requirements * Your solution should have a time complexity of O(n^2). # Example ```python # Example 1 arr = [5, 2, 9, 1, 5, 6] print(insertion_sort(arr)) # Output: [1, 2, 5, 5, 6, 9] # Example 2 arr = [3, -1, 4, 1, 5] print(insertion_sort(arr, simulation=True)) # Output: # iteration 0: 3 -1 4 1 5 # iteration 1: -1 3 4 1 5 # iteration 2: -1 3 4 1 5 # iteration 3: -1 1 3 4 5 # iteration 4: -1 1 3 4 5 # [ -1, 1, 3, 4, 5] ``` # Notes * Ensure that your function handles an empty array and returns it as is. * Your solution should not modify the original array but should return a new sorted array.","solution":"from typing import List def insertion_sort(arr: List[int], simulation: bool=False) -> List[int]: Sorts the array using the Insertion Sort algorithm. # Create a copy of the array to avoid in-place modifications sorted_array = arr[:] # Perform the Insertion Sort for i in range(1, len(sorted_array)): key = sorted_array[i] j = i - 1 while j >= 0 and key < sorted_array[j]: sorted_array[j + 1] = sorted_array[j] j -= 1 sorted_array[j + 1] = key # Print the state of the array if simulation is True if simulation: print(f\\"iteration {i}: {\' \'.join(map(str, sorted_array))}\\") return sorted_array"},{"question":"# Unique Character Filter Description You are given a task to write a function that processes a string and removes any reoccurring characters, preserving only the first occurrence of each character. The purpose of this function is to clean strings by filtering out repeat characters, which is typical in data preprocessing tasks like preparing textual data for analysis or input validation. Function Signature ```python def unique_filter(string: str) -> str: pass ``` Input * A single string `string` containing ASCII characters. * Constraints: 1 <= len(string) <= 10^6 Output * A string with all reoccurring characters removed, retaining only their first occurrences in the order they appear. Example ```python assert unique_filter(\\"programming\\") == \\"progamin\\" assert unique_filter(\\"aabbcc\\") == \\"abc\\" assert unique_filter(\\"abc\\") == \\"abc\\" assert unique_filter(\\"\\") == \\"\\" ``` Constraints and Performance Requirements * **Time Complexity**: Your algorithm should run in O(n) time, where n is the length of the input string. * **Space Complexity**: Your algorithm should use O(n) additional space. Guidelines 1. Consider edge cases such as empty strings, strings with all unique characters, and strings with all identical characters. 2. Ensure that your algorithm does not exceed the time and space complexity requirements. 3. Optimize string operations by minimizing the use of concatenation within loops.","solution":"def unique_filter(string: str) -> str: Returns a string with only the first occurrence of each character in the order they appear. seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"**String Reversal Coding Challenge** **Objective**: Implement a string reversal function in Python using recursion, iteration, and Pythonic idioms, and analyze their differences. **Problem Statement**: Write three different functions to reverse a given string. You will implement: 1. A recursive approach. 2. An iterative approach using a two-pointer technique. 3. A Pythonic approach leveraging built-in functions. Your functions should be named `reverse_recursive`, `reverse_iterative`, and `reverse_pythonic` respectively. **Input**: - A single string `s` of length between `0` and `1000`, consisting of ASCII characters. **Output**: - All functions should return the reversed string. **Constraints**: - Handle empty or single-character strings gracefully. - No additional memory beyond necessary data structures should be used. - Assume the input string is always valid. **Examples**: 1. Input: `\\"hello\\"` - Output: `\\"olleh\\"` 2. Input: `\\"a\\"` - Output: `\\"a\\"` 3. Input: `\\"\\"` - Output: `\\"\\"` 4. Input: `\\"Python Power\\"` - Output: `\\"rewoP nohtyP\\"` **Function Signatures**: ```python def reverse_recursive(s: str) -> str: pass def reverse_iterative(s: str) -> str: pass def reverse_pythonic(s: str) -> str: pass ``` **Additional Requirements**: - Analyze each method in the context of time complexity and space complexity. - Discuss any edge cases and how your function handles them. - Note: Do not use any existing function or method that directly reverses the string in your implementations, except for the Pythonic method where it\'s encouraged.","solution":"def reverse_recursive(s: str) -> str: Recursively reverses the given string. if len(s) == 0: return s else: return reverse_recursive(s[1:]) + s[0] def reverse_iterative(s: str) -> str: Iteratively reverses the given string using two-pointer technique. s_list = list(s) left, right = 0, len(s_list) - 1 while left < right: s_list[left], s_list[right] = s_list[right], s_list[left] left += 1 right -= 1 return \'\'.join(s_list) def reverse_pythonic(s: str) -> str: Pythonic way to reverse the given string using slicing. return s[::-1]"},{"question":"# Question: Removing Duplicates from a Singly Linked List You are given a singly linked list where each node contains an integer value. Write a function to remove duplicate values from the linked list. There are two parts to the question, one requiring the use of extra space for optimized time complexity, and the other disallowing extra space focusing on minimal space complexity. Part 1 Implement a function `remove_dups_using_set(head: Node) -> None` to remove duplicates from the list using additional data structures. Part 2 Implement a function `remove_dups_without_extra_space(head: Node) -> None` to remove duplicates from the list without using any additional data structures. # Input Format: - The function `remove_dups_using_set` and `remove_dups_without_extra_space` will take the head node of the linked list which is an instance of the class `Node`. # Output Format: - Both functions should modify the list in place and return `None`. # Constraints: - The length of the linked list can be up to 10^6 nodes. - The values in each node are integers and can be negative or positive. # Examples: Example 1 ``` Input: Linked List: 1 -> 2 -> 3 -> 2 -> 1 -> 4 -> 5 Output after remove_dups_using_set: 1 -> 2 -> 3 -> 4 -> 5 Output after remove_dups_without_extra_space: 1 -> 2 -> 3 -> 4 -> 5 ``` Example 2 ``` Input: Linked List: 1 -> 1 -> 1 -> 1 -> 1 Output after remove_dups_using_set: 1 Output after remove_dups_without_extra_space: 1 ``` Example 3 ``` Input: Linked List: 1 -> 2 -> 3 -> 4 -> 5 Output after remove_dups_using_set: 1 -> 2 -> 3 -> 4 -> 5 Output after remove_dups_without_extra_space: 1 -> 2 -> 3 -> 4 -> 5 ``` Develop and test the functions to ensure they handle all edge cases efficiently.","solution":"class Node: def __init__(self, value=None, next=None): self.value = value self.next = next def remove_dups_using_set(head: Node) -> None: if not head: return seen_values = set() current = head seen_values.add(current.value) while current.next: if current.next.value in seen_values: current.next = current.next.next else: seen_values.add(current.next.value) current = current.next def remove_dups_without_extra_space(head: Node) -> None: if not head: return current = head while current: runner = current while runner.next: if runner.next.value == current.value: runner.next = runner.next.next else: runner = runner.next current = current.next def linked_list_to_list(head: Node): node = head result = [] while node: result.append(node.value) node = node.next return result"},{"question":"# Task: Implement a String Reversal Algorithm **Context:** String reversal is a common operation in various applications, such as text processing, data encoding/decoding, and palindromes checking. Four methods (recursive, iterative, pythonic, and ultra-pythonic) can reverse a string in Python. Understanding these methods solidifies your grasp of algorithmic techniques and Pythonic idioms. **Question:** Implement a function `reverse_string(s: str) -> str` that reverses the provided string `s`. You are required to write the iterative version of the string reversal. Your implementation should not rely on slicing, reversed, or other built-in functions that directly perform the reversal. **Input:** * A string `s` with length (0 leq |s| leq 10^5). **Output:** * A reversed string. **Constraints:** * Your implementation must handle the reversal manually via loops. * Consider edge cases such as empty strings and single-character strings. **Performance Requirements:** * Time Complexity: O(n) * Space Complexity: O(n) **Function Signature:** ```python def reverse_string(s: str) -> str: pass ``` **Examples:** ```python # Example 1: # Input: \\"hello\\" # Output: \\"olleh\\" # Example 2: # Input: \\"A\\" # Output: \\"A\\" # Example 3: # Input: \\"\\" # Output: \\"\\" # Example 4: # Input: \\"abcdefghijklmnopqrstuvwxyz\\" # Output: \\"zyxwvutsrqponmlkjihgfedcba\\" ```","solution":"def reverse_string(s: str) -> str: Reverses the provided string using an iterative approach. Args: s (str): The string to be reversed. Returns: str: The reversed string. reversed_str = [] for char in s: reversed_str.insert(0, char) return \'\'.join(reversed_str)"},{"question":"Scenario Suppose you are tasked with storing and retrieving binary tree structures within a high-performance database system. You need to ensure that the structures can be saved and later reconstructed accurately, maintaining the same shape and values. Objective Write functions to serialize and deserialize a binary tree. Ensure that the functions are efficient in both time and space complexity and handle various edge cases properly. Detailed Requirements 1. **Serialization Function**: - **Function Name**: `serialize` - **Input**: `root` (TreeNode) - the root of the binary tree. - **Output**: `str` - a string representation of the tree. 2. **Deserialization Function**: - **Function Name**: `deserialize` - **Input**: `data` (str) - the string representation of the tree. - **Output**: `TreeNode` - the root of the reconstructed binary tree. Constraints - Tree nodes’ values are integers. - Consider the tree could be large. - Efficiently handle null pointers using a marker (e.g., \'#\'). Example ```python class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None # Example Tree: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) # Serialization serialized = serialize(root) print(serialized) # Expected Output: \\"1 2 # # 3 4 # # 5 # #\\" # Deserialization deserialized_root = deserialize(serialized) # Verify by checking the structure and values of deserialized_root ``` Ensure that your solution correctly handles all edge cases and performs efficiently.","solution":"class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root): Encodes a tree to a single string. :param root: TreeNode :return: str def serialize_helper(node): if not node: return \'# \' return str(node.val) + \' \' + serialize_helper(node.left) + serialize_helper(node.right) return serialize_helper(root) def deserialize(data): Decodes your encoded data to tree. :param data: str :return: TreeNode def deserialize_helper(nodes): val = next(nodes) if val == \'#\': return None node = TreeNode(int(val)) node.left = deserialize_helper(nodes) node.right = deserialize_helper(nodes) return node node_iter = iter(data.split()) return deserialize_helper(node_iter)"},{"question":"You are asked to implement a function that calculates the number of ways to choose `r` items from `n` items (`nCr`), optimized for efficiency. # Function Signature ```python def optimized_combination(n: int, r: int) -> int: pass ``` # Requirements 1. **Input**: - `n` (int): The total number of items. - `r` (int): The number of items to choose. - Constraints: `0 <= r <= n <= 1000` 2. **Output**: - Return the value of `nCr` (int). 3. **Considerations**: - Implement the solution efficiently using dynamic programming principles. - Optimize for both time and space complexity. - Handle edge cases properly (e.g., `n == r`, `r == 0`). # Example ```python assert optimized_combination(5, 2) == 10 assert optimized_combination(6, 0) == 1 assert optimized_combination(6, 6) == 1 assert optimized_combination(10, 5) == 252 ``` # Performance Requirements Your solution should have a time complexity no worse than (O(n cdot r)) and should aim for efficient space usage. # Context This problem is fundamental in combinatorial mathematics, particularly useful in scenarios involving probability calculations, game theory, and various optimization problems. Developing an efficient algorithm for computing combinations is crucial for applications requiring large input sizes.","solution":"def optimized_combination(n: int, r: int) -> int: Calculate number of ways to choose r items from n items (nCr) using dynamic programming. :param n: Total number of items. :param r: Number of items to choose. :return: Number of combinations, nCr. if r > n: return 0 if r == 0 or r == n: return 1 # Initialize a list to store calculated values of combinations C = [0] * (r + 1) C[0] = 1 # There is 1 way to choose 0 items from n items # Calculate value of Binomial Coefficient using bottom-up approach for i in range(1, n + 1): # Compute next row of pascal triangle using the previous row # Start from min(i, r) and go to 1 so that we use last value of C[] # These updates ensure that at any time we are only working with current row values for j in range(min(i, r), 0, -1): C[j] = C[j] + C[j-1] return C[r]"},{"question":"# Problem: Find the First Occurrence of a Target in a Sorted Array You are given a sorted array of integers, and you need to find the first occurrence of a given target integer in this array. The array is sorted in increasing order. Use the Binary Search algorithm to achieve this with optimal time complexity. Function Signature ```python def first_occurrence(array: List[int], query: int) -> Optional[int]: pass ``` Input * `array` (List[int]): A list of integers sorted in increasing order. * `query` (int): The target integer to find the first occurrence of. Output * `Optional[int]`: * The index of the first occurrence of the query in the array. * Return `None` if the element is not found. Constraints * The length of the array is in the range [1, 10^5]. * The array contains integers in the range [-10^6, 10^6]. * The `query` integer is in the range [-10^6, 10^6]. Examples ```python # Example 1 array1 = [1, 2, 2, 2, 3, 4, 5] query1 = 2 assert first_occurrence(array1, query1) == 1 # Example 2 array2 = [1, 1, 1, 1, 1] query2 = 1 assert first_occurrence(array2, query2) == 0 # Example 3 array3 = [1, 3, 3, 5, 5, 5, 7] query3 = 4 assert first_occurrence(array3, query3) == None # Example 4 array4 = [10, 20, 30, 40, 50] query4 = 30 assert first_occurrence(array4, query4) == 2 # Example 5 array5 = [-10, -5, 0, 5, 10, 15] query5 = 10 assert first_occurrence(array5, query5) == 4 ``` Notes * Ensure to handle scenarios where the target does not exist in the array. * The solution should maintain O(log n) complexity for efficient performance.","solution":"from typing import List, Optional def first_occurrence(array: List[int], query: int) -> Optional[int]: Find the first occurrence of a query in a sorted array using binary search. Parameters: array (List[int]): A list of sorted integers. query (int): The target integer to find the first occurrence of. Returns: Optional[int]: The index of the first occurrence of query in array, or None if not found. low, high = 0, len(array) - 1 result = None while low <= high: mid = (low + high) // 2 if array[mid] == query: result = mid high = mid - 1 # continue to search in the left half elif array[mid] < query: low = mid + 1 else: high = mid - 1 return result"},{"question":"**Problem Statement**: You are given an unsorted array of integers and a target integer. Write a function `find_last_occurrence` that performs a linear search to find the index of the last occurrence of the target integer in the array. If the target is not found, return -1. # Function Signature: ```python def find_last_occurrence(array: List[int], query: int) -> int: ``` # Input: * `array`: A list of integers where the integer values range from -10^6 to 10^6 and the list length is between 0 and 10^5. * `query`: An integer value ranging from -10^6 to 10^6. # Output: * An integer representing the index of the last occurrence of the `query` in the `array`. If the `query` is not found, return -1. # Constraints: * The algorithm should have a time complexity of O(n). # Example: ```python assert find_last_occurrence([1, 2, 3, 2, 4, 2], 2) == 5 assert find_last_occurrence([4, 5, 6, 7, 5], 5) == 4 assert find_last_occurrence([10, 20, 30, 40], 25) == -1 assert find_last_occurrence([], 3) == -1 assert find_last_occurrence([5, 5, 5, 5, 5, 5], 5) == 5 ``` # Explanation: 1. In the first example, the target `2` appears at indices 1, 3, and 5. The function should return 5. 2. In the second example, the target `5` appears at indices 1 and 4. The function should return 4. 3. In the third example, the target `25` does not appear in the array. The function should return -1. 4. In the fourth example, the array is empty. The function should return -1. 5. In the fifth example, the entire array consists of the target value `5`. The function should return 5. # Solution Requirements: * Ensure your function handles edge cases such as empty arrays and arrays with only one element. * Optimize for readability and maintainability.","solution":"def find_last_occurrence(array, query): This function returns the index of the last occurrence of the target integer in the array. If the target is not found, it returns -1. last_index = -1 for index, value in enumerate(array): if value == query: last_index = index return last_index"},{"question":"You are tasked with implementing a function `binary_pow` that leverages binary exponentiation to compute powers efficiently. Your implementation should support both iterative and recursive approaches. Specifically, you should: 1. Implement an iterative version of binary exponentiation. 2. Implement a recursive version of binary exponentiation. 3. Both implementations should support an optional modulus parameter to compute results modulo a given number. # Function Signature ```python def binary_pow_iterative(a: int, n: int, mod: int = None) -> int: pass def binary_pow_recursive(a: int, n: int, mod: int = None) -> int: pass ``` # Input - `a` - an integer base, (a). - `n` - a non-negative integer exponent, (n). - `mod` (optional) - an integer modulus. If provided, the function should return (a^n mod text{mod}). # Output - An integer representing (a^n). If `mod` is provided, it should return (a^n mod text{mod}). # Constraints - (0 leq a leq 10^9) - (0 leq n leq 10^9) - (1 leq text{mod} leq 10^9) # Requirements - Your implementation must handle large inputs efficiently. - Ensure your code handles the edge case of zero base and zero exponent, returning 1. # Sample Input/Output Iterative 1. **Input**: `binary_pow_iterative(2, 10)` **Output**: `1024` 2. **Input**: `binary_pow_iterative(2, 10, 1000)` **Output**: `24` Recursive 1. **Input**: `binary_pow_recursive(2, 10)` **Output**: `1024` 2. **Input**: `binary_pow_recursive(2, 10, 1000)` **Output**: `24` # Example Usage ```python # Using iterative approach print(binary_pow_iterative(2, 10)) # Output: 1024 print(binary_pow_iterative(2, 10, 1000)) # Output: 24 # Using recursive approach print(binary_pow_recursive(2, 10)) # Output: 1024 print(binary_pow_recursive(2, 10, 1000)) # Output: 24 ```","solution":"def binary_pow_iterative(a: int, n: int, mod: int = None) -> int: result = 1 base = a while n > 0: if n % 2 == 1: # If n is odd, multiply the result by the base result = result * base if mod is None else (result * base) % mod base = base * base if mod is None else (base * base) % mod n //= 2 # Divide n by 2 return result def binary_pow_recursive(a: int, n: int, mod: int = None) -> int: if n == 0: return 1 half = binary_pow_recursive(a, n // 2, mod) half = half * half if mod is None else (half * half) % mod if n % 2 != 0: half = half * a if mod is None else (half * a) % mod return half"},{"question":"# Radix Sort Implementation and Analysis Scenario You are tasked with sorting a list of non-negative integers efficiently for a large-scale data processing system. Given the constraints on execution time, you decide to implement the Radix Sort algorithm, which can offer better performance than traditional comparison sorts for sizable datasets. To ensure the efficiency and correctness of your solution, you need to thoroughly understand and implement the algorithm. Objective Complete the function `radix_sort` that sorts an array of non-negative integers using the radix sort technique. Input - `arr`: A list of non-negative integers (0 <= integer <= 10^9) to be sorted. - `simulation`: A boolean flag to enable or disable printing intermediate steps (default: False). Output - The function should return a sorted list of integers in ascending order. Constraints - The input list may contain up to 10^5 elements. - The maximum value in the list is guaranteed to fit within the integer data type in Python. - The elements of the list are non-negative integers. Examples 1. `radix_sort([170, 45, 75, 90, 802, 24, 2, 66])` should return `[2, 24, 45, 66, 75, 90, 170, 802]`. 2. `radix_sort([78, 56, 89, 234, 12, 789])` should return `[12, 56, 78, 89, 234, 789]`. Instructions 1. Implement the `radix_sort` function based on the provided code snippet. 2. Ensure your solution handles edge cases such as an empty input list. 3. If the `simulation` flag is set to `True`, print each iteration\'s intermediate state. Note - You should not use built-in Python sorting functions. - Aim to optimize for both time and space complexity. Here is the function signature: ```python def radix_sort(arr, simulation=False): # Your code here ``` Test your function thoroughly to validate correctness and performance.","solution":"def counting_sort(arr, exp, simulation): n = len(arr) output = [0] * n count = [0] * 10 # Store count of occurrences in count[] for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 # Change count[i] so that count[i] contains actual position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 # Copy the output array to arr[], so that arr now contains sorted numbers for i in range(n): arr[i] = output[i] if simulation: print(f\\"After sorting with exp={exp}: {arr}\\") def radix_sort(arr, simulation=False): if not arr: return [] # Find the maximum number to know number of digits max1 = max(arr) # Do counting sort based on the exponent - first 1, then 10, then 100, etc. exp = 1 while max1 // exp > 0: counting_sort(arr, exp, simulation) exp *= 10 return arr"},{"question":"**Contextual Scenario**: You are working on a historical data project where you need to convert Roman numeral dates into integer form to ensure compatibility with a modern database system. The database only accepts integer representations of dates. **Task**: Write a function that converts Roman numeral strings into their integer equivalents following standard Roman numeral rules. **Function to Implement**: ```python def roman_to_integer(roman: str) -> int: ``` # Input and Output * **Input**: A single string `roman` representing a Roman numeral. The input is guaranteed to be a valid Roman numeral within the range from 1 to 3999. * **Output**: An integer corresponding to the Roman numeral. # Constraints * Roman numeral characters include \'I\', \'V\', \'X\', \'L\', \'C\', \'D\', and \'M\'. * The Roman numeral will be in uppercase. * The input will not contain any invalid Roman numeral characters or be outside the 1 to 3999 range. # Example ```python assert roman_to_integer(\\"III\\") == 3 assert roman_to_integer(\\"IV\\") == 4 assert roman_to_integer(\\"IX\\") == 9 assert roman_to_integer(\\"LVIII\\") == 58 assert roman_to_integer(\\"MCMXCIV\\") == 1994 ``` # Notes 1. Remember that in Roman numeral subtraction, order matters significantly (e.g., \'IV\' = 4 but \'VI\' = 6). 2. Consider edge cases where the numeral might be composed entirely of additive sequences (e.g., \\"III\\") and those with subtractive sequences (e.g., \\"IX\\").","solution":"def roman_to_integer(roman: str) -> int: Convert a Roman numeral string into an integer. roman_to_int = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(roman): value = roman_to_int[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"# Stuttering a Stack Scenario You are tasked with writing two functions that take a stack as an input and replace every value in the stack with two occurrences of that value. You will use auxiliary storage (another stack or a queue) to achieve this. Function Definitions 1. `def first_stutter(stack) -> list`: * **Description**: Uses an additional stack for auxiliary storage. * **Input**: A list representing a stack, e.g., `stack = [3, 7, 1, 14, 9]`. * **Output**: The modified stack with each value duplicated, e.g., `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]`. * **Constraints**: * Elements in the stack are integers. * The stack input can be empty. 2. `def second_stutter(stack) -> list`: * **Description**: Uses a queue (from `collections.deque`) for auxiliary storage. * **Input**: A list representing a stack, e.g., `stack = [3, 7, 1, 14, 9]`. * **Output**: The modified stack with each value duplicated, e.g., `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]`. * **Constraints**: * Elements in the stack are integers. * The stack input can be empty. Examples ```python # Case 1: Stack with multiple elements stack = [3, 7, 1, 14, 9] print(first_stutter(stack)) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] print(second_stutter(stack)) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] # Case 2: Empty Stack stack = [] print(first_stutter(stack)) # Output: [] print(second_stutter(stack)) # Output: [] # Case 3: Stack with single element stack = [5] print(first_stutter(stack)) # Output: [5, 5] print(second_stutter(stack)) # Output: [5, 5] ```","solution":"def first_stutter(stack): Uses an additional stack for auxiliary storage to duplicate elements. aux_stack = [] while stack: value = stack.pop() aux_stack.append(value) aux_stack.append(value) while aux_stack: stack.append(aux_stack.pop()) return stack from collections import deque def second_stutter(stack): Uses a queue for auxiliary storage to duplicate elements. queue = deque() while stack: value = stack.pop() queue.appendleft(value) queue.appendleft(value) while queue: stack.append(queue.popleft()) return stack # Examples stack = [3, 7, 1, 14, 9] print(first_stutter([3, 7, 1, 14, 9])) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] print(second_stutter([3, 7, 1, 14, 9])) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] print(first_stutter([])) # Output: [] print(second_stutter([])) # Output: [] print(first_stutter([5])) # Output: [5, 5] print(second_stutter([5])) # Output: [5, 5]"},{"question":"# Question: You are tasked with writing a function `fizzbuzz_with_limiter` that incorporates an additional constraint on the result list length. This function will follow the `FizzBuzz` logic but will only return the first `m` elements of the resulting sequence of numbers from 1 to N. # Function Signature: ```python def fizzbuzz_with_limiter(n: int, m: int) -> List[Union[int, str]]: ``` # Input: - `n` (int): The upper bound of the sequence (1 to n). - `m` (int): The number of elements to return from the start of the sequence. # Output: - List of `m` elements consisting of integers and strings (`\'Fizz\'`, `\'Buzz\'`, `\'FizzBuzz\'`). # Constraints: - 1 ≤ `n` ≤ 10^4 - 1 ≤ `m` ≤ n # Example: ```python assert fizzbuzz_with_limiter(15, 10) == [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\'] assert fizzbuzz_with_limiter(10, 5) == [1, 2, \'Fizz\', 4, \'Buzz\'] assert fizzbuzz_with_limiter(5, 5) == [1, 2, \'Fizz\', 4, \'Buzz\'] ``` # Scenario: Consider that you are part of a team developing educational tools for children. You\'re implementing a feature where kids can explore the \'FizzBuzz\' sequence but only display a subset of it to avoid overwhelming the interface. Implement the function following the guidelines above. # Assessment Criteria: 1. Correctness: The function must return the correct `m` elements based on the `FizzBuzz` logic. 2. Efficiency: The function should handle large values of `n` within reasonable time and space limits. 3. Edge Case Handling: The function should work correctly for the edge cases as defined in the constraints.","solution":"from typing import List, Union def fizzbuzz_with_limiter(n: int, m: int) -> List[Union[int, str]]: result = [] for i in range(1, n + 1): if len(result) >= m: break if i % 15 == 0: result.append(\'FizzBuzz\') elif i % 3 == 0: result.append(\'Fizz\') elif i % 5 == 0: result.append(\'Buzz\') else: result.append(i) return result"},{"question":"# Problem: Predictive Text using Markov Chain In this task, you will implement the predictive text algorithm using a Markov Chain, based on the functionality provided in the code snippets. You will write a function that simulates text generation given a dictionary representing the Markov Chain and an initial state. Objective: Given: 1. `chain`: a dictionary where keys are words (states) and values are dictionaries representing the possible next word (state) and its associated probability. 2. `initial_state`: the initial word from which the state transitions will start. 3. `length`: the desired length of the generated text sequence. You are to implement the function `generate_text(chain, initial_state, length)` that generates and returns a list of words forming the sequence. Input: 1. `chain` (dict): A dictionary representing the Markov Chain. 2. `initial_state` (str): The starting word for the sequence. 3. `length` (int): The desired length of the text to be generated. Output: * Returns a list of words (states) representing the generated sequence of the given length. Example: ```python chain = { \'hello\': {\'world\': 0.5, \'there\': 0.5}, \'world\': {\'hello\': 1.0}, \'there\': {\'world\': 1.0} } initial_state = \'hello\' length = 5 generate_text(chain, initial_state, length) # Possible Output: [\'hello\', \'there\', \'world\', \'hello\', \'there\'] ``` Constraints: * `1 <= length <= 1000` * The `chain` dictionary contains valid states and probabilities summing to 1 for each state.","solution":"import random def generate_text(chain, initial_state, length): Generates a sequence of words (states) using the given Markov Chain. :param chain: A dictionary representing the Markov Chain. :param initial_state: The starting word for the sequence. :param length: The desired length of the text to be generated. :return: A list of words representing the generated sequence. if length < 1: return [] sequence = [initial_state] current_state = initial_state for _ in range(length - 1): next_states = chain.get(current_state, {}) if not next_states: break next_state = random.choices(list(next_states.keys()), list(next_states.values()))[0] sequence.append(next_state) current_state = next_state return sequence"},{"question":"Context Imagine you are working on a communication system that needs to send lists of text messages over a network. Because lists of strings can vary greatly in length and format, you need a reliable way to encode these lists into a single string for transmission. This string should then be decoded back to the original list of strings on the receiving end. Task Design and implement two functions: `encode` and `decode`. Your `encode` function should take a list of strings and return a single encoded string. Your `decode` function should take this encoded string and return the original list of strings. Function Signatures ```python def encode(strs: List[str]) -> str: pass def decode(s: str) -> List[str]: pass ``` Input and Output * `encode(strs: List[str]) -> str`: * **Input**: A list of strings (`strs`). `strs` can be empty. * **Output**: A single encoded string representation of the list. * `decode(s: str) -> List[str]`: * **Input**: The encoded string (`s`). * **Output**: The original list of strings (`List[str]`). Constraints and Notes * The encoded format should allow any characters, including colons, to be part of the strings in the list. * Consider performance and efficiency. * Ensure your solution handles edge cases (e.g., an empty list, strings with special characters). Example ```python # Example Use input_list = [\\"hello\\", \\"world\\", \\"!\\", \\"42: is the answer\\"] encoded_string = encode(input_list) print(encoded_string) # Example Output: \\"5:hello5:world1:!18:42: is the answer\\" decoded_list = decode(encoded_string) print(decoded_list) # Output: [\\"hello\\", \\"world\\", \\"!\\", \\"42: is the answer\\"] ```","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings into a single string. encoded_strings = [] for s in strs: length = len(s) encoded_strings.append(f\\"{length}:{s}\\") return \\"\\".join(encoded_strings) def decode(s: str) -> List[str]: Decodes a single string back into a list of strings. strs = [] i = 0 while i < len(s): # Find the position of the separator \':\' sep_index = s.find(\':\', i) length = int(s[i:sep_index]) # Extract the actual string actual_string = s[sep_index + 1: sep_index + 1 + length] strs.append(actual_string) # Move to the start of the next encoded string i = sep_index + 1 + length return strs"},{"question":"# Fibonacci Sequence Variation Scenario You are tasked with developing an efficient algorithm to compute a modified version of the Fibonacci sequence that is defined as follows: - F(0) = x - F(1) = y - For n ≥ 2, F(n) = F(n-1) + F(n-2) Given integers x, y, and n, write a function `fib_modified(x, y, n)` that returns the n-th term of this modified Fibonacci sequence. Your implementation should focus on efficiency. Input - x (0 ≤ x ≤ 10^9) - y (0 ≤ y ≤ 10^9) - n (0 ≤ n ≤ 10^4) Output - The n-th term of the modified Fibonacci sequence. Constraints - 0 ≤ n ≤ 10^4 - The solution should be efficient in both time and space. Example Cases 1. **Input:** x = 0, y = 1, n = 10 **Output:** 55 2. **Input:** x = 2, y = 3, n = 5 **Output:** 21 3. **Input:** x = 5, y = 8, n = 0 **Output:** 5 ```python def fib_modified(x, y, n): assert n >= 0, \\"n must be a non-negative integer\\" if n == 0: return x elif n == 1: return y prev_1, prev_2 = x, y for i in range(2, n + 1): current = prev_1 + prev_2 prev_1, prev_2 = prev_2, current return current # Example function calls # print(fib_modified(0, 1, 10)) # Output: 55 # print(fib_modified(2, 3, 5)) # Output: 21 # print(fib_modified(5, 8, 0)) # Output: 5 ``` Explanation The problem extends the classic Fibonacci sequence by allowing arbitrary initial values x and y and requires the computation of the n-th term with efficiency. The provided solution leverages an iterative approach to ensure the time complexity is O(n) and the space complexity is O(1), making it suitable for large inputs.","solution":"def fib_modified(x, y, n): Calculate the n-th term of a modified Fibonacci sequence. Parameters: x (int): The 0-th term of the sequence. y (int): The 1st term of the sequence. n (int): The term to compute. Returns: int: The n-th term of the modified Fibonacci sequence. if n == 0: return x elif n == 1: return y prev_1, prev_2 = x, y for _ in range(2, n + 1): current = prev_1 + prev_2 prev_1, prev_2 = prev_2, current return current"},{"question":"# Question: Validate Patterns in Text **Context:** You are developing a language parsing program that ensures commands in text files follow specified patterns. Each pattern is defined using characters, where each character represents a unique word in the command. Your task is to implement a function that validates whether a given command string follows the specified pattern. **Task:** Implement a function `validate_pattern(pattern: str, command: str) -> bool` that determines if the command string follows the specified pattern. **Input:** * `pattern`: A string consisting of lowercase letters where each letter represents a unique word. * `command`: A string of space-separated words. **Output:** * Return `True` if the command follows the pattern; otherwise, return `False`. **Constraints:** * The pattern string contains only lowercase letters. * The command string contains only lowercase words separated by a single space. * The length of the pattern will be in the range [1, 1000]. * Command words will be non-empty and their lengths will be in the range [1, 1000]. **Examples:** Example 1: ```plaintext Input: pattern = \\"abba\\", command = \\"dog cat cat dog\\" Output: True ``` Example 2: ```plaintext Input: pattern = \\"abba\\", command = \\"dog cat cat fish\\" Output: False ``` Example 3: ```plaintext Input: pattern = \\"aaaa\\", command = \\"dog cat cat dog\\" Output: False ``` Example 4: ```plaintext Input: pattern = \\"abba\\", command = \\"dog dog dog dog\\" Output: False ``` **Note:** You may assume `pattern` contains only lowercase letters, and `command` contains lowercase words separated by a single space.","solution":"def validate_pattern(pattern: str, command: str) -> bool: Returns True if the command string follows the specified pattern; otherwise, returns False. words = command.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for p_char, word in zip(pattern, words): if p_char in char_to_word: if char_to_word[p_char] != word: return False if word in word_to_char: if word_to_char[word] != p_char: return False char_to_word[p_char] = word word_to_char[word] = p_char return True"},{"question":"You are given an integer array `nums` containing both positive and negative numbers. Your task is to implement a function `max_contiguous_subsequence_sum(nums: List[int]) -> int` that will return the sum of the contiguous subarray with the largest sum within the array. # Input - A list `nums` of integers, where 1 ≤ len(nums) ≤ 10^5 and -10^4 ≤ nums[i] ≤ 10^4. # Output - Return an integer representing the maximum sum of the contiguous subarray. # Constraints - The array will contain at least one number. - Try to optimize the solution to run in O(n) time complexity and O(1) space complexity. # Example ```python # Example 1 nums = [-2, 3, 8, -1, 4] # The maximum sum is for subarray [3, 8, -1, 4], and the answer is 14 # Example 2 nums = [-1, 1, 0] # The maximum sum is for subarray [1], and the answer is 1 # Example 3 nums = [-1, -3, -4] # The maximum sum is for subarray [-1], and the answer is -1 # Example 4 nums = [-2, 3, 8, -12, 8, 4] # The maximum sum is for subarray [8, 4], and the answer is 12 ``` # Function Signature ```python def max_contiguous_subsequence_sum(nums: List[int]) -> int: # Your solution here ```","solution":"from typing import List def max_contiguous_subsequence_sum(nums: List[int]) -> int: Returns the sum of the contiguous subarray with the largest sum. Implements Kadane\'s Algorithm for O(n) time complexity. max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Context You are tasked with implementing a task scheduling system that prioritizes tasks with the earliest deadlines. To achieve this, you will use a min-heap to efficiently manage and retrieve the tasks with the earliest deadlines. # Task Implement a `TaskScheduler` class using a min-heap data structure. Each task has an integer deadline (lower value indicates higher priority) and a description string. # Requirements 1. Implement the `TaskScheduler` class with the following methods: - `add_task(deadline: int, description: str) -> None`: Adds a new task to the scheduler. - `get_next_task() -> str`: Retrieves and removes the task with the earliest deadline. Returns \\"No tasks available\\" if the scheduler is empty. - `peek_next_task() -> str`: Retrieves the task with the earliest deadline without removing it. Returns \\"No tasks available\\" if the scheduler is empty. 2. Ensure that your implementation maintains the min-heap property and handles edge cases appropriately. # Input and Output Formats - **`add_task` method**: Accepts an integer `deadline` and a string `description`. Does not return any value. - **`get_next_task` method**: Returns a string, which is the description of the task with the earliest deadline. If no tasks are available, returns \\"No tasks available\\". - **`peek_next_task` method**: Returns a string, which is the description of the task with the earliest deadline. If no tasks are available, returns \\"No tasks available\\". # Constraints - Deadlines are positive integers. - Task descriptions are non-empty strings with a length of at most 256 characters. - The system should handle up to 10,000 tasks efficiently. # Performance - Ensuring O(log N) time complexity for `add_task` and O(1) for `peek_next_task` is essential. - `get_next_task` should have a time complexity of O(log N). # Example ```python scheduler = TaskScheduler() scheduler.add_task(5, \\"Write report\\") scheduler.add_task(3, \\"Prepare presentation\\") print(scheduler.peek_next_task()) # Output: \\"Prepare presentation\\" print(scheduler.get_next_task()) # Output: \\"Prepare presentation\\" print(scheduler.get_next_task()) # Output: \\"Write report\\" print(scheduler.get_next_task()) # Output: \\"No tasks available\\" ```","solution":"import heapq class TaskScheduler: def __init__(self): self.heap = [] def add_task(self, deadline: int, description: str) -> None: heapq.heappush(self.heap, (deadline, description)) def get_next_task(self) -> str: if not self.heap: return \\"No tasks available\\" return heapq.heappop(self.heap)[1] def peek_next_task(self) -> str: if not self.heap: return \\"No tasks available\\" return self.heap[0][1]"},{"question":"# Bit Manipulation Assessment Question Scenario Company XYZ is developing a software system for embedded devices. You have been tasked with optimizing storage by manipulating individual bits within integers to represent flags efficiently. To ensure your comprehension of bit manipulation, complete the following functions. Task Implement Python functions for basic bit manipulations. These functions will include getting, setting, clearing, and updating bits at specific positions. Your solution should handle any valid 32-bit signed integer and positions within the range [0, 31]. Function Specifications * `def get_bit(num: int, i: int) -> bool:` - **Input**: - `num`: A 32-bit signed integer. - `i`: The bit position (0-indexed) from the least significant bit. - **Output**: - Returns `True` if the bit at position `i` is `1`, `False` otherwise. * `def set_bit(num: int, i: int) -> int:` - **Input**: - `num`: A 32-bit signed integer. - `i`: The bit position (0-indexed). - **Output**: - Returns the integer with the bit at position `i` set to `1`. * `def clear_bit(num: int, i: int) -> int:` - **Input**: - `num`: A 32-bit signed integer. - `i`: The bit position (0-indexed). - **Output**: - Returns the integer with the bit at position `i` cleared (set to `0`). * `def update_bit(num: int, i: int, bit: bool) -> int:` - **Input**: - `num`: A 32-bit signed integer. - `i`: The bit position (0-indexed). - `bit`: `True` to set the bit to `1`, `False` to set it to `0`. - **Output**: - Returns the integer with the bit at position `i` updated to the provided boolean value. Constraints - `num` will always be within the range of 32-bit signed integers (`-2^31` to `2^31 - 1`). - `i` will be an integer in the range `[0, 31]`. - You must handle both positive and negative integers correctly. Examples ```python # Example usage assert get_bit(5, 0) == True # 5 is 101 in binary, bit at position 0 is 1. assert set_bit(5, 1) == 7 # 5 is 101 in binary, setting bit 1 gives 111 which is 7. assert clear_bit(7, 1) == 5 # 7 is 111 in binary, clearing bit 1 gives 101 which is 5. assert update_bit(5, 1, True) == 7 # 5 is 101 in binary, updating bit 1 to 1 gives 111 which is 7. assert update_bit(5, 2, False) == 1 # 5 is 101 in binary, updating bit 2 to 0 gives 001 which is 1. ``` Write your implementation for the above functions.","solution":"def get_bit(num: int, i: int) -> bool: Returns true if the bit at position i is 1, false otherwise. return (num & (1 << i)) != 0 def set_bit(num: int, i: int) -> int: Sets the bit at position i to 1. return num | (1 << i) def clear_bit(num: int, i: int) -> int: Clears the bit at position i (sets to 0). return num & ~(1 << i) def update_bit(num: int, i: int, bit: bool) -> int: Updates the bit at position i to the provided boolean value. value = 1 if bit else 0 mask = ~(1 << i) return (num & mask) | (value << i)"},{"question":"# Encoding and Decoding Strings In this exercise, you will implement two functions, `encode` and `decode`, for encoding a list of strings into a single string for safe transmission over a network, and decoding it back into the original list of strings. Function Signatures ```python def encode(strs: List[str]) -> str: pass def decode(s: str) -> List[str]: pass ``` # Requirements: 1. **Encoding**: - `encode(strs: List[str]) -> str`: Takes a list of strings and returns a single encoded string representation of that list. - Each string in the list should be encoded by prefixing it with its length and a colon (`\\":\\"`) delimiter. - Example: Given `[\\"hello\\", \\"world\\"]`, the result should be `\\"5:hello5:world\\"`. 2. **Decoding**: - `decode(s: str) -> List[str]`: Takes an encoded string and returns the original list of strings. - Example: Given `\\"5:hello5:world\\"`, the result should be `[\\"hello\\", \\"world\\"]`. # Constraints - The input list to `encode` can contain between 0 and 1000 strings. - Each string in the input list can have a maximum length of 1000 characters. - Ensure the encoding and decoding functions handle edge cases effectively, such as empty lists, strings that contain the delimiter `\\":\\"`, and very large lists. # Example ```python print(encode([\\"lint\\",\\"code\\",\\"love\\",\\"you\\"])) # Output: \\"4:lint4:code4:love3:you\\" print(decode(\\"4:lint4:code4:love3:you\\")) # Output: [\\"lint\\", \\"code\\", \\"love\\", \\"you\\"] ``` # Evaluation Criteria - Correctness: Ensure your functions produce the correct encoded and decoded outputs. - Efficiency: Solutions should be optimal with respect to time and space complexity. - Edge Cases: Handle various edge cases effectively and efficiently.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. encoded_string = \\"\\" for s in strs: encoded_string += f\\"{len(s)}:{s}\\" return encoded_string def decode(s: str) -> List[str]: Decodes a single string to a list of strings. decoded_list = [] i = 0 while i < len(s): # Find the length of the current string j = i while s[j] != \':\': j += 1 length = int(s[i:j]) # Extract the string using the length j += 1 # Skip the colon decoded_string = s[j:j + length] decoded_list.append(decoded_string) # Move to the next encoded string portion i = j + length return decoded_list"},{"question":"# Magic Number Check You\'ve been hired by a company that uses a unique form of validation for their product serial numbers. It involves a concept known as \\"Magic Numbers\\". A number is considered a Magic Number if the sum of its digits, repeatedly summed until a single digit is obtained, results in the number 1. Your task is to write a function `is_magic_number(n: int) -> bool` that checks if a given integer `n` is a Magic Number. Function Signature: ```python def is_magic_number(n: int) -> bool: ``` Input: * `n` - an integer, 0 ≤ n ≤ 10^18 Output: * Return `True` if `n` is a Magic Number; otherwise, return `False`. # Constraints * 0 ≤ n ≤ 10^18 * Your function should handle and return the result in a reasonable time (consider the constraints on very large numbers). # Examples ```python assert is_magic_number(50113) == True, \\"Example 1 Failed\\" assert is_magic_number(1234) == True, \\"Example 2 Failed\\" assert is_magic_number(199) == True, \\"Example 3 Failed\\" assert is_magic_number(111) == False, \\"Example 4 Failed\\" assert is_magic_number(0) == False, \\"Example 5 Failed\\" assert is_magic_number(9) == False, \\"Example 6 Failed\\" ``` **Additional Considerations:** - Handle the edge cases where `n` is a single-digit number. - Optimize your solution to be efficient even for the upper limits of the input range. - Ensure your solution is robust and handles all specified constraints effectively.","solution":"def is_magic_number(n: int) -> bool: Check if a given number is a Magic Number. A number is considered a Magic Number if the sum of its digits, repeatedly summed until a single digit is obtained, results in the number 1. :param n: int - input number to be checked :return: bool - True if n is a Magic Number, False otherwise def digit_sum(num): total = 0 while num > 0: total += num % 10 num //= 10 return total while n >= 10: n = digit_sum(n) return n == 1"},{"question":"# Problem: Digit Counter Context: You are developing a tool that processes various numbers and as part of this tool, you need to determine how many digits an integer contains. Create a function that efficiently computes the number of digits in a given integer. Requirements: - Write a function `digit_count(n: int) -> int` that returns the number of digits in the given integer `n`. - The function must handle negative numbers correctly - the sign does not count as a digit. - Ensure the solution is efficiently executed in constant time. - Consider edge cases such as `0` and handle the largest and smallest possible integers within the 32-bit signed integer range. Input: - An integer `n` where `-2^31 <= n <= 2^31 - 1`. Output: - An integer representing the number of digits in `n`. Example: ```python assert digit_count(12345) == 5 assert digit_count(-9876) == 4 assert digit_count(0) == 1 assert digit_count(500) == 3 ```","solution":"def digit_count(n: int) -> int: Returns the number of digits in the given integer n. The sign of the integer does not count as a digit. return len(str(abs(n)))"},{"question":"# Scenario You are working for a combinatorics company that enhances algorithms for computing combinatorial numbers. Your team has developed a recursive approach to compute the binomial coefficient, but you find that as inputs grow very large, the performance degrades due to deep recursion and repeated calculations of the same values. # Objective Write an optimized function to calculate the binomial coefficient using an iterative approach instead of recursion. This will reduce the overhead associated with function calls and provide better performance for large inputs. # Function Signature ```python def iterative_binomial_coefficient(n, k): Calculate the binomial coefficient, C(n, k), using an iterative approach. Args: n (int): Number of elements. k (int): Number of elements to choose. Returns: int: The binomial coefficient C(n, k). Raises: ValueError: If n < k. pass ``` # Input/Output Examples - **Example 1**: ```python iterative_binomial_coefficient(5, 0) # Output: 1 ``` - **Example 2**: ```python iterative_binomial_coefficient(8, 2) # Output: 28 ``` # Constraints - (0 leq k leq n) - The function should handle large values efficiently (`n, k` up to (10^6)). # Performance Requirements Your function should operate efficiently within the given constraints, avoiding deep recursion and utilizing iterative methods to minimize call overhead.","solution":"def iterative_binomial_coefficient(n, k): Calculate the binomial coefficient, C(n, k), using an iterative approach. Args: n (int): Number of elements. k (int): Number of elements to choose. Returns: int: The binomial coefficient C(n, k). Raises: ValueError: If n < k. if k > n: raise ValueError(\\"k cannot be greater than n\\") if k == 0 or k == n: return 1 k = min(k, n - k) # C(n, k) == C(n, n - k) c = 1 for i in range(k): c = c * (n - i) // (i + 1) return c"},{"question":"You are given a function that generates a hailstone sequence starting from a given number `n`. Your task is to modify the function to handle large inputs more efficiently by leveraging memoization. You also need to implement a secondary function that, given an integer `m`, finds the starting number `n` in the range `1` to `m` that produces the longest hailstone sequence. # Task: 1. **Function 1**: Optimize the `hailstone` function using memoization to improve performance. 2. **Function 2**: Implement a new function `longest_hailstone_sequence` that finds the number between `1` to `m` which produces the longest hailstone sequence when starting from that number. # Input: - The input to the `hailstone` function is a single integer `n` (1 ≤ n ≤ 10^5). - The input to the `longest_hailstone_sequence` function is a single integer `m` (1 ≤ m ≤ 10^5). # Output: - The `hailstone` function should return a list representing the hailstone sequence. - The `longest_hailstone_sequence` function should return a tuple: `(n, length)` where `n` is the starting number within the range that produces the longest sequence, and `length` is the length of that sequence. # Constraints: - Ensure that your functions handle the inputs within the provided range efficiently. - You may assume that both input values are always positive integers. # Example: ```python hailstone(10) # Should return [10, 5, 16, 8, 4, 2, 1] longest_hailstone_sequence(10) # Should return (9, 20), since starting at 9 produces a sequence with length 20: [9, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1] ``` # Implementation: ```python def hailstone(n, memo={}): Return the \'hailstone sequence\' from n to 1 with memoization to improve performance. n: The starting point of the hailstone sequence memo: A dictionary to store previously computed sequences if n in memo: return memo[n] original_n = n sequence = [n] while n > 1: if n % 2 != 0: n = 3 * n + 1 else: n = int(n / 2) sequence.append(n) memo[original_n] = sequence return sequence def longest_hailstone_sequence(m): Finds the starting number between 1 to m that produces the longest hailstone sequence. m: The upper limit of the range to check for starting numbers. max_length = 0 best_n = 1 memo = {} for i in range(1, m + 1): seq = hailstone(i, memo) if len(seq) > max_length: max_length = len(seq) best_n = i return best_n, max_length ```","solution":"def hailstone(n, memo={}): Return the \'hailstone sequence\' from n to 1 with memoization to improve performance. n: The starting point of the hailstone sequence memo: A dictionary to store previously computed sequences if n in memo: return memo[n] original_n = n sequence = [] while n != 1: sequence.append(n) if n in memo: sequence.extend(memo[n][1:]) memo[original_n] = sequence return sequence elif n % 2 != 0: n = 3 * n + 1 else: n = n // 2 sequence.append(1) memo[original_n] = sequence return sequence def longest_hailstone_sequence(m): Finds the starting number between 1 to m that produces the longest hailstone sequence. m: The upper limit of the range to check for starting numbers. max_length = 0 best_n = 1 memo = {} for i in range(1, m + 1): seq = hailstone(i, memo) if len(seq) > max_length: max_length = len(seq) best_n = i return best_n, max_length"},{"question":"Context: You work as a software developer for a company that processes series of data transformations on a stack data structure. One of the tasks involves switching successive pairs of stack elements while preserving the order of single elements when there is an odd number of items. Problem Statement: Write a program to switch successive pairs of numbers in a stack. If the stack contains an odd number of items, the last item should remain in its original position. Requirements: * You need to implement the following function: ```python def switch_pairs(stack): This function takes a stack (list) as input and switches successive pairs of numbers in the stack. If the stack has an odd number of values, the value at the top of the stack should not be moved. Args: stack: list of integers representing a stack with the top of the stack at the end of the list. Returns: Modified stack with pairs switched. pass ``` * **Input**: * The input parameter is a list of integers which behaves as a stack where the end of the list is the top of the stack. * You may assume that the number of elements in the stack will not exceed 10^6. * **Output**: * The function should modify the input stack in-place and return the updated stack. * **Constraints**: * You should use O(n) additional space. * You must maintain O(n) time complexity. Examples: 1. **Example 1**: * Input: `[3, 8, 17, 9, 1, 10]` * Output: `[8, 3, 9, 17, 10, 1]` 2. **Example 2**: * Input: `[3, 8, 17, 9, 1]` * Output: `[8, 3, 9, 17, 1]` Note: * Implement the function without using any built-in functions that perform swapping directly. * Consider edge cases carefully, such as when the stack has fewer than two elements.","solution":"def switch_pairs(stack): This function takes a stack (list) as input and switches successive pairs of numbers in the stack. If the stack has an odd number of values, the value at the top of the stack should not be moved. Args: stack: list of integers representing a stack with the top of the stack at the end of the list. Returns: Modified stack with pairs switched. # Iterate over the stack in steps of 2. for i in range(0, len(stack) - 1, 2): # Swap successive pairs stack[i], stack[i + 1] = stack[i + 1], stack[i] return stack"},{"question":"You are given a singly linked list and an integer `k`. Your task is to write a function `kth_to_last(head, k)` that returns the k-th to last node of the list. # Input * `head`: The head node of the singly linked list. * `k`: Integer representing the position from the end (1-based). # Output * Return the k-th to last node. The node\'s value can be accessed using `.val`. # Constraints * The list is non-circular. * The list may contain various types of values stored in nodes. * 1 <= k <= n where n is the number of elements in the list. # Performance Requirements * Your implementation should have a time complexity of O(n) and a space complexity of O(1). # Example ```python class Node(): def __init__(self, val=None): self.val = val self.next = None def print_linked_list(head): string = \\"\\" while head.next: string += head.val + \\" -> \\" head = head.next string += head.val print(string) def kth_to_last(head, k): # Your implementation here def test(): a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g print_linked_list(a1) kth = kth_to_last(a1, 4) assert kth.val == \\"D\\" print(\\"Test passed.\\") test() ``` # Detailed Explanation * We define a `Node` class to create linked list nodes. * The `print_linked_list` function helps to output the list for testing/debugging purposes. * The function `kth_to_last` should be implemented following the optimal two-pointer method discussed in the analysis, ensuring to handle all edge cases. * In the provided `test` function, we create the list, print it, and test for the 4th to last element which should be \\"D\\". You should focus on writing your `kth_to_last` function in a way that is efficient and robust.","solution":"class Node(): def __init__(self, val=None): self.val = val self.next = None def kth_to_last(head, k): Returns the k-th to last node of the singly linked list. p1 = head p2 = head # Move p2 k steps ahead for _ in range(k): if p2 is None: return None p2 = p2.next # Move both pointers until p2 reaches the end while p2: p1 = p1.next p2 = p2.next return p1"},{"question":"# Linked List Cycle Detection **Scenario**: You are a software engineer working on a routing algorithm that needs to identify cyclical routes to optimize the paths. Given a singly linked list, your task is to find the first node where a cycle begins (if any). If there is no cycle, you should return `None`. # Problem Statement Write a function `detect_cycle(head)` that returns the first node of the cycle in a linked list. If there is no cycle, return `None`. # Function Signature ```python def detect_cycle(head: Node) -> Node: pass ``` # Input - `head`: The head node of the singly linked list (of type `Node`). # Output - If the linked list has a cycle, return the node (of type `Node`) where the cycle starts. - If there is no cycle, return `None`. # Constraints - The maximum length of the linked list is (10^5). - Each node in the linked list contains an integer or character value. # Example ```python class Node: def __init__(self, x): self.val = x self.next = None # Example # Create linked list: 3 -> 2 -> 0 -> -4 -> 2 (cycle starts here) head = Node(3) second = Node(2) third = Node(0) fourth = Node(-4) head.next = second second.next = third third.next = fourth fourth.next = second assert detect_cycle(head).val == 2 # The cycle starts at node with value 2 # No cycle example head = Node(1) assert detect_cycle(head) == None ``` # Requirements: - Implement the function using Floyd’s cycle-finding algorithm. - Ensure your function handles the edge cases, such as an empty list or a list with no cycle.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def detect_cycle(head: Node) -> Node: Returns the node where the cycle begins if there is a cycle in the linked list. Otherwise, returns None. if not head or not head.next: return None slow = head fast = head # Detect if there is a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # If there is a cycle, find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow return None"},{"question":"Reversal Algorithm Function Implementation You are given four different implementations of a string reversal algorithm. Each implementation represents a unique approach to the problem. Your objective is to write a new function that combines these methods and performs additional specific validation. # Function Specification Implement a function `validated_reverse(s: str) -> str` that combines two of the provided reversal methods and adds validation to handle specific edge cases. Requirements: 1. **Input Format**: A single string `s` containing characters. 2. **Output Format**: A reversed string based on the following steps: - Validate the input string: - If the string is empty or has only one character, return it as is. - If the string is longer than 1000 characters, raise a `ValueError`. - Reverse the string using a combination of `iterative` and `ultra_pythonic` methods: - First, reverse the string using the `iterative` method. - Then, reverse the resulting string again using the `ultra_pythonic` method. Constraints: - Must handle edge cases as described. - Should maintain efficiency, aiming for O(n) time complexity. Example Usage: ```python try: print(validated_reverse(\\"\\")) # Output: \\"\\" print(validated_reverse(\\"a\\")) # Output: \\"a\\" print(validated_reverse(\\"hello\\")) # Output: \\"hello\\" print(validated_reverse(\\"reverse\\")) # Output: \\"reverse\\" print(validated_reverse(\\"A\\" * 1001)) # Raises ValueError except ValueError as e: print(e) ``` Notes: - Use the provided code snippets for the `iterative` and `ultra_pythonic` methods as part of your implementation. - Properly handle and raise appropriate exceptions where necessary.","solution":"def iterative(s: str) -> str: Reverses a string using an iterative approach. reversed_str = \'\' for char in s: reversed_str = char + reversed_str return reversed_str def ultra_pythonic(s: str) -> str: Reverses a string using Python slicing. return s[::-1] def validated_reverse(s: str) -> str: Validates and reverses the string first using iterative then using ultra_pythonic method. # Validate the input string if len(s) == 0 or len(s) == 1: return s if len(s) > 1000: raise ValueError(\\"String length exceeds maximum allowed limit of 1000 characters\\") # Reverse the string using iterative method reversed_once = iterative(s) # Reverse the resulting string again using ultra_pythonic method reversed_twice = ultra_pythonic(reversed_once) return reversed_twice"},{"question":"You are given an absolute path for a file (Unix-style). Your task is to simplify it to a canonical path without using any external libraries like `os.path`. # Input A single string `path`, representing the absolute Unix-style file path. * Constraints: - The path should be a non-empty string composed of ASCII characters, and it should start with a `/`. - The length of the path will not exceed 3000 characters. # Output Return a simplified canonical path as a single string. # Examples ```python # Example 1 input_path = \\"/home/\\" output_path = \\"/home\\" # Example 2 input_path = \\"/a/./b/../../c/\\" output_path = \\"/c\\" # Example 3 input_path = \\"/../\\" output_path = \\"/\\" # Example 4 input_path = \\"/home//foo/\\" output_path = \\"/home/foo\\" ``` # Instructions - Implement a function `simplify_path(path: str) -> str` to do this task. - Your implementation must handle all possible edge cases and ensure the resulting path is canonical.","solution":"def simplify_path(path: str) -> str: Simplify the given Unix-style file path to a canonical path. # Use a stack to help manage directories stack = [] # Split the path by \'/\' and process each part parts = path.split(\'/\') for part in parts: if part == \'\' or part == \'.\': # Skip empty parts and current directory placeholders continue elif part == \'..\': # Go up one directory unless the stack is empty if stack: stack.pop() else: # Add the directory to the stack stack.append(part) # Join the stack to form the canonical path return \'/\' + \'/\'.join(stack)"},{"question":"# Problem: Custom Counting Sort Implementation You are tasked with implementing a custom variation of the Counting Sort algorithm that can handle both positive and negative integers. Based on the framework provided in the analysis, your goal is to complete a function `custom_counting_sort` that sorts the input array in non-decreasing order. Your implementation must adhere to the principles of Counting Sort and handle edge cases effectively. # Function Signature ```python def custom_counting_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`: A list of integers, both positive and negative. The length of the list is `n` (0 <= n <= 10^6). # Output * A sorted list of integers in non-decreasing order. # Constraints 1. The elements of the array are integers within the range -10^6 to 10^6. 2. Favor linear time sorting in scenarios where the range of input is small relative to the number of elements. # Requirements * Your solution should efficiently handle and sort arrays containing both positive and negative numbers. * Implement the function without using Python\'s built-in sorting functions. # Example ```python assert custom_counting_sort([3, -1, -2, 0, 2, 1, -1]) == [-2, -1, -1, 0, 1, 2, 3] assert custom_counting_sort([]) == [] assert custom_counting_sort([-1, -3, -2, -4, -5]) == [-5, -4, -3, -2, -1] ``` # Notes * Carefully handle the conversion of negative numbers to ensure they are correctly placed in the count array. * Ensure your implementation is optimized for both time and space efficiency.","solution":"from typing import List def custom_counting_sort(arr: List[int]) -> List[int]: if not arr: return [] min_val = min(arr) max_val = max(arr) range_of_elements = max_val - min_val + 1 count = [0] * range_of_elements output = [0] * len(arr) for num in arr: count[num - min_val] += 1 for i in range(1, len(count)): count[i] += count[i - 1] for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"# Task You are given a sorted list of integers with no duplicates. Write a function `summarize_ranges` that processes this list to return a summary of consecutive ranges in the format specified below. # Function Signature ```python def summarize_ranges(array: List[int]) -> List[str]: ``` # Input * `array` - A list of integers sorted in ascending order with no duplicates. # Output * A list of strings, each string representing a range of consecutive integers or a single integer if no consecutive range exists. # Example ```python summarize_ranges([0, 1, 2, 4, 5, 7]) # Returns: [\\"0-2\\", \\"4-5\\", \\"7\\"] summarize_ranges([1, 3, 5, 6, 7, 9]) # Returns: [\\"1\\", \\"3\\", \\"5-7\\", \\"9\\"] ``` # Constraints * The function must have a time complexity of O(n), where n is the number of elements in the list. * The input list will have at most 10^4 elements. * The input list will be provided sorted in ascending order. # Performance Requirements Your implementation should make efficient use of space and time, ensuring that it adheres to the provided constraints. Additionally, be sure to handle edge cases appropriately as described in the analysis. # Additional Context The problem involves creating a human-readable summary of distinct ranges found within the list. This summary can be useful in applications involving data compression, output formatting, or simplifying the visualization of sequence data.","solution":"def summarize_ranges(array): Processes a sorted list of integers and returns a summary of consecutive ranges. Parameters: array (List[int]): A list of sorted integers with no duplicates. Returns: List[str]: A list of strings representing ranges of consecutive integers. if not array: return [] result = [] start = array[0] end = array[0] for num in array[1:]: if num == end + 1: end = num else: if start == end: result.append(f\\"{start}\\") else: result.append(f\\"{start}-{end}\\") start = num end = num if start == end: result.append(f\\"{start}\\") else: result.append(f\\"{start}-{end}\\") return result"},{"question":"# Scenario You are part of a software engineering team working on a system that processes and cleanses data. One of the preprocessing steps involves removing duplicate entries from a data stream that is represented as a linked list. # Task Your task is to implement a function that removes duplicate values from a linked list. You must implement the function without using any additional data structures like sets or arrays to store node values. # Function Signature ```python def remove_duplicates(head: Node) -> Node ``` # Input * A reference to the head of a singly linked list where each node contains a string as its value. # Output * Should return a reference to the head of the modified list with duplicates removed. # Constraints * The linked list can contain up to 10,000 nodes. * Each node value is a string with a maximum length of 20 characters. # Requirements * Do not use additional space for storing elements (sets, arrays). * Aim for a solution with time complexity better than O(N^2) if possible but prioritize space complexity. # Example ```python class Node(): def __init__(self, val=None): self.val = val self.next = None def print_linked_list(head): string = \\"\\" while head: string += head.val if head.next: string += \\" -> \\" head = head.next print(string) # Example linked list a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Removing duplicates remove_duplicates(a1) print_linked_list(a1) # Should output: A -> B -> C -> D -> F -> G ``` You need to provide the implementation for `remove_duplicates` that adheres to the constraints described.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates(head: Node) -> Node: Removes duplicate values from the linked list. if not head: return head current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next return head"},{"question":"# String Pattern Matching Problem with Backtracking You are tasked with implementing a function that determines whether a given string `str` follows a specified pattern. The objective is to find a bijection between letters in the pattern and non-empty substrings in the string such that the entire string is completely matched by the pattern. # Function Signature ```python def pattern_match(pattern: str, string: str) -> bool: ``` # Input - `pattern`: A string consisting of lowercase letters with length `P` (1 <= P <= 15). - `string`: A string consisting of lowercase letters with length `S` (1 <= S <= 50). # Output - `True` if there exists a bijection such that the pattern fully matches the string. - `False` otherwise. # Constraints - Each character in the pattern must map to a unique, non-empty substring of the string. - Each substring corresponding to a pattern character should only be used once. - Both the `pattern` and `string` only contain lowercase English letters. # Example Usage ```python pattern = \\"abab\\" string = \\"redblueredblue\\" assert pattern_match(pattern, string) == True pattern = \\"aaaa\\" string = \\"asdasdasdasd\\" assert pattern_match(pattern, string) == True pattern = \\"aabb\\" string = \\"xyzabcxzyabc\\" assert pattern_match(pattern, string) == False ``` # Explanation 1. For `pattern = \\"abab\\"` and `string = \\"redblueredblue\\"`, we can map \'a\' to \\"red\\" and \'b\' to \\"blue\\" resulting in true. 2. For `pattern = \\"aaaa\\"` and `string = \\"asdasdasdasd\\"`, we can map \'a\' to \\"asd\\" resulting in true. 3. For `pattern = \\"aabb\\"` and `string = \\"xyzabcxzyabc\\"`, there is no way to map \'a\' and \'b\' to unique substrings due to repeated usage, resulting in false. # Detailed Steps 1. Define a helper function or use nested functions to perform recursive backtracking. 2. Use a dictionary to map pattern characters to substrings. 3. For each character in the pattern, attempt to map every possible substring of the remaining string. 4. If a consistent mapping is found for the entire pattern, return `True`; otherwise, return `False`. # Additional Notes Consider edge cases such as single character patterns, entirely different mappings, maps leading to partially matched scenarios, and those that require resetting of mappings.","solution":"def pattern_match(pattern: str, string: str) -> bool: def backtrack(p_idx, s_idx, mapping, used): # If both pattern and string are completely matched if p_idx == len(pattern) and s_idx == len(string): return True # If only one of them is fully traversed if p_idx == len(pattern) or s_idx == len(string): return False pattern_char = pattern[p_idx] # Try every possible substring for each character in the pattern for end in range(s_idx + 1, len(string) + 1): substring = string[s_idx:end] # If the pattern character has not been mapped yet if pattern_char not in mapping: # And the substring is not already used in another mapping if substring not in used: # Create a new mapping and recurse mapping[pattern_char] = substring used.add(substring) if backtrack(p_idx + 1, end, mapping, used): return True # Backtrack del mapping[pattern_char] used.remove(substring) # If pattern character has been mapped already elif mapping[pattern_char] == substring: # Continue with the existing mapping if backtrack(p_idx + 1, end, mapping, used): return True return False return backtrack(0, 0, {}, set())"},{"question":"You are given a directed graph represented by an adjacency matrix where each entry `[i][j]` indicates the capacity of the edge from node `i` to node `j`. Your task is to compute the maximum flow from the source node (node 0) to the sink node (the last node) using the Edmonds-Karp algorithm, which is an implementation of the Ford-Fulkerson method using Breadth-First Search (BFS). # Input * An `n x n` adjacency matrix `graph`, where `n` is the number of vertices in the graph. * Each `graph[i][j]` is an integer representing the capacity of the edge from node `i` to node `j`. A value of `0` indicates no direct edge exists. # Output * An integer `max_flow` representing the maximum flow from the source node (0) to the sink node (n-1). # Constraints * The graph will have at least 2 nodes and at most 100 nodes. * Capacities will be non-negative integers and will not exceed 10^6. # Performance Requirements * Your solution should efficiently handle the complexity of BFS in the context of the Edmonds-Karp algorithm, ensuring optimal performance within the given constraints. # Example ```python graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] print(maximum_flow_bfs(graph)) # Output should be 23 ``` # Implementation Instructions * Implement the `maximum_flow_bfs(adjacency_matrix)` function in Python. * Ensure that your implementation handles all potential edge cases and performs efficiently. # Submission Submit a single Python file containing the `maximum_flow_bfs` function.","solution":"from collections import deque def bfs(capacity, source, sink, parent): visited = [False] * len(capacity) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for ind, val in enumerate(capacity[u]): if visited[ind] == False and val > 0: queue.append(ind) visited[ind] = True parent[ind] = u if ind == sink: return True return False def maximum_flow_bfs(graph): source = 0 sink = len(graph) - 1 parent = [-1] * len(graph) # Array to store path to a node from source max_flow = 0 # There will be no flow initially # Augment the flow while there is a path from source to sink while bfs(graph, source, sink, parent): path_flow = float(\\"Inf\\") s = sink while s != source: path_flow = min(path_flow, graph[parent[s]][s]) s = parent[s] # update residual capacities of the edges and reverse edges along the path v = sink while v != source: u = parent[v] graph[u][v] -= path_flow graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# One Edit Distance Checker Scenario You are developing a text editing software that brings up corrections for user typos. You must implement a function to determine if a word can be converted into another by performing exactly one single edit operation (insert a character, delete a character, or replace a character). Objective Write a function `is_one_edit_away(s: str, t: str) -> bool` that checks if two input strings `s` and `t` are exactly one edit distance apart. Input and Output Formats - **Input**: Two strings `s` and `t` (1 ≤ len(s), len(t) ≤ 10^4; all characters are lowercase English letters). - **Output**: A boolean value `True` if the strings are exactly one edit distance apart, and `False` otherwise. Constraints - You can\'t use any external libraries or built-in functions that perform the check for you. - Your function should handle edge cases like empty strings, strings with a length difference of more than one, and identical strings efficiently. Performance Requirements - Your solution should have a time complexity of O(n), where n is the length of the shorter string. Function Signature ```python def is_one_edit_away(s: str, t: str) -> bool: pass ``` Example ```python # Example 1 s = \\"abc\\" t = \\"ab\\" print(is_one_edit_away(s, t)) # Output: True # Example 2 s = \\"ab\\" t = \\"ab\\" print(is_one_edit_away(s, t)) # Output: False # Example 3 s = \\"abc\\" t = \\"aebc\\" print(is_one_edit_away(s, t)) # Output: False # Example 4 s = \\"abc\\" t = \\"abd\\" print(is_one_edit_away(s, t)) # Output: True ```","solution":"def is_one_edit_away(s: str, t: str) -> bool: Check if strings s and t are exactly one edit distance away. def one_edit_insert(shorter, longer): i, j = 0, 0 while i < len(shorter) and j < len(longer): if shorter[i] != longer[j]: if i != j: return False j += 1 else: i += 1 j += 1 return True if len(s) == len(t): diff_count = sum(1 for x, y in zip(s, t) if x != y) return diff_count == 1 elif len(s) + 1 == len(t): return one_edit_insert(s, t) elif len(s) == len(t) + 1: return one_edit_insert(t, s) else: return False"},{"question":"Rabin-Miller Primality Test Enhancement # Scenario The Rabin-Miller primality test is a widely used algorithm for determining if a number is prime. Although it provides a reliable result, it has a probabilistic component. You are tasked with enhancing this primality test to improve its efficiency and mitigate resource utilization. # Objective Your task is to implement an optimized version of the Rabin-Miller test that balances efficiency and accuracy. The optimized version should include improved handling of modular exponentiation, which is critical for large numbers. # Implementation Details 1. **Function Signature**: ```python def is_prime_optimized(n: int, k: int) -> bool: ``` 2. **Input**: - `n` - The number to test for primality ( ( n geq 2 )). - `k` - The number of iterations to reduce error probability ( ( k geq 1 )). 3. **Output**: - Returns `True` if the number `n` is probably prime. - Returns `False` if the number `n` is composite. # Constraints 1. The solution should handle very large integers (up to 10^18). 2. The implementation must efficiently use memory (i.e., constant space complexity, ( O(1) )). # Performance Requirement 1. Ensure that the optimized function runs within a reasonable time frame for very large inputs and a high number of iterations. # Edge Cases 1. Handle numbers less than 5 with separate conditions. 2. Ensure that randomly chosen bases for testing are within the valid range [2, n-2]. # Example ```python assert is_prime_optimized(561, 5) == False # Carmichael number known to be composite assert is_prime_optimized(101, 5) == True # Prime number ``` # Note - If you can incorporate \\"Exponentiation by Squaring\\" for calculating large powers modulo ( n ), it can significantly enhance performance. - The improvements should aim to reduce any redundant calculations and optimize the primality check iterations.","solution":"import random def is_prime_optimized(n: int, k: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Decompose (n - 1) to (2^r) * d r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 # Function to perform modular exponentiation def modular_pow(base, exponent, mod): result = 1 base = base % mod while exponent > 0: if exponent % 2 == 1: result = (result * base) % mod exponent = exponent >> 1 base = (base * base) % mod return result def miller_rabin_test(a): x = modular_pow(a, d, n) if x == 1 or x == n - 1: return True for _ in range(r - 1): x = modular_pow(x, 2, n) if x == n - 1: return True return False for _ in range(k): a = random.randint(2, n - 2) if not miller_rabin_test(a): return False return True"},{"question":"You are tasked with implementing a self-balancing binary search tree (AVL Tree). Write a function to insert nodes into the AVL Tree and maintain its balance. # Function Signature ```python class AvlTree: def insert(self, key: int) -> None: pass ``` # Requirements 1. The `AvlTree` class should be able to insert integers while maintaining the AVL tree property. 2. Implement a helper method to print the in-order traversal of the tree. 3. Ensure the tree remains balanced by adjusting the tree (using rotations) when the balance factor exceeds permissible limits (-1, 0, 1). # Input * `key` (integer): A single integer to be inserted into the AVL tree. # Output * None (the tree structure is modified in place). # Constraints * `key` will always be a non-negative integer greater than or equal to zero. * There will be no duplicate keys. # Example ```python tree = AvlTree() tree.insert(10) tree.insert(20) tree.insert(30) print(tree.in_order_traverse()) # Output should be [10, 20, 30] in sorted order tree.insert(25) print(tree.in_order_traverse()) # Output should be [10, 20, 25, 30] maintaining AVL properties ``` # Notes * You may want to create additional helper methods (`rotate_left`, `rotate_right`, `update_heights`, `update_balances`) to manage the re-balancing of the tree. * Ensure the in-order traversal method correctly outputs the keys in sorted order.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def insert(self, key: int) -> None: if not self.root: self.root = Node(key) else: self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return Node(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._rotate_right(node) if balance < -1 and key > node.right.key: return self._rotate_left(node) if balance > 1 and key > node.left.key: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1 and key < node.right.key: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def in_order_traverse(self): result = [] self._in_order_traverse(self.root, result) return result def _in_order_traverse(self, node, result): if node: self._in_order_traverse(node.left, result) result.append(node.key) self._in_order_traverse(node.right, result)"},{"question":"# Context You are helping to develop a system that finds important relationships between items in a large dataset. One of the tasks is to efficiently find pairs of numbers in a list that add up to a specific target value, which has various applications from financial transactions to social network analysis. # Task Write a function `two_sum(array, target)` that takes an array of integers and a target value. The function should return a tuple of the indices of the two numbers whose sum is equal to the target value. Assume that there is exactly one solution and that each element can be used only once. # Input * `array`: List of integers (e.g., [2, 7, 11, 15]) * `target`: An integer which is the target sum (e.g., 9) # Output * A tuple indicating the indices of the two numbers whose sum equals the target (e.g., (0, 1)) # Constraints * You may assume that each input would have exactly one solution. * You may not use the same element twice. * Try to achieve a solution with O(n) time complexity. # Examples Example 1: * Input: array = [2, 7, 11, 15], target = 9 * Output: (0, 1) * Explanation: Because `nums[0] + nums[1] = 2 + 7 = 9` Example 2: * Input: array = [3, 2, 4], target = 6 * Output: (1, 2) Example 3: * Input: array = [3, 3], target = 6 * Output: (0, 1) # Notes * The solution should take into account edge cases such as arrays containing negative numbers or large sets of data.","solution":"def two_sum(array, target): Returns a tuple of indices of the two numbers in `array` that add up to `target`. lookup = {} for i, num in enumerate(array): complement = target - num if complement in lookup: return (lookup[complement], i) lookup[num] = i"},{"question":"You are tasked with implementing a function to support regular expression matching with support for `.` and `*`. * `.` matches any single character. * `*` matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Function Signature: ```python def is_match(s: str, p: str) -> bool: ``` Input: * `s`: a string consisting of lowercase letters. * `p`: a string consisting of lowercase letters as well as `.` and `*` metacharacters. Output: * Return `True` if `s` matches the pattern `p` otherwise return `False`. Constraints: * `0 <= len(s) <= 1000` * `0 <= len(p) <= 1000` Examples: ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` Additional Task: Provide a brief explanation of how your solution works, including its time and space complexity.","solution":"def is_match(s: str, p: str) -> bool: Returns True if the string s matches the pattern p. The pattern supports \'.\' which matches any single character and \'*\' which matches zero or more of the preceding element. # DP table where dp[i][j] will be True if s[0:i] matches p[0:j] m, n = len(s), len(p) dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True # empty string and empty pattern are a match # Initialize the DP table for patterns with \'*\' for j in range(2, n + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # `*` can match zero occurrences of the preceding character for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == \'.\': # \'.\' matches any single character dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': # \'*\' matches zero or more of the preceding element dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] if (p[j - 2] == s[i - 1] or p[j - 2] == \'.\') else False) else: # p[j-1] is a regular character dp[i][j] = dp[i - 1][j - 1] if s[i - 1] == p[j - 1] else False return dp[m][n]"},{"question":"1-Sparse Recovery Problem Implement the 1-Sparse Recovery algorithm to determine if a given stream of non-negative number and sign tuples is 1-sparse. The algorithm should recognize if the elements cancel each other out leaving only one distinct number. # Specifications * Function Name: `one_sparse` * **Input**: A list of tuples, where each tuple contains a non-negative integer and a sign (`+` or `-`). * **Output**: An integer if the stream is 1-sparse, otherwise `None`. # Constraints 1. Each number `val` in the tuple is a non-negative integer. 2. Each sign in the tuple is either `\'+\'` or `\'-\'`. 3. The stream contains at most 10^5 elements. 4. Optimize for `O(n)` time complexity and `O(1)` space complexity. # Examples **Example 1**: ```python # Input array = [(4,\'+\'), (2,\'+\'), (2,\'-\'), (4,\'+\'), (3,\'+\'), (3,\'-\')] # Output print(one_sparse(array)) # Output: 4 ``` **Example 2**: ```python # Input array = [(2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\')] # Output print(one_sparse(array)) # Output: 2 ``` **Example 3**: ```python # Input array = [(2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (1,\'+\')] # Output print(one_sparse(array)) # Output: None ``` # Implementation Notes * Handle any edge cases with proper checking. * Optimize bit-level operations to handle large input streams efficiently. * Avoid memory-intensive operations given space constraints.","solution":"def one_sparse(stream): Determine if a given stream of non-negative number and sign tuples is 1-sparse. :param stream: List of tuples, where each tuple contains a non-negative integer and a sign (\'+\' or \'-\'). :return: An integer if the stream is 1-sparse, otherwise None. sum_val = 0 element_count = {} for value, sign in stream: if sign == \'+\': sum_val += value element_count[value] = element_count.get(value, 0) + 1 elif sign == \'-\': sum_val -= value if value in element_count: element_count[value] -= 1 if element_count[value] == 0: del element_count[value] if len(element_count) == 1: return sum(element_count.keys()) else: return None"},{"question":"Cumulative Frequency Queries with Fenwick Tree You are tasked to develop a class that implements a Fenwick Tree to efficiently handle cumulative frequency queries and point updates on an integer array. Your class should support the following operations: 1. **Construction**: Initialize the tree with a given list of integers. 2. **Update**: Update the value at a specific index. 3. **Get Sum**: Retrieve the sum of elements from the start up to a specific index (prefix sum). Function Descriptions: 1. **`__init__(self, frequency: List[int])`**: Initialize the Fenwick Tree with the given list of integers. This will preprocess the array and construct the binary indexed tree. 2. **`update(self, index: int, value: int) -> None`**: Update the value of the array at the given index. 3. **`get_sum(self, index: int) -> int`**: Return the prefix sum of the array up to the given index. Constraints: - The array size ( n leq 10^5 ). - The value ( -10^6 leq arr[i] leq 10^6 ). Example: ```python # Example Usage freq = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3] fenwick_tree = FenwickTree(freq) # Get prefix sum from index 0 to 5 (0-based) print(fenwick_tree.get_sum(5)) # Output: 19 # (sum calculation: 3 + 2 - 1 + 6 + 5 + 4 = 19) # Update value at index 3 to 8 (from 6 to 8) fenwick_tree.update(3, 8) # Get updated prefix sum from index 0 to 5 print(fenwick_tree.get_sum(5)) # Output: 21 # (sum calculation after update: 3 + 2 - 1 + 8 + 5 + 4 = 21) ``` **Note**: 1. Input index for `update` and `get_sum` functions is 0-based. 2. Ensure the construction time complexity is O(n log n), and both `update` and `get_sum` functions work in O(log n) time.","solution":"class FenwickTree: def __init__(self, frequency): self.n = len(frequency) self.tree = [0] * (self.n + 1) self.original_array = [0] * self.n for i in range(self.n): self.update(i, frequency[i]) def update(self, index, value): delta = value - self.original_array[index] self.original_array[index] = value index += 1 # Convert to 1-based index while index <= self.n: self.tree[index] += delta index += index & -index def get_sum(self, index): index += 1 # Convert to 1-based index result = 0 while index > 0: result += self.tree[index] index -= index & -index return result"},{"question":"**Scenario**: You are working on a data analysis tool that helps users understand the most common values in their datasets. One of the core functionalities your tool should provide is the ability to find the mode(s) of an array of numbers. **Task**: Write a function `find_modes(arr)` that, given an array of integers, returns a list of the mode(s) of the array. If there are multiple modes, include all of them in the list. If the input array is empty, the function should return an empty list. # Function Signature ```python def find_modes(arr: List[int]) -> List[int]: pass ``` # Input - `arr`: A list of integers where the length can range from 0 to 10^6. # Output - A list of integers representing the mode(s) of the input array. # Constraints - The array may contain duplicate elements. - The array may be empty. - The integers in the array can range from -10^9 to 10^9. # Example ```python assert find_modes([1, 1, 2, 2, 3, 4]) == [1, 2] assert find_modes([]) == [] assert find_modes([5, 5, 5, 1, 1, 1, 1]) == [1] assert find_modes([4, 5, 6]) == [4, 5, 6] ``` # Notes Your implementation should aim for optimal performance and handle large input sizes effectively.","solution":"from typing import List from collections import Counter def find_modes(arr: List[int]) -> List[int]: if not arr: return [] counts = Counter(arr) max_count = max(counts.values()) modes = [num for num, count in counts.items() if count == max_count] return modes"},{"question":"# Scenario You are tasked with developing a utility function to format a software license key. The software requires that license keys be presented in a specific format, ignoring arbitrary delimiters and ensuring sections of a given length from right to left. # Requirements Write a function `format_license_key(key: str, k: int) -> str` that reformats the input string `key` by: 1. Removing all occurrences of the \'-\' character. 2. Splitting the resultant string into groups of exactly `k` characters, starting from the right. 3. Joining these groups with \'-\' and returning the formatted string. Assume the input string will contain only alphanumeric characters and `-` as special marks. Input and Output Formats * **Input**: * `key`: a string containing alphanumeric characters and `-`. * `k`: an integer indicating the size of groups. * **Output**: * A string representing the reformatted license key. Constraints * `0 <= len(key) <= 10^4` * `1 <= k <= 10^4` Examples ```python format_license_key(\\"2-4A0r7-4k\\", 4) # Returns: \\"24A0-R74K\\" format_license_key(\\"2-4A0r7-4k\\", 3) # Returns: \\"24-A0R-74K\\" format_license_key(\\"--a-a-a-a--\\", 2) # Returns: \\"AA-AA\\" ```","solution":"def format_license_key(key: str, k: int) -> str: Reformats the input string \'key\' by: 1. Removing all occurrences of the \'-\' character. 2. Splitting the resultant string into groups of exactly \'k\' characters, starting from the right. 3. Joining these groups with \'-\' and returning the formatted string. # Remove all hyphens and convert to uppercase cleaned_key = key.replace(\'-\', \'\').upper() # Calculate the length of the first group first_group_length = len(cleaned_key) % k groups = [] # If the first group length is non-zero, add it first if first_group_length > 0: groups.append(cleaned_key[:first_group_length]) # Add subsequent k-length groups for i in range(first_group_length, len(cleaned_key), k): groups.append(cleaned_key[i:i + k]) # Join the groups with \'-\' and return the result return \'-\'.join(groups)"},{"question":"# Zigzag Iterator Implementation **Context**: You have two lists of integers, and you need to create an iterator that alternates between elements of the two lists. Once an element from either list is exhausted, the iterator should proceed with elements from the remaining list. **Function Signature**: ```python class ZigZagIterator: def __init__(self, v1: List[int], v2: List[int]): Initialize the ZigZagIterator with two lists of integers. :param v1: List[int] - First list of integers :param v2: List[int] - Second list of integers pass def next(self) -> int: Fetch the next element in the zigzag order. :return: int - Next integer in the zigzag sequence pass def has_next(self) -> bool: Check if there are any more elements to return. :return: bool - True if there are more elements, False otherwise pass ``` **Input**: - Two lists of integers, `v1` and `v2`. **Output**: - A sequence of integers in a zigzag manner. **Constraints**: * The total number of elements between the two lists is at most 1000. * The input lists are non-negative integers. **Requirements**: - Implement the `ZigZagIterator` class as described. - Your code should efficiently manage allocation and popping of elements. - Handle edge cases, such as one or both lists being empty, gracefully. **Example**: For the input lists: ```python v1 = [1, 2] v2 = [3, 4, 5, 6] ``` The output sequence should be: ``` 1, 3, 2, 4, 5, 6 ``` **Algorithm**: 1. Initialize the iterator with two input lists, `v1` and `v2`. 2. Use a queue to keep track of the lists. 3. Implement the `next()` method to pop the first element from the first list in the queue, append the rest if it\'s not empty. 4. Implement the `has_next()` method to check if there are more elements to iterate over.","solution":"from typing import List class ZigZagIterator: def __init__(self, v1: List[int], v2: List[int]): Initialize the ZigZagIterator with two lists of integers. :param v1: List[int] - First list of integers :param v2: List[int] - Second list of integers self.queue = [(v1, 0), (v2, 0)] def next(self) -> int: Fetch the next element in the zigzag order. :return: int - Next integer in the zigzag sequence if self.has_next(): v, idx = self.queue.pop(0) result = v[idx] if idx + 1 < len(v): self.queue.append((v, idx + 1)) return result else: raise ValueError(\\"No more elements\\") def has_next(self) -> bool: Check if there are any more elements to return. :return: bool - True if there are more elements, False otherwise while self.queue and len(self.queue[0][0]) <= self.queue[0][1]: self.queue.pop(0) return bool(self.queue)"},{"question":"# Task You are required to implement a function that mimics the behavior of the given `stutter` methods, but this time, you are asked to use a different data structure and achieve better performance if possible. Background Consider that you have a stack, and you want to replace each element of the stack with two consecutive occurrences of that element. Your objective is to write a function that takes a stack as input and returns a modified stack with each element replaced by two copies of itself. # Example Suppose the stack initially contains: bottom [3, 7, 1, 14, 9] top After invoking your function, the stack should be: bottom [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] top Requirements: * Use a different data structure and optimize the performance if possible. * Handle edge cases such as empty stacks. Function Signature ```python def optimized_stutter(stack: list[int]) -> list[int]: pass ``` Input * The function takes a single input, `stack`, which is a list of integers representing the stack. Output * The function should return the modified stack as a list of integers. Constraints * All elements in the stack are integers. * You cannot directly use the given `first_stutter` or `second_stutter` code but you can draw inspiration from them.","solution":"def optimized_stutter(stack: list[int]) -> list[int]: This function takes a stack represented as a list of integers and returns a new stack where each element is replaced by two consecutive occurrences of that element. Parameters: stack (list[int]): A list of integers representing the stack. Returns: list[int]: A modified stack with each element replaced by two copies of itself. result = [] for element in stack: result.append(element) result.append(element) return result"},{"question":"# Strongly Connected Components with Kosaraju\'s Algorithm **Context**: You are working on analyzing web pages to understand the relationship and connectivity between them. Each web page and hyperlink can be represented as a vertex and directed edge in a graph, respectively. By identifying strongly connected components, you can determine groups of web pages that are mutually reachable. **Task**: Write a function `find_strongly_connected_components` that takes the number of vertices `V` and the adjacency list `adj` representing a directed graph. The function should return the number of strongly connected components in the graph. **Function Signature**: ```python def find_strongly_connected_components(V: int, adj: List[List[int]]) -> int: ``` **Input**: * `V` - an integer representing the number of vertices. * `adj` - a list of lists, where `adj[i]` contains the list of vertices that vertex `i` has directed edges to. **Output**: * Return an integer representing the number of strongly connected components. **Constraints**: * (1 leq V leq 10^4) **Example**: ```python V = 6 adj = [ [2], # 0 -> 2 [0], # 1 -> 0 [3], # 2 -> 3 [1, 4], # 3 -> 1 and 3 -> 4 [5], # 4 -> 5 [4] # 5 -> 4 ] print(find_strongly_connected_components(V, adj)) # Output should be 2 # Explanation: There are two strongly connected components: # 1st: 0, 1, 2, 3 # 2nd: 4, 5 ``` **Note**: * Your solution should efficiently handle large graphs with up to (10^4) vertices and a similar number of edges.","solution":"from typing import List def find_strongly_connected_components(V: int, adj: List[List[int]]) -> int: # Helper function to perform DFS and fill the stack with vertices based on their finish time def dfs(v: int): visited[v] = True for neighbor in adj[v]: if not visited[neighbor]: dfs(neighbor) stack.append(v) # Helper function to perform DFS on the reversed graph def dfs_on_reversed(v: int): visited[v] = True for neighbor in reversed_adj[v]: if not visited[neighbor]: dfs_on_reversed(neighbor) # Step 1: Perform DFS to get the finishing times of vertices visited = [False] * V stack = [] for i in range(V): if not visited[i]: dfs(i) # Step 2: Create the reversed graph reversed_adj = [[] for _ in range(V)] for v in range(V): for neighbor in adj[v]: reversed_adj[neighbor].append(v) # Step 3: Perform DFS on the reversed graph in the order of finishing times visited = [False] * V scc_count = 0 while stack: v = stack.pop() if not visited[v]: scc_count += 1 dfs_on_reversed(v) return scc_count"},{"question":"# Remove a Bit from an Integer **Scenario**: You are working on a low-level system where you need to compress data by directly manipulating bits in an integer. One of the operations required is to remove a specific bit from an integer. **Task**: Write a function `remove_bit(num, i)` that takes a positive integer `num` and an integer `i`, and returns the new integer after removing the bit at position `i` (0-indexed from the right). # Function Signature ```python def remove_bit(num: int, i: int) -> int: ``` # Input: * `num`: A non-negative integer. * `i`: An integer representing the position of the bit to be removed (0-indexed from the right). # Output: * An integer that is the result of removing the bit at position `i` from `num`. # Constraints: * You can assume `num` is a non-negative integer. * The position `i` will be valid and will not be out of the bound of the binary representation of `num`. # Examples: ```python assert remove_bit(21, 2) == 9 # 21 in binary is 10101, removing the 2nd bit (third from the right) results in 1001, which is 9. assert remove_bit(21, 4) == 5 # 21 in binary is 10101, removing the 4th bit results in 101, which is 5. assert remove_bit(21, 0) == 10 # 21 in binary is 10101, removing the 0th bit results in 1010, which is 10. ``` # Performance Requirements: * The function should operate in constant time - O(1). * The space complexity should also be constant - O(1). **Notes**: Make sure your solution handles edge cases like `num` being zero or very large integers gracefully.","solution":"def remove_bit(num: int, i: int) -> int: Removes the bit at position i (0-indexed from the right) from the binary representation of num. # Create two masks: # 1. Mask for the part before the bit to be removed # 2. Mask for the part after the bit to be removed before = num >> (i + 1) << i after = num & ((1 << i) - 1) # Combine both parts to get the result result = before | after return result"},{"question":"Bit Manipulation Utilities You are required to implement a utility service that performs integer operations via direct bit manipulation. The operations you need to handle include querying, setting, clearing, and updating specific bits in the binary representation of given integers. Requirements: 1. **get_bit(num, i)**: Return the bit (0 or 1) at index `i` of the integer `num`. The least significant bit (LSB) is treated as at index 0. 2. **set_bit(num, i)**: Set the bit at index `i` to 1 and return the resulting integer. 3. **clear_bit(num, i)**: Clear the bit at index `i` (set it to 0) and return the resulting integer. 4. **update_bit(num, i, bit)**: Update the bit at index `i` to `bit` (which can be either 0 or 1) and return the resulting integer. Input: - For `get_bit`, `set_bit`, and `clear_bit`, your function should take two integers: `num` (the integer to manipulate) and `i` (the bit index). - For `update_bit`, your function should take three integers: `num` (the integer to manipulate), `i` (the bit index), and `bit` (the desired bit value, 0 or 1). Output: - Each function should return an integer representing the result of the bit manipulation. Constraints: - `0 <= num <= 2^31 - 1` - `0 <= i < 31` (You can assume the integers are at most 31 bits long for simplicity) - `bit` can only be `0` or `1` Example: ```python print(get_bit(5, 0)) # Output: 1 (binary of 5 is 101, LSB is 1) print(set_bit(5, 1)) # Output: 7 (binary of 5 is 101, setting bit at index 1 gives 111) print(clear_bit(5, 0)) # Output: 4 (binary of 5 is 101, clearing bit at index 0 gives 100) print(update_bit(5, 2, 0)) # Output: 1 (binary of 5 is 101, updating bit at index 2 to 0 gives 001) ``` You need to implement these four functions: ```python def get_bit(num, i): # your code here def set_bit(num, i): # your code here def clear_bit(num, i): # your code here def update_bit(num, i, bit): # your code here ``` Ensure that your functions handle edge cases properly, including bit indices that are at the limits (e.g., 0 and 30).","solution":"def get_bit(num, i): Return the bit (0 or 1) at index i of the integer num. return (num >> i) & 1 def set_bit(num, i): Set the bit at index i to 1 and return the resulting integer. return num | (1 << i) def clear_bit(num, i): Clear the bit at index i (set it to 0) and return the resulting integer. return num & ~(1 << i) def update_bit(num, i, bit): Update the bit at index i to bit (which can be either 0 or 1) and return the resulting integer. mask = ~(1 << i) return (num & mask) | (bit << i)"},{"question":"# Bitonic Sort Implementation You are tasked with implementing the bitonic sort algorithm, which is useful for sorting arrays in parallel processing environments but here we are focused on a non-parallel implementation. Given an array of integers and a boolean indicating the desired order, implement the bitonic sort algorithm. Function Signature ```python def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: ``` # Input * `arr`: A list of integers of length n, where n is a power of 2 (1 ≤ n ≤ 2^10). * `reverse`: A boolean value where `False` indicates sorting in ascending order and `True` indicates sorting in descending order. # Output * Returns the sorted list of integers in `arr` according to the `reverse` flag. # Constraints * The input list `arr` will always have a length that is a power of 2. * You should not use built-in sorting functions from libraries. # Performance Requirements * Your implementation should have a time complexity of O(n * log(n)^2). # Example ```python # Example 1 arr = [3, 7, 2, 5, 6, 1, 4, 8] reverse = False output = bitonic_sort(arr, reverse) print(output) # Output should be [1, 2, 3, 4, 5, 6, 7, 8] # Example 2 arr = [10, 30, 20, 50, 60, 40, 90, 70] reverse = True output = bitonic_sort(arr, reverse) print(output) # Output should be [90, 70, 60, 50, 40, 30, 20, 10] ``` # Notes * Handles arrays where the size is a power of two. * Ensure optimal implementation to meet performance constraints. Create your function below:","solution":"from typing import List def bitonic_merge(arr: List[int], low: int, cnt: int, direction: bool) -> None: if cnt > 1: k = cnt // 2 for i in range(low, low + k): if (direction == (arr[i] > arr[i + k])): arr[i], arr[i + k] = arr[i + k], arr[i] bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort_recursive(arr: List[int], low: int, cnt: int, direction: bool) -> None: if cnt > 1: k = cnt // 2 bitonic_sort_recursive(arr, low, k, True) bitonic_sort_recursive(arr, low + k, k, False) bitonic_merge(arr, low, cnt, direction) def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: Sorts the array using the bitonic sort algorithm. bitonic_sort_recursive(arr, 0, len(arr), not reverse) return arr"},{"question":"# Binary Tree Preorder Traversal You are given a binary tree where each node has an integer value. Your task is to implement functions to return the preorder traversal of its nodes\' values both iteratively and recursively. Function Definitions 1. `def preorder(node: Node) -> List[int]:` * **Input**: A `Node` object representing the root of a binary tree. * **Output**: A list of integers representing the node values in preorder traversal. * **Constraints**: - The input tree can have up to `10000` nodes. - Node values are integers and can be negative. * **Performance Requirements**: - Time: O(n), where n is the number of nodes. - Space: O(h), where h is the height of the tree. 2. `def preorder_rec(node: Node, res: List[int] = None) -> List[int]:` * **Input**: A `Node` object representing the root of a binary tree. * **Output**: A list of integers representing the node values in preorder traversal. * **Constraints**: - The input tree can have up to `10000` nodes. - Node values are integers and can be negative. * **Performance Requirements**: - Time: O(n), where n is the number of nodes. - Space: O(h), where h is the height of the tree. Example Consider a binary tree: ``` 1 / 2 3 / 4 5 6 ``` The preorder traversal of this tree should return `[1, 2, 4, 5, 3, 6]`. Note - You must handle edge cases such as an empty tree (`None`). Write the implementations for both functions to successfully perform the above tasks.","solution":"from typing import List, Optional class Node: def __init__(self, value: int, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.value = value self.left = left self.right = right def preorder(node: Node) -> List[int]: Returns the preorder traversal of a binary tree iteratively. if node is None: return [] stack, result = [node], [] while stack: current = stack.pop() result.append(current.value) if current.right: stack.append(current.right) if current.left: stack.append(current.left) return result def preorder_rec(node: Node, res: List[int] = None) -> List[int]: Returns the preorder traversal of a binary tree recursively. if res is None: res = [] if node: res.append(node.value) preorder_rec(node.left, res) preorder_rec(node.right, res) return res"},{"question":"**Segment Tree Implementation and Usage** You are tasked with implementing and using a segment tree to handle both range queries and point updates efficiently. Your segment tree should be able to handle various types of functions (e.g., sum, maximum). **Requirements**: 1. Implement a SegmentTree class that supports the following operations: - **Initialization**: `__init__(self, arr, function)` * Parameters: * `arr`: List of integers or tuples. * `function`: A commutative function that takes two arguments and returns a value of the same type. - **Update an element**: `update(self, p, v)` * Parameters: * `p`: Index of the element to be updated. * `v`: New value to be set at index `p`. - **Range Query**: `query(self, l, r)` * Parameters: * `l`: Left index of the range (inclusive). * `r`: Right index of the range (inclusive). * Returns the result of applying the function to the range `[l, r]`. **Instructions**: 1. **Initialization**: Create the segment tree using an array and a provided function. 2. **Building the Tree**: Construct the tree in O(N) time. 3. **Updating an Element**: Update the element at a specified index and propagate the change up the tree. 4. **Range Query**: Implement a function that returns the result of the function applied to the range `[l, r]` in O(log N) time. **Example Usage**: ```python # Example 1: Using the maximum function mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(2, 4)) # Output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Output: 6 # Example 2: Using the sum function mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(mytree.query(0, 6)) # Output: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Output: 52 # Example 3: Using a custom tuple function mytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) print(mytree.query(0, 2)) # Output: (9, 13) mytree.update(2, (-1, 2)) print(mytree.query(0, 2)) # Output: (4, 10) ``` **Constraints**: - The array length will be between 1 and 10^5. - Values in the array will be within the range of -10^9 to 10^9. - Combination function will be commutative. **Performance Requirements**: - Your solution should be efficient and handle updates and queries in O(log N) time.","solution":"class SegmentTree: def __init__(self, arr, function): Initializes the segment tree. Parameters: arr (list): List of values. function (callable): A commutative function to combine values. self.n = len(arr) self.func = function self.tree = [None] * (2 * self.n) # Build the segment tree # Insert leaf nodes in the tree array for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, p, value): Updates an element at index `p` with `value`. Parameters: p (int): The index to update. value (any): The new value. p += self.n self.tree[p] = value # Update the segment tree by recalculating the ancestors i = p while i > 1: self.tree[i // 2] = self.func(self.tree[i], self.tree[i ^ 1]) i //= 2 def query(self, l, r): Queries the range [l, r]. Parameters: l (int): Left bound of the range (inclusive). r (int): Right bound of the range (inclusive). Returns: result (any): The result of the function applied to the range [l, r]. l += self.n r += self.n result = None while l <= r: if l % 2 == 1: result = self.tree[l] if result is None else self.func(result, self.tree[l]) l += 1 if r % 2 == 0: result = self.tree[r] if result is None else self.func(result, self.tree[r]) r -= 1 l //= 2 r //= 2 return result"},{"question":"# Cocktail Shaker Sort Implementation Given the description and principles of the Cocktail Shaker Sort algorithm, you are required to implement this sorting algorithm for a given list of integers. **Function Signature**: ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: pass ``` # Input/Output Specifications * **Input**: * A list of integers `arr`, where `1 <= len(arr) <= 1000` and elements of `arr` can be any integer within the range of -10000 to 10000. * **Output**: * A list of integers containing the sorted elements in ascending order. # Constraints * Your implementation should handle the edge cases such as empty arrays or arrays with a single element. * Avoid unnecessary iterations to improve the efficiency of the algorithm. # Example ```python # Example 1 input: [3, 2, 1, 4, 5] output: [1, 2, 3, 4, 5] # Example 2 input: [5, 1, 4, 2, 8, 0, 2] output: [0, 1, 2, 2, 4, 5, 8] ``` # Evaluation Criteria * Correctness of the sorting algorithm. * Handling of edge cases and constraints. * Efficiency in terms of limiting unnecessary iterations. Implement the function `cocktail_shaker_sort` to follow the above specifications: ```python from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Cocktail Shaker Sort implementation n = len(arr) swapped = True while swapped: swapped = False for i in range(1, n): if arr[i - 1] > arr[i]: arr[i - 1], arr[i] = arr[i], arr[i - 1] swapped = True if not swapped: break swapped = False for i in range(n - 1, 0, -1): if arr[i - 1] > arr[i]: arr[i - 1], arr[i] = arr[i], arr[i - 1] swapped = True return arr ```","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Cocktail Shaker Sort implementation if not arr: return arr n = len(arr) swapped = True start = 0 end = n - 1 while swapped: swapped = False for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break swapped = False end -= 1 for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr"}]'),O={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},L={class:"card-container"},F={key:0,class:"empty-state"},z=["disabled"],R={key:0},j={key:1};function Y(r,e,l,p,a,s){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),y(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>a.searchQuery=o),placeholder:"Search..."},null,512),[[_,a.searchQuery]]),a.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>a.searchQuery="")}," ✕ ")):u("",!0)]),t("div",L,[(n(!0),i(b,null,v(s.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),s.displayedPoems.length===0?(n(),i("div",F,' No results found for "'+d(a.searchQuery)+'". ',1)):u("",!0)]),s.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:a.isLoading,onClick:e[2]||(e[2]=(...o)=>s.loadMore&&s.loadMore(...o))},[a.isLoading?(n(),i("span",j,"Loading...")):(n(),i("span",R,"See more"))],8,z)):u("",!0)])}const P=c(O,[["render",Y],["__scopeId","data-v-0f56f152"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/54.md","filePath":"drive/54.md"}'),D={name:"drive/54.md"},U=Object.assign(D,{setup(r){return(e,l)=>(n(),i("div",null,[x(P)]))}});export{M as __pageData,U as default};
