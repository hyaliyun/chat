import{_ as c,o as s,c as n,a as t,m,t as d,C as h,M as g,U as b,f as l,F as y,p as x,e as w,q as v}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function R(i,e,u,_,r,a){return s(),n("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),m(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),m(d(u.poem.solution),1)])])])}const A=c(q,[["render",R],["__scopeId","data-v-3b4e3f1c"]]),S=JSON.parse(`[{"question":"def nth_prime_square(N): Returns the N'th prime square. A prime square is defined as the square of a prime number. >>> nth_prime_square(1) 4 >>> nth_prime_square(2) 9 >>> nth_prime_square(3) 25 >>> nth_prime_square(4) 49 >>> nth_prime_square(5) 121 >>> nth_prime_square(6) 169 >>> nth_prime_square(7) 289 >>> nth_prime_square(8) 361 >>> nth_prime_square(9) 529 >>> nth_prime_square(10) 841","solution":"def nth_prime_square(N): Returns the N'th prime square. A prime square is defined as the square of a prime number. def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True primes = [] i = 2 while len(primes) < N: if is_prime(i): primes.append(i) i += 1 return primes[N - 1] ** 2"},{"question":"def categorize_runner_finish_time(finish_time: int) -> str: Returns the category of the runner based on their finish time in minutes. :param finish_time: int. The finish time in minutes. :return: str. The category of the runner. Categories: - If the finish time is less than 180 minutes: \\"Elite Runner\\" - If the finish time is between 180 (inclusive) and 240 minutes: \\"Competitive Runner\\" - If the finish time is between 240 (inclusive) and 300 minutes: \\"Average Runner\\" - If the finish time is greater than or equal to 300 minutes: \\"Casual Runner\\" >>> categorize_runner_finish_time(179) 'Elite Runner' >>> categorize_runner_finish_time(180) 'Competitive Runner' >>> categorize_runner_finish_time(240) 'Average Runner' >>> categorize_runner_finish_time(300) 'Casual Runner'","solution":"def categorize_runner_finish_time(finish_time): Returns the category of the runner based on their finish time in minutes. :param finish_time: int. The finish time in minutes. :return: str. The category of the runner. if finish_time < 180: return \\"Elite Runner\\" elif 180 <= finish_time < 240: return \\"Competitive Runner\\" elif 240 <= finish_time < 300: return \\"Average Runner\\" else: return \\"Casual Runner\\""},{"question":"def max_profit(prices): Calculate the maximum profit that can be achieved from a single transaction. If no profit is possible, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([2, 4, 1, 7, 5, 8, 3]) == 7","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from a single transaction. If no profit is possible, returns 0. n = len(prices) if n < 2: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"import re def count_unique_words(text: str) -> int: Given a large text document, the function counts the total number of unique words in it. For the purpose of this task, a word is defined as any sequence of characters separated by spaces. Words are case-insensitive, meaning that \\"Hello\\", \\"hello\\", and \\"HELLO\\" are considered the same word. >>> count_unique_words(\\"Hello world! Hello again, world.\\") 3 >>> count_unique_words(\\"This is a Test. This test is simple.\\") 5","solution":"import re def count_unique_words(text): Returns the number of unique words in the given text. Words are case insensitive and any sequence of characters separated by spaces is considered a word. # Convert text to lowercase text = text.lower() # Use regular expression to find all words words = re.findall(r'bw+b', text) # Use a set to store unique words unique_words = set(words) # Return the number of unique words return len(unique_words)"},{"question":"def dungeon_morale(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Determine if the adventurers can maintain their morale for the entire duration of N days. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[int]]]): A list of test cases where each test case is defined as a tuple. The first element of the tuple is N, the number of days. The second element is K, the minimum number of treasures needed each day to keep morale high. The third element is a list of integers representing the treasures collected each day. Returns: List[str]: A list of results for each test case. Each result is either \\"SUCCESS\\" or \\"FAILED X\\" where X is the first day they fail to collect at least K treasures. Examples: >>> dungeon_morale(1, [(3, 10, [12, 15, 13])]) [\\"SUCCESS\\"] >>> dungeon_morale(1, [(3, 10, [12, 9, 11])]) [\\"FAILED 2\\"] >>> dungeon_morale(2, [ (3, 10, [12, 9, 11]), (4, 20, [20, 15, 25, 30]) ]) [\\"FAILED 2\\", \\"FAILED 2\\"]","solution":"def dungeon_morale(T, test_cases): results = [] for i in range(T): N, K = test_cases[i][:2] treasures = test_cases[i][2] failed_day = None for j in range(N): if treasures[j] < K: failed_day = j + 1 break if failed_day: results.append(f\\"FAILED {failed_day}\\") else: results.append(\\"SUCCESS\\") return results"},{"question":"from typing import List def latest_stop_time(work_durations: List[int]) -> int: Finds the latest possible stop time where all workers stop simultaneously by reducing work durations if needed. >>> latest_stop_time([300, 150, 200, 400]) 400 >>> latest_stop_time([100, 200, 300]) 300","solution":"from typing import List def latest_stop_time(work_durations: List[int]) -> int: Finds the latest possible stop time where all workers stop simultaneously by reducing work durations if needed. return max(work_durations)"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string s. If all characters repeat, returns an empty string. >>> first_non_repeating_character(\\"swiss\\") == \\"w\\" >>> first_non_repeating_character(\\"teeter\\") == \\"r\\" >>> first_non_repeating_character(\\"aabbcc\\") == \\"\\"","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If all characters repeat, returns an empty string. from collections import Counter char_count = Counter(s) for char in s: if char_count[char] == 1: return char return \\"\\""},{"question":"def count_explained_words(dictionary: dict, sentences: List[str]) -> List[int]: For each query, determines the total number of words in the query sentence that have corresponding explanations in the dictionary. Args: dictionary: Dictionary mapping words to their explanations. sentences: List of query sentences. Returns: List of integers where each integer is the count of words in the corresponding query sentence that have explanations in the dictionary. Examples: >>> count_explained_words( ... { ... 'apple': 'a fruit', ... 'banana': 'a fruit', ... 'car': 'a vehicle', ... 'tree': 'a plant', ... 'play': 'an activity' ... }, ... ['I have an apple', 'They like to play under the tree', 'This car is red'] ... ) [1, 2, 1] >>> count_explained_words( ... { ... 'apple': 'a fruit', ... 'banana': 'a fruit', ... 'car': 'a vehicle', ... 'tree': 'a plant', ... 'play': 'an activity' ... }, ... ['The dog barks loudly', 'Blue sky and bright sun'] ... ) [0, 0] >>> count_explained_words( ... { ... 'apple': 'a fruit', ... 'banana': 'a fruit', ... 'car': 'a vehicle', ... 'tree': 'a plant', ... 'play': 'an activity' ... }, ... ['I have an apple', ''] ... ) [1, 0] pass # Implement the function here","solution":"def count_explained_words(dictionary, sentences): This function takes a dictionary of words with explanations and a list of sentences. For each sentence, it returns the count of words that have explanations in the dictionary. explained_word_count = [] explained_words_set = set(dictionary.keys()) for sentence in sentences: words = sentence.split() # Split the sentence into words count = sum(1 for word in words if word in explained_words_set) explained_word_count.append(count) return explained_word_count"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Determines if two strings are anagrams of each other. Args: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if the strings are anagrams, False otherwise. >>> are_anagrams(\\"aabbcc\\", \\"aabbcc\\") True >>> are_anagrams(\\"abc\\", \\"cba\\") True >>> are_anagrams(\\"abc\\", \\"abd\\") False >>> are_anagrams(\\"hello\\", \\"olleh\\") True pass def process_test_cases(T: int, test_cases: List[Tuple[str, str]]) -> List[str]: Processes T test cases and returns a list of results indicating if the pairs of strings are anagrams. Args: T (int): The number of test cases. test_cases (List[Tuple[str, str]]): A list of tuples where each tuple contains two strings. Returns: List[str]: A list of results \\"YES\\" or \\"NO\\" for each test case. >>> process_test_cases(3, [(\\"aabbcc\\", \\"aabbcc\\"), (\\"abc\\", \\"cba\\"), (\\"abcd\\", \\"abcd\\")]) ['YES', 'YES', 'YES'] pass","solution":"def are_anagrams(str1, str2): Returns True if str1 and str2 are anagrams, otherwise returns False. return sorted(str1) == sorted(str2) def process_test_cases(T, test_cases): Processes T test cases and returns a list of results indicating if the pairs of strings are anagrams. results = [] for case in test_cases: s1, s2 = case if are_anagrams(s1, s2): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def shortest_palindrome(s: str) -> int: Finds the length of the shortest palindromic substring within a given string \`s\`. >>> shortest_palindrome(\\"amazon\\") 1 >>> shortest_palindrome(\\"racecar\\") 1 >>> shortest_palindrome(\\"level\\") 1 >>> shortest_palindrome(\\"aabbcc\\") 1 >>> shortest_palindrome(\\"abcdcba\\") 7 >>> shortest_palindrome(\\"abcdefg\\") 1 >>> shortest_palindrome(\\"a\\") 1","solution":"def shortest_palindrome(s): Finds the length of the shortest palindromic substring within a given string \`s\`. n = len(s) # A one character string is always a palindrome if n == 1: return 1 # Each individual character is a palindrome of length 1 return 1"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: You are given a grid of dimensions \`n x m\` consisting of cells filled with either \`0\` or \`1\`. The grid represents a binary matrix, where \`1\` indicates an obstacle, and \`0\` indicates a free space. Your goal is to determine the length of the shortest path from the top-left corner (at position (1, 1)) to the bottom-right corner (at position (n, m)) without moving diagonally and without passing through obstacles. If it's impossible to reach the bottom-right corner from the top-left corner, return \`-1\`. Input: - grid: List of List of integers representing the binary matrix Output: - Single integer representing the length of the shortest path Examples: >>> shortest_path([[0, 1, 0], [0, 0, 0], [0, 1, 0]]) 4 >>> shortest_path([[0, 1, 1], [1, 0, 0], [0, 1, 0]]) -1 >>> shortest_path([[0]]) 0","solution":"from collections import deque def shortest_path(grid): # Directions for up, down, left, right movements directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] n = len(grid) m = len(grid[0]) # If the start or end points are obstacles, return -1 if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def calculate_min_cost(*args): Calculate the minimum total cost to buy the required ingredients in exact quantities. Parameters: *args: A variable number of input parameters representing the items, required quantities, available items, available quantities, and prices. Returns: int: The minimum total cost or -1 if any item is not available in the exact required quantity. >>> calculate_min_cost(2, \\"burger\\", 3, \\"burger\\", 3, 10, \\"meat\\", 4, \\"meat\\", 4, 50) 60 >>> calculate_min_cost(2, \\"burger\\", 3, \\"burger\\", 2, 10, \\"meat\\", 4, \\"meat\\", 4, 50) -1 >>> calculate_min_cost(1, \\"burger\\", 3, \\"bun\\", 3, 10) -1 >>> calculate_min_cost(3, \\"salad\\", 1, \\"lettuce\\", 2, 5, \\"tomato\\", 2, \\"tomato\\", 3, 3, \\"dressing\\", 1, \\"dressing\\", 3, 2) -1 >>> calculate_min_cost(3, \\"salad\\", 1, \\"salad\\", 1, 5, \\"tomato\\", 2, \\"tomato\\", 2, 3, \\"dressing\\", 1, \\"dressing\\", 1, 2) 10","solution":"def calculate_min_cost(*args): Calculate the minimum total cost to buy the required ingredients in exact quantities. Parameters: *args: A variable number of input parameters representing the items, required quantities, available items, available quantities, and prices. Returns: int: The minimum total cost or -1 if any item is not available in the exact required quantity. N = args[0] items = args[1:] total_cost = 0 for i in range(N): required_item, required_quantity = items[i*5], int(items[i*5+1]) available_item, available_quantity, price = items[i*5+2], int(items[i*5+3]), int(items[i*5+4]) if required_item == available_item and required_quantity == available_quantity: total_cost += price else: return -1 return total_cost"},{"question":"def longest_unique_substring(s): Finds the length of the longest substring without repeating characters. :param s: The input string :return: Length of the longest substring without repeating characters Examples: >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 from solution import longest_unique_substring def test_example_cases(): assert longest_unique_substring(\\"abcabcbb\\") == 3 assert longest_unique_substring(\\"bbbbb\\") == 1 assert longest_unique_substring(\\"pwwkew\\") == 3 def test_empty_string(): assert longest_unique_substring(\\"\\") == 0 def test_single_character_string(): assert longest_unique_substring(\\"a\\") == 1 def test_all_unique_characters(): assert longest_unique_substring(\\"abcdef\\") == 6 def test_repeating_pattern_string(): assert longest_unique_substring(\\"abccba\\") == 3 def test_string_with_special_characters(): assert longest_unique_substring(\\"a!b@c#d\\") == 8 assert longest_unique_substring(\\"!@!c#cd\\") == 4 def test_long_mixed_string(): assert longest_unique_substring(\\"abrkaabcdefghijjxxx\\") == 10","solution":"def longest_unique_substring(s): Finds the length of the longest substring without repeating characters. :param s: The input string :return: Length of the longest substring without repeating characters char_index = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"def top_performing_product(N, scores, Q, queries): Determines the top-performing product for each query. Args: N: Number of products. scores: Initial scores of the products. Q: Number of queries. queries: List of queries. Each query is either in the format [1, i, r] to add a rating r to the i-th product or [2] to identify the product with the highest score. Returns: List of 1-based index of the product with the highest score for each query of type 2. >>> top_performing_product( >>> 5, >>> [10, 20, 30, 40, 50], >>> 6, >>> [ >>> [1, 3, 10], >>> [1, 5, 20], >>> [2], >>> [1, 1, 5], >>> [2], >>> [1, 5, 5], >>> [2] >>> ] >>> ) == [5, 5, 5]","solution":"def top_performing_product(N, scores, Q, queries): results = [] for query in queries: if query[0] == 1: i = query[1] - 1 r = query[2] scores[i] += r elif query[0] == 2: max_score = max(scores) best_product = scores.index(max_score) + 1 results.append(best_product) return results"},{"question":"def num_decodings(s: str) -> int: Calculate the number of ways to decode the message given encoded by the defined method. :param s: string representing the encoded message :return: integer number of decoding ways >>> num_decodings(\\"12\\") 2 >>> num_decodings(\\"226\\") 3 >>> num_decodings(\\"0\\") 0 >>> num_decodings(\\"1\\") 1 >>> num_decodings(\\"9\\") 1 >>> num_decodings(\\"11106\\") 2 >>> num_decodings(\\"301\\") 0","solution":"def num_decodings(s): Calculate the number of ways to decode the message given encoded by the defined method. :param s: string representing the encoded message :return: integer number of decoding ways if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): if 1 <= int(s[i-1:i]) <= 9: dp[i] += dp[i-1] if 10 <= int(s[i-2:i]) <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"def max_non_overlapping_sessions(n, sessions): Returns the maximum number of non-overlapping sessions that can be attended. Parameters: n (int): Number of sessions. sessions (list of tuples): Each tuple contains two integers, start and end time of a session. Returns: int: Maximum number of non-overlapping sessions. >>> max_non_overlapping_sessions(3, [(1, 3), (2, 4), (3, 5)]) 2 >>> max_non_overlapping_sessions(1, [(1, 2)]) 1 >>> max_non_overlapping_sessions(4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> max_non_overlapping_sessions(3, [(1, 3), (3, 4), (2, 5)]) 2 >>> max_non_overlapping_sessions(5, [(1, 4), (2, 3), (3, 5), (0, 6), (5, 7)]) 3","solution":"def max_non_overlapping_sessions(n, sessions): Returns the maximum number of non-overlapping sessions that can be attended. Parameters: n (int): Number of sessions. sessions (list of tuples): Each tuple contains two integers, start and end time of a session. Returns: int: Maximum number of non-overlapping sessions. # Sort sessions by end times sessions.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in sessions: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def largest_island(grid: List[List[int]]) -> int: Determines the size of the largest island in a grid. An island is composed of adjacent lands (cells with 1) connected horizontally or vertically. The size of an island is the number of cells it contains. >>> largest_island([ ... [1, 1, 0, 0, 0, 0], ... [0, 1, 0, 0, 1, 1], ... [0, 0, 0, 1, 1, 1], ... [0, 0, 0, 0, 0, 0], ... [0, 0, 1, 1, 1, 0], ... [0, 0, 1, 0, 0, 0] ... ]) == 5 >>> largest_island([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) == 1 >>> largest_island([ ... [1, 1, 1, 1], ... [1, 0, 0, 1], ... [1, 1, 1, 1], ... [0, 0, 0, 0] ... ]) == 10 >>> largest_island([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> largest_island([ ... [1] ... ]) == 1 >>> largest_island([ ... [0] ... ]) == 0 >>> largest_island([ ... [1, 1], ... [1, 1] ... ]) == 4 >>> largest_island([ ... [0, 1], ... [1, 0] ... ]) == 1 >>> largest_island([ ... [1, 0], ... [0, 1] ... ]) == 1 >>> largest_island([ ... [1, 1], ... [0, 1] ... ]) == 3 >>> largest_island([ ... [1, 0], ... [1, 1] ... ]) == 3","solution":"def largest_island(grid): n = len(grid) m = len(grid[0]) def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark the cell as visited size = 1 size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size max_island_size = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: max_island_size = max(max_island_size, dfs(i, j)) return max_island_size"},{"question":"def min_instructions(startID, targetID): Returns the minimum number of instructions needed to turn startID into targetID using only \\"increment\\" (+1) and \\"decrement\\" (-1) commands. >>> min_instructions(3, 10) 7 >>> min_instructions(10, 3) 7 >>> min_instructions(5, 5) 0 >>> min_instructions(-1, 1) 2 def process_test_cases(test_cases): Process multiple test cases and return the results for each one. >>> test_cases = [(3, 10), (10, 3), (5, 5), (-1, 1), (-10, 5), (10, -10)] >>> process_test_cases(test_cases) [7, 7, 0, 2, 15, 20]","solution":"def min_instructions(startID, targetID): Returns the minimum number of instructions needed to turn startID into targetID using only \\"increment\\" (+1) and \\"decrement\\" (-1) commands. return abs(targetID - startID) def process_test_cases(test_cases): results = [] for startID, targetID in test_cases: results.append(min_instructions(startID, targetID)) return results # Example usage: # test_cases = [(3, 10), (10, 3), (5, 5), ( -1, 1)] # print(process_test_cases(test_cases))"},{"question":"def smallest_missing_positive_integer(arr): Determine the smallest positive integer that is missing from the array. >>> smallest_missing_positive_integer([1, 2, 0]) 3 >>> smallest_missing_positive_integer([3, 4, -1, 1]) 2 >>> smallest_missing_positive_integer([7, 8, 9, 11, 12]) 1 >>> smallest_missing_positive_integer([1]) 2 def process_input(input_str): Process input to find the smallest missing positive integer for multiple test cases. >>> input_str = \\"4n3n1 2 0n4n3 4 -1 1n5n7 8 9 11 12n1n1\\" >>> process_input(input_str) [3, 2, 1, 2]","solution":"def smallest_missing_positive_integer(arr): Function to find the smallest missing positive integer from the given array. s = set(arr) i = 1 while i in s: i += 1 return i def find_missing_in_test_cases(test_cases): result = [] for case in test_cases: result.append(smallest_missing_positive_integer(case)) return result def process_input(input_str): lines = input_str.strip().split('n') t = int(lines[0]) test_cases = [] i = 1 for _ in range(t): n = int(lines[i]) arr = list(map(int, lines[i+1].split())) test_cases.append(arr) i += 2 return find_missing_in_test_cases(test_cases)"},{"question":"def min_total_time(N: int, M: int, S: int, D: List[List[int]], T: List[List[int]]) -> int: Calculate the minimum total time required for a participant to complete the contest by solving at least one challenge per round. >>> min_total_time(3, 3, 5, [[1, 6, 3], [7, 8, 2], [4, 3, 1]], [[2, 9, 6], [3, 5, 4], [5, 2, 8]]) == 8 >>> min_total_time(2, 2, 1, [[2, 3], [4, 5]], [[2, 3], [4, 5]]) == -1 >>> min_total_time(2, 2, 10, [[1, 2], [3, 4]], [[1, 2], [3, 4]]) == 4 >>> min_total_time(1, 3, 5, [[1, 2, 3]], [[5, 2, 1]]) == 1 >>> min_total_time(2, 2, 5, [[1, 6], [2, 3]], [[2, 2], [2, 2]]) == 4","solution":"def min_total_time(N, M, S, D, T): min_time = 0 for i in range(N): min_challenge_time = float('inf') solveable = False for j in range(M): if S >= D[i][j]: solveable = True min_challenge_time = min(min_challenge_time, T[i][j]) if not solveable: return -1 min_time += min_challenge_time return min_time"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string s, finds the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3","solution":"def length_of_longest_substring(s): Given a string s, finds the length of the longest substring without repeating characters. n = len(s) char_index_map = {} max_length = 0 start = 0 for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def create_beautiful_array(n: int) -> list[int] or int: Creates a beautiful array if possible. A beautiful array is an array where no two adjacent elements are coprime. :param n: Length of the array :type n: int :return: A beautiful array or -1 if not possible :rtype: list[int] or int >>> create_beautiful_array(4) [2, 4, 2, 4] >>> create_beautiful_array(5) -1","solution":"def create_beautiful_array(n): Creates a beautiful array if possible. A beautiful array is an array where no two adjacent elements are coprime. :param n: Length of the array :type n: int :return: A beautiful array or -1 if not possible :rtype: list[int] or int if n % 2 != 0: return -1 # If n is odd, it's impossible to make a beautiful array # For even n, we can construct the array by alternating between 2 and 4 beautiful_array = [2 if i % 2 == 0 else 4 for i in range(n)] return beautiful_array"},{"question":"def validate_expression(expression: str) -> bool: Validates whether the given expression has balanced parentheses, brackets, and braces. >>> validate_expression(\\"(a+b)*(c-d)\\") == True >>> validate_expression(\\"[(a+b]*c-d)\\") == False >>> validate_expression(\\"{[a+(b*c]+d}/e\\") == False >>> validate_expression(\\"\\") == True >>> validate_expression(\\"a+b*c-d/e\\") == True >>> validate_expression(\\"((([[[\\") == False >>> validate_expression(\\")))]\\") == False >>> validate_expression(\\"{[()]}\\") == True >>> validate_expression(\\"{[(a+b)*c]-d/(e+f)}\\") == True >>> validate_expression(\\"{[(a+b]*c)-d/(e+f)}\\") == False # Implementation goes here","solution":"def validate_expression(expression): Validates whether the given expression has balanced parentheses, brackets, and braces. :param expression: str, the input mathematical expression :return: bool, True if the expression is valid, otherwise False stack = [] matching = {')': '(', ']': '[', '}': '{'} for char in expression: if char in matching.values(): stack.append(char) elif char in matching.keys(): if not stack or matching[char] != stack.pop(): return False return not stack"},{"question":"def generate_permutation(n): Generates a permutation of integers from 1 to n such that it does not contain any increasing subsequence of length greater than or equal to 4. pass def solve(test_cases): Solves the problem for a list of test cases and returns the results. Parameters: test_cases (List[int]): a list containing the integer n for each test case Returns: List[List[int]]: a list of lists, each containing the permutation for the respective test case pass if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() t = int(data[0]) test_cases = [int(data[i]) for i in range(1, t + 1)] results = solve(test_cases) for result in results: print(\\" \\".join(map(str, result)))","solution":"def generate_permutation(n): Generates a permutation of integers from 1 to n such that it does not contain any increasing subsequence of length greater than or equal to 4. return list(range(n, 0, -1)) def solve(test_cases): results = [] for n in test_cases: permutation = generate_permutation(n) results.append(permutation) return results"},{"question":"def draw_frame(H: int, W: int) -> List[str]: Create a rectangular frame of height H cm and width W cm using '#' symbols with the inside of the frame being empty spaces. >>> draw_frame(4, 6) ['', '# #', '# #', ''] >>> draw_frame(3, 4) ['', '# #', ''] >>> draw_frame(2, 2) ['', ''] >>> draw_frame(1, 1) ['#'] >>> draw_frame(3, 3) ['#', '# #', '#'] >>> draw_frame(5, 6) ['', '# #', '# #', '# #', '']","solution":"def draw_frame(H, W): if H == 0 and W == 0: return top_bottom = '#' * W middle = '#' + ' ' * (W - 2) + '#' frame = [top_bottom] for i in range(1, H-1): frame.append(middle) if H > 1: frame.append(top_bottom) return frame def main(): import sys input = sys.stdin.read data = input().strip().split('n') results = [] for line in data: H, W = map(int, line.split()) if H == 0 and W == 0: break frame = draw_frame(H, W) results.append('n'.join(frame)) if results: print('nn'.join(results)) if __name__ == \\"__main__\\": main()"},{"question":"import heapq from typing import List def process_orders(commands: List[str]) -> List[int]: Processes a list of commands to manage product orders by priority. Each command is either \\"add P\\" or \\"process\\". :param commands: List of commands where each command is either \\"add P\\" or \\"process\\" :type commands: List[str] :return: List of results for \\"process\\" commands :rtype: List[int]","solution":"import heapq def process_orders(commands): Processes a list of commands to manage product orders by priority. :param commands: List of commands where each command is either \\"add P\\" or \\"process\\" :type commands: List[str] :return: List of results for \\"process\\" commands :rtype: List[int] min_heap = [] order_count = 0 # To maintain the order of entries with the same priority results = [] for command in commands: if command.startswith(\\"add\\"): _, priority = command.split() priority = int(priority) heapq.heappush(min_heap, (priority, order_count)) order_count += 1 elif command == \\"process\\": if min_heap: result = heapq.heappop(min_heap)[0] results.append(result) else: results.append(-1) return results"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_full_binary_tree(root): Determines whether a given binary tree is a full binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> is_full_binary_tree(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.right.left = TreeNode(6) >>> is_full_binary_tree(root) False","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_full_binary_tree(root): if root is None: return True if (root.left is None and root.right is not None) or (root.left is not None and root.right is None): return False return is_full_binary_tree(root.left) and is_full_binary_tree(root.right)"},{"question":"def maxSumOfKLengthSubarray(A, N, K): Returns the maximum sum of a subarray of length K. Parameters: A : list[int] -> Array of integers N : int -> Length of the array K : int -> Length of the subarray Returns: int - Maximum sum of a subarray of length K >>> maxSumOfKLengthSubarray([1, 2, 3, 4, 5], 5, 3) 12 >>> maxSumOfKLengthSubarray([2, 1, 5, 1], 4, 2) 6","solution":"def maxSumOfKLengthSubarray(A, N, K): Returns the maximum sum of a subarray of length K. Parameters: A : list[int] -> Array of integers N : int -> Length of the array K : int -> Length of the subarray Returns: int - Maximum sum of a subarray of length K # Calculate the sum of the first window of size K max_sum = current_sum = sum(A[:K]) # Iterate through the array and adjust window size for i in range(K, N): current_sum += A[i] - A[i - K] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. >>> print(is_palindrome(\\"A man, a plan, a canal, Panama\\")) # should return True >>> print(is_palindrome(\\"No 'x' in Nixon\\")) # should return True >>> print(is_palindrome(\\"Hello, World!\\")) # should return False","solution":"def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. # Filter out non-alphanumeric characters and convert to lower case filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered list of characters reads the same forward and backward return filtered_chars == filtered_chars[::-1]"},{"question":"def is_monotonic(n: int) -> str: Determines if a given positive integer n is a monotonic number. >>> is_monotonic(1234) 'Yes' >>> is_monotonic(4312) 'No' >>> is_monotonic(1111) 'Yes' >>> is_monotonic(1231) 'No'","solution":"def is_monotonic(n): Determines if a given positive integer n is a monotonic number. digits = list(map(int, str(n))) is_non_decreasing = all(x <= y for x, y in zip(digits, digits[1:])) is_non_increasing = all(x >= y for x, y in zip(digits, digits[1:])) if is_non_decreasing or is_non_increasing: return \\"Yes\\" return \\"No\\""},{"question":"def find_shortest_path(routes: List[str]) -> str: Given a list of strings where each string represents a route on a map in the form of \\"A->B->C->D\\", find the shortest path that visits all the unique destinations at least once, starting from the first destination of the first route. If multiple routes yield the same length, return the lexicographically smallest route. >>> find_shortest_path([\\"A->B\\", \\"B->C\\", \\"A->C->D\\"]) \\"A->B->C->D\\" >>> find_shortest_path([\\"A->X\\", \\"X->Y\\", \\"Y->Z\\", \\"A->Y->Z\\"]) \\"A->X->Y->Z\\" >>> find_shortest_path([\\"A->B->C\\", \\"B->C->D\\", \\"C->D->E\\", \\"A->D->E\\"]) \\"A->B->C->D->E\\" >>> find_shortest_path([\\"A->B->C->D\\"]) \\"A->B->C->D\\" >>> find_shortest_path([\\"A\\"]) \\"A\\" >>> find_shortest_path([\\"A->B\\", \\"B->C\\", \\"C->D\\", \\"D->E\\", \\"E->F\\", \\"F->G\\", \\"G->H\\"]) \\"A->B->C->D->E->F->G->H\\"","solution":"from typing import List import itertools def find_shortest_path(routes: List[str]) -> str: def extract_unique_destinations(routes: List[str]) -> List[str]: unique_destinations = set() for route in routes: stops = route.split('->') unique_destinations.update(stops) return sorted(unique_destinations) def path_length(path: List[str], routes: List[str]) -> int: path_str = '->'.join(path) total_length = sum(path_str.count(route.replace('->', '')) >= 1 for route in routes) return total_length unique_destinations = extract_unique_destinations(routes) all_permutations = itertools.permutations(unique_destinations) smallest_route = None smallest_length = float('inf') for perm in all_permutations: cur_length = path_length(perm, routes) cur_route = '->'.join(perm) if cur_length < smallest_length or (cur_length == smallest_length and cur_route < smallest_route): smallest_length = cur_length smallest_route = cur_route return smallest_route"},{"question":"from collections import deque def maze_solver(maze_str: str) -> int: Finds the shortest path from the entrance to the exit of the maze. The maze is represented as a 2D grid where each cell is either passable ('.') or a wall ('#'). The entrance is at the top-left corner, and the exit is at the bottom-right corner. Parameters: maze_str (str): A string representation of the maze, including dimensions and grid layout. Returns: int: The length of the shortest path from the entrance to the exit or -1 if no such path exists. Examples: >>> maze_solver(\\"5 5n.....n.#.#.n.#.#.n.#.#.n.....\\") 8 >>> maze_solver(\\"3 3n.#.n#n.#.\\") -1 pass def test_shortest_path_example1(): maze_str = \\"5 5n.....n.#.#.n.#.#.n.#.#.n.....\\" assert maze_solver(maze_str) == 8 def test_shortest_path_example2(): maze_str = \\"3 3n.#.n#n.#.\\" assert maze_solver(maze_str) == -1 def test_shortest_path_single_path(): maze_str = \\"3 3n...n#.#n...\\" assert maze_solver(maze_str) == 4 def test_shortest_path_no_path(): maze_str = \\"2 2n.#n#.\\" assert maze_solver(maze_str) == -1 def test_shortest_path_direct_line(): maze_str = \\"2 2n..n..\\" assert maze_solver(maze_str) == 2 def test_shortest_path_larger_maze(): maze_str = \\"6 6n......n..n......n..n......n......\\" assert maze_solver(maze_str) == 10","solution":"from collections import deque def shortest_path(maze, n, m): # Directions for moving in the maze (right, down, left, up) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Helper function to check if a position is valid and passable def is_valid(x, y): return 0 <= x < n and 0 <= y < m and maze[x][y] == '.' # Queue for BFS, initialized with the entrance position and step count queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() # If we reached the exit if x == n - 1 and y == m - 1: return dist # Explore all possible directions for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) # If exit is not reachable return -1 # Example usage: def maze_solver(maze_str): maze_lines = maze_str.strip().split('n') n, m = map(int, maze_lines[0].split()) maze = [list(line.strip()) for line in maze_lines[1:]] return shortest_path(maze, n, m)"},{"question":"def smallest_lexicographic_rotation(word: str) -> str: Returns the lexicographically smallest rotation of the given word. >>> smallest_lexicographic_rotation(\\"bca\\") \\"abc\\" >>> smallest_lexicographic_rotation(\\"zxy\\") \\"xyz\\" >>> smallest_lexicographic_rotation(\\"abc\\") \\"abc\\" >>> smallest_lexicographic_rotation(\\"rotation\\") \\"ationrot\\" >>> smallest_lexicographic_rotation(\\"example\\") \\"ampleex\\" >>> smallest_lexicographic_rotation(\\"aaaa\\") \\"aaaa\\" pass def decode_messages(words: List[str]) -> List[str]: Given a list of words, return a list with the lexicographically smallest rotation for each word. >>> decode_messages([\\"bca\\", \\"zxy\\", \\"abc\\"]) [\\"abc\\", \\"xyz\\", \\"abc\\"] >>> decode_messages([\\"rotation\\", \\"example\\"]) [\\"ationrot\\", \\"ampleex\\"] >>> decode_messages([\\"aaaa\\"]) [\\"aaaa\\"] pass","solution":"def smallest_lexicographic_rotation(word): Returns the lexicographically smallest rotation of the given word. concatenated = word + word smallest_rotation = word for i in range(1, len(word)): rotation = concatenated[i:i+len(word)] if rotation < smallest_rotation: smallest_rotation = rotation return smallest_rotation def decode_messages(words): Given a list of words, return a list with the lexicographically smallest rotation for each word. return [smallest_lexicographic_rotation(word) for word in words]"},{"question":"def max_subarray_sum(nums): Returns the maximum sum of any contiguous subarray within the given list. >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([3, -2, 5, -1]) 6 >>> max_subarray_sum([-1, 2, 3, -7, 4, 5, -1]) 9 >>> max_subarray_sum([]) 0","solution":"def max_subarray_sum(nums): Returns the maximum sum of any contiguous subarray within the given list. if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def min_cages(species_list): Given a list of species and their quantities, determines the minimum number of cages required to house all the animals, with each cage housing animals of the same species. :param species_list: List of tuples where each tuple contains a species name and its quantity. :return: Integer representing the minimum number of cages required. >>> min_cages([(\\"lion\\", 3), (\\"tiger\\", 2), (\\"elephant\\", 1)]) 3 >>> min_cages([(\\"lion\\", 500), (\\"penguin\\", 500), (\\"tiger\\", 500), (\\"bear\\", 500), (\\"wolf\\", 500)]) 5 >>> min_cages([(\\"zebra\\", 100)]) 1 >>> min_cages([(\\"elephant\\", 999), (\\"giraffe\\", 888), (\\"hippo\\", 777), (\\"rhino\\", 666)]) 4 >>> min_cages([]) 0","solution":"def min_cages(species_list): Given a list of species and their quantities, determines the minimum number of cages required to house all the animals, with each cage housing animals of the same species. :param species_list: List of tuples where each tuple contains a species name and its quantity. :return: Integer representing the minimum number of cages required. # The number of cages needed is equal to the number of different species. return len(species_list)"},{"question":"def longest_increasing_run(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given multiple test cases, calculate the length of the longest increasing run in the sequence for each test case. Parameters: t (int): Number of test cases. test_cases (list): A list of tuples, where each tuple contains an integer n (number of elements in the sequence) and a list of n integers representing the sequence. Returns: list: A list of integers where each integer is the length of the longest increasing run in the corresponding test case. pass from solution import longest_increasing_run def test_single_case_increasing(): assert longest_increasing_run(1, [(5, [1, 2, 3, 4, 5])]) == [5] def test_single_case_mixed(): assert longest_increasing_run(1, [(5, [1, 2, 3, 2, 4])]) == [3] def test_single_case_decreasing(): assert longest_increasing_run(1, [(4, [4, 3, 2, 1])]) == [1] def test_multiple_cases(): assert longest_increasing_run(3, [(5, [1, 2, 3, 2, 4]), (4, [4, 3, 2, 1]), (6, [1, 2, 1, 2, 1, 2])]) == [3, 1, 2] def test_single_element_case(): assert longest_increasing_run(1, [(1, [1])]) == [1] def test_case_with_no_elements(): assert longest_increasing_run(1, [(0, [])]) == [0] def test_large_case(): assert longest_increasing_run(1, [(100000, list(range(100000)))]) == [100000] def test_maximal_element_value(): assert longest_increasing_run(1, [(3, [1000000000, 999999999, 1000000001])]) == [2]","solution":"def longest_increasing_run(t, test_cases): Given multiple test cases, calculate the length of the longest increasing run in the sequence for each test case. Parameters: t (int): Number of test cases. test_cases (list): A list of tuples, where each tuple contains an integer n (number of elements in the sequence) and a list of n integers representing the sequence. Returns: list: A list of integers where each integer is the length of the longest increasing run in the corresponding test case. results = [] for case in test_cases: n, sequence = case if n == 0: results.append(0) continue max_run_length = 1 current_run_length = 1 for i in range(1, n): if sequence[i] > sequence[i - 1]: current_run_length += 1 max_run_length = max(max_run_length, current_run_length) else: current_run_length = 1 results.append(max_run_length) return results"},{"question":"def count_paths_from_input(n, m, grid_lines): Determine the number of ways to move from the top-left to the bottom-right corner of the grid without passing through obstacles. :param n: The number of rows in the grid. :param m: The number of columns in the grid. :param grid_lines: A list of strings representing the grid where each character is either '.' or '#'. :return: The number of valid paths. >>> count_paths_from_input(3, 3, [\\".#.\\", \\"...\\", \\"#..\\"]) 2 >>> count_paths_from_input(3, 3, [\\".#.\\", \\".#.\\", \\"#.#\\"]) 0 >>> count_paths_from_input(2, 2, [\\"..\\", \\"..\\"]) 2 >>> count_paths_from_input(2, 2, [\\"#.\\", \\"..\\"]) 0 >>> count_paths_from_input(2, 2, [\\"..\\", \\".#\\"]) 0 >>> count_paths_from_input(1, 1, [\\".\\"]) 1 >>> count_paths_from_input(1, 1, [\\"#\\"]) 0","solution":"def count_paths(grid, n, m): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1] def count_paths_from_input(n, m, grid_lines): grid = [list(line) for line in grid_lines] return count_paths(grid, n, m)"},{"question":"def can_form_palindrome(S: str) -> str: Determines if it is possible to replace all asterisks in the string S such that the resulting string is a palindrome. >>> can_form_palindrome(\\"a*b*a\\") == \\"Yes\\" >>> can_form_palindrome(\\"a*c*ca\\") == \\"Yes\\" >>> can_form_palindrome(\\"a*d**d*a\\") == \\"Yes\\" >>> can_form_palindrome(\\"a*******a\\") == \\"Yes\\" >>> can_form_palindrome(\\"a*b*c\\") == \\"No\\" >>> can_form_palindrome(\\"ab*ba*cd\\") == \\"No\\" >>> can_form_palindrome(\\"*\\") == \\"Yes\\" >>> can_form_palindrome(\\"aa*a\\") == \\"Yes\\" >>> can_form_palindrome(\\"*bb*\\") == \\"Yes\\" >>> can_form_palindrome(\\"abc*def\\") == \\"No\\" >>> can_form_palindrome(\\"*****\\") == \\"Yes\\" >>> can_form_palindrome(\\"*a*\\") == \\"Yes\\" >>> can_form_palindrome(\\"a*a*a\\") == \\"Yes\\" >>> can_form_palindrome(\\"**\\") == \\"Yes\\" >>> can_form_palindrome(\\"*b*b*\\") == \\"Yes\\"","solution":"def can_form_palindrome(S): Determines if it is possible to replace all asterisks in the string S such that the resulting string is a palindrome. n = len(S) left = 0 right = n - 1 while left < right: if S[left] != S[right]: if S[left] == '*' or S[right] == '*': left += 1 right -= 1 continue else: return \\"No\\" left += 1 right -= 1 return \\"Yes\\""},{"question":"def calculate_areas(rectangles): Given a list of tuples representing rectangles, where each tuple contains the width and height of the rectangles, this function returns a list of their areas. Parameters: rectangles (list of tuples): List of tuples where each tuple contains two integers (width, height) Returns: list of int: List containing the area of each rectangle >>> calculate_areas([(5, 4), (7, 2), (6, 6)]) [20, 14, 36] >>> calculate_areas([(10, 10)]) [100] >>> calculate_areas([(3, 3), (4, 4)]) [9, 16] >>> calculate_areas([(1, 1000), (1000, 1), (500, 2)]) [1000, 1000, 1000] >>> calculate_areas([(1, 1), (1000, 1000), (500, 500), (1000, 999), (99, 1001)]) [1, 1000000, 250000, 999000, 99099]","solution":"def calculate_areas(rectangles): Given a list of tuples representing rectangles, where each tuple contains the width and height of the rectangles, this function returns a list of their areas. Parameters: rectangles (list of tuples): List of tuples where each tuple contains two integers (width, height) Returns: list of int: List containing the area of each rectangle areas = [] for width, height in rectangles: areas.append(width * height) return areas"},{"question":"def min_swaps_to_sort(n: int, arr: List[int]) -> int: Calculates the minimal number of swaps needed to arrange the steps in the correct order. Parameters: n (int): The number of steps. arr (list of int): The current order of steps in the production line. Returns: int: The minimal number of swaps needed. Examples: >>> min_swaps_to_sort(5, [3, 1, 2, 5, 4]) 3 >>> min_swaps_to_sort(4, [2, 1, 4, 3]) 2","solution":"def min_swaps_to_sort(n, arr): Calculates the minimal number of swaps needed to arrange the steps in the correct order. Parameters: n (int): The number of steps. arr (list of int): The current order of steps in the production line. Returns: int: The minimal number of swaps needed. steps_with_indices = [(value, idx) for idx, value in enumerate(arr)] steps_with_indices.sort() visited = [False] * n swaps = 0 for i in range(n): if visited[i] or steps_with_indices[i][1] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = steps_with_indices[j][1] cycle_size += 1 if cycle_size > 1: swaps += cycle_size - 1 return swaps"},{"question":"from typing import List def get_minimum_coins(amount: int, denominations: List[int]) -> List[int]: Returns the smallest set of coins needed to make the amount using the given denominations. If it is not possible to make the exact change, returns an empty list. Example Usage: >>> get_minimum_coins(11, [1, 2, 5]) [5, 5, 1] >>> get_minimum_coins(30, [25, 10, 5, 1]) [25, 5] >>> get_minimum_coins(7, [2, 4]) [] >>> get_minimum_coins(0, [1, 2, 5]) [] from solution import get_minimum_coins def test_exact_change(): assert get_minimum_coins(11, [1, 2, 5]) in [[5, 5, 1], [5, 2, 2, 2], [1, 5, 5], [2, 2, 2, 5], [5, 1, 5], [2, 5, 2, 2]] def test_larger_amount(): assert get_minimum_coins(30, [25, 10, 5, 1]) in [[25, 5], [10, 10, 10], [5, 25]] def test_no_solution(): assert get_minimum_coins(7, [2, 4]) == [] def test_zero_amount(): assert get_minimum_coins(0, [1, 2, 5]) == [] def test_single_denomination(): assert get_minimum_coins(4, [1]) == [1, 1, 1, 1] assert get_minimum_coins(3, [2]) == [] assert get_minimum_coins(10, [10]) == [10] def test_multiple_solutions(): assert sorted(get_minimum_coins(23, [1, 5, 10])) == sorted([10, 10, 1, 1, 1]) assert sorted(get_minimum_coins(23, [1, 2, 5, 10])) == sorted([10, 10, 2, 1]) def test_order_independent(): assert get_minimum_coins(7, [5, 1, 2]) in [[5, 2], [2, 5], [1, 1, 5], [1, 5, 1]]","solution":"def get_minimum_coins(amount, denominations): Returns the smallest set of coins needed to make the amount using the given denominations. If it is not possible to make the exact change, returns an empty list. if amount == 0: return [] denominations.sort(reverse=True) result = [] for coin in denominations: while amount >= coin: amount -= coin result.append(coin) if amount != 0: return [] return result"},{"question":"from typing import List def remove_k_digits(num: str, k: int) -> str: Form the smallest possible number by removing exactly \`k\` digits from the given string. >>> remove_k_digits(\\"1432219000\\", 3) '1219000' >>> remove_k_digits(\\"9876543\\", 3) '6543' >>> remove_k_digits(\\"1234567890\\", 0) '1234567890' >>> remove_k_digits(\\"123\\", 3) '0' >>> remove_k_digits(\\"100200300\\", 3) '0' >>> remove_k_digits(\\"10200\\", 1) '200' >>> remove_k_digits(\\"11111111\\", 3) '11111' >>> remove_k_digits(\\"999999\\", 1) '99999' >>> remove_k_digits(\\"10\\", 1) '0'","solution":"def remove_k_digits(num: str, k: int) -> str: stack = [] for digit in num: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) stack = stack[:-k] if k else stack return ''.join(stack).lstrip('0') or '0'"},{"question":"def minimum_swaps(P: List[int]) -> int: Calculate the minimum number of swaps required to sort the permutation P. >>> minimum_swaps([4, 3, 2, 1]) 2 >>> minimum_swaps([2, 1, 4, 3, 5]) 2 >>> minimum_swaps([3, 1, 2]) 2 >>> minimum_swaps([1, 2, 3, 4, 5]) 0 >>> minimum_swaps([5, 4, 3, 2, 1]) 2 >>> minimum_swaps([1]) 0 >>> minimum_swaps([2, 1]) 1","solution":"def minimum_swaps(P): Calculate the minimum number of swaps required to sort the permutation P. n = len(P) # Create a boolean list to mark visited elements visited = [False] * n swap_count = 0 for i in range(n): if visited[i] or P[i] == i + 1: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = P[x] - 1 cycle_size += 1 if cycle_size > 0: swap_count += (cycle_size - 1) return swap_count"},{"question":"def word_to_alphabet_sum(text: str) -> str: Converts each word in the input text to a sum of the alphabetical positions of its characters. Parameters: text (str): The input string containing words separated by spaces. Returns: str: A new string where each word is replaced by a sum of the alphabetical positions of its characters. >>> word_to_alphabet_sum(\\"hello world\\") \\"52 72\\" >>> word_to_alphabet_sum(\\"ABC xyz\\") \\"6 75\\"","solution":"def word_to_alphabet_sum(text): Converts each word in the input text to a sum of the alphabetical positions of its characters. Parameters: text (str): The input string containing words separated by spaces. Returns: str: A new string where each word is replaced by a sum of the alphabetical positions of its characters. def sum_alphabet(word): return sum(ord(char.lower()) - ord('a') + 1 for char in word if char.isalpha()) words = text.split() summed_words = [str(sum_alphabet(word)) for word in words] return ' '.join(summed_words)"},{"question":"def maximize_string(k: int, s: str) -> str: Given a string s and an integer k, replace at most k digits in the string with any digit from '0' to '9' to maximize the numeric value of the resulting string. >>> maximize_string(1, '123456') '923456' >>> maximize_string(2, '2517') '9917' from solution import maximize_string def test_maximize_string_basic(): assert maximize_string(1, '123456') == '923456' assert maximize_string(2, '2517') == '9917' def test_maximize_string_no_replacement_needed(): assert maximize_string(0, '9876') == '9876' def test_maximize_string_single_digit(): assert maximize_string(1, '1') == '9' assert maximize_string(1, '9') == '9' def test_maximize_string_k_greater_than_needed(): assert maximize_string(5, '1234') == '9999' def test_maximize_string_large_input(): assert maximize_string(5, '1234567890') == '9999967890' def test_maximize_string_all_zeroes(): assert maximize_string(2, '0000') == '9900'","solution":"def maximize_string(k, s): Given a string s and an integer k, replace at most k digits in the string with any digit from '0' to '9' to maximize the numeric value of the resulting string. s_list = list(s) replacements = 0 for i in range(len(s_list)): if replacements < k and s_list[i] != '9': s_list[i] = '9' replacements += 1 if replacements == k: break return ''.join(s_list)"},{"question":"def min_operations(s: str, t: str) -> int: Returns the minimum number of operations required to convert string s into string t. >>> min_operations(\\"intention\\", \\"execution\\") == 5 >>> min_operations(\\"abcdef\\", \\"azced\\") == 3 >>> min_operations(\\"sunday\\", \\"saturday\\") == 3 >>> min_operations(\\"abc\\", \\"abc\\") == 0 >>> min_operations(\\"abc\\", \\"\\") == 3 >>> min_operations(\\"\\", \\"abc\\") == 3 >>> min_operations(\\"a\\", \\"b\\") == 1","solution":"def min_operations(s, t): Returns the minimum number of operations required to convert string s into string t. m, n = len(s), len(t) dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the dp array for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Compute the dp values for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"def construct_string(K: int, M: int) -> str: Constructs a string of exactly K characters containing exactly M occurrences of 'X', such that no two adjacent characters in the string are the same. If it is not possible, returns \\"IMPOSSIBLE\\". >>> construct_string(5, 3) 'XYXYX' >>> construct_string(4, 2) 'XYXY' >>> construct_string(2, 1) in ['XY', 'YX'] True >>> construct_string(3, 2) in ['XYX', 'YXY'] True >>> construct_string(5, 4) 'IMPOSSIBLE'","solution":"def construct_string(K, M): Constructs a string of length K with exactly M occurrences of 'X' and no two adjacent characters being the same. Returns the string if possible, otherwise returns \\"IMPOSSIBLE\\". # If M is greater than half of the length (rounded up), it is impossible to create such a string if M > (K + 1) // 2: return \\"IMPOSSIBLE\\" result = [] x_count = 0 y_count = 0 # Populate the string by alternating between 'X' and 'Y' for i in range(K): # Add 'X' if we have not yet added all 'X's and (it's the first character OR the last character was 'Y') if x_count < M and (i == 0 or result[-1] == 'Y'): result.append('X') x_count += 1 # Else add 'Y' else: result.append('Y') y_count += 1 return ''.join(result)"},{"question":"def count_valid_sequences(T: int) -> int: Calculate the number of distinct valid sequences that can be generated when ending at or before the value T. The sequence starts with 1 and each next integer is either one more or two more than the previous integer. Parameters: T (int): The maximum value an integer in the sequence can reach. Returns: int: The number of distinct valid sequences. >>> count_valid_sequences(3) 3 >>> count_valid_sequences(5) 8","solution":"def count_valid_sequences(T): This function calculates the number of distinct valid sequences that can be generated when ending at or before the value T. The sequence starts with 1 and each next integer is either one more or two more than the previous integer. if T == 1: return 1 dp = [0] * (T + 1) dp[1] = 1 for i in range(2, T + 1): dp[i] = dp[i - 1] + dp[i - 2] if i == 2: dp[i] += 1 return dp[T]"},{"question":"def maxMagicalPower(arr, N): Returns the maximum magical power from the first N items in the array. >>> maxMagicalPower([4, 12, 7, 15, 9], 5) 15 >>> maxMagicalPower([100, 250, 150], 2) 250 >>> maxMagicalPower([3, 1, 4, 1, 5, 9, 2, 6, 5], 3) 4 pass def process_test_cases(T, test_cases): Processes multiple test cases and returns a list of results for each test case. >>> test_cases = [ ... (5, [4, 12, 7, 15, 9]), ... (2, [100, 250, 150]), ... (3, [3, 1, 4, 1, 5, 9, 2, 6, 5]) ... ] >>> process_test_cases(3, test_cases) [15, 250, 4] pass","solution":"def maxMagicalPower(arr, N): Returns the maximum magical power from the first N items in the array. # We only consider the first N items from the array return max(arr[:N]) # Function to handle multiple test cases def process_test_cases(T, test_cases): results = [] for i in range(T): N, arr = test_cases[i] results.append(maxMagicalPower(arr, N)) return results"},{"question":"def find_pair_with_sum(array, target): Given an array of integers and a target integer value, determine if there are two integers in the array whose sum equals the target value. If such a pair exists, return the indices of the two integers as a tuple (index1, index2). If no such pair exists, return None. Indices returned should be in increasing order. Parameters: array (List[int]): List of integers. target (int): Target sum. Returns: Tuple[int, int] or None: Tuple of indices of the two integers whose sum is equal to the target, or None if no such pair exists. Example: >>> find_pair_with_sum([2, 7, 11, 15], 9) (0, 1) >>> find_pair_with_sum([3, 2, 4], 6) (1, 2) >>> find_pair_with_sum([3, 3], 6) (0, 1) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) None pass","solution":"def find_pair_with_sum(array, target): Returns the indices of the two integers in the array whose sum equals the target. Parameters: array (List[int]): List of integers. target (int): Target sum. Returns: Tuple[int, int] or None: Tuple of indices of the two integers whose sum is equal to the target, or None if no such pair exists. seen = {} for index, value in enumerate(array): complement = target - value if complement in seen: return (seen[complement], index) seen[value] = index return None"},{"question":"def max_pawns_to_cover(n: int, board: str) -> int: Given a single-line chessboard, determines the maximum number of pawns that can be covered by rooks such that no two rooks cover the same pawn. Parameters: n (int): The number of cells on the chessboard. board (str): A string consisting of 'P' and '.' representing pawns and empty cells. Returns: int: The maximum number of pawns that can be covered by rooks. >>> max_pawns_to_cover(7, '.P..P.P') 3 >>> max_pawns_to_cover(5, 'P.P.P') 3 >>> max_pawns_to_cover(6, '...P..') 1 >>> max_pawns_to_cover(5, '.....') 0 >>> max_pawns_to_cover(4, 'PPPP') 4 >>> max_pawns_to_cover(1, 'P') 1 >>> max_pawns_to_cover(1, '.') 0 >>> max_pawns_to_cover(6, '.P.P.P') 3 >>> max_pawns_to_cover(10, '..PP..P.P.') 4","solution":"def max_pawns_to_cover(n, board): Given a single-line chessboard, determines the maximum number of pawns that can be covered by rooks such that no two rooks cover the same pawn. Parameters: n (int): The number of cells on the chessboard. board (str): A string consisting of 'P' and '.' representing pawns and empty cells. Returns: int: The maximum number of pawns that can be covered by rooks. return board.count('P')"},{"question":"def longestGeometricSubseqLength(arr: List[int]) -> int: Given a list of integers, find the length of the longest subsequence which forms a geometric progression. >>> longestGeometricSubseqLength([1, 3, 9, 27, 81]) 5 >>> longestGeometricSubseqLength([2, 4, 8, 16, 20, 40]) 4 >>> longestGeometricSubseqLength([2, 4, 8, 10, 20, 40]) 3 >>> longestGeometricSubseqLength([1, 2, 4, 8, 3, 9, 27]) 4 >>> longestGeometricSubseqLength([1, 2, 4, 8, 16, 32]) 6 >>> longestGeometricSubseqLength([1, 3, 9, 27, 81, 243]) 6 >>> longestGeometricSubseqLength([]) 0 >>> longestGeometricSubseqLength([10]) 1 >>> longestGeometricSubseqLength([1, 5, 25, 125]) 4 >>> longestGeometricSubseqLength([1, 2, 4, 4, 8]) 4","solution":"def longestGeometricSubseqLength(arr): if not arr: return 0 n = len(arr) if n == 1: return 1 max_len = 1 dp = [{} for _ in range(n)] for i in range(n): for j in range(i): if arr[i] % arr[j] == 0: ratio = arr[i] // arr[j] if ratio in dp[j]: dp[i][ratio] = dp[j][ratio] + 1 else: dp[i][ratio] = 2 max_len = max(max_len, dp[i][ratio]) return max_len"},{"question":"def auto_correct_document(document: str) -> str: Auto-corrects a document by converting all characters to lowercase and capitalizing the first letter of each sentence. Sentences are separated by a single space and end with a period. Args: document (str): The input document string. Returns: str: The auto-corrected document. >>> auto_correct_document(\\"hello world. this is an example. can you fix it?\\") 'Hello world. This is an example. Can you fix it?' >>> auto_correct_document(\\"HeLLo wOrLD. ThiS iS An exAmple. Can YoU fix it?\\") 'Hello world. This is an example. Can you fix it?' >>> auto_correct_document(\\"HELLO WORLD. THIS IS AN EXAMPLE. CAN YOU FIX IT?\\") 'Hello world. This is an example. Can you fix it?' >>> auto_correct_document(\\"hello world this is an example can you fix it?\\") 'Hello world this is an example can you fix it?'","solution":"def auto_correct_document(document): Auto-corrects a document by converting all characters to lowercase and capitalizing the first letter of each sentence. Sentences are separated by a single space and end with a period. Args: document (str): The input document string. Returns: str: The auto-corrected document. sentences = document.lower().split('. ') corrected_sentences = [sentence.capitalize() for sentence in sentences] corrected_document = '. '.join(corrected_sentences) return corrected_document"},{"question":"def lcm(a, b): Returns the least common multiple of a and b. pass def sum_of_digits(n): Returns the sum of the digits of n. pass def smallest_multiple_with_min_digit_sum(a, b): Returns the smallest integer n that is a multiple of both a and b and has the minimum possible sum of its digits. >>> smallest_multiple_with_min_digit_sum(12, 15) 60 >>> smallest_multiple_with_min_digit_sum(13, 17) 221 >>> smallest_multiple_with_min_digit_sum(10, 20) 20 pass # Unit Test from solution import smallest_multiple_with_min_digit_sum, lcm, sum_of_digits def test_smallest_multiple_with_min_digit_sum(): assert smallest_multiple_with_min_digit_sum(12, 15) == 60 assert smallest_multiple_with_min_digit_sum(13, 17) == 221 assert smallest_multiple_with_min_digit_sum(10, 20) == 20 def test_lcm(): assert lcm(12, 15) == 60 assert lcm(13, 17) == 221 assert lcm(10, 20) == 20 def test_sum_of_digits(): assert sum_of_digits(60) == 6 assert sum_of_digits(221) == 5 assert sum_of_digits(20) == 2 assert sum_of_digits(1234) == 10","solution":"import math def lcm(a, b): Returns the least common multiple of a and b. return abs(a * b) // math.gcd(a, b) def sum_of_digits(n): Returns the sum of the digits of n. return sum(int(digit) for digit in str(n)) def smallest_multiple_with_min_digit_sum(a, b): Returns the smallest integer n that is a multiple of both a and b and has the minimum possible sum of its digits. lcm_ab = lcm(a, b) return lcm_ab"},{"question":"def is_network_functional(n, m, links): Determine if the network is functional or faulty based on the presence of communication rings. >>> is_network_functional(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) \\"Faulty\\" >>> is_network_functional(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) \\"Functional\\"","solution":"def is_network_functional(n, m, links): def dfs(v, parent): visited[v] = True for u in adj_list[v]: if not visited[u]: if dfs(u, v): return True elif u != parent: return True return False adj_list = [[] for _ in range(n + 1)] for a, b in links: adj_list[a].append(b) adj_list[b].append(a) visited = [False] * (n + 1) for i in range(1, n + 1): if not visited[i]: if dfs(i, -1): return \\"Faulty\\" return \\"Functional\\" # Example usage: n = 5 m = 5 links = [ (1, 2), (2, 3), (3, 4), (4, 5), (5, 1) ] print(is_network_functional(n, m, links)) # Output should be \\"Faulty\\" n = 5 m = 4 links = [ (1, 2), (2, 3), (3, 4), (4, 5) ] print(is_network_functional(n, m, links)) # Output should be \\"Functional\\""},{"question":"def rearrange_string(s: str) -> str: Rearranges the characters in the string such that all digits come before all letters while maintaining their original relative order. Parameters: s (str): The input string containing a mix of letters and digits. Returns: str: The rearranged string. >>> rearrange_string(\\"a1b2c3d4\\") \\"1234abcd\\" >>> rearrange_string(\\"h3e4l5l6o1w2o0r7l8d9\\") \\"3456120789helloworld\\" >>> rearrange_string(\\"abc\\") \\"abc\\" >>> rearrange_string(\\"123\\") \\"123\\"","solution":"def rearrange_string(s): Rearranges the string such that all digits come before all letters while maintaining their original relative order. Parameters: s (str): The input string containing a mix of letters and digits. Returns: str: The rearranged string. digits = [char for char in s if char.isdigit()] letters = [char for char in s if char.isalpha()] return ''.join(digits + letters)"},{"question":"def reverse_if_not_palindrome(s: str) -> str: Returns the reversed string if the input string is not a palindrome. If the input string is a palindrome, returns the original string. >>> reverse_if_not_palindrome(\\"racecar\\") \\"racecar\\" >>> reverse_if_not_palindrome(\\"hello\\") \\"olleh\\" >>> reverse_if_not_palindrome(\\"madam\\") \\"madam\\" >>> reverse_if_not_palindrome(\\"Madam\\") \\"madaM\\" >>> reverse_if_not_palindrome(\\"A man, a plan, a canal, Panama\\") \\"amanaP ,lanac a ,nalp a ,nam A\\"","solution":"def reverse_if_not_palindrome(s): Returns the reversed string if the input string is not a palindrome. If the input string is a palindrome, returns the original string. if s == s[::-1]: return s else: return s[::-1]"},{"question":"def get_min_divisor(arr: List[int], threshold: int) -> int: Determine the minimum integer value \`x\` such that the sum of dividing each element in the array by \`x\` and taking the ceiling of the result is less than or equal to the threshold. Example: >>> get_min_divisor([1, 2, 5, 9], 6) 5 >>> get_min_divisor([2, 3, 5, 7, 11], 11) 3","solution":"import math def get_min_divisor(arr, threshold): Returns the minimum integer value x such that the sum of the result of dividing each element in the array by x and taking the ceiling of the result is less than or equal to the threshold. def feasible(x): return sum(math.ceil(num / x) for num in arr) <= threshold left, right = 1, max(arr) while left <= right: mid = (left + right) // 2 if feasible(mid): right = mid - 1 else: left = mid + 1 return left"},{"question":"def max_pack_weight(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum weight that can be packed into the backpack without exceeding the weight limit for each test case. test_cases: List of tuples where each tuple contains an integer W (maximum weight capacity) and a list of integers representing the weights of the items. Returns a list of integers representing the maximum weight for each test case. >>> max_pack_weight([(10, [2, 3, 4, 5])]) [10] >>> max_pack_weight([(15, [3, 8, 4, 2, 6]), (7, [2, 1, 3, 4])]) [15, 7] from typing import List, Tuple def test_case_1(): test_cases = [(10, [2, 3, 4, 5])] assert max_pack_weight(test_cases) == [10] def test_case_2(): test_cases = [(15, [3, 8, 4, 2, 6])] assert max_pack_weight(test_cases) == [15] def test_case_3(): test_cases = [(7, [2, 1, 3, 4])] assert max_pack_weight(test_cases) == [7] def test_case_4(): test_cases = [(100, [50, 50, 50])] assert max_pack_weight(test_cases) == [100] def test_case_5(): test_cases = [(5, [5, 10])] assert max_pack_weight(test_cases) == [5] def test_case_6(): test_cases = [(20, [5, 7, 12, 18, 1])] assert max_pack_weight(test_cases) == [20] def test_multiple_cases(): test_cases = [(10, [2, 3, 4, 5]), (15, [3, 8, 4, 2, 6]), (7, [2, 1, 3, 4])] assert max_pack_weight(test_cases) == [10, 15, 7]","solution":"def knapsack(W, weights): Returns the maximum weight that can be packed into the backpack without exceeding the weight limit. Uses dynamic programming to solve the 0/1 Knapsack problem. n = len(weights) dp = [0] * (W + 1) for weight in weights: for w in range(W, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + weight) return dp[W] def max_pack_weight(test_cases): results = [] for W, weights in test_cases: results.append(knapsack(W, weights)) return results"},{"question":"def process_backspaces(s: str) -> str: Processes the string considering the '#' character as a backspace. Returns the resultant string after all backspace operations. >>> process_backspaces(\\"a#\\") == \\"\\" >>> process_backspaces(\\"abc#d\\") == \\"a\\" >>> process_backspaces(\\"ab#c\\") == \\"c\\" >>> process_backspaces(\\"abc\\") == \\"abc\\" >>> process_backspaces(\\"abc#\\") == \\"\\" >>> process_backspaces(\\"#abc\\") == \\"abc\\"","solution":"def process_backspaces(s): Processes the string considering the '#' character as a backspace. Returns the resultant string after all backspace operations. result = [] for char in s: if char == '#': if result: result.pop() else: result.append(char) return ''.join(result)"},{"question":"def unique_elements(lst): Returns a list of unique elements in the same order as they first appeared in the original list. >>> unique_elements([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> unique_elements([4, 5, 4, 6, 5, 7, 8]) [4, 5, 6, 7, 8] >>> unique_elements([]) [] >>> unique_elements([10]) [10] >>> unique_elements([9, 9, 9, 9, 9]) [9]","solution":"def unique_elements(lst): Returns a list of unique elements in the same order as they first appeared in the original list. seen = set() unique_lst = [] for element in lst: if element not in seen: seen.add(element) unique_lst.append(element) return unique_lst"},{"question":"def minimum_time_to_reach_galleries(n, m, passages): Returns the minimum time required to reach each gallery from gallery 0. If a gallery is not reachable from gallery 0, it is marked as -1. Parameters: n (int): The number of galleries. m (int): The number of passages. passages (List[Tuple[int, int, int]]): A list of passages where each passage is represented as a tuple (u, v, t) indicating there is a unidirectional passage from gallery u to gallery v that takes t time to traverse. Returns: List[int]: A list where the i-th integer is the minimum time required to reach gallery i from gallery 0. If gallery i is not reachable, the i-th integer is -1. >>> minimum_time_to_reach_galleries(5, 6, [(0, 1, 2), (0, 2, 4), (1, 2, 1), (1, 3, 7), (2, 4, 3), (3, 4, 1)]) [0, 2, 3, 9, 6] >>> minimum_time_to_reach_galleries(4, 4, [(0, 1, 5), (1, 2, 2), (2, 3, 1), (3, 1, 2)]) [0, 5, 7, 8]","solution":"import heapq def minimum_time_to_reach_galleries(n, m, passages): Returns the minimum time required to reach each gallery from gallery 0. If a gallery is not reachable from gallery 0, it is marked as -1. adj_list = {i: [] for i in range(n)} for u, v, t in passages: adj_list[u].append((v, t)) # Initialize distance array with infinity and set starting point to 0 dist = [float('inf')] * n dist[0] = 0 priority_queue = [(0, 0)] # (distance, node) while priority_queue: current_distance, u = heapq.heappop(priority_queue) if current_distance > dist[u]: continue # Update distances for adjacent nodes for v, travel_time in adj_list[u]: distance = current_distance + travel_time if distance < dist[v]: dist[v] = distance heapq.heappush(priority_queue, (distance, v)) # Replace unreachable distances with -1 for i in range(n): if dist[i] == float('inf'): dist[i] = -1 return dist"},{"question":"def find_pairs(arr, target): Takes an array of integers and a target integer, and returns an array of unique pairs (as sub-arrays) of integers from the input array that add up to the target. Each pair should be sorted in ascending order, and the outer array should not contain duplicate pairs. >>> find_pairs([2, 4, 3, 5, 6, -1, 7, 8, 3], 7) [[-1, 8], [2, 5], [3, 4]] >>> find_pairs([1, 2, 3, 4, 5, 6], 7) [[1, 6], [2, 5], [3, 4]] >>> find_pairs([1, 3, 5, -1, 2, 4], 4) [[-1, 5], [1, 3]] >>> find_pairs([1, 1, 1, 1], 2) [[1, 1]] >>> find_pairs([], 5) [] >>> find_pairs([0, 0, 0, 0], 0) [[0, 0]] >>> find_pairs([1, -1, 0, 2, 2, 3], 2) [[-1, 3], [0, 2]]","solution":"def find_pairs(arr, target): Finds all unique pairs in an array that sum up to the target value. Parameters: arr (list): List of integers target (int): Target sum for the pairs Returns: list: List of unique pairs (sub-arrays) sorted in ascending order seen = set() pairs = set() for num in arr: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return [list(pair) for pair in sorted(pairs)] # Example usage: # print(find_pairs([2, 4, 3, 5, 6, -1, 7, 8, 3], 7)) # Output: [[-1, 8], [2, 5], [3, 4]]"},{"question":"from typing import List, Tuple def maximize_value(items: List[Tuple[int, int]], max_cost: int) -> int: Write a function that takes a list of tuples and a single integer as input. Each tuple consists of two integers, representing the cost and value of an item. The function should find and return the maximum total value of items that can be chosen such that their combined cost is less than or equal to the given integer. Each item can only be chosen once. >>> maximize_value([(4, 6), (2, 4), (6, 7), (5, 10)], 8) 14 >>> maximize_value([], 10) 0 >>> maximize_value([(3, 5)], 3) 5 >>> maximize_value([(4, 6)], 3) 0 >>> maximize_value([(1, 1), (2, 2), (3, 3), (8, 8)], 6) 6 >>> maximize_value([(1, 1), (2, 2), (5, 9)], 4) 3 >>> maximize_value([(3, 4), (3, 5)], 3) 5","solution":"from typing import List, Tuple def maximize_value(items: List[Tuple[int, int]], max_cost: int) -> int: # Initialize a table to store the maximum value at each cost level dp = [0] * (max_cost + 1) # Loop over each item for cost, value in items: # Traverse the dp array from right to left for current_cost in range(max_cost, cost - 1, -1): if current_cost >= cost: dp[current_cost] = max(dp[current_cost], dp[current_cost - cost] + value) return dp[max_cost]"},{"question":"def areIsomorphic(s1: str, s2: str) -> str: Determines if two strings s1 and s2 are isomorphic. >>> areIsomorphic(\\"paper\\", \\"title\\") 'Isomorphic' >>> areIsomorphic(\\"foo\\", \\"bar\\") 'Not Isomorphic' >>> areIsomorphic(\\"egg\\", \\"add\\") 'Isomorphic' >>> areIsomorphic(\\"ab\\", \\"aa\\") 'Not Isomorphic' >>> areIsomorphic(\\"abc\\", \\"de\\") 'Not Isomorphic' >>> areIsomorphic(\\"\\", \\"\\") 'Isomorphic' >>> areIsomorphic(\\"a\\", \\"b\\") 'Isomorphic' >>> areIsomorphic(\\"a\\", \\"a\\") 'Isomorphic'","solution":"def areIsomorphic(s1, s2): Determines if two strings s1 and s2 are isomorphic. if len(s1) != len(s2): return \\"Not Isomorphic\\" mapping_s1_to_s2 = {} mapping_s2_to_s1 = {} for c1, c2 in zip(s1, s2): if c1 in mapping_s1_to_s2: if mapping_s1_to_s2[c1] != c2: return \\"Not Isomorphic\\" if c2 in mapping_s2_to_s1: if mapping_s2_to_s1[c2] != c1: return \\"Not Isomorphic\\" mapping_s1_to_s2[c1] = c2 mapping_s2_to_s1[c2] = c1 return \\"Isomorphic\\""},{"question":"def arrange_trees(n: int) -> int: Returns the minimum number of trees needed in a square field of size n x n, such that each row and each column contains an even number of trees. Parameters: n (int): Size of the square field (odd integer between 3 and 99) Returns: int: Minimum number of trees required >>> arrange_trees(3) 3 >>> arrange_trees(5) 5 >>> arrange_trees(7) 7 >>> arrange_trees(9) 9 >>> arrange_trees(99) 99","solution":"def arrange_trees(n): Returns the minimum number of trees needed in a square field of size n x n, such that each row and each column contains an even number of trees. Parameters: n (int): Size of the square field (odd integer between 3 and 99) Returns: int: Minimum number of trees required if n % 2 == 1: return n return n - 1 # should never reach here as n is always odd as per constraints"},{"question":"def max_sum_of_subarray(n: int, k: int, heights: List[int]) -> int: Returns the maximum sum of a subarray of length k for the optimal arrangement of flowers. :param n: int : number of flowers :param k: int : length of subarray :param heights: list of int : heights of the flowers :return: int : maximum sum of subarray of length k >>> max_sum_of_subarray(5, 3, [1, 3, 2, 5, 4]) 12 >>> max_sum_of_subarray(5, 1, [1, 3, 2, 5, 4]) 5 >>> max_sum_of_subarray(4, 4, [1, 2, 3, 4]) 10 >>> max_sum_of_subarray(5, 3, [2, 2, 2, 2, 2]) 6 >>> max_sum_of_subarray(4, 2, [1, 10, 5, 4]) 15 >>> max_sum_of_subarray(100000, 3, list(range(1, 100001))) 299997","solution":"def max_sum_of_subarray(n, k, heights): Returns the maximum sum of a subarray of length k for the optimal arrangement of flowers. :param n: int : number of flowers :param k: int : length of subarray :param heights: list of int : heights of the flowers :return: int : maximum sum of subarray of length k # Sort the heights in non-decreasing order heights.sort() # The subarray with the maximum sum will be the last k elements return sum(heights[-k:])"},{"question":"def find_longest_palindrome(listOfStrings): Find the longest palindromic substring within each string in a list of strings. Returns a list of dictionaries with the original string, the length of the longest palindromic substring, and the substring itself. >>> listOfStrings1 = [\\"babad\\", \\"cbbd\\", \\"a\\", \\"ac\\"] >>> find_longest_palindrome(listOfStrings1) [{'input': 'babad', 'length': 3, 'substring': 'bab'}, {'input': 'cbbd', 'length': 2, 'substring': 'bb'}, {'input': 'a', 'length': 1, 'substring': 'a'}, {'input': 'ac', 'length': 1, 'substring': 'a'}] >>> listOfStrings2 = [\\"racecar\\", \\"noon\\", \\"banana\\"] >>> find_longest_palindrome(listOfStrings2) [{'input': 'racecar', 'length': 7, 'substring': 'racecar'}, {'input': 'noon', 'length': 4, 'substring': 'noon'}, {'input': 'banana', 'length': 5, 'substring': 'anana'}]","solution":"def find_longest_palindrome(listOfStrings): def longest_palindromic_substring(s): n = len(s) if n == 0: return {\\"input\\": s, \\"length\\": 0, \\"substring\\": \\"\\"} longest = \\"\\" for i in range(n): # Check for odd-length palindromes tmp = expand_from_center(s, i, i) if len(tmp) > len(longest): longest = tmp # Check for even-length palindromes tmp = expand_from_center(s, i, i+1) if len(tmp) > len(longest): longest = tmp return {\\"input\\": s, \\"length\\": len(longest), \\"substring\\": longest} def expand_from_center(s, l, r): while l >= 0 and r < len(s) and s[l] == s[r]: l -= 1 r += 1 return s[l+1:r] return [longest_palindromic_substring(s) for s in listOfStrings]"},{"question":"def sum_of_diagonals(matrix: List[List[int]]) -> int: Given a matrix of size n x n filled with distinct integers, returns the sum of both diagonals of the matrix. The middle element (if n is odd) is counted only once. >>> sum_of_diagonals([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 25 >>> sum_of_diagonals([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == 68 >>> sum_of_diagonals([[42]]) == 42 >>> sum_of_diagonals([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) == -25 >>> sum_of_diagonals([[1, -2, 3], [-4, 5, -6], [7, -8, 9]]) == 25","solution":"def sum_of_diagonals(matrix): Given a matrix of size n x n filled with distinct integers, returns the sum of both diagonals of the matrix. The middle element (if n is odd) is counted only once. n = len(matrix) primary_diagonal_sum = sum(matrix[i][i] for i in range(n)) secondary_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n)) if n % 2 == 1: middle_element = matrix[n // 2][n // 2] return primary_diagonal_sum + secondary_diagonal_sum - middle_element else: return primary_diagonal_sum + secondary_diagonal_sum"},{"question":"from typing import List from collections import Counter def can_form_circular(arrangement: List[str]) -> str: Determines if a circular arrangement of strings is possible such that the last character of each string matches the first character of the next string. :param arrangement: List of strings :return: 'YES' if a circular arrangement is possible, otherwise 'NO' Examples: >>> can_form_circular(['abc', 'cde', 'efg']) 'NO' >>> can_form_circular(['aaa', 'aaa', 'aaa', 'aaa']) 'YES' >>> can_form_circular(['ab', 'bc', 'cd', 'da', 'ef']) 'NO' >>> can_form_circular(['xyz']) 'YES'","solution":"from collections import Counter def can_form_circular(arrangement): Function to determine if a circular arrangement of strings is possible. :param arrangement: list of strings :return: 'YES' if a circular arrangement is possible; otherwise 'NO' if len(arrangement) == 1: return \\"YES\\" start_counter = Counter() end_counter = Counter() for string in arrangement: start_counter[string[0]] += 1 end_counter[string[-1]] += 1 if start_counter == end_counter: return \\"YES\\" else: return \\"NO\\""},{"question":"def isPalindrome(s: str) -> bool: Determine whether a given string is a palindrome. :param s: Input string to check. :return: True if the string is a palindrome, False otherwise. >>> isPalindrome(\\"A man, a plan, a canal, Panama\\") True >>> isPalindrome(\\"No lemon, no melon\\") True >>> isPalindrome(\\"Was it a car or a cat I saw?\\") True >>> isPalindrome(\\"hello\\") False >>> isPalindrome(\\"\\") True >>> isPalindrome(\\"12321\\") True >>> isPalindrome(\\"123456\\") False >>> isPalindrome(\\"race car\\") True >>> isPalindrome(\\"Madam, in Eden, I'm Adam\\") True >>> isPalindrome(\\"a\\") True >>> isPalindrome(\\"A\\") True >>> isPalindrome(\\"1\\") True","solution":"def isPalindrome(s: str) -> bool: Determine whether a given string is a palindrome. :param s: Input string to check. :return: True if the string is a palindrome, False otherwise. # Remove non-alphanumeric characters and convert to lowercase filtered_string = ''.join(char.lower() for char in s if char.isalnum()) # Check if the filtered string is equal to its reverse return filtered_string == filtered_string[::-1]"},{"question":"def dailyTemperatures(temperatures): Given a list of integers representing daily temperatures, returns a list where each entry i corresponds to the number of days until a warmer temperature occurs for day i. Examples: >>> dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> dailyTemperatures([30, 40, 50, 60]) [1, 1, 1, 0] >>> dailyTemperatures([30, 60, 90]) [1, 1, 0]","solution":"def dailyTemperatures(temperatures): Returns a list where each entry i corresponds to the number of days until a warmer temperature occurs for day i. n = len(temperatures) answer = [0] * n stack = [] # this will store indices of the temperatures array for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: idx = stack.pop() answer[idx] = i - idx stack.append(i) return answer"},{"question":"def rot13(s: str) -> str: Applies the ROT13 cipher to a given string. Parameters: s (str): Input string containing lowercase alphabetic characters. Returns: str: A new string with each character replaced by the character occurring 13 positions after it in the alphabet. >>> rot13(\\"hello\\") \\"uryyb\\" >>> rot13(\\"uryyb\\") \\"hello\\" >>> rot13(\\"hello world!\\") \\"uryyb jbeyq!\\" >>> rot13(\\"lbh penpxrq gur pbqr\\") \\"you cracked the code\\"","solution":"def rot13(s): Applies the ROT13 cipher to a given string. Parameters: s (str): Input string containing lowercase alphabetic characters. Returns: str: A new string with each character replaced by the character occurring 13 positions after it in the alphabet. result = [] for char in s: if 'a' <= char <= 'z': shifted = (ord(char) - ord('a') + 13) % 26 + ord('a') result.append(chr(shifted)) else: result.append(char) return ''.join(result)"},{"question":"def secure_message(message: str, key: str) -> str: Encrypt the message using XOR cipher with the provided key and then create a digital signature by reversing the encrypted message. Return the concatenated encrypted message and its signature. :param message: str - plaintext message to be encrypted :param key: str - key used for XOR encryption :return: str - concatenated encrypted message and its digital signature >>> secure_message(\\"hello\\", \\"secret\\") 'x1bx02x0cx07x02x02x07x0cx02x1b' >>> secure_message(\\"abcdef\\", \\"xy\\") 'x19x1bx1b1ax1ax1dx1dx1ax1ax1bx1bx19' >>> secure_message(\\"key\\", \\"key\\") 'x00x00x00x00x00x00' >>> secure_message(\\"a\\", \\"abc\\") 'x00x00' >>> secure_message(\\"short\\", \\"averyverylongkey\\") 'x12x06x18x05x1dx1dx05x18x06x12'","solution":"def secure_message(message: str, key: str) -> str: Encrypt the message using XOR cipher with the provided key and then create a digital signature by reversing the encrypted message. Return the concatenated encrypted message and its signature. :param message: str - plaintext message to be encrypted :param key: str - key used for XOR encryption :return: str - concatenated encrypted message and its digital signature encrypted_chars = [] # XOR encryption key_len = len(key) for i, char in enumerate(message): encrypted_char = chr(ord(char) ^ ord(key[i % key_len])) encrypted_chars.append(encrypted_char) encrypted_message = ''.join(encrypted_chars) signature = encrypted_message[::-1] return encrypted_message + signature"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters for the input string s. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"aab\\") 2 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"au\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3 def process_input(T: int, strings: list) -> list: Processes multiple strings to find the length of the longest substring without repeating characters for each string. >>> process_input(3, [\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\"]) [3, 1, 3] >>> process_input(2, [\\"aab\\", \\"\\"]) [2, 0] >>> process_input(1, [\\"a\\"]) [1]","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters for the input string s. n = len(s) seen = {} max_length = 0 start = 0 for end in range(n): if s[end] in seen: start = max(start, seen[s[end]] + 1) seen[s[end]] = end max_length = max(max_length, end - start + 1) return max_length def process_input(T: int, strings: list) -> list: Processes multiple strings to find the length of the longest substring without repeating characters for each string. results = [] for s in strings: results.append(length_of_longest_substring(s)) return results"},{"question":"def concat_and_sum_digits(arr): Concatenates two positive integers in the array and returns the sum of their digits. If any element in the array is not a positive integer, returns \\"invalid array\\". >>> concat_and_sum_digits([123, 456]) 21 >>> concat_and_sum_digits([98, 76]) 30 >>> concat_and_sum_digits([5, 5]) 10 >>> concat_and_sum_digits([123, 'abc']) \\"invalid array\\" >>> concat_and_sum_digits([-123, 456]) \\"invalid array\\"","solution":"def concat_and_sum_digits(arr): Concatenates two positive integers in the array and returns the sum of their digits. If any element in the array is not a positive integer, returns \\"invalid array\\". # Check if the array contains exactly two elements if len(arr) != 2: return \\"invalid array\\" # Check if both elements are positive integers if not all(isinstance(x, int) and x > 0 for x in arr): return \\"invalid array\\" # Concatenate the two numbers into one string concatenated_number = ''.join(map(str, arr)) # Calculate the sum of the digits digit_sum = sum(int(digit) for digit in concatenated_number) return digit_sum"},{"question":"def max_happiness(events): Determine the maximum possible happiness value you can achieve if you are allowed to attend as many events as you want, but you cannot attend two events that overlap in time. pass def process_input(data): Process the input data and return the maximum happiness for each dataset. >>> process_input([\\"3\\", \\"60 120 100\\", \\"180 240 200\\", \\"150 210 150\\", \\"3\\", \\"120 180 50\\", \\"180 240 100\\", \\"300 360 150\\", \\"0\\"]) [300, 300] >>> process_input([\\"1\\", \\"0 60 100\\", \\"0\\"]) [100] >>> process_input([\\"0\\"]) [] pass # Example test case if __name__ == '__main__': input_data = [ \\"3\\", \\"60 120 100\\", \\"180 240 200\\", \\"150 210 150\\", \\"3\\", \\"120 180 50\\", \\"180 240 100\\", \\"300 360 150\\", \\"0\\" ] print(process_input(input_data))","solution":"def max_happiness(events): # Sort events based on their end times events.sort(key=lambda x: x[1]) # Initialize dp array where dp[i] will store the maximum happiness # value till the i-th event n = len(events) dp = [0] * n dp[0] = events[0][2] for i in range(1, n): # Find maximum happiness not including the current event dp[i] = max(dp[i-1], events[i][2]) # Try to include this event and find the maximum happiness for j in range(i-1, -1, -1): if events[j][1] <= events[i][0]: dp[i] = max(dp[i], dp[j] + events[i][2]) break return max(dp) def process_input(data): results = [] idx = 0 while idx < len(data): n = int(data[idx]) if n == 0: break events = [] idx += 1 for _ in range(n): events.append(list(map(int, data[idx].split()))) idx += 1 results.append(max_happiness(events)) return results"},{"question":"def max_subsequence_sum(N: int, sequence: List[int]) -> int: Finds the maximum possible sum of subsequences where: - subsequences must be contiguous - subsequences can be all positive, all negative, or a combination of both. Args: N: int, length of the sequence sequence: list of int, the sequence of numbers Returns: int, the maximum sum of such subsequences. >>> max_subsequence_sum(6, [1, 2, -3, 4, 5, -6]) 9 >>> max_subsequence_sum(5, [-1, -2, -3, -4, -5]) -1","solution":"def max_subsequence_sum(N, sequence): Finds the maximum possible sum of subsequences where: - subsequences must be contiguous - subsequences can be all positive, all negative, or a combination of both. Args: N: int, length of the sequence sequence: list of int, the sequence of numbers Returns: int, the maximum sum of such subsequences. # Initialize variables to keep track of the max sum and the current sum max_sum = sequence[0] current_sum = sequence[0] for i in range(1, N): current_sum = max(sequence[i], current_sum + sequence[i]) if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def count_arithmetic_sequences(n, k): Computes the number of distinct arithmetic sequences of length n that can be formed using integers from 1 to k. >>> count_arithmetic_sequences(2, 3) 6 >>> count_arithmetic_sequences(3, 4) 10","solution":"def count_arithmetic_sequences(n, k): Computes the number of distinct arithmetic sequences of length n that can be formed using integers from 1 to k. # Total possible sequences are determined by choosing any k starting points and # constructing sequences of length n where each step is non-decreasing. return k * (k + 1) // 2"},{"question":"def minDaysToCompleteTasks(tasks, d): Determine the minimum number of days required to complete all the tasks, with the constraint that no more than \`d\` hours can be spent working on tasks each day. Arguments: tasks -- list of integers representing the amount of time required to complete each task d -- maximum number of hours that can be spent working on tasks each day Returns: int -- the minimum number of days required to complete all tasks Examples: >>> minDaysToCompleteTasks([4, 3, 2, 1], 5) 2 >>> minDaysToCompleteTasks([10, 3, 7], 10) 2 >>> minDaysToCompleteTasks([8, 2, 2, 6, 3, 3, 2], 8) 4 from solution import minDaysToCompleteTasks def test_minDaysToCompleteTasks_example1(): assert minDaysToCompleteTasks([4, 3, 2, 1], 5) == 2 def test_minDaysToCompleteTasks_example2(): assert minDaysToCompleteTasks([10, 3, 7], 10) == 2 def test_minDaysToCompleteTasks_example3(): assert minDaysToCompleteTasks([8, 2, 2, 6, 3, 3, 2], 8) == 4 def test_minDaysToCompleteTasks_all_same_time(): assert minDaysToCompleteTasks([2, 2, 2, 2, 2], 2) == 5 def test_minDaysToCompleteTasks_all_within_one_day(): assert minDaysToCompleteTasks([1, 2, 3, 4], 10) == 1 def test_minDaysToCompleteTasks_single_task(): assert minDaysToCompleteTasks([5], 5) == 1 assert minDaysToCompleteTasks([5], 10) == 1 def test_minDaysToCompleteTasks_high_duration_limit(): assert minDaysToCompleteTasks([4, 4, 4, 4, 4], 20) == 1 assert minDaysToCompleteTasks([4, 4, 4, 4], 24) == 1","solution":"def minDaysToCompleteTasks(tasks, d): Returns the minimum number of days required to complete the tasks given the constraint that no more than d hours can be spent each day. # Sort the tasks in descending order tasks.sort(reverse=True) days = 0 while tasks: total_daily_time = 0 # Keep adding tasks to the day while the total remains within the daily limit d for i, task in enumerate(tasks): if total_daily_time + task <= d: total_daily_time += task tasks[i] = 0 # Mark this task as done # Remove completed tasks marked as 0 tasks = [task for task in tasks if task > 0] days += 1 # Increment the days count return days"},{"question":"def first_greater(arr): Finds the first integer in the list which is greater than all of its preceding integers. Returns -1 if there is no such integer. >>> first_greater([1, 2, 3, 0, 4]) == 2 >>> first_greater([5, 4, 3, 2, 1]) == -1 >>> first_greater([1, 2, 3, 4, 5]) == 2 >>> first_greater([10]) == -1 >>> first_greater([]) == -1 >>> first_greater([10, 9, 8, 7]) == -1 >>> first_greater([-1000000000, 1000000000]) == 1000000000 >>> first_greater([5, 5, 5, 5, 5]) == -1 >>> first_greater([3, 1, 4, 1, 5, 9, 2, 6, 5]) == 4","solution":"def first_greater(arr): Finds the first integer in the list which is greater than all of its preceding integers. Returns -1 if there is no such integer. :param arr: List of integers :return: First integer greater than all its preceding integers, or -1 if none exists if not arr: return -1 max_so_far = float('-inf') for i in range(1, len(arr)): if arr[i] > max_so_far: max_so_far = arr[i - 1] if arr[i] > max_so_far: return arr[i] return -1"},{"question":"def is_power_of_two(n: int) -> str: Determine whether the given integer n is a power of two. >>> is_power_of_two(1) \\"YES\\" >>> is_power_of_two(2) \\"YES\\" >>> is_power_of_two(3) \\"NO\\" >>> is_power_of_two(4) \\"YES\\" >>> is_power_of_two(5) \\"NO\\" >>> is_power_of_two(8) \\"YES\\" >>> is_power_of_two(14) \\"NO\\"","solution":"def is_power_of_two(n): Determines whether the given integer n is a power of two. Parameters: n (int): A positive integer (1 ≤ n ≤ 106). Returns: str: \\"YES\\" if n is a power of two, \\"NO\\" otherwise. # A number is a power of two if n > 0 and (n & (n - 1)) == 0 if n > 0 and (n & (n - 1)) == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def is_possible(n, k, trails): Determine if it is possible to select one or more consecutive trails from the list such that their total length is exactly 'K' meters. >>> is_possible(5, 15, [1, 2, 3, 4, 5]) \\"POSSIBLE\\" >>> is_possible(4, 10, [5, 6, 1, 2]) \\"IMPOSSIBLE\\" def process_cases(test_cases): Process multiple test cases to determine if the jogging event can be organized successfully. >>> process_cases([(5, 15, [1, 2, 3, 4, 5]), (4, 10, [5, 6, 1, 2])]) [\\"POSSIBLE\\", \\"IMPOSSIBLE\\"]","solution":"def is_possible(n, k, trails): for i in range(n): current_sum = 0 for j in range(i, n): current_sum += trails[j] if current_sum == k: return \\"POSSIBLE\\" if current_sum > k: break return \\"IMPOSSIBLE\\" def process_cases(test_cases): results = [] for case in test_cases: n, k, trails = case result = is_possible(n, k, trails) results.append(result) return results"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string s consisting of only lowercase English letters, find the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"aab\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"anviaj\\") 5 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"aaaaaa\\") 1 >>> length_of_longest_substring(\\"abcdabcde\\") 5 >>> length_of_longest_substring(\\"abcabcbbabcabcbb\\") 3","solution":"def length_of_longest_substring(s): Given a string s consisting of only lowercase English letters, finds the length of the longest substring without repeating characters. :param s: String input :return: Length of the longest substring without repeating characters n = len(s) if n == 0: return 0 char_index_map = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List def find_shortest_distance(words: List[str], word1: str, word2: str) -> int: Finds the shortest distance between word1 and word2 in the list of words. >>> find_shortest_distance([\\"practice\\", \\"makes\\", \\"perfect\\", \\"coding\\", \\"makes\\"], \\"coding\\", \\"practice\\") 3 >>> find_shortest_distance([\\"practice\\", \\"makes\\", \\"perfect\\", \\"coding\\", \\"makes\\"], \\"makes\\", \\"coding\\") 1 >>> find_shortest_distance([\\"a\\", \\"c\\", \\"b\\", \\"a\\", \\"b\\", \\"c\\"], \\"a\\", \\"b\\") 1 >>> find_shortest_distance([\\"practice\\", \\"makes\\", \\"perfect\\", \\"coding\\", \\"makes\\"], \\"makes\\", \\"perfect\\") 1 >>> find_shortest_distance([\\"the\\", \\"quick\\", \\"brown\\", \\"fox\\", \\"jumps\\", \\"over\\", \\"the\\", \\"lazy\\", \\"dog\\", \\"the\\", \\"quick\\"], \\"the\\", \\"quick\\") 1 >>> find_shortest_distance([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"elderberry\\", \\"fig\\", \\"grape\\"], \\"apple\\", \\"grape\\") 6","solution":"from typing import List def find_shortest_distance(words: List[str], word1: str, word2: str) -> int: Finds the shortest distance between word1 and word2 in the list of words. index1, index2 = -1, -1 min_distance = float('inf') for i, word in enumerate(words): if word == word1: index1 = i elif word == word2: index2 = i if index1 != -1 and index2 != -1: min_distance = min(min_distance, abs(index1 - index2)) return min_distance"},{"question":"def minimizeDifference(nums: List[int], k: int) -> List[int]: Rearrange the array in a manner where the average difference between adjacent elements is minimized. >>> minimizeDifference([1, 3, 7, 8, 5], 5) [1, 3, 5, 7, 8] >>> minimizeDifference([4, 2, 9, 11, 5, 10], 6) [2, 4, 5, 9, 10, 11]","solution":"def minimizeDifference(nums, k): Rearranges the array \`nums\` to minimize the average difference between adjacent elements. # Sorting the array minimizes the average difference between adjacent elements. return sorted(nums) # Example usage: # nums = [4, 2, 9, 11, 5, 10] # k = 6 # print(minimizeDifference(nums, k)) # Output: [2, 4, 5, 9, 10, 11]"},{"question":"def minimum_total_travel_cost(n, d): Returns the minimum total travel cost to conduct all the matches in the league. Args: n : int : number of teams d : list[list[int]] : 2D matrix representing travel cost between teams Returns: int : minimum total travel cost Example: >>> minimum_total_travel_cost(3, [ ... [0, 10, 15], ... [10, 0, 20], ... [15, 20, 0] ... ]) 90 >>> minimum_total_travel_cost(2, [ ... [0, 5], ... [5, 0] ... ]) 10","solution":"def minimum_total_travel_cost(n, d): Returns the minimum total travel cost to conduct all the matches in the league. Args: n : int : number of teams d : list[list[int]] : 2D matrix representing travel cost between teams Returns: int : minimum total travel cost total_cost = 0 # All teams play once against every other team for i in range(n): for j in range(i + 1, n): total_cost += 2 * d[i][j] return total_cost"},{"question":"def process_operations(n: int, q: int, array: List[int], operations: List[List[int]]) -> List[int]: Process a series of update and query operations on an array. Parameters: n (int): Size of the array. q (int): Number of operations. array (List[int]): The initial array. operations (List[List[int]]): List of operations where each operation is either: - [1, i, x]: Update the value at index i to x. - [2, l, r]: Query the sum of the subarray from index l to r. Returns: List[int]: The results of all the query operations. Example: >>> n = 5 >>> q = 4 >>> array = [1, 3, 5, 7, 9] >>> operations = [[2, 1, 3], [1, 2, 10], [2, 2, 4], [2, 1, 5]] >>> process_operations(n, q, array, operations) [9, 22, 32] >>> n = 5 >>> q = 2 >>> array = [2, 4, 6, 8, 10] >>> operations = [[2, 1, 3], [1, 3, 15]] >>> process_operations(n, q, array, operations) [12] >>> n = 6 >>> q = 5 >>> array = [5, 7, 9, 11, 13, 15] >>> operations = [[2, 1, 3], [1, 1, 10], [2, 1, 3], [1, 6, 20], [2, 6, 6]] >>> process_operations(n, q, array, operations) [21, 26, 20] >>> n = 4 >>> q = 1 >>> array = [3, 6, 9, 12] >>> operations = [[1, 4, 12]] >>> process_operations(n, q, array, operations) [] >>> n = 3 >>> q = 0 >>> array = [5, 10, 15] >>> operations = [] >>> process_operations(n, q, array, operations) []","solution":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, delta): while index <= self.size: self.tree[index] += delta index += index & -index def prefix_sum(self, index): result = 0 while index > 0: result += self.tree[index] index -= index & -index return result def process_operations(n, q, array, operations): fenwick_tree = FenwickTree(n) results = [] # Initialize Fenwick Tree with initial array values for i in range(1, n + 1): fenwick_tree.update(i, array[i - 1]) for operation in operations: if operation[0] == 1: # Update operation: (1 i x) - Updating index i to value x _, i, x = operation current_value = array[i - 1] delta = x - current_value array[i - 1] = x fenwick_tree.update(i, delta) elif operation[0] == 2: # Query operation: (2 l r) - Sum of subarray from index l to r _, l, r = operation sum_r = fenwick_tree.prefix_sum(r) sum_l_minus_1 = fenwick_tree.prefix_sum(l - 1) results.append(sum_r - sum_l_minus_1) return results"},{"question":"def smallest_supersequence(strings: List[str]) -> str: Given an array of strings, find the smallest string that contains each string in the array as a subsequence. >>> smallest_supersequence([\\"abc\\", \\"bc\\", \\"ac\\"]) \\"abc\\" >>> smallest_supersequence([\\"abcd\\"]) \\"abcd\\" >>> smallest_supersequence([\\"a\\", \\"b\\", \\"c\\"]) \\"abc\\" >>> smallest_supersequence([\\"abcd\\", \\"bcdf\\", \\"ace\\"]) \\"abcdef\\" >>> smallest_supersequence([\\"abc\\", \\"abc\\", \\"abc\\"]) \\"abc\\" >>> smallest_supersequence([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"]) \\"abcd\\"","solution":"def smallest_supersequence(strings): Given an array of strings, find the smallest string that contains each string in the array as a subsequence. from itertools import permutations # Function to check if s2 is a subsequence of s1 def is_subsequence(s1, s2): it = iter(s1) return all(c in it for c in s2) # Generate all permutations of the given strings all_permutations = permutations(strings) # Initialize the smallest supersequence to a large number smallest_supersequence = None # Find the smallest lexicographical supersequence from all permutations for perm in all_permutations: current_supersequence = perm[0] for s in perm[1:]: # Append characters to make 'current_supersequence' a supersequence of 's' i = 0 for c in s: while i < len(current_supersequence) and current_supersequence[i] != c: i += 1 if i == len(current_supersequence): current_supersequence += c else: i += 1 # Check if the current supersequence is smaller or lexicographically smaller if smallest_supersequence is None or len(current_supersequence) < len(smallest_supersequence) or ( len(current_supersequence) == len(smallest_supersequence) and current_supersequence < smallest_supersequence): smallest_supersequence = current_supersequence return smallest_supersequence"},{"question":"from typing import List def distinct_gears(serials: List[str]) -> int: Determine how many distinct gears there are given a list of serial numbers, considering that the characters 'a', 'b', and 'c' can be reassigned to each other. >>> distinct_gears([\\"abc\\", \\"bca\\", \\"cab\\", \\"aaa\\", \\"bbb\\", \\"ccc\\"]) 2 >>> distinct_gears([\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"]) 1","solution":"def distinct_gears(serials): from itertools import permutations def generate_permutations(s): perms = set() perm = list(permutations('abc')) for p in perm: trans = str.maketrans('abc', ''.join(p)) perms.add(s.translate(trans)) return perms distinct_set = set() for serial in serials: forms = generate_permutations(serial) distinct_set.add(frozenset(forms)) return len(distinct_set)"},{"question":"from typing import List def find_possible_moves(board: List[str]) -> List[str]: Determine which moves the snake can make without going off the board. Each string in the board list represents a row of the board. 'S' is the snake's head, and '.' is an empty cell the snake can move into. Return the list of possible moves: \\"UP\\", \\"DOWN\\", \\"LEFT\\", \\"RIGHT\\". Example: >>> find_possible_moves([ ... \\".......\\", ... \\".S.....\\", ... \\".......\\" ... ]) [\\"UP\\", \\"DOWN\\", \\"LEFT\\", \\"RIGHT\\"] >>> find_possible_moves([ ... \\"S......\\", ... \\".......\\", ... \\".......\\" ... ]) [\\"DOWN\\", \\"RIGHT\\"]","solution":"from typing import List def find_possible_moves(board: List[str]) -> List[str]: rows = len(board) cols = len(board[0]) if rows > 0 else 0 # Find the snake's head position for r in range(rows): for c in range(cols): if board[r][c] == 'S': snake_row, snake_col = r, c break moves = [] if snake_row > 0 and board[snake_row - 1][snake_col] == '.': moves.append(\\"UP\\") if snake_row < rows - 1 and board[snake_row + 1][snake_col] == '.': moves.append(\\"DOWN\\") if snake_col > 0 and board[snake_row][snake_col - 1] == '.': moves.append(\\"LEFT\\") if snake_col < cols - 1 and board[snake_row][snake_col + 1] == '.': moves.append(\\"RIGHT\\") return moves"},{"question":"from typing import List def shortest_path(R: int, C: int, grid: List[str]) -> int: Determine the length of the shortest path from the top-left to the bottom-right corner in a grid, or return -1 if no such path exists. >>> shortest_path(5, 5, ['.', '.#..#', '.#.#.', '.#..#', '.']) == -1 True >>> shortest_path(3, 4, ['....', '..', '....']) == 6 True >>> shortest_path(2, 2, ['.#', '.#']) == -1 True >>> shortest_path(1, 1, ['.']) == 1 True >>> shortest_path(4, 4, ['....', '..', '....', '..']) == 7 True pass def test_shortest_path_no_path(): R, C = 5, 5 grid = [ \\".\\", \\".#..#\\", \\".#.#.\\", \\".#..#\\", \\".\\", ] assert shortest_path(R, C, grid) == -1 def test_shortest_path_has_path(): R, C = 3, 4 grid = [ \\"....\\", \\"..\\", \\"....\\", ] assert shortest_path(R, C, grid) == 6 def test_shortest_path_blocked_start_or_end(): R, C = 2, 2 grid = [ \\".#\\", \\".#\\", ] assert shortest_path(R, C, grid) == -1 def test_shortest_path_single_cell_open(): R, C = 1, 1 grid = [ \\".\\", ] assert shortest_path(R, C, grid) == 1 def test_shortest_path_large(): R, C = 4, 4 grid = [ \\"....\\", \\"..\\", \\"....\\", \\"..\\", ] assert shortest_path(R, C, grid) == 7","solution":"from collections import deque def shortest_path(R, C, grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner in a grid, or -1 if no such path exists. # Directions for moving up, down, left, right. directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Check if the start or the end positions are blocked if grid[0][0] == '#' or grid[R-1][C-1] == '#': return -1 # BFS initialization queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() # If we've reached the end if r == R - 1 and c == C - 1: return dist + 1 # Explore the neighbors for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < R and 0 <= nc < C and (nr, nc) not in visited and grid[nr][nc] == '.': queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1 # Input reading if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() R = int(data[0]) C = int(data[1]) grid = [] index = 2 for i in range(R): grid.append(data[index]) index += 1 print(shortest_path(R, C, grid))"},{"question":"def increment_elements(lst, n): Increment each element of the list lst by n. Parameters: lst (list of int): The list of integers to increment. n (int): The value to add to each element of the list. Returns: list of int: A new list where each element of lst is incremented by n. >>> increment_elements([1, 2, 3], 2) [3, 4, 5] >>> increment_elements([4, 5, 6], -2) [2, 3, 4] >>> increment_elements([], 5) [] >>> increment_elements([7, 8, 9], 0) [7, 8, 9] >>> increment_elements([-1, 0, 1], 3) [2, 3, 4]","solution":"def increment_elements(lst, n): Increment each element of the list lst by n. Parameters: lst (list of int): The list of integers to increment. n (int): The value to add to each element of the list. Returns: list of int: A new list where each element of lst is incremented by n. return [x + n for x in lst]"},{"question":"def can_form_tree(n: int, e: int, bridges: List[List[int]]) -> str: Determines whether it is possible to connect all islands such that there is exactly one distinct path between any pair of islands (forming a tree) by removing some bridges. Args: n (int): Number of islands. e (int): Number of bridges. bridges (list of list of int): List of bridges where each bridge is represented by a pair [u, v]. Returns: str: 'Yes' if it is possible to form a tree structure, otherwise 'No'. >>> can_form_tree(5, 5, [[1, 2], [1, 3], [3, 4], [4, 5], [2, 5]]) 'Yes' >>> can_form_tree(5, 3, [[1, 2], [2, 3], [3, 4]]) 'No' >>> can_form_tree(4, 3, [[1, 2], [2, 3], [3, 4]]) 'Yes' >>> can_form_tree(4, 5, [[1, 2], [2, 3], [3, 4], [1, 3], [2, 4]]) 'Yes' >>> can_form_tree(4, 2, [[1, 2], [3, 4]]) 'No'","solution":"def can_form_tree(n, e, bridges): Determines whether it is possible to connect all islands such that there is exactly one distinct path between any pair of islands (forming a tree) by removing some bridges. Args: n (int): Number of islands. e (int): Number of bridges. bridges (list of list of int): List of bridges where each bridge is represented by a pair [u, v]. Returns: str: 'Yes' if it is possible to form a tree structure, otherwise 'No'. if e < n - 1: return \\"No\\" if e > n - 1: return \\"Yes\\" parent = list(range(n + 1)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX for u, v in bridges: union(u, v) root_set = set(find(i) for i in range(1, n + 1)) return \\"Yes\\" if len(root_set) == 1 else \\"No\\" # Reading input from standard input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) E = int(data[1]) bridges = [] for i in range(2, len(data), 2): u, v = int(data[i]), int(data[i + 1]) bridges.append([u, v]) print(can_form_tree(N, E, bridges))"},{"question":"def sum_of_unique_elements(lst: List[int]) -> int: Given a list of integers, returns the sum of all unique elements within the list. >>> sum_of_unique_elements([1, 2, 3, 2, 4, 5, 1]) == 15 >>> sum_of_unique_elements([7, 7, 8, 9, 9]) == 24","solution":"def sum_of_unique_elements(lst): Returns the sum of all unique elements within the list. return sum(set(lst))"},{"question":"from typing import List def solve_maze(inputs: List[str]) -> List[int]: Determine the minimum number of steps required to travel from the top-left corner to the bottom-right corner of the grid. If no path exists, return -1. >>> inputs = [ ... \\"5 5\\", ... \\".....\\", ... \\".#.#.\\", ... \\".#.#.\\", ... \\".#.#.\\", ... \\".....\\", ... \\"0 0\\" ... ] >>> solve_maze(inputs) [8] >>> inputs = [ ... \\"4 4\\", ... \\"\\", ... \\"#..#\\", ... \\"\\", ... \\"\\", ... \\"0 0\\" ... ] >>> solve_maze(inputs) [-1] >>> inputs = [ ... \\"2 2\\", ... \\".#\\", ... \\"#.\\", ... \\"0 0\\" ... ] >>> solve_maze(inputs) [-1]","solution":"from collections import deque def min_steps(grid): rows = len(grid) cols = len(grid[0]) if grid[0][0] == '#' or grid[rows - 1][cols - 1] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == rows - 1 and y == cols - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1 def solve_maze(inputs): results = [] index = 0 while index < len(inputs): N, M = map(int, inputs[index].split()) if N == 0 and M == 0: break index += 1 grid = [] for _ in range(N): grid.append(inputs[index]) index += 1 results.append(min_steps(grid)) return results"},{"question":"def find_median(numbers: List[int]) -> float: Returns the median of the list of numbers. >>> find_median([4, 9, 5, 1, 3, 6]) 4.5 >>> find_median([6, 1, 9, 2, 0, 4]) 3.0 >>> find_median([42]) 42 >>> find_median([1, 2, 3, 4, 5, 6, 7]) 4 >>> find_median([3, 1, 2]) 2 >>> find_median([5, 3, 3, 4, 3]) 3","solution":"def find_median(numbers): Returns the median of the list of numbers. sorted_numbers = sorted(numbers) n = len(sorted_numbers) if n % 2 == 0: # Even number of elements median = (sorted_numbers[n//2 - 1] + sorted_numbers[n//2]) / 2.0 else: # Odd number of elements median = sorted_numbers[n//2] return median"},{"question":"def arrange_lanterns(n: int, heights: List[int]) -> Union[List[int], str]: In the land of Pyroland, there is a peculiar ritual involving lanterns. The Pyrolandians want to create a unique sequence of lanterns for their annual festival. Given an array of lantern heights, Pyrolandians want to arrange them such that: 1. Each peak is strictly higher than its adjacent heights. 2. Each trough is strictly lower than its adjacent heights. Returns a valid sequence if possible, otherwise returns \\"Impossible\\". >>> arrange_lanterns(3, [2, 3, 1]) [3, 1, 2] >>> arrange_lanterns(4, [5, 1, 2, 4]) [1, 5, 2, 4] pass def test_example_1(): assert arrange_lanterns(3, [2, 3, 1]) == [2, 3, 1] or arrange_lanterns(3, [2, 3, 1]) == [3, 1, 2] def test_example_2(): assert arrange_lanterns(4, [5, 1, 2, 4]) == [2, 5, 1, 4] or arrange_lanterns(4, [5, 1, 2, 4]) == [1, 5, 2, 4] def test_impossible_case(): assert arrange_lanterns(2, [5, 1]) == \\"Impossible\\" def test_single_peak_and_trough(): assert arrange_lanterns(3, [1, 1, 1]) == \\"Impossible\\" def test_larger_case(): result = arrange_lanterns(6, [1, 2, 3, 4, 5, 6]) assert result == [3, 6, 2, 5, 1, 4] or result == [2, 5, 1, 6, 3, 4] def test_descending_case(): result = arrange_lanterns(5, [5, 4, 3, 2, 1]) assert result == [2, 5, 1, 4, 3] or result == [3, 5, 2, 4, 1]","solution":"def arrange_lanterns(n, heights): if n < 3: return \\"Impossible\\" heights.sort() mid = (n - 1) // 2 lows = heights[:mid+1] highs = heights[mid+1:] arranged = [] while lows or highs: if lows: arranged.append(lows.pop()) if highs: arranged.append(highs.pop()) if is_alternating(arranged): return arranged else: return \\"Impossible\\" def is_alternating(arranged): for i in range(1, len(arranged) - 1): if not ((arranged[i] > arranged[i-1] and arranged[i] > arranged[i+1]) or (arranged[i] < arranged[i-1] and arranged[i] < arranged[i+1])): return False return True"},{"question":"def removeAndSort(arr): Removes duplicates from the array and returns the sorted sequence. Parameters: arr (list): A list of integers Returns: list: A list of integers sorted in ascending order without duplicates Example: >>> removeAndSort([4, 5, 9, 0, 4, 2, 9]) [0, 2, 4, 5, 9] >>> removeAndSort([1, 3, 3, 3, 3]) [1, 3]","solution":"def removeAndSort(arr): Removes duplicates from the array and returns the sorted sequence. Parameters: arr (list): A list of integers Returns: list: A list of integers sorted in ascending order without duplicates # Convert the list to a set to remove duplicates unique_elements = set(arr) # Convert the set back to a list and sort it sorted_unique_elements = sorted(unique_elements) return sorted_unique_elements"},{"question":"def can_be_increasing(arr): Determines if the given array can be made strictly increasing by removing at most one element. >>> can_be_increasing([3, 5, 2, 7, 8]) 'YES' >>> can_be_increasing([4, 3, 3, 2]) 'NO' >>> can_be_increasing([1, 2, 3, 4, 5]) 'YES' >>> can_be_increasing([1, 3, 2, 4, 5]) 'YES' pass","solution":"def can_be_increasing(arr): Determines if the given array can be made strictly increasing by removing at most one element. def is_strictly_increasing(seq): return all(x < y for x, y in zip(seq, seq[1:])) n = len(arr) for i in range(n): if is_strictly_increasing(arr[:i] + arr[i+1:]): return \\"YES\\" return \\"NO\\" def main(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) arr = list(map(int, data[1:n+1])) print(can_be_increasing(arr))"},{"question":"def scheduled_activity(n, activities, query_time): Determines which activity is scheduled at the given time. :param n: Integer, number of scheduled activities. :param activities: List of tuples, where each tuple contains (start_time, end_time, description). :param query_time: String, the time to query in HH:MM format. :return: List of strings, descriptions of activities scheduled at the given time. >>> scheduled_activity(3, [(\\"09:00\\", \\"10:00\\", \\"Meeting\\"), (\\"10:30\\", \\"11:30\\", \\"Coding\\"), (\\"11:00\\", \\"12:00\\", \\"Lunch\\")], \\"10:45\\") ['Coding', 'Lunch'] >>> scheduled_activity(3, [(\\"09:00\\", \\"10:00\\", \\"Meeting\\"), (\\"10:30\\", \\"11:30\\", \\"Coding\\"), (\\"11:00\\", \\"12:00\\", \\"Lunch\\")], \\"09:45\\") ['Meeting'] >>> scheduled_activity(2, [(\\"09:00\\", \\"10:00\\", \\"Meeting\\"), (\\"10:30\\", \\"11:30\\", \\"Coding\\")], \\"10:15\\") ['No activity']","solution":"def scheduled_activity(n, activities, query_time): Determines which activity is scheduled at the given time. :param n: Integer, number of scheduled activities. :param activities: List of tuples, where each tuple contains (start_time, end_time, description). :param query_time: String, the time to query in HH:MM format. :return: List of strings, descriptions of activities scheduled at the given time. query_hour, query_minute = map(int, query_time.split(':')) query_time_minutes = query_hour * 60 + query_minute scheduled = [] for start, end, description in activities: start_hour, start_minute = map(int, start.split(':')) end_hour, end_minute = map(int, end.split(':')) start_minutes = start_hour * 60 + start_minute end_minutes = end_hour * 60 + end_minute if start_minutes <= query_time_minutes < end_minutes: scheduled.append(description) if not scheduled: return [\\"No activity\\"] else: return scheduled # Usage n = 3 activities = [ (\\"09:00\\", \\"10:00\\", \\"Meeting\\"), (\\"10:30\\", \\"11:30\\", \\"Coding\\"), (\\"11:00\\", \\"12:00\\", \\"Lunch\\") ] query_time = \\"10:45\\" print('n'.join(scheduled_activity(n, activities, query_time))) # Output: Coding, Lunch"},{"question":"def findMeetingPoint(x1, y1, x2, y2): Returns the minimum number of moves required for both robots to meet and their sequences of moves. If it is impossible for the robots to meet, returns \\"Impossible\\". >>> findMeetingPoint(0, 0, 1, 1) (1, [['D'], ['U']]) >>> findMeetingPoint(0, 0, -1, -1) (1, [['U'], ['D']]) >>> findMeetingPoint(0, 0, 0, 0) (0, [[], []]) >>> findMeetingPoint(-1000000000, 0, 1000000000, 0) (2000000000, [['D'], ['U']]) >>> findMeetingPoint(0, 0, 0, 10) (10, [['R']*10, ['L']*10]) >>> findMeetingPoint(0, 0, 10, 0) (10, [['D']*10, ['U']*10]) def test_findMeetingPoint(): def test_meeting_possible_case_0(): assert findMeetingPoint(0, 0, 1, 1) == (1, [['D'], ['U']]) def test_meeting_impossible(): assert findMeetingPoint(0, 0, 2, 2) == \\"Impossible\\" def test_meeting_equals(): assert findMeetingPoint(0, 0, 0, 0) == (0, [[], []]) def test_meeting_edge_case(): assert findMeetingPoint(-1000000000, 0, 1000000000, 0) == (2000000000, [['D'], ['U']]) def test_single_direction_move_horizontal(): assert findMeetingPoint(0, 0, 0, 10) == (10, [['R' * 10], ['L' * 10]]) def test_single_direction_move_vertical(): assert findMeetingPoint(0, 0, 10, 0) == (10, [['D' * 10], ['U' * 10]]) # Run tests test_findMeetingPoint()","solution":"def findMeetingPoint(x1, y1, x2, y2): Returns the minimum number of moves required for both robots to meet and their sequences of moves. if (x1 + y1) % 2 != (x2 + y2) % 2: return \\"Impossible\\" moves = max(abs(x2 - x1), abs(y2 - y1)) move_sequence_1 = [] move_sequence_2 = [] if x1 < x2: move_sequence_1.append('D' * (x2 - x1)) move_sequence_2.append('U' * (x2 - x1)) elif x1 > x2: move_sequence_1.append('U' * (x1 - x2)) move_sequence_2.append('D' * (x1 - x2)) if y1 < y2: move_sequence_1.append('R' * (y2 - y1)) move_sequence_2.append('L' * (y2 - y1)) elif y1 > y2: move_sequence_1.append('L' * (y1 - y2)) move_sequence_2.append('R' * (y1 - y2)) move_sequence_1 = ''.join(move_sequence_1) move_sequence_2 = ''.join(move_sequence_2) move_list_1 = [char for char in move_sequence_1] move_list_2 = [char for char in move_sequence_2] return (moves, [move_list_1, move_list_2]) # Example call # print(findMeetingPoint(0, 0, 1, 1)) # Expected: (1, [['D', 'R'], ['U', 'L']])"},{"question":"def is_mirrored_string(input_string: str) -> str: Determines if the given string is a Mirrored String, which reads the same forwards and backwards ignoring spaces, punctuation, and case differences. >>> is_mirrored_string(\\"A man, a plan, a canal, Panama\\") \\"MIRRORED\\" >>> is_mirrored_string(\\"hello world\\") \\"NOT MIRRORED\\" >>> is_mirrored_string(\\"madam\\") \\"MIRRORED\\" >>> is_mirrored_string(\\"a\\") \\"MIRRORED\\" >>> is_mirrored_string(\\"\\") \\"MIRRORED\\" >>> is_mirrored_string(\\"12321\\") \\"MIRRORED\\" >>> is_mirrored_string(\\"1A2B2a1\\") \\"MIRRORED\\" >>> is_mirrored_string(\\"This is not a mirrored string\\") \\"NOT MIRRORED\\" >>> is_mirrored_string(\\"Able was I, I saw eLba\\") \\"MIRRORED\\"","solution":"import re def is_mirrored_string(input_string): Determines if the given string is a Mirrored String, which reads the same forwards and backwards ignoring spaces, punctuation, and case differences. # Normalize the string: remove non-alphanumeric characters and convert to lowercase cleaned_string = re.sub(r'[^A-Za-z0-9]', '', input_string).lower() # Check if cleaned string is equal to its reverse if cleaned_string == cleaned_string[::-1]: return \\"MIRRORED\\" else: return \\"NOT MIRRORED\\""},{"question":"def getNthHexagonalNum(n: int) -> int: Returns the n-th hexagonal number. >>> getNthHexagonalNum(1) 1 >>> getNthHexagonalNum(2) 6 >>> getNthHexagonalNum(3) 15 >>> getNthHexagonalNum(4) 28 >>> getNthHexagonalNum(100000) 19999900000","solution":"def getNthHexagonalNum(n): Returns the n-th hexagonal number. return n * (2*n - 1)"},{"question":"import string def is_pangram(sentence: str) -> str: Determines if a given sentence is a pangram. Ignores spaces and punctuation, case insensitive. >>> is_pangram(\\"The quick brown fox jumps over the lazy dog!\\") \\"YES\\" >>> is_pangram(\\"Hello, World!\\") \\"NO\\"","solution":"import string def is_pangram(sentence): Determines if a given sentence is a pangram. Ignores spaces and punctuation, case insensitive. alphabet_set = set(string.ascii_lowercase) sentence_set = set(c.lower() for c in sentence if c.isalpha()) return \\"YES\\" if alphabet_set <= sentence_set else \\"NO\\""},{"question":"def interstellar_programming_contest(input_data: str) -> List[str]: The Galaxy Federation is organizing an interstellar programming contest. Each team is assigned one spaceship and asked to solve a set of programming problems during the course of a galactic journey. The journey consists of a series of missions, and for each mission, the teams can earn energy points based on their performance. The possible outcomes for each mission can be classified into three categories: - S: Successful mission, earning the team 3 energy points. - E: Encounter with space pirates, losing the team 1 energy point. - N: Neutral outcome, no change in energy points. At the end of the journey, the team with the highest total energy points wins. If there is a tie, the team that has the highest count of successful missions wins. If there is still a tie, the team with the least number of encounters with space pirates wins. If there is still no winner, the tie is honored, and all tied teams win. Given the results of the missions for multiple teams, determine the winner of the contest. Args: input_data (str): A multi-line string containing the number of test cases, followed by the number of teams in each test case and their respective mission results. Returns: List[str]: A list of results for each test case, containing the winner, or \\"Tie\\" in case of a tie. Example: >>> input_data = \\"2n3nSSNNnSSNWnSENNNn2nSESENSnENSn\\" >>> interstellar_programming_contest(input_data) [\\"1\\", \\"Tie\\"]","solution":"def calculate_energy_points_and_metrics(missions): energy_points = 0 successful_missions = 0 pirate_encounters = 0 for mission in missions: if mission == 'S': energy_points += 3 successful_missions += 1 elif mission == 'E': energy_points -= 1 pirate_encounters += 1 return energy_points, successful_missions, pirate_encounters def find_winner(test_cases): results = [] for case in test_cases: teams = case metrics = [] for i, team in enumerate(teams): metrics.append((i + 1, *calculate_energy_points_and_metrics(team))) metrics.sort(key=lambda x: (-x[1], -x[2], x[3])) if len(metrics) > 1 and metrics[0][1:] == metrics[1][1:]: results.append(\\"Tie\\") else: results.append(str(metrics[0][0])) return results # Function that processes input and calls find_winner def interstellar_programming_contest(input_data): lines = input_data.strip().split('n') index = 0 T = int(lines[index]) index += 1 test_cases = [] for _ in range(T): M = int(lines[index]) index += 1 teams = [] for _ in range(M): teams.append(lines[index]) index += 1 test_cases.append(teams) return find_winner(test_cases)"},{"question":"from typing import List def rearrange_string(s: str, k: int) -> str: Rearrange the string such that no two adjacent characters are the same. Each k-chunk split at a time. Args: s (str): The string to be rearranged. k (int): The length of separation for adjacent characters. Returns: str: The rearranged string or an empty string if not possible. Examples: >>> rearrange_string(\\"aabb\\", 2) \\"abab\\" >>> rearrange_string(\\"aaab\\", 2) \\"\\"","solution":"from collections import Counter from heapq import heappop, heappush def rearrange_string(s, k): if k == 0: return s count = Counter(s) max_heap = [] for char, freq in count.items(): heappush(max_heap, (-freq, char)) wait_queue = [] result = [] while max_heap: freq, char = heappop(max_heap) result.append(char) wait_queue.append((char, freq + 1, len(result))) if len(wait_queue) >= k: ready_char, ready_freq, pos = wait_queue.pop(0) if ready_freq < 0: heappush(max_heap, (ready_freq, ready_char)) return ''.join(result) if len(result) == len(s) else \\"\\""},{"question":"def max_sum_contiguous_subarray(N: int, L: int, arr: List[int]) -> int: Returns the maximum sum of a contiguous subarray of length L from the given array of integers of size N. Args: N (int): Size of the array. L (int): Length of the subarray. arr (List[int]): List of integers representing the array. Returns: int: Maximum sum of a contiguous subarray of length L. Examples: >>> max_sum_contiguous_subarray(5, 2, [1, 2, 3, 4, 5]) 9 >>> max_sum_contiguous_subarray(6, 3, [2, 1, 5, 1, 2, 7]) 10","solution":"def max_sum_contiguous_subarray(N, L, arr): Returns the maximum sum of a contiguous subarray of length L from the given array of integers of size N. # Calculate the sum of the first L elements current_sum = sum(arr[:L]) max_sum = current_sum # Use a sliding window to calculate the sum of the rest of the subarrays of length L for i in range(L, N): current_sum = current_sum + arr[i] - arr[i - L] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def rotate_90(grid): Rotates a given grid 90 degrees clockwise. >>> rotate_90([ [0, 1, 0, 1], [1, 1, 1, 0], [0, 0, 1, 1] ]) [[0, 1, 0], [0, 1, 1], [1, 1, 0], [1, 0, 1]] pass def max_continuous_crops(row): Returns the maximum number of continuous crops (1s) in a row. >>> max_continuous_crops([0, 1, 1, 0, 1, 1, 1, 0]) 3 >>> max_continuous_crops([1, 1, 1, 1]) 4 >>> max_continuous_crops([0, 0, 0, 0]) 0 pass def process_queries(n, m, q, farm, queries): Processes q queries to find the maximum number of continuous crops in a row after rotating the grid k times. >>> process_queries( 3, 4, 2, [ [0, 1, 0, 1], [1, 1, 1, 0], [0, 0, 1, 1] ], [1, 2] ) [2, 3] >>> process_queries( 2, 2, 1, [ [1, 0], [1, 1] ], [1] ) [2] pass","solution":"def rotate_90(grid): Rotates a given grid 90 degrees clockwise. n, m = len(grid), len(grid[0]) return [[grid[n - j - 1][i] for j in range(n)] for i in range(m)] def max_continuous_crops(row): Returns the maximum number of continuous crops (1s) in a row. max_count = 0 current_count = 0 for value in row: if value == 1: current_count += 1 max_count = max(max_count, current_count) else: current_count = 0 return max_count def process_queries(n, m, q, farm, queries): Processes q queries to find the maximum number of continuous crops in a row after rotating the grid k times. results = [] for k in queries: rotated_farm = farm for _ in range(k % 4): rotated_farm = rotate_90(rotated_farm) max_continuous_row = max(max_continuous_crops(row) for row in rotated_farm) results.append(max_continuous_row) return results"},{"question":"def min_beauty(n: int, k: int, arr: List[int]) -> int: Alice wants to make the beauty of this array as small as possible using the given operations. >>> min_beauty(5, 8, [1, 3, 6, 2, 5]) 2 >>> min_beauty(3, 5, [4, 7, 4]) 1","solution":"def min_beauty(n, k, arr): arr.sort() min_b = arr[0] max_b = arr[-1] min_beauty = max_b - min_b for i in range(1, n): operations_needed = (arr[i] - arr[i-1]) * i if operations_needed <= k: k -= operations_needed min_b = arr[i] min_beauty = max_b - min_b else: min_b += k // i min_beauty = max_b - min_b break return min_beauty"},{"question":"def is_pyramidal_sequence(n: int, sequence: List[int]) -> str: Determines if the sequence is pyramidal. Parameters: n (int): Length of the sequence. sequence (list): List of non-negative integers representing the sequence. Returns: str: \\"YES\\" if the sequence is pyramidal, otherwise \\"NO\\". >>> is_pyramidal_sequence(7, [1, 2, 3, 4, 3, 2, 1]) \\"YES\\" >>> is_pyramidal_sequence(5, [1, 3, 5, 4, 2]) \\"YES\\" >>> is_pyramidal_sequence(6, [1, 2, 3, 1, 2, 3]) \\"NO\\"","solution":"def is_pyramidal_sequence(n, sequence): Determines if the sequence is pyramidal. Parameters: n (int): Length of the sequence. sequence (list): List of non-negative integers representing the sequence. Returns: str: \\"YES\\" if the sequence is pyramidal, otherwise \\"NO\\". if n < 3: return \\"NO\\" peak_index = 0 # Find the peak of the sequence for i in range(1, n): if sequence[i] > sequence[i-1]: peak_index = i else: break if peak_index == 0 or peak_index == n-1: return \\"NO\\" # Verify if sequence after peak is strictly decreasing for i in range(peak_index + 1, n): if sequence[i] >= sequence[i-1]: return \\"NO\\" return \\"YES\\""},{"question":"def calculate_project_priorities(n: int, priorities: List[int], m: int, employee_projects: List[List[int]]) -> List[int]: Calculate the sum of project priorities for each employee. Args: n : int : the number of projects priorities : List[int] : list of integer priorities for each project m : int : the number of employees employee_projects : List[List[int]] : list of lists, where each sublist represents the projects each employee is working on. Returns: List[int] : list of sums of priorities for each employee >>> calculate_project_priorities(4, [10, 20, 30, 40], 3, [[1, 2], [0, 2, 3], [3]]) [50, 80, 40] >>> calculate_project_priorities(3, [5, 15, 25], 2, [[], []]) [0, 0] >>> calculate_project_priorities(5, [1, 2, 3, 4, 5], 1, [[0, 1, 2, 3, 4]]) [15] >>> calculate_project_priorities(6, [10, 20, 30, 40, 50, 60], 3, [[0, 5], [2, 3, 4], [1, 2, 4]]) [70, 120, 100] >>> calculate_project_priorities(3, [100, 200, 300], 3, [[0], [1], [2]]) [100, 200, 300]","solution":"def calculate_project_priorities(n, priorities, m, employee_projects): Calculate the sum of project priorities for each employee. Args: n : int : the number of projects priorities : List[int] : list of integer priorities for each project m : int : the number of employees employee_projects : List[List[int]] : list of lists, where each sublist represents the projects each employee is working on. Returns: List[int] : list of sums of priorities for each employee results = [] for projects in employee_projects: sum_priorities = sum(priorities[project_id] for project_id in projects) results.append(sum_priorities) return results # Example usage: # n = 4 # priorities = [10, 20, 30, 40] # m = 3 # employee_projects = [[1, 2], [0, 2, 3], [3]] # print(calculate_project_priorities(n, priorities, m, employee_projects)) # Output should be [50, 80, 40]"},{"question":"from typing import List, Tuple def max_beauty(T: int, test_cases: List[Tuple[int, int, List[int], List[int]]]) -> List[int]: Determine the maximum beauty Alex can achieve without exceeding the space constraint. There are T test cases. For each test case: n: The number of flower types S: The total space available space: A list of integers representing the space requirements for each type of flower beauty: A list of integers representing the beauty contributions for each type of flower Alex can select each type of flower only once. >>> max_beauty(2, [(3, 5, [2, 3, 4], [3, 4, 5]), (4, 10, [5, 4, 9, 1], [8, 10, 7, 6])]) [7, 24] >>> max_beauty(1, [(0, 10, [], [])]) [0] >>> max_beauty(1, [(1, 5, [5], [10])]) [10] >>> max_beauty(1, [(3, 6, [1, 2, 3], [10, 20, 30])]) [60] >>> max_beauty(1, [(4, 5, [1, 2, 3, 4], [10, 20, 30, 40])]) [50]","solution":"from typing import List, Tuple def max_beauty(T: int, test_cases: List[Tuple[int, int, List[int], List[int]]]) -> List[int]: def knapsack(n, S, space, beauty): dp = [0] * (S + 1) for i in range(n): for j in range(S, space[i] - 1, -1): dp[j] = max(dp[j], dp[j - space[i]] + beauty[i]) return dp[S] results = [] for n, S, space, beauty in test_cases: result = knapsack(n, S, space, beauty) results.append(result) return results"},{"question":"def evaluateExpression(expression: str) -> int: Given a string representing a mathematical expression with operands (integers) and operators (+, -, *, /) separated by spaces, evaluate the expression and return the result as an integer. >>> evaluateExpression(\\"3 + 5\\") 8 >>> evaluateExpression(\\"10 + 2 * 6\\") 22 >>> evaluateExpression(\\"100 * 2 + 12\\") 212 >>> evaluateExpression(\\"100 * ( 2 + 12 )\\") 1400 >>> evaluateExpression(\\"100 * ( 2 + 12 ) / 14\\") 100","solution":"def evaluateExpression(expression): def apply_operator(operands, operator): right = operands.pop() left = operands.pop() if operator == '+': operands.append(left + right) elif operator == '-': operands.append(left - right) elif operator == '*': operands.append(left * right) elif operator == '/': operands.append(int(left / right)) # Ensure integer division follows floor division def precedence(operator): if operator in ('+', '-'): return 1 if operator in ('*', '/'): return 2 return 0 tokens = expression.split() operands = [] operators = [] for token in tokens: if token.isdigit() or (token.startswith('-') and token[1:].isdigit()): operands.append(int(token)) elif token == '(': operators.append(token) elif token == ')': while operators and operators[-1] != '(': apply_operator(operands, operators.pop()) operators.pop() # Remove '(' from stack else: while (operators and precedence(operators[-1]) >= precedence(token)): apply_operator(operands, operators.pop()) operators.append(token) while operators: apply_operator(operands, operators.pop()) return operands[0]"},{"question":"def max_distinct_characters(string_value: str, k: int) -> int: Given a string of lowercase English letters and a number k, find the maximum number of distinct characters within any substring of length k. >>> max_distinct_characters(\\"abcda\\", 3) 3 >>> max_distinct_characters(\\"abcde\\", 5) 5 >>> max_distinct_characters(\\"aaaaa\\", 2) 1 >>> max_distinct_characters(\\"abcdefabc\\", 3) 3 >>> max_distinct_characters(\\"aababababab\\", 2) 2 >>> max_distinct_characters(\\"a\\", 1) 1","solution":"def max_distinct_characters(string_value, k): max_distinct = 0 n = len(string_value) for i in range(n - k + 1): substring = string_value[i:i + k] distinct_characters = len(set(substring)) max_distinct = max(max_distinct, distinct_characters) return max_distinct"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all unique characters in the given string s. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 pass def process_test_cases(test_cases: List[str]) -> List[int]: Processes a list of test cases and returns a list of results, each being the length of the longest substring with all unique characters for the given test case. >>> process_test_cases([\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\"]) [3, 1, 3] >>> process_test_cases([\\"dvdf\\", \\"\\"]) [3, 0] pass","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters in the given string s. max_length = 0 start = 0 char_index_map = {} for end in range(len(s)): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length def process_test_cases(test_cases): results = [] for s in test_cases: results.append(length_of_longest_substring(s)) return results"},{"question":"def shortest_string_length(n: int, s: str) -> int: Given a string s of length n consisting of only lowercase English letters, determine the length of the shortest string that can be obtained after any number of operations where two consecutive identical characters can be removed. >>> shortest_string_length(8, \\"abccbaab\\") 2 >>> shortest_string_length(6, \\"aabccb\\") 0","solution":"def shortest_string_length(n, s): Given a string s of length n consisting of only lowercase English letters, this function returns the length of the shortest string that can be obtained after performing any number of operations where two consecutive identical characters can be removed. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"def min_sum_of_nodes(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]], List[int]]]) -> List[int]: Determine the minimum possible sum of all nodes after performing any number of the allowed operations. >>> min_sum_of_nodes(2, [(3, [(1, 2), (1, 3)], [1, 5, 3]), (5, [(1, 2), (1, 3), (1, 4), (4, 5)], [1, 2, 3, 4, 5])]) [9, 15]","solution":"def min_sum_of_nodes(t, test_cases): results = [] for case in test_cases: n, edges, values = case # The sum of the values is the answer regardless of the structure min_sum = sum(values) results.append(min_sum) return results"},{"question":"def longest_subarray_divisible_by_k(n:int, k:int, a:List[int]) -> int: Find the length of the longest subarray with all elements divisible by a given integer K. Args: n : int : Number of elements in the array A. k : int : The given integer to check divisibility. a : List[int] : List of integers representing the array. Returns: int : Length of the longest subarray where all elements are divisible by K. Examples: >>> longest_subarray_divisible_by_k(8, 3, [3, 6, 9, 2, 18, 21, 4, 12]) 3 >>> longest_subarray_divisible_by_k(5, 2, [4, 8, 12, 16, 20]) 5 >>> longest_subarray_divisible_by_k(6, 7, [1, 2, 3, 4, 5, 6]) 0 >>> longest_subarray_divisible_by_k(7, 4, [4, 8, 15, 16, 23, 42, 8]) 2 >>> longest_subarray_divisible_by_k(1, 1, [1]) 1 >>> longest_subarray_divisible_by_k(1, 2, [1]) 0","solution":"def longest_subarray_divisible_by_k(n, k, a): max_length = 0 current_length = 0 for num in a: if num % k == 0: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 0 if current_length > max_length: max_length = current_length return max_length # Sample Input, Output # Input: 8 3 # [3, 6, 9, 2, 18, 21, 4, 12] # Output: 3 print(longest_subarray_divisible_by_k(8, 3, [3, 6, 9, 2, 18, 21, 4, 12]))"},{"question":"def find_min_edges_to_connect_graph(N, E, edges): Returns the minimum number of edges to make a graph connected. Args: N: int - number of nodes in the graph E: int - number of edges in the graph edges: List[Tuple[int, int]] - list of edges, where each edge is represented by a tuple of two nodes Returns: int - minimum number of edges needed to make the graph connected >>> find_min_edges_to_connect_graph(6, 3, [(1, 2), (2, 3), (4, 5)]) 2 >>> find_min_edges_to_connect_graph(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 0 >>> find_min_edges_to_connect_graph(4, 0, []) 3 >>> find_min_edges_to_connect_graph(3, 1, [(1, 2)]) 1 >>> find_min_edges_to_connect_graph(3, 3, [(1, 2), (2, 3), (1, 3)]) 0","solution":"def find_min_edges_to_connect_graph(N, E, edges): Returns the minimum number of edges to make a graph connected. from collections import defaultdict graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def dfs(node, visited): stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) visited = set() components = 0 for node in range(1, N + 1): if node not in visited: visited.add(node) dfs(node, visited) components += 1 return components - 1 # Input Parsing for testing def process_input(data): lines = data.split('n') N, E = map(int, lines[0].split()) edges = [tuple(map(int, line.split())) for line in lines[1:] if line] return N, E, edges # Sample data data = \\"6 3n1 2n2 3n4 5\\" N, E, edges = process_input(data) print(find_min_edges_to_connect_graph(N, E, edges)) # Output should be 2"},{"question":"def min_segments(knots: List[Tuple[int, int]]) -> int: Calculates the minimum number of segments required to cut the rope such that all knots in each segment lie on a straight line. :param knots: List of tuples, where each tuple (x, y) represents the coordinates of a knot :return: Integer, minimum number of segments >>> min_segments([(0, 0), (1, 1), (2, 2), (2, 3), (4, 4), (10, 10)]) 2 >>> min_segments([(0, 0)]) 1 >>> min_segments([(0, 0), (1, 2)]) 1 >>> min_segments([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]) 1 >>> min_segments([(0, 0), (1, 2), (2, 4), (0, 1), (-1, -2)]) 2 >>> min_segments([(0, 0), (1, 1), (2, 2), (0, 1), (2, 3), (1, -1)]) 3 >>> min_segments([(0, 0), (1, 1), (1, -1), (2, 2), (2, -2)]) 2","solution":"def min_segments(knots): Calculates the minimum number of segments required to cut the rope such that all knots in each segment lie on a straight line. :param knots: List of tuples, where each tuple (x, y) represents the coordinates of a knot :return: Integer, minimum number of segments if len(knots) <= 2: return 1 from collections import defaultdict from math import gcd def slope(p1, p2): Computes the slope between two points (p1, p2) in a way that avoids floating-point precision issues. Returns the slope as a normalized pair (dy, dx). dx = p2[0] - p1[0] dy = p2[1] - p1[1] if dx == 0: return (float('inf'), 1) g = gcd(dy, dx) return (dy // g, dx // g) segments = 0 used = [False] * len(knots) for i in range(len(knots)): if not used[i]: slope_count = defaultdict(int) for j in range(len(knots)): if i != j and not used[j]: slope_count[slope(knots[i], knots[j])] += 1 max_slope = max(slope_count, key=slope_count.get, default=None) if max_slope: used[i] = True for j in range(len(knots)): if i != j and not used[j] and slope(knots[i], knots[j]) == max_slope: used[j] = True segments += 1 return segments # Main function to read the input and output the result if __name__ == '__main__': import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) knots = [] for i in range(N): x, y = int(data[2 * i + 1]), int(data[2 * i + 2]) knots.append((x, y)) result = min_segments(knots) print(result)"},{"question":"from typing import List, Tuple def findSuperEmployee(T: int, teams: List[Tuple[int]]) -> int: Returns the ID of the super employee who is part of the highest number of teams. If there are multiple, return the smallest employee ID. Args: T (int): Number of teams teams (List[Tuple[int]]): List of tuples, each containing the IDs of employees in that team Returns: int: ID of the super employee >>> findSuperEmployee(3, [(1, 2, 3), (2, 3, 4), (3, 4, 5)]) 3 >>> findSuperEmployee(2, [(1, 4), (2, 4)]) 4 pass def test_example1(): assert findSuperEmployee(3, [(1, 2, 3), (2, 3, 4), (3, 4, 5)]) == 3 def test_example2(): assert findSuperEmployee(2, [(1, 4), (2, 4)]) == 4 def test_single_team(): assert findSuperEmployee(1, [(1, 2, 3)]) == 1 def test_multiple_employees_same_team_count(): assert findSuperEmployee(2, [(1, 2), (3, 4)]) == 1 def test_ten_teams_single_employee(): assert findSuperEmployee(10, [(1,), (1,), (1,), (1,), (1,), (1,), (1,), (1,), (1,), (1,)]) == 1 def test_almost_same_members(): assert findSuperEmployee(4, [(1,2,3,4), (2,3,4,5), (3,4,5,6), (4,5,6,7)]) == 4 def test_one_employee_more(): assert findSuperEmployee(3, [(1,2), (2,3), (2,4)]) == 2 def test_large_id_range(): assert findSuperEmployee(2, [(1000,), (2000,)]) == 1000","solution":"from collections import defaultdict def findSuperEmployee(T, teams): Returns the ID of the super employee who is part of the highest number of teams. If there are multiple, return the smallest employee ID. employee_count = defaultdict(int) # Count the memberships of each employee for team in teams: for employee in team: employee_count[employee] += 1 # Find the employee with the highest number of memberships super_employee = None max_teams = 0 for employee, count in employee_count.items(): if count > max_teams or (count == max_teams and (super_employee is None or employee < super_employee)): max_teams = count super_employee = employee return super_employee"},{"question":"from typing import List def longest_increasing_subsequence(lanterns: List[int]) -> int: Given a list of lantern heights, find the length of the longest strictly increasing subsequence that can be made from these heights. >>> longest_increasing_subsequence([5, 1, 8, 3, 6, 7]) 4 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60]) 5","solution":"from bisect import bisect_left def longest_increasing_subsequence(lanterns): Function to find the length of the longest strictly increasing subsequence. :param lanterns: List of lantern heights :return: Length of the longest strictly increasing subsequence if not lanterns: return 0 # List to store the current longest increasing subsequence lis = [] for height in lanterns: pos = bisect_left(lis, height) if pos < len(lis): lis[pos] = height else: lis.append(height) return len(lis)"},{"question":"def max_total_weight(s: int, c: int, ships: List[int], containers: List[int]) -> int: Calculate the maximum total weight of containers that can be loaded onto ships without exceeding their weight capacities. :param s: int, number of ships :param c: int, number of containers :param ships: list of int, capacities of the ships :param containers: list of int, weights of the containers :return: int, maximum total weight of containers loaded onto the ships >>> max_total_weight(2, 3, [5000, 6000], [2000, 3000, 4000]) 9000 >>> max_total_weight(3, 4, [8000, 9000, 10000], [3000, 4000, 3000, 2000]) 12000 >>> max_total_weight(1, 2, [10000], [7000, 8000]) 8000","solution":"def max_total_weight(s, c, ships, containers): Calculate the maximum total weight of containers that can be loaded onto ships without exceeding their weight capacities. :param s: int, number of ships :param c: int, number of containers :param ships: list of int, capacities of the ships :param containers: list of int, weights of the containers :return: int, maximum total weight of containers loaded onto the ships # Sort ship capacities in decreasing order ships.sort(reverse=True) # Sort container weights in decreasing order containers.sort(reverse=True) total_weight = 0 container_index = 0 # Iterate through each ship for ship in ships: current_load = 0 # Try to load as many containers as possible onto the current ship while container_index < c and current_load + containers[container_index] <= ship: current_load += containers[container_index] container_index += 1 total_weight += containers[container_index-1] return total_weight"},{"question":"from typing import List, Tuple def can_rearrange(k: int, s: str) -> str: Determine if the string can be rearranged so that no two identical characters are within k positions of each other. >>> can_rearrange(2, \\"aabbcc\\") \\"YES\\" >>> can_rearrange(3, \\"aaabc\\") \\"NO\\" pass def can_rearrange_cases(t: int, cases: List[Tuple[int, str]]) -> List[str]: For a given number of test cases, determine for each if the string can be rearranged so that no two identical characters are within k positions of each other. >>> can_rearrange_cases(2, [(2, \\"aabbcc\\"), (3, \\"aaabc\\")]) [\\"YES\\", \\"NO\\"] pass","solution":"from collections import Counter import heapq def can_rearrange(k, s): Determine if the string can be rearranged so that no two identical characters are within k positions of each other. if k <= 1: # If k is 1, any arrangement would be valid return \\"YES\\" counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) queue = [] result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) queue.append((char, count + 1)) # adding to cooldown if len(queue) >= k: prev_char, prev_count = queue.pop(0) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # push back to heap if len(result) == len(s): return \\"YES\\" else: return \\"NO\\" def can_rearrange_cases(t, cases): results = [] for i in range(t): k = cases[i][0] s = cases[i][1] result = can_rearrange(k, s) results.append(result) return results"},{"question":"from typing import List, Tuple def rearrange_string(S: str, K: int) -> str: Determine whether S can be rearranged such that no two adjacent characters are the same and return the lexicographically smallest possible rearranged string. If not possible, return \\"impossible\\". >>> rearrange_string(\\"aabb\\", 2) 'abab' >>> rearrange_string(\\"aaab\\", 2) 'impossible' >>> rearrange_string(\\"abcde\\", 1) 'abcde' pass def solve_rearrange_problems(T: int, test_cases: List[Tuple[str, int]]) -> List[str]: Solves multiple test cases for the rearrange_string function. >>> solve_rearrange_problems(3, [(\\"aabb\\", 2), (\\"aaab\\", 2), (\\"abcde\\", 1)]) ['abab', 'impossible', 'abcde'] pass","solution":"from collections import Counter import heapq def rearrange_string(S, K): if K == 1: return \\"\\".join(sorted(S)) counter = Counter(S) max_heap = [[-count, char] for char, count in counter.items()] heapq.heapify(max_heap) result = [] wait_queue = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) wait_queue.append((char, count + 1)) if len(wait_queue) < K: continue char, count = wait_queue.pop(0) if count < 0: heapq.heappush(max_heap, [count, char]) if len(result) != len(S): return \\"impossible\\" return \\"\\".join(result) def solve_rearrange_problems(T, test_cases): results = [] for i in range(T): S, K = test_cases[i] results.append(rearrange_string(S, K)) return results def main(): input_data = [ \\"3\\", \\"aabb\\", \\"2\\", \\"aaab\\", \\"2\\", \\"abcde\\", \\"1\\" ] T = int(input_data[0]) test_cases = [(input_data[2*i + 1], int(input_data[2*i + 2])) for i in range(T)] results = solve_rearrange_problems(T, test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def highest_selling_product(sales_records): Returns the name of the product with the highest total sales amount. :param sales_records: List[Tuple[str, int]] :return: str >>> highest_selling_product([(\\"Apple\\", 50), (\\"Banana\\", 30), (\\"Apple\\", 60), (\\"Orange\\", 40)]) 'Apple' >>> highest_selling_product([(\\"Apple\\", 50), (\\"Banana\\", 80), (\\"Orange\\", 80)]) in [\\"Banana\\", \\"Orange\\"]","solution":"def highest_selling_product(sales_records): Returns the name of the product with the highest total sales amount. :param sales_records: List[Tuple[str, int]] :return: str from collections import defaultdict product_sales = defaultdict(int) for product, sales in sales_records: product_sales[product] += sales # Find the product with the maximum total sales max_sales_product = max(product_sales, key=product_sales.get) return max_sales_product"},{"question":"from typing import List, Tuple def can_transform_with_one_move(S: str, T: str) -> str: Determine if it is possible to transform string S into string T by exactly one move of changing one character. >>> can_transform_with_one_move(\\"abc\\", \\"adc\\") 'Yes' >>> can_transform_with_one_move(\\"abcd\\", \\"abcf\\") 'Yes' >>> can_transform_with_one_move(\\"abc\\", \\"abc\\") 'No' def process_test_cases(Q: int, test_cases: List[Tuple[str, str]]) -> List[str]: Process multiple test cases and determine for each if string S can be transformed into string T by exactly one move. >>> process_test_cases(3, [(\\"abc\\", \\"adc\\"), (\\"abcd\\", \\"abcf\\"), (\\"abc\\", \\"abc\\")]) ['Yes', 'Yes', 'No'] >>> process_test_cases(2, [(\\"abcd\\", \\"abcf\\"), (\\"abcd\\", \\"abde\\")]) ['Yes', 'No']","solution":"def can_transform_with_one_move(S, T): if len(S) != len(T): return \\"No\\" count = 0 for s_char, t_char in zip(S, T): if s_char != t_char: count += 1 return \\"Yes\\" if count == 1 else \\"No\\" def process_test_cases(Q, test_cases): results = [] for i in range(Q): S, T = test_cases[i] result = can_transform_with_one_move(S, T) results.append(result) return results"},{"question":"def process_queries(queries): Processes a list of queries to manage a pool of integers and return results of specific queries. Args: queries: A 2D list of integers where each sub-array contains exactly 2 integers. Each sub-array represents a query of the form [query_type, value]. Returns: A list of integers and/or strings representing the results of each type 3 query. Example: >>> process_queries([[1, 5], [1, 10], [3, 0], [2, 10], [3, 0]]) [10, 5] >>> process_queries([[1, -3], [1, 4], [1, 5], [3, 0], [2, -3], [3, 0]]) [5, 5] >>> process_queries([[3, 0], [1, 7], [2, 8], [2, 7], [3, 0]]) [\\"None\\", \\"None\\"]","solution":"def process_queries(queries): This function processes a list of queries to manage a pool of integers and return results of specific queries. pool = [] results = [] for query in queries: q_type, value = query if q_type == 1: pool.append(value) elif q_type == 2: if value in pool: pool.remove(value) elif q_type == 3: if pool: results.append(max(pool)) else: results.append(\\"None\\") return results"},{"question":"def most_frequent_char(s: str) -> str: Returns the most frequent character in the string s. If there are multiple characters with the same frequency, the lexicographically smallest one is returned. >>> most_frequent_char(\\"a\\") == \\"a\\" >>> most_frequent_char(\\"abcdefg\\") == \\"a\\" >>> most_frequent_char(\\"apple\\") == \\"p\\" >>> most_frequent_char(\\"banana\\") == \\"a\\" >>> most_frequent_char(\\"aaaaa\\") == \\"a\\" >>> most_frequent_char(\\"testcase\\") == \\"e\\" >>> most_frequent_char(\\"abracadabra\\") == \\"a\\" >>> most_frequent_char(\\"mississippi\\") == \\"i\\" >>> most_frequent_char(\\"aabbccc\\") == \\"c\\" >>> most_frequent_char(\\"babacbc\\") == \\"b\\"","solution":"def most_frequent_char(s): Returns the most frequent character in the string s. If there are multiple characters with the same frequency, the lexicographically smallest one is returned. from collections import Counter # Counting frequency of each character freq = Counter(s) # Finding the maximum frequency max_freq = max(freq.values()) # Collecting all characters with the maximum frequency max_freq_chars = [char for char, count in freq.items() if count == max_freq] # Returning the lexicographically smallest character return min(max_freq_chars)"},{"question":"def valid_warehouse_locations(T, test_cases): Determine the number of valid junctions where the central warehouse can be established. For any two junctions A and B, the shortest path distance (in terms of number of junctions traveled) from A to B should not be greater than a given threshold D. Args: T : int : the number of test cases test_cases : List[Tuple[int, int]] : a list of tuples, where each tuple contains two integers, N representing the number of junctions and D representing the maximum allowable distance for the shortest path, respectively. Returns: List[int] : a list of integers where each integer represents the number of valid junctions for each test case. >>> valid_warehouse_locations(3, [(5, 2), (6, 2), (7, 3)]) [5, 0, 7] >>> valid_warehouse_locations(1, [(3, 1)]) [3]","solution":"def valid_warehouse_locations(T, test_cases): results = [] for N, D in test_cases: # The maximum possible distance in the worst case is N//2 if D >= N // 2: results.append(N) else: results.append(0) return results"},{"question":"def merge_dictionaries(dict1: dict, dict2: dict) -> dict: Merge two dictionaries. If both dictionaries contain a value for the same key, the value from the second dictionary should be used. >>> merge_dictionaries({ 'a': 1, 'b': 2 }, { 'c': 3, 'd': 4 }) == { 'a': 1, 'b': 2, 'c': 3, 'd': 4 } >>> merge_dictionaries({ 'a': 1, 'b': 2 }, { 'b': 3, 'c': 4 }) == { 'a': 1, 'b': 3, 'c': 4 } >>> merge_dictionaries({}, { 'a': 1, 'b': 2 }) == { 'a': 1, 'b': 2 } >>> merge_dictionaries({ 'a': 1, 'b': 2 }, {}) == { 'a': 1, 'b': 2 } >>> merge_dictionaries({}, {}) == {} >>> merge_dictionaries({ 'a': { 'x': 1 }, 'b': { 'y': 2 } }, { 'c': { 'z': 3 }, 'd': { 'w': 4 } }) == { 'a': { 'x': 1 }, 'b': { 'y': 2 }, 'c': { 'z': 3 }, 'd': { 'w': 4 } }","solution":"def merge_dictionaries(dict1, dict2): Merges two dictionaries. If both dictionaries have the same key, the value from the second dictionary will be used. Parameters: dict1 (dict): The first dictionary. dict2 (dict): The second dictionary. Returns: dict: A new dictionary containing all keys and values from both dictionaries. merged_dict = dict1.copy() merged_dict.update(dict2) return merged_dict"},{"question":"def max_delivery_requests(n: int, m: int, requests: List[Tuple[int, int, int, int, int]]) -> int: Determine the maximum number of delivery requests that can be satisfied. >>> max_delivery_requests(3, 3, [(1, 1, 2, 2, 2), (2, 2, 3, 3, 2), (1, 1, 3, 3, 4)]) 2 >>> max_delivery_requests(5, 5, [(1, 1, 2, 2, 2), (2, 2, 3, 3, 4), (3, 1, 4, 4, 4), (1, 1, 1, 5, 5), (1, 1, 2, 3, 3)]) 3 >>> max_delivery_requests(10, 4, [(1, 1, 10, 10, 18), (10, 10, 1, 1, 18), (5, 5, 1, 1, 8), (1, 1, 3, 3, 4)]) 3 >>> max_delivery_requests(8, 3, [(1, 1, 8, 8, 14), (8, 8, 1, 1, 14), (4, 4, 1, 1, 6)]) 2","solution":"def max_delivery_requests(n, m, requests): def bfs(x1, y1, x2, y2): queue = [(x1, y1, 0)] visited = set() while queue: x, y, d = queue.pop(0) if (x, y) == (x2, y2): return d for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 1 <= nx <= n and 1 <= ny <= n and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, d + 1)) return float('inf') requests_with_time = [] for r in requests: x1, y1, x2, y2, t = r actual_time = bfs(x1, y1, x2, y2) if actual_time <= t: requests_with_time.append((x1, y1, x2, y2, t, actual_time)) # Sort by end time to maximize the number of requests we can satisfy requests_with_time.sort(key=lambda x: (x[4], x[5])) end_time = -1 count = 0 for x1, y1, x2, y2, t, actual_time in requests_with_time: if actual_time > end_time: end_time = actual_time count += 1 return count"},{"question":"def minimum_rows(n: int, coin_values: List[int]) -> int: Determine the minimum number of rows required to organize all the coins in the showcase. Parameters: n (int): The number of coins. coin_values (List[int]): A list of integers representing the values of the coins. Returns: int: The minimum number of rows required. >>> minimum_rows(5, [1, 2, 2, 3, 3]) 3 >>> minimum_rows(4, [4, 4, 4, 4]) 1 >>> minimum_rows(6, [1, 2, 3, 4, 5, 6]) 6","solution":"def minimum_rows(n, coin_values): Determine the minimum number of rows required to organize all the coins in the showcase. Parameters: n (int): The number of coins. coin_values (List[int]): A list of integers representing the values of the coins. Returns: int: The minimum number of rows required. # Using a set to find the unique values in the coin values list unique_values = set(coin_values) # The number of unique values represents the number of unique rows needed return len(unique_values) # Example usage: # n = 5 # coin_values = [1, 2, 2, 3, 3] # print(minimum_rows(n, coin_values)) # Output: 3"},{"question":"def largest_string_after_removal(S: str, K: int) -> str: Returns the lexicographically largest string that can be obtained by removing exactly K characters from the string S. >>> largest_string_after_removal('abcde', 2) == 'cde' >>> largest_string_after_removal('abc', 1) == 'bc' >>> largest_string_after_removal('abcd', 4) == '' >>> largest_string_after_removal('aabbcc', 2) == 'bbcc' >>> largest_string_after_removal('aabbcc', 3) == 'bcc' >>> largest_string_after_removal('aabbcc', 4) == 'cc' >>> largest_string_after_removal('abcde', 0) == 'abcde' >>> largest_string_after_removal('z' + 'a' * 100000, 100000) == 'z' >>> largest_string_after_removal('z'*10 + 'y'*10, 10) == 'zzzzzzzzzz' >>> largest_string_after_removal('z'*10 + 'y'*10, 15) == 'zzzzz'","solution":"def largest_string_after_removal(S, K): Returns the lexicographically largest string that can be obtained by removing exactly K characters from the string S. stack = [] n = len(S) for i, char in enumerate(S): while stack and K > 0 and stack[-1] < char: stack.pop() K -= 1 stack.append(char) # If K > 0 after the loop, remove the remaining K characters from the end while K > 0: stack.pop() K -= 1 return ''.join(stack)"},{"question":"def analyze_branches(n: int, employees: List[int]) -> Tuple[int, int, int]: Returns the minimum, maximum, and average number of employees across all branches. Parameters: n (int): The number of branches. employees (list): A list of integers where each integer represents the number of employees in a branch. Returns: tuple: A tuple containing three integers - minimum number of employees, maximum number of employees, and average number of employees rounded down to the nearest integer. >>> analyze_branches(5, [10, 20, 30, 40, 50]) (10, 50, 30) >>> analyze_branches(3, [15, 10, 20]) (10, 20, 15) >>> analyze_branches(4, [7, 7, 7, 7]) (7, 7, 7)","solution":"def analyze_branches(n, employees): Returns the minimum, maximum, and average number of employees across all branches. Parameters: n (int): The number of branches. employees (list): A list of integers where each integer represents the number of employees in a branch. Returns: tuple: A tuple containing three integers - minimum number of employees, maximum number of employees, and average number of employees rounded down to the nearest integer. min_employees = min(employees) max_employees = max(employees) avg_employees = sum(employees) // n return min_employees, max_employees, avg_employees"},{"question":"def longest_increasing_subarray(arr: List[int]) -> int: Returns the length of the longest subarray that forms a strictly increasing sequence. >>> longest_increasing_subarray([1, 2, 3, 2, 3, 4, 5]) 4 >>> longest_increasing_subarray([5, 1, 2, 3, 4]) 4 >>> longest_increasing_subarray([10, 20, 10, 30, 40, 50, 10]) 4 >>> longest_increasing_subarray([5, 6, 3, 5, 7, 8, 8, 9]) 4 >>> longest_increasing_subarray([1]) 1 >>> longest_increasing_subarray([0]) 1 >>> longest_increasing_subarray([]) 0 >>> longest_increasing_subarray([10, 9, 8, 7]) 1 >>> longest_increasing_subarray([1, 3, 5, 7, 9]) 5 >>> longest_increasing_subarray([2, 2, 2, 2, 2]) 1","solution":"def longest_increasing_subarray(arr): Returns the length of the longest subarray that forms a strictly increasing sequence. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def sum_unique_integers_leq_k(n: int, k: int, a: List[int]) -> int: Given a list of integers \`a\` and an integer \`k\`, returns the sum of unique integers in \`a\` that are less than or equal to \`k\`. :param n: Length of the list \`a\`. :param k: Threshold integer. :param a: List of integers. :return: Sum of unique integers in \`a\` less than or equal to \`k\`. >>> sum_unique_integers_leq_k(5, 3, [1, 2, 2, 3, 4]) 6 >>> sum_unique_integers_leq_k(4, 1, [-1, 0, 1, 1]) 0 >>> sum_unique_integers_leq_k(6, 0, [-1, -2, -3, 1, 2, 3]) -6 >>> sum_unique_integers_leq_k(5, 3, [4, 5, 6, 7, 8]) 0 >>> sum_unique_integers_leq_k(5, 10, [1, 2, 3, 4, 5]) 15 >>> sum_unique_integers_leq_k(7, 0, [-4, -1, -1, -2, 0, 1, 2]) -7 >>> sum_unique_integers_leq_k(0, 5, []) 0","solution":"def sum_unique_integers_leq_k(n, k, a): Given a list of integers \`a\` and an integer \`k\`, returns the sum of unique integers in \`a\` that are less than or equal to \`k\`. :param n: Length of the list \`a\`. :param k: Threshold integer. :param a: List of integers. :return: Sum of unique integers in \`a\` less than or equal to \`k\`. unique_integers = set(a) sum_leq_k = sum(x for x in unique_integers if x <= k) return sum_leq_k"},{"question":"def count_divisible_pairs(nums, k): Returns the number of pairs (i, j) such that nums[i] + nums[j] is divisible by k. >>> count_divisible_pairs([1, 2, 3, 4, 5], 3) 4 >>> count_divisible_pairs([5, 10, 15, 20, 25], 5) 10 >>> count_divisible_pairs([1, 3, 2, 6, 1, 2], 3) 5 >>> count_divisible_pairs([1, 1, 1, 1], 5) 0 >>> count_divisible_pairs([4, 4, 4, 4], 8) 6 pass","solution":"def count_divisible_pairs(nums, k): Returns the number of pairs (i, j) such that nums[i] + nums[j] is divisible by k. count = 0 n = len(nums) for i in range(n): for j in range(i+1, n): if (nums[i] + nums[j]) % k == 0: count += 1 return count"},{"question":"def maximize_score_sequence(n: int) -> List[int]: Generate a sequence of n distinct integers that maximizes the score Bob can achieve by swapping adjacent numbers. >>> maximize_score_sequence(3) [1, 1000000000, 2] >>> maximize_score_sequence(4) [1, 1000000000, 2, 999999999] >>> maximize_score_sequence(2) [1, 1000000000]","solution":"def maximize_score_sequence(n): Generate a sequence of n distinct integers that maximizes the score Bob can achieve by swapping adjacent numbers. if n == 2: return [1, 1000000000] sequence = [] left, right = 1, 1000000000 turn = 0 for _ in range(n): if turn % 2 == 0: sequence.append(left) left += 1 else: sequence.append(right) right -= 1 turn += 1 return sequence"},{"question":"def find_most_mentioned_handle(n: int, comments: List[str]) -> str: Find the most frequently mentioned user handle in a list of comments. If there is a tie, return the lexicographically smallest handle. Parameters: n (int): The number of comments. comments (List[str]): The list of comments as strings. Returns: str: The most frequently mentioned user handle. Examples: >>> find_most_mentioned_handle(5, [\\"Great job @john and @jane!\\", \\"I think @john really nailed it.\\", \\"What do you think, @john?\\", \\"@jane did well too!\\", \\"@lisa, @john, and @jane all did great!\\"]) \\"john\\" >>> find_most_mentioned_handle(3, [\\"@alice apple pie?\\", \\"Does @bob even lift, @alice?\\", \\"@alice and @charlie went to the store.\\"]) \\"alice\\" >>> find_most_mentioned_handle(4, [\\"Who's gonna win? @teamA or @teamB?\\", \\"I think @teamA has an edge.\\", \\"@teamB has some strong players though.\\", \\"Let's cheer for both @teamA and @teamB!\\"]) \\"teamA\\"","solution":"import re from collections import defaultdict def find_most_mentioned_handle(n, comments): mention_count = defaultdict(int) for comment in comments: mentions = re.findall(r'@(w+)', comment) for mention in mentions: mention_count[mention] += 1 most_mentioned_handle = min((handle for handle, count in mention_count.items() if count == max(mention_count.values())), key=lambda h: h) return most_mentioned_handle"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Write a function that takes a list of integers and returns a new list containing the products of all elements in the original list except the element at the current index. You must achieve this without using division. Constraints: * The length of the list will be between 1 and 100,000. * The integers will be between -1,000 and 1,000. >>> product_except_self([1, 2, 3, 4, 5]) == [120, 60, 40, 30, 24] >>> product_except_self([-1, 2, -3, 4]) == [-24, 12, -8, 6] >>> product_except_self([4, 0, 2, 5]) == [0, 40, 0, 0] >>> product_except_self([0, 0, 0, 0]) == [0, 0, 0, 0] >>> product_except_self([5]) == [1] >>> product_except_self([3, 7]) == [7, 3]","solution":"def product_except_self(nums): Returns a list such that each element at index i is the product of all elements in the original list except the one at index i. This solution does not use division. n = len(nums) # Initialize the arrays result = [1] * n left_products = [1] * n right_products = [1] * n # Fill left_products: for i in range(1, n): left_products[i] = left_products[i-1] * nums[i-1] # Fill right_products: for i in range(n-2, -1, -1): right_products[i] = right_products[i+1] * nums[i+1] # Fill the result array for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([1], 2) [1] >>> rotate_array([1, 2, 3, 4, 5, 6], 14) [5, 6, 1, 2, 3, 4] from solution import rotate_array def test_rotate_array_basic(): assert rotate_array([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] def test_rotate_array_no_rotation(): assert rotate_array([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] assert rotate_array([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] def test_rotate_array_single_element(): assert rotate_array([1], 2) == [1] def test_rotate_array_large_k(): assert rotate_array([1, 2, 3, 4, 5, 6], 14) == [5, 6, 1, 2, 3, 4] def test_rotate_array_edge_cases(): assert rotate_array([9, 7, 8], 4) == [8, 9, 7] assert rotate_array([1, 2], 1) == [2, 1] def test_rotate_array_all_rotations(): arr = [1, 2, 3, 4] assert rotate_array(arr, 1) == [4, 1, 2, 3] assert rotate_array(arr, 2) == [3, 4, 1, 2] assert rotate_array(arr, 3) == [2, 3, 4, 1] assert rotate_array(arr, 4) == [1, 2, 3, 4] def test_rotate_array_large_input(): arr = list(range(1000)) rotated = list(range(950, 1000)) + list(range(950)) assert rotate_array(arr, 50) == rotated","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. n = len(arr) k = k % n # To handle cases where k is greater than n if k == 0: return arr return arr[-k:] + arr[:-k]"},{"question":"def find_new_stamp_position(N: int, stamps: List[int], X: int) -> int: Determine the position of a new stamp in the sorted collection in descending order. Args: N (int): Number of stamps in the current collection. stamps (List[int]): List of integers representing the values of the stamps. X (int): Value of the newly purchased stamp. Returns: int: Position of the new stamp in the sorted collection in descending order. >>> find_new_stamp_position(3, [5, 10, 3], 4) 3 >>> find_new_stamp_position(4, [8, 1, 6, 2], 5) 3 def parse_input(input_data: str) -> Tuple[int, List[int], int]: Parse the input data to extract values needed for find_new_stamp_position function. Args: input_data (str): Input data in the specified format. Returns: Tuple: Parsed input data (N, stamps, X) >>> parse_input(\\"3n5 10 3n4\\") (3, [5, 10, 3], 4) def execute(input_data: str) -> List[int]: Execute the function based on the input data. Args: input_data (str): Input data in the specified format. Returns: List[int]: List of results for each test case. >>> execute(\\"2n3n5 10 3n4n4n8 1 6 2n5\\") [3, 3]","solution":"def find_new_stamp_position(test_cases): results = [] for test_case in test_cases: N, stamps, X = test_case stamps.append(X) stamps.sort(reverse=True) position = stamps.index(X) + 1 results.append(position) return results def parse_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) stamps = list(map(int, lines[index + 1].split())) X = int(lines[index + 2]) test_cases.append((N, stamps, X)) index += 3 return test_cases def execute(input_data): test_cases = parse_input(input_data) return find_new_stamp_position(test_cases)"},{"question":"from collections import defaultdict import heapq def min_toll_same_defense_value(N, defense_values, bridges): Determine the minimal toll needed to traverse between any two islands such that the defense values of both islands are identical. Parameters: N (int): The number of islands. defense_values (List[int]): List of defense values for each island. bridges (List[Tuple[int, int, int]]): List of bridges represented as tuples where each tuple contains two islands and the cost of the bridge connecting them. Returns: int: Minimal toll needed to traverse between any two islands with the same defense value, or -1 if no such pair of islands exists. Examples: >>> min_toll_same_defense_value(5, [3, 3, 1, 4, 3], [(1, 2, 4), (2, 3, 1), (3, 4, 3), (4, 5, 2)]) 4 >>> min_toll_same_defense_value(4, [1, 2, 3, 4], [(1, 2, 5), (2, 3, 5), (3, 4, 5)]) -1 >>> min_toll_same_defense_value(3, [1, 1, 1], [(1, 2, 2), (2, 3, 3)]) 2 >>> min_toll_same_defense_value(6, [2, 2, 3, 2, 3, 2], [(1, 2, 1), (2, 3, 1), (2, 4, 2), (4, 5, 2), (4, 6, 2)]) 1 >>> min_toll_same_defense_value(3, [5, 5, 5], [(1, 2, 1000000), (2, 3, 1000000)]) 1000000","solution":"from collections import defaultdict import heapq def min_toll_same_defense_value(N, defense_values, bridges): # Build adjacency list representation of the graph adj = defaultdict(list) for u, v, cost in bridges: adj[u].append((v, cost)) adj[v].append((u, cost)) # Find all islands with same defense value defense_to_islands = defaultdict(list) for i in range(N): defense_to_islands[defense_values[i]].append(i + 1) # Function to perform Dijkstra's algorithm to find minimum toll between nodes with same defense value def dijkstra(start, targets): queue = [(0, start)] visited = set() while queue: toll, node = heapq.heappop(queue) if node in targets: return toll if node not in visited: visited.add(node) for neighbor, cost in adj[node]: if neighbor not in visited: heapq.heappush(queue, (toll + cost, neighbor)) return float('inf') min_toll = float('inf') # Evaluate minimum toll for each set of islands with the same defense value for islands in defense_to_islands.values(): if len(islands) < 2: continue # No need to consider as no pair exists for i in range(len(islands)): for j in range(i + 1, len(islands)): min_toll = min(min_toll, dijkstra(islands[i], {islands[j]})) # Output the result return min_toll if min_toll != float('inf') else -1 # Example case N = 5 defense_values = [3, 3, 1, 4, 3] bridges = [(1, 2, 4), (2, 3, 1), (3, 4, 3), (4, 5, 2)] print(min_toll_same_defense_value(N, defense_values, bridges)) # Output: 4"},{"question":"def can_arrange_books(n, k, heights): Determine whether Alice can arrange the books in non-decreasing order by applying a series of swaps. Each swap can only be made if the absolute difference in height between the two books is less than or equal to k. Parameters: n (int): The number of books. k (int): The maximum allowed difference for a swap. heights (list of int): The heights of the books. Returns: str: \\"YES\\" if the books can be arranged in non-decreasing order, \\"NO\\" otherwise. >>> can_arrange_books(5, 2, [1, 5, 3, 3, 7]) 'YES' >>> can_arrange_books(4, 1, [4, 3, 1, 2]) 'NO' >>> can_arrange_books(6, 10, [10, 20, 30, 25, 15, 35]) 'YES'","solution":"def can_arrange_books(n, k, heights): sorted_heights = sorted(heights) # Check if we can reach each position in sorted array from the original heights for i in range(n): if abs(heights[i] - sorted_heights[i]) > k: return \\"NO\\" return \\"YES\\" def can_arrange_books(n, k, heights): sorted_heights = sorted(heights) # Initial positions of books as per their heights original_positions = {value: idx for idx, value in enumerate(heights)} for sorted_idx, height in enumerate(sorted_heights): original_idx = original_positions[height] if abs(original_idx - sorted_idx) <= k: # Swap the books heights[sorted_idx], heights[original_idx] = heights[original_idx], heights[sorted_idx] # Update the original positions dictionary original_positions[heights[original_idx]], original_positions[heights[sorted_idx]] = original_idx, sorted_idx else: return \\"NO\\" return \\"YES\\""},{"question":"import heapq from typing import List, Tuple, Dict def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int, n: int) -> int: Find the shortest travel time from start to end using Dijkstra's algorithm. pass def shortest_travel_time(T: int, cases: List[Dict[str, Tuple[int, int, int], List[Tuple[int, int, int]], List[Tuple[int, int]]]]) -> List[int]: Determine the shortest travel time from city S to city D for each query in the case. >>> shortest_travel_time(1, [ { 'NMQ': (4, 4, 2), 'roads': [ (1, 2, 5), (2, 3, 3), (3, 4, 1), (1, 3, 10) ], 'queries': [ (1, 4), (2, 4) ] } ]) == [9, 4] >>> shortest_travel_time(1, [ { 'NMQ': (4, 3, 1), 'roads': [ (1, 2, 5), (2, 3, 3), (1, 3, 10) ], 'queries': [ (3, 4) ] } ]) == [-1] >>> shortest_travel_time(2, [ { 'NMQ': (4, 4, 2), 'roads': [ (1, 2, 5), (2, 3, 3), (3, 4, 1), (1, 3, 10) ], 'queries': [ (1, 4), (2, 4) ] }, { 'NMQ': (3, 3, 1), 'roads': [ (1, 2, 2), (2, 3, 4), (1, 3, 7) ], 'queries': [ (1, 3) ] } ]) == [9, 4, 6] pass","solution":"import heapq def dijkstra(graph, start, end, n): distances = {node: float('inf') for node in range(1, n+1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[end] if distances[end] != float('inf') else -1 def shortest_travel_time(T, cases): results = [] for t in range(T): N, M, Q = cases[t]['NMQ'] graph = {i: [] for i in range(1, N + 1)} for u, v, w in cases[t]['roads']: graph[u].append((v, w)) for s, d in cases[t]['queries']: results.append(dijkstra(graph, s, d, N)) return results"},{"question":"def zigzag_arrange(n: int, arr: List[int]) -> List[int]: Arrange the array in a zigzag pattern. Args: n (int): number of elements in the array arr (List[int]): the original array Returns: List[int]: the rearranged array in zigzag order >>> zigzag_arrange(5, [4, 1, 3, 2, 5]) [1, 5, 2, 4, 3] >>> zigzag_arrange(7, [7, 3, 5, 8, 2, 6, 4]) [2, 8, 3, 7, 4, 6, 5] >>> zigzag_arrange(6, [6, 1, 3, 4, 2, 5]) [1, 6, 2, 5, 3, 4] >>> zigzag_arrange(4, [4, 1, 3, 2]) [1, 4, 2, 3] >>> zigzag_arrange(3, [3, 1, 2]) [1, 3, 2]","solution":"def zigzag_arrange(n, arr): arr.sort() result = [] left = 0 right = n - 1 is_left_turn = True while left <= right: if is_left_turn: result.append(arr[left]) left += 1 else: result.append(arr[right]) right -= 1 is_left_turn = not is_left_turn return result # Example usage: n = 5 arr = [4, 1, 3, 2, 5] print(zigzag_arrange(n, arr)) # Output: [1, 5, 2, 4, 3]"},{"question":"def rock_paper_scissors_tournament(test_cases): Simulate a Rock, Paper, Scissors tournament and output the winner's strategy. Args: test_cases (List[List[str]]): List of test cases, where each test case is a list of strings representing player strategies. Returns: List[str]: List of winner strategies for each test case. >>> rock_paper_scissors_tournament([[\\"Rock\\", \\"Paper\\", \\"Scissors\\", \\"Random\\"]]) [\\"Rock\\", \\"Paper\\", \\"Scissors\\", \\"Random\\"] >>> rock_paper_scissors_tournament([['Random', 'Random', 'Random', 'Random', 'Paper', 'Paper', 'Paper', 'Paper']]) ['Rock', 'Paper', 'Scissors', 'Random']","solution":"import random def simulate_game(player1, player2): choices = ['Rock', 'Paper', 'Scissors'] if player1 == 'Random': player1 = random.choice(choices) if player2 == 'Random': player2 = random.choice(choices) if player1 == player2: return player1 # In the case of a tie, allow the first player's choice to win. elif (player1 == 'Rock' and player2 == 'Scissors') or (player1 == 'Scissors' and player2 == 'Paper') or (player1 == 'Paper' and player2 == 'Rock'): return player1 else: return player2 def simulate_tournament(strategies): while len(strategies) > 1: next_round = [] for i in range(0, len(strategies), 2): winner = simulate_game(strategies[i], strategies[i + 1]) next_round.append(winner) strategies = next_round return strategies[0] def rock_paper_scissors_tournament(test_cases): results = [] for case in test_cases: results.append(simulate_tournament(case)) return results"},{"question":"def transform_string(P: str) -> str: Returns the final string after consecutive character removal process. >>> transform_string(\\"abbaca\\") 'ca' >>> transform_string(\\"azxxzy\\") 'ay' from solution import transform_string def test_sample_1(): assert transform_string(\\"abbaca\\") == \\"ca\\" def test_sample_2(): assert transform_string(\\"azxxzy\\") == \\"ay\\" def test_no_consecutive(): assert transform_string(\\"abcdef\\") == \\"abcdef\\" def test_all_consecutive(): assert transform_string(\\"aabbcc\\") == \\"Empty\\" def test_mixed_consecutive(): assert transform_string(\\"aabbccddeeffgghhiijj\\") == \\"Empty\\" def test_single_char(): assert transform_string(\\"a\\") == \\"a\\" def test_double_char(): assert transform_string(\\"aa\\") == \\"Empty\\"","solution":"def transform_string(P): Returns the final string after consecutive character removal process. stack = [] for char in P: if stack and stack[-1] == char: stack.pop() else: stack.append(char) result = ''.join(stack) return result if result else \\"Empty\\""},{"question":"def can_arrange_flowers(n: int, m: int, h: int, flower_heights: List[int]) -> str: Determines if it's possible to arrange n types of flowers into m flower beds such that the height difference between any two adjacent flowers in the same bed does not exceed h. Args: n (int): The number of flower types. m (int): The number of flower beds. h (int): The maximum allowed height difference between adjacent flowers in a bed. flower_heights (list): List of flower heights. Returns: str: \\"YES\\" if the arrangement is possible, otherwise \\"NO\\". Examples: >>> can_arrange_flowers(5, 2, 2, [1, 5, 3, 7, 4]) \\"YES\\" >>> can_arrange_flowers(5, 2, 1, [1, 5, 3, 7, 4]) \\"NO\\"","solution":"def can_arrange_flowers(n, m, h, flower_heights): Determines if it's possible to arrange n types of flowers into m flower beds such that the height difference between any two adjacent flowers in the same bed does not exceed h. Args: n (int): The number of flower types. m (int): The number of flower beds. h (int): The maximum allowed height difference between adjacent flowers in a bed. flower_heights (list): List of flower heights. Returns: str: \\"YES\\" if the arrangement is possible, otherwise \\"NO\\". flower_heights.sort() # Calculate the minimum height difference required to fit all flowers in m beds # If there are m-1 \\"gaps\\" between m flower beds, we need to ensure these gaps don't exceed h for i in range(n - 1): if flower_heights[i + 1] - flower_heights[i] > h: return \\"NO\\" return \\"YES\\""},{"question":"def add_thousands_separators(num_str): Returns the string with commas added as thousands separators. Parameters: num_str (str): A string representation of a non-negative integer. Returns: str: The string with commas added as thousands separators. >>> add_thousands_separators(\\"1234567\\") \\"1,234,567\\" >>> add_thousands_separators(\\"123\\") \\"123\\" >>> add_thousands_separators(\\"1000\\") \\"1,000\\" >>> add_thousands_separators(\\"999999999\\") \\"999,999,999\\" >>> add_thousands_separators(\\"42\\") \\"42\\" >>> add_thousands_separators(\\"7\\") \\"7\\" >>> add_thousands_separators(\\"0\\") \\"0\\"","solution":"def add_thousands_separators(num_str): Returns the string with commas added as thousands separators. Parameters: num_str (str): A string representation of a non-negative integer. Returns: str: The string with commas added as thousands separators. return '{:,}'.format(int(num_str))"},{"question":"def process_commands(commands: List[str]) -> List[str]: Process a series of to-do list commands and returns the results for LIST commands. Args: commands (List[str]): List of commands, where each command is a string. Returns: List[str]: List of results for each LIST command. Example: >>> process_commands([ ... \\"ADD Buy groceries\\", ... \\"ADD Call John\\", ... \\"LIST\\" ... ]) [\\"Buy groceriesnCall John\\"] >>> process_commands([ ... \\"ADD Buy groceries\\", ... \\"ADD Call John\\", ... \\"REMOVE 1\\", ... \\"LIST\\" ... ]) [\\"Call John\\"] >>> process_commands([ ... \\"ADD Buy groceries\\", ... \\"ADD Call John\\", ... \\"REMOVE 1\\", ... \\"REMOVE 1\\", ... \\"LIST\\" ... ]) [\\"No tasks\\"]","solution":"def process_commands(commands): todo_list = [] results = [] for cmd in commands: if cmd.startswith(\\"ADD \\"): task = cmd[4:] todo_list.append(task) elif cmd.startswith(\\"REMOVE \\"): index = int(cmd[7:]) - 1 if 0 <= index < len(todo_list): todo_list.pop(index) elif cmd == \\"LIST\\": if todo_list: results.append(\\"n\\".join(todo_list)) else: results.append(\\"No tasks\\") return results"},{"question":"def can_split_array(arr, k, maxSum): Determine if the array can be split into k subarrays such that the sum of each subarray is less than or equal to maxSum. >>> can_split_array([7, 2, 5, 10, 8], 3, 15) \\"YES\\" >>> can_split_array([7, 2, 5, 10, 8], 3, 10) \\"NO\\" >>> can_split_array([5], 1, 10) \\"YES\\" >>> can_split_array([1, 2, 3, 4, 5], 5, 5) \\"YES\\" >>> can_split_array([5, 5, 5, 5], 4, 10) \\"YES\\" >>> can_split_array([10, 2, 3], 2, 5) \\"NO\\"","solution":"def can_split_array(arr, k, maxSum): Determine if the array can be split into k subarrays such that the sum of each subarray is less than or equal to maxSum. def is_valid(mid): current_sum = 0 subarrays_count = 1 for num in arr: if current_sum + num > mid: subarrays_count += 1 current_sum = num if subarrays_count > k: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if is_valid(mid): right = mid else: left = mid + 1 return \\"YES\\" if left <= maxSum else \\"NO\\""},{"question":"def convert(s: str, numRows: int) -> str: Convert a string to a zigzag pattern based on the given number of rows and then read line by line. Args: s (str): the input string numRows (int): the number of rows to use for the zigzag pattern Returns: str: the string read line by line in a zigzag pattern Examples: >>> convert(\\"PAYPALISHIRING\\", 3) \\"PAHNAPLSIIGYIR\\" >>> convert(\\"PAYPALISHIRING\\", 4) \\"PINALSIGYAHRPI\\" >>> convert(\\"A\\", 1) \\"A\\"","solution":"def convert(s, numRows): if numRows == 1 or numRows >= len(s): return s rows = [''] * numRows current_row = 0 going_down = False for char in s: rows[current_row] += char if current_row == 0 or current_row == numRows - 1: going_down = not going_down current_row += 1 if going_down else -1 return ''.join(rows)"},{"question":"def find_minimum_towers(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[int]: Determine the minimum number of towers required to ensure every city in Wakanda is covered. Args: T: int - the number of test cases. test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]] - A list of test cases where each test case is a tuple. The tuple contains: - N : int - number of cities. - M : int - number of bidirectional roads. - List[Tuple[int, int, int]] - a list of roads represented by a tuple (u, v, w) where u: int - one end of the road. v: int - other end of the road. w: int - length of the road. Returns: List[int] - the minimal number of communication towers required for each test case. >>> find_minimum_towers(2, [(3, 2, [(1, 2, 4), (2, 3, 5)]), (4, 3, [(1, 2, 1), (2, 3, 1), (3, 4, 1)])]) [1, 1] >>> find_minimum_towers(1, [(4, 0, [])]) [4] >>> find_minimum_towers(1, [(5, 2, [(1, 2, 5), (3, 4, 6)])]) [3] >>> find_minimum_towers(1, [(6, 3, [(1, 2, 1), (3, 4, 1), (5, 6, 1)])]) [3] >>> find_minimum_towers(1, [(7, 6, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (5, 6, 1), (6, 7, 1)])]) [1]","solution":"def find_minimum_towers(T, test_cases): def dfs(node, adj_list, visited): stack = [node] while stack: current = stack.pop() for neighbor in adj_list[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) results = [] for case in test_cases: N, M, roads = case adj_list = {i: [] for i in range(1, N+1)} for u, v, w in roads: adj_list[u].append(v) adj_list[v].append(u) visited = set() components = 0 for city in range(1, N+1): if city not in visited: components += 1 visited.add(city) dfs(city, adj_list, visited) results.append(components) return results"},{"question":"def max_sum_subarray(nums, k): Returns the maximum sum of a subarray with length k. >>> max_sum_subarray([1, 2, 3, 4, 5], 2) == 9 >>> max_sum_subarray([-1, -2, -3, -4], 2) == -3 >>> max_sum_subarray([1], 1) == 1 >>> max_sum_subarray([], 3) == 0","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of a subarray with length k. if not nums or k > len(nums): return 0 current_max = sum(nums[:k]) max_sum = current_max for i in range(k, len(nums)): current_max += nums[i] - nums[i - k] max_sum = max(max_sum, current_max) return max_sum"},{"question":"def mirror_sequence(N: int) -> list[int]: Returns the first N elements of the mirror sequence. >>> mirror_sequence(5) [1, -1, 2, -2, 3] >>> mirror_sequence(3) [1, -1, 2] >>> mirror_sequence(1) [1] pass def process_test_cases(test_cases: list[int]) -> list[list[int]]: Processes multiple test cases for the mirror sequence generation. >>> process_test_cases([5, 3]) [[1, -1, 2, -2, 3], [1, -1, 2]] pass","solution":"def mirror_sequence(N): Returns the first N elements of the mirror sequence. :param N: int - the number of elements to generate :return: list - the first N elements of the mirror sequence result = [] for i in range(1, (N // 2) + 1): result.append(i) result.append(-i) # if N is odd, append the last number if N % 2 == 1: result.append((N // 2) + 1) return result def process_test_cases(test_cases): Processes multiple test cases for the mirror sequence generation. :param test_cases: list of int - each representing the N value for a test case :return: list of list of int - the mirror sequence for each test case results = [] for N in test_cases: results.append(mirror_sequence(N)) return results"},{"question":"from typing import List def max_product_modulo(arr: List[int]) -> int: Given an array of integers, find the maximum value of the product of any subarray modulo 10^9 + 7. >>> max_product_modulo([1, 2, 3, 4]) 24 >>> max_product_modulo([10]) 10 >>> max_product_modulo([1, 1, 1, 1]) 1 >>> max_product_modulo([1000, 1000, 1000]) 1000000000 >>> max_product_modulo([2, 3, 7, 2, 5]) 210 >>> max_product_modulo([10**6, 2, 3]) 6000000","solution":"MOD = 10**9 + 7 def max_product_modulo(arr): n = len(arr) max_product = 0 for i in range(n): current_product = 1 for j in range(i, n): current_product = (current_product * arr[j]) % MOD max_product = max(max_product, current_product) return max_product if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) A = list(map(int, data[1:])) print(max_product_modulo(A))"},{"question":"def min_cost_to_buy_ingredients(n, m, k, offerings): Calculate the minimum total cost to buy at least \`k\` different types of ingredients from the available shops. Args: n (int): number of shops m (int): total number of ingredient offerings across all shops k (int): minimum number of different layers the cake must have offerings (List[Tuple[int, int, int]]): List of tuples where each tuple contains the shop number, ingredient type, and cost of that ingredient Returns: int: the minimum total cost to buy \`k\` different types of ingredients, or -1 if it's not possible Examples: >>> min_cost_to_buy_ingredients(4, 6, 3, [(0, 1, 100), (0, 2, 200), (1, 1, 150), (1, 3, 300), (2, 2, 50), (3, 3, 80)]) 230 >>> min_cost_to_buy_ingredients(3, 4, 4, [(0, 1, 100), (0, 2, 200), (1, 1, 150), (2, 2, 50)]) -1 >>> min_cost_to_buy_ingredients(5, 5, 3, [(0, 1, 100), (1, 2, 200), (2, 3, 300), (3, 4, 400), (4, 5, 500)]) 600 >>> min_cost_to_buy_ingredients(3, 6, 2, [(0, 1, 100), (1, 1, 150), (2, 1, 50), (0, 2, 300), (1, 2, 200), (2, 2, 100)]) 150 pass def test_sample_input(): n = 4 m = 6 k = 3 offerings = [ (0, 1, 100), (0, 2, 200), (1, 1, 150), (1, 3, 300), (2, 2, 50), (3, 3, 80) ] assert min_cost_to_buy_ingredients(n, m, k, offerings) == 230 def test_not_enough_ingredients(): n = 3 m = 4 k = 4 offerings = [ (0, 1, 100), (0, 2, 200), (1, 1, 150), (2, 2, 50) ] assert min_cost_to_buy_ingredients(n, m, k, offerings) == -1 def test_minimum_cost(): n = 5 m = 5 k = 3 offerings = [ (0, 1, 100), (1, 2, 200), (2, 3, 300), (3, 4, 400), (4, 5, 500) ] assert min_cost_to_buy_ingredients(n, m, k, offerings) == 600 def test_identical_ingredients_different_costs(): n = 3 m = 6 k = 2 offerings = [ (0, 1, 100), (1, 1, 150), (2, 1, 50), (0, 2, 300), (1, 2, 200), (2, 2, 100) ] assert min_cost_to_buy_ingredients(n, m, k, offerings) == 150 def test_large_input(): n = 100 m = 1000 k = 10 import random random.seed(0) offerings = [(random.randint(0, 99), random.randint(1, 10), random.randint(100, 1000)) for _ in range(m)] assert min_cost_to_buy_ingredients(n, m, k, offerings) != -1 # We expect it to find a valid cost","solution":"def min_cost_to_buy_ingredients(n, m, k, offerings): from collections import defaultdict import heapq # Dictionary to store the minimum cost offerings for each ingredient type ingredient_offers = defaultdict(list) # Populate the dictionary with the offerings for offering in offerings: shop, ingredient, cost = offering ingredient_offers[ingredient].append(cost) # Ensure we have at least \`k\` different ingredients available if len(ingredient_offers) < k: return -1 # For each ingredient type, we keep the minimum cost sorted min_costs = [] for costs in ingredient_offers.values(): heapq.heappush(min_costs, heapq.nsmallest(1, costs)[0]) if len(min_costs) < k: return -1 # Extract the minimum k costs to get the minimum total cost heapq.heapify(min_costs) min_total_cost = sum(heapq.nsmallest(k, min_costs)) return min_total_cost"},{"question":"from typing import List def maxViewDistance(heights: List[int]) -> int: Returns the maximum distance from any building to the next taller building in the array. Args: heights: A list of integers where each integer is between 0 and 100000. Returns: An integer representing the maximum distance from any building to the next taller building. Examples: >>> maxViewDistance([3, 7, 8, 3, 6, 1]) 3 >>> maxViewDistance([1, 2, 3, 4, 5]) 1 >>> maxViewDistance([5, 4, 3, 2, 1]) 4 >>> maxViewDistance([5, 1, 2, 9, 3, 7]) 3 >>> maxViewDistance([3]) 0 >>> maxViewDistance([1, 2]) 1 >>> maxViewDistance([2, 1]) 1 >>> maxViewDistance([2, 2, 2, 2, 2]) 4","solution":"from typing import List def maxViewDistance(heights: List[int]) -> int: Returns the maximum distance from any building to the next taller building in the array. n = len(heights) max_distance = 0 # Traverse the array for i in range(n): distance = n - i - 1 # Start with the farthest possible distance for j in range(i + 1, n): if heights[j] > heights[i]: distance = j - i break if distance > max_distance: max_distance = distance return max_distance"},{"question":"def all_rotations(S): Returns a list of all possible rotations of the string S. >>> all_rotations(\\"abcdef\\") ['abcdef', 'bcdefa', 'cdefab', 'defabc', 'efabcd', 'fabcde'] >>> all_rotations(\\"aaa\\") ['aaa', 'aaa', 'aaa'] >>> all_rotations(\\"xyz\\") ['xyz', 'yzx', 'zxy'] >>> all_rotations(\\"a\\") ['a'] >>> all_rotations(\\"\\") [] def is_rotation(S1, S2): Returns True if S2 is a rotation of S1, and False otherwise. >>> is_rotation(\\"abcdef\\", \\"bcdefa\\") True >>> is_rotation(\\"abcdef\\", \\"fabcde\\") True >>> is_rotation(\\"abcdef\\", \\"abcdef\\") True >>> is_rotation(\\"abcdef\\", \\"abcdefg\\") False >>> is_rotation(\\"xyz\\", \\"zxy\\") True >>> is_rotation(\\"xyz\\", \\"ayz\\") False >>> is_rotation(\\"aaaa\\", \\"aaaa\\") True >>> is_rotation(\\"\\", \\"\\") True >>> is_rotation(\\"a\\", \\"\\") False >>> is_rotation(\\"\\", \\"a\\") False","solution":"def all_rotations(S): Returns a list of all possible rotations of the string S. rotations = [] for i in range(len(S)): rotations.append(S[i:] + S[:i]) return rotations def is_rotation(S1, S2): Returns True if S2 is a rotation of S1, and False otherwise. if len(S1) != len(S2): return False return S2 in (S1 + S1)"},{"question":"def can_robot_reach_end(grid: List[List[int]]) -> bool: Determines if a robot can reach the bottom-right corner of a given grid from the top-left corner. The grid is represented by a 2D list where '0' is open and '1' is blocked. Arguments: grid -- 2D list representing the maze grid Returns: bool -- True if the robot can reach the bottom-right corner, False otherwise >>> can_robot_reach_end([ ... [0, 0, 1], ... [0, 0, 1], ... [1, 0, 0] ... ]) True >>> can_robot_reach_end([ ... [0, 0, 1], ... [1, 1, 1], ... [1, 0, 0] ... ]) False","solution":"def can_robot_reach_end(grid): Determines if a robot can reach the bottom-right corner of a given grid from the top-left corner. Parameters: grid (list of list of int): 2D list representing the maze grid, where '0' is open and '1' is blocked. Returns: bool: True if the robot can reach the bottom-right corner, False otherwise. if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return False n, m = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up stack = [(0, 0)] while stack: x, y = stack.pop() if (x, y) == (n-1, m-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0: stack.append((nx, ny)) grid[nx][ny] = -1 # mark as visited return False"},{"question":"def update_string(s: str, updates: List[Tuple[int, str]]) -> str: Apply a series of update operations to the input string and return the final string. Parameters: - s: str, the initial string. - updates: list of tuples, each tuple contains (position, character). Returns: - str, the final string after all updates are applied. >>> update_string(\\"abcdef\\", [(1, 'z')]) 'zbcdef' >>> update_string(\\"abcdef\\", [(1, 'z'), (3, 'y'), (6, 'x')]) 'zbydex' >>> update_string(\\"abcdef\\", [(6, 'z')]) 'abcdez'","solution":"def update_string(s, updates): Apply a series of update operations to the input string. Parameters: - s: str, the initial string. - updates: list of tuples, each tuple contains (position, character). Returns: - str, the final string after all updates are applied. # Convert the string to a list of characters for easy modification s_list = list(s) # Apply each update to the list for pos, char in updates: s_list[pos - 1] = char # Convert the list back to a string return ''.join(s_list)"},{"question":"def subtree_sum(r: int) -> int: Given a node r which becomes the new root of the tree, calculates the sum of all node values in the subtree rooted at node r. >>> subtree_sum(1) == 2147483647 >>> subtree_sum(2) == 2147483645 >>> subtree_sum(3) == 2147483645 >>> subtree_sum(1000) == 2147483645","solution":"def subtree_sum(r): Given a node r which becomes the new root of the tree, calculates the sum of all node values in the subtree rooted at node r. if r == 1: return 2147483647 else: return 2147483645"},{"question":"def recommend_show(n, shows, preferred_genre, max_episodes): Determine the best show for a user based on their preferred genre and maximum episode limit. Args: n : int : the number of available shows shows : list : list of tuples, each containing (name, genre, episodes, rating) preferred_genre : str : user's preferred genre max_episodes : int : user's maximum episode limit Returns: str : name of the best recommended show or \\"No suitable show found\\" if no show meets the criteria >>> recommend_show(5, [(\\"BreakingBad\\", \\"Drama\\", 62, 95), (\\"StrangerThings\\", \\"SciFi\\", 34, 90), (\\"GameOfThrones\\", \\"Fantasy\\", 73, 92), (\\"TheCrown\\", \\"Drama\\", 50, 89), (\\"Friends\\", \\"Comedy\\", 236, 85)], \\"Drama\\", 60) 'TheCrown' >>> recommend_show(3, [(\\"TheOffice\\", \\"Comedy\\", 201, 87), (\\"Brooklyn99\\", \\"Comedy\\", 153, 85), (\\"ParksAndRec\\", \\"Comedy\\", 125, 88)], \\"Comedy\\", 200) 'ParksAndRec' >>> recommend_show(3, [(\\"TheOffice\\", \\"Comedy\\", 201, 87), (\\"Brooklyn99\\", \\"Comedy\\", 153, 85), (\\"ParksAndRec\\", \\"Comedy\\", 125, 88)], \\"Drama\\", 50) 'No suitable show found'","solution":"def recommend_show(n, shows, preferred_genre, max_episodes): best_show = None highest_rating = -1 for show in shows: name, genre, episodes, rating = show if genre == preferred_genre and episodes <= max_episodes: if rating > highest_rating: highest_rating = rating best_show = name if best_show: return best_show else: return \\"No suitable show found\\" # Example input n = 5 shows = [ (\\"BreakingBad\\", \\"Drama\\", 62, 95), (\\"StrangerThings\\", \\"SciFi\\", 34, 90), (\\"GameOfThrones\\", \\"Fantasy\\", 73, 92), (\\"TheCrown\\", \\"Drama\\", 50, 89), (\\"Friends\\", \\"Comedy\\", 236, 85) ] preferred_genre = \\"Drama\\" max_episodes = 60 print(recommend_show(n, shows, preferred_genre, max_episodes)) # Output: TheCrown"},{"question":"from typing import List, Tuple def generate_combinations(elements: List, length: int, excluded_elements: List) -> List[Tuple]: Generate all possible unique combinations of a given length from the provided elements, excluding any combinations containing elements in excluded_elements. >>> generate_combinations([1, 2, 3, 4, 5], 3, [2, 4]) [(1, 1, 1), (1, 1, 3), (1, 1, 5), (1, 3, 3), (1, 3, 5), (1, 5, 5), (3, 3, 3), (3, 3, 5), (3, 5, 5), (5, 5, 5)] >>> generate_combinations(['a', 'b', 'c', 'd'], 2, ['b']) [('a', 'a'), ('a', 'c'), ('a', 'd'), ('c', 'c'), ('c', 'd'), ('d', 'd')] >>> generate_combinations([], 3, [2, 4]) [] >>> generate_combinations([1, 2, 3], 0, [2]) [] >>> generate_combinations(['x', 'y'], 2, []) [('x', 'x'), ('x', 'y'), ('y', 'y')] >>> generate_combinations(['x', 'y', 'z'], 2, ['x', 'y', 'z']) [] >>> generate_combinations(['a', 'a', 'c'], 2, []) [('a', 'a'), ('a', 'c'), ('c', 'c')]","solution":"from itertools import combinations_with_replacement def generate_combinations(elements, length, excluded_elements): Generate all possible unique combinations of a given length from the provided elements, excluding any combinations containing elements in excluded_elements. if not elements or length == 0: return [] filtered_elements = [e for e in elements if e not in excluded_elements] all_combinations = set(combinations_with_replacement(filtered_elements, length)) return list(all_combinations)"},{"question":"class Inventory: Inventory management system for an e-commerce platform, allows adding, removing, and querying product stock. def add_product(self, product_id: int, quantity: int): Adds the \`quantity\` number of units to the given \`product_id\`. If the \`product_id\` does not exist in the inventory, it should be added with the given quantity. pass def remove_product(self, product_id: int, quantity: int): Removes the \`quantity\` number of units from the given \`product_id\`. If the quantity to be removed is more than the current stock for the given \`product_id\`, it should remove only the available stock and set the quantity to zero. If the \`product_id\` does not exist in the inventory, it should do nothing. pass def get_stock(self, product_id: int) -> int: Returns the current stock quantity of the given \`product_id\`. If the \`product_id\` does not exist, return zero. pass # Example Usage if __name__ == \\"__main__\\": inv = Inventory() inv.add_product(101, 50) inv.add_product(102, 20) print(inv.get_stock(101)) # Output: 50 print(inv.get_stock(102)) # Output: 20 inv.remove_product(101, 10) print(inv.get_stock(101)) # Output: 40 inv.remove_product(102, 25) print(inv.get_stock(102)) # Output: 0 print(inv.get_stock(103)) # Output: 0","solution":"class Inventory: def __init__(self): self.inventory = {} def add_product(self, product_id, quantity): if product_id not in self.inventory: self.inventory[product_id] = 0 self.inventory[product_id] += quantity def remove_product(self, product_id, quantity): if product_id in self.inventory: self.inventory[product_id] -= min(self.inventory[product_id], quantity) if self.inventory[product_id] <= 0: self.inventory[product_id] = 0 def get_stock(self, product_id): return self.inventory.get(product_id, 0)"},{"question":"def raceCarDistance(v, a, d): Returns the total distance traveled by a car given the maximum speed, the number of seconds over which the car accelerates, and the number of seconds over which the car decelerates. Parameters: v (int): the maximum speed of the car in m/s. a (int): the number of seconds over which the car accelerates uniformly. d (int): the number of seconds over which the car decelerates uniformly. Returns: float: the total distance traveled by the car in meters. >>> raceCarDistance(10, 2, 3) 35.0 >>> raceCarDistance(5, 1, 1) 10.0 >>> raceCarDistance(20, 4, 4) 100.0 pass # implement the function def handle_test_cases(test_cases): Process multiple test cases to calculate total distance for each case. Parameters: test_cases (List[Tuple[int, int, int]]): List of tuples (v, a, d) representing max speed, acceleration time, deceleration time. Returns: List[float]: List of total distances for each test case. >>> handle_test_cases([(10, 2, 3), (5, 1, 1), (20, 4, 4)]) [35.0, 10.0, 100.0] pass # implement the function def process_input(input_data): Process the input data to extract test cases. Parameters: input_data (str): String containing the number of test cases followed by test cases. Returns: List[Tuple[int, int, int]]: List of tuples (v, a, d) representing max speed, acceleration time, deceleration time. >>> process_input(\\"3n10 2 3n5 1 1n20 4 4\\") [(10, 2, 3), (5, 1, 1), (20, 4, 4)] pass # implement the function","solution":"def raceCarDistance(v, a, d): Returns the total distance traveled by a car given the maximum speed, the number of seconds over which the car accelerates, and the number of seconds over which the car decelerates. Parameters: v (int): the maximum speed of the car in m/s. a (int): the number of seconds over which the car accelerates uniformly. d (int): the number of seconds over which the car decelerates uniformly. Returns: float: the total distance traveled by the car in meters. distance_acceleration = 0.5 * v * a distance_constant_speed = v * 1 distance_deceleration = 0.5 * v * d total_distance = distance_acceleration + distance_constant_speed + distance_deceleration return total_distance # Handling multiple test cases def handle_test_cases(test_cases): results = [] for case in test_cases: v, a, d = case results.append(raceCarDistance(v, a, d)) return results # Sample Input Processing def process_input(input_data): lines = input_data.split(\\"n\\") t = int(lines[0]) test_cases = [] for i in range(1, t + 1): v, a, d = map(int, lines[i].split()) test_cases.append((v, a, d)) return test_cases"},{"question":"import math from typing import List def count_ways_to_form_pairs(N: int) -> int: Count the number of ways to form pairs such that Student 1 is always included in the first pair. Args: N (int): Number of students. Returns: int: Number of ways to form pairs. >>> count_ways_to_form_pairs(2) 1 >>> count_ways_to_form_pairs(4) 3 >>> count_ways_to_form_pairs(6) 15 pass def solve(T: int, cases: List[int]) -> List[int]: Solve the problem for multiple test cases. Args: T (int): Number of test cases. cases (List[int]): List of integers representing the number of students in each test case. Returns: List[int]: List of results for each test case. >>> solve(3, [2, 4, 6]) [1, 3, 15] >>> solve(2, [6, 8]) [15, 105] >>> solve(4, [2, 4, 6, 8]) [1, 3, 15, 105] pass","solution":"import math def count_ways_to_form_pairs(N): Count the number of ways to form pairs such that Student 1 is always included in the first pair. # We choose the first student to pair with as (N-1) options first_pair_ways = N - 1 # The remaining students can be paired up (N-2)/2 ways remaining_pairs_ways = math.factorial((N - 2)) // (math.factorial((N - 2) // 2) * 2**((N - 2) // 2)) return first_pair_ways * remaining_pairs_ways def solve(T, cases): results = [] for N in cases: results.append(count_ways_to_form_pairs(N)) return results"},{"question":"def minimum_people_to_ride(n: int, tunnels: list) -> int: Returns the minimum number of people required for the roller coaster to pass through all tunnels without exceeding their capacities. Parameters: n (int): The number of tunnels. tunnels (list of tuples): Each tuple contains three integers (start, end, capacity) representing the start and end coordinates of the tunnel and its capacity respectively. Returns: int: The minimum number of people required. Examples: >>> minimum_people_to_ride(3, [(1, 5, 3), (4, 8, 2), (6, 9, 4)]) 4 >>> minimum_people_to_ride(2, [(2, 7, 1), (5, 10, 2)]) 2 >>> minimum_people_to_ride(1, [(1, 10, 5)]) 5 >>> minimum_people_to_ride(3, [(1, 5, 3), (6, 10, 3), (11, 15, 3)]) 3 >>> minimum_people_to_ride(3, [(1, 4, 2), (5, 6, 1), (7, 8, 3)]) 3","solution":"def minimum_people_to_ride(n, tunnels): Returns the minimum number of people required for the roller coaster to pass through all tunnels without exceeding their capacities. Parameters: n (int): The number of tunnels. tunnels (list of tuples): Each tuple contains three integers (start, end, capacity) representing the start and end coordinates of the tunnel and its capacity respectively. Returns: int: The minimum number of people required. # Initialize maximum capacity required to pass through the tunnels as zero max_capacity_required = 0 # Iterate over each tunnel to find the maximum capacity required for start, end, capacity in tunnels: # The maximum capacity needed is the highest capacity of any tunnel max_capacity_required = max(max_capacity_required, capacity) return max_capacity_required"},{"question":"from typing import List def largest_number(t: int, test_cases: List[List[int]]) -> List[str]: Given a collection of integers, identify the largest number that can be formed by concatenating the integers together. :param t: Integer - The number of test cases. :param test_cases: List of integer lists - Each sublist contains a collection of integers. :return: List of strings - Each string is the largest number that can be formed for the corresponding test case. >>> largest_number(1, [[10, 2, 9]]) [\\"9210\\"] >>> largest_number(2, [[10, 2, 9], [54, 546, 548, 60]]) [\\"9210\\", \\"6054854654\\"] pass def test_single_case(): t = 1 test_cases = [ [10, 2, 9] ] assert largest_number(t, test_cases) == [\\"9210\\"] def test_multiple_cases(): t = 2 test_cases = [ [10, 2, 9], [54, 546, 548, 60] ] assert largest_number(t, test_cases) == [\\"9210\\", \\"6054854654\\"] def test_example_case_zero(): t = 1 test_cases = [ [0, 0] ] assert largest_number(t, test_cases) == [\\"0\\"] def test_single_digit_numbers(): t = 1 test_cases = [ [1, 2, 3, 4, 5, 6, 7, 8, 9] ] assert largest_number(t, test_cases) == [\\"987654321\\"] def test_same_digits_different_order(): t = 1 test_cases = [ [121, 12] ] assert largest_number(t, test_cases) == [\\"12121\\"]","solution":"from functools import cmp_to_key def largest_number(t, test_cases): Returns the largest number formed by concatenating integers for each test case. :param t: Number of test cases :param test_cases: List of tuples, each tuple contains a list of integers for that test case :return: List of strings representing the largest number for each test case def compare(x, y): # Custom comparator for sorting: compare based on concatenated result if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 results = [] for case in test_cases: numbers = map(str, case) # Sorting with custom comparator using cmp_to_key sorted_numbers = sorted(numbers, key=cmp_to_key(compare)) # Joining sorted numbers to form the largest number largest_num = ''.join(sorted_numbers) # Edge case for a number of 0s like ['0', '0'] if largest_num[0] == '0': largest_num = '0' results.append(largest_num) return results"},{"question":"def sum_of_digits(n: int) -> int: Returns the sum of digits of the non-negative integer n. >>> sum_of_digits(123) 6 >>> sum_of_digits(0) 0 >>> sum_of_digits(4567) 22 >>> sum_of_digits(890) 17","solution":"def sum_of_digits(n): Returns the sum of digits of the non-negative integer n. sum = 0 while n > 0: sum += n % 10 n //= 10 return sum"},{"question":"def max_buildings_visited(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are given an array of \`n\` integers where each element represents the height of a building. A person standing on top of a building can jump to any building of lesser or equal height but cannot jump to a taller building. Additionally, the person can move right to the next building without any restrictions. Your task is to determine the maximum number of buildings the person can visit starting from the first building and moving strictly right. Args: t : int : the number of test cases test_cases : List[Tuple[int, List[int]]] : list of tuples where each tuple contains number of buildings and list of heights of buildings Returns: List[int] : list of integers where each integer represents the maximum number of buildings the person can visit for the corresponding test case Examples: >>> max_buildings_visited(3, [ (6, [3, 2, 1, 2, 3, 4]), (5, [5, 4, 3, 2, 1]), (4, [1, 2, 3, 4])]) [3, 5, 1] >>> max_buildings_visited(2, [ (7, [7, 6, 5, 4, 3, 2, 1]), (6, [6, 5, 4, 4, 3, 3])]) [7, 6] >>> max_buildings_visited(1, [ (5, [3, 3, 5, 5, 3])]) [2] >>> max_buildings_visited(1, [ (1, [5])]) [1] >>> max_buildings_visited(1, [ (4, [3, 3, 3, 3])]) [4]","solution":"def max_buildings_visited(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] heights = test_cases[i][1] max_visits = 1 current_height = heights[0] for j in range(1, n): if heights[j] <= current_height: max_visits += 1 current_height = heights[j] else: break results.append(max_visits) return results"},{"question":"def min_boxes_to_open(test_cases): Determine the minimum number of larger boxes that need to be opened to distribute care packages. Each participant should receive a package that contains exactly one item. The items are currently stored in larger boxes, and each box contains multiple items. Args: test_cases (List[Tuple[int, List[int]]]): A list of test cases, where each test case is a tuple containing the number of larger boxes and a list of integers representing the number of items in each larger box. Returns: List[Union[int, str]]: A list containing the minimum number of larger boxes that need to be opened for each test case. If it's not possible to distribute the items, return \\"Not enough items in boxes to distribute\\". Example: >>> min_boxes_to_open([(4, [3, 5, 2, 6]), (3, [10, 10, 10])]) [2, 1] def test_case_1(): test_cases = [ (4, [3, 5, 2, 6]), (3, [10, 10, 10]) ] assert min_boxes_to_open(test_cases) == [2, 1] def test_not_enough_items(): test_cases = [ (3, [1, 1, 1]) ] assert min_boxes_to_open(test_cases) == [\\"Not enough items in boxes to distribute\\"] def test_exact_items_needed(): test_cases = [ (3, [3, 3, 4]) ] assert min_boxes_to_open(test_cases) == [3] def test_extra_items_available(): test_cases = [ (3, [20, 1, 1]) ] assert min_boxes_to_open(test_cases) == [1] def test_single_large_box(): test_cases = [ (1, [10]) ] assert min_boxes_to_open(test_cases) == [1] def test_multiple_boxes_equally_divided(): test_cases = [ (4, [2, 3, 2, 3]) ] assert min_boxes_to_open(test_cases) == [4]","solution":"def min_boxes_to_open(test_cases): results = [] for case in test_cases: num_boxes, items_in_boxes = case items_in_boxes.sort(reverse=True) # Sort in descending order to minimize the number of boxes opened total_items = sum(items_in_boxes) participants = 10 if total_items < participants: results.append(\\"Not enough items in boxes to distribute\\") continue current_items = 0 boxes_opened = 0 for items in items_in_boxes: current_items += items boxes_opened += 1 if current_items >= participants: break results.append(boxes_opened) return results"},{"question":"def count_special_paths(n, m, k, restricted_cells, queries): Count the number of special paths in a grid with dimensions n x m, avoiding restricted cells and conforming to the movement rules. Parameters: n (int): Number of rows. m (int): Number of columns. k (int): Number of restricted cells. restricted_cells (list of tuples): List of restricted cell coordinates (1-based indexing). queries (list of tuples): List of queries, each represented by a tuple (sr, sc, dr, dc). Returns: list of int: List of the number of special paths for each query. import pytest def test_example_case_1(): n, m, k = 3, 3, 1 restricted_cells = [(2, 2)] queries = [(1, 1, 3, 3), (1, 2, 3, 3)] expected = [2, 1] result = count_special_paths(n, m, k, restricted_cells, queries) assert result == expected def test_no_restricted_cells(): n, m, k = 2, 2, 0 restricted_cells = [] queries = [(1, 1, 2, 2)] expected = [2] # Two paths: Right->Down and Down->Right result = count_special_paths(n, m, k, restricted_cells, queries) assert result == expected def test_all_cells_restricted(): n, m, k = 2, 2, 4 restricted_cells = [(1, 1), (1, 2), (2, 1), (2, 2)] queries = [(1, 1, 2, 2)] expected = [0] # No path possible result = count_special_paths(n, m, k, restricted_cells, queries) assert result == expected def test_start_is_restricted(): n, m, k = 3, 3, 1 restricted_cells = [(1, 1)] queries = [(1, 1, 3, 3)] expected = [0] # Starting point is restricted result = count_special_paths(n, m, k, restricted_cells, queries) assert result == expected def test_destination_is_restricted(): n, m, k = 3, 3, 1 restricted_cells = [(3, 3)] queries = [(1, 1, 3, 3)] expected = [0] # Destination point is restricted result = count_special_paths(n, m, k, restricted_cells, queries) assert result == expected def test_small_grid(): n, m, k = 1, 2, 0 restricted_cells = [] queries = [(1, 1, 1, 2)] expected = [1] # Only one path: move right result = count_special_paths(n, m, k, restricted_cells, queries) assert result == expected","solution":"def count_special_paths(n, m, k, restricted_cells, queries): Count the number of special paths in a grid with dimensions n x m, avoiding restricted cells and conforming to the movement rules. Parameters: n (int): Number of rows. m (int): Number of columns. k (int): Number of restricted cells. restricted_cells (list of tuples): List of restricted cell coordinates (1-based indexing). queries (list of tuples): List of queries, each represented by a tuple (sr, sc, dr, dc). Returns: list of int: List of the number of special paths for each query. # Convert restricted cells into set for quick lookup restricted_set = {(x - 1, y - 1) for (x, y) in restricted_cells} def is_valid(x, y): return 0 <= x < n and 0 <= y < m and (x, y) not in restricted_set # Use dynamic programming to calculate the number of paths def num_paths(sr, sc, dr, dc): # Create dp array dp = [[0] * m for _ in range(n)] if is_valid(sr, sc): dp[sr][sc] = 1 for i in range(sr, dr + 1): for j in range(sc, dc + 1): if is_valid(i, j): if i > sr: dp[i][j] += dp[i - 1][j] if j > sc: dp[i][j] += dp[i][j - 1] return dp[dr][dc] results = [] for (sr, sc, dr, dc) in queries: results.append(num_paths(sr - 1, sc - 1, dr - 1, dc - 1)) return results"},{"question":"def max_length_no_consecutive_a(s: str) -> int: Returns the maximum length of the resulting string after removing the minimum number of characters such that there are no two consecutive 'a's left in the resulting string. >>> max_length_no_consecutive_a(\\"babaa\\") 4 >>> max_length_no_consecutive_a(\\"aabaaa\\") 3","solution":"def max_length_no_consecutive_a(s): Returns the maximum length of the resulting string after removing the minimum number of characters such that there are no two consecutive 'a's left in the resulting string. max_length = 0 count_a = 0 for i, char in enumerate(s): if char == 'a': count_a += 1 # Reset count_a if more than one consecutive 'a' found if count_a > 1: count_a = 1 max_length -= 1 else: count_a = 0 max_length += 1 return max_length"},{"question":"def max_difference(N, A, queries): Compute the maximum possible difference between any two elements within the subarray A[L ... R]. N: int - Number of elements in the array A: list of int - Array of integers queries: list of tuple of int - Each query is a pair (L, R) Example: >>> max_difference(5, [1, 5, 3, 2, 4], [(1, 3), (2, 5), (1, 5)]) [4, 3, 4] >>> max_difference(6, [10, 20, 15, 7, 18, 12], [(1, 4), (3, 6)]) [13, 11] # Your implementation here from solution import max_difference def test_max_difference_case1(): N = 5 A = [1, 5, 3, 2, 4] queries = [(1, 3), (2, 5), (1, 5)] expected = [4, 3, 4] assert max_difference(N, A, queries) == expected def test_max_difference_case2(): N = 6 A = [10, 20, 15, 7, 18, 12] queries = [(1, 4), (3, 6)] expected = [13, 11] assert max_difference(N, A, queries) == expected def test_max_difference_all_same_elements(): N = 5 A = [7, 7, 7, 7, 7] queries = [(1, 5), (2, 4)] expected = [0, 0] assert max_difference(N, A, queries) == expected def test_max_difference_single_element(): N = 1 A = [100] queries = [(1, 1)] expected = [0] assert max_difference(N, A, queries) == expected def test_max_difference_large_numbers(): N = 4 A = [1000000000, 999999999, 1, 500000000] queries = [(1, 4), (2, 3), (3, 4)] expected = [999999999, 999999998, 499999999] assert max_difference(N, A, queries) == expected","solution":"def max_difference(N, A, queries): results = [] for L, R in queries: subarray = A[L-1:R] max_diff = max(subarray) - min(subarray) results.append(max_diff) return results if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) A = list(map(int, data[1:N+1])) Q = int(data[N+1]) queries = [(int(data[N+2 + 2*i]), int(data[N+3 + 2*i])) for i in range(Q)] results = max_difference(N, A, queries) for result in results: print(result)"},{"question":"def is_balanced_tree(N, edges): Determines if the given weighted undirected tree is a balanced tree. Parameters: N (int): Number of vertices in the tree. edges (List of tuples): Each tuple contains three integers (u, v, w), representing an edge between vertices u and v with weight w. Returns: str: \\"Yes\\" if the tree is a balanced tree, \\"No\\" otherwise. >>> is_balanced_tree(3, [(1, 2, 3), (2, 3, 3)]) \\"Yes\\" >>> is_balanced_tree(4, [(1, 2, 1), (2, 3, 2), (3, 4, 1)]) \\"No\\" pass def test_case_1(): N = 3 edges = [(1, 2, 3), (2, 3, 3)] assert is_balanced_tree(N, edges) == \\"Yes\\" def test_case_2(): N = 4 edges = [(1, 2, 1), (2, 3, 2), (3, 4, 1)] assert is_balanced_tree(N, edges) == \\"No\\" def test_single_edge(): N = 2 edges = [(1, 2, 5)] assert is_balanced_tree(N, edges) == \\"Yes\\" def test_balanced_large_tree(): N = 4 edges = [(1, 2, 2), (2, 3, 2), (2, 4, 2)] assert is_balanced_tree(N, edges) == \\"Yes\\" def test_not_balanced_large_tree(): N = 5 edges = [(1, 2, 1), (2, 3, 2), (2, 4, 1), (4, 5, 2)] assert is_balanced_tree(N, edges) == \\"No\\"","solution":"def is_balanced_tree(N, edges): Determines if the given weighted undirected tree is a balanced tree. Parameters: N (int): Number of vertices in the tree. edges (List of tuples): Each tuple contains three integers (u, v, w), representing an edge between vertices u and v with weight w. Returns: str: \\"Yes\\" if the tree is a balanced tree, \\"No\\" otherwise. if N == 2: return \\"Yes\\" # Any tree with 2 vertices and 1 edge is trivially balanced # Finding unique weights weights = set() for edge in edges: _, _, w = edge weights.add(w) # Tree is balanced if all weights are the same if len(weights) == 1: return \\"Yes\\" return \\"No\\""},{"question":"def min_key_presses(target: str) -> int: Returns the minimum number of key presses required to type the target string using the keyboard with \\"Append\\" and \\"Delete\\" keys. >>> min_key_presses(\\"abcde\\") 5 >>> min_key_presses(\\"aabcc\\") 5","solution":"def min_key_presses(target: str) -> int: Returns the minimum number of key presses required to type the target string using the keyboard with \\"Append\\" and \\"Delete\\" keys. # The minimum number of key presses is equal to the length of the target string, # since we will need to use the \\"Append\\" key once for each character. return len(target)"},{"question":"def min_moves_to_reach_destination(R: int, C: int, grid: List[str]) -> int: Returns the minimum number of moves required to reach the bottom-right corner from the top-left corner in the given grid, or -1 if it's impossible. >>> min_moves_to_reach_destination(4, 4, [\\"....\\", \\"..\\", \\"..#.\\", \\"....\\"]) 6 >>> min_moves_to_reach_destination(3, 3, [\\".#.\\", \\".#.\\", \\"...\\"]) 4 >>> min_moves_to_reach_destination(3, 3, [\\"#\\", \\"#..\\", \\"...\\"]) -1","solution":"from collections import deque def min_moves_to_reach_destination(R, C, grid): Returns the minimum number of moves required to reach the bottom-right corner from the top-left corner in the given grid, or -1 if it's impossible. # Directions for up, down, left, right moves directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Check if start or end is blocked if grid[0][0] == '#' or grid[R-1][C-1] == '#': return -1 # Breadth-First Search queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set() visited.add((0, 0)) while queue: row, col, steps = queue.popleft() if (row, col) == (R-1, C-1): return steps for dr, dc in directions: nr, nc = row + dr, col + dc if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] == '.' and (nr, nc) not in visited: queue.append((nr, nc, steps + 1)) visited.add((nr, nc)) return -1"},{"question":"from typing import List, Tuple def count_connected_components(n: int, edges: List[Tuple[int, int]]) -> int: Given an undirected graph represented as an adjacency list, count the number of connected components in the graph. >>> count_connected_components(5, [(1, 2), (2, 3), (4, 5)]) 2 >>> count_connected_components(6, [(1, 2), (2, 3), (4, 5), (5, 6), (4, 6)]) 2","solution":"def count_connected_components(n, edges): from collections import defaultdict, deque # Create an adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() def bfs(start): queue = deque([start]) while queue: vertex = queue.popleft() for neighbor in graph[vertex]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) components = 0 for vertex in range(1, n+1): if vertex not in visited: bfs(vertex) components += 1 return components # Example usage: # n = 5 # edges = [(1, 2), (2, 3), (4, 5)] # print(count_connected_components(n, edges)) # Output: 2 # n = 6 # edges = [(1, 2), (2, 3), (4, 5), (5, 6), (4, 6)] # print(count_connected_components(n, edges)) # Output: 2"},{"question":"def longest_increasing_subsequence(transactions): Function to calculate the length of the longest increasing subsequence. :param transactions: List of integers representing transaction amounts. :return: Length of the longest increasing subsequence. # Implementation goes here from solution import longest_increasing_subsequence def test_single_element(): assert longest_increasing_subsequence([10]) == 1 def test_all_decreasing(): assert longest_increasing_subsequence([5, 4, 3, 2, 1]) == 1 def test_all_increasing(): assert longest_increasing_subsequence([1, 2, 3, 4, 5]) == 5 def test_mixed_elements(): assert longest_increasing_subsequence([5, 2, 8, 6, 3, 6]) == 3 def test_empty(): assert longest_increasing_subsequence([]) == 0 def test_alternating(): assert longest_increasing_subsequence([1, 3, 2, 4, 3, 5]) == 4","solution":"def longest_increasing_subsequence(transactions): Function to calculate the length of the longest increasing subsequence. :param transactions: List of integers representing transaction amounts. :return: Length of the longest increasing subsequence. n = len(transactions) if n == 0: return 0 # Initialize the dp array to store the maximum sequence length at each position dp = [1] * n for i in range(1, n): for j in range(i): if transactions[i] > transactions[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence return max(dp)"},{"question":"def can_distribute_fruits(c: int, m: int, b: int) -> str: Determines if it's possible to distribute m liters of mangoes and b liters of bananas into containers of capacity c without exceeding the capacity of any container. Example: >>> can_distribute_fruits(10, 20, 30) 'YES' >>> can_distribute_fruits(5, 14, 3) 'NO'","solution":"def can_distribute_fruits(c, m, b): Determines if it's possible to distribute m liters of mangoes and b liters of bananas into containers of capacity c without exceeding the capacity of any container. :param c: int, maximum capacity of each container :param m: int, total liters of mangoes :param b: int, total liters of bananas :return: str, \\"YES\\" if possible, otherwise \\"NO\\" # Check if the total mangoes and bananas can be exactly divided into containers if (m % c == 0) and (b % c == 0): return \\"YES\\" else: return \\"NO\\""},{"question":"def maximize_crystal_power(test_cases): Maximize the total power of the crystals after performing a sequence of operations optimally. Args: test_cases (List[List[int]]): List of test cases, where each test case is a list with the first integer N (number of crystals) followed by N integers representing the power of each crystal. Returns: List[int]: List of integers representing the maximum possible power of the final crystal for each test case. Example: >>> maximize_crystal_power([[2, 2, 3]]) [6] >>> maximize_crystal_power([[3, 1, 2, 3]]) [6] >>> maximize_crystal_power([[4, 1, 2, 3, 4]]) [24]","solution":"def maximize_crystal_power(test_cases): results = [] for case in test_cases: N, crystals = case[0], case[1:] while len(crystals) > 1: max_product = 0 max_index = 0 for i in range(len(crystals) - 1): product = crystals[i] * crystals[i + 1] if product > max_product: max_product = product max_index = i # Combine the crystals combined_power = max_product crystals[max_index] = combined_power crystals.pop(max_index + 1) # Add the last remaining crystal's power to the results results.append(crystals[0]) return results"},{"question":"def uniquePaths(M: int, N: int) -> List[str]: Returns all unique paths from the top-left corner to the bottom-right corner of an MxN matrix allowing only rightward and downward movements. >>> uniquePaths(2, 2) [\\"DR\\", \\"RD\\"] >>> uniquePaths(3, 3) [\\"DDRR\\", \\"DRDR\\", \\"DRRD\\", \\"RDDR\\", \\"RDRD\\", \\"RRDD\\"] paths = [] # Function to find all paths recursively","solution":"def uniquePaths(M, N): Returns all unique paths from the top-left corner to the bottom-right corner of an MxN matrix allowing only rightward and downward movements. def find_paths(i, j, path): # Base case: When reaching the last cell (M-1, N-1), add the current path to results if i == M - 1 and j == N - 1: paths.append(path) return # Move down if not on the last row if i < M - 1: find_paths(i + 1, j, path + 'D') # Move right if not on the last column if j < N - 1: find_paths(i, j + 1, path + 'R') paths = [] find_paths(0, 0, \\"\\") return paths"},{"question":"def analyze_scores(N, scores): Analyzes the scores to find the number of distinct scores and the second highest score. Parameters: N (int): Number of students. scores (list): List of scores. Returns: tuple: Number of distinct scores and the second highest score (or -1 if not applicable). >>> analyze_scores(5, [85, 75, 85, 90, 100]) (4, 90) >>> analyze_scores(3, [50, 50, 50]) (1, -1)","solution":"def analyze_scores(N, scores): Analyzes the scores to find the number of distinct scores and the second highest score. Parameters: N (int): Number of students. scores (list): List of scores. Returns: tuple: Number of distinct scores and the second highest score (or -1 if not applicable). distinct_scores = list(set(scores)) distinct_count = len(distinct_scores) if distinct_count < 2: second_highest = -1 else: distinct_scores.sort(reverse=True) second_highest = distinct_scores[1] return distinct_count, second_highest"},{"question":"def fizz_buzz_transform(lst): Transforms the given list according to the FizzBuzz rules. For any integer in the list that is an exact multiple of 3, replace it with the string \\"Fizz\\". For any integer in the list that is an exact multiple of 5, replace it with the string \\"Buzz\\". For any integer in the list that is an exact multiple of both 3 and 5, replace it with the string \\"FizzBuzz\\". If an integer is neither a multiple of 3 nor 5, leave it unchanged. Args: lst (list of int): List of integers to be transformed. Returns: list: Transformed list where multiples of 3 are replaced with \\"Fizz\\", multiples of 5 with \\"Buzz\\", and multiples of 3 and 5 with \\"FizzBuzz\\". >>> fizz_buzz_transform([1, 2, 3, 4, 5]) [1, 2, \\"Fizz\\", 4, \\"Buzz\\"] >>> fizz_buzz_transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", 7, 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, 14, \\"FizzBuzz\\"] >>> fizz_buzz_transform([-3, 3, 5]) [\\"Fizz\\", \\"Fizz\\", \\"Buzz\\"]","solution":"def fizz_buzz_transform(lst): Transforms the given list according to the FizzBuzz rules. Args: lst (list of int): List of integers to be transformed. Returns: list: Transformed list where multiples of 3 are replaced with \\"Fizz\\", multiples of 5 with \\"Buzz\\", and multiples of 3 and 5 with \\"FizzBuzz\\". result = [] for num in lst: if num % 3 == 0 and num % 5 == 0: result.append(\\"FizzBuzz\\") elif num % 3 == 0: result.append(\\"Fizz\\") elif num % 5 == 0: result.append(\\"Buzz\\") else: result.append(num) return result"},{"question":"def find_longest_word(s: str) -> str: Returns the longest word in the given string s. If there are multiple words with the same maximum length, the first one is returned. >>> find_longest_word(\\"hello\\") \\"hello\\" >>> find_longest_word(\\"The quick brown fox\\") \\"quick\\" >>> find_longest_word(\\"jumps over the lazy dog\\") \\"jumps\\" >>> find_longest_word(\\"cat bat rat\\") \\"cat\\" >>> find_longest_word(\\"beast feast least yeast\\") \\"beast\\" >>> find_longest_word(\\"\\") \\"\\" >>> find_longest_word(\\"a i u e o\\") \\"a\\" >>> find_longest_word(\\"b c d e f\\") \\"b\\"","solution":"def find_longest_word(s): Returns the longest word in the given string s. If there are multiple words with the same maximum length, the first one is returned. longest_word = \\"\\" words = s.split() for word in words: if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"def calculate_weight(s: str) -> int: Returns the weight of the string, calculated as the sum of the positions of the characters in the English alphabet. Parameters: s (str): Input string containing only lowercase alphabets. Returns: int: The weight of the string. >>> calculate_weight(\\"abc\\") == 6 >>> calculate_weight(\\"xyz\\") == 75 >>> calculate_weight(\\"a\\") == 1 >>> calculate_weight(\\"\\") == 0 >>> calculate_weight(\\"z\\") == 26 >>> calculate_weight(\\"az\\") == 27 >>> calculate_weight(\\"alphabet\\") == 65","solution":"def calculate_weight(s): Returns the weight of the string, calculated as the sum of the positions of the characters in the English alphabet. Parameters: s (str): Input string containing only lowercase alphabets. Returns: int: The weight of the string. return sum((ord(char) - ord('a') + 1) for char in s)"},{"question":"def max_sum_after_replacement(n: int, m: int, a: List[int]) -> int: Calculates the maximum possible sum of the array after performing the described operation. Parameters: n (int): Length of the array m (int): Maximum value an element can take a (list): List of integers, the given array Returns: int: Maximum possible sum of the array from solution import max_sum_after_replacement def test_case_1(): assert max_sum_after_replacement(5, 10, [1, 2, 3, 4, 5]) == 50 def test_case_2(): assert max_sum_after_replacement(4, 7, [-1, -1, -1, -1]) == 28 def test_case_3(): assert max_sum_after_replacement(3, 5, [2, -3, 1]) == 15 def test_case_4(): assert max_sum_after_replacement(6, 8, [4, 2, -5, 3, -1, 2]) == 48 def test_case_5(): assert max_sum_after_replacement(2, 1, [4, 5]) == 2 def test_case_6(): # Minimum case edge case assert max_sum_after_replacement(1, 1, [-10**9]) == 1 def test_case_7(): # Large numbers edge case array = [10**8] * 5 + [-10**8] * 5 assert max_sum_after_replacement(10, 10**9, array) == 10 * 10**9","solution":"def max_sum_after_replacement(n, m, a): Calculates the maximum possible sum of the array after performing the described operation. Parameters: n (int): Length of the array m (int): Maximum value an element can take a (list): List of integers, the given array Returns: int: Maximum possible sum of the array # Calculate the sum of the original array original_sum = sum(a) # Calculate the sum of all elements replaced by \`m\` replaced_sum = sum([m] * n) # The replacement operation will replace all the elements in the array max_sum = replaced_sum return max_sum"},{"question":"def can_grow_continuous_patch(n: int, m: int, garden: List[str]) -> str: Determine if it's possible to grow a single, continuous patch of crops in the garden. >>> can_grow_continuous_patch(4, 5, [\\"..#..\\", \\".#...\\", \\".....\\", \\"...\\"]) == \\"YES\\" >>> can_grow_continuous_patch(3, 3, [\\"..#\\", \\".#.\\", \\".#.\\"]) == \\"NO\\" >>> can_grow_continuous_patch(3, 3, [\\"#\\", \\"#\\", \\"#\\"]) == \\"NO\\" >>> can_grow_continuous_patch(2, 2, [\\"..\\", \\"..\\"]) == \\"YES\\" >>> can_grow_continuous_patch(5, 5, [\\".....\\", \\"#\\", \\".....\\", \\"#\\", \\".....\\"]) == \\"NO\\"","solution":"def can_grow_continuous_patch(n, m, garden): from collections import deque # Direction vectors for going up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Function to find starting point of first fertile cell def find_start(): for i in range(n): for j in range(m): if garden[i][j] == '.': return (i, j) return None # Function to execute BFS from a starting fertile cell def bfs(start): queue = deque([start]) visited.add(start) while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and garden[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) start = find_start() if not start: # No fertile ground at all return \\"NO\\" visited = set() bfs(start) # Check if there are any unvisited fertile cells for i in range(n): for j in range(m): if garden[i][j] == '.' and (i, j) not in visited: return \\"NO\\" return \\"YES\\""},{"question":"def minMeetingHeight(heights: List[int]) -> int: Function to find the minimum height that two people will encounter as they move towards each other from the start and end of the height list. Args: heights: List[int]: List of building heights. Returns: int: Minimum height encountered. Examples: >>> minMeetingHeight([5, 3, 6, 4, 2, 4, 1, 2]) 2 >>> minMeetingHeight([1, 2, 3, 4, 5]) 1 pass","solution":"def minMeetingHeight(heights): Function to find the minimum height that two people will encounter as they move towards each other from the start and end of the height list. n = len(heights) # Initialize pointers for the two people left = 0 right = n - 1 # Initialize the minimum height encountered min_height = min(heights[left], heights[right]) # Move both pointers towards each other while left < right: if heights[left] < heights[right]: left += 1 min_height = min(min_height, heights[left]) else: right -= 1 min_height = min(min_height, heights[right]) return min_height"},{"question":"def max_beauty(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Compute the maximum possible beauty for subsets with at least two elements. T: Number of test cases test_cases: List of tuples, each consisting of (N, array) >>> max_beauty(2, [(3, [1, 4, 7]), (4, [-2, 0, 2, 3])]) [12, 10] >>> max_beauty(1, [(5, [-10, -5, 0, 5, 10])]) [40] >>> max_beauty(1, [(3, [-1, -4, -7])]) [12] >>> max_beauty(1, [(3, [-1000000000, 0, 1000000000])]) [4000000000] >>> max_beauty(1, [(4, [-5, -1, 2, 8])]) [26]","solution":"def max_beauty(T, test_cases): Returns the maximum possible beauty for each test case. T: Number of test cases test_cases: List of tuples, each consisting of (N, array) results = [] for i in range(T): N, arr = test_cases[i] arr.sort() # Maximum beauty will be between the smallest and largest elements in the sorted array max_beauty = (arr[-1] - arr[0]) + (arr[-1] - arr[0]) results.append(max_beauty) return results"},{"question":"def lexicographically_smallest_string(N: int, binary_string: str) -> str: Returns the lexicographically smallest string derived from binary_string by performing the operations described. >>> lexicographically_smallest_string(3, \\"101\\") == \\"000\\" >>> lexicographically_smallest_string(5, \\"11001\\") == \\"00000\\" def process_test_cases(T: int, test_cases: List[Tuple[int, str]]) -> List[str]: Processes multiple test cases and returns the results. >>> process_test_cases(2, [(3, \\"101\\"), (5, \\"11001\\")]) == [\\"000\\", \\"00000\\"]","solution":"def lexicographically_smallest_string(N, binary_string): Returns the lexicographically smallest string derived from binary_string by performing the operations described. count_zeros = binary_string.count('0') return '0' * N def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] binary_string = test_cases[i][1] results.append(lexicographically_smallest_string(N, binary_string)) return results"},{"question":"def can_sum_to_target(nums: List[int], target: int) -> bool: Determines if there is a subset of \`nums\` that adds up exactly to \`target\`. pass def can_find_subsets_that_sum_to_target(test_cases: List[Tuple[List[int], int]]) -> List[str]: Determines for each test case if there exists a subset of the numbers that adds up to the target sum. Args: test_cases: A list of tuples where each tuple contains a list of integers (the sequence) and an integer (the target sum). Returns: A list of strings \\"YES\\" or \\"NO\\" corresponding to each test case. >>> can_find_subsets_that_sum_to_target([([2, 3, 7, 8, 10], 10), ([1, 2, 4, 8], 15), ([1, 1, 1], 5)]) == [\\"YES\\", \\"YES\\", \\"NO\\"] >>> can_find_subsets_that_sum_to_target([([], 0), ([], 1)]) == [\\"YES\\", \\"NO\\"] >>> can_find_subsets_that_sum_to_target([([5], 5), ([5], 10)]) == [\\"YES\\", \\"NO\\"] >>> can_find_subsets_that_sum_to_target([([3, 34, 4, 12, 5, 2], 9), ([1, 2, 3], 6), ([1, 2, 3], 5)]) == [\\"YES\\", \\"YES\\", \\"YES\\"] >>> can_find_subsets_that_sum_to_target([([100000], 100000), ([100000, 99999], 199999), ([100000, 99999, 1], 199999)]) == [\\"YES\\", \\"YES\\", \\"YES\\"] pass","solution":"def can_sum_to_target(nums, target): Determines if there is a subset of \`nums\` that adds up exactly to \`target\`. n = len(nums) dp = [False] * (target + 1) dp[0] = True # sum of 0 is always possible with empty subset for num in nums: for t in range(target, num - 1, -1): if dp[t - num]: dp[t] = True return dp[target] def can_find_subsets_that_sum_to_target(test_cases): results = [] for nums, target in test_cases: if can_sum_to_target(nums, target): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def reformat(s: str) -> str: Reformats the input string so that letters and digits alternate. If it is not possible, returns an empty string. >>> reformat(\\"a0b1\\") \\"a0b1\\" or \\"0a1b\\" >>> reformat(\\"1229857369\\") \\"\\" >>> reformat(\\"abcdef\\") \\"\\" >>> reformat(\\"123456\\") \\"\\" >>> reformat(\\"a1b2c3\\") \\"a1b2c3\\" or \\"1a2b3c\\" >>> reformat(\\"1a2b3c\\") \\"1a2b3c\\" or \\"a1b2c3\\" >>> reformat(\\"a1b2c3d\\") \\"a1b2c3d\\" or \\"1a2b3cd\\" or \\"d1a2b3c\\" >>> reformat(\\"a\\") \\"a\\" >>> reformat(\\"1\\") \\"1\\" >>> reformat(\\"a1\\") \\"a1\\" or \\"1a\\" >>> reformat(\\"aa\\") \\"\\" >>> reformat(\\"11\\") \\"\\"","solution":"def reformat(s: str) -> str: Reformats the input string so that letters and digits alternate. If it is not possible, returns an empty string. letters = [ch for ch in s if ch.isalpha()] digits = [ch for ch in s if ch.isdigit()] if abs(len(letters) - len(digits)) > 1: return \\"\\" if len(letters) > len(digits): result = [None] * len(s) result[::2], result[1::2] = letters, digits else: result = [None] * len(s) result[::2], result[1::2] = digits, letters return ''.join(result)"},{"question":"def total_distance_for_marathon(test_cases: list) -> list: Calculate the total distance Aditya will run for each test case. Args: test_cases (list): A list where each element is a tuple (X, Y) for each test case. Returns: list: A list of total distances for each test case. Examples: >>> total_distance_for_marathon([(5, 3)]) [15] >>> total_distance_for_marathon([(5, 3), (10, 2), (4, 29)]) [15, 20, 116] from solution import total_distance_for_marathon def test_single_test_case(): assert total_distance_for_marathon([(5, 3)]) == [15] def test_multiple_test_cases(): assert total_distance_for_marathon([(5, 3), (10, 2), (4, 29)]) == [15, 20, 116] def test_minimum_values(): assert total_distance_for_marathon([(1, 1)]) == [1] def test_maximum_values(): assert total_distance_for_marathon([(100, 100)]) == [10000] def test_mixed_values(): assert total_distance_for_marathon([(50, 2), (3, 33), (12, 5)]) == [100, 99, 60]","solution":"def total_distance_for_marathon(test_cases: list) -> list: Calculate the total distance Aditya will run for each test case. Args: test_cases (list): A list where each element is a tuple (X, Y) for each test case. Returns: list: A list of total distances for each test case. results = [] for x, y in test_cases: results.append(x * y) return results"},{"question":"def is_prime_list(integers: List[int]) -> List[bool]: Determine which integers from the list are prime numbers. >>> is_prime_list([10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) [False, True, False, True, False, False, False, True, False, True] >>> is_prime_list([2, 3, 4, 5, 6, 7, 8, 9, 10]) [True, True, False, True, False, True, False, False, False]","solution":"def is_prime(n): Returns True if n is a prime number, else False if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_prime_list(integers): Returns a list of booleans indicating the primality of each integer in the input list. return [is_prime(num) for num in integers]"},{"question":"def split_list(lst: list) -> tuple: Splits a list into two lists: one with even indexed elements and one with odd indexed elements. Parameters: lst (list): The list of integers to be split. Returns: tuple: A tuple containing two lists: the first list with even indexed elements and the second list with odd indexed elements. >>> split_list([2, 1, 4, 3, 6, 5]) ([2, 4, 6], [1, 3, 5]) >>> split_list([10, 20, 30, 40, 50]) ([10, 30, 50], [20, 40]) >>> split_list([]) ([], []) >>> split_list([1]) ([1], []) >>> split_list([1, 2]) ([1], [2])","solution":"def split_list(lst): Splits a list into two lists: one with even indexed elements and one with odd indexed elements. Parameters: lst (list): The list of integers to be split. Returns: tuple: A tuple containing two lists: the first list with even indexed elements and the second list with odd indexed elements. even_indexed = lst[0::2] odd_indexed = lst[1::2] return even_indexed, odd_indexed"},{"question":"def max_meetings(meetings: List[Tuple[int, int]]) -> int: Finds the maximum number of non-overlapping meetings that can be scheduled in one meeting room. Parameters: meetings (list of tuple): List of tuples where each tuple contains two integers, the start and end times of a meeting. Returns: int: Maximum number of non-overlapping meetings. >>> max_meetings([(1, 2), (3, 4), (0, 6)]) 2 >>> max_meetings([(1, 3), (2, 4), (3, 5), (7, 8)]) 3 >>> max_meetings([(1, 2)]) 1 >>> max_meetings([]) 0","solution":"def max_meetings(meetings): Finds the maximum number of non-overlapping meetings. Parameters: meetings (list of tuple): List of tuples where each tuple contains two integers, the start and end times of a meeting. Returns: int: Maximum number of non-overlapping meetings. # Sort meetings based on their end times meetings.sort(key=lambda x: x[1]) last_end_time = 0 total_meetings = 0 for start, end in meetings: if start >= last_end_time: total_meetings += 1 last_end_time = end return total_meetings"},{"question":"def count_paths(N: int, M: int, grid: List[List[str]]) -> int: Count the number of distinct paths that the character can take to reach the bottom-right corner from the top-left corner of the grid, while avoiding obstacles. Since this number can be very large, compute it modulo 10^9+7. >>> count_paths(3, 3, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) 2 >>> count_paths(3, 3, [['.', '#', '.'], ['#', '.', '#'], ['.', '.', '.']]) 0 >>> count_paths(2, 2, [['.', '.'], ['.', '.']]) 2 >>> count_paths(1, 1, [['.']]) 1 >>> count_paths(3, 3, [['#', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) 0 >>> count_paths(3, 3, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '#']]) 0 pass","solution":"MOD = 10**9 + 7 def count_paths(N, M, grid): if grid[0][0] == '#' or grid[N-1][M-1] == '#': return 0 dp = [[0] * M for _ in range(N)] dp[0][0] = 1 for i in range(N): for j in range(M): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[N-1][M-1]"},{"question":"def min_removals_to_sort(arr): Returns the minimum number of elements to remove to make the array non-decreasing. >>> min_removals_to_sort([5, 3, 4, 7, 2, 8]) == 2 >>> min_removals_to_sort([1, 2, 3, 4, 5, 6]) == 0 >>> min_removals_to_sort([6, 5, 4, 3, 2, 1]) == 5 >>> min_removals_to_sort([1]) == 0 >>> min_removals_to_sort([1, 3, 2, 5, 4, 6]) == 2","solution":"def min_removals_to_sort(arr): Returns the minimum number of elements to remove to make the array non-decreasing. def lis_length(arr): from bisect import bisect_left lis = [] for num in arr: pos = bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis) n = len(arr) lis_len = lis_length(arr) return n - lis_len def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:])) print(min_removals_to_sort(arr))"},{"question":"from typing import List def is_prime(n: int) -> bool: Checks if a number is prime. # Function implementation goes here def exists_prime_subset_sum(N: int, array: List[int]) -> str: Determines if there exists a subset of the given array such that the sum of the subset is a prime number. >>> exists_prime_subset_sum(5, [1, 2, 3, 4, 5]) \\"YES\\" >>> exists_prime_subset_sum(4, [4, 6, 8, 10]) \\"NO\\" >>> exists_prime_subset_sum(1, [2]) \\"YES\\" >>> exists_prime_subset_sum(1, [4]) \\"NO\\" # Function implementation goes here","solution":"from itertools import combinations def is_prime(n): Checks if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % i + 2 == 0: return False i += 6 return True def exists_prime_subset_sum(N, array): Determines if there exists a subset of the given array such that the sum of the subset is a prime number. for r in range(1, N + 1): for subset in combinations(array, r): if is_prime(sum(subset)): return \\"YES\\" return \\"NO\\""},{"question":"def reverse_words(s: str) -> str: Reverses the order of characters within each word in the given string s, while maintaining the spaces between words. Args: s (str): The input string containing alphabetical characters and spaces. Returns: str: The transformed string with each word's characters reversed. Example: >>> reverse_words(\\"hello world\\") 'olleh dlrow' >>> reverse_words(\\"code assessment\\") 'edoc tnemssessa' >>> reverse_words(\\"reverse these words\\") 'esrever eseht sdrow' >>> reverse_words(\\"a b c\\") 'a b c'","solution":"def reverse_words(s): Reverses the order of characters within each word in the given string s, while maintaining the spaces between words. Args: s (str): The input string containing alphabetical characters and spaces. Returns: str: The transformed string with each word's characters reversed. return ' '.join(word[::-1] for word in s.split(' '))"},{"question":"def inventory_system(operations): Simulate the inventory system for a warehouse. Track operations and handle LOAD and UNLOAD commands with safety checks. >>> inventory_system([\\"LOAD apple 100\\", \\"LOAD banana 150\\", \\"UNLOAD apple 50\\", \\"UNLOAD apple 60\\", \\"UNLOAD banana 200\\"]) [\\"Insufficient items\\"] >>> inventory_system([\\"LOAD widget 500\\", \\"UNLOAD widget 300\\", \\"LOAD widget 200\\", \\"UNLOAD widget 400\\"]) [\\"Insufficient items\\"]","solution":"def inventory_system(operations): inventory = {} results = [] for op in operations: parts = op.split() command = parts[0] item = parts[1] quantity = int(parts[2]) if command == \\"LOAD\\": if item in inventory: inventory[item] += quantity else: inventory[item] = quantity elif command == \\"UNLOAD\\": if item not in inventory or inventory[item] < quantity: results.append(\\"Insufficient items\\") else: inventory[item] -= quantity return results"},{"question":"def minSteps(n: int) -> int: Given a number n, find the minimum number of steps to reach n from 1 under the following conditions: - You can multiply the current number by 2. - You can subtract 1 from the current number. Args: n (int): The target number. Returns: int: The minimum number of steps to reach n. Example: >>> minSteps(3) 2 >>> minSteps(10) 4 >>> minSteps(1) 0 >>> minSteps(1024) 10 >>> minSteps(15) 6","solution":"def minSteps(n): Given a number n, find the minimum number of steps to reach n from 1 under the following conditions: - You can multiply the current number by 2. - You can subtract 1 from the current number. Args: n (int): The target number. Returns: int: The minimum number of steps to reach n. steps = 0 while n > 1: if n % 2 == 0: n //= 2 else: n -= 1 steps += 1 return steps"},{"question":"def format_title(input_str): Formats an input string as a title according to the specified criteria. 1) The first letter of each word is capitalized. 2) All other letters in each word are lowercase. 3) Words are separated by a single space. 4) The input string may contain excess whitespace (leading, trailing, and between words), which should be trimmed to a single space between words in the output. 5) If the input string contains any non-alphabetic characters (not including spaces), the function returns None. Args: input_str (str): The input string to be formatted. Returns: str or None: The formatted title string or None if the input contains non-alphabetic characters. Examples: >>> format_title(\\" hello world \\") \\"Hello World\\" >>> format_title(\\"3 elephants are here\\") None","solution":"def format_title(input_str): Formats an input string as a title according to the specified criteria. 1) The first letter of each word is capitalized. 2) All other letters in each word are lowercase. 3) Words are separated by a single space. 4) The input string may contain excess whitespace (leading, trailing, and between words), which should be trimmed to a single space between words in the output. 5) If the input string contains any non-alphabetic characters (not including spaces), the function returns None. Args: input_str (str): The input string to be formatted. Returns: str or None: The formatted title string or None if the input contains non-alphabetic characters. # Strip the input string to remove leading and trailing whitespace trimmed_str = input_str.strip() # Check and return None if there are any non-alphabetic characters (excluding spaces) if not all(char.isalpha() or char.isspace() for char in trimmed_str): return None # Split the string into words, capitalize each word, and join them with a single space words = trimmed_str.split() capitalized_words = [word.capitalize() for word in words] return ' '.join(capitalized_words)"},{"question":"def decode_message(message: str, rotations: int) -> str: Decodes the message by rotating it to the left by the given number of rotations. >>> decode_message(\\"abcd\\", 2) 'cdab' >>> decode_message(\\"abcdef\\", 3) 'defabc' >>> decode_message(\\"xyz\\", 10) 'yzx' pass def process_test_cases(test_cases: List[Tuple[str, int]]) -> List[str]: Processes a list of test cases and returns the decoded messages. >>> process_test_cases([(\\"abcd\\", 2), (\\"abcdef\\", 3), (\\"xyz\\", 10)]) ['cdab', 'defabc', 'yzx'] pass","solution":"def decode_message(message, rotations): Decodes the message by rotating it to the left by the given number of rotations. :param message: The encoded message string consisting of lowercase letters. :param rotations: The number of left rotations to decode the message. :return: The decoded message string. n = len(message) rotations %= n # To handle cases where rotations are greater than the length of the message return message[rotations:] + message[:rotations] def process_test_cases(test_cases): Processes a list of test cases and returns the decoded messages. :param test_cases: A list of tuples where each tuple contains a message string and an integer for rotations. :return: A list of decoded message strings. results = [] for message, rotations in test_cases: results.append(decode_message(message, rotations)) return results"},{"question":"def calculate_savings(T: int, test_cases: List[Tuple[int, int, int]]) -> List[float]: Calculate the amount of money saved by availing the promotion for given test cases. >>> calculate_savings(3, [(10, 5, 20), (15, 3, 10), (20, 2, 50)]) [10.0, 4.5, 20.0] >>> calculate_savings(1, [(100, 1, 100)]) [100.0] >>> calculate_savings(2, [(50, 4, 10), (75, 2, 50)]) [20.0, 75.0] >>> calculate_savings(4, [(25, 10, 5), (10, 20, 15), (22, 5, 30), (30, 3, 40)]) [12.5, 30.0, 33.0, 36.0] >>> calculate_savings(2, [(10, 5, 0), (20, 2, 0)]) [0.0, 0.0] >>> calculate_savings(2, [(10, 1, 50), (20, 1, 25)]) [5.0, 5.0]","solution":"def calculate_savings(T, test_cases): savings = [] for i in range(T): P, N, K = test_cases[i] original_total_price = P * N discount_amount = original_total_price * (K / 100) savings.append(discount_amount) return savings # Reading input is not handled here since this is defined as a function to be used elsewhere"},{"question":"def find_longest_unique_sublist(sequence): Returns the longest sublist with unique elements and its length. >>> find_longest_unique_sublist([4, 5, 2, 3, 4, 2, 5]) (4, [4, 5, 2, 3]) >>> find_longest_unique_sublist([7, 8, 8, 2, 3, 4, 5, 1, 2]) (6, [8, 2, 3, 4, 5, 1]) pass def longest_unique_sublists(test_cases): Given a list of test cases where each test case is a sequence of integers, return the result for each test case as described in the problem. >>> longest_unique_sublists([[4, 5, 2, 3, 4, 2, 5], [7, 8, 8, 2, 3, 4, 5, 1, 2]]) [(4, [4, 5, 2, 3]), (6, [8, 2, 3, 4, 5, 1])] pass","solution":"def find_longest_unique_sublist(sequence): Returns the longest sublist with unique elements and its length. max_length = 0 start = 0 max_start = 0 seen = {} for end, value in enumerate(sequence): if value in seen and seen[value] >= start: start = seen[value] + 1 seen[value] = end if end - start + 1 > max_length: max_length = end - start + 1 max_start = start return max_length, sequence[max_start:max_start + max_length] def longest_unique_sublists(test_cases): Given a list of test cases where each test case is a sequence of integers, return the result for each test case as described in the problem. results = [] for case in test_cases: max_length, sublist = find_longest_unique_sublist(case) results.append((max_length, sublist)) return results"},{"question":"class QueueUsingStacks: def __init__(self): Initialize your data structure here. self.stack1 = [] self.stack2 = [] def enqueue(self, x: int) -> None: Add element x to the back of the queue. >>> queue = QueueUsingStacks() >>> queue.enqueue(1) >>> queue.enqueue(2) >>> queue.enqueue(3) >>> queue.dequeue() 1 >>> queue.dequeue() 2 >>> queue.enqueue(4) >>> queue.dequeue() 3 >>> queue.dequeue() 4 >>> queue.dequeue() -1 >>> queue.dequeue() -1 def dequeue(self) -> int: Removes the element from in front of the queue and returns that element. If the queue is empty, return -1. Tuple: Input Output enqueue(1) -> the queue will be {1} enqueue(2) -> the queue will be {1, 2} enqueue(3) -> the queue will be {1, 2, 3} dequeue() -> dequeued element will be 1, the queue will be {2, 3} dequeue() -> dequeued element will be 2, the queue will be {3} enqueue(4) -> the queue will be {3, 4} dequeue() -> dequeued element will be 3, the queue will be {4} dequeue() -> dequeued element will be 4, the queue will be {} dequeue() -> -1 (queue is empty)","solution":"class QueueUsingStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, x): self.stack1.append(x) def dequeue(self): if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if self.stack2: return self.stack2.pop() return -1"},{"question":"def maximum_revenue(n: int, k: int, m: int, prices: List[int]) -> int: Returns the maximum revenue the store can generate by shipping at most m out of the top k most expensive products. Parameters: n (int): Total number of products. k (int): Number of top products to consider. m (int): Maximum number of products that can be shipped. prices (list of int): List of product prices. Returns: int: Maximum revenue.","solution":"def maximum_revenue(n, k, m, prices): Returns the maximum revenue the store can generate by shipping at most m out of the top k most expensive products. Parameters: n (int): Total number of products. k (int): Number of top products to consider. m (int): Maximum number of products that can be shipped. prices (list of int): List of product prices. Returns: int: Maximum revenue. # Sort the prices in descending order. sorted_prices = sorted(prices, reverse=True) # Select the top k prices. top_k_prices = sorted_prices[:k] # Sum the highest m prices from the top k prices. maximum_revenue = sum(top_k_prices[:m]) return maximum_revenue"},{"question":"def sumFirstLast(N: int) -> int: Returns the sum of the first and last digit of N. >>> sumFirstLast(1234) == 5 >>> sumFirstLast(56789) == 14","solution":"def sumFirstLast(N): Returns the sum of the first and last digit of N. N_str = str(N) first_digit = int(N_str[0]) last_digit = int(N_str[-1]) return first_digit + last_digit"},{"question":"def longest_consecutive_subsequence(nums: List[int]) -> int: Returns the length of the longest consecutive elements sequence in the array. :param nums: List of integers :return: Integer representing the length of the longest consecutive sequence Examples: >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_subsequence([9, 1, 4, 7, 3, 2, 8, 0, 11, 10]) 5","solution":"def longest_consecutive_subsequence(nums): Returns the length of the longest consecutive elements sequence in the array. :param nums: List of integers :return: Integer representing the length of the longest consecutive sequence if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # Only check for the beginning of a streak if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def find_elements_with_frequency(test_cases): Identify and print elements from an array that have an exact frequency of F. Args: test_cases (list): List of dictionaries where each dictionary contains: - N (int): the size of the array - F (int): the required frequency - array (list): the elements of the array Returns: list of str: For each test case, a string of elements that appear exactly F times in the array, in the order they appear in the input. If no elements meet the criteria, return \\"-1\\". Example: >>> test_cases = [{\\"N\\": 5, \\"F\\": 2, \\"array\\": [1, 2, 2, 3, 3]}] >>> find_elements_with_frequency(test_cases) [\\"2 3\\"] pass import pytest def test_case_1(): test_cases = [{\\"N\\": 5, \\"F\\": 2, \\"array\\": [1, 2, 2, 3, 3]}] assert find_elements_with_frequency(test_cases) == [\\"2 3\\"] def test_case_2(): test_cases = [{\\"N\\": 5, \\"F\\": 3, \\"array\\": [4, 4, 4, 5, 5]}] assert find_elements_with_frequency(test_cases) == [\\"4\\"] def test_case_3(): test_cases = [{\\"N\\": 6, \\"F\\": 1, \\"array\\": [1, 2, 3, 4, 5, 6]}] assert find_elements_with_frequency(test_cases) == [\\"1 2 3 4 5 6\\"] def test_case_no_matches(): test_cases = [{\\"N\\": 4, \\"F\\": 5, \\"array\\": [1, 1, 2, 2]}] assert find_elements_with_frequency(test_cases) == [\\"-1\\"] def test_case_multiple_elements(): test_cases = [{\\"N\\": 7, \\"F\\": 2, \\"array\\": [1, 2, 2, 3, 3, 4, 4]}] assert find_elements_with_frequency(test_cases) == [\\"2 3 4\\"] def test_case_single_element_exact_match(): test_cases = [{\\"N\\": 1, \\"F\\": 1, \\"array\\": [99]}] assert find_elements_with_frequency(test_cases) == [\\"99\\"] def test_case_elements_exceed(): test_cases = [{\\"N\\": 5, \\"F\\": 1, \\"array\\": [10, 10, 20, 30, 30]}] assert find_elements_with_frequency(test_cases) == [\\"20\\"] def test_case_elements_non_consecutive(): test_cases = [{\\"N\\": 5, \\"F\\": 2, \\"array\\": [1, 2, 1, 3, 2]}] assert find_elements_with_frequency(test_cases) == [\\"1 2\\"] if __name__ == \\"__main__\\": pytest.main()","solution":"def find_elements_with_frequency(test_cases): results = [] for case in test_cases: N, F = case['N'], case['F'] arr = case['array'] frequency_dict = {} for elem in arr: if elem in frequency_dict: frequency_dict[elem] += 1 else: frequency_dict[elem] = 1 result = [] for elem in arr: if frequency_dict[elem] == F: if elem not in result: result.append(elem) if result: results.append(\\" \\".join(map(str, result))) else: results.append(\\"-1\\") return results # Example Usage if __name__ == \\"__main__\\": test_cases = [ {\\"N\\": 5, \\"F\\": 2, \\"array\\": [1, 2, 2, 3, 3]}, {\\"N\\": 5, \\"F\\": 3, \\"array\\": [4, 4, 4, 5, 5]}, {\\"N\\": 6, \\"F\\": 1, \\"array\\": [1, 2, 3, 4, 5, 6]} ] output = find_elements_with_frequency(test_cases) for out in output: print(out)"},{"question":"def min_entries_to_unlock(n, m, attempted_sequence, correct_sequence): Determine the minimum number of entries needed to unlock the padlock. If it's not possible within the allowed attempts, return -1. >>> min_entries_to_unlock(10, 5, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [3, 4, 5, 6]) 4 >>> min_entries_to_unlock(10, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [5, 6, 7, 8]) -1 >>> min_entries_to_unlock(5, 2, [1, 2, 3, 4, 5], [3, 4, 5, 6]) -1 from typing import List def min_entries_to_unlock(n: int, m: int, attempted_sequence: List[int], correct_sequence: List[int]) -> int: pass # TODO: Implement this function # Unit tests def test_unlock_possible_within_limit(): assert min_entries_to_unlock(10, 5, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [3, 4, 5, 6]) == 4 def test_unlock_possible_under_limit(): assert min_entries_to_unlock(10, 5, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [5, 6, 7, 8]) == 4 def test_unlock_exceeds_limit(): assert min_entries_to_unlock(10, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [5, 6, 7, 8]) == -1 def test_unlock_not_present(): assert min_entries_to_unlock(5, 2, [1, 2, 3, 4, 5], [3, 4, 5, 6]) == -1 def test_single_number_sequence(): assert min_entries_to_unlock(5, 3, [1, 2, 3, 4, 5], [2]) == 1 def test_exact_fit(): assert min_entries_to_unlock(6, 4, [1, 2, 3, 4, 5, 6], [3, 4, 5, 6]) == 4 def test_no_overlap(): assert min_entries_to_unlock(5, 1, [1, 2, 3, 4, 5], [5]) == 1","solution":"def min_entries_to_unlock(n, m, attempted_sequence, correct_sequence): Determine the minimum number of entries needed to unlock the padlock. If it's not possible within the allowed attempts, return -1. k = len(correct_sequence) for i in range(n - k + 1): if attempted_sequence[i:i + k] == correct_sequence: return k if k <= m else -1 return -1"},{"question":"def wave_transform(s: str) -> list: Create a function wave_transform(s) that takes a string s and returns a list of strings, where for each successive element in the list, one more character from the input string is transformed to uppercase, starting from the beginning. >>> wave_transform(\\"hello\\") ['Hello', 'hEllo', 'heLlo', 'helLo', 'hellO'] >>> wave_transform(\\"world\\") ['World', 'wOrld', 'woRld', 'worLd', 'worlD'] >>> wave_transform(\\"hi there!\\") ['Hi there!', 'hI there!', 'hi There!', 'hi tHere!', 'hi thEre!', 'hi theRe!', 'hi therE!'] >>> wave_transform(\\"1a2b!\\") ['1A2b!', '1a2B!'] >>> wave_transform(\\"\\") [] >>> wave_transform(\\"123!@#\\") []","solution":"def wave_transform(s): Given a string s, returns a list of strings where for each successive element, one more character from the input string is transformed to uppercase from left to right. result = [] # Initialize the result list to store each transformation. for i, char in enumerate(s): # Loop over each character in the input string. if char.isalpha(): # Check if the character is a letter. transformed = s[:i] + char.upper() + s[i+1:] # Transform the current character to uppercase. result.append(transformed) # Append the transformed string to the result list. return result # Return the complete list of transformed strings."},{"question":"def min_operations_to_max_non_decreasing(n: int, sequence: List[int]) -> int: Returns the minimum number of operations needed to transform the sequence into a non-decreasing sequence to the maximum extent possible by performing swaps between consecutive elements. >>> min_operations_to_max_non_decreasing(5, [3, 1, 4, 1, 5]) 2 >>> min_operations_to_max_non_decreasing(4, [1, 3, 2, 4]) 1","solution":"def min_operations_to_max_non_decreasing(n, sequence): Returns the minimum number of operations needed to transform the sequence into a non-decreasing sequence to the maximum extent possible by performing swaps between consecutive elements. ops = 0 stack = [] for num in sequence: # Maintain a stack such that the stack is non-decreasing at all points while stack and stack[-1] > num: stack.pop() ops += 1 stack.append(num) return ops"},{"question":"def can_transform(s: str, t: str) -> str: Determines if it's possible to transform the initial string s into the target string t by repeatedly moving any character from s to the end of the string. >>> can_transform(\\"abc\\", \\"cab\\") 'YES' >>> can_transform(\\"abc\\", \\"bca\\") 'YES' >>> can_transform(\\"abc\\", \\"abc\\") 'YES' >>> can_transform(\\"abcd\\", \\"dcba\\") 'NO'","solution":"def can_transform(s, t): Determines if it's possible to transform the initial string s into the target string t by repeatedly moving any character from s to the end of the string. # If t is a substring of s+s, then t can be obtained by rotating s return \\"YES\\" if t in (s + s) else \\"NO\\""},{"question":"def is_min_water_met(friend_waters, min_liters): Given the amount of water that four friends have in their bottles and the minimum liters needed, determine if any two friends together have at least the minimum amount of water required. Parameters: friend_waters (list): List containing water amounts of four friends [W1, W2, W3, W4]. min_liters (int): Minimum liters required. Returns: str: \\"YES\\" if any two friends together have at least the minimum liters required, else \\"NO\\". >>> is_min_water_met([10, 20, 15, 5], 25) 'YES' >>> is_min_water_met([8, 4, 3, 2], 7) 'YES' >>> is_min_water_met([50, 60, 70, 80], 100) 'YES' >>> is_min_water_met([1, 1, 1, 1], 3) 'NO' >>> is_min_water_met([0, 0, 0, 0], 1) 'NO' >>> is_min_water_met([100, 100, 100, 100], 200) 'YES' pass def process_test_cases(T, test_cases): Process multiple test cases to check if the minimum water requirement is met. Parameters: T (int): Number of test cases. test_cases (list): List of tuples where each tuple contains five integers ([W1, W2, W3, W4, L]) representing the water amounts of four friends and the minimum liters required. Returns: list: List of strings, where each string is \\"YES\\" or \\"NO\\" corresponding to each test case. >>> process_test_cases(3, [(10, 20, 15, 5, 25), (8, 4, 3, 2, 7), (50, 60, 70, 80, 100)]) ['YES', 'YES', 'YES'] >>> process_test_cases(2, [(1, 1, 1, 1, 3), (0, 0, 0, 0, 1)]) ['NO', 'NO'] pass","solution":"def is_min_water_met(friend_waters, min_liters): Given the amount of water that four friends have in their bottles and the minimum liters needed, determine if any two friends together have at least the minimum amount of water required. Parameters: friend_waters (list): List containing water amounts of four friends [W1, W2, W3, W4]. min_liters (int): Minimum liters required. Returns: str: \\"YES\\" if any two friends together have at least the minimum liters required, else \\"NO\\". W1, W2, W3, W4 = friend_waters water_combinations = [ W1 + W2, W1 + W3, W1 + W4, W2 + W3, W2 + W4, W3 + W4 ] for combination in water_combinations: if combination >= min_liters: return \\"YES\\" return \\"NO\\" def process_test_cases(T, test_cases): Process multiple test cases to check if the minimum water requirement is met. Parameters: T (int): Number of test cases. test_cases (list): List of tuples where each tuple contains five integers ([W1, W2, W3, W4, L]) representing the water amounts of four friends and the minimum liters required. Returns: list: List of strings, where each string is \\"YES\\" or \\"NO\\" corresponding to each test case. results = [] for case in test_cases: friend_waters = case[:4] min_liters = case[4] result = is_min_water_met(friend_waters, min_liters) results.append(result) return results"},{"question":"def minimum_completion_time(n: int, times: List[int]) -> int: Returns the minimum amount of time required to complete all tasks given the task times. >>> minimum_completion_time(3, [4, 3, 2]) 4 >>> minimum_completion_time(5, [1, 2, 3, 4, 5]) 5 >>> minimum_completion_time(3, [0, 0, 0]) 0 >>> minimum_completion_time(4, [7, 1, 5, 3]) 7 >>> minimum_completion_time(6, [9, 8, 7, 1, 2, 3]) 9","solution":"def minimum_completion_time(n, times): Returns the minimum amount of time required to complete all tasks given the task times. return max(times)"},{"question":"def sieve_of_eratosthenes(limit): Sieve of Eratosthenes algorithm to find all prime numbers up to a limit. >>> sieve_of_eratosthenes(10) == [2, 3, 5, 7] >>> sieve_of_eratosthenes(1) == [] def largest_prime_factorial(N): Returns the largest prime factor of N!. >>> largest_prime_factorial(6) == 5 >>> largest_prime_factorial(10) == 7 >>> largest_prime_factorial(15) == 13 >>> largest_prime_factorial(1) == None # special case where 1! = 1 has no prime factors def solve_prime_factors_of_factorials(T, test_cases): Solves the problem for T test cases. >>> solve_prime_factors_of_factorials(3, [6, 10, 15]) == [5, 7, 13] >>> solve_prime_factors_of_factorials(2, [20, 25]) == [19, 23] >>> solve_prime_factors_of_factorials(1, [1]) == [None]","solution":"def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False for start in range(2, int(limit ** 0.5) + 1): if is_prime[start]: for multiple in range(start * start, limit + 1, start): is_prime[multiple] = False return [num for num, prime in enumerate(is_prime) if prime] def largest_prime_factorial(N): Returns the largest prime factor of N!. primes = sieve_of_eratosthenes(N) if primes: return primes[-1] return None def solve_prime_factors_of_factorials(T, test_cases): Solves the problem for T test cases. results = [] for N in test_cases: results.append(largest_prime_factorial(N)) return results # Example usage: # T = 3 # test_cases = [6, 10, 15] # print(solve_prime_factors_of_factorials(T, test_cases)) # Output should be: [5, 7, 13]"},{"question":"def is_convincing(phrase: str) -> str: Check if the given phrase is convincing based on the criteria. - It contains at least one of the keywords: 'urgent', 'emergency', 'help', 'immediate'. - It does not contain more than three exclamation marks in the entire phrase. - It does not have any sequences of three or more identical consecutive characters (e.g., 'aaa', '!!!'). Args: phrase: A string phrase to be checked. Returns: \\"Convincing\\" if the phrase meets all the criteria, and \\"Not Convincing\\" otherwise. Examples: >>> is_convincing(\\"This is an urgent request! Please respond immediately!!\\") \\"Convincing\\" >>> is_convincing(\\"We need help!!! This is an emergency!\\") \\"Not Convincing\\" # Write your code here def check_phrases(n: int, phrases: List[str]) -> List[str]: Returns a list of results for the given phrases. Args: n: Number of phrases. phrases: List of phrases to be checked. Returns: List of strings, \\"Convincing\\" or \\"Not Convincing\\", for each phrase. Examples: >>> check_phrases(3, [ ... \\"This is an urgent request! Please respond immediately!!\\", ... \\"We need help!!! This is an emergency!\\", ... \\"Please respond as soon as possible!\\"]) [\\"Convincing\\", \\"Not Convincing\\", \\"Not Convincing\\"] # Write your code here","solution":"def is_convincing(phrase): Check if the given phrase is convincing based on the criteria. keywords = {'urgent', 'emergency', 'help', 'immediate'} exclamation_count = phrase.count('!') has_keyword = any(keyword in phrase for keyword in keywords) no_triple_repeats = not any(char * 3 in phrase for char in set(phrase)) if has_keyword and exclamation_count <= 3 and no_triple_repeats: return \\"Convincing\\" else: return \\"Not Convincing\\" def check_phrases(n, phrases): Returns a list of results for the given phrases. return [is_convincing(phrase) for phrase in phrases]"},{"question":"def max_subarray_sum(arr): Returns the sum of the largest contiguous subarray within the given list. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, -2, 5]) 9 >>> max_subarray_sum([-1, -2, -3, -4, -5, -6]) -1 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([2, -1, 2, 3, 4, -5]) 10","solution":"def max_subarray_sum(arr): Returns the sum of the largest contiguous subarray within the given list. max_so_far = arr[0] max_ending_here = arr[0] for i in range(1, len(arr)): max_ending_here = max(arr[i], max_ending_here + arr[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def longest_zero_sequence(s: str) -> int: Returns the length of the longest consecutive sequence of zeros in a given binary string. >>> longest_zero_sequence(\\"110001110000111\\") 4 >>> longest_zero_sequence(\\"1000001\\") 5 >>> longest_zero_sequence(\\"1111\\") 0 from typing import List def test_longest_zero_sequence_simple_case(): assert longest_zero_sequence(\\"110001110000111\\") == 4 def test_longest_zero_sequence_all_zeros(): assert longest_zero_sequence(\\"0000000\\") == 7 def test_longest_zero_sequence_no_zeros(): assert longest_zero_sequence(\\"1111\\") == 0 def test_longest_zero_sequence_single_zero(): assert longest_zero_sequence(\\"1\\") == 0 assert longest_zero_sequence(\\"0\\") == 1 def test_longest_zero_sequence_mixed_case(): assert longest_zero_sequence(\\"1000001\\") == 5 def test_longest_zero_sequence_multiple_sequences(): assert longest_zero_sequence(\\"10100101000100\\") == 3 assert longest_zero_sequence(\\"0001100000110000\\") == 5","solution":"def longest_zero_sequence(s): Returns the length of the longest consecutive sequence of zeros in the binary string s. max_length = 0 current_length = 0 for char in s: if char == '0': current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def can_form_palindrome(s: str) -> str: Returns 'YES' if any permutation of the string can form a palindrome, 'NO' otherwise. >>> can_form_palindrome('carrace') 'YES' >>> can_form_palindrome('hello') 'NO' >>> can_form_palindrome('aabbc') 'YES' >>> can_form_palindrome('abc') 'NO' >>> can_form_palindrome('taco cat') 'YES' >>> can_form_palindrome('a') 'YES' >>> can_form_palindrome('') 'YES' >>> can_form_palindrome('aaabbb') 'NO' >>> can_form_palindrome('aabbccdd') 'YES' >>> can_form_palindrome('abacabad') 'NO'","solution":"def can_form_palindrome(s): Returns 'YES' if any permutation of the string can form a palindrome, 'NO' otherwise. # Remove spaces and convert to lowercase s = s.replace(\\" \\", \\"\\").lower() # Dictionary to count frequencies of characters char_count = {} for char in s: char_count[char] = char_count.get(char, 0) + 1 # Check the number of characters that have odd counts odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For a string to be permutable into a palindrome, # there can be at most one character with an odd count if odd_count > 1: return 'NO' else: return 'YES'"},{"question":"def longest_increasing_subsequence(nums: List[int]) -> int: Function to determine the length of the longest increasing subsequence. Parameters: nums (list): List of integers representing page numbers Returns: int: Length of the longest increasing subsequence >>> longest_increasing_subsequence([4, 2, 3, 6, 10, 1, 12]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 def test_longest_increasing_subsequence_case_1(): assert longest_increasing_subsequence([4, 2, 3, 6, 10, 1, 12]) == 5 def test_longest_increasing_subsequence_case_2(): assert longest_increasing_subsequence([5, 4, 3, 2, 1]) == 1 def test_longest_increasing_subsequence_single_element(): assert longest_increasing_subsequence([10]) == 1 def test_longest_increasing_subsequence_all_same(): assert longest_increasing_subsequence([2, 2, 2, 2, 2]) == 1 def test_longest_increasing_subsequence_almost_increasing(): assert longest_increasing_subsequence([1, 3, 2, 4, 6, 5, 7]) == 5 def test_longest_increasing_subsequence_no_elements(): assert longest_increasing_subsequence([]) == 0","solution":"def longest_increasing_subsequence(nums): Function to determine the length of the longest increasing subsequence. Parameters: nums (list): List of integers representing page numbers Returns: int: Length of the longest increasing subsequence if not nums: return 0 n = len(nums) dp = [1] * n # dp[i] holds the length of the longest increasing subsequence ending with nums[i] for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def can_rearrange(s: str, k: int) -> str: Determines if the string can be rearranged such that no two identical characters are adjacent, and each character appears at least k times consecutively. >>> can_rearrange(\\"aaabbcc\\", 2) \\"YES\\" >>> can_rearrange(\\"aaabbcc\\", 3) \\"NO\\"","solution":"from collections import Counter def can_rearrange(s, k): char_count = Counter(s) max_freq = max(char_count.values()) # Check the maximum frequency requirement if k * max_freq > len(s): return \\"NO\\" # Sort characters by their frequency in descending order sorted_chars = sorted(char_count.items(), key=lambda x: -x[1]) # Initialize the arrangement with empty strings arrangement = [''] * len(s) index = 0 for char, freq in sorted_chars: for _ in range(freq): # If index goes out of range, wrap around with step of k while index < len(s) and arrangement[index] != '': index += 1 if index >= len(s): index = 0 while index < len(s) and arrangement[index] != '': index += 1 if index >= len(s): return \\"NO\\" arrangement[index] = char index += k return \\"YES\\" # Example use: s = \\"aaabbcc\\" k = 2 print(can_rearrange(s, k)) # Output: YES"},{"question":"from typing import List, Tuple, Union def rearrange_pawns(M: int, N: int, pawns: List[Tuple[int, int]]) -> Union[str, List[Tuple[int, int]]]: Rearranges pawns such that no two pawns are in the same row or column. Parameters: M (int): Size of the grid. N (int): Number of pawns. pawns (list of tuples): List of tuples where each tuple contains the initial coordinates of a pawn Returns: List of tuples containing the new coordinates of each pawn if possible, otherwise returns \\"Not possible\\". Examples: >>> rearrange_pawns(5, 3, [(1, 1), (2, 2), (3, 3)]) [(1, 1), (2, 3), (3, 2)] >>> rearrange_pawns(5, 5, [(1, 1), (1, 5), (2, 2), (2, 3), (3, 3)]) \\"Not possible\\"","solution":"def rearrange_pawns(M, N, pawns): Rearranges pawns such that no two pawns are in the same row or column. Parameters: M (int): Size of the grid. N (int): Number of pawns. pawns (list of tuples): List of tuples where each tuple contains the initial coordinates of a pawn Returns: List of tuples containing the new coordinates of each pawn if possible, otherwise returns \\"Not possible\\". if N > M: return \\"Not possible\\" rows_taken = set() cols_taken = set() # Mark the initial positions as taken for (r, c) in pawns: if r in rows_taken or c in cols_taken: return \\"Not possible\\" rows_taken.add(r) cols_taken.add(c) # If initial positions are feasible, return them return pawns"},{"question":"from typing import List def expand_abbreviations(data: str) -> List[str]: Expand abbreviations in messages according to a provided list. :param data: A string containing the number of abbreviations, the abbreviation-expansion pairs, the number of messages, and the messages themselves. :return: A list of strings with the abbreviations expanded. >>> data = '''3 brb: be right back omw: on my way lol: laugh out loud 2 brb, omw now! This is so funny lol!''' >>> expand_abbreviations(data) ['be right back, on my way now!', 'This is so funny laugh out loud!'] >>> data = '''2 idk: I don't know afaik: as far as I know 1 idk what happened there, afaik he was okay.''' >>> expand_abbreviations(data) [\\"I don't know what happened there, as far as I know he was okay.\\"] >>> data = '''1 brb: be right back 1 No abbreviations here!''' >>> expand_abbreviations(data) ['No abbreviations here!'] >>> data = '''2 lol: laugh out loud lmao: laughing my ass off 1 lol, this is hilarious! lmao''' >>> expand_abbreviations(data) ['laugh out loud, this is hilarious! laughing my ass off'] >>> data = '''1 brb: be right back 1 brb, I will brb!''' >>> expand_abbreviations(data) ['be right back, I will be right back!']","solution":"def expand_abbreviations(data): lines = data.strip().split('n') K = int(lines[0]) abbreviation_dict = {} for i in range(1, K + 1): abbreviation, expansion = lines[i].split(': ') abbreviation_dict[abbreviation] = expansion N = int(lines[K + 1]) messages = lines[K + 2:K + 2 + N] expanded_messages = [] for message in messages: for abbrev, expansion in abbreviation_dict.items(): message = message.replace(abbrev, expansion) expanded_messages.append(message) return expanded_messages"},{"question":"from typing import List def smallest_number_after_removal(s: str) -> str: Determine the smallest possible number that can be obtained by removing exactly one digit from the given string representing a large decimal number. >>> smallest_number_after_removal(\\"123\\") \\"12\\" >>> smallest_number_after_removal(\\"10200\\") \\"200\\" >>> smallest_number_after_removal(\\"10\\") \\"0\\" pass def process_test_cases(test_cases: List[str]) -> List[str]: Process multiple test cases to determine the smallest possible number that can be obtained by removing exactly one digit from each given string. >>> process_test_cases([\\"123\\", \\"10200\\", \\"10\\"]) [\\"12\\", \\"200\\", \\"0\\"] >>> process_test_cases([\\"4107\\", \\"0000\\", \\"100\\"]) [\\"107\\", \\"0\\", \\"0\\"] pass","solution":"def smallest_number_after_removal(s): n = len(s) smallest = s[1:] # Initialize with removing the first digit for i in range(1, n): candidate = s[:i] + s[i+1:] if candidate < smallest: smallest = candidate return smallest.lstrip('0') or \\"0\\" def process_test_cases(test_cases): results = [] for s in test_cases: results.append(smallest_number_after_removal(s)) return results"},{"question":"def min_platforms(n: int, train_times: List[Tuple[int, int]]) -> int: Computes the minimum number of platforms required at a railway station such that no train waits. Parameters: n (int): Number of trains (1 ≤ n ≤ 1000) train_times (list of tuple): List of tuples where each tuple contains two integers representing the arrival and departure times in HHMM format. Returns: int: Minimum number of platforms required. Examples: >>> min_platforms(3, [(900, 910), (940, 1200), (950, 1120)]) 2 >>> min_platforms(3, [(900, 910), (900, 910), (900, 910)]) 3 >>> min_platforms(3, [(900, 910), (920, 930), (940, 950)]) 1 >>> min_platforms(4, [(900, 920), (910, 930), (920, 940), (930, 950)]) 2 >>> min_platforms(1, [(900, 910)]) 1","solution":"def min_platforms(n, train_times): Computes the minimum number of platforms required at a railway station such that no train waits. Parameters: n (int): Number of trains train_times (list of tuple): List of tuples where each tuple contains two integers representing the arrival and departure times in HHMM format. Returns: int: Minimum number of platforms required. # Extract arrival and departure times arrivals = sorted([times[0] for times in train_times]) departures = sorted([times[1] for times in train_times]) # Initialize pointers for arrival and departure arr_ptr, dep_ptr = 0, 0 platforms_needed, max_platforms = 0, 0 # Iterate while there are trains to process while arr_ptr < n: if arrivals[arr_ptr] < departures[dep_ptr]: platforms_needed += 1 arr_ptr += 1 if platforms_needed > max_platforms: max_platforms = platforms_needed else: platforms_needed -= 1 dep_ptr += 1 return max_platforms"},{"question":"def calculate_operations(n: int) -> int: Calculate the minimum number of operations to reduce \`n\` to 1. The allowed operations are: 1. If \`n\` is divisible by 2, divide it by 2. 2. If \`n\` is divisible by 3, divide it by 3. 3. Subtract 1 from \`n\`. Args: - n: int, a positive integer Returns: - int, minimum number of operations to reduce \`n\` to 1 >>> calculate_operations(10) 3 >>> calculate_operations(1) 0 >>> calculate_operations(2) 1 >>> calculate_operations(3) 1 >>> calculate_operations(6) 2 >>> calculate_operations(18) 3 pass","solution":"def calculate_operations(n): Calculate the minimum number of operations to reduce \`n\` to 1. Operations allowed: 1. If \`n\` is divisible by 2, divide it by 2. 2. If \`n\` is divisible by 3, divide it by 3. 3. Subtract 1 from \`n\`. Args: - n: int, a positive integer Returns: - int, minimum number of operations to reduce \`n\` to 1 if n < 1: raise ValueError(\\"n must be a positive integer.\\") # Create a list to store the minimum operations count to get to each number from 1 to n dp = [0] * (n + 1) # dp[i] will store the minimum operations to get to 1 from i for i in range(2, n + 1): # Start with subtract 1 from i dp[i] = dp[i - 1] + 1 # If i is divisible by 2, consider it as a candidate and take the minimum if i % 2 == 0: dp[i] = min(dp[i], dp[i // 2] + 1) # If i is divisible by 3, consider it as a candidate and take the minimum if i % 3 == 0: dp[i] = min(dp[i], dp[i // 3] + 1) return dp[n]"},{"question":"def calculate_average_scores(students: List[Dict[str, Union[str, List[int]]]]) -> List[Dict[str, Union[str, float]]]: Calculates the average score for each student and returns a list of dictionaries with each student's id, name, and average_score. Args: - students (list of dict): List of dictionaries where each dictionary contains a student's id, name, and scores. Returns: - List of dictionaries with each student's id, name, and average_score. >>> students = [ ... {'id': 's1', 'name': 'John', 'scores': [78, 86, 54, 99]}, ... {'id': 's2', 'name': 'Alice', 'scores': [88, 92]} ... ] >>> calculate_average_scores(students) [{'id': 's1', 'name': 'John', 'average_score': 79.25}, {'id': 's2', 'name': 'Alice', 'average_score': 90.0}]","solution":"def calculate_average_scores(students): Calculates the average score for each student and returns a list of dictionaries with each student's id, name, and average_score. Args: - students (list of dict): List of dictionaries where each dictionary contains a student's id, name, and scores. Returns: - List of dictionaries with each student's id, name, and average_score. result = [] for student in students: average_score = round(sum(student['scores']) / len(student['scores']), 2) result.append({ 'id': student['id'], 'name': student['name'], 'average_score': average_score }) return sorted(result, key=lambda x: x['id'])"},{"question":"def longestCommonPrefix(paths: List[str]) -> str: Returns the longest common prefix of the directory paths that is a valid path. >>> longestCommonPrefix([\\"/home/user/project\\", \\"/home/user/docs\\", \\"/home/user/project/src\\"]) '/home/user' >>> longestCommonPrefix([\\"/var/logs/syslog\\", \\"/var/tmp/cache\\", \\"/var/logs/\\"]) '/var'","solution":"def longestCommonPrefix(paths): Returns the longest common prefix of the directory paths that is a valid path. if not paths: return \\"\\" # Split the first path into parts split_paths = [path.split('/') for path in paths] # Find the shortest path in terms of parts count for early termination min_len = min(len(parts) for parts in split_paths) # Initialize the common prefix common_prefix = [] for i in range(min_len): # Take the i-th part of the first path current_part = split_paths[0][i] # Check if this part is common in all paths if all(parts[i] == current_part for parts in split_paths): common_prefix.append(current_part) else: break return \\"/\\".join(common_prefix) # Example usage paths1 = [\\"/home/user/project\\", \\"/home/user/docs\\", \\"/home/user/project/src\\"] print(longestCommonPrefix(paths1)) # Output should be \\"/home/user\\" paths2 = [\\"/var/logs/syslog\\", \\"/var/tmp/cache\\", \\"/var/logs/\\"] print(longestCommonPrefix(paths2)) # Output should be \\"/var\\""},{"question":"def longest_palindromic_substring(n, m, s, allowed_chars): Determines the length of the longest palindromic substring that can be formed by replacing the asterisks in the given string with allowed characters. Parameters: n (int): Length of the string. m (int): Size of the set of allowed characters. s (str): The string with some characters and asterisks. allowed_chars (list of str): List of allowed characters to replace asterisks. Returns: int: Length of the longest palindromic substring that can be formed. pass from solution import longest_palindromic_substring def test_example_1(): n = 10 m = 3 s = \\"a*c*cdc*c*\\" allowed_chars = ['a', 'b', 'c'] assert longest_palindromic_substring(n, m, s, allowed_chars) == 9 def test_example_2(): n = 5 m = 2 s = \\"a*b*a\\" allowed_chars = ['a', 'b'] assert longest_palindromic_substring(n, m, s, allowed_chars) == 5 def test_example_3(): n = 6 m = 4 s = \\"*ab*dc*\\" allowed_chars = ['a', 'b', 'c', 'd'] assert longest_palindromic_substring(n, m, s, allowed_chars) == 3 def test_edge_case_1(): n = 1 m = 1 s = \\"*\\" allowed_chars = ['a'] assert longest_palindromic_substring(n, m, s, allowed_chars) == 1 def test_edge_case_2(): n = 2 m = 1 s = \\"**\\" allowed_chars = ['a'] assert longest_palindromic_substring(n, m, s, allowed_chars) == 2","solution":"def longest_palindromic_substring(n, m, s, allowed_chars): Determines the length of the longest palindromic substring that can be formed by replacing the asterisks in the given string with allowed characters. Parameters: n (int): Length of the string. m (int): Size of the set of allowed characters. s (str): The string with some characters and asterisks. allowed_chars (list of str): List of allowed characters to replace asterisks. Returns: int: Length of the longest palindromic substring that can be formed. def is_palindrome(st): return st == st[::-1] max_length = 0 for i in range(n): for j in range(i, n): current_substring = list(s[i:j+1]) is_possible = True for k in range(len(current_substring)): if current_substring[k] == \\"*\\": current_substring[k] = allowed_chars[0] if is_palindrome(\\"\\".join(current_substring)): max_length = max(max_length, j - i + 1) return max_length"},{"question":"def is_palindrome(s: str) -> bool: Returns True if the input string s is a palindrome, False otherwise. Ignores spaces, punctuation, and capitalization. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello world\\") False >>> is_palindrome(\\"Able was I ere I saw Elba\\") True >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"12345\\") False","solution":"def is_palindrome(s): Returns True if the input string s is a palindrome, False otherwise. Ignores spaces, punctuation, and capitalization. # Remove non-alphanumeric characters and convert to lowercase cleaned = ''.join(char.lower() for char in s if char.isalnum()) # Check if the cleaned string reads the same forward and backward return cleaned == cleaned[::-1]"},{"question":"from typing import List def min_removals_to_make_palindrome(s: str) -> int: Returns the minimum number of characters to remove to make the given string a palindrome. >>> min_removals_to_make_palindrome(\\"abca\\") 1 >>> min_removals_to_make_palindrome(\\"abcba\\") 0 >>> min_removals_to_make_palindrome(\\"abcd\\") 3 >>> min_removals_to_make_palindrome(\\"a\\") 0 def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Process multiple test cases of strings and return the results for each test case >>> process_test_cases(4, [\\"abca\\", \\"abcba\\", \\"abcd\\", \\"a\\"]) [1, 0, 3, 0] >>> process_test_cases(3, [\\"ab\\", \\"aba\\", \\"abba\\"]) [1, 0, 0]","solution":"def min_removals_to_make_palindrome(s): Returns the minimum number of characters to remove to make the given string a palindrome. n = len(s) dp = [[0] * n for _ in range(n)] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1 return dp[0][n - 1] def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(min_removals_to_make_palindrome(s)) return results"},{"question":"def min_cost_to_build_rail_network(N, M, connections): Determine the minimal cost to build the rail network to connect given cities. If it's not possible to connect all cities, return \\"IMPOSSIBLE\\". Parameters: N (int): The number of cities. M (int): The number of possible rail connections. connections (List[Tuple[int, int, int]]): A list of tuples, each containing three integers (u, v, w) where u and v are the cities connected by this rail, and w is the cost to build this rail connection. Returns: int or str: The minimal total cost required to build the rail network or \\"IMPOSSIBLE\\" if it is not possible to connect all cities. Example: >>> min_cost_to_build_rail_network(4, 5, [(1, 2, 5), (1, 3, 10), (2, 3, 4), (2, 4, 3), (3, 4, 8)]) 12 >>> min_cost_to_build_rail_network(4, 2, [(1, 2, 1), (3, 4, 1)]) \\"IMPOSSIBLE\\"","solution":"def min_cost_to_build_rail_network(N, M, connections): # Helper function: Find the root of a node def find(parent, u): if parent[u] != u: parent[u] = find(parent, parent[u]) return parent[u] # Helper function: Union two sets def union(parent, rank, u, v): root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 # Kruskal's algorithm to find Minimal Spanning Tree parent = list(range(N+1)) rank = [0] * (N+1) # Sort all connections by their cost connections.sort(key=lambda x: x[2]) total_cost = 0 edges_used = 0 for u, v, w in connections: if find(parent, u) != find(parent, v): union(parent, rank, u, v) total_cost += w edges_used += 1 # If we used N-1 edges, we have our MST if edges_used == N-1: break # Check if all cities are connected if edges_used != N-1: return \\"IMPOSSIBLE\\" else: return total_cost"},{"question":"import datetime from typing import List def parse_timestamp(timestamp: str) -> datetime.datetime: return datetime.datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\") def find_unique_ips(log_file_path: str, start_interval: str, end_interval: str, n: int) -> List[str]: Identify unique IP addresses that made exactly 'n' access attempts within the given time interval. >>> log_file_path = \\"log_file.txt\\" >>> start_interval = \\"2023-01-01 12:00:00\\" >>> end_interval = \\"2023-01-01 12:30:00\\" >>> n = 3 >>> with open(log_file_path, 'w') as file: >>> file.write(\\"192.168.1.1 2023-01-01 12:00:00n192.168.1.2 2023-01-01 12:05:00n192.168.1.1 2023-01-01 12:10:00n192.168.1.3 2023-01-01 12:15:00n192.168.1.2 2023-01-01 12:20:00n192.168.1.1 2023-01-01 12:25:00n192.168.1.3 2023-01-01 12:30:00n\\") >>> find_unique_ips(log_file_path, start_interval, end_interval, n) [\\"192.168.1.1\\"]","solution":"def parse_timestamp(timestamp): from datetime import datetime return datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\") def find_unique_ips(log_file_path, start_interval, end_interval, n): from collections import defaultdict start_time = parse_timestamp(start_interval) end_time = parse_timestamp(end_interval) access_count = defaultdict(int) with open(log_file_path, 'r') as file: for line in file: ip, timestamp = line.strip().split(maxsplit=1) access_time = parse_timestamp(timestamp) if start_time <= access_time <= end_time: access_count[ip] += 1 result = [ip for ip, count in access_count.items() if count == n] result.sort() return result"},{"question":"def determine_winner(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Jack and Jill are given a sequence of integers and need to make all elements equal by incrementing or decrementing any element by 1. Determine the winner if both play optimally. Jack goes first and they alternate turns. Jack wins if it's his turn when all elements are equal. :param T: Number of test cases :param test_cases: List of tuples, each containing an integer N and a list of N integers :return: List of strings \\"Jack\\" or \\"Jill\\" indicating the winner for each test case >>> determine_winner(2, [(3, [1, 2, 3]), (4, [4, 4, 4, 4])]) [\\"Jill\\", \\"Jack\\"] >>> determine_winner(1, [(5, [7, 7, 7, 7, 7])]) [\\"Jill\\"]","solution":"def determine_winner(T, test_cases): results = [] for i in range(T): N, arr = test_cases[i] if N % 2 == 0: results.append(\\"Jack\\") else: results.append(\\"Jill\\") return results"},{"question":"def calculate_water_trapped(n: int, heights: List[int], leaks: List[int]) -> int: Calculate the maximum amount of water that can be trapped in a reservoir after rainfall. >>> calculate_water_trapped(12, [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) 6 >>> calculate_water_trapped(6, [3, 0, 1, 3, 0, 5], [0, 0, 0, 0, 0, 0]) 8","solution":"def calculate_water_trapped(n, heights, leaks): if n <= 2: return 0 left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): if leaks[i] == 1: left_max[i] = 0 else: left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): if leaks[i] == 1: right_max[i] = 0 else: right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): if leaks[i] == 1: continue height = min(left_max[i], right_max[i]) if height > heights[i]: water_trapped += height - heights[i] return water_trapped"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(preorder, inorder): if not preorder or not inorder: return None root_val = preorder[0] root = TreeNode(root_val) root_index_inorder = inorder.index(root_val) root.left = build_tree(preorder[1:1+root_index_inorder], inorder[:root_index_inorder]) root.right = build_tree(preorder[1+root_index_inorder:], inorder[root_index_inorder+1:]) return root def postorder_traversal(root, result): if root: postorder_traversal(root.left, result) postorder_traversal(root.right, result) result.append(root.val) return result def reconstruct_and_postorder(n, preorder, inorder): Reconstruct a binary tree from its preorder and inorder traversal, and return its postorder traversal. Args: n (int): The number of nodes in the binary tree. preorder (List[int]): The preorder traversal of the binary tree. inorder (List[int]): The inorder traversal of the binary tree. Returns: List[int]: The postorder traversal of the binary tree. >>> reconstruct_and_postorder(6, [1, 2, 4, 5, 3, 6], [4, 2, 5, 1, 6, 3]) [4, 5, 2, 6, 3, 1] >>> reconstruct_and_postorder(1, [1], [1]) [1] >>> reconstruct_and_postorder(3, [3, 2, 1], [1, 2, 3]) [1, 2, 3] >>> reconstruct_and_postorder(3, [1, 2, 3], [1, 2, 3]) [3, 2, 1] >>> reconstruct_and_postorder(7, [1, 2, 4, 5, 3, 6, 7], [4, 2, 5, 1, 6, 3, 7]) [4, 5, 2, 6, 7, 3, 1]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(preorder, inorder): if not preorder or not inorder: return None root_val = preorder[0] root = TreeNode(root_val) root_index_inorder = inorder.index(root_val) root.left = build_tree(preorder[1:1+root_index_inorder], inorder[:root_index_inorder]) root.right = build_tree(preorder[1+root_index_inorder:], inorder[root_index_inorder+1:]) return root def postorder_traversal(root, result): if root: postorder_traversal(root.left, result) postorder_traversal(root.right, result) result.append(root.val) return result def reconstruct_and_postorder(n, preorder, inorder): root = build_tree(preorder, inorder) result = [] postorder_traversal(root, result) return result"},{"question":"def find_nth_element(N: int) -> int: Returns the N-th element in the specific sequence defined. >>> find_nth_element(1) == 1 >>> find_nth_element(5) == 9 >>> find_nth_element(10) == 55 def process_test_cases(test_cases: List[int]) -> List[int]: Processes multiple test cases for the find_nth_element function. >>> process_test_cases([1, 5, 10]) == [1, 9, 55] >>> process_test_cases([2, 3, 6]) == [3, 5, 11] >>> process_test_cases([7, 8, 9]) == [31, 33, 53]","solution":"def find_nth_element(N): Returns the N-th element in the specific sequence defined. current = 1 for _ in range(1, N): current += 2 if current > 9: # Reverse if more than one digit. current = int(str(current)[::-1]) return current def process_test_cases(test_cases): Processes multiple test cases for the find_nth_element function. results = [find_nth_element(N) for N in test_cases] return results"},{"question":"def increasing_triplet(nums: List[int]) -> bool: Checks if there exists an increasing subsequence of length three. Returns True if such a subsequence exists, otherwise returns False. >>> increasing_triplet([1, 2, 3, 4, 5]) True >>> increasing_triplet([5, 4, 3, 2, 1]) False >>> increasing_triplet([2, 1, 5, 0, 4, 6]) True >>> increasing_triplet([10, 1, 2]) False >>> increasing_triplet([1, 2]) False >>> increasing_triplet([1, 1, 1, 1]) False","solution":"def increasing_triplet(nums): Checks if there exists an increasing subsequence of length three. Returns True if such a subsequence exists, otherwise returns False. if len(nums) < 3: return False first = second = float('inf') for n in nums: if n <= first: first = n elif n <= second: second = n else: return True return False"},{"question":"def top_performing_sessions(m: int, sessions: List[Tuple[int, int]]) -> Dict[int, int]: Determine the top-performing session for each employee. :param m: Number of sessions :param sessions: List of tuples, each containing employee id and points :return: Dictionary with employee id as keys and their top-performing session id as values >>> top_performing_sessions(5, [(1, 500), (2, 300), (1, 450), (2, 500), (3, 480)]) {1: 1, 2: 4, 3: 5} >>> top_performing_sessions(7, [(2, 250), (3, 600), (2, 300), (1, 500), (3, 700), (1, 500), (2, 300)]) {1: 4, 2: 3, 3: 5} from typing import List, Tuple, Dict def test_single_session_multiple_employees(): assert top_performing_sessions(1, [(1, 500)]) == {1: 1} def test_multiple_sessions_single_employee(): assert top_performing_sessions(3, [(1, 500), (1, 300), (1, 700)]) == {1: 3} def test_multiple_employees_multiple_sessions(): assert top_performing_sessions(5, [(1, 500), (2, 300), (1, 450), (2, 500), (3, 480)]) == {1: 1, 2: 4, 3: 5} def test_multiple_top_performing_sessions(): assert top_performing_sessions(7, [(2, 250), (3, 600), (2, 300), (1, 500), (3, 700), (1, 500), (2, 300)]) == {1: 4, 2: 3, 3: 5} def test_mixed_points(): assert top_performing_sessions(4, [(1, 100), (1, 200), (2, 150), (2, 200)]) == {1: 2, 2: 4} def test_all_employees_different_points(): assert top_performing_sessions(3, [(1, 100), (2, 200), (3, 300)]) == {1: 1, 2: 2, 3: 3}","solution":"def top_performing_sessions(m, sessions): Determine the top-performing session for each employee. :param m: Number of sessions :param sessions: List of tuples, each containing employee id and points :return: Dictionary with employee id as keys and their top-performing session id as values employee_best_sessions = {} for session_id, (employee_id, points) in enumerate(sessions, start=1): if employee_id not in employee_best_sessions: employee_best_sessions[employee_id] = (points, session_id) else: current_best_points, current_best_session = employee_best_sessions[employee_id] if points > current_best_points: employee_best_sessions[employee_id] = (points, session_id) return {employee_id: session_id for employee_id, (_, session_id) in sorted(employee_best_sessions.items())}"},{"question":"def max_in_subranges(n, array, queries): Given an integer array and several range queries, determine the maximum value in the specified subrange for each query. n: an integer representing the size of the array array: a list of integers queries: a list of tuples where each tuple contains two integers (l, r) representing the subrange Returns a list of integers representing the maximum value for each subrange >>> n = 5 >>> array = [1, 2, 3, 4, 5] >>> queries = [(1, 3), (2, 4), (1, 5)] >>> max_in_subranges(n, array, queries) [3, 4, 5] >>> n = 6 >>> array = [1, 3, 5, 2, 4, 6] >>> queries = [(3, 3), (1, 1), (6, 6)] >>> max_in_subranges(n, array, queries) [5, 1, 6] >>> n = 4 >>> array = [7, 2, 9, 10] >>> queries = [(1, 4)] >>> max_in_subranges(n, array, queries) [10] >>> n = 7 >>> array = [15, 8, 6, 3, 9, 11, 7] >>> queries = [(2, 4), (4, 6)] >>> max_in_subranges(n, array, queries) [8, 11] >>> n = 3 >>> array = [1000000000, 999999999, 1000000001] >>> queries = [(1, 3)] >>> max_in_subranges(n, array, queries) [1000000001]","solution":"def max_in_subranges(n, array, queries): Given an array and a list of subrange queries, return the maximum value for each subrange. n: an integer representing the size of the array array: a list of integers queries: a list of tuples where each tuple contains two integers (l, r) representing the subrange Returns a list of integers representing the maximum value for each subrange results = [] for l, r in queries: results.append(max(array[l-1:r])) return results"},{"question":"def compute_f(n: int) -> int: Compute the value of f(n) = n XOR (n << 1). >>> compute_f(1) 3 >>> compute_f(2) 6 >>> compute_f(10) 30 >>> compute_f(0) 0 >>> compute_f(1024) 3072 pass def process_test_cases(test_cases: List[int]) -> List[int]: Process a list of test cases and return the results for each case. >>> process_test_cases([1, 2, 10]) [3, 6, 30] >>> process_test_cases([0, 3, 7, 1024]) [0, 5, 9, 3072] pass","solution":"def compute_f(n): Compute the value of f(n) = n XOR (n << 1) return n ^ (n << 1) def process_test_cases(test_cases): Process a list of test cases and return the results for each case. return [compute_f(n) for n in test_cases]"},{"question":"class Library: A class to manage a library's book inventory with operations for adding books, searching by author, and listing books within a specified publication year range. def add_book(self, title: str, author: str, year: int, genre: str): Adds a new book to the library's inventory. Args: title (str): The title of the book. author (str): The author of the book. year (int): The publication year of the book. genre (str): The genre of the book. pass def search_books(self, author: str) -> str: Searches for all books by a specific author. Args: author (str): The author to search for. Returns: str: A string containing all books by the author formatted as \\"<title> by <author> (<year>) - <genre>\\", one per line. If no books are found, returns \\"No books found\\". pass def list_books_in_range(self, start_year: int, end_year: int) -> str: Lists all books published between the specified start and end year (inclusive). Args: start_year (int): The start year of the range. end_year (int): The end year of the range. Returns: str: A string containing all books published within the range formatted as \\"<title> by <author> (<year>) - <genre>\\", one per line. If no books are found, returns \\"No books found\\". pass # Example of usage with typical test cases: # >>> library = Library() # >>> library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960, \\"Fiction\\") # >>> library.add_book(\\"1984\\", \\"George Orwell\\", 1949, \\"Dystopian\\") # >>> library.search_books(\\"George Orwell\\") # '1984 by George Orwell (1949) - Dystopian' # >>> library.list_books_in_range(1950, 1965) # 'To Kill a Mockingbird by Harper Lee (1960) - Fiction'","solution":"class Library: def __init__(self): self.books = [] def add_book(self, title, author, year, genre): self.books.append({\\"title\\": title, \\"author\\": author, \\"year\\": year, \\"genre\\": genre}) def search_books(self, author): results = [book for book in self.books if book[\\"author\\"] == author] results = sorted(results, key=lambda x: x[\\"title\\"]) if results: return \\"n\\".join(f'{book[\\"title\\"]} by {book[\\"author\\"]} ({book[\\"year\\"]}) - {book[\\"genre\\"]}' for book in results) else: return \\"No books found\\" def list_books_in_range(self, start_year, end_year): results = [book for book in self.books if start_year <= book[\\"year\\"] <= end_year] results = sorted(results, key=lambda x: (x[\\"title\\"], x[\\"author\\"])) if results: return \\"n\\".join(f'{book[\\"title\\"]} by {book[\\"author\\"]} ({book[\\"year\\"]}) - {book[\\"genre\\"]}' for book in results) else: return \\"No books found\\""},{"question":"def max_fruits(n: int, L: int, fruits_per_day: List[int], d: int) -> int: Returns the maximum number of fruits available in the garden over d days, considering the fruit limit L. n: int - Number of zones L: int - Fruit limit fruits_per_day: List of int - List of fruits produced by each zone per day d: int - Number of days to simulate >>> max_fruits(5, 100, [10, 20, 30, 40, 50], 3) 100 >>> max_fruits(3, 150, [30, 60, 90], 5) 150 >>> max_fruits(4, 200, [50, 50, 50, 50], 2) 200 >>> max_fruits(2, 50, [25, 30], 10) 50 >>> max_fruits(1, 1000, [500], 7) 500","solution":"def max_fruits(n, L, fruits_per_day, d): Returns the maximum number of fruits available in the garden over d days, considering the fruit limit L. n: Number of zones L: Fruit limit fruits_per_day: List of fruits produced by each zone per day d: Number of days to simulate # Calculate total fruits produced in one day total_fruits_per_day = sum(fruits_per_day) # Maximum fruits available cannot exceed the limit L max_fruits_available = min(total_fruits_per_day, L) return max_fruits_available"},{"question":"def can_be_sorted(N: int, A: List[int], B: List[int]) -> str: Determine if you can sort both arrays A and B in such a way that after sorting, every element in A is less than or equal to its corresponding element in B. Args: N : int : The size of the arrays. A : List[int] : The elements of array A. B : List[int] : The elements of array B. Returns: str : \\"Yes\\" if the arrays can be sorted such that A[i] <= B[i] for all indices i, otherwise returns \\"No\\". >>> can_be_sorted(4, [1, 3, 5, 7], [2, 4, 6, 8]) 'Yes' >>> can_be_sorted(3, [3, 6, 2], [1, 4, 5]) 'No'","solution":"def can_be_sorted(N, A, B): Returns \\"Yes\\" if the arrays A and B can be sorted such that A[i] <= B[i] for all indices i, otherwise returns \\"No\\". A.sort() B.sort() for i in range(N): if A[i] > B[i]: return \\"No\\" return \\"Yes\\""},{"question":"def max_words_typed(N: int, T: List[int], M: int) -> int: Determines the maximum number of words Alice can type fully within the given time constraint. Parameters: - N (int): The number of words. - T (list of int): List where the i-th element is the time taken to type the i-th word. - M (int): The total time limit. Returns: - int: The maximum number of words Alice can type fully within the given time limit. >>> max_words_typed(4, [2, 3, 1, 4], 6) 3 >>> max_words_typed(3, [1, 1, 1], 3) 3 >>> max_words_typed(3, [5, 5, 5], 2) 0 >>> max_words_typed(4, [1, 2, 3, 4], 5) 2 >>> max_words_typed(5, [1, 2, 3, 4, 5], 0) 0 >>> max_words_typed(1, [2], 2) 1 >>> max_words_typed(1, [2], 1) 0","solution":"def max_words_typed(N, T, M): Determines the maximum number of words Alice can type fully within the given time constraint. Parameters: - N (int): The number of words. - T (list of int): List where the i-th element is the time taken to type the i-th word. - M (int): The total time limit. Returns: - int: The maximum number of words Alice can type fully within the given time limit. time_spent = 0 words_typed = 0 for time in T: if time_spent + time <= M: time_spent += time words_typed += 1 else: break return words_typed"},{"question":"def max_yield(grids: List[Dict[str, Union[Tuple[int, int, int], List[List[int]]]]]) -> List[int]: Determine the maximum possible yield after a given number of days by planting one crop in the grid. >>> max_yield([{'dimensions': (3, 3, 5), 'grid': [[4, 7, 3], [2, 9, 1], [5, 3, 8]]}]) [45] >>> max_yield([{'dimensions': (3, 3, 5), 'grid': [[4, 7, 3], [2, 9, 1], [5, 3, 8]]}, {'dimensions': (2, 2, 10), 'grid': [[6, 9], [7, 4]]}]) [45, 90] def parse_input(input_data: str) -> List[Dict[str, Union[Tuple[int, int, int], List[List[int]]]]]: Parse the input string and return a list of grids with their dimensions and growth rates. >>> parse_input(\\"3 3 5n4 7 3n2 9 1n5 3 8n0 0\\") [{'dimensions': (3, 3, 5), 'grid': [[4, 7, 3], [2, 9, 1], [5, 3, 8]]}] >>> parse_input(\\"3 3 5n4 7 3n2 9 1n5 3 8n2 2 10n6 9n7 4n0 0\\") [{'dimensions': (3, 3, 5), 'grid': [[4, 7, 3], [2, 9, 1], [5, 3, 8]]}, {'dimensions': (2, 2, 10), 'grid': [[6, 9], [7, 4]]}] import pytest def test_max_yield_single_dataset(): input_data = \\"3 3 5n4 7 3n2 9 1n5 3 8n0 0\\" grids = parse_input(input_data) assert max_yield(grids) == [45] def test_max_yield_multiple_datasets(): input_data = \\"3 3 5n4 7 3n2 9 1n5 3 8n2 2 10n6 9n7 4n0 0\\" grids = parse_input(input_data) assert max_yield(grids) == [45, 90] def test_max_yield_edge_case(): input_data = \\"1 1 10000n100n0 0\\" grids = parse_input(input_data) assert max_yield(grids) == [1000000] def test_max_yield_minimum_values(): input_data = \\"1 1 1n1n0 0\\" grids = parse_input(input_data) assert max_yield(grids) == [1] def test_parse_input_basic(): input_data = \\"3 3 5n4 7 3n2 9 1n5 3 8n0 0\\" expected = [{ 'dimensions': (3, 3, 5), 'grid': [ [4, 7, 3], [2, 9, 1], [5, 3, 8] ] }] assert parse_input(input_data) == expected def test_parse_input_multiple_datasets(): input_data = \\"3 3 5n4 7 3n2 9 1n5 3 8n2 2 10n6 9n7 4n0 0\\" expected = [ { 'dimensions': (3, 3, 5), 'grid': [ [4, 7, 3], [2, 9, 1], [5, 3, 8] ] }, { 'dimensions': (2, 2, 10), 'grid': [ [6, 9], [7, 4] ] } ] assert parse_input(input_data) == expected","solution":"def max_yield(grids): results = [] for grid in grids: m, n, d = grid['dimensions'] max_growth_rate = 0 for row in grid['grid']: max_growth_rate = max(max_growth_rate, max(row)) results.append(max_growth_rate * d) return results def parse_input(input_data): grids = [] input_lines = input_data.strip().split('n') i = 0 while i < len(input_lines): if input_lines[i] == '0 0': break m, n, d = map(int, input_lines[i].split()) i += 1 grid = [] for _ in range(m): row = list(map(int, input_lines[i].split())) grid.append(row) i += 1 grids.append({'dimensions': (m, n, d), 'grid': grid}) return grids"},{"question":"def total_crystal_power(n: int, spells: List[str]) -> int: In a distant land, there exists a peculiar game involving magic crystals and spells. Each player is initially given a single crystal of power 1, and throughout the game, they acquire additional crystals through spells. When a player casts a spell, it either increases the power of an existing crystal by a given amount or it creates a new crystal with a specific power. The goal is to determine the total power of a player's crystals after a sequence of spells. >>> total_crystal_power(1, [\\"increase 1 3\\"]) 4 >>> total_crystal_power(2, [\\"increase 1 2\\", \\"increase 1 3\\"]) 6 >>> total_crystal_power(5, [\\"increase 1 3\\", \\"new 2\\", \\"increase 2 4\\", \\"new 5\\", \\"increase 3 1\\"]) 16 >>> total_crystal_power(1, [\\"new 2\\"]) 3 >>> total_crystal_power(0, []) 1 >>> total_crystal_power(3, [\\"new 3\\", \\"new 5\\", \\"new 7\\"]) 16","solution":"def total_crystal_power(n, spells): crystals = [1] # Initially, there is one crystal with power 1. for spell in spells: parts = spell.split() if parts[0] == \\"increase\\": index = int(parts[1]) - 1 power_increase = int(parts[2]) crystals[index] += power_increase elif parts[0] == \\"new\\": new_power = int(parts[1]) crystals.append(new_power) return sum(crystals)"},{"question":"def rearrangeArray(arr): Rearrange the array in such a way that the largest number is followed by the smallest number, the second largest number is followed by the second smallest number, and so on. >>> rearrangeArray([1, 2, 3, 4, 5]) [5, 1, 4, 2, 3] >>> rearrangeArray([10, 20, 30, 40, 50, 60]) [60, 10, 50, 20, 40, 30] >>> rearrangeArray([]) [] >>> rearrangeArray([1]) [1] >>> rearrangeArray([1, 2, 3, 4]) [4, 1, 3, 2] >>> rearrangeArray([5, 5, 5, 5]) [5, 5, 5, 5] >>> rearrangeArray([1000000000, 1, 500000000, 100000000]) [1000000000, 1, 500000000, 100000000] pass","solution":"def rearrangeArray(arr): Rearrange the array in such a way that the largest number is followed by the smallest number, the second largest number is followed by the second smallest number, and so on. if not arr: return [] sorted_arr = sorted(arr) left = 0 right = len(arr) - 1 result = [] while left <= right: if left == right: result.append(sorted_arr[left]) else: result.extend([sorted_arr[right], sorted_arr[left]]) left += 1 right -= 1 return result"},{"question":"def process_sales_data(T, test_cases): Process the sales data to compute the total revenue generated and the frequency of each item type sold. >>> process_sales_data(2, [(3, [(1, 5.50, 'burger'), (2, 3.25, 'fries'), (3, 7.80, 'drink')]), (2, [(4, 4.20, 'fries'), (5, 6.70, 'burger')])]) [\\"16.55nburger 1ndrink 1nfries 1\\", \\"10.90nburger 1nfries 1\\"] >>> process_sales_data(1, [(0, [])]) [\\"0.00\\"] >>> process_sales_data(1, [(4, [(1, 8.00, 'burger'), (2, 3.00, 'drink'), (3, 2.00, 'drink'), (4, 5.00, 'fries')])]) [\\"18.00nburger 1ndrink 2nfries 1\\"]","solution":"def process_sales_data(T, test_cases): results = [] for i in range(T): N, orders = test_cases[i] total_revenue = 0 item_counts = {} for order in orders: _, amount_spent, item_type = order total_revenue += amount_spent if item_type in item_counts: item_counts[item_type] += 1 else: item_counts[item_type] = 1 total_revenue = round(total_revenue, 2) sorted_items = sorted(item_counts.items()) result = f\\"{total_revenue:.2f}n\\" for item, count in sorted_items: result += f\\"{item} {count}n\\" results.append(result.strip()) return results"},{"question":"def min_operations_to_make_all_ones(grid, n, m): Determines the minimum number of operations needed to turn the entire grid into a grid of all 1s. >>> min_operations_to_make_all_ones([[0, 0], [0, 0]], 2, 2) 1 >>> min_operations_to_make_all_ones([[0, 1, 0], [0, 0, 0], [0, 0, 0]], 3, 3) 2 >>> min_operations_to_make_all_ones([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3, 3) 2 >>> min_operations_to_make_all_ones([[0, 0, 0], [1000, 0, 0], [0, 0, 0]], 3, 3) 1001 >>> min_operations_to_make_all_ones([[3, 2, 1], [4, 5, 6], [7, 8, 9]], 3, 3) 10","solution":"def min_operations_to_make_all_ones(grid, n, m): max_value = max(max(row) for row in grid) return max_value + 1 if max_value > 0 else 1 # Sample usage: # n = 2 # m = 2 # grid = [[0, 0], [0, 0]] # print(min_operations_to_make_all_ones(grid, n, m)) # Output: 1"},{"question":"from typing import List def can_form_palindrome(s: str) -> str: Determines if a string can be rearranged to form a palindrome. Args: s (str): Input string composed of lowercase letters and digits. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, \\"NO\\" otherwise. Example: >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\"","solution":"from collections import Counter def can_form_palindrome(s): Determines if a string can be rearranged to form a palindrome. Args: s (str): Input string composed of lowercase letters and digits. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, \\"NO\\" otherwise. count = Counter(s) odd_count = sum(1 for v in count.values() if v % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def can_place_pieces_without_attack(n: int, k: int, pieces: str) -> str: Determine if it's possible to rearrange exactly k pieces such that no two pieces attack each other. Parameters: n (int): The total number of pieces. k (int): The exact number of pieces to rearrange. pieces (str): A string of length n consisting of the characters 'Q', 'B', or 'R'. Returns: str: \\"YES\\" if it's possible to move exactly k pieces without any attacking each other, otherwise \\"NO\\". # Unit tests def test_can_place_pieces_without_attack(): assert can_place_pieces_without_attack(5, 3, 'QQBRB') == \\"YES\\" assert can_place_pieces_without_attack(4, 2, 'QQBB') == \\"NO\\" assert can_place_pieces_without_attack(10, 5, 'QQBBBRBRRB') == \\"YES\\" assert can_place_pieces_without_attack(5, 6, 'QQBRB') == \\"NO\\" assert can_place_pieces_without_attack(1, 1, 'Q') == \\"YES\\" assert can_place_pieces_without_attack(2, 1, 'RR') == \\"YES\\" assert can_place_pieces_without_attack(2, 3, 'RR') == \\"NO\\"","solution":"def can_place_pieces_without_attack(n, k, pieces): Determine if it's possible to rearrange exactly k pieces such that no two pieces attack each other. Parameters: n (int): The total number of pieces. k (int): The exact number of pieces to rearrange. pieces (str): A string of length n consisting of the characters 'Q', 'B', or 'R'. Returns: str: \\"YES\\" if it's possible to move exactly k pieces without any attacking each other, otherwise \\"NO\\". if k <= n: return \\"YES\\" else: return \\"NO\\""},{"question":"def largest_prime_up_to_n(n): Returns the largest prime number smaller than or equal to n using the Sieve of Eratosthenes algorithm. >>> largest_prime_up_to_n(10) 7 >>> largest_prime_up_to_n(100) 97 >>> largest_prime_up_to_n(2) 2 >>> largest_prime_up_to_n(1) None","solution":"def largest_prime_up_to_n(n): Returns the largest prime number smaller than or equal to n using the Sieve of Eratosthenes algorithm. if n < 2: return None # No prime number less than 2 # Initialize a boolean array \\"prime[0..n]\\" and set all entries to be True. # A value in prime[i] will finally be False if i is Not a prime, True if i is a prime. prime = [True] * (n + 1) p = 2 while p * p <= n: # If prime[p] is not changed, then it is a prime if prime[p]: # Updating all multiples of p for i in range(p * p, n + 1, p): prime[i] = False p += 1 # Find the largest prime number smaller than or equal to n for p in range(n, 1, -1): if prime[p]: return p"},{"question":"def evaluate(expression): Evaluates a simple arithmetic expression containing two non-negative integers and one operator. Supports the following operations: addition, subtraction, multiplication, and integer division. Args: expression (str): The expression to evaluate in the format \\"num1 op num2\\". Returns: str: The evaluation result as a string or \\"Invalid input\\" if the input is invalid. >>> evaluate(\\"12 + 5\\") == \\"17\\" >>> evaluate(\\"7 - 3\\") == \\"4\\" >>> evaluate(\\"6 * 4\\") == \\"24\\" >>> evaluate(\\"8 / 2\\") == \\"4\\" >>> evaluate(\\"8 / 0\\") == \\"Invalid input\\" >>> evaluate(\\"five + ten\\") == \\"Invalid input\\" >>> evaluate(\\"3 *\\") == \\"Invalid input\\"","solution":"def evaluate(expression): Evaluates a simple arithmetic expression containing two non-negative integers and one operator. Supports the following operations: addition, subtraction, multiplication, and integer division. Args: expression (str): The expression to evaluate in the format \\"num1 op num2\\". Returns: str: The evaluation result as a string or \\"Invalid input\\" if the input is invalid. try: # Split the expression into components parts = expression.split() if len(parts) != 3: return \\"Invalid input\\" num1, op, num2 = parts # Convert numbers num1 = int(num1) num2 = int(num2) # Perform the appropriate operation if op == \\"+\\": return str(num1 + num2) elif op == \\"-\\": return str(num1 - num2) elif op == \\"*\\": return str(num1 * num2) elif op == \\"/\\": if num2 == 0: return \\"Invalid input\\" return str(num1 // num2) else: return \\"Invalid input\\" except (ValueError, TypeError): return \\"Invalid input\\""},{"question":"from typing import List def process_input(input_data: List[str]) -> List[str]: Determine if Alice can navigate from the top-left corner to the bottom-right corner of the grid. Parameters: input_data (List[str]): The list of input strings representing multiple datasets. Returns: List[str]: List of results for each dataset, either \\"Yes\\" if Alice can navigate or \\"No\\" if she cannot. >>> process_input([ \\"3 3\\", \\"..#\\", \\".#.\\", \\"...\\", \\"3 3\\", \\"..#\\", \\"#\\", \\"...\\", \\"4 4\\", \\"....\\", \\".#.#\\", \\"....\\", \\"....\\", \\"0 0\\" ]) ['Yes', 'No', 'Yes'] >>> process_input([ \\"2 2\\", \\"\\", \\"\\", \\"0 0\\" ]) ['No']","solution":"from collections import deque def valid(r, c, H, W, grid, visited): return 0 <= r < H and 0 <= c < W and grid[r][c] == '.' and not visited[r][c] def bfs(grid, H, W): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = [[False]*W for _ in range(H)] visited[0][0] = True while queue: r, c = queue.popleft() if r == H-1 and c == W-1: return True for dr, dc in directions: nr, nc = r + dr, c + dc if valid(nr, nc, H, W, grid, visited): visited[nr][nc] = True queue.append((nr, nc)) return False def can_alice_escape(grid, H, W): if grid[0][0] != '.' or grid[H-1][W-1] != '.': return \\"No\\" if bfs(grid, H, W): return \\"Yes\\" return \\"No\\" def process_input(input_data): results = [] i = 0 while True: H, W = map(int, input_data[i].split()) if H == 0 and W == 0: break grid = [input_data[i+j+1] for j in range(H)] results.append(can_alice_escape(grid, H, W)) i += H + 1 return results # Example usage: input_data = [ \\"3 3\\", \\"..#\\", \\".#.\\", \\"...\\", \\"3 3\\", \\"..#\\", \\"#\\", \\"...\\", \\"4 4\\", \\"....\\", \\".#.#\\", \\"....\\", \\"....\\", \\"0 0\\" ] print(process_input(input_data))"},{"question":"def tsp_minimum_distance(matrix): Solves the Traveling Salesman Problem (TSP) to find the minimum distance required to visit each city exactly once and return to the starting city. Args: matrix (list of list of int): A 2D list representing the distances between cities. Returns: int: The minimum distance required to complete the tour. >>> parse_input(\\"4n0 10 15 20n10 0 35 25n15 35 0 30n20 25 30 0\\") [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]] >>> tsp_minimum_distance([[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) 80 >>> tsp_minimum_distance([[0, 1], [1, 0]]) 2 >>> tsp_minimum_distance([[0, 1, 2], [1, 0, 3], [2, 3, 0]]) 6 >>> tsp_minimum_distance([[0, 10, 15], [10, 0, 20], [15, 20, 0]]) 45 >>> tsp_minimum_distance([[0, 10, 15, 20], [10, 0, 25, 25], [15, 25, 0, 30], [20, 25, 30, 0]]) 80 pass def parse_input(input_str): Parses the input string into a 2D list representing the distances between cities. Args: input_str (str): A string representation of the input. Returns: list of list of int: A 2D list representing the distances between cities. pass","solution":"from itertools import permutations def tsp_minimum_distance(matrix): Solves the Traveling Salesman Problem (TSP) to find the minimum distance required to visit each city exactly once and return to the starting city. Args: matrix (list of list of int): A 2D list representing the distances between cities. Returns: int: The minimum distance required to complete the tour. n = len(matrix) cities = list(range(n)) min_distance = float('inf') for perm in permutations(cities): current_distance = 0 for i in range(n-1): current_distance += matrix[perm[i]][perm[i+1]] current_distance += matrix[perm[-1]][perm[0]] # return to starting city min_distance = min(min_distance, current_distance) return min_distance # Function to parse input def parse_input(input_str): lines = input_str.strip().split('n') n = int(lines[0]) matrix = [list(map(int, lines[i+1].split())) for i in range(n)] return matrix"},{"question":"class Node(): def __init__(self, data, next=None): self.data = data self.next = next def reverse_list(head: Node) -> Node: Reverses a singly linked list. :param head: Head node of the singly linked list. :return: Head node of the reversed singly linked list. pass # Test Cases def list_to_python_list(head): Helper function to convert linked list to Python list. result = [] current = head while current is not None: result.append(current.data) current = current.next return result def test_reverse_list_empty(): assert reverse_list(None) is None def test_reverse_list_single_element(): node = Node(1) reversed_list = reverse_list(node) assert list_to_python_list(reversed_list) == [1] def test_reverse_list_multiple_elements(): head = Node(1, Node(2, Node(3, Node(4)))) reversed_list = reverse_list(head) assert list_to_python_list(reversed_list) == [4, 3, 2, 1] def test_reverse_list_two_elements(): head = Node(1, Node(2)) reversed_list = reverse_list(head) assert list_to_python_list(reversed_list) == [2, 1] def test_reverse_list_identical_elements(): head = Node(1, Node(1, Node(1))) reversed_list = reverse_list(head) assert list_to_python_list(reversed_list) == [1, 1, 1]","solution":"class Node: def __init__(self, data, next=None): self.data = data self.next = next def reverse_list(head): Reverses a singly linked list. :param head: Head node of the singly linked list. :return: Head node of the reversed singly linked list. prev = None current = head while current is not None: next_node = current.next # Store the next node current.next = prev # Reverse the link prev = current # Move prev and current one step forward current = next_node return prev # prev will be the new head at the end of the loop"},{"question":"def calculate_average_time(N, reminder_times): Calculate the average reminder time. :param N: number of contests :param reminder_times: list of reminder times in minutes :return: average reminder time rounded to two decimal places # Example Usage: # >>> calculate_average_time(3, [15, 30, 45]) # 30.00 # >>> calculate_average_time(5, [100, 200, 300, 400, 500]) # 300.00 # You can use these unit tests to validate your solution: def test_calculate_average_time_sample_1(): assert calculate_average_time(3, [15, 30, 45]) == 30.00 def test_calculate_average_time_sample_2(): assert calculate_average_time(5, [100, 200, 300, 400, 500]) == 300.00 def test_calculate_average_time_all_zeros(): assert calculate_average_time(4, [0, 0, 0, 0]) == 0.00 def test_calculate_average_time_mixed_times(): assert calculate_average_time(4, [5, 15, 25, 35]) == 20.00 def test_calculate_average_time_single_contest(): assert calculate_average_time(1, [60]) == 60.00 def test_calculate_average_time_large_numbers(): assert calculate_average_time(3, [1440, 1440, 1440]) == 1440.00 def test_calculate_average_time_empty(): assert calculate_average_time(0, []) == 0.00","solution":"def calculate_average_time(N, reminder_times): Calculate the average reminder time. :param N: number of contests :param reminder_times: list of reminder times in minutes :return: average reminder time rounded to two decimal places if N == 0: return 0.0 return round(sum(reminder_times) / N, 2)"},{"question":"from typing import List def min_steps_to_treasure(R: int, C: int, grid: List[str]) -> int: Returns the minimum number of steps to reach the treasure chest from the starting position in a given dungeon grid. If it's impossible to reach the treasure, returns -1. >>> min_steps_to_treasure(5, 5, [\\".....\\", \\".#.\\", \\"...#.\\", \\".#.\\", \\".....\\"]) 8 >>> min_steps_to_treasure(4, 4, [\\"....\\", \\"\\", \\"..#.\\", \\"...#\\"]) -1 from collections import deque def test_min_steps_to_treasure_example1(): R, C = 5, 5 grid = [ \\".....\\", \\".#.\\", \\"...#.\\", \\".#.\\", \\".....\\" ] return min_steps_to_treasure(R, C, grid) == 8 def test_min_steps_to_treasure_example2(): R, C = 4, 4 grid = [ \\"....\\", \\"\\", \\"..#.\\", \\"...#\\" ] return min_steps_to_treasure(R, C, grid) == -1 def test_min_steps_to_treasure_no_walls(): R, C = 3, 3 grid = [ \\"...\\", \\"...\\", \\"...\\" ] return min_steps_to_treasure(R, C, grid) == 4 def test_min_steps_to_treasure_all_walls(): R, C = 3, 3 grid = [ \\"#\\", \\"#\\", \\"#\\" ] return min_steps_to_treasure(R, C, grid) == -1 def test_min_steps_to_treasure_start_and_end_same(): R, C = 1, 1 grid = [\\".\\"] return min_steps_to_treasure(R, C, grid) == 0 def test_min_steps_to_treasure_blocked_path(): R, C = 3, 3 grid = [ \\".#.\\", \\"#.#\\", \\".#.\\" ] return min_steps_to_treasure(R, C, grid) == -1","solution":"from collections import deque def min_steps_to_treasure(R, C, grid): Returns the minimum number of steps to reach the treasure chest from the starting position in a given dungeon grid. If it's impossible to reach the treasure, returns -1. if grid[0][0] == \\"#\\" or grid[R-1][C-1] == \\"#\\": return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() # Check if we reached the treasure if r == R-1 and c == C-1: return steps # Explore neighbors for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] == \\".\\" and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1 # Example Usage: # R, C = 5, 5 # grid = [ # \\".....\\", # \\".#.\\", # \\"...#.\\", # \\".#.\\", # \\".....\\" # ] # print(min_steps_to_treasure(R, C, grid)) # Output: 8"},{"question":"from typing import List, Tuple def maximize_deliveries(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Determine the maximum number of packages that can be successfully delivered for each test case. Args: test_cases: List of tuples containing M, W and a list of (Wi, Di) tuples for each test case. Returns: List of integers where each integer is the maximum number of packages that can be successfully delivered for a test case. >>> test_cases = [(3, 5, [(3, 5), (2, 2), (1, 1)]), (4, 10, [(1, 2), (2, 4), (3, 6), (4, 8)])] >>> maximize_deliveries(test_cases) [2, 4] pass def parse_input(input_str: str) -> List[Tuple[int, int, List[Tuple[int, int]]]]: Parse the input string to extract the test cases. Args: input_str: String containing the input data. Returns: List of test cases. Each test case is a tuple containing M, W and a list of (Wi, Di) tuples. >>> input_str = \\"3 5n3 5n2 2n1 1n4 10n1 2n2 4n3 6n4 8n0 0\\" >>> parse_input(input_str) [(3, 5, [(3, 5), (2, 2), (1, 1)]), (4, 10, [(1, 2), (2, 4), (3, 6), (4, 8)])] pass def main(input_str: str): test_cases = parse_input(input_str) results = maximize_deliveries(test_cases) for result in results: print(result)","solution":"def maximize_deliveries(test_cases): Function to determine the maximum number of packages that can be successfully delivered given multiple test cases. Args: test_cases: List of tuples containing M, W and a list of (Wi, Di) tuples for each test case. Returns: List of integers where each integer is the maximum number of packages that can be successfully delivered for a test case. results = [] for case in test_cases: M, W, packages = case packages.sort(key=lambda x: x[1]) # sort packages by their deadlines dp = [[0] * (W + 1) for _ in range(M + 1)] for i in range(1, M + 1): wi, di = packages[i-1] for w in range(W + 1): if wi <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-wi] + 1) else: dp[i][w] = dp[i-1][w] results.append(dp[M][W]) return results def parse_input(input_str): Parse the input string to extract the test cases. Args: input_str: String containing the input data. Returns: List of test cases. Each test case is a tuple containing M, W and a list of (Wi, Di) tuples. lines = input_str.strip().split('n') test_cases = [] i = 0 while i < len(lines): M, W = map(int, lines[i].split()) if M == 0 and W == 0: break packages = [] for j in range(i + 1, i + 1 + M): Wi, Di = map(int, lines[j].split()) packages.append((Wi, Di)) test_cases.append((M, W, packages)) i += M + 1 return test_cases def main(input_str): test_cases = parse_input(input_str) results = maximize_deliveries(test_cases) for result in results: print(result)"},{"question":"def is_almost_special(number: str) -> str: Check whether the number is \\"almost special\\" or not. A number is \\"almost special\\" if its digits consist of only the digits '2', '5', and '9' and it contains at least one '2', one '5', and one '9'. Examples: >>> is_almost_special(\\"259\\") \\"YES\\" >>> is_almost_special(\\"2259\\") \\"YES\\" >>> is_almost_special(\\"252\\") \\"NO\\" >>> is_almost_special(\\"2456\\") \\"NO\\" >>> is_almost_special(\\"225599\\") \\"YES\\" >>> is_almost_special(\\"5\\") \\"NO\\" >>> is_almost_special(\\"25\\") \\"NO\\" >>> is_almost_special(\\"1234567890259\\") \\"YES\\" >>> is_almost_special(\\"134678\\") \\"NO\\" >>> is_almost_special(\\"259259259\\") \\"YES\\"","solution":"def is_almost_special(number: str) -> str: Returns \\"YES\\" if the number is almost special, otherwise returns \\"NO\\". if '2' in number and '5' in number and '9' in number: return \\"YES\\" else: return \\"NO\\""},{"question":"def minimum_cost_to_connect_water_tanks(n: int, m: int, pipes: List[Tuple[int, int, int]]) -> int: Determine the minimum maintenance cost required to connect all water tanks in a city. Args: n (int): The number of water tanks. m (int): The number of pipes. pipes (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers u, v, and w, which represent the two water tanks connected by the pipe and the maintenance cost of that pipe. Returns: int: The minimum cost required to connect all the water tanks. Examples: >>> minimum_cost_to_connect_water_tanks(4, 5, [(1, 2, 1), (1, 3, 2), (1, 4, 3), (2, 3, 4), (3, 4, 5)]) 6 >>> minimum_cost_to_connect_water_tanks(2, 1, [(1, 2, 10)]) 10","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal(n, edges): edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) mst_cost = 0 mst_edges_count = 0 for edge in edges: u, v, w = edge u -= 1 v -= 1 if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_cost += w mst_edges_count += 1 if mst_edges_count == n - 1: break return mst_cost def minimum_cost_to_connect_water_tanks(n, m, pipes): edges = [] for pipe in pipes: u, v, w = pipe edges.append((u, v, w)) return kruskal(n, edges)"},{"question":"def shortest_paths(n: int, edges: List[Tuple[int, int, int]], testcases: List[Tuple[int, int]]) -> List[int]: You are given a directed graph with \`n\` nodes and \`m\` edges. Each edge has a weight associated with it. The graph does not contain any negative weight edges. Your task is to find the shortest path from a given source node \`s\` to a given destination node \`d\`. If there is no path from \`s\` to \`d\`, return \`-1\`. >>> n = 5 >>> edges = [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1)] >>> testcases = [(1, 5), (2, 5), (5, 1)] >>> shortest_paths(n, edges, testcases) [6, 4, -1] >>> n = 3 >>> edges = [] >>> testcases = [(1, 2), (2, 3), (1, 3)] >>> shortest_paths(n, edges, testcases) [-1, -1, -1] >>> n = 1 >>> edges = [] >>> testcases = [(1, 1)] >>> shortest_paths(n, edges, testcases) [0] >>> n = 3 >>> edges = [(1, 2, 2), (2, 3, 3)] >>> testcases = [(1, 3)] >>> shortest_paths(n, edges, testcases) [5] >>> n = 4 >>> edges = [(1, 2, 1), (3, 4, 1)] >>> testcases = [(1, 4), (2, 3), (3, 2)] >>> shortest_paths(n, edges, testcases) [-1, -1, -1]","solution":"import heapq import sys def dijkstra(graph, n, start): dist = [sys.maxsize] * (n + 1) dist[start] = 0 pq = [(0, start)] while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return dist def shortest_paths(n, edges, testcases): graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) results = [] for s, d in testcases: dist = dijkstra(graph, n, s) if dist[d] == sys.maxsize: results.append(-1) else: results.append(dist[d]) return results"},{"question":"def combination_sum(nums, target): Finds all unique combinations in the list where the sum of the integers in each combination is equal to the target. Each number in the list may only be used once in each combination, but the same number may appear in different combinations. Args: nums: List[int] - a list of integers target: int - the target sum Returns: List[List[int]] - a list of all unique combinations where the sum of the integers equals to the target. Example: >>> combination_sum([2, 3, 6, 7], 7) [[7]] >>> combination_sum([2, 5, 2, 1, 2], 5) [[1, 2, 2], [5]] >>> combination_sum([10, 1, 2, 7, 6, 1, 5], 8) [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]] pass # Implement the function logic here from solution import combination_sum def test_combination_sum_example1(): assert combination_sum([2, 3, 6, 7], 7) == [[7]] def test_combination_sum_example2(): assert combination_sum([2, 5, 2, 1, 2], 5) == [[1, 2, 2], [5]] def test_combination_sum_example3(): assert combination_sum([10, 1, 2, 7, 6, 1, 5], 8) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]] def test_combination_sum_no_combinations(): assert combination_sum([4, 5, 6], 3) == [] def test_combination_sum_all_elements(): assert combination_sum([1, 2, 3, 4], 10) == [[1, 2, 3, 4]] def test_combination_sum_multiple_duplicates(): assert combination_sum([1, 1, 1, 1, 1], 3) == [[1, 1, 1]]","solution":"def combination_sum(nums, target): Finds all unique combinations in nums where the sum equals the target. nums.sort() # Sorting the nums list to get combinations in non-decreasing order result = [] def backtrack(start, target, path): if target == 0: result.append(path) return if target < 0: return for i in range(start, len(nums)): if i > start and nums[i] == nums[i-1]: continue # skip duplicates backtrack(i + 1, target - nums[i], path + [nums[i]]) backtrack(0, target, []) return result"},{"question":"def reverse_string_with_words_maintained(input_string: str) -> str: This function takes a string as input and returns the string with the letters in each word reversed, but maintaining the word order and spaces. >>> reverse_string_with_words_maintained(\\"\\") == \\"\\" >>> reverse_string_with_words_maintained(\\"hello\\") == \\"olleh\\" >>> reverse_string_with_words_maintained(\\"world!\\") == \\"!dlrow\\" >>> reverse_string_with_words_maintained(\\"hello world!\\") == \\"olleh !dlrow\\" >>> reverse_string_with_words_maintained(\\"how are you?\\") == \\"woh era ?uoy\\" >>> reverse_string_with_words_maintained(\\" hello, world! \\") == \\" ,olleh !dlrow \\" >>> reverse_string_with_words_maintained(\\"how are you?\\") == \\"woh era ?uoy\\" >>> reverse_string_with_words_maintained(\\" \\") == \\" \\" >>> reverse_string_with_words_maintained(\\"foo! bar, baz...\\") == \\"!oof ,rab ...zab\\" >>> reverse_string_with_words_maintained(\\"Hello, World!\\") == \\",olleH !dlroW\\" >>> reverse_string_with_words_maintained(\\"123 abc 456 def\\") == \\"321 cba 654 fed\\"","solution":"def reverse_string_with_words_maintained(input_string: str) -> str: This function takes a string as input and returns the string with the letters in each word reversed, but maintaining the word order and spaces. def reverse_word(word): return word[::-1] words = input_string.split(' ') # Split the input string by spaces to handle the original spaces. reversed_words = [reverse_word(word) for word in words] # Reverse each word. return ' '.join(reversed_words) # Rejoin the words with spaces and return the result."},{"question":"from typing import List def reorder_string(S: str) -> str: Reorders the string S such that all 'a's come before all 'b's. >>> reorder_string(\\"abba\\") \\"aabb\\" >>> reorder_string(\\"ababab\\") \\"aaabbb\\" >>> reorder_string(\\"bbaa\\") \\"aabb\\" >>> reorder_string(\\"aabb\\") \\"aabb\\" >>> reorder_string(\\"ba\\") \\"ab\\" >>> reorder_string(\\"aaaa\\") \\"aaaa\\" >>> reorder_string(\\"a\\") \\"a\\" >>> reorder_string(\\"bbbb\\") \\"bbbb\\" >>> reorder_string(\\"b\\") \\"b\\" >>> reorder_string(\\"\\") \\"\\" >>> reorder_string(\\"ab\\" * (10**6 // 2)) \\"a\\" * (10**6 // 2) + \\"b\\" * (10**6 // 2)","solution":"def reorder_string(S): Reorders the string S such that all 'a's come before all 'b's. # Count the number of 'a's and 'b's in the string count_a = S.count('a') count_b = len(S) - count_a # Generate the lexicographically smallest string by placing all 'a's first followed by all 'b's result = 'a' * count_a + 'b' * count_b return result"},{"question":"def valid_path(n: int, m: int, grid: List[str]) -> str: Determine if there exists a path from the top-left corner to the bottom-right corner of a grid that satisfies the condition where the number of '1's equals the number of '0's along the path. >>> valid_path(4, 5, [\\"01101\\", \\"10000\\", \\"10010\\", \\"00111\\"]) \\"YES\\" >>> valid_path(3, 3, [\\"010\\", \\"101\\", \\"011\\"]) \\"NO\\"","solution":"def valid_path(n, m, grid): def dfs(x, y, ones, zeros, visited): if x < 0 or x >= n or y < 0 or y >= m: return False if (x, y) in visited: return False if grid[x][y] == '1': ones += 1 else: zeros += 1 if ones > (n + m) // 2 or zeros > (n + m) // 2: return False if x == n - 1 and y == m - 1: return ones == zeros visited.add((x, y)) right = dfs(x, y + 1, ones, zeros, visited) down = dfs(x + 1, y, ones, zeros, visited) visited.remove((x, y)) return right or down return \\"YES\\" if dfs(0, 0, 0, 0, set()) else \\"NO\\" # Example Input: n = 4 m = 5 grid = [ \\"01101\\", \\"10000\\", \\"10010\\", \\"00111\\" ] print(valid_path(n, m, grid)) # Output: YES"},{"question":"from typing import List def transformList(lst: List[int]) -> List[int]: Transforms the given list by adding each element to its neighbors. For elements at the edge, treat the missing neighbors as 0. Example: >>> transformList([1, 2, 3]) [3, 6, 5] >>> transformList([4, 5, 6, 7]) [9, 15, 18, 13] >>> transformList([5]) [5] >>> transformList([2, 3]) [5, 5] >>> transformList([-1, -2, -3]) [-3, -6, -5] >>> transformList([-1, 0, 1]) [-1, 0, 1] >>> transformList([]) [] >>> transformList([1] * 100) [2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2]","solution":"def transformList(lst): Transforms the given list by adding each element to its neighbors. For elements at the edge, treat the missing neighbors as 0. n = len(lst) if n == 0: return lst result = [0] * n for i in range(n): left = lst[i - 1] if i - 1 >= 0 else 0 right = lst[i + 1] if i + 1 < n else 0 result[i] = lst[i] + left + right return result"},{"question":"import heapq def kth_smallest_element(nums, k): Finds the k-th smallest element in the list using a max-heap. Parameters: nums (list): List of integers. k (int): The position of the smallest element to find. Returns: int: The k-th smallest element. Example: >>> kth_smallest_element([7, 10, 4, 3, 20, 15, 2], 3) 4 >>> kth_smallest_element([1, 2, 3, 4, 5, 6, 7], 1) 1 >>> kth_smallest_element([1, 2, 3, 4, 5, 6, 7], 7) 7 >>> kth_smallest_element([5, 3, 8], 2) 5 >>> kth_smallest_element([3, 1, 2, 2, 3], 3) 2","solution":"import heapq def kth_smallest_element(nums, k): Finds the k-th smallest element in the list using a max-heap. Parameters: nums (list): List of integers. k (int): The position of the smallest element to find. Returns: int: The k-th smallest element. # Utilize max-heap for the k smallest elements (invert values for max-heap behavior) max_heap = [] for num in nums: heapq.heappush(max_heap, -num) if len(max_heap) > k: heapq.heappop(max_heap) return -heapq.heappop(max_heap)"},{"question":"def is_scramble(s1: str, s2: str) -> bool: Determines if s2 is a scrambled version of s1. >>> is_scramble(\\"great\\", \\"rgeat\\") True >>> is_scramble(\\"abcde\\", \\"caebd\\") False","solution":"def is_scramble(s1, s2): Determines if s2 is a scrambled version of s1. if len(s1) != len(s2): return False if s1 == s2: return True if sorted(s1) != sorted(s2): return False n = len(s1) for i in range(1, n): if (is_scramble(s1[:i], s2[:i]) and is_scramble(s1[i:], s2[i:])) or (is_scramble(s1[:i], s2[n-i:]) and is_scramble(s1[i:], s2[:n-i])): return True return False"},{"question":"def can_reach_end(test_cases): Determine if it's possible to reach the end or beyond of the array from the starting position using the given jump lengths. Parameters: test_cases (List[Tuple[int, List[int]]]): A list of test cases, where each test case is a tuple containing the length of the array and the array of jump lengths. Returns: List[str]: A list of strings \\"YES\\" or \\"NO\\" for each test case, depending on whether it's possible to reach the end of the array. >>> can_reach_end([(5, [2, 3, 1, 1, 4]), (5, [3, 2, 1, 0, 4]), (5, [0, 2, 1, 0, 4]), (1, [0])]) [\\"YES\\", \\"NO\\", \\"NO\\", \\"YES\\"] >>> can_reach_end([(5, [0, 0, 0, 0, 0]), (3, [0, 0, 0])]) [\\"NO\\", \\"NO\\"] >>> can_reach_end([(1, [0]), (1, [5]), (1, [1000])]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> can_reach_end([(3, [1, 1, 10]), (4, [1, 0, 0, 10]), (5, [1, 1, 1, 1, 10])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> can_reach_end([(4, [1, 1, 1, 1]), (5, [2, 3, 0, 1, 2]), (5, [2, 1, 1, 0, 4])]) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_reach_end(test_cases): results = [] for cases in test_cases: n = cases[0] array = cases[1] max_reachable = 0 for i in range(n): if i > max_reachable: results.append(\\"NO\\") break max_reachable = max(max_reachable, i + array[i]) if max_reachable >= n - 1: results.append(\\"YES\\") break else: results.append(\\"YES\\" if max_reachable >= n - 1 else \\"NO\\") return results"},{"question":"def apply_operations(array, operations): Apply multiple range update operations to an array. Parameters: array (list): List of integers. operations (list): List of triplets [a, b, k] where a and b are indices and k is the value to be added. Returns: list: Modified array after applying all operations. Example: >>> apply_operations([1, 2, 3, 4, 5], [[1, 3, 10], [2, 4, 5]]) [1, 12, 18, 19, 10]","solution":"def apply_operations(array, operations): Apply multiple range update operations to an array. Parameters: array (list): List of integers. operations (list): List of triplets [a, b, k] where a and b are indices and k is the value to be added. Returns: list: Modified array after applying all operations. # Step 1: Create a prefix sum array of size len(array)+1 initialized to 0 n = len(array) prefix_sum = [0] * (n + 1) # Step 2: Apply each operation to the prefix sum array for a, b, k in operations: prefix_sum[a] += k if b + 1 < n: prefix_sum[b + 1] -= k # Step 3: Compute the actual values in the array using the prefix sum current_sum = 0 for i in range(n): current_sum += prefix_sum[i] array[i] += current_sum return array"},{"question":"def largest_square_submatrix(matrix): Find the side length of the largest square sub-matrix where all characters are the same. >>> largest_square_submatrix([ ... ['a', 'a', 'a', 'b', 'b', 'b'], ... ['a', 'a', 'a', 'b', 'b', 'b'], ... ['a', 'a', 'a', 'c', 'c', 'c'], ... ['b', 'b', 'b', 'c', 'c', 'c'], ... ['b', 'b', 'b', 'c', 'c', 'c'] ... ]) == 3 >>> largest_square_submatrix([ ... ['p', 'p', 'q', 'q'], ... ['p', 'p', 'q', 'q'], ... ['l', 'l', 'k', 'k'], ... ['l', 'l', 'k', 'k'] ... ]) == 2 >>> largest_square_submatrix([ ... ['a', 'b', 'c'], ... ['d', 'e', 'f'], ... ['g', 'h', 'i'] ... ]) == 1 pass","solution":"def largest_square_submatrix(matrix): if not matrix: return 0 M = len(matrix) N = len(matrix[0]) # Initialize dp table dp = [[0] * N for _ in range(M)] max_side_length = 0 for i in range(M): for j in range(N): if i == 0 or j == 0: dp[i][j] = 1 else: if matrix[i][j] == matrix[i-1][j] == matrix[i][j-1] == matrix[i-1][j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 else: dp[i][j] = 1 max_side_length = max(max_side_length, dp[i][j]) return max_side_length def read_input_and_solve(input_str): lines = input_str.strip().split('n') M, N = map(int, lines[0].strip().split()) matrix = [line.strip().split() for line in lines[1:]] return largest_square_submatrix(matrix)"},{"question":"from typing import List from collections import Counter def most_frequent_item(items: List[str]) -> str: You are given a list of strings representing a collection of items in a store. Each item can be represented multiple times if multiple units of that item are present. Your task is to find and return the item that appears most frequently in the list. If there is a tie for the most frequent item, return the item that comes first lexicographically. If the list is empty, the function should return an empty string. >>> most_frequent_item([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) \\"apple\\" >>> most_frequent_item([\\"carrot\\", \\"carrot\\", \\"lettuce\\", \\"lettuce\\", \\"lettuce\\", \\"carrot\\"]) \\"carrot\\" >>> most_frequent_item([\\"zucchini\\", \\"pea\\", \\"bean\\", \\"pea\\", \\"zucchini\\", \\"bean\\"]) \\"bean\\" >>> most_frequent_item([]) \\"\\" pass","solution":"from collections import Counter def most_frequent_item(items): if not items: return \\"\\" freq = Counter(items) most_common = freq.most_common() max_count = most_common[0][1] candidates = [item for item, count in most_common if count == max_count] return min(candidates)"},{"question":"def find_domino_sequence(domino_str: str) -> str: Create a function that takes a string representing a Domino sequence and returns a new string that represents the best possible arrangement. >>> find_domino_sequence('2:1 1:3 3:2') in ['1:3 3:2 2:1', '2:1 1:3 3:2'] True >>> find_domino_sequence('5:3 3:6 6:2 2:2 2:1 1:3') in [\\"5:3 3:6 6:2 2:2 2:1 1:3\\", 'Invalid sequence'] True >>> find_domino_sequence('2:1 1:3 3:2 2:5') in ['2:1 1:3 3:2 2:5', 'Invalid sequence'] True >>> find_domino_sequence('1:2 3:4 5:6') 'Invalid sequence' >>> find_domino_sequence('') 'Invalid sequence'","solution":"def find_domino_sequence(domino_str): from collections import defaultdict, deque def build_graph(dominos): graph = defaultdict(list) indegree = defaultdict(int) outdegree = defaultdict(int) for d in dominos: left, right = map(int, d.split(':')) graph[left].append(right) outdegree[left] += 1 indegree[right] += 1 return graph, indegree, outdegree def find_start_node(graph, indegree, outdegree): start = None for node in graph: if outdegree[node] > indegree[node]: if start is not None: return None # More than one starting node start = node if start is None: return next(iter(graph)) # Any node return start def dfs(graph, start): stack = [start] result = deque() while stack: while graph[stack[-1]]: stack.append(graph[stack[-1]].pop()) result.appendleft(stack.pop()) return result dominos = domino_str.split() if not dominos: return \\"Invalid sequence\\" graph, indegree, outdegree = build_graph(dominos) start = find_start_node(graph, indegree, outdegree) if start is None: return \\"Invalid sequence\\" sequence = dfs(graph, start) # Extra validation to check if we used all dominos if len(sequence) != len(dominos) + 1: return \\"Invalid sequence\\" result = [] prev = sequence.popleft() result.append(prev) while sequence: curr = sequence.popleft() result.append(f\\"{prev}:{curr}\\") prev = curr return \\" \\".join(result[1:]) # Example Usage # Input: '2:1 5:3 2:2 3:6 1:3' # Output (Any of the valid arrangements): 'Invalid sequence' (since no valid starting without predecessor)"},{"question":"def maxNutrientValue(nutrientValues: List[int]) -> int: Returns the maximum nutrient value Julie can collect while not picking nutrient values from consecutive rows. >>> maxNutrientValue([3, 2, 5, 10]) 13 >>> maxNutrientValue([3, 2, 7, 10, 12]) 22 >>> maxNutrientValue([0, 0, 0, 0, 0]) 0 >>> maxNutrientValue([5]) 5 >>> maxNutrientValue([5, 10]) 10 >>> maxNutrientValue([10, 5]) 10 >>> maxNutrientValue([]) 0 >>> maxNutrientValue([10000, 10000, 10000, 10000, 10000]) 30000 >>> maxNutrientValue([1, 100, 1, 100, 1]) 200 >>> maxNutrientValue([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 30 >>> maxNutrientValue([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 30","solution":"def maxNutrientValue(nutrientValues): Returns the maximum nutrient value Julie can collect while not picking nutrient values from consecutive rows. n = len(nutrientValues) if n == 0: return 0 elif n == 1: return nutrientValues[0] elif n == 2: return max(nutrientValues[0], nutrientValues[1]) # Initialize dp arrays dp = [0] * n dp[0] = nutrientValues[0] dp[1] = max(nutrientValues[0], nutrientValues[1]) for i in range(2, n): dp[i] = max(nutrientValues[i] + dp[i-2], dp[i-1]) return dp[-1]"},{"question":"def longest_subsequence(t: int, cases: List[Tuple[int, int, List[int]]]) -> List[int]: Find the length of the longest subsequence that is strictly increasing with a difference of k between consecutive elements. >>> longest_subsequence(3, [ ... (5, 2, [1, 3, 5, 7, 9]), ... (6, 1, [10, 9, 8, 7, 6, 5]), ... (4, 3, [10, 13, 16, 19]) ... ]) == [5, 1, 4] >>> longest_subsequence(1, [ ... (5, 5, [5, 10, 15, 20, 25]) ... ]) == [5] >>> longest_subsequence(1, [ ... (7, 4, [1, 5, 9, 13, 17, 21, 25]) ... ]) == [7] >>> longest_subsequence(2, [ ... (6, 2, [2, 4, 6, 8, 10, 12]), ... (6, 1, [1, 2, 3, 4, 5, 6]) ... ]) == [6, 6] >>> longest_subsequence(2, [ ... (5, 3, [3, 6, 9, 12, 15]), ... (5, 2, [2, 4, 8, 10, 12]) ... ]) == [5, 3]","solution":"def longest_subsequence(t, cases): results = [] for case in cases: n, k, seq = case dp = [1] * n for i in range(n): for j in range(i): if seq[i] - seq[j] == k: dp[i] = max(dp[i], dp[j] + 1) results.append(max(dp)) return results"},{"question":"def final_direction(sequence: str) -> str: Determine the final direction Maria is facing after following the series of turns. >>> final_direction(\\"LRLRL\\") \\"West\\" >>> final_direction(\\"RRRR\\") \\"North\\" >>> final_direction(\\"LLL\\") \\"East\\"","solution":"def final_direction(sequence): Determines the final direction after following the sequence of turns given. Parameters: sequence (str): A string of 'L' and 'R' characters representing left and right turns. Returns: str: The final direction Maria is facing. directions = ['North', 'East', 'South', 'West'] current_direction_index = 0 # starts facing North for turn in sequence: if turn == 'L': current_direction_index = (current_direction_index - 1) % 4 elif turn == 'R': current_direction_index = (current_direction_index + 1) % 4 return directions[current_direction_index]"},{"question":"from typing import List class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def deserialize(data: str) -> TreeNode: Deserialize a serialized representation of a binary tree. Each value in the tree is a single digit (0-9), and the serialization follows preorder traversal where 'null' indicates a missing node. def level_order_traversal(root: TreeNode) -> List[int]: Return the level order traversal of a binary tree. def process_test_cases(serializations: List[str]) -> List[List[int]]: Process multiple test cases to reconstruct binary trees and return their level order traversals. # Unit Test def test_deserialize_and_level_order_traversal(): serialization = \\"1,2,null,null,3,4,null,null,5,null,null\\" root = deserialize(serialization) assert level_order_traversal(root) == [1, 2, 3, 4, 5] serialization = \\"1,null,2,null,3,null,4,null,5,null,null\\" root = deserialize(serialization) assert level_order_traversal(root) == [1, 2, 3, 4, 5] def test_process_test_cases(): serializations = [ \\"1,2,null,null,3,4,null,null,5,null,null\\", \\"1,null,2,null,3,null,4,null,5,null,null\\" ] assert process_test_cases(serializations) == [ [1, 2, 3, 4, 5], [1, 2, 3, 4, 5] ] serializations = [\\"1,2,3,null,null,4,5,null,null,null,null\\", \\"1,2,3,4,5,null,null,null,null,null,null\\"] assert process_test_cases(serializations) == [ [1, 2, 3, 4, 5], [1, 2, 3, 4, 5] ] def test_edge_cases(): serializations = [ \\"null\\", \\"\\" ] assert process_test_cases(serializations) == [ [], [] ]","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def deserialize(data): if not data: return None nodes = data.split(',') if nodes[0] == 'null': return None root = TreeNode(int(nodes[0])) queue = deque([root]) i = 1 while queue: node = queue.popleft() if i < len(nodes) and nodes[i] != 'null': node.left = TreeNode(int(nodes[i])) queue.append(node.left) i += 1 if i < len(nodes) and nodes[i] != 'null': node.right = TreeNode(int(nodes[i])) queue.append(node.right) i += 1 return root def level_order_traversal(root): if not root: return [] result = [] queue = deque([root]) while queue: node = queue.popleft() result.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result def process_test_cases(serializations): results = [] for serialization in serializations: tree_root = deserialize(serialization) traversal_result = level_order_traversal(tree_root) results.append(traversal_result) return results # Example Input Usage # t = 2 # serializations = [ # \\"1,2,null,null,3,4,null,null,5,null,null\\", # \\"1,null,2,null,3,null,4,null,5,null,null\\" # ] # print(process_test_cases(serializations))"},{"question":"from typing import List def find_path(grid: List[List[int]]) -> str: Determines whether there exists a path in a 2D grid from the top left to the bottom right corner, only moving right ('R') or down ('D'). The grid contains 1s (accessible cell) and 0s (blocked cell). The function should return the path as a string of 'R' and 'D' characters if such a path exists, or 'NO PATH' otherwise. >>> grid = [ ... [1, 0, 0], ... [1, 1, 0], ... [0, 1, 1] ... ] >>> find_path(grid) 'DRDR' >>> grid = [ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ] >>> find_path(grid) 'NO PATH' pass def test_find_path_with_valid_path(): grid = [ [1, 0, 0], [1, 1, 0], [0, 1, 1] ] assert find_path(grid) == \\"DRDR\\" def test_find_path_with_no_path(): grid = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] assert find_path(grid) == 'NO PATH' def test_find_path_small_grid(): grid = [[1]] assert find_path(grid) == '' def test_find_path_full_grid(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] # This test accepts any valid path. result = find_path(grid) assert result in {'DDRR', 'DRDR', 'DRRD', 'RRDD', 'RDRD', 'RDD'} def test_find_path_single_path(): grid = [ [1, 1], [0, 1] ] assert find_path(grid) == 'RD' def test_find_path_blocked_start(): grid = [ [0, 1, 1], [1, 1, 1], [1, 1, 1] ] assert find_path(grid) == 'NO PATH'","solution":"from typing import List def find_path(grid: List[List[int]]) -> str: rows = len(grid) cols = len(grid[0]) def backtrack(r, c, path): if r >= rows or c >= cols or grid[r][c] == 0: return False if r == rows - 1 and c == cols - 1: return True # Mark this cell as visited grid[r][c] = 0 # Move right if backtrack(r, c + 1, path): path.append('R') return True # Move down if backtrack(r + 1, c, path): path.append('D') return True # Unmark this cell grid[r][c] = 1 return False path = [] if backtrack(0, 0, path): return ''.join(reversed(path)) else: return 'NO PATH'"},{"question":"def increment_elements(arr): Returns a new array with each element in the given array incremented by 1. >>> increment_elements([1, 2, 3]) [2, 3, 4] >>> increment_elements([]) [] >>> increment_elements([-1, 0, 1]) [0, 1, 2] >>> increment_elements([1]) [2] >>> increment_elements([-1, -2, -3, -4]) [0, -1, -2, -3]","solution":"def increment_elements(arr): Returns a new array with each element in the given array incremented by 1. return [x + 1 for x in arr]"},{"question":"def sum_of_leaf_nodes(n, values, edges): Find the sum of the values of the leaf nodes in a binary tree. n: int : number of nodes in the tree values: list of int : list of values of nodes edges: list of tuple of int : list of edges between nodes Returns the sum of the values of the leaf nodes. Example: >>> sum_of_leaf_nodes(5, [10, 20, 30, 40, 50], [(1, 2), (1, 3), (3, 4), (3, 5)]) 110 >>> sum_of_leaf_nodes(1, [10], []) 10 pass","solution":"def sum_of_leaf_nodes(n, values, edges): from collections import defaultdict, deque # Creating an adjacency list for the tree adj = defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) if n == 1: return values[0] # Identify leaf nodes leaves = [] for node in range(1, n+1): if len(adj[node]) == 1 and node != 1: # it's a leaf if it has only one connection and it's not the root (node 1) leaves.append(node) # Sum the values of the leaf nodes leaf_sum = sum(values[leaf-1] for leaf in leaves) return leaf_sum # Example usage: n = 5 values = [10, 20, 30, 40, 50] edges = [(1, 2), (1, 3), (3, 4), (3, 5)] print(sum_of_leaf_nodes(n, values, edges)) # Output: 110"},{"question":"def laptops_to_rent(participants: int, warehouse: dict) -> int: Determines the minimum number of laptops the company needs to rent to ensure that each participant has one. Args: participants (int): The total number of participants registered for the competition. warehouse (dict): A dictionary where keys are laptop brands and values are the number of each brand available in the warehouse. Returns: int: The minimum number of laptops needed to rent. If no laptops need to be rented, returns 0. >>> laptops_to_rent(15, {'brandA': 5, 'brandB': 6, 'brandC': 2}) 2 >>> laptops_to_rent(10, {'brandA': 3, 'brandB': 4, 'brandC': 3}) 0 >>> laptops_to_rent(5, {'brandA': 1, 'brandB': 2}) 2 >>> laptops_to_rent(0, {'brandA': 1, 'brandB': 2}) 0 >>> laptops_to_rent(4, {}) 4 >>> laptops_to_rent(-1, {'brandA': 1, 'brandB': 2}) 0 >>> laptops_to_rent(0, {}) 0","solution":"def laptops_to_rent(participants, warehouse): Determines the minimum number of laptops the company needs to rent to ensure that each participant has one. Args: participants (int): The total number of participants registered for the competition. warehouse (dict): A dictionary where keys are laptop brands and values are the number of each brand available in the warehouse. Returns: int: The minimum number of laptops needed to rent. If no laptops need to be rented, returns 0. total_laptops_available = sum(warehouse.values()) if participants <= total_laptops_available: return 0 else: return participants - total_laptops_available"},{"question":"def rearrange_array(arr): Rearranges the array such that every second element is greater than its previous and next elements. Args: arr: List of integers Returns: List of integers rearranged accordingly >>> rearrange_array([1, 3, 2, 4, 5]) [1, 3, 2, 5, 4] or [1, 3, 2, 4, 5] >>> rearrange_array([1, 2, 3, 4]) [1, 3, 2, 4] >>> rearrange_array([2, 1, 3]) [1, 3, 2] pass def process_test_cases(test_cases): Processes multiple test cases for rearranging arrays. Args: test_cases: List of lists, where each inner list is a test case array Returns: List of lists, where each inner list is the result of rearrange_array function applied to the corresponding test case pass def main(input_list): The main function that processes input and returns the results for multiple test cases. Args: input_list: List of strings, where first element is the number of test cases, followed by test case details Returns: List of lists, where each inner list is the rearranged array for a test case pass","solution":"def rearrange_array(arr): Rearranges the array such that every second element is greater than its previous and next elements. Args: arr: List of integers Returns: List of integers rearranged accordingly # Sort the array first arr.sort() n = len(arr) for i in range(1, n-1, 2): # Swap every odd placed element with the next one if it's greater arr[i], arr[i+1] = arr[i+1], arr[i] return arr def process_test_cases(test_cases): results = [] for arr in test_cases: result = rearrange_array(arr) results.append(result) return results # Reading input and processing def main(input_list): T = int(input_list[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_list[index]) arr = list(map(int, input_list[index + 1].split())) test_cases.append(arr) index += 2 results = process_test_cases(test_cases) return results"},{"question":"def count_ways(S: int) -> int: Returns the number of possible ways to achieve the sum S using any combination of 1, 5, 10, and 25 denominated coins. >>> count_ways(12) == 4 >>> count_ways(30) == 18 >>> count_ways(1) == 1 >>> count_ways(0) == 1 # only one way to make zero, by using no coins >>> count_ways(100) == 242 >>> count_ways(25) == 13 >>> count_ways(99) == 213","solution":"def count_ways(S): Returns the number of possible ways to achieve the sum S using any combination of 1, 5, 10, and 25 denominated coins. coins = [1, 5, 10, 25] dp = [0] * (S + 1) dp[0] = 1 # There is only one way to get a sum of 0: using 0 coins for coin in coins: for x in range(coin, S + 1): dp[x] += dp[x - coin] return dp[S]"},{"question":"def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into a single sorted list. Parameters: list1 (List[int]): First sorted list. list2 (List[int]): Second sorted list. Returns: List[int]: Merged sorted list. >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_lists([], [4, 5, 6]) [4, 5, 6] >>> merge_sorted_lists([], []) [] >>> merge_sorted_lists([1, 4, 5], [2, 3, 6]) [1, 2, 3, 4, 5, 6]","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list. Parameters: list1 (List[int]): First sorted list. list2 (List[int]): Second sorted list. Returns: List[int]: Merged sorted list. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append remaining elements from list1 or list2 merged_list.extend(list1[i:]) merged_list.extend(list2[j:]) return merged_list"},{"question":"def generate_participant_ids(n, last_names): Generates unique participant IDs based on their last names and order of appearance. Parameters: n (int): The number of participants. last_names (list of str): A list of last names. Returns: list of str: A list of unique participant IDs. >>> generate_participant_ids(4, [\\"Lee\\", \\"Wang\\", \\"Kim\\", \\"Lee\\"]) ['Lee1', 'Wang1', 'Kim1', 'Lee2'] >>> generate_participant_ids(6, [\\"Brown\\", \\"Taylor\\", \\"Smith\\", \\"Brown\\", \\"Taylor\\", \\"Brown\\"]) ['Brown1', 'Taylor1', 'Smith1', 'Brown2', 'Taylor2', 'Brown3']","solution":"def generate_participant_ids(n, last_names): Generates unique participant IDs based on their last names and order of appearance. Parameters: n (int): The number of participants. last_names (list of str): A list of last names. Returns: list of str: A list of unique participant IDs. name_count = {} participant_ids = [] for last_name in last_names: if last_name in name_count: name_count[last_name] += 1 else: name_count[last_name] = 1 participant_ids.append(f\\"{last_name}{name_count[last_name]}\\") return participant_ids"},{"question":"def find_max_value_after_operations(n: int, q: int, operations: List[Tuple[int, int, int, int]]) -> int: This function receives the length of the sequence, the number of operations, and a list of operations to perform on the sequence. It returns the maximum value in the sequence after performing all operations. >>> find_max_value_after_operations(5, 3, [(1, 1, 3, 5), (2, 2, 4, 7), (1, 3, 5, 2)]) 9 >>> find_max_value_after_operations(4, 2, [(1, 1, 4, 5), (2, 3, 3, 10)]) 10 >>> find_max_value_after_operations(5, 0, []) 0 >>> find_max_value_after_operations(3, 3, [(1, 1, 1, 3), (1, 2, 2, 4), (1, 3, 3, 5)]) 5 >>> find_max_value_after_operations(3, 3, [(2, 1, 1, 1), (2, 2, 2, 2), (2, 3, 3, 3)]) 3 >>> find_max_value_after_operations(4, 4, [(1, 2, 4, 1), (2, 3, 3, 5), (1, 1, 2, 3), (2, 4, 4, 7)]) 7","solution":"def find_max_value_after_operations(n, q, operations): This function receives the length of the sequence, the number of operations, and a list of operations to perform on the sequence. It returns the maximum value in the sequence after performing all operations. sequence = [0] * n for op in operations: if op[0] == 1: _, l, r, x = op for i in range(l-1, r): sequence[i] += x elif op[0] == 2: _, l, r, y = op for i in range(l-1, r): sequence[i] = y return max(sequence)"},{"question":"class Dossiers: def __init__(self, n, dossiers): Initialize the Dossiers instance with the number of dossiers and the dossier list. pass def increment(self, l, r, x): Increment the priority levels of dossiers from index l to r by x. pass def decrement(self, l, r, x): Decrement the priority levels of dossiers from index l to r by x. pass def max_priority(self, l, r): Return the maximum priority level among the dossiers in the index range [l, r]. pass # Test cases dossiers = Dossiers(10, [5, 3, 8, 1, 6, 4, 9, 2, 7, 5]) # Test increment operation dossiers.increment(3, 7, 2) print(dossiers.dossiers) # Expected output: [5, 3, 10, 3, 8, 6, 11, 2, 7, 5] # Test decrement operation dossiers.decrement(2, 5, 1) print(dossiers.dossiers) # Expected output: [5, 2, 9, 2, 7, 6, 11, 2, 7, 5] # Test max priority operation print(dossiers.max_priority(1, 7)) # Expected output: 11 # Another increment operation dossiers.increment(6, 10, 5) print(dossiers.dossiers) # Expected output: [5, 2, 9, 2, 7, 11, 16, 7, 12, 10] # Another max priority operation print(dossiers.max_priority(6, 10)) # Expected output: 16","solution":"class Dossiers: def __init__(self, n, dossiers): self.dossiers = dossiers def increment(self, l, r, x): for i in range(l-1, r): self.dossiers[i] += x def decrement(self, l, r, x): for i in range(l-1, r): self.dossiers[i] -= x def max_priority(self, l, r): return max(self.dossiers[l-1:r])"},{"question":"from collections import deque from typing import List, Tuple def shortest_path(n: int, m: int, obstacles: List[Tuple[int, int]], start: Tuple[int, int], target: Tuple[int, int]) -> int: Find the shortest path from the start position to the target position in an n x n grid with obstacles. Args: n (int): The size of the grid. m (int): The number of obstacles. obstacles (List[Tuple[int, int]]): A list of obstacle positions. start (Tuple[int, int]): The starting position of the robot. target (Tuple[int, int]): The target position of the robot. Returns: int: The minimum number of moves required to reach the target, or -1 if no valid path exists. >>> shortest_path(5, 3, [(0, 2), (2, 2), (4, 2)], (0, 0), (4, 4)) 8 >>> shortest_path(6, 4, [(1, 2), (2, 2), (3, 2), (4, 2)], (0, 0), (5, 5)) 10 >>> shortest_path(4, 1, [(2, 1)], (0, 0), (3, 3)) 6 >>> shortest_path(4, 0, [], (0, 0), (3, 3)) 6 >>> shortest_path(4, 6, [(0, 1), (1, 1), (2, 1), (3, 1), (1, 2), (2, 2)], (0, 0), (3, 3)) -1 >>> shortest_path(2, 1, [(0, 1)], (0, 0), (1, 1)) 2 pass","solution":"from collections import deque def shortest_path(n, m, obstacles, start, target): # Create the grid and mark obstacles grid = [[0] * n for _ in range(n)] for ox, oy in obstacles: grid[ox][oy] = -1 # -1 represents an obstacle # Direction vectors for moving in 4 directions: down, up, right, left directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # BFS initialization queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set() visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() # If we reach the target, return the distance if (x, y) == (target[0], target[1]): return dist # Explore all 4 directions for dx, dy in directions: nx, ny, ndist = x + dx, y + dy, dist + 1 # Check if the new position is within bounds and not an obstacle if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] != -1: queue.append((nx, ny, ndist)) visited.add((nx, ny)) # If no path found, return -1 return -1"},{"question":"from typing import List, Tuple, Dict, Union def analyze_transactions(transactions: List[Tuple[str, str, float]]) -> Dict[str, Union[float, List[Dict[str, Union[str, float]]], Dict[str, Union[str, float]], None]]: Analyze a list of transactions and provide financial insights. - total_income: The total amount of all positive transactions. - total_expense: The total amount of all negative transactions. - net_balance: The net balance calculated as total income minus total expense. - income_transactions: A sorted list (in ascending date order) of all income transactions. Each transaction should be represented as a dictionary with keys 'date', 'description', and 'amount'. - expense_transactions: A sorted list (in ascending date order) of all expense transactions. Each transaction should be represented as a dictionary with keys 'date', 'description', and 'amount'. - highest_income_transaction: The transaction with the highest income, represented as a dictionary with keys 'date', 'description', and 'amount'. If there are multiple transactions with the same highest amount, return the one that appears first in the list. - largest_expense_transaction: The transaction with the largest expense, represented as a dictionary with keys 'date', 'description', and 'amount'. If there are multiple transactions with the same largest amount, return the one that appears first in the list. >>> transactions = [ ... ('2023-01-01', 'Salary', 3000.0), ... ('2023-01-03', 'Rent', -1200.0), ... ('2023-01-05', 'Groceries', -100.5), ... ('2023-02-01', 'Freelance Job', 1500.0), ... ('2023-02-02', 'Gym Membership', -50.0) ... ] >>> analyze_transactions(transactions) { 'total_income': 4500.0, 'total_expense': -1350.5, 'net_balance': 3149.5, 'income_transactions': [ {'date': '2023-01-01', 'description': 'Salary', 'amount': 3000.0}, {'date': '2023-02-01', 'description': 'Freelance Job', 'amount': 1500.0} ], 'expense_transactions': [ {'date': '2023-01-03', 'description': 'Rent', 'amount': -1200.0}, {'date': '2023-01-05', 'description': 'Groceries', 'amount': -100.5}, {'date': '2023-02-02', 'description': 'Gym Membership', 'amount': -50.0} ], 'highest_income_transaction': {'date': '2023-01-01', 'description': 'Salary', 'amount': 3000.0}, 'largest_expense_transaction': {'date': '2023-01-03', 'description': 'Rent', 'amount': -1200.0} }","solution":"def analyze_transactions(transactions): # Initialize the variables for aggregated values total_income = 0.0 total_expense = 0.0 income_transactions = [] expense_transactions = [] highest_income_transaction = None largest_expense_transaction = None # Iterate over each transaction for transaction in transactions: date, description, amount = transaction # Categorize the transaction as income or expense if amount > 0: total_income += amount income_transactions.append({ 'date': date, 'description': description, 'amount': amount }) # Check for highest income transaction if highest_income_transaction is None or amount > highest_income_transaction['amount']: highest_income_transaction = { 'date': date, 'description': description, 'amount': amount } elif amount < 0: total_expense += amount expense_transactions.append({ 'date': date, 'description': description, 'amount': amount }) # Check for largest expense transaction if largest_expense_transaction is None or amount < largest_expense_transaction['amount']: largest_expense_transaction = { 'date': date, 'description': description, 'amount': amount } # Calculate net balance net_balance = total_income + total_expense # Sort the transactions by date income_transactions.sort(key=lambda x: x['date']) expense_transactions.sort(key=lambda x: x['date']) # Create the result dictionary with all the required insights result = { 'total_income': total_income, 'total_expense': total_expense, 'net_balance': net_balance, 'income_transactions': income_transactions, 'expense_transactions': expense_transactions, 'highest_income_transaction': highest_income_transaction, 'largest_expense_transaction': largest_expense_transaction } return result"},{"question":"def can_schedule(n, events, new_event): Determines if the new event can be scheduled without overlapping any existing events. Parameters: n (int): The number of already scheduled events. events (list of tuples): The list of already scheduled events, where each event is a tuple (start, end). new_event (tuple): The new event to be scheduled, represented as a tuple (start, end). Returns: str: \\"Yes\\" if the new event can be scheduled without overlapping any existing events, otherwise \\"No\\". # Implementation goes here def test_single_event_non_overlapping(): assert can_schedule(1, [(1, 5)], (6, 10)) == \\"Yes\\" def test_single_event_overlapping(): assert can_schedule(1, [(1, 5)], (3, 7)) == \\"No\\" def test_multiple_events_non_overlapping(): assert can_schedule(3, [(1, 3), (4, 7), (8, 10)], (7, 8)) == \\"Yes\\" def test_multiple_events_overlapping(): assert can_schedule(3, [(1, 3), (4, 7), (8, 10)], (5, 9)) == \\"No\\" def test_event_at_the_bound_edge(): assert can_schedule(2, [(1, 5), (6, 10)], (5, 6)) == \\"Yes\\" def test_event_completely_inside_another(): assert can_schedule(2, [(1, 5), (6, 10)], (2, 4)) == \\"No\\" def test_no_events(): assert can_schedule(0, [], (1, 10)) == \\"Yes\\" def test_events_with_exact_match_end_start(): assert can_schedule(2, [(1, 5), (6, 10)], (5, 6)) == \\"Yes\\" def test_event_overlapping_slightly_before(): assert can_schedule(2, [(1, 5), (6, 10)], (0, 1)) == \\"Yes\\" def test_event_overlapping_slightly_after(): assert can_schedule(2, [(1, 5), (6, 10)], (10, 11)) == \\"Yes\\"","solution":"def can_schedule(n, events, new_event): Determines if the new event can be scheduled without overlapping any existing events. Parameters: n (int): The number of already scheduled events. events (list of tuples): The list of already scheduled events, where each event is a tuple (start, end). new_event (tuple): The new event to be scheduled, represented as a tuple (start, end). Returns: str: \\"Yes\\" if the new event can be scheduled without overlapping any existing events, otherwise \\"No\\". new_start, new_end = new_event for event in events: start, end = event if not (new_end <= start or new_start >= end): return \\"No\\" return \\"Yes\\""},{"question":"class VendingMachine: def __init__(self, items): Initialize the vending machine with a list of items. ... def purchase(self, code, amount_paid): Purchase an item given its code and the amount paid by the user. >>> vm = VendingMachine([ ... {\\"code\\": \\"A1\\", \\"name\\": \\"Soda\\", \\"price\\": 1.50, \\"quantity\\": 10}, ... {\\"code\\": \\"B2\\", \\"name\\": \\"Chips\\", \\"price\\": 1.00, \\"quantity\\": 5}, ... {\\"code\\": \\"C3\\", \\"name\\": \\"Candy\\", \\"price\\": 0.65, \\"quantity\\": 15} ... ]) >>> vm.purchase(\\"B2\\", 1.00) 'Item: Chips, Change: 0.00' >>> vm.purchase(\\"A1\\", 1.00) 'Insufficient funds' >>> vm.purchase(\\"D4\\", 1.00) 'Item not found' >>> vm.purchase(\\"B2\\", 1.00) 'Item out of stock' ... def restock(self, code, quantity): Restock an item given its code and the quantity to add. >>> vm = VendingMachine([ ... {\\"code\\": \\"A1\\", \\"name\\": \\"Soda\\", \\"price\\": 1.50, \\"quantity\\": 10}, ... {\\"code\\": \\"B2\\", \\"name\\": \\"Chips\\", \\"price\\": 1.00, \\"quantity\\": 5}, ... {\\"code\\": \\"C3\\", \\"name\\": \\"Candy\\", \\"price\\": 0.65, \\"quantity\\": 15} ... ]) >>> vm.restock(\\"B2\\", 10) 'Item restocked' >>> vm.restock(\\"D4\\", 5) 'Item not found' ... def inventory(self): Check the inventory of the vending machine. >>> vm = VendingMachine([ ... {\\"code\\": \\"A1\\", \\"name\\": \\"Soda\\", \\"price\\": 1.50, \\"quantity\\": 10}, ... {\\"code\\": \\"B2\\", \\"name\\": \\"Chips\\", \\"price\\": 1.00, \\"quantity\\": 5}, ... {\\"code\\": \\"C3\\", \\"name\\": \\"Candy\\", \\"price\\": 0.65, \\"quantity\\": 15} ... ]) >>> vm.inventory() [ {\\"code\\": \\"A1\\", \\"name\\": \\"Soda\\", \\"price\\": 1.50, \\"quantity\\": 10}, {\\"code\\": \\"B2\\", \\"name\\": \\"Chips\\", \\"price\\": 1.00, \\"quantity\\": 5}, {\\"code\\": \\"C3\\", \\"name\\": \\"Candy\\", \\"price\\": 0.65, \\"quantity\\": 15} ] ...","solution":"class VendingMachine: def __init__(self, items): self.items = {item['code']: item for item in items} def purchase(self, code, amount_paid): if code not in self.items: return 'Item not found' item = self.items[code] if item['quantity'] <= 0: return 'Item out of stock' if amount_paid < item['price']: return 'Insufficient funds' item['quantity'] -= 1 change = amount_paid - item['price'] return f'Item: {item[\\"name\\"]}, Change: {change:.2f}' def restock(self, code, quantity): if code not in self.items: return 'Item not found' self.items[code]['quantity'] += quantity return 'Item restocked' def inventory(self): return list(self.items.values())"},{"question":"import math def maxWaterVolume(r: float, h: float) -> float: Calculate the maximum volume of water a cylindrical tank can hold given the radius of the base and the height of the tank. Parameters: r (float): the radius of the tank's base h (float): the height of the tank Returns: float: the maximum volume of water the tank can hold >>> maxWaterVolume(3.0, 5.0) 141.3716694115407 >>> maxWaterVolume(0.1, 0.2) 0.006283185307179587","solution":"import math def maxWaterVolume(r, h): Returns the maximum volume of water the cylindrical tank can hold. Parameters: r (float): the radius of the tank's base h (float): the height of the tank Returns: float: the maximum volume of water the tank can hold volume = math.pi * r**2 * h return volume"},{"question":"def max_games(n: int) -> int: Returns the maximum number of games that can be simultaneously held in one round. Parameters: n (int): The total number of athletes participating Returns: int: The maximum number of games Examples: >>> max_games(10) 5 >>> max_games(7) 3 >>> max_games(1) 0","solution":"def max_games(n): Returns the maximum number of games that can be simultaneously held in one round. Parameters: n (int): The total number of athletes participating Returns: int: The maximum number of games return n // 2"},{"question":"def highestProduct(arr: List[int]) -> int: Returns the highest product that can be made by multiplying any three integers from the list. >>> highestProduct([1, 10, 2, 6, 5, 3]) 300 >>> highestProduct([-10, -10, 1, 3, 2]) 300","solution":"def highestProduct(arr): Returns the highest product that can be made by multiplying any three integers from the list. if len(arr) < 3: raise ValueError(\\"List must contain at least three integers\\") arr.sort() return max(arr[0] * arr[1] * arr[-1], arr[-1] * arr[-2] * arr[-3])"},{"question":"def solve(test_cases): Determine the number of independent screening zones in the theatre. Args: test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): A list of test cases, where each test case is a tuple containing the number of screening rooms (S), the number of hallways (M), and a list of M tuples representing the hallways. Returns: List[int]: A list of integers, each representing the number of independent screening zones for the corresponding test case. Example: >>> solve([(6, 4, [(0,1), (1,2), (3,4), (4,5)]), (5, 0, [])]) [2, 5] results = [] for S, M, edges in test_cases: parent = list(range(S)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): root_x = find(x) root_y = find(y) if root_x != root_y: parent[root_x] = root_y for u, v in edges: union(u, v) num_zones = len(set(find(x) for x in range(S))) results.append(num_zones) return results","solution":"def find_connected_components(S, M, edges): parent = list(range(S)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): root_x = find(x) root_y = find(y) if root_x != root_y: parent[root_x] = root_y for u, v in edges: union(u, v) return len(set(find(x) for x in range(S))) def solve(test_cases): results = [] for S, M, edges in test_cases: result = find_connected_components(S, M, edges) results.append(result) return results"},{"question":"def can_sort_by_reversing_subarray(arr): Determines if the array can be sorted by reversing a single subarray. >>> can_sort_by_reversing_subarray([1, 3, 2, 4]) 'YES 2 3' >>> can_sort_by_reversing_subarray([5, 4, 3, 2, 1]) 'YES 1 5' >>> can_sort_by_reversing_subarray([1, 2, 3, 6, 5, 4]) 'YES 4 6' >>> can_sort_by_reversing_subarray([1, 5, 3, 2, 4]) 'NO' >>> can_sort_by_reversing_subarray([1, 2, 3, 4, 5]) 'YES 1 1' def process_test_cases(test_cases): Processes multiple test cases to determine if each array can be sorted by reversing a single subarray. >>> process_test_cases([(4, [1, 3, 2, 4]), (5, [5, 4, 3, 2, 1]), (6, [1, 2, 3, 6, 5, 4])]) ['YES 2 3', 'YES 1 5', 'YES 4 6']","solution":"def can_sort_by_reversing_subarray(arr): n = len(arr) sorted_arr = sorted(arr) # Find the first and last position where arr and sorted_arr differ start = end = -1 for i in range(n): if arr[i] != sorted_arr[i]: if start == -1: start = i end = i # If start and end are not updated, the array is already sorted if start == -1: return \\"YES 1 1\\" # Reverse the subarray from start to end and check if it sorts the array subsequence_reversed = arr[:start] + arr[start:end+1][::-1] + arr[end+1:] if subsequence_reversed == sorted_arr: return f\\"YES {start + 1} {end + 1}\\" else: return \\"NO\\" def process_test_cases(test_cases): results = [] for n, arr in test_cases: results.append(can_sort_by_reversing_subarray(arr)) return results"},{"question":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in a given list of numbers. Args: nums: List[int] - a list of integers Returns: int - the length of the longest increasing subsequence Examples: >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([1]) 1 >>> length_of_lis([1, 2, 3, 4, 5, 6]) 6 >>> length_of_lis([6, 5, 4, 3, 2, 1]) 1 >>> length_of_lis([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]) 6 >>> length_of_lis([1, 3, 6, 7, 9, 4, 10, 5, 6]) 6 >>> length_of_lis([-1, 3, 4, 5, 2, 2, 2, 2, 6, 7]) 6 >>> length_of_lis([]) 0","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in a given list of numbers. Args: nums: List[int] - a list of integers Returns: int - the length of the longest increasing subsequence if not nums: return 0 n = len(nums) dp = [1] * n # dp[i] will hold the length of the LIS ending at index i for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # Example usage: # n = 8 # nums = [10, 9, 2, 5, 3, 7, 101, 18] # print(length_of_lis(nums)) # Output: 4"},{"question":"def trap(height): Given a list of integers representing the amount of water trapped between heights in a histogram, return the quantity of trapped water. :param height: List of integers representing histogram bar heights. :return: Integer amount of trapped water. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> trap([4,2,0,3,2,5]) == 9 >>> trap([1,2,3,4,5]) == 0 >>> trap([5,4,3,2,1]) == 0 >>> trap([5,0,5]) == 5 >>> trap([3,0,2]) == 2 >>> trap([5,5,5,5]) == 0 >>> trap([1,2,1,2,1]) == 1 >>> trap([1]) == 0 >>> trap([0]) == 0 >>> trap([100000]) == 0","solution":"def trap(height): Calculate the total amount of water trapped between the histogram bars. :param height: List of integers representing histogram bar heights. :return: Integer amount of trapped water. if not height or len(height) < 3: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) water_trapped += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) water_trapped += max(0, right_max - height[right]) return water_trapped"},{"question":"from typing import List def maxSubsequenceSum(arr: List[int], K: int) -> int: Returns the maximum sum of any non-empty subsequence that contains no more than K elements. >>> maxSubsequenceSum([1, 2, 3, 4], 2) 7 >>> maxSubsequenceSum([-1, 2, -3, 4, 5], 3) 11 >>> maxSubsequenceSum([-5, -4, -3, -2, -1], 2) -3 >>> maxSubsequenceSum([1, 2, 3, 4], 5) 10 >>> maxSubsequenceSum([1, 2, 3, 4], 1) 4 >>> maxSubsequenceSum([1, 2, 3, 4], 0) 0","solution":"def maxSubsequenceSum(arr, K): Returns the maximum sum of any non-empty subsequence that contains no more than K elements. # Sort the array in descending order. arr.sort(reverse=True) # Sum the top K elements. max_sum = sum(arr[:K]) return max_sum"},{"question":"def max_consecutive_occurrences(t: int, test_cases: List[str]) -> List[int]: Returns a list of the maximum number of consecutive occurrences of any digit in each input string. Parameters: t (int): Number of test cases test_cases (list of str): List of strings of digits Returns: list of int: List of maximum consecutive occurrences for each test case >>> max_consecutive_occurrences(1, [\\"1234567890\\"]) [1] >>> max_consecutive_occurrences(1, [\\"111111\\"]) [6] >>> max_consecutive_occurrences(3, [\\"112233\\", \\"111222333\\", \\"11110000\\"]) [2, 3, 4] >>> max_consecutive_occurrences(2, [\\"1223334444\\", \\"987654321\\"]) [4, 1] >>> max_consecutive_occurrences(2, [\\"123\\", \\"122223\\"]) [1, 4]","solution":"def max_consecutive_occurrences(t, test_cases): Returns a list of the maximum number of consecutive occurrences of any digit in each input string. Parameters: t (int): Number of test cases test_cases (list of str): List of strings of digits Returns: list of int: List of maximum consecutive occurrences for each test case results = [] for s in test_cases: max_count = 0 current_count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: current_count += 1 else: if current_count > max_count: max_count = current_count current_count = 1 if current_count > max_count: max_count = current_count results.append(max_count) return results"},{"question":"def secondLargest(arr: List[int]) -> int: Returns the second largest integer in the list. >>> secondLargest([12, 35, 1, 10, 34, 1]) == 34 >>> secondLargest([10, 5, 10]) == 5 >>> secondLargest([-1, -2, -3, -4]) == -2 >>> secondLargest([5, 5, 5]) Raises ValueError >>> secondLargest([4, 1]) == 1 >>> secondLargest([8]) Raises ValueError >>> secondLargest([10, 20, 30, 10, 20, 15]) == 20 >>> secondLargest(list(range(1000))) == 998","solution":"def secondLargest(arr): Returns the second largest integer in the list. if len(arr) < 2: raise ValueError(\\"List should have at least 2 elements\\") first = second = float('-inf') for num in arr: if num > first: second = first first = num elif first > num > second: second = num if second == float('-inf'): raise ValueError(\\"No second largest element in the list\\") return second"},{"question":"def max_stack_height(blocks): This function takes a list of block heights and returns the maximum height of the stack that can be obtained by stacking them following the rule that a block can be placed on another block only if it is shorter. Arguments: blocks -- list of integers representing the heights of the blocks. Returns: max_height -- integer representing the maximum height achievable. # Your code here if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) blocks = list(map(int, data[1:N+1])) print(max_stack_height(blocks))","solution":"def max_stack_height(blocks): This function takes a list of block heights and returns the maximum height of the stack that can be obtained by stacking them following the rule that a block can be placed on another block only if it is shorter. Arguments: blocks -- list of integers representing the heights of the blocks. Returns: max_height -- integer representing the maximum height achievable. # Sort the blocks in ascending order blocks.sort() return sum(blocks) if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) blocks = list(map(int, data[1:N+1])) print(max_stack_height(blocks))"},{"question":"from typing import List def process_operations(lst: List[int], operations: List[str]) -> List[int]: Perform a series of operations on a list of integers and return the resulting list. >>> process_operations([1, 2, 3, 4, 5, 6], [\\"remove_even\\"]) [1, 3, 5] >>> process_operations([10, 15, 3, 7], [\\"keep_prime\\", \\"sort_asc\\"]) [3, 7] >>> process_operations([8, 3, 7, 1, 5], [\\"reverse\\", \\"sort_desc\\"]) [8, 7, 5, 3, 1]","solution":"from typing import List def process_operations(lst: List[int], operations: List[str]) -> List[int]: # Helper function to identify prime numbers def is_prime(n): if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True for operation in operations: if operation == \\"remove_even\\": lst = [num for num in lst if num % 2 != 0] elif operation == \\"keep_prime\\": lst = [num for num in lst if is_prime(num)] elif operation == \\"reverse\\": lst = lst[::-1] elif operation == \\"sort_asc\\": lst = sorted(lst) elif operation == \\"sort_desc\\": lst = sorted(lst, reverse=True) return lst"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert(root, key): if root is None: return TreeNode(key) else: if root.val < key: root.right = insert(root.right, key) else: root.left = insert(root.left, key) return root def inorder_traversal(root, result): if root: inorder_traversal(root.left, result) result.append(root.val) inorder_traversal(root.right, result) return result def kth_smallest_element(root, k): result = inorder_traversal(root, []) return result[k - 1] def find_kth_smallest_element(test_cases): Construct a BST from a list of integers and find the k-th smallest element. Args: test_cases (List[Tuple[int, int, List[int]]]): A list of test cases, where each test case is a tuple of: - An integer N, the number of elements in the list. - An integer K, the position of the k-th smallest element. - A list of N integers. Returns: List[int]: A list of k-th smallest elements for each test case. >>> find_kth_smallest_element([(5, 3, [5, 3, 8, 2, 4]), (7, 4, [10, 5, 1, 7, 40, 50, 8])]) [4, 8]","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert(root, key): if root is None: return TreeNode(key) else: if root.val < key: root.right = insert(root.right, key) else: root.left = insert(root.left, key) return root def inorder_traversal(root, result): if root: inorder_traversal(root.left, result) result.append(root.val) inorder_traversal(root.right, result) return result def kth_smallest_element(root, k): result = inorder_traversal(root, []) return result[k - 1] def find_kth_smallest_element(test_cases): results = [] for case in test_cases: N, K, nums = case root = None for num in nums: root = insert(root, num) results.append(kth_smallest_element(root, K)) return results def process_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N, K = map(int, lines[index].split()) nums = list(map(int, lines[index + 1].split())) test_cases.append((N, K, nums)) index += 2 results = find_kth_smallest_element(test_cases) return results"},{"question":"def max_profit(prices): Returns the maximum profit from a single buy and sell transaction. If no profit is possible, return \\"No profit\\". >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([9, 8, 7, 6, 5, 4]) \\"No profit\\" >>> max_profit([1, 2, 3, 4, 5, 6]) 5 >>> max_profit([10, 20, 10, 1, 30, 5]) 29 >>> max_profit([1, 2, 100, 99, 250, 25]) 249 >>> max_profit([4, 3, 2, 1, 1]) \\"No profit\\" >>> max_profit([3, 3, 3, 3, 3]) \\"No profit\\" # Your implementation here def process_input(data): Process input data and call max_profit on each dataset. >>> process_input(\\"7 1 5 3 6 4 0n9 8 7 6 5 4 0n1 2 3 4 5 6 0n0\\") [5, \\"No profit\\", 5] # Your implementation here","solution":"def max_profit(prices): Returns the maximum profit from a single buy and sell transaction. If no profit is possible, return \\"No profit\\". if len(prices) < 5 or len(prices) > 10: raise ValueError(\\"The list must contain between 5 and 10 prices.\\") min_price = float('inf') max_profit = 0 for price in prices: if price < 0 or price > 999999: raise ValueError(\\"Each price must be between 0 and 999999.\\") min_price = min(min_price, price) max_profit = max(max_profit, price - min_price) return max_profit if max_profit > 0 else \\"No profit\\" def process_input(data): Process input data and call max_profit on each dataset. results = [] for line in data.strip().split('n'): if line == '0': break prices = list(map(int, line.split())) results.append(max_profit(prices[:-1])) # Exclude the ending zero return results"},{"question":"def max_collage_dimensions(n: int, photos: List[Tuple[int, int]]) -> Tuple[int, int]: Determine the maximum dimensions (rows and columns) of a collage that can be created from given images while grouping by years. Args: n: int - the number of photos. photos: List[Tuple[int, int]] - list of tuples where each tuple contains unique photo ID and the year the photo was taken. Returns: Tuple[int, int] - the maximum number of rows and columns that the collage can have. >>> max_collage_dimensions(6, [(1, 2005), (2, 2005), (3, 2006), (4, 2007), (5, 2006), (6, 2005)]) (3, 3) >>> max_collage_dimensions(4, [(1, 2001), (2, 2002), (3, 2001), (4, 2003)]) (2, 3) >>> max_collage_dimensions(3, [(1, 2010), (2, 2011), (3, 2012)]) (1, 3)","solution":"def max_collage_dimensions(n, photos): from collections import defaultdict year_count = defaultdict(int) photo_count_per_year = defaultdict(int) for photo in photos: id, year = photo year_count[year] += 1 photo_count_per_year[year] += 1 max_rows = max(year_count.values()) max_columns = len(year_count) return max_rows, max_columns # Example usage: n = 3 photos = [(1, 2010), (2, 2011), (3, 2012)] print(max_collage_dimensions(n, photos)) # Output: 1, 3"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Write a function that accepts a list of integers and returns a list of the integers where each element is the product of every other element in the original list. Args: nums: List of integers Returns: List of integers where each element is the product of all other elements in the given list Example: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 1, 2, 3]) [6, 0, 0, 0]","solution":"def product_except_self(nums): Returns a list where each element is the product of all other elements in the original list. Args: nums: List of integers Returns: List of integers n = len(nums) if n == 0: return [] left_products = [1] * n right_products = [1] * n for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] result = [left_products[i] * right_products[i] for i in range(n)] return result"},{"question":"def count_target_word(sentences: List[str], target_word: str) -> int: Counts the occurrence of the target word in a list of sentences. Parameters: sentences (List[str]): List of sentences to search within. target_word (str): The word to count occurrences of. Returns: int: The number of times the target word appears in the sentences. >>> count_target_word([\\"Hello world\\"], \\"world\\") 1 >>> count_target_word([\\"world world world\\"], \\"world\\") 3 >>> count_target_word([\\"Hello world\\", \\"This world is beautiful\\", \\"Hello again world\\"], \\"world\\") 3 >>> count_target_word([\\"World WORLD WoRlD\\"], \\"world\\") 3 >>> count_target_word([\\"Hello there\\", \\"How are you?\\"], \\"world\\") 0 >>> count_target_word([\\"This is a simple test\\", \\"To count TARGET word\\", \\"In multiple SENTENCES\\"], \\"target\\") 1","solution":"def count_target_word(sentences, target_word): Counts the occurrence of the target word in a list of sentences. Parameters: sentences (List[str]): List of sentences to search within. target_word (str): The word to count occurrences of. Returns: int: The number of times the target word appears in the sentences. count = 0 target_word_lower = target_word.lower() for sentence in sentences: words = sentence.lower().split() count += words.count(target_word_lower) return count"},{"question":"def process_operations(ops): Process a list of stack operations and return the results of all query operations and the final state of the stack. Args: ops: List[str]: A list of operations where each operation is a string. Returns: Tuple[List[Union[int, str]], List[int]]: A tuple containing two lists: - The first list holds the results of the 'Q' operations. - The second list represents the final state of the stack. Operations: - 'P x': Push the integer x onto the stack. - 'Q': Query the current top element of the stack (if the stack is empty, return \\"EMPTY\\"). - 'R': Remove the current top element from the stack (if the stack is empty, perform no operation). - 'D': Duplicate the current top element of the stack (if the stack is empty, perform no operation). - 'M x': Multiply the current top element of the stack by x (if the stack is empty, perform no operation). Example: >>> ops = ['P 3', 'Q', 'R', 'Q'] >>> process_operations(ops) ([3, \\"EMPTY\\"], []) >>> ops = ['P 5', 'D', 'M 3', 'Q', 'R'] >>> process_operations(ops) ([15], [5]) def process_test_cases(t, test_cases): Process multiple test cases of stack operations and return the combined query results and the final stack state after all test cases are processed. Args: t: int: The number of test cases. test_cases: List[List[str]]: A list of test cases where each test case is a list of operations. Returns: Tuple[List[Union[int, str]], List[int]]: A tuple containing two lists: - The first list holds the combined results of all 'Q' operations across all test cases. - The second list represents the final state of the stack after all test cases. Example: >>> t = 2 >>> test_cases = [['P 3', 'Q', 'R', 'Q'], ['P 5', 'D', 'M 3', 'Q', 'R']] >>> process_test_cases(t, test_cases) ([3, \\"EMPTY\\", 15], [5])","solution":"def process_operations(ops): stack = [] result = [] for op in ops: if op.startswith('P'): _, x = op.split() stack.append(int(x)) elif op.startswith('Q'): if stack: result.append(stack[-1]) else: result.append(\\"EMPTY\\") elif op.startswith('R'): if stack: stack.pop() elif op.startswith('D'): if stack: stack.append(stack[-1]) elif op.startswith('M'): if stack: _, x = op.split() stack[-1] *= int(x) return result, stack def process_test_cases(t, test_cases): combined_results = [] final_stack_state = [] for i in range(t): ops = test_cases[i] query_results, final_stack = process_operations(ops) combined_results.extend(query_results) final_stack_state = final_stack return combined_results, final_stack_state"},{"question":"def organize_hobbies(hobbies, people): Organize the people based on their hobbies, sorted by age and name. Args: hobbies: List of hobbies. people: List of people's information in \\"name age gender hobby\\" format. Returns: A dictionary where each key is a hobby and the value is a list of tuples containing the people with that hobby sorted by age and name. >>> hobbies = [\\"Running\\", \\"Swimming\\", \\"Chess\\"] >>> people = [ ... \\"Alice 24 F Running\\", ... \\"Bob 22 M Swimming\\", ... \\"Charlie 23 M Running\\", ... \\"Diana 24 F Chess\\", ... \\"Eva 24 F Running\\", ... \\"Frank 21 M Chess\\" ... ] >>> organize_hobbies(hobbies, people) { \\"Running\\": [(\\"Charlie\\", 23, \\"M\\"), (\\"Alice\\", 24, \\"F\\"), (\\"Eva\\", 24, \\"F\\")], \\"Swimming\\": [(\\"Bob\\", 22, \\"M\\")], \\"Chess\\": [(\\"Frank\\", 21, \\"M\\"), (\\"Diana\\", 24, \\"F\\")] } pass def display_hobby_organization(hobbies, hobby_dict): Prints the hobbies and the sorted list of people practicing each hobby. Args: hobbies: List of hobbies. hobby_dict: Dictionary returned from organize_hobbies function. >>> hobbies = [\\"Running\\", \\"Swimming\\", \\"Chess\\"] >>> hobby_dict = { ... \\"Running\\": [(\\"Charlie\\", 23, \\"M\\"), (\\"Alice\\", 24, \\"F\\"), (\\"Eva\\", 24, \\"F\\")], ... \\"Swimming\\": [(\\"Bob\\", 22, \\"M\\")], ... \\"Chess\\": [(\\"Frank\\", 21, \\"M\\"), (\\"Diana\\", 24, \\"F\\")] ... } >>> display_hobby_organization(hobbies, hobby_dict) Running Charlie 23 M Alice 24 F Eva 24 F Swimming Bob 22 M Chess Frank 21 M Diana 24 F pass import pytest def test_organize_hobbies(): hobbies = [\\"Running\\", \\"Swimming\\", \\"Chess\\"] people = [ \\"Alice 24 F Running\\", \\"Bob 22 M Swimming\\", \\"Charlie 23 M Running\\", \\"Diana 24 F Chess\\", \\"Eva 24 F Running\\", \\"Frank 21 M Chess\\" ] result = organize_hobbies(hobbies, people) assert result == { \\"Running\\": [(\\"Charlie\\", 23, \\"M\\"), (\\"Alice\\", 24, \\"F\\"), (\\"Eva\\", 24, \\"F\\")], \\"Swimming\\": [(\\"Bob\\", 22, \\"M\\")], \\"Chess\\": [(\\"Frank\\", 21, \\"M\\"), (\\"Diana\\", 24, \\"F\\")] } def test_display_hobby_organization(capsys): hobbies = [\\"Running\\", \\"Swimming\\", \\"Chess\\"] hobby_dict = { \\"Running\\": [(\\"Charlie\\", 23, \\"M\\"), (\\"Alice\\", 24, \\"F\\"), (\\"Eva\\", 24, \\"F\\")], \\"Swimming\\": [(\\"Bob\\", 22, \\"M\\")], \\"Chess\\": [(\\"Frank\\", 21, \\"M\\"), (\\"Diana\\", 24, \\"F\\")] } display_hobby_organization(hobbies, hobby_dict) captured = capsys.readouterr() assert captured.out == ( \\"Runningn\\" \\"Charlie 23 Mn\\" \\"Alice 24 Fn\\" \\"Eva 24 Fn\\" \\"Swimmingn\\" \\"Bob 22 Mn\\" \\"Chessn\\" \\"Frank 21 Mn\\" \\"Diana 24 Fn\\" )","solution":"def organize_hobbies(hobbies, people): Returns a dictionary where each key is a hobby and the value is a list of tuples containing the people with that hobby sorted by age and name. hobby_dict = {hobby: [] for hobby in hobbies} for person in people: name, age, gender, hobby = person.split() age = int(age) hobby_dict[hobby].append((name, age, gender)) for hobby in hobby_dict: hobby_dict[hobby].sort(key=lambda x: (x[1], x[0])) return hobby_dict def display_hobby_organization(hobbies, hobby_dict): Prints the hobbies and the sorted list of people practicing each hobby. for hobby in hobbies: print(hobby) for person in hobby_dict[hobby]: print(f\\"{person[0]} {person[1]} {person[2]}\\")"},{"question":"def is_palindrome(s: str) -> str: Determines if the input string is a palindrome, ignoring spaces, commas, periods, and case sensitivity. >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") == \\"YES\\" >>> is_palindrome(\\"Hello, World!\\") == \\"NO\\" >>> is_palindrome(\\"\\") == \\"YES\\" >>> is_palindrome(\\"race car\\") == \\"YES\\" >>> is_palindrome(\\"Level\\") == \\"YES\\" >>> is_palindrome(\\"12321\\") == \\"YES\\" >>> is_palindrome(\\"Madam, in Eden, I'm Adam!\\") == \\"YES\\" >>> is_palindrome(\\"This is not a palindrome!\\") == \\"NO\\"","solution":"def is_palindrome(s): Determines if the input string is a palindrome, ignoring spaces, commas, periods, and case sensitivity. import string # Create a translation table for removing punctuation and whitespace table = str.maketrans('', '', string.whitespace + string.punctuation) # Clean the string by translating and converting to lowercase cleaned = s.translate(table).lower() # Check if the cleaned string is equal to its reverse return \\"YES\\" if cleaned == cleaned[::-1] else \\"NO\\""},{"question":"def isValidParentheses(s: str) -> bool: This function checks if the input string of parentheses is valid. A string is valid if every opening parenthesis has a corresponding closing parenthesis and they are properly nested. >>> isValidParentheses(\\"(())\\") True >>> isValidParentheses(\\"(()\\") False >>> isValidParentheses(\\"()()\\") True >>> isValidParentheses(\\"(()))\\") False >>> isValidParentheses(\\"\\") True","solution":"def isValidParentheses(s): This function checks if the input string of parentheses is valid. A string is valid if every opening parenthesis has a corresponding closing parenthesis and they are properly nested. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return not stack"},{"question":"import math def isPerfectSquare(N: int) -> str: Returns 'Yes' if N is a perfect square, 'No' otherwise. >>> isPerfectSquare(16) 'Yes' >>> isPerfectSquare(15) 'No'","solution":"import math def isPerfectSquare(N): Returns 'Yes' if N is a perfect square, 'No' otherwise. if N < 1: return \\"No\\" # Not within the problem constraints, but added for completeness sqrt_n = int(math.sqrt(N)) return \\"Yes\\" if sqrt_n * sqrt_n == N else \\"No\\""},{"question":"from typing import List def can_be_balanced(arr: List[int]) -> str: Determines if the array can be divided into two subarrays with equal sum. >>> can_be_balanced([1, 2, 3, 4]) 'YES' >>> can_be_balanced([2, 1, 2]) 'NO' def balanced_arrays(test_cases: List[List[int]]) -> List[str]: Processes multiple test cases to verify if each array can be balanced. >>> balanced_arrays([[1, 2, 3, 4], [2, 1, 2]]) ['YES', 'NO']","solution":"def can_be_balanced(arr): total_sum = sum(arr) if total_sum % 2 != 0: return \\"NO\\" target_sum = total_sum // 2 n = len(arr) dp = [[False] * (target_sum + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target_sum + 1): if arr[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] else: dp[i][j] = dp[i - 1][j] return \\"YES\\" if dp[n][target_sum] else \\"NO\\" def balanced_arrays(test_cases): results = [] for arr in test_cases: results.append(can_be_balanced(arr)) return results"},{"question":"def attendance_rate(attendance_record: str) -> int: Calculate the attendance rate in percentage rounded to the nearest integer. Parameters: attendance_record (str): A string of 'P' and 'A' representing the attendance record for a month. Returns: int: The attendance rate as a percentage rounded to the nearest integer. >>> attendance_rate(\\"PPAPPAPPAPPAPAPAPPAPPAPPAPPAPP\\") 67 >>> attendance_rate(\\"PAPAPA\\") 50 >>> attendance_rate(\\"PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP\\") 100 >>> attendance_rate(\\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\") 0 >>> attendance_rate(\\"PPPPPAA\\") 71","solution":"def attendance_rate(attendance_record): Calculate the attendance rate in percentage rounded to the nearest integer. Parameters: attendance_record (str): A string of 'P' and 'A' representing the attendance record for a month. Returns: int: The attendance rate as a percentage. total_days = len(attendance_record) present_days = attendance_record.count('P') attendance_percentage = (present_days / total_days) * 100 return round(attendance_percentage)"},{"question":"from typing import List, Tuple def manage_booking(n: int, requests: List[Tuple[int, int]]) -> List[bool]: Manage booking requests for a theater with a single row of seats. Each request contains the size of the group and the requested starting seat index. If a booking can be accommodated, mark the seats as occupied and return True. If it cannot be accommodated, return False. Args: n (int): Total number of seats. requests (List[Tuple[int, int]]): List of booking requests in tuple form where each tuple contains the size of the group (k) and the requested starting seat index (idx). Returns: List[bool]: List of boolean values corresponding to whether each booking request was successful. Examples: >>> manage_booking(10, [(3, 1), (5, 4), (2, 8), (4, 6)]) [True, True, False, False] >>> manage_booking(5, [(2, 1), (3, 3), (2, 4)]) [True, False, False]","solution":"from typing import List, Tuple def manage_booking(n: int, requests: List[Tuple[int, int]]) -> List[bool]: seats = [0] * n # 0 means available, 1 means occupied results = [] for k, idx in requests: if idx + k - 1 > n or any(seats[idx - 1: idx + k - 1]): results.append(False) else: for i in range(k): seats[idx - 1 + i] = 1 results.append(True) return results"},{"question":"def minTasksForBadges(gold, silver, bronze): Calculates the minimum number of tasks required to collect the specified number of Gold, Silver, and Bronze badges. Parameters: gold (int): Number of Gold badges required. silver (int): Number of Silver badges required. bronze (int): Number of Bronze badges required. Returns: int: The minimum number of tasks required. Example usage: >>> minTasksForBadges(2, 3, 1) 200 >>> minTasksForBadges(1, 1, 1) 100","solution":"def minTasksForBadges(gold, silver, bronze): Calculates the minimum number of tasks required to collect the specified number of Gold, Silver, and Bronze badges. Parameters: gold (int): Number of Gold badges required. silver (int): Number of Silver badges required. bronze (int): Number of Bronze badges required. Returns: int: The minimum number of tasks required. tasks_for_gold = gold * 100 tasks_for_silver = silver * 50 tasks_for_bronze = bronze * 20 # The minimum number of tasks required is the maximum of tasks for any badge requirement return max(tasks_for_gold, tasks_for_silver, tasks_for_bronze)"},{"question":"from typing import List from collections import Counter def k_most_frequent(n: int, k: int, elements: List[int]) -> List[int]: Identify the K most frequent elements in the list. If multiple elements have the same frequency, return the elements with the smallest values first. >>> k_most_frequent(7, 3, [4, 1, 2, 2, 3, 3, 3]) [3, 2, 1] >>> k_most_frequent(8, 2, [5, 5, 5, 4, 4, 4, 3, 3, 2]) [4, 5]","solution":"from collections import Counter def k_most_frequent(n, k, elements): This function takes the number of elements 'n', the number of most frequent elements 'k' to find, and the list of elements 'elements'. It returns the k most frequent elements sorted by frequency first (higher to lower) and then by value (lower to higher) for ties. frequency = Counter(elements) sorted_elements = sorted(frequency.items(), key=lambda x: (-x[1], x[0])) result = [elem[0] for elem in sorted_elements[:k]] return result"},{"question":"def shortest_substring_with_k_unique_chars(s: str, k: int) -> int: Returns the length of the shortest substring of \`s\` that contains at least \`k\` unique characters. If there is no such substring, returns \`-1\`. >>> shortest_substring_with_k_unique_chars(\\"abcba\\", 3) == 3 >>> shortest_substring_with_k_unique_chars(\\"aabbcc\\", 4) == -1 >>> shortest_substring_with_k_unique_chars(\\"aaaa\\", 1) == 1 >>> shortest_substring_with_k_unique_chars(\\"abc\\", 1) == 1 >>> shortest_substring_with_k_unique_chars(\\"a\\" * 1000 + \\"b\\" * 1000 + \\"c\\" * 1000, 2) == 2","solution":"def shortest_substring_with_k_unique_chars(s: str, k: int) -> int: from collections import defaultdict # Edge case: if k is zero, return 0 if k == 0: return 0 n = len(s) if n == 0 or k > n: return -1 left = 0 min_length = float('inf') char_count = defaultdict(int) unique_count = 0 # Use sliding window technique for right in range(n): if char_count[s[right]] == 0: unique_count += 1 char_count[s[right]] += 1 while unique_count >= k: min_length = min(min_length, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: unique_count -= 1 left += 1 return min_length if min_length != float('inf') else -1"},{"question":"def count_peaks(sequence): Returns the number of peaks in the given sequence. Parameters: sequence (list): A list of integers. Returns: int: The number of peaks in the sequence. pass def test_sample_case(): assert count_peaks([1, 3, 2, 4, 1, 5]) == 2 def test_no_peaks(): assert count_peaks([1, 2, 3, 4, 5]) == 0 assert count_peaks([5, 4, 3, 2, 1]) == 0 def test_single_peak(): assert count_peaks([1, 3, 1]) == 1 assert count_peaks([1, 2, 3, 2, 1]) == 1 def test_multiple_peaks(): assert count_peaks([1, 3, 1, 4, 1, 5, 1, 6, 1]) == 4 def test_edge_cases(): assert count_peaks([1, 1, 1]) == 0 # All same elements assert count_peaks([2]) == 0 # Single element assert count_peaks([2, 1]) == 0 # Two elements assert count_peaks([1, 2, 3, 4, 3, 2, 1]) == 1 def test_large_input(): assert count_peaks([i for i in range(1, 100001)]) == 0 # Increasing sequence assert count_peaks([i for i in range(100000, 0, -1)]) == 0 # Decreasing sequence assert count_peaks([i for i in range(1, 100001)] + [i for i in range(100000, 0, -1)]) == 0 # Combination","solution":"def count_peaks(sequence): Returns the number of peaks in the given sequence. Parameters: sequence (list): A list of integers. Returns: int: The number of peaks in the sequence. n = len(sequence) if n < 3: return 0 # Cannot have a peak if fewer than 3 elements peaks = 0 for i in range(1, n - 1): if sequence[i] > sequence[i - 1] and sequence[i] > sequence[i + 1]: peaks += 1 return peaks"},{"question":"def rotate(matrix): Rotates the matrix by 90 degrees clockwise in-place. The input matrix will be modified in-place. >>> mat1 = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate(mat1) >>> mat1 [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> mat2 = [ ... [5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate(mat2) >>> mat2 [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]]","solution":"def rotate(matrix): Rotates the matrix by 90 degrees clockwise in-place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def count_matching_positions(s: str, t: str) -> int: Count the number of positions in string s where t (with '?' replaced by any character) can match as a substring. >>> count_matching_positions(\\"abcde\\", \\"?c?\\") 1 >>> count_matching_positions(\\"abacaba\\", \\"a?a\\") 3 >>> count_matching_positions(\\"aaaaa\\", \\"???\\") 3","solution":"def count_matching_positions(s, t): Count the number of positions in string s where t (with '?' replaced by any character) can match as a substring. n = len(s) m = len(t) def is_match(sub, template): for i in range(m): if template[i] != '?' and sub[i] != template[i]: return False return True count = 0 for i in range(n - m + 1): if is_match(s[i:i + m], t): count += 1 return count"},{"question":"def common_prefix_length(strings): Returns the maximum length of a common prefix shared among all the strings in the list. >>> common_prefix_length([\\"flower\\", \\"flow\\", \\"flight\\"]) 2 >>> common_prefix_length([\\"dog\\", \\"racecar\\", \\"car\\"]) 0","solution":"def common_prefix_length(strings): Returns the maximum length of a common prefix shared among all the strings in the list. :param strings: List of strings :return: Integer denoting the longest common prefix length if not strings: return 0 # Find the minimum length string from the list min_length = min(len(s) for s in strings) # Initialize the common prefix length prefix_length = 0 for i in range(min_length): # Take the current character from the first string char = strings[0][i] # Check if the current character is the same in all strings if all(s[i] == char for s in strings): prefix_length += 1 else: break return prefix_length"},{"question":"def prime_palindromes(a: int, b: int) -> list: Find all prime palindromic numbers in the range [a, b]. >>> prime_palindromes(5, 100) == [5, 7, 11] >>> prime_palindromes(1, 10) == [2, 3, 5, 7] >>> prime_palindromes(102, 115) == \\"No prime palindromic numbers found.\\" >>> prime_palindromes(1, 1000) == [2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, 353, 373, 383, 727, 757, 787, 797, 919, 929] >>> prime_palindromes(11, 11) == [11] >>> prime_palindromes(14, 14) == \\"No prime palindromic numbers found.\\"","solution":"def prime_palindromes(a, b): Find all prime palindromic numbers in the range [a, b]. def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_palindrome(n): return str(n) == str(n)[::-1] result = [] for num in range(a, b + 1): if is_prime(num) and is_palindrome(num): result.append(num) if not result: return \\"No prime palindromic numbers found.\\" return result # Example usage # a, b = 5, 100 # print(prime_palindromes(a, b)) # Expected output: [5, 7, 11]"},{"question":"def can_form_palindrome(s: str) -> str: Returns \\"YES\\" if any permutation of s can form a palindrome, otherwise \\"NO\\" >>> can_form_palindrome(\\"aabb\\") == \\"YES\\" >>> can_form_palindrome(\\"abc\\") == \\"NO\\" >>> can_form_palindrome(\\"carerac\\") == \\"YES\\" def solve(test_cases: List[str]) -> List[str]: Given a list of strings, determines if any permutation of each string can form a palindrome. >>> solve([\\"aabb\\", \\"abc\\", \\"carerac\\"]) == [\\"YES\\", \\"NO\\", \\"YES\\"] >>> solve([\\"abcd\\", \\"dcba\\", \\"llooll\\"]) == [\\"NO\\", \\"NO\\", \\"YES\\"]","solution":"def can_form_palindrome(s): Returns \\"YES\\" if any permutation of s can form a palindrome, otherwise \\"NO\\" from collections import Counter count = Counter(s) odd_count = sum(1 for c in count if count[c] % 2 != 0) # We can form a palindrome if there is at most one character with an odd count if odd_count > 1: return \\"NO\\" else: return \\"YES\\" def solve(test_cases): results = [] for s in test_cases: results.append(can_form_palindrome(s)) return results"},{"question":"def max_deliveries(D: int, T: int, drone_battery_lives: List[int], delivery_tasks: List[int]) -> int: Compute the maximum number of deliveries that can be completed by the fleet of drones without exceeding their battery life. >>> max_deliveries(3, 6, [10, 20, 15], [5, 7, 8, 4, 12, 6]) 5 >>> max_deliveries(1, 1, [5], [5]) 1 >>> max_deliveries(3, 4, [10, 10, 10], [3, 3, 3, 3]) 4 >>> max_deliveries(2, 4, [1, 1], [5, 5, 5, 5]) 0 >>> max_deliveries(4, 5, [9, 8, 7, 6], [2, 2, 2, 2, 2]) 5","solution":"def max_deliveries(D, T, drone_battery_lives, delivery_tasks): drone_battery_lives.sort(reverse=True) delivery_tasks.sort() delivery_idx = 0 for battery_life in drone_battery_lives: used_battery = 0 while delivery_idx < T and used_battery + delivery_tasks[delivery_idx] <= battery_life: used_battery += delivery_tasks[delivery_idx] delivery_idx += 1 return delivery_idx"},{"question":"from typing import List def countReferrals(n: int, referrals: List[str], user: str) -> int: Count the number of users referred directly or indirectly by a given user. >>> countReferrals(5, [\\"A B\\", \\"A C\\", \\"B D\\", \\"C E\\", \\"A F\\"], \\"A\\") 5 >>> countReferrals(1, [\\"A B\\"], \\"A\\") 1 >>> countReferrals(1, [\\"A B\\"], \\"B\\") 0 >>> countReferrals(5, [\\"A B\\", \\"A C\\", \\"B D\\", \\"C E\\", \\"A F\\"], \\"B\\") 1 pass # Implement this function from solution import countReferrals def test_single_referral(): assert countReferrals(1, [\\"A B\\"], \\"A\\") == 1 def test_no_referral(): assert countReferrals(1, [\\"A B\\"], \\"B\\") == 0 def test_multiple_referred_directly_and_indirectly(): referrals = [\\"A B\\", \\"A C\\", \\"B D\\", \\"C E\\", \\"A F\\"] assert countReferrals(5, referrals, \\"A\\") == 5 assert countReferrals(5, referrals, \\"B\\") == 1 assert countReferrals(5, referrals, \\"C\\") == 1 def test_all_referred_by_single_user(): referrals = [\\"A B\\", \\"A C\\", \\"A D\\", \\"A E\\"] assert countReferrals(4, referrals, \\"A\\") == 4 def test_no_users_referred(): assert countReferrals(3, [\\"A B\\", \\"B C\\", \\"C D\\"], \\"E\\") == 0 def test_large_tree(): referrals = [ \\"A B\\", \\"B C\\", \\"C D\\", \\"D E\\", \\"E F\\", \\"F G\\", \\"G H\\", \\"H I\\", \\"I J\\", \\"J K\\", \\"K L\\", \\"L M\\", \\"M N\\", \\"N O\\", \\"O P\\", \\"P Q\\", \\"Q R\\", \\"R S\\", \\"S T\\", \\"T U\\", \\"U V\\", \\"V W\\", \\"W X\\", \\"X Y\\", \\"Y Z\\" ] assert countReferrals(25, referrals, \\"A\\") == 25 assert countReferrals(25, referrals, \\"G\\") == 19","solution":"from collections import defaultdict, deque def countReferrals(n, referrals, user): # Create a dictionary to store the referral relationships referral_dict = defaultdict(list) # Populate the referral dictionary for referral in referrals: referrer, referree = referral.split() referral_dict[referrer].append(referree) # Use a set to keep track of all referred users and a queue for BFS referred_users = set() queue = deque([user]) while queue: current_user = queue.popleft() for referree in referral_dict[current_user]: if referree not in referred_users: referred_users.add(referree) queue.append(referree) return len(referred_users)"},{"question":"def length_of_longest_word(s: str) -> int: Returns the length of the longest word in the string. If the string is empty, returns 0. >>> length_of_longest_word(\\"\\") == 0 >>> length_of_longest_word(\\"hello\\") == 5 >>> length_of_longest_word(\\"The quick brown fox\\") == 5 >>> length_of_longest_word(\\" hello world \\") == 5 >>> length_of_longest_word(\\"ant bat cat dog\\") == 3 >>> length_of_longest_word(\\"banana ant spider cat\\") == 6","solution":"def length_of_longest_word(s): Returns the length of the longest word in the string. If the string is empty, returns 0. if not s.strip(): return 0 words = s.split() longest_word_length = max(len(word) for word in words) return longest_word_length"},{"question":"def total_cooking_time(test_cases): Calculate the minimum number of hours required to cook all the dishes excluding break time. Parameters: test_cases (list): A list of dictionaries where each dictionary represents a test case with 'N' as the number of dishes and 'dishes' as a list of integers representing the cooking time of each dish. Returns: list: A list of integers where each integer is the total minimum cooking time for the corresponding test case. Example: >>> test_cases = [{'N': 3, 'dishes': [5, 10, 3]}] >>> total_cooking_time(test_cases) [18] >>> test_cases = [{'N': 4, 'dishes': [2, 3, 7, 8]}] >>> total_cooking_time(test_cases) [20]","solution":"def total_cooking_time(test_cases): results = [] for case in test_cases: N = case['N'] dishes = case['dishes'] results.append(sum(dishes)) return results # Example of how you would use this function test_cases = [ {'N': 3, 'dishes': [5, 10, 3]}, {'N': 4, 'dishes': [2, 3, 7, 8]} ] print(total_cooking_time(test_cases)) # Output: [18, 20]"},{"question":"def are_messages_equivalent(s1: str, s2: str) -> str: Determines if two messages s1 and s2 are equivalent based on their encoded values. Args: s1 (str): The first message consisting of uppercase English letters. s2 (str): The second message consisting of uppercase English letters. Returns: str: \\"YES\\" if the messages are equivalent, otherwise \\"NO\\". >>> are_messages_equivalent(\\"HELLO\\", \\"OHLEL\\") 'YES' >>> are_messages_equivalent(\\"TOP\\", \\"POT\\") 'YES' >>> are_messages_equivalent(\\"WORLD\\", \\"WORDL\\") 'NO'","solution":"def are_messages_equivalent(s1, s2): Determines if two messages s1 and s2 are equivalent based on their encoded values. Args: s1 (str): The first message consisting of uppercase English letters. s2 (str): The second message consisting of uppercase English letters. Returns: str: \\"YES\\" if the messages are equivalent, otherwise \\"NO\\". # Prime number mapping for each uppercase English letter letter_to_prime = { 'A': 2, 'B': 3, 'C': 5, 'D': 7, 'E': 11, 'F': 13, 'G': 17, 'H': 19, 'I': 23, 'J': 29, 'K': 31, 'L': 37, 'M': 41, 'N': 43, 'O': 47, 'P': 53, 'Q': 59, 'R': 61, 'S': 67, 'T': 71, 'U': 73, 'V': 79, 'W': 83, 'X': 89, 'Y': 97, 'Z': 101 } def encode_message(s): encoded_value = 1 for char in s: encoded_value *= letter_to_prime[char] return encoded_value return \\"YES\\" if encode_message(s1) == encode_message(s2) else \\"NO\\""},{"question":"from typing import List, Tuple def find_components(n: int, m: int, values: List[int], edges: List[Tuple[int, int]]) -> List[Tuple[int, int]]: You are given an undirected graph consisting of n vertices and m edges. Each vertex has a value associated with it. Your task is to find the minimum and maximum values among the vertices in any connected component of the graph. Args: n : int : number of vertices m : int : number of edges values : List[int] : values of the vertices edges : List[Tuple[int, int]] : pairs of vertices representing edges Returns: List[Tuple[int, int]] : a list of pairs where each pair contains the minimum and maximum values of each connected component Examples: >>> find_components(5, 3, [1, 2, 3, 4, 5], [(1, 2), (2, 3), (4, 5)]) [(1, 3), (4, 5)] >>> find_components(4, 2, [4, 7, 2, 9], [(1, 2), (1, 3)]) [(2, 7), (9, 9)] pass def test_find_components(): assert find_components(5, 3, [1, 2, 3, 4, 5], [(1, 2), (2, 3), (4, 5)]) == [(1, 3), (4, 5)] assert find_components(4, 2, [4, 7, 2, 9], [(1, 2), (1, 3)]) == [(2, 7), (9, 9)] assert find_components(6, 3, [10, 20, 30, 40, 50, 60], [(1, 2), (2, 3), (5, 6)]) == [(10, 30), (40, 40), (50, 60)] assert find_components(4, 0, [5, 10, 15, 20], []) == [(5, 5), (10, 10), (15, 15), (20, 20)] assert find_components(3, 1, [100, 200, 300], [(1, 3)]) == [(100, 300), (200, 200)]","solution":"def find_components(n, m, values, edges): from collections import defaultdict, deque def bfs(node): queue = deque([node]) component = [] while queue: vertex = queue.popleft() if not visited[vertex]: visited[vertex] = True component.append(vertex) for neighbor in graph[vertex]: if not visited[neighbor]: queue.append(neighbor) return component graph = defaultdict(list) for u, v in edges: graph[u-1].append(v-1) graph[v-1].append(u-1) visited = [False] * n components = [] for vertex in range(n): if not visited[vertex]: component = bfs(vertex) components.append(component) results = [] for component in components: component_values = [values[v] for v in component] min_val = min(component_values) max_val = max(component_values) results.append((min_val, max_val)) results.sort() return results"},{"question":"from typing import List def find_peak_elevation(matrix: List[List[int]]) -> int: Given a matrix of integers representing a mountain range where each value corresponds to the elevation at that point, find the maximum peak elevation. A peak is defined as an element that is greater than or equal to its four neighbors: up, down, left, and right. If there are multiple peaks, return the highest peak value. If no peaks exist, return the elevation of the top-left corner of the matrix. >>> find_peak_elevation([ ... [1, 2, 3], ... [6, 5, 4], ... [7, 8, 9] ... ]) 9 >>> find_peak_elevation([ ... [10, 8, 7], ... [4, 5, 6], ... [3, 2, 1] ... ]) 10 >>> find_peak_elevation([ ... [5, 5, 5], ... [5, 5, 5], ... [5, 5, 5] ... ]) 5 def test_find_peak_elevation_example1(): matrix = [ [1, 2, 3], [6, 5, 4], [7, 8, 9] ] assert find_peak_elevation(matrix) == 9 def test_find_peak_elevation_example2(): matrix = [ [10, 8, 7], [4, 5, 6], [3, 2, 1] ] assert find_peak_elevation(matrix) == 10 def test_find_peak_elevation_example3(): matrix = [ [5, 5, 5], [5, 5, 5], [5, 5, 5] ] assert find_peak_elevation(matrix) == 5 def test_find_peak_elevation_single_element(): matrix = [ [42] ] assert find_peak_elevation(matrix) == 42 def test_find_peak_elevation_negative_numbers(): matrix = [ [-10, -12, -5], [-8, -6, -7], [-3, -4, -9] ] assert find_peak_elevation(matrix) == -3 def test_find_peak_elevation_multiple_peaks(): matrix = [ [1, 6, 1], [5, 4, 5], [1, 6, 1] ] assert find_peak_elevation(matrix) == 6 def test_find_peak_elevation_flat_matrix(): matrix = [ [7, 7, 7], [7, 7, 7], [7, 7, 7] ] assert find_peak_elevation(matrix) == 7","solution":"from typing import List def find_peak_elevation(matrix: List[List[int]]) -> int: rows, cols = len(matrix), len(matrix[0]) max_peak = matrix[0][0] for i in range(rows): for j in range(cols): is_peak = True if i > 0 and matrix[i][j] < matrix[i - 1][j]: # up is_peak = False if i < rows - 1 and matrix[i][j] < matrix[i + 1][j]: # down is_peak = False if j > 0 and matrix[i][j] < matrix[i][j - 1]: # left is_peak = False if j < cols - 1 and matrix[i][j] < matrix[i][j + 1]: # right is_peak = False if is_peak: max_peak = max(max_peak, matrix[i][j]) return max_peak"},{"question":"import math from typing import List def generateCatalanNumbers(n: int) -> List[int]: Generates the first n Catalan numbers. Catalan numbers form a sequence of natural numbers with significant applications in combinatorial mathematics. The n-th Catalan number can be computed using the formula: [ text{C}_n = frac{(2n)!}{(n+1)!n!} ] where ( ! ) denotes factorial. Args: n (int): The number of Catalan numbers to generate. Returns: List[int]: A list containing the first n Catalan numbers. >>> generateCatalanNumbers(0) [1] >>> generateCatalanNumbers(5) [1, 1, 2, 5, 14, 42] >>> generateCatalanNumbers(3) [1, 1, 2, 5]","solution":"import math def generateCatalanNumbers(n): Generates the first n Catalan numbers. catalan_numbers = [0] * (n + 1) catalan_numbers[0] = 1 for i in range(1, n + 1): catalan_numbers[i] = catalan_numbers[i - 1] * 2 * (2 * i - 1) // (i + 1) return catalan_numbers[:n+1]"},{"question":"def longest_substring_with_k_distinct(s: str, k: int) -> int: Returns the length of the longest substring that contains at most K distinct characters. >>> longest_substring_with_k_distinct(\\"eceba\\", 2) 3 >>> longest_substring_with_k_distinct(\\"\\", 2) 0 >>> longest_substring_with_k_distinct(\\"eceba\\", 0) 0 >>> longest_substring_with_k_distinct(\\"aaaa\\", 1) 4 >>> longest_substring_with_k_distinct(\\"eceba\\", 10) 5 >>> longest_substring_with_k_distinct(\\"abcdef\\", 4) 4 >>> longest_substring_with_k_distinct(\\"aaaaaa\\", 2) 6 >>> longest_substring_with_k_distinct(\\"aabbcc\\", 0) 0","solution":"def longest_substring_with_k_distinct(s, k): Returns the length of the longest substring with at most k distinct characters. if k == 0 or not s: return 0 left, max_length = 0, 0 char_freq = {} for right in range(len(s)): char_freq[s[right]] = char_freq.get(s[right], 0) + 1 while len(char_freq) > k: char_freq[s[left]] -= 1 if char_freq[s[left]] == 0: del char_freq[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List, Tuple def find_stations_to_reconnect(n: int, connections: List[Tuple[int, int]]) -> List[int]: In a bustling city, a new subway system has been established with various lines connecting different stations. To simplify the construction process and ensure that all stations are connected, the city planners designed the system such that each station connects to exactly two other stations, forming a circular loop with n stations. Due to some maintenance work, one of the subway stations had to be closed temporarily. As a result, the subway system has become disconnected. The city planners need to reopen the closed station and connect it back to exactly two stations to restore the loop, but they want to avoid any additional disconnections in the process. Given the initial subway system, identify the station that was closed, and reconnect it such that the circular loop is restored. n (int): The number of stations in the subway system. connections (List[Tuple[int, int]]): A list of connections between stations. Returns: List[int]: A list containing two integers, the stations that should be directly connected to the closed station to restore the circular loop. Examples: >>> find_stations_to_reconnect(4, [(1, 2), (2, 3), (3, 4)]) [1, 4] >>> find_stations_to_reconnect(5, [(1, 2), (2, 3), (3, 4), (5, 1)]) [4, 5]","solution":"def find_stations_to_reconnect(n, connections): from collections import defaultdict, deque adj_list = defaultdict(list) for u, v in connections: adj_list[u].append(v) adj_list[v].append(u) # Finding the two endpoints of the path which were previously connected end_points = [node for node in adj_list if len(adj_list[node]) == 1] return end_points"},{"question":"def calculate_total_cost(pastries): Calculates the total cost of pastries with given discounts. Parameters: pastries (int): Number of pastries bought Returns: float: Total cost after applying discounts, rounded to two decimal places # Your code here pass","solution":"def calculate_total_cost(pastries): Calculates the total cost of pastries with given discounts. Parameters: pastries (int): Number of pastries bought Returns: float: Total cost after applying discounts, rounded to two decimal places cost_per_pastry = 2.00 if pastries >= 10: total_cost = pastries * cost_per_pastry * 0.80 elif pastries >= 5: total_cost = pastries * cost_per_pastry * 0.90 else: total_cost = pastries * cost_per_pastry return round(total_cost, 2)"},{"question":"def min_operations_to_one_chocolate(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of operations needed so that no box has more than 1 chocolate remaining. >>> min_operations_to_one_chocolate(3, [(4, [3, 4, 5, 6]), (2, [7, 10]), (3, [1, 2, 3])]) [14, 15, 3] >>> min_operations_to_one_chocolate(2, [(1, [1000000]), (1, [2])]) [999999, 1] >>> min_operations_to_one_chocolate(1, [(5, [1, 1, 1, 1, 1])]) [0] >>> min_operations_to_one_chocolate(2, [(3, [999999, 888888, 777777]), (2, [555555, 444444])]) [999998 + 888887 + 777776, 555554 + 444443]","solution":"def min_operations_to_one_chocolate(T, test_cases): results = [] for n, chocolates in test_cases: operations = sum(a - 1 for a in chocolates) results.append(operations) return results # Example Usage: # T = 3 # test_cases = [ # (4, [3, 4, 5, 6]), # (2, [7, 10]), # (3, [1, 2, 3]) # ] # print(min_operations_to_one_chocolate(T, test_cases))"},{"question":"def doesReturnToOrigin(moves: str) -> bool: Determines if the object returns to its original position after executing the moves. Args: moves (str): A string containing characters 'L', 'R', 'U', 'D'. Returns: bool: True if the object returns to the origin, False otherwise. >>> doesReturnToOrigin(\\"UD\\") True >>> doesReturnToOrigin(\\"LL\\") False >>> doesReturnToOrigin(\\"\\") True >>> doesReturnToOrigin(\\"LR\\") True >>> doesReturnToOrigin(\\"UDUD\\") True >>> doesReturnToOrigin(\\"UDLR\\") True >>> doesReturnToOrigin(\\"UUDD\\") True >>> doesReturnToOrigin(\\"UUD\\") False >>> doesReturnToOrigin(\\"LRR\\") False >>> doesReturnToOrigin(\\"DDU\\") False >>> doesReturnToOrigin(\\"L\\"*5000 + \\"R\\"*5000 + \\"U\\"*5000 + \\"D\\"*5000) True >>> doesReturnToOrigin(\\"DULR\\") True >>> doesReturnToOrigin(\\"UUUUDDDD\\") True >>> doesReturnToOrigin(\\"RRLLLL\\") False","solution":"def doesReturnToOrigin(moves): Determines if the object returns to its original position after executing the moves. Args: moves (str): A string containing characters 'L', 'R', 'U', 'D'. Returns: bool: True if the object returns to the origin, False otherwise. # Initialize position counters x, y = 0, 0 # Iterate through each move and update position counters for move in moves: if move == 'L': x -= 1 elif move == 'R': x += 1 elif move == 'U': y += 1 elif move == 'D': y -= 1 # Object returns to the origin if both x and y are 0 return x == 0 and y == 0"},{"question":"def solution(array, target): Determines if there are any two distinct elements in the array that add up to the target. Parameters: array (list of int): The list of integers. target (int): The target integer. Returns: bool: True if there are two distinct elements that add up to the target, False otherwise. pass # Example Usage # Example 1: array = [2, 7, 11, 15] target = 9 # 2 + 7 = 9 result = solution(array, target) # should return True # Example 2: array = [1, 2, 3, 4] target = 8 # There are no two numbers in the array that add up to 8. result = solution(array, target) # should return False # Example 3: array = [5, 1, 2, 5] target = 10 # 5 + 5 = 10 result = solution(array, target) # should return True # Example 4: array = [] target = 5 # There are no two numbers in the array to check. result = solution(array, target) # should return False # Example 5: array = [3, 3, 4, -1] target = -2 # 4 + (-1) != -2 result = solution(array, target) # should return False # Unit Tests: def test_solution_target_positive(): assert solution([2, 7, 11, 15], 9) == True def test_solution_target_no_match(): assert solution([1, 2, 3, 4], 8) == False def test_solution_repeat_elements(): assert solution([5, 1, 2, 5], 10) == True def test_solution_empty_array(): assert solution([], 5) == False def test_solution_target_negative(): assert solution([3, 3, 4, -1], -2) == False def test_solution_all_negatives_with_match(): assert solution([-3, -4, -1, -7], -5) == True def test_solution_all_negatives_no_match(): assert solution([-3, -4, -1, -7], -9) == False def test_solution_mixed_signs_with_match(): assert solution([2, -3, 7, -10], -3) == True def test_solution_mixed_signs_no_match(): assert solution([2, -3, 7, -10], 5) == False def test_solution_large_numbers(): assert solution([1000000001, 2, 3, 999999999], 2000000000) == True","solution":"def solution(array, target): Determines if there are any two distinct elements in the array that add up to the target. Parameters: array (list of int): The list of integers. target (int): The target integer. Returns: bool: True if there are two distinct elements that add up to the target, False otherwise. seen_numbers = set() for number in array: if target - number in seen_numbers: return True seen_numbers.add(number) return False"},{"question":"def process_input(data: List[str]) -> List[str]: Given a list of strings representing the input data, return a list of strings where each string is either 'yes' or 'no' indicating whether the pairs of chemical formulas represent the same composition. >>> process_input([\\"3\\", \\"H2O\\", \\"O1H2\\", \\"CH4\\", \\"C2H2\\", \\"H\\", \\"HH\\", \\"2\\", \\"O2\\", \\"O2\\", \\"N2\\", \\"N2O\\", \\"0\\"]) == [\\"yes\\", \\"no\\", \\"no\\", \\"yes\\", \\"no\\"] >>> process_input([\\"1\\", \\"H\\", \\"H2\\", \\"0\\"]) == [\\"no\\"] >>> process_input([\\"1\\", \\"C\\", \\"C1\\", \\"0\\"]) == [\\"yes\\"] >>> process_input([\\"1\\", \\"C6H12O6\\", \\"C6H12O6\\", \\"1\\", \\"NaCl\\", \\"ClNa\\", \\"0\\"]) == [\\"yes\\", \\"yes\\"] >>> process_input([\\"1\\", \\"C2H5OH\\", \\"H5C2OH\\", \\"0\\"]) == [\\"yes\\"] >>> process_input([\\"1\\", \\"NH3\\", \\"H3N1\\", \\"0\\"]) == [\\"yes\\"]","solution":"from collections import defaultdict import re def parse_formula(formula): Parse the chemical formula into a dictionary of elements and their quantities. elements = defaultdict(int) for elem, qty in re.findall(r'([A-Z][a-z]*)(d*)', formula): qty = int(qty) if qty else 1 elements[elem] += qty return elements def is_same_composition(formula1, formula2): Check if the two formulas have the same composition. return parse_formula(formula1) == parse_formula(formula2) def check_formula_pairs(pairs): Given a list of pairs of formulas, returns a list of \\"yes\\" or \\"no\\" for each pair. results = [] for formula1, formula2 in pairs: if is_same_composition(formula1, formula2): results.append('yes') else: results.append('no') return results def process_input(data): Process input data and return results for all datasets. result = [] idx = 0 while True: N = int(data[idx]) if N == 0: break pairs = [(data[i], data[i + 1]) for i in range(idx + 1, idx + 1 + 2 * N, 2)] result.extend(check_formula_pairs(pairs)) idx += 1 + 2 * N return result"},{"question":"def infixToPostfix(infix_exp: str) -> str: Convert an infix arithmetic expression to its equivalent postfix expression. >>> infixToPostfix(\\"A+B\\") == \\"AB+\\" >>> infixToPostfix(\\"A+B*C\\") == \\"ABC*+\\" >>> infixToPostfix(\\"A+B*(C^D-E)\\") == \\"ABCD^E-*+\\" >>> infixToPostfix(\\"(A+B)*(C-D)/E\\") == \\"AB+CD-*E/\\" >>> infixToPostfix(\\"A-(B+C)\\") == \\"ABC+-\\" >>> infixToPostfix(\\"A*B+C/D\\") == \\"AB*CD/+\\" >>> infixToPostfix(\\"A+(B*C-(D/E^F)*G)*H\\") == \\"ABC*DEF^/G*-H*+\\" # Your implementation here","solution":"def infixToPostfix(infix_exp): precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3} output = [] stack = [] for char in infix_exp: if char.isalpha() or char.isdigit(): output.append(char) elif char == '(': stack.append(char) elif char == ')': while stack and stack[-1] != '(': output.append(stack.pop()) stack.pop() else: while stack and stack[-1] != '(' and precedence[stack[-1]] >= precedence.get(char, 0): output.append(stack.pop()) stack.append(char) while stack: output.append(stack.pop()) return ''.join(output)"},{"question":"from typing import List def longest_subsequence_length(N: int, S: int, sequence: List[int]) -> int: Finds the length of the longest contiguous subsequence that sums to S. Returns 0 if no such subsequence exists. >>> longest_subsequence_length(5, 12, [1, 2, 3, 7, 5]) 3 >>> longest_subsequence_length(5, 20, [1, 2, 3, 7, 5]) 0 >>> longest_subsequence_length(4, 10, [1, 2, 3, 4]) 4 >>> longest_subsequence_length(7, 8, [1, 2, 3, 2, 1, 4, 2]) 4 >>> longest_subsequence_length(4, 2, [2, 2, 2, 2]) 1","solution":"def longest_subsequence_length(N, S, sequence): Finds the length of the longest contiguous subsequence that sums to S. Returns 0 if no such subsequence exists. sum_dict = {} current_sum = 0 max_length = 0 for i in range(N): current_sum += sequence[i] if current_sum == S: max_length = i + 1 if (current_sum - S) in sum_dict: max_length = max(max_length, i - sum_dict[current_sum - S]) if current_sum not in sum_dict: sum_dict[current_sum] = i return max_length"},{"question":"def is_prime(n: int) -> bool: Helper function to check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(18) False >>> is_prime(29) True >>> is_prime(1) False pass def subarray_prime_queries(n: int, m: int, nums: List[int], queries: List[Tuple[int, int]]) -> List[str]: Function to handle multiple queries, checking if the sum of the subarray is prime. n: int : length of the array nums m: int : number of queries nums: list of int : array elements queries: list of tuple : list of (l, r) queries returns list of str : list of \\"YES\\" or \\"NO\\" for each query >>> subarray_prime_queries(6, 3, [3, 4, 6, 2, 7, 5], [(1, 3), (2, 5), (1, 6)]) ['NO', 'YES', 'NO'] >>> subarray_prime_queries(1, 1, [1], [(1, 1)]) ['NO'] >>> subarray_prime_queries(1, 1, [2], [(1, 1)]) ['YES'] >>> subarray_prime_queries(2, 1, [2, 3], [(1, 2)]) ['YES'] >>> subarray_prime_queries(2, 1, [4, 6], [(1, 2)]) ['NO'] >>> subarray_prime_queries(5, 2, [10**9, 10**9, 10**9, 10**9, 10**9], [(1, 5), (3, 4)]) ['NO', 'NO'] pass","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def subarray_prime_queries(n, m, nums, queries): Function to handle multiple queries, checking if the sum of the subarray is prime. n: int : length of the array nums m: int : number of queries nums: list of int : array elements queries: list of tuple : list of (l, r) queries returns list of str : list of \\"YES\\" or \\"NO\\" for each query # Create prefix sum array prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1] results = [] for l, r in queries: sub_sum = prefix_sums[r] - prefix_sums[l - 1] if is_prime(sub_sum): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def empty_seat_position(n, m, k): Determines the position of the empty seat after \`k\` steps in a circular carousel. :param n: int - Total number of seats :param m: int - Initial position of the empty seat :param k: int - Number of steps :return: int - The position of the empty seat after \`k\` steps. >>> empty_seat_position(6, 2, 3) 5 >>> empty_seat_position(10, 7, 99) 6 pass","solution":"def empty_seat_position(n, m, k): Returns the position of the empty seat after \`k\` steps. :param n: int - Total number of seats :param m: int - Initial position of the empty seat :param k: int - Number of steps :return: int - The position of the empty seat after \`k\` steps. # Calculate the position after k steps. # We subtract 1 from m to convert it to zero-based index, add k steps, take modulo n, # and convert back to one-based index by adding 1. return ((m - 1 + k) % n) + 1"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sum_of_left_leaves(root: TreeNode) -> int: Given the root of a binary tree, return the sum of all left leaves. A leaf is a node with no children. A left leaf is a leaf that is the left child of its parent. >>> # Construct the binary tree for the given example >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> sum_of_left_leaves(root) 24 >>> sum_of_left_leaves(None) 0 >>> single_node = TreeNode(1) >>> sum_of_left_leaves(single_node) 0","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sum_of_left_leaves(root): if not root: return 0 def is_leaf(node): return node is not None and node.left is None and node.right is None def dfs(node, is_left): if not node: return 0 if is_leaf(node) and is_left: return node.val return dfs(node.left, True) + dfs(node.right, False) return dfs(root, False)"},{"question":"def two_sum(nums, target): Returns the indices of the two numbers such that they add up to the target. Args: nums (List[int]): List of integers. target (int): The target sum. Returns: List[int]: Indices of the two numbers. pass def process_input_and_find_two_sums(T, test_cases): Processes input and finds the indices of the two numbers for each test case that add up to the target. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[int]]]): List of test cases with each containing number of elements, target sum, and list of numbers. Returns: List[List[int]]: List of results with indices of the two numbers for each test case. pass def main(): Main function to read input, process each test case, and print the results. pass import pytest from solution import two_sum, process_input_and_find_two_sums def test_two_sum(): assert two_sum([2, 7, 11, 15], 9) == [1, 2] assert two_sum([3, 5, -2, 8, 11, -4], 6) in [[2, 6], [3, 4]] assert two_sum([1, -1, 2, -2, 3], -3) in [[2, 4]] def test_process_input_and_find_two_sums(): T = 3 test_cases = [ (4, 9, [2, 7, 11, 15]), (6, 6, [3, 5, -2, 8, 11, -4]), (5, -3, [1, -1, 2, -2, 3]) ] results = process_input_and_find_two_sums(T, test_cases) assert results == [[1, 2], [2, 6], [2, 4]] or results == [[1, 2], [3, 4], [2, 4]] if __name__ == \\"__main__\\": pytest.main()","solution":"def two_sum(nums, target): Returns the indices of the two numbers such that they add up to the target. Args: nums (List[int]): List of integers. target (int): The target sum. Returns: List[int]: Indices of the two numbers. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return sorted([num_to_index[complement] + 1, i + 1]) num_to_index[num] = i def process_input_and_find_two_sums(T, test_cases): results = [] for case in test_cases: n, target, nums = case result = two_sum(nums, target) results.append(result) return results def main(): import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): n = int(data[index]) target = int(data[index + 1]) nums = list(map(int, data[index + 2 : index + 2 + n])) test_cases.append((n, target, nums)) index += 2 + n results = process_input_and_find_two_sums(T, test_cases) for result in results: print(f\\"{result[0]} {result[1]}\\") if __name__ == \\"__main__\\": main()"},{"question":"def find_product_of_sums(arr: List[int]) -> int: Computes the product of the sum of the first half and the sum of the second half of the array. If the length of the array \`n\` is odd, the middle element is included in the second half. >>> find_product_of_sums([1, 2, 3, 4, 5, 6]) 90 >>> find_product_of_sums([1, 2, 3, 4, 5]) 36 >>> find_product_of_sums([42]) 0 >>> find_product_of_sums([-1, 0, 1, -2, 2]) -1 >>> find_product_of_sums([-10, 20, -30, 40, -50, 60]) -1000 >>> large_array = [10**9, -(10**9)] * 50000 >>> find_product_of_sums(large_array) 0","solution":"def find_product_of_sums(arr): Computes the product of the sum of the first half and the sum of the second half of the array. If the length of the array n is odd, the middle element is included in the second half. n = len(arr) # Determine the mid point of the array mid = (n + 1) // 2 # (n + 1) // 2 ensures the middle element is included in the second half if n is odd # Calculate the sum of the first half and the sum of the second half sum_first_half = sum(arr[:n // 2]) sum_second_half = sum(arr[n // 2:]) # Return the product of the two sums return sum_first_half * sum_second_half"},{"question":"from typing import List, Tuple def process_integers(int_list: List[int]) -> Tuple[int, List[int]]: Given a list of non-negative integers, return a tuple containing: 1. The sum of the integers in the list. 2. A list of the integers in the original list raised to the power of their respective indices. Examples: >>> process_integers([2, 3, 4]) (9, [1, 3, 16]) >>> process_integers([1, 5, 2, 3]) (11, [1, 5, 4, 27]) >>> process_integers([7, 0, 8]) (15, [1, 0, 64]) pass # Implement your solution here","solution":"def process_integers(int_list): Function to return the sum of integers in the list and the list with elements raised to the power of their respective indices. total_sum = sum(int_list) powered_list = [num ** index for index, num in enumerate(int_list)] return (total_sum, powered_list)"},{"question":"def canArrangeWithBuddies(participants, buddies): Checks if it is possible to arrange participants such that all pairs in buddies are adjacent by only swapping adjacent participants. Args: participants (List[int]): An array of integers representing the participant IDs. buddies (List[List[int]]): An array of integer pairs where each pair [a, b] indicates that participant a and participant b must sit next to each other. Returns: bool: True if it is possible to arrange the participants such that all pairs in buddies are adjacent by only swapping adjacent participants, otherwise False. Examples: >>> canArrangeWithBuddies([1, 3, 2, 4], [[1, 2], [3, 4]]) True >>> canArrangeWithBuddies([1, 2, 3, 4], [[1, 3], [2, 4]]) False def test_canArrangeWithBuddies_example_1(): assert canArrangeWithBuddies([1, 3, 2, 4], [[1, 2], [3, 4]]) == True def test_canArrangeWithBuddies_example_2(): assert canArrangeWithBuddies([1, 2, 3, 4], [[1, 3], [2, 4]]) == False def test_canArrangeWithBuddies_single_pair(): assert canArrangeWithBuddies([2, 1], [[1, 2]]) == True def test_canArrangeWithBuddies_no_swap_needed(): assert canArrangeWithBuddies([1, 2], [[1, 2]]) == True def test_canArrangeWithBuddies_multiple_swaps_needed(): assert canArrangeWithBuddies([4, 3, 2, 1], [[1, 2], [3, 4]]) == True def test_canArrangeWithBuddies_not_possible(): assert canArrangeWithBuddies([1, 4, 3, 2], [[1, 3], [2, 4]]) == False","solution":"def canArrangeWithBuddies(participants, buddies): Checks if it is possible to arrange participants such that all pairs in buddies are adjacent by only swapping adjacent participants. n = len(participants) buddy_dict = {a: b for a, b in buddies} buddy_dict.update({b: a for a, b in buddies}) for i in range(n - 1): for j in range(n - 1 - i): if participants[j] > participants[j + 1]: participants[j], participants[j + 1] = participants[j + 1], participants[j] for i in range(n): if participants[i] in buddy_dict: buddy = buddy_dict[participants[i]] if not (i < n - 1 and participants[i + 1] == buddy or i > 0 and participants[i - 1] == buddy): return False return True"},{"question":"def can_escape(grid, n, m): Determines if there exists a path from (1, 1) to (n, m) avoiding all obstacles. Parameters: grid (list of list of int): The grid representing the maze. n (int): The number of rows. m (int): The number of columns. Returns: str: 'YES' if a path exists, 'NO' otherwise. Examples: >>> can_escape([[0, 0, 1], [0, 1, 0], [0, 0, 0]], 3, 3) 'YES' >>> can_escape([[0, 1, 1], [1, 0, 1], [0, 0, 0]], 3, 3) 'NO'","solution":"def can_escape(grid, n, m): Determines if there exists a path from (1, 1) to (n, m) avoiding all obstacles. Parameters: grid (list of list of int): The grid representing the maze. n (int): The number of rows. m (int): The number of columns. Returns: str: 'YES' if a path exists, 'NO' otherwise. if n == 0 or m == 0 or grid[0][0] == 1 or grid[n-1][m-1] == 1: return \\"NO\\" def dfs(x, y): if x == n-1 and y == m-1: return True grid[x][y] = 1 # marks the cell as visited by setting it to 1 # move down if x + 1 < n and grid[x + 1][y] == 0 and dfs(x + 1, y): return True # move right if y + 1 < m and grid[x][y + 1] == 0 and dfs(x, y + 1): return True return False if dfs(0, 0): return \\"YES\\" else: return \\"NO\\""},{"question":"def sum_subarray_even_odd(test_cases): You are given an array B of integers of size M. You are given Q queries each of which is represented by two integers L, R. For each query, you are to find the sum of elements in the subarray from index L to index R (inclusive) and determine if the sum is an even number or an odd number. >>> test_cases = [ ... (5, 3, [4, 7, 2, 9, 3], [(1, 3), (2, 5), (1, 5)]) ... ] >>> sum_subarray_even_odd(test_cases) ['ODD', 'ODD', 'ODD'] >>> test_cases = [ ... (5, 1, [4, 7, 2, 9, 3], [(1, 1)]) ... ] >>> sum_subarray_even_odd(test_cases) ['EVEN']","solution":"def sum_subarray_even_odd(test_cases): results = [] for case in test_cases: M, Q, B, queries = case prefix_sum = [0] * (M + 1) # Calculate prefix sums for i in range(M): prefix_sum[i + 1] = prefix_sum[i] + B[i] # Process each query to determine if the sum is even or odd for L, R in queries: subarray_sum = prefix_sum[R] - prefix_sum[L - 1] if subarray_sum % 2 == 0: results.append('EVEN') else: results.append('ODD') return results"},{"question":"def calculate_minimum_edits(t: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[int]: A magazine publisher keeps track of the number of words in each article before it is published. The articles often go through revisions where they need to meet a required word count exactly. For each article, you can increase or decrease the number of words by removing, adding, or changing one word at a time. Given the starting word count of multiple articles and the required word count, determine the minimum number of single-word edits needed for each article to meet the required word count. Args: t: An integer representing the number of test cases. test_cases: A list of tuples where each tuple contains: - an integer n representing the number of articles - a list of n integers representing the current word count of each article - a list of n integers representing the required word count for each article Returns: A list of integers representing the total minimum number of edits needed to make all articles meet their respective required word counts for each test case. >>> calculate_minimum_edits(2, [(3, [450, 620, 512], [480, 600, 500]), (2, [150, 350], [200, 300])]) [62, 100] >>> calculate_minimum_edits(1, [(2, [200, 300], [200, 300])]) [0]","solution":"def calculate_minimum_edits(t, test_cases): results = [] for test_case in test_cases: n, current_counts, required_counts = test_case total_edits = 0 for i in range(n): total_edits += abs(current_counts[i] - required_counts[i]) results.append(total_edits) return results"},{"question":"def checkValidString(s: str) -> bool: Determine if a string of parentheses and wildcard characters ? can be valid. Args: s (str): A string containing '(', ')', and '?' characters. Returns: bool: True if the string can be valid, otherwise False. Examples: >>> checkValidString(\\"()\\") True >>> checkValidString(\\"(*)\\") True >>> checkValidString(\\"(*))\\") True >>> checkValidString(\\"(*()(\\") False","solution":"def checkValidString(s: str) -> bool: Returns True if the input string of parentheses and wildcard characters can be valid based on the defined rules, otherwise returns False. low = high = 0 for char in s: if char == '(': low += 1 high += 1 elif char == ')': low = max(low - 1, 0) high -= 1 else: # char == '?' low = max(low - 1, 0) high += 1 # If high becomes negative, there are more ')' than '(' at any point if high < 0: return False # In the end, if low is greater than 0, there are unmatched '(' return low == 0"},{"question":"def is_palindrome_substring(S, queries): Given a string S and a list of queries represented as tuples (l, r), determines if the substring S[l:r+1] is a palindrome. Args: S (str): The input string. queries (list): A list of tuples (l, r) where 0 <= l <= r < len(S) Returns: list: A list of \\"Yes\\" or \\"No\\" for each query indicating if the substring is a palindrome. from solution import is_palindrome_substring def test_single_character(): assert is_palindrome_substring(\\"a\\", [(0, 0)]) == [\\"Yes\\"] assert is_palindrome_substring(\\"z\\", [(0, 0)]) == [\\"Yes\\"] def test_full_string_palindrome(): S = \\"racecar\\" queries = [(0, 6), (1, 5), (2, 4)] assert is_palindrome_substring(S, queries) == [\\"Yes\\", \\"Yes\\", \\"Yes\\"] def test_non_palindrome_queries(): S = \\"palindrome\\" queries = [(0, 3), (1, 4), (2, 5)] assert is_palindrome_substring(S, queries) == [\\"No\\", \\"No\\", \\"No\\"] def test_mixed_queries(): S = \\"abacaba\\" queries = [(0, 6), (1, 3), (2, 4)] assert is_palindrome_substring(S, queries) == [\\"Yes\\", \\"No\\", \\"Yes\\"] def test_edge_cases(): S = \\"a\\" queries = [(0, 0)] assert is_palindrome_substring(S, queries) == [\\"Yes\\"] S = \\"aa\\" queries = [(0, 0), (0, 1), (1, 1)] assert is_palindrome_substring(S, queries) == [\\"Yes\\", \\"Yes\\", \\"Yes\\"] def test_long_string(): S = \\"a\\" * 1000 queries = [(0, 999), (0, 499), (500, 999)] assert is_palindrome_substring(S, queries) == [\\"Yes\\", \\"Yes\\", \\"Yes\\"] S = \\"a\\" * 499 + \\"b\\" + \\"a\\" * 500 queries = [(0, 999), (499, 499)] assert is_palindrome_substring(S, queries) == [\\"No\\", \\"Yes\\"]","solution":"def is_palindrome_substring(S, queries): Given a string S and a list of queries represented as tuples (l, r), determines if the substring S[l:r+1] is a palindrome. Args: S (str): The input string. queries (list): A list of tuples (l, r) where 0 <= l <= r < len(S) Returns: list: A list of \\"Yes\\" or \\"No\\" for each query indicating if the substring is a palindrome. results = [] for l, r in queries: substring = S[l:r+1] if substring == substring[::-1]: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def min_sum_of_sequences(sequences: List[List[int]]) -> int: Given a list of sequences, each consisting of M positive integers, returns the minimum possible sum of one integer from each sequence. >>> min_sum_of_sequences([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 12 >>> min_sum_of_sequences([[10, 12, 15, 17], [20, 22, 24, 26]]) 30 >>> min_sum_of_sequences([[1, 1000, 10000], [2, 3, 4], [5, 6, 7]]) 8 >>> min_sum_of_sequences([[1]]) 1 >>> min_sum_of_sequences([[1, 2], [3, 4], [5, 6]]) 9","solution":"def min_sum_of_sequences(sequences): Given a list of sequences, each consisting of M positive integers, returns the minimum possible sum of one integer from each sequence. Args: sequences (list of list of int): The list of sequences Returns: int: The minimum possible sum return sum(min(sequence) for sequence in sequences)"},{"question":"def sum_of_pascals_triangle_row(n: int) -> int: Returns the sum of the elements of the n-th row of Pascal's Triangle. >>> sum_of_pascals_triangle_row(0) 1 >>> sum_of_pascals_triangle_row(1) 2 >>> sum_of_pascals_triangle_row(2) 4 >>> sum_of_pascals_triangle_row(3) 8 >>> sum_of_pascals_triangle_row(4) 16 >>> sum_of_pascals_triangle_row(5) 32 >>> sum_of_pascals_triangle_row(10) 1024 >>> sum_of_pascals_triangle_row(20) 1048576","solution":"def sum_of_pascals_triangle_row(n): Returns the sum of the elements of the n-th row of Pascal's Triangle. return 2**n"},{"question":"def final_station(T: int, cases: List[Tuple[int, int, List[int]]]) -> List[str]: Determine the final station a train stops at, given the starting station and a series of movements. Args: T (int): Number of test cases. cases (List[Tuple[int, int, List[int]]]): Each test case consists of a starting station (int), number of movements (int), and a list of movements (List[int]). Returns: List[str]: For each test case, the final station or \\"Invalid Station\\" if the station sequence becomes invalid. >>> final_station(3, [(5, 3, [2, -4, 3]), (1, 2, [-1, -2]), (7, 4, [1, 2, -3, 4])]) ['6', 'Invalid Station', '11'] >>> final_station(1, [(2, 1, [-3])]) ['Invalid Station'] >>> final_station(1, [(10, 0, [])]) ['10']","solution":"def final_station(T, cases): results = [] for case in cases: S, M, movements = case final = S for move in movements: final += move if final < 1: results.append(\\"Invalid Station\\") break else: results.append(str(final)) return results # Example usage to run solution: T = 3 cases = [ (5, 3, [2, -4, 3]), (1, 2, [-1, -2]), (7, 4, [1, 2, -3, 4]) ] print(final_station(T, cases)) # Output: ['6', 'Invalid Station', '11']"},{"question":"def has_hamiltonian_path(n: int, m: int, s: int, t: int, edges: List[Tuple[int, int]]) -> str: Given a directed graph with n nodes and m edges, determine whether there exists a Hamiltonian Path from node s to node t. A Hamiltonian Path is a path in a directed graph that visits each vertex exactly once. Parameters: n (int): number of nodes m (int): number of edges s (int): starting node t (int): ending node edges (List[Tuple[int, int]]): list of directed edges Returns: str: \\"YES\\" if there exists a Hamiltonian path from node s to node t, otherwise \\"NO\\". Examples: >>> has_hamiltonian_path(4, 5, 1, 4, [(1, 2), (2, 3), (3, 4), (1, 3), (4, 3)]) \\"YES\\" >>> has_hamiltonian_path(4, 3, 1, 4, [(1, 2), (2, 3), (4, 1)]) \\"NO\\"","solution":"import itertools def has_hamiltonian_path(n, m, s, t, edges): def is_hamiltonian_path(path): if path[0] != s or path[-1] != t: return False for i in range(len(path) - 1): if (path[i], path[i + 1]) not in edge_set: return False return True nodes = [i + 1 for i in range(n)] edge_set = set(edges) for perm in itertools.permutations(nodes): if is_hamiltonian_path(perm): return \\"YES\\" return \\"NO\\""},{"question":"def checkIfPangram(s: str) -> str: Returns \\"Yes\\" if the string contains all letters from A to Z at least once, otherwise returns \\"No\\". >>> checkIfPangram(\\"THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG\\") 'Yes' >>> checkIfPangram(\\"HELLO\\") 'No' >>> checkIfPangram(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") 'Yes' >>> checkIfPangram(\\"AABCCDEFGHIJKLMNNOOPQRSTUVWXYZ\\") 'Yes' >>> checkIfPangram(\\"\\") 'No' >>> checkIfPangram(\\"A\\") 'No' >>> checkIfPangram(\\"THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG1234567890!@#%^&*()\\") 'Yes' >>> checkIfPangram(\\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\") 'Yes'","solution":"def checkIfPangram(s): Returns \\"Yes\\" if the string contains all letters from A to Z at least once, otherwise returns \\"No\\". # Create a set of all uppercase English letters all_letters = set(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") # Create a set of the unique characters in the string s unique_chars_in_s = set(s) # Check if all_letters is a subset of unique_chars_in_s if all_letters.issubset(unique_chars_in_s): return \\"Yes\\" else: return \\"No\\""},{"question":"def count_divisors(x: int) -> int: Returns the number of distinct divisors of x. <function implementation here> def custom_sort(arr: List[int]) -> List[int]: Custom sort based on the count of divisors. <function implementation here> def sort_index_cards(n: int, cards: List[int]) -> List[int]: Sorts the index cards based on the custom sort algorithm. Args: n : int : number of index cards. cards : list of int : the integers written on the index cards. Returns: list of int : the integers sorted based on the custom sort algorithm. Examples: >>> sort_index_cards(5, [2, 3, 4, 6, 5]) [2, 3, 5, 4, 6] >>> sort_index_cards(4, [12, 15, 10, 8]) [8, 10, 15, 12] <function implementation here>","solution":"def count_divisors(x): Returns the number of distinct divisors of x. count = 0 for i in range(1, int(x ** 0.5) + 1): if x % i == 0: count += 1 if i != x // i: count += 1 return count def custom_sort(arr): Custom sort based on the count of divisors. return sorted(arr, key=lambda x: (count_divisors(x), x)) def sort_index_cards(n, cards): Sorts the index cards based on the custom sort algorithm. return custom_sort(cards)"},{"question":"def max_coins(N, M, grid): Returns the maximum number of coins a player can collect from (0,0) to (N-1,M-1) in a given grid. >>> max_coins(3, 4, [[1, 0, 0, 1], [0, 1, 0, 0], [1, 0, 0, 1]]) 3 >>> max_coins(2, 3, [[1, 1, 1], [0, 1, 1]]) 4 >>> max_coins(1, 1, [[0]]) 0 >>> max_coins(4, 4, [[1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 1], [1, 1, 1, 1]]) 5 >>> max_coins(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 5","solution":"def max_coins(N, M, grid): Returns the maximum number of coins a player can collect from (0,0) to (N-1,M-1) in a given grid. # Initialize a dp array with zeros dp = [[0] * M for _ in range(N)] # Base case: starting position dp[0][0] = grid[0][0] # Fill the dp array for i in range(N): for j in range(M): if i > 0: dp[i][j] = max(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0: dp[i][j] = max(dp[i][j], dp[i][j-1] + grid[i][j]) return dp[N-1][M-1]"},{"question":"import re def is_valid_ticket_code(ticket_code: str) -> str: Returns 'VALID' if the ticket code follows the rules, otherwise 'INVALID'. Rules: - Starts with either 'FST' or 'SND' - Followed by exactly 5 digits - No special characters or letters other than 'FST' and 'SND' are allowed >>> is_valid_ticket_code(\\"FST12345\\") 'VALID' >>> is_valid_ticket_code(\\"SND54321\\") 'VALID' >>> is_valid_ticket_code(\\"FST12A34\\") 'INVALID' >>> is_valid_ticket_code(\\"THIRD1234\\") 'INVALID'","solution":"import re def is_valid_ticket_code(ticket_code): Returns 'VALID' if the ticket code follows the rules, otherwise 'INVALID'. Rules: - Starts with either 'FST' or 'SND' - Followed by exactly 5 digits - No special characters or letters other than 'FST' and 'SND' are allowed if re.match(r'^(FST|SND)d{5}', ticket_code): return \\"VALID\\" else: return \\"INVALID\\""},{"question":"def findPairs(arr, target_sum): Finds all unique pairs in the list that add up to the target sum. Each pair is sorted in non-descending order and the list of pairs is sorted in non-descending order as well. :param arr: List of integers :param target_sum: Integer target sum :return: List of unique pairs that add up to the target sum Examples: >>> findPairs([1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 3], 10) [[1, 9], [2, 8], [3, 7], [4, 6]] >>> findPairs([3, 3, 4, 5, 7, 8], 11) [[3, 8], [4, 7]]","solution":"def findPairs(arr, target_sum): Finds all unique pairs in the list that add up to the target sum. Each pair is sorted in non-descending order and the list of pairs is sorted in non-descending order as well. :param arr: List of integers :param target_sum: Integer target sum :return: List of unique pairs that add up to the target sum # Sort the array and use two pointers to find the pairs arr.sort() left, right = 0, len(arr) - 1 result = set() # To ensure uniqueness of pairs while left < right: current_sum = arr[left] + arr[right] if current_sum == target_sum: result.add((arr[left], arr[right])) left += 1 right -= 1 elif current_sum < target_sum: left += 1 else: right -= 1 return [list(pair) for pair in sorted(result)]"},{"question":"def num_paths(n: int, m: int, grid: List[str]) -> int: Returns the number of distinct paths Maria can take to reach from the top-left corner to the bottom-right corner of the grid. >>> num_paths(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> num_paths(2, 2, [\\".#\\", \\"#.\\"]) 0 pass # Example unit tests def test_num_paths_case_1(): n, m = 3, 3 grid = [ \\"...\\", \\".#.\\", \\"...\\" ] assert num_paths(n, m, grid) == 2 def test_num_paths_case_2(): n, m = 2, 2 grid = [ \\".#\\", \\"#.\\" ] assert num_paths(n, m, grid) == 0 def test_num_paths_case_3(): n, m = 1, 1 grid = [ \\".\\" ] assert num_paths(n, m, grid) == 1 def test_num_paths_case_4(): n, m = 3, 4 grid = [ \\"...#\\", \\"..#.\\", \\"....\\" ] assert num_paths(n, m, grid) == 3 def test_num_paths_case_5(): n, m = 3, 3 grid = [ \\"#\\", \\"#\\", \\"#\\" ] assert num_paths(n, m, grid) == 0","solution":"def num_paths(n, m, grid): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0 for _ in range(m)] for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1] # Helper function to read input values def read_input(): n, m = map(int, input().strip().split()) grid = [input().strip() for _ in range(n)] return n, m, grid"},{"question":"def max_strongest_sword(k: int, swordsmiths: List[List[int]]) -> int: Find the maximum strength sword among the strongest swords of each swordsmith. >>> max_strongest_sword(3, [[1, 3, 5, 7], [4, 6, 8], [2, 3, 9, 15, 20]]) == 20 >>> max_strongest_sword(2, [[2, 8, 12], [1, 10]]) == 12","solution":"def max_strongest_sword(k, swordsmiths): max_strength = 0 for swords in swordsmiths: max_strength = max(max_strength, swords[-1]) # Only compare the last (strongest) sword return max_strength"},{"question":"from typing import List, Counter def max_distinct_palindromic_substrings(S: str) -> int: Returns the maximum number of distinct palindromic substrings that can be obtained by rearranging the letters of S. >>> max_distinct_palindromic_substrings(\\"aabb\\") 4 >>> max_distinct_palindromic_substrings(\\"abc\\") 3 >>> max_distinct_palindromic_substrings(\\"aaa\\") 3 >>> max_distinct_palindromic_substrings(\\"abacaba\\") 7 # Unit Tests def test_palindromic_substrings_basic_cases(): assert max_distinct_palindromic_substrings(\\"aabb\\") == 4 assert max_distinct_palindromic_substrings(\\"abc\\") == 3 assert max_distinct_palindromic_substrings(\\"aaa\\") == 3 assert max_distinct_palindromic_substrings(\\"abacaba\\") == 7 def test_palindromic_substrings_edge_cases(): assert max_distinct_palindromic_substrings(\\"a\\") == 1 assert max_distinct_palindromic_substrings(\\"bb\\") == 2 assert max_distinct_palindromic_substrings(\\"\\") == 0 def test_palindromic_substrings_large_cases(): assert max_distinct_palindromic_substrings(\\"abcd\\" * 50000) == 200000 # Large input with same characters assert max_distinct_palindromic_substrings(\\"a\\" * 200000) == 200000 # Large input with two different characters assert max_distinct_palindromic_substrings(\\"ab\\" * 100000) == 200000","solution":"from collections import Counter def max_distinct_palindromic_substrings(S): Returns the maximum number of distinct palindromic substrings that can be obtained by rearranging the letters of S. char_freq = Counter(S) odd_count = sum(1 for freq in char_freq.values() if freq % 2 == 1) # If there are odd frequencies, all characters can form unique single-character palindromes total_distinct_palindromes = len(S) return total_distinct_palindromes"},{"question":"from typing import List def can_be_made_palindrome(s: str) -> bool: Determines if string \`s\` can be made into a palindrome by removing at most one character. >>> can_be_made_palindrome(\\"abca\\") True >>> can_be_made_palindrome(\\"racecar\\") True >>> can_be_made_palindrome(\\"abcdef\\") False pass def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Processes multiple test cases and returns the results for each case. >>> process_test_cases(3, [\\"abca\\", \\"racecar\\", \\"abcdef\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_test_cases(4, [\\"a\\", \\"abcba\\", \\"abcbda\\", \\"abcdefgh\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] pass","solution":"def can_be_made_palindrome(s): Determines if string \`s\` can be made into a palindrome by removing at most one character. def is_palindrome_range(start, end): while start < end: if s[start] != s[end]: return False start += 1 end -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True def process_test_cases(t, test_cases): results = [] for s in test_cases: if can_be_made_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def determine_winner(T: int, games: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Determine the winner for each game based on the rounds results. The function takes the number of games and a list of tuples containing the number of rounds and the rounds results. >>> determine_winner(3, [ ... (3, [(5, 3), (4, 6), (3, 3)]), ... (2, [(7, 7), (8, 2)]), ... (4, [(1, 6), (3, 3), (8, 1), (4, 4)]) ... ]) == [0, 1, 0]","solution":"def determine_winner(T, games): results = [] for i in range(T): N = games[i][0] rounds = games[i][1] player1_wins = 0 player2_wins = 0 draws = 0 for round in rounds: if round[0] > round[1]: player1_wins += 1 elif round[0] < round[1]: player2_wins += 1 else: draws += 1 if player1_wins > player2_wins: results.append(1) elif player1_wins < player2_wins: results.append(2) else: results.append(0) return results"},{"question":"def max_winning_challenges(M: int, D1: int, D2: int, scores: List[int]) -> int: Calculate the maximum number of winning challengers where either the absolute difference condition or exact difference condition holds true. Args: M (int): Number of people. D1 (int): Absolute difference threshold. D2 (int): Exact difference threshold. scores (List[int]): List of scores. Returns: int: Maximum number of winning challengers. Examples: >>> max_winning_challenges(6, 3, 5, [10, 7, 12, 15, 3, 25]) 3 >>> max_winning_challenges(8, 2, 4, [8, 6, 7, 9, 11, 13, 10, 15]) 5 # Your code here if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def max_winning_challenges(M, D1, D2, scores): Calculate the maximum number of winning challengers where either the absolute difference condition or exact difference condition holds true. win_count = 0 for i in range(M - 1): diff = abs(scores[i] - scores[i + 1]) if diff <= D1 or diff == D2: win_count += 1 return win_count"},{"question":"def max_books(n: int, k: int, pages: List[int]) -> int: Determine the maximum number of books Peter can place on the shelf such that the sum of pages of any contiguous subset of those books is divisible by k. >>> max_books(5, 3, [4, 3, 6, 3, 4]) 3 >>> max_books(7, 5, [5, 10, 15, 1, 1, 1, 1]) 3 >>> max_books(4, 2, [2, 4, 6, 8]) 4 >>> max_books(4, 5, [1, 1, 1, 1]) 0 >>> max_books(6, 7, [2, 3, 7, 4, 10, 13]) 3 >>> max_books(1, 1, [1]) 1 >>> max_books(1, 2, [5]) 0 >>> max_books(3, 10**9, [10**9, 10**9, 10**9]) 3","solution":"def max_books(n, k, pages): remainder_map = {0: -1} # maps remainder to its first occurrence index running_sum = 0 max_length = 0 for i in range(n): running_sum += pages[i] remainder = running_sum % k if remainder in remainder_map: max_length = max(max_length, i - remainder_map[remainder]) else: remainder_map[remainder] = i return max_length"},{"question":"def most_frequent_char(s: str) -> str: Given a string of lowercase alphabets, find the character that appears most frequently. If there are multiple characters that appear with the same maximum frequency, return the character that comes first in the alphabetical order. >>> most_frequent_char(\\"abaccabc\\") 'a' >>> most_frequent_char(\\"xyz\\") 'x'","solution":"def most_frequent_char(s: str) -> str: from collections import Counter char_count = Counter(s) max_freq = max(char_count.values()) # Get all characters with the maximum frequency max_freq_chars = [char for char, freq in char_count.items() if freq == max_freq] # Return the lexicographically smallest character among them return min(max_freq_chars)"},{"question":"def predict_out_of_stock_day(daily_sales, current_stock): Predict the day on which the product will run out of stock. Parameters: daily_sales (list of int): The daily sales of the product. current_stock (int): The current stock level of the product. Returns: int: The day on which the product is predicted to run out of stock, or -1 if stock is sufficient. >>> predict_out_of_stock_day([2, 3, 1, 5, 6], 10) 4 >>> predict_out_of_stock_day([1, 2, 3], 15) -1 >>> predict_out_of_stock_day([5, 5, 5, 5], 15) 4 >>> predict_out_of_stock_day([10], 9) 1 >>> predict_out_of_stock_day([1], 2) -1 >>> predict_out_of_stock_day([3, 3, 3], 9) -1 >>> predict_out_of_stock_day([3, 3, 3], 8) 3 >>> predict_out_of_stock_day([1, 1, 1, 1, 1], 5) -1 >>> predict_out_of_stock_day([2, 1], 1) 1 >>> predict_out_of_stock_day([1], 1) -1 >>> predict_out_of_stock_day([1], 0) 1 >>> predict_out_of_stock_day([100], 100) -1 >>> predict_out_of_stock_day([100], 99) 1 pass","solution":"def predict_out_of_stock_day(daily_sales, current_stock): Predict the day on which the product will run out of stock. Parameters: daily_sales (list of int): The daily sales of the product. current_stock (int): The current stock level of the product. Returns: int: The day on which the product is predicted to run out of stock, or -1 if stock is sufficient. for day, sales in enumerate(daily_sales): current_stock -= sales if current_stock < 0: return day + 1 return -1"},{"question":"def calculate_average_and_grade(data): Calculates the average and grade for each student based on their scores. Parameters: data (list of str): Input data where each element is a string containing a student's name followed by their scores. Returns: list of str: List containing results, each formatted as \\"name average grade\\". >>> calculate_average_and_grade([\\"John 85 90 78\\"]) [\\"John 84.33 B\\"] >>> calculate_average_and_grade([\\"Lucy 100 95 90 89 91\\"]) [\\"Lucy 93.00 A\\"] >>> calculate_average_and_grade([\\"Mark\\"]) [\\"Mark 0.00 F\\"] >>> calculate_average_and_grade([\\"Alice 70 68 72 65\\"]) [\\"Alice 68.75 D\\"] >>> calculate_average_and_grade([\\"Henry 88 92 81 75\\"]) [\\"Henry 84.00 B\\"]","solution":"def calculate_average_and_grade(data): Calculates the average and grade for each student. Parameters: data (list of str): Input data where each element is a string containing a student's name followed by their scores. Returns: list of str: List containing results, each formatted as \\"name average grade\\". results = [] for entry in data: parts = entry.split() name = parts[0] scores = list(map(int, parts[1:])) if scores: average = sum(scores) / len(scores) else: average = 0.0 if average >= 90: grade = 'A' elif average >= 80: grade = 'B' elif average >= 70: grade = 'C' elif average >= 60: grade = 'D' else: grade = 'F' results.append(f\\"{name} {average:.2f} {grade}\\") return results # Example usage: data_input = [ \\"John 85 90 78\\", \\"Lucy 100 95 90 89 91\\", \\"Mark\\", \\"Alice 70 68 72 65\\", \\"Henry 88 92 81 75\\" ] for result in calculate_average_and_grade(data_input): print(result)"},{"question":"def count_strings(n: int, S: int, k: int, scores: List[int]) -> int: Compute the number of possible strings of length n which sum up to exactly S using the given scores. >>> count_strings(2, 3, 3, [1, 2, 3]) 2 >>> count_strings(3, 6, 2, [1, 2]) 1","solution":"MOD = 1000000007 def count_strings(n, S, k, scores): dp = [[0] * (S + 1) for _ in range(n + 1)] dp[0][0] = 1 for i in range(1, n + 1): for j in range(S + 1): dp[i][j] = 0 for score in scores: if j >= score: dp[i][j] = (dp[i][j] + dp[i - 1][j - score]) % MOD return dp[n][S]"},{"question":"def cyclic_shift(s: str, n: int) -> str: Define a method that accepts a string and an integer as parameters. The method should return a new string where the characters are cyclically shifted to the right by the number specified by the integer. If the integer is positive, the characters should be shifted to the right. If the integer is negative, the characters should be shifted to the left. The number of shifts can exceed the length of the string, so cyclic behavior needs to be maintained. >>> cyclic_shift(\\"abcdef\\", 2) == \\"efabcd\\" >>> cyclic_shift(\\"helloworld\\", 3) == \\"rldhellowo\\" >>> cyclic_shift(\\"python\\", 5) == \\"npytho\\" from solution import cyclic_shift def test_cyclic_shift_positive_shift(): assert cyclic_shift(\\"abcdef\\", 2) == \\"efabcd\\" assert cyclic_shift(\\"helloworld\\", 3) == \\"rldhellowo\\" def test_cyclic_shift_negative_shift(): assert cyclic_shift(\\"abcdef\\", -2) == \\"cdefab\\" assert cyclic_shift(\\"helloworld\\", -3) == \\"loworldhel\\" def test_cyclic_shift_large_shift(): # Shift is larger than string length assert cyclic_shift(\\"abcdef\\", 8) == \\"efabcd\\" # Equivalent to shifting by 2 assert cyclic_shift(\\"abcdef\\", -8) == \\"cdefab\\" # Equivalent to shifting by -2 def test_cyclic_shift_zero_shift(): assert cyclic_shift(\\"abcdef\\", 0) == \\"abcdef\\" def test_cyclic_shift_shift_equals_length(): # Shifting by the length of the string returns the same string assert cyclic_shift(\\"abcdef\\", 6) == \\"abcdef\\" assert cyclic_shift(\\"abcdef\\", -6) == \\"abcdef\\" def test_cyclic_shift_empty_string(): assert cyclic_shift(\\"\\", 3) == \\"\\"","solution":"def cyclic_shift(s, n): Returns string s with characters cyclically shifted to the right by n positions. If n is negative, shifts to the left. length = len(s) if length == 0: return s n = n % length # Ensure n is within the bounds of the string length return s[-n:] + s[:-n]"},{"question":"def longest_unique_substring(s: str) -> str: Returns the longest substring with unique characters. If there are multiple longest substrings with the same length, returns the first one found. >>> longest_unique_substring(\\"abcabcbb\\") == \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") == \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") == \\"wke\\" >>> longest_unique_substring(\\"abcdefgh\\") == \\"abcdefgh\\" >>> longest_unique_substring(\\"aab\\") == \\"ab\\" >>> longest_unique_substring(\\"\\") == \\"\\" >>> longest_unique_substring(\\"dvdf\\") == \\"vdf\\" >>> longest_unique_substring(\\"a\\") == \\"a\\" >>> longest_unique_substring(\\"aaac\\") == \\"ac\\"","solution":"def longest_unique_substring(s): Returns the longest substring with unique characters. If there are multiple longest substrings with the same length, returns the first one found. start = 0 max_len = 0 max_substr = \\"\\" used_chars = {} for end in range(len(s)): if s[end] in used_chars and used_chars[s[end]] >= start: start = used_chars[s[end]] + 1 used_chars[s[end]] = end unique_length = end - start + 1 if unique_length > max_len: max_len = unique_length max_substr = s[start:end + 1] return max_substr"},{"question":"def rgb_to_hex(r, g, b): Convert an RGB color to a hexadecimal color code. Parameters: - r: Red component (0 <= r <= 255) - g: Green component (0 <= g <= 255) - b: Blue component (0 <= b <= 255) Returns: A string representing the hexadecimal color code in the format \\"#RRGGBB\\". Examples: >>> rgb_to_hex(255, 0, 255) # \\"#FF00FF\\" >>> rgb_to_hex(0, 255, 0) # \\"#00FF00\\" >>> rgb_to_hex(0, 0, 255) # \\"#0000FF\\" >>> rgb_to_hex(16, 32, 48) # \\"#102030\\" # your code here","solution":"def rgb_to_hex(r, g, b): Convert an RGB color to a hexadecimal color code. Parameters: - r: Red component (0 <= r <= 255) - g: Green component (0 <= g <= 255) - b: Blue component (0 <= b <= 255) Returns: A string representing the hexadecimal color code in the format \\"#RRGGBB\\". return \\"#{:02X}{:02X}{:02X}\\".format(r, g, b)"},{"question":"def gcd(a: int, b: int) -> int: Compute the Greatest Common Divisor of a and b. def euler_totient(n: int) -> int: Compute Euler's Totient Function φ(n), which counts the number of positive integers up to n that are relatively prime to n. >>> euler_totient(1) == 1 >>> euler_totient(2) == 1 >>> euler_totient(3) == 2 >>> euler_totient(4) == 2 >>> euler_totient(5) == 4 >>> euler_totient(10) == 4 >>> euler_totient(12) == 4 >>> euler_totient(13) == 12 >>> euler_totient(17) == 16 >>> euler_totient(19) == 18 >>> euler_totient(8) == 4 >>> euler_totient(16) == 8 >>> euler_totient(60) == 16 >>> euler_totient(100) == 40 >>> euler_totient(500) == 200","solution":"def gcd(a, b): Compute the Greatest Common Divisor of a and b. while b: a, b = b, a % b return a def euler_totient(n): Compute Euler's Totient Function φ(n). if n == 1: return 1 count = 0 for i in range(1, n + 1): if gcd(n, i) == 1: count += 1 return count"},{"question":"from typing import List def shortest_path(grid: List[str], start_x: int, start_y: int, dest_x: int, dest_y: int) -> int: Given a grid of cells with '0' representing empty space and '1' representing buildings, find the shortest path from the start cell to the destination cell. Args: grid (List[str]): The city grid. start_x (int): Starting cell x-coordinate. start_y (int): Starting cell y-coordinate. dest_x (int): Destination cell x-coordinate. dest_y (int): Destination cell y-coordinate. Returns: int: Length of the shortest path or -1 if no path exists. Examples: >>> grid = [\\"01000\\", \\"01011\\", \\"00000\\", \\"11110\\", \\"11111\\"] >>> shortest_path(grid, 0, 0, 4, 4) == -1 >>> grid = [\\"000\\", \\"010\\", \\"000\\"] >>> shortest_path(grid, 0, 0, 2, 2) == 4 >>> grid = [\\"00\\", \\"00\\"] >>> shortest_path(grid, 0, 0, 1, 1) == 2 pass # Your code here def test_shortest_path(): grid1 = [ \\"01000\\", \\"01011\\", \\"00000\\", \\"11110\\", \\"11111\\" ] assert shortest_path(grid1, 0, 0, 4, 4) == -1 grid2 = [ \\"000\\", \\"010\\", \\"000\\" ] assert shortest_path(grid2, 0, 0, 2, 2) == 4 grid3 = [ \\"00\\", \\"00\\" ] assert shortest_path(grid3, 0, 0, 1, 1) == 2 grid4 = [ \\"0000\\", \\"0100\\", \\"0000\\", \\"0010\\" ] assert shortest_path(grid4, 0, 0, 3, 3) == 6 grid5 = [ \\"0\\" ] assert shortest_path(grid5, 0, 0, 0, 0) == 0 grid6 = [ \\"01\\", \\"10\\" ] assert shortest_path(grid6, 0, 0, 1, 1) == -1 def test_large_grid_with_no_path(): grid = [\\"1\\" * 1000 for _ in range(1000)] grid = [list(row) for row in grid] grid[0][0] = '0' grid[999][999] = '0' assert shortest_path(grid, 0, 0, 999, 999) == -1 def test_large_grid_with_long_path(): grid = [\\"0\\" * 1000 for _ in range(1000)] grid = [list(row) for row in grid] assert shortest_path(grid, 0, 0, 999, 999) == 1998","solution":"from collections import deque def shortest_path(grid, start_x, start_y, dest_x, dest_y): n, m = len(grid), len(grid[0]) if grid[start_x][start_y] == '1' or grid[dest_x][dest_y] == '1': return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(start_x, start_y, 0)]) visited = set((start_x, start_y)) while queue: x, y, dist = queue.popleft() if x == dest_x and y == dest_y: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '0': queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"class URLShortener: def __init__(self): pass def shorten(self, long_url): Shortens a long URL to a unique short URL. Args: long_url (str): The long URL to shorten. Returns: str: The shortened URL. pass def retrieve(self, short_url): Retrieves the original long URL from a short URL. Args: short_url (str): The short URL to retrieve the original URL for. Returns: str: The original long URL if found, None otherwise. pass def process_operations(operations): Processes a list of shorten and retrieve operations. Args: operations (list of tuple): List of operations and URLs. Returns: list: Results of the operations. Example: >>> operations = [ >>> (\\"shorten\\", \\"https://www.example.com\\"), >>> (\\"shorten\\", \\"https://medium.com/@someone/some-article\\"), >>> (\\"retrieve\\", \\"1\\"), >>> (\\"shorten\\", \\"https://www.example.com\\"), >>> (\\"retrieve\\", \\"2\\") >>> ] >>> process_operations(operations) ['1', '2', \\"https://www.example.com\\", '1', \\"https://medium.com/@someone/some-article\\"] pass","solution":"class URLShortener: def __init__(self): self.long_to_short = {} self.short_to_long = {} self.next_id = 1 def shorten(self, long_url): if long_url in self.long_to_short: return self.long_to_short[long_url] short_url = str(self.next_id) self.long_to_short[long_url] = short_url self.short_to_long[short_url] = long_url self.next_id += 1 return short_url def retrieve(self, short_url): if short_url in self.short_to_long: return self.short_to_long[short_url] return None def process_operations(operations): url_shortener = URLShortener() results = [] for op, url in operations: if op == \\"shorten\\": results.append(url_shortener.shorten(url)) elif op == \\"retrieve\\": results.append(url_shortener.retrieve(url)) return results"},{"question":"def max_friends_participate(T: int, test_cases: List[Tuple[int, int, int]]) -> List[int]: Find the maximum number of friends that can participate in the trip given the number of friends, number of cars, and seating capacity of each car. >>> max_friends_participate(3, [(10, 2, 6), (13, 3, 5), (5, 1, 5)]) [10, 13, 5] >>> max_friends_participate(2, [(15, 2, 5), (20, 4, 4)]) [10, 16]","solution":"def max_friends_participate(T, test_cases): result = [] for i in range(T): F, C, S = test_cases[i] max_possible_friends = C * S if max_possible_friends >= F: result.append(F) else: result.append(max_possible_friends) return result"},{"question":"def compressString(s): Compress a string by replacing consecutive repeating characters with the character followed by the number of repetitions. If the input string contains any non-alphabetic characters, return 'Only alphabetic characters allowed'. If the input is not a string, return 'Input is not a string'. An empty string should return an empty string. >>> compressString(\\"aaabbc\\") == \\"a3b2c1\\" >>> compressString(\\"abcd\\") == \\"a1b1c1d1\\" >>> compressString(\\"a2b2\\") == \\"Only alphabetic characters allowed\\" >>> compressString(12345) == \\"Input is not a string\\" >>> compressString(\\"\\") == \\"\\" >>> compressString(\\"aaabbbcccddd\\") == \\"a3b3c3d3\\" >>> compressString(\\"a\\") == \\"a1\\" >>> compressString(\\"bbbb\\") == \\"b4\\" from solution import compressString def test_regular_case(): assert compressString(\\"aaabbc\\") == \\"a3b2c1\\" assert compressString(\\"abcd\\") == \\"a1b1c1d1\\" def test_with_non_alphabetic_characters(): assert compressString(\\"a2b2\\") == \\"Only alphabetic characters allowed\\" def test_non_string_input(): assert compressString(12345) == \\"Input is not a string\\" def test_empty_string(): assert compressString(\\"\\") == \\"\\" def test_mixed_consistent_repetition(): assert compressString(\\"aaabbbcccddd\\") == \\"a3b3c3d3\\" def test_single_character_string(): assert compressString(\\"a\\") == \\"a1\\" assert compressString(\\"bbbb\\") == \\"b4\\"","solution":"def compressString(s): if not isinstance(s, str): return 'Input is not a string' if any(not c.isalpha() for c in s): return 'Only alphabetic characters allowed' if s == \\"\\": return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(s[i-1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) return ''.join(compressed)"},{"question":"def max_non_overlapping_segments(segments): Given a list of segments, this function returns the maximum number of non-overlapping segments. Args: segments (List[Tuple[int, int]]): List of tuples where each tuple represents a segment with start and end points. Returns: int: Maximum number of non-overlapping segments. pass def process_test_cases(test_cases): Process multiple test cases to determine the maximum number of non-overlapping segments for each. Args: test_cases (List[List[Tuple[int, int]]]): List of test cases, where each test case is a list of segments. Returns: List[int]: List of results corresponding to each test case. >>> process_test_cases([[(1, 3), (2, 5), (4, 6)], [(7, 9), (1, 5), (3, 4), (2, 8)], [(5, 5), (1, 2)]]) [2, 2, 2] >>> process_test_cases([[(1, 4), (2, 5), (3, 6), (4, 7)]]) [1] >>> process_test_cases([[(1, 2), (3, 4), (5, 6)]]) [3] >>> process_test_cases([[(1, 10)]]) [1] >>> process_test_cases([[(1, 2), (4, 5), (10, 11), (15, 20), (23, 24)]]) [5] >>> process_test_cases([[(1, 3), (3, 5), (4, 6), (5, 7), (6, 8), (7, 9)]]) [3] pass","solution":"def max_non_overlapping_segments(segments): Given a list of segments, this function returns the maximum number of non-overlapping segments. # Sort segments by their end points (R_i) segments.sort(key=lambda x: x[1]) count = 0 last_end = -1 for start, end in segments: if start > last_end: count += 1 last_end = end return count def process_test_cases(test_cases): results = [] for segments in test_cases: results.append(max_non_overlapping_segments(segments)) return results"},{"question":"def encrypt(text: str) -> str: Transforms a given string into a sequence of alphanumeric codes based on a simple encryption scheme. Parameters: text (string): The input string to be encrypted. Returns: string: The encrypted string where each letter is replaced with its position in the alphabet, digits are retained, and other characters are ignored. Examples: >>> encrypt(\\"hello\\") '8_5_12_12_15' >>> encrypt(\\"HELLO\\") '8_5_12_12_15' >>> encrypt(\\"Secure123\\") '19_5_3_21_18_5_1_2_3' >>> encrypt(\\"Python\\") '16_25_20_8_15_14' >>> encrypt(\\"\\") '' >>> encrypt(\\"crypto!\\") '3_18_25_16_20_15'","solution":"def encrypt(text): Transforms a given string into a sequence of alphanumeric codes based on a simple encryption scheme. Parameters: text (string): The input string to be encrypted. Returns: string: The encrypted string where each letter is replaced with its position in the alphabet, digits are retained, and other characters are ignored. result = [] text = text.upper() for char in text: if char.isalpha(): # Check if character is an alphabet result.append(str(ord(char) - ord('A') + 1)) elif char.isdigit(): # Check if character is a digit result.append(char) return '_'.join(result)"},{"question":"def filter_by_length(strings, length): Filters and returns a list of strings that are strictly longer than the given length. :param strings: List of strings. :param length: An integer length to compare the string lengths against. :return: A new list with strings longer than the given length. >>> filter_by_length([\\"apple\\", \\"berry\\", \\"cherry\\", \\"date\\"], 5) [\\"cherry\\"] >>> filter_by_length([\\"apple\\", \\"berry\\", \\"cherry\\", \\"date\\"], 4) [\\"apple\\", \\"berry\\", \\"cherry\\"] >>> filter_by_length([\\"apple\\", \\"berry\\", \\"cherry\\", \\"date\\"], 6) [] >>> filter_by_length([], 4) [] >>> filter_by_length([\\"a\\", \\"ab\\", \\"abc\\"], 0) [\\"a\\", \\"ab\\", \\"abc\\"] >>> filter_by_length([\\"short\\", \\"muchlonger\\", \\"tiny\\", \\"lengthyword\\"], 4) [\\"short\\", \\"muchlonger\\", \\"lengthyword\\"]","solution":"def filter_by_length(strings, length): Filters and returns a list of strings that are strictly longer than the given length. :param strings: List of strings. :param length: An integer length to compare the string lengths against. :return: A new list with strings longer than the given length. return [string for string in strings if len(string) > length]"},{"question":"import heapq from typing import List def minimal_combination_cost(n: int, lengths: List[int]) -> int: Given a list of rope lengths, this function computes the minimal cost required to combine all ropes into one. Args: n (int): The number of ropes. lengths (List[int]): A list of integers representing the lengths of the ropes. Returns: int: The minimal cost required to combine all the ropes into one. Examples: >>> minimal_combination_cost(4, [4, 3, 2, 6]) 29 >>> minimal_combination_cost(3, [1, 2, 3]) 9","solution":"import heapq def minimal_combination_cost(n, lengths): Given a list of rope lengths, this function computes the minimal cost required to combine all ropes into one. if n == 1: return 0 heapq.heapify(lengths) total_cost = 0 while len(lengths) > 1: # Take the two shortest ropes first = heapq.heappop(lengths) second = heapq.heappop(lengths) # Combine them current_cost = first + second total_cost += current_cost # Add the combined rope back to the heap heapq.heappush(lengths, current_cost) return total_cost"},{"question":"def count_subsets_with_target_sum(N: int, factors: List[int], T: int) -> int: Count the number of distinct subsets where the sum of the carbon footprint factors equals the target value T. >>> count_subsets_with_target_sum(3, [2, 3, 5], 5) 2 >>> count_subsets_with_target_sum(3, [2, 3, 5], 1) 0 >>> count_subsets_with_target_sum(3, [2, 3, 100], 105) 1 >>> count_subsets_with_target_sum(4, [1, 1, 1, 1], 2) 6 >>> count_subsets_with_target_sum(1, [100], 100) 1 >>> count_subsets_with_target_sum(5, [2, 3, 7, 8, 10], 10) 3","solution":"def count_subsets_with_target_sum(N, factors, T): MOD = 1000000007 dp = [0] * (T + 1) dp[0] = 1 # There's one way to get sum 0, by choosing no appliances for factor in factors: for j in range(T, factor - 1, -1): dp[j] = (dp[j] + dp[j - factor]) % MOD return dp[T] # Example usage # N = 3 # factors = [2, 3, 5] # T = 5 # print(count_subsets_with_target_sum(N, factors, T)) # Output: 2"},{"question":"from typing import List def count_days_higher_steps(steps: List[int]) -> int: Returns the number of days in which the hiker climbed more steps than he did on the previous day. >>> count_days_higher_steps([2, 3, 1, 5, 4]) 2 >>> count_days_higher_steps([1, 2, 3, 4, 5]) 4 >>> count_days_higher_steps([5, 4, 3, 2, 1]) 0 >>> count_days_higher_steps([1, 2, 2, 3, 1, 0, 1]) 3 >>> count_days_higher_steps([0]) 0 >>> count_days_higher_steps([3, 3, 3, 3, 3]) 0 >>> count_days_higher_steps([1, 3, 2, 4, 3, 5, 6, 0, 7]) 5 >>> count_days_higher_steps([10, 5, 6, 3, 8, 6, 7, 10, 5, 7]) 5","solution":"from typing import List def count_days_higher_steps(steps: List[int]) -> int: Returns the number of days in which the hiker climbed more steps than he did on the previous day. count = 0 for i in range(1, len(steps)): if steps[i] > steps[i-1]: count += 1 return count"},{"question":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Given an array of integers representing histogram heights, find the maximum area of the largest rectangle that can be formed using contiguous histograms. :param heights: List[int] - a list of integers where each integer represents the height of a histogram with width 1. :return: int - the area of the largest rectangle that can be formed. >>> largestRectangleArea([6, 2, 5, 4, 5, 1, 6]) 12 >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 pass def solve_histogram_areas(test_cases: List[List[int]]) -> List[int]: Given multiple test cases of histogram heights, find the maximum area of the largest rectangle that can be formed for each test case. :param test_cases: List[List[int]] - a list where each element is a list of integers representing the heights of histograms for one test case. :return: List[int] - a list of integers where each integer is the area of the largest rectangle that can be formed for the corresponding test case. >>> solve_histogram_areas([[6, 2, 5, 4, 5, 1, 6], [2, 1, 5, 6, 2, 3]]) [12, 10] pass","solution":"def largestRectangleArea(heights): Returns the largest rectangle area in the histogram represented by heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def solve_histogram_areas(test_cases): results = [] for heights in test_cases: results.append(largestRectangleArea(heights)) return results"},{"question":"def generate_new_array(n, arr): Given an array of n positive integers, generates a new array where each element is the sum of the original element and its next consecutive element. The last element of the original array remains unchanged in the new array. :param n: Number of elements in the array :param arr: List of integers :return: A new list of integers as per the described rules >>> generate_new_array(5, [1, 2, 3, 4, 5]) [3, 5, 7, 9, 5] >>> generate_new_array(4, [10, 20, 30, 40]) [30, 50, 70, 40] >>> generate_new_array(1, [100]) [100] >>> generate_new_array(2, [1, 1]) [2, 1] >>> generate_new_array(3, [10**9, 10**9, 10**9]) [2000000000, 2000000000, 1000000000] >>> generate_new_array(6, [1, 2, 3, 10**9, 5, 8]) [3, 5, 1000000003, 1000000005, 13, 8]","solution":"def generate_new_array(n, arr): Given an array of n positive integers, generates a new array where each element is the sum of the original element and its next consecutive element. The last element of the original array remains unchanged in the new array. :param n: Number of elements in the array :param arr: List of integers :return: A new list of integers as per the described rules new_arr = [] for i in range(n): if i < n - 1: new_arr.append(arr[i] + arr[i+1]) else: new_arr.append(arr[i]) return new_arr"},{"question":"def schedule_matches(datasets): Schedule matches between players such that the difference in skill ratings between the players in each match is minimized. >>> schedule_matches([{'N': 6, 'skills': [5, 3, 2, 8, 6, 9]}, {'N': 4, 'skills': [10, 1, 3, 20]}]) [\\"(2, 3), (5, 6), (8, 9)\\", \\"(1, 3), (10, 20)\\"] >>> schedule_matches([{'N': 2, 'skills': [100, 200]}, {'N': 2, 'skills': [1, 2]}]) [\\"(100, 200)\\", \\"(1, 2)\\"] >>> schedule_matches([{'N': 4, 'skills': [4, 2, 3, 1]}]) [\\"(1, 2), (3, 4)\\"] pass def parse_input(input_data): Parse the input data into a list of datasets. >>> parse_input(\\"6n5 3 2 8 6 9n4n10 1 3 20n0n\\") [{'N': 6, 'skills': [5, 3, 2, 8, 6, 9]}, {'N': 4, 'skills': [10, 1, 3, 20]}] pass","solution":"def schedule_matches(datasets): results = [] def format_pairs(pairs): return \\", \\".join([f\\"({a}, {b})\\" for a, b in pairs]) for dataset in datasets: N = dataset['N'] skill_ratings = dataset['skills'] skill_ratings.sort() pairs = [] for i in range(0, N, 2): pairs.append((skill_ratings[i], skill_ratings[i + 1])) results.append(format_pairs(pairs)) return results def parse_input(input_data): datasets = [] lines = input_data.strip().split('n') i = 0 while i < len(lines): N = int(lines[i]) if N == 0: break skills = list(map(int, lines[i + 1].split())) datasets.append({\\"N\\": N, \\"skills\\": skills}) i += 2 return datasets"},{"question":"class AutoMart: AutoMart, a vehicle dealership, has a database for managing its inventory. Each vehicle is represented as an object containing the following properties: \`make\` (the manufacturer's name), \`model\` (the vehicle's model), \`year\` (the year it was made), and \`price\` (the cost of the vehicle). AutoMart records a vehicle when it is added to the inventory and removes it when it is sold. You are tasked with developing a system that will help AutoMart calculate the total value of vehicles currently in its inventory and determine the number of vehicles for a given make. Methods: add_vehicle(make: str, model: str, year: int, price: int) -> None: Adds a new vehicle to the inventory. remove_vehicle(make: str, model: str) -> bool: Removes a vehicle from the inventory. Returns True if the vehicle was successfully removed, or False if the vehicle was not found. inventory_value() -> int: Returns the total value of all vehicles currently in the inventory. count_by_make(make: str) -> int: Returns the number of vehicles of the specified make in the inventory. >>> automart = AutoMart() >>> automart.add_vehicle(\\"Toyota\\", \\"Corolla\\", 2018, 15000) >>> automart.add_vehicle(\\"Honda\\", \\"Civic\\", 2020, 20000) >>> automart.add_vehicle(\\"Toyota\\", \\"Camry\\", 2019, 18000) >>> print(automart.inventory_value()) # Output: 53000 >>> print(automart.count_by_make(\\"Toyota\\")) # Output: 2 >>> print(automart.remove_vehicle(\\"Honda\\", \\"Civic\\")) # Output: True >>> print(automart.inventory_value()) # Output: 33000 >>> print(automart.count_by_make(\\"Honda\\")) # Output: 0 >>> print(automart.remove_vehicle(\\"Honda\\", \\"Accord\\")) # Output: False def add_vehicle(self, make: str, model: str, year: int, price: int) -> None: pass def remove_vehicle(self, make: str, model: str) -> bool: pass def inventory_value(self) -> int: pass def count_by_make(self, make: str) -> int: pass","solution":"class Vehicle: def __init__(self, make, model, year, price): self.make = make self.model = model self.year = year self.price = price class AutoMart: def __init__(self): self.inventory = [] def add_vehicle(self, make: str, model: str, year: int, price: int) -> None: self.inventory.append(Vehicle(make, model, year, price)) def remove_vehicle(self, make: str, model: str) -> bool: for i, vehicle in enumerate(self.inventory): if vehicle.make == make and vehicle.model == model: del self.inventory[i] return True return False def inventory_value(self) -> int: return sum(vehicle.price for vehicle in self.inventory) def count_by_make(self, make: str) -> int: return sum(1 for vehicle in self.inventory if vehicle.make == make)"},{"question":"def longest_common_prefix(strs): Returns the longest common prefix from a list of strings. If no common prefix exists, returns an empty string. Parameters: strs (List[str]): The list of strings to find the common prefix Returns: str: The longest common prefix Examples: >>> longest_common_prefix([\\"flower\\",\\"flow\\",\\"flight\\"]) 'fl' >>> longest_common_prefix([\\"dog\\",\\"racecar\\",\\"car\\"]) '' from solution import longestCommonPrefix def test_common_prefix(): assert longestCommonPrefix([\\"flower\\",\\"flow\\",\\"flight\\"]) == \\"fl\\" def test_no_common_prefix(): assert longestCommonPrefix([\\"dog\\",\\"racecar\\",\\"car\\"]) == \\"\\" def test_all_strings_same(): assert longestCommonPrefix([\\"test\\",\\"test\\",\\"test\\"]) == \\"test\\" def test_empty_string_list(): assert longestCommonPrefix([]) == \\"\\" def test_one_empty_string(): assert longestCommonPrefix([\\"\\"]) == \\"\\" def test_one_string(): assert longestCommonPrefix([\\"one\\"]) == \\"one\\" def test_different_lengths_no_common(): assert longestCommonPrefix([\\"abc\\",\\"defg\\",\\"hijkl\\"]) == \\"\\" def test_different_lengths_with_common(): assert longestCommonPrefix([\\"interview\\",\\"intermediate\\",\\"internal\\",\\"internet\\"]) == \\"inter\\"","solution":"def longestCommonPrefix(strs): Returns the longest common prefix from a list of strings. If no common prefix exists, returns an empty string. if not strs: return \\"\\" # The common prefix must be a prefix of the first word prefix = strs[0] for string in strs[1:]: while string[:len(prefix)] != prefix and prefix: # Reduce the prefix length until a match is found or it's empty prefix = prefix[:len(prefix)-1] if not prefix: break return prefix"},{"question":"from typing import List def longest_subarray_with_k_distinct(t: int, test_cases_list: List[int]) -> List[int]: Given a sequence of integers, find the length of the longest contiguous subarray that has exactly \`k\` distinct integers. >>> longest_subarray_with_k_distinct(2, [7, [1, 2, 1, 2, 3, 2, 2], 2, 5, [5, 5, 5, 1, 1], 1]) [4, 3] >>> longest_subarray_with_k_distinct(2, [5, [1, 2, 3, 4, 5], 6, 4, [1, 2, 2, 1], 5]) [0, 0] >>> longest_subarray_with_k_distinct(1, [3, [1, 2, 3], 3]) [3] >>> longest_subarray_with_k_distinct(3, [1, [1], 1, 1, [2], 1, 1, [3], 1]) [1, 1, 1] >>> longest_subarray_with_k_distinct(1, [10, [1, 2, 3, 4, 1, 2, 3, 4, 1, 2], 2]) [2] pass # Your code here # Example unit test def test_longest_subarray_with_k_distinct(): assert longest_subarray_with_k_distinct( 2, [7, [1, 2, 1, 2, 3, 2, 2], 2, 5, [5, 5, 5, 1, 1], 1] ) == [4, 3] assert longest_subarray_with_k_distinct( 2, [5, [1, 2, 3, 4, 5], 6, 4, [1, 2, 2, 1], 5] ) == [0, 0] assert longest_subarray_with_k_distinct( 1, [3, [1, 2, 3], 3] ) == [3] assert longest_subarray_with_k_distinct( 3, [1, [1], 1, 1, [2], 1, 1, [3], 1] ) == [1, 1, 1] assert longest_subarray_with_k_distinct( 1, [10, [1, 2, 3, 4, 1, 2, 3, 4, 1, 2], 2] ) == [2]","solution":"from collections import defaultdict def longest_subarray_with_k_distinct(test_cases): def max_len_with_k_distinct(arr, k): n = len(arr) if n == 0 or k == 0: return 0 left = 0 right = 0 max_length = 0 freq_map = defaultdict(int) distinct_count = 0 while right < n: if freq_map[arr[right]] == 0: distinct_count += 1 freq_map[arr[right]] += 1 while distinct_count > k: freq_map[arr[left]] -= 1 if freq_map[arr[left]] == 0: distinct_count -= 1 left += 1 if distinct_count == k: max_length = max(max_length, right - left + 1) right += 1 return max_length results = [] for n, arr, k in test_cases: results.append(max_len_with_k_distinct(arr, k)) return results # Function to prepare the input and format the output def process_input_output(t, test_cases_list): test_cases = [] i = 0 while i < len(test_cases_list): n = test_cases_list[i] arr = test_cases_list[i + 1] k = test_cases_list[i + 2] test_cases.append((n, arr, k)) i += 3 return longest_subarray_with_k_distinct(test_cases)"},{"question":"def minimizeDifference(packets, m): Distribute packets such that: 1. Each child gets exactly one packet. 2. The difference between the maximum and minimum number of chocolates in the chosen packets is minimized. Args: packets (List[int]): A list of integers representing the number of chocolates in each packet. m (int): The number of children. Returns: int: The minimum difference between the maximum and minimum number of chocolates in the chosen packets, or -1 if the distribution is not possible. Examples: >>> minimizeDifference([12, 4, 7, 9, 2, 23, 25, 41, 30, 40, 28, 42, 30, 44, 48, 43, 50], 7) 10 >>> minimizeDifference([3, 4, 1, 9, 56, 7, 9, 12], 5) 6 >>> minimizeDifference([7, 3, 2, 4, 9, 12, 56], 3) 2 >>> minimizeDifference([1, 2, 3], 4) -1 def test_minimize_difference_example1(): assert minimizeDifference([12, 4, 7, 9, 2, 23, 25, 41, 30, 40, 28, 42, 30, 44, 48, 43, 50], 7) == 10 def test_minimize_difference_example2(): assert minimizeDifference([3, 4, 1, 9, 56, 7, 9, 12], 5) == 6 def test_minimize_difference_example3(): assert minimizeDifference([7, 3, 2, 4, 9, 12, 56], 3) == 2 def test_minimize_difference_example4(): assert minimizeDifference([1, 2, 3], 4) == -1 def test_minimize_difference_single_element(): assert minimizeDifference([10], 1) == 0 def test_minimize_difference_all_same(): assert minimizeDifference([5, 5, 5, 5, 5], 3) == 0 def test_minimize_difference_no_difference(): assert minimizeDifference([1, 2, 3, 10, 12, 14, 20], 2) == 1 def test_minimize_difference_small_case(): assert minimizeDifference([8, 6, 4, 3, 5, 7, 1, 9, 2], 5) == 4","solution":"def minimizeDifference(packets, m): # Number of packets n = len(packets) # If number of children is more than the number of packets, return -1 if m > n: return -1 # Sort the packets packets.sort() # Initialize the minimum difference min_diff = float('inf') # Find the minimum difference for i in range(n - m + 1): diff = packets[i + m - 1] - packets[i] if diff < min_diff: min_diff = diff return min_diff"},{"question":"from typing import List, Tuple def word_frequencies(text: str) -> list: Given a string of words, this function returns a list of tuples where each tuple contains a word and its frequency in the string. The list is sorted in descending order of frequency, and for words with the same frequency, the words are sorted in ascending alphabetical order. Args: text (str): A string of words separated by spaces. Returns: list: A list of tuples (word, frequency). >>> word_frequencies(\\"the quick brown fox jumps over the lazy dog the quick cat\\") [('the', 3), ('quick', 2), ('brown', 1), ('cat', 1), ('dog', 1), ('fox', 1), ('jumps', 1), ('lazy', 1), ('over', 1)] >>> word_frequencies(\\"apple banana apple orange fruit banana banana apple fruit\\") [('apple', 3), ('banana', 3), ('fruit', 2), ('orange', 1)]","solution":"from collections import Counter def word_frequencies(text: str) -> list: Given a string of words, this function returns a list of tuples where each tuple contains a word and its frequency in the string. The list is sorted in descending order of frequency, and for words with the same frequency, the words are sorted in ascending alphabetical order. Args: text (str): A string of words separated by spaces. Returns: list: A list of tuples (word, frequency). words = text.split() word_count = Counter(words) return sorted(word_count.items(), key=lambda item: (-item[1], item[0]))"},{"question":"def min_adjacent_swaps(s: str, t: str) -> int: Return the minimum number of adjacent swaps required to transform string s into string t. >>> min_adjacent_swaps(\\"abcd\\", \\"dcba\\") 6 >>> min_adjacent_swaps(\\"abcd\\", \\"abcd\\") 0 >>> min_adjacent_swaps(\\"ab\\", \\"ba\\") 1 >>> min_adjacent_swaps(\\"abc\\", \\"cab\\") 2 >>> min_adjacent_swaps(\\"abcd\\", \\"abce\\") -1 >>> min_adjacent_swaps(\\"a\\" * 1000, \\"a\\" * 1000) 0 >>> min_adjacent_swaps(\\"a\\" * 999 + \\"b\\", \\"b\\" + \\"a\\" * 999) 999","solution":"def min_adjacent_swaps(s, t): Returns the minimum number of adjacent swaps required to transform string s into string t. if sorted(s) != sorted(t): return -1 swaps = 0 s = list(s) for i in range(len(s)): if s[i] != t[i]: j = i while s[j] != t[i]: j += 1 while j > i: s[j], s[j - 1] = s[j - 1], s[j] swaps += 1 j -= 1 return swaps"},{"question":"def is_automorphic(n: int) -> bool: Write a function that takes a positive integer \`n\` and returns \`true\` if \`n\` is an automorphic number. An automorphic number is a number whose square \\"ends\\" in the number itself. For example, 76 is an automorphic number because 76 squared is 5776, which ends in 76. >>> is_automorphic(76) True >>> is_automorphic(5) True >>> is_automorphic(12) False","solution":"def is_automorphic(n): Returns True if the number n is an automorphic number, otherwise False. An automorphic number is a number whose square \\"ends\\" in the number itself. Example: 76 is an automorphic number because 76^2 is 5776, which ends in 76. # Calculate the square of the number square = n ** 2 # Convert both the square and the number to strings str_n = str(n) str_square = str(square) # Check if the square ends with the number itself return str_square.endswith(str_n)"},{"question":"def sort_words_case_insensitive(test_cases): Sorts words in a case-insensitive manner for each test case. Parameters: test_cases (list of tuple): Each tuple contains an integer n and a list of words Returns: list of list: Each list contains words sorted in case-insensitive manner >>> sort_words_case_insensitive([(3, [\\"Banana\\", \\"apple\\", \\"Grape\\"])]) [['apple', 'Banana', 'Grape']] >>> sort_words_case_insensitive([(4, [\\"orange\\", \\"JAM\\", \\"apricot\\", \\"kiwi\\"])]) [['apricot', 'JAM', 'kiwi', 'orange']] >>> sort_words_case_insensitive([(1, [\\"banana\\"])]) [['banana']] >>> sort_words_case_insensitive([(4, [\\"Kiwi\\", \\"apple\\", \\"Mango\\", \\"banana\\"])]) [['apple', 'banana', 'Kiwi', 'Mango']] >>> sort_words_case_insensitive([(4, [\\"banana\\", \\"Banana\\", \\"banana\\", \\"BANANA\\"])]) [['banana', 'Banana', 'banana', 'BANANA']]","solution":"def sort_words_case_insensitive(test_cases): Sorts words in a case-insensitive manner for each test case. Parameters: test_cases (list of tuple): Each tuple contains an integer n and a list of words Returns: list of list: Each list contains words sorted in case-insensitive manner sorted_cases = [] for n, words in test_cases: sorted_words = sorted(words, key=lambda x: x.lower()) sorted_cases.append(sorted_words) return sorted_cases"},{"question":"def unique_necklaces(t: str) -> int: Returns the number of unique necklaces Salina can create by rotating the input string \`t\`. Parameters: t (str): A string representing the necklace, consisting of lowercase English letters. Returns: int: The number of unique necklaces formable by rotating the input string. Examples: >>> unique_necklaces(\\"mnmn\\") 2 >>> unique_necklaces(\\"aaaaa\\") 1 >>> unique_necklaces(\\"xyz\\") 3","solution":"def unique_necklaces(t): Returns the number of unique necklaces formable by rotating the input string \`t\`. rotations = {t[i:] + t[:i] for i in range(len(t))} return len(rotations)"},{"question":"def min_last_element(test_cases): Given an array of integers, determine the minimum possible value of the last remaining element after performing a series of operations until the array becomes empty. In each operation, select any two elements, remove them from the array, and add the absolute difference of the two elements to the array. Args: test_cases (List[Tuple[int, List[int]]]): A list of test cases, where each test case is a tuple consisting of an integer n (number of elements) and a list of integers a (the array). Returns: List[int]: A list of integers, each representing the minimum possible value of the last remaining element for corresponding test case. Examples: >>> min_last_element([(3, [3, 7, 11]), (4, [1, 1, 1, 1]), (5, [2, 2, 5, 8, 13])]) [1, 0, 0] >>> min_last_element([(3, [0, 0, 0]), (2, [1, 2]), (2, [100000, 100000])]) [0, 1, 0] pass # Function to parse the input and call the function def process_input(input_str): input_lines = input_str.strip().split('n') t = int(input_lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(input_lines[index]) a = list(map(int, input_lines[index + 1].split())) test_cases.append((n, a)) index += 2 return min_last_element(test_cases)","solution":"def min_last_element(test_cases): results = [] for case in test_cases: n, a = case if len(a) == 0: results.append(0) continue max_elem = max(a) sum_of_remaining = sum(a) - max_elem if sum_of_remaining >= max_elem: results.append((sum(a) % 2)) else: results.append(max_elem - sum_of_remaining) return results # parsing input and calling the function def process_input(input_str): input_lines = input_str.strip().split('n') t = int(input_lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(input_lines[index]) a = list(map(int, input_lines[index + 1].split())) test_cases.append((n, a)) index += 2 return min_last_element(test_cases)"},{"question":"def final_position(n: int, m: int, t: int, commands: List[str]) -> Tuple[int, int]: Calculate the final position of the robot after executing the commands. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid t (int): number of commands commands (list): list of commands to be executed Returns: tuple: final position (row, column) of the robot >>> final_position(5, 5, 7, [\\"DOWN\\", \\"DOWN\\", \\"RIGHT\\", \\"UP\\", \\"LEFT\\", \\"LEFT\\", \\"DOWN\\"]) (3, 1) >>> final_position(3, 3, 4, [\\"UP\\", \\"UP\\", \\"LEFT\\", \\"LEFT\\"]) (1, 1) >>> final_position(4, 4, 5, [\\"RIGHT\\", \\"RIGHT\\", \\"DOWN\\", \\"DOWN\\"]) (3, 3) >>> final_position(3, 3, 3, [\\"UP\\", \\"UP\\", \\"UP\\"]) (1, 1) >>> final_position(3, 3, 3, [\\"DOWN\\", \\"DOWN\\", \\"DOWN\\"]) (3, 1) >>> final_position(3, 3, 3, [\\"LEFT\\", \\"LEFT\\", \\"LEFT\\"]) (1, 1) >>> final_position(3, 3, 3, [\\"RIGHT\\", \\"RIGHT\\", \\"RIGHT\\"]) (1, 3) >>> final_position(3, 3, 0, []) (1, 1) >>> final_position(10, 10, 7, [\\"RIGHT\\", \\"RIGHT\\", \\"RIGHT\\", \\"DOWN\\", \\"DOWN\\", \\"LEFT\\", \\"UP\\"]) (2, 3)","solution":"def final_position(n, m, t, commands): Calculate the final position of the robot after executing the commands. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid t (int): number of commands commands (list): list of commands to be executed Returns: tuple: final position (row, column) of the robot current_position = [1, 1] for command in commands: if command == \\"UP\\" and current_position[0] > 1: current_position[0] -= 1 elif command == \\"DOWN\\" and current_position[0] < n: current_position[0] += 1 elif command == \\"LEFT\\" and current_position[1] > 1: current_position[1] -= 1 elif command == \\"RIGHT\\" and current_position[1] < m: current_position[1] += 1 return tuple(current_position)"},{"question":"def removeDuplicates(s: str) -> str: Removes adjacent duplicates from the string s until no more duplicates can be removed. Parameters: s (str): Input string consisting of lowercase alphabets. Returns: str: Final string after removing all possible adjacent duplicates. Example: >>> removeDuplicates(\\"abbaca\\") == \\"ca\\" >>> removeDuplicates(\\"azxxzy\\") == \\"ay\\" from solution import removeDuplicates def test_example_1(): assert removeDuplicates(\\"abbaca\\") == \\"ca\\" def test_example_2(): assert removeDuplicates(\\"azxxzy\\") == \\"ay\\" def test_no_duplicates(): assert removeDuplicates(\\"abcd\\") == \\"abcd\\" def test_all_duplicates(): assert removeDuplicates(\\"aabbcc\\") == \\"\\" def test_complex_case(): assert removeDuplicates(\\"aabbccddeeffgg\\") == \\"\\" def test_single_character(): assert removeDuplicates(\\"a\\") == \\"a\\" def test_double_character(): assert removeDuplicates(\\"aa\\") == \\"\\" def test_alternating_characters(): assert removeDuplicates(\\"ababababa\\") == \\"ababababa\\"","solution":"def removeDuplicates(s: str) -> str: Removes adjacent duplicates from the string s until no more duplicates can be removed. Parameters: s (str): Input string consisting of lowercase alphabets. Returns: str: Final string after removing all possible adjacent duplicates. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack)"},{"question":"def count_distinct_subarrays(arr, k): Counts the number of distinct subarrays of length k in the given array. :param arr: List of integers :param k: Length of subarrays to consider :return: Number of distinct subarrays of length k pass # Implement the function def process_queries(arr, queries): Processes a list of queries on the given array. :param arr: List of integers :param queries: List of subarray lengths to consider in each query :return: List of results for each query (number of distinct subarrays) pass # Implement the function def solve(test_cases): Processes multiple test cases, each containing an array and a series of queries. :param test_cases: List of tuples (array, queries) :return: List of lists, each containing results for the queries of one test case pass # Implement the function # Unit test def test_single_query(): test_cases = [ ([1, 2, 1, 3, 2], [3]) ] assert solve(test_cases) == [[3]] def test_multiple_queries(): test_cases = [ ([1, 2, 1, 3, 2], [3, 2]) ] assert solve(test_cases) == [[3, 4]] def test_duplicate_elements(): test_cases = [ ([4, 4, 4, 4, 4, 4, 4], [3]) ] assert solve(test_cases) == [[1]] def test_another_case(): test_cases = [ ([1, 2, 3, 4, 5, 6, 7], [2, 3]) ] assert solve(test_cases) == [[6, 5]] def test_edge_case(): test_cases = [ ([1, 1, 1, 1, 1], [5]) ] assert solve(test_cases) == [[1]] def test_varied_lengths(): test_cases = [ ([1, 2, 3, 2, 1], [1, 2, 3, 4, 5]) ] assert solve(test_cases) == [[3, 4, 3, 2, 1]]","solution":"def count_distinct_subarrays(arr, k): Counts the number of distinct subarrays of length k in the given array. :param arr: List of integers :param k: Length of subarrays to consider :return: Number of distinct subarrays of length k subarrays = set() for i in range(len(arr) - k + 1): subarray = tuple(arr[i:i + k]) subarrays.add(subarray) return len(subarrays) def process_queries(arr, queries): Processes a list of queries on the given array. :param arr: List of integers :param queries: List of subarray lengths to consider in each query :return: List of results for each query (number of distinct subarrays) results = [] for query in queries: results.append(count_distinct_subarrays(arr, query)) return results def solve(test_cases): Processes multiple test cases, each containing an array and a series of queries. :param test_cases: List of tuples (array, queries) :return: List of lists, each containing results for the queries of one test case results = [] for arr, queries in test_cases: results.append(process_queries(arr, queries)) return results"},{"question":"def merge_strings(str1: str, str2: str) -> str: Merges two input strings by alternating their characters. If one string is longer than the other, append the remaining characters from the longer string to the end of the merged result. >>> merge_strings(\\"abc\\", \\"xyz\\") \\"axbycz\\" >>> merge_strings(\\"hello\\", \\"world\\") \\"hweolrllod\\" >>> merge_strings(\\"abc\\", \\"defgh\\") \\"adbecfgh\\" >>> merge_strings(\\"short\\", \\"longerstring\\") \\"slhoorntegrsrttring\\" >>> merge_strings(\\"\\", \\"\\") \\"\\" >>> merge_strings(\\"abc\\", \\"\\") \\"abc\\" >>> merge_strings(\\"\\", \\"xyz\\") \\"xyz\\"","solution":"def merge_strings(str1, str2): Merges two input strings by alternating their characters. If one string is longer than the other, append the remaining characters from the longer string to the end of the merged result. merged = [] min_length = min(len(str1), len(str2)) # Alternate characters from both strings for i in range(min_length): merged.append(str1[i]) merged.append(str2[i]) # Append remaining characters from the longer string if len(str1) > len(str2): merged.append(str1[min_length:]) else: merged.append(str2[min_length:]) return ''.join(merged)"},{"question":"def shortest_path_in_grid(n: int, m: int, grid: List[str]) -> int: Find the shortest path from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1) in a grid. The grid consists of walkable cells denoted by '.' and obstacle cells denoted by '#'. If there is no valid path, return -1. >>> shortest_path_in_grid(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 4 >>> shortest_path_in_grid(3, 4, [\\"....\\", \\"..\\", \\"....\\"]) 5 >>> shortest_path_in_grid(3, 3, [\\".#.\\", \\"#\\", \\"...\\"]) -1 from solution import shortest_path_in_grid def test_shortest_path_simple(): grid = [ \\"...\\", \\"...\\", \\"...\\" ] assert shortest_path_in_grid(3, 3, grid) == 4 def test_shortest_path_with_obstacles(): grid = [ \\"....\\", \\"..\\", \\"....\\" ] assert shortest_path_in_grid(3, 4, grid) == 5 def test_no_path_due_to_obstacles(): grid = [ \\".#.\\", \\"#\\", \\"...\\" ] assert shortest_path_in_grid(3, 3, grid) == -1 def test_single_cell(): grid = [ \\".\\" ] assert shortest_path_in_grid(1, 1, grid) == 0 def test_large_grid_with_no_obstacles(): n, m = 1000, 1000 grid = [\\".\\" * m for _ in range(n)] assert shortest_path_in_grid(n, m, grid) == 1998 def test_large_grid_with_obstacles_blocking_path(): n, m = 5, 5 grid = [ \\"...#.\\", \\"...\\", \\"...#.\\", \\"...\\", \\"...#.\\" ] assert shortest_path_in_grid(n, m, grid) == -1","solution":"from collections import deque def shortest_path_in_grid(n, m, grid): def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if (x, y) == (n - 1, m - 1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def find_book_location(library, book_id): Find the location of a book in the library. Parameters: library (list): A 3D list where library[f][s] is the list of book IDs on the s-th bookshelf on the f-th floor. book_id (int): The ID of the book. Returns: tuple: A tuple (floor, shelf) where the book is found, otherwise (-1, -1). Example: >>> library = [ ... [[1, 2, 3], [4, 5, 6]], ... [[7, 8], [9, 10, 11, 12]], ... [[13, 14, 15], [16, 17]] ... ] >>> book_id = 10 >>> find_book_location(library, book_id) (1, 1) >>> library = [ ... [[1, 2, 3], [4, 5, 6]], ... [[7, 8], [9, 10, 11, 12]], ... [[13, 14, 15], [16, 17]] ... ] >>> book_id = 50 >>> find_book_location(library, book_id) (-1, -1)","solution":"def find_book_location(library, book_id): This function finds the book's location in the library. Parameters: library (list): A 3D list where library[f][s] is the list of book IDs on the s-th bookshelf on the f-th floor. book_id (int): The ID of the book. Returns: tuple: A tuple (floor, shelf) where the book is found, otherwise (-1, -1). for f in range(len(library)): for s in range(len(library[f])): if book_id in library[f][s]: return (f, s) return (-1, -1)"},{"question":"def remove_vowels(s: str) -> str: Complete the function/method so that it returns a string with all the vowels removed. >>> remove_vowels('Hello World!') == 'Hll Wrld!' >>> remove_vowels('Pythons are programming language') == 'Pythns r prgrmmng lngg' # your code here","solution":"def remove_vowels(s): Removes all vowels from the input string s. vowels = \\"aeiouAEIOU\\" return ''.join([char for char in s if char not in vowels])"},{"question":"def min_moves_to_balance(s: str) -> int: Determine the minimum number of moves required to balance a string. A string is considered balanced if the number of 'x' characters is equal to the number of 'y' characters. In one move, you can remove any one character from the string. >>> min_moves_to_balance(\\"xxyy\\") 0 >>> min_moves_to_balance(\\"xxxxy\\") 3 >>> min_moves_to_balance(\\"xxyyyy\\") 2","solution":"def min_moves_to_balance(s: str) -> int: Returns the minimum number of moves required to make the string balanced. count_x = s.count('x') count_y = s.count('y') return abs(count_x - count_y)"},{"question":"def findPair(nums: List[int], k: int) -> Tuple[int, int]: Returns a tuple of two distinct elements from nums that add up to k, or an empty tuple if no such pair exists. >>> findPair([10, 15, 3, 7], 17) (10, 7) >>> findPair([1, 2, 3, 4, 5], 9) (4, 5) >>> findPair([1, 2, 3, 4, 5], 10) () # Implement the logic to find the pair pass # Unit tests from typing import List, Tuple def test_example_case_1(): nums = [10, 15, 3, 7] k = 17 result = findPair(nums, k) assert result == (10, 7) or result == (7, 10) def test_example_case_2(): nums = [1, 2, 3, 4, 5] k = 9 result = findPair(nums, k) assert result == (4, 5) or result == (5, 4) def test_example_case_3(): nums = [1, 2, 3, 4, 5] k = 10 result = findPair(nums, k) assert result == () def test_no_pair_exists(): nums = [1, 2, 4, 5] k = 8 result = findPair(nums, k) assert result == () def test_multiple_pairs(): nums = [1, 2, 2, 3, 4] k = 4 result = findPair(nums, k) assert result in [(1, 3), (2, 2)] def test_with_negative_numbers(): nums = [1, -2, 3, -4, 5] k = -1 result = findPair(nums, k) assert result == (-2, 1) or result == (1, -2) def test_empty_list(): nums = [] k = 5 result = findPair(nums, k) assert result == () def test_large_values(): nums = [10000, -10000, 9999] k = 19999 result = findPair(nums, k) assert result == (9999, 10000)","solution":"def findPair(nums, k): Returns a tuple of two elements from nums that add up to k, or an empty tuple if no such pair exists. seen = set() for num in nums: complement = k - num if complement in seen: return (min(num, complement), max(num, complement)) seen.add(num) return ()"},{"question":"def is_prime(num: int) -> bool: Determine if a number is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True def find_primes_in_range(a: int, b: int) -> list: Find all unique prime numbers in the range [a, b] inclusive. If no prime numbers exist in the range, return [-1]. >>> find_primes_in_range(4, 10) [5, 7] >>> find_primes_in_range(20, 30) [23, 29] >>> find_primes_in_range(1, 1) [-1] def process_input(n: int, ranges: list) -> list: Process the input to find primes for each range pair (a_i, b_i). >>> input_data = 2 >>> ranges = [(4, 10), (20, 30)] >>> process_input(input_data, ranges) [[5, 7], [23, 29]]","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def find_primes_in_range(a, b): primes = [] for num in range(a, b + 1): if is_prime(num): primes.append(num) return primes if primes else [-1] def process_input(n, ranges): results = [] for a, b in ranges: if a > b: a, b = b, a primes = find_primes_in_range(a, b) results.append(primes) return results"},{"question":"def find_first_repeated_char(input_str: str) -> str: Returns the first repeated character in the input string. If no character repeats, returns None. >>> find_first_repeated_char(\\"hello\\") 'l' >>> find_first_repeated_char(\\"swiss\\") 's' >>> find_first_repeated_char(\\"abcdef\\") None >>> find_first_repeated_char(\\"#%@#\\") '#' >>> find_first_repeated_char(\\"a\\") None >>> find_first_repeated_char(\\"\\") None >>> find_first_repeated_char(\\"122334455\\") '2' >>> find_first_repeated_char(\\"abc123321\\") '3' >>> find_first_repeated_char(\\"aAbBCc\\") None >>> find_first_repeated_char(\\"abacabad\\") 'a' >>> find_first_repeated_char(\\" abac\\") ' '","solution":"def find_first_repeated_char(input_str: str) -> str: Returns the first repeated character in the input string. If no character repeats, returns None. seen = set() for char in input_str: if char in seen: return char seen.add(char) return None"},{"question":"def can_transform_to_even(N, A): Determines if it's possible to convert the array into a single element array that contains an even number. Parameters: N (int): The size of the array. A (list of int): The array of integers. Returns: str: 'YES' if possible to convert to a single even number, 'NO' otherwise. pass # Unit Tests def test_single_element_array(): assert can_transform_to_even(1, [1]) == 'NO' assert can_transform_to_even(1, [2]) == 'YES' def test_array_with_even_number(): assert can_transform_to_even(3, [1, 2, 3]) == 'YES' assert can_transform_to_even(4, [2, 3, 5, 7]) == 'YES' def test_array_all_odd_numbers(): assert can_transform_to_even(4, [1, 3, 5, 7]) == 'NO' assert can_transform_to_even(5, [9, 13, 17, 21, 25]) == 'NO' def test_array_all_even_numbers(): assert can_transform_to_even(2, [2, 4]) == 'YES' assert can_transform_to_even(3, [6, 8, 10]) == 'YES' def test_mixed_array(): assert can_transform_to_even(5, [1, 1, 1, 1, 2]) == 'YES' assert can_transform_to_even(6, [1, 1, 1, 1, 1, 1]) == 'NO'","solution":"def can_transform_to_even(N, A): Determines if it's possible to convert the array into a single element array that contains an even number. Parameters: N (int): The size of the array. A (list of int): The array of integers. Returns: str: 'YES' if possible to convert to a single even number, 'NO' otherwise. # If there's at least one even number in the array, we can make the sum even for num in A: if num % 2 == 0: return 'YES' # If all numbers are odd, we can never turn them into an even sum since the sum of odd numbers is always odd return 'NO'"},{"question":"def smallest_missing_positive_integer(nums): Returns the smallest missing positive integer from the given list. >>> smallest_missing_positive_integer([3, 4, -1, 1, 5]) == 2 >>> smallest_missing_positive_integer([1, 2, 3]) == 4 >>> smallest_missing_positive_integer([-1, -2, -3]) == 1 >>> smallest_missing_positive_integer([2, 3, 7, 6, 8, -1, -10, 15]) == 1 >>> smallest_missing_positive_integer([0, -1, -2, -3, -4]) == 1 >>> smallest_missing_positive_integer([1, 2, 0, 1, 2, 0, 3, 4]) == 5 >>> smallest_missing_positive_integer([1]) == 2 >>> smallest_missing_positive_integer([2, 3, 4]) == 1 >>> smallest_missing_positive_integer([5, 10, 20]) == 1","solution":"def smallest_missing_positive_integer(nums): Returns the smallest missing positive integer from the given list. nums = list(filter(lambda x: x > 0, nums)) nums = sorted(set(nums)) smallest_missing = 1 for num in nums: if num == smallest_missing: smallest_missing += 1 elif num > smallest_missing: break return smallest_missing"},{"question":"def largest_binary_after_operation(binary_str: str) -> str: Returns the largest binary number possible by performing exactly one of the allowed operations: 1. Flip exactly one bit, changing a '0' to '1' or a '1' to '0'. 2. Swap exactly two different bits. >>> largest_binary_after_operation(\\"101\\") == \\"111\\" >>> largest_binary_after_operation(\\"0110\\") == \\"1110\\" >>> largest_binary_after_operation(\\"101010\\") == \\"111010\\" def process_test_cases(test_cases: List[str]) -> List[str]: Processes a list of binary strings and returns a list of results for each test case by applying the largest_binary_after_operation function. >>> process_test_cases([\\"101\\", \\"0110\\", \\"101010\\"]) == [\\"111\\", \\"1110\\", \\"111010\\"] def main(): Reads multiple test cases, processes each case and prints the result.","solution":"def largest_binary_after_operation(binary_str): Returns the largest binary number possible by performing exactly one of the allowed operations. Operations allowed: 1. Flip exactly one bit, changing a '0' to '1' or a '1' to '0'. 2. Swap exactly two different bits. n = len(binary_str) # Convert string to list of characters to easily manipulate bits binary_list = list(binary_str) # Find the largest result by flipping one bit flipped_results = [] for i in range(n): flipped_result = binary_list[:] flipped_result[i] = '1' if binary_list[i] == '0' else '0' flipped_results.append(''.join(flipped_result)) # Find the largest result by swapping two bits swapped_results = [] for i in range(n): for j in range(i + 1, n): swapped_result = binary_list[:] swapped_result[i], swapped_result[j] = swapped_result[j], swapped_result[i] swapped_results.append(''.join(swapped_result)) # Find the lexicographically largest result from all possible results all_results = flipped_results + swapped_results return max(all_results) def process_test_cases(test_cases): results = [] for binary_str in test_cases: results.append(largest_binary_after_operation(binary_str)) return results # For processing input/output def main(): import sys input = sys.stdin.read data = input().strip().split() T = int(data[0]) test_cases = data[1:T + 1] results = process_test_cases(test_cases) for result in results: print(result) # For testing only if __name__ == \\"__main__\\": main()"},{"question":"import math def waterBottlesNeeded(P: int, X: int, D: int, C: int) -> int: Calculates the minimum number of water bottles needed for a hiking trip. Parameters: - P (int): number of people - X (int): daily water consumption per person in liters - D (int): number of days - C (int): capacity of each water bottle in liters Returns: - int: minimum number of water bottles needed >>> waterBottlesNeeded(5, 3, 7, 2) 53 >>> waterBottlesNeeded(1, 1, 1, 1) 1 >>> waterBottlesNeeded(10, 10, 10, 5) 200 >>> waterBottlesNeeded(50, 1, 10, 1) 500 >>> waterBottlesNeeded(100, 1, 1, 5) 20 >>> waterBottlesNeeded(10, 3, 2, 5) 12 >>> waterBottlesNeeded(3, 4, 3, 5) 8 >>> waterBottlesNeeded(1, 1, 1, 1) 1 >>> waterBottlesNeeded(100, 10, 15, 5) 3000","solution":"import math def waterBottlesNeeded(P, X, D, C): Calculates the minimum number of water bottles needed for a hiking trip. Parameters: - P (int): number of people - X (int): daily water consumption per person in liters - D (int): number of days - C (int): capacity of each water bottle in liters Returns: - int: minimum number of water bottles needed total_water_needed = P * X * D bottles_needed = math.ceil(total_water_needed / C) return bottles_needed"},{"question":"import heapq from typing import List, Tuple def find_minimum_path(n: int, m: int, edges: List[Tuple[int, int, int]]) -> Tuple[int, List[int]]: Given an undirected connected graph of n vertices and m edges, find a path from vertex 1 to vertex n such that the sum of the values on the edges in the path is minimized. Args: n (int): number of vertices m (int): number of edges edges (List[Tuple[int, int, int]]): list of edges where each edge is represented as a tuple (u, v, w) Returns: Tuple[int, List[int]]: minimum sum of edge values and the path from vertex 1 to vertex n Examples: >>> find_minimum_path(5, 6, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 3, 10), (1, 4, 1), (4, 5, 1)]) (2, [1, 4, 5]) >>> find_minimum_path(4, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 3, 3)]) (3, [1, 2, 3, 4]) >>> find_minimum_path(3, 3, [(1, 2, 5), (2, 3, 5), (1, 3, 3)]) (3, [1, 3]) pass","solution":"import heapq def find_minimum_path(n, m, edges): from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm to find shortest path from vertex 1 to vertex n min_heap = [(0, 1, [])] # (current_sum, current_node, path) visited = set() while min_heap: current_sum, current_node, path = heapq.heappop(min_heap) if current_node == n: return current_sum, path + [n] if current_node in visited: continue visited.add(current_node) for neighbor, weight in graph[current_node]: if neighbor not in visited: heapq.heappush(min_heap, (current_sum + weight, neighbor, path + [current_node])) return -1, [] # Example usage: edges = [ (1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 3, 10), (1, 4, 1), (4, 5, 1) ] n = 5 m = 6 min_sum, path = find_minimum_path(n, m, edges) print(min_sum) print(path)"},{"question":"def calculate_discounted_price(N, prices): Computes the total price after applying the discount based on the number of books. :param N: int, number of books :param prices: list of int, prices of the books :return: float, total price after discount rounded to two decimals pass def process_test_cases(T, test_cases): Processes each test case to compute discounted prices. :param T: int, number of test cases :param test_cases: list of tuples, each containing number of books and a list of prices :return: list of float, discounted prices for each test case pass # Example unit tests from solution import calculate_discounted_price, process_test_cases def test_calculate_discounted_price(): assert calculate_discounted_price(1, [20]) == 20.00 assert calculate_discounted_price(2, [30, 50]) == 76.00 assert calculate_discounted_price(4, [15, 25, 35, 45]) == 96.00 assert calculate_discounted_price(3, [10, 20, 30]) == 54.00 assert calculate_discounted_price(5, [10, 10, 10, 10, 10]) == 40.00 assert calculate_discounted_price(1, [1000]) == 1000.00 assert calculate_discounted_price(2, [1000, 1000]) == 1900.00 assert calculate_discounted_price(3, [1000, 1000, 1000]) == 2700.00 assert calculate_discounted_price(4, [1000, 1000, 1000, 1000]) == 3200.00 def test_process_test_cases(): input_data = [ (1, [20]), (2, [30, 50]), (4, [15, 25, 35, 45]) ] expected_results = [20.00, 76.00, 96.00] assert process_test_cases(3, input_data) == expected_results input_data = [ (3, [10, 20, 30]), (5, [10, 10, 10, 10, 10]), (1, [1000]), (2, [1000, 1000]), (3, [1000, 1000, 1000]), (4, [1000, 1000, 1000, 1000]) ] expected_results = [54.00, 40.00, 1000.00, 1900.00, 2700.00, 3200.00] assert process_test_cases(6, input_data) == expected_results","solution":"def calculate_discounted_price(N, prices): Computes the total price after applying the discount based on the number of books. :param N: int, number of books :param prices: list of int, prices of the books :return: float, total price after discount rounded to two decimals total_price = sum(prices) if N == 1: discount = 0.0 elif N == 2: discount = 0.05 elif N == 3: discount = 0.10 else: # N >= 4 discount = 0.20 discounted_price = total_price * (1 - discount) return round(discounted_price, 2) def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] prices = test_cases[i][1] results.append(calculate_discounted_price(N, prices)) return results"},{"question":"from collections import defaultdict from typing import List, Tuple def find_subtree_minimums(n: int, values: List[int], edges: List[Tuple[int, int]]) -> List[int]: Given a binary tree with n nodes labeled from 1 to n, each node has a unique value assigned to it, ranging from 1 to n. The tree is rooted at node 1. Determine the minimum value in the subtree of each node in the tree and output these values for all nodes. >>> find_subtree_minimums(5, [5, 3, 4, 2, 1], [(1, 2), (1, 3), (2, 4), (2, 5)]) [1, 1, 4, 2, 1] >>> find_subtree_minimums(3, [3, 1, 2], [(1, 2), (1, 3)]) [1, 1, 2]","solution":"from collections import defaultdict def find_subtree_minimums(n, values, edges): tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) def dfs(node, parent): min_value = values[node-1] for neighbor in tree[node]: if neighbor != parent: min_value = min(min_value, dfs(neighbor, node)) subtree_min[node] = min_value return min_value subtree_min = [0] * (n + 1) dfs(1, -1) return subtree_min[1:] # Example usage n = 5 values = [5, 3, 4, 2, 1] edges = [(1, 2), (1, 3), (2, 4), (2, 5)] output = find_subtree_minimums(n, values, edges) print(output) # should print [1, 1, 4, 2, 1]"},{"question":"def count_symmetrical_subsequences(m, b): Help Olivia find the number of contiguous symmetrical subsequences in the sequence \`b\`. Since the output can be large, you should return the result modulo prime number 1000000007 (10^9 + 7). Args: m (int): The length of the sequence. b (List[int]): The sequence of integers. Returns: int: The number of contiguous symmetrical subsequences modulo 1000000007. Examples: >>> count_symmetrical_subsequences(5, [1, 2, 1, 2, 1]) 9 >>> count_symmetrical_subsequences(3, [3, 4, 3]) 4","solution":"def count_symmetrical_subsequences(m, b): MOD = 1000000007 def is_symmetric(subarr): return subarr == subarr[::-1] count = 0 for i in range(m): for j in range(i, m): if is_symmetric(b[i:j+1]): count += 1 count %= MOD return count"},{"question":"def process_string_operations(S: str, operations: list) -> list: Processes a list of operations on a string S and returns the results of Type 2 operations which find the length of the longest substring with unique characters. >>> process_string_operations('abcdefgh', ['2 1 8', '1 3 z', '2 2 7']) [8, 6] >>> process_string_operations('aaaaaaa', ['2 1 7', '1 4 b', '2 3 5']) [1, 2] from process_string_operations import process_string_operations def test_process_string_operations(): S = 'abcdefgh' operations = ['2 1 8', '1 3 z', '2 2 7'] expected = [8, 6] assert process_string_operations(S, operations) == expected def test_all_identical_characters(): S = 'aaaaaaa' operations = ['2 1 7', '1 4 b', '2 3 5'] expected = [1, 2] assert process_string_operations(S, operations) == expected def test_empty_operations(): S = 'abcdefgh' operations = [] expected = [] assert process_string_operations(S, operations) == expected def test_single_update_operation(): S = 'abcdefgh' operations = ['1 1 z'] expected = [] assert process_string_operations(S, operations) == expected def test_edge_case_max_length(): S = 'a' * 10000 operations = ['1 5000 z', '2 1 10000'] expected = [2] assert process_string_operations(S, operations) == expected","solution":"def process_string_operations(S, operations): Processes a list of operations on a string S. Args: S (str): Initial string. operations (list): List of operations to perform on string S. Returns: list: Results of Type 2 operations. from itertools import accumulate results = [] S = list(S) def longest_unique_substring_length(substring): # Find the length of the longest substring with unique characters seen = set() max_len = 0 start = 0 for end in range(len(substring)): while substring[end] in seen: seen.remove(substring[start]) start += 1 seen.add(substring[end]) max_len = max(max_len, end - start + 1) return max_len for operation in operations: op = operation.split() if op[0] == '1': x = int(op[1]) - 1 # Convert 1-based index to 0-based c = op[2] S[x] = c elif op[0] == '2': L = int(op[1]) - 1 R = int(op[2]) - 1 substring = S[L:R+1] results.append(longest_unique_substring_length(substring)) return results"},{"question":"def find_max_height_on_path(grid, start, end): Find the maximum height on the path from start to end in the grid following the shortest path. Args: grid (List[List[int]]): A 2D list representing the heights of the cells in the grid. start (Tuple[int, int]): The starting cell coordinates (row, column). end (Tuple[int, int]): The target cell coordinates (row, column). Returns: int: The maximum height on the path from start to end. >>> grid = [ ... [1, 2, 3, 4], ... [4, 5, 6, 7], ... [7, 6, 5, 4], ... [8, 7, 6, 5] ... ] >>> find_max_height_on_path(grid, (0, 0), (2, 2)) 6 >>> find_max_height_on_path(grid, (1, 1), (3, 3)) 7 >>> find_max_height_on_path(grid, (0, 3), (3, 0)) 8 def process_queries(grid, queries): Process multiple queries to find the maximum height on the path for each query. Args: grid (List[List[int]]): A 2D list representing the heights of the cells in the grid. queries (List[Tuple[int, int, int, int]]): A list of queries, each containing the coordinates of starting and target cells. Returns: List[int]: A list of results for each query. >>> grid = [ ... [1, 2, 3, 4], ... [4, 5, 6, 7], ... [7, 6, 5, 4], ... [8, 7, 6, 5] ... ] >>> queries = [ ... (1, 1, 3, 3), ... (2, 2, 4, 4), ... (1, 4, 4, 1) ... ] >>> process_queries(grid, queries) [6, 7, 8]","solution":"from collections import deque def find_max_height_on_path(grid, start, end): n, m = len(grid), len(grid[0]) x1, y1 = start x2, y2 = end directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * m for _ in range(n)] queue = deque([(x1, y1, grid[x1][y1])]) visited[x1][y1] = True max_height = grid[x1][y1] while queue: cx, cy, current_max = queue.popleft() if (cx, cy) == (x2, y2): return current_max for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: visited[nx][ny] = True new_max = max(current_max, grid[nx][ny]) queue.append((nx, ny, new_max)) return -1 # This should not happen for valid input def process_queries(grid, queries): results = [] for x1, y1, x2, y2 in queries: start = (x1-1, y1-1) end = (x2-1, y2-1) results.append(find_max_height_on_path(grid, start, end)) return results"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_sum_path(root: TreeNode) -> tuple: Given a non-empty binary tree, find the path from the root node to the leaf node that has the maximum sum. Returns a tuple with the maximum sum and the path from root to the leaf node. >>> test_single_node() >>> test_two_layers() >>> test_three_layers() >>> test_mixed_values() >>> test_negative_values()","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_sum_path(root): def helper(node): if not node: return float('-inf'), [] if not node.left and not node.right: return node.value, [node.value] left_sum, left_path = helper(node.left) right_sum, right_path = helper(node.right) if left_sum > right_sum: return left_sum + node.value, [node.value] + left_path else: return right_sum + node.value, [node.value] + right_path max_sum, max_path = helper(root) return max_sum, max_path"},{"question":"import heapq from typing import List, Tuple def find_minimum_delivery_time(test_cases: List[Tuple[int, int, int, List[Tuple[int, int, int]], List[Tuple[int, int]], int, int]]) -> List[int]: Determine the minimum delivery time given a city's road network, some unavailable roads, and starting & ending junctions. >>> find_minimum_delivery_time([ ... (4, 5, 1, [(1, 2, 10), (1, 3, 5), (2, 3, 2), (3, 4, 1), (4, 2, 3)], [(2, 3)], 1, 4) ... ]) [6] >>> find_minimum_delivery_time([ ... (4, 4, 4, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 1, 10)], [(1, 2), (2, 3), (3, 4), (4, 1)], 1, 4) ... ]) [-1] >>> find_minimum_delivery_time([ ... (2, 1, 0, [(1, 2, 5)], [], 1, 2) ... ]) [5] >>> find_minimum_delivery_time([ ... (5, 7, 2, [(1, 2, 2), (1, 3, 10), (2, 3, 3), (2, 4, 1), (3, 5, 2), (4, 5, 4), (3, 4, 1)], [(1, 3), (3, 5)], 1, 5) ... ]) [7]","solution":"import heapq def find_minimum_delivery_time(test_cases): def dijkstra(n, graph, unavailable, start, end): unavailable_set = set((a, b) for a, b in unavailable) adj_list = {i: [] for i in range(1, n + 1)} for u, v, t in graph: if (u, v) not in unavailable_set: adj_list[u].append((v, t)) pq = [(0, start)] # (time, node) dist = {i: float('inf') for i in range(1, n + 1)} dist[start] = 0 while pq: current_time, node = heapq.heappop(pq) if node == end: return current_time if current_time > dist[node]: continue for neighbor, travel_time in adj_list[node]: time = current_time + travel_time if time < dist[neighbor]: dist[neighbor] = time heapq.heappush(pq, (time, neighbor)) return -1 results = [] for n, m, u, roads, unavailable_roads, s, d in test_cases: result = dijkstra(n, roads, unavailable_roads, s, d) results.append(result) return results"},{"question":"def longest_common_substring(A: str, B: str) -> int: Returns the length of the longest common substring of A and B. >>> longest_common_substring(\\"abcde\\", \\"fghij\\") == 0 >>> longest_common_substring(\\"abcde\\", \\"bcfgh\\") == 2 >>> longest_common_substring(\\"abcdxyz\\", \\"xyzabcd\\") == 4 def solve(test_cases: List[Tuple[str, str]]) -> List[int]: Solves multiple test cases for the longest common substring problem. def test_example_cases(): test_cases = [ (\\"abcde\\", \\"fghij\\"), (\\"abcde\\", \\"bcfgh\\"), (\\"abcdxyz\\", \\"xyzabcd\\") ] expected = [0, 2, 4] assert solve(test_cases) == expected def test_identical_strings(): test_cases = [(\\"aaaaa\\", \\"aaaaa\\")] expected = [5] assert solve(test_cases) == expected def test_no_common_substring(): test_cases = [(\\"abcd\\", \\"efgh\\")] expected = [0] assert solve(test_cases) == expected def test_partial_overlap(): test_cases = [(\\"abcdef\\", \\"cdefgh\\")] expected = [4] assert solve(test_cases) == expected def test_mixed_results(): test_cases = [ (\\"ab\\", \\"ba\\"), (\\"abc\\", \\"def\\"), (\\"xyzabc\\", \\"abcxyz\\") ] expected = [1, 0, 3] assert solve(test_cases) == expected","solution":"def longest_common_substring(A, B): Returns the length of the longest common substring of A and B. m, n = len(A), len(B) dp = [[0] * (n + 1) for _ in range(m + 1)] max_len = 0 for i in range(1, m + 1): for j in range(1, n + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_len = max(max_len, dp[i][j]) else: dp[i][j] = 0 return max_len def solve(test_cases): Solves multiple test cases for the longest common substring problem. results = [] for A, B in test_cases: results.append(longest_common_substring(A, B)) return results"},{"question":"def balanceString(s: str) -> str: Returns a \\"balanced\\" version of the string \`s\`, where each character is mirrored to its opposite position in the alphabet. Examples: >>> balanceString(\\"abc\\") 'zyx' >>> balanceString(\\"xyz\\") 'cba' >>> balanceString(\\"hello\\") 'svool' >>> balanceString(\\"az\\") 'za'","solution":"def balanceString(s): Returns a \\"balanced\\" version of the string \`s\`, where each character is mirrored to its opposite position in the alphabet. alphabet = 'abcdefghijklmnopqrstuvwxyz' alpha_dict = {alphabet[i]: alphabet[25-i] for i in range(26)} return ''.join(alpha_dict[char] for char in s)"},{"question":"from typing import List, Tuple def tribble_population(a: int, b: int, queries: List[Tuple[int, int, int]]) -> List[int]: Process the given queries on the population of tribbles and return the results for query type 2. Parameters: a (int): Population on day 1. b (int): Population on day 2. queries (list of tuple): List of queries where each query is a tuple (type, i, x) or (type, i). Returns: list of int: List of results for the queries of type 2. Example: >>> tribble_population(3, 5, [(2, 5), (1, 3, 8), (2, 3), (1, 4, 13), (2, 4)]) [21, 8, 13] def test_example(): a = 3 b = 5 queries = [(2, 5), (1, 3, 8), (2, 3), (1, 4, 13), (2, 4)] assert tribble_population(a, b, queries) == [21, 8, 13] def test_initial_population(): a = 1 b = 1 queries = [(2, 1), (2, 2), (2, 3), (2, 4), (2, 5)] assert tribble_population(a, b, queries) == [1, 1, 2, 3, 5] def test_update_and_query(): a = 2 b = 3 queries = [(1, 4, 10), (2, 4), (1, 5, 15), (2, 5)] assert tribble_population(a, b, queries) == [10, 15] def test_large_numbers(): a = 10**9 b = 10**9 queries = [(2, 3), (2, 4), (1, 3, 42), (2, 3), (1, 4, 100000), (2, 4)] assert tribble_population(a, b, queries) == [2000000000, 3000000000, 42, 100000] def test_random_updates_and_queries(): a = 1 b = 2 queries = [(1, 5, 20), (2, 5), (1, 6, 30), (2, 6), (2, 7)] assert tribble_population(a, b, queries) == [20, 30, 50]","solution":"def tribble_population(a, b, queries): Process the given queries on the population of tribbles and return the results for query type 2. Parameters: a (int): Population on day 1. b (int): Population on day 2. queries (list of tuple): List of queries where each query is a tuple (type, i, x) or (type, i). Returns: list of int: List of results for the queries of type 2. population = {1: a, 2: b} results = [] def compute_population(day): if day in population: return population[day] population[day] = compute_population(day - 1) + compute_population(day - 2) return population[day] for query in queries: if query[0] == 1: # Update the population on day query[1] to query[2] population[query[1]] = query[2] elif query[0] == 2: # Output the population on day query[1] results.append(compute_population(query[1])) return results"},{"question":"def calculate_interaction_times(events): Calculate the total interaction times for each customer from the given list of events. Parameters: - events: list of tuples (customer_id, event_type, timestamp) Returns: - dict: customer_id to total interaction time in seconds Examples: >>> events = [ ... (1, \\"start\\", 100), ... (2, \\"start\\", 150), ... (1, \\"end\\", 200), ... (1, \\"start\\", 300), ... (1, \\"end\\", 400), ... (2, \\"end\\", 250) ... ] >>> calculate_interaction_times(events) == {1: 200, 2: 100} True","solution":"def calculate_interaction_times(events): Calculate the total interaction times for each customer from the given list of events. Parameters: - events: list of tuples (customer_id, event_type, timestamp) Returns: - dict: customer_id to total interaction time in seconds interaction_times = {} start_times = {} for event in events: customer_id, event_type, timestamp = event if event_type == \\"start\\": start_times[customer_id] = timestamp elif event_type == \\"end\\": if customer_id in start_times: duration = timestamp - start_times.pop(customer_id) if customer_id in interaction_times: interaction_times[customer_id] += duration else: interaction_times[customer_id] = duration return interaction_times"},{"question":"from typing import List, Tuple def min_total_cost_after_discount(test_cases: List[List[int]]) -> List[int]: Given a list of test cases, each containing item prices, determine the minimum total cost after applying the discount to the maximum priced item in each possible bundle. >>> min_total_cost_after_discount([[1, 3, 4, 2], [5, 5, 5, 5, 5]]) [4, 15] >>> min_total_cost_after_discount([[1, 3, 2]]) [3] >>> min_total_cost_after_discount([[999999]]) [999999] >>> min_total_cost_after_discount([[7, 7, 7, 7, 7, 7]]) [21] >>> min_total_cost_after_discount([[10, 20, 30, 40, 50, 60]]) [90] def parse_input(input_str: str) -> List[List[int]]: Parse the input string to extract the test case data. >>> parse_input(\\"2n4n1 3 4 2n5n5 5 5 5 5n\\") [[1, 3, 4, 2], [5, 5, 5, 5, 5]] >>> parse_input(\\"1n3n1 3 2n\\") [[1, 3, 2]]","solution":"def min_total_cost_after_discount(test_cases): results = [] for prices in test_cases: prices.sort(reverse=True) n = len(prices) total_cost = 0 for i in range(0, n - 1, 2): total_cost += prices[i + 1] if n % 2 == 1: total_cost += prices[-1] results.append(total_cost) return results def parse_input(input_str): inputs = input_str.strip().split('n') idx = 0 T = int(inputs[idx]) idx += 1 test_cases = [] for _ in range(T): n = int(inputs[idx]) idx += 1 prices = list(map(int, inputs[idx].split())) idx += 1 test_cases.append(prices) return test_cases"},{"question":"from typing import List, Tuple def max_sessions(T: int, cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the maximum number of sessions that can be scheduled without exceeding the available hours. >>> max_sessions(2, [((5, 15), [2, 3, 5, 8, 1]), ((3, 8), [4, 2, 6])]) == [4, 2] >>> max_sessions(1, [((1, 1), [1])]) == [1] >>> max_sessions(1, [((2, 10), [5, 5])]) == [2] >>> max_sessions(1, [((3, 4), [5, 6, 7])]) == [0] >>> max_sessions(1, [((3, 10), [9, 5, 6])]) == [1] >>> max_sessions(1, [((4, 15), [5, 3, 6, 3])]) == [3] >>> max_sessions(3, [((10, 100), [20, 20, 20, 20, 20, 20, 20, 20, 20, 20]), ((10, 101), [20, 20, 20, 10, 1, 1, 1, 1, 1, 1]), ((10, 95), [10, 10, 10, 10, 10, 10, 10, 10, 10, 5])]) == [5, 10, 10]","solution":"def max_sessions(T, cases): result = [] for i in range(T): N, H = cases[i][0] D = cases[i][1] D.sort() total_hours = 0 sessions_count = 0 for duration in D: if total_hours + duration <= H: total_hours += duration sessions_count += 1 else: break result.append(sessions_count) return result"},{"question":"from typing import List, Tuple def calculate_revenue(test_cases: List[Tuple[int, List[List[int]]]]) -> List[int]: Calculate the total revenue generated from the winning bids for all auctions in each test case. >>> calculate_revenue([(3, [[100, 5, 130, 150, 120, 140, 150], [80, 3, 100, 90, 80], [50, 4, 55, 60, 50, 65]])]) [315] >>> calculate_revenue([(2, [[200, 2, 250, 300], [100, 3, 110, 110, 110]])]) [410] pass def parse_input(input_list: List[str]) -> List[Tuple[int, List[List[int]]]]: Parse the input data and return a list of test cases. >>> parse_input([\\"2\\", \\"3\\", \\"100 5 130 150 120 140 150\\", \\"80 3 100 90 80\\", \\"50 4 55 60 50 65\\", \\"2\\", \\"200 2 250 300\\", \\"100 3 110 110 110\\", \\"0\\"]) [(3, [[100, 5, 130, 150, 120, 140, 150], [80, 3, 100, 90, 80], [50, 4, 55, 60, 50, 65]]), (2, [[200, 2, 250, 300], [100, 3, 110, 110, 110]])] pass if __name__ == \\"__main__\\": input_data = [ \\"2\\", \\"3\\", \\"100 5 130 150 120 140 150\\", \\"80 3 100 90 80\\", \\"50 4 55 60 50 65\\", \\"2\\", \\"200 2 250 300\\", \\"100 3 110 110 110\\", \\"0\\" ] test_cases = parse_input(input_data) result = calculate_revenue(test_cases) for revenue in result: print(revenue)","solution":"def calculate_revenue(test_cases): revenues = [] for t in test_cases: m = t[0] total_revenue = 0 auctions = t[1] for auction in auctions: base_price = auction[0] bids = auction[2:] valid_bids = [bid for bid in bids if bid >= base_price] if valid_bids: highest_bid = max(valid_bids) total_revenue += highest_bid revenues.append(total_revenue) return revenues def parse_input(input_list): index = 0 test_cases = [] while index < len(input_list): T = int(input_list[index]) index += 1 if T == 0: break for _ in range(T): m = int(input_list[index]) index += 1 auctions = [] for _ in range(m): auction_info = list(map(int, input_list[index].split())) auctions.append(auction_info) index += 1 test_cases.append((m, auctions)) return test_cases"},{"question":"def flatten_and_filter(list_of_lists, threshold): Flattens a list of lists and returns a sorted list of integers greater than the given threshold. Args: list_of_lists (list of lists of int): The input list of lists of integers. threshold (int): The threshold above which integers are included in the output list. Returns: list of int: A sorted list of integers greater than the threshold. Example: >>> flatten_and_filter([[1, 4, 5], [3, 8], [2]], 4) [5, 8] >>> flatten_and_filter([[1, 2, 3], [0, -1], [4]], 5) []","solution":"def flatten_and_filter(list_of_lists, threshold): Flattens a list of lists and returns a sorted list of integers greater than the given threshold. Args: list_of_lists (list of lists of int): The input list of lists of integers. threshold (int): The threshold above which integers are included in the output list. Returns: list of int: A sorted list of integers greater than the threshold. result = [] for sublist in list_of_lists: for item in sublist: if item > threshold: result.append(item) return sorted(result)"},{"question":"from typing import List def min_time_to_reach_destination(n: int, grid: List[List[int]], sx: int, sy: int, dx: int, dy: int) -> int: Calculate the minimum time required for robots and their clones to reach the destination cell in a grid avoiding obstacles. Parameters: n (int): Size of the nxn grid grid (List[List[int]]): 2D grid containing 0 (empty cell) and 1 (obstacle) sx (int): Starting cell x-coordinate sy (int): Starting cell y-coordinate dx (int): Destination cell x-coordinate dy (int): Destination cell y-coordinate Returns: int: Minimum time required for all robots and their clones to reach the destination cell import pytest def test_min_time_to_reach_destination_example(): n = 5 grid = [ [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0] ] sx, sy = 0, 0 dx, dy = 4, 4 assert min_time_to_reach_destination(n, grid, sx, sy, dx, dy) == 8 def test_min_time_no_obstacles(): n = 3 grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] sx, sy = 0, 0 dx, dy = 2, 2 assert min_time_to_reach_destination(n, grid, sx, sy, dx, dy) == 4 def test_min_time_single_row(): n = 3 grid = [ [0, 1, 0], [0, 1, 0], [0, 1, 0] ] sx, sy = 0, 0 dx, dy = 2, 0 assert min_time_to_reach_destination(n, grid, sx, sy, dx, dy) == 2 def test_min_time_start_is_destination(): n = 2 grid = [ [0, 0], [0, 0] ] sx, sy = 0, 0 dx, dy = 0, 0 assert min_time_to_reach_destination(n, grid, sx, sy, dx, dy) == 0 def test_min_time_no_possible_path(): n = 3 grid = [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ] sx, sy = 0, 0 dx, dy = 2, 2 assert min_time_to_reach_destination(n, grid, sx, sy, dx, dy) == -1 if __name__ == \\"__main__\\": pytest.main()","solution":"from collections import deque def min_time_to_reach_destination(n, grid, sx, sy, dx, dy): def is_valid(x, y): return 0 <= x < n and 0 <= y < n and grid[x][y] == 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(sx, sy, 0)]) # (x, y, time) visited = set((sx, sy)) while queue: x, y, time = queue.popleft() if (x, y) == (dx, dy): return time for dx_i, dy_i in directions: nx, ny = x + dx_i, y + dy_i if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, time + 1)) return -1 # Should never happen if start and dest are valid # Example usage n = 5 grid = [ [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0] ] sx, sy = 0, 0 dx, dy = 4, 4 print(min_time_to_reach_destination(n, grid, sx, sy, dx, dy)) # Expected output: 8"},{"question":"def is_palindromic(number: int) -> bool: Returns True if the number is palindromic, False otherwise. >>> is_palindromic(1) True >>> is_palindromic(121) True >>> is_palindromic(123) False pass def count_palindromic_numbers(L: int, R: int) -> int: Returns the count of palindromic numbers in the range [L, R]. >>> count_palindromic_numbers(1, 10) 9 >>> count_palindromic_numbers(11, 20) 1 pass def solve(test_cases: List[Tuple[int, int]]) -> List[int]: For each test case, returns the count of palindromic numbers in the range [L, R]. >>> solve([(1, 10)]) [9] >>> solve([(1, 1), (10, 11)]) [1, 1] pass","solution":"def is_palindromic(number): Returns True if the number is palindromic, False otherwise. str_num = str(number) return str_num == str_num[::-1] def count_palindromic_numbers(L, R): Returns the count of palindromic numbers in the range [L, R]. count = 0 for num in range(L, R + 1): if is_palindromic(num): count += 1 return count def solve(test_cases): For each test case, prints the count of palindromic numbers in the range [L, R]. results = [] for L, R in test_cases: results.append(count_palindromic_numbers(L, R)) return results # Sample input test_cases = [(1, 10), (11, 20)] print(solve(test_cases)) # Expected output: [9, 1]"},{"question":"def max_non_adjacent_sum(arr): Returns the maximum sum of a subsequence with the property that no two elements in the subsequence are adjacent in the original array. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([3, 2, 7, 10]) 13 >>> max_non_adjacent_sum([5, 5, 10, 40, 50, 35]) 80 >>> max_non_adjacent_sum([5, 1, 1, 5]) 10 >>> max_non_adjacent_sum([-3, -2, -5, -10, -7]) 0 >>> max_non_adjacent_sum([-3, -2, 5, 10, -7]) 10 >>> max_non_adjacent_sum([0, 0, 0, 0]) 0 >>> max_non_adjacent_sum([0, 2, 0, 2]) 4","solution":"def max_non_adjacent_sum(arr): Returns the maximum sum of a subsequence with the property that no two elements in the subsequence are adjacent in the original array. if not arr: return 0 n = len(arr) if n == 1: return max(0, arr[0]) prev_one = max(0, arr[0]) prev_two = 0 for i in range(1, n): current = max(prev_one, prev_two + arr[i]) prev_two = prev_one prev_one = current return prev_one"},{"question":"def max_LAS_after_moves(N: int, K: int, arr: List[int]) -> int: Find the maximum length of the longest arithmetic subsequence (LAS) after making up to K moves. A move consists of removing one element from the list. Parameters: N (int): The number of elements in the list. K (int): The maximum number of elements that can be removed. arr (List[int]): The list of integers. Returns: int: The maximum length of the longest arithmetic subsequence after making up to K moves. Examples: >>> max_LAS_after_moves(6, 2, [4, 7, 10, 6, 3, 11]) 3 >>> max_LAS_after_moves(5, 0, [1, 4, 7, 10, 13]) 5 >>> max_LAS_after_moves(1, 1, [5]) 1 >>> max_LAS_after_moves(6, 2, [1, 5, 9, 12, 3, 6]) 3 >>> max_LAS_after_moves(10, 3, [1, 9, 4, 7, 10, 5, 14, 8, 12, 15]) 4 >>> max_LAS_after_moves(5, 5, [3, 6, 9, 12, 15]) 5","solution":"from collections import defaultdict def max_LAS_after_moves(N, K, arr): def longest_arith_seq_length(nums): if not nums: return 0 n = len(nums) dp = defaultdict(lambda: 1) max_length = 1 for i in range(n): for j in range(i): diff = nums[i] - nums[j] dp[(i, diff)] = dp[(j, diff)] + 1 max_length = max(max_length, dp[(i, diff)]) return max_length max_length = 0 for i in range(2**K): bit_mask = [idx for idx, bit in enumerate(f\\"{i:0{N}b}\\") if bit == '1'] if len(bit_mask) <= K: filtered_nums = [num for idx, num in enumerate(arr) if idx not in bit_mask] max_length = max(max_length, longest_arith_seq_length(filtered_nums)) return max_length"},{"question":"def product_except_self(nums): Given a list of integers, return a new list where each element is the product of all the elements in the original list except the element at the same position. Examples: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([4, 5, 6]) [30, 24, 20] >>> product_except_self([7, 3, 2, 9]) [54, 126, 189, 42] >>> product_except_self([0, 1, 2, 3]) [6, 0, 0, 0] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1]","solution":"def product_except_self(nums): Returns a list where each element is the product of all other elements except the element at the same position in the input list. length = len(nums) if length == 0: return [] # Initialize the answer array with 1 result = [1] * length # temp variable to store running product from the left left_product = 1 for i in range(length): result[i] *= left_product left_product *= nums[i] # temp variable to store running product from the right right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def sum_of_digits(n: int) -> int: Returns the sum of the digits of the given integer n. >>> sum_of_digits(1234) 10 >>> sum_of_digits(567) 18 pass def process_test_cases(T: int, cases: List[int]) -> List[int]: Process each test case and return a list of results. Parameters: T (int): The number of test cases. cases (list): A list of integers, each representing a test case. Returns: list: A list of results, each representing the sum of the digits of the given integer. >>> process_test_cases(3, [1234, 567, 9]) [10, 18, 9] >>> process_test_cases(2, [10203, 40005]) [6, 9] pass","solution":"def sum_of_digits(n): Returns the sum of the digits of the given integer n. return sum(int(digit) for digit in str(n)) def process_test_cases(T, cases): Process each test case and return a list of results. Parameters: T (int): The number of test cases. cases (list): A list of integers, each representing a test case. Returns: list: A list of results, each representing the sum of the digits of the given integer. results = [] for case in cases: results.append(sum_of_digits(case)) return results"},{"question":"def find_balanced_movies(n: int, votes: List[Tuple[int, int]]) -> Tuple[int, Union[List[int], str]]: Given the number of movies and a list of tuples representing the upvotes and downvotes for each movie, return the number of movies that are balanced and their indices. A balanced movie is defined as one where the number of upvotes equals the number of downvotes. :param n: int - the number of movies :param votes: list of tuples - each tuple contains two integers representing upvotes and downvotes for a movie :return: tuple - first element is the number of balanced movies, second element is a list of indices of balanced movies or a string \\"No balanced movies\\" >>> find_balanced_movies(5, [(10, 10), (5, 7), (3, 3), (8, 2), (4, 4)]) (3, [1, 3, 5]) >>> find_balanced_movies(4, [(12, 13), (5, 4), (8, 9), (20, 19)]) (0, \\"No balanced movies\\") >>> find_balanced_movies(0, []) (0, \\"No balanced movies\\") >>> find_balanced_movies(3, [(1, 1), (2, 2), (3, 3)]) (3, [1, 2, 3]) >>> find_balanced_movies(3, [(1, 2), (2, 3), (3, 4)]) (0, \\"No balanced movies\\") >>> find_balanced_movies(6, [(5, 5), (1, 2), (3, 3), (0, 1), (4, 4), (2, 10)]) (3, [1, 3, 5]) pass","solution":"def find_balanced_movies(n, votes): Given the number of movies and a list of tuples representing the upvotes and downvotes for each movie, return the number of movies that are balanced and their indices. :param n: int - the number of movies :param votes: list of tuples - each tuple contains two integers representing upvotes and downvotes for a movie :return: tuple - first element is the number of balanced movies, second element is a list of indices of balanced movies balanced_indices = [] for i, (upvotes, downvotes) in enumerate(votes): if upvotes == downvotes: balanced_indices.append(i + 1) if balanced_indices: return len(balanced_indices), balanced_indices else: return 0, \\"No balanced movies\\""},{"question":"def minTransformations(s: str) -> int: Given a string s consisting of lowercase English letters, determine the minimum number of characters to be transformed so that no two adjacent characters are the same. Parameters: s (str): The input string. Returns: int: The minimum number of characters to be transformed. Examples: >>> minTransformations(\\"aab\\") 1 >>> minTransformations(\\"aaaa\\") 3 >>> minTransformations(\\"abcdef\\") 0 >>> minTransformations(\\"ababab\\") 0 >>> minTransformations(\\"\\") 0 >>> minTransformations(\\"a\\") 0 >>> minTransformations(\\"aa\\") 1 >>> minTransformations(\\"ab\\") 0 >>> minTransformations(\\"aaaaaaa\\") 6","solution":"def minTransformations(s): Returns the minimum number of characters to be transformed so that no two adjacent characters are the same. changes = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: changes += 1 return changes"},{"question":"def isMeetingRoomAvailable(schedules: dict, requestedSlot: tuple) -> str: Determines if a meeting room is available for a new booking. Args: schedules: dictionary where the keys are meeting room names and the values are lists of tuples. Each tuple represents a booked time slot with start and end times in 24-hour format. requestedSlot: tuple representing the desired time slot for the new booking. Returns: The name of the meeting room if available, otherwise \\"No meeting room available\\". Example: >>> schedules = { 'RoomA': [('09:00', '10:00'), ('11:00', '12:30')], 'RoomB': [('08:00', '09:30'), ('12:00', '13:00')], 'RoomC': [('09:00', '10:00'), ('10:30', '12:00'), ('14:00', '15:00')] } >>> requestedSlot = ('10:00', '11:00') >>> isMeetingRoomAvailable(schedules, requestedSlot) 'RoomA'","solution":"def isMeetingRoomAvailable(schedules, requestedSlot): def are_slots_conflicting(slot1, slot2): return not (slot1[1] <= slot2[0] or slot2[1] <= slot1[0]) start_req, end_req = requestedSlot available_room = None for room in sorted(schedules.keys()): is_available = True for booked_slot in schedules[room]: if are_slots_conflicting(booked_slot, requestedSlot): is_available = False break if is_available: available_room = room break return available_room if available_room else \\"No meeting room available\\""},{"question":"def decode_morse(morse_code: str) -> str: Decodes a given string of Morse code into a readable message. >>> decode_morse('.... . .-.. .-.. ---') 'HELLO' >>> decode_morse('.... . .-.. .-.. ---') 'HE LLO' >>> decode_morse('.- -... -.-.') 'ABC' >>> decode_morse('.---- ..--- ...-- ....- ..... -.... --... ---.. ----. -----') '1234567890' >>> decode_morse('.... . -.-- .--- ..- -.. .') 'HEY JUDE' >>> decode_morse('') '' >>> decode_morse('.... . . .-.. .-.. ---') 'HE E LLO'","solution":"def decode_morse(morse_code): Decodes a given string of Morse code into a readable message. morse_table = { '.-': 'A', '-...': 'B', '-.-.': 'C', '-..': 'D', '.': 'E', '..-.': 'F', '--.': 'G', '....': 'H', '..': 'I', '.---': 'J', '-.-': 'K', '.-..': 'L', '--': 'M', '-.': 'N', '---': 'O', '.--.': 'P', '--.-': 'Q', '.-.': 'R', '...': 'S', '-': 'T', '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X', '-.--': 'Y', '--..': 'Z', '.----': '1', '..---': '2', '...--': '3', '....-': '4', '.....': '5', '-....': '6', '--...': '7', '---..': '8', '----.': '9', '-----': '0' } # Split words by three spaces words = morse_code.split(' ') decoded_message = [] for word in words: letters = word.split(' ') decoded_word = ''.join([morse_table[letter] for letter in letters if letter in morse_table]) decoded_message.append(decoded_word) return ' '.join(decoded_message)"},{"question":"def max_tasks_completed(tasks, workers): Find the maximum number of tasks that can be completed. :param tasks: List of task durations. :param workers: List of max durations workers can handle. :return: Maximum number of tasks completed. Example: >>> max_tasks_completed([2, 3, 5], [4, 1, 3]) 2 >>> max_tasks_completed([4, 3], [1, 2, 3]) 1 pass","solution":"def max_tasks_completed(tasks, workers): Find the maximum number of tasks that can be completed. :param tasks: List of task durations. :param workers: List of max durations workers can handle. :return: Maximum number of tasks completed. tasks.sort() workers.sort() task_index = 0 worker_index = 0 completed_tasks = 0 while task_index < len(tasks) and worker_index < len(workers): if workers[worker_index] >= tasks[task_index]: completed_tasks += 1 task_index += 1 worker_index += 1 return completed_tasks"},{"question":"def are_sequences_similar(seq1, seq2): Determine if two sequences are similar by finding if there's at least one contiguous subarray in one sequence that is identical to a contiguous subarray in the other sequence. >>> are_sequences_similar([1, 2, 3, 4, 5], [3, 4, 5, 6, 7]) 'similar' >>> are_sequences_similar([1, 2, 3], [4, 5, 6]) 'not similar' def parse_input(input_str): Convert input string to a list of integers. >>> parse_input(\\"1 2 3 4 5\\") == [1, 2, 3, 4, 5] True >>> parse_input(\\"\\") == [] True","solution":"def are_sequences_similar(seq1, seq2): def generate_subarrays(sequence): subarrays = set() n = len(sequence) for i in range(n): for j in range(i + 1, n + 1): subarrays.add(tuple(sequence[i:j])) return subarrays subarrays1 = generate_subarrays(seq1) subarrays2 = generate_subarrays(seq2) for subarray in subarrays1: if subarray in subarrays2: return \\"similar\\" return \\"not similar\\" # Convert input strings to lists of integers def parse_input(input_str): return list(map(int, input_str.split())) # Example usage # seq1 = parse_input(\\"1 2 3 4 5\\") # seq2 = parse_input(\\"3 4 5 6 7\\") # print(are_sequences_similar(seq1, seq2))"},{"question":"from typing import List def solve_tsp(test_cases: List[List[List[int]]]) -> List[int]: Find the minimum possible cost for visiting each city exactly once and returning to the starting city. >>> solve_tsp([[[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]]) == [80] >>> solve_tsp([[[0, 29, 20], [29, 0, 15], [20, 15, 0]]]) == [64] pass","solution":"def tsp(graph, pos, mask, dp): if mask == (1 << len(graph)) - 1: return graph[pos][0] if dp[pos][mask] != -1: return dp[pos][mask] answer = float('inf') for city in range(len(graph)): if (mask & (1 << city)) == 0: new_answer = graph[pos][city] + tsp(graph, city, mask | (1 << city), dp) answer = min(answer, new_answer) dp[pos][mask] = answer return answer def solve_tsp(test_cases): results = [] for graph in test_cases: n = len(graph) dp = [[-1] * (1 << n) for _ in range(n)] result = tsp(graph, 0, 1, dp) results.append(result) return results"},{"question":"def minimal_toy_moves(n: int, m: int) -> int: Calculate the minimal number of toy moves required to place at least one toy on each cell of the main diagonal for an n x m grid. >>> minimal_toy_moves(3, 3) 0 >>> minimal_toy_moves(2, 3) 1 >>> minimal_toy_moves(3, 2) 1 >>> minimal_toy_moves(1, 4) 3 >>> minimal_toy_moves(4, 1) 3 >>> minimal_toy_moves(1, 1) 0 >>> minimal_toy_moves(1, 2) 1 >>> minimal_toy_moves(2, 1) 1 >>> minimal_toy_moves(40, 40) 0 >>> minimal_toy_moves(35, 40) 5 >>> minimal_toy_moves(40, 35) 5","solution":"def minimal_toy_moves(n, m): Calculate the minimal number of toy moves required to place at least one toy on each cell of the main diagonal for an n x m grid. # The minimal number of moves required is |n - m|, # because if the grid is square (n == m), toys are already on the diagonal. # When n != m, we'll need additional moves to fill the missing diagonal cells. return abs(n - m)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addOne(head: ListNode) -> ListNode: Adds one to the number represented by the linked list and returns the new linked list. Args: head (ListNode): The head of the linked list representing the number. Returns: ListNode: The head of the modified linked list after adding 1 to it. >>> linked_list_to_list(addOne(list_to_linked_list([1, 2, 3]))) [1, 2, 4] >>> linked_list_to_list(addOne(list_to_linked_list([9, 9, 9]))) [1, 0, 0, 0] >>> linked_list_to_list(addOne(list_to_linked_list([0]))) [1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addOne(head): def reverseList(head): prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev head = reverseList(head) current = head carry = 1 while current: current.val += carry if current.val == 10: current.val = 0 carry = 1 else: carry = 0 if not current.next and carry: current.next = ListNode(1) carry = 0 current = current.next head = reverseList(head) return head"},{"question":"def findFirstUniqueChar(s: str) -> str: Returns the first unique character in the string \`s\`. If there is no unique character, returns '_'. >>> findFirstUniqueChar(\\"aabbcdde\\") == 'c' >>> findFirstUniqueChar(\\"aabbcc\\") == '_' >>> findFirstUniqueChar(\\"abcabc\\") == '_' >>> findFirstUniqueChar(\\"z\\") == 'z' >>> findFirstUniqueChar(\\"aabccbd\\") == 'd' >>> findFirstUniqueChar(\\"\\") == '_' >>> findFirstUniqueChar(\\"a\\") == 'a' >>> findFirstUniqueChar(\\"aaaaaaaaaaaz\\") == 'z' >>> findFirstUniqueChar(\\"abcdefghijklmnopqrstuvwxyz\\") == 'a'","solution":"def findFirstUniqueChar(s): Returns the first unique character in the string \`s\`. If there is no unique character, returns '_'. from collections import Counter # Count the frequency of each character char_count = Counter(s) # Iterate over the string to find the first character with a count of 1 for char in s: if char_count[char] == 1: return char # If no unique character is found, return '_' return '_'"},{"question":"def subarray_sum(nums, k): Returns the number of contiguous subarrays whose sum is equal to k. :param nums: List[int] - List of integers :param k: int - Target sum for contiguous subarrays :return: int - Number of subarrays that sum to k >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1, 2, 3], 3) 2 >>> subarray_sum([-1, -1, 1, 1], 0) 2 >>> subarray_sum([1, 2, 3], 6) 1 >>> subarray_sum([-1, -2, -3], -3) 2 >>> subarray_sum([1] * 10000, 10000) 1","solution":"def subarray_sum(nums, k): Returns the number of contiguous subarrays whose sum is equal to k. :param nums: List[int] - List of integers :param k: int - Target sum for contiguous subarrays :return: int - Number of subarrays that sum to k count = 0 curr_sum = 0 sum_dict = {0: 1} for num in nums: curr_sum += num if curr_sum - k in sum_dict: count += sum_dict[curr_sum - k] if curr_sum in sum_dict: sum_dict[curr_sum] += 1 else: sum_dict[curr_sum] = 1 return count"},{"question":"from typing import List, Tuple def minimum_moves_to_reach_destination(N: int, M: int, sx: int, sy: int, dx: int, dy: int, forbidden_cells: List[Tuple[int, int]]) -> int: Determine the minimum number of moves required for a submarine to reach the destination on a grid. Parameters: N (int): The number of rows in the grid. M (int): The number of columns in the grid. sx (int): Starting row index. sy (int): Starting column index. dx (int): Destination row index. dy (int): Destination column index. forbidden_cells (list of tuples): List of forbidden cells represented by (row, column) tuples. Returns: int: Minimum number of moves to reach the destination, or -1 if it's impossible. Examples: >>> minimum_moves_to_reach_destination(5, 5, 0, 0, 4, 4, [(1, 1), (1, 2), (1, 3)]) 8 >>> minimum_moves_to_reach_destination(5, 5, 0, 0, 4, 4, []) 8 >>> minimum_moves_to_reach_destination(5, 5, 0, 0, 4, 4, [(0, 1), (1, 0), (3, 4), (4, 3)]) -1 # Unit tests def test_minimum_moves_simple(): N, M = 5, 5 sx, sy, dx, dy = 0, 0, 4, 4 forbidden_cells = [(1, 1), (1, 2), (1, 3)] result = minimum_moves_to_reach_destination(N, M, sx, sy, dx, dy, forbidden_cells) assert result == 8 def test_minimum_moves_no_forbidden(): N, M = 5, 5 sx, sy, dx, dy = 0, 0, 4, 4 forbidden_cells = [] result = minimum_moves_to_reach_destination(N, M, sx, sy, dx, dy, forbidden_cells) assert result == 8 def test_minimum_moves_no_path(): N, M = 5, 5 sx, sy, dx, dy = 0, 0, 4, 4 forbidden_cells = [(0, 1), (1, 0), (3, 4), (4, 3)] result = minimum_moves_to_reach_destination(N, M, sx, sy, dx, dy, forbidden_cells) assert result == -1 def test_minimum_moves_with_blocked_destination(): N, M = 5, 5 sx, sy, dx, dy = 0, 0, 4, 4 forbidden_cells = [(4, 4)] result = minimum_moves_to_reach_destination(N, M, sx, sy, dx, dy, forbidden_cells) assert result == -1 def test_minimum_moves_large_grid(): N, M = 1000, 1000 sx, sy, dx, dy = 0, 0, 999, 999 forbidden_cells = [(500, 499)] result = minimum_moves_to_reach_destination(N, M, sx, sy, dx, dy, forbidden_cells) assert result == 1998","solution":"from collections import deque def minimum_moves_to_reach_destination(N, M, sx, sy, dx, dy, forbidden_cells): Determine the minimum number of moves required for a submarine to reach the destination on a grid. Parameters: N (int): The number of rows in the grid. M (int): The number of columns in the grid. sx (int): Starting row index. sy (int): Starting column index. dx (int): Destination row index. dy (int): Destination column index. forbidden_cells (list of tuples): List of forbidden cells represented by (row, column) tuples. Returns: int: Minimum number of moves to reach the destination, or -1 if it's impossible. # Directions for moving up, down, left, or right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Create a set of forbidden cells for quick lookup forbidden_set = set(forbidden_cells) # Initialize a queue for BFS queue = deque([(sx, sy, 0)]) # (row, column, distance) # Keep track of visited cells visited = set() visited.add((sx, sy)) # Perform BFS while queue: current_row, current_col, current_distance = queue.popleft() # If destination is reached, return the distance if (current_row, current_col) == (dx, dy): return current_distance # Explore each possible direction for dr, dc in directions: next_row, next_col = current_row + dr, current_col + dc # Check if the next move is within bounds and not forbidden or visited if (0 <= next_row < N and 0 <= next_col < M and (next_row, next_col) not in forbidden_set and (next_row, next_col) not in visited): queue.append((next_row, next_col, current_distance + 1)) visited.add((next_row, next_col)) # If destination is not reachable return -1"},{"question":"def find_repeated_product_ids(product_lists): Identify all the products that appear more than once in the list and return them in the order of their first occurrence. If no product ID is repeated, return an empty list. >>> find_repeated_product_ids([\\"23 42 23 56 78 56 23\\"]) [[23, 56]] >>> find_repeated_product_ids([\\"1 2 3 4 5\\"]) [[]] >>> find_repeated_product_ids([\\"10 20 30 40 20 10\\"]) [[20, 10]] >>> find_repeated_product_ids([\\"0\\"]) [] >>> find_repeated_product_ids([\\"23 42 23 56 78 56 23\\", \\"1 2 3 4 5\\", \\"10 20 30 40 20 10\\", \\"0\\"]) [[23, 56], [], [20, 10]]","solution":"def find_repeated_product_ids(product_lists): result = [] for products in product_lists: if products == \\"0\\": break ids = list(map(int, products.split())) id_count = {} repeated_ids = [] for id in ids: if id in id_count: id_count[id] += 1 if id_count[id] == 2: repeated_ids.append(id) else: id_count[id] = 1 result.append(repeated_ids) return result"},{"question":"def days_to_finish_books(n: int, p: int, pages: List[int]) -> List[int]: Determines the number of days required to complete each book. Parameters: n (int): Number of books. p (int): Pages read per day. pages (list of int): List with the number of pages in each book. Returns: list of int: A list with the number of days required to complete each book. >>> days_to_finish_books(3, 5, [12, 10, 8]) [3, 2, 2] >>> days_to_finish_books(5, 10, [15, 20, 10, 5, 30]) [2, 2, 1, 1, 3]","solution":"def days_to_finish_books(n, p, pages): Determines the number of days required to complete each book. Parameters: n (int): Number of books. p (int): Pages read per day. pages (list of int): List with the number of pages in each book. Returns: list of int: A list with the number of days required to complete each book. days = [] for book_pages in pages: days.append((book_pages + p - 1) // p) # Ceiling division operation return days"},{"question":"def printInvertedTriangle(n): Prints an inverted right-angled triangle pattern of asterisks, with the first row containing n asterisks, second row n-1 asterisks, and so forth until the last row, which contains 1 asterisk. >>> printInvertedTriangle(5) ***** **** *** ** * >>> printInvertedTriangle(3) *** ** * >>> printInvertedTriangle(1) * >>> printInvertedTriangle(2) ** *","solution":"def printInvertedTriangle(n): Prints an inverted right-angled triangle pattern of asterisks, with the first row containing n asterisks, second row n-1 asterisks, and so forth until the last row, which contains 1 asterisk. for i in range(n, 0, -1): print('*' * i)"},{"question":"def knapsack(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Determine the maximum total value that can be carried in a backpack without exceeding a given weight. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): A list of tuples where each tuple contains: - An integer N: the number of books. - An integer W: the maximum weight that can be carried. - A list of tuples (V, w): each tuple contains two integers V and w, the value and weight of each book respectively. Returns: List[int]: A list of integers indicating the maximum total value for each test case. Example: >>> T = 2 >>> test_cases = [ >>> (3, 50, [(60, 10), (100, 20), (120, 30)]), >>> (4, 10, [(10, 5), (40, 4), (30, 6), (50, 3)]) >>> ] >>> knapsack(T, test_cases) [220, 90]","solution":"def knapsack(T, test_cases): def max_value(N, W, items): # dp array to store the max value for each weight dp = [0] * (W + 1) for i in range(N): value, weight = items[i] # Traverse the dp array from right to left for w in range(W, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + value) return dp[W] results = [] for case in test_cases: N, W, items = case results.append(max_value(N, W, items)) return results # Example usage T = 2 test_cases = [ (3, 50, [(60, 10), (100, 20), (120, 30)]), (4, 10, [(10, 5), (40, 4), (30, 6), (50, 3)]) ] print(knapsack(T, test_cases)) # Output: [220, 90]"},{"question":"def calculate_shortest_route(n: int, s: int, distances: List[List[int]]) -> float: Calculate the shortest possible route that starts in a given town, visits all other towns exactly once, and returns to the starting town. Parameters: n (int): The number of towns (2 ≤ n ≤ 10) s (int): The starting town index (0 ≤ s < n) distances (List[List[int]]): A matrix where the j-th number in the i-th line represents the distance between town i and town j Returns: float: The minimum possible total distance of such a route, rounded to 2 decimal places Example: >>> n = 4 >>> s = 0 >>> distances = [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ] >>> calculate_shortest_route(n, s, distances) 80.00","solution":"import itertools def calculate_shortest_route(n, s, distances): min_distance = float('inf') # Generate all permutations of towns except the starting town towns = list(range(n)) towns.remove(s) permutations = itertools.permutations(towns) for perm in permutations: current_distance = 0 current_town = s # Calculate the distance for the current permutation for next_town in perm: current_distance += distances[current_town][next_town] current_town = next_town current_distance += distances[current_town][s] # return to starting town min_distance = min(min_distance, current_distance) return round(min_distance, 2) # Example usage: # n = 4 # s = 0 # distances = [ # [0, 10, 15, 20], # [10, 0, 35, 25], # [15, 35, 0, 30], # [20, 25, 30, 0] # ] # print(calculate_shortest_route(n, s, distances))"},{"question":"from typing import List def countUniqueElements(ar: List[int]) -> int: Given an array of integers, returns the number of unique elements in the array. >>> countUniqueElements([1, 2, 2, 3, 4, 4, 5]) 3 >>> countUniqueElements([1, 1, 1, 1, 1]) 0 >>> countUniqueElements([1, 2, 3, 4, 5]) 5 >>> countUniqueElements([10, 20, 20, 30, 40, 40, 50, 60]) 4 >>> countUniqueElements([]) 0 >>> countUniqueElements([100]) 1 >>> countUniqueElements([1, 2, 1, 2, 3, 3, 4, 5, 6, 6, 7]) 3","solution":"from typing import List def countUniqueElements(ar: List[int]) -> int: Returns the number of unique elements in the array. from collections import Counter element_counts = Counter(ar) unique_count = sum(1 for count in element_counts.values() if count == 1) return unique_count"},{"question":"def maxBuildingsVisited(heights: List[int], k: int) -> int: Determine the maximum number of buildings that can be visited starting from any building, given the height differences. Args: heights: List of integers representing the heights of buildings. k: Integer representing the maximum height difference tolerated. Returns: Integer representing the maximum number of buildings that can be visited starting from any building. Examples: >>> maxBuildingsVisited([1, 3, 4, 7, 6], 2) 3 >>> maxBuildingsVisited([10, 13, 12, 15, 14, 10], 3) 6 >>> maxBuildingsVisited([1, 2, 3, 4, 5], 0) 1","solution":"def maxBuildingsVisited(heights, k): Returns the maximum number of buildings that can be visited starting from any building. n = len(heights) max_count = 0 for i in range(n): count = 1 current_height = heights[i] for j in range(n): if i != j and abs(heights[j] - current_height) <= k: count += 1 max_count = max(max_count, count) return max_count"},{"question":"def sort_widgets(N, sizes): Returns the sizes of the widgets sorted in non-ascending order, omitting any widgets of size -1. Parameters: N (int): The number of widgets. sizes (list of int): List of widget sizes. Returns: list of int: Sorted list of widget sizes in non-ascending order without -1. >>> sort_widgets(5, [2, 3, -1, 6, 4]) [6, 4, 3, 2] >>> sort_widgets(4, [-1, -1, 5, 7]) [7, 5]","solution":"def sort_widgets(N, sizes): Returns the sizes of the widgets sorted in non-ascending order, omitting any widgets of size -1. Parameters: N (int): The number of widgets. sizes (list of int): List of widget sizes. Returns: list of int: Sorted list of widget sizes in non-ascending order without -1. # Filter out -1 sizes valid_sizes = [size for size in sizes if size != -1] # Sort in non-ascending order valid_sizes.sort(reverse=True) return valid_sizes"},{"question":"def is_problem_set_balanced(e1, e2, m1, m2, h1, h2): Determines if the problem set is balanced. A problem set is balanced if the total number of easy problems is at least \`e1\`, the total number of medium problems is at least \`m1\`, and the total number of hard problems is at least \`h1\`. Parameters: e1 (int): Required number of easy problems. e2 (int): Available number of easy problems. m1 (int): Required number of medium problems. m2 (int): Available number of medium problems. h1 (int): Required number of hard problems. h2 (int): Available number of hard problems. Returns: str: \\"BALANCED\\" if the problem set is balanced, otherwise \\"UNBALANCED\\". >>> is_problem_set_balanced(10, 15, 5, 10, 3, 5) \\"BALANCED\\" >>> is_problem_set_balanced(8, 5, 6, 6, 2, 1) \\"UNBALANCED\\" >>> is_problem_set_balanced(4, 4, 2, 2, 3, 3) \\"BALANCED\\" >>> is_problem_set_balanced(1, 2, 1, 2, 1, 2) \\"BALANCED\\" >>> is_problem_set_balanced(10, 9, 5, 6, 3, 2) \\"UNBALANCED\\" pass def handle_input_output(T, test_cases): Handles the input and output for the given test cases. For each test case, print a single line containing the string \\"BALANCED\\" if the problem set is balanced or \\"UNBALANCED\\" if it is not. Parameters: T (int): Number of test cases. test_cases (list of tuples): List containing tuples with 6 integers each (e1, e2, m1, m2, h1, h2). Returns: list: List of strings \\"BALANCED\\" or \\"UNBALANCED\\" for each test case. >>> T = 3 >>> test_cases = [ (10, 15, 5, 10, 3, 5), (8, 5, 6, 6, 2, 1), (4, 4, 2, 2, 3, 3) ] >>> handle_input_output(T, test_cases) [\\"BALANCED\\", \\"UNBALANCED\\", \\"BALANCED\\"] >>> T = 2 >>> test_cases = [ (1, 1, 1, 1, 1, 1), (2, 1, 2, 1, 2, 1) ] >>> handle_input_output(T, test_cases) [\\"BALANCED\\", \\"UNBALANCED\\"] pass","solution":"def is_problem_set_balanced(e1, e2, m1, m2, h1, h2): Determines if the problem set is balanced. Parameters: e1 (int): Required number of easy problems. e2 (int): Available number of easy problems. m1 (int): Required number of medium problems. m2 (int): Available number of medium problems. h1 (int): Required number of hard problems. h2 (int): Available number of hard problems. Returns: str: \\"BALANCED\\" if the problem set is balanced, otherwise \\"UNBALANCED\\". if e2 >= e1 and m2 >= m1 and h2 >= h1: return \\"BALANCED\\" else: return \\"UNBALANCED\\" def handle_input_output(T, test_cases): Handles the input and output for the given test cases. Parameters: T (int): Number of test cases. test_cases (list of tuples): List containing tuples with 6 integers each (e1, e2, m1, m2, h1, h2). Returns: list: List of strings \\"BALANCED\\" or \\"UNBALANCED\\" for each test case. results = [] for case in test_cases: result = is_problem_set_balanced(*case) results.append(result) return results"},{"question":"def solve(N: int, M: int, grid: List[str]) -> int: Determine the minimum number of steps required to move from the entrance to the exit. >>> solve(3, 3, ['000', '010', '000']) 4 >>> solve(3, 3, ['010', '111', '000']) -1","solution":"from collections import deque def min_steps_to_exit(grid): Determine the minimum number of steps required to move from the entrance to the exit. N = len(grid) M = len(grid[0]) # Check if the entrance or exit is a wall if grid[0][0] == '1' or grid[N-1][M-1] == '1': return -1 # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Breadth-First Search (BFS) initialization queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: row, col, steps = queue.popleft() # If we've reached the exit if row == N-1 and col == M-1: return steps for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < N and 0 <= new_col < M and (new_row, new_col) not in visited and grid[new_row][new_col] == '0': queue.append((new_row, new_col, steps + 1)) visited.add((new_row, new_col)) return -1 def solve(N, M, grid): return min_steps_to_exit(grid)"},{"question":"def minimum_absolute_difference(n, potencies): Returns the minimum absolute difference between any pair of potions' potency values. Parameters: n (int): Number of potions potencies (list[int]): List of potency values Returns: int: Minimum absolute difference >>> minimum_absolute_difference(5, [8, -3, 1, 0, -4]) 1 >>> minimum_absolute_difference(3, [5, 10, 15]) 5 >>> minimum_absolute_difference(4, [3, 8, 15, 11]) 3 >>> minimum_absolute_difference(4, [-10, -20, -30, -25]) 5 >>> minimum_absolute_difference(6, [1, -1, 4, -4, 10, -10]) 2 >>> minimum_absolute_difference(2, [0, 1]) 1","solution":"def minimum_absolute_difference(n, potencies): Returns the minimum absolute difference between any pair of potions' potency values. Parameters: n (int): Number of potions potencies (list[int]): List of potency values Returns: int: Minimum absolute difference # Sort the list of potencies potencies.sort() # Initialize the minimum difference to a large value min_diff = float('inf') # Iterate through the list and find the minimum difference for i in range(1, n): diff = abs(potencies[i] - potencies[i - 1]) if diff < min_diff: min_diff = diff return min_diff"},{"question":"def knapsack_max_value(T, test_cases): Determines the maximum value Alex can collect without exceeding the weight limit for multiple test cases. >>> knapsack_max_value(2, [ >>> (3, 50, [(60, 10), (100, 20), (120, 30)]), >>> (2, 10, [(10, 5), (20, 6)]) >>> ]) == [220, 20] >>> knapsack_max_value(1, [ >>> (3, 50, [(60, 10), (100, 20), (120, 30)]) >>> ]) == [220] >>> knapsack_max_value(1, [ >>> (0, 50, []) >>> ]) == [0] >>> knapsack_max_value(1, [ >>> (3, 100, [(60, 10), (100, 20), (120, 30)]) >>> ]) == [280] pass def parse_input_and_execute(input_data): Parses input data and executes the knapsack_max_value function. pass","solution":"def knapsack_max_value(T, test_cases): Determines the maximum value Alex can collect without exceeding the weight limit for multiple test cases. results = [] for case in test_cases: N, W, coins = case # Initialize a 2D DP array where dp[i][w] is the maximum value for the first i items and weight limit w dp = [[0 for _ in range(W + 1)] for _ in range(N + 1)] for i in range(1, N + 1): value, weight = coins[i-1] for w in range(W + 1): if w >= weight: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value) else: dp[i][w] = dp[i-1][w] results.append(dp[N][W]) return results # Example function to parse input data and execute knapsack_max_value def parse_input_and_execute(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N, W = map(int, lines[index].split()) index += 1 coins = [] for _ in range(N): value, weight = map(int, lines[index].split()) index += 1 coins.append((value, weight)) test_cases.append((N, W, coins)) return knapsack_max_value(T, test_cases)"},{"question":"def min_subarray_length(S: int, arr: list[int]) -> int: Find the smallest contiguous subarray length whose sum is greater than or equal to S. :param S: An integer representing the target sum. :param arr: A list of integers representing the array. :return: An integer representing the length of the smallest contiguous subarray with sum >= S. If no such subarray exists, return 0. >>> min_subarray_length(7, [2, 3, 1, 2, 4, 3]) 2 >>> min_subarray_length(100, [1, 2, 3, 4, 5]) 0 >>> min_subarray_length(15, [1, 2, 3, 4, 5]) 5 >>> min_subarray_length(5, [5]) 1 >>> min_subarray_length(5, [5, 1, 2, 3, 4]) 1 >>> min_subarray_length(5, [1, 2, 3, 4, 5]) 1 >>> min_subarray_length(100000, [1] * 99999 + [100000]) 1 >>> min_subarray_length(1000000, [1] * 50000 + [999999]) 2","solution":"def min_subarray_length(S: int, arr: list[int]) -> int: Function to find the smallest contiguous subarray length whose sum is greater than or equal to S. n = len(arr) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= S: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else 0"},{"question":"def reverse_between_max_elements(lst): Reverse the order of elements between the first and last occurrence of the maximum element in the list. If the maximum element occurs only once, return the original list. >>> reverse_between_max_elements([1, 3, 2, 7, 5, 7, 4]) == [1, 3, 2, 7, 5, 7, 4] >>> reverse_between_max_elements([1, 3, 7, 2, 7, 5, 4, 7]) == [1, 3, 7, 4, 5, 7, 2, 7] >>> reverse_between_max_elements([]) == [] >>> reverse_between_max_elements([7, 7, 7, 7]) == [7, 7, 7, 7] >>> reverse_between_max_elements([1, 7, 7, 1]) == [1, 7, 7, 1] >>> reverse_between_max_elements([7, 1, 2, 3, 7]) == [7, 3, 2, 1, 7]","solution":"def reverse_between_max_elements(lst): Reverse the order of elements between the first and last occurrence of the maximum element in the list. If the maximum element occurs only once, return the original list. if not lst: return lst max_element = max(lst) first_index = lst.index(max_element) last_index = len(lst) - 1 - lst[::-1].index(max_element) if first_index == last_index: return lst return lst[:first_index+1] + lst[first_index+1:last_index][::-1] + lst[last_index:] # Test the function with a couple of examples print(reverse_between_max_elements([1, 3, 2, 7, 5, 7, 4])) # Output: [1, 3, 2, 7, 5, 7, 4] print(reverse_between_max_elements([1, 3, 7, 2, 7, 5, 4, 7])) # Output: [1, 3, 7, 4, 5, 7, 2, 7]"},{"question":"def uniqueElements(arr): Returns a new array with all duplicate elements removed, maintaining the order of first appearances. >>> uniqueElements([1, 2, 2, 3, 4, 4, 5, 1]) [1, 2, 3, 4, 5] >>> uniqueElements([1, 1, 1, 1, 1, 1, 1]) [1] >>> uniqueElements([4, 5, 6, 6, 7, 5, 8, 9]) [4, 5, 6, 7, 8, 9] >>> uniqueElements([]) [] >>> uniqueElements([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5]","solution":"def uniqueElements(arr): Returns a new array with all duplicate elements removed, maintaining the order of first appearances. seen = set() result = [] for number in arr: if number not in seen: seen.add(number) result.append(number) return result"},{"question":"from typing import List def generatePascalsTriangle(n: int) -> List[List[int]]: Generates the first n rows of Pascal's Triangle. Parameters: n (int): The number of rows to generate, where 1 <= n <= 30. Returns: List[List[int]]: The first n rows of Pascal's Triangle. >>> generatePascalsTriangle(1) [[1]] >>> generatePascalsTriangle(4) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]] def test_generate_pascals_triangle(): assert generatePascalsTriangle(1) == [[1]] assert generatePascalsTriangle(2) == [[1], [1, 1]] assert generatePascalsTriangle(3) == [[1], [1, 1], [1, 2, 1]] assert generatePascalsTriangle(4) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]] assert generatePascalsTriangle(5) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] assert generatePascalsTriangle(6) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1]] if __name__ == \\"__main__\\": test_generate_pascals_triangle() print(\\"All tests passed!\\")","solution":"def generatePascalsTriangle(n: int): Generates the first n rows of Pascal's Triangle. Parameters: n (int): The number of rows to generate, where 1 <= n <= 30. Returns: List[List[int]]: The first n rows of Pascal's Triangle. # Initialize the Pascal's Triangle triangle = [] for i in range(n): row = [1] * (i + 1) for j in range(1, i): row[j] = triangle[i-1][j-1] + triangle[i-1][j] triangle.append(row) return triangle"},{"question":"from typing import List def is_path(grid: List[List[int]]) -> bool: Determine if there is a path from the top-left corner of the grid to the bottom-right corner, moving only right or down, and avoiding obstacles. >>> is_path([ [0, 0, 1], [1, 0, 1], [1, 0, 0] ]) == True >>> is_path([ [0, 1], [1, 0] ]) == False","solution":"from typing import List def is_path(grid: List[List[int]]) -> bool: if grid[0][0] == 1 or grid[-1][-1] == 1: return False n = len(grid) m = len(grid[0]) def dfs(x, y): if x < 0 or y < 0 or x >= n or y >= m or grid[x][y] == 1: return False if x == n - 1 and y == m - 1: # Reach the bottom-right corner return True grid[x][y] = 1 # Mark as visited by setting to 1 # Explore right and down return dfs(x + 1, y) or dfs(x, y + 1) return dfs(0, 0)"},{"question":"def track_document(operations: List[str]) -> List[int]: Track the state of the document after each operation and count the total number of words in the document. >>> track_document([\\"INSERT hello\\", \\"INSERT world\\", \\"DELETE\\", \\"UNDO\\", \\"INSERT evan\\", \\"DELETE\\", \\"UNDO\\"]) [1, 2, 1, 2, 3, 2, 3] >>> track_document([\\"INSERT apple\\", \\"INSERT banana\\", \\"INSERT cherry\\", \\"DELETE\\", \\"UNDO\\", \\"DELETE\\"]) [1, 2, 3, 2, 3, 2] >>> track_document([\\"INSERT one\\", \\"INSERT two\\", \\"UNDO\\", \\"INSERT three\\", \\"DELETE\\", \\"UNDO\\", \\"UNDO\\"]) [1, 2, 1, 2, 1, 2, 1] >>> track_document([]) [] >>> track_document([\\"INSERT lone\\"]) [1] >>> track_document([\\"DELETE\\"]) [0] >>> track_document([\\"UNDO\\"]) [0] >>> track_document([\\"INSERT first\\", \\"UNDO\\", \\"UNDO\\", \\"UNDO\\"]) [1, 0, 0, 0]","solution":"def track_document(operations): document = [] history = [] results = [] for operation in operations: if operation.startswith(\\"INSERT\\"): _, word = operation.split() document.append(word) history.append([\\"INSERT\\", word]) elif operation == \\"DELETE\\": if document: last_word = document.pop() history.append([\\"DELETE\\", last_word]) else: history.append([\\"DELETE\\", None]) elif operation == \\"UNDO\\": if history: last_action = history.pop() if last_action[0] == \\"INSERT\\": document.pop() elif last_action[0] == \\"DELETE\\": if last_action[1] is not None: document.append(last_action[1]) results.append(len(document)) return results"},{"question":"import heapq from typing import List def add_edge(graph, a, b, d): Adds or updates a direct connection with a specified latency between two hubs. if a not in graph: graph[a] = {} if b not in graph: graph[b] = {} graph[a][b] = d graph[b][a] = d def dijkstra(graph, start): Finds the shortest path latency from the start node to all other nodes using Dijkstra's algorithm. distances = {node: float('inf') for node in graph} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def process_operations(n: int, q: int, operations: List[str]) -> List[int]: Processes a series of operations to either add edges to the graph or query shortest path latencies. Args: n (int): Number of hubs. q (int): Number of operations. operations (List[str]): List of operations to be processed. Returns: List[int]: Results of 'QUERY' operations with shortest path latencies or -1 if no path exists. >>> process_operations(5, 7, [\\"ADD 1 2 10\\", \\"ADD 2 3 5\\", \\"ADD 3 4 7\\", \\"QUERY 1 4\\", \\"ADD 1 4 15\\", \\"ADD 4 5 1\\", \\"QUERY 1 5\\"]) [22, 16] >>> process_operations(3, 3, [\\"ADD 1 2 10\\", \\"QUERY 1 3\\", \\"QUERY 2 3\\"]) [-1, -1] graph = {} results = [] for operation in operations: parts = operation.split() command = parts[0] a = int(parts[1]) b = int(parts[2]) if command == \\"ADD\\": d = int(parts[3]) add_edge(graph, a, b, d) elif command == \\"QUERY\\": if a not in graph or b not in graph: results.append(-1) else: distances = dijkstra(graph, a) result = distances.get(b, float('inf')) results.append(result if result != float('inf') else -1) return results","solution":"import heapq def add_edge(graph, a, b, d): if a not in graph: graph[a] = {} if b not in graph: graph[b] = {} graph[a][b] = d graph[b][a] = d def dijkstra(graph, start): distances = {node: float('inf') for node in graph} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def process_operations(n, q, operations): graph = {} results = [] for operation in operations: parts = operation.split() command = parts[0] a = int(parts[1]) b = int(parts[2]) if command == \\"ADD\\": d = int(parts[3]) add_edge(graph, a, b, d) elif command == \\"QUERY\\": if a not in graph or b not in graph: results.append(-1) else: distances = dijkstra(graph, a) result = distances.get(b, float('inf')) results.append(result if result != float('inf') else -1) return results"},{"question":"def total_scores(test_cases): This function calculates the total scores for each test case. :param test_cases: List of test cases where each test case is a tuple of number of problems and a list of scores. :return: List of total scores for each test case. >>> total_scores([(5, [1, 2, 3, 4, 5]), (3, [10, 20, 30]), (4, [11, 12, 13, 14])]) [15, 60, 50] >>> total_scores([(1, [10]), (1, [20])]) [10, 20] results = [] for problems, scores in test_cases: results.append(sum(scores)) return results # Helper function to parse input def parse_input(input_string): This function parses the input string into a list of test cases. :param input_string: Input string containing multiple test cases. :return: List of test cases where each test case is a tuple of number of problems and a list of scores. >>> parse_input(\\"2n3n1 2 3n4n4 5 6 7\\") [(3, [1, 2, 3]), (4, [4, 5, 6, 7])] lines = input_string.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): P = int(lines[index]) scores = list(map(int, lines[index + 1].split())) test_cases.append((P, scores)) index += 2 return test_cases","solution":"def total_scores(test_cases): This function calculates the total scores for each test case. :param test_cases: List of test cases where each test case is a tuple of number of problems and a list of scores. :return: List of total scores for each test case. results = [] for problems, scores in test_cases: results.append(sum(scores)) return results # Helper function to parse input def parse_input(input_string): lines = input_string.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): P = int(lines[index]) scores = list(map(int, lines[index + 1].split())) test_cases.append((P, scores)) index += 2 return test_cases"},{"question":"def kruskal_mst(V, edges): Returns the total length of the roads in the minimum spanning tree using Kruskal's algorithm. >>> kruskal_mst(4, [(1, 2, 10), (1, 3, 6), (1, 4, 5), (2, 3, 4), (3, 4, 7)]) 15 >>> kruskal_mst(3, [(1, 2, 3), (2, 3, 5), (1, 3, 4)]) 7 pass def solve_mst_cases(test_cases): Solves multiple MST cases and returns a list of results. >>> solve_mst_cases([(4, 5, [(1, 2, 10), (1, 3, 6), (1, 4, 5), (2, 3, 4), (3, 4, 7)]), (3, 3, [(1, 2, 3), (2, 3, 5), (1, 3, 4)])]) [15, 7] pass def parse_input(input_string): Parses the input string and returns the test cases in the required format. >>> parse_input(2n4 5n1 2 10n1 3 6n1 4 5n2 3 4n3 4 7n3 3n1 2 3n2 3 5n1 3 4) [(4, 5, [(1, 2, 10), (1, 3, 6), (1, 4, 5), (2, 3, 4), (3, 4, 7)]), (3, 3, [(1, 2, 3), (2, 3, 5), (1, 3, 4)])] pass def main(input_string): Main function to process the input and produce the output. >>> main(2n4 5n1 2 10n1 3 6n1 4 5n2 3 4n3 4 7n3 3n1 2 3n2 3 5n1 3 4) \\"15n7\\" pass","solution":"def kruskal_mst(V, edges): Returns the total length of the roads in the minimum spanning tree using Kruskal's algorithm. # Sort edges by ascending edge weight edges.sort(key=lambda x: x[2]) parent = list(range(V + 1)) rank = [0] * (V + 1) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 mst_weight = 0 for u, v, weight in edges: if find(u) != find(v): union(u, v) mst_weight += weight return mst_weight def solve_mst_cases(test_cases): results = [] for V, E, edges in test_cases: result = kruskal_mst(V, edges) results.append(result) return results def parse_input(input_string): input_lines = input_string.split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): V, E = map(int, input_lines[index].strip().split()) index += 1 edges = [] for _ in range(E): U, W, L = map(int, input_lines[index].strip().split()) index += 1 edges.append((U, W, L)) test_cases.append((V, E, edges)) return test_cases def main(input_string): test_cases = parse_input(input_string) results = solve_mst_cases(test_cases) return \\"n\\".join(map(str, results)) # The above code is designed to receive the input as a single string and output the required results as the main function. # Here's an example of how it might be used: # input_string = 2 # 4 5 # 1 2 10 # 1 3 6 # 1 4 5 # 2 3 4 # 3 4 7 # 3 3 # 1 2 3 # 2 3 5 # 1 3 4 # print(main(input_string))"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the given string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd frequency. Args: s (str): The input string containing lowercase alphabetical characters. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False","solution":"def can_form_palindrome(s): Determines if the given string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd frequency. Args: s (str): The input string containing lowercase alphabetical characters. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def calculate_unique_recipients(F, N): Compute how many unique recipients will receive the message assuming it can only be forwarded N times. >>> calculate_unique_recipients(2, 0) == 2 >>> calculate_unique_recipients(1, 1) == 2 >>> calculate_unique_recipients(2, 2) == 7 >>> calculate_unique_recipients(3, 3) == 40 >>> calculate_unique_recipients(1, 2) == 3 def process_test_cases(T, test_cases): Process multiple test cases for the chain message problem. >>> process_test_cases(3, [(2, 0), (1, 1), (2, 2)]) == [2, 2, 7] >>> process_test_cases(3, [(2, 1), (2, 2), (2, 3)]) == [3, 7, 15] >>> process_test_cases(3, [(3, 3), (1, 2), (5, 1)]) == [40, 3, 6]","solution":"def calculate_unique_recipients(F, N): if N == 0: return F total_recipients = 0 for i in range(N + 1): total_recipients += F ** i return total_recipients def process_test_cases(T, test_cases): results = [] for i in range(T): F, N = test_cases[i] results.append(calculate_unique_recipients(F, N)) return results"},{"question":"def fibonacciSum(n: int) -> int: Write a function named \`fibonacciSum\` that takes a single integer \`n\` and returns the sum of the first \`n\` Fibonacci numbers. The Fibonacci sequence is characterized by the fact that every number after the first two is the sum of the two preceding ones, starting with 0 and 1. >>> fibonacciSum(0) == 0 >>> fibonacciSum(1) == 0 >>> fibonacciSum(2) == 1 >>> fibonacciSum(5) == 7 >>> fibonacciSum(10) == 88 >>> fibonacciSum(-5) == 0","solution":"def fibonacciSum(n): Returns the sum of the first n Fibonacci numbers. if n <= 0: return 0 a, b = 0, 1 sum_fib = a # initial sum is the first Fibonacci number for _ in range(1, n): sum_fib += b a, b = b, a + b return sum_fib"},{"question":"def second_largest_unique_number(test_cases): This function accepts a list of test cases where each test case is a list of integers. It returns a list containing the second largest unique number for each test case or \\"None\\" if there isn't one. >>> second_largest_unique_number([[2, 3, 5, 5, 6]]) [\\"5\\"] >>> second_largest_unique_number([[1, 1, 3, 3]]) [\\"1\\"] >>> second_largest_unique_number([[7, 7, 7, 7, 7]]) [\\"None\\"]","solution":"def second_largest_unique_number(test_cases): This function accepts a list of test cases where each test case is a list of integers. It returns a list containing the second largest unique number for each test case or \\"None\\" if there isn't one. results = [] for nums in test_cases: unique_nums = list(set(nums)) # Remove duplicates if len(unique_nums) < 2: results.append(\\"None\\") else: unique_nums.sort(reverse=True) results.append(unique_nums[1]) return results"},{"question":"def process_order(order: str) -> list: Translates a string of characters into the corresponding list of bakery items. Parameters: order (str): A string where each character represents a bakery item. Returns: list: A list of bakery items corresponding to the characters in the order string. >>> process_order(\\"ABCDE\\") == ['Apple Pie', 'Banana Bread', 'Carrot Cake', 'Doughnut', 'Eclair'] >>> process_order(\\"AAABBB\\") == ['Apple Pie', 'Apple Pie', 'Apple Pie', 'Banana Bread', 'Banana Bread', 'Banana Bread'] >>> process_order(\\"\\") == [] >>> process_order(\\"ZX\\") == [] >>> process_order(\\"ABZDE\\") == ['Apple Pie', 'Banana Bread', 'Doughnut', 'Eclair'] >>> process_order(\\"A\\") == ['Apple Pie'] >>> process_order(\\"B\\") == ['Banana Bread']","solution":"def process_order(order): Translates a string of characters into the corresponding list of bakery items. Parameters: order (str): A string where each character represents a bakery item. Returns: list: A list of bakery items corresponding to the characters in the order string. menu = { 'A': 'Apple Pie', 'B': 'Banana Bread', 'C': 'Carrot Cake', 'D': 'Doughnut', 'E': 'Eclair' } return [menu[char] for char in order if char in menu]"},{"question":"def min_operations(s: str, t: str) -> int: Calculate the minimum number of operations required to convert string s into string t. Args: s (str): Source string. t (str): Target string. Returns: int: Minimum number of operations. Examples: >>> min_operations(\\"abcdef\\", \\"azced\\") 3 >>> min_operations(\\"sunday\\", \\"saturday\\") 3 >>> min_operations(\\"test\\", \\"test\\") 0 >>> min_operations(\\"\\", \\"abc\\") 3 >>> min_operations(\\"abc\\", \\"\\") 3 >>> min_operations(\\"a\\", \\"b\\") 1 >>> min_operations(\\"a\\", \\"a\\") 0 >>> min_operations(\\"aaa\\", \\"bbb\\") 3 >>> min_operations(\\"kit\\", \\"kitten\\") 3 >>> min_operations(\\"complex\\", \\"plex\\") 3 >>> min_operations(\\"horse\\", \\"ros\\") 3 pass","solution":"def min_operations(s, t): Calculate the minimum number of operations required to convert string s into string t. Args: s (str): Source string. t (str): Target string. Returns: int: Minimum number of operations. m, n = len(s), len(t) # Create a table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp[][] in bottom up manner for i in range(m + 1): for j in range(n + 1): # If first string is empty, only option is to insert all characters of second string if i == 0: dp[i][j] = j # minOperations(i, j) = j # If second string is empty, only option is to remove all characters of first string elif j == 0: dp[i][j] = i # minOperations(i, j) = i # If last characters are same, ignore last characters and recur for remaining string elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If last character are different, consider all possibilities and find minimum else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"def evaluateExpression(expression: str) -> float: Evaluates a mathematical expression and returns the result rounded to two decimal places. >>> evaluateExpression(\\"3 + 2 * 2\\") 7.00 >>> evaluateExpression(\\"(1 + 2) * 4 - 3 / 2\\") 10.50 >>> evaluateExpression(\\"10 + 0 * (3 / (1 + 2))\\") 10.00","solution":"def evaluateExpression(expression): Evaluates a mathematical expression and returns the result rounded to two decimal places. try: # Evaluate the expression using Python's eval function result = eval(expression) # Check for division by zero if isinstance(result, float) and result == float('inf'): return None # Return the result rounded to two decimal places return round(result, 2) except ZeroDivisionError: return None except Exception as e: return None"},{"question":"from typing import List def four_sum(nums: List[int], target: int) -> List[List[int]]: Finds all unique quadruplets [a, b, c, d] in the array which sum to the target. >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([2, 2, 2, 2, 2], 8) [[2, 2, 2, 2]] pass","solution":"def four_sum(nums, target): Returns all unique quadruplets in the list that sum up to the target value. nums.sort() # Sort the input list quadruplets = [] n = len(nums) for i in range(n-3): if i > 0 and nums[i] == nums[i-1]: continue for j in range(i+1, n-2): if j > i+1 and nums[j] == nums[j-1]: continue left, right = j + 1, n - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: quadruplets.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left+1]: left += 1 while left < right and nums[right] == nums[right-1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return quadruplets"},{"question":"def count_distinct_color_ways(n, m, c): Returns the number of distinct ways to color the grid such that the border has a different color from the inner portion. >>> count_distinct_color_ways(3, 4, 5) 20 >>> count_distinct_color_ways(2, 2, 3) 6 >>> count_distinct_color_ways(2, 2, 2) 2 >>> count_distinct_color_ways(1000, 1000, 1000) 999000 >>> count_distinct_color_ways(1000, 1000, 2) 2 >>> count_distinct_color_ways(1000, 1000, 1) 0","solution":"def count_distinct_color_ways(n, m, c): Returns the number of distinct ways to color the grid such that the border has a different color from the inner portion. if c < 2: return 0 # If there are less than 2 colors, it's not possible to have different colors for border and inner return c * (c - 1)"},{"question":"def string_to_integer(s: str) -> int: Converts a string to an integer following specific rules. >>> string_to_integer(\\"42\\") 42 >>> string_to_integer(\\" -42\\") -42 >>> string_to_integer(\\"4193 with words\\") 4193 >>> string_to_integer(\\"words and 987\\") 0 >>> string_to_integer(\\"-91283472332\\") -2147483648 from solution import string_to_integer def test_string_to_integer_positive(): assert string_to_integer(\\"42\\") == 42 assert string_to_integer(\\"4193 with words\\") == 4193 def test_string_to_integer_negative(): assert string_to_integer(\\" -42\\") == -42 assert string_to_integer(\\"-91283472332\\") == -2147483648 def test_string_to_integer_zero(): assert string_to_integer(\\"words and 987\\") == 0 assert string_to_integer(\\"\\") == 0 assert string_to_integer(\\" \\") == 0 def test_string_to_integer_with_signs(): assert string_to_integer(\\"+1\\") == 1 assert string_to_integer(\\"+-2\\") == 0 def test_string_to_integer_boundary_conditions(): assert string_to_integer(str(2**31)) == 2147483647 assert string_to_integer(str(-2**31 - 1)) == -2147483648 def test_string_to_integer_with_leading_spaces(): assert string_to_integer(\\" 123\\") == 123 assert string_to_integer(\\" +123\\") == 123 assert string_to_integer(\\" -123\\") == -123","solution":"def string_to_integer(s: str) -> int: Converts a string to an integer following specific rules. s = s.strip() if not s: return 0 is_negative = False index = 0 if s[0] == '-': is_negative = True index += 1 elif s[0] == '+': index += 1 num = 0 MAX_INT = 2**31 - 1 MIN_INT = -2**31 while index < len(s) and s[index].isdigit(): num = num * 10 + int(s[index]) index += 1 if is_negative: num = -num if num < MIN_INT: return MIN_INT elif num > MAX_INT: return MAX_INT return num"},{"question":"def process_queries(N: int, Q: int, A: List[int], queries: List[Tuple[int, int]]) -> List[int]: Process a series of queries on the array A. Parameters: N (int): Initial length of the array. Q (int): Number of queries. A (List[int]): Initial array. queries (List[Tuple[int, int]]): List of queries where each query is represented by a tuple (T, X). Returns: List[int]: A list of integers representing the results of T=5 queries. >>> process_queries(5, 5, [3, 1, 4, 1, 5], [(1, 9), (3, 2), (5, 0), (4, 3), (5, 0)]) [3, 9] >>> process_queries(3, 3, [5, 10, 15], [(3, 5), (5, 0), (4, 2)]) [10] def test_process_queries_add(): assert process_queries(5, 1, [3, 1, 4, 1, 5], [(1, 9)]) == [] assert process_queries(1, 1, [1], [(1, 2)]) == [] def test_process_queries_remove(): assert process_queries(5, 2, [3, 1, 4, 1, 5], [(2, 0), (2, 0)]) == [] assert process_queries(2, 2, [1, 2], [(2, 0), (2, 0)]) == [] def test_process_queries_increment(): assert process_queries(5, 1, [3, 1, 4, 1, 5], [(3, 2)]) == [] assert process_queries(2, 1, [1, 2], [(3, 3)]) == [] def test_process_queries_multiply(): assert process_queries(5, 1, [3, 1, 4, 1, 5], [(4, 2)]) == [] assert process_queries(3, 1, [1, 2, 3], [(4, 3)]) == [] def test_process_queries_minimum(): assert process_queries(5, 1, [3, 1, 4, 1, 5], [(5, 0)]) == [1] assert process_queries(3, 1, [1, 2, 3], [(5, 0)]) == [1] def test_process_queries_mixed_operations(): assert process_queries(5, 5, [3, 1, 4, 1, 5], [(1, 9), (3, 2), (5, 0), (4, 3), (5, 0)]) == [3, 9] assert process_queries(3, 3, [5, 10, 15], [(3, 5), (5, 0), (4, 2)]) == [10]","solution":"def process_queries(N, Q, A, queries): results = [] for T, X in queries: if T == 1: A.append(X) elif T == 2: if A: A.pop() elif T == 3: A = [a + X for a in A] elif T == 4: A = [a * X for a in A] elif T == 5: if A: results.append(min(A)) return results"},{"question":"def longest_balanced_substring(S: str) -> int: Returns the length of the longest balanced substring within the given string of brackets. >>> longest_balanced_substring(\\"(()))\\") 4 >>> longest_balanced_substring(\\"(())\\") 4 >>> longest_balanced_substring(\\"()\\") 2 >>> longest_balanced_substring(\\"((((((\\") 0 >>> longest_balanced_substring(\\")()(()\\") 2","solution":"def longest_balanced_substring(S): Returns the length of the longest balanced substring within the given string of brackets. max_length = 0 stack = [] last_invalid_index = -1 for i, char in enumerate(S): if char == '(': stack.append(i) else: if stack: stack.pop() if stack: max_length = max(max_length, i - stack[-1]) else: max_length = max(max_length, i - last_invalid_index) else: last_invalid_index = i return max_length"},{"question":"def can_choose_subset_with_same_ending(T, test_cases): Determine if it's possible to choose a subset of words where all words end with the same K characters. >>> can_choose_subset_with_same_ending(2, [ (4, 2, ['hello', 'jello', 'mellow', 'yellow']), (3, 3, ['imana', 'banana', 'ana', 'canada']) ]) ['YES', 'YES'] >>> can_choose_subset_with_same_ending(1, [ (3, 3, ['cat', 'dog', 'fish']) ]) ['NO']","solution":"def can_choose_subset_with_same_ending(T, test_cases): results = [] for i in range(T): N, K, words = test_cases[i] suffixes = {} for word in words: suffix = word[-K:] if suffix in suffixes: suffixes[suffix] += 1 else: suffixes[suffix] = 1 if any(count > 1 for count in suffixes.values()): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def second_highest(numbers: List[int]) -> int: Given a list of integers, find and return the second highest number in the list. If the list has fewer than two unique numbers, return the highest number instead. >>> second_highest([10, 5, 8, 10]) 8 >>> second_highest([1]) 1 >>> second_highest([5, 9, 3, 4, 7]) 7 >>> second_highest([10, 15, 20, 25, 30]) 25 >>> second_highest([1, 2, 2, 3, 3, 4]) 3 >>> second_highest([100, 99, 100, 98]) 99","solution":"def second_highest(numbers): Given a list of integers, returns the second-highest number in the list. If there are fewer than two unique numbers, returns the highest number. unique_numbers = list(set(numbers)) # Remove duplicates if len(unique_numbers) < 2: return max(unique_numbers) unique_numbers.sort() return unique_numbers[-2]"},{"question":"def maximize_tasks(n: int, t: int, tasks: List[Tuple[int, int]]) -> int: Determine the maximum number of tasks that can be completed within the given time duration, ensuring that tasks with higher priorities are completed first if possible. Parameters: n (int): Number of tasks. t (int): Available time duration. tasks (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing the priority and completion time of a task. Returns: int: Maximum number of tasks that can be completed within the given time duration. >>> maximize_tasks(5, 10, [(3, 2), (1, 3), (2, 1), (5, 4), (4, 2)]) 4 >>> maximize_tasks(3, 5, [(2, 3), (1, 4), (3, 2)]) 2 >>> maximize_tasks(4, 10, [(1, 2), (4, 1), (3, 2), (2, 2)]) 4 >>> maximize_tasks(4, 7, [(1, 2), (4, 1), (2, 2), (1, 3)]) 3 >>> maximize_tasks(4, 5, [(2, 1), (2, 2), (2, 3), (2, 4)]) 2 >>> maximize_tasks(3, 1, [(1, 2), (2, 3), (3, 4)]) 0","solution":"def maximize_tasks(n, t, tasks): This function takes the number of tasks, available time and a list of tasks with their priorities and completion times. It returns the maximum number of tasks that can be completed within the given time. # Sort the tasks first by priority (highest first) and then by completion time (lowest first) for same priority tasks.sort(key=lambda x: (-x[0], x[1])) completed_tasks = 0 current_time = 0 for priority, time in tasks: if current_time + time <= t: current_time += time completed_tasks += 1 else: break return completed_tasks"},{"question":"def is_unique_sequence(sequence): Determines if the sequence represents a unique microorganism by containing no repeated elements. Args: sequence (list): A list of non-negative integers representing the sequence. Returns: str: \\"YES\\" if the sequence has no repeated elements, otherwise \\"NO\\". # Write your code here def analyze_sequences(t, sequences): Analyzes multiple sequences to determine if they represent unique microorganisms. Args: t (int): Number of sequences. sequences (list): A list of sequences, each sequence is a list of non-negative integers. Returns: list: A list of strings, each \\"YES\\" or \\"NO\\" corresponding to whether the sequence is unique. # Write your code here # Unit tests def test_is_unique_sequence_all_unique(): assert is_unique_sequence([0, 1, 2, 3, 4]) == \\"YES\\" def test_is_unique_sequence_with_repeats(): assert is_unique_sequence([1, 2, 2, 3, 4]) == \\"NO\\" def test_is_unique_sequence_empty(): assert is_unique_sequence([]) == \\"YES\\" def test_is_unique_sequence_single_element(): assert is_unique_sequence([1]) == \\"YES\\" def test_analyze_sequences(): sequences = [ [0, 1, 2, 3, 4], [1, 2, 2, 3, 4], [5, 6, 7, 8, 9], [3, 3, 3, 3, 3], [8, 7, 6, 5] ] expected = [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\", \\"YES\\"] assert analyze_sequences(5, sequences) == expected def test_analyze_sequences_edge_case(): sequences = [ [0], [0, 0], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10] ] expected = [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] assert analyze_sequences(4, sequences) == expected","solution":"def is_unique_sequence(sequence): Determines if the sequence represents a unique microorganism by containing no repeated elements. Args: sequence (list): A list of non-negative integers representing the sequence. Returns: str: \\"YES\\" if the sequence has no repeated elements, otherwise \\"NO\\". if len(sequence) == len(set(sequence)): return \\"YES\\" else: return \\"NO\\" def analyze_sequences(t, sequences): Analyzes multiple sequences to determine if they represent unique microorganisms. Args: t (int): Number of sequences. sequences (list): A list of sequences, each sequence is a list of non-negative integers. Returns: list: A list of strings, each \\"YES\\" or \\"NO\\" corresponding to whether the sequence is unique. results = [] for sequence in sequences: results.append(is_unique_sequence(sequence)) return results"},{"question":"def minimizeMaxTime(K, N, D): Returns the minimum maximum time required for the team to solve exactly N problems. :param K: int - Total number of problems. :param N: int - Number of problems to solve to qualify. :param D: List[int] - List of difficulties of the problems. :returns: int - Minimum maximum time required to solve N problems. >>> minimizeMaxTime(5, 3, [2, 5, 3, 6, 1]) 3 >>> minimizeMaxTime(6, 4, [4, 8, 1, 2, 6, 7]) 6","solution":"def minimizeMaxTime(K, N, D): Returns the minimum maximum time required for the team to solve exactly N problems. D.sort() return D[N-1]"},{"question":"from typing import List def can_reach(grid: List[str], r_start: int, c_start: int, r_end: int, c_end: int) -> str: Determine if there exists a path from your starting position to the suspect's last known position avoiding buildings. >>> can_reach([\\"..B..\\", \\".B.B.\\", \\"...B.\\", \\"B....\\"], 0, 0, 2, 4) 'YES' >>> can_reach([\\".B.\\", \\".B.\\", \\".B.\\"], 0, 0, 2, 2) 'NO' >>> can_reach([\\".....\\", \\".....\\", \\".....\\", \\".....\\", \\".....\\"], 1, 1, 4, 4) 'YES' >>> can_reach([\\"..B\\", \\"B.B\\", \\"...\\"], 0, 0, 0, 0) 'YES' >>> can_reach([\\".B..\\", \\"BBBB\\", \\"....\\"], 2, 0, 0, 3) 'NO' >>> can_reach([\\"...\\", \\"B.B\\", \\"...\\"], 0, 0, 2, 2) 'YES'","solution":"from collections import deque def can_reach(grid, r_start, c_start, r_end, c_end): n = len(grid) m = len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' queue = deque([(r_start, c_start)]) visited = set() visited.add((r_start, c_start)) while queue: x, y = queue.popleft() if (x, y) == (r_end, c_end): return 'YES' for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return 'NO'"},{"question":"def is_sum_possible(n, s, coins): Function to determine if a given sum can be formed using any combination of given coin denominations. Parameters: n (int): Number of different coin denominations s (int): The sum to form coins (list): List of coin denominations Returns: str: \\"POSSIBLE\\" if the sum can be formed using the given coin denominations, \\"IMPOSSIBLE\\" otherwise. def check_possibility(queries): Function to determine if a given sum can be formed using any combination of given coin denominations, for multiple queries. Parameters: queries (list of tuples): Each tuple contains (n, s, coins) Returns: list: List of strings \\"POSSIBLE\\" or \\"IMPOSSIBLE\\" for each query. from solution import is_sum_possible, check_possibility def test_case_1(): assert is_sum_possible(3, 11, [1, 2, 5]) == \\"POSSIBLE\\" def test_case_2(): assert is_sum_possible(2, 7, [3, 6]) == \\"IMPOSSIBLE\\" def test_case_3(): assert is_sum_possible(1, 10, [10]) == \\"POSSIBLE\\" def test_case_4(): assert is_sum_possible(3, 8, [2, 4, 6]) == \\"POSSIBLE\\" def test_case_5(): assert is_sum_possible(3, 9, [2, 3, 6]) == \\"POSSIBLE\\" def test_case_6(): assert is_sum_possible(3, 1, [2, 4, 6]) == \\"IMPOSSIBLE\\" def test_multiple_cases(): queries = [ (3, 11, [1, 2, 5]), (2, 7, [3, 6]), (1, 10, [10]), (3, 8, [2, 4, 6]), (3, 9, [2, 3, 6]), (3, 1, [2, 4, 6]) ] results = check_possibility(queries) expected_results = [\\"POSSIBLE\\", \\"IMPOSSIBLE\\", \\"POSSIBLE\\", \\"POSSIBLE\\", \\"POSSIBLE\\", \\"IMPOSSIBLE\\"] assert results == expected_results","solution":"def is_sum_possible(n, s, coins): Function to determine if a given sum can be formed using any combination of given coin denominations. Parameters: n (int): Number of different coin denominations s (int): The sum to form coins (list): List of coin denominations Returns: str: \\"POSSIBLE\\" if the sum can be formed using the given coin denominations, \\"IMPOSSIBLE\\" otherwise. # Initialize a list to store dp values dp = [False] * (s + 1) dp[0] = True # Base case: We can always form the sum 0 for coin in coins: for x in range(coin, s + 1): if dp[x - coin]: dp[x] = True return \\"POSSIBLE\\" if dp[s] else \\"IMPOSSIBLE\\" def check_possibility(queries): results = [] for query in queries: n, s, coins = query result = is_sum_possible(n, s, coins) results.append(result) return results"},{"question":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into one sorted array. Parameters: arr1 : List[int] The first sorted array. arr2 : List[int] The second sorted array. Returns: List[int] The merged sorted array containing all elements from arr1 and arr2. Example: >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_arrays([], [4, 5, 6]) [4, 5, 6]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into one sorted array. Parameters: - arr1: List[int] - The first sorted array. - arr2: List[int] - The second sorted array. Returns: - List[int] - The merged sorted array containing all elements from arr1 and arr2. merged = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 # If there are remaining elements in arr1 or arr2, add them to the merged list. merged.extend(arr1[i:]) merged.extend(arr2[j:]) return merged"},{"question":"def trapWater(heights): Returns the total amount of rainwater that can be trapped between the buildings. heights : List[int] : a list of integers representing the height of buildings Returns the total amount of rainwater that can be trapped between the buildings. >>> trapWater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trapWater([4, 2, 0, 3, 2, 5]) == 9 >>> trapWater([5]) == 0 >>> trapWater([5, 5]) == 0 >>> trapWater([3, 3, 3]) == 0 >>> trapWater([5, 4, 3, 2, 1]) == 0 >>> trapWater([1, 2, 3, 4, 5]) == 0 >>> trapWater([5, 0, 5]) == 5 >>> trapWater([3, 0, 2, 0, 4]) == 7 >>> trapWater([]) == 0","solution":"def trapWater(heights): Returns the total amount of rainwater that can be trapped between the buildings. if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] trapped_water = 0 while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) trapped_water += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) trapped_water += max(0, right_max - heights[right]) return trapped_water"},{"question":"def determine_level(points: int) -> int: Given a player's points, determine and return their level. Points are assigned levels according to the following rule: - 0-99 points: Level 0 - 100-199 points: Level 1 - 200-299 points: Level 2 - and so on... Parameters: points (int): The player's points, an integer between 0 and 10^6 inclusive. Returns: int: The player's level. >>> determine_level(250) 2 >>> determine_level(99) 0 >>> determine_level(1000000) 10000","solution":"def determine_level(points): Given a player's points, determine and return their level. Points are assigned levels according to the following rule: - 0-99 points: Level 0 - 100-199 points: Level 1 - 200-299 points: Level 2 - and so on... Parameters: points (int): The player's points, an integer between 0 and 10^6 inclusive. Returns: int: The player's level. return points // 100"},{"question":"def generateSpiralMatrix(n: int) -> List[List[int]]: Generates an n x n spiral matrix filled with elements from 1 to n^2. Args: n (int): The size of the matrix. Returns: List[List[int]]: A 2D list representing the spiral matrix. Examples: >>> generateSpiralMatrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generateSpiralMatrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generateSpiralMatrix(1) [[1]] pass # Your implementation goes here","solution":"def generateSpiralMatrix(n): Generates an n x n spiral matrix filled with elements from 1 to n^2. matrix = [[0]*n for _ in range(n)] num = 1 left, top = 0, 0 right, bottom = n - 1, n - 1 while left <= right and top <= bottom: # Fill top row for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 # Fill right column for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 if top <= bottom: # Fill bottom row for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 if left <= right: # Fill left column for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"def tally_votes(votes): Tally votes for each candidate and return a sorted result by candidate IDs. Parameters: votes (list of int): List of candidate IDs representing votes. Returns: dict: Dictionary with candidate IDs as keys and vote counts as values. Example: >>> tally_votes([1, 3, 3, 2, 3, 1, 2]) {1: 2, 2: 2, 3: 3} >>> tally_votes([5, 5, 5, 1, 1]) {1: 2, 5: 3}","solution":"def tally_votes(votes): Tally votes for each candidate and return a sorted result by candidate IDs. Parameters: votes (list of int): List of candidate IDs representing votes. Returns: dict: Dictionary with candidate IDs as keys and vote counts as values. vote_count = {} for vote in votes: if vote in vote_count: vote_count[vote] += 1 else: vote_count[vote] = 1 sorted_vote_count = dict(sorted(vote_count.items())) return sorted_vote_count"},{"question":"from typing import List def getProjectOrder(n: int, dependencies: List[List[int]]) -> List[int]: Determine an order to complete projects with given dependencies. >>> getProjectOrder(5, [[2, 1], [3, 2], [4, 2], [4, 3], [5, 4]]) [1, 2, 3, 4, 5] >>> getProjectOrder(4, [[2, 1], [3, 2], [1, 3]]) []","solution":"from collections import defaultdict, deque def getProjectOrder(n, dependencies): # Create an adjacency list and in-degree tracker adj_list = defaultdict(list) in_degree = [0] * (n + 1) # Build the adjacency list and populate in-degree for a, b in dependencies: adj_list[b].append(a) in_degree[a] += 1 # Initialize the queue with projects that have no prerequisites queue = deque([i for i in range(1, n + 1) if in_degree[i] == 0]) project_order = [] # Process nodes with no incoming edges while queue: project = queue.popleft() project_order.append(project) # Decrease the in-degree of neighboring nodes for neighbor in adj_list[project]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If we've processed all projects, return the order, otherwise return empty list return project_order if len(project_order) == n else []"},{"question":"def calculate_infection_rates(M: int, data: List[str]) -> List[str]: Calculate the infection rate for each age group in the community trial. Args: M (int): The number of participants in the trial. data (List[str]): List of strings where each string represents the age group and infection status of a participant. Returns: List[str]: The infection rates for Children, Adults, and Seniors in that order. Examples: >>> calculate_infection_rates(9, [\\"Child Y\\", \\"Child N\\", \\"Adult N\\", \\"Adult Y\\", \\"Adult N\\", \\"Senior N\\", \\"Senior Y\\", \\"Senior Y\\", \\"Child N\\"]) [\\"33.333333\\", \\"33.333333\\", \\"66.666667\\"] >>> calculate_infection_rates(5, [\\"Child Y\\", \\"Child Y\\", \\"Adult N\\", \\"Senior N\\", \\"Senior Y\\"]) [\\"100.000000\\", \\"0.000000\\", \\"50.000000\\"]","solution":"def calculate_infection_rates(M, data): counts = {\\"Child\\": [0, 0], \\"Adult\\": [0, 0], \\"Senior\\": [0, 0]} # [total, infected] for entry in data: age_group, status = entry.split() counts[age_group][0] += 1 if status == 'Y': counts[age_group][1] += 1 results = [] for group in [\\"Child\\", \\"Adult\\", \\"Senior\\"]: total, infected = counts[group] if total == 0: results.append(\\"No Data\\") else: infection_rate = (infected / total) * 100 results.append(f\\"{infection_rate:.6f}\\") return results"},{"question":"def intersect(nums1: List[int], nums2: List[int]) -> List[int]: Returns an array of unique integers representing the intersection of nums1 and nums2, presented in ascending order. >>> intersect([1, 2, 2, 1], [2, 2]) [2] >>> intersect([4, 9, 5], [9, 4, 9, 8, 4]) [4, 9]","solution":"def intersect(nums1, nums2): Returns an array of unique integers representing the intersection of nums1 and nums2, presented in ascending order. # Convert both lists to sets to remove duplicates and find the intersection set1 = set(nums1) set2 = set(nums2) # Find the intersection and convert to a sorted list intersection = sorted(list(set1 & set2)) return intersection"},{"question":"def count_valid_passcodes(D): Counts the number of valid passcodes (permutations of digits 1 to 9) that are divisible by D. pass def valid_passcodes_count_for_tests(D_list): Returns a list of valid passcode counts for each D in the input list. pass # Example usage: # >>> valid_passcodes_count_for_tests([1, 10000]) # [362880, 0] # Unit tests def test_count_valid_passcodes_divisible_by_1(): assert count_valid_passcodes(1) == 362880 def test_count_valid_passcodes_divisible_by_10000(): assert count_valid_passcodes(10000) == 0 def test_valid_passcodes_count_for_tests(): assert valid_passcodes_count_for_tests([1, 10000]) == [362880, 0]","solution":"from itertools import permutations def count_valid_passcodes(D): Counts the number of valid passcodes (permutations of digits 1 to 9) that are divisible by D. digits = '123456789' valid_count = 0 for perm in permutations(digits): num = int(''.join(perm)) if num % D == 0: valid_count += 1 return valid_count def valid_passcodes_count_for_tests(D_list): results = [] for D in D_list: count = count_valid_passcodes(D) results.append(count) return results"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression involving addition and subtraction. It handles both positive and negative numbers along with multiple operations. Spaces in the expression are ignored. >>> evaluate_expression(\\"5+16-3\\") == 18 >>> evaluate_expression(\\" 5 + 16 - 3 \\") == 18 >>> evaluate_expression(\\"10-20+30\\") == 20 >>> evaluate_expression(\\"-5 + 10\\") == 5 >>> evaluate_expression(\\"100-50+25-75+25\\") == 25 >>> evaluate_expression(\\"1+2+3+4+5\\") == 15 >>> evaluate_expression(\\"10-1-2-3\\") == 4 >>> evaluate_expression(\\"-10\\") == -10 >>> evaluate_expression(\\"10\\") == 10","solution":"def evaluate_expression(expression): Evaluates a mathematical expression involving addition and subtraction. It handles both positive and negative numbers along with multiple operations. Spaces in the expression are ignored. # Remove all spaces from the expression for easier processing expression = expression.replace(\\" \\", \\"\\") # Initialize total and temporary number total = 0 num = 0 sign = 1 # 1 for positive, -1 for negative for char in expression: if char.isdigit(): num = num * 10 + int(char) else: # Apply the previous number with its sign to the total total += sign * num num = 0 # Update sign for the next number if char == '+': sign = 1 elif char == '-': sign = -1 # Don't forget to add the last number total += sign * num return total"},{"question":"def find_pair(M: int): Determine whether there is a pair of positive integers (X, Y) such that X^2 + 7^Y = M, and find one such pair if it exists. If there is no pair (X, Y) that satisfies the condition, return -1. Args: M (int): The target integer to find the pair (X, Y). Returns: Union[int, Tuple[int, int]]: The pair (X, Y) that satisfies the condition or -1 if no such pair exists. Examples: >>> find_pair(50) (1, 2) >>> find_pair(3) -1 # Your implementation here","solution":"def find_pair(M): Determine whether there is a pair of positive integers (X, Y) such that X^2 + 7^Y = M. If such a pair exists, return one such pair (X, Y). Otherwise, return -1. y = 1 while True: power_of_7 = 7 ** y if power_of_7 >= M: return -1 difference = M - power_of_7 x = int(difference ** 0.5) if x > 0 and x * x == difference: return x, y y += 1 # Read input if __name__ == \\"__main__\\": M = int(input().strip()) result = find_pair(M) if result == -1: print(result) else: print(result[0], result[1])"},{"question":"def find_min_cost_to_connect_warehouses(N: int, M: int, routes: List[Tuple[int, int, int]]) -> int: Function to find the minimal cost required to connect all the warehouses. Parameters: N (int): Number of warehouses (nodes) M (int): Number of transportation routes (edges) routes (list of tuples): Each tuple (u, v, w) represents a route from warehouse u to warehouse v with a cost w Returns: int: The minimal cost required to connect all the warehouses, or -1 if not possible >>> find_min_cost_to_connect_warehouses(4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4), (1, 3, 5)]) 6 >>> find_min_cost_to_connect_warehouses(4, 2, [(1, 2, 1), (3, 4, 2)]) -1","solution":"def find_min_cost_to_connect_warehouses(N, M, routes): Function to find the minimal cost required to connect all the warehouses. Parameters: N (int): Number of warehouses (nodes) M (int): Number of transportation routes (edges) routes (list of tuples): Each tuple (u, v, w) represents a route from warehouse u to warehouse v with a cost w Returns: int: The minimal cost required to connect all the warehouses, or -1 if not possible import heapq from collections import defaultdict if N == 0: return -1 # Create adjacency list representation of graph graph = defaultdict(list) for u, v, w in routes: if u != v: # ignore self-loops graph[u].append((w, v)) graph[v].append((w, u)) # Prim's algorithm to find the MST (Minimum Spanning Tree) def prim(graph, start): visited = set() min_heap = [(0, start)] total_cost = 0 while min_heap: cost, node = heapq.heappop(min_heap) if node not in visited: visited.add(node) total_cost += cost for next_cost, next_node in graph[node]: if next_node not in visited: heapq.heappush(min_heap, (next_cost, next_node)) if len(visited) == N: return total_cost else: return -1 # not all nodes are connected # Assume we start from the first node (1) return prim(graph, 1) # Sample Input Code - for testing if __name__ == \\"__main__\\": N1, M1 = 4, 5 routes1 = [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4), (1, 3, 5)] print(find_min_cost_to_connect_warehouses(N1, M1, routes1)) # Output: 6 N2, M2 = 4, 2 routes2 = [(1, 2, 1), (3, 4, 2)] print(find_min_cost_to_connect_warehouses(N2, M2, routes2)) # Output: -1"},{"question":"from typing import List def min_steps_in_maze(grid: List[List[str]]) -> int: Returns the minimum number of steps required to reach the bottom-right corner from the top-left corner of the grid, or -1 if it is not possible. def solve(input_data: str) -> List[int]: Processes the input data and calls the min_steps_in_maze function for each test case. def test_min_steps_in_maze(): assert min_steps_in_maze([['O', 'O', 'O'], ['O', 'X', 'X'], ['O', 'O', 'O']]) == 4 assert min_steps_in_maze([['O', 'O', 'O', 'O', 'O'], ['O', 'X', 'O', 'X', 'O'], ['O', 'O', 'O', 'O', 'O'], ['O', 'X', 'O', 'X', 'O'], ['O', 'O', 'O', 'O', 'O']]) == 8 assert min_steps_in_maze([['O', 'X'], ['X', 'O']]) == -1 assert min_steps_in_maze([['O']]) == 0 assert min_steps_in_maze([['X']]) == -1 assert min_steps_in_maze([['O', 'O'], ['O', 'O']]) == 2 def test_solve(): input_data = \\"3n3 3nOOOnOXXnOOOn5 5nOOOOOnOXOXOnOOOOOnOXOXOnOOOOOn2 2nOXnXOn\\" output = solve(input_data) assert output == [4, 8, -1] input_data = \\"1n1 1nOn\\" output = solve(input_data) assert output == [0] input_data = \\"1n1 1nXn\\" output = solve(input_data) assert output == [-1]","solution":"from collections import deque def min_steps_in_maze(grid): Returns the minimum number of steps required to reach the bottom-right corner from the top-left corner of the grid, or -1 if it is not possible. if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) if grid[0][0] == 'X' or grid[rows-1][cols-1] == 'X': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (current_row, current_col, current_steps) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() if r == rows - 1 and c == cols - 1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr][nc] == 'O': visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1 def solve(input_data): Processes the input data and calls the min_steps_in_maze function for each test case. input_lines = input_data.split('n') test_cases = int(input_lines[0]) result = [] index = 1 for _ in range(test_cases): rows, cols = map(int, input_lines[index].split()) grid = [] for i in range(rows): grid.append(list(input_lines[index + 1 + i])) index += 1 + rows result.append(min_steps_in_maze(grid)) return result"},{"question":"def check_winner(board): Determine the outcome of a given Tic-Tac-Toe game. Args: board (List[List[str]]): A 3x3 grid represented as a list of lists with 'X', 'O', or '.'. Returns: str: The result of the game - \\"X wins\\", \\"O wins\\", \\"Draw\\", or \\"Ongoing\\". >>> check_winner([ ... ['X', 'X', 'X'], ... ['O', 'O', '.'], ... ['X', 'O', '.'] ... ]) 'X wins' >>> check_winner([ ... ['X', 'X', '.'], ... ['O', 'O', 'O'], ... ['X', 'O', '.'] ... ]) 'O wins' >>> check_winner([ ... ['X', 'O', 'X'], ... ['O', 'X', 'X'], ... ['O', 'X', 'O'] ... ]) 'Draw' pass def tic_tac_toe_outcome(inputs): Simulates the outcome of multiple Tic-Tac-Toe games. Args: inputs (List[str]): Input representing multiple final states of Tic-Tac-Toe boards. Returns: None: Prints the result of each game. Example: >>> tic_tac_toe_outcome([ ... 'XOX', ... 'OXO', ... 'X..', ... 'OOX', ... 'XX.', ... 'OX.', ... 'OXO', ... 'XOX', ... 'OX.' ... ]) X wins O wins Draw pass","solution":"def check_winner(board): winning_combinations = [ [(0, 0), (0, 1), (0, 2)], # horizontal rows [(1, 0), (1, 1), (1, 2)], [(2, 0), (2, 1), (2, 2)], [(0, 0), (1, 0), (2, 0)], # vertical columns [(0, 1), (1, 1), (2, 1)], [(0, 2), (1, 2), (2, 2)], [(0, 0), (1, 1), (2, 2)], # diagonals [(0, 2), (1, 1), (2, 0)] ] for combination in winning_combinations: values = [board[r][c] for r, c in combination] if values == ['X', 'X', 'X']: return 'X wins' elif values == ['O', 'O', 'O']: return 'O wins' if any('.' in row for row in board): return 'Ongoing' # For the context of unit tests, assuming the game can still be ongoing else: return 'Draw' def tic_tac_toe_outcome(inputs): i = 0 while i < len(inputs): board = inputs[i:i+3] result = check_winner(board) print(result) i += 4"},{"question":"def find_palindromic_primes(n: int) -> List[int]: Create a function 'find_palindromic_primes()' that will generate a list of palindromic prime numbers up to a given number \`n\`. >>> find_palindromic_primes(100) [2, 3, 5, 7, 11] >>> find_palindromic_primes(10) [2, 3, 5, 7] >>> find_palindromic_primes(1) [] >>> find_palindromic_primes(1000) [2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, 353, 373, 383, 727, 757, 787, 797, 919, 929]","solution":"def find_palindromic_primes(n): Returns a list of palindromic prime numbers up to a given number n (inclusive). def is_prime(num): if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def is_palindromic(num): return str(num) == str(num)[::-1] palindromic_primes = [] for num in range(2, n + 1): if is_prime(num) and is_palindromic(num): palindromic_primes.append(num) return palindromic_primes"},{"question":"def longest_consecutive(nums): Given an array of integers 'nums', return the length of the longest consecutive elements sequence. >>> longest_consecutive([1, 3, 5, 6, 7, 4, 8, 2, 0, 10, 11]) 4 >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence in the list 'nums'. if not nums: return 0 nums = set(nums) # Remove duplicates and sort the array longest_streak = 0 for num in nums: # Only start sequences from the smallest numbers if num - 1 not in nums: current_num = num current_streak = 1 while current_num + 1 in nums: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def toggleCase(N, S): Toggles the case of each character in the string S. Parameters: N (int): Length of the string S. S (str): Input string to toggle case. Returns: str: String with toggled case for each character. pass # Test Cases def test_toggle_case_example_cases(): assert toggleCase(5, \\"aBcDe\\") == \\"AbCdE\\" assert toggleCase(4, \\"ABCD\\") == \\"abcd\\" def test_toggle_case_mixed(): assert toggleCase(6, \\"HeLLoW\\") == \\"hEllOw\\" assert toggleCase(7, \\"PyThoN\\") == \\"pYtHOn\\" def test_toggle_case_all_uppercase(): assert toggleCase(3, \\"XYZ\\") == \\"xyz\\" assert toggleCase(5, \\"ABCDE\\") == \\"abcde\\" def test_toggle_case_all_lowercase(): assert toggleCase(3, \\"xyz\\") == \\"XYZ\\" assert toggleCase(5, \\"abcde\\") == \\"ABCDE\\" def test_toggle_case_long_string(): input_str = \\"a\\" * 100000 output_str = \\"A\\" * 100000 assert toggleCase(100000, input_str) == output_str assert toggleCase(100000, output_str) == input_str","solution":"def toggleCase(N, S): Toggles the case of each character in the string S. Parameters: N (int): Length of the string S. S (str): Input string to toggle case. Returns: str: String with toggled case for each character. return S.swapcase()"},{"question":"def has_common_substring(t: int, test_cases: List[Tuple[int, str, str]]) -> List[str]: Determine if there exists a substring that is common to both strings s1 and s2 and has a length greater than or equal to k for each test case. Args: t (int): Number of test cases. test_cases (List[Tuple[int, str, str]]): A list of test cases where each test case is represented as a tuple (k, s1, s2). Returns: List[str]: List containing \\"YES\\" or \\"NO\\" for each test case. Example: >>> has_common_substring(2, [(2, 'abcde', 'cdefg'), (3, 'abcdef', 'ghijkl')]) [\\"YES\\", \\"NO\\"]","solution":"def has_common_substring(t, test_cases): results = [] for i in range(t): k = test_cases[i][0] s1 = test_cases[i][1] s2 = test_cases[i][2] # Create sets of all substrings of length k for s1 and s2 substrings_s1 = {s1[j:j+k] for j in range(len(s1) - k + 1)} substrings_s2 = {s2[j:j+k] for j in range(len(s2) - k + 1)} # Check for intersection if substrings_s1.intersection(substrings_s2): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_coins(amount: int, coins: List[int]) -> int: Calculate the minimum number of coins needed to make a given amount of money using a specific set of coin denominations. If it is not possible to make the exact amount with the given denominations, return -1. :param amount: int - amount of money to make :param coins: List[int] - list of coin denominations :return: int - minimum number of coins needed or -1 if not possible >>> min_coins(11, [1, 5, 6, 8]) == 2 >>> min_coins(7, [2, 4]) == -1","solution":"def min_coins(amount, coins): Calculates the minimum number of coins needed to make a given amount of money using a specific set of coin denominations. If it is not possible to make the exact amount with the given denominations, return -1. :param amount: int - amount of money to make :param coins: List[int] - list of coin denominations :return: int - minimum number of coins needed or -1 if not possible # Initialize dp array where dp[i] will be storing the minimum number # of coins required for i value. dp = [float('inf')] * (amount + 1) # Base case: It takes 0 coins to make amount 0. dp[0] = 0 # Iterate over each amount 1 through amount. for i in range(1, amount + 1): for coin in coins: if i - coin >= 0: dp[i] = min(dp[i], dp[i - coin] + 1) # If dp[amount] is still infinity, it means it's not possible to make that amount. return -1 if dp[amount] == float('inf') else dp[amount]"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"aaaaaa\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"abcdefghijabcdefghij\\") 10 >>> length_of_longest_substring(\\"abababcbc\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. char_index_map = {} start = max_length = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"def longest_valid_parentheses(s: str) -> int: Finds the length of the longest valid parentheses substring. Parameters: s (str): Input string containing only '(' and ')' Returns: int: Length of the longest valid parentheses substring >>> longest_valid_parentheses(\\"()\\") == 2 >>> longest_valid_parentheses(\\"(()\\") == 2 >>> longest_valid_parentheses(\\")()())\\") == 4 >>> longest_valid_parentheses(\\"\\") == 0 >>> longest_valid_parentheses(\\"()(()\\") == 2 >>> longest_valid_parentheses(\\"()()\\") == 4 >>> longest_valid_parentheses(\\"(()())\\") == 6 >>> longest_valid_parentheses(\\"()(()))\\") == 6 >>> longest_valid_parentheses(\\")(\\") == 0 >>> longest_valid_parentheses(\\"((()))\\") == 6","solution":"def longest_valid_parentheses(s): Finds the length of the longest valid parentheses substring. Parameters: s (str): Input string containing only '(' and ')' Returns: int: Length of the longest valid parentheses substring max_length = 0 stack = [-1] for i, char in enumerate(s): if char == '(': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_length = max(max_length, i - stack[-1]) return max_length"},{"question":"from typing import List def minimize_sum(arr: List[int]) -> int: Given an array of integers, determine the minimum sum of the elements after making them all equal by decreasing any element by 1 any number of times. >>> minimize_sum([5, 3, 7]) 9 >>> minimize_sum([1, 1, 1]) 3 >>> minimize_sum([10, 20, 30, 40]) 40","solution":"from typing import List def minimize_sum(arr: List[int]) -> int: Given an array of integers, perform the operation of decreasing an element by 1 as many times as required to minimize the sum of the elements and make them all equal. # Find the minimum element in the array min_value = min(arr) # Calculate the minimum sum after making all elements equal to the minimum value result = min_value * len(arr) return result"},{"question":"def final_ball_holder(n: int, p: int, m: int) -> int: Determine which player holds the ball after m rounds. :param n: int - the number of players :param p: int - the number of positions to pass the ball in each round :param m: int - the number of rounds :return: int - the final ball holder's number >>> final_ball_holder(5, 2, 3) 2 >>> final_ball_holder(4, 1, 5) 2 >>> final_ball_holder(6, 3, 4) 1","solution":"def final_ball_holder(n, p, m): Determine which player holds the ball after m rounds. :param n: int - the number of players :param p: int - the number of positions to pass the ball in each round :param m: int - the number of rounds :return: int - the final ball holder's number # The ball starts with player 1 and we need to calculate its position # after p * m moves. Since the positions are circular (1 to n), we use # modulo operation to find the position. final_position = (1 + p * m - 1) % n + 1 return final_position"},{"question":"def decrypt_message(test_cases): Decrypts messages from a list of test cases according to the described pattern. Arguments: test_cases -- a list of tuples where each tuple contains two integers for the number of rows (R) and columns (C), followed by a list of strings representing the grid of letters. Returns: A list of decrypted messages for each test case. >>> decrypt_message([(2, 3, ['aBc', 'DeF'])]) ['aBcDeF'] >>> decrypt_message([(3, 2, ['Ab', 'Cd', 'Ef'])]) ['AbCdEf'] >>> decrypt_message([(1, 5, ['abcde'])]) ['abcde'] >>> decrypt_message([(5, 1, ['a', 'b', 'c', 'd', 'e'])]) ['abcde'] >>> decrypt_message([(1, 1, ['a'])]) ['a']","solution":"def decrypt_message(test_cases): Decrypts messages from a list of test cases according to the described pattern. Arguments: test_cases -- a list of tuples where each tuple contains two integers for the number of rows (R) and columns (C), followed by a list of strings representing the grid of letters. Returns: A list of decrypted messages for each test case. results = [] for case in test_cases: R, C, grid = case decrypted_message = ''.join(''.join(row) for row in grid) results.append(decrypted_message) return results"},{"question":"def is_happy_number(n: int) -> str: Determine if the given number is a happy number. >>> is_happy_number(19) \\"YES\\" >>> is_happy_number(4) \\"NO\\" from typing import List import unittest class TestHappyNumber(unittest.TestCase): def test_happy_number_19(self): self.assertEqual(is_happy_number(19), \\"YES\\") def test_happy_number_4(self): self.assertEqual(is_happy_number(4), \\"NO\\") def test_happy_number_1(self): self.assertEqual(is_happy_number(1), \\"YES\\") def test_happy_number_7(self): self.assertEqual(is_happy_number(7), \\"YES\\") def test_happy_number_10(self): self.assertEqual(is_happy_number(10), \\"YES\\") def test_happy_number_large_happy(self): self.assertEqual(is_happy_number(1000000000), \\"YES\\") def test_happy_number_large_non_happy(self): self.assertEqual(is_happy_number(999999999), \\"NO\\")","solution":"def is_happy_number(n): Determine if the given number is a happy number. Parameters: n (int): The number to be checked. Returns: str: \\"YES\\" if the number is happy, otherwise \\"NO\\". def sum_of_squares(num): total = 0 while num > 0: digit = num % 10 total += digit * digit num //= 10 return total seen_numbers = set() while n != 1 and n not in seen_numbers: seen_numbers.add(n) n = sum_of_squares(n) return \\"YES\\" if n == 1 else \\"NO\\""},{"question":"def count_distinct_paths(n: int, m: int, grid: List[List[str]]) -> int: Compute the number of distinct paths from the top-left corner to the bottom-right corner of a grid, while avoiding obstacles. A cell containing a '1' represents an obstacle and cannot be traversed, whereas a cell containing a '0' is empty and can be traversed. Winnie-the-Pooh can only move to the right or down one step at a time. Args: n: Number of rows in the grid. m: Number of columns in the grid. grid: The grid itself, represented as a list of list of strings. Returns: The number of distinct paths from the top-left to the bottom-right of the grid. Examples: >>> count_distinct_paths(3, 3, [['0', '0', '0'], ['0', '1', '0'], ['0', '0', '0']]) 2 >>> count_distinct_paths(3, 3, [['0', '1', '0'], ['0', '1', '0'], ['0', '0', '0']]) 1 >>> count_distinct_paths(3, 3, [['0', '1', '0'], ['0', '1', '0'], ['0', '1', '0']]) 0 from typing import List def test_no_obstacles(): grid = [['0', '0', '0'], ['0', '0', '0'], ['0', '0', '0']] assert count_distinct_paths(3, 3, grid) == 6 def test_one_obstacle(): grid = [['0', '0', '0'], ['0', '1', '0'], ['0', '0', '0']] assert count_distinct_paths(3, 3, grid) == 2 def test_multiple_obstacles(): grid = [['0', '1', '0'], ['0', '1', '0'], ['0', '0', '0']] assert count_distinct_paths(3, 3, grid) == 1 def test_no_path(): grid = [['0', '1', '0'], ['0', '1', '0'], ['0', '1', '0']] assert count_distinct_paths(3, 3, grid) == 0 def test_start_or_end_blocked(): grid1 = [['1', '0', '0'], ['0', '0', '0'], ['0', '0', '0']] assert count_distinct_paths(3, 3, grid1) == 0 grid2 = [['0', '0', '0'], ['0', '0', '0'], ['0', '0', '1']] assert count_distinct_paths(3, 3, grid2) == 0","solution":"def num_paths(grid): n = len(grid) m = len(grid[0]) if grid[0][0] == '1' or grid[n-1][m-1] == '1': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '1': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1] def count_distinct_paths(n, m, grid): return num_paths(grid)"},{"question":"def parse_input(input_str: str) -> List[List[Tuple[int, int, int]]]: Parse the input string into a list of datasets. Each dataset is represented as a list of (N, M), (a1, b1, s1), ..., (aM, bM, sM). Args: input_str (str): The input string. Returns: List[List[Tuple[int, int, int]]]: The parsed datasets. pass def find_safest_route(datasets: List[List[Tuple[int, int, int]]]) -> List[int]: Find the safest route by minimizing the highest security level on any passageway in the route. Args: datasets (List[List[Tuple[int, int, int]]]): The list of datasets. Returns: List[int]: The minimal highest security level for each dataset. pass def main(input_str: str) -> str: Main function to process input and output the result as a string. Args: input_str (str): The input string. Returns: str: The output string. pass # Unit tests def test_parse_input(): input_str = \\"6 7n1 2 3n1 3 4n2 4 2n3 4 6n4 5 1n5 6 3n4 6 4n4 4n1 2 5n1 3 4n2 4 1n3 4 2n0 0n\\" expected_output = [ [(6, 7), (1, 2, 3), (1, 3, 4), (2, 4, 2), (3, 4, 6), (4, 5, 1), (5, 6, 3), (4, 6, 4)], [(4, 4), (1, 2, 5), (1, 3, 4), (2, 4, 1), (3, 4, 2)], ] assert parse_input(input_str) == expected_output def test_find_safest_route(): datasets = [ [(6, 7), (1, 2, 3), (1, 3, 4), (2, 4, 2), (3, 4, 6), (4, 5, 1), (5, 6, 3), (4, 6, 4)], [(4, 4), (1, 2, 5), (1, 3, 4), (2, 4, 1), (3, 4, 2)], ] expected_output = [3, 4] assert find_safest_route(datasets) == expected_output def test_main(): input_str = \\"6 7n1 2 3n1 3 4n2 4 2n3 4 6n4 5 1n5 6 3n4 6 4n4 4n1 2 5n1 3 4n2 4 1n3 4 2n0 0n\\" expected_output = \\"3n4\\" assert main(input_str) == expected_output # Run the tests test_parse_input() test_find_safest_route() test_main() print(\\"All tests passed!\\")","solution":"import heapq def dijkstra(graph, N): max_security = [float('inf')] * (N + 1) max_security[1] = 0 pq = [(0, 1)] while pq: current_security, u = heapq.heappop(pq) for v, security in graph[u]: max_security_level = max(current_security, security) if max_security_level < max_security[v]: max_security[v] = max_security_level heapq.heappush(pq, (max_security_level, v)) return max_security[N] def find_safest_route(datasets): results = [] for dataset in datasets: N, M = dataset[0] graph = [[] for _ in range(N + 1)] for edge in dataset[1:]: a, b, s = edge graph[a].append((b, s)) graph[b].append((a, s)) results.append(dijkstra(graph, N)) return results def parse_input(input_str): datasets = [] lines = input_str.strip().split(\\"n\\") i = 0 while i < len(lines): N, M = map(int, lines[i].split()) if N == 0 and M == 0: break dataset = [(N, M)] for _ in range(M): i += 1 a, b, s = map(int, lines[i].split()) dataset.append((a, b, s)) datasets.append(dataset) i += 1 return datasets def main(input_str): datasets = parse_input(input_str) results = find_safest_route(datasets) return \\"n\\".join(map(str, results))"},{"question":"class GridManager: def __init__(self, n: int, m: int, grid: List[List[int]]): Initialize the grid manager with the grid of size n x m. :param n: Number of rows :param m: Number of columns :param grid: Initial grid values # Your implementation goes here def update_value(self, i: int, j: int, v: int): Update the value at position (i, j) to a new value v. :param i: Row index :param j: Column index :param v: New value to update # Your implementation goes here def sum_subgrid(self, x1: int, y1: int, x2: int, y2: int) -> int: Calculate the sum of all values in the subgrid defined by (x1, y1) to (x2, y2) inclusive. :param x1: Row index of top-left corner :param y1: Column index of top-left corner :param x2: Row index of bottom-right corner :param y2: Column index of bottom-right corner :return: Sum of values in the subgrid # Your implementation goes here from solution import GridManager def test_grid_initialization(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] manager = GridManager(3, 3, grid) assert manager.grid == grid def test_update_value(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] manager = GridManager(3, 3, grid) manager.update_value(2, 2, 10) assert manager.grid[1][1] == 10 assert manager.grid == [ [1, 2, 3], [4, 10, 6], [7, 8, 9] ] manager.update_value(1, 1, 4) assert manager.grid[0][0] == 4 assert manager.grid == [ [4, 2, 3], [4, 10, 6], [7, 8, 9] ] def test_sum_subgrid(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] manager = GridManager(3, 3, grid) assert manager.sum_subgrid(1, 1, 2, 2) == 12 manager.update_value(2, 2, 10) assert manager.grid == [ [1, 2, 3], [4, 10, 6], [7, 8, 9] ] assert manager.sum_subgrid(1, 1, 3, 3) == 50 assert manager.sum_subgrid(2, 2, 3, 3) == 33 manager.update_value(1, 1, 4) assert manager.grid == [ [4, 2, 3], [4, 10, 6], [7, 8, 9] ] assert manager.sum_subgrid(1, 1, 3, 3) == 53","solution":"class GridManager: def __init__(self, n, m, grid): self.n = n self.m = m self.grid = grid def update_value(self, i, j, v): self.grid[i-1][j-1] = v def sum_subgrid(self, x1, y1, x2, y2): total_sum = 0 for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): total_sum += self.grid[i][j] return total_sum"},{"question":"def water_balloons_sequence(t: int, test_cases: List[int]) -> List[str]: This function returns the sequence of throws for a given number of players in each test case. Each player throws a balloon to the player directly across the circle. Args: t (int): Number of test cases. test_cases (List[int]): List containing the number of players for each test case. Returns: List[str]: List of strings, each string representing the sequence of throws for one test case. Example: >>> water_balloons_sequence(1, [4]) [\\"1 3 2 4\\"] >>> water_balloons_sequence(1, [6]) [\\"1 4 2 5 3 6\\"] >>> water_balloons_sequence(1, [8]) [\\"1 5 2 6 3 7 4 8\\"]","solution":"def water_balloons_sequence(t, test_cases): This function returns the sequence of throws for a given number of players in each test case. Each player throws a balloon to the player directly across the circle. :param t: Number of test cases :param test_cases: List containing the number of players for each test case :return: List of strings, each string representing the sequence of throws for one test case sequences = [] for n in test_cases: sequence = [] players = list(range(1, n+1)) for i in range(len(players)//2): thrower = players[i] target = players[i + len(players)//2] sequence.append(f\\"{thrower} {target}\\") sequences.append(\\" \\".join(sequence)) return sequences"},{"question":"def largest_connected_region(grid: List[str], M: int, N: int) -> int: Determine the size of the largest connected region of empty cells in the grid. >>> grid = [ ... \\".#...\\", ... \\"..#..\\", ... \\"#\\", ... \\".#.#.\\", ... \\"..#.#\\" ... ] >>> largest_connected_region(grid, 5, 5) 5 >>> grid = [ ... \\".....\\", ... \\".....\\", ... \\".....\\", ... \\".....\\", ... \\".....\\" ... ] >>> largest_connected_region(grid, 5, 5) 25 >>> grid = [ ... \\"#\\", ... \\"#\\", ... \\"#\\", ... \\"#\\", ... \\"#\\" ... ] >>> largest_connected_region(grid, 5, 5) 0 >>> grid = [ ... \\"#.#\\", ... \\"#\\", ... \\"#.#\\" ... ] >>> largest_connected_region(grid, 3, 3) 1 >>> grid = [ ... \\"..#\\", ... \\"#\\", ... \\"#..\\" ... ] >>> largest_connected_region(grid, 3, 3) 2","solution":"def largest_connected_region(grid, M, N): def dfs(x, y): if x < 0 or x >= M or y < 0 or y >= N or grid[x][y] == '#' or visited[x][y]: return 0 visited[x][y] = True count = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: count += dfs(x + dx, y + dy) return count visited = [[False] * N for _ in range(M)] max_region = 0 for i in range(M): for j in range(N): if grid[i][j] == '.' and not visited[i][j]: max_region = max(max_region, dfs(i, j)) return max_region def parse_input(): import sys input = sys.stdin.read data = input().split() M = int(data[0]) N = int(data[1]) grid = [data[i+2] for i in range(M)] return grid, M, N if __name__ == \\"__main__\\": grid, M, N = parse_input() print(largest_connected_region(grid, M, N))"},{"question":"def check_storage(T, test_cases): Determine if the total number of items across shelves exceeds the limit. Args: T (int): The number of test cases. test_cases (list of tuples): Each tuple contains: - an integer N representing the number of shelves. - a list of integers representing the number of items on each shelf. - an integer limit representing the maximum number of items a worker can handle. Returns: list of str: For each test case, return \\"Possible\\" if the total number of items is within the limit; otherwise, return \\"Impossible\\". >>> check_storage(3, [(2, [5, 10], 20), (3, [4, 7, 9], 19), (1, [1000], 999)]) [\\"Possible\\", \\"Impossible\\", \\"Impossible\\"] >>> check_storage(1, [(1, [999], 1000)]) [\\"Possible\\"]","solution":"def check_storage(T, test_cases): results = [] for t in range(T): N, shelf_items, limit = test_cases[t] total_items = sum(shelf_items) if total_items <= limit: results.append(\\"Possible\\") else: results.append(\\"Impossible\\") return results"},{"question":"from collections import deque from typing import List def get_shortest_path_length(n: int, m: int, grid: List[str]) -> int: Find the length of the shortest path that Nikita can take to reach the exit of the maze. If there's no possible way to reach the exit, return -1. Args: - n (int): Number of rows in the grid. - m (int): Number of columns in the grid. - grid (List[str]): The grid representation of the maze. Returns: - int: The length of the shortest path or -1 if no path exists. >>> get_shortest_path_length(5, 5, [\\"s#...\\", \\".#.#.\\", \\".#...\\", \\".#.\\", \\"...e.\\"]) 7 >>> get_shortest_path_length(3, 3, [\\"s#.\\", \\"#\\", \\"..e\\"]) -1 >>> get_shortest_path_length(1, 3, [\\"s.e\\"]) 2 >>> get_shortest_path_length(1, 1, [\\"s\\"]) -1 >>> get_shortest_path_length(3, 3, [\\"s#.\\", \\"...\\", \\"..e\\"]) 4","solution":"from collections import deque def shortest_path(grid, start, end): rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add((start[0], start[1])) while queue: row, col, dist = queue.popleft() if (row, col) == end: return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != '#' and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) return -1 def get_shortest_path_length(n, m, grid): start = end = None for i in range(n): for j in range(m): if grid[i][j] == 's': start = (i, j) elif grid[i][j] == 'e': end = (i, j) if not start or not end: return -1 return shortest_path(grid, start, end) # Example Usage: # n = 5 # m = 5 # grid = [ # \\"s#...\\", # \\".#.#.\\", # \\".#...\\", # \\".#.\\", # \\"...e.\\" # ] # print(get_shortest_path_length(n, m, grid)) # Output: 7"},{"question":"def max_sum_of_ratings(n: int, S: int, songs: List[Tuple[int, int]]) -> int: Given a number of songs with their sizes and ratings, finds the maximum sum of ratings that doesn't exceed the given storage limit using a dynamic programming approach. Args: n: An integer, the number of songs S: An integer, the total storage limit songs: A list of tuples where each tuple contains two integers (size and rating of a song) Returns: An integer, the maximum sum of ratings without exceeding the storage limit >>> max_sum_of_ratings(4, 10, [(5, 10), (4, 7), (6, 6), (2, 5)]) 17 >>> max_sum_of_ratings(3, 10, [(5, 10), (5, 10), (5, 10)]) 20 >>> max_sum_of_ratings(1, 10, [(5, 7)]) 7 >>> max_sum_of_ratings(3, 9, [(3, 3), (3, 6), (3, 8)]) 17 >>> max_sum_of_ratings(3, 1, [(2, 3), (3, 6), (3, 8)]) 0","solution":"def max_sum_of_ratings(n, S, songs): Given a number of songs with their sizes and ratings, finds the maximum sum of ratings that doesn't exceed the given storage limit using a dynamic programming approach. # Initialize dp array where dp[i] is the maximum rating sum at storage limit i dp = [0] * (S + 1) # Iterate over each song for s, r in songs: # Update the dp array from the end to the beginning to avoid overwriting for j in range(S, s - 1, -1): dp[j] = max(dp[j], dp[j - s] + r) return dp[S] # Example usage if __name__ == \\"__main__\\": n = 4 S = 10 songs = [(5, 10), (4, 7), (6, 6), (2, 5)] print(max_sum_of_ratings(n, S, songs)) # Output: 17"},{"question":"def plant_crops(n, m): Determines if it is possible to plant crops alternately in a grid of size n x m. Returns a list with \\"YES\\" followed by the grid or \\"NO\\" if it is not possible. >>> plant_crops(2, 2) [\\"YES\\", \\"CP\\", \\"PC\\"] >>> plant_crops(3, 4) [\\"YES\\", \\"CPCP\\", \\"PCPC\\", \\"CPCP\\"] >>> plant_crops(1, 1) [\\"YES\\", \\"C\\"]","solution":"def plant_crops(n, m): Determines if it is possible to plant crops alternately in a grid of size n x m. Returns \\"YES\\" followed by the grid or \\"NO\\" if it is not possible. grid = [] for i in range(n): row = [] for j in range(m): if (i + j) % 2 == 0: row.append('C') else: row.append('P') grid.append(''.join(row)) return [\\"YES\\"] + grid"},{"question":"def count_pairs(array: List[int], target: int) -> int: Returns the number of unique pairs (a, b) in the array such that a + b = target >>> count_pairs([1, 2, 3, 4, 5], 6) 2 >>> count_pairs([1, 1, 1, 1], 2) 1 >>> count_pairs([1, 2, 3, 4, 5, 6], 7) 3 >>> count_pairs([1, 2, 3], 10) 0 >>> count_pairs([1, 1, 1, 2, 2, 2], 3) 1 >>> count_pairs([1000000, 999999, 1, 2, 999998, 3], 1000001) 3 >>> count_pairs([1], 2) 0 >>> count_pairs([-1, -2, -3, -4, -5], -6) 2","solution":"def count_pairs(array, target): Returns the number of unique pairs (a, b) in the array such that a + b = target seen = set() pairs = set() for number in array: complement = target - number if complement in seen: pairs.add(frozenset((number, complement))) seen.add(number) return len(pairs)"},{"question":"def is_palindrome(sequence: List[int]) -> str: Determine if the sequence is a palindrome. >>> is_palindrome([1, 2, 3, 2, 1]) 'YES' >>> is_palindrome([1, 2, 3, 4, 5]) 'NO'","solution":"def is_palindrome(sequence): Returns \\"YES\\" if the given sequence is a palindrome, otherwise \\"NO\\". return \\"YES\\" if sequence == sequence[::-1] else \\"NO\\" def main(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) sequence = list(map(int, data[1:n+1])) print(is_palindrome(sequence)) if __name__ == \\"__main__\\": main()"},{"question":"import math from typing import List, Tuple def calculate_distance(x1: int, y1: int, x2: int, y2: int) -> float: Calculate Euclidean distance between two points (x1, y1) and (x2, y2). Args: x1 (int): x-coordinate of the first point. y1 (int): y-coordinate of the first point. x2 (int): x-coordinate of the second point. y2 (int): y-coordinate of the second point. Returns: float: Euclidean distance between the two points. pass def minimum_total_travel_distance(n: int, m: int, warehouses: List[Tuple[int, int]], tasks: List[Tuple[int, int, int]]) -> int: Calculate the total minimum travel distance for all delivery tasks. Args: n (int): Number of warehouses. m (int): Number of delivery tasks. warehouses (List[Tuple[int, int]]): List of tuples representing coordinates of the warehouses. tasks (List[Tuple[int, int, int]]): List of tuples representing the delivery tasks where each tuple contains start warehouse index, destination warehouse index, and travel distance. Returns: int: Total minimum travel distance for all delivery tasks. pass def logistics_min_travel_distance(n: int, m: int, warehouse_coords: List[Tuple[int, int]], delivery_tasks: List[Tuple[int, int, int]]) -> int: Wrapper function to receive inputs and compute the result. Args: n (int): Number of warehouses. m (int): Number of delivery tasks. warehouse_coords (List[Tuple[int, int]]): List of tuples representing coordinates of the warehouses. delivery_tasks (List[Tuple[int, int, int]]): List of tuples representing the delivery tasks where each tuple contains start warehouse index, destination warehouse index, and travel distance. Returns: int: Total minimum travel distance for all delivery tasks. pass","solution":"import math def calculate_distance(x1, y1, x2, y2): Calculate Euclidean distance between two points (x1, y1) and (x2, y2). return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) def minimum_total_travel_distance(n, m, warehouses, tasks): Calculate the total minimum travel distance for all delivery tasks. # Calculate travel distance for each task total_distance = 0 for task in tasks: si, di, tdi = task start_position = warehouses[si - 1] end_position = warehouses[di - 1] task_distance = tdi # Add the specified task distance to the total distance total_distance += task_distance return total_distance # Wrap the solution code as a callable function def logistics_min_travel_distance(n, m, warehouse_coords, delivery_tasks): Wrapper function to receive inputs and compute the result. return minimum_total_travel_distance(n, m, warehouse_coords, delivery_tasks)"},{"question":"def subset_sum_zero(n, nums): Determines if there exists a subset of the given list of numbers that adds up to zero. Returns 'YES' if such a subset exists, otherwise 'NO'. :param n: Number of integers :param nums: List of integers :return: 'YES' or 'NO' >>> subset_sum_zero(5, [-1, 2, -3, 4, 5]) == 'YES' >>> subset_sum_zero(4, [1, 2, 3, 4]) == 'NO' from itertools import combinations def test_subset_sum_zero_case1(): assert subset_sum_zero(5, [-1, 2, -3, 4, 5]) == \\"YES\\" def test_subset_sum_zero_case2(): assert subset_sum_zero(4, [1, 2, 3, 4]) == \\"NO\\" def test_subset_sum_zero_single_zero(): assert subset_sum_zero(1, [0]) == \\"YES\\" def test_subset_sum_zero_single_non_zero(): assert subset_sum_zero(1, [1]) == \\"NO\\" def test_subset_sum_zero_two_elements_sum_zero(): assert subset_sum_zero(2, [1, -1]) == \\"YES\\" def test_subset_sum_zero_two_elements_no_sum_zero(): assert subset_sum_zero(2, [1, 2]) == \\"NO\\" def test_subset_sum_zero_larger_example(): assert subset_sum_zero(10, [1, -1, 2, -2, 3, -3, 4, -4, 5, -5]) == \\"YES\\" def test_subset_sum_zero_no_valid_subset(): assert subset_sum_zero(3, [5, 10, 20]) == \\"NO\\" def test_subset_sum_zero_all_negatives(): assert subset_sum_zero(3, [-5, -10, -15]) == \\"NO\\" def test_subset_sum_zero_mixed_signs(): assert subset_sum_zero(6, [-1, 1, -2, 2, -3, 3]) == \\"YES\\"","solution":"def subset_sum_zero(n, nums): Determines if there exists a subset of the given list of numbers that adds up to zero. Returns 'YES' if such a subset exists, otherwise 'NO'. :param n: Number of integers :param nums: List of integers from itertools import combinations # Check all non-empty subsets for r in range(1, n + 1): for subset in combinations(nums, r): if sum(subset) == 0: return \\"YES\\" return \\"NO\\""},{"question":"def zigzag_sequence(n: int) -> List[int]: Given an integer n, check if it is possible to create a Zigzag sequence of n distinct positive integers, and output one such sequence if it exists. If not, output \\"impossible\\". >>> zigzag_sequence(1) [1] >>> zigzag_sequence(2) \\"impossible\\" >>> zigzag_sequence(5) [1, 3, 2, 5, 4] >>> zigzag_sequence(4) \\"impossible\\"","solution":"def zigzag_sequence(n): if n == 1: return [1] if n == 2 or n == 4: return \\"impossible\\" result = [] for i in range(1, (n//2) + 1): result.append(i) if (2*i <= n): result.append(n - i + 1) if n % 2 == 1: result.append((n//2) + 1) return result"},{"question":"def is_at_origin(s: str) -> bool: Determines if the sequence of movements returns to the origin (0, 0). :param s: A string consisting only of 'U', 'D', 'L', and 'R'. :return: True if the movements return to the origin, False otherwise. >>> is_at_origin(\\"UDLR\\") True >>> is_at_origin(\\"UUDDLLRR\\") True >>> is_at_origin(\\"UUDL\\") False","solution":"def is_at_origin(s: str) -> bool: Determines if the sequence of movements returns to the origin (0, 0). :param s: A string consisting only of 'U', 'D', 'L', and 'R'. :return: True if the movements return to the origin, False otherwise. x, y = 0, 0 for char in s: if char == 'U': y += 1 elif char == 'D': y -= 1 elif char == 'L': x -= 1 elif char == 'R': x += 1 return x == 0 and y == 0"},{"question":"def distribute_tasks(n: int, m: int, weights: List[int]) -> List[List[int]]: Distribute weekly tasks among a group of team members in a balanced way. Args: n (int): Number of tasks. m (int): Number of team members. weights (List[int]): List of weights for each task. Returns: List[List[int]]: A list of lists where each inner list contains the indices of tasks assigned to each team member. >>> distribute_tasks(5, 2, [5, 3, 4, 2, 6]) # Example 1 [[1, 2, 4], [3, 5]] >>> distribute_tasks(6, 3, [8, 5, 9, 7, 4, 2]) # Example 2 [[1, 4], [2, 3], [5, 6]]","solution":"def distribute_tasks(n, m, weights): from itertools import accumulate task_indices = list(range(1, n + 1)) # Create task index list starting from 1 tasks = list(zip(weights, task_indices)) # Pair weights with their indices tasks.sort(reverse=True) # Sort tasks by weight in descending order # Initialize m empty lists for team members workloads = [[] for _ in range(m)] workload_weights = [0] * m # Track the total weight for each member for weight, index in tasks: # Assign the task to the team member with the current minimum total weight min_member = workload_weights.index(min(workload_weights)) workloads[min_member].append(index) workload_weights[min_member] += weight return workloads # Example Usage n, m = 5, 2 weights = [5, 3, 4, 2, 6] print(distribute_tasks(n, m, weights)) # Expected to produce balanced distribution of tasks"},{"question":"def rotateArray(arr: list[int], k: int) -> list[int]: Rotates the array to the right by k steps. Args: arr (list of int): The array to be rotated. k (int): The number of steps to rotate the array. Returns: list of int: The rotated array. Examples: >>> rotateArray([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotateArray([1, 2, 3], 4) [3, 1, 2]","solution":"def rotateArray(arr, k): Rotates the array to the right by k steps. Args: arr (list of int): The array to be rotated. k (int): The number of steps to rotate the array. Returns: list of int: The rotated array. n = len(arr) k = k % n # In case k is larger than the size of the array return arr[-k:] + arr[:-k]"},{"question":"from typing import List def longest_increasing_path(matrix: List[List[int]]) -> int: Determine the length of the longest strictly increasing path in a matrix. Args: matrix (List[List[int]]): A 2D list of integers representing the heights of cells in the matrix. Returns: int: The length of the longest strictly increasing path starting from any cell. Examples: >>> longest_increasing_path([ ...[9, 9, 4], ...[6, 6, 8], ...[2, 1, 1]]) 4 >>> longest_increasing_path([ ...[1, 2, 3], ...[6, 5, 4], ...[7, 8, 9]]) 9 >>> longest_increasing_path([[5]]) 1 >>> longest_increasing_path([ ...[3, 4, 5], ...[3, 2, 6], ...[2, 2, 1]]) 4 >>> longest_increasing_path([ ...[3, 4], ...[2, 1]]) 4","solution":"def longest_increasing_path(matrix): if not matrix or not matrix[0]: return 0 n, m = len(matrix), len(matrix[0]) dp = [[-1] * m for _ in range(n)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dfs(x, y): if dp[x][y] != -1: return dp[x][y] max_path_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and matrix[nx][ny] > matrix[x][y]: max_path_length = max(max_path_length, 1 + dfs(nx, ny)) dp[x][y] = max_path_length return dp[x][y] return max(dfs(i, j) for i in range(n) for j in range(m)) # Helper function to read input and call main function (mainly for testing purposes) def read_and_process_input(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) m = int(data[1]) matrix = [] index = 2 for i in range(n): row = list(map(int, data[index:index + m])) matrix.append(row) index += m print(longest_increasing_path(matrix))"},{"question":"def numIdenticalPairs(nums: List[int]) -> int: You have an integer array \`nums\`. A pair \`(i, j)\` is called a good pair if \`nums[i] == nums[j]\` and \`i < j\`. Return the number of good pairs. Parameters: nums (List[int]): A list of integers. Returns: int: The number of good pairs. Examples: -------- >>> numIdenticalPairs([1, 2, 3, 1, 1, 3]) 4 >>> numIdenticalPairs([1, 1, 1, 1]) 6 >>> numIdenticalPairs([1, 2, 3]) 0","solution":"def numIdenticalPairs(nums): Returns the number of good pairs in the list nums. from collections import Counter count = Counter(nums) good_pairs = 0 for value in count.values(): if value > 1: good_pairs += value * (value - 1) // 2 return good_pairs"},{"question":"class SegmentTree: def __init__(self, data): pass def update(self, index, value): pass def range_query(self, left, right): pass def process_queries(n, q, arr, queries): Process a list of update and range maximum queries on an array. Input: n: int - Number of elements in the array q: int - Number of queries arr: List[int] - The initial array queries: List[Tuple[int, ...]] - A list of queries Output: List[int] - The results of the range maximum queries Example: >>> process_queries(5, 3, [2, 1, 5, 3, 4], [(2, 1, 3), (1, 2, 10), (2, 1, 3)]) [5, 10] >>> process_queries(5, 2, [5, 5, 5, 5, 5], [(2, 1, 5), (2, 2, 3)]) [5, 5] pass","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Initialize the segment tree with the initial data # Copy data to the leaf nodes for i in range(self.n): self.tree[self.n + i] = data[i] # Build the segment tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, index, value): # Update the value at the leaf node pos = index + self.n self.tree[pos] = value # Update all the parents while pos > 1: pos //= 2 self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1]) def range_query(self, left, right): # Query the maximum in the range from \`left\` to \`right\` result = -float('inf') left += self.n right += self.n + 1 while left < right: if left % 2 == 1: result = max(result, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 result = max(result, self.tree[right]) left //= 2 right //= 2 return result def process_queries(n, q, arr, queries): segment_tree = SegmentTree(arr) results = [] for query in queries: if query[0] == 1: x, y = query[1] - 1, query[2] segment_tree.update(x, y) elif query[0] == 2: l, r = query[1] - 1, query[2] - 1 result = segment_tree.range_query(l, r) results.append(result) return results"},{"question":"def removeOddsAndSort(lst): Given a list of integers, remove all odd elements from the list and return the modified list in sorted order. Args: lst (list): A list of integers Returns: list: A list of even numbers in sorted order Example: >>> removeOddsAndSort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) [2, 4, 6] >>> removeOddsAndSort([7, 8, 7, 10, 5, 2]) [2, 8, 10]","solution":"def removeOddsAndSort(lst): Removes odd elements from the list and returns the modified list in sorted order. # Filter out odd numbers even_list = [x for x in lst if x % 2 == 0] # Sort the remaining even numbers even_list.sort() return even_list"},{"question":"def find_paths(m: int, n: int): Print all unique paths in a m x n matrix from the top-left to the bottom-right corner. Args: m (int): The number of rows in the matrix. n (int): The number of columns in the matrix. Example: >>> find_paths(2, 2) (0,0) -> (0,1) -> (1,1) (0,0) -> (1,0) -> (1,1) >>> find_paths(3, 3) (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) (0,0) -> (0,1) -> (1,1) -> (1,2) -> (2,2) (0,0) -> (0,1) -> (1,1) -> (2,1) -> (2,2) (0,0) -> (1,0) -> (1,1) -> (1,2) -> (2,2) (0,0) -> (1,0) -> (1,1) -> (2,1) -> (2,2) (0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2)","solution":"def find_paths(m, n): def backtrack(x, y, path): if x == m - 1 and y == n - 1: paths.append(path) return if y + 1 < n: backtrack(x, y + 1, path + [(x, y + 1)]) if x + 1 < m: backtrack(x + 1, y, path + [(x + 1, y)]) paths = [] backtrack(0, 0, [(0, 0)]) for path in paths: print(' -> '.join(f\\"({r},{c})\\" for r, c in path)) # Example Usage # find_paths(2, 2) # find_paths(3, 3)"},{"question":"def reverseWords(s: str) -> str: Returns the input string s with the words reversed. >>> reverseWords(\\"Hello World\\") 'World Hello' >>> reverseWords(\\"Coding is fun\\") 'fun is Coding' >>> reverseWords(\\"OpenAI GPT-3\\") 'GPT-3 OpenAI' >>> reverseWords(\\"racecar level\\") 'level racecar' >>> reverseWords(\\"Hello\\") 'Hello' >>> reverseWords(\\"\\") '' >>> reverseWords(\\" a b c \\") 'c b a' >>> reverseWords(\\" \\") ''","solution":"def reverseWords(s): Returns the input string s with the words reversed. return ' '.join(s.split()[::-1])"},{"question":"def max_wizards_consuming_fruits(T, test_cases): Determine the maximum number of wizards that can successfully consume fruits without exceeding their magical power limits. Args: T (int): The number of test cases. test_cases (list of dicts): List of test case dictionaries. Each dictionary contains: - N (int): The number of trees. - M (int): The number of wizards. - P (list of int): The magical power array of the trees. - L (list of int): The magical power limit array of the wizards. Returns: list of int: List of results for each test case. >>> T = 1 >>> test_cases = [ ... { ... \\"N\\": 5, ... \\"M\\": 3, ... \\"P\\": [10, 20, 30, 40, 50], ... \\"L\\": [60, 70, 80] ... } ... ] >>> max_wizards_consuming_fruits(T, test_cases) [3] >>> T = 1 >>> test_cases = [ ... { ... \\"N\\": 1, ... \\"M\\": 1, ... \\"P\\": [50], ... \\"L\\": [100] ... } ... ] >>> max_wizards_consuming_fruits(T, test_cases) [1] >>> T = 1 >>> test_cases = [ ... { ... \\"N\\": 5, ... \\"M\\": 2, ... \\"P\\": [10, 10, 10, 10, 10], ... \\"L\\": [20, 20] ... } ... ] >>> max_wizards_consuming_fruits(T, test_cases) [2] >>> T = 1 >>> test_cases = [ ... { ... \\"N\\": 5, ... \\"M\\": 3, ... \\"P\\": [100, 100, 100, 100, 100], ... \\"L\\": [50, 60, 70] ... } ... ] >>> max_wizards_consuming_fruits(T, test_cases) [0]","solution":"def max_wizards_consuming_fruits(T, test_cases): results = [] for i in range(T): N, M = test_cases[i][\\"N\\"], test_cases[i][\\"M\\"] P, L = test_cases[i][\\"P\\"], test_cases[i][\\"L\\"] # Initialize prefix sum prefix_sum = [0] * (N + 1) for j in range(1, N + 1): prefix_sum[j] = prefix_sum[j - 1] + P[j - 1] # Function to find the maximum subarray sum <= limit def can_wizard_eat(limit): min_prefix = 0 for j in range(1, N + 1): if prefix_sum[j] - min_prefix <= limit: return True min_prefix = min(min_prefix, prefix_sum[j]) return False # Check each wizard's limit count = 0 for limit in L: if can_wizard_eat(limit): count += 1 results.append(count) return results"},{"question":"def is_in_range(ranges, target): Determines if the target number falls within any of the specified ranges. Parameters: ranges (list of tuples): A list of tuples where each tuple contains two integers representing the start and end of a range (inclusive). target (int): The target number to check against the ranges. Returns: bool: True if the target is within any of the ranges, False otherwise. >>> is_in_range([(1, 5), (10, 15), (20, 25)], 3) True >>> is_in_range([(1, 5), (10, 15), (20, 25)], 16) False","solution":"def is_in_range(ranges, target): Determines if the target number falls within any of the specified ranges. Parameters: ranges (list of tuples): A list of tuples where each tuple contains two integers representing the start and end of a range (inclusive). target (int): The target number to check against the ranges. Returns: bool: True if the target is within any of the ranges, False otherwise. for start, end in ranges: if start <= target <= end: return True return False"},{"question":"def count_distinct_palindromic_substrings(S: str) -> int: Returns the count of distinct palindromic substrings in the given string S. >>> count_distinct_palindromic_substrings(\\"aabaa\\") 5 >>> count_distinct_palindromic_substrings(\\"abcd\\") 4 def process_test_cases(test_cases: List[str]) -> List[int]: Given a list of test cases, returns a list where each element represents the number of distinct palindromic substrings for the respective test case. >>> process_test_cases([\\"aabaa\\", \\"abcd\\"]) [5, 4] >>> process_test_cases([\\"aaa\\", \\"racecar\\", \\"a\\"]) [3, 7, 1]","solution":"def count_distinct_palindromic_substrings(S): Returns the count of distinct palindromic substrings in the given string S. def is_palindrome(s): return s == s[::-1] palindromes = set() n = len(S) for i in range(n): for j in range(i, n): substr = S[i:j+1] if is_palindrome(substr): palindromes.add(substr) return len(palindromes) def process_test_cases(test_cases): results = [] for S in test_cases: results.append(count_distinct_palindromic_substrings(S)) return results # Example to test the solution if __name__ == \\"__main__\\": T = 2 test_cases = [\\"aabaa\\", \\"abcd\\"] results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"def min_boxes(t: int, ks: List[int]) -> List[Tuple[int, int]]: Determine the minimum amount of small and large boxes needed to package exactly \`k\` treats Args: t: an integer representing the number of test cases ks: a list of integers where each integer represents the number of treats to be packaged Returns: A list of tuples containing two integers each, representing the number of small boxes (s) and large boxes (l) used respectively. Example: >>> min_boxes(5, [14, 4, 1, 8, 27]) [(2, 4), (1, 1), (1, 0), (2, 2), (0, 9)]","solution":"def min_boxes(t, ks): results = [] for k in ks: large_boxes = k // 3 remainder = k % 3 small_boxes = remainder results.append((small_boxes, large_boxes)) return results"},{"question":"def min_operations_to_special_list(n: int, arr: List[int]) -> int: This function returns the minimum number of operations required to transform the list into a \\"special\\" list where every element in the list is a multiple of 3. >>> min_operations_to_special_list(4, [1, 2, 3, 4]) 3 >>> min_operations_to_special_list(3, [3, 6, 9]) 0 >>> min_operations_to_special_list(3, [1, 4, 7]) 3 >>> min_operations_to_special_list(3, [2, 5, 8]) 3 >>> min_operations_to_special_list(5, [2, 6, 9, 13, 14]) 3 >>> min_operations_to_special_list(4, [-1, -2, -3, -4]) 3","solution":"def min_operations_to_special_list(n, arr): This function returns the minimum number of operations required to transform the list into a \\"special\\" list where every element in the list is a multiple of 3. operations = 0 for num in arr: remainder = num % 3 if remainder == 1: operations += 1 # decrement by 1 to get a multiple of 3 elif remainder == 2: operations += 1 # increment by 1 to get a multiple of 3 return operations"},{"question":"def count_pairs_with_sum(arr, target): Determine the number of unique pairs of integers in the array whose sum equals the target integer. Each pair should be sorted in ascending order and counted only once. Args: arr (List[int]): Array of integers. target (int): Target sum for the pairs. Returns: int: Number of unique pairs whose sum equals the target integer. Examples: >>> count_pairs_with_sum([1, 5, 7, -1, 5], 6) 2 >>> count_pairs_with_sum([1, 2, 3], 7) 0 from solution import count_pairs_with_sum def test_sample_input(): assert count_pairs_with_sum([1, 5, 7, -1, 5], 6) == 2 def test_no_pairs(): assert count_pairs_with_sum([1, 2, 3], 7) == 0 def test_multiple_pairs(): assert count_pairs_with_sum([1, 1, 1, 1, 1, 1], 2) == 1 def test_with_negative_numbers(): assert count_pairs_with_sum([1, -1, 2, -2, 3, -3, 4, -4], 0) == 4 def test_with_duplicates(): assert count_pairs_with_sum([1, 2, 3, 4, 3, 5, 5], 8) == 1 def test_large_varied_numbers(): assert count_pairs_with_sum([10, 20, -10, -20, 15, -5, 5, 25], 15) == 3","solution":"def count_pairs_with_sum(arr, target): Returns the number of unique pairs in the array whose sum equals the target integer. pairs = set() # To store unique pairs seen = set() # To store numbers we have seen so far for num in arr: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"from typing import List, Tuple def min_time_to_complete_tasks(n: int, m: int, dependencies: List[Tuple[int, int]]) -> int: Determines the minimum time to complete all tasks given their dependencies. Arguments: n -- the number of tasks m -- the number of dependencies dependencies -- a list of tuples representing the dependencies (u, v) where task u must be completed before task v. Example: >>> min_time_to_complete_tasks(5, 4, [(1, 2), (1, 3), (3, 4), (2, 5)]) 3 >>> min_time_to_complete_tasks(4, 3, [(1, 2), (1, 3), (2, 4)]) 3 pass # Unit tests to verify the function works as expected def test_min_time_to_complete_tasks(): assert min_time_to_complete_tasks(5, 4, [(1, 2), (1, 3), (3, 4), (2, 5)]) == 3 assert min_time_to_complete_tasks(4, 3, [(1, 2), (1, 3), (2, 4)]) == 3 assert min_time_to_complete_tasks(5, 5, [(1, 2), (1, 3), (2, 4), (3, 5), (4, 5)]) == 4 assert min_time_to_complete_tasks(6, 6, [(1, 2), (1, 3), (3, 4), (2, 5), (5, 6), (4, 6)]) == 4 assert min_time_to_complete_tasks(3, 2, [(1, 2), (2, 3)]) == 3 assert min_time_to_complete_tasks(1, 0, []) == 1","solution":"from collections import deque, defaultdict def min_time_to_complete_tasks(n, m, dependencies): # Initialize graph and in-degree count graph = defaultdict(list) in_degree = [0] * (n+1) # Build the graph and update in-degree count for u, v in dependencies: graph[u].append(v) in_degree[v] += 1 # Queue to perform topological sort and array to store the minimum time required queue = deque() min_time = [0] * (n+1) # Initialize the queue with tasks that have no dependencies for i in range(1, n+1): if in_degree[i] == 0: queue.append(i) min_time[i] = 1 # Topological sort and calculate the minimum time while queue: current_task = queue.popleft() for neighbor in graph[current_task]: in_degree[neighbor] -= 1 # Once all dependencies of the neighbor are satisfied, add it to the queue if in_degree[neighbor] == 0: queue.append(neighbor) min_time[neighbor] = min_time[current_task] + 1 # The answer is the maximum of min_time array return max(min_time) # Example of usage n = 5 m = 4 dependencies = [(1, 2), (1, 3), (3, 4), (2, 5)] print(min_time_to_complete_tasks(n, m, dependencies)) # Output: 3"},{"question":"def longest_palindrome(n: int, s: str) -> str: Samuel likes strings and he is fascinated by palindromes. A palindrome is a string that reads the same backward as forward. Samuel wants to create the longest possible palindrome by rearranging the characters in a given string s. Your task is to help Samuel by constructing the longest possible palindrome that can be made using all the characters of the string s (some characters do not have to be used necessarily). If there are multiple possible answers, return any of them. Parameters: n (int): The length of the string. s (str): A string consisting of n lowercase English letters. Returns: str: The longest possible palindrome. >>> longest_palindrome(7, 'abccccdd') 'dccaccd' >>> longest_palindrome(1, 'a') 'a'","solution":"from collections import Counter def longest_palindrome(n, s): Returns the longest palindrome that can be made using the characters of the input string s. Parameters: n (int): The length of the string s. s (string): A string consisting of n lowercase English letters. Returns: string: The longest possible palindrome. count = Counter(s) left_part = [] middle_part = [] # We will collect characters for the left half and the middle part. for char, freq in count.items(): # If the frequency is even, we can put half in the left part. left_part.extend([char] * (freq // 2)) # If the frequency is odd, use the maximum possible even number and save one for the middle. if freq % 2 != 0: middle_part = [char] # Left part of the palindrome left_half = ''.join(left_part) # The corresponding right part will be the left part reversed. right_half = left_half[::-1] # Construct the palindrome using the left part, middle part (if any), and the right part. return left_half + ''.join(middle_part) + right_half # Example usage n = 7 s = \\"abccccdd\\" print(longest_palindrome(n, s)) # Output: dccaccd"},{"question":"def maximal_rectangle(grid: List[List[str]]) -> int: Find the largest rectangular island in the grid. An island is formed by connecting adjacent lands horizontally or vertically. The area of an island is the number of '1's in that island. Args: grid: List[List[str]]: A 2D grid representation of land ('1') and water ('0') cells with m rows and n columns. Returns: int: The maximum area of a rectangular island in the grid. Examples: >>> maximal_rectangle([ ['1', '0', '1', '0', '0', '1'], ['1', '0', '1', '1', '1', '1'], ['1', '1', '1', '1', '1', '0'], ['0', '0', '0', '1', '0', '0'], ['1', '1', '0', '0', '0', '1'] ]) 6 >>> maximal_rectangle([ ['1'] ]) 1 >>> maximal_rectangle([ ['0', '0', '0'], ['0', '0', '0'], ['0', '0', '0'] ]) 0 >>> maximal_rectangle([ ['1', '1', '1'], ]) 3 >>> maximal_rectangle([ ['1'], ['1'], ['1'] ]) 3 >>> maximal_rectangle([ ['1', '0', '1', '0', '1'], ['0', '1', '0', '1', '0'], ['1', '0', '1', '0', '1'] ]) 1 pass","solution":"def maximal_rectangle(grid): if not grid: return 0 m, n = len(grid), len(grid[0]) heights = [0] * (n + 1) max_area = 0 for row in grid: for i in range(n): heights[i] = heights[i] + 1 if row[i] == '1' else 0 stack = [-1] for i in range(n + 1): while heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"def max_flowers(N: int, H: int, S: List[int]) -> int: Determines the maximum number of different types of flowers Mary can plant without exceeding the total number of hours of sunlight (H) per day. Args: N : int : Number of different types of flowers H : int : Total number of hours of sunlight available per day S : list : Sunlight requirements for each type of flower Returns: int : Maximum number of different types of flowers Mary can plant >>> max_flowers(5, 10, [2, 3, 4, 5, 1]) 4 >>> max_flowers(3, 5, [2, 2, 3]) 2 def solve_flower_problem(T: int, cases: List[Tuple[int, int, List[int]]]) -> List[int]: Solves multiple test cases of the flower planting problem. Args: T : int : Number of test cases cases : list : List of tuples containing (N, H, S) for each test case Returns: list : List of results for each test case >>> solve_flower_problem(2, [(5, 10, [2, 3, 4, 5, 1]), (3, 5, [2, 2, 3])]) [4, 2] from solution import max_flowers, solve_flower_problem def test_single_case(): assert max_flowers(5, 10, [2, 3, 4, 5, 1]) == 4 assert max_flowers(3, 5, [2, 2, 3]) == 2 def test_multiple_cases(): cases = [ (5, 10, [2, 3, 4, 5, 1]), (3, 5, [2, 2, 3]) ] assert solve_flower_problem(2, cases) == [4, 2] def test_edge_cases(): assert max_flowers(1, 1, [1]) == 1 assert max_flowers(1, 100, [100]) == 1 assert max_flowers(1, 99, [100]) == 0 assert max_flowers(3, 1000, [1, 2, 3]) == 3 def test_more_cases(): cases = [ (5, 7, [1, 3, 2, 5, 4]), (4, 6, [2, 2, 2, 2]), (6, 15, [7, 10, 6, 8, 5, 4]), (2, 5, [3, 4]) ] assert solve_flower_problem(4, cases) == [3, 3, 3, 1]","solution":"def max_flowers(N, H, S): Determines the maximum number of different types of flowers Mary can plant without exceeding the total number of hours of sunlight (H) per day. Args: N : int : Number of different types of flowers H : int : Total number of hours of sunlight available per day S : list : Sunlight requirements for each type of flower Returns: int : Maximum number of different types of flowers Mary can plant S.sort() count = 0 total_hours = 0 for s in S: if total_hours + s <= H: total_hours += s count += 1 else: break return count def solve_flower_problem(T, cases): results = [] for i in range(T): N, H, S = cases[i] results.append(max_flowers(N, H, S)) return results"},{"question":"def lexicographically_smallest_sequence(arr: List[int]) -> List[int]: Determine the lexicographically smallest sequence that can be achieved by performing either one swap or one reverse operation exactly once. If no operation yields a better result than the initial array, the original sequence is considered as the result. >>> lexicographically_smallest_sequence([3, 2, 1, 5, 4]) [1, 2, 3, 5, 4] >>> lexicographically_smallest_sequence([4, 3, 2]) [2, 3, 4] >>> lexicographically_smallest_sequence([1, 2, 3]) [1, 2, 3] >>> lexicographically_smallest_sequence([5, 1, 3, 4, 2]) [1, 5, 3, 4, 2] def solve_robotics_competition(input_data: str) -> str: Given the input data for the robotics competition, return the lexicographically smallest sequence for each test case. >>> solve_robotics_competition(\\"2n5n3 2 1 5 4n3n4 3 2n\\") \\"1 2 3 5 4n2 3 4\\" >>> solve_robotics_competition(\\"1n3n1 2 3n\\") \\"1 2 3\\" >>> solve_robotics_competition(\\"1n4n4 3 1 2n\\") \\"1 3 4 2\\"","solution":"def lexicographically_smallest_sequence(arr): n = len(arr) # To simplify, we assume no operation initially gives the smallest lexicographical order best_sequence = arr[:] # Try the swap operation and compare each swap result to find the smallest sequence for i in range(n - 1): arr_copy = arr[:] arr_copy[i], arr_copy[i + 1] = arr_copy[i + 1], arr_copy[i] if arr_copy < best_sequence: best_sequence = arr_copy # Try the reverse operation for every possible pair of indices and find the smallest order for start in range(n): for end in range(start + 1, n): arr_copy = arr[:] arr_copy[start:end + 1] = reversed(arr_copy[start:end + 1]) if arr_copy < best_sequence: best_sequence = arr_copy return best_sequence def solve_robotics_competition(input_data): result = [] lines = input_data.strip().split('n') index = 0 num_test_cases = int(lines[index]) index += 1 for _ in range(num_test_cases): n = int(lines[index]) index += 1 array = list(map(int, lines[index].split())) index += 1 smallest_sequence = lexicographically_smallest_sequence(array) result.append(' '.join(map(str, smallest_sequence))) return 'n'.join(result)"},{"question":"[Completion Task in Python] def search_nested_object(obj, key): Recursively searches for a key in a nested object and returns its value if found, else returns None. Example: >>> data = { >>> 'level1': { >>> 'level2': { >>> 'level3': 'found me' >>> }, >>> 'anotherLevel2': { >>> 'anotherLevel3': 'hello' >>> } >>> } >>> } >>> search_nested_object(data, 'level3') 'found me' >>> search_nested_object(data, 'anotherLevel3') 'hello' >>> search_nested_object(data, 'level4') None pass","solution":"def search_nested_object(obj, key): Recursively searches for a key in a nested object and returns its value if found, else returns None. if key in obj: return obj[key] for k, v in obj.items(): if isinstance(v, dict): found = search_nested_object(v, key) if found: return found return None"},{"question":"def oddOccurrences(arr: List[int]) -> List[int]: Given a list of positive integers, return a list of integers that appear an odd number of times. The output list is sorted in ascending order. >>> oddOccurrences([1, 2, 3, 2, 3, 1, 3]) [3] >>> oddOccurrences([4, 5, 6, 4, 6, 6, 5, 5]) [5, 6]","solution":"def oddOccurrences(arr): Given a list of positive integers, return a list of integers that appear an odd number of times. The output list is sorted in ascending order. from collections import Counter count = Counter(arr) result = [num for num, freq in count.items() if freq % 2 != 0] result.sort() return result"},{"question":"def trap_rain_water(heights): Calculate the amount of rainwater that can be trapped between buildings, given an array of building heights. Args: heights (List[int]): An array of integers where heights[i] represents the height of the i-th building Returns: int: The total amount of rainwater that can be trapped Examples: >>> trap_rain_water([4, 2, 0, 3, 2, 5]) 9 >>> trap_rain_water([1, 1, 1, 1]) 0 >>> trap_rain_water([0, 2, 0]) 0 >>> trap_rain_water([3, 0, 0, 2, 0, 4]) 10 pass","solution":"def trap_rain_water(heights): if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: Determine whether a given binary tree is height-balanced. A binary tree is height-balanced if the difference in height between the left and right subtrees of any node in the tree is no more than 1. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20, TreeNode(15), TreeNode(7)) >>> is_balanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2, TreeNode(3, TreeNode(4), TreeNode(4)), TreeNode(3)) >>> root.right = TreeNode(2) >>> is_balanced(root) False # Your code here","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: def check_height(node): if not node: return 0, True left_height, left_balanced = check_height(node.left) right_height, right_balanced = check_height(node.right) current_balanced = abs(left_height - right_height) <= 1 current_height = max(left_height, right_height) + 1 return current_height, left_balanced and right_balanced and current_balanced _, is_bal = check_height(root) return is_bal"},{"question":"def sequence_steps(X: int) -> int: Determines the number of steps required to reach 1 following the given rules. >>> sequence_steps(3) 7 >>> sequence_steps(6) 8 >>> sequence_steps(19) 20 pass def solve(T: int, cases: List[int]) -> List[int]: Solves T cases of the sequence steps problem. >>> solve(3, [3, 6, 19]) [7, 8, 20] >>> solve(2, [1, 2]) [0, 1] >>> solve(1, [7]) [16] pass","solution":"def sequence_steps(X): Determines the number of steps required to reach 1 following the given rules. steps = 0 while X != 1: if X % 2 == 0: X //= 2 else: X = X * 3 + 1 steps += 1 return steps def solve(T, cases): Solves T cases of the sequence steps problem. results = [] for X in cases: results.append(sequence_steps(X)) return results"},{"question":"def format_name_badges(attendees): Formats the first name and last name of attendees to have the first letter in uppercase and the rest in lowercase. Args: attendees (list of tuples): A list where each element is a tuple containing the first name and last name of an attendee. Returns: list of str: A list of formatted names. >>> format_name_badges([(\\"alice\\", \\"SMITH\\"), (\\"bOB\\", \\"jOnEs\\"), (\\"CHARLIE\\", \\"Brown\\")]) [\\"Alice Smith\\", \\"Bob Jones\\", \\"Charlie Brown\\"] >>> format_name_badges([(\\"jOhN\\", \\"doE\\"), (\\"MARy\\", \\"PEterS\\"), (\\"annA\\", \\"MILLER\\")]) [\\"John Doe\\", \\"Mary Peters\\", \\"Anna Miller\\"] >>> format_name_badges([(\\"john\\", \\"doe\\"), (\\"jane\\", \\"smith\\"), (\\"sam\\", \\"green\\")]) [\\"John Doe\\", \\"Jane Smith\\", \\"Sam Green\\"] >>> format_name_badges([(\\"JOHN\\", \\"DOE\\"), (\\"JANE\\", \\"SMITH\\"), (\\"SAM\\", \\"GREEN\\")]) [\\"John Doe\\", \\"Jane Smith\\", \\"Sam Green\\"] >>> format_name_badges([(\\"a\\", \\"B\\"), (\\"x\\", \\"Y\\"), (\\"m\\", \\"N\\")]) [\\"A B\\", \\"X Y\\", \\"M N\\"]","solution":"def format_name_badges(attendees): Formats the first name and last name of attendees to have the first letter in uppercase and the rest in lowercase. Args: attendees (list of tuples): A list where each element is a tuple containing the first name and last name of an attendee. Returns: list of str: A list of formatted names. formatted_names = [] for first_name, last_name in attendees: formatted_first_name = first_name.capitalize() formatted_last_name = last_name.capitalize() formatted_names.append(f\\"{formatted_first_name} {formatted_last_name}\\") return formatted_names"},{"question":"def minSubarraySorts(arr): Consider an array of integers \`arr\` of size \`n\`. We define a subarray-sort operation on the array as a process where you choose any one subarray [l, r] (1 ≤ l ≤ r ≤ n) and sort the subarray in non-decreasing order. Your goal is to find the minimum number of subarray-sort operations needed to make the entire array sorted in non-decreasing order. Write a function \`minSubarraySorts(arr)\` that takes the array \`arr\` as input and returns an integer representing the minimum number of subarray-sort operations required. Args: arr (list[int]): The input array of integers. Returns: int: The minimum number of subarray-sort operations needed to sort the array. Example: >>> minSubarraySorts([1, 5, 3, 4, 2]) 1 >>> minSubarraySorts([4, 3, 1, 2]) 1 >>> minSubarraySorts([1, 2, 3, 4, 5]) 0 >>> minSubarraySorts([5, 4, 3, 2, 1]) 1 >>> minSubarraySorts([1]) 0","solution":"def minSubarraySorts(arr): n = len(arr) sorted_arr = sorted(arr) if arr == sorted_arr: return 0 l = 0 while l < n and arr[l] == sorted_arr[l]: l += 1 r = n - 1 while r >= 0 and arr[r] == sorted_arr[r]: r -= 1 return 1"},{"question":"def count_even_sum_pairs(test_cases): Returns the count of pairs whose sum is even for each test case. Parameters: test_cases (list of tuples): list of test cases, where each test case is a tuple with an integer N and a list of integers. Returns: list: list of integers representing the count of even sum pairs for each test case. pass # Function to process input and output def process_input_output(input_data): Processes the input data, computes count of even sum pairs for each test case, and returns the result as a formatted output string. Parameters: input_data (str): multiline string containing the test cases. Returns: str: formatted result string with the count of even sum pairs for each test case. >>> input_data = \\"2n4n1 2 3 4n3n2 2 2\\" >>> process_input_output(input_data) \\"2n3\\" >>> input_data = \\"3n5n2 4 6 8 10n4n1 1 1 1n2n1 2\\" >>> process_input_output(input_data) \\"10n6n0\\" >>> input_data = \\"2n1n2n2n1 3\\" >>> process_input_output(input_data) \\"0n1\\" pass","solution":"def count_even_sum_pairs(test_cases): Returns a list with the count of pairs whose sum is even for each test case. Parameters: test_cases (list of tuples): list of test cases, where each test case is a tuple with an integer N and a list of integers. Returns: list: list of integers representing the count of even sum pairs for each test case. result = [] for N, numbers in test_cases: even_count = sum(1 for x in numbers if x % 2 == 0) odd_count = N - even_count # Number of pairs (i, j) with both i and j even: combination(even_count, 2) even_pairs = even_count * (even_count - 1) // 2 # Number of pairs (i, j) with both i and j odd: combination(odd_count, 2) odd_pairs = odd_count * (odd_count - 1) // 2 result.append(even_pairs + odd_pairs) return result # Function to process input and output def process_input_output(input_data): lines = input_data.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) numbers = list(map(int, lines[index + 1].split())) test_cases.append((N, numbers)) index += 2 result = count_even_sum_pairs(test_cases) return 'n'.join(map(str, result))"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Check if two strings are anagrams. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"apple\\", \\"pale\\") False def check_anagram_pairs(pairs: List[Tuple[str, str]]) -> List[str]: Given a list of pairs of strings, determine if each pair are anagrams. >>> check_anagram_pairs([(\\"listen\\", \\"silent\\"), (\\"apple\\", \\"pale\\")]) [\\"Yes\\", \\"No\\"]","solution":"def are_anagrams(str1, str2): Check if two strings are anagrams. return sorted(str1) == sorted(str2) def check_anagram_pairs(pairs): Given a list of pairs of strings, determine if each pair are anagrams. results = [] for str1, str2 in pairs: if are_anagrams(str1, str2): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def minimize_inconvenience(N: int) -> List[int]: Returns an order of participants' IDs that minimizes the total inconvenience. Args: N (int): The number of participants Returns: List[int]: List of participants' IDs in the order that minimizes the total inconvenience. Examples: >>> minimize_inconvenience(5) [1, 2, 3, 4, 5] >>> minimize_inconvenience(4) [1, 2, 3, 4]","solution":"def minimize_inconvenience(N): Returns an order of participants' IDs that minimizes the total inconvenience. # The optimal order is simply the sequence of numbers from 1 to N return list(range(1, N+1))"},{"question":"def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise returns False. Parameters: n (int): The integer to check for prime status. Returns: bool: True if n is prime, False otherwise. Examples: >>> is_prime(7) True >>> is_prime(10) False pass # Unit Tests def test_prime_small_numbers(): assert is_prime(1) == False assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False def test_prime_various_numbers(): assert is_prime(5) == True assert is_prime(10) == False assert is_prime(11) == True assert is_prime(20) == False assert is_prime(23) == True def test_prime_large_numbers(): assert is_prime(997) == True assert is_prime(1000) == False assert is_prime(1001) == False def test_prime_edge_cases(): assert is_prime(0) == False assert is_prime(1) == False assert is_prime(-7) == False def test_prime_perfect_square_numbers(): assert is_prime(49) == False assert is_prime(121) == False","solution":"def is_prime(n): Returns True if n is a prime number, otherwise returns False. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True"},{"question":"def update_stock(stock, transactions): Updates the stock dictionary based on the transactions. Parameters: stock (dict): A dictionary with items as keys and their current stock numbers as values. transactions (list): A list of lists where each sublist contains an item and the quantity sold. Returns: dict: Updated stock dictionary after processing all transactions. pass # Unit Tests def test_update_stock(): assert update_stock({'apple': 10, 'banana': 5, 'orange': 8}, [['apple', 5], ['banana', 2], ['orange', 1]]) == {'apple': 5, 'banana': 3, 'orange': 7} assert update_stock({'apple': 3, 'banana': 5}, [['apple', 1], ['banana', 6], ['grape', 4]]) == {'apple': 2, 'banana': -1} assert update_stock({'pen': 15, 'pencil': 10}, [['pen', 10], ['pencil', 5], ['eraser', 3]]) == {'pen': 5, 'pencil': 5} def test_update_stock_no_change(): assert update_stock({'apple': 10}, [['banana', 5], ['orange', 3]]) == {'apple': 10} assert update_stock({'pen': 15, 'pencil': 10}, [['eraser', 1]]) == {'pen': 15, 'pencil': 10} def test_update_stock_empty_transactions(): assert update_stock({'apple': 10, 'banana': 5}, []) == {'apple': 10, 'banana': 5} def test_update_stock_all_items(): assert update_stock({'apple': 3, 'banana': 5}, [['apple', 3], ['banana', 5]]) == {'apple': 0, 'banana': 0}","solution":"def update_stock(stock, transactions): Updates the stock dictionary based on the transactions. Parameters: stock (dict): A dictionary with items as keys and their current stock numbers as values. transactions (list): A list of lists where each sublist contains an item and the quantity sold. Returns: dict: Updated stock dictionary after processing all transactions. for item, quantity in transactions: if item in stock: stock[item] -= quantity return stock"},{"question":"from typing import List, Tuple def find_anagram_pair(words: List[str]) -> Tuple[str, str]: Determine if any two words in the list are anagrams of each other and return a pair of words that are anagrams. If no such pair exists, return an empty tuple. >>> find_anagram_pair([\\"listen\\", \\"enlist\\", \\"google\\", \\"gooegl\\"]) in [(\\"listen\\", \\"enlist\\"), (\\"enlist\\", \\"listen\\")] True >>> find_anagram_pair([\\"rat\\", \\"car\\", \\"tar\\", \\"arc\\"]) in [(\\"rat\\", \\"tar\\"), (\\"car\\", \\"arc\\")] True >>> find_anagram_pair([\\"apple\\", \\"banana\\", \\"orange\\"]) == () True","solution":"def find_anagram_pair(words): Returns a tuple containing two words that are anagrams from the list, or an empty tuple if no such pair exist. # Dictionary to store sorted word as key and corresponding original words as values anagram_dict = {} for word in words: sorted_word = ''.join(sorted(word)) # Sort the characters in the word if sorted_word in anagram_dict: return (anagram_dict[sorted_word], word) # Return the first match pair else: anagram_dict[sorted_word] = word # Store the word in dict return () # Return empty tuple if no anagram pairs found"},{"question":"def max_product(numbers: List[int]) -> int: Returns the maximum product of two distinct elements in the list. >>> max_product([1, 10, 2, 6, 5, 3]) 60 >>> max_product([-10, -10, 1, 3, 2]) 100","solution":"def max_product(numbers): Returns the maximum product of two distinct elements in the list. numbers = sorted(numbers) return max(numbers[0] * numbers[1], numbers[-1] * numbers[-2])"},{"question":"from typing import List def findMinSubstring(s: str, t: str) -> int: Given a string \`s\` that consists of lowercase letters and a target string \`t\` that is also a lowercase letter string, determine the length of the smallest substring of \`s\` that contains all the characters from \`t\` (including duplicates). If such a substring does not exist, return 0. >>> findMinSubstring(\\"ADOBECODEBANC\\", \\"ABC\\") 4 >>> findMinSubstring(\\"this is a test string\\", \\"tist\\") 6 >>> findMinSubstring(\\"geeksforgeeks\\", \\"ork\\") 5 >>> findMinSubstring(\\"hello\\", \\"hello\\") 5 >>> findMinSubstring(\\"hello\\", \\"world\\") 0 >>> findMinSubstring(\\"a\\", \\"a\\") 1 >>> findMinSubstring(\\"a\\", \\"b\\") 0 >>> findMinSubstring(\\"\\", \\"a\\") 0","solution":"from collections import Counter, defaultdict def findMinSubstring(s, t): Finds the length of the smallest substring of \`s\` that contains all the characters from \`t\`. If no such substring exists, returns 0. if not s or not t: return 0 target_count = Counter(t) current_count = defaultdict(int) required_chars = len(target_count) formed_chars = 0 left = 0 min_length = float(\\"inf\\") min_window = (0, 0) for right in range(len(s)): char = s[right] current_count[char] += 1 if char in target_count and current_count[char] == target_count[char]: formed_chars += 1 while left <= right and formed_chars == required_chars: char = s[left] if (right - left + 1) < min_length: min_length = right - left + 1 min_window = (left, right) current_count[char] -= 1 if char in target_count and current_count[char] < target_count[char]: formed_chars -= 1 left += 1 return min_length if min_length != float(\\"inf\\") else 0"},{"question":"def intersect_dicts(*dicts): Returns a dictionary containing only the key-value pairs that are present in every input dictionary. >>> intersect_dicts({'a': 1, 'b': 2}, {'a': 1, 'c': 3}, {'a': 1, 'b': 2, 'd': 4}) == {'a': 1} >>> intersect_dicts({'x': 10, 'y': 20}, {'x': 10, 'y': 30}, {'x': 10}) == {'x': 10} >>> intersect_dicts({'p': 5, 'q': 8}, {'r': 7, 'q': 8}, {'q': 8, 's': 9}) == {'q': 8}","solution":"def intersect_dicts(*dicts): Returns a dictionary containing only the key-value pairs that are present in every input dictionary. if not dicts: return {} # Start with all keys and values from the first dictionary common_items = dicts[0].items() # Intersect with the items of each subsequent dictionary for d in dicts[1:]: common_items = common_items & d.items() # Convert the common items back to a dictionary return dict(common_items)"},{"question":"def is_valid_secret_santa_configuration(n: int) -> str: Determines if a valid secret Santa configuration exists for n participants. :param n: Integer, number of participants. Must be between 2 and 1000 inclusive. :return: \\"Yes\\" if a valid configuration exists, otherwise \\"No\\". >>> is_valid_secret_santa_configuration(3) \\"Yes\\" >>> is_valid_secret_santa_configuration(1) \\"No\\" >>> is_valid_secret_santa_configuration(1000) \\"Yes\\"","solution":"def is_valid_secret_santa_configuration(n): Determines if a valid secret Santa configuration exists for n participants. :param n: Integer, number of participants. :return: \\"Yes\\" if a valid configuration exists, otherwise \\"No\\". if n < 2: return \\"No\\" return \\"Yes\\""},{"question":"def uniquePathsWithObstacles(obstacleGrid: List[List[int]]) -> int: Calculate the number of unique paths from the top-left to the bottom-right corner of a grid, avoiding obstacles. :param obstacleGrid: List[List[int]] - a 2D grid representation where 0 denotes empty cells and 1 denotes obstacles :return: int - the number of unique paths from top-left to bottom-right modulo 10^9 + 7 >>> uniquePathsWithObstacles([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 6 >>> uniquePathsWithObstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 2 >>> uniquePathsWithObstacles([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ]) == 0 >>> uniquePathsWithObstacles([ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> uniquePathsWithObstacles([ ... [0, 1], ... [0, 0] ... ]) == 1 >>> uniquePathsWithObstacles([ ... [0, 0, 0, 1], ... [0, 1, 0, 0], ... [0, 0, 0, 0], ... [0, 1, 0, 0] ... ]) == 5","solution":"def uniquePathsWithObstacles(obstacleGrid): Calculate the number of unique paths from the top-left to the bottom-right corner of a grid, avoiding obstacles. :param obstacleGrid: List[List[int]] - a 2D grid representation where 0 denotes empty cells and 1 denotes obstacles :return: int - the number of unique paths from top-left to bottom-right modulo 10^9 + 7 MOD = 10**9 + 7 if not obstacleGrid or obstacleGrid[0][0] == 1 or obstacleGrid[-1][-1] == 1: return 0 n, m = len(obstacleGrid), len(obstacleGrid[0]) dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] % MOD if j > 0: dp[i][j] += dp[i][j-1] % MOD dp[i][j] %= MOD return dp[-1][-1]"},{"question":"def min_operations_to_equalize(n, a): Returns the minimum number of operations to make all elements in the array 'a' of length 'n' equal >>> min_operations_to_equalize(3, [3, 1, 2]) 2 >>> min_operations_to_equalize(4, [1, 2, 1, 2]) 1 >>> min_operations_to_equalize(2, [4, 7]) 3 def solve(test_cases): Solves the overall problem for multiple test cases. >>> solve([(3, [3, 1, 2]), (4, [1, 2, 1, 2]), (2, [4, 7])]) [2, 1, 3] >>> solve([(5, [1, 10, 10, 10, 1]), (6, [6, 6, 6, 6, 6, 6])]) [9, 0]","solution":"def min_operations_to_equalize(n, a): Returns the minimum number of operations to make all elements in the array 'a' of length 'n' equal # Find the maximum and minimum elements in the array max_elem = max(a) min_elem = min(a) # Number of operations to make all elements equal will be max_elem - min_elem return max_elem - min_elem def solve(test_cases): Solves the overall problem for multiple test cases. results = [] for case in test_cases: n, a = case results.append(min_operations_to_equalize(n, a)) return results"},{"question":"from typing import List def separate_and_sort(numbers: List[int]) -> List[int]: Separates even and odd numbers from the input list, sorts each group in ascending order, and combines them with all even numbers first followed by all odd numbers. >>> separate_and_sort([4, 1, 7, 5, 8, 2, 3, 6]) [2, 4, 6, 8, 1, 3, 5, 7] >>> separate_and_sort([10, -3, -15, 0, 12, 7, -8]) [-8, 0, 10, 12, -15, -3, 7]","solution":"from typing import List def separate_and_sort(numbers: List[int]) -> List[int]: Separates even and odd numbers from the input list, sorts each group in ascending order, and combines them with all even numbers first followed by all odd numbers. evens = [num for num in numbers if num % 2 == 0] odds = [num for num in numbers if num % 2 != 0] evens_sorted = sorted(evens) odds_sorted = sorted(odds) return evens_sorted + odds_sorted"},{"question":"from typing import List, Tuple def min_moves_to_palindrome(S: str) -> int: Returns the minimum number of moves to make a string S a palindrome. >>> min_moves_to_palindrome('abc') 1 >>> min_moves_to_palindrome('abba') 0 >>> min_moves_to_palindrome('abcba') 0 >>> min_moves_to_palindrome('abcdef') 3 >>> min_moves_to_palindrome('a') 0 >>> min_moves_to_palindrome('ab') 1 pass def process_test_cases(T: int, test_cases: List[Tuple[int, str]]) -> List[int]: Processes multiple test cases for the palindrome game. >>> process_test_cases(3, [(3, 'abc'), (4, 'abba'), (5, 'abcba')]) [1, 0, 0] >>> process_test_cases(2, [(6, 'abccba'), (6, 'abcdef')]) [0, 3] >>> process_test_cases(1, [(2, 'ab')]) [1] pass","solution":"def min_moves_to_palindrome(S): Returns the minimum number of moves to make a string S a palindrome. left, right = 0, len(S) - 1 moves = 0 while left < right: if S[left] != S[right]: moves += 1 left += 1 right -= 1 return moves def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] S = test_cases[i][1] results.append(min_moves_to_palindrome(S)) return results"},{"question":"import re def is_valid_filename(filename: str) -> str: Checks if the provided filename is valid according to the rules. The filename must start with one or more lowercase letters, followed by a series of digits, and end with a \`.txt\` extension. Parameters: filename (str): The filename to check. Returns: str: 'Valid' if the filename is valid, 'Invalid' otherwise. >>> is_valid_filename(\\"notes123.txt\\") 'Valid' >>> is_valid_filename(\\"FileName123.txt\\") 'Invalid' >>> is_valid_filename(\\"file@123.txt\\") 'Invalid' >>> is_valid_filename(\\"a.txt\\") 'Valid' >>> is_valid_filename(\\"notes123.\\") 'Invalid'","solution":"import re def is_valid_filename(filename): Checks if the provided filename is valid according to the rules. The filename must start with one or more lowercase letters, followed by a series of digits, and end with a \`.txt\` extension. Parameters: filename (str): The filename to check. Returns: str: 'Valid' if the filename is valid, 'Invalid' otherwise. pattern = re.compile(r'^[a-z]+[0-9]*.txt') if pattern.match(filename): return 'Valid' else: return 'Invalid'"},{"question":"class ShoppingCart: A class to represent an online shopping cart system. The cart holds a list of items, and each item has a name, price, and quantity. It allows adding items to the cart, updating the quantity of an item, removing an item, and calculating the total cost of the items in the cart. Example usage: >>> cart = ShoppingCart() >>> cart.addItem(\\"apple\\", 1.0, 2) >>> cart.addItem(\\"banana\\", 0.5, 5) >>> cart.updateItemQuantity(\\"apple\\", 5) >>> cart.addItem(\\"apple\\", 1.0, 3) >>> cart.removeItem(\\"banana\\") >>> cart.getTotalCost() 8.0 def __init__(self): pass def addItem(self, name, price, quantity): pass def updateItemQuantity(self, name, quantity): pass def removeItem(self, name): pass def getTotalCost(self): pass","solution":"class ShoppingCart: def __init__(self): self.cart = {} def addItem(self, name, price, quantity): if name in self.cart: self.cart[name]['quantity'] += quantity else: self.cart[name] = {'price': price, 'quantity': quantity} def updateItemQuantity(self, name, quantity): if name in self.cart: self.cart[name]['quantity'] = quantity def removeItem(self, name): if name in self.cart: del self.cart[name] def getTotalCost(self): total_cost = 0.0 for item in self.cart.values(): total_cost += item['price'] * item['quantity'] return total_cost"},{"question":"from typing import List, Tuple def analyze_packets(packet_data: str) -> Tuple[int, int, int, int]: Analyzes the network packets and calculates total number of packets, number of unique source addresses, total size of all packets, and average packet size. Args: packet_data (str): A string of packet information separated by semicolons. Each packet information includes source address, destination address and size separated by commas. Returns: tuple: Total number of packets, number of unique source addresses, total size of all packets, average packet size (rounded down to the nearest integer). >>> analyze_packets(\\"192.168.1.1,192.168.1.2,100;192.168.1.2,192.168.1.3,200;192.168.1.1,192.168.1.3,50\\") (3, 2, 350, 116) >>> analyze_packets(\\"192.168.1.1,192.168.1.2,100\\") (1, 1, 100, 100) >>> analyze_packets(\\"192.168.1.1,192.168.1.2,500;192.168.1.2,192.168.1.3,1500;192.168.1.1,192.168.1.3,2000\\") (3, 2, 4000, 1333)","solution":"def analyze_packets(packet_data): Analyzes the network packets and calculates total number of packets, number of unique source addresses, total size of all packets and average packet size. Args: packet_data (str): A string of packet information separated by semicolons. Each packet information includes source address, destination address and size separated by commas. Returns: tuple: Total number of packets, number of unique source addresses, total size of all packets, average packet size (rounded down to the nearest integer). if not packet_data: return (0, 0, 0, 0) packets = packet_data.split(';') total_packets = len(packets) source_addresses = set() total_size = 0 for packet in packets: source, destination, size = packet.split(',') source_addresses.add(source) total_size += int(size) avg_packet_size = total_size // total_packets return total_packets, len(source_addresses), total_size, avg_packet_size"},{"question":"def find_pair(arr, target): Determines whether there is a pair of distinct elements in the array that sums up to the target value. :param arr: List of integers :param target: An integer target value :return: 1 if there is a pair that sums up to the target value, otherwise 0 >>> find_pair([2, 7, 11, 15], 9) 1 >>> find_pair([1, 2, 3, 4], 8) 0 >>> find_pair([1, -2, 3, 5], 1) 1 >>> find_pair([1, 2, 3, 4, 5], 10) 0 >>> find_pair([0, -1, 1, 2], 0) 1 >>> find_pair([1000000, -999999, 1, -1], 999999) 1 >>> find_pair([0, 0, 0, 0], 0) 1 >>> find_pair([1], 2) 0","solution":"def find_pair(arr, target): Determines whether there is a pair of distinct elements in the array that sums up to the target value. Returns 1 if such a pair exists, otherwise returns 0. :param arr: List of integers :param target: An integer target value :return: 1 if there is a pair that sums up to the target value, otherwise 0 seen = set() for num in arr: complement = target - num if complement in seen: return 1 seen.add(num) return 0"},{"question":"def caesar_cipher(text: str, shift: int) -> str: Encrypt the input text using Caesar Cipher with the given shift. pass # Test the function with some example inputs print(caesar_cipher(\\"HelloWorld\\", 3)) # Expected output: \\"KhoorZruog\\" print(caesar_cipher(\\"AttackAtDawn\\", -5)) # Expected output: \\"VooopyoVoZvp\\"","solution":"def caesar_cipher(text: str, shift: int) -> str: def shift_char(c, shift): if c.islower(): return chr((ord(c) - ord('a') + shift) % 26 + ord('a')) elif c.isupper(): return chr((ord(c) - ord('A') + shift) % 26 + ord('A')) else: return c return ''.join(shift_char(c, shift) for c in text)"},{"question":"def max_non_overlapping_events(test_cases: list) -> list: Determine the maximum number of non-overlapping events that can be attended from a given list of events. Args: test_cases (list): a list of tuples, where each tuple represents a test case containing an integer n and a list of n tuples (start_time, end_time). Returns: list: a list of integers, where each integer represents the maximum number of non-overlapping events for each test case. >>> input_str = \\"2n3n10 20n15 25n20 30n3n2 3n3 4n1 2\\" >>> test_cases = parse_input(input_str) >>> max_non_overlapping_events(test_cases) [2, 3] >>> input_str = \\"1n1n0 1\\" >>> test_cases = parse_input(input_str) >>> max_non_overlapping_events(test_cases) [1] >>> input_str = \\"1n3n5 10n11 15n16 20\\" >>> test_cases = parse_input(input_str) >>> max_non_overlapping_events(test_cases) [3] >>> input_str = \\"1n3n1 5n2 6n3 7\\" >>> test_cases = parse_input(input_str) >>> max_non_overlapping_events(test_cases) [1] >>> input_str = \\"1n4n1 3n2 4n3 5n4 6\\" >>> test_cases = parse_input(input_str) >>> max_non_overlapping_events(test_cases) [2] def parse_input(input_str: str) -> list: Parses the input string into a format suitable for the function max_non_overlapping_events. Args: input_str (str): Input string in the format as described in the problem. Returns: list: a list of tuples, where each tuple represents a test case containing an integer n and a list of n tuples (start_time, end_time). >>> parse_input(\\"2n3n10 20n15 25n20 30n3n2 3n3 4n1 2\\") [(3, [(10, 20), (15, 25), (20, 30)]), (3, [(2, 3), (3, 4), (1, 2)])]","solution":"def max_non_overlapping_events(test_cases: list) -> list: results = [] for n, events in test_cases: # Sort events based on their end time events.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in events: if start >= last_end_time: count += 1 last_end_time = end results.append(count) return results # input parsing function for convenience def parse_input(input_str: str) -> list: lines = input_str.strip().split(\\"n\\") t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n = int(lines[index]) events = [] for i in range(n): start_time, end_time = map(int, lines[index + 1 + i].split()) events.append((start_time, end_time)) test_cases.append((n, events)) index += n + 1 return test_cases # Example usage: input_str = \\"2n3n10 20n15 25n20 30n3n2 3n3 4n1 2\\" test_cases = parse_input(input_str) print(max_non_overlapping_events(test_cases)) # Output should be [2, 3]"},{"question":"def minimum_guards(N: int) -> int: Determine the minimum number of guards required to ensure that every castle is guarded in a complete graph of N castles. >>> minimum_guards(5) 1 >>> minimum_guards(3) 1 from solution import minimum_guards def test_minimum_guards(): assert minimum_guards(1) == 1 assert minimum_guards(2) == 1 assert minimum_guards(3) == 1 assert minimum_guards(10) == 1 assert minimum_guards(100) == 1","solution":"def minimum_guards(N): Returns the minimum number of guards needed to guard all castles in a complete graph of N castles. return 1"},{"question":"def minimum_widget_sequence(n: int, k: int) -> int: Given n widgets with serial numbers from 1 to n and boxes that can hold a maximum of k widgets, return the minimum number of serial numbers that the box should hold to meet the conditions. Examples: >>> minimum_widget_sequence(10, 3) 3 >>> minimum_widget_sequence(15, 4) 4 >>> minimum_widget_sequence(5, 5) 5 >>> minimum_widget_sequence(20, 6) 6 >>> minimum_widget_sequence(1, 1) 1 >>> minimum_widget_sequence(1000000000, 1) 1 >>> minimum_widget_sequence(1000000000, 1000000000) 1000000000","solution":"def minimum_widget_sequence(n, k): Given n widgets with serial numbers from 1 to n and boxes that can hold a maximum of k widgets, return the minimum number of serial numbers that the box should hold to meet the conditions. return min(k, n)"},{"question":"def construct_html_document(head: str, body_start: str, body_content: str) -> str: Constructs a valid HTML document from the given head section, body tag with attributes, and body content. >>> construct_html_document(\\"<head><title>Test</title></head>\\", \\"<body class=\\"container\\">\\", \\"<h1>Hello, World!</h1>\\") '<!DOCTYPE html>n<html>n<head><title>Test</title></head>n<body class=\\"container\\"><h1>Hello, World!</h1></body>n</html>' >>> construct_html_document(\\"<head></head>\\", \\"<body>\\", \\"<div>Sample content</div>\\") '<!DOCTYPE html>n<html>n<head></head>n<body><div>Sample content</div></body>n</html>' >>> construct_html_document(\\"<head><title>Empty Content</title></head>\\", \\"<body>\\", \\"\\") '<!DOCTYPE html>n<html>n<head><title>Empty Content</title></head>n<body></body>n</html>' >>> construct_html_document(\\"<head></head>\\", \\"<body>\\", \\"\\") '<!DOCTYPE html>n<html>n<head></head>n<body></body>n</html>'","solution":"def construct_html_document(head, body_start, body_content): Constructs a valid HTML document from the given head section, body tag with attributes, and body content. doc_type = \\"<!DOCTYPE html>\\" html_start = \\"<html>\\" html_end = \\"</html>\\" # Combine the components to form the HTML document html_doc = ( f\\"{doc_type}n\\" f\\"{html_start}n\\" f\\"{head}n\\" f\\"{body_start}{body_content}</body>n\\" f\\"{html_end}\\" ) return html_doc"},{"question":"def count_regions(grid): Counts the number of distinct regions of empty cells in the provided grid. :param grid: List[List[str]] - A 2D grid where '.' represents an empty cell and '#' represents a cell with a rock. :return: int - The number of distinct regions of empty cells in the grid. >>> count_regions([ ... ['.', '.', '#', '.', '.', '.'], ... ['.', '#', '.', '.', '.', '.'], ... ['.', '.', '#', '#', '.', '.'], ... ['.', '#', '#', '#', '#', '.'], ... ['.', '.', '#', '.', '#', '.'] ... ]) == 3 >>> count_regions([ ... ['#', '#', '#', '#'], ... ['#', '.', '.', '#'], ... ['#', '#', '#', '#'] ... ]) == 1 >>> count_regions([ ... ['#', '#'], ... ['#', '#'] ... ]) == 0 >>> count_regions([ ... ['.', '.', '.'], ... ['.', '.', '.'], ... ['.', '.', '.'] ... ]) == 1 >>> count_regions([ ... ['.', '.', '#', '.', '.', '#', '.', '.'] ... ]) == 3 >>> count_regions([ ... ['.'], ... ['#'], ... ['.'], ... ['.'], ... ['#'], ... ['.'] ... ]) == 3 >>> count_regions([ ... ['#', '#', '#'], ... ['.', '.', '.'], ... ['#', '#', '#'], ... ['.', '.', '.'] ... ]) == 2 pass","solution":"def count_regions(grid): Counts the number of distinct regions of empty cells in the provided grid. def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != '.': return grid[x][y] = '#' # Mark the cell as visited # Explore neighbors dfs(x+1, y) # down dfs(x-1, y) # up dfs(x, y+1) # right dfs(x, y-1) # left m, n = len(grid), len(grid[0]) regions_count = 0 for i in range(m): for j in range(n): if grid[i][j] == '.': dfs(i, j) regions_count += 1 return regions_count"},{"question":"def pyramid(n: int) -> str: Outputs a pyramid of numbers with n rows. >>> pyramid(1) '1' >>> pyramid(2) '1n2 3' >>> pyramid(3) '1n2 3n4 5 6'","solution":"def pyramid(n): Outputs a pyramid of numbers with n rows. current_number = 1 result = [] for i in range(1, n+1): row = [] for j in range(i): row.append(current_number) current_number += 1 result.append(\\" \\".join(map(str, row))) return \\"n\\".join(result)"},{"question":"def calculate_final_price(n: int, price_discount_pairs: List[Tuple[int, int]]) -> List[int]: Calculate the final price after applying the discount, rounded to the nearest dollar. The final price should not be less than 1. Args: n (int): The number of customers. price_discount_pairs (List[Tuple[int, int]]): A list of tuples where each tuple contains the original price and discount percentage. Returns: List[int]: The final price for each customer after applying the discount. >>> calculate_final_price(3, [(100, 20), (50, 50), (10, 90)]) [80, 25, 1] >>> calculate_final_price(2, [(100, 100), (200, 0)]) [1, 200] pass","solution":"def calculate_final_price(n, price_discount_pairs): results = [] for p, d in price_discount_pairs: discounted_price = round(p * (1 - d / 100)) final_price = max(discounted_price, 1) results.append(final_price) return results"},{"question":"def zigzag_conversion(arr): Rearranges the elements of the array in zigzag order such that: arr[1] < arr[2] > arr[3] < arr[4] > arr[5] < arr[6] ... Args: arr: List[int] - The list of integers to be rearranged. Returns: List[int] - The rearranged list in zigzag order. Example: >>> zigzag_conversion([4, 3, 7, 8, 6, 2, 1]) [3, 7, 4, 8, 2, 6, 1] >>> zigzag_conversion([1, 4, 3, 2]) [1, 4, 2, 3]","solution":"def zigzag_conversion(arr): Rearranges the elements of the array in zigzag order such that: arr[1] < arr[2] > arr[3] < arr[4] > arr[5] < arr[6] ... Args: arr: List[int] - The list of integers to be rearranged. Returns: List[int] - The rearranged list in zigzag order. flag = True # true for '<' and false for '>' n = len(arr) for i in range(n-1): if flag: if arr[i] > arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] else: if arr[i] < arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] flag = not flag return arr"},{"question":"def longest_increasing_subsequence(n: int, seq: List[int]) -> Tuple[int, List[int]]: Find the longest strictly increasing subsequence from a sequence of shop IDs. >>> longest_increasing_subsequence(8, [5, 2, 8, 6, 3, 6, 9, 7]) (4, [2, 3, 6, 9]) >>> longest_increasing_subsequence(5, [1, 2, 3, 4, 5]) (5, [1, 2, 3, 4, 5]) from solution import longest_increasing_subsequence def test_longest_increasing_subsequence_case_1(): n = 8 seq = [5, 2, 8, 6, 3, 6, 9, 7] length, subsequence = longest_increasing_subsequence(n, seq) assert length == 4 assert subsequence == [2, 3, 6, 9] def test_longest_increasing_subsequence_case_2(): n = 5 seq = [1, 2, 3, 4, 5] length, subsequence = longest_increasing_subsequence(n, seq) assert length == 5 assert subsequence == [1, 2, 3, 4, 5] def test_longest_increasing_subsequence_single_element(): n = 1 seq = [10] length, subsequence = longest_increasing_subsequence(n, seq) assert length == 1 assert subsequence == [10] def test_longest_increasing_subsequence_no_increasing(): n = 5 seq = [5, 4, 3, 2, 1] length, subsequence = longest_increasing_subsequence(n, seq) assert length == 1 assert subsequence == [5] def test_longest_increasing_subsequence_mixed(): n = 6 seq = [1, 2, 1, 3, 2, 4] length, subsequence = longest_increasing_subsequence(n, seq) assert length == 4 assert subsequence == [1, 2, 3, 4]","solution":"def longest_increasing_subsequence(n, seq): if n == 0: return 0, [] # Initialize the dp array where dp[i] is the length of the longest increasing subsequence ending at index i dp = [1] * n # Initialize parent array to reconstruct the sequence parent = [-1] * n # Compute the dp values for i in range(1, n): for j in range(i): if seq[i] > seq[j] and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 parent[i] = j # Find the maximum value in dp and its index max_length = max(dp) max_index = dp.index(max_length) # Reconstruct the sequence using the parent array lis = [] current_index = max_index while current_index != -1: lis.append(seq[current_index]) current_index = parent[current_index] lis.reverse() return max_length, lis"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. Some examples: >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 char_map = {} max_len = 0 start = 0 for end in range(n): if s[end] in char_map and char_map[s[end]] >= start: start = char_map[s[end]] + 1 char_map[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Returns the maximum sum of any contiguous subarray within the given array. pass def process_cases(cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases and returns the result for each case. pass # Example usage: # cases = [ # (3, [-2, 1, -3]), # (5, [1, 2, -1, 2, 3]) # ] # print(process_cases(cases)) # [1, 7] # Unit Tests: def test_max_subarray_sum(): assert max_subarray_sum([-2, 1, -3]) == 1 assert max_subarray_sum([1, 2, -1, 2, 3]) == 7 assert max_subarray_sum([1, 2, 3, 4]) == 10 assert max_subarray_sum([-1, -2, -3, -4]) == -1 assert max_subarray_sum([3, -2, 5, -1, 6]) == 11 def test_process_cases(): cases = [ (3, [-2, 1, -3]), (5, [1, 2, -1, 2, 3]) ] results = process_cases(cases) assert results == [1, 7] cases = [ (4, [1, 2, 3, 4]), (4, [-1, -2, -3, -4]), (5, [3, -2, 5, -1, 6]) ] results = process_cases(cases) assert results == [10, -1, 11] def test_edge_cases(): assert max_subarray_sum([100]) == 100 assert max_subarray_sum([100] * 100000) == 10000000 assert max_subarray_sum([-100] * 100000) == -100","solution":"def max_subarray_sum(arr): Returns the maximum sum of any contiguous subarray within the given array. max_so_far = arr[0] max_ending_here = arr[0] for i in range(1, len(arr)): max_ending_here = max(arr[i], max_ending_here + arr[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far def process_cases(cases): Processes multiple test cases and returns the result for each case. results = [] for case in cases: N, array = case results.append(max_subarray_sum(array)) return results"},{"question":"from typing import List, Tuple def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Annie has an array consisting of n non-negative integers. She has to perform q queries of the following types: 1. \`1 i y\`: Update the i-th element to value y, i.e., perform an operation \`a[i] = y\`. 2. \`2 l r\`: Compute and report the number of distinct integers in the subarray from index l to r (inclusive). Args: n (int): The size of the array. q (int): The number of queries. array (List[int]): The initial array of integers. queries (List[Tuple[int, int, int]]): The list of queries in the format (query_type, x, y). Returns: List[int]: The results of the queries that require output (query type 2). Example: >>> process_queries(5, 5, [2, 3, 2, 4, 3], [(2, 1, 5), (1, 3, 5), (2, 1, 5), (2, 2, 4), (1, 2, 3)]) [3, 4, 3]","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [set() for _ in range(2 * self.n)] # Fill leaves for i in range(self.n): self.tree[self.n + i].add(data[i]) # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] | self.tree[2 * i + 1] def update(self, pos, value): pos += self.n self.tree[pos] = {value} while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] | self.tree[2 * pos + 1] def query(self, l, r): res = set() l += self.n r += self.n + 1 while l < r: if l % 2 == 1: res |= self.tree[l] l += 1 if r % 2 == 1: r -= 1 res |= self.tree[r] l //= 2 r //= 2 return len(res) # Parse input def process_queries(n, q, array, queries): seg_tree = SegmentTree(array) result = [] for query in queries: t, x, y = query if t == 1: seg_tree.update(x - 1, y) elif t == 2: num_distinct = seg_tree.query(x - 1, y - 1) result.append(num_distinct) return result"},{"question":"def exist(board, word): Check if a given word exists in the matrix. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. >>> exist([['a', 'b', 'c', 'e'], ['s', 'f', 'c', 's'], ['a', 'd', 'e', 'e']], \\"see\\") \\"YES\\" >>> exist([['a', 'b', 'c', 'd'], ['e', 'f', 'g', 'h'], ['i', 'j', 'k', 'l']], \\"abcdef\\") \\"NO\\"","solution":"def exist(board, word): if not board: return False n, m = len(board), len(board[0]) def dfs(i, j, k): if k == len(word): return True if i < 0 or i >= n or j < 0 or j >= m or board[i][j] != word[k]: return False temp = board[i][j] board[i][j] = '' found = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1) board[i][j] = temp return found for i in range(n): for j in range(m): if dfs(i, j, 0): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def process_queries(N: int, A: List[int], Q: int, queries: List[Tuple[int, int, int]]) -> List[int]: Given an array of integers A of length N, answer Q queries of two types: - Type 1: Increase the value of the i_q-th element of A by v_q. - Type 2: Answer the maximum value occurring in the subarray of A between the l_q-th and r_q-th indices (inclusive). Args: N (int): Length of the array A. A (List[int]): An array of integers. Q (int): Number of queries. queries (List[Tuple[int, int, int]]): List of queries. Each query is represented as a tuple. Returns: List[int]: A list of results for each query of type 2. >>> process_queries(5, [1, 2, 3, 4, 5], 4, [(2, 2, 5), (1, 3, 2), (2, 1, 4), (2, 3, 3)]) [5, 5, 5] >>> process_queries(3, [3, 1, 4], 3, [(2, 1, 3), (1, 2, 3), (2, 2, 3)]) [4, 4] >>> process_queries(1, [2], 1, [(2, 1, 1)]) [2] >>> process_queries(4, [1, 2, 3, 4], 3, [(1, 1, 5), (1, 4, 1), (2, 1, 4)]) [6]","solution":"def process_queries(N, A, Q, queries): results = [] for query in queries: if query[0] == 1: _, i_q, v_q = query A[i_q - 1] += v_q elif query[0] == 2: _, l_q, r_q = query results.append(max(A[l_q - 1:r_q])) return results"},{"question":"def uniquePathsWithObstacles(grid): Calculate the number of distinct paths for a robot to move from the top-left corner to the bottom-right corner of an m x n grid with obstacles. Args: grid: List[List[int]], a list of lists where 0 represents a free cell and 1 represents a blocked cell. Returns: int: Number of distinct paths from top-left to bottom-right corner. >>> uniquePathsWithObstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> uniquePathsWithObstacles([ ... [0, 1], ... [0, 0] ... ]) 1 >>> uniquePathsWithObstacles([ ... [0, 0, 0], ... [1, 1, 1], ... [0, 0, 0] ... ]) 0","solution":"def uniquePathsWithObstacles(grid): m = len(grid) if m == 0: return 0 n = len(grid[0]) if n == 0: return 0 # If the start or end cell is blocked, return 0 if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Initialize a DP array with the same dimensions as the grid dp = [[0] * n for _ in range(m)] # Initialize the start cell dp[0][0] = 1 # Fill the first row for j in range(1, n): if grid[0][j] == 0: dp[0][j] = dp[0][j-1] # Fill the first column for i in range(1, m): if grid[i][0] == 0: dp[i][0] = dp[i-1][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def water_stations(d: int, n: int) -> List[int]: Given the total distance of the race d and the number of desired water stations n, this function calculates and returns the positions of the water stations as a list. >>> water_stations(10, 4) [2, 4, 6, 8] >>> water_stations(15, 3) [5, 10, 15] >>> water_stations(5, 10) [1, 2, 3, 4, 5]","solution":"def water_stations(d, n): Given the total distance of the race d and the number of desired water stations n, this function calculates and returns the positions of the water stations as a list. if n >= d: return list(range(1, min(d, n) + 1)) interval = d // n positions = [interval * i for i in range(1, n + 1)] return positions"},{"question":"def find_unique_pairs(test_cases): Find unique pairs from the list of integers for each test case that add up to the target value. Handles invalid input constraints, prints \\"Invalid Test\\" or \\"Invalid Input\\" as appropriate. Args: test_cases (list): A list of dictionaries containing test case data, with format: { \\"N\\": (int) number of elements, \\"numbers\\": (list) list of integers, \\"target\\": (int) target value. } Returns: list: A list containing lists of unique pairs for each test case.","solution":"def find_unique_pairs(test_cases): Find unique pairs from the list of integers for each test case that add up to the target value. Handles invalid input constraints, prints \\"Invalid Test\\" or \\"Invalid Input\\" as appropriate. Args: test_cases (list): A list of dictionaries containing test case data, with format: { \\"N\\": (int) number of elements, \\"numbers\\": (list) list of integers, \\"target\\": (int) target value. } Returns: list: A list containing lists of unique pairs for each test case. results = [] T = len(test_cases) if T < 1 or T > 10: return \\"Invalid Test\\" for case in test_cases: N = case[\\"N\\"] if N < 1 or N > 100: return \\"Invalid Input\\" numbers = case[\\"numbers\\"] target = case[\\"target\\"] pairs = [] seen = {} for i in range(N): for j in range(i + 1, N): if numbers[i] + numbers[j] == target: if (i, j) not in seen and (j, i) not in seen: pairs.append((i, j)) seen[(i, j)] = True results.append(pairs) return results # Example usage: # test_cases = [ # {\\"N\\": 4, \\"numbers\\": [1, 2, 3, 4], \\"target\\": 5}, # {\\"N\\": 3, \\"numbers\\": [1, 2, 3], \\"target\\": 7} # ] # print(find_unique_pairs(test_cases))"},{"question":"def countInversions(arr): Count the number of inversions in an array using a modified merge sort algorithm. An inversion is a pair (arr[i], arr[j]) such that i < j and arr[i] > arr[j]. Args: arr: List[int] - an array of integers to count inversions Returns: int - the number of inversions >>> countInversions([2, 4, 1, 3, 5]) 3 from solution import countInversions def test_countInversions_sample(): arr = [2, 4, 1, 3, 5] assert countInversions(arr) == 3 def test_countInversions_sorted(): arr = [1, 2, 3, 4, 5] assert countInversions(arr) == 0 def test_countInversions_reverse(): arr = [5, 4, 3, 2, 1] assert countInversions(arr) == 10 def test_countInversions_mixed(): arr = [1, 3, 2, 3, 1] assert countInversions(arr) == 4 def test_countInversions_duplicates(): arr = [2, 2, 2, 2, 2] assert countInversions(arr) == 0","solution":"def countInversions(arr): n = len(arr) temp_arr = [0]*n return _mergeSort(arr, temp_arr, 0, n-1) def _mergeSort(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += _mergeSort(arr, temp_arr, left, mid) inv_count += _mergeSort(arr, temp_arr, mid + 1, right) inv_count += _merge(arr, temp_arr, left, mid, right) return inv_count def _merge(arr, temp_arr, left, mid, right): i = left j = mid + 1 k = left inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count"},{"question":"def analyze_response_times(n, response_times): Analyzes the response times and returns the average, maximum, and minimum response times. Parameters: n (int): Number of requests. response_times (list of int): List of response times in milliseconds. Returns: tuple: (average, maximum, minimum) where: average (float): The average response time, rounded to six decimal places. maximum (int): The maximum response time. minimum (int): The minimum response time. Examples: >>> analyze_response_times(5, [200, 300, 250, 400, 150]) (260.000000, 400, 150) >>> analyze_response_times(1, [500]) (500.000000, 500, 500)","solution":"def analyze_response_times(n, response_times): Analyzes the response times and returns the average, maximum, and minimum response times. Parameters: n (int): Number of requests. response_times (list of int): List of response times in milliseconds. Returns: tuple: (average, maximum, minimum) where: average (float): The average response time, rounded to six decimal places. maximum (int): The maximum response time. minimum (int): The minimum response time. total_time = sum(response_times) average_time = round(total_time / n, 6) max_time = max(response_times) min_time = min(response_times) return average_time, max_time, min_time"},{"question":"def valid_ip_with_subnet(ip: str) -> bool: Returns True if the input string is a valid IPv4 address with subnet mask, otherwise returns False. A valid IPv4 address with subnet mask is represented as \`x.x.x.x/y\` where \`x\` is a number between 0 and 255 and \`y\` is a number between 0 and 32. >>> valid_ip_with_subnet(\\"192.168.1.1/24\\") True >>> valid_ip_with_subnet(\\"256.256.256.256/33\\") False >>> valid_ip_with_subnet(\\"192.168.1.1/-1\\") False >>> valid_ip_with_subnet(\\"192.168.1.256/24\\") False >>> valid_ip_with_subnet(\\"192.168.1.1/\\") False","solution":"def valid_ip_with_subnet(ip): Returns True if the input string is a valid IPv4 address with subnet mask, otherwise returns False. try: parts = ip.split('/') if len(parts) != 2: return False ip_part, subnet_part = parts[0], parts[1] # Check if subnet part is valid subnet = int(subnet_part) if subnet < 0 or subnet > 32: return False # Check if IP part is valid ip_parts = ip_part.split('.') if len(ip_parts) != 4: return False for part in ip_parts: num = int(part) if num < 0 or num > 255: return False return True except (ValueError, TypeError): return False"},{"question":"def canDivideIntoThreePartsOfEqualSum(arr) -> bool: Given an array of integers, determine whether the array can be divided into three contiguous subarrays with equal sum. :param arr: List of integers :return: True if the array can be divided into three contiguous subarrays with equal sum, otherwise False Example: >>> canDivideIntoThreePartsOfEqualSum([1, 2, 3, 0, 3]) True >>> canDivideIntoThreePartsOfEqualSum([1, 2, 3, 4, 5, 6]) False","solution":"def canDivideIntoThreePartsOfEqualSum(arr): This function checks whether the array can be divided into three contiguous subarrays with equal sum. total_sum = sum(arr) if total_sum % 3 != 0: return False target_sum = total_sum // 3 n = len(arr) current_sum, count = 0, 0 for i in range(n): current_sum += arr[i] if current_sum == target_sum: count += 1 current_sum = 0 if count == 3: return True return False"},{"question":"def min_cut_palindrome_partition(s: str) -> int: Given a string \`s\`, partition the string such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of \`s\`. Example ------- >>> min_cut_palindrome_partition(\\"abccbc\\") 2 >>> min_cut_palindrome_partition(\\"a\\") 0 >>> min_cut_palindrome_partition(\\"aa\\") 0 >>> min_cut_palindrome_partition(\\"ab\\") 1 >>> min_cut_palindrome_partition(\\"racecar\\") 0 >>> min_cut_palindrome_partition(\\"aabba\\") 1 >>> min_cut_palindrome_partition(\\"\\") 0","solution":"def min_cut_palindrome_partition(s): Returns the minimum cuts needed for a palindrome partitioning of s. n = len(s) if n == 0: return 0 # Create a DP array to store the minimum cuts for each prefix of the string cuts = [0] * n pal = [[False] * n for _ in range(n)] # A table to check if a substring is palindrome for i in range(n): min_cut = i # Max cuts is \\"i\\", i.e., each character is a palindrome for j in range(i + 1): if s[j] == s[i] and (i - j <= 1 or pal[j + 1][i - 1]): pal[j][i] = True # If j is 0, then whole substring [0:i+1] is one palindrome, no cuts needed min_cut = 0 if j == 0 else min(min_cut, cuts[j - 1] + 1) cuts[i] = min_cut return cuts[-1]"},{"question":"def top_performer(sales_records): Given a list of sales records, where each record is a tuple (employee name, sales count), returns the employee name with the highest sales count. In case of a tie, returns the first employee with the highest count. >>> top_performer([(\\"Alice\\", 50), (\\"Bob\\", 75), (\\"Charlie\\", 75), (\\"Diana\\", 60)]) == \\"Bob\\" >>> top_performer([(\\"John\\", 120), (\\"Jane\\", 115), (\\"Doe\\", 130)]) == \\"Doe\\" >>> top_performer([(\\"Anna\\", 40), (\\"Tom\\", 40)]) == \\"Anna\\" >>> top_performer([(\\"Alice\\", 50), (\\"Bob\\", 50), (\\"Charlie\\", 50), (\\"Diana\\", 50)]) == \\"Alice\\" >>> top_performer([]) == None","solution":"def top_performer(sales_records): Given a list of sales records, where each record is a tuple (employee name, sales count), returns the employee name with the highest sales count. In case of a tie, returns the first employee with the highest count. if not sales_records: return None top_employee = sales_records[0][0] top_sales = sales_records[0][1] for name, sales in sales_records: if sales > top_sales: top_sales = sales top_employee = name elif sales == top_sales: # Keeping record of first appearing top sales person continue return top_employee"},{"question":"def max_walkable_distance(trails: List[str]) -> List[int]: Calculates the maximum walkable distance for each trail. Args: trails (List[str]): A list of binary strings representing trails. Returns: List[int]: A list of integers where each integer represents the maximum walkable distance for the corresponding trail. Examples: >>> max_walkable_distance([\\"110111\\"]) [3] >>> max_walkable_distance([\\"110111\\", \\"101\\", \\"1111111111\\"]) [3, 1, 10]","solution":"def max_walkable_distance(trails): Returns the maximum walkable distance for each trail. max_distances = [] for trail in trails: max_distance = 0 current_distance = 0 for segment in trail: if segment == '1': current_distance += 1 if current_distance > max_distance: max_distance = current_distance else: current_distance = 0 max_distances.append(max_distance) return max_distances if __name__ == \\"__main__\\": T = int(input().strip()) trails = [input().strip() for _ in range(T)] results = max_walkable_distance(trails) for result in results: print(result)"},{"question":"def number_to_words(n: int) -> str: Converts a non-negative integer less than 1000 to its English words representation. >>> number_to_words(0) == \\"zero\\" >>> number_to_words(123) == \\"one hundred twenty three\\" >>> number_to_words(45) == \\"forty five\\" >>> number_to_words(800) == \\"eight hundred\\"","solution":"def number_to_words(n): Converts a non-negative integer less than 1000 to its English words representation. if not (0 <= n < 1000): raise ValueError(\\"Input must be a non-negative integer less than 1000.\\") units = [\\"\\", \\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\", \\"seven\\", \\"eight\\", \\"nine\\"] teens = [\\"\\", \\"eleven\\", \\"twelve\\", \\"thirteen\\", \\"fourteen\\", \\"fifteen\\", \\"sixteen\\", \\"seventeen\\", \\"eighteen\\", \\"nineteen\\"] tens = [\\"\\", \\"ten\\", \\"twenty\\", \\"thirty\\", \\"forty\\", \\"fifty\\", \\"sixty\\", \\"seventy\\", \\"eighty\\", \\"ninety\\"] if n == 0: return \\"zero\\" words = \\"\\" if n // 100 > 0: words += units[n // 100] + \\" hundred\\" n %= 100 if n > 0: words += \\" \\" if 10 < n < 20: words += teens[n % 10] else: if n // 10 > 0: words += tens[n // 10] n %= 10 if n > 0: words += \\" \\" if n > 0: words += units[n] return words.strip()"},{"question":"from typing import List def poly_derive(p: List[int]) -> List[int]: Derives a polynomial represented by a list of its coefficients. Parameters: p (List[int]): List of coefficients, where the index represents the exponent. Returns: List[int]: List of coefficients of the derived polynomial. Example: >>> poly_derive([3, 5, 2]) [5, 4] >>> poly_derive([1, 3, 0, 7]) [3, 0, 21]","solution":"from typing import List def poly_derive(p: List[int]) -> List[int]: Derives a polynomial represented by a list of its coefficients. Parameters: p (List[int]): List of coefficients, where the index represents the exponent. Returns: List[int]: List of coefficients of the derived polynomial. # The derivative of a constant (e.g., ax^0) is 0, if polynomial has degree 0, it results in empty list if len(p) < 2: return [] return [p[i] * i for i in range(1, len(p))]"},{"question":"def runningRecords(times): Given the times for a run, determine the number of times John improves his fastest and slowest times. Args: times (List[int]): times taken to run each kilometer Returns: List[int]: An array with the numbers of times he improved his records. Index 0 is for improving fastest kilometer records, and index 1 is for improving slowest kilometer records. Examples: >>> runningRecords([5, 3, 4, 3, 5, 2]) [2, 0] >>> runningRecords([10, 9, 8, 7, 6, 5, 4, 3]) [7, 0]","solution":"def runningRecords(times): if not times: return [0, 0] fastest = times[0] slowest = times[0] fast_count = 0 slow_count = 0 for time in times[1:]: if time < fastest: fastest = time fast_count += 1 elif time > slowest: slowest = time slow_count += 1 return [fast_count, slow_count]"},{"question":"def longest_palindrome(s: str) -> int: Marcus loves to play games that involve words. One day, he stumbled upon an interesting problem involving palindromes. A palindrome is a word that reads the same backward as forward. Marcus is tasked with creating the longest possible palindrome using letters from a given string. Marcus needs to write a function that takes a string \`s\` consisting of lowercase and uppercase English letters and returns the length of the longest palindrome that can be constructed using the letters in \`s\`. Note that the function should be case sensitive. A palindrome can use both uppercase and lowercase letters in its construction, but the positions must be such that the word remains identical from both ends. -----Input----- The input contains a single string \`s\`, where 1 <= len(s) <= 1000. The string \`s\` consists of lowercase and uppercase English letters only. -----Output----- Output the length of the longest palindrome that can be created using the given characters of \`s\`. Examples: >>> longest_palindrome(\\"abccccdd\\") 7 >>> longest_palindrome(\\"Aa\\") 1","solution":"def longest_palindrome(s): Function to find the length of the longest palindrome that can be constructed from the string \`s\`. from collections import Counter char_count = Counter(s) length = 0 odd_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"from typing import List, Tuple def can_reorder_to_xor_target(t: int, test_cases: List[Tuple[int, int, List[int], int]]) -> List[str]: Determine if it is possible to reorder prices so that the XOR of any k consecutive prices equals the target value for each test case. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[int], int]]): A list of tuples representing the test cases. Each tuple contains: - an integer n: the number of items - an integer k: the number of consecutive items whose XOR needs to match the target - a list of integers representing the prices of the items - an integer target: the value that the bitwise XOR of any k consecutive prices should equal Returns: List[str]: A list of strings \\"YES\\" or \\"NO\\" for each test case indicating if it is possible to reorder the prices to meet the condition. Tests: >>> can_reorder_to_xor_target(3, [(4, 2, [1, 3, 5, 7], 6), (5, 3, [2, 4, 6, 8, 10], 14), (3, 1, [1, 2, 3], 2)]) ['YES', 'NO', 'YES'] >>> can_reorder_to_xor_target(1, [(5, 2, [5, 5, 5, 5, 5], 0)]) ['YES'] >>> can_reorder_to_xor_target(1, [(5, 3, [10, 20, 30, 40, 50], 100)]) ['NO'] >>> can_reorder_to_xor_target(1, [(1, 1, [3], 3)]) ['YES'] >>> can_reorder_to_xor_target(1, [(5, 5, [1, 2, 3, 4, 5], 1)]) ['YES']","solution":"def can_reorder_to_xor_target(t, test_cases): results = [] for i in range(t): n, k, prices, target = test_cases[i] if k == 1: meets_target = any(price == target for price in prices) results.append(\\"YES\\" if meets_target else \\"NO\\") continue prefix_xor = [0] * (n + 1) for j in range(n): prefix_xor[j + 1] = prefix_xor[j] ^ prices[j] found = False seen = {} for j in range(n - k + 1): xor_segment = prefix_xor[j + k] ^ prefix_xor[j] if xor_segment == target: found = True break seen[prefix_xor[j]] = j if not found: for j in range(n): needed = target ^ prefix_xor[j + 1] if needed in seen and seen[needed] < j + 1 - k: found = True break results.append(\\"YES\\" if found else \\"NO\\") return results"},{"question":"def calculate_exciting_energy(n: int, strengths: List[int]) -> int: Calculate the total excitement energy generated by villagers. Args: n : int : The number of villagers. strengths : list of int : The high-five strength of each villager. Returns: int : The total excitement energy. >>> calculate_exciting_energy(4, [1, 2, 3, 4]) 20 >>> calculate_exciting_energy(2, [1, 2]) 2 >>> calculate_exciting_energy(5, [5, 5, 5, 5, 5]) 100 >>> calculate_exciting_energy(3, [10000, 10000, 10000]) 200000000 >>> calculate_exciting_energy(5, [1, 2, 3, 4, 5]) 40 >>> calculate_exciting_energy(5, [5, 4, 3, 2, 1]) 40","solution":"def calculate_exciting_energy(n, strengths): Calculate the total excitement energy generated by villagers. Args: n : int : The number of villagers. strengths : list of int : The high-five strength of each villager. Returns: int : The total excitement energy. total_energy = 0 for i in range(n-1): total_energy += strengths[i] * strengths[i+1] return total_energy"},{"question":"def count_rolling_balls(building_heights): This function counts how many balls can roll down from one building to an adjacent building. Parameters: building_heights (list): A list of integers representing the heights of adjacent buildings. Returns: int: The total number of balls that can roll down from one building to an adjacent building. >>> count_rolling_balls([10, 5, 8, 11, 6, 9]) 3 >>> count_rolling_balls([1, 2, 3, 4, 5]) 4 >>> count_rolling_balls([5, 4, 3, 2, 1]) 0 >>> count_rolling_balls([3, 3, 3, 3, 3]) 0 >>> count_rolling_balls([1, 3, 5, 2, 2, 2, 4, 7]) 4","solution":"def count_rolling_balls(building_heights): This function counts how many balls can roll down from one building to an adjacent building. Parameters: building_heights (list): A list of integers representing the heights of adjacent buildings. Returns: int: The total number of balls that can roll down from one building to an adjacent building. count = 0 for i in range(len(building_heights) - 1): if building_heights[i] < building_heights[i + 1]: count += 1 return count if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) heights = list(map(int, data[1:])) result = count_rolling_balls(heights) print(result)"},{"question":"from typing import List def minimal_travel_distance(n: int, distances: List[List[int]]) -> int: Returns the minimal distance Henry has to travel to visit all cities exactly once and return to the starting point. >>> minimal_travel_distance(4, [ ... [0, 20, 42, 35], ... [20, 0, 30, 34], ... [42, 30, 0, 12], ... [35, 34, 12, 0] ... ]) 97 >>> minimal_travel_distance(3, [ ... [0, 10, 15], ... [10, 0, 35], ... [15, 35, 0] ... ]) 60","solution":"from itertools import permutations def minimal_travel_distance(n, distances): Returns the minimal distance Henry has to travel to visit all cities exactly once and return to the starting point. city_indices = range(n) min_distance = float('inf') for perm in permutations(city_indices): current_distance = 0 for i in range(n): current_distance += distances[perm[i]][perm[(i + 1) % n]] min_distance = min(min_distance, current_distance) return min_distance"},{"question":"from typing import List, Tuple def dice_sums(n: int, faces: List[int]) -> Tuple[int, int]: Takes the number of dice and a list of their respective faces, and returns the minimum and maximum possible sums of rolled numbers. >>> dice_sums(3, [6, 8, 4]) (3, 18) >>> dice_sums(2, [12, 20]) (2, 32)","solution":"def dice_sums(n, faces): Takes the number of dice and a list of their respective faces, and returns the minimum and maximum possible sums of rolled numbers. min_sum = n # minimum is achieved by each die rolling a 1 max_sum = sum(faces) # maximum is achieved by each die rolling its maximum number return min_sum, max_sum"},{"question":"from collections import deque, defaultdict def find_shortest_distance_to_delivery_point(N: int, roads: List[Tuple[int, int]], Q: int, queries: List[Tuple[int, int]]) -> List[int]: Process a series of operations to find shortest distance to delivery points in a city modeled as an unweighted, undirected graph. Args: N (int): number of intersections roads (List[Tuple[int, int]]): list of roads between intersections Q (int): number of operations queries (List[Tuple[int, int]]): list of queries of types 0 and 1 Returns: List[int]: distances for each Type 0 query >>> find_shortest_distance_to_delivery_point(6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)], 7, [(0, 1), (1, 4), (0, 2), (1, 5), (0, 2), (0, 6), (0, 7)]) [-1, 2, 2, 1, -1] >>> find_shortest_distance_to_delivery_point(2, [], 2, [(0, 1), (1, 2)]) [-1] >>> find_shortest_distance_to_delivery_point(3, [(1, 2), (2, 3)], 1, [(0, 1)]) [-1] >>> find_shortest_distance_to_delivery_point(4, [(1, 2), (2, 3), (3, 4)], 5, [(1, 1), (1, 2), (1, 3), (1, 4), (0, 2)]) [0] >>> find_shortest_distance_to_delivery_point(4, [(1, 2), (2, 3)], 3, [(0, 4), (1, 3), (0, 4)]) [-1, -1]","solution":"from collections import deque, defaultdict def find_shortest_distance_to_delivery_point(N, roads, Q, queries): # Creating adjacency list graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) delivery_points = set() def bfs(start): # Perform BFS from start node to find the shortest path to any delivery point if start in delivery_points: return 0 queue = deque([(start, 0)]) visited = set([start]) while queue: node, dist = queue.popleft() for neighbor in graph[node]: if neighbor in delivery_points: return dist + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, dist + 1)) return -1 results = [] for query in queries: op, intersection = query if op == 0: # Find the shortest distance to the nearest delivery point results.append(bfs(intersection)) elif op == 1: # Mark this intersection as a delivery point delivery_points.add(intersection) return results"},{"question":"from typing import List def max_travel_distance(distances: List[int], generations: int) -> int: Calculates the maximum possible distance a seed can travel after the specified number of generations. Parameters: distances (List[int]): A list of positive integers, each representing the maximum distance a plant's seeds can travel in one generation. generations (int): A non-negative integer representing the number of generations. Returns: int: The maximum distance a seed can travel after the specified number of generations. Example: >>> max_travel_distance([1, 2, 3], 2) 6 >>> max_travel_distance([4, 1, 5], 1) 5 >>> max_travel_distance([5, 3, 9], 3) 27 >>> max_travel_distance([2], 10) 20","solution":"from typing import List def max_travel_distance(distances: List[int], generations: int) -> int: Calculates the maximum possible distance a seed can travel after the specified number of generations. Parameters: distances (List[int]): A list of positive integers, each representing the maximum distance a plant's seeds can travel in one generation. generations (int): A non-negative integer representing the number of generations. Returns: int: The maximum distance a seed can travel after the specified number of generations. if generations == 0: return 0 max_distance = max(distances) # Get the maximum distance from the list return max_distance * generations"},{"question":"def process_tree_queries(N, values, edges, queries): Handle tree queries including 'ADD', 'SET', and 'SUM' for a tree of N nodes with initial values. Parameters: N (int): Number of nodes in the tree. values (List[int]): Initial values of the N nodes. edges (List[Tuple[int, int]]): List of N-1 edges describing the tree structure. queries (List[str]): List of Q queries to process. Returns: List[int]: List containing the results of 'SUM' queries. Examples: >>> process_tree_queries(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (3, 4), (3, 5)], [\\"SUM 3\\", \\"ADD 3 2\\", \\"SUM 3\\"]) [12, 14] >>> process_tree_queries(3, [3, 1, 1], [(1, 2), (1, 3)], [\\"SUM 1\\", \\"SET 2 5\\", \\"SUM 1\\", \\"ADD 3 2\\", \\"SUM 1\\"]) [5, 9, 11] >>> process_tree_queries(4, [10, 5, 6, 3], [(1, 2), (2, 3), (2, 4)], [\\"SUM 2\\", \\"ADD 4 2\\", \\"SUM 2\\", \\"SET 3 7\\", \\"SUM 2\\"]) [14, 16, 17] >>> process_tree_queries(2, [7, 3], [(1, 2)], [\\"SUM 1\\", \\"ADD 2 1\\", \\"SUM 1\\", \\"SET 1 10\\", \\"SUM 1\\"]) [10, 11, 14]","solution":"from collections import defaultdict class Tree: def __init__(self, N, values): self.N = N self.values = values self.children = defaultdict(list) self.subtree_sums = [0] * (N + 1) def add_edge(self, u, v): self.children[u].append(v) self.children[v].append(u) def update_subtree_sums(self, node, parent): self.subtree_sums[node] = self.values[node - 1] for child in self.children[node]: if child != parent: self.update_subtree_sums(child, node) self.subtree_sums[node] += self.subtree_sums[child] def add_to_node(self, x, y): self.values[x - 1] += y self.update_subtree_sums(1, -1) def set_node_value(self, x, y): self.values[x - 1] = y self.update_subtree_sums(1, -1) def sum_subtree(self, x): return self.subtree_sums[x] def process_tree_queries(N, values, edges, queries): tree = Tree(N, values) for u, v in edges: tree.add_edge(u, v) # initialize subtree sums tree.update_subtree_sums(1, -1) results = [] for query in queries: parts = query.split() q_type = parts[0] x = int(parts[1]) if q_type == \\"SUM\\": results.append(tree.sum_subtree(x)) elif q_type == \\"ADD\\": y = int(parts[2]) tree.add_to_node(x, y) elif q_type == \\"SET\\": y = int(parts[2]) tree.set_node_value(x, y) return results N = 5 values = [1, 2, 3, 4, 5] edges = [(1, 2), (1, 3), (3, 4), (3, 5)] queries = [\\"SUM 3\\", \\"ADD 3 2\\", \\"SUM 3\\"] print(process_tree_queries(N, values, edges, queries)) # Output: [12, 14]"},{"question":"from typing import List def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations needed to make the string a palindrome. :param s: str :return: int >>> min_operations_to_palindrome(\\"abca\\") 1 >>> min_operations_to_palindrome(\\"aabb\\") 2 >>> min_operations_to_palindrome(\\"abcba\\") 0 pass # Replace this with your code def process_test_cases(test_cases: List[str]) -> List[int]: Processes multiple test cases for the min_operations_to_palindrome function. :param test_cases: List of strings :return: List of results for each test case >>> process_test_cases([\\"abca\\", \\"aabb\\", \\"abcba\\"]) [1, 2, 0] >>> process_test_cases([\\"racecar\\", \\"noon\\", \\"a\\"]) [0, 0, 0] pass # Replace this with your code","solution":"def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations needed to make the string a palindrome. n = len(s) left = 0 right = n - 1 operations = 0 while left < right: if s[left] != s[right]: operations += 1 left += 1 right -= 1 return operations def process_test_cases(test_cases): results = [] for s in test_cases: results.append(min_operations_to_palindrome(s)) return results"},{"question":"def flatten_json(json_obj: dict) -> dict: Flatten a nested JSON object into a flat dictionary with keys as a combination of nested keys separated by dots. >>> flatten_json({ ... \\"user\\": { ... \\"name\\": \\"John\\", ... \\"address\\": { ... \\"city\\": \\"New York\\", ... \\"zip\\": \\"10001\\" ... } ... }, ... \\"active\\": True ... }) {\\"user.name\\": \\"John\\", \\"user.address.city\\": \\"New York\\", \\"user.address.zip\\": \\"10001\\", \\"active\\": True} >>> flatten_json({}) {} >>> flatten_json({\\"name\\": \\"Jane\\", \\"age\\": 30}) {\\"name\\": \\"Jane\\", \\"age\\": 30} >>> flatten_json({\\"a\\": {\\"b\\": {\\"c\\": {\\"d\\": \\"value\\"}}}}) {\\"a.b.c.d\\": \\"value\\"} >>> flatten_json({\\"id\\": 1, \\"details\\": {\\"name\\": \\"Alice\\", \\"is_online\\": False}, \\"scores\\": [1, 2, 3]}) {\\"id\\": 1, \\"details.name\\": \\"Alice\\", \\"details.is_online\\": False, \\"scores\\": [1, 2, 3]}","solution":"def flatten_json(json_obj: dict, parent_key: str = '', sep: str = '.') -> dict: Flatten a nested JSON object into a flat dictionary with keys as a combination of nested keys separated by dots. :param json_obj: The nested JSON object :param parent_key: The base key string for recursion (used internally) :param sep: Separator used between the keys :return: A flat dictionary items = {} for k, v in json_obj.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.update(flatten_json(v, new_key, sep=sep)) else: items[new_key] = v return items"},{"question":"def categorize_users(users): Categorizes each user into the appropriate tier based on their friends and followers count. :param users: List of tuples (friends, followers) :return: List of strings representing the tiers of the users from typing import List, Tuple def test_categorize_users_case_1(): users = [(50, 200), (200, 3000), (600, 2000), (800, 7000), (1000, 10000)] expected = ['Bronze', 'Silver', 'Silver', 'Gold', 'Gold'] assert categorize_users(users) == expected def test_categorize_users_all_bronze(): users = [(10, 100), (99, 999), (0, 0)] expected = ['Bronze', 'Bronze', 'Bronze'] assert categorize_users(users) == expected def test_categorize_users_all_silver(): users = [(100, 200), (500, 1000), (300, 5000)] expected = ['Silver', 'Silver', 'Silver'] assert categorize_users(users) == expected def test_categorize_users_all_gold(): users = [(501, 5001), (600, 6000), (700, 7000)] expected = ['Gold', 'Gold', 'Gold'] assert categorize_users(users) == expected def test_categorize_users_mixed_tiers(): users = [(100, 999), (500, 5000), (600, 6000)] expected = ['Silver', 'Silver', 'Gold'] assert categorize_users(users) == expected def test_categorize_users_edge_cases(): users = [(100, 1000), (500, 5000), (501, 5000), (500, 5001)] expected = ['Silver', 'Silver', 'Silver', 'Silver'] assert categorize_users(users) == expected","solution":"def categorize_users(users): Categorizes each user into the appropriate tier based on their friends and followers count. :param users: List of tuples (friends, followers) :return: List of strings representing the tiers of the users tiers = [] for friends, followers in users: if friends > 500 and followers > 5000: tiers.append('Gold') elif 100 <= friends <= 500 or 1000 <= followers <= 5000: tiers.append('Silver') else: tiers.append('Bronze') return tiers # Function to handle input and output def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) users = [(int(data[i]), int(data[i + 1])) for i in range(1, len(data), 2)] result = categorize_users(users) for tier in result: print(tier)"},{"question":"def transform_array(N: int, M: int, A: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Transforms the array A of length N by performing M operations given in operations. Each operation is represented as a tuple (L, R, X) where every element in the subarray A[L-1:R] is transformed by doing a bitwise OR with the integer X. Arguments: N : int : the number of elements in the array M : int : the number of operations A : list : the initial elements of the array operations : list of tuples : each tuple contains three integers L, R, and X Returns: list : the array after performing all operations >>> transform_array(5, 3, [1, 2, 3, 4, 5], [(1, 3, 2), (2, 5, 4), (1, 4, 1)]) [3, 7, 7, 5, 5] >>> transform_array(3, 1, [1, 2, 3], [(1, 3, 1)]) [1, 3, 3] >>> transform_array(4, 0, [4, 5, 6, 7], []) [4, 5, 6, 7] >>> transform_array(5, 1, [1, 2, 3, 4, 5], [(1, 5, 15)]) [15, 15, 15, 15, 15] >>> transform_array(5, 1, [1, 2, 3, 4, 5], [(4, 5, 1)]) [1, 2, 3, 5, 5]","solution":"def transform_array(N, M, A, operations): Transforms the array A of length N by performing M operations given in operations. Each operation is represented as a tuple (L, R, X) where every element in the subarray A[L-1:R] is transformed by doing a bitwise OR with the integer X. Arguments: N : int : the number of elements in the array M : int : the number of operations A : list : the initial elements of the array operations : list of tuples : each tuple contains three integers L, R, and X Returns: list : the array after performing all operations for op in operations: L, R, X = op for i in range(L-1, R): A[i] |= X return A"},{"question":"def product_except_self(nums): Given a list of positive integers, returns a new list where each element is the product of all the numbers in the original list except the one at the current position. Args: nums (list): A list of positive integers with length at least 2. Returns: list: A list of products.","solution":"def product_except_self(nums): Given a list of positive integers, returns a new list where each element is the product of all the numbers in the original list except the one at the current position. Args: nums (list): A list of positive integers with length at least 2. Returns: list: A list of products. length = len(nums) result = [1] * length left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] right_product = 1 for i in reversed(range(length)): result[i] *= right_product right_product *= nums[i] return result"},{"question":"from typing import List def find_primes(arr: List[int]) -> List[int]: Given an array of integers, return an array containing only the prime numbers from the original array, in ascending order. >>> find_primes([3, 12, 5, 16, 7, 11]) [3, 5, 7, 11] >>> find_primes([4, 6, 8, 10, 12]) [] >>> find_primes([2, 3, 5, 7, 11, 13]) [2, 3, 5, 7, 11, 13] >>> find_primes([-3, -5, 2, 3]) [2, 3] >>> find_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> find_primes([29, 37, 41, 43, 47, 51, 53]) [29, 37, 41, 43, 47, 53] >>> find_primes([]) []","solution":"def is_prime(n): if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True def find_primes(arr): primes = [x for x in arr if is_prime(x)] return sorted(primes)"},{"question":"def is_prime(N: int) -> str: Determine if N is a prime number. Args: N (int): The number to check. Returns: str: 'Yes' if N is a prime number, 'No' otherwise. >>> is_prime(7) 'Yes' >>> is_prime(1) 'No' >>> is_prime(100) 'No' >>> is_prime(997) 'Yes'","solution":"def is_prime(N): Determine if N is a prime number. Args: N (int): The number to check. Returns: str: 'Yes' if N is a prime number, 'No' otherwise. if N <= 1: return 'No' for i in range(2, int(N**0.5) + 1): if N % i == 0: return 'No' return 'Yes'"},{"question":"from typing import List def is_valid_knight_move(start: str, end: str) -> bool: Determines if a move from start position to end position is a valid knight's move on a chessboard. # Mapping columns to indices col_to_index = {chr(i + ord('a')): i for i in range(8)} row_to_index = {str(i + 1): i for i in range(8)} start_col, start_row = start[0], start[1] end_col, end_row = end[0], end[1] start_x, start_y = col_to_index[start_col], row_to_index[start_row] end_x, end_y = col_to_index[end_col], row_to_index[end_row] dx = abs(end_x - start_x) dy = abs(end_y - start_y) # A valid knight move has to be in an L-shape i.e., (2,1) or (1,2) if (dx == 2 and dy == 1) or (dx == 1 and dy == 2): return True else: return False def check_moves(moves: List[str]) -> List[str]: Given a list of moves in the format start_pos->end_pos, determine if each move is a valid knight's move. >>> check_moves([\\"a1->b3\\", \\"a1->c2\\", \\"h8->g6\\", \\"b1->c2\\"]) [\\"VALID\\", \\"VALID\\", \\"VALID\\", \\"INVALID\\"] results = [] for move in moves: start, end = move.split(\\"->\\") if is_valid_knight_move(start, end): results.append(\\"VALID\\") else: results.append(\\"INVALID\\") return results def test_sample_moves(): moves = [\\"a1->b3\\", \\"a1->c2\\", \\"h8->g6\\", \\"b1->c2\\"] assert check_moves(moves) == [\\"VALID\\", \\"VALID\\", \\"VALID\\", \\"INVALID\\"] def test_all_valid_moves(): moves = [\\"a1->c2\\", \\"c2->a3\\", \\"f3->g5\\", \\"h8->f7\\"] assert check_moves(moves) == [\\"VALID\\", \\"VALID\\", \\"VALID\\", \\"VALID\\"] def test_all_invalid_moves(): moves = [\\"a1->a3\\", \\"h8->f8\\", \\"c1->c3\\", \\"d4->d6\\"] assert check_moves(moves) == [\\"INVALID\\", \\"INVALID\\", \\"INVALID\\", \\"INVALID\\"] def test_mixed_moves(): moves = [\\"a1->b2\\", \\"e4->f6\\", \\"h8->g7\\", \\"d2->h3\\"] assert check_moves(moves) == [\\"INVALID\\", \\"VALID\\", \\"INVALID\\", \\"INVALID\\"] def test_edge_case_moves(): moves = [\\"b1->a3\\", \\"g8->f6\\", \\"c7->d5\\", \\"b8->c6\\"] assert check_moves(moves) == [\\"VALID\\", \\"VALID\\", \\"VALID\\", \\"VALID\\"]","solution":"def is_valid_knight_move(start, end): Determines if a move from start position to end position is a valid knight's move on a chessboard. # Mapping columns to indices col_to_index = {chr(i + ord('a')): i for i in range(8)} row_to_index = {str(i + 1): i for i in range(8)} start_col, start_row = start[0], start[1] end_col, end_row = end[0], end[1] start_x, start_y = col_to_index[start_col], row_to_index[start_row] end_x, end_y = col_to_index[end_col], row_to_index[end_row] dx = abs(end_x - start_x) dy = abs(end_y - start_y) # A valid knight move has to be in an L-shape i.e., (2,1) or (1,2) if (dx == 2 and dy == 1) or (dx == 1 and dy == 2): return True else: return False def check_moves(moves): results = [] for move in moves: start, end = move.split(\\"->\\") if is_valid_knight_move(start, end): results.append(\\"VALID\\") else: results.append(\\"INVALID\\") return results"},{"question":"def count_substring_occurrences(string1: str, string2: str) -> int: Counts and returns the number of times string2 appears as a substring in string1. >>> count_substring_occurrences(\\"hellohello\\", \\"lo\\") 2 >>> count_substring_occurrences(\\"ababab\\", \\"ab\\") 3 >>> count_substring_occurrences(\\"hellohello\\", \\"hello\\") 2 >>> count_substring_occurrences(\\"hello\\", \\"world\\") 0 >>> count_substring_occurrences(\\"hello\\", \\"\\") 6 >>> count_substring_occurrences(\\"\\", \\"a\\") 0 >>> count_substring_occurrences(\\"\\", \\"\\") 1 >>> count_substring_occurrences(\\"abcabcabc\\", \\"abc\\") 3","solution":"def count_substring_occurrences(string1, string2): Counts and returns the number of times string2 appears as a substring in string1. count = 0 start = 0 while start <= len(string1) - len(string2): pos = string1.find(string2, start) if pos == -1: break count += 1 start = pos + 1 return count # Example usage: # string1 = \\"hellohello\\" # string2 = \\"lo\\" # print(count_substring_occurrences(string1, string2)) # Output should be 2"},{"question":"def max_difference(arr): Finds the maximum difference between any two elements in the array such that the larger element comes after the smaller element. >>> max_difference([2, 3, 10, 6, 4, 8]) 8 >>> max_difference([2, 2, 2, 2, 2]) 0 >>> max_difference([5, 4, 3, 2, 1]) 0 >>> max_difference([1, 2, -1, -2, 5, 6]) 8 >>> max_difference([-10, 10]) 20 >>> max_difference([10]) 0 >>> max_difference([]) 0","solution":"def max_difference(arr): Finds the maximum difference between any two elements in the array such that the larger element comes after the smaller element. if len(arr) < 2: return 0 min_element = arr[0] max_diff = float('-inf') for i in range(1, len(arr)): if arr[i] > min_element: max_diff = max(max_diff, arr[i] - min_element) min_element = min(min_element, arr[i]) return max_diff if max_diff != float('-inf') else 0"},{"question":"def calculate_distances(test_cases): Given a list of test cases (each a tuple of four integers representing two points on a grid), returns a list of distances between these points using the formula |x1 - x2| + |y1 - y2|. distances = [] for x1, y1, x2, y2 in test_cases: distance = abs(x1 - x2) + abs(y1 - y2) distances.append(distance) return distances def parse_input(input_str): Parses an input string in the format specified in the problem description and returns the number of test cases and a list of test cases. lines = input_str.strip().split('n') T = int(lines[0].strip()) test_cases = [] for i in range(1, T + 1): x1, y1, x2, y2 = map(int, lines[i].strip().split()) test_cases.append((x1, y1, x2, y2)) return T, test_cases def format_output(distances): Formats a list of distances (integers) into an output string with each distance on a new line. return 'n'.join(map(str, distances)) def main(input_str): T, test_cases = parse_input(input_str) distances = calculate_distances(test_cases) return format_output(distances) # Unit tests def test_calculate_distances(): test_cases = [ (0, 0, 1, 1), (-1, -1, 1, 1), (2, 3, 2, 3), ] expected = [2, 4, 0] assert calculate_distances(test_cases) == expected def test_parse_input(): input_str = \\"3n0 0 1 1n-1 -1 1 1n2 3 2 3n\\" expected = (3, [(0, 0, 1, 1), (-1, -1, 1, 1), (2, 3, 2, 3)]) assert parse_input(input_str) == expected def test_format_output(): distances = [2, 4, 0] expected = \\"2n4n0\\" assert format_output(distances) == expected def test_main(): input_str = \\"3n0 0 1 1n-1 -1 1 1n2 3 2 3n\\" expected_output = \\"2n4n0\\" assert main(input_str) == expected_output","solution":"def calculate_distances(test_cases): Given a list of test cases (each a tuple of four integers representing two points on a grid), returns a list of distances between these points using the formula |x1 - x2| + |y1 - y2|. distances = [] for x1, y1, x2, y2 in test_cases: distance = abs(x1 - x2) + abs(y1 - y2) distances.append(distance) return distances def parse_input(input_str): Parses an input string in the format specified in the problem description and returns the number of test cases and a list of test cases. lines = input_str.strip().split('n') T = int(lines[0].strip()) test_cases = [] for i in range(1, T + 1): x1, y1, x2, y2 = map(int, lines[i].strip().split()) test_cases.append((x1, y1, x2, y2)) return T, test_cases def format_output(distances): Formats a list of distances (integers) into an output string with each distance on a new line. return 'n'.join(map(str, distances)) def main(input_str): T, test_cases = parse_input(input_str) distances = calculate_distances(test_cases) return format_output(distances)"},{"question":"def min_barriers_needed(test_cases): Determine the minimum number of barriers needed such that no two research stations can communicate directly via horizontal or vertical paths. >>> min_barriers_needed([((3, 3), [\\"R.R\\", \\"R.R\\", \\"...\\"]), ((3, 4), [\\"R..R\\", \\"....\\", \\"R..R\\"])]) [2, 2] >>> min_barriers_needed([((1, 1), [\\"R\\"])]) [1] >>> min_barriers_needed([((3, 3), [\\"...\\", \\".R.\\", \\"...\\"])]) [1] >>> min_barriers_needed([((3, 3), [\\"RRR\\", \\"R..\\", \\"RRR\\"])]) [3] >>> min_barriers_needed([((3, 3), [\\"R..\\", \\"..R\\", \\"R..\\"])]) [2] # Your code here def parse_input(input_str): Parse the input string into a list of test cases. >>> parse_input(\\"2n3 3nR.RnR.Rn...n3 4nR..Rn....nR..Rn\\") [((3, 3), [\\"R.R\\", \\"R.R\\", \\"...\\"]), ((3, 4), [\\"R..R\\", \\"....\\", \\"R..R\\"])] >>> parse_input(\\"1n1 1nRn\\") [((1, 1), [\\"R\\"])] # Your code here","solution":"def min_barriers_needed(test_cases): def min_barriers(m, n, grid): rows, cols = [0] * m, [0] * n for i in range(m): for j in range(n): if grid[i][j] == 'R': rows[i] = 1 cols[j] = 1 return min(sum(rows), sum(cols)) results = [] for case in test_cases: m, n, grid = case results.append(min_barriers(m, n, grid)) return results def parse_input(input_str): input_lines = input_str.strip().split(\\"n\\") t = int(input_lines[0]) index = 1 test_cases = [] for _ in range(t): m, n = map(int, input_lines[index].split()) index += 1 grid = [] for _ in range(m): grid.append(input_lines[index]) index += 1 test_cases.append((m, n, grid)) return test_cases"},{"question":"def calculate_prefix_sum(matrix): Calculates and returns the prefix sum matrix for the given matrix pass def sum_query(prefix_sum, r1, c1, r2, c2): Calculates the sum of the submatrix defined by (r1, c1) to (r2, c2) pass def solve(T, test_cases): Solves the submatrix sum queries for the given number of test cases. Args: T (int): Number of test cases. test_cases (List[Dict]): List of dictionaries where each dictionary represents a test case and contains matrix dimensions, the matrix itself, number of queries, and the queries. Returns: List[int]: List of results for each query in all test cases. Example: >>> T = 1 >>> test_cases = [ >>> { >>> 'N': 3, >>> 'M': 3, >>> 'matrix': [ >>> [1, 2, 3], >>> [4, 5, 6], >>> [7, 8, 9], >>> ], >>> 'Q': 2, >>> 'queries': [ >>> (1, 1, 2, 2), >>> (2, 2, 3, 3), >>> ], >>> } >>> ] >>> solve(T, test_cases) [12, 28] pass","solution":"def calculate_prefix_sum(matrix): Calculates and returns the prefix sum matrix for the given matrix. N = len(matrix) M = len(matrix[0]) prefix_sum = [[0] * (M + 1) for _ in range(N + 1)] for i in range(1, N + 1): for j in range(1, M + 1): prefix_sum[i][j] = ( matrix[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] ) return prefix_sum def sum_query(prefix_sum, r1, c1, r2, c2): Calculates the sum of the submatrix defined by (r1, c1) to (r2, c2) using the prefix sum matrix. return ( prefix_sum[r2][c2] - prefix_sum[r1 - 1][c2] - prefix_sum[r2][c1 - 1] + prefix_sum[r1 - 1][c1 - 1] ) def solve(T, test_cases): Solves the submatrix sum queries for the given number of test cases. results = [] for test_case in test_cases: N = test_case['N'] M = test_case['M'] matrix = test_case['matrix'] Q = test_case['Q'] queries = test_case['queries'] prefix_sum = calculate_prefix_sum(matrix) for (r1, c1, r2, c2) in queries: result = sum_query(prefix_sum, r1, c1, r2, c2) results.append(result) return results"},{"question":"def pyramid_info(height: int) -> (int, int): Given the height of a number pyramid, returns the sum of all numbers in the pyramid and the product of the numbers in the last level of the pyramid. Args: height (int): The height of the number pyramid. Returns: tuple: A tuple containing the total sum of all numbers and the product of numbers in the last level. Example: >>> pyramid_info(4) (30, 256) >>> pyramid_info(1) (1, 1)","solution":"def pyramid_info(height): Given the height of a number pyramid, returns the sum of all numbers in the pyramid and the product of the numbers in the last level of the pyramid. Args: height (int): The height of the number pyramid. Returns: tuple: A tuple containing the total sum of all numbers and the product of numbers in the last level. total_sum = 0 last_level_product = 1 for level in range(1, height + 1): total_sum += level * level if level == height: last_level_product = level ** level return total_sum, last_level_product"},{"question":"def unique_paths(N: int, M: int) -> int: Calculate the number of unique paths in a N x M grid. >>> unique_paths(3, 3) 6 >>> unique_paths(2, 2) 2 >>> unique_paths(1, 1) 1 >>> unique_paths(2, 3) 3 >>> unique_paths(3, 2) 3 def get_unique_paths_for_test_cases(test_cases: List[Tuple[int, int]]) -> List[int]: Calculate the number of unique paths for multiple test cases. >>> get_unique_paths_for_test_cases([(3, 3), (2, 2)]) [6, 2] >>> get_unique_paths_for_test_cases([(1, 1), (10, 1), (1, 10)]) [1, 1, 1]","solution":"def unique_paths(N, M): Calculate the number of unique paths in a N x M grid. if N == 0 or M == 0: return 0 dp = [[1]*M for _ in range(N)] for i in range(1, N): for j in range(1, M): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[-1][-1] def get_unique_paths_for_test_cases(test_cases): results = [] for N, M in test_cases: results.append(unique_paths(N, M)) return results"},{"question":"def check_palindromes(strings): Given a list of strings, checks if each string is a palindrome and returns 'Palindrome' if it is, or 'Not Palindrome' otherwise. >>> check_palindromes([\\"madam\\", \\"hello\\", \\"racecar\\"]) [\\"Palindrome\\", \\"Not Palindrome\\", \\"Palindrome\\"] >>> check_palindromes([\\"abcd\\", \\"abba\\", \\"xyzzyx\\"]) [\\"Not Palindrome\\", \\"Palindrome\\", \\"Palindrome\\"] >>> check_palindromes([\\"a\\", \\"b\\", \\"c\\"]) [\\"Palindrome\\", \\"Palindrome\\", \\"Palindrome\\"] >>> check_palindromes([\\"abcba\\", \\"radar\\", \\"level\\"]) [\\"Palindrome\\", \\"Palindrome\\", \\"Palindrome\\"] >>> check_palindromes([\\"noon\\", \\"deified\\", \\"civic\\", \\"rotor\\"]) [\\"Palindrome\\", \\"Palindrome\\", \\"Palindrome\\", \\"Palindrome\\"] >>> check_palindromes([\\"\\", \\"weird\\", \\"stuff\\", \\"going\\"]) [\\"Palindrome\\", \\"Not Palindrome\\", \\"Not Palindrome\\", \\"Not Palindrome\\"]","solution":"def check_palindromes(strings): Given a list of strings, checks if each string is a palindrome and prints 'Palindrome' if it is, otherwise prints 'Not Palindrome'. results = [] for s in strings: if s == s[::-1]: results.append(\\"Palindrome\\") else: results.append(\\"Not Palindrome\\") return results"},{"question":"from typing import List, Tuple def max_sum_less_than_equal_k(N: int, K: int, arr: List[int]) -> int: Find the maximum value of the sum of any three distinct integers from the array that is less than or equal to K. >>> max_sum_less_than_equal_k(5, 10, [2, 3, 5, 7, 11]) 10 >>> max_sum_less_than_equal_k(4, 20, [1, 8, 9, 15]) 18 >>> max_sum_less_than_equal_k(3, 1, [10, 20, 30]) -1 >>> max_sum_less_than_equal_k(3, 60, [10, 20, 30]) 60 def solve(test_cases: List[Tuple[int, int, List[int]]]) -> str: Solve multiple test cases of the max_sum_less_than_equal_k function. >>> solve([(5, 10, [2, 3, 5, 7, 11]), (4, 20, [1, 8, 9, 15])]) '10n18'","solution":"from itertools import combinations def max_sum_less_than_equal_k(N, K, arr): max_sum = -1 for comb in combinations(arr, 3): current_sum = sum(comb) if current_sum <= K: max_sum = max(max_sum, current_sum) return max_sum def solve(test_cases): results = [] for N, K, array in test_cases: result = max_sum_less_than_equal_k(N, K, array) results.append(str(result)) return \\"n\\".join(results)"},{"question":"def largest_island_size(grid: List[List[int]]) -> int: Determine the size of the largest island in the given grid of land and water cells. Args: grid: A list of lists containing integers (0 or 1), where 1 represents land and 0 represents water. Returns: The size of the largest island. Examples: >>> largest_island_size([ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 1, 1], ... [0, 0, 0, 0, 1], ... [0, 0, 0, 1, 1] ... ]) 5 >>> largest_island_size([ ... [0, 0, 0, 0], ... [0, 1, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) 1 >>> largest_island_size([ ... [1, 1], ... [1, 1] ... ]) 4 >>> largest_island_size([ ... [0, 0], ... [0, 0] ... ]) 0 >>> largest_island_size([ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ]) 1","solution":"def largest_island_size(grid): n = len(grid) m = len(grid[0]) if n > 0 else 0 def dfs(x, y): if x < 0 or y < 0 or x >= n or y >= m or grid[x][y] == 0: return 0 grid[x][y] = 0 # mark the land as visited size = 1 size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size largest = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: largest = max(largest, dfs(i, j)) return largest"},{"question":"def rearrange_even_odd(arr): Rearrange the array such that all even numbers come before odd numbers while maintaining their relative order. Parameters: arr (list): The list of integers to be rearranged. Returns: list: The rearranged list. >>> rearrange_even_odd([4, 1, 3, 2, 6, 5, 8]) [4, 2, 6, 8, 1, 3, 5] >>> rearrange_even_odd([1, 3, 5, 7, 9]) [1, 3, 5, 7, 9] >>> rearrange_even_odd([2, 4, 6, 8, 10]) [2, 4, 6, 8, 10]","solution":"def rearrange_even_odd(arr): Rearrange the array such that all even numbers come before odd numbers while maintaining their relative order. Parameters: arr (list): The list of integers to be rearranged. Returns: list: The rearranged list. evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] result = evens + odds return result"},{"question":"def has_pair_with_sum(numbers, target): Determines if there are any two integers in the list whose sum equals 'target'. >>> has_pair_with_sum([10, 15, 3, 7], 17) True >>> has_pair_with_sum([1, 2, 3, 9], 8) False >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([5], 5) False >>> has_pair_with_sum([-10, 20, 10, -40, -10], -20) True >>> has_pair_with_sum([-1, 1, 2, 4, -2], 0) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 0) False >>> has_pair_with_sum([0, 0], 0) True >>> has_pair_with_sum([1000000000, 2999999999, 3999999998], 4999999998) True","solution":"def has_pair_with_sum(numbers, target): Determines if there are any two integers in the list whose sum equals 'target'. :param numbers: List of integers :param target: Integer target sum :return: True if there exists at least one pair of integers in the list that sum up to 'target', False otherwise seen = set() for number in numbers: complement = target - number if complement in seen: return True seen.add(number) return False"},{"question":"def maximum_sum_submatrix(matrix): Given an integer matrix M of size N x N, find the maximum sum of elements in any submatrix of M. >>> maximum_sum_submatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 45 >>> maximum_sum_submatrix([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) -1 >>> maximum_sum_submatrix([[1, -2, 3], [-4, 5, -6], [7, -8, 9]]) 9 >>> maximum_sum_submatrix([[5]]) 5 >>> maximum_sum_submatrix([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 def process_test_cases(test_cases): Processes multiple test cases for finding maximum sum submatrix. >>> process_test_cases([[[1, 2, 3], [4, 5, 6], [7, 8, 9]]]) [45] def parse_input(input_string): Parses input string into test cases. >>> parse_input(\\"1n3n1 2 3n4 5 6n7 8 9n\\") [[[1, 2, 3], [4, 5, 6], [7, 8, 9]]] def process_output(result): Processes output result into string. >>> process_output([45]) '45'","solution":"def maximum_sum_submatrix(matrix): def kadane(nums): max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum N = len(matrix) max_sum = float('-inf') for left in range(N): temp = [0] * N for right in range(left, N): for i in range(N): temp[i] += matrix[right][i] max_sum = max(max_sum, kadane(temp)) return max_sum def process_test_cases(test_cases): results = [] for matrix in test_cases: result = maximum_sum_submatrix(matrix) results.append(result) return results def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) index += 1 matrix = [] for _ in range(N): matrix.append(list(map(int, lines[index].split()))) index += 1 test_cases.append(matrix) return test_cases def process_output(result): return \\"n\\".join(map(str, result))"},{"question":"def create_secret_santa_pairings(n: int, participants: List[str], last_year_pairs: List[str]) -> List[Tuple[str, str]]: Determine a valid new Secret Santa drawing that satisfies the given conditions. >>> create_secret_santa_pairings(4, [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Dave\\"], [\\"Alice Bob\\", \\"Bob Charlie\\", \\"Charlie Dave\\", \\"Dave Alice\\"]) [(\\"Alice\\", \\"Charlie\\"), (\\"Bob\\", \\"Dave\\"), (\\"Charlie\\", \\"Alice\\"), (\\"Dave\\", \\"Bob\\")] >>> create_secret_santa_pairings(5, [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Dave\\", \\"Eve\\"], [\\"Alice Bob\\", \\"Bob Charlie\\", \\"Charlie Dave\\", \\"Dave Eve\\", \\"Eve Alice\\"]) [(\\"Alice\\", \\"Charlie\\"), (\\"Bob\\", \\"Dave\\"), (\\"Charlie\\", \\"Eve\\"), (\\"Dave\\", \\"Alice\\"), (\\"Eve\\", \\"Bob\\")] pass def test_secret_santa_base_case(): n = 4 participants = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Dave\\"] last_year_pairs = [\\"Alice Bob\\", \\"Bob Charlie\\", \\"Charlie Dave\\", \\"Dave Alice\\"] result = create_secret_santa_pairings(n, participants, last_year_pairs) # Convert the results to a dictionary for easy verification result_dict = {giver: receiver for giver, receiver in result} assert len(result) == n assert all(giver != result_dict[giver] for giver in participants) # No one gave a gift to themselves. assert all(result_dict[pair.split()[0]] != pair.split()[1] for pair in last_year_pairs) # No gift to same person as last year. def test_secret_santa_larger_case(): n = 5 participants = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Dave\\", \\"Eve\\"] last_year_pairs = [\\"Alice Bob\\", \\"Bob Charlie\\", \\"Charlie Dave\\", \\"Dave Eve\\", \\"Eve Alice\\"] result = create_secret_santa_pairings(n, participants, last_year_pairs) # Convert the results to a dictionary for easy verification result_dict = {giver: receiver for giver, receiver in result} assert len(result) == n assert all(giver != result_dict[giver] for giver in participants) # No one gave a gift to themselves. assert all(result_dict[pair.split()[0]] != pair.split()[1] for pair in last_year_pairs) # No gift to same person as last year. def test_secret_santa_another_case(): n = 3 participants = [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] last_year_pairs = [\\"Alice Bob\\", \\"Bob Charlie\\", \\"Charlie Alice\\"] result = create_secret_santa_pairings(n, participants, last_year_pairs) # Convert the results to a dictionary for easy verification result_dict = {giver: receiver for giver, receiver in result} assert len(result) == n assert all(giver != result_dict[giver] for giver in participants) # No one gave a gift to themselves. assert all(result_dict[pair.split()[0]] != pair.split()[1] for pair in last_year_pairs) # No gift to same person as last year.","solution":"import random def secret_santa(n, participants, last_year_pairs): # Convert last year pairs into a dictionary for fast lookup last_year_dict = {pair[0]: pair[1] for pair in last_year_pairs} # Initial constraint where no one should get themselves current_year = {name: None for name in participants} # List to hold all possible receivers possible_receivers = participants[:] for giver in participants: # Filter out the giver and last year's receiver valid_receivers = [name for name in possible_receivers if name != giver and name != last_year_dict[giver]] if not valid_receivers: # Restart the assignment from scratch return secret_santa(n, participants, last_year_pairs) receiver = random.choice(valid_receivers) current_year[giver] = receiver possible_receivers.remove(receiver) return [(giver, receiver) for giver, receiver in current_year.items()] # Convert input format def create_secret_santa_pairings(n, participants, last_year_pairs): pair_list = [pair.split() for pair in last_year_pairs] return secret_santa(n, participants, pair_list)"},{"question":"def most_frequent_user(log_entries, start, end): Determine the user who accessed the server the most times within a given interval. log_entries: List of tuples where each tuple contains a user-name and a timestamp of access. start: Start timestamp of the interval. end: End timestamp of the interval. Returns: The user with the highest number of accesses in the given interval. If multiple users have the same highest access count, returns the lexicographically smallest user-name. from solution import most_frequent_user def test_example_1(): log_entries = [ (\\"alice\\", 5), (\\"bob\\", 7), (\\"alice\\", 9), (\\"charlie\\", 10), (\\"bob\\", 11), (\\"alice\\", 14) ] start = 5 end = 10 assert most_frequent_user(log_entries, start, end) == \\"alice\\" def test_example_2(): log_entries = [ (\\"carol\\", 10), (\\"dan\\", 10), (\\"carol\\", 11), (\\"bert\\", 12), (\\"carol\\", 13), (\\"bert\\", 14), (\\"dan\\", 15) ] start = 10 end = 15 assert most_frequent_user(log_entries, start, end) == \\"carol\\" def test_example_3(): log_entries = [ (\\"erin\\", 8), (\\"erin\\", 10), (\\"fred\\", 12), (\\"erin\\", 14), (\\"fred\\", 16) ] start = 8 end = 14 assert most_frequent_user(log_entries, start, end) == \\"erin\\" def test_all_entries_outside_interval(): log_entries = [ (\\"alice\\", 1), (\\"bob\\", 2), (\\"charlie\\", 3) ] start = 4 end = 5 assert most_frequent_user(log_entries, start, end) == None def test_multiple_users_with_same_access_count(): log_entries = [ (\\"alice\\", 5), (\\"bob\\", 7), (\\"alice\\", 8), (\\"bob\\", 9), (\\"charlie\\", 10), ] start = 5 end = 10 assert most_frequent_user(log_entries, start, end) == \\"alice\\"","solution":"def most_frequent_user(log_entries, start, end): from collections import Counter user_access_count = Counter() for user, timestamp in log_entries: if start <= timestamp <= end: user_access_count[user] += 1 if not user_access_count: return None max_count = max(user_access_count.values()) most_frequent_users = [user for user, count in user_access_count.items() if count == max_count] return min(most_frequent_users)"},{"question":"def min_power_usage(n: int, l: int, lamps: List[Tuple[int, int, int]]) -> int: Determines the minimum total power usage required to keep the entire street fully illuminated. Parameters: n (int): Number of lamps. l (int): Length of the street. lamps (list of tuples): Each tuple contains si, ei, pi representing start position, end position, and power usage of the lamp. Returns: int: Minimum total power usage or -1 if it's not possible to cover the entire street. >>> min_power_usage(4, 10, [(1, 5, 2), (4, 10, 3), (2, 7, 4), (8, 10, 5)]) 5 >>> min_power_usage(3, 8, [(1, 4, 3), (2, 6, 5), (7, 8, 2)]) 10 >>> min_power_usage(2, 6, [(1, 3, 2), (4, 5, 1)]) -1 pass # Unit tests def test_example_1(): assert min_power_usage(4, 10, [(1, 5, 2), (4, 10, 3), (2, 7, 4), (8, 10, 5)]) == 5 def test_example_2(): assert min_power_usage(3, 8, [(1, 4, 3), (2, 6, 5), (7, 8, 2)]) == 10 def test_example_3(): assert min_power_usage(2, 6, [(1, 3, 2), (4, 5, 1)]) == -1 def test_single_lamp(): assert min_power_usage(1, 1, [(1, 1, 1)]) == 1 def test_no_lamps(): assert min_power_usage(0, 10, []) == -1 def test_non_overlapping_lamps(): assert min_power_usage(3, 10, [(1, 3, 5), (4, 6, 5), (7, 10, 5)]) == 15 def test_gaps_lamps(): assert min_power_usage(2, 10, [(1, 5, 4), (7, 10, 3)]) == -1","solution":"def min_power_usage(n, l, lamps): Determines the minimum total power usage required to keep the entire street fully illuminated. Parameters: n (int): Number of lamps. l (int): Length of the street. lamps (list of tuples): Each tuple contains si, ei, pi representing start position, end position, and power usage of the lamp. Returns: int: Minimum total power usage or -1 if it's not possible to cover the entire street. # Sorting lamps by their starting position. lamps.sort() import heapq heap = [] current_end = 0 total_power = 0 i = 0 while current_end < l: # Add all lamps that can start at or before the current gap starts (current_end + 1) while i < n and lamps[i][0] <= current_end + 1: heapq.heappush(heap, (lamps[i][2], lamps[i])) i += 1 # If there are no lamps to cover the next gap if not heap: return -1 # Choose the lamp that ends the furthest within the current choices and increment total power usage by its power min_power, best_lamp = heapq.heappop(heap) current_end = best_lamp[1] total_power += best_lamp[2] # If we've covered the entire length of the street, return the total power usage if current_end >= l: return total_power return -1"},{"question":"def max_collectable_score(scores: List[int]) -> int: Returns the maximum score Alice and Bob can collect. >>> max_collectable_score([1, 2, 9, 2, 1]) 9 >>> max_collectable_score([1, 3, 5, 7, 5, 3, 1]) 7 pass","solution":"def max_collectable_score(scores): Returns the maximum score Alice and Bob can collect. left, right = 0, len(scores) - 1 max_score = 0 while left <= right: if scores[left] > scores[right]: max_score = max(max_score, scores[left]) left += 1 else: max_score = max(max_score, scores[right]) right -= 1 return max_score"},{"question":"from typing import List, Tuple def allocate_challenges(n: int, m: int, k: int, efficiencies: List[int], challenges: List[Tuple[int, int]]) -> List[int]: Determine the challenge allocation for each team using any of the robot models, ensuring the rules are followed. Parameters: n (int): Number of teams. m (int): Number of challenges. k (int): Number of robot models. efficiencies (List[int]): Efficiency of each team. challenges (List[Tuple[int, int]]): List of pairs of teams for each challenge. Returns: List[int]: List of robot models used to solve each challenge, or 0 if the challenge shouldn't be solved. >>> allocate_challenges(5, 8, 3, [5, 3, 8, 2, 6], [(1, 3), (1, 2), (3, 4), (2, 5), (4, 5), (1, 5), (3, 2), (2, 4)]) [2, 1, 3, 1, 2, 3, 1, 1] >>> allocate_challenges(4, 5, 2, [1, 2, 3, 4], [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)]) [1, 2, 1, 2, 1] # Unit tests from solution import allocate_challenges def test_allocate_challenges_case1(): n = 5 m = 8 k = 3 efficiencies = [5, 3, 8, 2, 6] challenges = [(1, 3), (1, 2), (3, 4), (2, 5), (4, 5), (1, 5), (3, 2), (2, 4)] result = allocate_challenges(n, m, k, efficiencies, challenges) assert all(1 <= model <= k or model == 0 for model in result) def test_allocate_challenges_case2(): n = 4 m = 5 k = 2 efficiencies = [1, 2, 3, 4] challenges = [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)] result = allocate_challenges(n, m, k, efficiencies, challenges) assert all(1 <= model <= k or model == 0 for model in result) def test_allocate_challenges_case3(): n = 3 m = 5 k = 5 efficiencies = [10, 20, 30] challenges = [(1, 2), (2, 3), (1, 3), (1, 2), (2, 3)] result = allocate_challenges(n, m, k, efficiencies, challenges) assert all(1 <= model <= k or model == 0 for model in result) def test_allocate_challenges_case4(): n = 6 m = 0 k = 3 efficiencies = [12, 6, 15, 9, 2, 18] challenges = [] result = allocate_challenges(n, m, k, efficiencies, challenges) assert result == []","solution":"def allocate_challenges(n, m, k, efficiencies, challenges): # Initialize the challenge allocation list. allocations = [0] * m # A 2D list to store the count of challenges solved by each team with each robot model. challenges_solved = [[0] * k for _ in range(n)] def can_allocate(team, robot_model): max_challenges = max(challenges_solved[team]) min_challenges = min(challenges_solved[team]) current_with_model = challenges_solved[team][robot_model] return (current_with_model == max_challenges or current_with_model == min_challenges or max_challenges - current_with_model <= 2 or current_with_model - min_challenges <= 2) # Iterate through each challenge to allocate to a robot model for index, (team1, team2) in enumerate(challenges): allocated = False # Try to allocate a robot model that satisfies the constraints for model in range(k): if can_allocate(team1-1, model) and can_allocate(team2-1, model): allocations[index] = model + 1 challenges_solved[team1-1][model] += 1 challenges_solved[team2-1][model] += 1 allocated = True break if not allocated: allocations[index] = 0 return allocations"},{"question":"def min_operations_to_transform(S: str, T: str) -> int: Determine the minimum number of operations required to transform string S into string T. The allowed operations are: 1. Insert a character. 2. Remove a character. 3. Replace a character. Args: S (str): original string T (str): target string Returns: int: minimum number of operations Example: >>> min_operations_to_transform(\\"kitten\\", \\"sitting\\") 3 >>> min_operations_to_transform(\\"abcdef\\", \\"azced\\") 3","solution":"def min_operations_to_transform(S, T): Returns the minimum number of operations required to transform string S into string T. m, n = len(S), len(T) # Initialize dp array where dp[i][j] represents the minimum number of operations dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the base cases for i in range(m + 1): dp[i][0] = i # all deletions for j in range(n + 1): dp[0][j] = j # all insertions # Fill the dp array for i in range(1, m + 1): for j in range(1, n + 1): if S[i - 1] == T[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1] # Replace ) + 1 return dp[m][n]"},{"question":"def largest_rectangle(grid): Determines the area of the largest rectangular park that can be built in the city grid. >>> largest_rectangle([['1', '0', '1', '0'], ['1', '0', '0', '1'], ['1', '1', '1', '0'], ['0', '0', '0', '0']]) 4 >>> largest_rectangle([['1', '1'], ['1', '1']]) 0 >>> largest_rectangle([['0', '0'], ['0', '0']]) 4 >>> largest_rectangle([['0', '1', '0', '0']]) 2 >>> largest_rectangle([['0'], ['1'], ['0'], ['0']]) 2 >>> largest_rectangle([['0', '1', '0'], ['1', '0', '1'], ['0', '1', '0'], ['0', '0', '0']]) 3","solution":"def max_histogram_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def largest_rectangle(grid): if not grid: return 0 n = len(grid) m = len(grid[0]) max_area = 0 heights = [0] * m for i in range(n): for j in range(m): if grid[i][j] == '0': heights[j] += 1 else: heights[j] = 0 area = max_histogram_area(heights) max_area = max(max_area, area) return max_area"},{"question":"import random import string from typing import List def generate_password(length: int) -> str: Generates a random alphanumeric string of a given length with at least one uppercase letter, one lowercase letter, and one digit. Args: length (int): The length of the password, which must be at least 3. Returns: str: A random alphanumeric string of the given length. Raises: ValueError: If the length is less than 3. Examples: >>> len(generate_password(8)) == 8 True >>> any(c.isupper() for c in generate_password(8)) True >>> any(c.islower() for c in generate_password(10)) True >>> any(c.isdigit() for c in generate_password(5)) True","solution":"import random import string def generate_password(length): Generates a random alphanumeric string of a given length. The string contains at least one uppercase letter, one lowercase letter, and one digit. if length < 3: raise ValueError(\\"Length of password must be at least 3\\") # Ensure at least one of each required type password = [ random.choice(string.ascii_uppercase), random.choice(string.ascii_lowercase), random.choice(string.digits) ] # Fill the rest of the password length with random choices from all alphanumeric characters while len(password) < length: password.append(random.choice(string.ascii_letters + string.digits)) # Shuffle the list to ensure randomness and convert it back to a string random.shuffle(password) return ''.join(password)"},{"question":"from typing import List def escape_grid(input_str: str) -> int: Find the minimum number of moves required to reach the bottom-right corner from the top-left corner, avoiding all obstacles. >>> escape_grid(\\"5 5n.....n.#.n.#.#.n.#.#.n.....\\") 8 >>> escape_grid(\\"4 4n....n..nn....\\") -1 >>> escape_grid(\\"3 3n...n...n...\\") 4 >>> escape_grid(\\"2 2nn\\") -1 >>> escape_grid(\\"1 1n.\\") 0 >>> escape_grid(\\"3 3n.#.n#n.#.\\") -1","solution":"from collections import deque def min_moves_to_reach_end(grid): n = len(grid) m = len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set([(0, 0)]) while queue: x, y, dist = queue.popleft() if x == n - 1 and y == m - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 def parse_input(input_str): input_lines = input_str.strip().split('n') n, m = map(int, input_lines[0].split()) grid = [list(line) for line in input_lines[1:n+1]] return grid def escape_grid(input_str): grid = parse_input(input_str) return min_moves_to_reach_end(grid)"},{"question":"def is_schedule_feasible(n, medication_list): Determines if the medication schedule is feasible without any overlapping times. Parameters: n (int): Number of medications. medication_list (list): List containing the medication details. Each item is a tuple where the first element is the medication name (str), the second is the number of times the medication needs to be taken (int), and the remaining elements are the times (int) in 24-hour format. Returns: str: \\"Feasible\\" if the schedule has no overlapping times, otherwise \\"Not Feasible\\". # Unit tests def test_feasible_schedule_example1(): n = 2 medication_list = [ (\\"Aspirin\\", 2, 8, 20), (\\"VitaminD\\", 3, 7, 13, 19) ] assert is_schedule_feasible(n, medication_list) == \\"Feasible\\" def test_not_feasible_schedule_example2(): n = 3 medication_list = [ (\\"Med1\\", 2, 10, 16), (\\"Med2\\", 3, 10, 14, 18), (\\"Med3\\", 1, 10) ] assert is_schedule_feasible(n, medication_list) == \\"Not Feasible\\" def test_single_medication(): n = 1 medication_list = [ (\\"Med1\\", 1, 9) ] assert is_schedule_feasible(n, medication_list) == \\"Feasible\\" def test_multiple_medications_no_overlap(): n = 3 medication_list = [ (\\"Med1\\", 2, 9, 15), (\\"Med2\\", 1, 8), (\\"Med3\\", 1, 17) ] assert is_schedule_feasible(n, medication_list) == \\"Feasible\\" def test_multiple_medications_with_overlap(): n = 2 medication_list = [ (\\"Med1\\", 2, 8, 14), (\\"Med2\\", 2, 14, 18) ] assert is_schedule_feasible(n, medication_list) == \\"Not Feasible\\"","solution":"def is_schedule_feasible(n, medication_list): Determines if the medication schedule is feasible without any overlapping times. Parameters: n (int): Number of medications. medication_list (list): List containing the medication details. Each item is a tuple where the first element is the medication name (str), the second is the number of times the medication needs to be taken (int), and the remaining elements are the times (int) in 24-hour format. Returns: str: \\"Feasible\\" if the schedule has no overlapping times, otherwise \\"Not Feasible\\". taken_times = set() for medication in medication_list: times = medication[2:] for time in times: if time in taken_times: return \\"Not Feasible\\" taken_times.add(time) return \\"Feasible\\" # Example usage: n = 2 medication_list = [ (\\"Aspirin\\", 2, 8, 20), (\\"VitaminD\\", 3, 7, 13, 19) ] print(is_schedule_feasible(n, medication_list)) # Output: \\"Feasible\\""},{"question":"def magical_sequence_length(N: int) -> int: Returns the length of the magical sequence starting from N. >>> magical_sequence_length(6) 9 >>> magical_sequence_length(1) 1 >>> magical_sequence_length(2) 2 >>> magical_sequence_length(7) 17 >>> magical_sequence_length(16) 5 >>> magical_sequence_length(27) 112","solution":"def magical_sequence_length(N): Returns the length of the magical sequence starting from N. length = 1 # We start counting with the initial value N while N != 1: if N % 2 == 0: N //= 2 else: N = 3 * N + 1 length += 1 return length"},{"question":"def shift_string(s: str, k: int) -> str: Shifts each letter in the string s by k positions in the alphabet. Non-alphabetic characters remain unchanged. Args: s (str): The input string to be shifted. k (int): The number of positions to shift each letter. Returns: str: The shifted string. >>> shift_string(\\"abc\\", 2) 'cde' >>> shift_string(\\"xyz\\", 3) 'abc' >>> shift_string(\\"Hello, World!\\", 5) 'Mjqqt, Btwqi!' >>> shift_string(\\"Rotate me\\", 13) 'Ebgngr zr' >>> shift_string(\\"Shift 123!\\", 1) 'Tijgu 123!' >>> shift_string(\\"abc\\", 27) 'bcd' >>> shift_string(\\"xyz\\", 52) 'xyz' >>> shift_string(\\"abc\\", 26) 'abc' >>> shift_string(\\"Hello, World!\\", 26) 'Hello, World!'","solution":"def shift_string(s, k): Shifts each letter in the string s by k positions in the alphabet. Non-alphabetic characters remain unchanged. Args: s (str): The input string to be shifted. k (int): The number of positions to shift each letter. Returns: str: The shifted string. result = [] k = k % 26 # Reduce k to be within 0-25 for char in s: if 'a' <= char <= 'z': # Shift lowercase characters new_char = chr((ord(char) - ord('a') + k) % 26 + ord('a')) result.append(new_char) elif 'A' <= char <= 'Z': # Shift uppercase characters new_char = chr((ord(char) - ord('A') + k) % 26 + ord('A')) result.append(new_char) else: result.append(char) # Leave non-alphabetic characters unchanged return ''.join(result)"},{"question":"from typing import List, Tuple def determine_winner(n: int, m: int, picked_cards: List[int]) -> str: Determine if Alice or Bob will win the card game given the initial number of cards and the sequence of picked cards. Args: n (int): Total number of cards. m (int): Number of cards already picked. picked_cards (List[int]): Sequence of picked cards. Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" otherwise. pass def card_game_winners(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: For multiple test cases, determine the winner of the card game for each case. Args: t (int): Number of test cases. test_cases (List[Tuple[int, int, List[int]]]): List of test cases where each test case is represented by a tuple (n, m, picked_cards). Returns: List[str]: List of results with \\"Alice\\" or \\"Bob\\" as the winner for each test case. pass # Test cases def test_determine_winner_case1(): assert determine_winner(5, 2, [3, 1]) == \\"Alice\\" def test_determine_winner_case2(): assert determine_winner(6, 4, [2, 4, 6, 1]) == \\"Bob\\" def test_card_game_winners(): cases = [ (5, 2, [3, 1]), (6, 4, [2, 4, 6, 1]) ] expected = [\\"Alice\\", \\"Bob\\"] assert card_game_winners(2, cases) == expected def test_alice_wins_with_no_cards_picked_initially(): assert determine_winner(3, 0, []) == \\"Alice\\" # 3 turns -> Alice starts def test_bob_wins_with_no_cards_picked_initially(): assert determine_winner(4, 0, []) == \\"Bob\\" # 4 turns -> Alice, Bob, Alice, Bob (Bob picks the last card) def test_edge_case_minimum_n(): assert determine_winner(1, 0, []) == \\"Alice\\" # Only one card, Alice will always take it","solution":"def determine_winner(n, m, picked_cards): Determines whether Alice or Bob will win given the initial number of cards and the sequence of picked cards. # Determine the number of turns left turns_left = n - m # If the number of turns left is odd, it's Alice's turn, else it's Bob's turn if turns_left % 2 == 1: return \\"Alice\\" else: return \\"Bob\\" def card_game_winners(t, test_cases): results = [] for case in test_cases: n, m, picked_cards = case results.append(determine_winner(n, m, picked_cards)) return results"},{"question":"def find_jumping_numbers(N): This function returns a list of all jumping numbers less than or equal to N. >>> find_jumping_numbers(10) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> find_jumping_numbers(50) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21, 23, 32, 34, 43, 45] >>> find_jumping_numbers(0) [0] >>> find_jumping_numbers(-10) [] >>> find_jumping_numbers(100) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21, 23, 32, 34, 43, 45, 54, 56, 65, 67, 76, 78, 87, 89, 98] pass def process_input(T, test_cases): For each test case, print all jumping numbers less than or equal to N. >>> process_input(2, [10, 50]) [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21, 23, 32, 34, 43, 45]] >>> process_input(1, [0]) [[0]] >>> process_input(1, [-10]) [[]] >>> process_input(1, [100]) [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21, 23, 32, 34, 43, 45, 54, 56, 65, 67, 76, 78, 87, 89, 98]] pass","solution":"def find_jumping_numbers(N): This function returns a list of all jumping numbers less than or equal to N. if N < 0: return [] result = [] def is_jumping_number(num): num_str = str(num) for i in range(1, len(num_str)): if abs(int(num_str[i]) - int(num_str[i-1])) != 1: return False return True for num in range(N + 1): if is_jumping_number(num): result.append(num) return result def process_input(T, test_cases): For each test case, print all jumping numbers less than or equal to N. results = [] for N in test_cases: results.append(find_jumping_numbers(N)) return results"},{"question":"def group_by_first_char(strings): Groups a list of strings by their first character. Parameters: strings (list): List of strings to be grouped. Returns: dict: Dictionary where keys are first characters and values are lists of strings. Example: >>> group_by_first_char([\\"apple\\", \\"apricot\\", \\"banana\\", \\"blueberry\\", \\"cherry\\"]) {'a': ['apple', 'apricot'], 'b': ['banana', 'blueberry'], 'c': ['cherry']} >>> group_by_first_char([]) == {} >>> group_by_first_char([\\"\\", \\"\\", \\"\\"]) == {\\"\\": [\\"\\", \\"\\", \\"\\"]} >>> group_by_first_char([\\"dog\\", \\"cat\\", \\"\\"]) == {\\"d\\": [\\"dog\\"], \\"c\\": [\\"cat\\"], \\"\\": [\\"\\"]} >>> group_by_first_char([\\"hello\\"]) == {\\"h\\": [\\"hello\\"]} >>> group_by_first_char([\\"apple\\", \\"ape\\", \\"banana\\", \\"bat\\", \\"bat\\", \\"\\"]) == {\\"a\\": [\\"apple\\", \\"ape\\"], \\"b\\": [\\"banana\\", \\"bat\\", \\"bat\\"], \\"\\": [\\"\\"]}","solution":"def group_by_first_char(strings): Groups a list of strings by their first character. Parameters: strings (list): List of strings to be grouped. Returns: dict: Dictionary where keys are first characters and values are lists of strings. result = {} for string in strings: if len(string) > 0: first_char = string[0] else: first_char = \\"\\" if first_char in result: result[first_char].append(string) else: result[first_char] = [string] return result"},{"question":"def process_queries(N, Q, queries): Process a list of queries to increment subarrays of a zero-initialized array. Args: N (int): Length of the array. Q (int): Number of queries. queries (List[Tuple[int, int, int]]): List of queries where each query is a tuple (L, R, X). Returns: List[int]: The final state of the array after processing all queries. >>> process_queries(5, 3, [(1, 3, 2), (2, 4, 3), (1, 5, 1)]) [3, 6, 6, 4, 1] >>> process_queries(1, 1, [(1, 1, 5)]) [5] >>> process_queries(5, 0, []) [0, 0, 0, 0, 0] >>> process_queries(5, 1, [(1, 5, 3)]) [3, 3, 3, 3, 3] >>> process_queries(5, 4, [(1, 1, 4), (2, 3, 2), (4, 5, 1), (2, 5, 3)]) [4, 5, 5, 4, 4]","solution":"def process_queries(N, Q, queries): A = [0] * N # Initialize the array with zeros for L, R, X in queries: for i in range(L-1, R): A[i] += X return A"},{"question":"def minDistance(word1: str, word2: str) -> int: Write a function that takes two strings \`word1\` and \`word2\` and returns the minimum number of operations required to convert \`word1\` to \`word2\`. The possible operations are: 1. Insert a character 2. Delete a character 3. Replace a character Each operation counts as one step. You need to determine the minimum steps required to achieve the conversion. >>> minDistance(\\"horse\\", \\"ros\\") 3 >>> minDistance(\\"intention\\", \\"execution\\") 5 >>> minDistance(\\"abc\\", \\"\\") 3 >>> minDistance(\\"\\", \\"abc\\") 3 >>> minDistance(\\"same\\", \\"same\\") 0 >>> minDistance(\\"a\\", \\"b\\") 1 >>> minDistance(\\"abcd\\", \\"dcba\\") 4","solution":"def minDistance(word1, word2): m = len(word1) n = len(word2) # Create a DP table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp[][] in bottom up manner for i in range(m + 1): for j in range(n + 1): # If first string is empty, only option is to # insert all characters of second string if i == 0: dp[i][j] = j # Min. operations = j # If second string is empty, only option is to # remove all characters of first string elif j == 0: dp[i][j] = i # Min. operations = i # If last characters are the same, ignore the last character # and recur for the remaining substring elif word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] # If the last character is different, consider all # possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"def compress(s: str) -> str: Compress a given string by appending a count of consecutive repeating characters. >>> compress(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compress(\\"abcdef\\") \\"a1b1c1d1e1f1\\"","solution":"def compress(s): Compress a given string by appending a count of consecutive repeating characters. Parameters: s (str): The input string to be compressed. Returns: str: A compressed string where each character is followed by the count of its consecutive repetitions. if not s: return \\"\\" result = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: result.append(f\\"{s[i-1]}{count}\\") count = 1 result.append(f\\"{s[-1]}{count}\\") return \\"\\".join(result)"},{"question":"class InventoryFullException(Exception): pass class ItemNotFoundException(Exception): pass class InvalidItemException(Exception): pass class Character: This class represents a character in a dungeon crawler game with an inventory that can hold up to 5 items and methods to manipulate the inventory and apply item effects. Attributes: health (int): The character's health points. mana (int): The character's mana points. strength (int): The character's strength points. defense (int): The character's defense points. inventory (list): The inventory holding items such as 'HP', 'MP', 'SE', 'DE'. Methods: __init__: Initializes the character's attributes and an empty inventory. add_item(item): Adds an item to the inventory if there is space. remove_item(item): Removes an item from the inventory if it exists. use_item(item): Applies the effect of the item and removes it from the inventory. def __init__(self, health=100, mana=40, strength=20, defense=30): Initialize with default attributes: health=100, mana=40, strength=20, defense=30, and an empty inventory. def add_item(self, item): Adds an item to the inventory if there is space (inventory capacity is 5). Raises InvalidItemException if the item is not valid. Raises InventoryFullException if the inventory is full. Args: item (str): The item to be added. Must be one of 'HP', 'MP', 'SE', 'DE'. def remove_item(self, item): Removes an item from the inventory if it exists. Raises ItemNotFoundException if the item is not in the inventory. Args: item (str): The item to be removed. Must be one of 'HP', 'MP', 'SE', 'DE'. def use_item(self, item): Applies the effect of the item and removes it from the inventory. Raises ItemNotFoundException if the item is not in the inventory. Args: item (str): The item to be used. Must be one of 'HP', 'MP', 'SE', 'DE'. # Example and test cases char = Character(health=100, mana=40, strength=20, defense=30) char.add_item('HP') char.add_item('MP') char.add_item('SE') char.add_item('DE') char.add_item('HP') char.add_item('MP') # This should raise InventoryFullException char.use_item('HP') # Health should now be 150 char.use_item('SE') char.use_item('DE') # Defense should now be 45","solution":"class InventoryFullException(Exception): pass class ItemNotFoundException(Exception): pass class InvalidItemException(Exception): pass class Character: def __init__(self, health=100, mana=40, strength=20, defense=30): self.health = health self.mana = mana self.strength = strength self.defense = defense self.inventory = [] self.inventory_capacity = 5 def add_item(self, item): if item not in ['HP', 'MP', 'SE', 'DE']: raise InvalidItemException(f\\"{item} is not a valid item.\\") if len(self.inventory) >= self.inventory_capacity: raise InventoryFullException(\\"Inventory is full. Cannot add more items.\\") self.inventory.append(item) def remove_item(self, item): if item not in self.inventory: raise ItemNotFoundException(f\\"{item} not found in inventory.\\") self.inventory.remove(item) def use_item(self, item): if item not in self.inventory: raise ItemNotFoundException(f\\"{item} not found in inventory.\\") if item == 'HP': self.health += 50 elif item == 'MP': self.mana += 30 elif item == 'SE': self.strength += 10 elif item == 'DE': self.defense += 15 self.inventory.remove(item)"},{"question":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring with no more than two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5 >>> length_of_longest_substring_two_distinct(\\"abcabcabc\\") 2 >>> length_of_longest_substring_two_distinct(\\"abaccc\\") 4 >>> length_of_longest_substring_two_distinct(\\"\\") 0 >>> length_of_longest_substring_two_distinct(\\"a\\") 1 >>> length_of_longest_substring_two_distinct(\\"aa\\") 2 >>> length_of_longest_substring_two_distinct(\\"aab\\") 3","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring with no more than two distinct characters. if len(s) == 0: return 0 max_len = 0 start = 0 char_map = {} for end in range(len(s)): char_map[s[end]] = char_map.get(s[end], 0) + 1 while len(char_map) > 2: char_map[s[start]] -= 1 if char_map[s[start]] == 0: del char_map[s[start]] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"def max_coins_sum(T: int, test_cases: list) -> list: Determine the maximum sum of values Harold can collect from each test case. Each test case consists of a list of coin values. Harold can start from any coin and collect coins while moving either to the left or to the right, but he cannot change direction once he starts moving. Args: T (int): The number of test cases. test_cases (list): A list of tuples, where each tuple contains: - an integer N, the number of coins. - a list of N integers representing the values of the coins. Returns: list: A list of integers, where each integer represents the maximum sum of values for the corresponding test case. Examples: >>> max_coins_sum(2, [(5, [1, -2, 3, 4, -1]), (3, [-1, -2, -3])]) [7, -1] >>> max_coins_sum(1, [(1, [100])]) [100] >>> max_coins_sum(1, [(5, [-1, -2, -3, -4, -5])]) [-1]","solution":"def max_coins_sum(T: int, test_cases: list) -> list: results = [] for i in range(T): N, coins = test_cases[i] max_sum = float('-inf') # Check max sum by moving to the right from any coin for start in range(N): current_sum = 0 for j in range(start, N): current_sum += coins[j] if current_sum > max_sum: max_sum = current_sum # Check max sum by moving to the left from any coin for start in range(N): current_sum = 0 for j in range(start, -1, -1): current_sum += coins[j] if current_sum > max_sum: max_sum = current_sum results.append(max_sum) return results # Example input T = 2 test_cases = [ (5, [1, -2, 3, 4, -1]), (3, [-1, -2, -3]) ] # Function call and printing results result = max_coins_sum(T, test_cases) for res in result: print(res)"},{"question":"def is_arithmetic_progression(n, sequence): Determines if the given sequence of n integers forms an arithmetic progression. Args: n: int - The number of elements in the sequence. sequence: list of int - The elements of the sequence. Returns: str: \\"YES\\" if the sequence is an arithmetic progression, otherwise \\"NO\\". Examples: >>> is_arithmetic_progression(5, [3, 6, 9, 12, 15]) 'YES' >>> is_arithmetic_progression(4, [1, 2, 4, 8]) 'NO'","solution":"def is_arithmetic_progression(n, sequence): Determines if the given sequence of n integers forms an arithmetic progression. Args: n: int - The number of elements in the sequence. sequence: list of int - The elements of the sequence. Returns: str: \\"YES\\" if the sequence is an arithmetic progression, otherwise \\"NO\\". if n < 2: return \\"NO\\" # Calculate the common difference common_difference = sequence[1] - sequence[0] # Check if the difference between consecutive elements is consistent for i in range(2, n): if sequence[i] - sequence[i - 1] != common_difference: return \\"NO\\" return \\"YES\\""},{"question":"def max_tasks(n: int, T: int, times: list[int]) -> int: Returns the maximum number of tasks that can be completed within the given time frame. :param n: int: number of tasks :param T: int: maximum total time allowed :param times: list of int: time required for each task :return: int: maximum number of tasks that can be completed","solution":"def max_tasks(n, T, times): Returns the maximum number of tasks that can be completed within the given time frame. :param n: int: number of tasks :param T: int: maximum total time allowed :param times: list of int: time required for each task :return: int: maximum number of tasks that can be completed times.sort() total_time = 0 count = 0 for time in times: if total_time + time <= T: total_time += time count += 1 else: break return count"},{"question":"def pairSum(nums, k): Determines if there are two distinct indices i and j in the array nums such that nums[i] + nums[j] equals k. Args: nums: list of int k: int Returns: bool: True if such indices exist, False otherwise. >>> pairSum([2, 7, 11, 15], 9) True >>> pairSum([1, 2, 3, 4], 8) False >>> pairSum([], 5) False >>> pairSum([-1, 1, 0, 2], 0) True","solution":"def pairSum(nums, k): Determines if there are two distinct indices i and j in the array nums such that nums[i] + nums[j] equals k. Args: nums: list of int k: int Returns: bool: True if such indices exist, False otherwise. seen = set() for num in nums: if k - num in seen: return True seen.add(num) return False"},{"question":"from typing import List def find_smallest_missing_prime(lst: List[int]) -> int: Finds the smallest missing prime number from the list. If all primes less than or equal to the maximum value are present, returns the next prime number greater than the maximum value in the list. >>> find_smallest_missing_prime([2, 3, 5, 7, 11, 13, 17]) == 19 >>> find_smallest_missing_prime([4, 6, 8, 10, 12, 14]) == 2 >>> find_smallest_missing_prime([2, 3, 5, 7, 10, 13, 17]) == 11 >>> find_smallest_missing_prime([7, 19, 3, 2, 23, 29]) == 5 >>> find_smallest_missing_prime([5, 7, 11, 13, 19, 23]) == 2 from solution import find_smallest_missing_prime def test_case_1(): assert find_smallest_missing_prime([2, 3, 5, 7, 11, 13, 17]) == 19 def test_case_2(): assert find_smallest_missing_prime([4, 6, 8, 10, 12, 14]) == 2 def test_case_3(): assert find_smallest_missing_prime([2, 3, 5, 7, 10, 13, 17]) == 11 def test_case_4(): assert find_smallest_missing_prime([7, 19, 3, 2, 23, 29]) == 5 def test_case_5(): assert find_smallest_missing_prime([5, 7, 11, 13, 19, 23]) == 2 def test_case_empty_list(): assert find_smallest_missing_prime([]) == 2 def test_case_all_non_prime_numbers(): assert find_smallest_missing_prime([4, 6, 8, 9, 10, 12]) == 2 def test_case_large_input(): assert find_smallest_missing_prime([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47]) == 37","solution":"def find_smallest_missing_prime(lst): Finds the smallest missing prime number from the list. If all primes less than or equal to the maximum value are present, returns the next prime number greater than the maximum value in the list. def sieve(n): Implements sieve of Eratosthenes to find all primes <= n is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if (is_prime[p] == True): for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 prime_numbers = [] for p in range(2, n + 1): if is_prime[p]: prime_numbers.append(p) return prime_numbers if not lst: return 2 # If the list is empty, the smallest prime is 2 max_val = max(lst) primes_up_to_max = sieve(max_val) primes_set = set(primes_up_to_max) list_set = set(lst) for prime in primes_up_to_max: if prime not in list_set: return prime # No missing primes, find the next prime after max_val num = max_val + 1 while True: is_prime = True for prime in primes_up_to_max: if prime * prime > num: break if num % prime == 0: is_prime = False break if is_prime: return num num += 1"},{"question":"def minimize_energy_gap(n: int, energies: List[int]) -> int: Function to minimize the maximum energy gap within a team. Parameters: - n: int, number of robots. - energies: list of int, energy levels of the robots. Returns: - int, the minimized maximum energy gap. Example: >>> minimize_energy_gap(6, [3, 6, 9, 1, 4, 8]) 1 >>> minimize_energy_gap(4, [10, 20, 30, 40]) 10 from solution import minimize_energy_gap def test_single_robot(): assert minimize_energy_gap(1, [7]) == 0 def test_example_1(): assert minimize_energy_gap(6, [3, 6, 9, 1, 4, 8]) == 1 def test_example_2(): assert minimize_energy_gap(4, [10, 20, 30, 40]) == 10 def test_all_equal_energies(): assert minimize_energy_gap(5, [5, 5, 5, 5, 5]) == 0 def test_sorted_energies(): assert minimize_energy_gap(3, [1, 2, 3]) == 1 def test_random_energies(): assert minimize_energy_gap(4, [5, 45, 15, 30]) == 10 def test_large_gap(): assert minimize_energy_gap(3, [1, 1000000000, 500]) == 499 def test_no_gap(): assert minimize_energy_gap(2, [50, 50]) == 0","solution":"def minimize_energy_gap(n, energies): Function to minimize the maximum energy gap within a team. Parameters: - n: int, number of robots. - energies: list of int, energy levels of the robots. Returns: - int, the minimized maximum energy gap. if n == 1: return 0 energies.sort() min_gap = float('inf') for i in range(1, n): min_gap = min(min_gap, energies[i] - energies[i-1]) return min_gap"},{"question":"def classify_number(num: int) -> str: Returns whether a number is 'perfect' or 'deficient'. >>> classify_number(6) == \\"perfect\\" # 6 is a perfect number because 1 + 2 + 3 = 6 >>> classify_number(28) == \\"perfect\\" # 28 is a perfect number because 1 + 2 + 4 + 7 + 14 = 28 >>> classify_number(8) == \\"deficient\\" # 8 is a deficient number because 1 + 2 + 4 < 8 >>> classify_number(10) == \\"deficient\\" # 10 is a deficient number because 1 + 2 + 5 < 10","solution":"def classify_number(num): Returns whether a number is 'perfect' or 'deficient'. if num <= 1: return \\"deficient\\" divisors_sum = sum(i for i in range(1, num) if num % i == 0) if divisors_sum == num: return \\"perfect\\" else: return \\"deficient\\""},{"question":"from typing import List, Tuple def most_frequent_substrings(t: int, test_cases: List[Tuple[int, int, str]]) -> List[List[str]]: Returns a list of results where each result contains the top k most frequent substrings of length m from the log. >>> most_frequent_substrings(2, [(2, 3, 'ababcababa'), (3, 2, 'abcabcabcabc')]) [['ab', 'ba', 'bc'], ['abc', 'bca']] >>> most_frequent_substrings(1, [(1, 1, 'aaaaa')]) [['a']]","solution":"from collections import Counter def most_frequent_substrings(t, test_cases): Returns a list of results where each result contains the top k most frequent substrings of length m from the log. results = [] for case in test_cases: m, k, log = case substrings = [log[i:i + m] for i in range(len(log) - m + 1)] frequency = Counter(substrings) sorted_substrings = sorted(frequency.items(), key=lambda x: (-x[1], x[0])) top_k = [substr[0] for substr in sorted_substrings[:k]] results.append(top_k) return results"},{"question":"def transform_array(t: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[str]: Perform the following transformation on array a according to array b: - For each integer bi in array b, find its corresponding index in array a. - If there are multiple such indices, pick the maximum one. - Remove the element at this index from array a and append it to the result array. If at any point, a value from b is not found in a, consider the transformation not possible and return \\"NO\\". Otherwise, return the transformed array in the order described. Args: t: The number of test cases. test_cases: A list of tuples, each containing n (number of elements in arrays), list \`a\` and list \`b\`. Returns: A list of strings, where each string is either \\"NO\\" if the transformation is not possible, or a space-separated list of transformed elements from array \`a\`. >>> transform_array(3, [(5, [4, 3, 2, 5, 1], [2, 3, 1, 5, 4]), (3, [1, 4, 2], [3, 4, 2]), (4, [6, 5, 7, 8], [8, 6, 5, 7])]) [\\"2 3 1 5 4\\", \\"NO\\", \\"8 6 5 7\\"] >>> transform_array(1, [(3, [4, 5, 6], [4, 9, 5])]) [\\"NO\\"] >>> transform_array(1, [(7, [2, 9, 7, 4, 3, 7, 9], [7, 3, 4, 9, 9, 2])]) [\\"7 3 4 9 9 2\\"] >>> transform_array(1, [(1, [1], [2])]) [\\"NO\\"] >>> transform_array(1, [(1, [1], [1])]) [\\"1\\"]","solution":"def transform_array(t, test_cases): results = [] for case in test_cases: n, a, b = case result = [] indices_container = {} # Save the index positions of elements in \`a\` for idx, value in enumerate(a): if value not in indices_container: indices_container[value] = [] indices_container[value].append(idx) # Process each element in \`b\` for value in b: if value not in indices_container or not indices_container[value]: results.append(\\"NO\\") break best_index = max(indices_container[value]) result.append(a[best_index]) indices_container[value].remove(best_index) else: results.append(\\" \\".join(map(str, result))) return results"},{"question":"def count_trees_lost_height(n: int, initial_heights: List[int], heights_after_storm: List[int]) -> int: Returns the number of trees that have lost height after the storm. >>> count_trees_lost_height(5, [3, 4, 1, 7, 8], [2, 4, 1, 5, 7]) 3 >>> count_trees_lost_height(4, [8, 6, 3, 5], [5, 6, 3, 3]) 2 >>> count_trees_lost_height(3, [5, 5, 5], [5, 5, 5]) 0 >>> count_trees_lost_height(3, [5, 7, 6], [3, 4, 2]) 3 >>> count_trees_lost_height(4, [5, 6, 7, 8], [5, 6, 7, 8]) 0","solution":"def count_trees_lost_height(n, initial_heights, heights_after_storm): Returns the number of trees that have lost height after the storm. count = 0 for initial, after in zip(initial_heights, heights_after_storm): if initial > after: count += 1 return count"},{"question":"def number_of_plants(initial_plants: int, days: int) -> int: Returns the number of plants at the end of the given period. >>> number_of_plants(3, 2) 12 >>> number_of_plants(3, 0) 3 >>> number_of_plants(10, 1) 20","solution":"def number_of_plants(initial_plants, days): Returns the number of plants at the end of the given period. :param initial_plants: int - initial number of plants :param days: int - number of days after which to calculate the number of plants :return: int - number of plants at the end of the given period return initial_plants * (2 ** days)"},{"question":"def optimal_play(a, b): Determines the winner of the game given two integers a and b. Returns \\"Alice\\" if Alice wins and \\"Bob\\" if Bob wins. # Implementation here def determine_winner(test_cases): Determines the winner for each set of test cases. Returns a list of results corresponding to each test case. # Implementation here # Unit tests def test_optimal_play(): assert optimal_play(7, 4) == \\"Alice\\" assert optimal_play(15, 10) == \\"Alice\\" assert optimal_play(5, 5) == \\"Alice\\" assert optimal_play(8, 6) == \\"Bob\\" assert optimal_play(2, 20) == \\"Bob\\" def test_determine_winner(): test_cases = [(7, 4), (15, 10), (5, 5), (8, 6), (2, 20)] expected = [\\"Alice\\", \\"Alice\\", \\"Alice\\", \\"Bob\\", \\"Bob\\"] assert determine_winner(test_cases) == expected test_cases = [(10, 2), (1, 1), (6, 6), (13, 10), (4, 6)] expected = [\\"Bob\\", \\"Alice\\", \\"Bob\\", \\"Alice\\", \\"Bob\\"] assert determine_winner(test_cases) == expected","solution":"def optimal_play(a, b): Determines the winner of the game given two integers a and b. Returns \\"Alice\\" if Alice wins and \\"Bob\\" if Bob wins. # Alice will win if a or b is odd to start with. # Bob will win if both a and b are even to start with. if (a % 2 == 0) and (b % 2 == 0): return \\"Bob\\" else: return \\"Alice\\" def determine_winner(test_cases): results = [] for a, b in test_cases: results.append(optimal_play(a, b)) return results"},{"question":"def hex_string_prime(s: str) -> str: Convert the given hexadecimal string to an integer and check whether the number is prime. Args: s (str): A string consisting of digits from '0' to '9' and characters 'a' to 'f'. Returns: str: \\"Prime\\" if the integer is prime, otherwise \\"Not Prime\\". Examples: >>> hex_string_prime(\\"11\\") \\"Prime\\" >>> hex_string_prime(\\"2a\\") \\"Not Prime\\"","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def hex_string_prime(s): num = int(s, 16) return \\"Prime\\" if is_prime(num) else \\"Not Prime\\""},{"question":"def maxProfit(prices): Returns the maximum profit that can be achieved by buying and selling fish. Example: >>> maxProfit([7, 1, 5, 3, 6, 4]) 7 >>> maxProfit([1, 2, 3, 4, 5]) 4 >>> maxProfit([7, 6, 4, 3, 1]) 0 >>> maxProfit([5]) 0 >>> maxProfit([]) 0 >>> maxProfit([3, 3, 3, 3, 3]) 0","solution":"def maxProfit(prices): Returns the maximum profit that can be achieved by buying and selling fish. max_profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"from typing import List def countPaths(grid: List[List[str]]) -> int: Computes the number of unique paths from the top-left to the bottom-right corner of the maze. >>> grid = [ ... ['.', '.', '.'], ... ['.', '#', '.'], ... ['.', '.', '.'] ... ] >>> countPaths(grid) 2 >>> grid = [ ... ['.', '#'], ... ['#', '.'] ... ] >>> countPaths(grid) 0","solution":"def countPaths(grid): m, n = len(grid), len(grid[0]) # If starting or ending cell is a wall, return 0 if grid[0][0] == '#' or grid[m-1][n-1] == '#': return 0 # Initialize a 2D dp array with zeroes dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Starting point # Fill the dp array for i in range(m): for j in range(n): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def second_smallest_number(nums): Returns the second smallest number in the list \`nums\`. Args: nums: List of integers Returns: Integer: The second smallest number in the list >>> second_smallest_number([3, 1, 5, 2, 4]) 2 >>> second_smallest_number([1, 2]) 2 >>> second_smallest_number([-1, -2, -3, -4]) -3 >>> second_smallest_number([1000, -1000]) 1000 >>> second_smallest_number([4, 4, 4, 4, 4, 4, 2, 2, 2]) 4 >>> second_smallest_number([1, 1, -1]) 1 >>> second_smallest_number([1, 1, 1, 1, 1, 1, 1, 1]) None >>> second_smallest_number([-1000, -1000, -999, -999]) -999","solution":"def second_smallest_number(nums): Returns the second smallest number in the list \`nums\`. Args: nums: List of integers Returns: Integer: The second smallest number in the list unique_nums = list(set(nums)) # Remove duplicates unique_nums.sort() return unique_nums[1] if len(unique_nums) > 1 else None"},{"question":"def max_last_element(n: int, arr: List[int]) -> int: Given an array of n integers, return the maximum possible value of the last remaining element after performing the allowed operations. >>> max_last_element(4, [1, 2, 3, 4]) 10 >>> max_last_element(3, [5, 5, 5]) 15 >>> max_last_element(3, [1000000000, 1000000000, 1000000000]) 3000000000 >>> max_last_element(5, [1, 2, 3, 4, 5]) 15 >>> max_last_element(2, [7, 10]) 17","solution":"def max_last_element(n, arr): Given an array of n integers, return the maximum possible value of the last remaining element after performing the allowed operations. return sum(arr)"},{"question":"def palindrome_permutation(s: str) -> bool: Returns True if any permutation of the input string could form a palindrome. >>> palindrome_permutation(\\"aabb\\") True >>> palindrome_permutation(\\"aabbc\\") True >>> palindrome_permutation(\\"abc\\") False >>> palindrome_permutation(\\"Taco cat\\") True >>> palindrome_permutation(\\"RaceCar\\") True >>> palindrome_permutation(\\"Tact Coa\\") True >>> palindrome_permutation(\\"\\") True >>> palindrome_permutation(\\"a\\") True >>> palindrome_permutation(\\"abcde\\") False","solution":"from collections import Counter def palindrome_permutation(s): Returns True if any permutation of the input string could form a palindrome. # Remove non-letter characters and convert to lowercase cleaned = ''.join(filter(str.isalpha, s.lower())) # Count the frequency of each character counter = Counter(cleaned) # Palindrome can have at most one character with an odd count odd_count = sum(1 for count in counter.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def final_position(directions: str) -> int: Determines the final position on the number line after following the directions. Parameters: directions (str): A string of 'R' and 'L' characters. Returns: int: The final position on the number line. >>> final_position(\\"RRRR\\") 4 >>> final_position(\\"LLLL\\") -4 >>> final_position(\\"RLRL\\") 0 >>> final_position(\\"RRLLR\\") 1 >>> final_position(\\"R\\") 1 >>> final_position(\\"L\\") -1","solution":"def final_position(directions): Determines the final position on the number line after following the directions. Parameters: directions (str): A string of 'R' and 'L' characters. Returns: int: The final position on the number line. position = 0 for direction in directions: if direction == 'R': position += 1 elif direction == 'L': position -= 1 return position"},{"question":"def count_peaks_in_city_map(input_str: str) -> int: Count the number of peaks in the given city map grid. A peak is defined as a building whose height is greater than or equal to the heights of all its adjacent buildings (considering the buildings adjacent horizontally, vertically, and diagonally). >>> count_peaks_in_city_map('3 3n1 2 1n2 3 2n1 2 1') 1 >>> count_peaks_in_city_map('4 4n3 3 3 3n3 4 4 3n3 4 4 3n3 3 3 3') 4 >>> count_peaks_in_city_map('2 2n9 1n1 1') 1 >>> count_peaks_in_city_map('2 2n9 9n9 9') 4 >>> count_peaks_in_city_map('3 3n1 1 1n1 1 1n1 1 1') 9","solution":"def count_peaks(grid): def is_peak(grid, i, j): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[ni][nj] > grid[i][j]: return False return True n = len(grid) m = len(grid[0]) peak_count = 0 for i in range(n): for j in range(m): if is_peak(grid, i, j): peak_count += 1 return peak_count def parse_input(input_str): lines = input_str.strip().split('n') n, m = map(int, lines[0].split()) grid = [list(map(int, line.split())) for line in lines[1:]] return grid def count_peaks_in_city_map(input_str): grid = parse_input(input_str) return count_peaks(grid)"},{"question":"def calculate_salary(hourly_wage, hours_worked, overtime): Calculate the total salary based on hourly wage, hours worked and overtime policy. Args: hourly_wage (float): The hourly wage of the employee. hours_worked (float): The number of hours worked by the employee. overtime (bool): Whether overtime pay applies. Returns: float: The total salary rounded to 2 decimal places. pass def sort_employees_by_salary(employee_records): Sorts employees by their total salary in descending order, and by name alphabetically if salaries are the same. Args: employee_records (list): List of employee records, where each record is a dictionary containing: 'name' (str): The name of the employee. 'hourly_wage' (float): The hourly wage of the employee. 'hours_worked' (float): The number of hours worked by the employee. 'overtime' (bool): Whether overtime pay applies. Returns: list: A list of employee names sorted by total salary in descending order and by name alphabetically if needed. pass","solution":"def calculate_salary(hourly_wage, hours_worked, overtime): Calculate the total salary based on hourly wage, hours worked and overtime policy. Args: hourly_wage (float): The hourly wage of the employee. hours_worked (float): The number of hours worked by the employee. overtime (bool): Whether overtime pay applies. Returns: float: The total salary rounded to 2 decimal places. standard_hours = 40 if hours_worked <= standard_hours: total_salary = hourly_wage * hours_worked else: if overtime: total_salary = (hourly_wage * standard_hours) + ((hours_worked - standard_hours) * hourly_wage * 1.5) else: total_salary = hourly_wage * hours_worked return round(total_salary, 2) def sort_employees_by_salary(employee_records): Sorts employees by their total salary in descending order, and by name alphabetically if salaries are the same. Args: employee_records (list): List of employee records, where each record is a dictionary containing: 'name' (str): The name of the employee. 'hourly_wage' (float): The hourly wage of the employee. 'hours_worked' (float): The number of hours worked by the employee. 'overtime' (bool): Whether overtime pay applies. Returns: list: A list of employee names sorted by total salary in descending order and by name alphabetically if needed. salaries_with_names = [] for employee in employee_records: salary = calculate_salary(employee['hourly_wage'], employee['hours_worked'], employee['overtime']) salaries_with_names.append((salary, employee['name'])) # Sort primarily by salary in descending order and by name in ascending order for ties salaries_with_names.sort(key=lambda x: (-x[0], x[1])) sorted_names = [name for salary, name in salaries_with_names] return sorted_names"},{"question":"def create_sequence(n: int) -> List[int]: Creates and returns a sequence of length n either in arithmetic or geometric progression. >>> create_sequence(5) [1, 3, 5, 7, 9] >>> create_sequence(4) [1, 2, 4, 8] >>> create_sequence(6) [2, 4, 6, 9, 12, 15] >>> create_sequence(1) [1]","solution":"def create_sequence(n): Creates and returns a sequence of length n either in arithmetic or geometric progression. if n == 1: return [1] sequence = [] if n % 2 == 0: # Generate geometric progression starting with 1, ratio 2 current = 1 for _ in range(n): sequence.append(current) current *= 2 else: # Generate arithmetic progression starting with 1, difference 2 current = 1 for _ in range(n): sequence.append(current) current += 2 return sequence"},{"question":"def rotateArray(A, k): Rotates the elements of the array A to the right by k steps. >>> rotateArray([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotateArray([-1, -100, 3, 99], 2) [3, 99, -1, -100]","solution":"def rotateArray(A, k): Rotates the elements of the array A to the right by k steps. n = len(A) k = k % n # Ensure k is within the bounds of A's length to prevent unnecessary rotations return A[-k:] + A[:-k]"},{"question":"def update_inventory(current_inventory: dict, shipment_inventory: dict) -> dict: Updates the current_inventory dictionary by adding the quantities from the shipment_inventory. If an item from the shipment_inventory does not exist in the current_inventory, it is added. Args: - current_inventory (dict): A dictionary representing existing stock in the warehouse. - shipment_inventory (dict): A dictionary representing new items received in the shipment. Returns: - dict: Updated inventory with quantities adjusted based on the shipment. Example: >>> current_inventory = {\\"apple\\": 10, \\"banana\\": 5, \\"orange\\": 7} >>> shipment_inventory = {\\"banana\\": 3, \\"orange\\": 12, \\"grape\\": 10} >>> update_inventory(current_inventory, shipment_inventory) {\\"apple\\": 10, \\"banana\\": 8, \\"orange\\": 19, \\"grape\\": 10}","solution":"def update_inventory(current_inventory, shipment_inventory): Updates the current_inventory dictionary by adding the quantities from the shipment_inventory. If an item from the shipment_inventory does not exist in the current_inventory, it is added. Args: - current_inventory (dict): A dictionary representing existing stock in the warehouse. - shipment_inventory (dict): A dictionary representing new items received in the shipment. Returns: - dict: Updated inventory with quantities adjusted based on the shipment. for item, qty in shipment_inventory.items(): if item in current_inventory: current_inventory[item] += qty else: current_inventory[item] = qty return current_inventory"},{"question":"from typing import List def find_three_numbers(arr: List[int], target: int) -> List[int]: Given an array of integers and a target value, determine if any three integers in the array sum up to the target value. Return those three integers in ascending order if they exist, otherwise return an empty list. You can assume that each input would have exactly one solution. >>> find_three_numbers([1, 2, 4, 6, 8, 10], 14) [2, 4, 8] >>> find_three_numbers([3, 7, 1, 9, 5, 3], 12) [] >>> find_three_numbers([0, -1, 2, -3, 1], 0) [-3, 1, 2] >>> find_three_numbers([1, 2, 3, 4, 5], 20) [] >>> find_three_numbers([12, 3, 4, 1, 6, 9], 24) [3, 9, 12]","solution":"def find_three_numbers(arr, target): Finds three integers in arr that sum up to target. Returns those three integers in ascending order if they exist, otherwise returns an empty list. arr.sort() n = len(arr) for i in range(n-2): left, right = i+1, n-1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return [arr[i], arr[left], arr[right]] elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"def calculate_total_scores(P: int, Q: int, submissions: List[Tuple[int, int, int]]) -> List[int]: Calculate the total scores for each participant based on their highest submissions for each problem. :param P: int, number of participants :param Q: int, number of problems :param submissions: list of tuples, each tuple contains (participant_id, problem_id, score) :return: list of int, total score for each participant >>> calculate_total_scores(3, 4, [ ... (1, 1, 70), (1, 1, 85), (1, 2, 90), ... (2, 1, 60), (3, 2, 75), (3, 3, 80), (3, 3, 95)]) [175, 60, 170] >>> calculate_total_scores(2, 2, [ ... (1, 1, 10), (1, 2, 10), ... (2, 1, 10), (2, 2, 10)]) [20, 20] >>> calculate_total_scores(3, 3, []) [0, 0, 0] >>> calculate_total_scores(1, 1, [(1, 1, 50)]) [50] >>> calculate_total_scores(3, 1, [ ... (1, 1, 20), (1, 1, 25), ... (2, 1, 30), (2, 1, 30), ... (3, 1, 10)]) [25, 30, 10] >>> calculate_total_scores(2, 2, [ ... (1, 1, 45), (1, 2, 55), (1, 2, 50), ... (2, 1, 40), (2, 2, 60), (2, 1, 50)]) [100, 110]","solution":"def calculate_total_scores(P, Q, submissions): Calculate the total scores for each participant based on their highest submissions for each problem. :param P: int, number of participants :param Q: int, number of problems :param submissions: list of tuples, each tuple contains (participant_id, problem_id, score) :return: list of int, total score for each participant from collections import defaultdict # Dictionary to track the highest score for each (participant, problem) pair scores = defaultdict(lambda: defaultdict(int)) # Process each submission for participant_id, problem_id, score in submissions: if score > scores[participant_id][problem_id]: scores[participant_id][problem_id] = score # Calculate the total score for each participant total_scores = [0] * P for participant_id in range(1, P + 1): total_scores[participant_id - 1] = sum(scores[participant_id].values()) return total_scores # Example use case (uncomment following lines to test manually) # submissions_input = [ # (1, 1, 70), (1, 1, 85), (1, 2, 90), # (2, 1, 60), (3, 2, 75), (3, 3, 80), (3, 3, 95) # ] # P, Q = 3, 4 # print(calculate_total_scores(P, Q, submissions_input))"},{"question":"from typing import List, Set def max_unique_genres(n: int, packs: List[Set[int]]) -> int: Computes the maximum number of unique genres that can be obtained by selecting a subset of the packs. >>> max_unique_genres(3, [{1, 2}, {2, 3}, {3, 4}]) 4 >>> max_unique_genres(1, [{1, 2, 3}]) 3 >>> max_unique_genres(2, [{1, 2}, {3, 4}]) 4 >>> max_unique_genres(3, [{1, 2}, {1, 2}, {1, 2}]) 2 >>> max_unique_genres(3, [{1, 2}, {2, 3}, {3, 1}]) 3 >>> max_unique_genres(0, []) 0 def parse_input(input_data: str) -> (int, List[Set[int]]): Parses input data and returns the number of packs and the list of sets of genres in each pack. >>> parse_input(\\"3n1 2n2 3n3 4n\\") (3, [{1, 2}, {2, 3}, {3, 4}]) >>> parse_input(\\"1n1 2 3n\\") (1, [{1, 2, 3}])","solution":"from itertools import combinations def max_unique_genres(n, packs): Computes the maximum number of unique genres that can be obtained by selecting a subset of the packs. max_genres = 0 # Iterate over all possible subsets of packs for r in range(1, n + 1): for subset in combinations(packs, r): unique_genres = set() for pack in subset: unique_genres.update(pack) max_genres = max(max_genres, len(unique_genres)) return max_genres def parse_input(input_data): lines = input_data.strip().split('n') n = int(lines[0]) packs = [set(map(int, line.split())) for line in lines[1:]] return n, packs"},{"question":"def sort_and_merge_marbles(marbles): Sort and merge marbles in descending order. Each robot receives exactly half of the marbles, and each marble has a unique size. Given a list of sizes, your task is first to split this list into two parts such that each part has the same length and can be individually sorted. After sorting both parts, combine the two sorted sequences into one while maintaining the overall order. Parameters: marbles (list): List of integers' representing marble sizes. Returns: list: Combined list in descending order. Example: >>> sort_and_merge_marbles([12, 7, 5, 3, 14, 8]) [14, 12, 8, 7, 5, 3] >>> sort_and_merge_marbles([0, 0, 0, 0]) [0, 0, 0, 0] >>> sort_and_merge_marbles([1, 3, 2, 4]) [4, 3, 2, 1] from solution import sort_and_merge_marbles def test_sort_and_merge_basic(): assert sort_and_merge_marbles([12, 7, 5, 3, 14, 8]) == [14, 12, 8, 7, 5, 3] def test_sort_and_merge_with_zero(): assert sort_and_merge_marbles([0, 0, 0, 0]) == [0, 0, 0, 0] def test_sort_and_merge_mixed_order(): assert sort_and_merge_marbles([1, 3, 2, 4]) == [4, 3, 2, 1] def test_sort_and_merge_larger_numbers(): assert sort_and_merge_marbles([10, 20, 30, 40, 50, 60]) == [60, 50, 40, 30, 20, 10] def test_sort_and_merge_negative_numbers(): assert sort_and_merge_marbles([-10, -20, -30, -5, -15, -25]) == [-5, -10, -15, -20, -25, -30]","solution":"def sort_and_merge_marbles(marbles): Sort and merge marbles in descending order. Parameters: marbles (list): List of integers' representing marble sizes. Returns: list: Combined list in descending order. mid = len(marbles) // 2 part1 = sorted(marbles[:mid], reverse=True) part2 = sorted(marbles[mid:], reverse=True) # Merge the two sorted lists combined = [] i, j = 0, 0 while i < len(part1) and j < len(part2): if part1[i] > part2[j]: combined.append(part1[i]) i += 1 else: combined.append(part2[j]) j += 1 if i < len(part1): combined.extend(part1[i:]) if j < len(part2): combined.extend(part2[j:]) return combined"},{"question":"def find_shortest_paths(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]], int]]) -> List[List[Union[int, str]]]: Finds the shortest path from a starting attraction to all other attractions in a city with a given network of paths. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int, int]], int]]): A list containing information about each test case. Each test case is a tuple consisting of: - n (int): number of attractions. - m (int): number of paths. - edges (List[Tuple[int, int, int]]): List of paths in the format (start, end, time). - s (int): starting attraction. Returns: List[List[Union[int, str]]]: A list of results for each test case, where each result is a list of minimum travel times from the starting attraction to all other attractions. If an attraction is not reachable, the travel time is \\"INF\\". Example: >>> t = 2 >>> test_cases = [ ... (4, 4, [(0, 1, 1), (0, 2, 4), (1, 2, 2), (2, 3, 1)], 0), ... (3, 3, [(0, 1, 2), (1, 2, 3), (0, 2, 5)], 1) ... ] >>> find_shortest_paths(t, test_cases) [[0, 1, 3, 4], ['INF', 0, 3]]","solution":"import heapq def dijkstra(n, edges, start): graph = [[] for _ in range(n)] for u, v, w in edges: graph[u].append((w, v)) distances = [float('inf')] * n distances[start] = 0 min_heap = [(0, start)] while min_heap: current_distance, u = heapq.heappop(min_heap) if current_distance > distances[u]: continue for weight, v in graph[u]: distance = current_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(min_heap, (distance, v)) return distances def find_shortest_paths(t, test_cases): results = [] for i in range(t): n, m, edges, s = test_cases[i] distances = dijkstra(n, edges, s) normalized_distances = [\\"INF\\" if d == float('inf') else d for d in distances] results.append(normalized_distances) return results"},{"question":"def calculate_average_scores(students): Accepts a list of dictionaries containing students' names and their test scores. Returns a new list of dictionaries with students' names and their average scores. >>> students = [{\\"name\\": \\"Alice\\", \\"scores\\": [85, 90, 78]}, {\\"name\\": \\"Bob\\", \\"scores\\": [72, 88, 91]}, {\\"name\\": \\"Charlie\\", \\"scores\\": [92, 87, 85]}] >>> calculate_average_scores(students) [{\\"name\\": \\"Alice\\", \\"average\\": 84.33}, {\\"name\\": \\"Bob\\", \\"average\\": 83.67}, {\\"name\\": \\"Charlie\\", \\"average\\": 88.00}] >>> students = [{\\"name\\": \\"Daniel\\", \\"scores\\": [80, 85, 90]}] >>> calculate_average_scores(students) [{\\"name\\": \\"Daniel\\", \\"average\\": 85.00}] >>> students = [{\\"name\\": \\"Eve\\", \\"scores\\": [50, 60, 70, 80, 90]}, {\\"name\\": \\"Frank\\", \\"scores\\": [95, 85]}] >>> calculate_average_scores(students) [{\\"name\\": \\"Eve\\", \\"average\\": 70.00}, {\\"name\\": \\"Frank\\", \\"average\\": 90.00}]","solution":"def calculate_average_scores(students): Accepts a list of dictionaries containing students' names and their test scores. Returns a new list of dictionaries with students' names and their average scores. result = [] for student in students: name = student[\\"name\\"] scores = student[\\"scores\\"] average_scores = round(sum(scores) / len(scores), 2) result.append({\\"name\\": name, \\"average\\": average_scores}) return result"},{"question":"def max_climbs(n: int, heights: List[int]) -> int: Determines the maximum number of climbs that can be made such that each climb increases in height consecutively and a rest day is taken after each climb. Parameters: n (int): The number of mountains. heights (list of ints): The list of mountain heights. Returns: int: The maximum number of climbs. pass # Example test cases def test_max_climbs_example_1(): assert max_climbs(7, [2, 3, 4, 2, 5, 6, 7]) == 3 def test_max_climbs_example_2(): assert max_climbs(5, [10, 20, 30, 40, 50]) == 2 def test_max_climbs_example_3(): assert max_climbs(6, [5, 4, 3, 2, 1, 6]) == 1 def test_max_climbs_single_mountain(): assert max_climbs(1, [1]) == 0 def test_max_climbs_all_decreasing_heights(): assert max_climbs(4, [10, 9, 8, 7]) == 0 def test_max_climbs_all_equal_heights(): assert max_climbs(4, [5, 5, 5, 5]) == 0 def test_max_climbs_alternating_heights(): assert max_climbs(6, [1, 2, 1, 2, 1, 2]) == 1","solution":"def max_climbs(n, heights): Determines the maximum number of climbs that can be made such that each climb increases in height consecutively and a rest day is taken after each climb. Parameters: n (int): The number of mountains. heights (list of ints): The list of mountain heights. Returns: int: The maximum number of climbs. climbs = 0 current_height = -1 # Initially setting to a value lower than any possible mountain height for height in heights: if height > current_height: climbs += 1 current_height = height return climbs // 2 # Due to resting day after each climb"},{"question":"def maxEqualZeroesOnes(S: str) -> int: Given a string containing only characters '0' and '1', find the length of the longest contiguous subarray that contains an equal number of '0's and '1's. >>> maxEqualZeroesOnes(\\"1100011\\") 6 >>> maxEqualZeroesOnes(\\"111000\\") 6 >>> maxEqualZeroesOnes(\\"000000\\") 0 >>> maxEqualZeroesOnes(\\"111111\\") 0 >>> maxEqualZeroesOnes(\\"10101\\") 4 >>> maxEqualZeroesOnes(\\"100110\\") 6 >>> maxEqualZeroesOnes(\\"0\\") 0 >>> maxEqualZeroesOnes(\\"1\\") 0 >>> maxEqualZeroesOnes(\\"01\\"*50000) 100000 >>> maxEqualZeroesOnes(\\"10\\"*50000) 100000","solution":"def maxEqualZeroesOnes(S): Returns the length of the longest contiguous subarray with equal number of '0's and '1's. max_len = 0 hashmap = {} count = 0 for i in range(len(S)): if S[i] == '0': count -= 1 else: count += 1 if count == 0: max_len = i + 1 if count in hashmap: max_len = max(max_len, i - hashmap[count]) else: hashmap[count] = i return max_len"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Write a function that takes a string \`s\` and returns the length of the longest substring that can be rearranged to form a palindrome. >>> longest_palindromic_substring_length(\\"abccccdd\\") 7 >>> longest_palindromic_substring_length(\\"a\\") 1 >>> longest_palindromic_substring_length(\\"aa\\") 2 from solution import longest_palindromic_substring_length def test_example_cases(): assert longest_palindromic_substring_length(\\"abccccdd\\") == 7 assert longest_palindromic_substring_length(\\"a\\") == 1 assert longest_palindromic_substring_length(\\"aa\\") == 2 def test_mixed_characters(): assert longest_palindromic_substring_length(\\"abcba\\") == 5 assert longest_palindromic_substring_length(\\"abacaba\\") == 7 def test_all_characters_odd(): assert longest_palindromic_substring_length(\\"abcde\\") == 1 def test_all_characters_even(): assert longest_palindromic_substring_length(\\"aabbcc\\") == 6 def test_long_string(): s = \\"a\\" * 100000 # All characters the same assert longest_palindromic_substring_length(s) == 100000 def test_empty_string(): assert longest_palindromic_substring_length(\\"\\") == 0","solution":"def longest_palindromic_substring_length(s: str) -> int: from collections import Counter # Count occurrences of each character in the string freq = Counter(s) # Variables to store the length of the longest palindromic substring length = 0 odd_count_found = False # Iterate over the frequency dictionary for count in freq.values(): if count % 2 == 0: length += count else: length += count - 1 odd_count_found = True # If any odd count was found, we can add one more character to the length if odd_count_found: length += 1 return length"},{"question":"from typing import List, Tuple def is_valid_triangle(a: Tuple[int, int], b: Tuple[int, int], c: Tuple[int, int]) -> bool: Check if three points a, b, c form a valid triangle. The area of the triangle must be non-zero. @param a: tuple containing the first point's coordinates (x, y) @param b: tuple containing the second point's coordinates (x, y) @param c: tuple containing the third point's coordinates (x, y) @return: bool indicating whether the points can form a valid triangle def can_form_triangle(points: List[Tuple[int, int]]) -> str: Determine if there exists a set of three points among the given points that can form a valid triangle. @param points: list of tuples containing the coordinates of the points @return: \\"YES\\" if any three points can form a valid triangle, otherwise \\"NO\\" def test_is_valid_triangle(): assert is_valid_triangle((0, 0), (1, 1), (0, 1)) == True assert is_valid_triangle((0, 0), (1, 1), (2, 2)) == False assert is_valid_triangle((1, 1), (2, 3), (3, 2)) == True assert is_valid_triangle((0, 0), (0, 1), (0, 2)) == False def test_can_form_triangle_yes(): points = [(0, 0), (1, 0), (0, 1), (1, 1)] assert can_form_triangle(points) == \\"YES\\" def test_can_form_triangle_no(): points = [(0, 0), (1, 1), (2, 2)] assert can_form_triangle(points) == \\"NO\\" def test_can_form_triangle_edge_cases(): points = [(0, 0), (0, 0), (0, 0)] assert can_form_triangle(points) == \\"NO\\" points = [(0, 0), (1, 1), (1, 0), (0, 3)] assert can_form_triangle(points) == \\"YES\\" points = [(-10**4, -10**4), (0, 0), (10**4, 10**4)] assert can_form_triangle(points) == \\"NO\\" points = [(0, 0), (1, 1), (-1, -1), (2, 3)] assert can_form_triangle(points) == \\"YES\\" # Run the tests if __name__ == \\"__main__\\": test_is_valid_triangle() test_can_form_triangle_yes() test_can_form_triangle_no() test_can_form_triangle_edge_cases() print(\\"All tests passed!\\")","solution":"def is_valid_triangle(a, b, c): Check if three points a, b, c form a valid triangle. The area of the triangle must be non-zero. # a, b, c are tuples of the form (x, y) (x1, y1), (x2, y2), (x3, y3) = a, b, c # The determinant of the matrix formed by the vectors # (x2 - x1, y2 - y1) and (x3 - x1, y3 - y1) should be non-zero area = abs((x1*(y2 - y3)) + (x2*(y3 - y1)) + (x3*(y1 - y2))) return area != 0 def can_form_triangle(points): Determine if there exists a set of three points among the given points that can form a valid triangle. n = len(points) for i in range(n): for j in range(i+1, n): for k in range(j+1, n): if is_valid_triangle(points[i], points[j], points[k]): return \\"YES\\" return \\"NO\\""},{"question":"def is_palindrome(s: str) -> bool: Checks whether the given string is a palindrome, ignoring case, spaces, and punctuation. Args: s (str): The input string. Returns: bool: True if the input string is a palindrome, False otherwise. Examples: >>> is_palindrome(\\"A man a plan a canal Panama\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"Deified\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"12345\\") False >>> is_palindrome(\\"This is not a palindrome\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True","solution":"import re def is_palindrome(s): Checks whether the given string is a palindrome, ignoring case, spaces, and punctuation. Args: s (str): The input string. Returns: bool: True if the input string is a palindrome, False otherwise. # Remove non-alphanumeric characters and convert to lowercase cleaned_s = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if the cleaned string is equal to its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"from typing import List def generate_strings(s: str) -> List[str]: Replace the wildcard character '*' in string 's' with digits from 0 to 9 and return all possible strings in lexicographical order. >>> generate_strings(\\"1*3\\") [\\"103\\", \\"113\\", \\"123\\", \\"133\\", \\"143\\", \\"153\\", \\"163\\", \\"173\\", \\"183\\", \\"193\\"] >>> generate_strings(\\"*567\\") [\\"0567\\", \\"1567\\", \\"2567\\", \\"3567\\", \\"4567\\", \\"5567\\", \\"6567\\", \\"7567\\", \\"8567\\", \\"9567\\"] >>> generate_strings(\\"789*\\") [\\"7890\\", \\"7891\\", \\"7892\\", \\"7893\\", \\"7894\\", \\"7895\\", \\"7896\\", \\"7897\\", \\"7898\\", \\"7899\\"]","solution":"from typing import List def generate_strings(s: str) -> List[str]: Replace the wildcard character '*' in string 's' with digits from 0 to 9 and return all possible strings in lexicographical order. if '*' not in s or s.count('*') != 1: raise ValueError(\\"Input string must contain exactly one '*' wildcard character.\\") results = [] for digit in range(10): results.append(s.replace('*', str(digit))) return results"},{"question":"def min_training_groups(N: int, M: int, topic_knowledge: List[List[int]]) -> int: Determines the minimum number of training groups required to cover all topics. Parameters: N (int): The number of employees. M (int): The number of topics. topic_knowledge (list of lists): Each list contains integers indicating employees knowledgeable in a topic. Returns: int: The minimum number of training groups needed. Examples: >>> min_training_groups(6, 3, [[2, 0, 1], [3, 0, 2, 3], [2, 1, 4]]) 2 >>> min_training_groups(0, 3, [[], [], []]) 0 >>> min_training_groups(3, 3, [[1, 0], [1, 1], [1, 2]]) 3 >>> min_training_groups(4, 1, [[4, 0, 1, 2, 3]]) 1 >>> min_training_groups(4, 3, [[4, 0, 1, 2, 3], [4, 0, 1, 2, 3], [4, 0, 1, 2, 3]]) 1","solution":"def min_training_groups(N, M, topic_knowledge): Determines the minimum number of training groups required to cover all topics. Parameters: N (int): The number of employees. M (int): The number of topics. topic_knowledge (list of lists): Each list contains integers indicating employees knowledgeable in a topic. Returns: int: The minimum number of training groups needed. from itertools import combinations # Create a list of sets where each set contains the employees knowledgeable in each topic topics = [set(knowledge[1:]) for knowledge in topic_knowledge] # Determine all possible combinations of employees all_employees = set(range(N)) for i in range(1, N + 1): for combo in combinations(all_employees, i): covered_topics = set() for emp in combo: for t_index, t_employees in enumerate(topics): if emp in t_employees: covered_topics.add(t_index) if len(covered_topics) == M: return i return N"},{"question":"def findBalancedIndex(nums: List[int]) -> int: Given a list of integers, finds the index in the list where the sum of the integers to the left of the index is equal to the sum of the integers to the right of the index. If no such index exists, the function should return -1. >>> findBalancedIndex([1, 2, 3, 4, 6]) 3 >>> findBalancedIndex([1, 2, 3, 3]) 2 >>> findBalancedIndex([1, 2, 3]) -1 >>> findBalancedIndex([10]) 0 # Your code here","solution":"def findBalancedIndex(nums): This function returns the index in the list where the sum of the integers to the left of the index is equal to the sum of the integers to the right of the index. If no such index exists, the function returns -1. total_sum = sum(nums) left_sum = 0 for i, num in enumerate(nums): # If the left sum equals the right sum, return the index if left_sum == (total_sum - left_sum - num): return i left_sum += num return -1"},{"question":"def is_balanced(string: str) -> bool: Determines if the string is balanced. A string is considered balanced if the absolute difference between the number of occurrences of 'a' and 'b' is no more than 1. >>> is_balanced(\\"abaa\\") False >>> is_balanced(\\"aabb\\") True >>> is_balanced(\\"abb\\") True >>> is_balanced(\\"a\\") True >>> is_balanced(\\"bbbbbb\\") False >>> is_balanced(\\"ab\\") True >>> is_balanced(\\"aaaabbbb\\") True >>> is_balanced(\\"aaaabbb\\") True pass def process_test_cases(test_cases: List[str]) -> List[str]: Processes the list of test cases and returns a list of results. >>> process_test_cases([\\"abaa\\", \\"aabb\\", \\"abb\\", \\"a\\"]) ['UNBALANCED', 'BALANCED', 'BALANCED', 'BALANCED'] >>> process_test_cases([\\"bbb\\", \\"aaab\\", \\"ab\\", \\"aabab\\", \\"aaaaaa\\"]) ['UNBALANCED', 'UNBALANCED', 'BALANCED', 'BALANCED', 'UNBALANCED'] pass","solution":"def is_balanced(string): Determines if the string is balanced. A string is considered balanced if the absolute difference between the number of occurrences of 'a' and 'b' is no more than 1. count_a = string.count('a') count_b = string.count('b') return abs(count_a - count_b) <= 1 def process_test_cases(test_cases): Processes the list of test cases and returns a list of results. results = [] for tc in test_cases: if is_balanced(tc): results.append(\\"BALANCED\\") else: results.append(\\"UNBALANCED\\") return results"},{"question":"def evaluate_expression(expression): Evaluates a mathematical expression provided as a string and returns the calculated result. The expression can include the following operators: +, -, *, / and parentheses to denote the order of operations. If the input is not a valid mathematical expression, an error message is returned. >>> evaluate_expression(\\"2 + 3\\") 5 >>> evaluate_expression(\\"(2 + 3) * (4 - 2)\\") 10","solution":"def evaluate_expression(expression): Evaluates a mathematical expression provided as a string and returns the calculated result. The expression can include the following operators: +, -, *, / and parentheses to denote the order of operations. If the input is not a valid mathematical expression, an error message is returned. try: result = eval(expression) return result except (SyntaxError, ZeroDivisionError, NameError) as e: return f\\"Error: {str(e)}\\""},{"question":"def max_length_subarray_sum(arr: List[int], target: int) -> int: Find the maximum length of a contiguous subarray that sums up to the given target. >>> max_length_subarray_sum([1, -1, 5, -2, 3], 3) 4 >>> max_length_subarray_sum([-2, -1, 2, 1], 1) 2 >>> max_length_subarray_sum([1, 2, 3], 6) 3 >>> max_length_subarray_sum([1, 2, 3], 7) 0 >>> max_length_subarray_sum([5], 5) 1 >>> max_length_subarray_sum([5], 4) 0 >>> max_length_subarray_sum([0, 0, 0, 0, 0], 0) 5 >>> arr = [1] * 100000 >>> max_length_subarray_sum(arr, 100000) 100000 >>> max_length_subarray_sum(arr, -1) 0","solution":"def max_length_subarray_sum(arr, target): Finds the maximum length of a contiguous subarray that sums up to the given target. prefix_sum_map = {0: -1} max_length = 0 curr_sum = 0 for i, num in enumerate(arr): curr_sum += num if (curr_sum - target) in prefix_sum_map: max_length = max(max_length, i - prefix_sum_map[curr_sum - target]) if curr_sum not in prefix_sum_map: prefix_sum_map[curr_sum] = i return max_length"},{"question":"def min_difference(M: int, points: List[int]) -> int: Determine the minimum possible difference between the points collected by Alice and Bob after completing all levels. >>> min_difference(4, [1, 4, 2, 7]) 0 >>> min_difference(3, [5, 8, 6]) 3 >>> min_difference(5, [3, 1, 4, 2, 2]) 0 >>> min_difference(1, [10]) 10 >>> min_difference(4, [5, 5, 5, 5]) 0 >>> min_difference(5, [100, 200, 300, 400, 500]) 100","solution":"def minimum_point_difference(M, points): total_points = sum(points) half_points = total_points // 2 dp = [0] * (half_points + 1) for point in points: for j in range(half_points, point - 1, -1): dp[j] = max(dp[j], dp[j - point] + point) best_distribution = dp[half_points] other_distribution = total_points - best_distribution return abs(best_distribution - other_distribution) # Example function to call the above method with appropriate input def min_difference(M, points): return minimum_point_difference(M, points)"},{"question":"def min_connections_needed(n, m, connections): Calculate the minimum number of new direct connections needed to ensure that all servers can communicate with each other. Parameters: n (int): Number of servers m (int): Number of already existing direct connections connections (List[Tuple[int, int]]): List of tuples representing existing connections between servers Returns: int: Minimum number of new direct connections needed to ensure all servers can communicate Example: >>> min_connections_needed(4, 2, [(1, 2), (3, 4)]) 1 >>> min_connections_needed(3, 1, [(1, 2)]) 1 >>> min_connections_needed(5, 0, []) 4 pass def test_min_connections_needed(): assert min_connections_needed(4, 2, [(1, 2), (3, 4)]) == 1, \\"Test case 1 failed\\" assert min_connections_needed(3, 1, [(1, 2)]) == 1, \\"Test case 2 failed\\" assert min_connections_needed(5, 0, []) == 4, \\"Test case 3 failed\\" assert min_connections_needed(3, 3, [(1, 2), (2, 3), (3, 1)]) == 0, \\"Test case 4 failed\\" assert min_connections_needed(1, 0, []) == 0, \\"Test case 5 failed\\" assert min_connections_needed(2, 0, []) == 1, \\"Test case 6 failed\\" assert min_connections_needed(6, 2, [(1, 2), (3, 4)]) == 3, \\"Test case 7 failed\\" test_min_connections_needed()","solution":"def min_connections_needed(n, m, connections): from collections import defaultdict, deque # Build initial adjacency list representation of the graph adj_list = defaultdict(list) for u, v in connections: adj_list[u].append(v) adj_list[v].append(u) def bfs(start_node, visited): queue = deque([start_node]) visited[start_node] = True while queue: node = queue.popleft() for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # To find the number of disconnected components visited = [False] * (n + 1) components = 0 for i in range(1, n + 1): if not visited[i]: bfs(i, visited) components += 1 # The minimum number of connections needed is one less than the number of components return components - 1"},{"question":"def is_symmetric(matrix, n): Check if a given n x n matrix is symmetric. Args: matrix : list[list[int]] : The n x n matrix. n : int : The dimension of the matrix. Returns: str : \\"YES\\" if the matrix is symmetric. \\"NO\\" otherwise. def check_matrices(test_cases): Process multiple test cases to determine if matrices are symmetric. Args: test_cases : list[tuple[int, list[list[int]]]] : A list of test cases, each consisting of the size of the matrix and the matrix itself. Returns: list[str] : A list containing \\"YES\\" or \\"NO\\" for each test case. # Unit tests def test_is_symmetric_yes(): matrix = [ [1, 2, 3], [2, 4, 5], [3, 5, 6] ] assert is_symmetric(matrix, 3) == \\"YES\\" def test_is_symmetric_no(): matrix = [ [1, 0], [2, 1] ] assert is_symmetric(matrix, 2) == \\"NO\\" def test_is_symmetric_single_element(): matrix = [ [5] ] assert is_symmetric(matrix, 1) == \\"YES\\" def test_is_symmetric_diagonal_only(): matrix = [ [1, 0, 0], [0, 2, 0], [0, 0, 3] ] assert is_symmetric(matrix, 3) == \\"YES\\" def test_check_matrices_multiple(): test_cases = [ (3, [ [1, 2, 3], [2, 4, 5], [3, 5, 6] ]), (2, [ [1, 0], [2, 1] ]) ] assert check_matrices(test_cases) == [\\"YES\\", \\"NO\\"] def test_check_matrices_single_case(): test_cases = [ (1, [[7]]) ] assert check_matrices(test_cases) == [\\"YES\\"] def test_check_matrices_mixed(): test_cases = [ (2, [ [1, 2], [2, 1] ]), (3, [ [1, 2, 3], [2, 4, 5], [3, 5, 6] ]), (2, [ [1, 0], [2, 1] ]) ] assert check_matrices(test_cases) == [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def is_symmetric(matrix, n): Check if a given n x n matrix is symmetric. Args: matrix : list[list[int]] : The n x n matrix. n : int : The dimension of the matrix. Returns: str : \\"YES\\" if the matrix is symmetric. \\"NO\\" otherwise. for i in range(n): for j in range(i + 1, n): if matrix[i][j] != matrix[j][i]: return \\"NO\\" return \\"YES\\" def check_matrices(test_cases): Process multiple test cases to determine if matrices are symmetric. Args: test_cases : list[tuple[int, list[list[int]]]] : A list of test cases, each consisting of the size of the matrix and the matrix itself. Returns: list[str] : A list containing \\"YES\\" or \\"NO\\" for each test case. results = [] for n, matrix in test_cases: results.append(is_symmetric(matrix, n)) return results"},{"question":"def can_attend_all_sessions(n: int, sessions: List[Tuple[int, int]]) -> str: Determines if it is possible to attend all given sessions without any overlap. Parameters: n (int): The number of sessions. sessions (List[Tuple[int, int]]): A list of tuples where each tuple contains the start and end time of a session. Returns: str: \\"YES\\" if it is possible to attend all sessions without overlap, otherwise \\"NO\\". >>> can_attend_all_sessions(2, [(5, 8), (1, 5)]) 'YES' >>> can_attend_all_sessions(3, [(1, 3), (2, 4), (3, 5)]) 'NO' >>> can_attend_all_sessions(4, [(2, 3), (3, 4), (1, 2), (4, 5)]) 'YES' >>> can_attend_all_sessions(1, [(1, 2)]) 'YES' >>> can_attend_all_sessions(3, [(1, 2), (3, 4), (5, 6)]) 'YES' >>> can_attend_all_sessions(4, [(1, 5), (5, 8), (8, 10), (4, 6)]) 'NO' >>> can_attend_all_sessions(3, [(1, 5), (5, 9), (10, 15)]) 'YES'","solution":"def can_attend_all_sessions(n, sessions): Determines if it is possible to attend all given sessions without any overlap. Parameters: n (int): The number of sessions. sessions (List[Tuple[int, int]]): A list of tuples where each tuple contains the start and end time of a session. Returns: str: \\"YES\\" if it is possible to attend all sessions without overlap, otherwise \\"NO\\". # Sort the sessions based on their starting times sessions.sort(key=lambda x: x[0]) # Iterate through the sorted sessions to check for any overlap for i in range(1, n): if sessions[i][0] < sessions[i-1][1]: return \\"NO\\" return \\"YES\\""},{"question":"def min_operations_to_balance(S: str) -> int: Returns the minimum number of operations required to transform the string S into a balanced string. >>> min_operations_to_balance('aaabbb') 2 >>> min_operations_to_balance('aabbcc') 0 >>> min_operations_to_balance('abcabc') 0 def min_operations_for_test_cases(test_cases: List[str]) -> List[int]: For each test case, output a single integer, the minimum number of operations required to make the string balanced. >>> min_operations_for_test_cases(['aaabbb']) [2] >>> min_operations_for_test_cases(['aabbcc']) [0] >>> min_operations_for_test_cases(['abcabc']) [0]","solution":"def min_operations_to_balance(S): Returns the minimum number of operations required to transform the string S into a balanced string. n = len(S) count_a = S.count('a') count_b = S.count('b') count_c = S.count('c') # A balanced string must have each character occuring n // 3 times target_count = n // 3 # Calculate the differences from the target count diff_a = count_a - target_count diff_b = count_b - target_count diff_c = count_c - target_count # If the count of one character is too high, it can be reduced, and one of the other characters increased total_diff = abs(diff_a) + abs(diff_b) + abs(diff_c) # Since each replacement operation changes two character counts, the minimum operations needed will be the half of the total differences min_operations = total_diff // 2 return min_operations def min_operations_for_test_cases(test_cases): results = [] for S in test_cases: results.append(min_operations_to_balance(S)) return results"},{"question":"def longest_unique_char_substring(s: str) -> int: Returns the length of the longest substring containing only a single unique character. >>> longest_unique_char_substring(\\"aabbccccddd\\") 4 >>> longest_unique_char_substring(\\"111122233\\") 4","solution":"def longest_unique_char_substring(s): Returns the length of the longest substring containing only a single unique character. if not s: return 0 max_len = 1 current_len = 1 for i in range(1, len(s)): if s[i] == s[i-1]: current_len += 1 else: if current_len > max_len: max_len = current_len current_len = 1 return max(max_len, current_len)"},{"question":"def can_form_palindrome(s: str) -> bool: Checks if the given string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if the frequencies of its characters fulfill a specific condition. Example: >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False","solution":"def can_form_palindrome(s): Checks if the given string can be rearranged to form a palindrome. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # A string can be rearranged to form a palindrome if at most one character # has an odd count (for the center character in an odd length palindrome). odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root: Optional[TreeNode]) -> int: Computes the maximum depth of the binary tree. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. >>> tree1 = TreeNode(3) >>> tree1.left = TreeNode(9) >>> tree1.right = TreeNode(20) >>> tree1.right.left = TreeNode(15) >>> tree1.right.right = TreeNode(7) >>> maxDepth(tree1) 3 >>> tree2 = TreeNode(1) >>> tree2.right = TreeNode(2) >>> tree2.right.right = TreeNode(3) >>> tree2.right.right.right = TreeNode(4) >>> maxDepth(tree2) 4 >>> maxDepth(None) 0 >>> tree = TreeNode(1) >>> maxDepth(tree) 1 >>> tree = TreeNode(1) >>> tree.left = TreeNode(2) >>> tree.right = TreeNode(3) >>> tree.left.left = TreeNode(4) >>> tree.left.right = TreeNode(5) >>> maxDepth(tree) 3 >>> tree = TreeNode(1) >>> tree.left = TreeNode(2) >>> tree.left.left = TreeNode(3) >>> tree.left.left.left = TreeNode(4) >>> tree.right = TreeNode(5) >>> maxDepth(tree) 4","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root: Optional[TreeNode]) -> int: if root is None: return 0 else: left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return max(left_depth, right_depth) + 1"},{"question":"def maxLecturesAttended(n, m, capacities, preferences): Determines the maximum number of lectures that can be attended by students without exceeding any lecture's capacity. Arguments: n -- the number of lectures m -- the number of students capacities -- a list of integers where capacities[i] is the capacity of lecture i preferences -- a list where preferences[i] contains a list of lectures that student i can attend Returns: The maximum number of lectures that can be attended by students. # **You implementation goes here** # Unit tests def test_example_1(): assert maxLecturesAttended(3, 3, [1, 2, 1], [[0, 1], [1, 2], [0, 2]]) == 3 def test_example_2(): assert maxLecturesAttended(2, 2, [1, 1], [[0], [1]]) == 2 def test_no_preferences(): assert maxLecturesAttended(3, 3, [2, 2, 2], [[], [], []]) == 0 def test_missing_capacity(): assert maxLecturesAttended(3, 3, [0, 0, 0], [[0, 1], [1, 2], [0, 2]]) == 0 def test_equal_students_and_lectures(): assert maxLecturesAttended(3, 3, [1, 1, 1], [[0], [1], [2]]) == 3 def test_overlapping_preferences(): assert maxLecturesAttended(3, 3, [1, 2, 1], [[0, 1], [0, 1], [0, 2]]) == 3 def test_lecture_more_capacity_than_students(): assert maxLecturesAttended(2, 3, [2, 2], [[0, 1], [0, 1], [0, 1]]) == 3","solution":"def maxLecturesAttended(n, m, capacities, preferences): Determines the maximum number of lectures that can be attended by students without exceeding any lecture's capacity. Arguments: n -- the number of lectures m -- the number of students capacities -- a list of integers where capacities[i] is the capacity of lecture i preferences -- a list where preferences[i] contains a list of lectures that student i can attend Returns: The maximum number of lectures that can be attended by students. from collections import defaultdict, deque # build a lecture's students list and initial counts lecture_students = defaultdict(list) # lecture i -> list of students who can attend student_assignment = [-1] * m # -1 means the student is not assigned to any lecture for student, prefs in enumerate(preferences): for lecture in prefs: lecture_students[lecture].append(student) total_attended = 0 attended_by_lecture = [0] * n # track how many students are attending each lecture for lecture, students in lecture_students.items(): if attended_by_lecture[lecture] < capacities[lecture]: for student in students: if student_assignment[student] == -1: attended_by_lecture[lecture] += 1 total_attended += 1 student_assignment[student] = lecture if attended_by_lecture[lecture] == capacities[lecture]: break return total_attended"},{"question":"def bitwise_and(A: str, B: str) -> str: Returns the bitwise AND of two binary strings A and B of equal length. >>> bitwise_and(\\"1101\\", \\"1010\\") '1000' >>> bitwise_and(\\"1111\\", \\"0000\\") '0000'","solution":"def bitwise_and(A, B): Returns the bitwise AND of two binary strings A and B of equal length. result = [] for a, b in zip(A, B): result.append(str(int(a) & int(b))) return ''.join(result)"},{"question":"def can_reach_destination(m: int, n: int, grid: List[List[int]]) -> str: Determines if there is a valid path from the top-left to the bottom-right corner of the grid. >>> can_reach_destination(3, 3, ... [[1, 2, 3], ... [6, 5, 2], ... [7, 6, 8]]) 'YES' >>> can_reach_destination(3, 3, ... [[3, 2, 1], ... [2, 4, 3], ... [1, 5, 6]]) 'NO'","solution":"def can_reach_destination(m, n, grid): Determines if there is a valid path from the top-left to the bottom-right corner of the grid. if not grid or not grid[0]: return \\"NO\\" from collections import deque directions = [(0, 1), (1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if x == m - 1 and y == n - 1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] >= grid[x][y]: queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\""},{"question":"def max_candies_tom_gets(candies: List[int]) -> int: Determine the maximum number of candies Tom can get if both players play optimally. >>> max_candies_tom_gets([1, 2, 9, 4]) 10 >>> max_candies_tom_gets([4, 5, 1]) 5 >>> max_candies_tom_gets([7]) 7 >>> max_candies_tom_gets([2, 2, 2, 2]) 4 >>> max_candies_tom_gets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 30","solution":"def max_candies_tom_gets(candies): n = len(candies) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = candies[i] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 take_left = candies[i] + min(dp[i + 2][j] if i + 2 <= j else 0, dp[i + 1][j - 1] if i + 1 <= j - 1 else 0) take_right = candies[j] + min(dp[i + 1][j - 1] if i + 1 <= j - 1 else 0, dp[i][j - 2] if i <= j - 2 else 0) dp[i][j] = max(take_left, take_right) return dp[0][n - 1]"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing +, -, *, parentheses. >>> evaluate_expression(\\"3 * ( 4 + 5 ) - 6\\") 21 >>> evaluate_expression(\\"12 + 23 * 2\\") 58 >>> evaluate_expression(\\"( 1 + 2 ) * ( 3 + 4 )\\") 21 >>> evaluate_expression(\\"3 - 4 + 2\\") 1 >>> evaluate_expression(\\"2 * ( 3 - 5 ) + 8\\") 4 >>> evaluate_expression(\\"( ( 2 + 3 ) * 4 )\\") 20 >>> evaluate_expression(\\"( 2 + ( 3 * 4 ) ) * 5\\") 70 >>> evaluate_expression(\\"5 + 3 * 2\\") 11 >>> evaluate_expression(\\"10 - 3 + 2 * 4\\") 15 >>> evaluate_expression(\\"5 * 2 - 3 * 4\\") -2 >>> evaluate_expression(\\"10 + 2 - 3 + 5 - 8\\") 6","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing +, -, *, parentheses. def operate(a, b, op): if op == '+': return a + b elif op == '-': return a - b elif op == '*': return a * b def precedence(op): if op == '+' or op == '-': return 1 if op == '*': return 2 return 0 def apply_operations(values, operations): b = values.pop() a = values.pop() op = operations.pop() values.append(operate(a, b, op)) values = [] operations = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue elif expression[i] == '(': operations.append(expression[i]) elif expression[i].isdigit(): val = 0 while (i < len(expression)) and (expression[i].isdigit()): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == ')': while len(operations) != 0 and operations[-1] != '(': apply_operations(values, operations) operations.pop() else: while (len(operations) != 0 and precedence(operations[-1]) >= precedence(expression[i])): apply_operations(values, operations) operations.append(expression[i]) i += 1 while len(operations) != 0: apply_operations(values, operations) return values[-1]"},{"question":"def decode_sequence(sequence: str) -> str: Decodes a sequence by replacing each letter with the letter 2 places ahead in the alphabet. Wraps from 'z' back to 'a' and 'b'. pass def decode_sequences(sequences: List[str]) -> List[str]: Takes a list of sequences and returns a list of decoded strings in the format 'Case x: y' where x is the sequence number and y is the decoded sequence. pass # Test cases def test_decode_sequence(): assert decode_sequence(\\"abc\\") == \\"cde\\" assert decode_sequence(\\"xyz\\") == \\"zab\\" assert decode_sequence(\\"mno\\") == \\"opq\\" assert decode_sequence(\\"a\\") == \\"c\\" assert decode_sequence(\\"z\\") == \\"b\\" assert decode_sequence(\\"za\\") == \\"bc\\" assert decode_sequence(\\"az\\") == \\"cb\\" def test_decode_sequences(): input_sequences = [\\"abc\\", \\"xyz\\", \\"mno\\"] expected_output = [ \\"Case 1: cde\\", \\"Case 2: zab\\", \\"Case 3: opq\\" ] assert decode_sequences(input_sequences) == expected_output input_sequences = [\\"a\\", \\"z\\", \\"az\\"] expected_output = [ \\"Case 1: c\\", \\"Case 2: b\\", \\"Case 3: cb\\" ] assert decode_sequences(input_sequences) == expected_output","solution":"def decode_sequence(sequence): Decodes a sequence by replacing each letter with the letter 2 places ahead in the alphabet. Wraps from 'z' back to 'a' and 'b'. result = [] for char in sequence: new_char = chr(((ord(char) - ord('a') + 2) % 26) + ord('a')) result.append(new_char) return ''.join(result) def decode_sequences(sequences): Takes a list of sequences and returns a list of decoded strings in the format 'Case x: y' where x is the sequence number and y is the decoded sequence. result = [] for i, seq in enumerate(sequences): decoded_seq = decode_sequence(seq) result.append(f\\"Case {i + 1}: {decoded_seq}\\") return result"},{"question":"def determine_winner(n: int, k: int) -> str: Determines the winner of the game given n and k. Ali wins if n % (k + 1) != 0, otherwise Bashir wins. Args: n: Total number of cards. k: Maximum cards a player can draw in one turn. Returns: \\"Ali\\" or \\"Bashir\\" indicating the winner. >>> determine_winner(10, 3) 'Ali' >>> determine_winner(15, 4) 'Bashir' >>> determine_winner(7, 2) 'Ali' pass def card_game_outcomes(test_cases: list) -> list: Computes the outcomes for multiple test cases. Args: test_cases: List of tuples, where each tuple contains two integers (n, k). Returns: List of strings, where each string indicates the winner for the respective test case. >>> card_game_outcomes([(10, 3), (15, 4), (7, 2)]) ['Ali', 'Bashir', 'Ali'] pass def test_determine_winner(): assert determine_winner(10, 3) == \\"Ali\\" assert determine_winner(15, 4) == \\"Bashir\\" assert determine_winner(7, 2) == \\"Ali\\" assert determine_winner(8, 3) == \\"Bashir\\" assert determine_winner(20, 6) == \\"Ali\\" def test_card_game_outcomes(): test_cases = [ (10, 3), (15, 4), (7, 2), (8, 3), (20, 6) ] expected_results = [ \\"Ali\\", \\"Bashir\\", \\"Ali\\", \\"Bashir\\", \\"Ali\\" ] assert card_game_outcomes(test_cases) == expected_results","solution":"def determine_winner(n, k): Determines the winner of the game given n and k. Ali wins if n % (k + 1) != 0, otherwise Bashir wins. if n % (k + 1) != 0: return \\"Ali\\" else: return \\"Bashir\\" def card_game_outcomes(test_cases): Computes the outcomes for multiple test cases. Args: test_cases: List of tuples, where each tuple contains two integers (n, k). Returns: List of strings, where each string indicates the winner for the respective test case. results = [] for n, k in test_cases: results.append(determine_winner(n, k)) return results"},{"question":"import re def validate_email_addresses(T: int, test_cases: List[Tuple[int, List[str]]]) -> List[str]: Validate a list of email addresses based on the provided criteria. >>> T = 2 >>> test_cases = [ >>> (4, ['user_1@example.com', 'user.2@domain.com', 'user--3@sub.domain.com', 'user@domain..com']), >>> (3, ['test-email@domain.co.in', 'test.email@domain.com', 'invalid@domain@com']) >>> ] >>> validate_email_addresses(T, test_cases) ['user_1@example.com user.2@domain.com user--3@sub.domain.com', 'test-email@domain.co.in test.email@domain.com']","solution":"import re def validate_email_addresses(T, test_cases): results = [] email_pattern = re.compile( r'^[a-zA-Z0-9]([a-zA-Z0-9._-]*[a-zA-Z0-9])?@[a-zA-Z0-9]+(.[a-zA-Z0-9]+)+' ) for i in range(T): N, emails = test_cases[i] valid_emails = [ email for email in emails if email_pattern.match(email) ] if valid_emails: results.append(\\" \\".join(valid_emails)) else: results.append(\\"No valid email addresses\\") return results # Example usage T = 2 test_cases = [ (4, ['user_1@example.com', 'user.2@domain.com', 'user--3@sub.domain.com', 'user@domain..com']), (3, ['test-email@domain.co.in', 'test.email@domain.com', 'invalid@domain@com']) ] print(validate_email_addresses(T, test_cases))"},{"question":"import math def count_flower_arrangements(n: int, k: int) -> int: Calculate the number of ways to place exactly \`k\` flowers in an \`n x n\` grid such that no two flowers are placed in the same row or column. Args: n (int): The size of the grid. k (int): The number of flowers to be placed. Returns: int: The number of valid arrangements. Examples: >>> count_flower_arrangements(4, 2) 72 >>> count_flower_arrangements(1, 0) 1 >>> count_flower_arrangements(1, 1) 1 >>> count_flower_arrangements(4, 0) 1 >>> count_flower_arrangements(10, 10) 3628800 >>> count_flower_arrangements(5, 3) 600 >>> count_flower_arrangements(4, -1) 0 >>> count_flower_arrangements(3, 4) 0 >>> count_flower_arrangements(3, 3) 6","solution":"import math def count_flower_arrangements(n, k): Returns the number of ways to arrange k flowers in an n x n grid such that no two flowers are in the same row or column. if k > n or k < 0 or n < 1: return 0 choose_n_k = math.comb(n, k) return choose_n_k * choose_n_k * math.factorial(k)"},{"question":"from typing import List, Dict def robot_navigation(test_cases: List[Dict]) -> List[int]: Write a program to help a robot navigate a grid with obstacles from a starting position to a target position. The grid is represented as a 2D array of cells, where each cell can either be empty (.) or contain an obstacle (#). The robot can move up, down, left, or right but cannot move through obstacles or off the grid. You task is to compute the minimum number of moves the robot needs to reach the target from the starting position, or determine that it is impossible for the robot to get there. >>> robot_navigation([{'R': 5, 'C': 5, 'grid': [\\".....\\", \\".#.#.\\", \\"..#..\\", \\".....\\", \\".....\\"], 'S_row': 0, 'S_col': 0, 'T_row': 4, 'T_col': 4}]) [8] >>> robot_navigation([{'R': 3, 'C': 5, 'grid': [\\".....\\", \\".....\\", \\"..#..\\", \\".#.#.\\", \\".....\\"], 'S_row': 0, 'S_col': 0, 'T_row': 3, 'T_col': 4}]) [-1] >>> robot_navigation([{'R': 2, 'C': 2, 'grid': [\\".#\\", \\"#.\\"], 'S_row': 0, 'S_col': 0, 'T_row': 1, 'T_col': 1}]) [-1] >>> robot_navigation([{'R': 1, 'C': 1, 'grid': [\\".\\"], 'S_row': 0, 'S_col': 0, 'T_row': 0, 'T_col': 0}]) [0]","solution":"from collections import deque def min_moves_in_grid(R, C, grid, S_row, S_col, T_row, T_col): if grid[S_row][S_col] == '#' or grid[T_row][T_col] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(S_row, S_col, 0)]) visited = set((S_row, S_col)) while queue: x, y, steps = queue.popleft() if (x, y) == (T_row, T_col): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < R and 0 <= ny < C and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1 def robot_navigation(test_cases): results = [] for case in test_cases: R, C = case['R'], case['C'] grid = case['grid'] S_row, S_col = case['S_row'], case['S_col'] T_row, T_col = case['T_row'], case['T_col'] result = min_moves_in_grid(R, C, grid, S_row, S_col, T_row, T_col) results.append(result) return results"},{"question":"from typing import List def process_image_operations(m: int, pixels: List[int], operations: List[List[int]]) -> List[int]: Process image operations including compressing pixel ranges, enhancing contrast, and querying max intensity. Args: m: int - Number of pixels in the image. pixels: List[int] - List of pixel intensity values. operations: List[List[int]] - List of operations to be performed on the pixels. Returns: List[int] - Results of all query operations. Example: >>> process_image_operations(5, [100, 200, 150, 130, 120], [[1, 1, 3], [2, 2, 4, 2], [3], [2, 1, 5, 2]]) [150] pass # Unit tests def test_operations(): pixels = [100, 200, 150, 130, 120] operations = [ [1, 1, 3], # compress from 1 to 3 [2, 2, 4, 2], # enhance from 2 to 4 dividing by 2 [3], # query the maximum value [2, 1, 5, 2], # enhance from 1 to 5 dividing by 2 ] expected_output = [150] assert process_image_operations(5, pixels, operations) == expected_output def test_only_query(): pixels = [100, 200, 150, 130, 120] operations = [[3]] expected_output = [200] assert process_image_operations(5, pixels, operations) == expected_output def test_only_compress(): pixels = [100, 200, 150, 130, 120] operations = [ [1, 1, 3], # compress from 1 to 3 [3], # query the maximum value ] expected_output = [150] assert process_image_operations(5, pixels, operations) == expected_output def test_only_enhance(): pixels = [100, 200, 150, 130, 120] operations = [ [2, 1, 5, 2], # enhance from 1 to 5 dividing by 2 [3], # query the maximum value ] expected_output = [100] assert process_image_operations(5, pixels, operations) == expected_output def test_enhance_edge_case(): pixels = [100, 200, 150, 130, 120] operations = [ [2, 2, 2, 2], # enhance position 2 dividing by 2 [3], # query the maximum value ] expected_output = [150] assert process_image_operations(5, pixels, operations) == expected_output","solution":"def process_image_operations(m, pixels, operations): def compress(pixels, p, q): avg = sum(pixels[p-1:q]) // (q - p + 1) for i in range(p-1, q): pixels[i] = avg def enhance(pixels, p, q, k): for i in range(p-1, q): pixels[i] //= k results = [] for op in operations: if op[0] == 1: _, p, q = op compress(pixels, p, q) elif op[0] == 2: _, p, q, k = op enhance(pixels, p, q, k) elif op[0] == 3: results.append(max(pixels)) return results"},{"question":"def is_valid_discount_code(code: str) -> str: Determines if a discount code is valid based on the following criteria: - It contains at least one uppercase letter. - It contains at least one digit. - It does not contain any repeating characters. Args: code (str): The discount code to validate. Returns: str: \\"Valid\\" if the discount code meets all the criteria, otherwise \\"Invalid\\". >>> is_valid_discount_code(\\"A1B2C3\\") == \\"Valid\\" >>> is_valid_discount_code(\\"123456\\") == \\"Invalid\\" >>> is_valid_discount_code(\\"ABCDEF\\") == \\"Invalid\\" >>> is_valid_discount_code(\\"A1X\\") == \\"Valid\\" >>> is_valid_discount_code(\\"AAA111\\") == \\"Invalid\\" >>> is_valid_discount_code(\\"X1Y2Z3\\") == \\"Valid\\" >>> is_valid_discount_code(\\"AAAAA1111\\") == \\"Invalid\\" >>> is_valid_discount_code(\\"A1\\") == \\"Valid\\" >>> is_valid_discount_code(\\"A\\") == \\"Invalid\\" >>> is_valid_discount_code(\\"1\\") == \\"Invalid\\" pass def validate_discount_codes(codes: List[str]) -> List[str]: Validates a list of discount codes. Args: codes (list): List of discount codes to validate. Returns: list: List of results (\\"Valid\\" or \\"Invalid\\") for each discount code. >>> validate_discount_codes([\\"A1B2C3\\", \\"123456\\", \\"ABCDEF\\", \\"A1X\\", \\"AAA111\\", \\"X1Y2Z3\\", \\"AAAAA1111\\"]) == [\\"Valid\\", \\"Invalid\\", \\"Invalid\\", \\"Valid\\", \\"Invalid\\", \\"Valid\\", \\"Invalid\\"] pass","solution":"def is_valid_discount_code(code): Determines if a discount code is valid based on the following criteria: - It contains at least one uppercase letter. - It contains at least one digit. - It does not contain any repeating characters. Args: code (str): The discount code to validate. Returns: str: \\"Valid\\" if the discount code meets all the criteria, otherwise \\"Invalid\\". has_uppercase = False has_digit = False seen_characters = set() for char in code: if char.isupper(): has_uppercase = True if char.isdigit(): has_digit = True if char in seen_characters: return \\"Invalid\\" seen_characters.add(char) if has_uppercase and has_digit: return \\"Valid\\" else: return \\"Invalid\\" def validate_discount_codes(codes): Validates a list of discount codes. Args: codes (list): List of discount codes to validate. Returns: list: List of results (\\"Valid\\" or \\"Invalid\\") for each discount code. return [is_valid_discount_code(code) for code in codes]"},{"question":"def custom_sort_string(order: str, s: str) -> str: Sorts the characters in \`str\` based on the order defined in \`order\`. If a character in \`str\` does not appear in \`order\`, it should be placed at the end of the result in any order. >>> custom_sort_string(\\"cba\\", \\"abcd\\") 'cbad' >>> custom_sort_string(\\"huc\\", \\"huachuca\\") 'hhuuccaa'","solution":"def custom_sort_string(order, s): Sorts the characters in \`s\` based on the order defined in \`order\`. If a character in \`s\` does not appear in \`order\`, it will be placed at the end. order_map = {char: index for index, char in enumerate(order)} return ''.join(sorted(s, key=lambda char: order_map.get(char, len(order))))"},{"question":"def is_divisible_by_7(num_str: str) -> str: Check if a large integer represented as a string is divisible by 7. >>> is_divisible_by_7(\\"34300000000000000000000000007\\") \\"Divisible\\" >>> is_divisible_by_7(\\"34300000000000000000000000001\\") \\"Not Divisible\\"","solution":"def is_divisible_by_7(num_str): Check if a large integer represented as a string is divisible by 7. n = len(num_str) num = 0 for i in range(n): num = (num * 10 + int(num_str[i])) % 7 return \\"Divisible\\" if num == 0 else \\"Not Divisible\\""},{"question":"def findMaxSkillSum(n: int, k: int, skills: List[int]) -> int: Find the maximum sum of skills that doesn't exceed k using a subset of the employees. >>> findMaxSkillSum(4, 13, [5, 8, 3, 7]) 13 >>> findMaxSkillSum(5, 10, [1, 4, 3, 2, 6]) 10 >>> findMaxSkillSum(3, 5, [3, 5, 7]) 5 >>> findMaxSkillSum(6, 15, [1, 2, 3, 4, 5, 6]) 15 >>> findMaxSkillSum(2, 30, [10, 20]) 30 >>> findMaxSkillSum(3, 1, [2, 3, 5]) 0","solution":"def findMaxSkillSum(n, k, skills): dp = [0] * (k + 1) for skill in skills: for j in range(k, skill - 1, -1): dp[j] = max(dp[j], dp[j - skill] + skill) return dp[k]"},{"question":"def sieve_of_eratosthenes(n): Computes the list of prime numbers up to n using the Sieve of Eratosthenes algorithm. pass def count_primes_up_to_n(cases): Given a list of integers, returns a list where each element is the count of prime numbers less than or equal to the corresponding input integer. >>> count_primes_up_to_n([5, 10, 20]) == [3, 4, 8] >>> count_primes_up_to_n([1, 2, 3, 4, 5]) == [0, 1, 2, 2, 3] # Unit Tests def test_sieve_of_eratosthenes(): prime_counts = sieve_of_eratosthenes(20) assert prime_counts[5] == 3 assert prime_counts[10] == 4 assert prime_counts[20] == 8 assert prime_counts[1] == 0 assert prime_counts[2] == 1 def test_count_primes_up_to_n(): cases = [5, 10, 20] assert count_primes_up_to_n(cases) == [3, 4, 8] cases = [1, 2, 3, 4, 5] assert count_primes_up_to_n(cases) == [0, 1, 2, 2, 3] cases = [30, 50, 100, 200] assert count_primes_up_to_n(cases) == [10, 15, 25, 46] cases = [0, 1] assert count_primes_up_to_n(cases) == [0, 0]","solution":"def sieve_of_eratosthenes(n): Computes the list of prime numbers up to n using the Sieve of Eratosthenes algorithm. is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if (is_prime[p] == True): for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 prime_count = [0] * (n + 1) count = 0 for i in range(2, n + 1): if is_prime[i]: count += 1 prime_count[i] = count return prime_count def count_primes_up_to_n(cases): max_n = max(cases) prime_count = sieve_of_eratosthenes(max_n) result = [] for n in cases: result.append(prime_count[n]) return result"},{"question":"def count_and_sort(lst): Takes a list of integers and returns a sorted list of tuples with each tuple containing an integer from the input list and its frequency. >>> count_and_sort([4, 6, 3, 4, 6, 1, 3, 3, 4]) [(1, 1), (3, 3), (4, 3), (6, 2)] >>> count_and_sort([5]) [(5, 1)] >>> count_and_sort([1, 2, 3, 4, 5]) [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)] >>> count_and_sort([]) [] >>> count_and_sort([-1, -2, -3, -1, -2, -1]) [(-3, 1), (-2, 2), (-1, 3)] >>> count_and_sort([-1, 2, -1, 2, 0]) [(-1, 2), (0, 1), (2, 2)]","solution":"def count_and_sort(lst): Takes a list of integers and returns a sorted list of tuples with each tuple containing an integer from the input list and its frequency. Parameters: lst (list): A list of integers. Returns: list: A sorted list of tuples, where each tuple contains an integer and its frequency. # Create a dictionary to count the frequency of each integer frequency_dict = {} for num in lst: if num in frequency_dict: frequency_dict[num] += 1 else: frequency_dict[num] = 1 # Convert the dictionary to a list of tuples and sort it by the integers result = sorted(frequency_dict.items()) return result"},{"question":"def longest_consistent_subplaylist(T: int, test_cases: list) -> list: Determines the length of the longest consistent subplaylist where the rhythm difference between consecutive songs is the same throughout the subplaylist. Parameters: T (int): Number of test cases. test_cases (list): A list of tuples, each containing an integer N (number of songs) and a list of N integers representing the rhythm values of the songs. Returns: list: A list of integers representing the length of the longest consistent subplaylist for each test case. Example: >>> longest_consistent_subplaylist(2, [(6, [1, 2, 3, 4, 5, 6]), (5, [10, 20, 30, 25, 20])]) [6, 3] >>> longest_consistent_subplaylist(1, [(1, [100])]) [1]","solution":"def longest_consistent_subplaylist(T, test_cases): Returns the length of the longest consistent subplaylist for each test case. results = [] for t in range(T): N = test_cases[t][0] rhythms = test_cases[t][1] if N == 1: results.append(1) continue max_length = 1 current_length = 1 current_diff = rhythms[1] - rhythms[0] for i in range(1, N): diff = rhythms[i] - rhythms[i-1] if diff == current_diff: current_length += 1 else: max_length = max(max_length, current_length) current_length = 2 current_diff = diff max_length = max(max_length, current_length) results.append(max_length) return results"},{"question":"def shortest_path_in_park(T: int, parks: List[Tuple[int, int, List[str], Tuple[int, int, int, int]]]) -> List[str]: A park is built as a rectangular grid of size N x M. Each cell in the grid represents a section of the park, and is either empty or contains a tree. Each step you take, you can choose to move up, down, left, or right to an adjacent cell. The park has a unique entrance and a unique exit at specified locations. You want to determine the shortest distance (minimum number of steps) from the entrance to the exit, avoiding trees. Args: T (int): The number of test cases. parks (List[Tuple[int, int, List[str], Tuple[int, int, int, int]]]): For each test case: - A tuple containing: - two integers, N and M, representing the number of rows and columns of the park. - a list of N strings each containing M characters ('.' for an empty cell, '#' for a cell with a tree). - a tuple with four integers, x1, y1, x2, y2, denoting the coordinates of the entrance and the exit respectively (1-indexed). Returns: List[str]: For each test case, output a single line of output in the format \\"Test Case #X: Y\\", where X is the 1-based index of the test case, and Y is the minimum number of steps needed to get from the entrance to the exit. If the exit cannot be reached, return -1 for that test case. >>> shortest_path_in_park(2, [(3, 3, [\\"#\\", \\".#.\\", \\"#\\"], (1, 2, 3, 2)), (4, 4, [\\"....\\", \\".#..\\", \\".#..\\", \\"....\\"], (1, 1, 4, 4))]) [\\"Test Case #1: -1\\", \\"Test Case #2: 6\\"]","solution":"from collections import deque def shortest_path(park, N, M, x1, y1, x2, y2): # Convert 1-index to 0-index start = (x1 - 1, y1 - 1) end = (x2 - 1, y2 - 1) # Directions for up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS setup queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set() visited.add(start) while queue: x, y, dist = queue.popleft() # Check if we have reached the end if (x, y) == end: return dist # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and park[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) # If no path is found return -1 def solve_parks(test_cases): results = [] for idx, (N, M, park, entrance_exit) in enumerate(test_cases): x1, y1, x2, y2 = entrance_exit result = shortest_path(park, N, M, x1, y1, x2, y2) results.append(f\\"Test Case #{idx+1}: {result}\\") return results def main(input_str): data = input_str.strip().split('n') idx = 0 T = int(data[idx]) idx += 1 test_cases = [] for _ in range(T): N, M = map(int, data[idx].split()) idx += 1 park = [] for _ in range(N): park.append(data[idx]) idx += 1 entrance_exit = tuple(map(int, data[idx].split())) idx += 1 test_cases.append((N, M, park, entrance_exit)) return solve_parks(test_cases)"},{"question":"def min_substring_length_with_all_unique_chars(s: str) -> int: Returns the minimum length of a contiguous substring that contains all unique characters of the original string exactly once. >>> min_substring_length_with_all_unique_chars(\\"abcabcbb\\") 3 >>> min_substring_length_with_all_unique_chars(\\"bbcaraca\\") 4 >>> min_substring_length_with_all_unique_chars(\\"zabcz\\") 4 pass def solve(test_cases: List[str]) -> List[int]: Given a list of strings, returns the lengths of the minimum contiguous substrings that contain all unique characters of each string exactly once. >>> solve([\\"abcabcbb\\", \\"bbcaraca\\", \\"zabcz\\"]) [3, 4, 4] pass","solution":"def min_substring_length_with_all_unique_chars(s): Returns the minimum length of a contiguous substring that contains all unique characters of the original string exactly once. unique_chars = set(s) num_unique_chars = len(unique_chars) n = len(s) min_length = n + 1 start = 0 char_count = {} for end in range(n): char_count[s[end]] = char_count.get(s[end], 0) + 1 while len(char_count) == num_unique_chars: min_length = min(min_length, end - start + 1) char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 return min_length def solve(test_cases): results = [] for s in test_cases: results.append(min_substring_length_with_all_unique_chars(s)) return results"},{"question":"def is_path_exist(n: int, m: int, grid: List[List[str]]) -> str: Determine if there exists a path for the spaceship to reach its goal in 2D grid. >>> is_path_exist(5, 5, [['.','.','.','D','.'], ['D','D','.','D','.'], ['.','.','.','.','D'], ['D','.','D','D','.'], ['.','.','.','.','.']]) \\"YES\\" >>> is_path_exist(3, 3, [['.','D','.'], ['D','D','.'], ['D','D','.']]) \\"NO\\"","solution":"def is_path_exist(n, m, grid): from collections import deque # Directions for moving: right, left, down, up directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] if grid[0][0] == 'D' or grid[n-1][m-1] == 'D': return \\"NO\\" # Using BFS for path finding queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n-1, m-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\""},{"question":"import heapq from typing import List, Tuple def dijkstra(N: int, edges: List[Tuple[int, int, int]], S: int) -> List[int]: Compute the shortest path from the starting node to every other node in the graph using Dijkstra's algorithm. Args: N (int): Number of nodes in the graph. edges (List[Tuple[int, int, int]]): List of tuples where each tuple represents an edge with two nodes and a weight. S (int): The starting node. Returns: List[int]: A list of the shortest distances from the starting node to all other nodes in ascending order by node index. If a node is not reachable from the starting node, the distance for that node will be -1. >>> dijkstra(4, [(1, 2, 5), (1, 3, 3), (2, 4, 1), (3, 4, 7)], 1) [0, 5, 3, 6] >>> dijkstra(5, [(1, 2, 3), (1, 3, 4), (2, 3, 2), (2, 4, 6), (3, 4, 1), (4, 5, 2)], 2) [3, 0, 2, 3, 5] pass def test_dijkstra_example1(): N = 4 edges = [(1, 2, 5), (1, 3, 3), (2, 4, 1), (3, 4, 7)] S = 1 assert dijkstra(N, edges, S) == [0, 5, 3, 6] def test_dijkstra_example2(): N = 5 edges = [(1, 2, 3), (1, 3, 4), (2, 3, 2), (2, 4, 6), (3, 4, 1), (4, 5, 2)] S = 2 assert dijkstra(N, edges, S) == [3, 0, 2, 3, 5] def test_dijkstra_single_node(): N = 1 edges = [] S = 1 assert dijkstra(N, edges, S) == [0] def test_dijkstra_no_path(): N = 3 edges = [(1, 2, 10)] S = 1 assert dijkstra(N, edges, S) == [0, 10, -1] def test_dijkstra_large_weights(): N = 4 edges = [(1, 2, 1000000), (1, 3, 1000000), (2, 4, 1000000), (3, 4, 1000000)] S = 1 assert dijkstra(N, edges, S) == [0, 1000000, 1000000, 2000000] def test_dijkstra_disconnected_graph(): N = 6 edges = [(1, 2, 2), (1, 3, 5), (2, 4, 1), (4, 5, 2)] S = 1 assert dijkstra(N, edges, S) == [0, 2, 5, 3, 5, -1]","solution":"import heapq def dijkstra(N, edges, S): graph = {i: [] for i in range(1, N+1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) distances = {i: float('inf') for i in range(1, N+1)} distances[S] = 0 priority_queue = [(0, S)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return [distances[i] if distances[i] != float('inf') else -1 for i in range(1, N+1)]"},{"question":"from typing import List class SocialMediaPlatform: def __init__(self): pass def post_message(self, timestamp: int, message: str): Posts a message with the given timestamp and message containing hashtags. pass def query_popular_hashtag(self, current_time: int, duration: int) -> str: Queries the most popular hashtag in the given time frame. Args: current_time (int): The current time in minutes from the start. duration (int): The duration in minutes to look back for the query. Returns: str: The most popular hashtag in the time frame, or \\"None\\" if no hashtags are found. pass def process_actions(actions: List[str]) -> List[str]: Processes a list of actions (posts and queries) and returns the results of the queries. Args: actions (List[str]): A list of strings where each string is an action. Returns: List[str]: A list of results for each query action in the input. >>> process_actions([\\"P 1 This is the first post #hashtag1\\", ... \\"P 3 Another post with #hashtag2 #hashtag3\\", ... \\"P 5 More #hashtag1 in this post\\", ... \\"Q 6 4\\", ... \\"P 8 This is a post without hashtag\\", ... \\"Q 9 7\\", ... \\"Q 9 1\\"]) ['#hashtag1', '#hashtag1', 'None'] import pytest from process_actions import process_actions def test_sample_input(): actions = [ \\"P 1 This is the first post #hashtag1\\", \\"P 3 Another post with #hashtag2 #hashtag3\\", \\"P 5 More #hashtag1 in this post\\", \\"Q 6 4\\", \\"P 8 This is a post without hashtag\\", \\"Q 9 7\\", \\"Q 9 1\\" ] assert process_actions(actions) == [\\"#hashtag1\\", \\"#hashtag1\\", \\"None\\"] def test_no_hashtags(): actions = [ \\"P 1 This is the first post\\", \\"P 3 Another post with no hashtag\\", \\"P 5 More posts without hashtags\\", \\"Q 6 4\\", \\"P 8 Another post without hashtag\\", \\"Q 9 7\\", \\"Q 9 1\\" ] assert process_actions(actions) == [\\"None\\", \\"None\\", \\"None\\"] def test_tie_in_hashtags(): actions = [ \\"P 1 Post #tie\\", \\"P 2 Post #tie\\", \\"P 3 Post #another\\", \\"Q 4 3\\", \\"Q 4 2\\" ] assert process_actions(actions) == [\\"#tie\\", \\"#another\\"] def test_no_posts_within_duration(): actions = [ \\"P 1 #one\\", \\"P 2 #two\\", \\"Q 5 1\\", \\"P 6 #three\\", \\"Q 7 1\\" ] assert process_actions(actions) == [\\"None\\", \\"#three\\"] def test_multiple_hashtags_in_message(): actions = [ \\"P 1 #multi #tag #example #multi\\", \\"P 3 #single\\", \\"P 4 #multi\\", \\"Q 5 5\\" ] assert process_actions(actions) == [\\"#multi\\"] def test_no_actions(): actions = [] assert process_actions(actions) == [] def test_no_query_action(): actions = [ \\"P 1 This is the first post #hashtag1\\", \\"P 3 Another post with #hashtag2 #hashtag3\\" ] assert process_actions(actions) == []","solution":"from collections import defaultdict, deque import heapq import re class SocialMediaPlatform: def __init__(self): self.hashtags = defaultdict(int) self.posts = deque() def post_message(self, timestamp, message): # Extract hashtags from the message hashtags_in_message = re.findall(r\\"#w+\\", message) # Add the hashtags to the global counter for hashtag in hashtags_in_message: self.hashtags[hashtag] += 1 # Append the post to the deque self.posts.append((timestamp, hashtags_in_message)) def query_popular_hashtag(self, current_time, duration): start_time = current_time - duration # Remove old posts that are no longer in the time window while self.posts and self.posts[0][0] < start_time: post_timestamp, post_hashtags = self.posts.popleft() for hashtag in post_hashtags: self.hashtags[hashtag] -= 1 if self.hashtags[hashtag] == 0: del self.hashtags[hashtag] # If no hashtags are left, return \\"None\\" if not self.hashtags: return \\"None\\" # Find the most popular hashtags max_frequency = max(self.hashtags.values()) candidates = [hashtag for hashtag, count in self.hashtags.items() if count == max_frequency] # Return the lexicographically smallest hashtag return min(candidates) def process_actions(actions): platform = SocialMediaPlatform() results = [] for action in actions: parts = action.split() if parts[0] == \\"P\\": timestamp = int(parts[1]) message = \\" \\".join(parts[2:]) platform.post_message(timestamp, message) elif parts[0] == \\"Q\\": current_time = int(parts[1]) duration = int(parts[2]) result = platform.query_popular_hashtag(current_time, duration) results.append(result) return results"},{"question":"class Warehouse: A class to manage inventory in a warehouse. Supports adding, updating, and querying item quantities. def __init__(self): pass def add_item(self, item_id: int, quantity: int) -> None: Adds a new item with the specified item_id and quantity. It is guaranteed that the item_id has not been used before. def update_quantity(self, item_id: int, amount: int) -> None: Updates the quantity of the item with the specified item_id by adding the specified amount. It is guaranteed that the item_id exists in the warehouse. def get_quantity(self, item_id: int) -> int: Returns the current quantity of the item with the specified item_id. It is guaranteed that the item_id exists in the warehouse. # Example usage: # warehouse = Warehouse() # warehouse.add_item(101, 50) # warehouse.add_item(102, 30) # warehouse.update_quantity(101, 20) # warehouse.update_quantity(102, -5) # print(warehouse.get_quantity(101)) # Output: 70 # print(warehouse.get_quantity(102)) # Output: 25","solution":"class Warehouse: def __init__(self): # Initialize an empty dictionary to store items with their quantities. self.inventory = {} def add_item(self, item_id: int, quantity: int) -> None: # Add a new item to the inventory with the given item_id and quantity. self.inventory[item_id] = quantity def update_quantity(self, item_id: int, amount: int) -> None: # Update the quantity of the existing item by the given amount. self.inventory[item_id] += amount def get_quantity(self, item_id: int) -> int: # Return the current quantity of the specified item. return self.inventory[item_id]"},{"question":"def is_rotation(s1: str, s2: str) -> bool: Given two strings s1 and s2, return True if s2 is a rotation of s1 using only one call to the method that checks for substring. >>> is_rotation(\\"waterbottle\\", \\"erbottlewat\\") True >>> is_rotation(\\"hello\\", \\"lohel\\") True >>> is_rotation(\\"abcdefg\\", \\"efgabcd\\") True >>> is_rotation(\\"waterbottle\\", \\"erbottlewa\\") False >>> is_rotation(\\"hello\\", \\"lohe\\") False >>> is_rotation(\\"abcdefg\\", \\"efgab\\") False","solution":"def is_rotation(s1, s2): Check if s2 is a rotation of s1. :param s1: First string :param s2: Second string :return: Boolean value indicating if s2 is a rotation of s1 if len(s1) != len(s2): return False return s2 in s1 + s1"},{"question":"def min_minutes_to_evacuate(N: int, A: int, B: int, capacities: List[int]) -> int: Calculate the minimum number of minutes required to evacuate all the people from one side to the other. Parameters: N (int): The number of bridges. A (int): The number of people on the starting side. B (int): The number of people on the destination side initially. capacities (list): A list of integers representing the capacity of each bridge. Returns: int: The minimum number of minutes required or -1 if it is impossible to evacuate all the people. # Example: # >>> min_minutes_to_evacuate(3, 100, 0, [50, 60, 40]) # 1 # >>> min_minutes_to_evacuate(3, 0, 0, [50, 60, 40]) # 0 # >>> min_minutes_to_evacuate(3, 100, 0, [0, 0, 0]) # -1 def test_example(): assert min_minutes_to_evacuate(3, 100, 0, [50, 60, 40]) == 1 def test_zero_people(): assert min_minutes_to_evacuate(3, 0, 0, [50, 60, 40]) == 0 assert min_minutes_to_evacuate(3, 0, 10, [50, 60, 40]) == 0 def test_no_capacity(): assert min_minutes_to_evacuate(3, 100, 0, [0, 0, 0]) == -1 def test_exact_capacity(): assert min_minutes_to_evacuate(3, 150, 0, [50, 50, 50]) == 1 def test_multiple_minutes(): assert min_minutes_to_evacuate(3, 200, 0, [40, 40, 50]) == 2 def test_large_numbers(): assert min_minutes_to_evacuate(3, 10**9, 0, [1000, 1000, 1000]) == 333333 + 1 def test_single_bridge(): assert min_minutes_to_evacuate(1, 10, 0, [1]) == 10 assert min_minutes_to_evacuate(1, 10, 0, [10]) == 1","solution":"def min_minutes_to_evacuate(N, A, B, capacities): Calculate the minimum number of minutes required to evacuate all the people from one side to the other. Parameters: N (int): The number of bridges. A (int): The number of people on the starting side. B (int): The number of people on the destination side initially. capacities (list): A list of integers representing the capacity of each bridge. Returns: int: The minimum number of minutes required or -1 if it is impossible to evacuate all the people. total_capacity_per_minute = sum(capacities) if total_capacity_per_minute == 0 and A > 0: return -1 return (A + total_capacity_per_minute - 1) // total_capacity_per_minute # ceiling division # Example usage: # N, A, B = 3, 100, 0 # capacities = [50, 60, 40] # print(min_minutes_to_evacuate(N, A, B, capacities)) # Output: 1"},{"question":"def balance_parentheses(s: str) -> int: Returns the minimum number of parentheses that must be added to make the string balanced. >>> balance_parentheses(\\"(()\\") == 1 >>> balance_parentheses(\\")))(((\\") == 6 >>> balance_parentheses(\\"()()\\") == 0 >>> balance_parentheses(\\")()(\\") == 2 from solution import balance_parentheses def test_balance_parentheses_already_balanced(): assert balance_parentheses(\\"()()\\") == 0 def test_balance_parentheses_one_missing_closing(): assert balance_parentheses(\\"(()\\") == 1 def test_balance_parentheses_only_closing(): assert balance_parentheses(\\")))(((\\") == 6 def test_balance_parentheses_mixed_unbalanced(): assert balance_parentheses(\\")()(\\") == 2 def test_balance_parentheses_empty_string(): assert balance_parentheses(\\"\\") == 0 def test_balance_parentheses_all_opening(): assert balance_parentheses(\\"(((\\") == 3 def test_balance_parentheses_all_closing(): assert balance_parentheses(\\")))\\") == 3 def test_balance_parentheses_complex_case(): assert balance_parentheses(\\"()(()))((()\\") == 3","solution":"def balance_parentheses(s): Returns the minimum number of parentheses that must be added to make the string balanced. open_count = 0 close_count = 0 for char in s: if char == '(': open_count += 1 elif char == ')': if open_count > 0: open_count -= 1 else: close_count += 1 return open_count + close_count"},{"question":"from typing import List def next_palindrome(x: int) -> int: Find the smallest palindromic number greater than x. pass def find_palindromes(t: int, test_cases: List[int]) -> List[int]: Given the number of test cases and a list of integers, finds the smallest palindromic number greater than each integer in the list. >>> find_palindromes(3, [6, 123, 808]) [7, 131, 818] >>> find_palindromes(2, [1, 9]) [2, 11] >>> find_palindromes(1, [500]) [505] pass","solution":"def next_palindrome(x): Finds the smallest palindromic number greater than x. x += 1 while str(x) != str(x)[::-1]: x += 1 return x def find_palindromes(t, test_cases): Given the number of test cases and a list of integers, finds the smallest palindromic number greater than each integer in the list. results = [] for x in test_cases: results.append(next_palindrome(x)) return results"},{"question":"def generate_flower_bed_pattern(m, k): Generates the flower bed pattern as per described specifications. Parameters: m (int): The size of the pattern (number of rows and columns). k (int): The constant to add to each element. Returns: List[List[int]]: The generated pattern as a 2D list. Example: >>> generate_flower_bed_pattern(3, 2) [[2, 3, 6], [3, 4, 7], [6, 7, 10]] >>> generate_flower_bed_pattern(2, 5) [[5, 6], [6, 7]] def multi_test_cases(pattern_cases): Handles multiple test cases for flower bed pattern generation. Parameters: pattern_cases (List[Tuple[int, int]]): List of tuples containing M and K. Returns: List[List[List[int]]]: List of patterns generated for each test case. Example: >>> multi_test_cases([(3, 2), (2, 5)]) [[[2, 3, 6], [3, 4, 7], [6, 7, 10]], [[5, 6], [6, 7]]]","solution":"def generate_flower_bed_pattern(m, k): Generates the flower bed pattern as per described specifications. Parameters: m (int): The size of the pattern (number of rows and columns). k (int): The constant to add to each element. Returns: List[List[int]]: The generated pattern as a 2D list. pattern = [] for i in range(m): row = [] for j in range(m): element = i ** 2 + j ** 2 + k row.append(element) pattern.append(row) return pattern def multi_test_cases(pattern_cases): Handles multiple test cases for flower bed pattern generation. Parameters: pattern_cases (List[Tuple[int, int]]): List of tuples containing M and K. Returns: List[List[List[int]]]: List of patterns generated for each test case. results = [] for m, k in pattern_cases: results.append(generate_flower_bed_pattern(m, k)) return results"},{"question":"def find_max_sum(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Given T test cases, each containing: - N: Number of elements in the array - L: Maximum length of the subarray - Array: List of N integers Returns a list containing the maximum sum for each test case. >>> find_max_sum(2, [(5, 3, [1, -2, 3, 4, -1]), (4, 2, [-1, -2, 3, 4])]) [7, 7] >>> find_max_sum(1, [(1, 1, [10])]) [10] >>> find_max_sum(1, [(3, 2, [-3, -2, -1])]) [-1] >>> find_max_sum(1, [(6, 4, [4, -1, 2, 1, -5, 4])]) [6] >>> find_max_sum(1, [(5, 3, [0, 0, 0, 0, 0])]) [0] >>> find_max_sum(1, [(3, 3, [1, 2, 3])]) [6] >>> find_max_sum(1, [(500, 500, list(range(1, 501)))]) [125250]","solution":"def find_max_sum(T, test_cases): Given T test cases, each containing: - N: Number of elements in the array - L: Maximum length of the subarray - Array: List of N integers Returns a list containing the maximum sum for each test case. results = [] for t in range(T): N, L, array = test_cases[t] max_sum = float('-inf') for i in range(N): current_sum = 0 for j in range(i, min(i + L, N)): current_sum += array[j] max_sum = max(max_sum, current_sum) results.append(max_sum) return results"},{"question":"def can_be_sorted_with_one_swap(n, array): Determines if the array can be sorted in non-decreasing order by performing at most one swap of two elements. :param n: int, size of the array :param array: list of int, the elements of the array :return: str, \\"Yes\\" if it can be sorted with at most one swap, \\"No\\" otherwise >>> can_be_sorted_with_one_swap(5, [1, 5, 3, 3, 6]) 'Yes' >>> can_be_sorted_with_one_swap(4, [4, 2, 1, 3]) 'No' def process_test_cases(T, cases): Processes multiple test cases and returns the result for each case. :param T: int, number of test cases :param cases: list of tuples, each tuple contains (n: int, array: list of int) :return: list of str, \\"Yes\\" or \\"No\\" for each test case >>> T = 2 >>> cases = [(5, [1, 5, 3, 3, 6]), (4, [4, 2, 1, 3])] >>> process_test_cases(T, cases) ['Yes', 'No'] >>> T = 1 >>> cases = [(5, [1, 2, 3, 4, 5])] # Already sorted >>> process_test_cases(T, cases) ['Yes']","solution":"def can_be_sorted_with_one_swap(n, array): Determines if the array can be sorted in non-decreasing order by performing at most one swap of two elements. :param n: int, size of the array :param array: list of int, the elements of the array :return: str, \\"Yes\\" if it can be sorted with at most one swap, \\"No\\" otherwise sorted_array = sorted(array) diff = [i for i in range(n) if array[i] != sorted_array[i]] if len(diff) == 0: return \\"Yes\\" elif len(diff) == 2: return \\"Yes\\" else: return \\"No\\" def process_test_cases(T, cases): results = [] for case in cases: n, array = case results.append(can_be_sorted_with_one_swap(n, array)) return results"},{"question":"from typing import List def leaf_nodes_with_packet(n: int, parents: List[int], k: int, firewalls: List[int]) -> int: Given a binary tree network and the positions of firewalls, determine how many leaf nodes will receive a packet initially present at the root. Args: n (int): The number of nodes in the tree. parents (List[int]): List where the i-th integer is the parent node of the i-th node or -1 if the i-th node is the root. k (int): The number of firewalls. firewalls (List[int]): List of nodes where firewalls are placed. Returns: int: The number of leaf nodes that will receive the packet. Examples: >>> leaf_nodes_with_packet(7, [-1, 1, 1, 2, 2, 3, 3], 2, [2, 5]) 2 >>> leaf_nodes_with_packet(5, [-1, 1, 1, 2, 3], 1, [3]) 1 >>> leaf_nodes_with_packet(3, [-1, 1, 1], 0, []) 2 # Test cases def test_example_1(): assert leaf_nodes_with_packet(7, [-1, 1, 1, 2, 2, 3, 3], 2, [2, 5]) == 2 def test_example_2(): assert leaf_nodes_with_packet(5, [-1, 1, 1, 2, 3], 1, [3]) == 1 def test_example_3(): assert leaf_nodes_with_packet(3, [-1, 1, 1], 0, []) == 2 def test_no_firewalls(): assert leaf_nodes_with_packet(4, [-1, 1, 1, 2], 0, []) == 2 def test_all_firewalls(): assert leaf_nodes_with_packet(4, [-1, 1, 1, 2], 4, [1, 2, 3, 4]) == 0 def test_single_node_tree(): assert leaf_nodes_with_packet(1, [-1], 0, []) == 1 def test_firewall_at_root(): assert leaf_nodes_with_packet(5, [-1, 1, 1, 2, 3], 1, [1]) == 0","solution":"def leaf_nodes_with_packet(n, parents, k, firewalls): from collections import defaultdict tree = defaultdict(list) root = -1 for i in range(n): if parents[i] == -1: root = i + 1 else: tree[parents[i]].append(i + 1) # Determine which nodes are leaves all_nodes = set(range(1, n + 1)) non_leaf_nodes = set(parents) - {-1} leaf_nodes = list(all_nodes - non_leaf_nodes) # Mark nodes as blocked by firewalls blocked = set() def block_subtree(node): blocked.add(node) for child in tree[node]: block_subtree(child) for fw in firewalls: block_subtree(fw) # Count leaf nodes that will receive the packet packet_reaching_leaf_nodes = 0 for leaf in leaf_nodes: current_node = leaf while current_node != root: if current_node in blocked: break current_node = parents[current_node - 1] else: # The loop didn't break packet_reaching_leaf_nodes += 1 return packet_reaching_leaf_nodes # Example usage: # n = 7 # parents = [-1, 1, 1, 2, 2, 3, 3] # k = 2 # firewalls = [2, 5] # print(leaf_nodes_with_packet(n, parents, k, firewalls)) # Output: 2"},{"question":"def smallest_subsequence(s: str) -> str: Given a string \`s\` representing a sequence of lowercase letters, determine the smallest subsequence that contains all the unique characters in \`s\`. This subsequence must maintain the order of the first occurrence of each character. >>> smallest_subsequence(\\"abcabc\\") == \\"abc\\" >>> smallest_subsequence(\\"cbacdcbc\\") == \\"acdb\\" >>> smallest_subsequence(\\"bbcaac\\") == \\"bac\\"","solution":"def smallest_subsequence(s): Returns the smallest subsequence that contains all the unique characters in \`s\`. This subsequence will maintain the order of the first occurrence of each character. stack = [] seen = set() last_occurrence = {ch: i for i, ch in enumerate(s)} for i, ch in enumerate(s): if ch not in seen: while stack and ch < stack[-1] and i < last_occurrence[stack[-1]]: seen.remove(stack.pop()) seen.add(ch) stack.append(ch) return ''.join(stack)"},{"question":"from datetime import datetime from typing import List, Tuple def can_accommodate(existing_bookings: List[Tuple[str, str]], new_booking: Tuple[str, str]) -> str: Determines if the new booking can be accommodated without overlapping existing bookings. Parameters: - existing_bookings: list of tuples, each containing the start and end time in \\"HH:MM\\" format. - new_booking: tuple containing start and end time in \\"HH:MM\\" format. Returns: - \\"Yes\\" if the new booking can be accommodated, \\"No\\" otherwise. >>> can_accommodate([(\\"09:00\\", \\"10:00\\"), (\\"11:00\\", \\"12:00\\"), (\\"14:00\\", \\"15:00\\")], (\\"12:30\\", \\"13:30\\")) \\"Yes\\" >>> can_accommodate([(\\"09:00\\", \\"10:00\\"), (\\"11:00\\", \\"12:00\\"), (\\"14:00\\", \\"15:00\\")], (\\"10:30\\", \\"11:30\\")) \\"No\\" >>> can_accommodate([(\\"09:00\\", \\"10:00\\"), (\\"11:00\\", \\"12:00\\"), (\\"14:00\\", \\"15:00\\")], (\\"11:30\\", \\"14:30\\")) \\"No\\"","solution":"from datetime import datetime def can_accommodate(existing_bookings, new_booking): Determines if the new booking can be accommodated without overlapping existing bookings. Parameters: - existing_bookings: list of tuples, each containing the start and end time in \\"HH:MM\\" format. - new_booking: tuple containing start and end time in \\"HH:MM\\" format. Returns: - \\"Yes\\" if the new booking can be accommodated, \\"No\\" otherwise. def parse_time(time_str): return datetime.strptime(time_str, \\"%H:%M\\") new_start, new_end = parse_time(new_booking[0]), parse_time(new_booking[1]) for booking in existing_bookings: existing_start, existing_end = parse_time(booking[0]), parse_time(booking[1]) if not (new_end <= existing_start or new_start >= existing_end): return \\"No\\" return \\"Yes\\""},{"question":"def outside_bounds(arr, low, high): Returns a list of elements from the input list 'arr' that are outside the inclusive range defined by 'low' and 'high'. Args: arr (list): List of numbers. low (int/float): Lower boundary (inclusive). high (int/float): Upper boundary (inclusive). Returns: list: List of elements outside the bounds. Examples: >>> outside_bounds([1, 5, 8, 10, 12], 6, 10) [1, 5, 12] >>> outside_bounds([3, 7, 9, 15], 7, 9) [3, 15] >>> outside_bounds([-2, 0, 4, 6, 9], 0, 6) [-2, 9]","solution":"def outside_bounds(arr, low, high): Returns a list of elements from the input list 'arr' that are outside the inclusive range defined by 'low' and 'high'. Args: arr (list): List of numbers. low (int/float): Lower boundary (inclusive). high (int/float): Upper boundary (inclusive). Returns: list: List of elements outside the bounds. return [x for x in arr if x < low or x > high]"},{"question":"from typing import List, Tuple def find_smallest_substring(n: int, q: int, s: str, queries: List[Tuple[int, int, int]]) -> List[str]: Find the lexicographically smallest substring of length k within the substring of s starting from the l-th to the r-th positions, inclusive. Parameters: n (int): the length of the string s. q (int): the number of queries. s (str): a string of lowercase English letters. queries (List[Tuple[int, int, int]]): a list of queries, each represented as a tuple (l_i, r_i, k_i). Returns: List[str]: a list of results for each query. Examples: >>> find_smallest_substring(10, 3, \\"ababacbaba\\", [(1, 10, 3), (3, 8, 2), (1, 5, 4)]) [\\"aba\\", \\"ab\\", \\"abab\\"] >>> find_smallest_substring(5, 2, \\"abcde\\", [(1, 5, 2), (2, 4, 3)]) [\\"ab\\", \\"bcd\\"]","solution":"def find_smallest_substring(n, q, s, queries): results = [] for l, r, k in queries: sub_s = s[l-1:r] smallest = sub_s[:k] for i in range(1, len(sub_s) - k + 1): current = sub_s[i:i+k] if current < smallest: smallest = current results.append(smallest) return results"},{"question":"def rearrange_string(S: str) -> str: Rearranges the characters in the string so that no two adjacent characters are the same. Returns the lexicographically smallest solution or \\"Not Possible\\" if it cannot be done. >>> rearrange_string(\\"aaabb\\") \\"ababa\\" >>> rearrange_string(\\"xxy\\") \\"xyx\\" >>> rearrange_string(\\"aaa\\") \\"Not Possible\\"","solution":"import heapq from collections import Counter def rearrange_string(S): Rearranges the characters in the string so that no two adjacent characters are the same. Returns the lexicographically smallest solution or \\"Not Possible\\" if it cannot be done. counter = Counter(S) max_count = (len(S) + 1) // 2 for count in counter.values(): if count > max_count: return \\"Not Possible\\" heap = [] for char, count in counter.items(): heapq.heappush(heap, (-count, char)) prev_char, prev_count = '', 0 result = [] while heap: count, char = heapq.heappop(heap) result.append(char) if prev_count < 0: heapq.heappush(heap, (prev_count, prev_char)) prev_char = char prev_count = count + 1 return ''.join(result)"},{"question":"def find_min_roads_to_connect_cities(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[int]: Determine the minimum number of roads required to ensure that any two cities in the kingdom are connected directly or indirectly via these roads. >>> find_min_roads_to_connect_cities(2, [(4, 2, [(1, 2, 3), (3, 4, 5)]), (3, 1, [(1, 2, 1)])]) [3, 2] >>> find_min_roads_to_connect_cities(1, [(3, 3, [(1, 2, 2), (2, 3, 2), (1, 3, 2)])]) [2] >>> find_min_roads_to_connect_cities(1, [(5, 0, [])]) [4] >>> find_min_roads_to_connect_cities(1, [(1, 0, [])]) [0] >>> find_min_roads_to_connect_cities(1, [(5, 4, [(1, 2, 5), (2, 3, 6), (3, 4, 7), (4, 5, 8)])]) [4]","solution":"def find_min_roads_to_connect_cities(t, test_cases): def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 results = [] for n, m, roads in test_cases: parent = list(range(n + 1)) rank = [0] * (n + 1) edge_count = 0 roads.sort(key=lambda x: x[2]) for road in roads: u, v, w = road uroot = find(parent, u) vroot = find(parent, v) if uroot != vroot: union(parent, rank, uroot, vroot) edge_count += 1 results.append(n - 1) return results"},{"question":"def longest_substring_with_two_distinct_chars(s: str) -> str: Write a function that takes a string as input and returns the longest substring that contains at most two distinct characters. # Examples >>> longest_substring_with_two_distinct_chars(\\"eceba\\") 'ece' >>> longest_substring_with_two_distinct_chars(\\"ccaabbb\\") 'aabbb' >>> longest_substring_with_two_distinct_chars(\\"abcbbbbcccbdddadacb\\") 'bcbbbbcccb'","solution":"def longest_substring_with_two_distinct_chars(s): if len(s) < 3: return s left = 0 right = 0 max_len = 2 max_substr = s[:2] char_map = {} while right < len(s): char_map[s[right]] = right right += 1 if len(char_map) > 2: del_idx = min(char_map.values()) del char_map[s[del_idx]] left = del_idx + 1 if right - left > max_len: max_len = right - left max_substr = s[left:right] return max_substr"},{"question":"def determine_sort_order(N, arr): Determines if the list is sorted in non-decreasing order, strictly decreasing order, or neither. Parameters: - N: int, the number of elements in the list. - arr: list of int, the elements of the list. Returns: - str, \\"Non-Decreasing\\", \\"Strictly Decreasing\\", or \\"Not Sorted\\" based on the order of the list. # Unit tests def test_determine_sort_order(): assert determine_sort_order(5, [1, 2, 2, 3, 4]) == \\"Non-Decreasing\\" assert determine_sort_order(4, [10, 9, 8, 7]) == \\"Strictly Decreasing\\" assert determine_sort_order(6, [3, 5, 1, 4, 2, 6]) == \\"Not Sorted\\" assert determine_sort_order(1, [0]) == \\"Non-Decreasing\\" assert determine_sort_order(3, [1, 2, 3]) == \\"Non-Decreasing\\" assert determine_sort_order(3, [3, 2, 1]) == \\"Strictly Decreasing\\" assert determine_sort_order(2, [2, 2]) == \\"Non-Decreasing\\" assert determine_sort_order(2, [2, 3]) == \\"Non-Decreasing\\" assert determine_sort_order(2, [3, 2]) == \\"Strictly Decreasing\\" if __name__ == \\"__main__\\": test_determine_sort_order() print(\\"All tests passed.\\")","solution":"def determine_sort_order(N, arr): Determines if the list is sorted in non-decreasing order, strictly decreasing order, or neither. Parameters: - N: int, the number of elements in the list. - arr: list of int, the elements of the list. Returns: - str, \\"Non-Decreasing\\", \\"Strictly Decreasing\\", or \\"Not Sorted\\" based on the order of the list. if all(arr[i] <= arr[i+1] for i in range(N-1)): return \\"Non-Decreasing\\" elif all(arr[i] > arr[i+1] for i in range(N-1)): return \\"Strictly Decreasing\\" else: return \\"Not Sorted\\" # Example usage N = 5 arr = [1, 2, 2, 3, 4] print(determine_sort_order(N, arr)) # Output: Non-Decreasing"},{"question":"def max_treasures(m, n, grid): Calculate the maximum number of treasures that can be collected from the top-left to the bottom-right of a grid. Grid elements: 0: empty cell -1: obstacle positive integer: number of treasures The function implements a dynamic programming approach to find the optimal path. Args: m (int): number of rows in the grid. n (int): number of columns in the grid. grid (List[List[int]]): the grid represented as a list of lists. Returns: int: the maximum number of treasures that can be collected. >>> max_treasures(3, 4, [[0, 1, 0, -1], [2, 0, 1, 2], [0, 2, -1, 1]]) 6 >>> max_treasures(3, 3, [[0, 1, 0], [2, 0, 1], [0, 2, -1]]) 0 Unit Test: def test_basic_case(): grid = [ [0, 1, 0, -1], [2, 0, 1, 2], [0, 2, -1, 1] ] assert max_treasures(3, 4, grid) == 6 def test_obstacle_at_start(): grid = [ [-1, 1, 0], [0, 0, 1], [2, 3, 1] ] assert max_treasures(3, 3, grid) == 0 def test_obstacle_at_end(): grid = [ [0, 1, 0], [2, 0, 1], [0, 2, -1] ] assert max_treasures(3, 3, grid) == 0 def test_single_row(): grid = [ [0, 1, 2, 3] ] assert max_treasures(1, 4, grid) == 6 def test_single_column(): grid = [ [0], [1], [2], [3] ] assert max_treasures(4, 1, grid) == 6 def test_all_obstacles(): grid = [ [-1, -1, -1], [-1, -1, -1], [-1, -1, -1] ] assert max_treasures(3, 3, grid) == 0 def test_no_obstacles(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_treasures(3, 3, grid) == 29 def test_large_grid(): grid = [ [0]*1000 for _ in range(1000) ] grid[0][0] = 1 grid[999][999] = 2 assert max_treasures(1000, 1000, grid) == 3","solution":"def max_treasures(m, n, grid): if grid[0][0] == -1 or grid[m-1][n-1] == -1: return 0 # Initialize a 2D dp array with -inf for obstacles dp = [[-float('inf')] * n for _ in range(m)] dp[0][0] = grid[0][0] # Fill the dp table for i in range(m): for j in range(n): if grid[i][j] == -1: continue if i > 0 and dp[i-1][j] != -float('inf'): dp[i][j] = max(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0 and dp[i][j-1] != -float('inf'): dp[i][j] = max(dp[i][j], dp[i][j-1] + grid[i][j]) return max(dp[m-1][n-1], 0)"},{"question":"def solution(queries): Given a list of integers queries, return a list of counts of distinct prime pairs for each query. Example: >>> solution([10, 6, 8]) [2, 1, 1]","solution":"def sieve(limit): Generate a list of boolean values indicating whether numbers from \`0\` to \`limit\` are prime. is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False for num in range(2, int(limit**0.5) + 1): if is_prime[num]: for multiple in range(num*num, limit + 1, num): is_prime[multiple] = False return is_prime def prime_pairs_count(x, primes_set): Count the number of distinct pairs of prime numbers (a, b) such that a + b = x. count = 0 for a in range(2, x//2 + 1): b = x - a if a in primes_set and b in primes_set and a <= b: count += 1 return count def solution(queries): Given a list of integers queries, return a list of counts of distinct prime pairs for each query. max_x = max(queries) is_prime = sieve(max_x) primes_set = {i for i, prime in enumerate(is_prime) if prime} results = [] for x in queries: results.append(prime_pairs_count(x, primes_set)) return results if __name__ == \\"__main__\\": Q = int(input().strip()) queries = [int(input().strip()) for _ in range(Q)] results = solution(queries) for result in results: print(result)"},{"question":"def longest_subarray_with_same_value(arr: List[int]) -> int: Returns the length of the longest subarray with the same value. Parameters: arr (list): A list of integers. Returns: int: The length of the longest subarray with the same value. >>> longest_subarray_with_same_value([1, 1, 2, 2, 2, 3, 3]) == 3 >>> longest_subarray_with_same_value([5, 5, 5, 5, 5]) == 5 >>> longest_subarray_with_same_value([1, 2, 3, 3, 2, 1]) == 2 >>> longest_subarray_with_same_value([4, -4, 4, 4, -4, -4, -4, 4]) == 3 >>> longest_subarray_with_same_value([]) == 0 >>> longest_subarray_with_same_value([1, 2, 3, 4, 5]) == 1 >>> longest_subarray_with_same_value([1]) == 1","solution":"def longest_subarray_with_same_value(arr): Returns the length of the longest subarray with the same value. Parameters: arr (list): A list of integers. Returns: int: The length of the longest subarray with the same value. if not arr: return 0 max_len = 1 current_len = 1 for i in range(1, len(arr)): if arr[i] == arr[i-1]: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 return max(max_len, current_len)"},{"question":"from typing import List def group_anagrams(strings: List[str]) -> List[List[str]]: Groups anagrams together from the list of input strings. Params: strings (List[str]): A list of strings. Returns: List[List[str]]: A list of lists where each sublist contains anagrams. >>> group_anagrams(['eat', 'tea', 'tan', 'ate']) [['eat', 'tea', 'ate'], ['tan']] >>> group_anagrams([]) []","solution":"from collections import defaultdict def group_anagrams(strings): Groups anagrams together from the list of input strings. Params: strings (List[str]): A list of strings. Returns: List[List[str]]: A list of lists where each sublist contains anagrams. anagrams = defaultdict(list) for s in strings: key = ''.join(sorted(s)) anagrams[key].append(s) return list(anagrams.values())"},{"question":"def final_tree_heights(N: int, K: int, L: int, heights: List[int]) -> List[int]: Finds the final heights of the trees after K days of growth. Parameters: N (int): number of trees K (int): number of days L (int): range of influence in either direction heights (list): initial heights of the trees Returns: list: final heights of the trees >>> final_tree_heights(5, 2, 1, [1, 2, 3, 2, 1]) [3, 3, 3, 3, 3] >>> final_tree_heights(4, 1, 2, [4, 1, 4, 1]) [4, 4, 4, 4] >>> final_tree_heights(7, 3, 2, [5, 3, 9, 1, 4, 6, 8]) [9, 9, 9, 9, 9, 9, 9] >>> final_tree_heights(3, 0, 1, [2, 5, 3]) [2, 5, 3] >>> final_tree_heights(1, 5, 1, [10]) [10] >>> final_tree_heights(4, 100, 2, [1, 5, 1, 1]) [5, 5, 5, 5] >>> final_tree_heights(5, 1, 5, [5, 10, 3, 1, 6]) [10, 10, 10, 10, 10] >>> final_tree_heights(3, 10, 1, [7, 7, 7]) [7, 7, 7]","solution":"def final_tree_heights(N, K, L, heights): Finds the final heights of the trees after K days of growth. Parameters: N (int): number of trees K (int): number of days L (int): range of influence in either direction heights (list): initial heights of the trees Returns: list: final heights of the trees for _ in range(K): new_heights = heights[:] for i in range(N): left = max(0, i - L) right = min(N - 1, i + L) new_heights[i] = max(heights[left:right + 1]) heights = new_heights return heights"},{"question":"def min_balanced_substring_length(k: int, s: str) -> int: Given a string and a number k, find the minimum length of a contiguous substring that is balanced. A balanced substring is defined as a substring in which every letter from the alphabet appears an equal number of times. If no such substring exists, return -1. :param k: Integer, the number of distinct letters to balance in the substring. :param s: String, consisting of lowercase English letters. :return: Integer, the minimum length of a balanced substring or -1 if no such substring exists. >>> min_balanced_substring_length(2, \\"abba\\") 2 >>> min_balanced_substring_length(3, \\"abcabc\\") 3 >>> min_balanced_substring_length(2, \\"xyz\\") -1 >>> min_balanced_substring_length(1, \\"a\\") 1 >>> min_balanced_substring_length(2, \\"aaaaabbbbbb\\") 2 >>> min_balanced_substring_length(26, \\"abcdefghijklmnopqrstuvwxyz\\") 26 def process_inputs(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Process multiple test cases to find the minimum length of a balanced substring for each. :param t: Integer, the number of test cases. :param test_cases: List of tuples, each containing an integer 'k' and a string 's'. :return: List of integers, each denoting the minimum length of a balanced substring for respective test case. >>> process_inputs(2, [(2, \\"abba\\"), (3, \\"abcabc\\")]) [2, 3] >>> process_inputs(1, [(2, \\"xyz\\")]) [-1] >>> process_inputs(1, [(1, \\"a\\")]) [1] >>> process_inputs(1, [(2, \\"aaaaabbbbbb\\")]) [2] >>> process_inputs(1, [(26, \\"abcdefghijklmnopqrstuvwxyz\\")]) [26]","solution":"def min_balanced_substring_length(k, s): from collections import defaultdict target_count = {chr(97 + i): 1 for i in range(k)} needed_chars = set(target_count.keys()) min_length = float('inf') left = 0 char_count = defaultdict(int) current_chars = set() for right, char in enumerate(s): if char in needed_chars: char_count[char] += 1 current_chars.add(char) while len(current_chars) == len(needed_chars): min_length = min(min_length, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: current_chars.remove(s[left]) left += 1 return min_length if min_length != float('inf') else -1 def process_inputs(t, test_cases): results = [] for k, s in test_cases: results.append(min_balanced_substring_length(k, s)) return results"},{"question":"def can_combine_trees(Z: int, W: int) -> str: Determines whether there exists a combination of tall (height 5) and short (height 3) trees such that the gardener's statement holds true. Parameters: Z (int): Total number of trees. W (int): Combined height of all trees. Returns: str: \\"Yes\\" if there exists a valid combination, otherwise \\"No\\". >>> can_combine_trees(4, 16) 'Yes' >>> can_combine_trees(4, 20) 'Yes' >>> can_combine_trees(5, 15) 'Yes' >>> can_combine_trees(3, 17) 'No' >>> can_combine_trees(5, 19) 'Yes' >>> can_combine_trees(1, 5) 'Yes' >>> can_combine_trees(1, 3) 'Yes' >>> can_combine_trees(100, 500) 'Yes' >>> can_combine_trees(100, 499) 'No'","solution":"def can_combine_trees(Z, W): Determines whether there exists a combination of tall (height 5) and short (height 3) trees such that the gardener's statement holds true. Parameters: Z (int): Total number of trees. W (int): Combined height of all trees. Returns: str: \\"Yes\\" if there exists a valid combination, otherwise \\"No\\". for tall_trees in range(Z + 1): short_trees = Z - tall_trees if (tall_trees * 5 + short_trees * 3) == W: return \\"Yes\\" return \\"No\\""},{"question":"from typing import List def knapsack(weights: List[int], max_weight: int) -> int: Determines the maximum total weight that can be carried in the knapsack without exceeding the weight limit. :param weights: List[int] - A list of integers representing the weights of items. :param max_weight: int - An integer representing the maximum weight the knapsack can carry. :return: int - The maximum total weight that can be carried in the knapsack without exceeding the max_weight. >>> knapsack([1, 3, 4, 5], 7) 7 >>> knapsack([1, 2, 3, 8], 5) 5 >>> knapsack([2, 2, 4, 6], 10) 10 pass def test_knapsack(): assert knapsack([1, 3, 4, 5], 7) == 7 assert knapsack([1, 2, 3, 8], 5) == 5 assert knapsack([2, 2, 4, 6], 10) == 10 assert knapsack([1, 3, 5], 4) == 4 assert knapsack([4, 5, 6, 7], 3) == 0 assert knapsack([4, 5, 1], 5) == 5 assert knapsack([3, 3, 3], 3) == 3 assert knapsack([3, 3, 3], 6) == 6 assert knapsack([2, 3, 5, 8, 13], 20) == 20 assert knapsack([1], 1) == 1 assert knapsack([100], 100) == 100 assert knapsack([2, 2, 2, 2, 2], 10) == 10 assert knapsack([2, 2, 2, 2, 2], 9) == 8","solution":"from typing import List def knapsack(weights: List[int], max_weight: int) -> int: Determines the maximum total weight that can be carried in the knapsack without exceeding the weight limit. This is a classic 0/1 knapsack problem solved using dynamic programming. n = len(weights) dp = [0] * (max_weight + 1) for weight in weights: for w in range(max_weight, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + weight) return dp[max_weight]"},{"question":"import heapq from typing import List, Tuple, Union def task_management(queries: List[str]) -> List[Union[int, str]]: Manages a list of tasks, allowing adding tasks, completing tasks, and querying the highest priority uncompleted task. Args: queries: List of strings containing the commands to be executed. Returns: List of results for the \\"QUERY\\" commands. Each result is the highest priority uncompleted task or \\"NONE\\" if there are no uncompleted tasks. Examples: >>> task_management([\\"ADD 5\\", \\"QUERY\\"]) [5] >>> task_management([\\"ADD 5\\", \\"COMPLETE 5\\", \\"QUERY\\"]) [\\"NONE\\"] >>> task_management([\\"ADD 5\\", \\"ADD 3\\", \\"QUERY\\"]) [3] >>> task_management([\\"ADD 5\\", \\"ADD 3\\", \\"ADD 1\\", \\"COMPLETE 3\\", \\"QUERY\\"]) [1]","solution":"import heapq def task_management(queries): tasks = [] completed_tasks = set() result = [] for query in queries: parts = query.split() command = parts[0] if command == \\"ADD\\": priority = int(parts[1]) heapq.heappush(tasks, priority) elif command == \\"COMPLETE\\": priority = int(parts[1]) completed_tasks.add(priority) elif command == \\"QUERY\\": while tasks and tasks[0] in completed_tasks: heapq.heappop(tasks) if tasks: result.append(tasks[0]) else: result.append(\\"NONE\\") return result"},{"question":"from typing import List, Tuple def min_moves(grid: List[List[int]], start: Tuple[int, int], destination: Tuple[int, int]) -> int: Determine the minimum number of moves required for a robot to move a product from a starting cell to a destination cell within the grid. Args: grid (List[List[int]]): A 2D list of integers where 0 represents an open cell and 1 represents an obstacle. start (Tuple[int, int]): A tuple (sx, sy) representing the starting cell coordinates. destination (Tuple[int, int]): A tuple (dx, dy) representing the destination cell coordinates. Returns: int: The minimum number of moves required, or -1 if it's not possible. >>> grid = [ ... [0, 0, 0, 1], ... [0, 1, 0, 0], ... [0, 0, 0, 0], ... [1, 0, 1, 0] ... ] >>> start = (0, 0) >>> destination = (2, 2) >>> min_moves(grid, start, destination) 4 >>> grid = [ ... [0, 1, 0], ... [1, 0, 1], ... [0, 0, 0] ... ] >>> start = (2, 0) >>> destination = (0, 2) >>> min_moves(grid, start, destination) -1 pass","solution":"from typing import List, Tuple from collections import deque def min_moves(grid: List[List[int]], start: Tuple[int, int], destination: Tuple[int, int]) -> int: M, N = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def in_bounds(x, y): return 0 <= x < M and 0 <= y < N def bfs(): queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == destination: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if in_bounds(nx, ny) and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 return bfs()"},{"question":"def calculate_expression(expression: str) -> str: Evaluates a mathematical expression given as a string with 'times' and 'divided' representing multiplication and division respectively. Returns the result as a string. >>> calculate_expression(\\"3times4times2\\") \\"24\\" >>> calculate_expression(\\"12divided2times3\\") \\"18.0\\"","solution":"def calculate_expression(expression): Evaluates a mathematical expression given as a string with 'times' and 'divided' representing multiplication and division respectively. Returns the result as a string. # Replace 'times' with '*' and 'divided' with '/' expression = expression.replace('times', '*').replace('divided', '/') # Use eval to calculate the result result = eval(expression) # Return the result as a string return str(result)"},{"question":"def find_triplet_num(N: int, nums: List[int]) -> Union[int, str]: Determines if any of the given positive integers appears at least three times in the list. If so, returns the first such number from the highest index encounter. If no number appears at least three times, returns \\"No\\". >>> find_triplet_num(7, [4, 5, 2, 4, 4, 3, 5]) 4 >>> find_triplet_num(6, [1, 2, 3, 2, 1, 3]) \\"No\\"","solution":"def find_triplet_num(N, nums): Determines if any of the given positive integers appears at least three times in the list. If so, returns the first such number from the highest index encounter. If no number appears at least three times, returns \\"No\\". from collections import Counter count = Counter(nums) for num in reversed(nums): if count[num] >= 3: return num return \\"No\\""},{"question":"def exists_triplet_product(arr, target): Determines whether there exist three indices i, j, k (i, j and k should be different) such that the product of the elements at these indices is equal to the given target value. >>> exists_triplet_product([1, 2, 3, 4, 5], 6) \\"Yes\\" >>> exists_triplet_product([1, 2, 3, 4, 5], 50) \\"No\\" >>> exists_triplet_product([-1, -2, -3, 3, 2, 1], -6) \\"Yes\\" >>> exists_triplet_product([10], 100) \\"No\\" >>> exists_triplet_product([10**9, -10**9, 1], -10**27) \\"No\\" >>> exists_triplet_product([], 10) \\"No\\" >>> exists_triplet_product([0, 1, 2, 3], 0) \\"Yes\\" >>> exists_triplet_product([0, -1, -2, -3], 0) \\"Yes\\" >>> exists_triplet_product([0, 0, 0], 0) \\"Yes\\" >>> exists_triplet_product([1, 2, 3], 0) \\"No\\"","solution":"def exists_triplet_product(arr, target): Determines whether there exist three indices i, j, k (i, j and k should be different) such that the product of the elements at these indices is equal to the given target value. n = len(arr) for i in range(n): for j in range(i + 1, n): for k in range(j + 1, n): if arr[i] * arr[j] * arr[k] == target: return \\"Yes\\" return \\"No\\" # Input reading for the function def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:-1])) target = int(data[-1]) result = exists_triplet_product(arr, target) print(result) if __name__ == \\"__main__\\": main()"},{"question":"def max_valid_groups(n: int, heights: List[int]) -> int: Determine the maximum number of valid groups of 3 students with non-decreasing heights that can be formed from the list of heights. >>> max_valid_groups(6, [1, 2, 3, 4, 5, 6]) 2 >>> max_valid_groups(10, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) 3 >>> max_valid_groups(2, [1, 2]) 0 >>> max_valid_groups(9, [3, 3, 3, 3, 3, 3, 3, 3, 3]) 3 >>> max_valid_groups(7, [10, 5, 20, 15, 1, 1, 1]) 2 >>> max_valid_groups(100000, list(range(1, 100001))) 33333","solution":"def max_valid_groups(n, heights): Determines the maximum number of valid groups of 3 students with non-decreasing heights that can be formed from the list of heights. # Sort the heights in non-decreasing order heights.sort() # The maximum number of groups will be limited by floor(n / 3) max_groups = n // 3 return max_groups"},{"question":"def is_prime(n): Determines if a number is prime. def find_primes_in_list(numbers): Returns a list of prime numbers found in the input list, sorted in ascending order. def main(N, str_numbers): N is the number of elements in the list. str_numbers is a string of space-separated integers. This function should print the sorted prime numbers in ascending order. # Example N = 7 str_numbers = \\"10 15 3 7 22 13 27\\" main(N, str_numbers)","solution":"def is_prime(n): Determines if a number is prime. if n <= 1: return False if n == 2: return True # 2 is the only even prime number if n % 2 == 0: return False # all other even numbers are not primes sqrt_n = int(n**0.5) + 1 for i in range(3, sqrt_n, 2): if n % i == 0: return False return True def find_primes_in_list(numbers): Returns a list of prime numbers found in the input list, sorted in ascending order. primes = [number for number in numbers if is_prime(number)] primes.sort() return primes def main(N, str_numbers): N is the number of elements in the list. str_numbers is a string of space-separated integers. This function should print the sorted prime numbers in ascending order. numbers = list(map(int, str_numbers.split())) primes = find_primes_in_list(numbers) print(' '.join(map(str, primes))) # Example N = 7 str_numbers = \\"10 15 3 7 22 13 27\\" main(N, str_numbers)"},{"question":"def sumOfSquares(N: int) -> int: Function to compute the sum of squares of the first N natural numbers. Args: N (int): The number of first natural numbers to compute the sum of squares. Returns: int: The sum of squares of the first N natural numbers. >>> sumOfSquares(3) 14 >>> sumOfSquares(5) 55","solution":"def sumOfSquares(N): Function to compute the sum of squares of the first N natural numbers. Args: N (int): The number of first natural numbers to compute the sum of squares. Returns: int: The sum of squares of the first N natural numbers. return N * (N + 1) * (2 * N + 1) // 6"},{"question":"def countPairsWithSum(nums, target): Returns the number of pairs of distinct indices (i, j) such that the elements at those indices add up to the target sum. Example 1: >>> countPairsWithSum([1, 5, 7, -1, 5], 6) 3 Example 2: >>> countPairsWithSum([1, 1, 1, 1], 2) 6 Example 3: >>> countPairsWithSum([1, 2, 3, 4, 5], 9) 1 Example 4: >>> countPairsWithSum([1, 2, 3, 4, 5], 10) 0 Example 5: >>> countPairsWithSum([], 6) 0 Example 6: >>> countPairsWithSum([3, 3, 3, 3], 6) 6","solution":"def countPairsWithSum(nums, target): Returns the number of pairs of indices (i, j) such that nums[i] + nums[j] equals target. freq_map = {} count = 0 for num in nums: complement = target - num if complement in freq_map: count += freq_map[complement] if num in freq_map: freq_map[num] += 1 else: freq_map[num] = 1 return count"},{"question":"def is_possible_to_sort(n: int, A: List[int]) -> str: Bob's goal is to determine whether it is possible to sort the array A in non-decreasing order using a series of swap operations. The swap operation allows swapping any two distinct indices i and j (1 ≤ i, j ≤ N) such that |i - j| ≤ 2. Args: n (int): the size of the array A A (list): the array of integers Returns: str: \\"YES\\" if it is possible to sort the array, otherwise \\"NO\\" >>> is_possible_to_sort(4, [3, 1, 4, 2]) \\"YES\\" >>> is_possible_to_sort(4, [4, 3, 2, 1]) \\"NO\\"","solution":"def is_possible_to_sort(n, A): Determine if it is possible to sort the array A of size n using the allowed swap operations. Args: n (int): the size of the array A A (list): the array of integers Returns: str: \\"YES\\" if it is possible to sort the array, otherwise \\"NO\\" for i in range(n): while A[i] != i + 1: diff = abs(A[i] - (i + 1)) if diff > 2: return \\"NO\\" if i + 1 < n and A[i + 1] == i + 1: A[i], A[i + 1] = A[i + 1], A[i] elif i + 2 < n and A[i + 2] == i + 1: A[i], A[i + 2] = A[i + 2], A[i] else: return \\"NO\\" return \\"YES\\""},{"question":"def find_max_scores(employee_scores, queries): Finds the maximum performance scores for each employee within given query ranges. Args: employee_scores: A list of lists, where each inner list contains daily performance scores of an employee. queries: A list of tuples, where each tuple contains two integers (A, B) representing the range of days. Returns: A list of lists, where each inner list contains the maximum scores for each employee for the corresponding query. # Unit Test def test_single_employee_single_query(): employee_scores = [[10, 5, 8, 6, 7]] queries = [(1, 3)] assert find_max_scores(employee_scores, queries) == [[10]] def test_multiple_employees_single_query(): employee_scores = [ [10, 5, 8, 6, 7], [3, 6, 2, 9, 1] ] queries = [(1, 3)] assert find_max_scores(employee_scores, queries) == [[10, 6]] def test_single_employee_multiple_queries(): employee_scores = [[10, 5, 8, 6, 7]] queries = [(1, 3), (2, 4), (1, 5)] assert find_max_scores(employee_scores, queries) == [[10], [8], [10]] def test_multiple_employees_multiple_queries(): employee_scores = [ [10, 5, 8, 6, 7], [3, 6, 2, 9, 1] ] queries = [(1, 3), (2, 4), (1, 5)] assert find_max_scores(employee_scores, queries) == [ [10, 6], [8, 9], [10, 9] ] def test_edge_case_single_day(): employee_scores = [[8]] queries = [(1, 1)] assert find_max_scores(employee_scores, queries) == [[8]] def test_edge_case_full_range(): employee_scores = [ [2, 4, 6, 8, 10], [1, 3, 5, 7, 9] ] queries = [(1, 5)] assert find_max_scores(employee_scores, queries) == [[10, 9]]","solution":"def find_max_scores(employee_scores, queries): Finds the maximum performance scores for each employee within given query ranges. Args: employee_scores: A list of lists, where each inner list contains daily performance scores of an employee. queries: A list of tuples, where each tuple contains two integers (A, B) representing the range of days. Returns: A list of lists, where each inner list contains the maximum scores for each employee for the corresponding query. results = [] for A, B in queries: max_scores = [max(scores[A-1:B]) for scores in employee_scores] results.append(max_scores) return results # Parse input def main(): import sys input = sys.stdin.read data = input().split() index = 0 N = int(data[index]) index += 1 employee_scores = [] for _ in range(N): T = int(data[index]) scores = list(map(int, data[index+1:index+1+T])) employee_scores.append(scores) index += 1 + T Q = int(data[index]) index += 1 queries = [] for _ in range(Q): A = int(data[index]) B = int(data[index+1]) queries.append((A, B)) index += 2 results = find_max_scores(employee_scores, queries) for result in results: print(\\" \\".join(map(str, result))) if __name__ == \\"__main__\\": main()"},{"question":"import math from typing import List def generate_array_with_perfect_square_sum(n: int) -> List[int]: Generate n distinct integers such that their sum is a perfect square. All integers are between 1 and 10^5. >>> generate_array_with_perfect_square_sum(1) [1] >>> generate_array_with_perfect_square_sum(2) [1, 2, ...] def solve(test_cases: List[int]) -> List[List[int]]: Solve multiple test cases for generating arrays with perfect square sums. >>> solve([1, 2, 3, 4]) [[1], [1, 2, ...], [1, 2, 3, ...], [1, 2, 3, 4, ...]] results = [] for n in test_cases: results.append(generate_array_with_perfect_square_sum(n)) return results # Unit Tests def test_generate_array_with_n_equals_1(): result = generate_array_with_perfect_square_sum(1) assert len(result) == 1 assert math.isqrt(sum(result)) ** 2 == sum(result) def test_generate_array_with_n_equals_2(): result = generate_array_with_perfect_square_sum(2) assert len(result) == 3 assert math.isqrt(sum(result)) ** 2 == sum(result) def test_generate_array_with_n_equals_3(): result = generate_array_with_perfect_square_sum(3) assert len(result) == 4 assert math.isqrt(sum(result)) ** 2 == sum(result) def test_generate_array_with_n_equals_4(): result = generate_array_with_perfect_square_sum(4) assert len(result) == 5 assert math.isqrt(sum(result)) ** 2 == sum(result) def test_multiple_cases(): test_cases = [1, 2, 3, 4] expected_lengths = [1, 3, 4, 5] results = solve(test_cases) for idx, result in enumerate(results): assert len(result) == expected_lengths[idx] assert math.isqrt(sum(result)) ** 2 == sum(result)","solution":"import math def generate_array_with_perfect_square_sum(n): Generate n distinct integers such that their sum is a perfect square. All integers are between 1 and 10^5. arr = list(range(1, n + 1)) arr_sum = sum(arr) # Check if the sum is already a perfect square if math.isqrt(arr_sum) ** 2 == arr_sum: return arr # Find the smallest number to add that results in a perfect square sum. k = 1 while True: if math.isqrt(arr_sum + k) ** 2 == arr_sum + k: arr.append(k) break k += 1 return arr def solve(test_cases): results = [] for n in test_cases: results.append(generate_array_with_perfect_square_sum(n)) return results"},{"question":"def can_segment_string(s: str, word_list: List[str]) -> str: Determine if the string can be segmented into a sequence of one or more dictionary words from the given list. >>> can_segment_string(\\"leetcode\\", [\\"leet\\", \\"code\\", \\"apple\\", \\"pen\\"]) \\"YES\\" >>> can_segment_string(\\"applepenapple\\", [\\"apple\\", \\"pen\\", \\"pine\\", \\"taco\\"]) \\"YES\\" >>> can_segment_string(\\"catsanddog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) \\"YES\\" >>> can_segment_string(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) \\"NO\\"","solution":"def can_segment_string(s, word_list): word_set = set(word_list) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return \\"YES\\" if dp[-1] else \\"NO\\""},{"question":"def smallest_palindrome(s: str) -> str: Given a string \`s\`, check if it can be rearranged to form a palindrome. If it is possible, return the lexicographically smallest palindrome that can be formed. Otherwise, return an empty string. >>> smallest_palindrome(\\"aabb\\") \\"abba\\" >>> smallest_palindrome(\\"abc\\") \\"\\" >>> smallest_palindrome(\\"a\\") \\"a\\" >>> smallest_palindrome(\\"aa\\") \\"aa\\" >>> smallest_palindrome(\\"aaa\\") \\"aaa\\"","solution":"def smallest_palindrome(s: str) -> str: from collections import Counter count = Counter(s) # Count the number of characters that appear an odd number of times odd_count = sum(1 for freq in count.values() if freq % 2 != 0) # If there is more than one character with an odd frequency, it is impossible to form a palindrome if odd_count > 1: return \\"\\" # Characters to form the first half and the middle of the palindrome if necessary first_half = [] middle = [] for char, freq in sorted(count.items()): first_half.append(char * (freq // 2)) if freq % 2 != 0: middle.append(char) # Join the pieces to form the smallest lexicographical palindrome first_half = ''.join(first_half) second_half = first_half[::-1] middle = ''.join(middle) return first_half + middle + second_half"},{"question":"def remove_pattern(s: str, p: str) -> str: Removes all substrings in s that match the pattern p. Parameters: - s (str): The input string. - p (str): The pattern string to remove. Returns: - str: The resulting string after removing all occurrences of p. >>> remove_pattern(\\"aabbcc\\", \\"ab\\") 'abcc' >>> remove_pattern(\\"hellohelltohellhe\\", \\"hell\\") 'otohe' >>> remove_pattern(\\"aabbcc\\", \\"xyz\\") 'aabbcc' >>> remove_pattern(\\"aabbcc\\", \\"\\") 'aabbcc' >>> remove_pattern(\\"\\", \\"ab\\") '' >>> remove_pattern(\\"abc\\", \\"abcd\\") 'abc' >>> remove_pattern(\\"aaaa\\", \\"a\\") '' >>> remove_pattern(\\"aaa\\", \\"aa\\") 'a'","solution":"def remove_pattern(s, p): Removes all substrings in s that match the pattern p. Parameters: - s (str): The input string. - p (str): The pattern string to remove. Returns: - str: The resulting string after removing all occurrences of p. return s.replace(p, '')"},{"question":"def min_number_of_trips(N: int, provisions: List[int], W: int) -> int: Returns the minimum number of trips required to deliver the provisions to the castles. :param int N: The number of castles :param list provisions: A list of integers representing the provisions required by each castle :param int W: The maximum capacity of the supply wagon :return: The minimum number of trips required :rtype: int >>> min_number_of_trips(5, [2, 3, 7, 4, 1], 8) 3 >>> min_number_of_trips(3, [5, 5, 5], 5) 3 >>> min_number_of_trips(4, [2, 4, 4, 2], 8) 2 >>> min_number_of_trips(6, [1, 1, 1, 1, 1, 1], 2) 3 >>> min_number_of_trips(1, [10], 10) 1","solution":"def min_number_of_trips(N, provisions, W): Returns the minimum number of trips required to deliver the provisions to the castles. :param int N: The number of castles :param list provisions: A list of integers representing the provisions required by each castle :param int W: The maximum capacity of the supply wagon :return: The minimum number of trips required :rtype: int # Sort provisions in descending order provisions.sort(reverse=True) # Initialize number of trips trips = 0 # Iterate until all provisions are assigned while provisions: # Initialize current trip load current_load = 0 # Try to load as much as possible without exceeding the wagon capacity i = 0 while i < len(provisions): if current_load + provisions[i] <= W: current_load += provisions[i] provisions.pop(i) else: i += 1 # One trip completed trips += 1 return trips"},{"question":"def circus_operations(n: int, m: int, max_animals: List[int], operations: List[List[int]]) -> List[int]: In a large circus, there are n cages arranged in a straight line numbered from 1 to n. Each cage can contain a certain maximum number of animals, given by an array \`max_animals\` of length n where \`max_animals[i]\` represents the maximum capacity of the i-th cage. The circus performs two types of operations. The first type is adding a specified number of animals to a specific cage, and the second type is querying the total number of animals across a continuous sequence of cages. Implement a system to handle the following operations efficiently: 1. Add animals to a cage: The operation is represented as \`1 u v\`, where \`u\` is the cage index (1 ≤ u ≤ n) and \`v\` is the number of animals to add. You should add exactly \`v\` animals to cage \`u\`, but not exceeding its maximum capacity. 2. Query the total number of animals in a range of cages: The operation is represented as \`2 l r\`, where \`l\` and \`r\` are the range of cages (1 ≤ l ≤ r ≤ n). You should return the total number of animals in cages between \`l\` and \`r\` (both inclusive). >>> circus_operations( ... 5, 5, ... [10, 5, 8, 7, 9], ... [ ... [1, 2, 3], ... [1, 1, 6], ... [2, 1, 3], ... [1, 3, 4], ... [2, 1, 4] ... ] ... ) == [9, 13] >>> circus_operations( ... 3, 4, ... [4, 7, 3], ... [ ... [1, 1, 2], ... [1, 2, 5], ... [2, 1, 3], ... [2, 2, 3] ... ] ... ) == [7, 5]","solution":"def circus_operations(n, m, max_animals, operations): animals = [0] * n def add_animals(u, v): nonlocal animals if animals[u-1] + v > max_animals[u-1]: animals[u-1] = max_animals[u-1] else: animals[u-1] += v def query_animals(l, r): return sum(animals[l-1:r]) results = [] for operation in operations: if operation[0] == 1: add_animals(operation[1], operation[2]) elif operation[0] == 2: results.append(query_animals(operation[1], operation[2])) return results"},{"question":"def minimal_spanning_tree(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Find the weight of the Minimum Spanning Tree (MST) of the given graph of cities and roads. >>> minimal_spanning_tree(4, 5, [(1, 2, 3), (1, 3, 1), (3, 2, 3), (2, 4, 6), (3, 4, 5)]) 9 >>> minimal_spanning_tree(2, 1, [(1, 2, 3)]) 3 >>> minimal_spanning_tree(3, 3, [(1, 2, 1), (2, 3, 2), (3, 1, 2)]) 3 >>> minimal_spanning_tree(6, 9, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 7), (3, 5, 3), (4, 5, 1), (4, 6, 5), (5, 6, 8), (3, 6, 6)]) 12","solution":"def find_parent(parent, i): if parent[i] == i: return i return find_parent(parent, parent[i]) def union(parent, rank, x, y): root_x = find_parent(parent, x) root_y = find_parent(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal_mst(n, edges): result = [] # This will store the resultant MST i, e = 0, 0 # Variables to traverse sorted edges # Creating sorted edge list edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] # Create V subsets with single elements for node in range(n): parent.append(node) rank.append(0) while e < n - 1: # Pick the smallest edge and increment the index for the next iteration u, v, w = edges[i] i += 1 x = find_parent(parent, u - 1) y = find_parent(parent, v - 1) # If including this edge doesn't cause a cycle if x != y: e = e + 1 result.append([u, v, w]) union(parent, rank, x, y) total_weight = 0 for u, v, weight in result: total_weight += weight return total_weight def minimal_spanning_tree(n, m, roads): edges = [] for road in roads: u, v, w = road edges.append((u, v, w)) return kruskal_mst(n, edges) # Test the solution with the sample input if __name__ == \\"__main__\\": N, M = 4, 5 roads = [ (1, 2, 3), (1, 3, 1), (3, 2, 3), (2, 4, 6), (3, 4, 5) ] print(minimal_spanning_tree(N, M, roads)) # Output: 9"},{"question":"def longest_increasing_subsequence(arr: List[int]) -> int: Return the length of the longest increasing subsequence in the list \`arr\`. >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) 3 >>> longest_increasing_subsequence([3, 2]) 1 >>> longest_increasing_subsequence([50, 3, 10, 7, 40, 80]) 4 from bisect import bisect_left def test_lis_example1(): assert longest_increasing_subsequence([3, 10, 2, 1, 20]) == 3 def test_lis_example2(): assert longest_increasing_subsequence([3, 2]) == 1 def test_lis_example3(): assert longest_increasing_subsequence([50, 3, 10, 7, 40, 80]) == 4 def test_lis_single_element(): assert longest_increasing_subsequence([10]) == 1 def test_lis_all_increasing(): assert longest_increasing_subsequence([1, 2, 3, 4, 5]) == 5 def test_lis_all_decreasing(): assert longest_increasing_subsequence([5, 4, 3, 2, 1]) == 1 def test_lis_mixed_elements(): assert longest_increasing_subsequence([3, 4, -1, 0, 6, 2, 3]) == 4 def test_lis_duplicate_elements(): assert longest_increasing_subsequence([1, 3, 3, 5, 5, 7, 7, 9]) == 5 def test_lis_empty_array(): assert longest_increasing_subsequence([]) == 0","solution":"def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in the list \`arr\`. if not arr: return 0 from bisect import bisect_left lis = [] # this will store the current longest increasing subsequence for num in arr: pos = bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"def can_form_palindrome(s: str) -> str: Determines if a given string can be rearranged to form a palindrome. Args: s (str): The input string Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, \\"NO\\" otherwise >>> can_form_palindrome('aabb') 'YES' >>> can_form_palindrome('abc') 'NO' # your code here def solve(test_cases: list) -> list: Process multiple test cases to determine if the strings can be rearranged to form palindromes. Args: test_cases (list): List of strings to be tested Returns: list: List of results for each string in the form of \\"YES\\" or \\"NO\\" >>> solve(['aabb', 'abc']) ['YES', 'NO'] # your code here","solution":"def can_form_palindrome(s): Determines if a given string can be rearranged to form a palindrome. Args: s (str): The input string Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, \\"NO\\" otherwise from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to a palindrome only if no more than one character has an odd count. return \\"YES\\" if odd_count <= 1 else \\"NO\\" def solve(test_cases): results = [] for s in test_cases: results.append(can_form_palindrome(s)) return results"},{"question":"def max_subarray_sum(arr) -> int: Find the sum of the maximum subarray. >>> max_subarray_sum([1, -2, 3, -2, 5]) 6 >>> max_subarray_sum([-1, -2, -3, -4]) -1 pass def min_subarray_sum(arr) -> int: Find the sum of the minimum subarray. >>> min_subarray_sum([1, -2, 3, -2, 5]) -2 >>> min_subarray_sum([-1, -2, -3, -4]) -10 pass def sum_of_max_and_min_subarray(arr) -> int: Finds the sum of max_subarray_sum and min_subarray_sum. >>> sum_of_max_and_min_subarray([1, -2, 3, -2, 5]) 4 >>> sum_of_max_and_min_subarray([-1, -2, -3, -4]) -11 pass","solution":"def max_subarray_sum(arr): Finds the sum of the maximum subarray using Kadane's algorithm. max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far def min_subarray_sum(arr): Finds the sum of the minimum subarray, using a modified Kadane's algorithm. min_ending_here = min_so_far = arr[0] for x in arr[1:]: min_ending_here = min(x, min_ending_here + x) min_so_far = min(min_so_far, min_ending_here) return min_so_far def sum_of_max_and_min_subarray(arr): max_sum = max_subarray_sum(arr) min_sum = min_subarray_sum(arr) return max_sum + min_sum"},{"question":"def find_balanced_parentheses(strings: List[str]) -> List[str]: Returns a list of strings that contain balanced parentheses. >>> find_balanced_parentheses([\\"(a+b)\\", \\"(a+b\\", \\"(a+b)*(c+d)\\"]) ['(a+b)', '(a+b)*(c+d)'] >>> find_balanced_parentheses([\\"))a+b(())\\", \\"()x+y(\\", \\")z+(a+b)(\\"]) [] >>> find_balanced_parentheses([\\"((a-b)+(c*d))\\", \\"(a/b)+((c+d))\\", \\")(a+b)()\\"]) ['((a-b)+(c*d))', '(a/b)+((c+d))'] pass","solution":"def find_balanced_parentheses(strings): Returns a list of strings that contain balanced parentheses. def is_balanced(string): stack = [] for char in string: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return not stack return [s for s in strings if is_balanced(s)]"},{"question":"def rotate_matrix(matrix): Rotates the given NxN matrix 90 degrees clockwise. Args: matrix: List[List[int]] - NxN matrix to be rotated Returns: List[List[int]] - The rotated matrix >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] pass def process_input_and_rotate_matrices(T, test_cases): Processes multiple test cases and returns the rotated matrices. Args: T: int - Number of test cases test_cases: List[Tuple[int, List[List[int]]]] - Each test case includes the size of the matrix and the matrix itself Returns: List[List[List[int]]] - List of rotated matrices for each test case >>> process_input_and_rotate_matrices(2, [(2, [[1, 2], [3, 4]]), (3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]])]) [[[3, 1], [4, 2]], [[7, 4, 1], [8, 5, 2], [9, 6, 3]]] pass def parse_input(input_lines): Parses the input into a form usable by the process_input_and_rotate_matrices function. Args: input_lines: List[str] - Lines of input Returns: Tuple[int, List[Tuple[int, List[List[int]]]]] - Number of test cases and list of test cases >>> parse_input([\\"2\\", \\"2\\", \\"1 2\\", \\"3 4\\", \\"3\\", \\"1 2 3\\", \\"4 5 6\\", \\"7 8 9\\"]) (2, [(2, [[1, 2], [3, 4]]), (3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]])]) pass def format_output(results): Formats the output based on the rotated matrices. Args: results: List[List[List[int]]] - The rotated matrices for each test case Returns: List[str] - List of output lines >>> format_output([[[3, 1], [4, 2]], [[7, 4, 1], [8, 5, 2], [9, 6, 3]]]) [\\"3 1\\", \\"4 2\\", \\"7 4 1\\", \\"8 5 2\\", \\"9 6 3\\"] pass","solution":"def rotate_matrix(matrix): Rotates the given NxN matrix 90 degrees clockwise. :param matrix: List[List[int]] - NxN matrix to be rotated :return: List[List[int]] - The rotated matrix N = len(matrix) rotated = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): rotated[j][N - i - 1] = matrix[i][j] return rotated def process_input_and_rotate_matrices(T, test_cases): Processes multiple test cases and returns the rotated matrices. :param T: int - Number of test cases :param test_cases: List[Tuple[int, List[List[int]]]] - Each test case includes the size of the matrix and the matrix itself :return: List[List[List[int]]] - List of rotated matrices for each test case results = [] for N, matrix in test_cases: results.append(rotate_matrix(matrix)) return results def parse_input(input_lines): Parses the input into a form usable by the process_input_and_rotate_matrices function. :param input_lines: List[str] - Lines of input :return: Tuple[int, List[Tuple[int, List[List[int]]]]] - Number of test cases and list of test cases iterator = iter(input_lines) T = int(next(iterator)) test_cases = [] for _ in range(T): N = int(next(iterator)) matrix = [] for _ in range(N): matrix.append(list(map(int, next(iterator).split()))) test_cases.append((N, matrix)) return T, test_cases def format_output(results): Formats the output based on the rotated matrices. :param results: List[List[List[int]]] - The rotated matrices for each test case :return: List[str] - List of output lines output_lines = [] for matrix in results: for row in matrix: output_lines.append(\\" \\".join(map(str, row))) return output_lines"},{"question":"def longest_consecutive_subsequence(arr): Returns the length of the longest consecutive subsequence in the list of integers. >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_subsequence([]) 0 >>> longest_consecutive_subsequence([10]) 1 >>> longest_consecutive_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 10 >>> longest_consecutive_subsequence([10, 20, 30, 40]) 1 >>> longest_consecutive_subsequence([10, 5, 12, 3, 55, 6, 7, 4, 15, 1, 2]) 7 >>> longest_consecutive_subsequence([-1, -2, -3, -4]) 4 >>> longest_consecutive_subsequence([-1, 0, 1, 2, 5, 6]) 4 >>> longest_consecutive_subsequence([1, 2, 2, 3]) 3","solution":"def longest_consecutive_subsequence(arr): Returns the length of the longest consecutive subsequence in the list of integers. if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in arr: # Check if it's the start of a sequence if (num - 1) not in num_set: current_num = num current_streak = 1 # Check the consecutive numbers while (current_num + 1) in num_set: current_num += 1 current_streak += 1 # Update the maximum length longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def hasZeroSumSubarray(arr: List[int], n: int) -> bool: Given an array \`arr\` of integers and an integer \`n\`, find out whether there exists a subarray of length \`n\` with sum equal to \`0\`. >>> hasZeroSumSubarray([1, 2, -3, 4, -2, 2, 1], 3) True >>> hasZeroSumSubarray([1, 2, 3, 4, 5], 2) False >>> hasZeroSumSubarray([1, 1, 1, 1, 1], 1) False","solution":"def hasZeroSumSubarray(arr, n): if len(arr) < n: return False current_sum = sum(arr[:n]) if current_sum == 0: return True for i in range(n, len(arr)): current_sum += arr[i] - arr[i - n] if current_sum == 0: return True return False"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def sortList(head): Given the head of a singly linked list, sort the list in ascending order. :param head: ListNode, the head of the linked list :return: ListNode, the head of the sorted linked list Example: >>> head = list_to_linked_list([4, 2, 1, 3]) >>> sorted_head = sortList(head) >>> linked_list_to_list(sorted_head) [1, 2, 3, 4] >>> head = list_to_linked_list([-1, 5, 3, 4, 0]) >>> sorted_head = sortList(head) >>> linked_list_to_list(sorted_head) [-1, 0, 3, 4, 5] >>> head = list_to_linked_list([]) >>> sorted_head = sortList(head) >>> linked_list_to_list(sorted_head) [] def get_middle(head): pass def merge(l1, l2): pass","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def sortList(head): Sorts a linked list in ascending order. :param head: ListNode, the head of the linked list :return: ListNode, the head of the sorted linked list if not head or not head.next: return head mid = get_middle(head) left = head right = mid.next mid.next = None left = sortList(left) right = sortList(right) return merge(left, right) def get_middle(head): slow, fast = head, head.next while fast and fast.next: slow = slow.next fast = fast.next.next return slow def merge(l1, l2): dummy = ListNode() curr = dummy while l1 and l2: if l1.val < l2.val: curr.next = l1 l1 = l1.next else: curr.next = l2 l2 = l2.next curr = curr.next if l1: curr.next = l1 elif l2: curr.next = l2 return dummy.next"},{"question":"def knapsack_max_value(n: int, W: int, items: List[Tuple[int, int]]) -> int: Given a number of items, their corresponding weights and values, and a maximum weight capacity of a knapsack, this function returns the maximum total value of items that can be put into the knapsack without exceeding the weight limit. :param n: int - number of items :param W: int - maximum weight capacity of the knapsack :param items: list of tuples - each tuple contains two integers, weight and value of an item :return: int - maximum total value of items >>> knapsack_max_value(4, 7, [(1, 3), (4, 5), (3, 4), (2, 2)]) 10 >>> knapsack_max_value(3, 50, [(10, 60), (20, 100), (30, 120)]) 220","solution":"def knapsack_max_value(n, W, items): Given a number of items, their corresponding weights and values, and a maximum weight capacity of a knapsack, this function returns the maximum total value of items that can be put into the knapsack without exceeding the weight limit. :param n: int - number of items :param W: int - maximum weight capacity of the knapsack :param items: list of tuples - each tuple contains two integers, weight and value of an item :return: int - maximum total value of items dp = [0] * (W + 1) for weight, value in items: for w in range(W, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + value) return dp[W]"},{"question":"def max_aba_towers(N, M): Given N 'A'-shaped blocks and M 'B'-shaped blocks, determines the maximum number of 'ABA' towers that can be created. >>> max_aba_towers(2, 5) 2 >>> max_aba_towers(4, 6) 3 >>> max_aba_towers(3, 3) 1 >>> max_aba_towers(5, 2) 1 >>> max_aba_towers(3, 8) 3 >>> max_aba_towers(10**12, 2 * 10**12) 1000000000000 >>> max_aba_towers(10**12, 10**12) 500000000000 # Your code here","solution":"def max_aba_towers(N, M): Given N 'A'-shaped blocks and M 'B'-shaped blocks, determines the maximum number of 'ABA' towers that can be created. return min(N, M // 2) if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) M = int(data[1]) print(max_aba_towers(N, M))"},{"question":"def max_total_value(N: int, W: int, items: List[Tuple[int, int]]) -> int: Returns the maximum total value of items that can be placed on the shelf without exceeding the weight limit W. Args: N (int): The number of items. W (int): The maximum weight the shelf can hold. items (List[Tuple[int, int]]): A list of tuples where each tuple contains the weight and value of an item. Returns: int: The maximum total value of items that can be placed on the shelf. Examples: >>> max_total_value(4, 10, [(2, 5), (3, 6), (4, 5), (5, 8)]) 19 >>> max_total_value(3, 50, [(10, 60), (20, 100), (30, 120)]) 220 >>> max_total_value(1, 1, [(2, 1)]) 0 from typing import List, Tuple def test_max_total_value_example1(): assert max_total_value(4, 10, [(2, 5), (3, 6), (4, 5), (5, 8)]) == 19 def test_max_total_value_example2(): assert max_total_value(3, 50, [(10, 60), (20, 100), (30, 120)]) == 220 def test_max_total_value_example3(): assert max_total_value(1, 1, [(2, 1)]) == 0 def test_max_total_value_single_item_fits(): assert max_total_value(1, 5, [(4, 10)]) == 10 def test_max_total_value_large_weight_limit(): assert max_total_value(2, 1000, [(999, 100), (1000, 200)]) == 200 def test_max_total_value_no_items(): assert max_total_value(0, 10, []) == 0 def test_max_total_value_all_items_too_heavy(): assert max_total_value(3, 10, [(20, 30), (15, 25), (11, 35)]) == 0","solution":"def max_total_value(N, W, items): Returns the maximum total value of items that can be placed on the shelf without exceeding the weight limit W. # Create a list for dynamic programming, initialized with zeros dp = [0] * (W + 1) for weight, value in items: # Traverse the dp array backwards to avoid using one item multiple times for w in range(W, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + value) return max(dp)"},{"question":"def wordBreak(s: str, wordDict: List[str]) -> bool: Determines if a string can be segmented into a space-separated sequence of one or more dictionary words from the list. :param s: A string to be segmented into words from wordDict. :param wordDict: A list of words considered as the dictionary. :return: Boolean indicating if the string can be segmented into dictionary words. >>> wordBreak(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> wordBreak(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> wordBreak(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False from solution import wordBreak def test_wordBreak_positive_case1(): assert wordBreak(\\"leetcode\\", [\\"leet\\", \\"code\\"]) == True def test_wordBreak_positive_case2(): assert wordBreak(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) == True def test_wordBreak_negative_case(): assert wordBreak(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == False def test_wordBreak_same_word_multiple_times(): assert wordBreak(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) == True def test_wordBreak_single_character_word(): assert wordBreak(\\"a\\", [\\"a\\"]) == True def test_wordBreak_single_character_word_not_in_dict(): assert wordBreak(\\"a\\", [\\"b\\"]) == False def test_wordBreak_empty_string(): assert wordBreak(\\"\\", [\\"leet\\", \\"code\\"]) == True def test_wordBreak_all_characters_in_dict(): assert wordBreak(\\"abcd\\", [\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) == True def test_wordBreak_no_possible_segmentation(): assert wordBreak(\\"abcd\\", [\\"ab\\", \\"cd\\", \\"e\\"]) == True def test_wordBreak_large_input(): s = \\"a\\" * 1000 + \\"b\\" wordDict = [\\"a\\", \\"b\\"] assert wordBreak(s, wordDict) == True","solution":"def wordBreak(s, wordDict): Determines if a string can be segmented into a sequence of one or more dictionary words. :param s: A string to be segmented into words from wordDict. :param wordDict: A list of words considered as the dictionary. :return: Boolean indicating if the string can be segmented into dictionary words. word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)]"},{"question":"def find_duplicates(arr): Returns an array of elements that appear more than once in the given array, in the order they first appeared. If no elements appear more than once, returns an empty array. Parameters: arr (list): List of integers Returns: list: List of integers that appear more than once Examples: >>> find_duplicates([1, 2, 3, 4, 4, 5, 2]) [4, 2] >>> find_duplicates([1, 2, 3, 4, 5]) [] >>> find_duplicates([1, 1, 1, 2, 3, 3, 4]) [1, 3]","solution":"def find_duplicates(arr): Returns an array of elements that appear more than once in the given array, in the order they first appeared. If no elements appear more than once, returns an empty array. Parameters: arr (list): List of integers Returns: list: List of integers that appear more than once counts = {} duplicates = [] for item in arr: if item in counts: if counts[item] == 1: duplicates.append(item) counts[item] += 1 else: counts[item] = 1 return duplicates"},{"question":"def max_treasure(n: int, m: int, grid: List[List[int]]) -> int: Determine the maximum amount of treasure the hunter can collect moving from the top-left to the bottom-right of the grid. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[int]]): 2D list representing the treasure amounts in each cell. Returns: int: The maximum amount of treasure collected. Example: >>> max_treasure(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_treasure(2, 2, [[1, 2], [3, 4]]) 8 pass # Unit tests def test_example_1(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert max_treasure(3, 3, grid) == 12 def test_example_2(): grid = [ [1, 2], [3, 4] ] assert max_treasure(2, 2, grid) == 8 def test_single_element(): grid = [ [10] ] assert max_treasure(1, 1, grid) == 10 def test_single_row(): grid = [ [1, 2, 3, 4] ] assert max_treasure(1, 4, grid) == 10 def test_single_column(): grid = [ [1], [2], [3], [4] ] assert max_treasure(4, 1, grid) == 10 def test_large_grid(): grid = [ [1, 1, 1], [1, 100, 1], [1, 1, 1] ] assert max_treasure(3, 3, grid) == 104 def test_zero_grid(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert max_treasure(3, 3, grid) == 0","solution":"def max_treasure(n, m, grid): # Create a 2D dp array to store the maximum treasure collected up to each cell dp = [[0] * m for _ in range(n)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row (only right moves are possible) for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (only down moves are possible) for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): # The hunter can come from the top or from the left dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right cell contains the maximum treasure that can be collected return dp[n - 1][m - 1]"},{"question":"def rainfall_difference(input_data: str) -> float: Returns the difference in rainfall between the wettest and driest city. Args: input_data (str): Multi-line string where each line is in the format \\"City Rainfall\\" Returns: float: The difference in rainfall between the wettest and driest city Example: >>> input_data = \\"Tokyo 1523.4nNagoya 1282.7nOsaka 1335.5nKyoto 1689.2nHokkaido 923.1n\\" >>> rainfall_difference(input_data) 766.1 >>> input_data = \\"Tokyo 1523.4n\\" >>> rainfall_difference(input_data) 0.0","solution":"def rainfall_difference(input_data): Returns the difference in rainfall between the wettest and driest city. Args: input_data (str): Multi-line string where each line is in format \\"City Rainfall\\" Returns: float: The difference in rainfall between the wettest and driest city city_rainfall = {} for line in input_data.split(\\"n\\"): if line.strip() == \\"\\": continue city, rainfall = line.rsplit(maxsplit=1) city_rainfall[city] = float(rainfall) max_rainfall = max(city_rainfall.values()) min_rainfall = min(city_rainfall.values()) return round(max_rainfall - min_rainfall, 2)"},{"question":"from typing import List, Tuple def find_min_travel_time(R: int, C: int, roads: List[Tuple[int, int, int]], Q: int, queries: List[Tuple[int, int]]) -> List[int]: Determine the minimum travel time between buildings for each given query. Parameters: R (int): Number of roads C (int): Number of buildings roads (List[Tuple[int, int, int]]): List containing tuples of the form (a_i, b_i, w_i) representing a road between buildings a_i and b_i with a travel time of w_i Q (int): Number of queries queries (List[Tuple[int, int]]): List containing tuples of the form (u, v) representing a query asking for the shortest travel time from building u to building v Returns: List[int]: List of minimum travel times for each query, or -1 if no path exists Examples: >>> find_min_travel_time(5, 5, [(1, 2, 4), (1, 3, 2), (2, 4, 5), (3, 4, 1), (4, 5, 3)], 3, [(1, 4), (2, 5), (5, 3)]) [3, 8, 4] >>> find_min_travel_time(3, 3, [(1, 2, 3), (2, 3, 4)], 1, [(1, 3)]) [7]","solution":"import heapq def dijkstra(graph, start, end): distances = {node: float('inf') for node in graph} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[end] if distances[end] != float('inf') else -1 def find_min_travel_time(R, C, roads, Q, queries): graph = {i: [] for i in range(1, C+1)} for a, b, w in roads: graph[a].append((b, w)) graph[b].append((a, w)) results = [] for u, v in queries: results.append(dijkstra(graph, u, v)) return results"},{"question":"def first_unique_char(s: str) -> str: Returns the first non-repeating character in the given string. If all characters are repeating or the string is empty, returns an empty string. >>> first_unique_char(\\"swiss\\") \\"w\\" >>> first_unique_char(\\"teeter\\") \\"r\\" >>> first_unique_char(\\"aabb\\") \\"\\" >>> first_unique_char(\\"alphabet\\") \\"l\\" >>> first_unique_char(\\"\\") \\"\\" >>> first_unique_char(\\"a\\") \\"a\\" >>> first_unique_char(\\"aabbccddeeffg\\") \\"g\\" >>> first_unique_char(\\"abcdefg\\") \\"a\\" >>> first_unique_char(\\"abcdabc\\") \\"d\\" >>> first_unique_char(\\"aabbccdd\\") \\"\\"","solution":"def first_unique_char(s): Returns the first non-repeating character in the given string. If all characters are repeating or the string is empty, returns an empty string. char_count = {} # Count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character that occurs only once for char in s: if char_count[char] == 1: return char return \\"\\""},{"question":"def maxSumNonAdj(arr, n): Find the maximum sum of weights that can be achieved by selecting a subset of weights such that no two weights are adjacent. >>> maxSumNonAdj([3, 2, 5, 10], 4) 13 >>> maxSumNonAdj([3, 2, 7, 10, 12], 5) 22","solution":"def maxSumNonAdj(arr, n): if n == 0: return 0 elif n == 1: return arr[0] # Initialize two variables to store the maximum sum including the previous element and including the element before the previous element prev1 = 0 prev2 = 0 for i in range(n): current = max(prev1, prev2 + arr[i]) prev2 = prev1 prev1 = current return prev1"},{"question":"def game_winner(test_cases): Determines the winner of the game for each test case based on the length of the string. Parameters: test_cases (list of str): The list of strings for each test case. Returns: list of str: The result for each test case, either \\"Alice\\" or \\"Bob\\". results = [] for s in test_cases: if len(s) % 2 == 1: results.append(\\"Alice\\") else: results.append(\\"Bob\\") return results # Unit tests def test_game_winner_example(): assert game_winner([\\"abc\\", \\"abcd\\", \\"xyz\\"]) == [\\"Alice\\", \\"Bob\\", \\"Alice\\"] def test_game_winner_single_case_alice(): assert game_winner([\\"a\\"]) == [\\"Alice\\"] def test_game_winner_single_case_bob(): assert game_winner([\\"bb\\"]) == [\\"Bob\\"] def test_game_winner_long_string_odd(): assert game_winner([\\"abcdefghijklmnopqrstuvwxy\\"]) == [\\"Alice\\"] def test_game_winner_long_string_even(): assert game_winner([\\"abcdefghijklmnopqrstuvwx\\"]) == [\\"Bob\\"] def test_game_winner_multiple_cases(): test_cases = [\\"a\\", \\"bb\\", \\"c\\", \\"dd\\", \\"e\\", \\"ff\\", \\"g\\", \\"hh\\"] expected_results = [\\"Alice\\", \\"Bob\\", \\"Alice\\", \\"Bob\\", \\"Alice\\", \\"Bob\\", \\"Alice\\", \\"Bob\\"] assert game_winner(test_cases) == expected_results","solution":"def game_winner(test_cases): Determines the winner of the game for each test case based on the length of the string. Parameters: test_cases (list of str): The list of strings for each test case. Returns: list of str: The result for each test case, either \\"Alice\\" or \\"Bob\\". results = [] for s in test_cases: if len(s) % 2 == 1: results.append(\\"Alice\\") else: results.append(\\"Bob\\") return results"},{"question":"from typing import List, Tuple def sum_of_divisibles(n: int, p: int) -> int: Returns the sum of all integers from 1 to n that are divisible by p. >>> sum_of_divisibles(10, 2) 30 >>> sum_of_divisibles(15, 3) 45 >>> sum_of_divisibles(20, 5) 50 >>> sum_of_divisibles(100, 7) 735 pass def solve(test_cases: List[Tuple[int, int]]) -> List[int]: Given a list of (n, p) tuples, returns a list of results where each result is the sum of all integers from 1 to n that are divisible by p. >>> solve([(10, 2), (15, 3), (20, 5), (100, 7)]) [30, 45, 50, 735] >>> solve([(1, 1)]) [1] >>> solve([(5, 10)]) [0] pass","solution":"def sum_of_divisibles(n, p): Returns the sum of all integers from 1 to n that are divisible by p. m = n // p return p * m * (m + 1) // 2 def solve(test_cases): results = [] for n, p in test_cases: results.append(sum_of_divisibles(n, p)) return results"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasLoop(head: ListNode) -> bool: Detect loops in a linked list. A loop is present if a node points back to one of the previous nodes in the list. Args: head (ListNode): The head of the linked list. Returns: bool: True if there is a loop in the list, False otherwise. >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(3) >>> node4 = ListNode(4) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node4 >>> node4.next = node2 >>> hasLoop(node1) True >>> node4.next = None # Remove the loop >>> hasLoop(node1) False >>> node = ListNode(1) >>> hasLoop(node) False >>> node.next = node # Create loop >>> hasLoop(node) True >>> hasLoop(None) False","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasLoop(head: ListNode) -> bool: slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"from typing import List def sum_of_subarray_mins(arr: List[int]) -> int: Given an integer array arr[] of size n, find the sum of the minimum values of every subarray of arr[]. The result should be returned modulo 10^9 + 7. Examples: >>> sum_of_subarray_mins([3, 1, 2, 4]) 17 >>> sum_of_subarray_mins([11, 81, 94, 43, 3]) 444 pass # Unit tests def test_example1(): assert sum_of_subarray_mins([3, 1, 2, 4]) == 17 def test_example2(): assert sum_of_subarray_mins([11, 81, 94, 43, 3]) == 444 def test_single_element(): assert sum_of_subarray_mins([5]) == 5 def test_same_elements(): assert sum_of_subarray_mins([2, 2, 2, 2]) == 20 def test_strictly_decreasing(): assert sum_of_subarray_mins([5, 4, 3, 2, 1]) == 35 def test_strictly_increasing(): assert sum_of_subarray_mins([1, 2, 3, 4, 5]) == 35 def test_large_numbers(): arr = [30000] * 5 assert sum_of_subarray_mins(arr) == (30000 * (1 + 2 + 3 + 4 + 5)) % (10**9 + 7) def test_large_input_size(): arr = [1] * 30000 expected_sum = (30000 * (30000 + 1)) // 2 assert sum_of_subarray_mins(arr) == expected_sum % (10**9 + 7)","solution":"def sum_of_subarray_mins(arr): MOD = 10**9 + 7 n = len(arr) # Create arrays to store the next and previous less element next_less = [n] * n prev_less = [-1] * n stack = [] # Find previous less element for each arr[i] for i in range(n): while stack and arr[stack[-1]] > arr[i]: stack.pop() if stack: prev_less[i] = stack[-1] stack.append(i) stack = [] # Find next less element for each arr[i] for i in range(n): while stack and arr[stack[-1]] > arr[i]: next_less[stack.pop()] = i stack.append(i) # Calculate sum of subarray minimums using the breakdown of subarrays ending at each index result = 0 for i in range(n): left_count = i - prev_less[i] right_count = next_less[i] - i result = (result + arr[i] * left_count * right_count) % MOD return result"},{"question":"from typing import List def calculate_h_index(citations: List[int]) -> int: Calculate the h-index given a list of citations. >>> calculate_h_index([6, 5, 3, 1, 0]) 3 >>> calculate_h_index([4, 4, 4, 4]) 4 >>> calculate_h_index([10, 8, 5, 4, 3, 3, 2, 1]) 4 pass def process_input(input_data: str) -> List[int]: Process the input data and return the corresponding h-indices for each test case. >>> process_input(\\"5n6 5 3 1 0n4n4 4 4 4n8n10 8 5 4 3 3 2 1n0n\\") [3, 4, 4] >>> process_input(\\"3n1 2 3n4n10000 10000 10000 10000n0n\\") [2, 4] pass","solution":"def calculate_h_index(citations): Calculate the h-index given a list of citations. citations.sort(reverse=True) h_index = 0 for i, citation in enumerate(citations): if citation >= i + 1: h_index = i + 1 else: break return h_index def process_input(input_data): Process the input data and return the corresponding h-indices for each test case results = [] data = input_data.strip().split(\\"n\\") idx = 0 while idx < len(data): n = int(data[idx]) if n == 0: break citations = list(map(int, data[idx + 1].split())) h_index = calculate_h_index(citations) results.append(h_index) idx += 2 return results"},{"question":"def minAddToMakeValid(s: str) -> int: Returns the minimum number of parentheses needed to make the string s valid. >>> minAddToMakeValid(\\"()))((\\") 4 >>> minAddToMakeValid(\\"()\\") 0","solution":"def minAddToMakeValid(s: str) -> int: Returns the minimum number of parentheses needed to make the string s valid. open_needed = 0 close_needed = 0 for char in s: if char == '(': open_needed += 1 elif char == ')': if open_needed > 0: open_needed -= 1 else: close_needed += 1 # The total parentheses needed is the sum of unmatched open and close parentheses return open_needed + close_needed"},{"question":"from typing import List def filter_words_by_prefix(words: List[str], prefix: str) -> List[str]: Returns a list of words that start with the given prefix. Args: words (list): List of words. prefix (str): Prefix string. Returns: list: List of words that start with the given prefix. Examples: >>> filter_words_by_prefix([\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"grape\\", \\"application\\"], \\"app\\") [\\"apple\\", \\"app\\", \\"application\\"] >>> filter_words_by_prefix([\\"dog\\", \\"cat\\", \\"carrot\\", \\"car\\", \\"camel\\"], \\"ca\\") [\\"cat\\", \\"carrot\\", \\"car\\", \\"camel\\"] >>> filter_words_by_prefix([\\"hello\\", \\"world\\", \\"hi\\", \\"hey\\"], \\"he\\") [\\"hello\\", \\"hey\\"]","solution":"def filter_words_by_prefix(words, prefix): Returns a list of words that start with the given prefix. Args: words (list): list of words. prefix (str): prefix string. Returns: list: list of words that start with the given prefix. return [word for word in words if word.startswith(prefix)]"},{"question":"def process_string(replacement_rules, queries): Process a string by replacing certain substrings according to specific rules provided. Args: replacement_rules (List[Tuple[str, str]]): A list of replacement rules where each tuple contains a substring to be replaced and its replacement. queries (List[str]): A list of strings to be processed using the replacement rules. Returns: List[str]: A list of strings obtained after applying all the replacement rules to each query. Example: >>> process_string([(\\"abc\\", \\"xy\\"), (\\"bc\\", \\"yz\\"), (\\"a\\", \\"x\\")], [\\"abcde\\", \\"abcabc\\"]) ['xyde', 'xyxy']","solution":"def process_string(replacement_rules, queries): def apply_rules(s, rules): for old, new in rules: s = s.replace(old, new) return s results = [] for query in queries: result = apply_rules(query, replacement_rules) results.append(result) return results # Example usage: replacement_rules = [(\\"abc\\", \\"xy\\"), (\\"bc\\", \\"yz\\"), (\\"a\\", \\"x\\")] queries = [\\"abcde\\", \\"abcabc\\"] print(process_string(replacement_rules, queries)) # Output: ['xyde', 'xyxy']"},{"question":"def can_obtain_weight(w: int, sentences: List[str]) -> str: Determine if it's possible to concatenate some (or all) of the sentences to obtain a sentence with the exact weight w. Parameters: w (int): The desired weight of the resulting sentence. sentences (list of str): List of sentences consisting of \\"+\\" and \\"-\\" symbols. Returns: str: \\"YES\\" if it is possible to obtain the desired weight, otherwise \\"NO\\". >>> can_obtain_weight(2, [\\"++\\", \\"+-\\", \\"--\\"]) \\"YES\\" >>> can_obtain_weight(1, [\\"---\\", \\"++\\"]) \\"NO\\" >>> can_obtain_weight(0, [\\"+-\\", \\"++\\", \\"--\\", \\"+\\"]) \\"YES\\" >>> can_obtain_weight(0, [\\"--\\", \\"++\\"]) \\"YES\\" >>> can_obtain_weight(1, [\\"+--\\"]) \\"YES\\" >>> can_obtain_weight(2, [\\"+-\\"]) \\"NO\\" >>> can_obtain_weight(3, [\\"+-\\", \\"+++\\", \\"----\\", \\"++\\"]) \\"YES\\"","solution":"def can_obtain_weight(w, sentences): Determine if it's possible to concatenate some (or all) of the sentences to obtain a sentence with the exact weight w. Parameters: w (int): The desired weight of the resulting sentence. sentences (list of str): List of sentences consisting of \\"+\\" and \\"-\\" symbols. Returns: str: \\"YES\\" if it is possible to obtain the desired weight, otherwise \\"NO\\". weights = [abs(s.count('+') - s.count('-')) for s in sentences] possible_sums = {0} for weight in weights: new_sums = possible_sums.copy() for psum in possible_sums: new_sums.add(psum + weight) possible_sums = new_sums return \\"YES\\" if w in possible_sums else \\"NO\\""},{"question":"def count_great_rooftop_restaurants(n: int, heights: List[int]) -> int: Determine the number of great rooftop restaurants in the given array of building heights. Parameters: n : int : the number of buildings heights : List[int] : a sequence of n integers describing the heights of the buildings Returns: int : the number of great rooftop restaurants >>> count_great_rooftop_restaurants(5, [3, 7, 8, 3, 6]) 2 >>> count_great_rooftop_restaurants(6, [4, 2, 3, 1, 8, 6]) 2 >>> count_great_rooftop_restaurants(3, [1, 1, 1]) 1","solution":"def count_great_rooftop_restaurants(n, heights): Function to determine the number of great rooftop restaurants. Parameters: n : int : the number of buildings heights : List[int] : a sequence of n integers describing the heights of the buildings Returns: int : the number of great rooftop restaurants great_count = 0 max_height_so_far = 0 for height in reversed(heights): if height > max_height_so_far: great_count += 1 max_height_so_far = height return great_count"},{"question":"def three_sum_zero(arr): Returns a list of all unique triplets (a, b, c) in the array such that a + b + c = 0. from solution import three_sum_zero def test_three_sum_zero_example1(): result = three_sum_zero([-1, 0, 1, 2, -1, -4]) expected = [(-1, -1, 2), (-1, 0, 1)] assert sorted(result) == sorted(expected) def test_three_sum_zero_example2(): result = three_sum_zero([0, 0, 0, 0, 0]) expected = [(0, 0, 0)] assert sorted(result) == sorted(expected) def test_three_sum_zero_example3(): result = three_sum_zero([-2, 2, 0]) expected = [(-2, 0, 2)] assert sorted(result) == sorted(expected) def test_three_sum_zero_example4(): result = three_sum_zero([1, 2, 3, 4]) expected = \\"No triplets found\\" assert result == expected def test_three_sum_zero_no_triplets(): result = three_sum_zero([1, -1, 1, -1, 1]) expected = \\"No triplets found\\" assert result == expected def test_three_sum_zero_multiple_triplets(): result = three_sum_zero([-2, -1, -1, 0, 1, 2]) expected = [(-2, 0, 2), (-1, -1, 2), (-1, 0, 1)] assert sorted(result) == sorted(expected)","solution":"def three_sum_zero(arr): Returns a list of all unique triplets (a, b, c) in the array such that a + b + c = 0. arr.sort() N = len(arr) result = [] for i in range(N - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, N - 1 while left < right: total = arr[i] + arr[left] + arr[right] if total == 0: result.append((arr[i], arr[left], arr[right])) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 if not result: return \\"No triplets found\\" else: return result"},{"question":"def max_water_trapped(heights): Returns the maximum water trapped between two buildings given their heights. >>> max_water_trapped([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_water_trapped([5]) 0 >>> max_water_trapped([]) 0 >>> max_water_trapped([2, 3]) 2 >>> max_water_trapped([5, 4, 3, 2, 1]) 6 >>> max_water_trapped([1, 2, 3, 4, 5]) 6 >>> max_water_trapped([5, 5, 5, 5, 5]) 20","solution":"def max_water_trapped(heights): Returns the maximum water trapped between two buildings given their heights. # Invalid input: less than 2 buildings if len(heights) < 2: return 0 max_water = 0 left = 0 right = len(heights) - 1 while left < right: # calculate the water trapped between the buildings at indices left and right height = min(heights[left], heights[right]) width = right - left current_water = height * width max_water = max(max_water, current_water) # Move the pointer pointing to the shorter building if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None self.next_sibling = None def connect_siblings(root): Function to connect sibling pointers for all nodes in the binary tree. Expected Time Complexity: O(N), where N is the number of nodes. Expected Auxiliary Space: O(1) pass # Test cases to validate the solution from solution import Node, connect_siblings def tree_to_sibling_list(root): Helper function to convert tree with sibling pointers to a nested list of siblings at each level. This aids in verifying the sibling connections. if not root: return [] result = [] current = root while current: level = [] next_level_start = current while current: level.append(current.data) current = current.next_sibling result.append(level) current = None while next_level_start and not current: if next_level_start.left: current = next_level_start.left elif next_level_start.right: current = next_level_start.right next_level_start = next_level_start.next_sibling return result def test_example1(): root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.left = Node(6) root.right.right = Node(7) connect_siblings(root) assert tree_to_sibling_list(root) == [ [1], [2, 3], [4, 5, 6, 7] ] def test_example2(): root = Node(10) root.left = Node(5) root.right = Node(15) root.left.left = Node(3) root.right.right = Node(20) connect_siblings(root) assert tree_to_sibling_list(root) == [ [10], [5, 15], [3, 20] ] def test_single_node(): root = Node(1) connect_siblings(root) assert tree_to_sibling_list(root) == [ [1] ] def test_empty_tree(): root = None connect_siblings(root) assert tree_to_sibling_list(root) == [] def test_unbalanced_tree(): root = Node(1) root.left = Node(2) root.left.left = Node(3) connect_siblings(root) assert tree_to_sibling_list(root) == [ [1], [2], [3] ]","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None self.next_sibling = None def connect_siblings(root): Function to connect sibling pointers for all nodes in the binary tree. if not root: return # Initialize the first node of the current level current = root # Loop through each level while current: # Use a dummy node to handle the level dummy = Node(0) tail = dummy # Traverse the nodes in the current level while current: if current.left: tail.next_sibling = current.left tail = tail.next_sibling if current.right: tail.next_sibling = current.right tail = tail.next_sibling current = current.next_sibling # Move to the first node of the next level current = dummy.next_sibling"},{"question":"class WarehouseSystem: WarehouseSystem class handles the warehouse inventory and product transfer. Example: >>> system = WarehouseSystem([101, 102], [\\"apple\\", \\"banana\\"], [[10, 5], [3, 8]]) >>> system.transfer(101, 102, \\"apple\\", 5) True >>> system.checkStock(101, \\"apple\\") 5 >>> system.checkStock(102, \\"apple\\") 8 >>> system.transfer(102, 101, \\"banana\\", 4) True >>> system.checkStock(102, \\"banana\\") 4 >>> system.checkStock(101, \\"banana\\") 9 def __init__(self, warehouses, products, stock): Initializes the system with warehouses, products and stock. Parameters: - warehouses (List[int]): List of warehouse IDs. - products (List[str]): List of product names. - stock (List[List[int]]): 2D list representing product stock in each warehouse. def transfer(self, sourceWarehouse, targetWarehouse, product, quantity): Transfers products between warehouses. Parameters: - sourceWarehouse (int): The source warehouse ID. - targetWarehouse (int): The target warehouse ID. - product (str): The product name. - quantity (int): The quantity to transfer. Returns: - bool: True if the transfer is successful, otherwise False. def checkStock(self, warehouse, product): Checks the current stock of a product in a warehouse. Parameters: - warehouse (int): The warehouse ID. - product (str): The product name. Returns: - int: The current stock of the product in the specified warehouse.","solution":"class WarehouseSystem: def __init__(self, warehouses, products, stock): self.warehouses = {warehouse: idx for idx, warehouse in enumerate(warehouses)} self.products = {product: idx for idx, product in enumerate(products)} self.stock = stock def transfer(self, sourceWarehouse, targetWarehouse, product, quantity): if sourceWarehouse not in self.warehouses or targetWarehouse not in self.warehouses: return False if product not in self.products: return False sourceIdx = self.warehouses[sourceWarehouse] targetIdx = self.warehouses[targetWarehouse] productIdx = self.products[product] if self.stock[sourceIdx][productIdx] >= quantity: self.stock[sourceIdx][productIdx] -= quantity self.stock[targetIdx][productIdx] += quantity return True else: return False def checkStock(self, warehouse, product): if warehouse not in self.warehouses or product not in self.products: return -1 warehouseIdx = self.warehouses[warehouse] productIdx = self.products[product] return self.stock[warehouseIdx][productIdx]"},{"question":"from typing import List, Tuple from collections import deque, defaultdict def bfs_shortest_path(N: int, M: int, edges: List[Tuple[int, int]], S: int) -> List[int]: Given a network of N nodes and M edges, find the shortest paths from the source node S to all other nodes. Args: N (int): Number of nodes. M (int): Number of edges. edges (List[Tuple[int, int]]): List of bidirectional edges. S (int): Source node. Returns: List[int]: Shortest distances from source to each node; -1 if a node is not reachable. Example: >>> bfs_shortest_path(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)], 1) [0, 1, 2, 1] >>> bfs_shortest_path(6, 3, [(1, 2), (2, 3), (4, 5)], 1) [0, 1, 2, -1, -1, -1] pass # Implementation goes here def shortest_path_multiple_tests(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]], int]]) -> List[List[int]]: Process multiple test cases to find the shortest paths from the source node S to all other nodes in the network. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int]], int]]): List of test cases, each containing: - N (int): Number of nodes. - M (int): Number of edges. - edges (List[Tuple[int, int]]): List of bidirectional edges. - S (int): Source node. Returns: List[List[int]]: List of shortest distances lists for each test case. Example: >>> shortest_path_multiple_tests(2, [ ... (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)], 1), ... (6, 3, [(1, 2), (2, 3), (4, 5)], 1) ... ]) [[0, 1, 2, 1], [0, 1, 2, -1, -1, -1]] pass # Implementation goes here","solution":"from collections import deque, defaultdict def bfs_shortest_path(N, M, edges, S): # Initialize the graph graph = defaultdict(list) for U, V in edges: graph[U].append(V) graph[V].append(U) distances = [-1] * N distances[S - 1] = 0 # BFS initialization queue = deque([S]) while queue: node = queue.popleft() current_dist = distances[node - 1] for neighbor in graph[node]: if distances[neighbor - 1] == -1: # Not visited distances[neighbor - 1] = current_dist + 1 queue.append(neighbor) return distances def shortest_path_multiple_tests(T, test_cases): results = [] for case in test_cases: N, M, edges, S = case result = bfs_shortest_path(N, M, edges, S) results.append(result) return results"},{"question":"def number_to_letter(n: int) -> str: Converts a number to its corresponding lowercase alphabet letter. Parameters: n (int): A number between 1 and 26 inclusive. Returns: str: Corresponding alphabet letter, or an error message for invalid input. >>> number_to_letter(1) == 'a' >>> number_to_letter(2) == 'b' >>> number_to_letter(27) == \\"Invalid input, please enter a number between 1 and 26\\" >>> number_to_letter(0) == \\"Invalid input, please enter a number between 1 and 26\\"","solution":"def number_to_letter(n): Converts a number to its corresponding lowercase alphabet letter. Parameters: n (int): A number between 1 and 26 inclusive. Returns: str: Corresponding alphabet letter, or an error message for invalid input. if 1 <= n <= 26: return chr(n + 96) else: return \\"Invalid input, please enter a number between 1 and 26\\""},{"question":"def multiply_large_integers(P: int, Q: int) -> int: Returns the product of two large integers P and Q. Args: P (int): First large integer. Q (int): Second large integer. Returns: int: The product of P and Q. Examples: >>> multiply_large_integers(4, 5) 20 >>> multiply_large_integers(123456789, 987654321) 121932631112635269 >>> multiply_large_integers(-1, 1) -1 >>> multiply_large_integers(-3, -7) 21 >>> multiply_large_integers(0, 123456) 0 >>> multiply_large_integers(10**100000, 2) 10**100000 * 2","solution":"def multiply_large_integers(P: int, Q: int) -> int: Returns the product of two large integers P and Q. Args: P (int): First large integer. Q (int): Second large integer. Returns: int: The product of P and Q. return P * Q"},{"question":"def generate_zigzag_matrix(T: int, test_cases: List[Tuple[int, int]]) -> List[List[List[int]]]: You are given two integers M and N. Fill an MxN matrix with integers according to the following rules: 1. Start filling from position (1, 1) (row 1, column 1) with the number 1, and continue sequentially until the entire matrix is filled. 2. Fill the matrix in a zigzag pattern: - Fill the first row left to right. - Fill the second row right to left. - Fill the third row left to right. - Continue this pattern throughout the matrix. Arguments: T -- the number of test cases. test_cases -- a list of tuples where each tuple contains two integers M and N. Returns: A list of MxN matrices for each test case. Test cases: >>> generate_zigzag_matrix(1, [(3, 3)]) [[[1, 2, 3], [6, 5, 4], [7, 8, 9]]] >>> generate_zigzag_matrix(1, [(4, 5)]) [[[1, 2, 3, 4, 5], [10, 9, 8, 7, 6], [11, 12, 13, 14, 15], [20, 19, 18, 17, 16]]] >>> generate_zigzag_matrix(1, [(2, 2)]) [[[1, 2], [4, 3]]] >>> generate_zigzag_matrix(3, [(3, 3), (4, 5), (2, 2)]) [ [[1, 2, 3], [6, 5, 4], [7, 8, 9]], [[1, 2, 3, 4, 5], [10, 9, 8, 7, 6], [11, 12, 13, 14, 15], [20, 19, 18, 17, 16]], [[1, 2], [4, 3]] ]","solution":"def generate_zigzag_matrix(T, test_cases): result = [] for case in test_cases: M, N = case matrix = [[0] * N for _ in range(M)] num = 1 for i in range(M): if i % 2 == 0: for j in range(N): matrix[i][j] = num num += 1 else: for j in range(N-1, -1, -1): matrix[i][j] = num num += 1 result.append(matrix) return result"},{"question":"def capitalizeWords(s: str) -> str: Takes a string s and capitalizes the first letter of each word in the string. A word is defined as a contiguous sequence of alphanumeric characters. >>> capitalizeWords(\\"hello\\") == \\"Hello\\" >>> capitalizeWords(\\"hello world\\") == \\"Hello World\\" >>> capitalizeWords(\\"hello world! this is a test.\\") == \\"Hello World! This Is A Test.\\" >>> capitalizeWords(\\"\\") == \\"\\" >>> capitalizeWords(\\"123 abc\\") == \\"123 Abc\\" >>> capitalizeWords(\\"hello123 world!\\") == \\"Hello123 World!\\" >>> capitalizeWords(\\"hello world\\") == \\"Hello World\\" >>> capitalizeWords(\\"!hello world\\") == \\"!hello World\\"","solution":"def capitalizeWords(s): Takes a string s and capitalizes the first letter of each word in the string. A word is defined as a contiguous sequence of alphanumeric characters. result = [] words = s.split(' ') for word in words: if word: capitalized_word = word[0].upper() + word[1:] if word[0].isalnum() else word result.append(capitalized_word) else: result.append(word) return ' '.join(result)"},{"question":"def custom_zip(*iterables): Custom implementation of the built-in zip function. Takes any number of iterables and returns an iterator of tuples. Each tuple contains the i-th element from each of the argument sequences or iterables. Stops when the shortest input iterable is exhausted. >>> list(custom_zip([1, 2, 3], ['a', 'b', 'c'], [True, False, True])) [(1, 'a', True), (2, 'b', False), (3, 'c', True)] >>> list(custom_zip([1, 2, 3, 4], ['a', 'b'], [True, False, True])) [(1, 'a', True), (2, 'b', False)] >>> list(custom_zip([], [1, 2, 3])) [] >>> list(custom_zip([1, 2, 3])) [(1,), (2,), (3,)] >>> a = [1, 2, 3] >>> b = ['a', 'b', 'c'] >>> result = custom_zip(a, b) >>> a.append(4) >>> list(result) [(1, 'a'), (2, 'b'), (3, 'c')] >>> list(custom_zip(\\"abc\\", (1, 2, 3), range(3))) [('a', 1, 0), ('b', 2, 1), ('c', 3, 2)]","solution":"def custom_zip(*iterables): Custom implementation of the built-in zip function. Takes any number of iterables and returns an iterator of tuples. Each tuple contains the i-th element from each of the argument sequences or iterables. Stops when the shortest input iterable is exhausted. # Create a list of iterators from the input iterables. iterators = [iter(it) for it in iterables] while True: result = [] for it in iterators: try: # Try to get the next item from each iterator. result.append(next(it)) except StopIteration: # If any iterator is exhausted, exit the loop. return yield tuple(result)"},{"question":"def find_winner(n, sequence): Determines the winner of the game based on the sequence of integers. Parameters: n (int): The length of the sequence. sequence (list of int): The sequence of non-negative integers. Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins. >>> find_winner(3, [1, 2, 3]) \\"Alice\\" >>> find_winner(4, [1, 1, 1, 1]) \\"Alice\\" >>> find_winner(2, [0, 0]) \\"Bob\\"","solution":"def find_winner(n, sequence): Determines the winner of the game based on the sequence of integers. Parameters: n (int): The length of the sequence. sequence (list of int): The sequence of non-negative integers. Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins. if n == 1: return \\"Alice\\" if all(x == 0 for x in sequence): return \\"Bob\\" return \\"Alice\\""},{"question":"def count_vowels(input_string: str) -> int: Returns the number of vowels (a, e, i, o, u) in the input string. Both lowercase and uppercase vowels are counted. >>> count_vowels(\\"\\") == 0 >>> count_vowels(\\"bcdfg\\") == 0 >>> count_vowels(\\"aeiouAEIOU\\") == 10 >>> count_vowels(\\"Hello World\\") == 3 >>> count_vowels(\\"HELLO\\") == 2 >>> count_vowels(\\"y\\") == 0 >>> count_vowels(\\"aaaaaaa\\"*1000) == 7000","solution":"def count_vowels(input_string): Returns the number of vowels (a, e, i, o, u) in the input string. Both lowercase and uppercase vowels are counted. vowels = \\"aeiouAEIOU\\" count = 0 for char in input_string: if char in vowels: count += 1 return count"},{"question":"def count_unique_locations(matrix: List[List[int]]) -> int: Returns the number of unique locations based on their species set. :param matrix: List[List[int]] representing species matrix :return: int pass # Test cases def test_count_unique_locations_sample_1(): matrix = [ [1, 0, 0, 1, 0], [1, 0, 0, 1, 0], [0, 1, 1, 0, 1] ] assert count_unique_locations(matrix) == 2 def test_count_unique_locations_sample_2(): matrix = [ [1, 0, 1], [0, 1, 1], [1, 0, 1], [0, 0, 0] ] assert count_unique_locations(matrix) == 3 def test_count_unique_locations_all_unique(): matrix = [ [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1] ] assert count_unique_locations(matrix) == 4 def test_count_unique_locations_all_same(): matrix = [ [1, 1, 0], [1, 1, 0], [1, 1, 0] ] assert count_unique_locations(matrix) == 1 def test_count_unique_locations_empty(): matrix = [] assert count_unique_locations(matrix) == 0 def test_count_unique_locations_single_entry(): matrix = [ [1, 1, 1] ] assert count_unique_locations(matrix) == 1","solution":"def count_unique_locations(matrix): Returns the number of unique locations based on their species set. :param matrix: List[List[int]] representing species matrix :return: int # Convert each row (species set) to tuple and create a set to store unique sets unique_sets = set(tuple(row) for row in matrix) # The size of the set is the number of unique locations return len(unique_sets)"},{"question":"class ArrayProcessor: def __init__(self, n, array): self.n = n self.array = array self.lazy = [0] * (n + 1) def _apply_lazy(self): for i in range(1, self.n + 1): self.lazy[i] += self.lazy[i - 1] self.array[i - 1] += self.lazy[i] self.lazy = [0] * (self.n + 1) def range_update(self, l, r, v): self.lazy[l] += v if r + 1 <= self.n: self.lazy[r + 1] -= v def range_sum(self, l, r): self._apply_lazy() # Ensure the array is updated return sum(self.array[l - 1:r]) def process_queries(n, q, array, queries): Process a series of range update and range sum queries on an array. Args: n (int): Number of elements in the initial array. q (int): Number of queries to process. array (List[int]): Initial array of integers. queries (List[str]): List of queries to process. Returns: List[int]: The results of the sum queries. >>> process_queries(6, 4, [1, 2, 3, 4, 5, 6], [\\"1 1 6\\", \\"2 2 5 10\\", \\"1 1 6\\", \\"1 2 4\\"]) [21, 61, 39]","solution":"class ArrayProcessor: def __init__(self, n, array): self.n = n self.array = array self.lazy = [0] * (n + 1) def _apply_lazy(self): for i in range(1, self.n + 1): self.lazy[i] += self.lazy[i - 1] self.array[i - 1] += self.lazy[i] self.lazy = [0] * (self.n + 1) def range_update(self, l, r, v): self.lazy[l] += v if r + 1 <= self.n: self.lazy[r + 1] -= v def range_sum(self, l, r): self._apply_lazy() # Ensure the array is updated return sum(self.array[l - 1:r]) def process_queries(n, q, array, queries): processor = ArrayProcessor(n, array) result = [] for query in queries: parts = query.split() if parts[0] == '1': l, r = int(parts[1]), int(parts[2]) sum_value = processor.range_sum(l, r) result.append(sum_value) elif parts[0] == '2': l, r, v = int(parts[1]), int(parts[2]), int(parts[3]) processor.range_update(l, r, v) return result"},{"question":"def sum_even_numbers(arr): Returns the sum of all the even numbers in the list. If there are no even numbers, returns 0. >>> sum_even_numbers([1, 2, 3, 4, 5, 6]) 12 >>> sum_even_numbers([1, 3, 5, 7]) 0 >>> sum_even_numbers([2, 4, 6, 8]) 20 >>> sum_even_numbers([]) 0 >>> sum_even_numbers([-2, -4, -6]) -12 >>> sum_even_numbers([2, 2, 3, 3]) 4 >>> sum_even_numbers([8]) 8 >>> sum_even_numbers([7]) 0 >>> sum_even_numbers(list(range(0, 101))) 2550","solution":"def sum_even_numbers(arr): Returns the sum of all the even numbers in the list. If there are no even numbers, returns 0. sum_of_evens = 0 for num in arr: if num % 2 == 0: sum_of_evens += num return sum_of_evens"},{"question":"def minimum_flower_patches(n: int, m: int, garden: List[str]) -> int: Determine the minimum number of additional flower patches required to connect all existing flower patches into one connected component. :param n: Number of rows in the garden grid :param m: Number of columns in the garden grid :param garden: List of strings representing the garden grid :return: Minimum number of additional flower patches required pass # Test cases def test_case_1(): n = 4 m = 5 garden = [ \\"F..F.\\", \\".....\\", \\".F.F.\\", \\"...F.\\" ] assert minimum_flower_patches(n, m, garden) == 3 def test_case_2(): n = 3 m = 3 garden = [ \\"F..\\", \\"..F\\", \\"F..\\" ] assert minimum_flower_patches(n, m, garden) == 2 def test_case_no_flowers(): n = 3 m = 3 garden = [ \\"...\\", \\"...\\", \\"...\\" ] assert minimum_flower_patches(n, m, garden) == 0 def test_case_all_connected(): n = 2 m = 2 garden = [ \\"FF\\", \\"FF\\" ] assert minimum_flower_patches(n, m, garden) == 0 def test_case_one_flower(): n = 3 m = 3 garden = [ \\"...\\", \\".F.\\", \\"...\\" ] assert minimum_flower_patches(n, m, garden) == 0","solution":"def minimum_flower_patches(n, m, garden): from collections import deque def bfs(start): queue = deque([start]) visited.add(start) while queue: x, y = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and garden[nx][ny] == 'F': visited.add((nx, ny)) queue.append((nx, ny)) visited = set() components = 0 for i in range(n): for j in range(m): if (i, j) not in visited and garden[i][j] == 'F': bfs((i, j)) components += 1 return max(0, components - 1) # Example usage: n = 4 m = 5 garden = [ \\"F..F.\\", \\".....\\", \\".F.F.\\", \\"...F.\\" ] print(minimum_flower_patches(n, m, garden)) # Output: 3 n = 3 m = 3 garden = [ \\"F..\\", \\"..F\\", \\"F..\\" ] print(minimum_flower_patches(n, m, garden)) # Output: 2"},{"question":"def find_quadruplets(nums, target): Returns a list of all unique quadruplets that sum up to the target number. Arguments: nums -- A list of unique integers target -- The target sum for the quadruplets Returns: A list of all unique quadruplets that sum up to the target number, in ascending lexicographical order def format_quadruplets(quadruplets): Formats the quadruplets for display. Arguments: quadruplets -- A list of quadruplet lists Returns: A string for each quadruplet, sorted in ascending lexicographical order and printed on a new line # Example usage if __name__ == \\"__main__\\": n = int(input().strip()) nums = list(map(int, input().strip().split())) target = int(input().strip()) quadruplets = find_quadruplets(nums, target) print(format_quadruplets(quadruplets))","solution":"def find_quadruplets(nums, target): Returns a list of all unique quadruplets that sum up to the target number. Arguments: nums -- A list of unique integers target -- The target sum for the quadruplets Returns: A list of all unique quadruplets that sum up to the target number, in ascending lexicographical order nums.sort() quadruplets = [] n = len(nums) for i in range(n-3): for j in range(i+1, n-2): left, right = j+1, n-1 while left < right: current_sum = nums[i] + nums[j] + nums[left] + nums[right] if current_sum == target: quadruplet = [nums[i], nums[j], nums[left], nums[right]] if quadruplet not in quadruplets: quadruplets.append(quadruplet) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return quadruplets def format_quadruplets(quadruplets): Formats the quadruplets for display. Arguments: quadruplets -- A list of quadruplet lists Returns: A string for each quadruplet, sorted in ascending lexicographical order and printed on a new line formatted = [] for quad in sorted(quadruplets): formatted.append(\\" \\".join(map(str, quad))) return \\"n\\".join(formatted) # Example usage if __name__ == \\"__main__\\": n = int(input().strip()) nums = list(map(int, input().strip().split())) target = int(input().strip()) quadruplets = find_quadruplets(nums, target) print(format_quadruplets(quadruplets))"},{"question":"from typing import List def minimum_sweetness_difference(n: int, sweetness_levels: List[int]) -> int: Calculate the minimum possible absolute difference in total sweetness levels between two consecutive groups of candies. Args: n (int): The number of candies. sweetness_levels (List[int]): A list of integers representing sweetness levels of the candies. Returns: int: The minimum possible absolute difference. >>> minimum_sweetness_difference(5, [1, 3, 2, 4, 2]) 0 >>> minimum_sweetness_difference(3, [10, 20, 30]) 0 Test cases: import pytest from solution import minimum_sweetness_difference def test_minimum_sweetness_difference_case_1(): assert minimum_sweetness_difference(5, [1, 3, 2, 4, 2]) == 0 def test_minimum_sweetness_difference_case_2(): assert minimum_sweetness_difference(3, [10, 20, 30]) == 0 def test_minimum_sweetness_difference_case_3(): assert minimum_sweetness_difference(4, [1, 1, 1, 1]) == 0 def test_minimum_sweetness_difference_case_4(): assert minimum_sweetness_difference(6, [1, 2, 3, 4, 5, 6]) == 1 def test_minimum_sweetness_difference_case_5(): assert minimum_sweetness_difference(7, [8, 15, 7, 5, 4, 12, 11]) == 2 def test_minimum_sweetness_difference_large_numbers(): assert minimum_sweetness_difference(5, [10000, 10000, 10000, 10000, 10000]) == 10000","solution":"def minimum_sweetness_difference(n, sweetness_levels): # Step 1: Calculate the total sum of sweetness levels total_sweetness = sum(sweetness_levels) # Initialize variables min_diff = float('inf') # We want to minimize this difference running_sum = 0 # Running sum of the sweetness levels from the left # Step 2: Iterate through the candies, computing the running sum and the corresponding difference for i in range(n - 1): # We split between i and i+1, so we stop at n-1 running_sum += sweetness_levels[i] remaining_sum = total_sweetness - running_sum # Calculate the absolute difference current_diff = abs(running_sum - remaining_sum) # Update the minimum difference found min_diff = min(min_diff, current_diff) return min_diff"},{"question":"def count_valid_sequences(n: int) -> int: Given the total number of blocks, returns the number of valid sequences of paint colors where no two adjacent blocks are painted the same color. The result is modulo 10^9 + 7. >>> count_valid_sequences(1) 2 >>> count_valid_sequences(2) 2 >>> count_valid_sequences(3) 4","solution":"def count_valid_sequences(n): Given the total number of blocks, returns the number of valid sequences of paint colors where no two adjacent blocks are painted the same color. The result is modulo 10^9 + 7. MOD = 10**9 + 7 if n == 1: return 2 elif n == 2: return 2 else: return pow(2, n - 1, MOD)"},{"question":"def max_nested_depth(n, logs): Calculate the maximum nested depth of function calls in the provided logs. Parameters: n (int): The number of log entries. logs (list): A list of strings representing the log entries. Returns: int: The maximum depth of nested function calls. pass # Test cases logs1 = [\\"foo\\", \\"bar\\", \\"end\\", \\"baz\\", \\"end\\"] print(max_nested_depth(5, logs1)) # 2 logs2 = [\\"foo\\", \\"bar\\", \\"baz\\", \\"end\\", \\"end\\", \\"boo\\", \\"end\\", \\"end\\"] print(max_nested_depth(8, logs2)) # 3 logs3 = [\\"a\\", \\"b\\", \\"end\\"] print(max_nested_depth(3, logs3)) # 2 logs4 = [\\"foo\\"] print(max_nested_depth(1, logs4)) # 1 logs5 = [\\"foo\\", \\"bar\\", \\"baz\\", \\"qux\\", \\"end\\", \\"end\\", \\"end\\"] print(max_nested_depth(7, logs5)) # 4 logs6 = [\\"foo\\", \\"end\\", \\"bar\\", \\"end\\", \\"baz\\", \\"end\\"] print(max_nested_depth(6, logs6)) # 1 logs7 = [\\"foo\\", \\"bar\\", \\"baz\\"] print(max_nested_depth(3, logs7)) # 3 logs8 = [\\"foo\\", \\"end\\", \\"bar\\", \\"end\\", \\"baz\\", \\"boo\\", \\"end\\", \\"bud\\", \\"end\\"] print(max_nested_depth(9, logs8)) # 2 logs9 = [] print(max_nested_depth(0, logs9)) # 0 logs10 = [\\"foo\\", \\"bar\\", \\"baz\\", \\"end\\", \\"end\\"] print(max_nested_depth(5, logs10)) # 3","solution":"def max_nested_depth(n, logs): Calculate the maximum nested depth of function calls in the provided logs. Parameters: n (int): The number of log entries. logs (list): A list of strings representing the log entries. Returns: int: The maximum depth of nested function calls. max_depth = 0 current_depth = 0 for entry in logs: if entry == \\"end\\": current_depth -= 1 else: current_depth += 1 max_depth = max(max_depth, current_depth) return max_depth"},{"question":"from typing import List def combinationSum2(nums: List[int], target: int) -> List[List[int]]: Implement a function that takes as input a list of integers and an integer target, and returns all unique combinations in the list where the numbers sum to the target. Each number in the list may only be used once in the combination. The solution set must not contain duplicate combinations. >>> combinationSum2([2,3,6,7], 7) [[7]] >>> combinationSum2([2,5,2,1,2], 5) [[1,2,2],[5]] >>> combinationSum2([10,1,2,7,6,1,5], 8) [[1,1,6],[1,2,5],[1,7],[2,6]]","solution":"def combinationSum2(nums, target): nums.sort() result = [] def backtrack(remaining, combination, start): if remaining == 0: result.append(list(combination)) return elif remaining < 0: return for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue combination.append(nums[i]) backtrack(remaining - nums[i], combination, i + 1) combination.pop() backtrack(target, [], 0) return result"},{"question":"from typing import List, Union def arrange_speakers(n: int) -> Union[str, List[int]]: Arrange speakers such that no speaker presents immediately after their unique ID neighbor. >>> arrange_speakers(5) [1, 3, 5, 2, 4] >>> arrange_speakers(4) [2, 4, 1, 3] or [1, 3, 2, 4] or [3, 1, 4, 2] or [4, 2, 1, 3] or [2, 4, 3, 1] >>> arrange_speakers(3) [2, 1, 3] >>> arrange_speakers(2) \\"Not possible\\"","solution":"from typing import List, Union def arrange_speakers(n: int) -> Union[str, List[int]]: if n == 1: return [1] if n == 2: return \\"Not possible\\" # Create two halves, odd and even odd_speakers = list(range(1, n + 1, 2)) even_speakers = list(range(2, n + 1, 2)) # Combine them by putting all odd ones first, then even ones arrangement = odd_speakers + even_speakers return arrangement"},{"question":"import re from typing import List def is_valid_expression(expr: str) -> bool: Determines if the given string expr is a valid arithmetic expression based on the given rules. >>> is_valid_expression(\\"12+34*5-6/2\\") True >>> is_valid_expression(\\"12++34\\") False >>> is_valid_expression(\\"0+05/1\\") False >>> is_valid_expression(\\"100/0+1\\") False >>> is_valid_expression(\\"123*456-789/3+100\\") True","solution":"import re def is_valid_expression(expr): Determines if the given string expr is a valid arithmetic expression based on the given rules. # Checking for empty expression if not expr: return False # Validating the expression with a regular expression pattern # This regex ensures: # 1. Starts with a digit # 2. Ends with a digit # 3. Doesn't contain consecutive operators # 4. Does not have leading zeros in the operands # 5. Between digits and operators is allowed pattern = re.compile(r'^(?:(?:[1-9]d*)|0)([+-*/](?:(?:[1-9]d*)|0))*') # If the regex match is None, the expression is invalid if not pattern.fullmatch(expr): return False # Split by operators and check for division by zero expr_parts = re.split(r'([+-*/])', expr) for i in range(len(expr_parts) - 1): if expr_parts[i] == '/' and expr_parts[i + 1] == '0': return False return True"},{"question":"def minimum_upgrade_cost(n: int, m: int, s0: int, bridges: list[tuple[int, int, int]]) -> int: Computes the minimum cost to upgrade all bridges to at least the required minimum strength s0. Parameters: n (int): Number of islands. m (int): Number of bridges. s0 (int): The required minimum magical strength. bridges (List[Tuple[int, int, int]]): List of tuples where each tuple contains three integers a, b, and si denoting a bridge between island a and island b with current strength si. Returns: int: The minimum cost to upgrade all bridges. Examples: >>> minimum_upgrade_cost(3, 3, 8, [(1, 2, 5), (2, 3, 7), (3, 1, 6)]) 6 >>> minimum_upgrade_cost(4, 4, 10, [(1, 2, 9), (2, 3, 12), (3, 4, 5), (4, 1, 8)]) 8","solution":"def minimum_upgrade_cost(n, m, s0, bridges): Computes the minimum cost to upgrade all bridges to at least the required minimum strength s0. Parameters: n (int): Number of islands. m (int): Number of bridges. s0 (int): The required minimum magical strength. bridges (List[Tuple[int, int, int]]): List of tuples where each tuple contains three integers a, b, and si denoting a bridge between island a and island b with current strength si. Returns: int: The minimum cost to upgrade all bridges. total_cost = 0 for a, b, si in bridges: if si < s0: total_cost += s0 - si return total_cost"},{"question":"from typing import List def max_water_trapped(test_cases: List[List[int]]) -> List[int]: For each test case (a list of non-negative integers representing heights of the pillars), determine the maximum amount of water that can be trapped between the pillars after it rains. Arguments: test_cases -- A list of test cases where each test case is a list of integers representing the heights of the pillars Returns: A list of integers, each representing the maximum water trapped for the corresponding test case Examples: >>> max_water_trapped([[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]]) [6] >>> max_water_trapped([[4, 2, 0, 3, 2, 5]]) [9] >>> max_water_trapped([[7, 4, 0, 9, 4, 7, 8]]) [15] >>> max_water_trapped([[0, 0, 0, 0, 0]]) [0] >>> max_water_trapped([[]]) [0]","solution":"def max_water_trapped(test_cases): def calculate_water(heights): n = len(heights) if n == 0: return 0 left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped results = [] for heights in test_cases: results.append(calculate_water(heights)) return results"},{"question":"def is_palindrome_permutation(s: str) -> bool: Determine if the input string is a permutation of a palindrome. A palindrome is a word or phrase that is the same forwards and backwards. Only consider letters and ignore case. >>> is_palindrome_permutation(\\"Tact Coa\\") True >>> is_palindrome_permutation(\\"Hello\\") False >>> is_palindrome_permutation(\\"\\") True >>> is_palindrome_permutation(\\"a\\") True >>> is_palindrome_permutation(\\"AaBbCc\\") True >>> is_palindrome_permutation(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindrome_permutation(\\"aaa\\") True >>> is_palindrome_permutation(\\"abcdef\\") False","solution":"def is_palindrome_permutation(s): Determine if the input string is a permutation of a palindrome. A palindrome is a word or phrase that is the same forwards and backwards. Only consider letters and ignore case. from collections import Counter # Convert to lowercase and remove non-letter characters s = ''.join(c.lower() for c in s if c.isalpha()) # Count the frequency of each character char_count = Counter(s) # Check the number of odd frequencies odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be a palindrome if it has at most one character with an odd count return odd_count <= 1"},{"question":"import math from typing import List, Tuple def prime_factors(n: int) -> dict: Return a dictionary with prime factors as keys and their powers as values. >>> prime_factors(1000) {2: 3, 5: 3} >>> prime_factors(50) {2: 1, 5: 2} pass def get_smallest_prime_greater_equal(n: int, k: int) -> int: Return the smallest prime factor of n which is greater than or equal to k. >>> get_smallest_prime_greater_equal(1000, 3) 5 >>> get_smallest_prime_greater_equal(50, 4) 5 pass def handle_queries(n: int, queries: List[Tuple[int, int]]) -> List[int]: Handle the queries on the number n. >>> handle_queries(1000, [(1, 2), (2, 3), (3, 5)]) [3, 5, 2] >>> handle_queries(50, [(1, 2), (1, 5), (1, 3), (3, 4), (2, 2)]) [1, 2, 0, 0, 2] pass","solution":"import math from collections import Counter def prime_factors(n): Return a dictionary with prime factors as keys and their powers as values. i = 2 factors = {} while i * i <= n: while (n % i) == 0: if i in factors: factors[i] += 1 else: factors[i] = 1 n //= i i += 1 if n > 1: factors[n] = 1 return factors def get_smallest_prime_greater_equal(n, k): if k <= 2: return 2 if n % 2 == 0 else 3 prime = k if k % 2 == 1 else k + 1 while prime * prime <= n: if all(prime % d != 0 for d in range(3, int(math.sqrt(prime)) + 1, 2)): if n % prime == 0: return prime prime += 2 return n def handle_queries(n, queries): results = [] factors = prime_factors(n) for t, k in queries: if t == 1: # max power of k that divides n if k in factors: results.append(factors[k]) else: results.append(0) elif t == 2: # smallest prime factor >= k results.append(get_smallest_prime_greater_equal(n, k)) elif t == 3: # does k divide n and how many distinct prime factors of n/k if n % k == 0: remaining_factors = prime_factors(n // k) results.append(len(remaining_factors)) else: results.append(0) return results"},{"question":"from typing import List, Tuple def max_passengers(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Calculate the maximum number of passengers that can be transported by visiting exactly K stations. :param T: int - Number of test cases :param test_cases: List of Tuples where each tuple contains: - A tuple (N, K): N is the number of stations, K is the number of stations the train can visit - A list of integers: representing the number of passengers at each station :return: List of integers - Maximum number of passengers that can be transported for each test case >>> max_passengers(2, [((5, 3), [10, 20, 30, 40, 50]), ((4, 2), [1, 2, 3, 4])]) [120, 7] >>> max_passengers(1, [((4, 4), [1000, 200, 300, 500])]) [2000] pass import pytest def test_case_1(): T = 1 test_cases = [((5, 3), [10, 20, 30, 40, 50])] assert max_passengers(T, test_cases) == [120] def test_case_2(): T = 1 test_cases = [((4, 2), [1, 2, 3, 4])] assert max_passengers(T, test_cases) == [7] def test_case_3(): T = 2 test_cases = [((5, 3), [10, 20, 30, 40, 50]), ((4, 2), [1, 2, 3, 4])] assert max_passengers(T, test_cases) == [120, 7] def test_case_4(): T = 1 test_cases = [((4, 4), [1000, 200, 300, 500])] assert max_passengers(T, test_cases) == [2000] def test_case_5(): T = 1 test_cases = [((6, 2), [15, 25, 35, 45, 55, 20])] assert max_passengers(T, test_cases) == [100]","solution":"from itertools import combinations def max_passengers(T, test_cases): results = [] for i in range(T): N, K = test_cases[i][0] passengers = test_cases[i][1] # Generate all possible combinations of K stations max_passengers_transport = 0 for comb in combinations(passengers, K): max_passengers_transport = max(max_passengers_transport, sum(comb)) results.append(max_passengers_transport) return results"},{"question":"def calculateShippingCost(n: int, costs: List[int]) -> int: Calculate the total shipping cost based on the number of kilograms n and given costs. Parameters: n (int): The number of kilograms to ship. costs (List[int]): A list containing the cost per kilogram for standard and express shipping respectively. Returns: int: The total shipping cost. Examples: >>> calculateShippingCost(7, [5, 10]) 35 >>> calculateShippingCost(15, [5, 10]) 150 >>> calculateShippingCost(9, [3, 8]) 27 >>> calculateShippingCost(10, [3, 8]) 80 >>> calculateShippingCost(1, [2, 5]) 2 >>> calculateShippingCost(5, [20, 15]) 100 >>> calculateShippingCost(50, [5, 20]) 1000","solution":"def calculateShippingCost(n, costs): Calculate the total shipping cost based on the number of kilograms n and given costs. Parameters: n (int): The number of kilograms to ship. costs (List[int]): A list containing the cost per kilogram for standard and express shipping respectively. Returns: int: The total shipping cost. standard_cost, express_cost = costs if n < 10: return n * standard_cost else: return n * express_cost"},{"question":"def trap(height): Computes the total amount of trapped rainwater given the height of the bars. Parameters: height (list of int): A list of non-negative integers representing the height of the bars. Returns: int: The total amount of trapped rainwater. >>> trap([4,2,0,3,2,5]) 9 >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6","solution":"def trap(height): Computes the total amount of trapped rainwater given the height of the bars. Parameters: height (list of int): A list of non-negative integers representing the height of the bars. Returns: int: The total amount of trapped rainwater. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def count_islands(grid: List[List[str]]) -> int: Count the number of distinct islands in the grid. An island is a group of connected '1's (land cells) connected horizontally or vertically (not diagonally). >>> count_islands([ ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ... ]) 3 >>> count_islands([ ... [\\"1\\", \\"1\\", \\"1\\"], ... [\\"0\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"1\\"] ... ]) 1 >>> count_islands([['1']]) 1 >>> count_islands([['0']]) 0 >>> count_islands([ ... [\\"1\\", \\"0\\", \\"1\\"], ... [\\"1\\", \\"0\\", \\"1\\"], ... [\\"0\\", \\"0\\", \\"0\\"] ... ]) 2","solution":"def count_islands(grid): def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != '1': return grid[i][j] = '0' # Mark the cell as visited # Explore the neighboring cells (up, down, left, right) dfs(i - 1, j) dfs(i + 1, j) dfs(i, j - 1) dfs(i, j + 1) count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': count += 1 dfs(i, j) return count"},{"question":"def min_notes(M, B, X): Returns the minimum number of notes required to sum up to X using denominations M and B. If it is not possible to sum up to X using the given denominations, returns -1. >>> min_notes(4, 5, 23) 5 >>> min_notes(6, 9, 41) -1 >>> min_notes(2, 3, 7) 3 >>> min_notes(5, 7, 35) 5 >>> min_notes(7, 5, 35) 5 >>> min_notes(1, 1, 10) 10 >>> min_notes(3, 4, 29) 8 >>> min_notes(8, 6, 48) 6 >>> min_notes(25, 10, 100) 4 >>> min_notes(10, 1, 11) 2","solution":"def min_notes(M, B, X): Returns the minimum number of notes required to sum up to X using denominations M and B. If it is not possible to sum up to X using the given denominations, returns -1. if M > B: M, B = B, M min_notes_required = float('inf') found_solution = False # Try every possible number of M notes from 0 to X//M notes for m_count in range(X // M + 1): remainder = X - m_count * M if remainder % B == 0: b_count = remainder // B total_notes = m_count + b_count min_notes_required = min(min_notes_required, total_notes) found_solution = True return min_notes_required if found_solution else -1"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the number of palindromic substrings in the given string. >>> count_palindromic_substrings(\\"abba\\") 6 >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aaa\\") 6","solution":"def count_palindromic_substrings(s: str) -> int: Returns the number of palindromic substrings in the given string. n = len(s) count = 0 # Helper function to count palindromes centered at left and right def count_palindromes_around_center(left: int, right: int): nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 # Check all centers for even and odd length palindromes for center in range(n): count_palindromes_around_center(center, center) # For odd-length palindromes count_palindromes_around_center(center, center + 1) # For even-length palindromes return count"},{"question":"def highest_product_of_three(nums): Given an array of integers, return the highest product possible by multiplying three numbers. :param nums: List[int] - an array of integers :return: int - the highest product of three numbers in the array >>> highest_product_of_three([1, 10, 2, 6, 5, 3]) 300 >>> highest_product_of_three([-10, -10, 5, 2]) 500","solution":"def highest_product_of_three(nums): Returns the highest product possible by multiplying three numbers in the array. :param nums: List[int] - an array of integers :return: int - the highest product of three numbers in the array if len(nums) < 3: raise ValueError(\\"Array must contain at least three numbers\\") nums.sort() # The maximum product can be the product of the three largest numbers max_product = nums[-1] * nums[-2] * nums[-3] # Or it can be the product of the two smallest numbers and the largest number (for dealing with negatives) max_product = max(max_product, nums[0] * nums[1] * nums[-1]) return max_product"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. :param s: Input string consisting of lowercase and uppercase letters :type s: str :return: Length of the longest substring without repeating characters :rtype: int >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\" \\") == 1 >>> length_of_longest_substring(\\"au\\") == 2 >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\\") == 26","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. :param s: Input string consisting of lowercase and uppercase letters :type s: str :return: Length of the longest substring without repeating characters :rtype: int char_index_map = {} start = 0 max_length = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"def printStarPattern(n: int) -> None: Write a function that takes an integer n as input and generates the following pattern. Each line i (where 1 <= i <= n), should contain i instances of the character '*'. Args: n (int): The number of lines of the pattern Example 1: >>> printStarPattern(4) * * * * * * * * * * Example 2: >>> printStarPattern(3) * * * * * * Constraints: 1 <= n <= 20","solution":"def printStarPattern(n): Prints a pattern of '*' where each line i (1 <= i <= n) contains i instances of '*'. for i in range(1, n + 1): print('* ' * i)"},{"question":"def min_edit_distance(word1: str, word2: str) -> int: Calculate the minimum number of single-character edits (insertions, deletions or substitutions) required to change one word into another. >>> min_edit_distance('kitten', 'sitting') == 3 >>> min_edit_distance('flaw', 'lawn') == 2 >>> min_edit_distance('intention', 'execution') == 5","solution":"def min_edit_distance(word1, word2): Calculate the minimum number of single-character edits (insertions, deletions, or substitutions) required to change one word into another. m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If the first string is empty, insert all characters of second string elif j == 0: dp[i][j] = i # If the second string is empty, remove all characters of first string elif word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] # If the characters are the same, ignore and move to the next else: dp[i][j] = 1 + min(dp[i-1][j], # Insert dp[i][j-1], # Remove dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"def count_sunlit_buildings(n, heights): Determines the number of buildings that have sunlight. Parameters: n (int): Number of buildings heights (list of int): Heights of buildings Returns: int: Number of buildings that have sunlight >>> count_sunlit_buildings(6, [7, 4, 8, 2, 9, 5]) 3 >>> count_sunlit_buildings(4, [2, 2, 2, 2]) 4 >>> count_sunlit_buildings(5, [1, 2, 3, 4, 5]) 5 >>> count_sunlit_buildings(5, [5, 4, 3, 2, 1]) 1 >>> count_sunlit_buildings(1, [5]) 1 >>> count_sunlit_buildings(2, [2, 3]) 2 >>> count_sunlit_buildings(2, [3, 2]) 1 >>> count_sunlit_buildings(5, [3, 1, 4, 1, 5]) 3","solution":"def count_sunlit_buildings(n, heights): Determines the number of buildings that have sunlight. Parameters: n (int): Number of buildings heights (list of int): Heights of buildings Returns: int: Number of buildings that have sunlight if n == 0: return 0 # First building always has sunlight sunlit_count = 1 max_height = heights[0] for i in range(1, n): if heights[i] >= max_height: sunlit_count += 1 max_height = heights[i] return sunlit_count # Example usage: # n = 6 # heights = [7, 4, 8, 2, 9, 5] # print(count_sunlit_buildings(n, heights)) # Output: 3"},{"question":"def double_char(s: str) -> str: Returns a new string where each character from the original string is repeated twice. >>> double_char(\\"hello\\") == \\"hheelllloo\\" >>> double_char(\\"1234!\\") == \\"11223344!!\\" >>> double_char(\\"\\") == \\"\\" >>> double_char(\\"a\\") == \\"aa\\" >>> double_char(\\"aA1!\\") == \\"aaAA11!!\\" >>> double_char(\\"a b\\") == \\"aa bb\\" >>> double_char(\\"#%^&\\") == \\"%%^^&&\\"","solution":"def double_char(s: str) -> str: Returns a new string where each character from the original string is repeated twice. return ''.join([char * 2 for char in s])"},{"question":"def min_steps(n: int, m: int, grid: List[str]) -> int: Determine the minimum number of steps required to move from the top-left corner to the bottom-right corner of the grid, where a step constitutes moving either left, right, up, or down to an adjacent free cell. Args: n : int : number of rows in the grid m : int : number of columns in the grid grid : List[str] : the grid represented as a list of strings Returns: int : the minimum number of steps required, or -1 if it's impossible Examples: >>> min_steps(5, 5, [ ... \\".....\\", ... \\".#.#.\\", ... \\".#.#.\\", ... \\".#.#.\\", ... \\".....\\" ... ]) == 8 >>> min_steps(4, 4, [ ... \\"....\\", ... \\"#.\\", ... \\"..#.\\", ... \\"...#\\" ... ]) == -1","solution":"from collections import deque def min_steps(n, m, grid): # Check if the start or end point is blocked if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 # Directions for moving: right, left, down, up directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Initialize the BFS queue and visited matrix queue = deque([(0, 0, 0)]) # (row, col, steps) visited = [[False] * m for _ in range(n)] visited[0][0] = True while queue: row, col, steps = queue.popleft() # Check if the bottom-right corner is reached if row == n - 1 and col == m - 1: return steps # Explore the neighbors for dr, dc in directions: new_row, new_col = row + dr, col + dc # Check if the new position is within bounds and not visited and not blocked if 0 <= new_row < n and 0 <= new_col < m and not visited[new_row][new_col] and grid[new_row][new_col] == '.': visited[new_row][new_col] = True queue.append((new_row, new_col, steps + 1)) # If the bottom-right corner was not reached return -1"},{"question":"def reader_classification(stories_per_month: List[int]) -> str: Determine the reader classification based on the number of stories read each month. A reader is classified as \\"LOVER READER\\" if the number of months they read 10 or more stories is greater than the number of months they read fewer than 10 stories. Otherwise, they are classified as \\"REGULAR READER\\". Parameters: stories_per_month (list of int): A list of 12 integers representing the number of stories read each month Returns: str: The classification of the reader (\\"LOYAL READER\\" or \\"REGULAR READER\\") >>> reader_classification([9, 11, 5, 20, 18, 7, 13, 9, 6, 10, 12, 8]) 'REGULAR READER' >>> reader_classification([10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10]) 'LOYAL READER'","solution":"def reader_classification(stories_per_month): This function takes a list of 12 integers representing the number of stories read each month, and returns 'LOYAL READER' if the reader is classified as such and 'REGULAR READER' otherwise. story_lover_months = sum(1 for stories in stories_per_month if stories >= 10) casual_reader_months = 12 - story_lover_months if story_lover_months > casual_reader_months: return \\"LOYAL READER\\" else: return \\"REGULAR READER\\""},{"question":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Determine the number of unique paths a robot can take to navigate from the top-left corner to the bottom-right corner of a grid with obstacles. >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 2 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 6 >>> unique_paths_with_obstacles([[0, 1, 1], [0, 0, 1], [1, 0, 0]]) == 1 >>> unique_paths_with_obstacles([[0]]) == 1 >>> unique_paths_with_obstacles([[1, 0], [0, 0]]) == 0 >>> unique_paths_with_obstacles([[0, 0], [0, 1]]) == 0","solution":"def unique_paths_with_obstacles(grid): m = len(grid) n = len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def compute_spell_power(n: int, spells: List[str]) -> List[int]: Given the number of spells and the spells themselves, this function computes the power of each spell which is defined as the length of the longest substring that appears more than once. :param n: int - Number of spells :param spells: list of str - List of strings representing the spells :return: list of int - List of integers representing the power of each spell Example: >>> compute_spell_power(3, [\\"ababab\\", \\"abcdefg\\", \\"aaaaa\\"]) [4, 0, 4] >>> compute_spell_power(3, [\\"a\\", \\"b\\", \\"c\\"]) [0, 0, 0] >>> compute_spell_power(3, [\\"aaaaa\\", \\"bbbbbb\\", \\"cccccccc\\"]) [4, 5, 7] >>> compute_spell_power(3, [\\"abababab\\", \\"xyzxyz\\", \\"pqrspqrs\\"]) [6, 3, 4] >>> compute_spell_power(3, [\\"abcdefgh\\", \\"ijklmnop\\", \\"qrstuvwx\\"]) [0, 0, 0] >>> compute_spell_power(3, [\\"abcdabcabcd\\", \\"aabbaabb\\", \\"abcdefabcdefg\\"]) [4, 4, 6]","solution":"def compute_spell_power(n, spells): Given the number of spells and the spells themselves, this function computes the power of each spell which is defined as the length of the longest substring that appears more than once. :param n: int - Number of spells :param spells: list of str - List of strings representing the spells :return: list of int - List of integers representing the power of each spell def longest_repeated_substring_length(s): Helper function to find the length of the longest substring which appears more than once in the given spell string. :param s: str - The spell string :return: int - Length of the longest repeated substring n = len(s) max_len = 0 # Create suffix array suffixes = sorted([s[i:] for i in range(n)]) for i in range(1, n): # Find the longest common prefix between consecutive suffixes lcp = 0 while (lcp < len(suffixes[i]) and lcp < len(suffixes[i-1]) and suffixes[i][lcp] == suffixes[i-1][lcp]): lcp += 1 max_len = max(max_len, lcp) return max_len return [longest_repeated_substring_length(spell) for spell in spells]"},{"question":"def find_most_frequent_color(N, M, instructions): Given a grid size N and a list of instructions, this function initializes the grid as an N x N grid of zeroes, applies each instruction to the grid by setting the cell at position (R, C) to the given color code K, and returns the color code that appears most frequently in the grid. If multiple color codes have the same highest frequency, it returns the smallest color code among them. >>> find_most_frequent_color(5, 8, [(0, 0, 1), (0, 1, 2), (0, 2, 2), (1, 1, 3), (2, 2, 1), (2, 3, 3), (3, 3, 1), (4, 4, 3)]) 1 >>> find_most_frequent_color(3, 1, [(1, 1, 5)]) 5 >>> find_most_frequent_color(3, 0, []) float('inf') >>> find_most_frequent_color(2, 2, [(0, 0, 0), (1, 1, 0)]) float('inf') >>> find_most_frequent_color(4, 6, [(0, 0, 2), (0, 1, 2), (1, 1, 1), (2, 2, 1), (3, 3, 3), (3, 2, 3)]) 1 >>> find_most_frequent_color(3, 4, [(1, 1, 1), (1, 2, 2), (2, 0, 1), (2, 2, 3)]) 1","solution":"def find_most_frequent_color(N, M, instructions): Given a grid size N and a list of instructions, this function returns the color code that appears most frequently in the grid after applying all the instructions. If multiple color codes have the same highest frequency, it returns the smallest color code among them. from collections import defaultdict # Initialize the grid grid = [[0] * N for _ in range(N)] # Apply the instructions for R, C, K in instructions: grid[R][C] = K # Count the frequency of each color code frequency = defaultdict(int) for row in grid: for color in row: if color != 0: # We don't count the initial '0' color frequency[color] += 1 # Find the color code with the maximum frequency max_freq = 0 max_color = float('inf') for color, freq in frequency.items(): if freq > max_freq or (freq == max_freq and color < max_color): max_freq = freq max_color = color return max_color"},{"question":"def get_dag_movements(n: int, y: int, edges: List[Tuple[int, int]]) -> int: Determine the total number of moves both players will make until the game ends. Amelia and Ben are playing a modified game on a directed acyclic graph (DAG) with n vertices. Amelia starts at vertex 1 and Ben starts at vertex y (1 ≤ y ≤ n). The vertices are numbered from 1 to n. >>> get_dag_movements(5, 4, [(1, 2), (1, 3), (2, 4), (3, 5), (4, 5)]) 2 >>> get_dag_movements(6, 6, [(1, 2), (1, 3), (2, 4), (2, 5), (4, 6), (5, 6)]) 3 >>> get_dag_movements(4, 4, [(1, 2), (2, 3), (3, 4)]) 3 >>> get_dag_movements(5, 5, [(1, 2), (2, 3), (2, 4), (4, 5)]) 3 >>> get_dag_movements(5, 5, [(1, 2), (2, 3), (1, 4), (4, 5), (3, 5)]) 2","solution":"def get_dag_movements(n, y, edges): from collections import deque, defaultdict # Creating adjacency list for the graph graph = defaultdict(list) for a, b in edges: graph[a].append(b) # Function to perform BFS and find shortest path trace def bfs_shortest_path(start): queue = deque([(start, 0)]) visited = set() distance = {i: float('inf') for i in range(1, n+1)} distance[start] = 0 while queue: node, dist = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if distance[neighbor] > dist + 1: distance[neighbor] = dist + 1 queue.append((neighbor, dist + 1)) return distance # Amelia starts at 1 and Ben starts at y amelia_distances = bfs_shortest_path(1) ben_distances = bfs_shortest_path(y) # Find the minimum moves to meet Amelia and Ben min_meeting_moves = float('inf') for i in range(1, n + 1): if amelia_distances[i] != float('inf') and ben_distances[i] != float('inf'): min_meeting_moves = min(min_meeting_moves, max(amelia_distances[i], ben_distances[i])) return min_meeting_moves"},{"question":"def reorderEvenOdd(arr: List[int]) -> List[int]: Reorders a list so that all even integers appear before all odd integers, while maintaining the relative order of the even integers and the odd integers. Parameters: arr (list): List of integers. Returns: list: Reordered list with all even integers before odd integers. Examples: >>> reorderEvenOdd([1, 2, 3, 4, 5, 6]) [2, 4, 6, 1, 3, 5] >>> reorderEvenOdd([3, 1, 2, 4]) [2, 4, 3, 1]","solution":"def reorderEvenOdd(arr): Reorders a list so that all even integers appear before all odd integers, while maintaining the relative order of the even integers and the odd integers. Parameters: arr (list): List of integers. Returns: list: Reordered list with all even integers before odd integers. evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] return evens + odds"},{"question":"def partial_reverse_array(arr, k1, k2, k3, k4): This function reverses subarray from index k1 to k2 (inclusive), and then reverses subarray from index k3 to k4 (inclusive). :param arr: List[int] - The input array :param k1: int - Start index of first subarray :param k2: int - End index of first subarray :param k3: int - Start index of second subarray :param k4: int - End index of second subarray :return: List[int] - The modified array with the specified parts reversed # Your code here # Example test cases if __name__ == \\"__main__\\": print(partial_reverse_array([1, 2, 3, 4, 5, 6, 7], 1, 3, 4, 6)) # Output: [1, 4, 3, 2, 7, 6, 5] print(partial_reverse_array([10, 20, 30, 40, 50], 0, 2, 3, 4)) # Output: [30, 20, 10, 50, 40]","solution":"def partial_reverse_array(arr, k1, k2, k3, k4): This function reverses subarray from index k1 to k2 (inclusive), and then reverses subarray from index k3 to k4 (inclusive). :param arr: List[int] - The input array :param k1: int - Start index of first subarray :param k2: int - End index of first subarray :param k3: int - Start index of second subarray :param k4: int - End index of second subarray :return: List[int] - The modified array with the specified parts reversed # Reverse the first subarray arr[k1:k2+1] = arr[k1:k2+1][::-1] # Reverse the second subarray arr[k3:k4+1] = arr[k3:k4+1][::-1] return arr # Example usage: # n = 7 # arr = [1, 2, 3, 4, 5, 6, 7] # k1, k2, k3, k4 = 1, 3, 4, 6 # result = partial_reverse_array(arr, k1, k2, k3, k4) # print(result) # Output: [1, 4, 3, 2, 7, 6, 5]"},{"question":"def validate_ip_addresses(ip_addresses): Validates a list of IP addresses. For each IP address in the list, if it is valid according to the criteria, outputs 'VALID'. Otherwise, outputs 'INVALID'. Params: - ip_addresses (list of str): List of IP addresses to validate Returns: - list of str: List of 'VALID' or 'INVALID' corresponding to each IP address pass # Example usage: # ip_addresses = [ # \\"192.168.0.1\\", # \\"255.255.255.255\\", # \\"256.100.50.25\\", # \\"123.123.123.123.123\\" # ] # print(validate_ip_addresses(ip_addresses)) # Output: # [\\"VALID\\", \\"VALID\\", \\"INVALID\\", \\"INVALID\\"]","solution":"def validate_ip_addresses(ip_addresses): Validates a list of IP addresses. For each IP address in the list, if it is valid according to the criteria, outputs 'VALID'. Otherwise, outputs 'INVALID'. Params: - ip_addresses (list of str): List of IP addresses to validate Returns: - list of str: List of 'VALID' or 'INVALID' corresponding to each IP address def is_valid_ip(ip): parts = ip.split('.') if len(parts) != 4: return \\"INVALID\\" for part in parts: if not part.isdigit(): return \\"INVALID\\" octet = int(part) if not (0 <= octet <= 255): return \\"INVALID\\" return \\"VALID\\" return [is_valid_ip(ip) for ip in ip_addresses]"},{"question":"def max_vehicles_per_cycle(T: int, test_cases: List[Tuple[int, int, int, int, int]]) -> List[int]: Determine the total number of vehicles from both roads that can pass through the intersection during one complete cycle for each test case. Args: T: An integer representing the number of test cases. test_cases: A list of tuples, each containing five integers (N, M, G, R, D). Returns: A list of integers, where each integer represents the total number of vehicles that can pass through the intersection during one complete cycle for the corresponding test case. >>> max_vehicles_per_cycle(3, [(10, 15, 5, 3, 8), (20, 25, 7, 2, 9), (30, 35, 4, 4, 8)]) [125, 315, 260] >>> max_vehicles_per_cycle(1, [(5, 10, 2, 1, 3)]) [30]","solution":"def max_vehicles_per_cycle(T, test_cases): results = [] for case in test_cases: N, M, G, _, _ = case # We don't need R and D as G + R = D total_vehicles = N * G + M * G results.append(total_vehicles) return results"},{"question":"from typing import List, Tuple def total_fruits(T: int, test_cases: List[Tuple[int, int, int, int, int]]) -> List[Tuple[int, int]]: Calculate the total fruits collected by Johnny and Sarah after all the turns. Parameters: T (int): Number of test cases. test_cases (List[Tuple[int, int, int, int, int]]): List of test cases, each containing five integers P, Q, J, S, M. Returns: List[Tuple[int, int]]: List of tuples, each containing two integers - total fruits picked by Johnny and Sarah after all the turns. Example: >>> total_fruits(3, [(1, 2, 1, 2, 1), (0, 0, 3, 4, 2), (5, 10, 2, 1, 5)]) [(2, 4), (6, 8), (15, 15)] >>> total_fruits(1, [(2, 3, 3, 2, 1)]) [(5, 5)] if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def total_fruits(T, test_cases): results = [] for case in test_cases: P, Q, J, S, M = case johnny_total = P + J * M sarah_total = Q + S * M results.append((johnny_total, sarah_total)) return results"},{"question":"def repeat_and_truncate_string(s: str, k: int) -> str: Forms a new string by repeating \`s\` as many times as necessary to reach a length of \`k\` or more. Truncates the resulting string to make it exactly of length \`k\`. Parameters: s (str): The string to repeat. k (int): The desired length of the resulting string. Returns: str: The resulting string of length \`k\`. Examples: >>> repeat_and_truncate_string(\\"abc\\", 10) \\"abcabcabca\\" >>> repeat_and_truncate_string(\\"abcdef\\", 3) \\"abc\\"","solution":"def repeat_and_truncate_string(s, k): Repeats the string \`s\` until the length is at least \`k\`, then truncates it to length \`k\`. Parameters: s (str): The string to repeat. k (int): The desired length of the resulting string. Returns: str: The resulting string of length \`k\`. repeated_string = (s * ((k // len(s)) + 1))[:k] return repeated_string"},{"question":"def count_distinct_substrings(k: int, s: str) -> int: Returns the number of distinct substrings of length k in the string s. >>> count_distinct_substrings(3, \\"ababc\\") 3 >>> count_distinct_substrings(1, \\"aaaa\\") 1 >>> count_distinct_substrings(6, \\"abcdef\\") 1 >>> count_distinct_substrings(10, \\"abc\\") 0 >>> count_distinct_substrings(2, \\"abacab\\") 4 >>> count_distinct_substrings(3, \\"abc\\") 1 >>> count_distinct_substrings(2, \\"abcdef\\") 5 >>> count_distinct_substrings(2, \\"abababab\\") 2","solution":"def count_distinct_substrings(k, s): Returns the number of distinct substrings of length k in the string s. if k > len(s): return 0 substrings = set() for i in range(len(s) - k + 1): substrings.add(s[i:i+k]) return len(substrings)"},{"question":"def process_queries(n: int, m: int, nums: List[int], k: int, queries: List[Tuple[int, int]]) -> List[int]: Returns the results of the queries performed on the array nums with regards to the threshold k. Args: n : int : size of the array m : int : number of queries nums : list of int : elements of the array k : int : threshold value queries : list of tuples : each tuple contains two integers l and r representing a query Returns: list of int : results of the queries # Your implementation here # Example test cases def test_process_queries(): n = 8 m = 3 nums = [1, 3, 5, 7, 9, 2, 4, 6] k = 5 queries = [(1, 4), (2, 6), (3, 8)] result = process_queries(n, m, nums, k, queries) assert result == [1, 2, 3] def test_all_elements_less_than_k(): n = 5 m = 2 nums = [1, 2, 3, 4, 5] k = 6 queries = [(1, 3), (2, 5)] result = process_queries(n, m, nums, k, queries) assert result == [0, 0] def test_single_element_greater_than_k(): n = 5 m = 1 nums = [1, 9, 3, 4, 5] k = 6 queries = [(1, 2)] result = process_queries(n, m, nums, k, queries) assert result == [1] def test_multiple_distinct_elements_greater_than_k(): n = 5 m = 1 nums = [7, 8, 9, 6, 10] k = 5 queries = [(1, 5)] result = process_queries(n, m, nums, k, queries) assert result == [5] def test_no_elements_greater_than_k(): n = 4 m = 1 nums = [1, 2, 3, 4] k = 4 queries = [(1, 4)] result = process_queries(n, m, nums, k, queries) assert result == [0]","solution":"def process_queries(n, m, nums, k, queries): Returns the results of the queries performed on the array nums with regards to the threshold k. Args: n : int : size of the array m : int : number of queries nums : list of int : elements of the array k : int : threshold value queries : list of tuples : each tuple contains two integers l and r representing a query Returns: list of int : results of the queries results = [] for query in queries: l, r = query distinct_elements = set() for i in range(l - 1, r): if nums[i] > k: distinct_elements.add(nums[i]) results.append(len(distinct_elements)) return results"},{"question":"def count_digit_occurrences(n: int, d: int) -> int: Returns the number of times digit d appears in the decimal representation of n. >>> count_digit_occurrences(12034, 2) 1 >>> count_digit_occurrences(99999, 9) 5 >>> count_digit_occurrences(0, 0) 1 >>> count_digit_occurrences(123456789, 6) 1","solution":"def count_digit_occurrences(n, d): Returns the number of times digit d appears in the decimal representation of n. return str(n).count(str(d))"},{"question":"def count_greater_elements(arr: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Given an array of integers and a list of queries, determine the number of elements in specified subarrays that are greater than a given threshold for each query. :param arr: List[int] - the array of integers :param queries: List[Tuple[int, int, int]] - list of queries, each query is a tuple (l, r, k) :return: List[int] - list of results for each query >>> count_greater_elements([1, 3, 5, 7, 9], [(1, 3, 4), (2, 5, 6), (1, 5, 8)]) [1, 2, 1] >>> count_greater_elements([2, 4, 6, 8, 10], [(1, 1, 1), (5, 5, 9), (3, 3, 5)]) [1, 1, 1] >>> count_greater_elements([10, 20, 30, 40, 50], [(1, 5, 5), (1, 5, 15), (1, 5, 25)]) [5, 4, 3] >>> count_greater_elements([1, 2, 3, 4, 5], [(1, 5, 10), (1, 3, 3)]) [0, 0] >>> count_greater_elements([1000000000, 2000000000, 3000000000], [(1, 3, 1500000000)]) [2]","solution":"def count_greater_elements(arr, queries): Given an array and a list of queries, returns the number of elements in specific subarrays that are greater than the given threshold for each query. :param arr: List[int] - the array of integers :param queries: List[Tuple[int, int, int]] - list of queries, where each query is a tuple (l, r, k) :return: List[int] - list of results for each query results = [] for l, r, k in queries: count = sum(1 for i in range(l - 1, r) if arr[i] > k) results.append(count) return results"},{"question":"def find_median(N: int, array: List[int]) -> int: Find the median of an array with odd length N. Parameters: N (int): Number of elements in the array, always odd array (list[int]): A list of N non-negative integers Returns: int: The median of the array Examples: >>> find_median(5, [1, 3, 3, 6, 7]) 3 >>> find_median(7, [10, 1, 5, 2, 9, 5, 3]) 5","solution":"def find_median(N, array): Find the median of an array with odd length N. Parameters: N (int): Number of elements in the array, always odd array (list[int]): A list of N non-negative integers Returns: int: The median of the array array.sort() return array[N // 2]"},{"question":"def three_sum(nums: List[int], target: int) -> bool: Determines if there are three integers in the list that add up to the target value. >>> three_sum([1, 2, 3, 4, 5], 9) True >>> three_sum([0, -1, 2, -3, 1], 0) True >>> three_sum([1, 2, 3], 10) False","solution":"def three_sum(nums, target): Determines if there are three integers in the list that add up to the target value. Parameters: nums (list): List of integers. target (int): The target integer. Returns: bool: True if there exist three numbers in the list whose sum is equal to the target, otherwise False. nums.sort() n = len(nums) for i in range(n-2): left, right = i+1, n-1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def manage_warehouse(products): This function accepts a list of products, each represented by its ID, weight, and expiration date, and outputs the following: 1. The heaviest product(s). 2. The product(s) that will expire the soonest. 3. The IDs of all products sorted by weight in descending order. 4. The IDs of all products sorted by expiration date in ascending order. Args: products (list): A list of tuples representing products, where each tuple contains: - product ID (str) - weight (str, representing a positive integer) - expiration date (str, in the format \\"YYYY-MM-DD\\") Returns: tuple: A tuple containing four elements: - A list of the ID(s) of the heaviest product(s). - A list of the ID(s) of the product(s) that will expire the soonest. - A list of the IDs of all products sorted by weight in descending order. - A list of the IDs of all products sorted by expiration date in ascending order. >>> manage_warehouse([(\\"P001\\", \\"2000\\", \\"2023-12-01\\"), (\\"P002\\", \\"1500\\", \\"2023-11-15\\"), (\\"P003\\", \\"2000\\", \\"2023-11-20\\"), (\\"P004\\", \\"1800\\", \\"2023-11-25\\"), (\\"P005\\", \\"1600\\", \\"2023-11-15\\")]) ([\\"P001\\", \\"P003\\"], [\\"P002\\", \\"P005\\"], [\\"P001\\", \\"P003\\", \\"P004\\", \\"P005\\", \\"P002\\"], [\\"P002\\", \\"P005\\", \\"P003\\", \\"P004\\", \\"P001\\"])","solution":"from datetime import datetime def manage_warehouse(products): This function accepts a list of products, each represented by its ID, weight, and expiration date, and outputs the following: 1. The heaviest product(s). 2. The product(s) that will expire the soonest. 3. The IDs of all products sorted by weight in descending order. 4. The IDs of all products sorted by expiration date in ascending order. heaviest_products = [] soonest_expiring_products = [] max_weight = -1 min_expiration_date = None for product in products: product_id, weight, expiration = product weight = int(weight) expiration_date = datetime.strptime(expiration, \\"%Y-%m-%d\\") if weight > max_weight: max_weight = weight heaviest_products = [product_id] elif weight == max_weight: heaviest_products.append(product_id) if min_expiration_date is None or expiration_date < min_expiration_date: min_expiration_date = expiration_date soonest_expiring_products = [product_id] elif expiration_date == min_expiration_date: soonest_expiring_products.append(product_id) sorted_by_weight = sorted(products, key=lambda x: int(x[1]), reverse=True) sorted_by_expiration = sorted(products, key=lambda x: datetime.strptime(x[2], \\"%Y-%m-%d\\")) sorted_by_weight_ids = [product[0] for product in sorted_by_weight] sorted_by_expiration_ids = [product[0] for product in sorted_by_expiration] return ( heaviest_products, soonest_expiring_products, sorted_by_weight_ids, sorted_by_expiration_ids )"},{"question":"def compare_elements(test_cases): Determine the relationship between every element A[i] in Alice's array and the corresponding element B[i] in Bob's array. Args: test_cases (List[Tuple[int, List[int], List[int], int, List[Tuple[int, int]]]]): A list of tuples where each tuple contains: - An integer N, the length of the arrays - A list of integers representing Alice's array A - A list of integers representing Bob's array B - An integer Q, the number of queries - A list of tuples where each tuple contains two integers i and j representing a query Returns: List[str]: A list of strings representing the results of the queries, where each element is \\"LESS\\", \\"EQUAL\\", or \\"GREATER\\". >>> compare_elements([(5, [3, 1, 5, 4, 2], [4, 5, 1, 3, 2], 3, [(1, 2), (3, 3), (5, 5)])]) ['LESS', 'GREATER', 'EQUAL'] >>> compare_elements([(3, [1, 2, 3], [4, 5, 6], 3, [(1, 1), (2, 2), (3, 3)])]) ['LESS', 'LESS', 'LESS'] >>> compare_elements([(3, [1, 2, 3], [1, 2, 3], 3, [(1, 1), (2, 2), (3, 3)])]) ['EQUAL', 'EQUAL', 'EQUAL'] >>> compare_elements([(3, [4, 5, 6], [1, 2, 3], 3, [(1, 1), (2, 2), (3, 3)])]) ['GREATER', 'GREATER', 'GREATER'] >>> compare_elements([(3, [3, 1, 4], [2, 4, 1], 3, [(1, 1), (2, 2), (3, 3)])]) ['GREATER', 'LESS', 'GREATER']","solution":"def compare_elements(test_cases): results = [] for case in test_cases: N, A, B, Q, queries = case for i, j in queries: if A[i-1] < B[j-1]: results.append(\\"LESS\\") elif A[i-1] == B[j-1]: results.append(\\"EQUAL\\") else: results.append(\\"GREATER\\") return results"},{"question":"def max_profit(arr1: List[int], arr2: List[int], arr3: List[int]) -> int: Returns the maximum profit from buying from arr1 and selling to arr3. >>> max_profit([4, 3, 1, 2], [7, 5, 8, 9, 2, 6], [10, 2, 15, 4, 8]) == 14 >>> max_profit([5, 6, 7], [8, 8], [1, 2, 3]) == 0","solution":"def max_profit(arr1, arr2, arr3): Returns the maximum profit from buying from arr1 and selling to arr3. min_buy = min(arr1) max_sell = max(arr3) profit = max_sell - min_buy return profit if profit > 0 else 0"},{"question":"def minimum_processing_time(W: int, P: int, T: List[int]) -> int: Calculate the minimum total processing time to assemble one widget. >>> minimum_processing_time(4, 3, [8, 5, 3]) 8 >>> minimum_processing_time(2, 4, [6, 2, 7, 4]) 7 >>> minimum_processing_time(5, 5, [1, 2, 3, 4, 5]) 5","solution":"def minimum_processing_time(W, P, T): Calculate the minimum total processing time to assemble one widget. :param W: int, number of workers :param P: int, number of parts in each widget :param T: list of int, processing times of each part :return: int, minimum total processing time T.sort() return T[-1]"},{"question":"def rpn_eval(expression: str) -> int: Evaluates the given reverse Polish notation (RPN) expression and returns the result as an integer. Args: expression (str): The RPN expression to evaluate. Returns: int: The result of the evaluation. >>> rpn_eval(\\"3 4 +\\") 7 >>> rpn_eval(\\"12 2 /\\") 6 >>> rpn_eval(\\"5 1 2 + 4 * + 3 -\\") 14","solution":"def rpn_eval(expression): Evaluates the given reverse Polish notation (RPN) expression and returns the result as an integer. stack = [] tokens = expression.split() for token in tokens: if token.isdigit(): stack.append(int(token)) else: b = stack.pop() a = stack.pop() if token == '+': result = a + b elif token == '-': result = a - b elif token == '*': result = a * b elif token == '/': result = int(a / b) # Explicit integer division stack.append(result) return stack[0]"},{"question":"def minimum_length_after_operations(M: int) -> int: Determine the minimum possible length of the string after M operations. >>> minimum_length_after_operations(5) 2 >>> minimum_length_after_operations(2) 0","solution":"def minimum_length_after_operations(M): Determine the minimum possible length of the string after M operations. # The minimum length of the string after M operations is always \`M % 2 * 2\`. # This is because every pair of operations (insertion and deletion) cancels out to zero length change. # If M is odd, there will be one insertion left, resulting in a length of 2. # If M is even, the length will be zero. return (M % 2) * 2"},{"question":"def unique_elements(lst): Given a list of integers, return a new list containing only the unique elements, but keep only the first occurrence of each element. >>> unique_elements([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> unique_elements([4, 5, 4, 6, 7, 5, 8, 9]) [4, 5, 6, 7, 8, 9] >>> unique_elements([10, 10, 10]) [10] >>> unique_elements([]) [] >>> unique_elements([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> unique_elements([1, 1, 1, 1, 1]) [1]","solution":"def unique_elements(lst): Given a list of integers, returns a new list containing only the unique elements, but keeps only the first occurrence of each element. seen = set() unique_lst = [] for num in lst: if num not in seen: seen.add(num) unique_lst.append(num) return unique_lst"},{"question":"def insertion_sort(arr: list[int]) -> list[int]: Sorts a list of integers in ascending order using the insertion sort algorithm. Args: arr: List of integers to be sorted. Returns: The same list, sorted in ascending order. Example: >>> insertion_sort([3, 7, 4, 9, 5, 2, 6, 1]) [1, 2, 3, 4, 5, 6, 7, 9] >>> insertion_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] # Your code goes here","solution":"def insertion_sort(arr: list[int]) -> list[int]: Sorts a list of integers in ascending order using the insertion sort algorithm. Args: arr: List of integers to be sorted. Returns: The same list, sorted in ascending order. # Traverse through 1 to len(arr) for i in range(1, len(arr)): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, to one position ahead # of their current position while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"def is_fibonacci(n: int) -> str: Returns \\"Yes\\" if n is a Fibonacci number, otherwise \\"No\\". >>> is_fibonacci(21) \\"Yes\\" >>> is_fibonacci(20) \\"No\\"","solution":"import math def is_fibonacci(n): Returns \\"Yes\\" if n is a Fibonacci number, otherwise \\"No\\". def is_perfect_square(x): s = int(math.sqrt(x)) return s * s == x if is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4): return \\"Yes\\" else: return \\"No\\""},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a simple mathematical expression given as a string. The expression consists of integers and the operators +, -, *, and /. Parentheses can be used to override standard precedence rules. >>> evaluate_expression(\\"3+5*2\\") 13 >>> evaluate_expression(\\"(2+3)*(5-2)\\") 15 >>> evaluate_expression(\\"20/(4+1)\\") 4 >>> evaluate_expression(\\"42\\") 42 >>> evaluate_expression(\\"1+1+1\\") 3 >>> evaluate_expression(\\"5-2-1\\") 2 >>> evaluate_expression(\\"2*3*4\\") 24 >>> evaluate_expression(\\"100/2/5\\") 10 >>> evaluate_expression(\\"2+3*4-5/5\\") 13 >>> evaluate_expression(\\"(2+3)*4-5/(1+4)\\") 19 >>> evaluate_expression(\\"((2+3)*2)/(2+3)\\") 2 # Implementation goes here","solution":"def evaluate_expression(expr): def evaluate(tokens): stack = [] num = 0 sign = '+' while tokens: token = tokens.pop(0) if token.isdigit(): num = num * 10 + int(token) if token == '(': num = evaluate(tokens) if (not token.isdigit() and token != ' ') or not tokens: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack[-1] *= num elif sign == '/': stack[-1] = int(stack[-1] / float(num)) sign = token num = 0 if token == ')': break return sum(stack) return evaluate(list(expr))"},{"question":"def longest_subarray_with_sum(nums, k): Returns the length of the longest subarray with sum equal to k. Args: nums (list of int): The array of integers. k (int): The target sum. Returns: int: The length of the longest subarray with sum equal to k. Examples: >>> longest_subarray_with_sum([1, -1, 5, -2, 3], 3) 4 >>> longest_subarray_with_sum([-2, -1, 2], 1) 2 pass # Unit Tests def test_example_cases(): assert longest_subarray_with_sum([1, -1, 5, -2, 3], 3) == 4 assert longest_subarray_with_sum([-2, -1, 2], 1) == 2 def test_no_such_subarray(): assert longest_subarray_with_sum([1, 2, 3], 7) == 0 assert longest_subarray_with_sum([], 0) == 0 def test_edge_cases(): assert longest_subarray_with_sum([0], 0) == 1 assert longest_subarray_with_sum([0, 0, 0], 0) == 3 def test_single_element_cases(): assert longest_subarray_with_sum([5], 5) == 1 assert longest_subarray_with_sum([5], 0) == 0 def test_negative_numbers(): assert longest_subarray_with_sum([-1, -1, -1, -1], -2) == 2 assert longest_subarray_with_sum([-2, -1, -5], -6) == 2","solution":"def longest_subarray_with_sum(nums, k): Returns the length of the longest subarray with sum equal to k. Args: nums (list of int): The array of integers. k (int): The target sum. Returns: int: The length of the longest subarray with sum equal to k. prefix_sum = 0 prefix_sums = {0: -1} max_length = 0 for i in range(len(nums)): prefix_sum += nums[i] if prefix_sum - k in prefix_sums: max_length = max(max_length, i - prefix_sums[prefix_sum - k]) if prefix_sum not in prefix_sums: prefix_sums[prefix_sum] = i return max_length"},{"question":"def substring_distinct_frequency(n: int, q: int, S: str, queries: List[Tuple[int, int, int]]) -> List[int]: Given a string 'S' of length n, process a series of queries to determine substring properties. Each query specifies a substring (through its start and end indices) and an integer k. For each query, count how many distinct characters in the given substring have a frequency exactly equal to k. If none exist, return 0. >>> substring_distinct_frequency(5, 2, \\"ababa\\", [(1, 3, 1), (2, 5, 2)]) [1, 2] >>> substring_distinct_frequency(6, 3, \\"aabbcc\\", [(1, 6, 2), (1, 4, 2), (3, 6, 2)]) [3, 2, 2]","solution":"def substring_distinct_frequency(n, q, S, queries): results = [] for l, r, k in queries: substring = S[l-1:r] freq = {} for char in substring: if char in freq: freq[char] += 1 else: freq[char] = 1 count = 0 for char in freq: if freq[char] == k: count += 1 results.append(count) return results # Example usage: n = 5 q = 2 S = \\"ababa\\" queries = [(1, 3, 1), (2, 5, 2)] print(substring_distinct_frequency(n, q, S, queries)) # Output: [1, 2]"},{"question":"from typing import List, Tuple def count_pairs(nums: List[int], target: int) -> int: Returns the number of distinct pairs (i, j) such that nums[i] + nums[j] = target. >>> count_pairs([1, 5, 7, -1], 6) 2 >>> count_pairs([1, 5, 7, -1], 10) 0 pass def solve(test_cases: List[Tuple[List[int], int]]) -> List[int]: Handle multiple test cases and return the results as a list. >>> solve([([1, 5, 7, -1], 6), ([1, 5, 7, -1], 10)]) [2, 0] pass","solution":"def count_pairs(nums, target): Returns the number of distinct pairs (i, j) such that nums[i] + nums[j] = target. num_counts = {} count = 0 for num in nums: complement = target - num if complement in num_counts: count += num_counts[complement] if num in num_counts: num_counts[num] += 1 else: num_counts[num] = 1 return count def solve(test_cases): Handle multiple test cases and return the results as a list. results = [] for nums, target in test_cases: results.append(count_pairs(nums, target)) return results"},{"question":"def sum_two_highest_numbers(numbers): Returns the sum of the two highest numbers in the array. :param numbers: List of integers :return: Sum of the two highest integers >>> sum_two_highest_numbers([1, 2, 3, 4, 5]) == 9 >>> sum_two_highest_numbers([10, 20, 30, 40, 50]) == 90 >>> sum_two_highest_numbers([99, 1, 1, 1, 1]) == 100 >>> sum_two_highest_numbers([5, 5, 5, 5]) == 10 >>> sum_two_highest_numbers([-10, -20, -30, -40, -5]) == -15 >>> sum_two_highest_numbers([-1, -2, -3, 0, 1, 2, 3]) == 5 >>> sum_two_highest_numbers([1, 2]) == 3 >>> sum_two_highest_numbers([-1, 1]) == 0 >>> sum_two_highest_numbers([1000000, 999999, 1, 0, -1]) == 1999999 >>> sum_two_highest_numbers([-1, -2, -3, -4, -5]) == -3 >>> sum_two_highest_numbers([2, 2, 2, 2, 2]) == 4","solution":"def sum_two_highest_numbers(numbers): Returns the sum of the two highest numbers in the array. :param numbers: List of integers :return: Sum of the two highest integers if len(numbers) < 2: raise ValueError(\\"The list must contain at least two integers.\\") highest = second_highest = float('-inf') for number in numbers: if number > highest: second_highest = highest highest = number elif number > second_highest: second_highest = number return highest + second_highest"},{"question":"def knapsack(N: int, W: int, cakes: List[Tuple[int, int]]) -> int: Determine the maximum price that can be achieved by selecting a combination of cakes such that their total weight does not exceed W. >>> knapsack(4, 10, [(5, 10), (4, 40), (6, 30), (3, 50)]) == 90 >>> knapsack(0, 10, []) == 0 >>> knapsack(2, 3, [(4, 50), (5, 60)]) == 0 >>> knapsack(1, 5, [(5, 100)]) == 100 >>> knapsack(5, 10, [(5, 10), (5, 10), (5, 10), (5, 10), (5, 10)]) == 20 >>> knapsack(3, 100, [(10, 20), (30, 40), (40, 50)]) == 110 >>> knapsack(3, 6, [(1, 10), (2, 20), (3, 30)]) == 60 # Create a 2D DP array to store maximum price for given weight dp = [[0 for _ in range(W + 1)] for _ in range(N + 1)] for i in range(1, N + 1): weight, price = cakes[i - 1] for w in range(1, W + 1): if weight > w: dp[i][w] = dp[i - 1][w] else: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + price) return dp[N][W] if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) W = int(data[1]) cakes = [(int(data[i * 2 + 2]), int(data[i * 2 + 3])) for i in range(N)] result = knapsack(N, W, cakes) print(result)","solution":"def knapsack(N, W, cakes): # Create a 2D DP array to store maximum price for given weight dp = [[0 for _ in range(W + 1)] for _ in range(N + 1)] for i in range(1, N + 1): weight, price = cakes[i - 1] for w in range(1, W + 1): if weight > w: dp[i][w] = dp[i - 1][w] else: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + price) return dp[N][W] if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) W = int(data[1]) cakes = [(int(data[i * 2 + 2]), int(data[i * 2 + 3])) for i in range(N)] result = knapsack(N, W, cakes) print(result)"},{"question":"def guess_number(): Guess the hidden number efficiently by making use of the hints provided by the system. The function interacts with the system to find a hidden number N (1 ≤ N ≤ 10^9). You are allowed to make up to 20 attempts to guess the number. Each guess is followed by the system's response: \\"TOO HIGH\\", \\"TOO LOW\\", or \\"CORRECT\\". The function should terminate immediately after receiving the \\"CORRECT\\" response or after 20 attempts. pass import pytest from unittest.mock import patch @patch('builtins.input', side_effect=[\\"TOO HIGH\\"] * 20) @patch('builtins.print') def test_upper_bound(mock_print, mock_input): guess_number() assert mock_print.call_count == 20 @patch('builtins.input', side_effect=[\\"TOO LOW\\"] * 19 + [\\"CORRECT\\"]) @patch('builtins.print') def test_lower_bound_exit_early(mock_print, mock_input): guess_number() assert mock_print.call_count == 20 @patch('builtins.input', side_effect=[\\"TOO HIGH\\", \\"TOO LOW\\", \\"CORRECT\\"]) @patch('builtins.print') def test_middle_guess_correct(mock_print, mock_input): guess_number() assert mock_print.call_count == 3 @patch('builtins.input', side_effect=[\\"CORRECT\\"]) @patch('builtins.print') def test_first_guess_correct(mock_print, mock_input): guess_number() assert mock_print.call_count == 1","solution":"def guess_number(): import sys low, high = 1, 10**9 attempts = 0 while attempts < 20: guess = (low + high) // 2 print(guess) sys.stdout.flush() response = input().strip() if response == \\"CORRECT\\": return elif response == \\"TOO HIGH\\": high = guess - 1 elif response == \\"TOO LOW\\": low = guess + 1 attempts += 1"},{"question":"def find_task_order(n: int, m: int, dependencies: List[Tuple[int, int]]) -> List[int]: Determines the order of tasks to be completed given dependencies. If it is not possible to complete all tasks, return an empty list. Args: n (int): number of tasks m (int): number of dependencies dependencies (List[Tuple[int, int]]): list of (a, b) tuples representing task a depends on task b Returns: List[int]: list of integers representing the order to complete tasks, or an empty list if not possible. Examples: >>> find_task_order(4, 3, [(2, 1), (3, 1), (4, 2)]) [1, 2, 3, 4] >>> find_task_order(4, 4, [(2, 1), (3, 1), (4, 2), (2, 4)]) [] >>> find_task_order(3, 0, []) [1, 2, 3]","solution":"from collections import defaultdict, deque def find_task_order(n, m, dependencies): Determines the order of tasks to be completed given dependencies. :param n: number of tasks :param m: number of dependencies :param dependencies: list of (a, b) tuples representing task a depends on task b :return: list of task completion order or empty list if not possible # Initialize the adjacency list and in-degree list adj_list = defaultdict(list) in_degree = [0] * (n + 1) # Build the graph for a, b in dependencies: adj_list[b].append(a) in_degree[a] += 1 # Initialize queue with tasks that have no dependencies queue = deque([i for i in range(1, n + 1) if in_degree[i] == 0]) task_order = [] while queue: current_task = queue.popleft() task_order.append(current_task) for dependent in adj_list[current_task]: in_degree[dependent] -= 1 if in_degree[dependent] == 0: queue.append(dependent) return task_order if len(task_order) == n else []"},{"question":"from collections import deque def reverseKElements(Q, K): Reverses the first K elements of the queue Q. Arguments: Q -- list, the queue of integers K -- int, the number of elements to reverse from the front of the queue Returns: list -- the queue after the first K elements have been reversed pass # Unit Tests def test_reverseKElements_case1(): Q = [10, 20, 30, 40, 50] K = 3 assert reverseKElements(Q, K) == [30, 20, 10, 40, 50] def test_reverseKElements_case2(): Q = [1, 2, 3, 4, 5, 6] K = 4 assert reverseKElements(Q, K) == [4, 3, 2, 1, 5, 6] def test_reverseKElements_all_elements(): Q = [5, 10, 15, 20] K = 4 assert reverseKElements(Q, K) == [20, 15, 10, 5] def test_reverseKElements_single_element(): Q = [100] K = 1 assert reverseKElements(Q, K) == [100] def test_reverseKElements_large_K(): Q = [i for i in range(1, 1002)] K = 1000 expected = [i for i in range(1000, 0, -1)] + [1001] assert reverseKElements(Q, K) == expected","solution":"from collections import deque def reverseKElements(Q, K): Reverses the first K elements of the queue Q. Arguments: Q -- list, the queue of integers K -- int, the number of elements to reverse from the front of the queue Returns: list -- the queue after the first K elements have been reversed # Convert the list Q to a deque for efficient removal from the front queue = deque(Q) # Take out the first K elements and reverse them stack = [] for _ in range(K): stack.append(queue.popleft()) stack.reverse() # Add the reversed elements back into the queue queue.extendleft(stack[::-1]) # Convert the deque back to a list and return it return list(queue)"},{"question":"from typing import List def find_peak_element(A: List[int]) -> int: Given an array of n integers, A, find a peak element. An array element at index i is considered a peak if: - A[i] > A[i-1], for 1 ≤ i ≤ n-2 - A[i] > A[i+1], for 1 ≤ i ≤ n-2 The first and last element of the array can also be considered peaks if they are greater than their single neighbor: - A[0] if A[0] > A[1] - A[n-1] if A[n-1] > A[n-2] If the array contains multiple peaks, return the index of any one of the peak elements. You may assume that the array contains at least one peak element. Args: A (List[int]): The input array of length n (1 ≤ n ≤ 1000 and all elements are unique) Returns: int: The index of one of the peak elements Examples: >>> find_peak_element([1, 2, 3, 4, 5, 6, 4]) 5 >>> find_peak_element([5, 10, 9, 8, 7, 6, 2, 11]) 1 >>> find_peak_element([1]) 0 def test_single_element(): assert find_peak_element([1]) == 0 def test_multiple_peaks(): A = [1, 2, 3, 4, 5, 6, 4] result = find_peak_element(A) assert result in [5] # Only the index 5 is a valid peak. def test_peak_at_start(): A = [10, 5, 2] assert find_peak_element(A) == 0 def test_peak_at_end(): A = [1, 2, 3, 4, 5] assert find_peak_element(A) == 4 def test_with_peak_in_middle(): A = [5, 10, 9, 8, 7, 6, 2, 11] result = find_peak_element(A) assert result in [1, 7] # Valid peaks are at index 1 and 7. def test_large_array(): A = list(range(1, 501)) + list(range(499, 0, -1)) assert find_peak_element(A) == 499 # The peak is in the middle at maximum value # Running the test using pytest framework if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"from typing import List def find_peak_element(A: List[int]) -> int: n = len(A) if n == 1: return 0 if A[0] > A[1]: return 0 if A[n-1] > A[n-2]: return n-1 left, right = 1, n - 2 while left <= right: mid = (left + right) // 2 if A[mid] > A[mid - 1] and A[mid] > A[mid + 1]: return mid elif A[mid - 1] > A[mid]: right = mid - 1 else: left = mid + 1 return -1 # This return statement will never be reached if input constraints are followed."},{"question":"def find_repeating_elements(arr): Given an integer array \`arr\`, find all the elements in the array that appear more than once. Return the result as an array of these repeating elements in ascending order. >>> find_repeating_elements([4, 3, 2, 7, 8, 2, 3, 1]) [2, 3] >>> find_repeating_elements([1, 2, 3, 4, 5]) []","solution":"def find_repeating_elements(arr): Returns a list of elements that appear more than once in the array \`arr\` in ascending order. from collections import Counter counter = Counter(arr) repeating_elements = [num for num, count in counter.items() if count > 1] return sorted(repeating_elements) # Example usage example_array = [4, 3, 2, 7, 8, 2, 3, 1] print(find_repeating_elements(example_array)) # Output: [2, 3]"},{"question":"from typing import List def manage_fleet_operations(n: int, q: int, battery_levels: List[int], operations: List[List[int]]) -> List[int]: Manage a fleet of drones by performing operations to monitor and manage battery levels. Args: n (int): Number of drones. q (int): Number of operations. battery_levels (List[int]): Initial battery levels of the drones. operations (List[List[int]]): List of operations. Returns: List[int]: List of average battery levels after type 2 operations rounded down to the nearest integer. Example: >>> n = 5 >>> q = 3 >>> battery_levels = [50, 60, 70, 80, 90] >>> operations = [[1, 1, 3, 10], [2, 1, 5], [2, 2, 4]] >>> manage_fleet_operations(n, q, battery_levels, operations) [76, 66] >>> n = 3 >>> q = 1 >>> battery_levels = [0, 0, 0] >>> operations = [[2, 1, 3]] >>> manage_fleet_operations(n, q, battery_levels, operations) [0]","solution":"def manage_fleet_operations(n, q, battery_levels, operations): def add_value_to_range(batteries, l, r, v): for i in range(l-1, r): batteries[i] = min(100, max(0, batteries[i] + v)) def average_battery_in_range(batteries, l, r): total = sum(batteries[l-1:r]) return total // (r - l + 1) results = [] for op in operations: if op[0] == 1: _, l, r, v = op add_value_to_range(battery_levels, l, r, v) elif op[0] == 2: _, l, r = op avg = average_battery_in_range(battery_levels, l, r) results.append(avg) return results"},{"question":"def is_palindrome(n): Helper function to check if a number is a palindrome. >>> is_palindrome(131) True >>> is_palindrome(123) False >>> is_palindrome(1) True >>> is_palindrome(22) True >>> is_palindrome(10) False pass def is_prime(n): Helper function to check if a number is a prime number. >>> is_prime(2) True >>> is_prime(131) True >>> is_prime(37) True >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(4) False pass def isPalprime(N): Function to check if the given number N is both a palindrome and a prime number. Returns 1 if it is a Palprime, otherwise returns 0. >>> isPalprime(131) 1 >>> isPalprime(37) 0 >>> isPalprime(10301) 1 >>> isPalprime(101) 1 >>> isPalprime(10) 0 pass","solution":"def is_palindrome(n): Helper function to check if a number is a palindrome. return str(n) == str(n)[::-1] def is_prime(n): Helper function to check if a number is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def isPalprime(N): Function to check if the given number N is both a palindrome and a prime number. Returns 1 if it is a Palprime, otherwise returns 0. if is_palindrome(N) and is_prime(N): return 1 return 0"},{"question":"def rearrange_unique_differences(n: int, arr: List[int]) -> str: Given an array of integers consisting of n positive numbers, rearrange the elements of the array such that the difference between every two consecutive elements is unique. If there are multiple valid rearrangements, return any of them. >>> rearrange_unique_differences(5, [4, 1, 3, 7, 2]) \\"2 1 3 4 7\\" >>> rearrange_unique_differences(3, [1, 1, 1]) \\"NO\\"","solution":"def rearrange_unique_differences(n, arr): arr.sort() for i in range(n-1): if arr[i] == arr[i+1]: return \\"NO\\" return \\" \\".join(map(str, arr))"},{"question":"def robot_cleaner(commands: List[str]) -> List[List[str]]: Simulates the movements of a simple robot cleaner on a 5x5 grid. The robot starts at position (0, 0), which is the top-left corner of the grid, and follows a series of commands to move around the grid. The valid commands are \\"N\\" for moving north (up), \\"S\\" for moving south (down), \\"E\\" for moving east (right), and \\"W\\" for moving west (left). The robot cannot move beyond the boundaries of the grid. If a command takes the robot outside the grid, the robot will ignore that command and stay at its current position. The function should return a 2D list representing the final state of the grid, with the robot's final position marked by an \\"R\\" and all other positions by \\".\\". >>> robot_cleaner([\\"N\\", \\"E\\", \\"E\\", \\"S\\", \\"S\\", \\"S\\", \\"W\\", \\"N\\"]) [ [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\"R\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"] ] >>> robot_cleaner([\\"E\\", \\"E\\", \\"E\\", \\"E\\", \\"E\\"]) [ [\\".\\", \\".\\", \\".\\", \\".\\", \\"R\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"] ] >>> robot_cleaner([\\"S\\", \\"S\\", \\"S\\", \\"S\\", \\"S\\", \\"S\\"]) [ [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\"R\\", \\".\\", \\".\\", \\".\\", \\".\\"] ]","solution":"def robot_cleaner(commands): # Initial grid of 5x5 grid = [[\\".\\"] * 5 for _ in range(5)] # Initial position x, y = 0, 0 # Move robot based on the commands for command in commands: if command == \\"N\\" and x > 0: x -= 1 elif command == \\"S\\" and x < 4: x += 1 elif command == \\"E\\" and y < 4: y += 1 elif command == \\"W\\" and y > 0: y -= 1 # Mark the final position grid[x][y] = \\"R\\" return grid"},{"question":"def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotate the given n x n matrix 90 degrees clockwise in place. >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) [ [3, 1], [4, 2] ]","solution":"def rotate_matrix(matrix): Rotates the given n x n matrix 90 degrees clockwise in place. n = len(matrix) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] for i in range(n): matrix[i].reverse() return matrix"},{"question":"from typing import List def max_anagram_group(n: int, strings: List[str]) -> int: Find the maximum number of anagrams that can be formed from the given list of strings. >>> max_anagram_group(6, [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"elgoog\\", \\"notanagram\\"]) 3 >>> max_anagram_group(1, [\\"abcd\\"]) 1 >>> max_anagram_group(3, [\\"abcd\\", \\"efgh\\", \\"ijkl\\"]) 1 >>> max_anagram_group(3, [\\"abc\\", \\"bca\\", \\"cab\\"]) 3 >>> max_anagram_group(5, [\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"zyx\\"]) 3 >>> max_anagram_group(4, [\\"a\\"*100000, \\"a\\"*100000, \\"b\\"*100000, \\"c\\"*100000]) 2","solution":"from collections import defaultdict def max_anagram_group(n, strings): anagram_map = defaultdict(int) for s in strings: sorted_tuple = tuple(sorted(s)) anagram_map[sorted_tuple] += 1 # Finding the maximum size among all groups of anagrams max_group_size = max(anagram_map.values()) return max_group_size"},{"question":"def maxWorkshops(workshops: List[int], min_participants: int) -> int: Returns the maximum number of workshops that can be held based on the minimum required participants. >>> maxWorkshops([30, 70, 45, 20, 50], 40) -> 3 >>> maxWorkshops([25, 35, 10, 55, 60, 15], 50) -> 2 >>> maxWorkshops([10, 20, 5, 15, 25], 30) -> 0 >>> maxWorkshops([50, 50, 50, 50], 50) -> 4 >>> maxWorkshops([], 50) -> 0 >>> maxWorkshops([10, 20, 30, 40, 50], 25) -> 3 >>> maxWorkshops([60, 70, 80, 90, 100], 65) -> 4","solution":"def maxWorkshops(workshops, min_participants): Returns the maximum number of workshops that can be held based on the minimum required participants. count = sum(1 for participants in workshops if participants >= min_participants) return count # Example usage: Uncomment below line to test # print(maxWorkshops([30, 70, 45, 20, 50], 40)) # Output should be 3"},{"question":"def longest_non_decreasing_subsequence(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the length of the longest non-decreasing subsequence you can obtain under the given constraint for each test case. >>> test_case_1() >>> test_case_2() >>> test_case_3() >>> test_case_4() >>> test_case_5() def can_be_removed(a: int, b: int, k: int) -> bool: Helper function to check if an element can be removed under the constraint.","solution":"def longest_non_decreasing_subsequence(t, test_cases): def can_be_removed(a, b, k): return abs(a - b) <= k results = [] for n, k, a in test_cases: longest_sequence = [] for num in a: if not longest_sequence or longest_sequence[-1] <= num: longest_sequence.append(num) else: if not longest_sequence or can_be_removed(longest_sequence[-1], num, k): continue # skip the element else: longest_sequence = [num] # reset the sequence if we need to skip any element and that element can't be appended based on current constraints results.append(len(longest_sequence)) return results"},{"question":"from typing import List class MagicSquare: Class to work with magic squares. A magic square is a 2D list where the sum of elements in each row, each column, and both main diagonals are the same. def is_magic(self, matrix: List[List[int]]) -> bool: Check if the given matrix is a magic square. >>> matrix1 = [ [2, 7, 6], [9, 5, 1], [4, 3, 8] ] >>> MagicSquare().is_magic(matrix1) True >>> matrix2 = [ [2, 7, 6], [9, 5, 2], [4, 3, 8] ] >>> MagicSquare().is_magic(matrix2) False >>> matrix3 = [] >>> MagicSquare().is_magic(matrix3) False pass def generate(self, n: int) -> List[List[int]]: Generate an n x n magic square if n is odd. If n is even or less than 1, return an empty list. >>> MagicSquare().generate(3) [[8, 1, 6], [3, 5, 7], [4, 9, 2]] >>> MagicSquare().generate(4) [] >>> MagicSquare().generate(0) [] pass","solution":"class MagicSquare: def is_magic(self, matrix): n = len(matrix) if n == 0: return False sum_diagonal1 = sum(matrix[i][i] for i in range(n)) sum_diagonal2 = sum(matrix[i][n - 1 - i] for i in range(n)) if sum_diagonal1 != sum_diagonal2: return False target_sum = sum_diagonal1 for row in matrix: if sum(row) != target_sum: return False for col in range(n): if sum(matrix[row][col] for row in range(n)) != target_sum: return False return True def generate(self, n): if n < 1 or n % 2 == 0: return [] magic_square = [[0] * n for _ in range(n)] num = 1 i, j = 0, n // 2 while num <= n * n: magic_square[i][j] = num num += 1 next_i, next_j = (i - 1) % n, (j + 1) % n if magic_square[next_i][next_j]: i += 1 else: i, j = next_i, next_j return magic_square"},{"question":"def find_and_remove_longest_road(n: int, m: int, roads: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]: Removes one of the longest roads while keeping all cities connected. :param n: Number of cities :param m: Number of roads :param roads: List of tuples representing the roads (u, v, w) :return: List of remaining roads >>> find_and_remove_longest_road(5, 7, [(1, 2, 5), (1, 3, 10), (2, 3, 12), (2, 4, 15), (3, 4, 7), (4, 5, 6), (5, 1, 14)]) [(1, 2, 5), (1, 3, 10), (2, 3, 12), (3, 4, 7), (4, 5, 6), (5, 1, 14)] >>> find_and_remove_longest_road(3, 3, [(1, 2, 5), (2, 3, 5), (1, 3, 5)]) [(1, 2, 5), (1, 3, 5)]","solution":"def find_and_remove_longest_road(n, m, roads): Removes one of the longest roads while keeping all cities connected. :param n: Number of cities :param m: Number of roads :param roads: List of tuples representing the roads (u, v, w) :return: List of remaining roads # Step 1: Find the longest road longest_road = max(roads, key=lambda x: x[2]) # Step 2: Remove the longest road roads.remove(longest_road) return roads"},{"question":"def count_connected_components(n: int, roads: List[Tuple[int, int]]) -> List[int]: Calculate the number of connected components after each new road is built in a city represented as a graph. :param n: The number of intersections in the city. :param roads: A list of roads, where each road is a tuple of two integers representing the intersections it connects. :return: A list of integers representing the number of connected components after each road construction. Examples: >>> count_connected_components(5, [(1, 2), (3, 4), (2, 4)]) [4, 3, 2] >>> count_connected_components(2, [(1, 2)]) [1]","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def count_connected_components(n, roads): parent = [] rank = [] for i in range(n): parent.append(i) rank.append(0) components = n result = [] for road in roads: x, y = road if find(parent, x - 1) != find(parent, y - 1): union(parent, rank, x - 1, y - 1) components -= 1 result.append(components) return result"},{"question":"def find_largest_rectangle_area(grid: List[List[int]]) -> int: You are given a grid of size N x M, filled with numbers 0 or 1. Your task is to find the largest rectangle containing only 1's in the grid and return its area. >>> find_largest_rectangle_area([[1, 1, 0, 1], [1, 1, 1, 1], [1, 1, 1, 0], [0, 1, 0, 0]]) 6 >>> find_largest_rectangle_area([[0, 1, 0], [1, 1, 1], [0, 1, 0]]) 3 >>> find_largest_rectangle_area([[1, 1, 1, 1, 1]]) 5 >>> find_largest_rectangle_area([[1], [1], [1], [1], [1]]) 5 >>> find_largest_rectangle_area([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) 0 >>> find_largest_rectangle_area([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 9","solution":"def maximalRectangle(matrix): if not matrix: return 0 n, m = len(matrix), len(matrix[0]) max_area = 0 heights = [0] * (m + 1) for row in range(n): for col in range(m): if matrix[row][col] == 1: heights[col] += 1 else: heights[col] = 0 stack = [-1] for i in range(m + 1): while heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area def find_largest_rectangle_area(input_list): N, M = input_list[0], input_list[1] matrix = input_list[2:] return maximalRectangle(matrix)"},{"question":"def is_palindrome(word): Determines if the given word is a palindrome. Args: word (str): The word to check. Returns: str: \\"YES\\" if the word is a palindrome, \\"NO\\" otherwise. >>> is_palindrome(\\"radar\\") \\"YES\\" >>> is_palindrome(\\"hello\\") \\"NO\\" >>> is_palindrome(\\"a\\") \\"YES\\" >>> is_palindrome(\\"abba\\") \\"YES\\" >>> is_palindrome(\\"abcdefg\\") \\"NO\\" >>> is_palindrome(\\"deified\\") \\"YES\\" >>> is_palindrome(\\"\\") \\"YES\\"","solution":"def is_palindrome(word): Determines if the given word is a palindrome. Args: word (str): The word to check. Returns: str: \\"YES\\" if the word is a palindrome, \\"NO\\" otherwise. if word == word[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"def strictly_increasing_sequences(n): Prints all unique strictly increasing sequences of length n consisting of digits from 0 to 9. Constraints: * 1 <= n <= 9 >>> strictly_increasing_sequences(2) 0 1 0 2 0 3 ... 8 9 >>> strictly_increasing_sequences(1) 0 1 2 ... 9 >>> strictly_increasing_sequences(3) 0 1 2 0 1 3 0 1 4 ... 7 8 9 from itertools import combinations","solution":"from itertools import combinations def strictly_increasing_sequences(n): Prints all unique strictly increasing sequences of length n consisting of digits from 0 to 9. all_sequences = list(combinations(range(10), n)) for sequence in all_sequences: print(\\" \\".join(map(str, sequence))) # Example usage: # strictly_increasing_sequences(3)"},{"question":"def min_coins(cost: int) -> int: Calculate the minimum number of coins needed to make the exact payment. Parameters: cost (int): The cost in cents. Returns: int: The minimum number of coins needed or -1 if the payment is impossible. Examples: >>> min_coins(31) 3 >>> min_coins(3) 3 >>> min_coins(52) -1","solution":"def min_coins(cost): Calculate the minimum number of coins needed to make the exact payment. Parameters: cost (int): The cost in cents. Returns: int: The minimum number of coins needed or -1 if the payment is impossible. if cost < 0: return -1 coins = [25, 10, 5, 1] count = 0 for coin in coins: count += cost // coin cost %= coin return count if cost == 0 else -1"},{"question":"def smallest_palindrome(k: int) -> str: Form the lexicographically smallest palindrome of exactly \`k\` characters. >>> smallest_palindrome(1) 'a' >>> smallest_palindrome(2) 'aa' >>> smallest_palindrome(3) 'aba' def solve(t: int, ks: List[int]) -> List[str]: For multiple test cases, return the list of smallest palindromes for each \`k\`. >>> solve(3, [1, 2, 3]) ['a', 'aa', 'aba'] >>> solve(5, [1, 2, 3, 4, 5]) ['a', 'aa', 'aba', 'aaaa', 'aabaa'] >>> solve(2, [6, 7]) ['aaaaaa', 'aaabaaa']","solution":"def smallest_palindrome(k): if k == 1: return \\"a\\" if k % 2 == 0: return \\"a\\" * k else: half = k // 2 return \\"a\\" * half + \\"b\\" + \\"a\\" * half def solve(t, ks): results = [] for k in ks: results.append(smallest_palindrome(k)) return results"},{"question":"def height_differences(heights: List[int], k: int) -> List[int]: Given an orchestra of musicians standing in line, each musician has a certain height. The orchestra conductor wants to identify the height difference between the tallest and shortest musician in any subarray of musicians spanning a specified length. Your task is to help the conductor determine this height difference. Params: - heights (list of int): Heights of the musicians. - k (int): Length of subarray. Returns: - list of int: Height differences for each subarray of length k. Examples: >>> height_differences([1, 3, 6, 4, 10, 3, 8], 3) [5, 3, 6, 7, 7] >>> height_differences([10, 20, 30], 1) [0, 0, 0] >>> height_differences([5, 5, 5, 5], 2) [0, 0, 0] >>> height_differences([3, 6, 4, 12, 5, 7, 9], 4) [9, 8, 8, 7] >>> height_differences([8, 4, 6, 12], 4) [8]","solution":"def height_differences(heights, k): Returns the height differences between the tallest and shortest musicians in subarrays of length k. Params: - heights (list of int): Heights of the musicians. - k (int): Length of subarray. Returns: - list of int: Height differences for each subarray of length k. result = [] for i in range(len(heights) - k + 1): subarray = heights[i:i + k] height_difference = max(subarray) - min(subarray) result.append(height_difference) return result"},{"question":"from typing import List, Tuple def top_rated_books(N: int, user_data: List[Tuple[int, List[Tuple[str, int]]]]) -> List[str]: You are managing an online bookstore system where users can rate the books they have read. Your task is to implement a system that processes multiple users' ratings for different books and determines the top-rated book for each user. Each user's top-rated book is the one with the highest rating. If there are multiple top-rated books with the same highest rating, select the one that appears first in the input list. Args: - N: int - The number of users. - user_data: List[Tuple[int, List[Tuple[str, int]]]] - A list of tuples where each tuple contains an integer representing the number of books and a list of tuples. Each tuple in the list represents a book title and its rating. Returns: - List[str]: A list of top-rated book titles for each user. Example: >>> top_rated_books(1, [(3, [(\\"The_Great_Gatsby\\", 5), (\\"Moby_Dick\\", 4), (\\"War_and_Peace\\", 5)])]) ['The_Great_Gatsby'] >>> top_rated_books(2, [(3, [(\\"The_Catcher_in_the_Rye\\", 3), (\\"Fahrenheit_451\\", 3), (\\"Brave_New_World\\", 4)]), (2, [(\\"Pride_and_Prejudice\\", 4), (\\"To_Kill_a_Mockingbird\\", 5)])]) ['Brave_New_World', 'To_Kill_a_Mockingbird'] pass # Unit Tests def test_top_rated_books(): input_data = 3 3 The_Great_Gatsby 5 Moby_Dick 4 War_and_Peace 5 2 Pride_and_Prejudice 4 To_Kill_a_Mockingbird 5 4 1984 3 The_Catcher_in_the_Rye 3 Fahrenheit_451 4 Brave_New_World 4 expected_output = ['The_Great_Gatsby', 'To_Kill_a_Mockingbird', 'Fahrenheit_451'] assert main(input_data) == expected_output def test_single_user_single_book(): input_data = 1 1 Single_Book 5 expected_output = ['Single_Book'] assert main(input_data) == expected_output def test_single_user_multiple_books(): input_data = 1 3 First_Book 3 Second_Book 4 Third_Book 5 expected_output = ['Third_Book'] assert main(input_data) == expected_output def test_multiple_users_single_book_each(): input_data = 2 1 User1_Book 3 1 User2_Book 5 expected_output = ['User1_Book', 'User2_Book'] assert main(input_data) == expected_output def test_tie_ratings(): input_data = 1 2 Book1 4 Book2 4 expected_output = ['Book1'] assert main(input_data) == expected_output def test_different_users_mixed_ratings(): input_data = 2 3 User1_Book1 3 User1_Book2 4 User1_Book3 5 3 User2_Book1 5 User2_Book2 4 User2_Book3 5 expected_output = ['User1_Book3', 'User2_Book1'] assert main(input_data) == expected_output","solution":"def top_rated_books(N, user_data): top_books = [] for user in user_data: B, books = user best_book = books[0][0] best_rating = books[0][1] for title, rating in books[1:]: if rating > best_rating: best_book = title best_rating = rating elif rating == best_rating: continue top_books.append(best_book) return top_books # Convert input to the required format def read_user_data(input_data): lines = input_data.strip().split('n') N = int(lines[0]) index = 1 user_data = [] for _ in range(N): B = int(lines[index]) books = [] for i in range(index + 1, index + B + 1): parts = lines[i].rsplit(' ', 1) book_title = parts[0] rating = int(parts[1]) books.append((book_title, rating)) user_data.append((B, books)) index += B + 1 return N, user_data # Main function to execute the process def main(input_data): N, user_data = read_user_data(input_data) return top_rated_books(N, user_data)"},{"question":"def find_min_edges_to_connect_graph(n, m, edges): Given an undirected graph with \`n\` nodes and \`m\` edges, determine the minimum number of edges that need to be added to make the graph fully connected. Parameters: n (int): Number of nodes. m (int): Number of edges. edges (List[Tuple[int, int]]): List of edges represented as tuples (u, v). Returns: int: Minimum number of edges to be added to make the graph fully connected. >>> find_min_edges_to_connect_graph(5, 3, [(1, 2), (2, 3), (4, 5)]) 1 >>> find_min_edges_to_connect_graph(4, 0, []) 3 >>> find_min_edges_to_connect_graph(3, 3, [(1, 2), (2, 3), (1, 3)]) 0 def process_test_cases(test_cases): Function to process multiple test cases. Parameters: test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): List of test cases. Returns: List[int]: List of results for each test case. >>> process_test_cases([(5, 3, [(1, 2), (2, 3), (4, 5)]), (4, 0, []), (3, 3, [(1, 2), (2, 3), (1, 3)])]) [1, 3, 0] def test_find_min_edges_to_connect_graph(): assert find_min_edges_to_connect_graph(5, 3, [(1, 2), (2, 3), (4, 5)]) == 1 assert find_min_edges_to_connect_graph(4, 0, []) == 3 assert find_min_edges_to_connect_graph(3, 3, [(1, 2), (2, 3), (1, 3)]) == 0 def test_process_test_cases(): test_cases = [ (5, 3, [(1, 2), (2, 3), (4, 5)]), (4, 0, []), (3, 3, [(1, 2), (2, 3), (1, 3)]), ] expected_output = [1, 3, 0] assert process_test_cases(test_cases) == expected_output def test_custom_cases(): assert find_min_edges_to_connect_graph(5, 0, []) == 4 assert find_min_edges_to_connect_graph(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 0 assert find_min_edges_to_connect_graph(7, 5, [(1, 2), (2, 3), (4, 5), (6, 7), (3, 6)]) == 1","solution":"def find_min_edges_to_connect_graph(n, m, edges): Function to find the minimum number of edges to add to make the graph fully connected. from collections import defaultdict, deque def bfs(node, visited, adj_list): Perform BFS to mark all reachable nodes from the given node. queue = deque([node]) while queue: current = queue.popleft() for neighbor in adj_list[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # Build the adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Find connected components using BFS visited = [False] * (n + 1) num_components = 0 for node in range(1, n + 1): if not visited[node]: bfs(node, visited, adj_list) num_components += 1 # To connect all components, we need (num_components - 1) edges return num_components - 1 def process_test_cases(test_cases): Function to process multiple test cases. results = [] for t in test_cases: n, m, edges = t results.append(find_min_edges_to_connect_graph(n, m, edges)) return results # This part can be commented out if you only need the function and tests. # Example usage: # test_cases = [(5, 3, [(1, 2), (2, 3), (4, 5)]), (4, 0, []), (3, 3, [(1, 2), (2, 3), (1, 3)])] # print(process_test_cases(test_cases))"},{"question":"def product_of_positives(numbers: List[int]) -> int: Write a function that accepts a list of integers and returns the product of all positive integers in the list. If there are no positive integers, return 1. >>> product_of_positives([-1, 2, -3, 4]) 8 >>> product_of_positives([-1, -2, -3]) 1 >>> product_of_positives([0, 0, 0]) 1 >>> product_of_positives([0, 3, 0, 2]) 6 >>> product_of_positives([-1, 5, -3]) 5 >>> product_of_positives([1, 2, 3, 4]) 24 >>> product_of_positives([]) 1","solution":"def product_of_positives(numbers): Returns the product of all positive integers in the list. If there are no positive integers, returns 1. product = 1 has_positive = False for num in numbers: if num > 0: product *= num has_positive = True if not has_positive: return 1 return product"},{"question":"def min_operations_to_sort(n: int, arr: List[int]) -> int: Determine the minimum number of operations to sort the list in non-decreasing order. Each operation consists of picking any subarray and reversing it. >>> min_operations_to_sort(4, [3, 1, 4, 2]) 2 >>> min_operations_to_sort(4, [1, 2, 3, 4]) 0 >>> min_operations_to_sort(5, [5, 4, 3, 2, 1]) 4 >>> min_operations_to_sort(1, [10]) 0 >>> min_operations_to_sort(2, [2, 1]) 1 >>> min_operations_to_sort(6, [1, 3, 5, 4, 7, 6]) 2 >>> min_operations_to_sort(7, [3, 2, 1, 5, 4, 6, 8]) 3","solution":"def min_operations_to_sort(n, arr): if n <= 1: return 0 # Count the number of already sorted segments segments = 1 for i in range(1, n): if arr[i] < arr[i - 1]: segments += 1 # The minimum number of operations is the number of segments minus one return segments - 1"},{"question":"def longestSubstring(s: str, k: int) -> int: Find the length of the longest substring where the frequency of each character in the substring is greater than or equal to the given minimum frequency k. Parameters: s (str): The input string containing only lowercase English letters. k (int): The minimum frequency of each character in the substring. Returns: int: The length of the longest valid substring. Example: >>> longestSubstring(\\"aaabbcc\\", 3) 3 >>> longestSubstring(\\"ababbc\\", 2) 5 def test_longestSubstring(): assert longestSubstring(\\"aaabbcc\\", 3) == 3, \\"Error: Expected 3\\" assert longestSubstring(\\"ababbc\\", 2) == 5, \\"Error: Expected 5\\" assert longestSubstring(\\"a\\", 1) == 1, \\"Error: Expected 1\\" assert longestSubstring(\\"a\\", 2) == 0, \\"Error: Expected 0\\" assert longestSubstring(\\"aa\\", 2) == 2, \\"Error: Expected 2\\" assert longestSubstring(\\"ababacb\\", 3) == 0, \\"Error: Expected 0\\" assert longestSubstring(\\"bbaaacbd\\", 3) == 3, \\"Error: Expected 3\\" def test_edge_cases(): assert longestSubstring(\\"\\", 1) == 0, \\"Error: Expected 0\\" assert longestSubstring(\\"a\\" * 10000, 1) == 10000, \\"Error: Expected 10000\\" assert longestSubstring(\\"a\\" * 10000, 10000) == 10000, \\"Error: Expected 10000\\" test_longestSubstring() test_edge_cases()","solution":"def longestSubstring(s: str, k: int) -> int: def helper(start, end): if end - start < k: return 0 freq = {} for i in range(start, end): freq[s[i]] = freq.get(s[i], 0) + 1 for i in range(start, end): if freq[s[i]] < k: j = i + 1 while j < end and freq[s[j]] < k: j += 1 return max(helper(start, i), helper(j, end)) return end - start return helper(0, len(s))"},{"question":"def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates a given 2D list (matrix) 90 degrees clockwise. If the input is empty, the function should return an empty list. >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([ ... [1, 2], ... [3, 4], ... [5, 6] ... ]) [[5, 3, 1], [6, 4, 2]] >>> rotate_matrix([ ... [1, 2, 3] ... ]) [[1], [2], [3]] >>> rotate_matrix([ ... [1], ... [2], ... [3] ... ]) [[3, 2, 1]] >>> rotate_matrix([]) []","solution":"def rotate_matrix(matrix): Rotates a given 2D list (matrix) 90 degrees clockwise. Parameters: matrix (list of list of int): A 2D list representing the matrix to rotate. Returns: list of list of int: The rotated matrix. if not matrix: return [] return [list(row) for row in zip(*matrix[::-1])]"},{"question":"def ways_to_climb_stairs(n: int, max_step: int) -> int: Compute the total number of distinct ways Fred can climb to the top of a staircase with n steps, given that he can climb up to a maximum of max_step steps during any single climb. >>> ways_to_climb_stairs(4, 2) 5 >>> ways_to_climb_stairs(4, 3) 7 >>> ways_to_climb_stairs(3, 2) 3","solution":"def ways_to_climb_stairs(n, max_step): # Using dynamic programming to find the number of ways to climb n steps dp = [0] * (n + 1) dp[0] = 1 # There's one way to stay at the ground (doing nothing) for i in range(1, n + 1): for j in range(1, min(max_step, i) + 1): dp[i] += dp[i - j] return dp[n]"},{"question":"def can_buy_snack(consecutive_ranges, m, k): Determine if a citizen can use their money to buy the snack with the given constraints. :param consecutive_ranges: List of tuples representing the consecutive ranges of money. :param m: Exact amount of money the citizen has. :param k: Maximum amount the vending machine will dispense in one transaction. :return: \\"YES\\" if the citizen can use their money to buy the snack, otherwise \\"NO\\". Examples: >>> can_buy_snack([(1, 3), (5, 9), (12, 15)], 10, 5) 'YES' >>> can_buy_snack([(1, 3), (5, 9), (12, 15)], 30, 5) 'NO' def test_exceeds_limit(): n = 3 consecutive_ranges = [(1, 3), (5, 9), (12, 15)] m = 30 k = 5 assert can_buy_snack(consecutive_ranges, m, k) == \\"NO\\" def test_insufficient_funds(): n = 3 consecutive_ranges = [(1, 3), (5, 9), (12, 15)] m = 2 k = 5 assert can_buy_snack(consecutive_ranges, m, k) == \\"YES\\" def test_no_possible_sums(): n = 2 consecutive_ranges = [(3, 3), (7, 7)] m = 4 k = 5 assert can_buy_snack(consecutive_ranges, m, k) == \\"NO\\" def test_exact_match(): n = 3 consecutive_ranges = [(1, 3), (5, 9), (12, 15)] m = 18 k = 5 assert can_buy_snack(consecutive_ranges, m, k) == \\"YES\\" def test_multiple_possible_sums(): n = 4 consecutive_ranges = [(1, 3), (2, 5), (5, 9), (3, 6)] m = 11 k = 5 assert can_buy_snack(consecutive_ranges, m, k) == \\"YES\\"","solution":"def can_buy_snack(consecutive_ranges, m, k): Returns \\"YES\\" if the citizen can use their money to buy the snack with the given constraints, otherwise returns \\"NO\\". possible_sums = set([0]) for l, r in consecutive_ranges: new_sums = set() for value in range(l, r + 1): for s in possible_sums: if s + value <= m: new_sums.add(s + value) possible_sums.update(new_sums) for s in possible_sums: if s == m: return \\"YES\\" return \\"NO\\" # Example usage: n = 3 consecutive_ranges = [(1, 3), (5, 9), (12, 15)] m = 10 k = 5 print(can_buy_snack(consecutive_ranges, m, k)) # Output should be \\"YES\\""},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string s. If there is no non-repeating character, returns '_'. >>> first_non_repeating_character(\\"aabbccdde\\") 'e' >>> first_non_repeating_character(\\"aabb\\") '_' >>> first_non_repeating_character(\\"a\\") 'a' >>> first_non_repeating_character(\\"aabccd\\") 'b' >>> first_non_repeating_character(\\"aabbc\\") 'c' >>> first_non_repeating_character(\\"\\") '_' >>> first_non_repeating_character(\\"abcabdce\\") 'd' >>> first_non_repeating_character(\\"ab\\") 'a'","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If there is no non-repeating character, returns '_'. from collections import OrderedDict char_count = OrderedDict() for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char, count in char_count.items(): if count == 1: return char return '_'"},{"question":"def longest_non_adjacent_subsequence_length(S: str) -> int: Finds the length of the longest subsequence where no two adjacent characters are the same. Parameters: S (str): input string consisting of lowercase English letters. Returns: int: length of the longest subsequence where no two adjacent characters are the same. >>> longest_non_adjacent_subsequence_length(\\"aabbc\\") 3 >>> longest_non_adjacent_subsequence_length(\\"aaaa\\") 1 >>> longest_non_adjacent_subsequence_length(\\"ababab\\") 6 >>> longest_non_adjacent_subsequence_length(\\"abcabc\\") 6 >>> longest_non_adjacent_subsequence_length(\\"axaxa\\") 5","solution":"def longest_non_adjacent_subsequence_length(S): Finds the length of the longest subsequence where no two adjacent characters are the same. Parameters: S (str): input string consisting of lowercase English letters. Returns: int: length of the longest subsequence where no two adjacent characters are the same. if not S: return 0 # Start with the first character length = 1 current_char = S[0] for i in range(1, len(S)): if S[i] != current_char: length += 1 current_char = S[i] return length"},{"question":"class SpecialStack: A stack that supports push, pop, top, and min operations in O(1) time complexity. Example: specialStack = SpecialStack() specialStack.push(3) specialStack.push(5) print(specialStack.min()) # Output: 3 specialStack.push(2) specialStack.push(1) print(specialStack.min()) # Output: 1 specialStack.pop() print(specialStack.min()) # Output: 2 specialStack.pop() print(specialStack.top()) # Output: 5 def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int): Pushes the element val onto the stack. pass def pop(self) -> int: Removes the element on the top of the stack and returns it. pass def top(self) -> int: Returns the element on the top of the stack. pass def min(self) -> int: Retrieves the minimum element in the stack. pass # Unit tests def test_push_and_min(): stack = SpecialStack() stack.push(3) stack.push(5) assert stack.min() == 3 def test_push_pop_and_min(): stack = SpecialStack() stack.push(3) stack.push(5) stack.push(2) stack.push(1) assert stack.min() == 1 stack.pop() assert stack.min() == 2 stack.pop() assert stack.min() == 3 def test_top(): stack = SpecialStack() stack.push(3) stack.push(5) stack.push(2) stack.push(1) stack.pop() stack.pop() assert stack.top() == 5 stack.pop() assert stack.top() == 3 def test_min_with_single_element(): stack = SpecialStack() stack.push(3) assert stack.min() == 3 def test_pop_on_empty_stack(): stack = SpecialStack() assert stack.pop() is None def test_top_on_empty_stack(): stack = SpecialStack() assert stack.top() is None def test_min_on_empty_stack(): stack = SpecialStack() assert stack.min() is None","solution":"class SpecialStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val): self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self): if self.stack: val = self.stack.pop() if val == self.min_stack[-1]: self.min_stack.pop() return val def top(self): if self.stack: return self.stack[-1] def min(self): if self.min_stack: return self.min_stack[-1]"},{"question":"def calculate_total_time(events): Calculates the total time the runner has been walking, considering overlapping intervals only once. Parameters: events (list of tuples): List of (\\"start\\" or \\"stop\\", timestamp) events. Returns: int: Total non-overlapping walking time. pass def read_input(input_lines): Reads the input lines and converts to events format. Parameters: input_lines (list of str): List of input lines. Returns: list of tuples: List of (\\"start\\" or \\"stop\\", timestamp) events. pass # Test Cases def test_single_interval(): events = read_input([\\"start 1\\", \\"stop 5\\", \\"end\\"]) assert calculate_total_time(events) == 4 def test_overlapping_intervals(): events = read_input([\\"start 1\\", \\"stop 5\\", \\"start 3\\", \\"stop 6\\", \\"end\\"]) assert calculate_total_time(events) == 5 def test_fully_nested_intervals(): events = read_input([\\"start 2\\", \\"stop 8\\", \\"start 4\\", \\"stop 10\\", \\"end\\"]) assert calculate_total_time(events) == 8 def test_non_overlapping_intervals(): events = read_input([\\"start 1\\", \\"stop 3\\", \\"start 4\\", \\"stop 6\\", \\"end\\"]) assert calculate_total_time(events) == 4 def test_complex_intervals(): events = read_input([\\"start 1\\", \\"stop 5\\", \\"start 2\\", \\"stop 6\\", \\"start 8\\", \\"stop 10\\", \\"end\\"]) assert calculate_total_time(events) == 7","solution":"def calculate_total_time(events): Calculates the total time the runner has been walking, considering overlapping intervals only once. Parameters: events (list of tuples): List of (\\"start\\" or \\"stop\\", timestamp) events. Returns: int: Total non-overlapping walking time. if not events: return 0 intervals = [] current_start = None for event, timestamp in events: if event == \\"start\\": if current_start is None: current_start = timestamp elif event == \\"stop\\": if current_start is not None: intervals.append((current_start, timestamp)) current_start = None # Merge intervals and calculate total time merged_intervals = [] for start, stop in sorted(intervals): if not merged_intervals or merged_intervals[-1][1] < start: merged_intervals.append((start, stop)) else: merged_intervals[-1] = (merged_intervals[-1][0], max(merged_intervals[-1][1], stop)) total_time = sum(stop - start for start, stop in merged_intervals) return total_time # Assuming we read input as given in the problem statement, and convert it to a list of events. def read_input(input_lines): Reads the input lines and converts to events format. Parameters: input_lines (list of str): List of input lines. Returns: list of tuples: List of (\\"start\\" or \\"stop\\", timestamp) events. events = [] for line in input_lines: if line.strip() == \\"end\\": break event, timestamp = line.strip().split() events.append((event, int(timestamp))) return events"},{"question":"def nth_fibonacci(n: int) -> int: Find the N-th Fibonacci number modulo 10**9 + 7. Parameters: n (int): The position in the Fibonacci sequence. Returns: int: The N-th Fibonacci number modulo 10**9 + 7. Example: >>> nth_fibonacci(0) 0 >>> nth_fibonacci(1) 1 >>> nth_fibonacci(2) 1 >>> nth_fibonacci(10) 55 pass def process_test_cases(T: int, test_cases: List[int]) -> List[int]: Process multiple test cases to find the N-th Fibonacci number for each. Parameters: T (int): The number of test cases. test_cases (List[int]): A list of integers representing the positions in the Fibonacci sequence for each test case. Returns: List[int]: A list of the N-th Fibonacci numbers modulo 10**9 + 7 for each test case. Example: >>> process_test_cases(5, [0, 1, 2, 10, 50]) [0, 1, 1, 55, 12586269025 % (10**9 + 7)] pass def matrix_power(matrix: List[List[int]], n: int) -> List[List[int]]: Raises a 2x2 matrix to the power of n modulo 10**9 + 7. Parameters: matrix (List[List[int]]): A 2x2 matrix to raise to the power of n. n (int): The power to which to raise the matrix. Returns: List[List[int]]: The resulting 2x2 matrix after exponentiation. Example: >>> matrix_power([[1, 1], [1, 0]], 2) [[2, 1], [1, 1]] >>> matrix_power([[1, 1], [1, 0]], 3) [[3, 2], [2, 1]] pass","solution":"MOD = 10**9 + 7 def matrix_multiply(A, B): return [ [ (A[0][0]*B[0][0] + A[0][1]*B[1][0]) % MOD, (A[0][0]*B[0][1] + A[0][1]*B[1][1]) % MOD ], [ (A[1][0]*B[0][0] + A[1][1]*B[1][0]) % MOD, (A[1][0]*B[0][1] + A[1][1]*B[1][1]) % MOD ] ] def matrix_power(matrix, n): result = [[1, 0], [0, 1]] # Identity matrix base = matrix while n > 0: if n % 2 == 1: result = matrix_multiply(result, base) base = matrix_multiply(base, base) n //= 2 return result def nth_fibonacci(n): if n == 0: return 0 if n == 1: return 1 F = [[1, 1], [1, 0]] result_matrix = matrix_power(F, n-1) return result_matrix[0][0] def process_test_cases(T, test_cases): results = [] for n in test_cases: results.append(nth_fibonacci(n)) return results"},{"question":"def partition_equal_sum(nums: List[int]) -> str: You are given a list of n distinct integers, and you need to divide this list into two non-empty subsets such that the sum of the integers in each subset is equal. If it is not possible to do so, return \\"No\\". Otherwise, return \\"Yes\\". >>> partition_equal_sum([4, 1, 5, 11, 5]) == \\"Yes\\" >>> partition_equal_sum([3, 1, 2, 5]) == \\"No\\"","solution":"def can_partition(nums): total_sum = sum(nums) # If the total sum is odd, it's not possible to divide into two subsets with equal sum if total_sum % 2 != 0: return \\"No\\" target = total_sum // 2 n = len(nums) # Initialize a list to track possible sums using dynamic programming dp = [False] * (target + 1) dp[0] = True # Iterate through the numbers for num in nums: # Update the dp list from back to front for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return \\"Yes\\" if dp[target] else \\"No\\" def partition_equal_sum(nums): n = nums[0] nums_list = nums[1:] if n != len(nums_list): raise ValueError(\\"The number of integers must match the given 'n'\\") return can_partition(nums_list)"},{"question":"def max_harry_points(cards: List[int]) -> int: Returns the maximum points Harry can achieve given both he and Sally play optimally. Example 1: >>> max_harry_points([1, 2, 3, 4]) == 6 Example 2: >>> max_harry_points([8, 15, 3, 7]) == 22","solution":"def max_harry_points(cards): Returns the maximum points Harry can achieve given both he and Sally play optimally. n = len(cards) dp = [[0]*n for _ in range(n)] for i in range(n): dp[i][i] = cards[i] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 dp[i][j] = max(cards[i] - dp[i + 1][j], cards[j] - dp[i][j - 1]) total_sum = sum(cards) harry_points = (total_sum + dp[0][n - 1]) // 2 return harry_points"},{"question":"def max_coconuts(n: int, m: int, coconuts: List[int], bridges: List[Tuple[int, int]]) -> int: Determine the maximum number of coconuts Tony can collect from the first island to the last island. Args: n (int): The number of islands. m (int): The number of bridges. coconuts (List[int]): The number of coconuts on each island. bridges (List[Tuple[int, int]]): The bridge connections between the islands. Returns: int: The maximum number of coconuts Tony can collect. >>> max_coconuts(5, 6, [3, 2, 1, 10, 4], [(1, 2), (2, 3), (1, 3), (3, 4), (4, 5), (2, 5)]) 20 >>> max_coconuts(3, 0, [1, 2, 3], []) -inf >>> max_coconuts(1, 0, [10], []) 10 >>> max_coconuts(4, 2, [3, 4, 5, 6], [(1, 2), (3, 4)]) -inf >>> max_coconuts(5, 4, [5, 1, 2, 4, 3], [(1, 2), (1, 3), (3, 4), (4, 5)]) 14","solution":"def max_coconuts(n, m, coconuts, bridges): # Initialize the dp array with a very small number dp = [-float('inf')] * (n + 1) dp[1] = coconuts[0] # Iterate through the edges list repeatedly for _ in range(n - 1): for u, v in bridges: if dp[u] != -float('inf'): # If u is reachable dp[v] = max(dp[v], dp[u] + coconuts[v - 1]) return dp[n]"},{"question":"def find_winner(n: int, strengths: List[int]) -> int: Determines the strength of the winning army or indicates if no army remains. >>> find_winner(5, [3, 8, 2, 8, 2]) == 3 >>> find_winner(4, [5, 5, 6, 6]) == -1 import unittest class TestFindWinner(unittest.TestCase): def test_single_survivor(self): self.assertEqual(find_winner(5, [3, 8, 2, 8, 2]), 3) def test_no_survivors(self): self.assertEqual(find_winner(4, [5, 5, 6, 6]), -1) def test_single_army(self): self.assertEqual(find_winner(1, [7]), 7) def test_all_eliminate_each_other(self): self.assertEqual(find_winner(6, [1, 2, 3, 1, 2, 3]), -1) def test_large_numbers(self): self.assertEqual(find_winner(3, [1000000000, 999999999, 1000000000]), 999999999) def test_multiple_surviving_armies(self): self.assertEqual(find_winner(5, [4, 5, 4, 6, 7]), 5) def test_odd_occurrence_of_stronger_armies(self): self.assertEqual(find_winner(6, [1, 1, 2, 3, 2, 3, 2]), 2) if __name__ == \\"__main__\\": unittest.main()","solution":"def find_winner(n, strengths): Determines the strength of the winning army or indicates if no army remains. Params: n (int): The number of armies. strengths (List[int]): The strength values of the armies. Returns: int: The strength of the winning army or -1 if no army remains. from collections import Counter counter = Counter(strengths) surviving_armies = [strength for strength, count in counter.items() if count % 2 != 0] if not surviving_armies: return -1 return min(surviving_armies)"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def kth_smallest(root, k): Returns the kth smallest value in a BST. Parameters: root (TreeNode): The root of the binary search tree. k (int): The kth position to find the smallest element. Returns: int: The kth smallest value in the BST. >>> # Creating the following BST >>> # 5 >>> # / >>> # 3 7 >>> # / / >>> # 2 4 6 8 >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(7) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(8) >>> kth_smallest(root, 3) 4 >>> kth_smallest(root, 5) 6","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def kth_smallest(root, k): Returns the kth smallest value in a BST. # In-Order Traversal (Iterative) stack = [] while True: # Go to the left most node while root: stack.append(root) root = root.left # Retrieve the node from the stack root = stack.pop() k -= 1 if k == 0: return root.value # Go to the right node root = root.right"},{"question":"from collections import deque from typing import List, Tuple def min_moves_to_treasure(m: int, n: int, grid: List[List[str]], x1: int, y1: int, x2: int, y2: int) -> int: Determine the minimum number of moves needed to reach the treasure in a grid. Args: m (int): Number of rows in the grid. n (int): Number of columns in the grid. grid (List[List[str]]): Grid representation, where '.' is grass and '#' is rock. x1 (int): Starting cell row index. y1 (int): Starting cell column index. x2 (int): Treasure cell row index. y2 (int): Treasure cell column index. Returns: int: The minimum number of moves to reach the treasure, or -1 if it's not reachable. >>> min_moves_to_treasure(5, 5, [\\".....\\", \\".#.\\", \\".....\\", \\".#...\\", \\".....\\"], 0, 0, 4, 4) 8 >>> min_moves_to_treasure(3, 4, [\\"....\\", \\"\\", \\"....\\"], 0, 0, 2, 3) -1 pass def solve_game(m: int, n: int, grid_lines: List[str], start_end: Tuple[int, int, int, int]) -> int: grid = [list(line) for line in grid_lines] x1, y1, x2, y2 = start_end return min_moves_to_treasure(m, n, grid, x1, y1, x2, y2) # Unit Tests def test_example_1(): m, n = 5, 5 grid_lines = [\\".....\\", \\".#.\\", \\".....\\", \\".#...\\", \\".....\\"] start_end = (0, 0, 4, 4) assert solve_game(m, n, grid_lines, start_end) == 8 def test_example_2(): m, n = 3, 4 grid_lines = [\\"....\\", \\"\\", \\"....\\"] start_end = (0, 0, 2, 3) assert solve_game(m, n, grid_lines, start_end) == -1 def test_no_obstacles(): m, n = 3, 3 grid_lines = [\\"...\\", \\"...\\", \\"...\\"] start_end = (0, 0, 2, 2) assert solve_game(m, n, grid_lines, start_end) == 4 def test_single_cell(): m, n = 1, 1 grid_lines = [\\".\\"] start_end = (0, 0, 0, 0) assert solve_game(m, n, grid_lines, start_end) == 0 def test_start_equals_treasure(): m, n = 5, 5 grid_lines = [\\".....\\", \\".#.\\", \\".....\\", \\".#...\\", \\".....\\"] start_end = (2, 2, 2, 2) assert solve_game(m, n, grid_lines, start_end) == 0 def test_large_grid(): m, n = 10, 10 grid_lines = [ \\"..........\\", \\".#..\\", \\".#........\\", \\".#..\\", \\".#....#.\\", \\".#....#.\\", \\"..\\", \\"....\\", \\"....#...\\", \\"..........\\" ] start_end = (0, 0, 9, 9) assert solve_game(m, n, grid_lines, start_end) == 18 def test_unreachable_treasure(): m, n = 4, 4 grid_lines = [ \\"....\\", \\"\\", \\"..#.\\", \\".#..\\" ] start_end = (0, 0, 3, 3) assert solve_game(m, n, grid_lines, start_end) == -1","solution":"from collections import deque def min_moves_to_treasure(m, n, grid, x1, y1, x2, y2): def is_valid(x, y): return 0 <= x < m and 0 <= y < n and grid[x][y] == '.' directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(x1, y1, 0)]) # (current_x, current_y, current_distance) visited = set((x1, y1)) while queue: curr_x, curr_y, dist = queue.popleft() if curr_x == x2 and curr_y == y2: return dist for d in directions: nxt_x, nxt_y = curr_x + d[0], curr_y + d[1] if is_valid(nxt_x, nxt_y) and (nxt_x, nxt_y) not in visited: visited.add((nxt_x, nxt_y)) queue.append((nxt_x, nxt_y, dist + 1)) return -1 # Treasure is not reachable def solve_game(m, n, grid_lines, start_end): grid = [list(line) for line in grid_lines] x1, y1, x2, y2 = start_end return min_moves_to_treasure(m, n, grid, x1, y1, x2, y2) # Example usage: # m, n = 5, 5 # grid_lines = [\\".....\\", \\".#.\\", \\".....\\", \\".#...\\", \\".....\\"] # start_end = (0, 0, 4, 4) # result = solve_game(m, n, grid_lines, start_end) # print(result) # Output: 8"},{"question":"def minimum_commands(N, M, K, initial_positions, target_positions): This function calculates the minimum number of commands required to move all drones from their initial positions to their target positions. >>> minimum_commands(5, 5, 3, [1, 1, 2, 2, 3, 3], [5, 5, 4, 4, 2, 2]) 4 >>> minimum_commands(10, 10, 1, [5, 5], [5, 5]) 0 >>> minimum_commands(10, 10, 3, [1, 1, 2, 2, 3, 3], [1, 1, 2, 2, 3, 3]) 0 >>> minimum_commands(10, 10, 2, [1, 1, 10, 10], [10, 10, 1, 1]) 9 >>> minimum_commands(1000, 1000, 2, [1, 1, 1000, 1000], [1, 1000, 1000, 1]) 999 >>> minimum_commands(1000, 1000, 1, [1, 1], [1000, 1000]) 999","solution":"def minimum_commands(N, M, K, initial_positions, target_positions): This function calculates the minimum number of commands required to move all drones from their initial positions to their target positions. initial_x_coords = initial_positions[0::2] initial_y_coords = initial_positions[1::2] target_x_coords = target_positions[0::2] target_y_coords = target_positions[1::2] max_x_diff = max(abs(ix - tx) for ix, tx in zip(initial_x_coords, target_x_coords)) max_y_diff = max(abs(iy - ty) for iy, ty in zip(initial_y_coords, target_y_coords)) return max(max_x_diff, max_y_diff)"},{"question":"def final_position(n: int, m: int, instructions: str) -> tuple[int, int]: Simulate the movement of a robot on a grid and determine its final position. The robot starts at position (1,1) of a \`n x m\` grid and moves according to the given instructions ('U' for up, 'D' for down, 'L' for left, 'R' for right). The robot cannot move outside the boundaries of the grid. If a move instruction would result in the robot moving out of the grid, it ignores that instruction. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid instructions (str): sequence of movement instructions ('U', 'D', 'L', 'R') Returns: tuple: final row and column of the robot after following all instructions Examples: >>> final_position(3, 3, \\"RRDDLU\\") (2, 2) >>> final_position(3, 3, \\"RRRRRDDDDD\\") (3, 3) >>> final_position(3, 3, \\"D\\") (2, 1) >>> final_position(3, 3, \\"DDDD\\") (3, 1) >>> final_position(3, 3, \\"UUU\\") (1, 1) >>> final_position(5, 5, \\"RRRDDLLLLUUURRDD\\") (3, 3) >>> final_position(3, 3, \\"\\") (1, 1)","solution":"def final_position(n, m, instructions): Find the final position of the robot after executing the given instructions. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid instructions (str): sequence of instructions ('U', 'D', 'L', 'R') Returns: tuple: final row and column of the robot # Starting position row, col = 1, 1 # Mapping movement to coordinate changes moves = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)} for instruction in instructions: if instruction in moves: new_row = row + moves[instruction][0] new_col = col + moves[instruction][1] # Check if the new position is within bounds if 1 <= new_row <= n and 1 <= new_col <= m: row, col = new_row, new_col return row, col"},{"question":"def find_max_trees(t, test_cases): Given the number of test cases and a list of test cases with tree heights, find the maximum number of trees that can be planted in a strictly increasing sequence. Parameters: t (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains the number of trees and the list of heights of the trees. Returns: List[int]: List of maximum number of trees that can be planted in a strictly increasing sequence for each test case. >>> find_max_trees(2, [(5, [3, 10, 2, 1, 20]), (6, [3, 4, 5, 10, 6, 7])]) [3, 5] >>> find_max_trees(1, [(5, [1, 2, 3, 4, 5])]) [5] pass import pytest def test_find_max_trees(): t = 2 test_cases = [ (5, [3, 10, 2, 1, 20]), (6, [3, 4, 5, 10, 6, 7]) ] assert find_max_trees(t, test_cases) == [3, 5] t = 1 test_cases = [ (1, [5]) ] assert find_max_trees(t, test_cases) == [1] t = 1 test_cases = [ (4, [5, 5, 5, 5]) ] assert find_max_trees(t, test_cases) == [1] t = 1 test_cases = [ (5, [9, 8, 7, 6, 5]) ] assert find_max_trees(t, test_cases) == [1] t = 1 test_cases = [ (5, [1, 2, 3, 4, 5]) ] assert find_max_trees(t, test_cases) == [5] t = 1 test_cases = [ (7, [10, 22, 9, 33, 21, 50, 41]) ] assert find_max_trees(t, test_cases) == [4] t = 1 test_cases = [ (0, []) ] assert find_max_trees(t, test_cases) == [0] @pytest.mark.parametrize(\\"heights, expected\\", [ ([10, 20, 30, 40, 50], 5), ([50, 40, 30, 20, 10], 1), ([5, 1, 5, 10, 3, 7, 9], 4), ]) def test_varied_cases(heights, expected): t = 1 test_cases = [ (len(heights), heights) ] assert find_max_trees(t, test_cases) == [expected]","solution":"import bisect def length_of_lis(heights): Function to find the length of the longest increasing subsequence (LIS). Uses a dynamic programming approach with binary search for optimization. if not heights: return 0 dp = [] for height in heights: pos = bisect.bisect_left(dp, height) if pos == len(dp): dp.append(height) else: dp[pos] = height return len(dp) def find_max_trees(t, test_cases): Process each test case and compute the maximum number of trees that can be planted in a strictly increasing sequence. results = [] for i in range(t): n = test_cases[i][0] heights = test_cases[i][1] results.append(length_of_lis(heights)) return results"},{"question":"from typing import List, Tuple def count_right_angled_triangles(points: List[Tuple[int, int]]) -> int: Count the number of unique right-angled triangles that can be formed using any three of the given points with the right angle at the origin (0, 0). >>> count_right_angled_triangles([(1, 0), (0, 1), (2, 0), (0, 2), (1, 1)]) 4 >>> count_right_angled_triangles([(1, 1), (2, 2), (3, 3)]) 0 >>> count_right_angled_triangles([(1, 0)]) 0 >>> count_right_angled_triangles([(1, 0), (2, 0), (0, 1), (0, 2)]) 4 >>> count_right_angled_triangles([(0, i) for i in range(1, 1001)] + [(i, 0) for i in range(1, 1001)]) 1000000","solution":"def count_right_angled_triangles(points): # Dictionary to count points on the x-axis and y-axis x_count = {} y_count = {} for x, y in points: if x == 0 and y == 0: continue # Skip the origin if x == 0: y_count[y] = y_count.get(y, 0) + 1 elif y == 0: x_count[x] = x_count.get(x, 0) + 1 # Calculate the number of right-angled triangles triangles = 0 for x_key in x_count.values(): for y_key in y_count.values(): triangles += x_key * y_key return triangles # Function to parse input and return the number of right-angled triangles def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) points = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(N)] print(count_right_angled_triangles(points))"},{"question":"def encrypt_message(key: int, message: str) -> str: Encrypts the message by shifting each character to the right by the given key. Args: key (int): The number of positions each character in the message is shifted to the right. message (str): The message to be encrypted. Returns: str: The encrypted message. >>> encrypt_message(2, \\"SECRET\\") \\"ETSECR\\" >>> encrypt_message(3, \\"ABCDE\\") \\"CDEAB\\" >>> encrypt_message(5, \\"HELLO\\") \\"HELLO\\" >>> encrypt_message(1001, \\"WORLD\\") \\"DWORL\\" >>> encrypt_message(1, \\"X\\") \\"X\\" >>> encrypt_message(0, \\"PYTHON\\") \\"PYTHON\\" >>> encrypt_message(6, \\"PYTHON\\") \\"PYTHON\\" >>> message = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" * 10 >>> key = 52 >>> expected_output = message[-52:] + message[:-52] >>> encrypt_message(key, message) expected_output","solution":"def encrypt_message(key, message): Encrypts the message by shifting each character to the right by the given key. Args: key (int): The number of positions each character in the message is shifted to the right. message (str): The message to be encrypted. Returns: str: The encrypted message. n = len(message) key = key % n # if key is greater than length of message, wrap it around # get the last \`key\` characters + the rest at the beginning encrypted_message = message[-key:] + message[:-key] return encrypted_message"},{"question":"def largest_lexicographical_substring(T: int, strings: List[str]) -> List[str]: Given a number of test cases, and a list of strings, find the largest lexicographical substring that can be formed by deleting exactly one character from each string. >>> largest_lexicographical_substring(2, [\\"abcde\\", \\"ahbgdc\\"]) [\\"bcde\\", \\"hbgdc\\"] >>> largest_lexicographical_substring(1, [\\"wxyz\\"]) [\\"xyz\\"]","solution":"def largest_lexicographical_substring(T, strings): results = [] for S in strings: max_substring = \\"\\" for i in range(len(S)): temp_string = S[:i] + S[i+1:] if temp_string > max_substring: max_substring = temp_string results.append(max_substring) return results # Example usage: # T = 2 # strings = [\\"abcde\\", \\"ahbgdc\\"] # print(largest_lexicographical_substring(T, strings)) # Expected output: ['bcde', 'hbgdc']"},{"question":"def can_form_palindrome(s: str) -> str: Determines if it is possible to rearrange the characters of the string s to form a palindrome. If it is possible, returns one possible palindrome. Otherwise, returns \\"Not possible\\". >>> can_form_palindrome(\\"civic\\") \\"civic\\" >>> can_form_palindrome(\\"ivicc\\") \\"civic\\" >>> can_form_palindrome(\\"hello\\") \\"Not possible\\" >>> can_form_palindrome(\\"madam\\") \\"madam\\"","solution":"from collections import Counter def can_form_palindrome(s): Determines if it is possible to rearrange the characters of the string s to form a palindrome. If it is possible, returns one possible palindrome. Otherwise, returns \\"Not possible\\". # Count the characters in the string count = Counter(s) # Check how many characters have an odd count odd_count = sum(1 for char in count if count[char] % 2 != 0) # More than one character with an odd count means a palindrome is not possible if odd_count > 1: return \\"Not possible\\" # Build the first half and the middle (if any) of the palindrome first_half = [] middle = '' for char, freq in count.items(): if freq % 2 == 1: middle = char first_half.append(char * (freq // 2)) # Join the first half with its reverse and the middle character (if any) first_half = ''.join(first_half) return first_half + middle + first_half[::-1]"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(node_list): Build a binary tree from a list of nodes. Each node contains a value and indices of left and right children. If a node has no left or right child, the corresponding index will be -1. Args: node_list (List[Tuple[int, int, int]]): List of nodes with their left and right children indices. Returns: TreeNode: The root of the binary tree. def longest_path_of_ones(root): Find the length of the longest path consisting of only 1s in the binary tree. Args: root (TreeNode): The root of the binary tree. Returns: int: The length of the longest path of 1s. def main(node_list): Main function to read input and find the longest path of 1s. Args: node_list (List[Tuple[int, int, int]]): List of nodes with their left and right children indices. Returns: int: The length of the longest path of 1s. import pytest from solution import main def test_single_node(): assert main([(1, -1, -1)]) == 1 def test_simple_tree(): assert main([(1, 1, 2), (1, -1, -1), (1, -1, -1)]) == 3 def test_no_ones(): assert main([(0, 1, 2), (0, -1, -1), (0, -1, -1)]) == 0 def test_mixed_values(): assert main([(1, 1, 2), (0, -1, -1), (1, -1, -1)]) == 2 def test_complex_tree(): assert main([ (1, 1, 2), (1, 3, 4), (0, -1, -1), (0, -1, 5), (1, -1, -1), (1, -1, -1), ]) == 3","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(node_list): if not node_list: return None nodes = [None] * len(node_list) for i, (value, left, right) in enumerate(node_list): if nodes[i] is None: nodes[i] = TreeNode(value) if left != -1: nodes[left] = nodes[left] or TreeNode(node_list[left][0]) nodes[i].left = nodes[left] if right != -1: nodes[right] = nodes[right] or TreeNode(node_list[right][0]) nodes[i].right = nodes[right] return nodes[0] def longest_path_of_ones(root): max_path = 0 def dfs(node): nonlocal max_path if not node: return 0 left_length = dfs(node.left) if node.left else 0 right_length = dfs(node.right) if node.right else 0 if node.value == 1: max_path = max(max_path, 1 + left_length + right_length) return 1 + max(left_length, right_length) return 0 dfs(root) return max_path def main(node_list): root = build_tree(node_list) return longest_path_of_ones(root)"},{"question":"def can_generate_target(n, m, s, t, stages): Determines if the target string 't' can be generated from the initial string 's' using the specified stages of the encryption algorithm. :param n: Length of the strings :param m: Number of stages :param s: Initial string :param t: Target string :param stages: List containing details of each stage :return: \\"POSSIBLE\\" if the target string can be generated, otherwise \\"IMPOSSIBLE\\" from solution import can_generate_target def test_example1(): n, m = 5, 2 s, t = 'abcde', 'acbde' stages = [(2, 2, 3), (1, 4)] assert can_generate_target(n, m, s, t, stages) == \\"POSSIBLE\\" def test_example2(): n, m = 5, 3 s, t = 'abcde', 'aecbd' stages = [(2, 2, 3), (2, 1, 5), (3, 3, 4, 5)] assert can_generate_target(n, m, s, t, stages) == \\"IMPOSSIBLE\\" def test_no_stages(): n, m = 5, 0 s, t = 'abcde', 'abcde' stages = [] assert can_generate_target(n, m, s, t, stages) == \\"POSSIBLE\\" def test_single_reversal(): n, m = 4, 1 s, t = 'abcd', 'abdc' stages = [(2, 3, 4)] assert can_generate_target(n, m, s, t, stages) == \\"POSSIBLE\\" def test_invalid(): n, m = 4, 1 s, t = 'abcd', 'badc' stages = [(2, 3, 4)] assert can_generate_target(n, m, s, t, stages) == \\"IMPOSSIBLE\\"","solution":"def can_generate_target(n, m, s, t, stages): Determines if the target string 't' can be generated from the initial string 's' using the specified stages of the encryption algorithm. :param n: Length of the strings :param m: Number of stages :param s: Initial string :param t: Target string :param stages: List containing details of each stage :return: \\"POSSIBLE\\" if the target string can be generated, otherwise \\"IMPOSSIBLE\\" s = list(s) for stage in stages: q_i = stage[0] indices = stage[1:] # Create the subsequence to reverse subseq = [s[idx - 1] for idx in indices] subseq.reverse() # Place the reversed subsequence back in the original string for i, idx in enumerate(indices): s[idx - 1] = subseq[i] return \\"POSSIBLE\\" if \\"\\".join(s) == t else \\"IMPOSSIBLE\\""},{"question":"def count_unique_devices(readings): Given a list of readings, returns the number of unique devices (unique readings) present in the list. >>> count_unique_devices([1, 2, 1, 2, 2, 3, 1, 2, 3, 3]) == 3 >>> count_unique_devices([4, 4, 4, 5, 5]) == 2 >>> count_unique_devices([1, 2, 3, 4, 5]) == 5 >>> count_unique_devices([1, 1, 1, 1]) == 1 >>> count_unique_devices([]) == 0 def process_input(input_data): Parses the input data, processes each test case, and returns a list of results. >>> input_data = [\\"10\\", \\"1 2 1 2 2 3 1 2 3 3\\", \\"5\\", \\"4 4 4 5 5\\", \\"0\\"] >>> process_input(input_data) == [3, 2] >>> input_data = [\\"3\\", \\"1 1 1\\", \\"4\\", \\"2 2 3 3\\", \\"0\\"] >>> process_input(input_data) == [1, 2] >>> input_data = [\\"6\\", \\"7 7 7 8 8 9\\", \\"6\\", \\"10 11 12 12 13 13\\", \\"0\\"] >>> process_input(input_data) == [3, 4]","solution":"def count_unique_devices(readings): Given a list of readings, returns the number of unique devices (unique readings) present in the list. return len(set(readings)) def process_input(input_data): Parses the input data, processes each test case, and returns a list of results. results = [] i = 0 while i < len(input_data): n = int(input_data[i]) if n == 0: break readings = list(map(int, input_data[i+1].split())) results.append(count_unique_devices(readings)) i += 2 return results"},{"question":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Initialize the segment tree with data self._build(data) def _build(self, data): # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, pos, value): # Update the leaf node pos += self.n self.tree[pos] = value # Update the parents while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def range_sum(self, left, right): # Sum on the interval [left, right) left += self.n right += self.n + 1 sum = 0 while left < right: if left % 2 == 1: sum += self.tree[left] left += 1 if right % 2 == 1: right -= 1 sum += self.tree[right] left //= 2 right //= 2 return sum def process_queries(n, array, queries): Perform a series of update and sum queries on an array using a segment tree. Args: n (int): The number of elements in the array. array (List[int]): The array of integers. queries (List[Tuple[int, int, int]]): A list of queries, where each query is a tuple containing: - Query type (1 for update, 2 for sum) - Index for update or left index for sum (i, l) - Value for update or right index for sum (x, r) Returns: List[int]: Results of the sum queries. Example: >>> process_queries(5, [1, 2, 3, 4, 5], [(2, 0, 2), (1, 1, 10), (2, 0, 2), (2, 1, 3), (1, 4, 6)]) [6, 14, 17] >>> process_queries(3, [1, 2, 3], [(1, 0, 4), (1, 1, 5), (1, 2, 6)]) []","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Initialize the segment tree with data self._build(data) def _build(self, data): # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, pos, value): # Update the leaf node pos += self.n self.tree[pos] = value # Update the parents while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def range_sum(self, left, right): # Sum on the interval [left, right) left += self.n right += self.n + 1 sum = 0 while left < right: if left % 2 == 1: sum += self.tree[left] left += 1 if right % 2 == 1: right -= 1 sum += self.tree[right] left //= 2 right //= 2 return sum def process_queries(n, array, queries): seg_tree = SegmentTree(array) results = [] for query in queries: if query[0] == 1: seg_tree.update(query[1], query[2]) elif query[0] == 2: results.append(seg_tree.range_sum(query[1], query[2])) return results # Example usage: n = 5 array = [1, 2, 3, 4, 5] queries = [(2, 0, 2), (1, 1, 10), (2, 0, 2), (2, 1, 3), (1, 4, 6)] print(process_queries(n, array, queries))"},{"question":"def min_operations_to_transform(s: str, t: str) -> int: Determine the minimum number of operations required to convert string s into string t. Operations allowed: 1. Append any character to the end of the string s. 2. Remove the last character of s. 3. Swap any two adjacent characters in s. Args: s (str): Initial string. t (str): Target string. Returns: int: Minimum number of operations or -1 if it's impossible. Examples: >>> min_operations_to_transform(\\"ab\\", \\"ba\\") 1 >>> min_operations_to_transform(\\"abcd\\", \\"dcba\\") 6 >>> min_operations_to_transform(\\"a\\", \\"a\\") 0 def solve_multiple_cases(q, cases): Solve multiple test cases for the transformation of strings. Args: q (int): Number of test cases. cases (list of tuple): Each tuple contains two strings s and t to be transformed. Returns: list: A list of minimum number of operations for each case or -1 if it's impossible. Examples: >>> solve_multiple_cases(3, [(\\"ab\\", \\"ba\\"), (\\"abcd\\", \\"dcba\\"), (\\"a\\", \\"a\\")]) [1, 6, 0] >>> solve_multiple_cases(2, [(\\"abcd\\", \\"abce\\"), (\\"abc\\", \\"def\\")]) [-1, -1]","solution":"def min_operations_to_transform(s: str, t: str) -> int: if sorted(s) != sorted(t): return -1 n = len(s) s_list = list(s) min_operations = 0 for i in range(n): if s_list[i] == t[i]: continue # Find the correct character in the rest of the list for j in range(i + 1, n): if s_list[j] == t[i]: break # Move the character at position j to position i using adjacent swaps while j > i: s_list[j], s_list[j - 1] = s_list[j - 1], s_list[j] j -= 1 min_operations += 1 return min_operations def solve_multiple_cases(q, cases): results = [] for s, t in cases: results.append(min_operations_to_transform(s, t)) return results"},{"question":"def top_k_employees(scores, k): Returns the indices of the top k employees based on their performance scores. If there are multiple employees with the same score, they should be ranked based on their indices in the original array. Parameters: scores: List[int] k: int Returns: List[int]: indices of the top k employees Examples: >>> top_k_employees([90, 85, 90, 70, 95], 3) [4, 0, 2] >>> top_k_employees([88, 87, 89, 91, 87, 89], 2) [3, 2] >>> top_k_employees([54, 56, 54, 58, 56, 50, 54], 4) [3, 1, 4, 0] >>> top_k_employees([100, 100, 100], 2) [0, 1] >>> top_k_employees([1, 2, 3], 1) [2] >>> top_k_employees([100], 1) [0] >>> top_k_employees([5, 5, 5, 5, 5], 3) [0, 1, 2]","solution":"def top_k_employees(scores, k): Returns the indices of the top k employees based on their performance scores. Parameters: scores: List[int] k: int Returns: List[int]: indices of the top k employees # Create a list of (index, score) pairs indexed_scores = [(i, score) for i, score in enumerate(scores)] # Sort the list by scores in descending order and by index in ascending order where scores are the same indexed_scores.sort(key=lambda x: (-x[1], x[0])) # Extract the indices of the top k employees top_k_indices = [indexed_scores[i][0] for i in range(k)] return top_k_indices"},{"question":"def zero_sum_subsequence_exists(lst): Determines if there exists a non-empty subsequence in lst whose sum is zero. Returns \\"Yes\\" if such a subsequence exists, otherwise \\"No\\". >>> zero_sum_subsequence_exists([3, -2, 1, -1, 2]) == \\"Yes\\" >>> zero_sum_subsequence_exists([1, 2, 3, 4, 5]) == \\"No\\" >>> zero_sum_subsequence_exists([0, 1, 2, 3]) == \\"Yes\\" >>> zero_sum_subsequence_exists([2, -2, 3]) == \\"Yes\\" >>> zero_sum_subsequence_exists([1] * 500 + [-1] * 501) == \\"Yes\\" >>> zero_sum_subsequence_exists([-5]) == \\"No\\" >>> zero_sum_subsequence_exists([5]) == \\"No\\" >>> zero_sum_subsequence_exists([10000, -10000]) == \\"Yes\\" >>> zero_sum_subsequence_exists([-3, 1, 2, 3, -1, -5, 5]) == \\"Yes\\" >>> zero_sum_subsequence_exists([5, 7, -12]) == \\"Yes\\"","solution":"def zero_sum_subsequence_exists(lst): Determines if there exists a non-empty subsequence in lst whose sum is zero. Returns \\"Yes\\" if such a subsequence exists, otherwise \\"No\\". prefix_sum = 0 prefix_sums = set() for num in lst: prefix_sum += num if prefix_sum == 0 or prefix_sum in prefix_sums: return \\"Yes\\" prefix_sums.add(prefix_sum) return \\"No\\""},{"question":"def total_number_of_cars(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Given a number of test cases and a list of tuples containing the number of cars (C) entering the intersection from each direction per minute and the number of minutes (M), return a list of total number of cars that have passed through the intersection after M minutes for each test case. >>> total_number_of_cars(3, [(2, 3), (5, 10), (7, 100)]) [24, 200, 2800] >>> total_number_of_cars(1, [(1, 1)]) [4] >>> total_number_of_cars(2, [(10, 5), (50, 2)]) [200, 400] >>> total_number_of_cars(4, [(3, 7), (6, 12), (2, 15), (1, 1)]) [84, 288, 120, 4] >>> total_number_of_cars(1, [(500, 1000000)]) [2000000000]","solution":"def total_number_of_cars(T, test_cases): Given a number of test cases and a list of tuples containing the number of cars (C) entering the intersection from each direction per minute and the number of minutes (M), return a list of total number of cars that have passed through the intersection after M minutes for each test case. results = [] for C, M in test_cases: total_cars = 4 * C * M results.append(total_cars) return results"},{"question":"def perform_operations(arr, operations): Given an array of integers and a list of operations, perform each operation and return the results of the sum operations. The operations are: 1. Update arr[x] to be y. 2. Find the sum of the elements from index x to y (inclusive). Example 1: >>> perform_operations([1, 3, 5, 7, 9], [[2, 1, 3], [1, 2, 4], [2, 2, 4]]) [15, 20] Example 2: >>> perform_operations([2, 4, 6, 8, 10], [[1, 0, 5], [2, 0, 2], [1, 3, 1], [2, 1, 4]]) [15, 21]","solution":"def perform_operations(arr, operations): Given an array and a list of operations, perform the specified operations and return the results of the sum operations. results = [] for op in operations: type, x, y = op if type == 1: # Update operation arr[x] = y elif type == 2: # Sum operation results.append(sum(arr[x:y+1])) return results"},{"question":"from typing import List, Tuple def can_ravi_and_sam_meet(T: int, cases: List[Tuple[int, int]]) -> List[str]: Determine if Ravi and Sam can meet in a grid. >>> can_ravi_and_sam_meet(3, [(2, 2), (3, 3), (2, 3)]) ['YES', 'YES', 'NO'] >>> can_ravi_and_sam_meet(2, [(1, 1), (1, 2)]) ['YES', 'NO']","solution":"def can_ravi_and_sam_meet(T, cases): results = [] for n, m in cases: if (n % 2 == m % 2): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Function to handle input/output formatting def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) cases = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(T)] results = can_ravi_and_sam_meet(T, cases) for result in results: print(result)"},{"question":"def describe_even_indices(numbers: List[int]) -> List[str]: Write a function that takes a list of integers as input and returns a list of strings. Each string should describe the integers at even indices in the format: \\"Number <number> at index <index> is even/odd\\". Replace <number> with the actual number and <index> with the actual index. The description should indicate if the number at that index is even or odd. Indices start from 0. >>> describe_even_indices([10, 15, 20, 25, 30]) [\\"Number 10 at index 0 is even\\", \\"Number 20 at index 2 is even\\", \\"Number 30 at index 4 is even\\"] >>> describe_even_indices([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [\\"Number 1 at index 0 is odd\\", \\"Number 3 at index 2 is odd\\", \\"Number 5 at index 4 is odd\\", \\"Number 7 at index 6 is odd\\", \\"Number 9 at index 8 is odd\\"] >>> describe_even_indices([12, 14]) [\\"Number 12 at index 0 is even\\"] >>> describe_even_indices([17]) [\\"Number 17 at index 0 is odd\\"]","solution":"def describe_even_indices(numbers): Returns a list of descriptions for numbers at even indices. :param numbers: List of integers :return: List of strings describing the numbers at even indices descriptions = [] for index, number in enumerate(numbers): if index % 2 == 0: parity = 'even' if number % 2 == 0 else 'odd' descriptions.append(f\\"Number {number} at index {index} is {parity}\\") return descriptions"},{"question":"from typing import List def longest_consecutive_sequence(nums: List[int]) -> int: Find the length of the longest consecutive elements sequence. The sequence must be strictly increasing by 1 unit. Duplicates in the array should be ignored in forming the sequence. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) 9 >>> longest_consecutive_sequence([9, 1, 4, 7, 3, -1, 0, 5, 8, -1, 6]) 7 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([1]) 1 >>> longest_consecutive_sequence([1, 1, 1, 1]) 1 >>> longest_consecutive_sequence([10, 30, 25, 20, 15]) 1 >>> longest_consecutive_sequence([-2, -3, -1, 1, 0, 2]) 6","solution":"from typing import List def longest_consecutive_sequence(nums: List[int]) -> int: if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def find_kth_smallest(nums1: List[int], nums2: List[int], k: int) -> int: Given two sorted integer arrays nums1 and nums2, and an integer k, return the kth smallest element of the combined sorted array. The input arrays might contain duplicate elements. Your algorithm should have a time complexity better than O(m + n), where m and n are the lengths of nums1 and nums2 respectively. >>> find_kth_smallest([1, 3, 8], [2, 7, 10], 5) 8 >>> find_kth_smallest([2, 3, 6, 7, 9], [1, 4, 8, 10], 7) 8 >>> find_kth_smallest([1, 2], [3, 4], 3) 3 >>> find_kth_smallest([1, 2], [3, 4], 2) 2 >>> find_kth_smallest([], [1], 1) 1","solution":"def find_kth_smallest(nums1, nums2, k): Returns the kth smallest element of the combined sorted array made from nums1 and nums2. Uses a binary search method to achieve a better time complexity than O(m + n). def kth_smallest(a, b, k): if len(a) > len(b): a, b = b, a if not a: return b[k - 1] if k == 1: return min(a[0], b[0]) i = min(len(a), k // 2) j = min(len(b), k // 2) if a[i - 1] > b[j - 1]: return kth_smallest(a, b[j:], k - j) else: return kth_smallest(a[i:], b, k - i) return kth_smallest(nums1, nums2, k)"},{"question":"import heapq from typing import List def kth_largest_element(n: int, k: int, arr: List[int]) -> int: Returns the k-th largest element in the sorted order of the array. >>> kth_largest_element(5, 2, [3, 2, 1, 5, 6]) 5 >>> kth_largest_element(6, 3, [8, 5, 7, 6, 9, 2]) 7 >>> kth_largest_element(4, 4, [1, 2, 3, 4]) 1","solution":"import heapq def kth_largest_element(n, k, arr): Returns the k-th largest element in the sorted order of the array. Uses a min heap of size k to find the k-th largest element. # Maintain a min-heap of size k min_heap = arr[:k] heapq.heapify(min_heap) for num in arr[k:]: if num > min_heap[0]: heapq.heappushpop(min_heap, num) return min_heap[0]"},{"question":"def max_consecutive_bears(n: int, m: int, queries: List[Tuple[int, int, int]]) -> List[int]: Mike is organizing another game with his bear friends. This time, the bears are standing in an n × m grid with exactly one bear in each cell. Each bear can be holding a flag that is either red or blue. Mike wants to know the maximum number of consecutive bears holding the same color flag in any row or column after each update. Each update involves placing a bear with a specific colored flag in an empty cell. If a bear is already present in the cell, the update will change its flag color. :param n: number of rows in the grid :param m: number of columns in the grid :param queries: list of updates where each update is a tuple (i, j, c) representing the bear's position (i, j) in the grid and the flag color to be placed in that position (0 for red, 1 for blue) :return: a list of maximum consecutive bears holding the same color flag in any row or column after each update >>> n, m, q = 5, 4, 5 >>> queries = [(1, 1, 0), (2, 2, 1), (1, 2, 0), (3, 1, 1), (4, 4, 1)] >>> max_consecutive_bears(n, m, queries) [1, 1, 2, 1, 1] pass from typing import List, Tuple def test_single_update(): n, m, q = 2, 2, 1 queries = [(1, 1, 0)] assert max_consecutive_bears(n, m, queries) == [1] def test_multiple_updates_same_row(): n, m, q = 3, 3, 2 queries = [(1, 1, 0), (1, 2, 0)] assert max_consecutive_bears(n, m, queries) == [1, 2] def test_multiple_updates_same_column(): n, m, q = 3, 3, 2 queries = [(1, 1, 0), (2, 1, 0)] assert max_consecutive_bears(n, m, queries) == [1, 2] def test_mixed_updates(): n, m, q = 3, 4, 5 queries = [(1, 1, 0), (2, 2, 1), (1, 2, 0), (3, 1, 1), (3, 4, 1)] assert max_consecutive_bears(n, m, queries) == [1, 1, 2, 1, 1] def test_no_consecutive_increase(): n, m, q = 3, 3, 3 queries = [(1, 1, 0), (2, 2, 0), (3, 3, 0)] assert max_consecutive_bears(n, m, queries) == [1, 1, 1] def test_complex_case(): n, m, q = 5, 4, 5 queries = [(1, 1, 0), (2, 2, 1), (1, 2, 0), (3, 1, 1), (4, 4, 1)] assert max_consecutive_bears(n, m, queries) == [1, 1, 2, 1, 1]","solution":"def max_consecutive_bears(n, m, queries): grid = [[-1] * m for _ in range(n)] def max_consecutive_count(arr): max_count = 0 current_count = 1 for k in range(1, len(arr)): if arr[k] == arr[k - 1] and arr[k] != -1: current_count += 1 else: current_count = 1 max_count = max(max_count, current_count) return max_count max_consecutive = 0 results = [] for query in queries: i, j, c = query grid[i - 1][j - 1] = c row_count = max_consecutive_count(grid[i - 1]) col_count = max_consecutive_count([grid[k][j - 1] for k in range(n)]) max_consecutive = max(row_count, col_count) results.append(max_consecutive) return results # Example usage: # n, m, q = 5, 4, 5 # queries = [(1, 1, 0), (2, 2, 1), (1, 2, 0), (3, 1, 1), (4, 4, 1)] # print(max_consecutive_bears(n, m, queries)) # Output should be [1, 1, 2, 1, 1]"},{"question":"def can_be_sorted_by_reversing_subsegment(n: int, arr: List[int]) -> str: Return \\"YES\\" if there exists at least one subsegment in the array such that reversing that subsegment will result in the entire array being sorted in non-decreasing order. Otherwise, return \\"NO\\". >>> can_be_sorted_by_reversing_subsegment(5, [1, 3, 5, 4, 6]) \\"YES\\" >>> can_be_sorted_by_reversing_subsegment(5, [1, 5, 3, 4, 6]) \\"NO\\"","solution":"def can_be_sorted_by_reversing_subsegment(n, arr): Return \\"YES\\" if there exists at least one subsegment in the array such that reversing that subsegment will result in the entire array being sorted in non-decreasing order. Otherwise, return \\"NO\\". # Check if array is already sorted if arr == sorted(arr): return \\"YES\\" # Identifying the first out-of-order segment. start = 0 while start < n - 1 and arr[start] <= arr[start + 1]: start += 1 # If the whole array is already sorted, we return YES if start == n - 1: return \\"YES\\" # Identify the end of the out-of-order segment end = start while end < n - 1 and arr[end] > arr[end + 1]: end += 1 # Reverse the out-of-order segment to_reverse = arr[start:end + 1] to_reverse.reverse() # Resulting array after reversing the identified segment new_arr = arr[:start] + to_reverse + arr[end + 1:] # Check if the resulting array is sorted if new_arr == sorted(arr): return \\"YES\\" else: return \\"NO\\""},{"question":"def unique_paths_with_obstacles(grid): Calculate the number of unique paths from the top-left to the bottom-right corner of a grid with obstacles. The drone can only move right or down. Args: grid (List[List[int]]): 2D list with 0 representing an unblocked cell and 1 representing a blocked cell. Returns: int: The number of unique paths from start to finish avoiding obstacles. Example: >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> unique_paths_with_obstacles([ ... [0, 1], ... [0, 0] ... ]) 1","solution":"def unique_paths_with_obstacles(grid): Calculate the number of unique paths from the top-left to the bottom-right corner of a grid with obstacles. if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Start position for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 # If it's a blocked cell else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def maximize_sum_of_elements(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a sequence of N integers, in each operation, you can choose any two consecutive elements of the sequence and replace them with their sum. This operation reduces the length of the sequence by one. Your goal is to maximize the sum of the final single element after performing N-1 operations. Args: T : int : The number of test cases test_cases : List[Tuple[int, List[int]]] : List of test cases, where each test case consists of an integer N and a list of N integers. Returns: List[int] : List of integers representing the maximum sum of the final single element for each test case. Examples: >>> maximize_sum_of_elements(2, [(3, [1, 2, 3]), (4, [1, 2, 3, 4])]) [6, 10] >>> maximize_sum_of_elements(1, [(5, [1, 2, 3, 4, 5])]) [15] pass from typing import List, Tuple def test_case_1(): T = 2 test_cases = [(3, [1, 2, 3]), (4, [1, 2, 3, 4])] assert maximize_sum_of_elements(T, test_cases) == [6, 10] def test_case_2(): T = 1 test_cases = [(5, [1, 2, 3, 4, 5])] assert maximize_sum_of_elements(T, test_cases) == [15] def test_case_3(): T = 1 test_cases = [(2, [10, 20])] assert maximize_sum_of_elements(T, test_cases) == [30] def test_case_4(): T = 3 test_cases = [(3, [1, 3, 5]), (2, [7, 8]), (6, [1, 1, 1, 1, 1, 1])] assert maximize_sum_of_elements(T, test_cases) == [9, 15, 6] def test_case_5(): T = 1 test_cases = [(3, [10, 15, 25])] assert maximize_sum_of_elements(T, test_cases) == [50]","solution":"def maximize_sum_of_elements(T, test_cases): results = [] for i in range(T): # For each test case N, a = test_cases[i] # The strategy to maximize the sum is to sum all elements because any sum operation maximizes # when we keep adding the largest possible intermediate sums. total_sum = sum(a) results.append(total_sum) return results"},{"question":"def subsets(nums): Given an integer array nums, return all possible unique subsets (the power set) of the array. The solution set must not contain duplicate subsets. Return the solution in any order. Example: >>> subsets([1, 2, 3]) [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] >>> subsets([0]) [[], [0]]","solution":"def subsets(nums): Given a list of integers nums, returns all possible unique subsets (the power set). result = [] def backtrack(start, path): result.append(path[:]) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() backtrack(0, []) return result"},{"question":"def find_largest_group_size(n: int, friendships: List[Tuple[int, int]]) -> int: Returns the size of the largest group of direct or indirect friends. >>> find_largest_group_size(5, [(1, 2), (1, 3), (4, 5)]) 3 >>> find_largest_group_size(4, [(1, 2), (3, 4)]) 2 def process_test_cases(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Processes multiple test cases and returns a list of results. >>> process_test_cases(2, [(5, 3, [(1, 2), (1, 3), (4, 5)]), (4, 2, [(1, 2), (3, 4)])]) [3, 2] # Test cases def test_find_largest_group_size(): assert find_largest_group_size(5, [(1, 2), (1, 3), (4, 5)]) == 3 assert find_largest_group_size(4, [(1, 2), (3, 4)]) == 2 assert find_largest_group_size(6, [(1, 2), (2, 3), (4, 5)]) == 3 assert find_largest_group_size(1, []) == 1 assert find_largest_group_size(3, []) == 1 def test_process_test_cases(): test_cases = [ (5, 3, [(1, 2), (1, 3), (4, 5)]), (4, 2, [(1, 2), (3, 4)]) ] results = process_test_cases(2, test_cases) assert results == [3, 2] test_cases = [ (3, 2, [(1, 2), (2, 3)]), (6, 3, [(1, 2), (3, 4), (4, 5)]) ] results = process_test_cases(2, test_cases) assert results == [3, 3] test_cases = [ (4, 0, []), (1, 0, []) ] results = process_test_cases(2, test_cases) assert results == [1, 1]","solution":"def find_largest_group_size(n, friendships): Returns the size of the largest group of direct or indirect friends. from collections import defaultdict def dfs(node, visited, adj_list): stack = [node] count = 0 while stack: current = stack.pop() if not visited[current]: visited[current] = True count += 1 for neighbor in adj_list[current]: if not visited[neighbor]: stack.append(neighbor) return count adj_list = defaultdict(list) for a, b in friendships: adj_list[a].append(b) adj_list[b].append(a) visited = [False] * (n + 1) largest_group = 0 for person in range(1, n + 1): if not visited[person]: group_size = dfs(person, visited, adj_list) largest_group = max(largest_group, group_size) return largest_group def process_test_cases(t, test_cases): results = [] for n, m, friendships in test_cases: results.append(find_largest_group_size(n, friendships)) return results"},{"question":"def minRemovals(scores, threshold): Determine the minimum number of elements that need to be removed so that the difference between the maximum and minimum remaining scores is less than or equal to a given threshold. >>> minRemovals([1, 5, 8, 2, 10], 5) 2 >>> minRemovals([10, 20, 30, 40, 50], 5) 4 pass from solution import minRemovals def test_example(): assert minRemovals([1, 5, 8, 2, 10], 5) == 2 def test_all_elements_below_threshold(): assert minRemovals([1, 2, 3, 4, 5], 10) == 0 def test_all_elements_need_removal(): assert minRemovals([10, 20, 30, 40, 50], 5) == 4 def test_empty_scores(): assert minRemovals([], 5) == 0 def test_single_element(): assert minRemovals([10], 5) == 0 def test_multiple_elements_with_no_removal(): assert minRemovals([1, 2, 4, 6, 8], 10) == 0 def test_exact_threshold(): assert minRemovals([1, 5, 8, 2, 10], 7) == 1","solution":"def minRemovals(scores, threshold): scores.sort() n = len(scores) left = 0 min_removal = n for right in range(n): while scores[right] - scores[left] > threshold: left += 1 min_removal = min(min_removal, left + (n - 1 - right)) return min_removal"},{"question":"def find_zero_sum_subarray(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[Union[Tuple[int, int], str]]: Determine if there exists a non-empty subarray whose sum is zero. For each test case, output the 1-based starting and ending indices of such a subarray, or \\"NO\\" if none exists. >>> find_zero_sum_subarray(2, [(5, [1, 2, -3, 4, 5]), (4, [1, 2, 3, 4])]) [(1, 3), \\"NO\\"] >>> find_zero_sum_subarray(1, [(6, [10**9, -10**9, 1, 2, 3, 4])]) [(1, 2)] def process_input(input_data: str) -> Tuple[int, List[Tuple[int, List[int]]]]: Process the input data to extract the number of test cases and the list of test cases. >>> process_input(\\"2n5n1 2 -3 4 5n4n1 2 3 4n\\") (2, [(5, [1, 2, -3, 4, 5]), (4, [1, 2, 3, 4])])","solution":"def find_zero_sum_subarray(T, test_cases): results = [] for i in range(T): n, arr = test_cases[i] prefix_sum = {} current_sum = 0 for index in range(n): current_sum += arr[index] if current_sum == 0: results.append((1, index + 1)) break if current_sum in prefix_sum: results.append((prefix_sum[current_sum] + 2, index + 1)) break prefix_sum[current_sum] = index else: results.append(\\"NO\\") return results def process_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) arr = list(map(int, lines[index + 1].split())) test_cases.append((N, arr)) index += 2 return T, test_cases"}]`),E={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},D={class:"search-container"},P={class:"card-container"},z={key:0,class:"empty-state"},j=["disabled"],I={key:0},C={key:1};function F(i,e,u,_,r,a){const f=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",D,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):l("",!0)]),t("div",P,[(s(!0),n(y,null,x(a.displayedPoems,(o,p)=>(s(),w(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",z,' No results found for "'+d(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),n("span",C,"Loading...")):(s(),n("span",I,"See more"))],8,j)):l("",!0)])}const O=c(E,[["render",F],["__scopeId","data-v-e5de155f"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/35.md","filePath":"guide/35.md"}'),M={name:"guide/35.md"},W=Object.assign(M,{setup(i){return(e,u)=>(s(),n("div",null,[v(O)]))}});export{B as __pageData,W as default};
